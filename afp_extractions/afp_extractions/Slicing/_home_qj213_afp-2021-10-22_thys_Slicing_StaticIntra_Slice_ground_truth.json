{"file_name": "/home/qj213/afp-2021-10-22/thys/Slicing/StaticIntra/Slice.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Slicing", "problem_names": ["lemma slice_n_in_obs:\n  \"n \\<in> backward_slice S \\<Longrightarrow> obs n (backward_slice S) = {n}\"", "lemma obs_singleton_disj: \n  \"(\\<exists>m. obs n (backward_slice S) = {m}) \\<or> obs n (backward_slice S) = {}\"", "lemma obs_singleton_element:\n  assumes \"m \\<in> obs n (backward_slice S)\" shows \"obs n (backward_slice S) = {m}\"", "lemma obs_the_element: \n  \"m \\<in> obs n (backward_slice S) \\<Longrightarrow> (THE m. m \\<in> obs n (backward_slice S)) = m\"", "lemma slice_kind_in_slice:\n  \"sourcenode a \\<in> backward_slice S \\<Longrightarrow> slice_kind S a = kind a\"", "lemma slice_kind_Upd:\n  \"\\<lbrakk>sourcenode a \\<notin> backward_slice S; kind a = \\<Up>f\\<rbrakk> \\<Longrightarrow> slice_kind S a = \\<Up>id\"", "lemma slice_kind_Pred_empty_obs_SOME:\n  \"\\<lbrakk>sourcenode a \\<notin> backward_slice S; kind a = (Q)\\<^sub>\\<surd>; \n    obs (sourcenode a) (backward_slice S) = {}; \n    targetnode a = (SOME n'. \\<exists>a'. sourcenode a = sourcenode a' \\<and> valid_edge a' \\<and>\n                                  targetnode a' = n')\\<rbrakk>\n  \\<Longrightarrow> slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\"", "lemma slice_kind_Pred_empty_obs_not_SOME:\n  \"\\<lbrakk>sourcenode a \\<notin> backward_slice S; kind a = (Q)\\<^sub>\\<surd>; \n    obs (sourcenode a) (backward_slice S) = {}; \n    targetnode a \\<noteq> (SOME n'. \\<exists>a'. sourcenode a = sourcenode a' \\<and> valid_edge a' \\<and>\n                                  targetnode a' = n')\\<rbrakk>\n  \\<Longrightarrow> slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>\"", "lemma slice_kind_Pred_obs_nearer_SOME:\n  assumes \"sourcenode a \\<notin> backward_slice S\" and \"kind a = (Q)\\<^sub>\\<surd>\" \n  and \"m \\<in> obs (sourcenode a) (backward_slice S)\"\n  and \"distance (targetnode a) m x\" \"distance (sourcenode a) m (x + 1)\"\n  and \"targetnode a = (SOME n'. \\<exists>a'. sourcenode a = sourcenode a' \\<and>\n                                          distance (targetnode a') m x \\<and>\n                                          valid_edge a' \\<and> targetnode a' = n')\"\n  shows \"slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\"", "lemma slice_kind_Pred_obs_nearer_not_SOME:\n  assumes \"sourcenode a \\<notin> backward_slice S\" and \"kind a = (Q)\\<^sub>\\<surd>\" \n  and \"m \\<in> obs (sourcenode a) (backward_slice S)\"\n  and \"distance (targetnode a) m x\" \"distance (sourcenode a) m (x + 1)\"\n  and \"targetnode a \\<noteq> (SOME nx'. \\<exists>a'. sourcenode a = sourcenode a' \\<and> \n                                          distance (targetnode a') m x \\<and>\n                                          valid_edge a' \\<and> targetnode a' = nx')\"\n  shows \"slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>\"", "lemma slice_kind_Pred_obs_not_nearer:\n  assumes \"sourcenode a \\<notin> backward_slice S\" and \"kind a = (Q)\\<^sub>\\<surd>\" \n  and in_obs:\"m \\<in> obs (sourcenode a) (backward_slice S)\"\n  and dist:\"distance (sourcenode a) m (x + 1)\" \n           \"\\<not> distance (targetnode a) m x\"\n  shows \"slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>\"", "lemma kind_Predicate_notin_slice_slice_kind_Predicate:\n  assumes \"kind a = (Q)\\<^sub>\\<surd>\" and \"sourcenode a \\<notin> backward_slice S\"\n  obtains Q' where \"slice_kind S a = (Q')\\<^sub>\\<surd>\" and \"Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True)\"", "lemma only_one_SOME_edge:\n  assumes \"valid_edge a\"\n  shows \"\\<exists>!a'. sourcenode a = sourcenode a' \\<and> valid_edge a' \\<and>\n               targetnode a' = (SOME n'. \\<exists>a'. sourcenode a = sourcenode a' \\<and> \n                                              valid_edge a' \\<and> targetnode a' = n')\"", "lemma slice_kind_only_one_True_edge:\n  assumes \"sourcenode a = sourcenode a'\" and \"targetnode a \\<noteq> targetnode a'\" \n  and \"valid_edge a\" and \"valid_edge a'\" and \"slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\"\n  shows \"slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>\"", "lemma slice_deterministic:\n  assumes \"valid_edge a\" and \"valid_edge a'\"\n  and \"sourcenode a = sourcenode a'\" and \"targetnode a \\<noteq> targetnode a'\"\n  obtains Q Q' where \"slice_kind S a = (Q)\\<^sub>\\<surd>\" and \"slice_kind S a' = (Q')\\<^sub>\\<surd>\"\n  and \"\\<forall>s. (Q s \\<longrightarrow> \\<not> Q' s) \\<and> (Q' s \\<longrightarrow> \\<not> Q s)\"", "lemma silent_moves_obs_slice:\n  \"\\<lbrakk>S,f \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s'); nx \\<in> obs n' (backward_slice S)\\<rbrakk>\n  \\<Longrightarrow> nx \\<in> obs n (backward_slice S)\"", "lemma silent_moves_preds_transfers_path:\n  \"\\<lbrakk>S,f \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s'); valid_node n\\<rbrakk> \n  \\<Longrightarrow> preds (map f as) s \\<and> transfers (map f as) s = s' \\<and> n -as\\<rightarrow>* n'\"", "lemma obs_silent_moves:\n  assumes \"obs n (backward_slice S) = {n'}\"\n  obtains as where \"S,slice_kind S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s)\"", "lemma observable_move_notempty:\n  \"\\<lbrakk>S,f \\<turnstile> (n,s) =as\\<Rightarrow> (n',s'); as = []\\<rbrakk> \\<Longrightarrow> False\"", "lemma silent_move_observable_moves:\n  \"\\<lbrakk>S,f \\<turnstile> (n'',s'') =as\\<Rightarrow> (n',s'); S,f \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n'',s'')\\<rbrakk>\n  \\<Longrightarrow> S,f \\<turnstile> (n,s) =a#as\\<Rightarrow> (n',s')\"", "lemma observable_moves_preds_transfers_path:\n  \"S,f \\<turnstile> (n,s) =as\\<Rightarrow> (n',s')\n  \\<Longrightarrow> preds (map f as) s \\<and> transfers (map f as) s = s' \\<and> n -as\\<rightarrow>* n'\"", "lemma rvE:\n  assumes rv:\"V \\<in> rv S n\"\n  obtains as n' where \"n -as\\<rightarrow>* n'\" and \"n' \\<in> backward_slice S\" and \"V \\<in> Use n'\"\n  and \"\\<forall>nx \\<in> set(sourcenodes as). V \\<notin> Def nx\"", "lemma eq_obs_in_rv:\n  assumes obs_eq:\"obs n (backward_slice S) = obs n' (backward_slice S)\" \n  and \"x \\<in> rv S n\" shows \"x \\<in> rv S n'\"", "lemma closed_eq_obs_eq_rvs:\n  fixes S :: \"'node set\"\n  assumes \"valid_node n\" and \"valid_node n'\"\n  and obs_eq:\"obs n (backward_slice S) = obs n' (backward_slice S)\"\n  shows \"rv S n = rv S n'\"", "lemma rv_edge_slice_kinds:\n  assumes \"valid_edge a\" and \"sourcenode a = n\" and \"targetnode a = n''\"\n  and \"\\<forall>V\\<in>rv S n. state_val s V = state_val s' V\"\n  and \"preds (slice_kinds S (a#as)) s\" and \"preds (slice_kinds S (a#asx)) s'\"\n  shows \"\\<forall>V\\<in>rv S n''. state_val (transfer (slice_kind S a) s) V =\n                       state_val (transfer (slice_kind S a) s') V\"", "lemma rv_branching_edges_slice_kinds_False:\n  assumes \"valid_edge a\" and \"valid_edge ax\" \n  and \"sourcenode a = n\" and \"sourcenode ax = n\"\n  and \"targetnode a = n''\" and \"targetnode ax \\<noteq> n''\"\n  and \"preds (slice_kinds S (a#as)) s\" and \"preds (slice_kinds S (ax#asx)) s'\"\n  and \"\\<forall>V\\<in>rv S n. state_val s V = state_val s' V\"\n  shows False", "lemma WSD:\n  \"((n,s),(n',s')) \\<in> WS S \n  \\<Longrightarrow> obs n (backward_slice S) = obs n' (backward_slice S) \\<and> \n      (\\<forall>V \\<in> rv S n. state_val s V = state_val s' V) \\<and>\n      valid_node n \\<and> valid_node n'\"", "lemma WS_silent_move:\n  assumes \"((n\\<^sub>1,s\\<^sub>1),(n\\<^sub>2,s\\<^sub>2)) \\<in> WS S\" and \"S,kind \\<turnstile> (n\\<^sub>1,s\\<^sub>1) -a\\<rightarrow>\\<^sub>\\<tau> (n\\<^sub>1',s\\<^sub>1')\"\n  and \"obs n\\<^sub>1' (backward_slice S) \\<noteq> {}\" shows \"((n\\<^sub>1',s\\<^sub>1'),(n\\<^sub>2,s\\<^sub>2)) \\<in> WS S\"", "lemma WS_silent_moves:\n  \"\\<lbrakk>S,f \\<turnstile> (n\\<^sub>1,s\\<^sub>1) =as\\<Rightarrow>\\<^sub>\\<tau> (n\\<^sub>1',s\\<^sub>1'); ((n\\<^sub>1,s\\<^sub>1),(n\\<^sub>2,s\\<^sub>2)) \\<in> WS S; f = kind;\n    obs n\\<^sub>1' (backward_slice S) \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> ((n\\<^sub>1',s\\<^sub>1'),(n\\<^sub>2,s\\<^sub>2)) \\<in> WS S\"", "lemma WS_observable_move:\n  assumes \"((n\\<^sub>1,s\\<^sub>1),(n\\<^sub>2,s\\<^sub>2)) \\<in> WS S\" and \"S,kind \\<turnstile> (n\\<^sub>1,s\\<^sub>1) -a\\<rightarrow> (n\\<^sub>1',s\\<^sub>1')\"\n  obtains as where \"((n\\<^sub>1',s\\<^sub>1'),(n\\<^sub>1',transfer (slice_kind S a) s\\<^sub>2)) \\<in> WS S\"\n  and \"S,slice_kind S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =as@[a]\\<Rightarrow> (n\\<^sub>1',transfer (slice_kind S a) s\\<^sub>2)\"", "lemma WS_weak_sim:\n  assumes \"((n\\<^sub>1,s\\<^sub>1),(n\\<^sub>2,s\\<^sub>2)) \\<in> WS S\" \n  and \"S,kind \\<turnstile> (n\\<^sub>1,s\\<^sub>1) =as\\<Rightarrow> (n\\<^sub>1',s\\<^sub>1')\"\n  shows \"((n\\<^sub>1',s\\<^sub>1'),(n\\<^sub>1',transfer (slice_kind S (last as)) s\\<^sub>2)) \\<in> WS S \\<and>\n  (\\<exists>as'. S,slice_kind S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =as'@[last as]\\<Rightarrow> \n                             (n\\<^sub>1',transfer (slice_kind S (last as)) s\\<^sub>2))\"", "theorem WS_is_weak_sim:\"is_weak_sim (WS S) S\"", "lemma silent_moves_no_slice_edges:\n  \"S,f \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<Longrightarrow> slice_edges S as = []\"", "lemma observable_moves_last_slice_edges:\n  \"S,f \\<turnstile> (n,s) =as\\<Rightarrow> (n',s') \\<Longrightarrow> slice_edges S as = [last as]\"", "lemma slice_edges_no_nodes_in_slice:\n  \"slice_edges S as = [] \n  \\<Longrightarrow> \\<forall>nx \\<in> set(sourcenodes as). nx \\<notin> (backward_slice S)\"", "lemma sliced_path_determ:\n  \"\\<lbrakk>n -as\\<rightarrow>* n'; n -as'\\<rightarrow>* n'; slice_edges S as = slice_edges S as';\n    preds (slice_kinds S as) s; preds (slice_kinds S as') s'; n' \\<in> S;\n    \\<forall>V \\<in> rv S n. state_val s V = state_val s' V\\<rbrakk> \\<Longrightarrow> as = as'\"", "lemma path_trans_observable_moves:\n  assumes \"n -as\\<rightarrow>* n'\" and \"preds (kinds as) s\" and \"transfers (kinds as) s = s'\"\n  obtains n'' s'' as' as'' where \"S,kind \\<turnstile> (n,s) =slice_edges S as\\<Rightarrow>* (n'',s'')\"\n  and \"S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s')\" \n  and \"slice_edges S as = slice_edges S as''\" and \"n -as''@as'\\<rightarrow>* n'\"", "lemma WS_weak_sim_trans:\n  assumes \"((n\\<^sub>1,s\\<^sub>1),(n\\<^sub>2,s\\<^sub>2)) \\<in> WS S\"\n  and \"S,kind \\<turnstile> (n\\<^sub>1,s\\<^sub>1) =as\\<Rightarrow>* (n\\<^sub>1',s\\<^sub>1')\" and \"as \\<noteq> []\"\n  shows \"((n\\<^sub>1',s\\<^sub>1'),(n\\<^sub>1',transfers (slice_kinds S as) s\\<^sub>2)) \\<in> WS S \\<and> \n         S,slice_kind S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>* (n\\<^sub>1',transfers (slice_kinds S as) s\\<^sub>2)\"", "lemma transfers_slice_kinds_slice_edges:\n  \"transfers (slice_kinds S (slice_edges S as)) s = transfers (slice_kinds S as) s\"", "lemma trans_observable_moves_preds:\n  assumes \"S,f \\<turnstile> (n,s) =as\\<Rightarrow>* (n',s')\" and \"valid_node n\"\n  obtains as' where \"preds (map f as') s\" and \"slice_edges S as' = as\"\n  and \"n -as'\\<rightarrow>* n'\"", "lemma exists_sliced_path_preds:\n  assumes \"n -as\\<rightarrow>* n'\" and \"slice_edges S as = []\" and \"n' \\<in> backward_slice S\"\n  obtains as' where \"n -as'\\<rightarrow>* n'\" and \"preds (slice_kinds S as') s\"\n  and \"slice_edges S as' = []\"", "theorem fundamental_property_of_static_slicing:\n  assumes path:\"n -as\\<rightarrow>* n'\" and preds:\"preds (kinds as) s\" and \"n' \\<in> S\"\n  obtains as' where \"preds (slice_kinds S as') s\"\n  and \"(\\<forall>V \\<in> Use n'. state_val (transfers (slice_kinds S as') s) V = \n                     state_val (transfers (kinds as) s) V)\"\n  and \"slice_edges S as = slice_edges S as'\" and \"n -as'\\<rightarrow>* n'\"", "theorem fundamental_property_of_path_slicing_semantically:\n  assumes \"n \\<triangleq> c\" and \"\\<langle>c,s\\<rangle> \\<Rightarrow> \\<langle>c',s'\\<rangle>\"\n  obtains n' as where \"n -as\\<rightarrow>* n'\" and \"preds (slice_kinds {n'} as) s\" and \"n' \\<triangleq> c'\"\n  and \"\\<forall>V \\<in> Use n'. state_val (transfers (slice_kinds {n'} as) s) V = state_val s' V\""], "translations": [["", "lemma slice_n_in_obs:\n  \"n \\<in> backward_slice S \\<Longrightarrow> obs n (backward_slice S) = {n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<in> backward_slice S \\<Longrightarrow>\n    obs n (backward_slice S) = {n}", "by(fastforce intro!:n_in_obs dest:valid_nodes)"], ["", "lemma obs_singleton_disj: \n  \"(\\<exists>m. obs n (backward_slice S) = {m}) \\<or> obs n (backward_slice S) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>m. obs n (backward_slice S) = {m}) \\<or>\n    obs n (backward_slice S) = {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<exists>m. obs n (backward_slice S) = {m}) \\<or>\n    obs n (backward_slice S) = {}", "have \"finite(obs n (backward_slice S))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (obs n (backward_slice S))", "by(rule obs_finite)"], ["proof (state)\nthis:\n  finite (obs n (backward_slice S))\n\ngoal (1 subgoal):\n 1. (\\<exists>m. obs n (backward_slice S) = {m}) \\<or>\n    obs n (backward_slice S) = {}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>m. obs n (backward_slice S) = {m}) \\<or>\n    obs n (backward_slice S) = {}", "proof(cases \"card(obs n (backward_slice S)) = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. card (obs n (backward_slice S)) = 0 \\<Longrightarrow>\n    (\\<exists>m. obs n (backward_slice S) = {m}) \\<or>\n    obs n (backward_slice S) = {}\n 2. card (obs n (backward_slice S)) \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>m. obs n (backward_slice S) = {m}) \\<or>\n    obs n (backward_slice S) = {}", "case True"], ["proof (state)\nthis:\n  card (obs n (backward_slice S)) = 0\n\ngoal (2 subgoals):\n 1. card (obs n (backward_slice S)) = 0 \\<Longrightarrow>\n    (\\<exists>m. obs n (backward_slice S) = {m}) \\<or>\n    obs n (backward_slice S) = {}\n 2. card (obs n (backward_slice S)) \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>m. obs n (backward_slice S) = {m}) \\<or>\n    obs n (backward_slice S) = {}", "with \\<open>finite(obs n (backward_slice S))\\<close>"], ["proof (chain)\npicking this:\n  finite (obs n (backward_slice S))\n  card (obs n (backward_slice S)) = 0", "have \"obs n (backward_slice S) = {}\""], ["proof (prove)\nusing this:\n  finite (obs n (backward_slice S))\n  card (obs n (backward_slice S)) = 0\n\ngoal (1 subgoal):\n 1. obs n (backward_slice S) = {}", "by simp"], ["proof (state)\nthis:\n  obs n (backward_slice S) = {}\n\ngoal (2 subgoals):\n 1. card (obs n (backward_slice S)) = 0 \\<Longrightarrow>\n    (\\<exists>m. obs n (backward_slice S) = {m}) \\<or>\n    obs n (backward_slice S) = {}\n 2. card (obs n (backward_slice S)) \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>m. obs n (backward_slice S) = {m}) \\<or>\n    obs n (backward_slice S) = {}", "thus ?thesis"], ["proof (prove)\nusing this:\n  obs n (backward_slice S) = {}\n\ngoal (1 subgoal):\n 1. (\\<exists>m. obs n (backward_slice S) = {m}) \\<or>\n    obs n (backward_slice S) = {}", "by simp"], ["proof (state)\nthis:\n  (\\<exists>m. obs n (backward_slice S) = {m}) \\<or>\n  obs n (backward_slice S) = {}\n\ngoal (1 subgoal):\n 1. card (obs n (backward_slice S)) \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>m. obs n (backward_slice S) = {m}) \\<or>\n    obs n (backward_slice S) = {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. card (obs n (backward_slice S)) \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>m. obs n (backward_slice S) = {m}) \\<or>\n    obs n (backward_slice S) = {}", "case False"], ["proof (state)\nthis:\n  card (obs n (backward_slice S)) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. card (obs n (backward_slice S)) \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>m. obs n (backward_slice S) = {m}) \\<or>\n    obs n (backward_slice S) = {}", "have \"card(obs n (backward_slice S)) \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (obs n (backward_slice S)) \\<le> 1", "by(rule obs_singleton)"], ["proof (state)\nthis:\n  card (obs n (backward_slice S)) \\<le> 1\n\ngoal (1 subgoal):\n 1. card (obs n (backward_slice S)) \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>m. obs n (backward_slice S) = {m}) \\<or>\n    obs n (backward_slice S) = {}", "with False"], ["proof (chain)\npicking this:\n  card (obs n (backward_slice S)) \\<noteq> 0\n  card (obs n (backward_slice S)) \\<le> 1", "have \"card(obs n (backward_slice S)) = 1\""], ["proof (prove)\nusing this:\n  card (obs n (backward_slice S)) \\<noteq> 0\n  card (obs n (backward_slice S)) \\<le> 1\n\ngoal (1 subgoal):\n 1. card (obs n (backward_slice S)) = 1", "by simp"], ["proof (state)\nthis:\n  card (obs n (backward_slice S)) = 1\n\ngoal (1 subgoal):\n 1. card (obs n (backward_slice S)) \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>m. obs n (backward_slice S) = {m}) \\<or>\n    obs n (backward_slice S) = {}", "hence \"\\<exists>m. obs n (backward_slice S) = {m}\""], ["proof (prove)\nusing this:\n  card (obs n (backward_slice S)) = 1\n\ngoal (1 subgoal):\n 1. \\<exists>m. obs n (backward_slice S) = {m}", "by(fastforce dest:card_eq_SucD)"], ["proof (state)\nthis:\n  \\<exists>m. obs n (backward_slice S) = {m}\n\ngoal (1 subgoal):\n 1. card (obs n (backward_slice S)) \\<noteq> 0 \\<Longrightarrow>\n    (\\<exists>m. obs n (backward_slice S) = {m}) \\<or>\n    obs n (backward_slice S) = {}", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>m. obs n (backward_slice S) = {m}\n\ngoal (1 subgoal):\n 1. (\\<exists>m. obs n (backward_slice S) = {m}) \\<or>\n    obs n (backward_slice S) = {}", "by simp"], ["proof (state)\nthis:\n  (\\<exists>m. obs n (backward_slice S) = {m}) \\<or>\n  obs n (backward_slice S) = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>m. obs n (backward_slice S) = {m}) \\<or>\n  obs n (backward_slice S) = {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma obs_singleton_element:\n  assumes \"m \\<in> obs n (backward_slice S)\" shows \"obs n (backward_slice S) = {m}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obs n (backward_slice S) = {m}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. obs n (backward_slice S) = {m}", "have \"(\\<exists>m. obs n (backward_slice S) = {m}) \\<or> obs n (backward_slice S) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>m. obs n (backward_slice S) = {m}) \\<or>\n    obs n (backward_slice S) = {}", "by(rule obs_singleton_disj)"], ["proof (state)\nthis:\n  (\\<exists>m. obs n (backward_slice S) = {m}) \\<or>\n  obs n (backward_slice S) = {}\n\ngoal (1 subgoal):\n 1. obs n (backward_slice S) = {m}", "with \\<open>m \\<in> obs n (backward_slice S)\\<close>"], ["proof (chain)\npicking this:\n  m \\<in> obs n (backward_slice S)\n  (\\<exists>m. obs n (backward_slice S) = {m}) \\<or>\n  obs n (backward_slice S) = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  m \\<in> obs n (backward_slice S)\n  (\\<exists>m. obs n (backward_slice S) = {m}) \\<or>\n  obs n (backward_slice S) = {}\n\ngoal (1 subgoal):\n 1. obs n (backward_slice S) = {m}", "by fastforce"], ["proof (state)\nthis:\n  obs n (backward_slice S) = {m}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma obs_the_element: \n  \"m \\<in> obs n (backward_slice S) \\<Longrightarrow> (THE m. m \\<in> obs n (backward_slice S)) = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<in> obs n (backward_slice S) \\<Longrightarrow>\n    (THE m. m \\<in> obs n (backward_slice S)) = m", "by(fastforce dest:obs_singleton_element)"], ["", "subsection \\<open>Traversing the sliced graph\\<close>"], ["", "text \\<open>\\<open>slice_kind S a\\<close> conforms to @{term \"kind a\"} in the\n  sliced graph\\<close>"], ["", "definition slice_kind :: \"'node set \\<Rightarrow> 'edge \\<Rightarrow> 'state edge_kind\"\n  where \"slice_kind S a = (let S' = backward_slice S; n = sourcenode a in \n  (if sourcenode a \\<in> S' then kind a\n   else (case kind a of \\<Up>f \\<Rightarrow> \\<Up>id | (Q)\\<^sub>\\<surd> \\<Rightarrow> \n    (if obs (sourcenode a) S' = {} then \n      (let nx = (SOME n'. \\<exists>a'. n = sourcenode a' \\<and> valid_edge a' \\<and> targetnode a' = n')\n      in (if (targetnode a = nx) then (\\<lambda>s. True)\\<^sub>\\<surd> else (\\<lambda>s. False)\\<^sub>\\<surd>))\n     else (let m = THE m. m \\<in> obs n S' in \n       (if (\\<exists>x. distance (targetnode a) m x \\<and> distance n m (x + 1) \\<and>\n            (targetnode a = (SOME nx'. \\<exists>a'. sourcenode a = sourcenode a' \\<and> \n                                     distance (targetnode a') m x \\<and>\n                                     valid_edge a' \\<and> targetnode a' = nx'))) \n          then (\\<lambda>s. True)\\<^sub>\\<surd> else (\\<lambda>s. False)\\<^sub>\\<surd>\n       ))\n     ))\n  ))\""], ["", "definition\n  slice_kinds :: \"'node set \\<Rightarrow> 'edge list \\<Rightarrow> 'state edge_kind list\"\n  where \"slice_kinds S as \\<equiv> map (slice_kind S) as\""], ["", "lemma slice_kind_in_slice:\n  \"sourcenode a \\<in> backward_slice S \\<Longrightarrow> slice_kind S a = kind a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sourcenode a \\<in> backward_slice S \\<Longrightarrow>\n    slice_kind S a = kind a", "by(simp add:slice_kind_def)"], ["", "lemma slice_kind_Upd:\n  \"\\<lbrakk>sourcenode a \\<notin> backward_slice S; kind a = \\<Up>f\\<rbrakk> \\<Longrightarrow> slice_kind S a = \\<Up>id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sourcenode a \\<notin> backward_slice S;\n     kind a = \\<Up>f\\<rbrakk>\n    \\<Longrightarrow> slice_kind S a = \\<Up>id", "by(simp add:slice_kind_def)"], ["", "lemma slice_kind_Pred_empty_obs_SOME:\n  \"\\<lbrakk>sourcenode a \\<notin> backward_slice S; kind a = (Q)\\<^sub>\\<surd>; \n    obs (sourcenode a) (backward_slice S) = {}; \n    targetnode a = (SOME n'. \\<exists>a'. sourcenode a = sourcenode a' \\<and> valid_edge a' \\<and>\n                                  targetnode a' = n')\\<rbrakk>\n  \\<Longrightarrow> slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sourcenode a \\<notin> backward_slice S;\n     kind a = (Q)\\<^sub>\\<surd>; obs (sourcenode a) (backward_slice S) = {};\n     targetnode a =\n     (SOME n'.\n         \\<exists>a'.\n            sourcenode a = sourcenode a' \\<and>\n            valid_edge a' \\<and> targetnode a' = n')\\<rbrakk>\n    \\<Longrightarrow> slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>", "by(simp add:slice_kind_def)"], ["", "lemma slice_kind_Pred_empty_obs_not_SOME:\n  \"\\<lbrakk>sourcenode a \\<notin> backward_slice S; kind a = (Q)\\<^sub>\\<surd>; \n    obs (sourcenode a) (backward_slice S) = {}; \n    targetnode a \\<noteq> (SOME n'. \\<exists>a'. sourcenode a = sourcenode a' \\<and> valid_edge a' \\<and>\n                                  targetnode a' = n')\\<rbrakk>\n  \\<Longrightarrow> slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sourcenode a \\<notin> backward_slice S;\n     kind a = (Q)\\<^sub>\\<surd>; obs (sourcenode a) (backward_slice S) = {};\n     targetnode a \\<noteq>\n     (SOME n'.\n         \\<exists>a'.\n            sourcenode a = sourcenode a' \\<and>\n            valid_edge a' \\<and> targetnode a' = n')\\<rbrakk>\n    \\<Longrightarrow> slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>", "by(simp add:slice_kind_def)"], ["", "lemma slice_kind_Pred_obs_nearer_SOME:\n  assumes \"sourcenode a \\<notin> backward_slice S\" and \"kind a = (Q)\\<^sub>\\<surd>\" \n  and \"m \\<in> obs (sourcenode a) (backward_slice S)\"\n  and \"distance (targetnode a) m x\" \"distance (sourcenode a) m (x + 1)\"\n  and \"targetnode a = (SOME n'. \\<exists>a'. sourcenode a = sourcenode a' \\<and>\n                                          distance (targetnode a') m x \\<and>\n                                          valid_edge a' \\<and> targetnode a' = n')\"\n  shows \"slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>", "from \\<open>m \\<in> obs (sourcenode a) (backward_slice S)\\<close>"], ["proof (chain)\npicking this:\n  m \\<in> obs (sourcenode a) (backward_slice S)", "have \"m = (THE m. m \\<in> obs (sourcenode a) (backward_slice S))\""], ["proof (prove)\nusing this:\n  m \\<in> obs (sourcenode a) (backward_slice S)\n\ngoal (1 subgoal):\n 1. m = (THE m. m \\<in> obs (sourcenode a) (backward_slice S))", "by(rule obs_the_element[THEN sym])"], ["proof (state)\nthis:\n  m = (THE m. m \\<in> obs (sourcenode a) (backward_slice S))\n\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>", "with assms"], ["proof (chain)\npicking this:\n  sourcenode a \\<notin> backward_slice S\n  kind a = (Q)\\<^sub>\\<surd>\n  m \\<in> obs (sourcenode a) (backward_slice S)\n  distance (targetnode a) m x\n  distance (sourcenode a) m (x + 1)\n  targetnode a =\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') m x \\<and>\n         valid_edge a' \\<and> targetnode a' = n')\n  m = (THE m. m \\<in> obs (sourcenode a) (backward_slice S))", "show ?thesis"], ["proof (prove)\nusing this:\n  sourcenode a \\<notin> backward_slice S\n  kind a = (Q)\\<^sub>\\<surd>\n  m \\<in> obs (sourcenode a) (backward_slice S)\n  distance (targetnode a) m x\n  distance (sourcenode a) m (x + 1)\n  targetnode a =\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') m x \\<and>\n         valid_edge a' \\<and> targetnode a' = n')\n  m = (THE m. m \\<in> obs (sourcenode a) (backward_slice S))\n\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>", "by(fastforce simp:slice_kind_def Let_def)"], ["proof (state)\nthis:\n  slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma slice_kind_Pred_obs_nearer_not_SOME:\n  assumes \"sourcenode a \\<notin> backward_slice S\" and \"kind a = (Q)\\<^sub>\\<surd>\" \n  and \"m \\<in> obs (sourcenode a) (backward_slice S)\"\n  and \"distance (targetnode a) m x\" \"distance (sourcenode a) m (x + 1)\"\n  and \"targetnode a \\<noteq> (SOME nx'. \\<exists>a'. sourcenode a = sourcenode a' \\<and> \n                                          distance (targetnode a') m x \\<and>\n                                          valid_edge a' \\<and> targetnode a' = nx')\"\n  shows \"slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>", "from \\<open>m \\<in> obs (sourcenode a) (backward_slice S)\\<close>"], ["proof (chain)\npicking this:\n  m \\<in> obs (sourcenode a) (backward_slice S)", "have \"m = (THE m. m \\<in> obs (sourcenode a) (backward_slice S))\""], ["proof (prove)\nusing this:\n  m \\<in> obs (sourcenode a) (backward_slice S)\n\ngoal (1 subgoal):\n 1. m = (THE m. m \\<in> obs (sourcenode a) (backward_slice S))", "by(rule obs_the_element[THEN sym])"], ["proof (state)\nthis:\n  m = (THE m. m \\<in> obs (sourcenode a) (backward_slice S))\n\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>", "with assms"], ["proof (chain)\npicking this:\n  sourcenode a \\<notin> backward_slice S\n  kind a = (Q)\\<^sub>\\<surd>\n  m \\<in> obs (sourcenode a) (backward_slice S)\n  distance (targetnode a) m x\n  distance (sourcenode a) m (x + 1)\n  targetnode a \\<noteq>\n  (SOME nx'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') m x \\<and>\n         valid_edge a' \\<and> targetnode a' = nx')\n  m = (THE m. m \\<in> obs (sourcenode a) (backward_slice S))", "show ?thesis"], ["proof (prove)\nusing this:\n  sourcenode a \\<notin> backward_slice S\n  kind a = (Q)\\<^sub>\\<surd>\n  m \\<in> obs (sourcenode a) (backward_slice S)\n  distance (targetnode a) m x\n  distance (sourcenode a) m (x + 1)\n  targetnode a \\<noteq>\n  (SOME nx'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') m x \\<and>\n         valid_edge a' \\<and> targetnode a' = nx')\n  m = (THE m. m \\<in> obs (sourcenode a) (backward_slice S))\n\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>", "by(fastforce dest:distance_det simp:slice_kind_def Let_def)"], ["proof (state)\nthis:\n  slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma slice_kind_Pred_obs_not_nearer:\n  assumes \"sourcenode a \\<notin> backward_slice S\" and \"kind a = (Q)\\<^sub>\\<surd>\" \n  and in_obs:\"m \\<in> obs (sourcenode a) (backward_slice S)\"\n  and dist:\"distance (sourcenode a) m (x + 1)\" \n           \"\\<not> distance (targetnode a) m x\"\n  shows \"slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>", "from in_obs"], ["proof (chain)\npicking this:\n  m \\<in> obs (sourcenode a) (backward_slice S)", "have the:\"m = (THE m. m \\<in> obs (sourcenode a) (backward_slice S))\""], ["proof (prove)\nusing this:\n  m \\<in> obs (sourcenode a) (backward_slice S)\n\ngoal (1 subgoal):\n 1. m = (THE m. m \\<in> obs (sourcenode a) (backward_slice S))", "by(rule obs_the_element[THEN sym])"], ["proof (state)\nthis:\n  m = (THE m. m \\<in> obs (sourcenode a) (backward_slice S))\n\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>", "from dist"], ["proof (chain)\npicking this:\n  distance (sourcenode a) m (x + 1)\n  \\<not> distance (targetnode a) m x", "have \"\\<not> (\\<exists>x. distance (targetnode a) m x \\<and> \n                            distance (sourcenode a) m (x + 1))\""], ["proof (prove)\nusing this:\n  distance (sourcenode a) m (x + 1)\n  \\<not> distance (targetnode a) m x\n\ngoal (1 subgoal):\n 1. \\<nexists>x.\n       distance (targetnode a) m x \\<and> distance (sourcenode a) m (x + 1)", "by(fastforce dest:distance_det)"], ["proof (state)\nthis:\n  \\<nexists>x.\n     distance (targetnode a) m x \\<and> distance (sourcenode a) m (x + 1)\n\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>", "with \\<open>sourcenode a \\<notin> backward_slice S\\<close> \\<open>kind a = (Q)\\<^sub>\\<surd>\\<close> in_obs the"], ["proof (chain)\npicking this:\n  sourcenode a \\<notin> backward_slice S\n  kind a = (Q)\\<^sub>\\<surd>\n  m \\<in> obs (sourcenode a) (backward_slice S)\n  m = (THE m. m \\<in> obs (sourcenode a) (backward_slice S))\n  \\<nexists>x.\n     distance (targetnode a) m x \\<and> distance (sourcenode a) m (x + 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  sourcenode a \\<notin> backward_slice S\n  kind a = (Q)\\<^sub>\\<surd>\n  m \\<in> obs (sourcenode a) (backward_slice S)\n  m = (THE m. m \\<in> obs (sourcenode a) (backward_slice S))\n  \\<nexists>x.\n     distance (targetnode a) m x \\<and> distance (sourcenode a) m (x + 1)\n\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>", "by(fastforce simp:slice_kind_def Let_def)"], ["proof (state)\nthis:\n  slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma kind_Predicate_notin_slice_slice_kind_Predicate:\n  assumes \"kind a = (Q)\\<^sub>\\<surd>\" and \"sourcenode a \\<notin> backward_slice S\"\n  obtains Q' where \"slice_kind S a = (Q')\\<^sub>\\<surd>\" and \"Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Q'.\n        \\<lbrakk>slice_kind S a = (Q')\\<^sub>\\<surd>;\n         Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "show \"\\<exists>Q'. slice_kind S a = (Q')\\<^sub>\\<surd> \\<and> (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "proof(cases \"obs (sourcenode a) (backward_slice S) = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. obs (sourcenode a) (backward_slice S) = {} \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))\n 2. obs (sourcenode a) (backward_slice S) \\<noteq> {} \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "case True"], ["proof (state)\nthis:\n  obs (sourcenode a) (backward_slice S) = {}\n\ngoal (2 subgoals):\n 1. obs (sourcenode a) (backward_slice S) = {} \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))\n 2. obs (sourcenode a) (backward_slice S) \\<noteq> {} \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "proof(cases \"targetnode a = (SOME n'. \\<exists>a'. sourcenode a = sourcenode a' \\<and> \n                                               valid_edge a' \\<and> targetnode a' = n')\")"], ["proof (state)\ngoal (2 subgoals):\n 1. targetnode a =\n    (SOME n'.\n        \\<exists>a'.\n           sourcenode a = sourcenode a' \\<and>\n           valid_edge a' \\<and> targetnode a' = n') \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))\n 2. targetnode a \\<noteq>\n    (SOME n'.\n        \\<exists>a'.\n           sourcenode a = sourcenode a' \\<and>\n           valid_edge a' \\<and> targetnode a' = n') \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "case True"], ["proof (state)\nthis:\n  targetnode a =\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         valid_edge a' \\<and> targetnode a' = n')\n\ngoal (2 subgoals):\n 1. targetnode a =\n    (SOME n'.\n        \\<exists>a'.\n           sourcenode a = sourcenode a' \\<and>\n           valid_edge a' \\<and> targetnode a' = n') \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))\n 2. targetnode a \\<noteq>\n    (SOME n'.\n        \\<exists>a'.\n           sourcenode a = sourcenode a' \\<and>\n           valid_edge a' \\<and> targetnode a' = n') \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "with \\<open>sourcenode a \\<notin> backward_slice S\\<close> \\<open>kind a = (Q)\\<^sub>\\<surd>\\<close>\n        \\<open>obs (sourcenode a) (backward_slice S) = {}\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a \\<notin> backward_slice S\n  kind a = (Q)\\<^sub>\\<surd>\n  obs (sourcenode a) (backward_slice S) = {}\n  targetnode a =\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         valid_edge a' \\<and> targetnode a' = n')", "have \"slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  sourcenode a \\<notin> backward_slice S\n  kind a = (Q)\\<^sub>\\<surd>\n  obs (sourcenode a) (backward_slice S) = {}\n  targetnode a =\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         valid_edge a' \\<and> targetnode a' = n')\n\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>", "by(rule slice_kind_Pred_empty_obs_SOME)"], ["proof (state)\nthis:\n  slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (2 subgoals):\n 1. targetnode a =\n    (SOME n'.\n        \\<exists>a'.\n           sourcenode a = sourcenode a' \\<and>\n           valid_edge a' \\<and> targetnode a' = n') \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))\n 2. targetnode a \\<noteq>\n    (SOME n'.\n        \\<exists>a'.\n           sourcenode a = sourcenode a' \\<and>\n           valid_edge a' \\<and> targetnode a' = n') \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "thus ?thesis"], ["proof (prove)\nusing this:\n  slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "by simp"], ["proof (state)\nthis:\n  \\<exists>Q'.\n     slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n     (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))\n\ngoal (1 subgoal):\n 1. targetnode a \\<noteq>\n    (SOME n'.\n        \\<exists>a'.\n           sourcenode a = sourcenode a' \\<and>\n           valid_edge a' \\<and> targetnode a' = n') \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. targetnode a \\<noteq>\n    (SOME n'.\n        \\<exists>a'.\n           sourcenode a = sourcenode a' \\<and>\n           valid_edge a' \\<and> targetnode a' = n') \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "case False"], ["proof (state)\nthis:\n  targetnode a \\<noteq>\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         valid_edge a' \\<and> targetnode a' = n')\n\ngoal (1 subgoal):\n 1. targetnode a \\<noteq>\n    (SOME n'.\n        \\<exists>a'.\n           sourcenode a = sourcenode a' \\<and>\n           valid_edge a' \\<and> targetnode a' = n') \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "with \\<open>sourcenode a \\<notin> backward_slice S\\<close> \\<open>kind a = (Q)\\<^sub>\\<surd>\\<close>\n        \\<open>obs (sourcenode a) (backward_slice S) = {}\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a \\<notin> backward_slice S\n  kind a = (Q)\\<^sub>\\<surd>\n  obs (sourcenode a) (backward_slice S) = {}\n  targetnode a \\<noteq>\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         valid_edge a' \\<and> targetnode a' = n')", "have \"slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  sourcenode a \\<notin> backward_slice S\n  kind a = (Q)\\<^sub>\\<surd>\n  obs (sourcenode a) (backward_slice S) = {}\n  targetnode a \\<noteq>\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         valid_edge a' \\<and> targetnode a' = n')\n\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>", "by(rule slice_kind_Pred_empty_obs_not_SOME)"], ["proof (state)\nthis:\n  slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. targetnode a \\<noteq>\n    (SOME n'.\n        \\<exists>a'.\n           sourcenode a = sourcenode a' \\<and>\n           valid_edge a' \\<and> targetnode a' = n') \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "thus ?thesis"], ["proof (prove)\nusing this:\n  slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "by simp"], ["proof (state)\nthis:\n  \\<exists>Q'.\n     slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n     (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>Q'.\n     slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n     (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))\n\ngoal (1 subgoal):\n 1. obs (sourcenode a) (backward_slice S) \\<noteq> {} \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. obs (sourcenode a) (backward_slice S) \\<noteq> {} \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "case False"], ["proof (state)\nthis:\n  obs (sourcenode a) (backward_slice S) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. obs (sourcenode a) (backward_slice S) \\<noteq> {} \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "then"], ["proof (chain)\npicking this:\n  obs (sourcenode a) (backward_slice S) \\<noteq> {}", "obtain m where \"m \\<in> obs (sourcenode a) (backward_slice S)\""], ["proof (prove)\nusing this:\n  obs (sourcenode a) (backward_slice S) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        m \\<in> obs (sourcenode a) (backward_slice S) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  m \\<in> obs (sourcenode a) (backward_slice S)\n\ngoal (1 subgoal):\n 1. obs (sourcenode a) (backward_slice S) \\<noteq> {} \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "proof(cases \"\\<exists>x. distance (targetnode a) m x \\<and> \n        distance (sourcenode a) m (x + 1)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>x.\n       distance (targetnode a) m x \\<and>\n       distance (sourcenode a) m (x + 1) \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))\n 2. \\<nexists>x.\n       distance (targetnode a) m x \\<and>\n       distance (sourcenode a) m (x + 1) \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "case True"], ["proof (state)\nthis:\n  \\<exists>x.\n     distance (targetnode a) m x \\<and> distance (sourcenode a) m (x + 1)\n\ngoal (2 subgoals):\n 1. \\<exists>x.\n       distance (targetnode a) m x \\<and>\n       distance (sourcenode a) m (x + 1) \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))\n 2. \\<nexists>x.\n       distance (targetnode a) m x \\<and>\n       distance (sourcenode a) m (x + 1) \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "then"], ["proof (chain)\npicking this:\n  \\<exists>x.\n     distance (targetnode a) m x \\<and> distance (sourcenode a) m (x + 1)", "obtain x where \"distance (targetnode a) m x\" \n        and \"distance (sourcenode a) m (x + 1)\""], ["proof (prove)\nusing this:\n  \\<exists>x.\n     distance (targetnode a) m x \\<and> distance (sourcenode a) m (x + 1)\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>distance (targetnode a) m x;\n         distance (sourcenode a) m (x + 1)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  distance (targetnode a) m x\n  distance (sourcenode a) m (x + 1)\n\ngoal (2 subgoals):\n 1. \\<exists>x.\n       distance (targetnode a) m x \\<and>\n       distance (sourcenode a) m (x + 1) \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))\n 2. \\<nexists>x.\n       distance (targetnode a) m x \\<and>\n       distance (sourcenode a) m (x + 1) \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "proof(cases \"targetnode a = (SOME n'. \\<exists>a'. sourcenode a = sourcenode a' \\<and>\n                                                 distance (targetnode a') m x \\<and>\n                                                 valid_edge a' \\<and> targetnode a' = n')\")"], ["proof (state)\ngoal (2 subgoals):\n 1. targetnode a =\n    (SOME n'.\n        \\<exists>a'.\n           sourcenode a = sourcenode a' \\<and>\n           distance (targetnode a') m x \\<and>\n           valid_edge a' \\<and> targetnode a' = n') \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))\n 2. targetnode a \\<noteq>\n    (SOME n'.\n        \\<exists>a'.\n           sourcenode a = sourcenode a' \\<and>\n           distance (targetnode a') m x \\<and>\n           valid_edge a' \\<and> targetnode a' = n') \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "case True"], ["proof (state)\nthis:\n  targetnode a =\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') m x \\<and>\n         valid_edge a' \\<and> targetnode a' = n')\n\ngoal (2 subgoals):\n 1. targetnode a =\n    (SOME n'.\n        \\<exists>a'.\n           sourcenode a = sourcenode a' \\<and>\n           distance (targetnode a') m x \\<and>\n           valid_edge a' \\<and> targetnode a' = n') \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))\n 2. targetnode a \\<noteq>\n    (SOME n'.\n        \\<exists>a'.\n           sourcenode a = sourcenode a' \\<and>\n           distance (targetnode a') m x \\<and>\n           valid_edge a' \\<and> targetnode a' = n') \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "with \\<open>sourcenode a \\<notin> backward_slice S\\<close> \\<open>kind a = (Q)\\<^sub>\\<surd>\\<close>\n          \\<open>m \\<in> obs (sourcenode a) (backward_slice S)\\<close>\n          \\<open>distance (targetnode a) m x\\<close> \\<open>distance (sourcenode a) m (x + 1)\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a \\<notin> backward_slice S\n  kind a = (Q)\\<^sub>\\<surd>\n  m \\<in> obs (sourcenode a) (backward_slice S)\n  distance (targetnode a) m x\n  distance (sourcenode a) m (x + 1)\n  targetnode a =\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') m x \\<and>\n         valid_edge a' \\<and> targetnode a' = n')", "have \"slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  sourcenode a \\<notin> backward_slice S\n  kind a = (Q)\\<^sub>\\<surd>\n  m \\<in> obs (sourcenode a) (backward_slice S)\n  distance (targetnode a) m x\n  distance (sourcenode a) m (x + 1)\n  targetnode a =\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') m x \\<and>\n         valid_edge a' \\<and> targetnode a' = n')\n\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>", "by(rule slice_kind_Pred_obs_nearer_SOME)"], ["proof (state)\nthis:\n  slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (2 subgoals):\n 1. targetnode a =\n    (SOME n'.\n        \\<exists>a'.\n           sourcenode a = sourcenode a' \\<and>\n           distance (targetnode a') m x \\<and>\n           valid_edge a' \\<and> targetnode a' = n') \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))\n 2. targetnode a \\<noteq>\n    (SOME n'.\n        \\<exists>a'.\n           sourcenode a = sourcenode a' \\<and>\n           distance (targetnode a') m x \\<and>\n           valid_edge a' \\<and> targetnode a' = n') \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "thus ?thesis"], ["proof (prove)\nusing this:\n  slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "by simp"], ["proof (state)\nthis:\n  \\<exists>Q'.\n     slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n     (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))\n\ngoal (1 subgoal):\n 1. targetnode a \\<noteq>\n    (SOME n'.\n        \\<exists>a'.\n           sourcenode a = sourcenode a' \\<and>\n           distance (targetnode a') m x \\<and>\n           valid_edge a' \\<and> targetnode a' = n') \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. targetnode a \\<noteq>\n    (SOME n'.\n        \\<exists>a'.\n           sourcenode a = sourcenode a' \\<and>\n           distance (targetnode a') m x \\<and>\n           valid_edge a' \\<and> targetnode a' = n') \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "case False"], ["proof (state)\nthis:\n  targetnode a \\<noteq>\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') m x \\<and>\n         valid_edge a' \\<and> targetnode a' = n')\n\ngoal (1 subgoal):\n 1. targetnode a \\<noteq>\n    (SOME n'.\n        \\<exists>a'.\n           sourcenode a = sourcenode a' \\<and>\n           distance (targetnode a') m x \\<and>\n           valid_edge a' \\<and> targetnode a' = n') \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "with \\<open>sourcenode a \\<notin> backward_slice S\\<close> \\<open>kind a = (Q)\\<^sub>\\<surd>\\<close>\n          \\<open>m \\<in> obs (sourcenode a) (backward_slice S)\\<close>\n          \\<open>distance (targetnode a) m x\\<close> \\<open>distance (sourcenode a) m (x + 1)\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a \\<notin> backward_slice S\n  kind a = (Q)\\<^sub>\\<surd>\n  m \\<in> obs (sourcenode a) (backward_slice S)\n  distance (targetnode a) m x\n  distance (sourcenode a) m (x + 1)\n  targetnode a \\<noteq>\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') m x \\<and>\n         valid_edge a' \\<and> targetnode a' = n')", "have \"slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  sourcenode a \\<notin> backward_slice S\n  kind a = (Q)\\<^sub>\\<surd>\n  m \\<in> obs (sourcenode a) (backward_slice S)\n  distance (targetnode a) m x\n  distance (sourcenode a) m (x + 1)\n  targetnode a \\<noteq>\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') m x \\<and>\n         valid_edge a' \\<and> targetnode a' = n')\n\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>", "by(rule slice_kind_Pred_obs_nearer_not_SOME)"], ["proof (state)\nthis:\n  slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. targetnode a \\<noteq>\n    (SOME n'.\n        \\<exists>a'.\n           sourcenode a = sourcenode a' \\<and>\n           distance (targetnode a') m x \\<and>\n           valid_edge a' \\<and> targetnode a' = n') \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "thus ?thesis"], ["proof (prove)\nusing this:\n  slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "by simp"], ["proof (state)\nthis:\n  \\<exists>Q'.\n     slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n     (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>Q'.\n     slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n     (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))\n\ngoal (1 subgoal):\n 1. \\<nexists>x.\n       distance (targetnode a) m x \\<and>\n       distance (sourcenode a) m (x + 1) \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>x.\n       distance (targetnode a) m x \\<and>\n       distance (sourcenode a) m (x + 1) \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "case False"], ["proof (state)\nthis:\n  \\<nexists>x.\n     distance (targetnode a) m x \\<and> distance (sourcenode a) m (x + 1)\n\ngoal (1 subgoal):\n 1. \\<nexists>x.\n       distance (targetnode a) m x \\<and>\n       distance (sourcenode a) m (x + 1) \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "from \\<open>m \\<in> obs (sourcenode a) (backward_slice S)\\<close>"], ["proof (chain)\npicking this:\n  m \\<in> obs (sourcenode a) (backward_slice S)", "have \"m = (THE m. m \\<in> obs (sourcenode a) (backward_slice S))\""], ["proof (prove)\nusing this:\n  m \\<in> obs (sourcenode a) (backward_slice S)\n\ngoal (1 subgoal):\n 1. m = (THE m. m \\<in> obs (sourcenode a) (backward_slice S))", "by(rule obs_the_element[THEN sym])"], ["proof (state)\nthis:\n  m = (THE m. m \\<in> obs (sourcenode a) (backward_slice S))\n\ngoal (1 subgoal):\n 1. \\<nexists>x.\n       distance (targetnode a) m x \\<and>\n       distance (sourcenode a) m (x + 1) \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "with \\<open>sourcenode a \\<notin> backward_slice S\\<close> \\<open>kind a = (Q)\\<^sub>\\<surd>\\<close> False\n        \\<open>m \\<in> obs (sourcenode a) (backward_slice S)\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a \\<notin> backward_slice S\n  kind a = (Q)\\<^sub>\\<surd>\n  \\<nexists>x.\n     distance (targetnode a) m x \\<and> distance (sourcenode a) m (x + 1)\n  m \\<in> obs (sourcenode a) (backward_slice S)\n  m = (THE m. m \\<in> obs (sourcenode a) (backward_slice S))", "have \"slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  sourcenode a \\<notin> backward_slice S\n  kind a = (Q)\\<^sub>\\<surd>\n  \\<nexists>x.\n     distance (targetnode a) m x \\<and> distance (sourcenode a) m (x + 1)\n  m \\<in> obs (sourcenode a) (backward_slice S)\n  m = (THE m. m \\<in> obs (sourcenode a) (backward_slice S))\n\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>", "by(fastforce simp:slice_kind_def Let_def)"], ["proof (state)\nthis:\n  slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. \\<nexists>x.\n       distance (targetnode a) m x \\<and>\n       distance (sourcenode a) m (x + 1) \\<Longrightarrow>\n    \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "thus ?thesis"], ["proof (prove)\nusing this:\n  slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. \\<exists>Q'.\n       slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n       (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))", "by simp"], ["proof (state)\nthis:\n  \\<exists>Q'.\n     slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n     (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>Q'.\n     slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n     (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>Q'.\n     slice_kind S a = (Q')\\<^sub>\\<surd> \\<and>\n     (Q' = (\\<lambda>s. False) \\<or> Q' = (\\<lambda>s. True))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma only_one_SOME_edge:\n  assumes \"valid_edge a\"\n  shows \"\\<exists>!a'. sourcenode a = sourcenode a' \\<and> valid_edge a' \\<and>\n               targetnode a' = (SOME n'. \\<exists>a'. sourcenode a = sourcenode a' \\<and> \n                                              valid_edge a' \\<and> targetnode a' = n')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!a'.\n       sourcenode a = sourcenode a' \\<and>\n       valid_edge a' \\<and>\n       targetnode a' =\n       (SOME n'.\n           \\<exists>a'.\n              sourcenode a = sourcenode a' \\<and>\n              valid_edge a' \\<and> targetnode a' = n')", "proof(rule ex_ex1I)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>a'.\n       sourcenode a = sourcenode a' \\<and>\n       valid_edge a' \\<and>\n       targetnode a' =\n       (SOME n'.\n           \\<exists>a'.\n              sourcenode a = sourcenode a' \\<and>\n              valid_edge a' \\<and> targetnode a' = n')\n 2. \\<And>a' y.\n       \\<lbrakk>sourcenode a = sourcenode a' \\<and>\n                valid_edge a' \\<and>\n                targetnode a' =\n                (SOME n'.\n                    \\<exists>a'.\n                       sourcenode a = sourcenode a' \\<and>\n                       valid_edge a' \\<and> targetnode a' = n');\n        sourcenode a = sourcenode y \\<and>\n        valid_edge y \\<and>\n        targetnode y =\n        (SOME n'.\n            \\<exists>a'.\n               sourcenode a = sourcenode a' \\<and>\n               valid_edge a' \\<and> targetnode a' = n')\\<rbrakk>\n       \\<Longrightarrow> a' = y", "show \"\\<exists>a'. sourcenode a = sourcenode a' \\<and> valid_edge a' \\<and>\n             targetnode a' = (SOME n'. \\<exists>a'. sourcenode a = sourcenode a' \\<and> \n                                            valid_edge a' \\<and> targetnode a' = n')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a'.\n       sourcenode a = sourcenode a' \\<and>\n       valid_edge a' \\<and>\n       targetnode a' =\n       (SOME n'.\n           \\<exists>a'.\n              sourcenode a = sourcenode a' \\<and>\n              valid_edge a' \\<and> targetnode a' = n')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>a'.\n       sourcenode a = sourcenode a' \\<and>\n       valid_edge a' \\<and>\n       targetnode a' =\n       (SOME n'.\n           \\<exists>a'.\n              sourcenode a = sourcenode a' \\<and>\n              valid_edge a' \\<and> targetnode a' = n')", "have \"(\\<exists>a'. sourcenode a = sourcenode a' \\<and> valid_edge a' \\<and>\n                targetnode a' = (SOME n'. \\<exists>a'. sourcenode a = sourcenode a' \\<and> \n                                               valid_edge a' \\<and> targetnode a' = n')) =\n      (\\<exists>n'. \\<exists>a'. sourcenode a = sourcenode a' \\<and> valid_edge a' \\<and> targetnode a' = n')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>a'.\n        sourcenode a = sourcenode a' \\<and>\n        valid_edge a' \\<and>\n        targetnode a' =\n        (SOME n'.\n            \\<exists>a'.\n               sourcenode a = sourcenode a' \\<and>\n               valid_edge a' \\<and> targetnode a' = n')) =\n    (\\<exists>n' a'.\n        sourcenode a = sourcenode a' \\<and>\n        valid_edge a' \\<and> targetnode a' = n')", "apply(unfold some_eq_ex[of \"\\<lambda>n'. \\<exists>a'. sourcenode a = sourcenode a' \\<and> \n                                            valid_edge a' \\<and> targetnode a' = n'\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>n' a'.\n        sourcenode a = sourcenode a' \\<and>\n        valid_edge a' \\<and> targetnode a' = n') =\n    (\\<exists>n' a'.\n        sourcenode a = sourcenode a' \\<and>\n        valid_edge a' \\<and> targetnode a' = n')", "by simp"], ["proof (state)\nthis:\n  (\\<exists>a'.\n      sourcenode a = sourcenode a' \\<and>\n      valid_edge a' \\<and>\n      targetnode a' =\n      (SOME n'.\n          \\<exists>a'.\n             sourcenode a = sourcenode a' \\<and>\n             valid_edge a' \\<and> targetnode a' = n')) =\n  (\\<exists>n' a'.\n      sourcenode a = sourcenode a' \\<and>\n      valid_edge a' \\<and> targetnode a' = n')\n\ngoal (1 subgoal):\n 1. \\<exists>a'.\n       sourcenode a = sourcenode a' \\<and>\n       valid_edge a' \\<and>\n       targetnode a' =\n       (SOME n'.\n           \\<exists>a'.\n              sourcenode a = sourcenode a' \\<and>\n              valid_edge a' \\<and> targetnode a' = n')", "also"], ["proof (state)\nthis:\n  (\\<exists>a'.\n      sourcenode a = sourcenode a' \\<and>\n      valid_edge a' \\<and>\n      targetnode a' =\n      (SOME n'.\n          \\<exists>a'.\n             sourcenode a = sourcenode a' \\<and>\n             valid_edge a' \\<and> targetnode a' = n')) =\n  (\\<exists>n' a'.\n      sourcenode a = sourcenode a' \\<and>\n      valid_edge a' \\<and> targetnode a' = n')\n\ngoal (1 subgoal):\n 1. \\<exists>a'.\n       sourcenode a = sourcenode a' \\<and>\n       valid_edge a' \\<and>\n       targetnode a' =\n       (SOME n'.\n           \\<exists>a'.\n              sourcenode a = sourcenode a' \\<and>\n              valid_edge a' \\<and> targetnode a' = n')", "have \"\\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n' a'.\n       sourcenode a = sourcenode a' \\<and>\n       valid_edge a' \\<and> targetnode a' = n'", "using \\<open>valid_edge a\\<close>"], ["proof (prove)\nusing this:\n  valid_edge a\n\ngoal (1 subgoal):\n 1. \\<exists>n' a'.\n       sourcenode a = sourcenode a' \\<and>\n       valid_edge a' \\<and> targetnode a' = n'", "by blast"], ["proof (state)\nthis:\n  \\<exists>n' a'.\n     sourcenode a = sourcenode a' \\<and>\n     valid_edge a' \\<and> targetnode a' = n'\n\ngoal (1 subgoal):\n 1. \\<exists>a'.\n       sourcenode a = sourcenode a' \\<and>\n       valid_edge a' \\<and>\n       targetnode a' =\n       (SOME n'.\n           \\<exists>a'.\n              sourcenode a = sourcenode a' \\<and>\n              valid_edge a' \\<and> targetnode a' = n')", "finally"], ["proof (chain)\npicking this:\n  \\<exists>a'.\n     sourcenode a = sourcenode a' \\<and>\n     valid_edge a' \\<and>\n     targetnode a' =\n     (SOME n'.\n         \\<exists>a'.\n            sourcenode a = sourcenode a' \\<and>\n            valid_edge a' \\<and> targetnode a' = n')", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>a'.\n     sourcenode a = sourcenode a' \\<and>\n     valid_edge a' \\<and>\n     targetnode a' =\n     (SOME n'.\n         \\<exists>a'.\n            sourcenode a = sourcenode a' \\<and>\n            valid_edge a' \\<and> targetnode a' = n')\n\ngoal (1 subgoal):\n 1. \\<exists>a'.\n       sourcenode a = sourcenode a' \\<and>\n       valid_edge a' \\<and>\n       targetnode a' =\n       (SOME n'.\n           \\<exists>a'.\n              sourcenode a = sourcenode a' \\<and>\n              valid_edge a' \\<and> targetnode a' = n')", "."], ["proof (state)\nthis:\n  \\<exists>a'.\n     sourcenode a = sourcenode a' \\<and>\n     valid_edge a' \\<and>\n     targetnode a' =\n     (SOME n'.\n         \\<exists>a'.\n            sourcenode a = sourcenode a' \\<and>\n            valid_edge a' \\<and> targetnode a' = n')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a'.\n     sourcenode a = sourcenode a' \\<and>\n     valid_edge a' \\<and>\n     targetnode a' =\n     (SOME n'.\n         \\<exists>a'.\n            sourcenode a = sourcenode a' \\<and>\n            valid_edge a' \\<and> targetnode a' = n')\n\ngoal (1 subgoal):\n 1. \\<And>a' y.\n       \\<lbrakk>sourcenode a = sourcenode a' \\<and>\n                valid_edge a' \\<and>\n                targetnode a' =\n                (SOME n'.\n                    \\<exists>a'.\n                       sourcenode a = sourcenode a' \\<and>\n                       valid_edge a' \\<and> targetnode a' = n');\n        sourcenode a = sourcenode y \\<and>\n        valid_edge y \\<and>\n        targetnode y =\n        (SOME n'.\n            \\<exists>a'.\n               sourcenode a = sourcenode a' \\<and>\n               valid_edge a' \\<and> targetnode a' = n')\\<rbrakk>\n       \\<Longrightarrow> a' = y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a' y.\n       \\<lbrakk>sourcenode a = sourcenode a' \\<and>\n                valid_edge a' \\<and>\n                targetnode a' =\n                (SOME n'.\n                    \\<exists>a'.\n                       sourcenode a = sourcenode a' \\<and>\n                       valid_edge a' \\<and> targetnode a' = n');\n        sourcenode a = sourcenode y \\<and>\n        valid_edge y \\<and>\n        targetnode y =\n        (SOME n'.\n            \\<exists>a'.\n               sourcenode a = sourcenode a' \\<and>\n               valid_edge a' \\<and> targetnode a' = n')\\<rbrakk>\n       \\<Longrightarrow> a' = y", "fix a' ax"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a' y.\n       \\<lbrakk>sourcenode a = sourcenode a' \\<and>\n                valid_edge a' \\<and>\n                targetnode a' =\n                (SOME n'.\n                    \\<exists>a'.\n                       sourcenode a = sourcenode a' \\<and>\n                       valid_edge a' \\<and> targetnode a' = n');\n        sourcenode a = sourcenode y \\<and>\n        valid_edge y \\<and>\n        targetnode y =\n        (SOME n'.\n            \\<exists>a'.\n               sourcenode a = sourcenode a' \\<and>\n               valid_edge a' \\<and> targetnode a' = n')\\<rbrakk>\n       \\<Longrightarrow> a' = y", "assume \"sourcenode a = sourcenode a' \\<and> valid_edge a' \\<and>\n    targetnode a' = (SOME n'. \\<exists>a'. sourcenode a = sourcenode a' \\<and> \n                                   valid_edge a' \\<and> targetnode a' = n')\"\n    and \"sourcenode a = sourcenode ax \\<and> valid_edge ax \\<and>\n    targetnode ax = (SOME n'. \\<exists>a'. sourcenode a = sourcenode a' \\<and> \n                              valid_edge a' \\<and> targetnode a' = n')\""], ["proof (state)\nthis:\n  sourcenode a = sourcenode a' \\<and>\n  valid_edge a' \\<and>\n  targetnode a' =\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         valid_edge a' \\<and> targetnode a' = n')\n  sourcenode a = sourcenode ax \\<and>\n  valid_edge ax \\<and>\n  targetnode ax =\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         valid_edge a' \\<and> targetnode a' = n')\n\ngoal (1 subgoal):\n 1. \\<And>a' y.\n       \\<lbrakk>sourcenode a = sourcenode a' \\<and>\n                valid_edge a' \\<and>\n                targetnode a' =\n                (SOME n'.\n                    \\<exists>a'.\n                       sourcenode a = sourcenode a' \\<and>\n                       valid_edge a' \\<and> targetnode a' = n');\n        sourcenode a = sourcenode y \\<and>\n        valid_edge y \\<and>\n        targetnode y =\n        (SOME n'.\n            \\<exists>a'.\n               sourcenode a = sourcenode a' \\<and>\n               valid_edge a' \\<and> targetnode a' = n')\\<rbrakk>\n       \\<Longrightarrow> a' = y", "thus \"a' = ax\""], ["proof (prove)\nusing this:\n  sourcenode a = sourcenode a' \\<and>\n  valid_edge a' \\<and>\n  targetnode a' =\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         valid_edge a' \\<and> targetnode a' = n')\n  sourcenode a = sourcenode ax \\<and>\n  valid_edge ax \\<and>\n  targetnode ax =\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         valid_edge a' \\<and> targetnode a' = n')\n\ngoal (1 subgoal):\n 1. a' = ax", "by(fastforce intro!:edge_det)"], ["proof (state)\nthis:\n  a' = ax\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma slice_kind_only_one_True_edge:\n  assumes \"sourcenode a = sourcenode a'\" and \"targetnode a \\<noteq> targetnode a'\" \n  and \"valid_edge a\" and \"valid_edge a'\" and \"slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\"\n  shows \"slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "from assms"], ["proof (chain)\npicking this:\n  sourcenode a = sourcenode a'\n  targetnode a \\<noteq> targetnode a'\n  valid_edge a\n  valid_edge a'\n  slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>", "obtain Q Q' where \"kind a = (Q)\\<^sub>\\<surd>\"\n    and \"kind a' = (Q')\\<^sub>\\<surd>\" and det:\"\\<forall>s. (Q s \\<longrightarrow> \\<not> Q' s) \\<and> (Q' s \\<longrightarrow> \\<not> Q s)\""], ["proof (prove)\nusing this:\n  sourcenode a = sourcenode a'\n  targetnode a \\<noteq> targetnode a'\n  valid_edge a\n  valid_edge a'\n  slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. (\\<And>Q Q'.\n        \\<lbrakk>kind a = (Q)\\<^sub>\\<surd>; kind a' = (Q')\\<^sub>\\<surd>;\n         \\<forall>s.\n            (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n            (Q' s \\<longrightarrow> \\<not> Q s)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto dest:deterministic)"], ["proof (state)\nthis:\n  kind a = (Q)\\<^sub>\\<surd>\n  kind a' = (Q')\\<^sub>\\<surd>\n  \\<forall>s.\n     (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n     (Q' s \\<longrightarrow> \\<not> Q s)\n\ngoal (1 subgoal):\n 1. slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "from \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a", "have ex1:\"\\<exists>!a'. sourcenode a = sourcenode a' \\<and> valid_edge a' \\<and>\n               targetnode a' = (SOME n'. \\<exists>a'. sourcenode a = sourcenode a' \\<and> \n                                              valid_edge a' \\<and> targetnode a' = n')\""], ["proof (prove)\nusing this:\n  valid_edge a\n\ngoal (1 subgoal):\n 1. \\<exists>!a'.\n       sourcenode a = sourcenode a' \\<and>\n       valid_edge a' \\<and>\n       targetnode a' =\n       (SOME n'.\n           \\<exists>a'.\n              sourcenode a = sourcenode a' \\<and>\n              valid_edge a' \\<and> targetnode a' = n')", "by(rule only_one_SOME_edge)"], ["proof (state)\nthis:\n  \\<exists>!a'.\n     sourcenode a = sourcenode a' \\<and>\n     valid_edge a' \\<and>\n     targetnode a' =\n     (SOME n'.\n         \\<exists>a'.\n            sourcenode a = sourcenode a' \\<and>\n            valid_edge a' \\<and> targetnode a' = n')\n\ngoal (1 subgoal):\n 1. slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "proof(cases \"sourcenode a \\<in> backward_slice S\")"], ["proof (state)\ngoal (2 subgoals):\n 1. sourcenode a \\<in> backward_slice S \\<Longrightarrow>\n    slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>\n 2. sourcenode a \\<notin> backward_slice S \\<Longrightarrow>\n    slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "case True"], ["proof (state)\nthis:\n  sourcenode a \\<in> backward_slice S\n\ngoal (2 subgoals):\n 1. sourcenode a \\<in> backward_slice S \\<Longrightarrow>\n    slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>\n 2. sourcenode a \\<notin> backward_slice S \\<Longrightarrow>\n    slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "with \\<open>slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\\<close> \\<open>kind a = (Q)\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\n  kind a = (Q)\\<^sub>\\<surd>\n  sourcenode a \\<in> backward_slice S", "have \"Q = (\\<lambda>s. True)\""], ["proof (prove)\nusing this:\n  slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\n  kind a = (Q)\\<^sub>\\<surd>\n  sourcenode a \\<in> backward_slice S\n\ngoal (1 subgoal):\n 1. Q = (\\<lambda>s. True)", "by(simp add:slice_kind_def Let_def)"], ["proof (state)\nthis:\n  Q = (\\<lambda>s. True)\n\ngoal (2 subgoals):\n 1. sourcenode a \\<in> backward_slice S \\<Longrightarrow>\n    slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>\n 2. sourcenode a \\<notin> backward_slice S \\<Longrightarrow>\n    slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "with det"], ["proof (chain)\npicking this:\n  \\<forall>s.\n     (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n     (Q' s \\<longrightarrow> \\<not> Q s)\n  Q = (\\<lambda>s. True)", "have \"Q' = (\\<lambda>s. False)\""], ["proof (prove)\nusing this:\n  \\<forall>s.\n     (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n     (Q' s \\<longrightarrow> \\<not> Q s)\n  Q = (\\<lambda>s. True)\n\ngoal (1 subgoal):\n 1. Q' = (\\<lambda>s. False)", "by(simp add:fun_eq_iff)"], ["proof (state)\nthis:\n  Q' = (\\<lambda>s. False)\n\ngoal (2 subgoals):\n 1. sourcenode a \\<in> backward_slice S \\<Longrightarrow>\n    slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>\n 2. sourcenode a \\<notin> backward_slice S \\<Longrightarrow>\n    slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "with True \\<open>kind a' = (Q')\\<^sub>\\<surd>\\<close> \\<open>sourcenode a = sourcenode a'\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a \\<in> backward_slice S\n  kind a' = (Q')\\<^sub>\\<surd>\n  sourcenode a = sourcenode a'\n  Q' = (\\<lambda>s. False)", "show ?thesis"], ["proof (prove)\nusing this:\n  sourcenode a \\<in> backward_slice S\n  kind a' = (Q')\\<^sub>\\<surd>\n  sourcenode a = sourcenode a'\n  Q' = (\\<lambda>s. False)\n\ngoal (1 subgoal):\n 1. slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "by(simp add:slice_kind_def Let_def)"], ["proof (state)\nthis:\n  slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. sourcenode a \\<notin> backward_slice S \\<Longrightarrow>\n    slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. sourcenode a \\<notin> backward_slice S \\<Longrightarrow>\n    slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "case False"], ["proof (state)\nthis:\n  sourcenode a \\<notin> backward_slice S\n\ngoal (1 subgoal):\n 1. sourcenode a \\<notin> backward_slice S \\<Longrightarrow>\n    slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "hence \"sourcenode a \\<notin> backward_slice S\""], ["proof (prove)\nusing this:\n  sourcenode a \\<notin> backward_slice S\n\ngoal (1 subgoal):\n 1. sourcenode a \\<notin> backward_slice S", "by simp"], ["proof (state)\nthis:\n  sourcenode a \\<notin> backward_slice S\n\ngoal (1 subgoal):\n 1. sourcenode a \\<notin> backward_slice S \\<Longrightarrow>\n    slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "thus ?thesis"], ["proof (prove)\nusing this:\n  sourcenode a \\<notin> backward_slice S\n\ngoal (1 subgoal):\n 1. slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "proof(cases \"obs (sourcenode a) (backward_slice S) = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>sourcenode a \\<notin> backward_slice S;\n     obs (sourcenode a) (backward_slice S) = {}\\<rbrakk>\n    \\<Longrightarrow> slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>\n 2. \\<lbrakk>sourcenode a \\<notin> backward_slice S;\n     obs (sourcenode a) (backward_slice S) \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "case True"], ["proof (state)\nthis:\n  obs (sourcenode a) (backward_slice S) = {}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>sourcenode a \\<notin> backward_slice S;\n     obs (sourcenode a) (backward_slice S) = {}\\<rbrakk>\n    \\<Longrightarrow> slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>\n 2. \\<lbrakk>sourcenode a \\<notin> backward_slice S;\n     obs (sourcenode a) (backward_slice S) \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "with \\<open>sourcenode a \\<notin> backward_slice S\\<close> \\<open>slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\\<close>\n        \\<open>kind a = (Q)\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a \\<notin> backward_slice S\n  slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\n  kind a = (Q)\\<^sub>\\<surd>\n  obs (sourcenode a) (backward_slice S) = {}", "have target:\"targetnode a = (SOME n'. \\<exists>a'. sourcenode a = sourcenode a' \\<and> \n                                                 valid_edge a' \\<and> targetnode a' = n')\""], ["proof (prove)\nusing this:\n  sourcenode a \\<notin> backward_slice S\n  slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\n  kind a = (Q)\\<^sub>\\<surd>\n  obs (sourcenode a) (backward_slice S) = {}\n\ngoal (1 subgoal):\n 1. targetnode a =\n    (SOME n'.\n        \\<exists>a'.\n           sourcenode a = sourcenode a' \\<and>\n           valid_edge a' \\<and> targetnode a' = n')", "by(auto simp:slice_kind_def Let_def fun_eq_iff split:if_split_asm)"], ["proof (state)\nthis:\n  targetnode a =\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         valid_edge a' \\<and> targetnode a' = n')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>sourcenode a \\<notin> backward_slice S;\n     obs (sourcenode a) (backward_slice S) = {}\\<rbrakk>\n    \\<Longrightarrow> slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>\n 2. \\<lbrakk>sourcenode a \\<notin> backward_slice S;\n     obs (sourcenode a) (backward_slice S) \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "have \"targetnode a' \\<noteq> (SOME n'. \\<exists>a'. sourcenode a = sourcenode a' \\<and> \n                                            valid_edge a' \\<and> targetnode a' = n')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. targetnode a' \\<noteq>\n    (SOME n'.\n        \\<exists>a'.\n           sourcenode a = sourcenode a' \\<and>\n           valid_edge a' \\<and> targetnode a' = n')", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> targetnode a' \\<noteq>\n           (SOME n'.\n               \\<exists>a'.\n                  sourcenode a = sourcenode a' \\<and>\n                  valid_edge a' \\<and> targetnode a' = n') \\<Longrightarrow>\n    False", "assume \"\\<not> targetnode a' \\<noteq> (SOME n'. \\<exists>a'. sourcenode a = sourcenode a' \\<and> \n                                                 valid_edge a' \\<and> targetnode a' = n')\""], ["proof (state)\nthis:\n  \\<not> targetnode a' \\<noteq>\n         (SOME n'.\n             \\<exists>a'.\n                sourcenode a = sourcenode a' \\<and>\n                valid_edge a' \\<and> targetnode a' = n')\n\ngoal (1 subgoal):\n 1. \\<not> targetnode a' \\<noteq>\n           (SOME n'.\n               \\<exists>a'.\n                  sourcenode a = sourcenode a' \\<and>\n                  valid_edge a' \\<and> targetnode a' = n') \\<Longrightarrow>\n    False", "hence \"targetnode a' = (SOME n'. \\<exists>a'. sourcenode a = sourcenode a' \\<and> \n                                              valid_edge a' \\<and> targetnode a' = n')\""], ["proof (prove)\nusing this:\n  \\<not> targetnode a' \\<noteq>\n         (SOME n'.\n             \\<exists>a'.\n                sourcenode a = sourcenode a' \\<and>\n                valid_edge a' \\<and> targetnode a' = n')\n\ngoal (1 subgoal):\n 1. targetnode a' =\n    (SOME n'.\n        \\<exists>a'.\n           sourcenode a = sourcenode a' \\<and>\n           valid_edge a' \\<and> targetnode a' = n')", "by simp"], ["proof (state)\nthis:\n  targetnode a' =\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         valid_edge a' \\<and> targetnode a' = n')\n\ngoal (1 subgoal):\n 1. \\<not> targetnode a' \\<noteq>\n           (SOME n'.\n               \\<exists>a'.\n                  sourcenode a = sourcenode a' \\<and>\n                  valid_edge a' \\<and> targetnode a' = n') \\<Longrightarrow>\n    False", "with ex1 target \\<open>sourcenode a = sourcenode a'\\<close> \\<open>valid_edge a\\<close>\n          \\<open>valid_edge a'\\<close>"], ["proof (chain)\npicking this:\n  \\<exists>!a'.\n     sourcenode a = sourcenode a' \\<and>\n     valid_edge a' \\<and>\n     targetnode a' =\n     (SOME n'.\n         \\<exists>a'.\n            sourcenode a = sourcenode a' \\<and>\n            valid_edge a' \\<and> targetnode a' = n')\n  targetnode a =\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         valid_edge a' \\<and> targetnode a' = n')\n  sourcenode a = sourcenode a'\n  valid_edge a\n  valid_edge a'\n  targetnode a' =\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         valid_edge a' \\<and> targetnode a' = n')", "have \"a = a'\""], ["proof (prove)\nusing this:\n  \\<exists>!a'.\n     sourcenode a = sourcenode a' \\<and>\n     valid_edge a' \\<and>\n     targetnode a' =\n     (SOME n'.\n         \\<exists>a'.\n            sourcenode a = sourcenode a' \\<and>\n            valid_edge a' \\<and> targetnode a' = n')\n  targetnode a =\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         valid_edge a' \\<and> targetnode a' = n')\n  sourcenode a = sourcenode a'\n  valid_edge a\n  valid_edge a'\n  targetnode a' =\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         valid_edge a' \\<and> targetnode a' = n')\n\ngoal (1 subgoal):\n 1. a = a'", "by blast"], ["proof (state)\nthis:\n  a = a'\n\ngoal (1 subgoal):\n 1. \\<not> targetnode a' \\<noteq>\n           (SOME n'.\n               \\<exists>a'.\n                  sourcenode a = sourcenode a' \\<and>\n                  valid_edge a' \\<and> targetnode a' = n') \\<Longrightarrow>\n    False", "with \\<open>targetnode a \\<noteq> targetnode a'\\<close>"], ["proof (chain)\npicking this:\n  targetnode a \\<noteq> targetnode a'\n  a = a'", "show False"], ["proof (prove)\nusing this:\n  targetnode a \\<noteq> targetnode a'\n  a = a'\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  targetnode a' \\<noteq>\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         valid_edge a' \\<and> targetnode a' = n')\n\ngoal (2 subgoals):\n 1. \\<lbrakk>sourcenode a \\<notin> backward_slice S;\n     obs (sourcenode a) (backward_slice S) = {}\\<rbrakk>\n    \\<Longrightarrow> slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>\n 2. \\<lbrakk>sourcenode a \\<notin> backward_slice S;\n     obs (sourcenode a) (backward_slice S) \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "with \\<open>sourcenode a \\<notin> backward_slice S\\<close> True \\<open>kind a' = (Q')\\<^sub>\\<surd>\\<close>\n        \\<open>sourcenode a = sourcenode a'\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a \\<notin> backward_slice S\n  obs (sourcenode a) (backward_slice S) = {}\n  kind a' = (Q')\\<^sub>\\<surd>\n  sourcenode a = sourcenode a'\n  targetnode a' \\<noteq>\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         valid_edge a' \\<and> targetnode a' = n')", "show ?thesis"], ["proof (prove)\nusing this:\n  sourcenode a \\<notin> backward_slice S\n  obs (sourcenode a) (backward_slice S) = {}\n  kind a' = (Q')\\<^sub>\\<surd>\n  sourcenode a = sourcenode a'\n  targetnode a' \\<noteq>\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         valid_edge a' \\<and> targetnode a' = n')\n\ngoal (1 subgoal):\n 1. slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "by(auto simp:slice_kind_def Let_def fun_eq_iff split:if_split_asm)"], ["proof (state)\nthis:\n  slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sourcenode a \\<notin> backward_slice S;\n     obs (sourcenode a) (backward_slice S) \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>sourcenode a \\<notin> backward_slice S;\n     obs (sourcenode a) (backward_slice S) \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "case False"], ["proof (state)\nthis:\n  obs (sourcenode a) (backward_slice S) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sourcenode a \\<notin> backward_slice S;\n     obs (sourcenode a) (backward_slice S) \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "hence \"obs (sourcenode a) (backward_slice S) \\<noteq> {}\""], ["proof (prove)\nusing this:\n  obs (sourcenode a) (backward_slice S) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. obs (sourcenode a) (backward_slice S) \\<noteq> {}", "."], ["proof (state)\nthis:\n  obs (sourcenode a) (backward_slice S) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sourcenode a \\<notin> backward_slice S;\n     obs (sourcenode a) (backward_slice S) \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "then"], ["proof (chain)\npicking this:\n  obs (sourcenode a) (backward_slice S) \\<noteq> {}", "obtain m where \"m \\<in> obs (sourcenode a) (backward_slice S)\""], ["proof (prove)\nusing this:\n  obs (sourcenode a) (backward_slice S) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        m \\<in> obs (sourcenode a) (backward_slice S) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  m \\<in> obs (sourcenode a) (backward_slice S)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sourcenode a \\<notin> backward_slice S;\n     obs (sourcenode a) (backward_slice S) \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "hence \"m = (THE m. m \\<in> obs (sourcenode a) (backward_slice S))\""], ["proof (prove)\nusing this:\n  m \\<in> obs (sourcenode a) (backward_slice S)\n\ngoal (1 subgoal):\n 1. m = (THE m. m \\<in> obs (sourcenode a) (backward_slice S))", "by(auto dest:obs_the_element)"], ["proof (state)\nthis:\n  m = (THE m. m \\<in> obs (sourcenode a) (backward_slice S))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sourcenode a \\<notin> backward_slice S;\n     obs (sourcenode a) (backward_slice S) \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "with \\<open>sourcenode a \\<notin> backward_slice S\\<close> \n        \\<open>obs (sourcenode a) (backward_slice S) \\<noteq> {}\\<close> \n        \\<open>slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\\<close> \\<open>kind a = (Q)\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a \\<notin> backward_slice S\n  obs (sourcenode a) (backward_slice S) \\<noteq> {}\n  slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\n  kind a = (Q)\\<^sub>\\<surd>\n  m = (THE m. m \\<in> obs (sourcenode a) (backward_slice S))", "obtain x x' where \"distance (targetnode a) m x\" \n        \"distance (sourcenode a) m (x + 1)\"\n        and target:\"targetnode a = (SOME n'. \\<exists>a'. sourcenode a = sourcenode a' \\<and>\n                                                 distance (targetnode a') m x \\<and>\n                                                 valid_edge a' \\<and> targetnode a' = n')\""], ["proof (prove)\nusing this:\n  sourcenode a \\<notin> backward_slice S\n  obs (sourcenode a) (backward_slice S) \\<noteq> {}\n  slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\n  kind a = (Q)\\<^sub>\\<surd>\n  m = (THE m. m \\<in> obs (sourcenode a) (backward_slice S))\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>distance (targetnode a) m x;\n         distance (sourcenode a) m (x + 1);\n         targetnode a =\n         (SOME n'.\n             \\<exists>a'.\n                sourcenode a = sourcenode a' \\<and>\n                distance (targetnode a') m x \\<and>\n                valid_edge a' \\<and> targetnode a' = n')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp:slice_kind_def Let_def fun_eq_iff split:if_split_asm)"], ["proof (state)\nthis:\n  distance (targetnode a) m x\n  distance (sourcenode a) m (x + 1)\n  targetnode a =\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') m x \\<and>\n         valid_edge a' \\<and> targetnode a' = n')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sourcenode a \\<notin> backward_slice S;\n     obs (sourcenode a) (backward_slice S) \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "proof(cases \"distance (targetnode a') m x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. distance (targetnode a') m x \\<Longrightarrow>\n    slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>\n 2. \\<not> distance (targetnode a') m x \\<Longrightarrow>\n    slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "case False"], ["proof (state)\nthis:\n  \\<not> distance (targetnode a') m x\n\ngoal (2 subgoals):\n 1. distance (targetnode a') m x \\<Longrightarrow>\n    slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>\n 2. \\<not> distance (targetnode a') m x \\<Longrightarrow>\n    slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "with \\<open>sourcenode a \\<notin> backward_slice S\\<close> \\<open>kind a' = (Q')\\<^sub>\\<surd>\\<close>\n          \\<open>m \\<in> obs (sourcenode a) (backward_slice S)\\<close>\n          \\<open>distance (targetnode a) m x\\<close> \\<open>distance (sourcenode a) m (x + 1)\\<close>\n          \\<open>sourcenode a = sourcenode a'\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a \\<notin> backward_slice S\n  kind a' = (Q')\\<^sub>\\<surd>\n  m \\<in> obs (sourcenode a) (backward_slice S)\n  distance (targetnode a) m x\n  distance (sourcenode a) m (x + 1)\n  sourcenode a = sourcenode a'\n  \\<not> distance (targetnode a') m x", "show ?thesis"], ["proof (prove)\nusing this:\n  sourcenode a \\<notin> backward_slice S\n  kind a' = (Q')\\<^sub>\\<surd>\n  m \\<in> obs (sourcenode a) (backward_slice S)\n  distance (targetnode a) m x\n  distance (sourcenode a) m (x + 1)\n  sourcenode a = sourcenode a'\n  \\<not> distance (targetnode a') m x\n\ngoal (1 subgoal):\n 1. slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "by(fastforce intro:slice_kind_Pred_obs_not_nearer)"], ["proof (state)\nthis:\n  slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. distance (targetnode a') m x \\<Longrightarrow>\n    slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. distance (targetnode a') m x \\<Longrightarrow>\n    slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "case True"], ["proof (state)\nthis:\n  distance (targetnode a') m x\n\ngoal (1 subgoal):\n 1. distance (targetnode a') m x \\<Longrightarrow>\n    slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "from \\<open>valid_edge a\\<close> \\<open>distance (targetnode a) m x\\<close>\n          \\<open>distance (sourcenode a) m (x + 1)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  distance (targetnode a) m x\n  distance (sourcenode a) m (x + 1)", "have ex1:\"\\<exists>!a'. sourcenode a = sourcenode a' \\<and> \n               distance (targetnode a') m x \\<and> valid_edge a' \\<and>\n               targetnode a' = (SOME nx. \\<exists>a'. sourcenode a = sourcenode a' \\<and>\n                                              distance (targetnode a') m x \\<and>\n                                              valid_edge a' \\<and> targetnode a' = nx)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  distance (targetnode a) m x\n  distance (sourcenode a) m (x + 1)\n\ngoal (1 subgoal):\n 1. \\<exists>!a'.\n       sourcenode a = sourcenode a' \\<and>\n       distance (targetnode a') m x \\<and>\n       valid_edge a' \\<and>\n       targetnode a' =\n       (SOME nx.\n           \\<exists>a'.\n              sourcenode a = sourcenode a' \\<and>\n              distance (targetnode a') m x \\<and>\n              valid_edge a' \\<and> targetnode a' = nx)", "by(fastforce intro!:only_one_SOME_dist_edge)"], ["proof (state)\nthis:\n  \\<exists>!a'.\n     sourcenode a = sourcenode a' \\<and>\n     distance (targetnode a') m x \\<and>\n     valid_edge a' \\<and>\n     targetnode a' =\n     (SOME nx.\n         \\<exists>a'.\n            sourcenode a = sourcenode a' \\<and>\n            distance (targetnode a') m x \\<and>\n            valid_edge a' \\<and> targetnode a' = nx)\n\ngoal (1 subgoal):\n 1. distance (targetnode a') m x \\<Longrightarrow>\n    slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "have \"targetnode a' \\<noteq> (SOME n'. \\<exists>a'. sourcenode a = sourcenode a' \\<and> \n                                               distance (targetnode a') m x \\<and>\n                                               valid_edge a' \\<and> targetnode a' = n')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. targetnode a' \\<noteq>\n    (SOME n'.\n        \\<exists>a'.\n           sourcenode a = sourcenode a' \\<and>\n           distance (targetnode a') m x \\<and>\n           valid_edge a' \\<and> targetnode a' = n')", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> targetnode a' \\<noteq>\n           (SOME n'.\n               \\<exists>a'.\n                  sourcenode a = sourcenode a' \\<and>\n                  distance (targetnode a') m x \\<and>\n                  valid_edge a' \\<and> targetnode a' = n') \\<Longrightarrow>\n    False", "assume \"\\<not> targetnode a' \\<noteq> (SOME n'. \\<exists>a'. sourcenode a = sourcenode a' \\<and> \n                                                 distance (targetnode a') m x \\<and>\n                                                 valid_edge a' \\<and> targetnode a' = n')\""], ["proof (state)\nthis:\n  \\<not> targetnode a' \\<noteq>\n         (SOME n'.\n             \\<exists>a'.\n                sourcenode a = sourcenode a' \\<and>\n                distance (targetnode a') m x \\<and>\n                valid_edge a' \\<and> targetnode a' = n')\n\ngoal (1 subgoal):\n 1. \\<not> targetnode a' \\<noteq>\n           (SOME n'.\n               \\<exists>a'.\n                  sourcenode a = sourcenode a' \\<and>\n                  distance (targetnode a') m x \\<and>\n                  valid_edge a' \\<and> targetnode a' = n') \\<Longrightarrow>\n    False", "hence \"targetnode a' = (SOME n'. \\<exists>a'. sourcenode a = sourcenode a' \\<and>\n                                                distance (targetnode a') m x \\<and>\n                                                valid_edge a' \\<and> targetnode a' = n')\""], ["proof (prove)\nusing this:\n  \\<not> targetnode a' \\<noteq>\n         (SOME n'.\n             \\<exists>a'.\n                sourcenode a = sourcenode a' \\<and>\n                distance (targetnode a') m x \\<and>\n                valid_edge a' \\<and> targetnode a' = n')\n\ngoal (1 subgoal):\n 1. targetnode a' =\n    (SOME n'.\n        \\<exists>a'.\n           sourcenode a = sourcenode a' \\<and>\n           distance (targetnode a') m x \\<and>\n           valid_edge a' \\<and> targetnode a' = n')", "by simp"], ["proof (state)\nthis:\n  targetnode a' =\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') m x \\<and>\n         valid_edge a' \\<and> targetnode a' = n')\n\ngoal (1 subgoal):\n 1. \\<not> targetnode a' \\<noteq>\n           (SOME n'.\n               \\<exists>a'.\n                  sourcenode a = sourcenode a' \\<and>\n                  distance (targetnode a') m x \\<and>\n                  valid_edge a' \\<and> targetnode a' = n') \\<Longrightarrow>\n    False", "with ex1 target \\<open>sourcenode a = sourcenode a'\\<close> \n            \\<open>valid_edge a\\<close> \\<open>valid_edge a'\\<close> \n            \\<open>distance (targetnode a) m x\\<close> \\<open>distance (sourcenode a) m (x + 1)\\<close>"], ["proof (chain)\npicking this:\n  \\<exists>!a'.\n     sourcenode a = sourcenode a' \\<and>\n     distance (targetnode a') m x \\<and>\n     valid_edge a' \\<and>\n     targetnode a' =\n     (SOME nx.\n         \\<exists>a'.\n            sourcenode a = sourcenode a' \\<and>\n            distance (targetnode a') m x \\<and>\n            valid_edge a' \\<and> targetnode a' = nx)\n  targetnode a =\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') m x \\<and>\n         valid_edge a' \\<and> targetnode a' = n')\n  sourcenode a = sourcenode a'\n  valid_edge a\n  valid_edge a'\n  distance (targetnode a) m x\n  distance (sourcenode a) m (x + 1)\n  targetnode a' =\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') m x \\<and>\n         valid_edge a' \\<and> targetnode a' = n')", "have \"a = a'\""], ["proof (prove)\nusing this:\n  \\<exists>!a'.\n     sourcenode a = sourcenode a' \\<and>\n     distance (targetnode a') m x \\<and>\n     valid_edge a' \\<and>\n     targetnode a' =\n     (SOME nx.\n         \\<exists>a'.\n            sourcenode a = sourcenode a' \\<and>\n            distance (targetnode a') m x \\<and>\n            valid_edge a' \\<and> targetnode a' = nx)\n  targetnode a =\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') m x \\<and>\n         valid_edge a' \\<and> targetnode a' = n')\n  sourcenode a = sourcenode a'\n  valid_edge a\n  valid_edge a'\n  distance (targetnode a) m x\n  distance (sourcenode a) m (x + 1)\n  targetnode a' =\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') m x \\<and>\n         valid_edge a' \\<and> targetnode a' = n')\n\ngoal (1 subgoal):\n 1. a = a'", "by auto"], ["proof (state)\nthis:\n  a = a'\n\ngoal (1 subgoal):\n 1. \\<not> targetnode a' \\<noteq>\n           (SOME n'.\n               \\<exists>a'.\n                  sourcenode a = sourcenode a' \\<and>\n                  distance (targetnode a') m x \\<and>\n                  valid_edge a' \\<and> targetnode a' = n') \\<Longrightarrow>\n    False", "with \\<open>targetnode a \\<noteq> targetnode a'\\<close>"], ["proof (chain)\npicking this:\n  targetnode a \\<noteq> targetnode a'\n  a = a'", "show False"], ["proof (prove)\nusing this:\n  targetnode a \\<noteq> targetnode a'\n  a = a'\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  targetnode a' \\<noteq>\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') m x \\<and>\n         valid_edge a' \\<and> targetnode a' = n')\n\ngoal (1 subgoal):\n 1. distance (targetnode a') m x \\<Longrightarrow>\n    slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "with \\<open>sourcenode a \\<notin> backward_slice S\\<close> \n          \\<open>kind a' = (Q')\\<^sub>\\<surd>\\<close> \\<open>m \\<in> obs (sourcenode a) (backward_slice S)\\<close>\n          \\<open>distance (targetnode a) m x\\<close> \\<open>distance (sourcenode a) m (x + 1)\\<close>\n          True \\<open>sourcenode a = sourcenode a'\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a \\<notin> backward_slice S\n  kind a' = (Q')\\<^sub>\\<surd>\n  m \\<in> obs (sourcenode a) (backward_slice S)\n  distance (targetnode a) m x\n  distance (sourcenode a) m (x + 1)\n  distance (targetnode a') m x\n  sourcenode a = sourcenode a'\n  targetnode a' \\<noteq>\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') m x \\<and>\n         valid_edge a' \\<and> targetnode a' = n')", "show ?thesis"], ["proof (prove)\nusing this:\n  sourcenode a \\<notin> backward_slice S\n  kind a' = (Q')\\<^sub>\\<surd>\n  m \\<in> obs (sourcenode a) (backward_slice S)\n  distance (targetnode a) m x\n  distance (sourcenode a) m (x + 1)\n  distance (targetnode a') m x\n  sourcenode a = sourcenode a'\n  targetnode a' \\<noteq>\n  (SOME n'.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') m x \\<and>\n         valid_edge a' \\<and> targetnode a' = n')\n\ngoal (1 subgoal):\n 1. slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "by(fastforce intro:slice_kind_Pred_obs_nearer_not_SOME)"], ["proof (state)\nthis:\n  slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma slice_deterministic:\n  assumes \"valid_edge a\" and \"valid_edge a'\"\n  and \"sourcenode a = sourcenode a'\" and \"targetnode a \\<noteq> targetnode a'\"\n  obtains Q Q' where \"slice_kind S a = (Q)\\<^sub>\\<surd>\" and \"slice_kind S a' = (Q')\\<^sub>\\<surd>\"\n  and \"\\<forall>s. (Q s \\<longrightarrow> \\<not> Q' s) \\<and> (Q' s \\<longrightarrow> \\<not> Q s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Q Q'.\n        \\<lbrakk>slice_kind S a = (Q)\\<^sub>\\<surd>;\n         slice_kind S a' = (Q')\\<^sub>\\<surd>;\n         \\<forall>s.\n            (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n            (Q' s \\<longrightarrow> \\<not> Q s)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>Q Q'.\n       slice_kind S a = (Q)\\<^sub>\\<surd> \\<and>\n       slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "from assms"], ["proof (chain)\npicking this:\n  valid_edge a\n  valid_edge a'\n  sourcenode a = sourcenode a'\n  targetnode a \\<noteq> targetnode a'", "obtain Q Q' \n    where \"kind a = (Q)\\<^sub>\\<surd>\" and \"kind a' = (Q')\\<^sub>\\<surd>\" \n    and det:\"\\<forall>s. (Q s \\<longrightarrow> \\<not> Q' s) \\<and> (Q' s \\<longrightarrow> \\<not> Q s)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  valid_edge a'\n  sourcenode a = sourcenode a'\n  targetnode a \\<noteq> targetnode a'\n\ngoal (1 subgoal):\n 1. (\\<And>Q Q'.\n        \\<lbrakk>kind a = (Q)\\<^sub>\\<surd>; kind a' = (Q')\\<^sub>\\<surd>;\n         \\<forall>s.\n            (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n            (Q' s \\<longrightarrow> \\<not> Q s)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto dest:deterministic)"], ["proof (state)\nthis:\n  kind a = (Q)\\<^sub>\\<surd>\n  kind a' = (Q')\\<^sub>\\<surd>\n  \\<forall>s.\n     (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n     (Q' s \\<longrightarrow> \\<not> Q s)\n\ngoal (1 subgoal):\n 1. \\<exists>Q Q'.\n       slice_kind S a = (Q)\\<^sub>\\<surd> \\<and>\n       slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "from \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a", "have ex1:\"\\<exists>!a'. sourcenode a = sourcenode a' \\<and> valid_edge a' \\<and>\n               targetnode a' = (SOME n'. \\<exists>a'. sourcenode a = sourcenode a' \\<and> \n                                              valid_edge a' \\<and> targetnode a' = n')\""], ["proof (prove)\nusing this:\n  valid_edge a\n\ngoal (1 subgoal):\n 1. \\<exists>!a'.\n       sourcenode a = sourcenode a' \\<and>\n       valid_edge a' \\<and>\n       targetnode a' =\n       (SOME n'.\n           \\<exists>a'.\n              sourcenode a = sourcenode a' \\<and>\n              valid_edge a' \\<and> targetnode a' = n')", "by(rule only_one_SOME_edge)"], ["proof (state)\nthis:\n  \\<exists>!a'.\n     sourcenode a = sourcenode a' \\<and>\n     valid_edge a' \\<and>\n     targetnode a' =\n     (SOME n'.\n         \\<exists>a'.\n            sourcenode a = sourcenode a' \\<and>\n            valid_edge a' \\<and> targetnode a' = n')\n\ngoal (1 subgoal):\n 1. \\<exists>Q Q'.\n       slice_kind S a = (Q)\\<^sub>\\<surd> \\<and>\n       slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "show \"\\<exists>Q Q'. slice_kind S a = (Q)\\<^sub>\\<surd> \\<and> slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and> \n                (\\<forall>s. (Q s \\<longrightarrow> \\<not> Q' s) \\<and> (Q' s \\<longrightarrow> \\<not> Q s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Q Q'.\n       slice_kind S a = (Q)\\<^sub>\\<surd> \\<and>\n       slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "proof(cases \"sourcenode a \\<in> backward_slice S\")"], ["proof (state)\ngoal (2 subgoals):\n 1. sourcenode a \\<in> backward_slice S \\<Longrightarrow>\n    \\<exists>Q Q'.\n       slice_kind S a = (Q)\\<^sub>\\<surd> \\<and>\n       slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))\n 2. sourcenode a \\<notin> backward_slice S \\<Longrightarrow>\n    \\<exists>Q Q'.\n       slice_kind S a = (Q)\\<^sub>\\<surd> \\<and>\n       slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "case True"], ["proof (state)\nthis:\n  sourcenode a \\<in> backward_slice S\n\ngoal (2 subgoals):\n 1. sourcenode a \\<in> backward_slice S \\<Longrightarrow>\n    \\<exists>Q Q'.\n       slice_kind S a = (Q)\\<^sub>\\<surd> \\<and>\n       slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))\n 2. sourcenode a \\<notin> backward_slice S \\<Longrightarrow>\n    \\<exists>Q Q'.\n       slice_kind S a = (Q)\\<^sub>\\<surd> \\<and>\n       slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "with \\<open>kind a = (Q)\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  kind a = (Q)\\<^sub>\\<surd>\n  sourcenode a \\<in> backward_slice S", "have \"slice_kind S a = (Q)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  kind a = (Q)\\<^sub>\\<surd>\n  sourcenode a \\<in> backward_slice S\n\ngoal (1 subgoal):\n 1. slice_kind S a = (Q)\\<^sub>\\<surd>", "by(simp add:slice_kind_def Let_def)"], ["proof (state)\nthis:\n  slice_kind S a = (Q)\\<^sub>\\<surd>\n\ngoal (2 subgoals):\n 1. sourcenode a \\<in> backward_slice S \\<Longrightarrow>\n    \\<exists>Q Q'.\n       slice_kind S a = (Q)\\<^sub>\\<surd> \\<and>\n       slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))\n 2. sourcenode a \\<notin> backward_slice S \\<Longrightarrow>\n    \\<exists>Q Q'.\n       slice_kind S a = (Q)\\<^sub>\\<surd> \\<and>\n       slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "from True \\<open>kind a' = (Q')\\<^sub>\\<surd>\\<close> \\<open>sourcenode a = sourcenode a'\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a \\<in> backward_slice S\n  kind a' = (Q')\\<^sub>\\<surd>\n  sourcenode a = sourcenode a'", "have \"slice_kind S a' = (Q')\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  sourcenode a \\<in> backward_slice S\n  kind a' = (Q')\\<^sub>\\<surd>\n  sourcenode a = sourcenode a'\n\ngoal (1 subgoal):\n 1. slice_kind S a' = (Q')\\<^sub>\\<surd>", "by(simp add:slice_kind_def Let_def)"], ["proof (state)\nthis:\n  slice_kind S a' = (Q')\\<^sub>\\<surd>\n\ngoal (2 subgoals):\n 1. sourcenode a \\<in> backward_slice S \\<Longrightarrow>\n    \\<exists>Q Q'.\n       slice_kind S a = (Q)\\<^sub>\\<surd> \\<and>\n       slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))\n 2. sourcenode a \\<notin> backward_slice S \\<Longrightarrow>\n    \\<exists>Q Q'.\n       slice_kind S a = (Q)\\<^sub>\\<surd> \\<and>\n       slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "with \\<open>slice_kind S a = (Q)\\<^sub>\\<surd>\\<close> det"], ["proof (chain)\npicking this:\n  slice_kind S a = (Q)\\<^sub>\\<surd>\n  \\<forall>s.\n     (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n     (Q' s \\<longrightarrow> \\<not> Q s)\n  slice_kind S a' = (Q')\\<^sub>\\<surd>", "show ?thesis"], ["proof (prove)\nusing this:\n  slice_kind S a = (Q)\\<^sub>\\<surd>\n  \\<forall>s.\n     (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n     (Q' s \\<longrightarrow> \\<not> Q s)\n  slice_kind S a' = (Q')\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. \\<exists>Q Q'.\n       slice_kind S a = (Q)\\<^sub>\\<surd> \\<and>\n       slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "by blast"], ["proof (state)\nthis:\n  \\<exists>Q Q'.\n     slice_kind S a = (Q)\\<^sub>\\<surd> \\<and>\n     slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and>\n     (\\<forall>s.\n         (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n         (Q' s \\<longrightarrow> \\<not> Q s))\n\ngoal (1 subgoal):\n 1. sourcenode a \\<notin> backward_slice S \\<Longrightarrow>\n    \\<exists>Q Q'.\n       slice_kind S a = (Q)\\<^sub>\\<surd> \\<and>\n       slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. sourcenode a \\<notin> backward_slice S \\<Longrightarrow>\n    \\<exists>Q Q'.\n       slice_kind S a = (Q)\\<^sub>\\<surd> \\<and>\n       slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "case False"], ["proof (state)\nthis:\n  sourcenode a \\<notin> backward_slice S\n\ngoal (1 subgoal):\n 1. sourcenode a \\<notin> backward_slice S \\<Longrightarrow>\n    \\<exists>Q Q'.\n       slice_kind S a = (Q)\\<^sub>\\<surd> \\<and>\n       slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "with \\<open>kind a = (Q)\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  kind a = (Q)\\<^sub>\\<surd>\n  sourcenode a \\<notin> backward_slice S", "have \"slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd> \\<or> slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  kind a = (Q)\\<^sub>\\<surd>\n  sourcenode a \\<notin> backward_slice S\n\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd> \\<or>\n    slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>", "by(simp add:slice_kind_def Let_def)"], ["proof (state)\nthis:\n  slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd> \\<or>\n  slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. sourcenode a \\<notin> backward_slice S \\<Longrightarrow>\n    \\<exists>Q Q'.\n       slice_kind S a = (Q)\\<^sub>\\<surd> \\<and>\n       slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "thus ?thesis"], ["proof (prove)\nusing this:\n  slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd> \\<or>\n  slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. \\<exists>Q Q'.\n       slice_kind S a = (Q)\\<^sub>\\<surd> \\<and>\n       slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd> \\<Longrightarrow>\n    \\<exists>Q Q'.\n       slice_kind S a = (Q)\\<^sub>\\<surd> \\<and>\n       slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))\n 2. slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd> \\<Longrightarrow>\n    \\<exists>Q Q'.\n       slice_kind S a = (Q)\\<^sub>\\<surd> \\<and>\n       slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "assume true:\"slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\""], ["proof (state)\nthis:\n  slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (2 subgoals):\n 1. slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd> \\<Longrightarrow>\n    \\<exists>Q Q'.\n       slice_kind S a = (Q)\\<^sub>\\<surd> \\<and>\n       slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))\n 2. slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd> \\<Longrightarrow>\n    \\<exists>Q Q'.\n       slice_kind S a = (Q)\\<^sub>\\<surd> \\<and>\n       slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "with \\<open>sourcenode a = sourcenode a'\\<close> \\<open>targetnode a \\<noteq> targetnode a'\\<close>\n        \\<open>valid_edge a\\<close> \\<open>valid_edge a'\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a = sourcenode a'\n  targetnode a \\<noteq> targetnode a'\n  valid_edge a\n  valid_edge a'\n  slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>", "have \"slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  sourcenode a = sourcenode a'\n  targetnode a \\<noteq> targetnode a'\n  valid_edge a\n  valid_edge a'\n  slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "by(rule slice_kind_only_one_True_edge)"], ["proof (state)\nthis:\n  slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal (2 subgoals):\n 1. slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd> \\<Longrightarrow>\n    \\<exists>Q Q'.\n       slice_kind S a = (Q)\\<^sub>\\<surd> \\<and>\n       slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))\n 2. slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd> \\<Longrightarrow>\n    \\<exists>Q Q'.\n       slice_kind S a = (Q)\\<^sub>\\<surd> \\<and>\n       slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "with true"], ["proof (chain)\npicking this:\n  slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\n  slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "show ?thesis"], ["proof (prove)\nusing this:\n  slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\n  slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. \\<exists>Q Q'.\n       slice_kind S a = (Q)\\<^sub>\\<surd> \\<and>\n       slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "by simp"], ["proof (state)\nthis:\n  \\<exists>Q Q'.\n     slice_kind S a = (Q)\\<^sub>\\<surd> \\<and>\n     slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and>\n     (\\<forall>s.\n         (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n         (Q' s \\<longrightarrow> \\<not> Q s))\n\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd> \\<Longrightarrow>\n    \\<exists>Q Q'.\n       slice_kind S a = (Q)\\<^sub>\\<surd> \\<and>\n       slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd> \\<Longrightarrow>\n    \\<exists>Q Q'.\n       slice_kind S a = (Q)\\<^sub>\\<surd> \\<and>\n       slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "assume false:\"slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>\""], ["proof (state)\nthis:\n  slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd> \\<Longrightarrow>\n    \\<exists>Q Q'.\n       slice_kind S a = (Q)\\<^sub>\\<surd> \\<and>\n       slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "from False \\<open>kind a' = (Q')\\<^sub>\\<surd>\\<close> \\<open>sourcenode a = sourcenode a'\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a \\<notin> backward_slice S\n  kind a' = (Q')\\<^sub>\\<surd>\n  sourcenode a = sourcenode a'", "have \"slice_kind S a' = (\\<lambda>s. True)\\<^sub>\\<surd> \\<or> slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  sourcenode a \\<notin> backward_slice S\n  kind a' = (Q')\\<^sub>\\<surd>\n  sourcenode a = sourcenode a'\n\ngoal (1 subgoal):\n 1. slice_kind S a' = (\\<lambda>s. True)\\<^sub>\\<surd> \\<or>\n    slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "by(simp add:slice_kind_def Let_def)"], ["proof (state)\nthis:\n  slice_kind S a' = (\\<lambda>s. True)\\<^sub>\\<surd> \\<or>\n  slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd> \\<Longrightarrow>\n    \\<exists>Q Q'.\n       slice_kind S a = (Q)\\<^sub>\\<surd> \\<and>\n       slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "with false"], ["proof (chain)\npicking this:\n  slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>\n  slice_kind S a' = (\\<lambda>s. True)\\<^sub>\\<surd> \\<or>\n  slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>", "show ?thesis"], ["proof (prove)\nusing this:\n  slice_kind S a = (\\<lambda>s. False)\\<^sub>\\<surd>\n  slice_kind S a' = (\\<lambda>s. True)\\<^sub>\\<surd> \\<or>\n  slice_kind S a' = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. \\<exists>Q Q'.\n       slice_kind S a = (Q)\\<^sub>\\<surd> \\<and>\n       slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "by auto"], ["proof (state)\nthis:\n  \\<exists>Q Q'.\n     slice_kind S a = (Q)\\<^sub>\\<surd> \\<and>\n     slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and>\n     (\\<forall>s.\n         (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n         (Q' s \\<longrightarrow> \\<not> Q s))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>Q Q'.\n     slice_kind S a = (Q)\\<^sub>\\<surd> \\<and>\n     slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and>\n     (\\<forall>s.\n         (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n         (Q' s \\<longrightarrow> \\<not> Q s))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>Q Q'.\n     slice_kind S a = (Q)\\<^sub>\\<surd> \\<and>\n     slice_kind S a' = (Q')\\<^sub>\\<surd> \\<and>\n     (\\<forall>s.\n         (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n         (Q' s \\<longrightarrow> \\<not> Q s))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Observable and silent moves\\<close>"], ["", "inductive silent_move :: \n  \"'node set \\<Rightarrow> ('edge \\<Rightarrow> 'state edge_kind) \\<Rightarrow> 'node \\<Rightarrow> 'state \\<Rightarrow> 'edge \\<Rightarrow> \n  'node \\<Rightarrow> 'state \\<Rightarrow> bool\" (\"_,_ \\<turnstile> '(_,_') -_\\<rightarrow>\\<^sub>\\<tau> '(_,_')\" [51,50,0,0,50,0,0] 51) \n \n  where silent_moveI:\n  \"\\<lbrakk>pred (f a) s; transfer (f a) s = s'; sourcenode a \\<notin> backward_slice S; \n    valid_edge a\\<rbrakk>  \n  \\<Longrightarrow> S,f \\<turnstile> (sourcenode a,s) -a\\<rightarrow>\\<^sub>\\<tau> (targetnode a,s')\""], ["", "inductive silent_moves :: \n  \"'node set \\<Rightarrow> ('edge \\<Rightarrow> 'state edge_kind) \\<Rightarrow> 'node \\<Rightarrow> 'state \\<Rightarrow> 'edge list \\<Rightarrow> \n  'node \\<Rightarrow> 'state \\<Rightarrow> bool\" (\"_,_ \\<turnstile> '(_,_') =_\\<Rightarrow>\\<^sub>\\<tau> '(_,_')\" [51,50,0,0,50,0,0] 51)\n\n  where silent_moves_Nil: \"S,f \\<turnstile> (n,s) =[]\\<Rightarrow>\\<^sub>\\<tau> (n,s)\"\n\n  | silent_moves_Cons:\n  \"\\<lbrakk>S,f \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n',s'); S,f \\<turnstile> (n',s') =as\\<Rightarrow>\\<^sub>\\<tau> (n'',s'')\\<rbrakk> \n  \\<Longrightarrow> S,f \\<turnstile> (n,s) =a#as\\<Rightarrow>\\<^sub>\\<tau> (n'',s'')\""], ["", "lemma silent_moves_obs_slice:\n  \"\\<lbrakk>S,f \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s'); nx \\<in> obs n' (backward_slice S)\\<rbrakk>\n  \\<Longrightarrow> nx \\<in> obs n (backward_slice S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,f \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s');\n     nx \\<in> obs n' (backward_slice S)\\<rbrakk>\n    \\<Longrightarrow> nx \\<in> obs n (backward_slice S)", "proof(induct rule:silent_moves.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>S f n s.\n       nx \\<in> obs n (backward_slice S) \\<Longrightarrow>\n       nx \\<in> obs n (backward_slice S)\n 2. \\<And>S f n s a n' s' as n'' s''.\n       \\<lbrakk>S,f \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n',s');\n        S,f \\<turnstile> (n',s') =as\\<Rightarrow>\\<^sub>\\<tau> (n'',s'');\n        nx \\<in> obs n'' (backward_slice S) \\<Longrightarrow>\n        nx \\<in> obs n' (backward_slice S);\n        nx \\<in> obs n'' (backward_slice S)\\<rbrakk>\n       \\<Longrightarrow> nx \\<in> obs n (backward_slice S)", "case silent_moves_Nil"], ["proof (state)\nthis:\n  nx \\<in> obs n_ (backward_slice S_)\n\ngoal (2 subgoals):\n 1. \\<And>S f n s.\n       nx \\<in> obs n (backward_slice S) \\<Longrightarrow>\n       nx \\<in> obs n (backward_slice S)\n 2. \\<And>S f n s a n' s' as n'' s''.\n       \\<lbrakk>S,f \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n',s');\n        S,f \\<turnstile> (n',s') =as\\<Rightarrow>\\<^sub>\\<tau> (n'',s'');\n        nx \\<in> obs n'' (backward_slice S) \\<Longrightarrow>\n        nx \\<in> obs n' (backward_slice S);\n        nx \\<in> obs n'' (backward_slice S)\\<rbrakk>\n       \\<Longrightarrow> nx \\<in> obs n (backward_slice S)", "thus ?case"], ["proof (prove)\nusing this:\n  nx \\<in> obs n_ (backward_slice S_)\n\ngoal (1 subgoal):\n 1. nx \\<in> obs n_ (backward_slice S_)", "by simp"], ["proof (state)\nthis:\n  nx \\<in> obs n_ (backward_slice S_)\n\ngoal (1 subgoal):\n 1. \\<And>S f n s a n' s' as n'' s''.\n       \\<lbrakk>S,f \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n',s');\n        S,f \\<turnstile> (n',s') =as\\<Rightarrow>\\<^sub>\\<tau> (n'',s'');\n        nx \\<in> obs n'' (backward_slice S) \\<Longrightarrow>\n        nx \\<in> obs n' (backward_slice S);\n        nx \\<in> obs n'' (backward_slice S)\\<rbrakk>\n       \\<Longrightarrow> nx \\<in> obs n (backward_slice S)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S f n s a n' s' as n'' s''.\n       \\<lbrakk>S,f \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n',s');\n        S,f \\<turnstile> (n',s') =as\\<Rightarrow>\\<^sub>\\<tau> (n'',s'');\n        nx \\<in> obs n'' (backward_slice S) \\<Longrightarrow>\n        nx \\<in> obs n' (backward_slice S);\n        nx \\<in> obs n'' (backward_slice S)\\<rbrakk>\n       \\<Longrightarrow> nx \\<in> obs n (backward_slice S)", "case (silent_moves_Cons S f n s a n' s' as n'' s'')"], ["proof (state)\nthis:\n  S,f \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n',s')\n  S,f \\<turnstile> (n',s') =as\\<Rightarrow>\\<^sub>\\<tau> (n'',s'')\n  nx \\<in> obs n'' (backward_slice S) \\<Longrightarrow>\n  nx \\<in> obs n' (backward_slice S)\n  nx \\<in> obs n'' (backward_slice S)\n\ngoal (1 subgoal):\n 1. \\<And>S f n s a n' s' as n'' s''.\n       \\<lbrakk>S,f \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n',s');\n        S,f \\<turnstile> (n',s') =as\\<Rightarrow>\\<^sub>\\<tau> (n'',s'');\n        nx \\<in> obs n'' (backward_slice S) \\<Longrightarrow>\n        nx \\<in> obs n' (backward_slice S);\n        nx \\<in> obs n'' (backward_slice S)\\<rbrakk>\n       \\<Longrightarrow> nx \\<in> obs n (backward_slice S)", "from \\<open>nx \\<in> obs n'' (backward_slice S)\\<close>\n    \\<open>nx \\<in> obs n'' (backward_slice S) \\<Longrightarrow> nx \\<in> obs n' (backward_slice S)\\<close>"], ["proof (chain)\npicking this:\n  nx \\<in> obs n'' (backward_slice S)\n  nx \\<in> obs n'' (backward_slice S) \\<Longrightarrow>\n  nx \\<in> obs n' (backward_slice S)", "have obs:\"nx \\<in> obs n' (backward_slice S)\""], ["proof (prove)\nusing this:\n  nx \\<in> obs n'' (backward_slice S)\n  nx \\<in> obs n'' (backward_slice S) \\<Longrightarrow>\n  nx \\<in> obs n' (backward_slice S)\n\ngoal (1 subgoal):\n 1. nx \\<in> obs n' (backward_slice S)", "by simp"], ["proof (state)\nthis:\n  nx \\<in> obs n' (backward_slice S)\n\ngoal (1 subgoal):\n 1. \\<And>S f n s a n' s' as n'' s''.\n       \\<lbrakk>S,f \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n',s');\n        S,f \\<turnstile> (n',s') =as\\<Rightarrow>\\<^sub>\\<tau> (n'',s'');\n        nx \\<in> obs n'' (backward_slice S) \\<Longrightarrow>\n        nx \\<in> obs n' (backward_slice S);\n        nx \\<in> obs n'' (backward_slice S)\\<rbrakk>\n       \\<Longrightarrow> nx \\<in> obs n (backward_slice S)", "from \\<open>S,f \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n',s')\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n',s')", "have \"n = sourcenode a\" and \"n' = targetnode a\" and \"valid_edge a\" \n    and \"n \\<notin> (backward_slice S)\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n',s')\n\ngoal (1 subgoal):\n 1. (n = sourcenode a &&& n' = targetnode a) &&&\n    valid_edge a &&& n \\<notin> backward_slice S", "by(auto elim:silent_move.cases)"], ["proof (state)\nthis:\n  n = sourcenode a\n  n' = targetnode a\n  valid_edge a\n  n \\<notin> backward_slice S\n\ngoal (1 subgoal):\n 1. \\<And>S f n s a n' s' as n'' s''.\n       \\<lbrakk>S,f \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n',s');\n        S,f \\<turnstile> (n',s') =as\\<Rightarrow>\\<^sub>\\<tau> (n'',s'');\n        nx \\<in> obs n'' (backward_slice S) \\<Longrightarrow>\n        nx \\<in> obs n' (backward_slice S);\n        nx \\<in> obs n'' (backward_slice S)\\<rbrakk>\n       \\<Longrightarrow> nx \\<in> obs n (backward_slice S)", "hence \"obs n' (backward_slice S) \\<subseteq> obs n (backward_slice S)\""], ["proof (prove)\nusing this:\n  n = sourcenode a\n  n' = targetnode a\n  valid_edge a\n  n \\<notin> backward_slice S\n\ngoal (1 subgoal):\n 1. obs n' (backward_slice S) \\<subseteq> obs n (backward_slice S)", "by simp(rule edge_obs_subset,simp+)"], ["proof (state)\nthis:\n  obs n' (backward_slice S) \\<subseteq> obs n (backward_slice S)\n\ngoal (1 subgoal):\n 1. \\<And>S f n s a n' s' as n'' s''.\n       \\<lbrakk>S,f \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n',s');\n        S,f \\<turnstile> (n',s') =as\\<Rightarrow>\\<^sub>\\<tau> (n'',s'');\n        nx \\<in> obs n'' (backward_slice S) \\<Longrightarrow>\n        nx \\<in> obs n' (backward_slice S);\n        nx \\<in> obs n'' (backward_slice S)\\<rbrakk>\n       \\<Longrightarrow> nx \\<in> obs n (backward_slice S)", "with obs"], ["proof (chain)\npicking this:\n  nx \\<in> obs n' (backward_slice S)\n  obs n' (backward_slice S) \\<subseteq> obs n (backward_slice S)", "show ?case"], ["proof (prove)\nusing this:\n  nx \\<in> obs n' (backward_slice S)\n  obs n' (backward_slice S) \\<subseteq> obs n (backward_slice S)\n\ngoal (1 subgoal):\n 1. nx \\<in> obs n (backward_slice S)", "by blast"], ["proof (state)\nthis:\n  nx \\<in> obs n (backward_slice S)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma silent_moves_preds_transfers_path:\n  \"\\<lbrakk>S,f \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s'); valid_node n\\<rbrakk> \n  \\<Longrightarrow> preds (map f as) s \\<and> transfers (map f as) s = s' \\<and> n -as\\<rightarrow>* n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,f \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s');\n     valid_node n\\<rbrakk>\n    \\<Longrightarrow> preds (map f as) s \\<and>\n                      transfers (map f as) s = s' \\<and>\n                      n -as\\<rightarrow>* n'", "proof(induct rule:silent_moves.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>S f n s.\n       valid_node n \\<Longrightarrow>\n       preds (map f []) s \\<and>\n       transfers (map f []) s = s \\<and> n -[]\\<rightarrow>* n\n 2. \\<And>S f n s a n' s' as n'' s''.\n       \\<lbrakk>S,f \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n',s');\n        S,f \\<turnstile> (n',s') =as\\<Rightarrow>\\<^sub>\\<tau> (n'',s'');\n        valid_node n' \\<Longrightarrow>\n        preds (map f as) s' \\<and>\n        transfers (map f as) s' = s'' \\<and> n' -as\\<rightarrow>* n'';\n        valid_node n\\<rbrakk>\n       \\<Longrightarrow> preds (map f (a # as)) s \\<and>\n                         transfers (map f (a # as)) s = s'' \\<and>\n                         n -a # as\\<rightarrow>* n''", "case silent_moves_Nil"], ["proof (state)\nthis:\n  valid_node n_\n\ngoal (2 subgoals):\n 1. \\<And>S f n s.\n       valid_node n \\<Longrightarrow>\n       preds (map f []) s \\<and>\n       transfers (map f []) s = s \\<and> n -[]\\<rightarrow>* n\n 2. \\<And>S f n s a n' s' as n'' s''.\n       \\<lbrakk>S,f \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n',s');\n        S,f \\<turnstile> (n',s') =as\\<Rightarrow>\\<^sub>\\<tau> (n'',s'');\n        valid_node n' \\<Longrightarrow>\n        preds (map f as) s' \\<and>\n        transfers (map f as) s' = s'' \\<and> n' -as\\<rightarrow>* n'';\n        valid_node n\\<rbrakk>\n       \\<Longrightarrow> preds (map f (a # as)) s \\<and>\n                         transfers (map f (a # as)) s = s'' \\<and>\n                         n -a # as\\<rightarrow>* n''", "thus ?case"], ["proof (prove)\nusing this:\n  valid_node n_\n\ngoal (1 subgoal):\n 1. preds (map f_ []) s_ \\<and>\n    transfers (map f_ []) s_ = s_ \\<and> n_ -[]\\<rightarrow>* n_", "by(simp add:path.empty_path)"], ["proof (state)\nthis:\n  preds (map f_ []) s_ \\<and>\n  transfers (map f_ []) s_ = s_ \\<and> n_ -[]\\<rightarrow>* n_\n\ngoal (1 subgoal):\n 1. \\<And>S f n s a n' s' as n'' s''.\n       \\<lbrakk>S,f \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n',s');\n        S,f \\<turnstile> (n',s') =as\\<Rightarrow>\\<^sub>\\<tau> (n'',s'');\n        valid_node n' \\<Longrightarrow>\n        preds (map f as) s' \\<and>\n        transfers (map f as) s' = s'' \\<and> n' -as\\<rightarrow>* n'';\n        valid_node n\\<rbrakk>\n       \\<Longrightarrow> preds (map f (a # as)) s \\<and>\n                         transfers (map f (a # as)) s = s'' \\<and>\n                         n -a # as\\<rightarrow>* n''", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S f n s a n' s' as n'' s''.\n       \\<lbrakk>S,f \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n',s');\n        S,f \\<turnstile> (n',s') =as\\<Rightarrow>\\<^sub>\\<tau> (n'',s'');\n        valid_node n' \\<Longrightarrow>\n        preds (map f as) s' \\<and>\n        transfers (map f as) s' = s'' \\<and> n' -as\\<rightarrow>* n'';\n        valid_node n\\<rbrakk>\n       \\<Longrightarrow> preds (map f (a # as)) s \\<and>\n                         transfers (map f (a # as)) s = s'' \\<and>\n                         n -a # as\\<rightarrow>* n''", "case (silent_moves_Cons S f n s a n' s' as n'' s'')"], ["proof (state)\nthis:\n  S,f \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n',s')\n  S,f \\<turnstile> (n',s') =as\\<Rightarrow>\\<^sub>\\<tau> (n'',s'')\n  valid_node n' \\<Longrightarrow>\n  preds (map f as) s' \\<and>\n  transfers (map f as) s' = s'' \\<and> n' -as\\<rightarrow>* n''\n  valid_node n\n\ngoal (1 subgoal):\n 1. \\<And>S f n s a n' s' as n'' s''.\n       \\<lbrakk>S,f \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n',s');\n        S,f \\<turnstile> (n',s') =as\\<Rightarrow>\\<^sub>\\<tau> (n'',s'');\n        valid_node n' \\<Longrightarrow>\n        preds (map f as) s' \\<and>\n        transfers (map f as) s' = s'' \\<and> n' -as\\<rightarrow>* n'';\n        valid_node n\\<rbrakk>\n       \\<Longrightarrow> preds (map f (a # as)) s \\<and>\n                         transfers (map f (a # as)) s = s'' \\<and>\n                         n -a # as\\<rightarrow>* n''", "note IH = \\<open>valid_node n' \\<Longrightarrow>\n    preds (map f as) s' \\<and> transfers (map f as) s' = s'' \\<and> n' -as\\<rightarrow>* n''\\<close>"], ["proof (state)\nthis:\n  valid_node n' \\<Longrightarrow>\n  preds (map f as) s' \\<and>\n  transfers (map f as) s' = s'' \\<and> n' -as\\<rightarrow>* n''\n\ngoal (1 subgoal):\n 1. \\<And>S f n s a n' s' as n'' s''.\n       \\<lbrakk>S,f \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n',s');\n        S,f \\<turnstile> (n',s') =as\\<Rightarrow>\\<^sub>\\<tau> (n'',s'');\n        valid_node n' \\<Longrightarrow>\n        preds (map f as) s' \\<and>\n        transfers (map f as) s' = s'' \\<and> n' -as\\<rightarrow>* n'';\n        valid_node n\\<rbrakk>\n       \\<Longrightarrow> preds (map f (a # as)) s \\<and>\n                         transfers (map f (a # as)) s = s'' \\<and>\n                         n -a # as\\<rightarrow>* n''", "from \\<open>S,f \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n',s')\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n',s')", "have \"pred (f a) s\" and \"transfer (f a) s = s'\"\n    and \"n = sourcenode a\" and \"n' = targetnode a\" and \"valid_edge a\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n',s')\n\ngoal (1 subgoal):\n 1. (pred (f a) s &&& transfer (f a) s = s') &&&\n    n = sourcenode a &&& n' = targetnode a &&& valid_edge a", "by(auto elim:silent_move.cases)"], ["proof (state)\nthis:\n  pred (f a) s\n  transfer (f a) s = s'\n  n = sourcenode a\n  n' = targetnode a\n  valid_edge a\n\ngoal (1 subgoal):\n 1. \\<And>S f n s a n' s' as n'' s''.\n       \\<lbrakk>S,f \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n',s');\n        S,f \\<turnstile> (n',s') =as\\<Rightarrow>\\<^sub>\\<tau> (n'',s'');\n        valid_node n' \\<Longrightarrow>\n        preds (map f as) s' \\<and>\n        transfers (map f as) s' = s'' \\<and> n' -as\\<rightarrow>* n'';\n        valid_node n\\<rbrakk>\n       \\<Longrightarrow> preds (map f (a # as)) s \\<and>\n                         transfers (map f (a # as)) s = s'' \\<and>\n                         n -a # as\\<rightarrow>* n''", "from \\<open>n' = targetnode a\\<close> \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  n' = targetnode a\n  valid_edge a", "have \"valid_node n'\""], ["proof (prove)\nusing this:\n  n' = targetnode a\n  valid_edge a\n\ngoal (1 subgoal):\n 1. valid_node n'", "by simp"], ["proof (state)\nthis:\n  valid_node n'\n\ngoal (1 subgoal):\n 1. \\<And>S f n s a n' s' as n'' s''.\n       \\<lbrakk>S,f \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n',s');\n        S,f \\<turnstile> (n',s') =as\\<Rightarrow>\\<^sub>\\<tau> (n'',s'');\n        valid_node n' \\<Longrightarrow>\n        preds (map f as) s' \\<and>\n        transfers (map f as) s' = s'' \\<and> n' -as\\<rightarrow>* n'';\n        valid_node n\\<rbrakk>\n       \\<Longrightarrow> preds (map f (a # as)) s \\<and>\n                         transfers (map f (a # as)) s = s'' \\<and>\n                         n -a # as\\<rightarrow>* n''", "from IH[OF this]"], ["proof (chain)\npicking this:\n  preds (map f as) s' \\<and>\n  transfers (map f as) s' = s'' \\<and> n' -as\\<rightarrow>* n''", "have \"preds (map f as) s'\" and \"transfers (map f as) s' = s''\"\n    and \"n' -as\\<rightarrow>* n''\""], ["proof (prove)\nusing this:\n  preds (map f as) s' \\<and>\n  transfers (map f as) s' = s'' \\<and> n' -as\\<rightarrow>* n''\n\ngoal (1 subgoal):\n 1. preds (map f as) s' &&&\n    transfers (map f as) s' = s'' &&& n' -as\\<rightarrow>* n''", "by simp_all"], ["proof (state)\nthis:\n  preds (map f as) s'\n  transfers (map f as) s' = s''\n  n' -as\\<rightarrow>* n''\n\ngoal (1 subgoal):\n 1. \\<And>S f n s a n' s' as n'' s''.\n       \\<lbrakk>S,f \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n',s');\n        S,f \\<turnstile> (n',s') =as\\<Rightarrow>\\<^sub>\\<tau> (n'',s'');\n        valid_node n' \\<Longrightarrow>\n        preds (map f as) s' \\<and>\n        transfers (map f as) s' = s'' \\<and> n' -as\\<rightarrow>* n'';\n        valid_node n\\<rbrakk>\n       \\<Longrightarrow> preds (map f (a # as)) s \\<and>\n                         transfers (map f (a # as)) s = s'' \\<and>\n                         n -a # as\\<rightarrow>* n''", "from \\<open>n = sourcenode a\\<close> \\<open>n' = targetnode a\\<close> \\<open>valid_edge a\\<close> \\<open>n' -as\\<rightarrow>* n''\\<close>"], ["proof (chain)\npicking this:\n  n = sourcenode a\n  n' = targetnode a\n  valid_edge a\n  n' -as\\<rightarrow>* n''", "have \"n -a#as\\<rightarrow>* n''\""], ["proof (prove)\nusing this:\n  n = sourcenode a\n  n' = targetnode a\n  valid_edge a\n  n' -as\\<rightarrow>* n''\n\ngoal (1 subgoal):\n 1. n -a # as\\<rightarrow>* n''", "by(fastforce intro:Cons_path)"], ["proof (state)\nthis:\n  n -a # as\\<rightarrow>* n''\n\ngoal (1 subgoal):\n 1. \\<And>S f n s a n' s' as n'' s''.\n       \\<lbrakk>S,f \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n',s');\n        S,f \\<turnstile> (n',s') =as\\<Rightarrow>\\<^sub>\\<tau> (n'',s'');\n        valid_node n' \\<Longrightarrow>\n        preds (map f as) s' \\<and>\n        transfers (map f as) s' = s'' \\<and> n' -as\\<rightarrow>* n'';\n        valid_node n\\<rbrakk>\n       \\<Longrightarrow> preds (map f (a # as)) s \\<and>\n                         transfers (map f (a # as)) s = s'' \\<and>\n                         n -a # as\\<rightarrow>* n''", "with \\<open>pred (f a) s\\<close> \\<open>preds (map f as) s'\\<close> \\<open>transfer (f a) s = s'\\<close> \n    \\<open>transfers (map f as) s' = s''\\<close>"], ["proof (chain)\npicking this:\n  pred (f a) s\n  preds (map f as) s'\n  transfer (f a) s = s'\n  transfers (map f as) s' = s''\n  n -a # as\\<rightarrow>* n''", "show ?case"], ["proof (prove)\nusing this:\n  pred (f a) s\n  preds (map f as) s'\n  transfer (f a) s = s'\n  transfers (map f as) s' = s''\n  n -a # as\\<rightarrow>* n''\n\ngoal (1 subgoal):\n 1. preds (map f (a # as)) s \\<and>\n    transfers (map f (a # as)) s = s'' \\<and> n -a # as\\<rightarrow>* n''", "by simp"], ["proof (state)\nthis:\n  preds (map f (a # as)) s \\<and>\n  transfers (map f (a # as)) s = s'' \\<and> n -a # as\\<rightarrow>* n''\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma obs_silent_moves:\n  assumes \"obs n (backward_slice S) = {n'}\"\n  obtains as where \"S,slice_kind S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as.\n        S,slice_kind\n           S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as.\n       S,slice_kind\n          S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s)", "from \\<open>obs n (backward_slice S) = {n'}\\<close>"], ["proof (chain)\npicking this:\n  obs n (backward_slice S) = {n'}", "have \"n' \\<in> obs n (backward_slice S)\""], ["proof (prove)\nusing this:\n  obs n (backward_slice S) = {n'}\n\ngoal (1 subgoal):\n 1. n' \\<in> obs n (backward_slice S)", "by simp"], ["proof (state)\nthis:\n  n' \\<in> obs n (backward_slice S)\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       S,slice_kind\n          S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s)", "then"], ["proof (chain)\npicking this:\n  n' \\<in> obs n (backward_slice S)", "obtain as where \"n -as\\<rightarrow>* n'\" \n    and \"\\<forall>nx \\<in> set(sourcenodes as). nx \\<notin> (backward_slice S)\"\n    and \"n' \\<in> (backward_slice S)\""], ["proof (prove)\nusing this:\n  n' \\<in> obs n (backward_slice S)\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        \\<lbrakk>n -as\\<rightarrow>* n';\n         \\<forall>nx\\<in>set (sourcenodes as). nx \\<notin> backward_slice S;\n         n' \\<in> backward_slice S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule obsE)"], ["proof (state)\nthis:\n  n -as\\<rightarrow>* n'\n  \\<forall>nx\\<in>set (sourcenodes as). nx \\<notin> backward_slice S\n  n' \\<in> backward_slice S\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       S,slice_kind\n          S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s)", "from \\<open>n -as\\<rightarrow>* n'\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>* n'", "obtain x where \"distance n n' x\" and \"x \\<le> length as\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>distance n n' x; x \\<le> length as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule every_path_distance)"], ["proof (state)\nthis:\n  distance n n' x\n  x \\<le> length as\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       S,slice_kind\n          S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s)", "from \\<open>distance n n' x\\<close> \\<open>n' \\<in> obs n (backward_slice S)\\<close>"], ["proof (chain)\npicking this:\n  distance n n' x\n  n' \\<in> obs n (backward_slice S)", "show \"\\<exists>as. S,slice_kind S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s)\""], ["proof (prove)\nusing this:\n  distance n n' x\n  n' \\<in> obs n (backward_slice S)\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       S,slice_kind\n          S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s)", "proof(induct x arbitrary:n s rule:nat.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n s.\n       \\<lbrakk>distance n n' 0; n' \\<in> obs n (backward_slice S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s)\n 2. \\<And>nat n s.\n       \\<lbrakk>\\<And>n s.\n                   \\<lbrakk>distance n n' nat;\n                    n' \\<in> obs n (backward_slice S)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s);\n        distance n n' (Suc nat); n' \\<in> obs n (backward_slice S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s)", "fix n s"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n s.\n       \\<lbrakk>distance n n' 0; n' \\<in> obs n (backward_slice S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s)\n 2. \\<And>nat n s.\n       \\<lbrakk>\\<And>n s.\n                   \\<lbrakk>distance n n' nat;\n                    n' \\<in> obs n (backward_slice S)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s);\n        distance n n' (Suc nat); n' \\<in> obs n (backward_slice S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s)", "assume \"distance n n' 0\""], ["proof (state)\nthis:\n  distance n n' 0\n\ngoal (2 subgoals):\n 1. \\<And>n s.\n       \\<lbrakk>distance n n' 0; n' \\<in> obs n (backward_slice S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s)\n 2. \\<And>nat n s.\n       \\<lbrakk>\\<And>n s.\n                   \\<lbrakk>distance n n' nat;\n                    n' \\<in> obs n (backward_slice S)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s);\n        distance n n' (Suc nat); n' \\<in> obs n (backward_slice S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s)", "then"], ["proof (chain)\npicking this:\n  distance n n' 0", "obtain as' where \"n -as'\\<rightarrow>* n'\" and \"length as' = 0\""], ["proof (prove)\nusing this:\n  distance n n' 0\n\ngoal (1 subgoal):\n 1. (\\<And>as'.\n        \\<lbrakk>n -as'\\<rightarrow>* n'; length as' = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto elim:distance.cases)"], ["proof (state)\nthis:\n  n -as'\\<rightarrow>* n'\n  length as' = 0\n\ngoal (2 subgoals):\n 1. \\<And>n s.\n       \\<lbrakk>distance n n' 0; n' \\<in> obs n (backward_slice S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s)\n 2. \\<And>nat n s.\n       \\<lbrakk>\\<And>n s.\n                   \\<lbrakk>distance n n' nat;\n                    n' \\<in> obs n (backward_slice S)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s);\n        distance n n' (Suc nat); n' \\<in> obs n (backward_slice S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s)", "hence \"n -[]\\<rightarrow>* n'\""], ["proof (prove)\nusing this:\n  n -as'\\<rightarrow>* n'\n  length as' = 0\n\ngoal (1 subgoal):\n 1. n -[]\\<rightarrow>* n'", "by(cases as) auto"], ["proof (state)\nthis:\n  n -[]\\<rightarrow>* n'\n\ngoal (2 subgoals):\n 1. \\<And>n s.\n       \\<lbrakk>distance n n' 0; n' \\<in> obs n (backward_slice S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s)\n 2. \\<And>nat n s.\n       \\<lbrakk>\\<And>n s.\n                   \\<lbrakk>distance n n' nat;\n                    n' \\<in> obs n (backward_slice S)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s);\n        distance n n' (Suc nat); n' \\<in> obs n (backward_slice S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s)", "hence \"n = n'\""], ["proof (prove)\nusing this:\n  n -[]\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. n = n'", "by(fastforce elim:path.cases)"], ["proof (state)\nthis:\n  n = n'\n\ngoal (2 subgoals):\n 1. \\<And>n s.\n       \\<lbrakk>distance n n' 0; n' \\<in> obs n (backward_slice S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s)\n 2. \\<And>nat n s.\n       \\<lbrakk>\\<And>n s.\n                   \\<lbrakk>distance n n' nat;\n                    n' \\<in> obs n (backward_slice S)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s);\n        distance n n' (Suc nat); n' \\<in> obs n (backward_slice S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s)", "hence \"S,slice_kind S \\<turnstile> (n,s) =[]\\<Rightarrow>\\<^sub>\\<tau> (n',s)\""], ["proof (prove)\nusing this:\n  n = n'\n\ngoal (1 subgoal):\n 1. S,slice_kind S \\<turnstile> (n,s) =[]\\<Rightarrow>\\<^sub>\\<tau> (n',s)", "by(fastforce intro:silent_moves_Nil)"], ["proof (state)\nthis:\n  S,slice_kind S \\<turnstile> (n,s) =[]\\<Rightarrow>\\<^sub>\\<tau> (n',s)\n\ngoal (2 subgoals):\n 1. \\<And>n s.\n       \\<lbrakk>distance n n' 0; n' \\<in> obs n (backward_slice S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s)\n 2. \\<And>nat n s.\n       \\<lbrakk>\\<And>n s.\n                   \\<lbrakk>distance n n' nat;\n                    n' \\<in> obs n (backward_slice S)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s);\n        distance n n' (Suc nat); n' \\<in> obs n (backward_slice S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s)", "thus \"\\<exists>as. S,slice_kind S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s)\""], ["proof (prove)\nusing this:\n  S,slice_kind S \\<turnstile> (n,s) =[]\\<Rightarrow>\\<^sub>\\<tau> (n',s)\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       S,slice_kind\n          S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s)", "by blast"], ["proof (state)\nthis:\n  \\<exists>as.\n     S,slice_kind S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s)\n\ngoal (1 subgoal):\n 1. \\<And>nat n s.\n       \\<lbrakk>\\<And>n s.\n                   \\<lbrakk>distance n n' nat;\n                    n' \\<in> obs n (backward_slice S)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s);\n        distance n n' (Suc nat); n' \\<in> obs n (backward_slice S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat n s.\n       \\<lbrakk>\\<And>n s.\n                   \\<lbrakk>distance n n' nat;\n                    n' \\<in> obs n (backward_slice S)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s);\n        distance n n' (Suc nat); n' \\<in> obs n (backward_slice S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s)", "fix x n s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat n s.\n       \\<lbrakk>\\<And>n s.\n                   \\<lbrakk>distance n n' nat;\n                    n' \\<in> obs n (backward_slice S)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s);\n        distance n n' (Suc nat); n' \\<in> obs n (backward_slice S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s)", "assume \"distance n n' (Suc x)\" and \"n' \\<in> obs n (backward_slice S)\"\n      and IH:\"\\<And>n s. \\<lbrakk>distance n n' x; n' \\<in> obs n (backward_slice S)\\<rbrakk> \n              \\<Longrightarrow> \\<exists>as. S,slice_kind S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s)\""], ["proof (state)\nthis:\n  distance n n' (Suc x)\n  n' \\<in> obs n (backward_slice S)\n  \\<lbrakk>distance ?n n' x; n' \\<in> obs ?n (backward_slice S)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as.\n                       S,slice_kind\n                          S \\<turnstile> (?n,?s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',?s)\n\ngoal (1 subgoal):\n 1. \\<And>nat n s.\n       \\<lbrakk>\\<And>n s.\n                   \\<lbrakk>distance n n' nat;\n                    n' \\<in> obs n (backward_slice S)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s);\n        distance n n' (Suc nat); n' \\<in> obs n (backward_slice S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s)", "from \\<open>n' \\<in> obs n (backward_slice S)\\<close>"], ["proof (chain)\npicking this:\n  n' \\<in> obs n (backward_slice S)", "have \"valid_node n\""], ["proof (prove)\nusing this:\n  n' \\<in> obs n (backward_slice S)\n\ngoal (1 subgoal):\n 1. valid_node n", "by(rule in_obs_valid)"], ["proof (state)\nthis:\n  valid_node n\n\ngoal (1 subgoal):\n 1. \\<And>nat n s.\n       \\<lbrakk>\\<And>n s.\n                   \\<lbrakk>distance n n' nat;\n                    n' \\<in> obs n (backward_slice S)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s);\n        distance n n' (Suc nat); n' \\<in> obs n (backward_slice S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s)", "with \\<open>distance n n' (Suc x)\\<close>"], ["proof (chain)\npicking this:\n  distance n n' (Suc x)\n  valid_node n", "have \"n \\<noteq> n'\""], ["proof (prove)\nusing this:\n  distance n n' (Suc x)\n  valid_node n\n\ngoal (1 subgoal):\n 1. n \\<noteq> n'", "by(fastforce elim:distance.cases dest:empty_path)"], ["proof (state)\nthis:\n  n \\<noteq> n'\n\ngoal (1 subgoal):\n 1. \\<And>nat n s.\n       \\<lbrakk>\\<And>n s.\n                   \\<lbrakk>distance n n' nat;\n                    n' \\<in> obs n (backward_slice S)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s);\n        distance n n' (Suc nat); n' \\<in> obs n (backward_slice S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s)", "have \"n \\<notin> backward_slice S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<notin> backward_slice S", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<in> backward_slice S \\<Longrightarrow> False", "assume isin:\"n \\<in> backward_slice S\""], ["proof (state)\nthis:\n  n \\<in> backward_slice S\n\ngoal (1 subgoal):\n 1. n \\<in> backward_slice S \\<Longrightarrow> False", "with \\<open>valid_node n\\<close>"], ["proof (chain)\npicking this:\n  valid_node n\n  n \\<in> backward_slice S", "have \"obs n (backward_slice S) = {n}\""], ["proof (prove)\nusing this:\n  valid_node n\n  n \\<in> backward_slice S\n\ngoal (1 subgoal):\n 1. obs n (backward_slice S) = {n}", "by(fastforce intro!:n_in_obs)"], ["proof (state)\nthis:\n  obs n (backward_slice S) = {n}\n\ngoal (1 subgoal):\n 1. n \\<in> backward_slice S \\<Longrightarrow> False", "with \\<open>n' \\<in> obs n (backward_slice S)\\<close> \\<open>n \\<noteq> n'\\<close>"], ["proof (chain)\npicking this:\n  n' \\<in> obs n (backward_slice S)\n  n \\<noteq> n'\n  obs n (backward_slice S) = {n}", "show False"], ["proof (prove)\nusing this:\n  n' \\<in> obs n (backward_slice S)\n  n \\<noteq> n'\n  obs n (backward_slice S) = {n}\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n \\<notin> backward_slice S\n\ngoal (1 subgoal):\n 1. \\<And>nat n s.\n       \\<lbrakk>\\<And>n s.\n                   \\<lbrakk>distance n n' nat;\n                    n' \\<in> obs n (backward_slice S)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s);\n        distance n n' (Suc nat); n' \\<in> obs n (backward_slice S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s)", "from \\<open>distance n n' (Suc x)\\<close>"], ["proof (chain)\npicking this:\n  distance n n' (Suc x)", "obtain a where \"valid_edge a\" \n      and \"n = sourcenode a\" and \"distance (targetnode a) n' x\"\n      and target:\"targetnode a = (SOME nx. \\<exists>a'. sourcenode a = sourcenode a' \\<and> \n                                     distance (targetnode a') n' x \\<and>\n                                     valid_edge a' \\<and> targetnode a' = nx)\""], ["proof (prove)\nusing this:\n  distance n n' (Suc x)\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>valid_edge a; n = sourcenode a;\n         distance (targetnode a) n' x;\n         targetnode a =\n         (SOME nx.\n             \\<exists>a'.\n                sourcenode a = sourcenode a' \\<and>\n                distance (targetnode a') n' x \\<and>\n                valid_edge a' \\<and> targetnode a' = nx)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(erule distance_successor_distance,simp+)"], ["proof (state)\nthis:\n  valid_edge a\n  n = sourcenode a\n  distance (targetnode a) n' x\n  targetnode a =\n  (SOME nx.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') n' x \\<and>\n         valid_edge a' \\<and> targetnode a' = nx)\n\ngoal (1 subgoal):\n 1. \\<And>nat n s.\n       \\<lbrakk>\\<And>n s.\n                   \\<lbrakk>distance n n' nat;\n                    n' \\<in> obs n (backward_slice S)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s);\n        distance n n' (Suc nat); n' \\<in> obs n (backward_slice S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s)", "from \\<open>n' \\<in> obs n (backward_slice S)\\<close>"], ["proof (chain)\npicking this:\n  n' \\<in> obs n (backward_slice S)", "have \"obs n (backward_slice S) = {n'}\""], ["proof (prove)\nusing this:\n  n' \\<in> obs n (backward_slice S)\n\ngoal (1 subgoal):\n 1. obs n (backward_slice S) = {n'}", "by(rule obs_singleton_element)"], ["proof (state)\nthis:\n  obs n (backward_slice S) = {n'}\n\ngoal (1 subgoal):\n 1. \\<And>nat n s.\n       \\<lbrakk>\\<And>n s.\n                   \\<lbrakk>distance n n' nat;\n                    n' \\<in> obs n (backward_slice S)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s);\n        distance n n' (Suc nat); n' \\<in> obs n (backward_slice S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s)", "with \\<open>valid_edge a\\<close> \\<open>n \\<notin> backward_slice S\\<close> \\<open>n = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  n \\<notin> backward_slice S\n  n = sourcenode a\n  obs n (backward_slice S) = {n'}", "have disj:\"obs (targetnode a) (backward_slice S) = {} \\<or> \n               obs (targetnode a) (backward_slice S) = {n'}\""], ["proof (prove)\nusing this:\n  valid_edge a\n  n \\<notin> backward_slice S\n  n = sourcenode a\n  obs n (backward_slice S) = {n'}\n\ngoal (1 subgoal):\n 1. obs (targetnode a) (backward_slice S) = {} \\<or>\n    obs (targetnode a) (backward_slice S) = {n'}", "by -(drule_tac S=\"backward_slice S\" in edge_obs_subset,auto)"], ["proof (state)\nthis:\n  obs (targetnode a) (backward_slice S) = {} \\<or>\n  obs (targetnode a) (backward_slice S) = {n'}\n\ngoal (1 subgoal):\n 1. \\<And>nat n s.\n       \\<lbrakk>\\<And>n s.\n                   \\<lbrakk>distance n n' nat;\n                    n' \\<in> obs n (backward_slice S)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s);\n        distance n n' (Suc nat); n' \\<in> obs n (backward_slice S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s)", "from \\<open>distance (targetnode a) n' x\\<close>"], ["proof (chain)\npicking this:\n  distance (targetnode a) n' x", "obtain asx where \"targetnode a -asx\\<rightarrow>* n'\" \n      and \"length asx = x\" and \"\\<forall>as'. targetnode a -as'\\<rightarrow>* n' \\<longrightarrow> x \\<le> length as'\""], ["proof (prove)\nusing this:\n  distance (targetnode a) n' x\n\ngoal (1 subgoal):\n 1. (\\<And>asx.\n        \\<lbrakk>targetnode a -asx\\<rightarrow>* n'; length asx = x;\n         \\<forall>as'.\n            targetnode a -as'\\<rightarrow>* n' \\<longrightarrow>\n            x \\<le> length as'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto elim:distance.cases)"], ["proof (state)\nthis:\n  targetnode a -asx\\<rightarrow>* n'\n  length asx = x\n  \\<forall>as'.\n     targetnode a -as'\\<rightarrow>* n' \\<longrightarrow> x \\<le> length as'\n\ngoal (1 subgoal):\n 1. \\<And>nat n s.\n       \\<lbrakk>\\<And>n s.\n                   \\<lbrakk>distance n n' nat;\n                    n' \\<in> obs n (backward_slice S)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s);\n        distance n n' (Suc nat); n' \\<in> obs n (backward_slice S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s)", "from \\<open>targetnode a -asx\\<rightarrow>* n'\\<close> \\<open>n' \\<in> (backward_slice S)\\<close>"], ["proof (chain)\npicking this:\n  targetnode a -asx\\<rightarrow>* n'\n  n' \\<in> backward_slice S", "obtain m where \"\\<exists>m. m \\<in> obs (targetnode a) (backward_slice S)\""], ["proof (prove)\nusing this:\n  targetnode a -asx\\<rightarrow>* n'\n  n' \\<in> backward_slice S\n\ngoal (1 subgoal):\n 1. (\\<exists>m.\n        m \\<in> obs (targetnode a) (backward_slice S) \\<Longrightarrow>\n     thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:path_ex_obs)"], ["proof (state)\nthis:\n  \\<exists>m. m \\<in> obs (targetnode a) (backward_slice S)\n\ngoal (1 subgoal):\n 1. \\<And>nat n s.\n       \\<lbrakk>\\<And>n s.\n                   \\<lbrakk>distance n n' nat;\n                    n' \\<in> obs n (backward_slice S)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s);\n        distance n n' (Suc nat); n' \\<in> obs n (backward_slice S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s)", "with disj"], ["proof (chain)\npicking this:\n  obs (targetnode a) (backward_slice S) = {} \\<or>\n  obs (targetnode a) (backward_slice S) = {n'}\n  \\<exists>m. m \\<in> obs (targetnode a) (backward_slice S)", "have \"n' \\<in> obs (targetnode a) (backward_slice S)\""], ["proof (prove)\nusing this:\n  obs (targetnode a) (backward_slice S) = {} \\<or>\n  obs (targetnode a) (backward_slice S) = {n'}\n  \\<exists>m. m \\<in> obs (targetnode a) (backward_slice S)\n\ngoal (1 subgoal):\n 1. n' \\<in> obs (targetnode a) (backward_slice S)", "by fastforce"], ["proof (state)\nthis:\n  n' \\<in> obs (targetnode a) (backward_slice S)\n\ngoal (1 subgoal):\n 1. \\<And>nat n s.\n       \\<lbrakk>\\<And>n s.\n                   \\<lbrakk>distance n n' nat;\n                    n' \\<in> obs n (backward_slice S)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s);\n        distance n n' (Suc nat); n' \\<in> obs n (backward_slice S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s)", "from IH[OF \\<open>distance (targetnode a) n' x\\<close> this,of \"transfer (slice_kind S a) s\"]"], ["proof (chain)\npicking this:\n  \\<exists>as.\n     S,slice_kind\n        S \\<turnstile> (targetnode\n                         a,transfer (slice_kind S a)\n                            s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',transfer\n                            (slice_kind S a) s)", "obtain asx' where \n    moves:\"S,slice_kind S \\<turnstile> (targetnode a,transfer (slice_kind S a) s) =asx'\\<Rightarrow>\\<^sub>\\<tau> \n                               (n',transfer (slice_kind S a) s)\""], ["proof (prove)\nusing this:\n  \\<exists>as.\n     S,slice_kind\n        S \\<turnstile> (targetnode\n                         a,transfer (slice_kind S a)\n                            s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',transfer\n                            (slice_kind S a) s)\n\ngoal (1 subgoal):\n 1. (\\<And>asx'.\n        S,slice_kind\n           S \\<turnstile> (targetnode\n                            a,transfer (slice_kind S a)\n                               s) =asx'\\<Rightarrow>\\<^sub>\\<tau> (n',transfer\n                                 (slice_kind S a) s) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  S,slice_kind\n     S \\<turnstile> (targetnode\n                      a,transfer (slice_kind S a)\n                         s) =asx'\\<Rightarrow>\\<^sub>\\<tau> (n',transfer\n                           (slice_kind S a) s)\n\ngoal (1 subgoal):\n 1. \\<And>nat n s.\n       \\<lbrakk>\\<And>n s.\n                   \\<lbrakk>distance n n' nat;\n                    n' \\<in> obs n (backward_slice S)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s);\n        distance n n' (Suc nat); n' \\<in> obs n (backward_slice S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s)", "have \"pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s", "proof(cases \"kind a\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       kind a = \\<Up>x1 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n 2. \\<And>x2.\n       kind a = (x2)\\<^sub>\\<surd> \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s", "case (Update f)"], ["proof (state)\nthis:\n  kind a = \\<Up>f\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       kind a = \\<Up>x1 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n 2. \\<And>x2.\n       kind a = (x2)\\<^sub>\\<surd> \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s", "with \\<open>n \\<notin> backward_slice S\\<close> \\<open>n = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  n \\<notin> backward_slice S\n  n = sourcenode a\n  kind a = \\<Up>f", "have \"slice_kind S a = \\<Up>id\""], ["proof (prove)\nusing this:\n  n \\<notin> backward_slice S\n  n = sourcenode a\n  kind a = \\<Up>f\n\ngoal (1 subgoal):\n 1. slice_kind S a = \\<Up>id", "by(fastforce intro:slice_kind_Upd)"], ["proof (state)\nthis:\n  slice_kind S a = \\<Up>id\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       kind a = \\<Up>x1 \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n 2. \\<And>x2.\n       kind a = (x2)\\<^sub>\\<surd> \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s", "thus ?thesis"], ["proof (prove)\nusing this:\n  slice_kind S a = \\<Up>id\n\ngoal (1 subgoal):\n 1. pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s", "by simp"], ["proof (state)\nthis:\n  pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       kind a = (x2)\\<^sub>\\<surd> \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       kind a = (x2)\\<^sub>\\<surd> \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s", "case (Predicate Q)"], ["proof (state)\nthis:\n  kind a = (Q)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       kind a = (x2)\\<^sub>\\<surd> \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s", "with \\<open>n \\<notin> backward_slice S\\<close> \\<open>n = sourcenode a\\<close>\n        \\<open>n' \\<in> obs n (backward_slice S)\\<close> \\<open>distance (targetnode a) n' x\\<close>\n        \\<open>distance n n' (Suc x)\\<close> target"], ["proof (chain)\npicking this:\n  n \\<notin> backward_slice S\n  n = sourcenode a\n  n' \\<in> obs n (backward_slice S)\n  distance (targetnode a) n' x\n  distance n n' (Suc x)\n  targetnode a =\n  (SOME nx.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') n' x \\<and>\n         valid_edge a' \\<and> targetnode a' = nx)\n  kind a = (Q)\\<^sub>\\<surd>", "have \"slice_kind S a =  (\\<lambda>s. True)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  n \\<notin> backward_slice S\n  n = sourcenode a\n  n' \\<in> obs n (backward_slice S)\n  distance (targetnode a) n' x\n  distance n n' (Suc x)\n  targetnode a =\n  (SOME nx.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') n' x \\<and>\n         valid_edge a' \\<and> targetnode a' = nx)\n  kind a = (Q)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>", "by(fastforce intro:slice_kind_Pred_obs_nearer_SOME)"], ["proof (state)\nthis:\n  slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       kind a = (x2)\\<^sub>\\<surd> \\<Longrightarrow>\n       pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s", "thus ?thesis"], ["proof (prove)\nusing this:\n  slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s", "by simp"], ["proof (state)\nthis:\n  pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n\ngoal (1 subgoal):\n 1. \\<And>nat n s.\n       \\<lbrakk>\\<And>n s.\n                   \\<lbrakk>distance n n' nat;\n                    n' \\<in> obs n (backward_slice S)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s);\n        distance n n' (Suc nat); n' \\<in> obs n (backward_slice S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s)", "hence \"pred (slice_kind S a) s\" and \"transfer (slice_kind S a) s = s\""], ["proof (prove)\nusing this:\n  pred (slice_kind S a) s \\<and> transfer (slice_kind S a) s = s\n\ngoal (1 subgoal):\n 1. pred (slice_kind S a) s &&& transfer (slice_kind S a) s = s", "by simp_all"], ["proof (state)\nthis:\n  pred (slice_kind S a) s\n  transfer (slice_kind S a) s = s\n\ngoal (1 subgoal):\n 1. \\<And>nat n s.\n       \\<lbrakk>\\<And>n s.\n                   \\<lbrakk>distance n n' nat;\n                    n' \\<in> obs n (backward_slice S)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s);\n        distance n n' (Suc nat); n' \\<in> obs n (backward_slice S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s)", "with \\<open>n \\<notin> backward_slice S\\<close> \\<open>n = sourcenode a\\<close> \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  n \\<notin> backward_slice S\n  n = sourcenode a\n  valid_edge a\n  pred (slice_kind S a) s\n  transfer (slice_kind S a) s = s", "have \"S,slice_kind S \\<turnstile> (sourcenode a,s) -a\\<rightarrow>\\<^sub>\\<tau> \n                             (targetnode a,transfer (slice_kind S a) s)\""], ["proof (prove)\nusing this:\n  n \\<notin> backward_slice S\n  n = sourcenode a\n  valid_edge a\n  pred (slice_kind S a) s\n  transfer (slice_kind S a) s = s\n\ngoal (1 subgoal):\n 1. S,slice_kind\n       S \\<turnstile> (sourcenode\n                        a,s) -a\\<rightarrow>\\<^sub>\\<tau> (targetnode\n                      a,transfer (slice_kind S a) s)", "by(fastforce intro:silent_moveI)"], ["proof (state)\nthis:\n  S,slice_kind\n     S \\<turnstile> (sourcenode\n                      a,s) -a\\<rightarrow>\\<^sub>\\<tau> (targetnode\n                    a,transfer (slice_kind S a) s)\n\ngoal (1 subgoal):\n 1. \\<And>nat n s.\n       \\<lbrakk>\\<And>n s.\n                   \\<lbrakk>distance n n' nat;\n                    n' \\<in> obs n (backward_slice S)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s);\n        distance n n' (Suc nat); n' \\<in> obs n (backward_slice S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s)", "with moves \\<open>transfer (slice_kind S a) s = s\\<close> \\<open>n = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  S,slice_kind\n     S \\<turnstile> (targetnode\n                      a,transfer (slice_kind S a)\n                         s) =asx'\\<Rightarrow>\\<^sub>\\<tau> (n',transfer\n                           (slice_kind S a) s)\n  transfer (slice_kind S a) s = s\n  n = sourcenode a\n  S,slice_kind\n     S \\<turnstile> (sourcenode\n                      a,s) -a\\<rightarrow>\\<^sub>\\<tau> (targetnode\n                    a,transfer (slice_kind S a) s)", "have \"S,slice_kind S \\<turnstile> (n,s) =a#asx'\\<Rightarrow>\\<^sub>\\<tau> (n',s)\""], ["proof (prove)\nusing this:\n  S,slice_kind\n     S \\<turnstile> (targetnode\n                      a,transfer (slice_kind S a)\n                         s) =asx'\\<Rightarrow>\\<^sub>\\<tau> (n',transfer\n                           (slice_kind S a) s)\n  transfer (slice_kind S a) s = s\n  n = sourcenode a\n  S,slice_kind\n     S \\<turnstile> (sourcenode\n                      a,s) -a\\<rightarrow>\\<^sub>\\<tau> (targetnode\n                    a,transfer (slice_kind S a) s)\n\ngoal (1 subgoal):\n 1. S,slice_kind\n       S \\<turnstile> (n,s) =a # asx'\\<Rightarrow>\\<^sub>\\<tau> (n',s)", "by(fastforce intro:silent_moves_Cons)"], ["proof (state)\nthis:\n  S,slice_kind\n     S \\<turnstile> (n,s) =a # asx'\\<Rightarrow>\\<^sub>\\<tau> (n',s)\n\ngoal (1 subgoal):\n 1. \\<And>nat n s.\n       \\<lbrakk>\\<And>n s.\n                   \\<lbrakk>distance n n' nat;\n                    n' \\<in> obs n (backward_slice S)\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as.\n  S,slice_kind S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s);\n        distance n n' (Suc nat); n' \\<in> obs n (backward_slice S)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as.\n                            S,slice_kind\n                               S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s)", "thus \"\\<exists>as. S,slice_kind S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s)\""], ["proof (prove)\nusing this:\n  S,slice_kind\n     S \\<turnstile> (n,s) =a # asx'\\<Rightarrow>\\<^sub>\\<tau> (n',s)\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       S,slice_kind\n          S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s)", "by blast"], ["proof (state)\nthis:\n  \\<exists>as.\n     S,slice_kind S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as.\n     S,slice_kind S \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s)\n\ngoal:\nNo subgoals!", "qed"], ["", "inductive observable_move ::\n  \"'node set \\<Rightarrow> ('edge \\<Rightarrow> 'state edge_kind) \\<Rightarrow> 'node \\<Rightarrow> 'state \\<Rightarrow> 'edge \\<Rightarrow> \n  'node \\<Rightarrow> 'state \\<Rightarrow> bool\" (\"_,_ \\<turnstile> '(_,_') -_\\<rightarrow> '(_,_')\" [51,50,0,0,50,0,0] 51) \n \n  where observable_moveI:\n  \"\\<lbrakk>pred (f a) s; transfer (f a) s = s'; sourcenode a \\<in> backward_slice S; \n    valid_edge a\\<rbrakk>  \n  \\<Longrightarrow> S,f \\<turnstile> (sourcenode a,s) -a\\<rightarrow> (targetnode a,s')\""], ["", "inductive observable_moves :: \n  \"'node set \\<Rightarrow> ('edge \\<Rightarrow> 'state edge_kind) \\<Rightarrow> 'node \\<Rightarrow> 'state \\<Rightarrow> 'edge list \\<Rightarrow> \n  'node \\<Rightarrow> 'state \\<Rightarrow> bool\" (\"_,_ \\<turnstile> '(_,_') =_\\<Rightarrow> '(_,_')\" [51,50,0,0,50,0,0] 51) \n\n  where observable_moves_snoc:\n  \"\\<lbrakk>S,f \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s'); S,f \\<turnstile> (n',s') -a\\<rightarrow> (n'',s'')\\<rbrakk> \n  \\<Longrightarrow> S,f \\<turnstile> (n,s) =as@[a]\\<Rightarrow> (n'',s'')\""], ["", "lemma observable_move_notempty:\n  \"\\<lbrakk>S,f \\<turnstile> (n,s) =as\\<Rightarrow> (n',s'); as = []\\<rbrakk> \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,f \\<turnstile> (n,s) =as\\<Rightarrow> (n',s');\n     as = []\\<rbrakk>\n    \\<Longrightarrow> False", "by(induct rule:observable_moves.induct,simp)"], ["", "lemma silent_move_observable_moves:\n  \"\\<lbrakk>S,f \\<turnstile> (n'',s'') =as\\<Rightarrow> (n',s'); S,f \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n'',s'')\\<rbrakk>\n  \\<Longrightarrow> S,f \\<turnstile> (n,s) =a#as\\<Rightarrow> (n',s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,f \\<turnstile> (n'',s'') =as\\<Rightarrow> (n',s');\n     S,f \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n'',s'')\\<rbrakk>\n    \\<Longrightarrow> S,f \\<turnstile> (n,s) =a # as\\<Rightarrow> (n',s')", "proof(induct rule:observable_moves.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S f na sa as n' s' aa n'' s''.\n       \\<lbrakk>S,f \\<turnstile> (na,sa) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s');\n        S,f \\<turnstile> (n',s') -aa\\<rightarrow> (n'',s'');\n        S,f \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (na,sa)\\<rbrakk>\n       \\<Longrightarrow> S,f \\<turnstile> (n,s) =a #\n           as @ [aa]\\<Rightarrow> (n'',s'')", "case (observable_moves_snoc S f nx sx as n' s' a' n'' s'')"], ["proof (state)\nthis:\n  S,f \\<turnstile> (nx,sx) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s')\n  S,f \\<turnstile> (n',s') -a'\\<rightarrow> (n'',s'')\n  S,f \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (nx,sx)\n\ngoal (1 subgoal):\n 1. \\<And>S f na sa as n' s' aa n'' s''.\n       \\<lbrakk>S,f \\<turnstile> (na,sa) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s');\n        S,f \\<turnstile> (n',s') -aa\\<rightarrow> (n'',s'');\n        S,f \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (na,sa)\\<rbrakk>\n       \\<Longrightarrow> S,f \\<turnstile> (n,s) =a #\n           as @ [aa]\\<Rightarrow> (n'',s'')", "from \\<open>S,f \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (nx,sx)\\<close> \\<open>S,f \\<turnstile> (nx,sx) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s')\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (nx,sx)\n  S,f \\<turnstile> (nx,sx) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s')", "have \"S,f \\<turnstile> (n,s) =a#as\\<Rightarrow>\\<^sub>\\<tau> (n',s')\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (nx,sx)\n  S,f \\<turnstile> (nx,sx) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s')\n\ngoal (1 subgoal):\n 1. S,f \\<turnstile> (n,s) =a # as\\<Rightarrow>\\<^sub>\\<tau> (n',s')", "by(rule silent_moves_Cons)"], ["proof (state)\nthis:\n  S,f \\<turnstile> (n,s) =a # as\\<Rightarrow>\\<^sub>\\<tau> (n',s')\n\ngoal (1 subgoal):\n 1. \\<And>S f na sa as n' s' aa n'' s''.\n       \\<lbrakk>S,f \\<turnstile> (na,sa) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s');\n        S,f \\<turnstile> (n',s') -aa\\<rightarrow> (n'',s'');\n        S,f \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (na,sa)\\<rbrakk>\n       \\<Longrightarrow> S,f \\<turnstile> (n,s) =a #\n           as @ [aa]\\<Rightarrow> (n'',s'')", "with \\<open>S,f \\<turnstile> (n',s') -a'\\<rightarrow> (n'',s'')\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (n',s') -a'\\<rightarrow> (n'',s'')\n  S,f \\<turnstile> (n,s) =a # as\\<Rightarrow>\\<^sub>\\<tau> (n',s')", "have \"S,f \\<turnstile> (n,s) =(a#as)@[a']\\<Rightarrow> (n'',s'')\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (n',s') -a'\\<rightarrow> (n'',s'')\n  S,f \\<turnstile> (n,s) =a # as\\<Rightarrow>\\<^sub>\\<tau> (n',s')\n\ngoal (1 subgoal):\n 1. S,f \\<turnstile> (n,s) =(a # as) @ [a']\\<Rightarrow> (n'',s'')", "by -(rule observable_moves.observable_moves_snoc)"], ["proof (state)\nthis:\n  S,f \\<turnstile> (n,s) =(a # as) @ [a']\\<Rightarrow> (n'',s'')\n\ngoal (1 subgoal):\n 1. \\<And>S f na sa as n' s' aa n'' s''.\n       \\<lbrakk>S,f \\<turnstile> (na,sa) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s');\n        S,f \\<turnstile> (n',s') -aa\\<rightarrow> (n'',s'');\n        S,f \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (na,sa)\\<rbrakk>\n       \\<Longrightarrow> S,f \\<turnstile> (n,s) =a #\n           as @ [aa]\\<Rightarrow> (n'',s'')", "thus ?case"], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (n,s) =(a # as) @ [a']\\<Rightarrow> (n'',s'')\n\ngoal (1 subgoal):\n 1. S,f \\<turnstile> (n,s) =a # as @ [a']\\<Rightarrow> (n'',s'')", "by simp"], ["proof (state)\nthis:\n  S,f \\<turnstile> (n,s) =a # as @ [a']\\<Rightarrow> (n'',s'')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma observable_moves_preds_transfers_path:\n  \"S,f \\<turnstile> (n,s) =as\\<Rightarrow> (n',s')\n  \\<Longrightarrow> preds (map f as) s \\<and> transfers (map f as) s = s' \\<and> n -as\\<rightarrow>* n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S,f \\<turnstile> (n,s) =as\\<Rightarrow> (n',s') \\<Longrightarrow>\n    preds (map f as) s \\<and>\n    transfers (map f as) s = s' \\<and> n -as\\<rightarrow>* n'", "proof(induct rule:observable_moves.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S f n s as n' s' a n'' s''.\n       \\<lbrakk>S,f \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s');\n        S,f \\<turnstile> (n',s') -a\\<rightarrow> (n'',s'')\\<rbrakk>\n       \\<Longrightarrow> preds (map f (as @ [a])) s \\<and>\n                         transfers (map f (as @ [a])) s = s'' \\<and>\n                         n -as @ [a]\\<rightarrow>* n''", "case (observable_moves_snoc S f n s as n' s' a n'' s'')"], ["proof (state)\nthis:\n  S,f \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s')\n  S,f \\<turnstile> (n',s') -a\\<rightarrow> (n'',s'')\n\ngoal (1 subgoal):\n 1. \\<And>S f n s as n' s' a n'' s''.\n       \\<lbrakk>S,f \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s');\n        S,f \\<turnstile> (n',s') -a\\<rightarrow> (n'',s'')\\<rbrakk>\n       \\<Longrightarrow> preds (map f (as @ [a])) s \\<and>\n                         transfers (map f (as @ [a])) s = s'' \\<and>\n                         n -as @ [a]\\<rightarrow>* n''", "have \"valid_node n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_node n", "proof(cases as)"], ["proof (state)\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow> valid_node n\n 2. \\<And>a list. as = a # list \\<Longrightarrow> valid_node n", "case Nil"], ["proof (state)\nthis:\n  as = []\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow> valid_node n\n 2. \\<And>a list. as = a # list \\<Longrightarrow> valid_node n", "with \\<open>S,f \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s')\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s')\n  as = []", "have \"n = n'\" and \"s = s'\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s')\n  as = []\n\ngoal (1 subgoal):\n 1. n = n' &&& s = s'", "by(auto elim:silent_moves.cases)"], ["proof (state)\nthis:\n  n = n'\n  s = s'\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow> valid_node n\n 2. \\<And>a list. as = a # list \\<Longrightarrow> valid_node n", "with \\<open>S,f \\<turnstile> (n',s') -a\\<rightarrow> (n'',s'')\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (n',s') -a\\<rightarrow> (n'',s'')\n  n = n'\n  s = s'", "show ?thesis"], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (n',s') -a\\<rightarrow> (n'',s'')\n  n = n'\n  s = s'\n\ngoal (1 subgoal):\n 1. valid_node n", "by(fastforce elim:observable_move.cases)"], ["proof (state)\nthis:\n  valid_node n\n\ngoal (1 subgoal):\n 1. \\<And>a list. as = a # list \\<Longrightarrow> valid_node n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list. as = a # list \\<Longrightarrow> valid_node n", "case (Cons a' as')"], ["proof (state)\nthis:\n  as = a' # as'\n\ngoal (1 subgoal):\n 1. \\<And>a list. as = a # list \\<Longrightarrow> valid_node n", "with \\<open>S,f \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s')\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s')\n  as = a' # as'", "show ?thesis"], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s')\n  as = a' # as'\n\ngoal (1 subgoal):\n 1. valid_node n", "by(fastforce elim:silent_moves.cases silent_move.cases)"], ["proof (state)\nthis:\n  valid_node n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  valid_node n\n\ngoal (1 subgoal):\n 1. \\<And>S f n s as n' s' a n'' s''.\n       \\<lbrakk>S,f \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s');\n        S,f \\<turnstile> (n',s') -a\\<rightarrow> (n'',s'')\\<rbrakk>\n       \\<Longrightarrow> preds (map f (as @ [a])) s \\<and>\n                         transfers (map f (as @ [a])) s = s'' \\<and>\n                         n -as @ [a]\\<rightarrow>* n''", "with \\<open>S,f \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s')\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s')\n  valid_node n", "have \"preds (map f as) s\" and \"transfers (map f as) s = s'\"\n    and \"n -as\\<rightarrow>* n'\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s')\n  valid_node n\n\ngoal (1 subgoal):\n 1. preds (map f as) s &&&\n    transfers (map f as) s = s' &&& n -as\\<rightarrow>* n'", "by(auto dest:silent_moves_preds_transfers_path)"], ["proof (state)\nthis:\n  preds (map f as) s\n  transfers (map f as) s = s'\n  n -as\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. \\<And>S f n s as n' s' a n'' s''.\n       \\<lbrakk>S,f \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s');\n        S,f \\<turnstile> (n',s') -a\\<rightarrow> (n'',s'')\\<rbrakk>\n       \\<Longrightarrow> preds (map f (as @ [a])) s \\<and>\n                         transfers (map f (as @ [a])) s = s'' \\<and>\n                         n -as @ [a]\\<rightarrow>* n''", "from \\<open>S,f \\<turnstile> (n',s') -a\\<rightarrow> (n'',s'')\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (n',s') -a\\<rightarrow> (n'',s'')", "have \"pred (f a) s'\" \n    and \"transfer (f a) s' = s''\" and \"n' = sourcenode a\" and \"n'' = targetnode a\" \n    and \"valid_edge a\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (n',s') -a\\<rightarrow> (n'',s'')\n\ngoal (1 subgoal):\n 1. (pred (f a) s' &&& transfer (f a) s' = s'') &&&\n    n' = sourcenode a &&& n'' = targetnode a &&& valid_edge a", "by(auto elim:observable_move.cases)"], ["proof (state)\nthis:\n  pred (f a) s'\n  transfer (f a) s' = s''\n  n' = sourcenode a\n  n'' = targetnode a\n  valid_edge a\n\ngoal (1 subgoal):\n 1. \\<And>S f n s as n' s' a n'' s''.\n       \\<lbrakk>S,f \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s');\n        S,f \\<turnstile> (n',s') -a\\<rightarrow> (n'',s'')\\<rbrakk>\n       \\<Longrightarrow> preds (map f (as @ [a])) s \\<and>\n                         transfers (map f (as @ [a])) s = s'' \\<and>\n                         n -as @ [a]\\<rightarrow>* n''", "from \\<open>n' = sourcenode a\\<close> \\<open>n'' = targetnode a\\<close> \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  n' = sourcenode a\n  n'' = targetnode a\n  valid_edge a", "have \"n' -[a]\\<rightarrow>* n''\""], ["proof (prove)\nusing this:\n  n' = sourcenode a\n  n'' = targetnode a\n  valid_edge a\n\ngoal (1 subgoal):\n 1. n' -[a]\\<rightarrow>* n''", "by(fastforce intro:path.intros)"], ["proof (state)\nthis:\n  n' -[a]\\<rightarrow>* n''\n\ngoal (1 subgoal):\n 1. \\<And>S f n s as n' s' a n'' s''.\n       \\<lbrakk>S,f \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s');\n        S,f \\<turnstile> (n',s') -a\\<rightarrow> (n'',s'')\\<rbrakk>\n       \\<Longrightarrow> preds (map f (as @ [a])) s \\<and>\n                         transfers (map f (as @ [a])) s = s'' \\<and>\n                         n -as @ [a]\\<rightarrow>* n''", "with \\<open>n -as\\<rightarrow>* n'\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>* n'\n  n' -[a]\\<rightarrow>* n''", "have \"n -as@[a]\\<rightarrow>* n''\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>* n'\n  n' -[a]\\<rightarrow>* n''\n\ngoal (1 subgoal):\n 1. n -as @ [a]\\<rightarrow>* n''", "by(rule path_Append)"], ["proof (state)\nthis:\n  n -as @ [a]\\<rightarrow>* n''\n\ngoal (1 subgoal):\n 1. \\<And>S f n s as n' s' a n'' s''.\n       \\<lbrakk>S,f \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s');\n        S,f \\<turnstile> (n',s') -a\\<rightarrow> (n'',s'')\\<rbrakk>\n       \\<Longrightarrow> preds (map f (as @ [a])) s \\<and>\n                         transfers (map f (as @ [a])) s = s'' \\<and>\n                         n -as @ [a]\\<rightarrow>* n''", "with \\<open>preds (map f as) s\\<close> \\<open>pred (f a) s'\\<close> \\<open>transfer (f a) s' = s''\\<close>\n    \\<open>transfers (map f as) s = s'\\<close>"], ["proof (chain)\npicking this:\n  preds (map f as) s\n  pred (f a) s'\n  transfer (f a) s' = s''\n  transfers (map f as) s = s'\n  n -as @ [a]\\<rightarrow>* n''", "show ?case"], ["proof (prove)\nusing this:\n  preds (map f as) s\n  pred (f a) s'\n  transfer (f a) s' = s''\n  transfers (map f as) s = s'\n  n -as @ [a]\\<rightarrow>* n''\n\ngoal (1 subgoal):\n 1. preds (map f (as @ [a])) s \\<and>\n    transfers (map f (as @ [a])) s = s'' \\<and>\n    n -as @ [a]\\<rightarrow>* n''", "by(simp add:transfers_split preds_split)"], ["proof (state)\nthis:\n  preds (map f (as @ [a])) s \\<and>\n  transfers (map f (as @ [a])) s = s'' \\<and> n -as @ [a]\\<rightarrow>* n''\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Relevant variables\\<close>"], ["", "inductive_set relevant_vars :: \"'node set \\<Rightarrow> 'node \\<Rightarrow> 'var set\" (\"rv _\")\nfor S :: \"'node set\" and n :: \"'node\"\n\nwhere rvI:\n  \"\\<lbrakk>n -as\\<rightarrow>* n'; n' \\<in> backward_slice S; V \\<in> Use n';\n    \\<forall>nx \\<in> set(sourcenodes as). V \\<notin> Def nx\\<rbrakk>\n  \\<Longrightarrow> V \\<in> rv S n\""], ["", "lemma rvE:\n  assumes rv:\"V \\<in> rv S n\"\n  obtains as n' where \"n -as\\<rightarrow>* n'\" and \"n' \\<in> backward_slice S\" and \"V \\<in> Use n'\"\n  and \"\\<forall>nx \\<in> set(sourcenodes as). V \\<notin> Def nx\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as n'.\n        \\<lbrakk>n -as\\<rightarrow>* n'; n' \\<in> backward_slice S;\n         V \\<in> Use n';\n         \\<forall>nx\\<in>set (sourcenodes as). V \\<notin> Def nx\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using rv"], ["proof (prove)\nusing this:\n  V \\<in> rv S n\n\ngoal (1 subgoal):\n 1. (\\<And>as n'.\n        \\<lbrakk>n -as\\<rightarrow>* n'; n' \\<in> backward_slice S;\n         V \\<in> Use n';\n         \\<forall>nx\\<in>set (sourcenodes as). V \\<notin> Def nx\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(atomize_elim,auto elim!:relevant_vars.cases)"], ["", "lemma eq_obs_in_rv:\n  assumes obs_eq:\"obs n (backward_slice S) = obs n' (backward_slice S)\" \n  and \"x \\<in> rv S n\" shows \"x \\<in> rv S n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> rv S n'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> rv S n'", "from \\<open>x \\<in> rv S n\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> rv S n", "obtain as m \n    where \"n -as\\<rightarrow>* m\" and \"m \\<in> backward_slice S\" and \"x \\<in> Use m\"\n    and \"\\<forall>nx\\<in>set (sourcenodes as). x \\<notin> Def nx\""], ["proof (prove)\nusing this:\n  x \\<in> rv S n\n\ngoal (1 subgoal):\n 1. (\\<And>as m.\n        \\<lbrakk>n -as\\<rightarrow>* m; m \\<in> backward_slice S;\n         x \\<in> Use m;\n         \\<forall>nx\\<in>set (sourcenodes as). x \\<notin> Def nx\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule rvE)"], ["proof (state)\nthis:\n  n -as\\<rightarrow>* m\n  m \\<in> backward_slice S\n  x \\<in> Use m\n  \\<forall>nx\\<in>set (sourcenodes as). x \\<notin> Def nx\n\ngoal (1 subgoal):\n 1. x \\<in> rv S n'", "from \\<open>n -as\\<rightarrow>* m\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>* m", "have \"valid_node m\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>* m\n\ngoal (1 subgoal):\n 1. valid_node m", "by(fastforce dest:path_valid_node)"], ["proof (state)\nthis:\n  valid_node m\n\ngoal (1 subgoal):\n 1. x \\<in> rv S n'", "from \\<open>n -as\\<rightarrow>* m\\<close> \\<open>m \\<in> backward_slice S\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>* m\n  m \\<in> backward_slice S", "have \"\\<exists>nx as' as''. nx \\<in> obs n (backward_slice S) \\<and> n -as'\\<rightarrow>* nx \\<and> \n                                     nx -as''\\<rightarrow>* m \\<and> as = as'@as''\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>* m\n  m \\<in> backward_slice S\n\ngoal (1 subgoal):\n 1. \\<exists>nx as' as''.\n       nx \\<in> obs n (backward_slice S) \\<and>\n       n -as'\\<rightarrow>* nx \\<and>\n       nx -as''\\<rightarrow>* m \\<and> as = as' @ as''", "proof(cases \"\\<forall>nx \\<in> set(sourcenodes as). nx \\<notin> backward_slice S\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>n -as\\<rightarrow>* m; m \\<in> backward_slice S;\n     \\<forall>nx\\<in>set (sourcenodes as).\n        nx \\<notin> backward_slice S\\<rbrakk>\n    \\<Longrightarrow> \\<exists>nx as' as''.\n                         nx \\<in> obs n (backward_slice S) \\<and>\n                         n -as'\\<rightarrow>* nx \\<and>\n                         nx -as''\\<rightarrow>* m \\<and> as = as' @ as''\n 2. \\<lbrakk>n -as\\<rightarrow>* m; m \\<in> backward_slice S;\n     \\<not> (\\<forall>nx\\<in>set (sourcenodes as).\n                nx \\<notin> backward_slice S)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>nx as' as''.\n                         nx \\<in> obs n (backward_slice S) \\<and>\n                         n -as'\\<rightarrow>* nx \\<and>\n                         nx -as''\\<rightarrow>* m \\<and> as = as' @ as''", "case True"], ["proof (state)\nthis:\n  \\<forall>nx\\<in>set (sourcenodes as). nx \\<notin> backward_slice S\n\ngoal (2 subgoals):\n 1. \\<lbrakk>n -as\\<rightarrow>* m; m \\<in> backward_slice S;\n     \\<forall>nx\\<in>set (sourcenodes as).\n        nx \\<notin> backward_slice S\\<rbrakk>\n    \\<Longrightarrow> \\<exists>nx as' as''.\n                         nx \\<in> obs n (backward_slice S) \\<and>\n                         n -as'\\<rightarrow>* nx \\<and>\n                         nx -as''\\<rightarrow>* m \\<and> as = as' @ as''\n 2. \\<lbrakk>n -as\\<rightarrow>* m; m \\<in> backward_slice S;\n     \\<not> (\\<forall>nx\\<in>set (sourcenodes as).\n                nx \\<notin> backward_slice S)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>nx as' as''.\n                         nx \\<in> obs n (backward_slice S) \\<and>\n                         n -as'\\<rightarrow>* nx \\<and>\n                         nx -as''\\<rightarrow>* m \\<and> as = as' @ as''", "with \\<open>n -as\\<rightarrow>* m\\<close> \\<open>m \\<in> backward_slice S\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>* m\n  m \\<in> backward_slice S\n  \\<forall>nx\\<in>set (sourcenodes as). nx \\<notin> backward_slice S", "have \"m \\<in> obs n (backward_slice S)\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>* m\n  m \\<in> backward_slice S\n  \\<forall>nx\\<in>set (sourcenodes as). nx \\<notin> backward_slice S\n\ngoal (1 subgoal):\n 1. m \\<in> obs n (backward_slice S)", "by -(rule obs_elem)"], ["proof (state)\nthis:\n  m \\<in> obs n (backward_slice S)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>n -as\\<rightarrow>* m; m \\<in> backward_slice S;\n     \\<forall>nx\\<in>set (sourcenodes as).\n        nx \\<notin> backward_slice S\\<rbrakk>\n    \\<Longrightarrow> \\<exists>nx as' as''.\n                         nx \\<in> obs n (backward_slice S) \\<and>\n                         n -as'\\<rightarrow>* nx \\<and>\n                         nx -as''\\<rightarrow>* m \\<and> as = as' @ as''\n 2. \\<lbrakk>n -as\\<rightarrow>* m; m \\<in> backward_slice S;\n     \\<not> (\\<forall>nx\\<in>set (sourcenodes as).\n                nx \\<notin> backward_slice S)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>nx as' as''.\n                         nx \\<in> obs n (backward_slice S) \\<and>\n                         n -as'\\<rightarrow>* nx \\<and>\n                         nx -as''\\<rightarrow>* m \\<and> as = as' @ as''", "with \\<open>n -as\\<rightarrow>* m\\<close> \\<open>valid_node m\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>* m\n  valid_node m\n  m \\<in> obs n (backward_slice S)", "show ?thesis"], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>* m\n  valid_node m\n  m \\<in> obs n (backward_slice S)\n\ngoal (1 subgoal):\n 1. \\<exists>nx as' as''.\n       nx \\<in> obs n (backward_slice S) \\<and>\n       n -as'\\<rightarrow>* nx \\<and>\n       nx -as''\\<rightarrow>* m \\<and> as = as' @ as''", "by(blast intro:empty_path)"], ["proof (state)\nthis:\n  \\<exists>nx as' as''.\n     nx \\<in> obs n (backward_slice S) \\<and>\n     n -as'\\<rightarrow>* nx \\<and>\n     nx -as''\\<rightarrow>* m \\<and> as = as' @ as''\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n -as\\<rightarrow>* m; m \\<in> backward_slice S;\n     \\<not> (\\<forall>nx\\<in>set (sourcenodes as).\n                nx \\<notin> backward_slice S)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>nx as' as''.\n                         nx \\<in> obs n (backward_slice S) \\<and>\n                         n -as'\\<rightarrow>* nx \\<and>\n                         nx -as''\\<rightarrow>* m \\<and> as = as' @ as''", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>n -as\\<rightarrow>* m; m \\<in> backward_slice S;\n     \\<not> (\\<forall>nx\\<in>set (sourcenodes as).\n                nx \\<notin> backward_slice S)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>nx as' as''.\n                         nx \\<in> obs n (backward_slice S) \\<and>\n                         n -as'\\<rightarrow>* nx \\<and>\n                         nx -as''\\<rightarrow>* m \\<and> as = as' @ as''", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<forall>nx\\<in>set (sourcenodes as).\n             nx \\<notin> backward_slice S)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n -as\\<rightarrow>* m; m \\<in> backward_slice S;\n     \\<not> (\\<forall>nx\\<in>set (sourcenodes as).\n                nx \\<notin> backward_slice S)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>nx as' as''.\n                         nx \\<in> obs n (backward_slice S) \\<and>\n                         n -as'\\<rightarrow>* nx \\<and>\n                         nx -as''\\<rightarrow>* m \\<and> as = as' @ as''", "hence \"\\<exists>nx \\<in> set(sourcenodes as). nx \\<in> backward_slice S\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>nx\\<in>set (sourcenodes as).\n             nx \\<notin> backward_slice S)\n\ngoal (1 subgoal):\n 1. \\<exists>nx\\<in>set (sourcenodes as). nx \\<in> backward_slice S", "by simp"], ["proof (state)\nthis:\n  \\<exists>nx\\<in>set (sourcenodes as). nx \\<in> backward_slice S\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n -as\\<rightarrow>* m; m \\<in> backward_slice S;\n     \\<not> (\\<forall>nx\\<in>set (sourcenodes as).\n                nx \\<notin> backward_slice S)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>nx as' as''.\n                         nx \\<in> obs n (backward_slice S) \\<and>\n                         n -as'\\<rightarrow>* nx \\<and>\n                         nx -as''\\<rightarrow>* m \\<and> as = as' @ as''", "then"], ["proof (chain)\npicking this:\n  \\<exists>nx\\<in>set (sourcenodes as). nx \\<in> backward_slice S", "obtain nx' ns ns' where \"sourcenodes as = ns@nx'#ns'\"\n      and \"nx' \\<in> backward_slice S\" \n      and \"\\<forall>x \\<in> set ns. x \\<notin> backward_slice S\""], ["proof (prove)\nusing this:\n  \\<exists>nx\\<in>set (sourcenodes as). nx \\<in> backward_slice S\n\ngoal (1 subgoal):\n 1. (\\<And>ns nx' ns'.\n        \\<lbrakk>sourcenodes as = ns @ nx' # ns';\n         nx' \\<in> backward_slice S;\n         \\<forall>x\\<in>set ns. x \\<notin> backward_slice S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim!:split_list_first_propE)"], ["proof (state)\nthis:\n  sourcenodes as = ns @ nx' # ns'\n  nx' \\<in> backward_slice S\n  \\<forall>x\\<in>set ns. x \\<notin> backward_slice S\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n -as\\<rightarrow>* m; m \\<in> backward_slice S;\n     \\<not> (\\<forall>nx\\<in>set (sourcenodes as).\n                nx \\<notin> backward_slice S)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>nx as' as''.\n                         nx \\<in> obs n (backward_slice S) \\<and>\n                         n -as'\\<rightarrow>* nx \\<and>\n                         nx -as''\\<rightarrow>* m \\<and> as = as' @ as''", "from \\<open>sourcenodes as = ns@nx'#ns'\\<close>"], ["proof (chain)\npicking this:\n  sourcenodes as = ns @ nx' # ns'", "obtain as' a' as'' where \"ns = sourcenodes as'\"\n      and \"as = as'@a'#as''\" and \"sourcenode a' = nx'\""], ["proof (prove)\nusing this:\n  sourcenodes as = ns @ nx' # ns'\n\ngoal (1 subgoal):\n 1. (\\<And>as' a' as''.\n        \\<lbrakk>ns = sourcenodes as'; as = as' @ a' # as'';\n         sourcenode a' = nx'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:map_append_append_maps simp:sourcenodes_def)"], ["proof (state)\nthis:\n  ns = sourcenodes as'\n  as = as' @ a' # as''\n  sourcenode a' = nx'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n -as\\<rightarrow>* m; m \\<in> backward_slice S;\n     \\<not> (\\<forall>nx\\<in>set (sourcenodes as).\n                nx \\<notin> backward_slice S)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>nx as' as''.\n                         nx \\<in> obs n (backward_slice S) \\<and>\n                         n -as'\\<rightarrow>* nx \\<and>\n                         nx -as''\\<rightarrow>* m \\<and> as = as' @ as''", "from \\<open>n -as\\<rightarrow>* m\\<close> \\<open>as = as'@a'#as''\\<close> \\<open>sourcenode a' = nx'\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>* m\n  as = as' @ a' # as''\n  sourcenode a' = nx'", "have \"n -as'\\<rightarrow>* nx'\" and \"valid_edge a'\" and \"targetnode a' -as''\\<rightarrow>* m\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>* m\n  as = as' @ a' # as''\n  sourcenode a' = nx'\n\ngoal (1 subgoal):\n 1. n -as'\\<rightarrow>* nx' &&&\n    valid_edge a' &&& targetnode a' -as''\\<rightarrow>* m", "by(fastforce dest:path_split)+"], ["proof (state)\nthis:\n  n -as'\\<rightarrow>* nx'\n  valid_edge a'\n  targetnode a' -as''\\<rightarrow>* m\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n -as\\<rightarrow>* m; m \\<in> backward_slice S;\n     \\<not> (\\<forall>nx\\<in>set (sourcenodes as).\n                nx \\<notin> backward_slice S)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>nx as' as''.\n                         nx \\<in> obs n (backward_slice S) \\<and>\n                         n -as'\\<rightarrow>* nx \\<and>\n                         nx -as''\\<rightarrow>* m \\<and> as = as' @ as''", "with \\<open>sourcenode a' = nx'\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a' = nx'\n  n -as'\\<rightarrow>* nx'\n  valid_edge a'\n  targetnode a' -as''\\<rightarrow>* m", "have \"nx' -a'#as''\\<rightarrow>* m\""], ["proof (prove)\nusing this:\n  sourcenode a' = nx'\n  n -as'\\<rightarrow>* nx'\n  valid_edge a'\n  targetnode a' -as''\\<rightarrow>* m\n\ngoal (1 subgoal):\n 1. nx' -a' # as''\\<rightarrow>* m", "by(fastforce intro:Cons_path)"], ["proof (state)\nthis:\n  nx' -a' # as''\\<rightarrow>* m\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n -as\\<rightarrow>* m; m \\<in> backward_slice S;\n     \\<not> (\\<forall>nx\\<in>set (sourcenodes as).\n                nx \\<notin> backward_slice S)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>nx as' as''.\n                         nx \\<in> obs n (backward_slice S) \\<and>\n                         n -as'\\<rightarrow>* nx \\<and>\n                         nx -as''\\<rightarrow>* m \\<and> as = as' @ as''", "from \\<open>n -as'\\<rightarrow>* nx'\\<close> \\<open>nx' \\<in> backward_slice S\\<close>\n      \\<open>\\<forall>x \\<in> set ns. x \\<notin> backward_slice S\\<close> \\<open>ns = sourcenodes as'\\<close>"], ["proof (chain)\npicking this:\n  n -as'\\<rightarrow>* nx'\n  nx' \\<in> backward_slice S\n  \\<forall>x\\<in>set ns. x \\<notin> backward_slice S\n  ns = sourcenodes as'", "have \"nx' \\<in> obs n (backward_slice S)\""], ["proof (prove)\nusing this:\n  n -as'\\<rightarrow>* nx'\n  nx' \\<in> backward_slice S\n  \\<forall>x\\<in>set ns. x \\<notin> backward_slice S\n  ns = sourcenodes as'\n\ngoal (1 subgoal):\n 1. nx' \\<in> obs n (backward_slice S)", "by(fastforce intro:obs_elem)"], ["proof (state)\nthis:\n  nx' \\<in> obs n (backward_slice S)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n -as\\<rightarrow>* m; m \\<in> backward_slice S;\n     \\<not> (\\<forall>nx\\<in>set (sourcenodes as).\n                nx \\<notin> backward_slice S)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>nx as' as''.\n                         nx \\<in> obs n (backward_slice S) \\<and>\n                         n -as'\\<rightarrow>* nx \\<and>\n                         nx -as''\\<rightarrow>* m \\<and> as = as' @ as''", "with \\<open>n -as'\\<rightarrow>* nx'\\<close> \\<open>nx' -a'#as''\\<rightarrow>* m\\<close> \\<open>as = as'@a'#as''\\<close>"], ["proof (chain)\npicking this:\n  n -as'\\<rightarrow>* nx'\n  nx' -a' # as''\\<rightarrow>* m\n  as = as' @ a' # as''\n  nx' \\<in> obs n (backward_slice S)", "show ?thesis"], ["proof (prove)\nusing this:\n  n -as'\\<rightarrow>* nx'\n  nx' -a' # as''\\<rightarrow>* m\n  as = as' @ a' # as''\n  nx' \\<in> obs n (backward_slice S)\n\ngoal (1 subgoal):\n 1. \\<exists>nx as' as''.\n       nx \\<in> obs n (backward_slice S) \\<and>\n       n -as'\\<rightarrow>* nx \\<and>\n       nx -as''\\<rightarrow>* m \\<and> as = as' @ as''", "by blast"], ["proof (state)\nthis:\n  \\<exists>nx as' as''.\n     nx \\<in> obs n (backward_slice S) \\<and>\n     n -as'\\<rightarrow>* nx \\<and>\n     nx -as''\\<rightarrow>* m \\<and> as = as' @ as''\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>nx as' as''.\n     nx \\<in> obs n (backward_slice S) \\<and>\n     n -as'\\<rightarrow>* nx \\<and>\n     nx -as''\\<rightarrow>* m \\<and> as = as' @ as''\n\ngoal (1 subgoal):\n 1. x \\<in> rv S n'", "then"], ["proof (chain)\npicking this:\n  \\<exists>nx as' as''.\n     nx \\<in> obs n (backward_slice S) \\<and>\n     n -as'\\<rightarrow>* nx \\<and>\n     nx -as''\\<rightarrow>* m \\<and> as = as' @ as''", "obtain nx as' as'' where \"nx \\<in> obs n (backward_slice S)\"\n    and \"n -as'\\<rightarrow>* nx\" and \"nx -as''\\<rightarrow>* m\" and \"as = as'@as''\""], ["proof (prove)\nusing this:\n  \\<exists>nx as' as''.\n     nx \\<in> obs n (backward_slice S) \\<and>\n     n -as'\\<rightarrow>* nx \\<and>\n     nx -as''\\<rightarrow>* m \\<and> as = as' @ as''\n\ngoal (1 subgoal):\n 1. (\\<And>nx as' as''.\n        \\<lbrakk>nx \\<in> obs n (backward_slice S); n -as'\\<rightarrow>* nx;\n         nx -as''\\<rightarrow>* m; as = as' @ as''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  nx \\<in> obs n (backward_slice S)\n  n -as'\\<rightarrow>* nx\n  nx -as''\\<rightarrow>* m\n  as = as' @ as''\n\ngoal (1 subgoal):\n 1. x \\<in> rv S n'", "from \\<open>nx \\<in> obs n (backward_slice S)\\<close> obs_eq"], ["proof (chain)\npicking this:\n  nx \\<in> obs n (backward_slice S)\n  obs n (backward_slice S) = obs n' (backward_slice S)", "have \"nx \\<in> obs n' (backward_slice S)\""], ["proof (prove)\nusing this:\n  nx \\<in> obs n (backward_slice S)\n  obs n (backward_slice S) = obs n' (backward_slice S)\n\ngoal (1 subgoal):\n 1. nx \\<in> obs n' (backward_slice S)", "by auto"], ["proof (state)\nthis:\n  nx \\<in> obs n' (backward_slice S)\n\ngoal (1 subgoal):\n 1. x \\<in> rv S n'", "then"], ["proof (chain)\npicking this:\n  nx \\<in> obs n' (backward_slice S)", "obtain asx where \"n' -asx\\<rightarrow>* nx\" \n    and \"\\<forall>ni \\<in> set(sourcenodes asx). ni \\<notin> backward_slice S\" \n    and \"nx \\<in> backward_slice S\""], ["proof (prove)\nusing this:\n  nx \\<in> obs n' (backward_slice S)\n\ngoal (1 subgoal):\n 1. (\\<And>asx.\n        \\<lbrakk>n' -asx\\<rightarrow>* nx;\n         \\<forall>ni\\<in>set (sourcenodes asx).\n            ni \\<notin> backward_slice S;\n         nx \\<in> backward_slice S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule obsE)"], ["proof (state)\nthis:\n  n' -asx\\<rightarrow>* nx\n  \\<forall>ni\\<in>set (sourcenodes asx). ni \\<notin> backward_slice S\n  nx \\<in> backward_slice S\n\ngoal (1 subgoal):\n 1. x \\<in> rv S n'", "from \\<open>as = as'@as''\\<close> \\<open>\\<forall>nx\\<in>set (sourcenodes as). x \\<notin> Def nx\\<close>"], ["proof (chain)\npicking this:\n  as = as' @ as''\n  \\<forall>nx\\<in>set (sourcenodes as). x \\<notin> Def nx", "have \"\\<forall>ni\\<in>set (sourcenodes as''). x \\<notin> Def ni\""], ["proof (prove)\nusing this:\n  as = as' @ as''\n  \\<forall>nx\\<in>set (sourcenodes as). x \\<notin> Def nx\n\ngoal (1 subgoal):\n 1. \\<forall>ni\\<in>set (sourcenodes as''). x \\<notin> Def ni", "by(auto simp:sourcenodes_def)"], ["proof (state)\nthis:\n  \\<forall>ni\\<in>set (sourcenodes as''). x \\<notin> Def ni\n\ngoal (1 subgoal):\n 1. x \\<in> rv S n'", "from \\<open>\\<forall>ni \\<in> set(sourcenodes asx). ni \\<notin> backward_slice S\\<close> \\<open>n' -asx\\<rightarrow>* nx\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>ni\\<in>set (sourcenodes asx). ni \\<notin> backward_slice S\n  n' -asx\\<rightarrow>* nx", "have \"\\<forall>ni \\<in> set(sourcenodes asx). x \\<notin> Def ni\""], ["proof (prove)\nusing this:\n  \\<forall>ni\\<in>set (sourcenodes asx). ni \\<notin> backward_slice S\n  n' -asx\\<rightarrow>* nx\n\ngoal (1 subgoal):\n 1. \\<forall>ni\\<in>set (sourcenodes asx). x \\<notin> Def ni", "proof(induct asx arbitrary:n')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n'.\n       \\<lbrakk>\\<forall>ni\\<in>set (sourcenodes []).\n                   ni \\<notin> backward_slice S;\n        n' -[]\\<rightarrow>* nx\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ni\\<in>set (sourcenodes []).\n                            x \\<notin> Def ni\n 2. \\<And>a asx n'.\n       \\<lbrakk>\\<And>n'.\n                   \\<lbrakk>\\<forall>ni\\<in>set (sourcenodes asx).\n                               ni \\<notin> backward_slice S;\n                    n' -asx\\<rightarrow>* nx\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>ni\\<in>set (sourcenodes asx).\n  x \\<notin> Def ni;\n        \\<forall>ni\\<in>set (sourcenodes (a # asx)).\n           ni \\<notin> backward_slice S;\n        n' -a # asx\\<rightarrow>* nx\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ni\\<in>set (sourcenodes (a # asx)).\n                            x \\<notin> Def ni", "case Nil"], ["proof (state)\nthis:\n  \\<forall>ni\\<in>set (sourcenodes []). ni \\<notin> backward_slice S\n  n' -[]\\<rightarrow>* nx\n\ngoal (2 subgoals):\n 1. \\<And>n'.\n       \\<lbrakk>\\<forall>ni\\<in>set (sourcenodes []).\n                   ni \\<notin> backward_slice S;\n        n' -[]\\<rightarrow>* nx\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ni\\<in>set (sourcenodes []).\n                            x \\<notin> Def ni\n 2. \\<And>a asx n'.\n       \\<lbrakk>\\<And>n'.\n                   \\<lbrakk>\\<forall>ni\\<in>set (sourcenodes asx).\n                               ni \\<notin> backward_slice S;\n                    n' -asx\\<rightarrow>* nx\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>ni\\<in>set (sourcenodes asx).\n  x \\<notin> Def ni;\n        \\<forall>ni\\<in>set (sourcenodes (a # asx)).\n           ni \\<notin> backward_slice S;\n        n' -a # asx\\<rightarrow>* nx\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ni\\<in>set (sourcenodes (a # asx)).\n                            x \\<notin> Def ni", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>ni\\<in>set (sourcenodes []). ni \\<notin> backward_slice S\n  n' -[]\\<rightarrow>* nx\n\ngoal (1 subgoal):\n 1. \\<forall>ni\\<in>set (sourcenodes []). x \\<notin> Def ni", "by(simp add:sourcenodes_def)"], ["proof (state)\nthis:\n  \\<forall>ni\\<in>set (sourcenodes []). x \\<notin> Def ni\n\ngoal (1 subgoal):\n 1. \\<And>a asx n'.\n       \\<lbrakk>\\<And>n'.\n                   \\<lbrakk>\\<forall>ni\\<in>set (sourcenodes asx).\n                               ni \\<notin> backward_slice S;\n                    n' -asx\\<rightarrow>* nx\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>ni\\<in>set (sourcenodes asx).\n  x \\<notin> Def ni;\n        \\<forall>ni\\<in>set (sourcenodes (a # asx)).\n           ni \\<notin> backward_slice S;\n        n' -a # asx\\<rightarrow>* nx\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ni\\<in>set (sourcenodes (a # asx)).\n                            x \\<notin> Def ni", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a asx n'.\n       \\<lbrakk>\\<And>n'.\n                   \\<lbrakk>\\<forall>ni\\<in>set (sourcenodes asx).\n                               ni \\<notin> backward_slice S;\n                    n' -asx\\<rightarrow>* nx\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>ni\\<in>set (sourcenodes asx).\n  x \\<notin> Def ni;\n        \\<forall>ni\\<in>set (sourcenodes (a # asx)).\n           ni \\<notin> backward_slice S;\n        n' -a # asx\\<rightarrow>* nx\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ni\\<in>set (sourcenodes (a # asx)).\n                            x \\<notin> Def ni", "case (Cons ax' asx')"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>ni\\<in>set (sourcenodes asx').\n              ni \\<notin> backward_slice S;\n   ?n' -asx'\\<rightarrow>* nx\\<rbrakk>\n  \\<Longrightarrow> \\<forall>ni\\<in>set (sourcenodes asx').\n                       x \\<notin> Def ni\n  \\<forall>ni\\<in>set (sourcenodes (ax' # asx')).\n     ni \\<notin> backward_slice S\n  n' -ax' # asx'\\<rightarrow>* nx\n\ngoal (1 subgoal):\n 1. \\<And>a asx n'.\n       \\<lbrakk>\\<And>n'.\n                   \\<lbrakk>\\<forall>ni\\<in>set (sourcenodes asx).\n                               ni \\<notin> backward_slice S;\n                    n' -asx\\<rightarrow>* nx\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>ni\\<in>set (sourcenodes asx).\n  x \\<notin> Def ni;\n        \\<forall>ni\\<in>set (sourcenodes (a # asx)).\n           ni \\<notin> backward_slice S;\n        n' -a # asx\\<rightarrow>* nx\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ni\\<in>set (sourcenodes (a # asx)).\n                            x \\<notin> Def ni", "note IH = \\<open>\\<And>n'. \\<lbrakk>\\<forall>ni\\<in>set (sourcenodes asx'). ni \\<notin> backward_slice S; \n      n' -asx'\\<rightarrow>* nx\\<rbrakk> \n        \\<Longrightarrow> \\<forall>ni\\<in>set (sourcenodes asx'). x \\<notin> Def ni\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>ni\\<in>set (sourcenodes asx').\n              ni \\<notin> backward_slice S;\n   ?n' -asx'\\<rightarrow>* nx\\<rbrakk>\n  \\<Longrightarrow> \\<forall>ni\\<in>set (sourcenodes asx').\n                       x \\<notin> Def ni\n\ngoal (1 subgoal):\n 1. \\<And>a asx n'.\n       \\<lbrakk>\\<And>n'.\n                   \\<lbrakk>\\<forall>ni\\<in>set (sourcenodes asx).\n                               ni \\<notin> backward_slice S;\n                    n' -asx\\<rightarrow>* nx\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>ni\\<in>set (sourcenodes asx).\n  x \\<notin> Def ni;\n        \\<forall>ni\\<in>set (sourcenodes (a # asx)).\n           ni \\<notin> backward_slice S;\n        n' -a # asx\\<rightarrow>* nx\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ni\\<in>set (sourcenodes (a # asx)).\n                            x \\<notin> Def ni", "from \\<open>n' -ax'#asx'\\<rightarrow>* nx\\<close>"], ["proof (chain)\npicking this:\n  n' -ax' # asx'\\<rightarrow>* nx", "have \"n' -[]@ax'#asx'\\<rightarrow>* nx\""], ["proof (prove)\nusing this:\n  n' -ax' # asx'\\<rightarrow>* nx\n\ngoal (1 subgoal):\n 1. n' -[] @ ax' # asx'\\<rightarrow>* nx", "by simp"], ["proof (state)\nthis:\n  n' -[] @ ax' # asx'\\<rightarrow>* nx\n\ngoal (1 subgoal):\n 1. \\<And>a asx n'.\n       \\<lbrakk>\\<And>n'.\n                   \\<lbrakk>\\<forall>ni\\<in>set (sourcenodes asx).\n                               ni \\<notin> backward_slice S;\n                    n' -asx\\<rightarrow>* nx\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>ni\\<in>set (sourcenodes asx).\n  x \\<notin> Def ni;\n        \\<forall>ni\\<in>set (sourcenodes (a # asx)).\n           ni \\<notin> backward_slice S;\n        n' -a # asx\\<rightarrow>* nx\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ni\\<in>set (sourcenodes (a # asx)).\n                            x \\<notin> Def ni", "hence \"targetnode ax' -asx'\\<rightarrow>* nx\" and \"n' = sourcenode ax'\""], ["proof (prove)\nusing this:\n  n' -[] @ ax' # asx'\\<rightarrow>* nx\n\ngoal (1 subgoal):\n 1. targetnode ax' -asx'\\<rightarrow>* nx &&& n' = sourcenode ax'", "by(fastforce dest:path_split)+"], ["proof (state)\nthis:\n  targetnode ax' -asx'\\<rightarrow>* nx\n  n' = sourcenode ax'\n\ngoal (1 subgoal):\n 1. \\<And>a asx n'.\n       \\<lbrakk>\\<And>n'.\n                   \\<lbrakk>\\<forall>ni\\<in>set (sourcenodes asx).\n                               ni \\<notin> backward_slice S;\n                    n' -asx\\<rightarrow>* nx\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>ni\\<in>set (sourcenodes asx).\n  x \\<notin> Def ni;\n        \\<forall>ni\\<in>set (sourcenodes (a # asx)).\n           ni \\<notin> backward_slice S;\n        n' -a # asx\\<rightarrow>* nx\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ni\\<in>set (sourcenodes (a # asx)).\n                            x \\<notin> Def ni", "from \\<open>\\<forall>ni\\<in>set (sourcenodes (ax'#asx')). ni \\<notin> backward_slice S\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>ni\\<in>set (sourcenodes (ax' # asx')).\n     ni \\<notin> backward_slice S", "have all:\"\\<forall>ni\\<in>set (sourcenodes asx'). ni \\<notin> backward_slice S\" \n      and \"sourcenode ax' \\<notin> backward_slice S\""], ["proof (prove)\nusing this:\n  \\<forall>ni\\<in>set (sourcenodes (ax' # asx')).\n     ni \\<notin> backward_slice S\n\ngoal (1 subgoal):\n 1. \\<forall>ni\\<in>set (sourcenodes asx'). ni \\<notin> backward_slice S &&&\n    sourcenode ax' \\<notin> backward_slice S", "by(auto simp:sourcenodes_def)"], ["proof (state)\nthis:\n  \\<forall>ni\\<in>set (sourcenodes asx'). ni \\<notin> backward_slice S\n  sourcenode ax' \\<notin> backward_slice S\n\ngoal (1 subgoal):\n 1. \\<And>a asx n'.\n       \\<lbrakk>\\<And>n'.\n                   \\<lbrakk>\\<forall>ni\\<in>set (sourcenodes asx).\n                               ni \\<notin> backward_slice S;\n                    n' -asx\\<rightarrow>* nx\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>ni\\<in>set (sourcenodes asx).\n  x \\<notin> Def ni;\n        \\<forall>ni\\<in>set (sourcenodes (a # asx)).\n           ni \\<notin> backward_slice S;\n        n' -a # asx\\<rightarrow>* nx\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ni\\<in>set (sourcenodes (a # asx)).\n                            x \\<notin> Def ni", "from IH[OF all \\<open>targetnode ax' -asx'\\<rightarrow>* nx\\<close>]"], ["proof (chain)\npicking this:\n  \\<forall>ni\\<in>set (sourcenodes asx'). x \\<notin> Def ni", "have \"\\<forall>ni\\<in>set (sourcenodes asx'). x \\<notin> Def ni\""], ["proof (prove)\nusing this:\n  \\<forall>ni\\<in>set (sourcenodes asx'). x \\<notin> Def ni\n\ngoal (1 subgoal):\n 1. \\<forall>ni\\<in>set (sourcenodes asx'). x \\<notin> Def ni", "."], ["proof (state)\nthis:\n  \\<forall>ni\\<in>set (sourcenodes asx'). x \\<notin> Def ni\n\ngoal (1 subgoal):\n 1. \\<And>a asx n'.\n       \\<lbrakk>\\<And>n'.\n                   \\<lbrakk>\\<forall>ni\\<in>set (sourcenodes asx).\n                               ni \\<notin> backward_slice S;\n                    n' -asx\\<rightarrow>* nx\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>ni\\<in>set (sourcenodes asx).\n  x \\<notin> Def ni;\n        \\<forall>ni\\<in>set (sourcenodes (a # asx)).\n           ni \\<notin> backward_slice S;\n        n' -a # asx\\<rightarrow>* nx\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ni\\<in>set (sourcenodes (a # asx)).\n                            x \\<notin> Def ni", "with \\<open>\\<forall>ni\\<in>set (sourcenodes as''). x \\<notin> Def ni\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>ni\\<in>set (sourcenodes as''). x \\<notin> Def ni\n  \\<forall>ni\\<in>set (sourcenodes asx'). x \\<notin> Def ni", "have \"\\<forall>ni\\<in>set (sourcenodes (asx'@as'')). x \\<notin> Def ni\""], ["proof (prove)\nusing this:\n  \\<forall>ni\\<in>set (sourcenodes as''). x \\<notin> Def ni\n  \\<forall>ni\\<in>set (sourcenodes asx'). x \\<notin> Def ni\n\ngoal (1 subgoal):\n 1. \\<forall>ni\\<in>set (sourcenodes (asx' @ as'')). x \\<notin> Def ni", "by(auto simp:sourcenodes_def)"], ["proof (state)\nthis:\n  \\<forall>ni\\<in>set (sourcenodes (asx' @ as'')). x \\<notin> Def ni\n\ngoal (1 subgoal):\n 1. \\<And>a asx n'.\n       \\<lbrakk>\\<And>n'.\n                   \\<lbrakk>\\<forall>ni\\<in>set (sourcenodes asx).\n                               ni \\<notin> backward_slice S;\n                    n' -asx\\<rightarrow>* nx\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>ni\\<in>set (sourcenodes asx).\n  x \\<notin> Def ni;\n        \\<forall>ni\\<in>set (sourcenodes (a # asx)).\n           ni \\<notin> backward_slice S;\n        n' -a # asx\\<rightarrow>* nx\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ni\\<in>set (sourcenodes (a # asx)).\n                            x \\<notin> Def ni", "from \\<open>n' -ax'#asx'\\<rightarrow>* nx\\<close> \\<open>nx -as''\\<rightarrow>* m\\<close>"], ["proof (chain)\npicking this:\n  n' -ax' # asx'\\<rightarrow>* nx\n  nx -as''\\<rightarrow>* m", "have \"n' -(ax'#asx')@as''\\<rightarrow>* m\""], ["proof (prove)\nusing this:\n  n' -ax' # asx'\\<rightarrow>* nx\n  nx -as''\\<rightarrow>* m\n\ngoal (1 subgoal):\n 1. n' -(ax' # asx') @ as''\\<rightarrow>* m", "by-(rule path_Append)"], ["proof (state)\nthis:\n  n' -(ax' # asx') @ as''\\<rightarrow>* m\n\ngoal (1 subgoal):\n 1. \\<And>a asx n'.\n       \\<lbrakk>\\<And>n'.\n                   \\<lbrakk>\\<forall>ni\\<in>set (sourcenodes asx).\n                               ni \\<notin> backward_slice S;\n                    n' -asx\\<rightarrow>* nx\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>ni\\<in>set (sourcenodes asx).\n  x \\<notin> Def ni;\n        \\<forall>ni\\<in>set (sourcenodes (a # asx)).\n           ni \\<notin> backward_slice S;\n        n' -a # asx\\<rightarrow>* nx\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ni\\<in>set (sourcenodes (a # asx)).\n                            x \\<notin> Def ni", "hence \"n' -ax'#asx'@as''\\<rightarrow>* m\""], ["proof (prove)\nusing this:\n  n' -(ax' # asx') @ as''\\<rightarrow>* m\n\ngoal (1 subgoal):\n 1. n' -ax' # asx' @ as''\\<rightarrow>* m", "by simp"], ["proof (state)\nthis:\n  n' -ax' # asx' @ as''\\<rightarrow>* m\n\ngoal (1 subgoal):\n 1. \\<And>a asx n'.\n       \\<lbrakk>\\<And>n'.\n                   \\<lbrakk>\\<forall>ni\\<in>set (sourcenodes asx).\n                               ni \\<notin> backward_slice S;\n                    n' -asx\\<rightarrow>* nx\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>ni\\<in>set (sourcenodes asx).\n  x \\<notin> Def ni;\n        \\<forall>ni\\<in>set (sourcenodes (a # asx)).\n           ni \\<notin> backward_slice S;\n        n' -a # asx\\<rightarrow>* nx\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ni\\<in>set (sourcenodes (a # asx)).\n                            x \\<notin> Def ni", "have \"x \\<notin> Def (sourcenode ax')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> Def (sourcenode ax')", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> Def (sourcenode ax') \\<Longrightarrow> False", "assume \"x \\<in> Def (sourcenode ax')\""], ["proof (state)\nthis:\n  x \\<in> Def (sourcenode ax')\n\ngoal (1 subgoal):\n 1. x \\<in> Def (sourcenode ax') \\<Longrightarrow> False", "with \\<open>x \\<in> Use m\\<close> \\<open>\\<forall>ni\\<in>set (sourcenodes (asx'@as'')). x \\<notin> Def ni\\<close>\n        \\<open>n' -ax'#asx'@as''\\<rightarrow>* m\\<close> \\<open>n' = sourcenode ax'\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> Use m\n  \\<forall>ni\\<in>set (sourcenodes (asx' @ as'')). x \\<notin> Def ni\n  n' -ax' # asx' @ as''\\<rightarrow>* m\n  n' = sourcenode ax'\n  x \\<in> Def (sourcenode ax')", "have \"n' influences x in m\""], ["proof (prove)\nusing this:\n  x \\<in> Use m\n  \\<forall>ni\\<in>set (sourcenodes (asx' @ as'')). x \\<notin> Def ni\n  n' -ax' # asx' @ as''\\<rightarrow>* m\n  n' = sourcenode ax'\n  x \\<in> Def (sourcenode ax')\n\ngoal (1 subgoal):\n 1. n' influences x in m", "by(auto simp:data_dependence_def)"], ["proof (state)\nthis:\n  n' influences x in m\n\ngoal (1 subgoal):\n 1. x \\<in> Def (sourcenode ax') \\<Longrightarrow> False", "with \\<open>m \\<in> backward_slice S\\<close> dd_closed"], ["proof (chain)\npicking this:\n  m \\<in> backward_slice S\n  \\<lbrakk>?n' \\<in> backward_slice ?S; ?n influences ?V in ?n'\\<rbrakk>\n  \\<Longrightarrow> ?n \\<in> backward_slice ?S\n  n' influences x in m", "have \"n' \\<in> backward_slice S\""], ["proof (prove)\nusing this:\n  m \\<in> backward_slice S\n  \\<lbrakk>?n' \\<in> backward_slice ?S; ?n influences ?V in ?n'\\<rbrakk>\n  \\<Longrightarrow> ?n \\<in> backward_slice ?S\n  n' influences x in m\n\ngoal (1 subgoal):\n 1. n' \\<in> backward_slice S", "by(auto simp:dd_closed)"], ["proof (state)\nthis:\n  n' \\<in> backward_slice S\n\ngoal (1 subgoal):\n 1. x \\<in> Def (sourcenode ax') \\<Longrightarrow> False", "with \\<open>n' = sourcenode ax'\\<close> \\<open>sourcenode ax' \\<notin> backward_slice S\\<close>"], ["proof (chain)\npicking this:\n  n' = sourcenode ax'\n  sourcenode ax' \\<notin> backward_slice S\n  n' \\<in> backward_slice S", "show False"], ["proof (prove)\nusing this:\n  n' = sourcenode ax'\n  sourcenode ax' \\<notin> backward_slice S\n  n' \\<in> backward_slice S\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<notin> Def (sourcenode ax')\n\ngoal (1 subgoal):\n 1. \\<And>a asx n'.\n       \\<lbrakk>\\<And>n'.\n                   \\<lbrakk>\\<forall>ni\\<in>set (sourcenodes asx).\n                               ni \\<notin> backward_slice S;\n                    n' -asx\\<rightarrow>* nx\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>ni\\<in>set (sourcenodes asx).\n  x \\<notin> Def ni;\n        \\<forall>ni\\<in>set (sourcenodes (a # asx)).\n           ni \\<notin> backward_slice S;\n        n' -a # asx\\<rightarrow>* nx\\<rbrakk>\n       \\<Longrightarrow> \\<forall>ni\\<in>set (sourcenodes (a # asx)).\n                            x \\<notin> Def ni", "with \\<open>\\<forall>ni\\<in>set (sourcenodes (asx'@as'')). x \\<notin> Def ni\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>ni\\<in>set (sourcenodes (asx' @ as'')). x \\<notin> Def ni\n  x \\<notin> Def (sourcenode ax')", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>ni\\<in>set (sourcenodes (asx' @ as'')). x \\<notin> Def ni\n  x \\<notin> Def (sourcenode ax')\n\ngoal (1 subgoal):\n 1. \\<forall>ni\\<in>set (sourcenodes (ax' # asx')). x \\<notin> Def ni", "by(simp add:sourcenodes_def)"], ["proof (state)\nthis:\n  \\<forall>ni\\<in>set (sourcenodes (ax' # asx')). x \\<notin> Def ni\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>ni\\<in>set (sourcenodes asx). x \\<notin> Def ni\n\ngoal (1 subgoal):\n 1. x \\<in> rv S n'", "with \\<open>\\<forall>ni\\<in>set (sourcenodes as''). x \\<notin> Def ni\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>ni\\<in>set (sourcenodes as''). x \\<notin> Def ni\n  \\<forall>ni\\<in>set (sourcenodes asx). x \\<notin> Def ni", "have \"\\<forall>ni\\<in>set (sourcenodes (asx@as'')). x \\<notin> Def ni\""], ["proof (prove)\nusing this:\n  \\<forall>ni\\<in>set (sourcenodes as''). x \\<notin> Def ni\n  \\<forall>ni\\<in>set (sourcenodes asx). x \\<notin> Def ni\n\ngoal (1 subgoal):\n 1. \\<forall>ni\\<in>set (sourcenodes (asx @ as'')). x \\<notin> Def ni", "by(auto simp:sourcenodes_def)"], ["proof (state)\nthis:\n  \\<forall>ni\\<in>set (sourcenodes (asx @ as'')). x \\<notin> Def ni\n\ngoal (1 subgoal):\n 1. x \\<in> rv S n'", "from \\<open>n' -asx\\<rightarrow>* nx\\<close> \\<open>nx -as''\\<rightarrow>* m\\<close>"], ["proof (chain)\npicking this:\n  n' -asx\\<rightarrow>* nx\n  nx -as''\\<rightarrow>* m", "have \"n' -asx@as''\\<rightarrow>* m\""], ["proof (prove)\nusing this:\n  n' -asx\\<rightarrow>* nx\n  nx -as''\\<rightarrow>* m\n\ngoal (1 subgoal):\n 1. n' -asx @ as''\\<rightarrow>* m", "by(rule path_Append)"], ["proof (state)\nthis:\n  n' -asx @ as''\\<rightarrow>* m\n\ngoal (1 subgoal):\n 1. x \\<in> rv S n'", "with \\<open>m \\<in> backward_slice S\\<close> \\<open>x \\<in> Use m\\<close> \n    \\<open>\\<forall>ni\\<in>set (sourcenodes (asx@as'')). x \\<notin> Def ni\\<close>"], ["proof (chain)\npicking this:\n  m \\<in> backward_slice S\n  x \\<in> Use m\n  \\<forall>ni\\<in>set (sourcenodes (asx @ as'')). x \\<notin> Def ni\n  n' -asx @ as''\\<rightarrow>* m", "show \"x \\<in> rv S n'\""], ["proof (prove)\nusing this:\n  m \\<in> backward_slice S\n  x \\<in> Use m\n  \\<forall>ni\\<in>set (sourcenodes (asx @ as'')). x \\<notin> Def ni\n  n' -asx @ as''\\<rightarrow>* m\n\ngoal (1 subgoal):\n 1. x \\<in> rv S n'", "by -(rule rvI)"], ["proof (state)\nthis:\n  x \\<in> rv S n'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma closed_eq_obs_eq_rvs:\n  fixes S :: \"'node set\"\n  assumes \"valid_node n\" and \"valid_node n'\"\n  and obs_eq:\"obs n (backward_slice S) = obs n' (backward_slice S)\"\n  shows \"rv S n = rv S n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rv S n = rv S n'", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. rv S n \\<subseteq> rv S n'\n 2. rv S n' \\<subseteq> rv S n", "show \"rv S n \\<subseteq> rv S n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rv S n \\<subseteq> rv S n'", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> rv S n \\<Longrightarrow> x \\<in> rv S n'", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> rv S n \\<Longrightarrow> x \\<in> rv S n'", "assume \"x \\<in> rv S n\""], ["proof (state)\nthis:\n  x \\<in> rv S n\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> rv S n \\<Longrightarrow> x \\<in> rv S n'", "with \\<open>valid_node n\\<close> obs_eq"], ["proof (chain)\npicking this:\n  valid_node n\n  obs n (backward_slice S) = obs n' (backward_slice S)\n  x \\<in> rv S n", "show \"x \\<in> rv S n'\""], ["proof (prove)\nusing this:\n  valid_node n\n  obs n (backward_slice S) = obs n' (backward_slice S)\n  x \\<in> rv S n\n\ngoal (1 subgoal):\n 1. x \\<in> rv S n'", "by -(rule eq_obs_in_rv)"], ["proof (state)\nthis:\n  x \\<in> rv S n'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rv S n \\<subseteq> rv S n'\n\ngoal (1 subgoal):\n 1. rv S n' \\<subseteq> rv S n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. rv S n' \\<subseteq> rv S n", "show \"rv S n' \\<subseteq> rv S n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rv S n' \\<subseteq> rv S n", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> rv S n' \\<Longrightarrow> x \\<in> rv S n", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> rv S n' \\<Longrightarrow> x \\<in> rv S n", "assume \"x \\<in> rv S n'\""], ["proof (state)\nthis:\n  x \\<in> rv S n'\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> rv S n' \\<Longrightarrow> x \\<in> rv S n", "with \\<open>valid_node n'\\<close> obs_eq[THEN sym]"], ["proof (chain)\npicking this:\n  valid_node n'\n  obs n' (backward_slice S) = obs n (backward_slice S)\n  x \\<in> rv S n'", "show \"x \\<in> rv S n\""], ["proof (prove)\nusing this:\n  valid_node n'\n  obs n' (backward_slice S) = obs n (backward_slice S)\n  x \\<in> rv S n'\n\ngoal (1 subgoal):\n 1. x \\<in> rv S n", "by -(rule eq_obs_in_rv)"], ["proof (state)\nthis:\n  x \\<in> rv S n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rv S n' \\<subseteq> rv S n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rv_edge_slice_kinds:\n  assumes \"valid_edge a\" and \"sourcenode a = n\" and \"targetnode a = n''\"\n  and \"\\<forall>V\\<in>rv S n. state_val s V = state_val s' V\"\n  and \"preds (slice_kinds S (a#as)) s\" and \"preds (slice_kinds S (a#asx)) s'\"\n  shows \"\\<forall>V\\<in>rv S n''. state_val (transfer (slice_kind S a) s) V =\n                       state_val (transfer (slice_kind S a) s') V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>rv S n''.\n       state_val (transfer (slice_kind S a) s) V =\n       state_val (transfer (slice_kind S a) s') V", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S n'' \\<Longrightarrow>\n       state_val (transfer (slice_kind S a) s) V =\n       state_val (transfer (slice_kind S a) s') V", "fix V"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S n'' \\<Longrightarrow>\n       state_val (transfer (slice_kind S a) s) V =\n       state_val (transfer (slice_kind S a) s') V", "assume \"V \\<in> rv S n''\""], ["proof (state)\nthis:\n  V \\<in> rv S n''\n\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S n'' \\<Longrightarrow>\n       state_val (transfer (slice_kind S a) s) V =\n       state_val (transfer (slice_kind S a) s') V", "show \"state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "proof(cases \"V \\<in> Def n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. V \\<in> Def n \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V\n 2. V \\<notin> Def n \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "case True"], ["proof (state)\nthis:\n  V \\<in> Def n\n\ngoal (2 subgoals):\n 1. V \\<in> Def n \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V\n 2. V \\<notin> Def n \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "proof(cases \"sourcenode a \\<in> backward_slice S\")"], ["proof (state)\ngoal (2 subgoals):\n 1. sourcenode a \\<in> backward_slice S \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V\n 2. sourcenode a \\<notin> backward_slice S \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "case True"], ["proof (state)\nthis:\n  sourcenode a \\<in> backward_slice S\n\ngoal (2 subgoals):\n 1. sourcenode a \\<in> backward_slice S \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V\n 2. sourcenode a \\<notin> backward_slice S \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "hence \"slice_kind S a = kind a\""], ["proof (prove)\nusing this:\n  sourcenode a \\<in> backward_slice S\n\ngoal (1 subgoal):\n 1. slice_kind S a = kind a", "by(rule slice_kind_in_slice)"], ["proof (state)\nthis:\n  slice_kind S a = kind a\n\ngoal (2 subgoals):\n 1. sourcenode a \\<in> backward_slice S \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V\n 2. sourcenode a \\<notin> backward_slice S \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "with \\<open>preds (slice_kinds S (a#as)) s\\<close>"], ["proof (chain)\npicking this:\n  preds (slice_kinds S (a # as)) s\n  slice_kind S a = kind a", "have \"pred (kind a) s\""], ["proof (prove)\nusing this:\n  preds (slice_kinds S (a # as)) s\n  slice_kind S a = kind a\n\ngoal (1 subgoal):\n 1. pred (kind a) s", "by(simp add:slice_kinds_def)"], ["proof (state)\nthis:\n  pred (kind a) s\n\ngoal (2 subgoals):\n 1. sourcenode a \\<in> backward_slice S \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V\n 2. sourcenode a \\<notin> backward_slice S \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "from \\<open>slice_kind S a = kind a\\<close> \\<open>preds (slice_kinds S (a#asx)) s'\\<close>"], ["proof (chain)\npicking this:\n  slice_kind S a = kind a\n  preds (slice_kinds S (a # asx)) s'", "have \"pred (kind a) s'\""], ["proof (prove)\nusing this:\n  slice_kind S a = kind a\n  preds (slice_kinds S (a # asx)) s'\n\ngoal (1 subgoal):\n 1. pred (kind a) s'", "by(simp add:slice_kinds_def)"], ["proof (state)\nthis:\n  pred (kind a) s'\n\ngoal (2 subgoals):\n 1. sourcenode a \\<in> backward_slice S \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V\n 2. sourcenode a \\<notin> backward_slice S \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "from \\<open>valid_edge a\\<close> \\<open>sourcenode a = n\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  sourcenode a = n", "have \"n -[]\\<rightarrow>* n\""], ["proof (prove)\nusing this:\n  valid_edge a\n  sourcenode a = n\n\ngoal (1 subgoal):\n 1. n -[]\\<rightarrow>* n", "by(fastforce intro:empty_path)"], ["proof (state)\nthis:\n  n -[]\\<rightarrow>* n\n\ngoal (2 subgoals):\n 1. sourcenode a \\<in> backward_slice S \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V\n 2. sourcenode a \\<notin> backward_slice S \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "with True \\<open>sourcenode a = n\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a \\<in> backward_slice S\n  sourcenode a = n\n  n -[]\\<rightarrow>* n", "have \"\\<forall>V \\<in> Use n. V \\<in> rv S n\""], ["proof (prove)\nusing this:\n  sourcenode a \\<in> backward_slice S\n  sourcenode a = n\n  n -[]\\<rightarrow>* n\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use n. V \\<in> rv S n", "by(fastforce intro:rvI simp:sourcenodes_def)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use n. V \\<in> rv S n\n\ngoal (2 subgoals):\n 1. sourcenode a \\<in> backward_slice S \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V\n 2. sourcenode a \\<notin> backward_slice S \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "with \\<open>\\<forall>V\\<in>rv S n. state_val s V = state_val s' V\\<close> \\<open>sourcenode a = n\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>rv S n. state_val s V = state_val s' V\n  sourcenode a = n\n  \\<forall>V\\<in>Use n. V \\<in> rv S n", "have \"\\<forall>V \\<in> Use (sourcenode a). state_val s V = state_val s' V\""], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>rv S n. state_val s V = state_val s' V\n  sourcenode a = n\n  \\<forall>V\\<in>Use n. V \\<in> rv S n\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use (sourcenode a). state_val s V = state_val s' V", "by blast"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use (sourcenode a). state_val s V = state_val s' V\n\ngoal (2 subgoals):\n 1. sourcenode a \\<in> backward_slice S \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V\n 2. sourcenode a \\<notin> backward_slice S \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "from \\<open>valid_edge a\\<close> this \\<open>pred (kind a) s\\<close> \\<open>pred (kind a) s'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  \\<forall>V\\<in>Use (sourcenode a). state_val s V = state_val s' V\n  pred (kind a) s\n  pred (kind a) s'", "have \"\\<forall>V \\<in> Def (sourcenode a). state_val (transfer (kind a) s) V =\n        state_val (transfer (kind a) s') V\""], ["proof (prove)\nusing this:\n  valid_edge a\n  \\<forall>V\\<in>Use (sourcenode a). state_val s V = state_val s' V\n  pred (kind a) s\n  pred (kind a) s'\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Def (sourcenode a).\n       state_val (transfer (kind a) s) V =\n       state_val (transfer (kind a) s') V", "by(rule CFG_edge_transfer_uses_only_Use)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Def (sourcenode a).\n     state_val (transfer (kind a) s) V = state_val (transfer (kind a) s') V\n\ngoal (2 subgoals):\n 1. sourcenode a \\<in> backward_slice S \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V\n 2. sourcenode a \\<notin> backward_slice S \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "with \\<open>V \\<in> Def n\\<close> \\<open>sourcenode a = n\\<close> \\<open>slice_kind S a = kind a\\<close>"], ["proof (chain)\npicking this:\n  V \\<in> Def n\n  sourcenode a = n\n  slice_kind S a = kind a\n  \\<forall>V\\<in>Def (sourcenode a).\n     state_val (transfer (kind a) s) V = state_val (transfer (kind a) s') V", "show ?thesis"], ["proof (prove)\nusing this:\n  V \\<in> Def n\n  sourcenode a = n\n  slice_kind S a = kind a\n  \\<forall>V\\<in>Def (sourcenode a).\n     state_val (transfer (kind a) s) V = state_val (transfer (kind a) s') V\n\ngoal (1 subgoal):\n 1. state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "by simp"], ["proof (state)\nthis:\n  state_val (transfer (slice_kind S a) s) V =\n  state_val (transfer (slice_kind S a) s') V\n\ngoal (1 subgoal):\n 1. sourcenode a \\<notin> backward_slice S \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. sourcenode a \\<notin> backward_slice S \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "case False"], ["proof (state)\nthis:\n  sourcenode a \\<notin> backward_slice S\n\ngoal (1 subgoal):\n 1. sourcenode a \\<notin> backward_slice S \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "from \\<open>V \\<in> rv S n''\\<close>"], ["proof (chain)\npicking this:\n  V \\<in> rv S n''", "obtain xs nx where \"n'' -xs\\<rightarrow>* nx\"\n        and \"nx \\<in> backward_slice S\" and \"V \\<in> Use nx\"\n        and \"\\<forall>nx' \\<in> set(sourcenodes xs). V \\<notin> Def nx'\""], ["proof (prove)\nusing this:\n  V \\<in> rv S n''\n\ngoal (1 subgoal):\n 1. (\\<And>xs nx.\n        \\<lbrakk>n'' -xs\\<rightarrow>* nx; nx \\<in> backward_slice S;\n         V \\<in> Use nx;\n         \\<forall>nx'\\<in>set (sourcenodes xs). V \\<notin> Def nx'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule rvE)"], ["proof (state)\nthis:\n  n'' -xs\\<rightarrow>* nx\n  nx \\<in> backward_slice S\n  V \\<in> Use nx\n  \\<forall>nx'\\<in>set (sourcenodes xs). V \\<notin> Def nx'\n\ngoal (1 subgoal):\n 1. sourcenode a \\<notin> backward_slice S \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "from \\<open>valid_edge a\\<close> \\<open>sourcenode a = n\\<close> \\<open>targetnode a = n''\\<close> \n        \\<open>n'' -xs\\<rightarrow>* nx\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  sourcenode a = n\n  targetnode a = n''\n  n'' -xs\\<rightarrow>* nx", "have \"n -a#xs\\<rightarrow>* nx\""], ["proof (prove)\nusing this:\n  valid_edge a\n  sourcenode a = n\n  targetnode a = n''\n  n'' -xs\\<rightarrow>* nx\n\ngoal (1 subgoal):\n 1. n -a # xs\\<rightarrow>* nx", "by -(rule path.Cons_path)"], ["proof (state)\nthis:\n  n -a # xs\\<rightarrow>* nx\n\ngoal (1 subgoal):\n 1. sourcenode a \\<notin> backward_slice S \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "with \\<open>V \\<in> Def n\\<close> \\<open>V \\<in> Use nx\\<close> \\<open>\\<forall>nx' \\<in> set(sourcenodes xs). V \\<notin> Def nx'\\<close>"], ["proof (chain)\npicking this:\n  V \\<in> Def n\n  V \\<in> Use nx\n  \\<forall>nx'\\<in>set (sourcenodes xs). V \\<notin> Def nx'\n  n -a # xs\\<rightarrow>* nx", "have \"n influences V in nx\""], ["proof (prove)\nusing this:\n  V \\<in> Def n\n  V \\<in> Use nx\n  \\<forall>nx'\\<in>set (sourcenodes xs). V \\<notin> Def nx'\n  n -a # xs\\<rightarrow>* nx\n\ngoal (1 subgoal):\n 1. n influences V in nx", "by(fastforce simp:data_dependence_def)"], ["proof (state)\nthis:\n  n influences V in nx\n\ngoal (1 subgoal):\n 1. sourcenode a \\<notin> backward_slice S \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "with \\<open>nx \\<in> backward_slice S\\<close>"], ["proof (chain)\npicking this:\n  nx \\<in> backward_slice S\n  n influences V in nx", "have \"n \\<in> backward_slice S\""], ["proof (prove)\nusing this:\n  nx \\<in> backward_slice S\n  n influences V in nx\n\ngoal (1 subgoal):\n 1. n \\<in> backward_slice S", "by(rule dd_closed)"], ["proof (state)\nthis:\n  n \\<in> backward_slice S\n\ngoal (1 subgoal):\n 1. sourcenode a \\<notin> backward_slice S \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "with \\<open>sourcenode a = n\\<close> False"], ["proof (chain)\npicking this:\n  sourcenode a = n\n  sourcenode a \\<notin> backward_slice S\n  n \\<in> backward_slice S", "have False"], ["proof (prove)\nusing this:\n  sourcenode a = n\n  sourcenode a \\<notin> backward_slice S\n  n \\<in> backward_slice S\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. sourcenode a \\<notin> backward_slice S \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "by simp"], ["proof (state)\nthis:\n  state_val (transfer (slice_kind S a) s) V =\n  state_val (transfer (slice_kind S a) s') V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  state_val (transfer (slice_kind S a) s) V =\n  state_val (transfer (slice_kind S a) s') V\n\ngoal (1 subgoal):\n 1. V \\<notin> Def n \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. V \\<notin> Def n \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "case False"], ["proof (state)\nthis:\n  V \\<notin> Def n\n\ngoal (1 subgoal):\n 1. V \\<notin> Def n \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "from \\<open>V \\<in> rv S n''\\<close>"], ["proof (chain)\npicking this:\n  V \\<in> rv S n''", "obtain xs nx where \"n'' -xs\\<rightarrow>* nx\"\n      and \"nx \\<in> backward_slice S\" and \"V \\<in> Use nx\"\n      and \"\\<forall>nx' \\<in> set(sourcenodes xs). V \\<notin> Def nx'\""], ["proof (prove)\nusing this:\n  V \\<in> rv S n''\n\ngoal (1 subgoal):\n 1. (\\<And>xs nx.\n        \\<lbrakk>n'' -xs\\<rightarrow>* nx; nx \\<in> backward_slice S;\n         V \\<in> Use nx;\n         \\<forall>nx'\\<in>set (sourcenodes xs). V \\<notin> Def nx'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule rvE)"], ["proof (state)\nthis:\n  n'' -xs\\<rightarrow>* nx\n  nx \\<in> backward_slice S\n  V \\<in> Use nx\n  \\<forall>nx'\\<in>set (sourcenodes xs). V \\<notin> Def nx'\n\ngoal (1 subgoal):\n 1. V \\<notin> Def n \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "from \\<open>valid_edge a\\<close> \\<open>sourcenode a = n\\<close> \\<open>targetnode a = n''\\<close> \\<open>n'' -xs\\<rightarrow>* nx\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  sourcenode a = n\n  targetnode a = n''\n  n'' -xs\\<rightarrow>* nx", "have \"n -a#xs\\<rightarrow>* nx\""], ["proof (prove)\nusing this:\n  valid_edge a\n  sourcenode a = n\n  targetnode a = n''\n  n'' -xs\\<rightarrow>* nx\n\ngoal (1 subgoal):\n 1. n -a # xs\\<rightarrow>* nx", "by -(rule path.Cons_path)"], ["proof (state)\nthis:\n  n -a # xs\\<rightarrow>* nx\n\ngoal (1 subgoal):\n 1. V \\<notin> Def n \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "from False \\<open>\\<forall>nx' \\<in> set(sourcenodes xs). V \\<notin> Def nx'\\<close> \\<open>sourcenode a = n\\<close>"], ["proof (chain)\npicking this:\n  V \\<notin> Def n\n  \\<forall>nx'\\<in>set (sourcenodes xs). V \\<notin> Def nx'\n  sourcenode a = n", "have \"\\<forall>nx' \\<in> set(sourcenodes (a#xs)). V \\<notin> Def nx'\""], ["proof (prove)\nusing this:\n  V \\<notin> Def n\n  \\<forall>nx'\\<in>set (sourcenodes xs). V \\<notin> Def nx'\n  sourcenode a = n\n\ngoal (1 subgoal):\n 1. \\<forall>nx'\\<in>set (sourcenodes (a # xs)). V \\<notin> Def nx'", "by(simp add:sourcenodes_def)"], ["proof (state)\nthis:\n  \\<forall>nx'\\<in>set (sourcenodes (a # xs)). V \\<notin> Def nx'\n\ngoal (1 subgoal):\n 1. V \\<notin> Def n \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "with \\<open>n -a#xs\\<rightarrow>* nx\\<close> \\<open>nx \\<in> backward_slice S\\<close> \\<open>V \\<in> Use nx\\<close>"], ["proof (chain)\npicking this:\n  n -a # xs\\<rightarrow>* nx\n  nx \\<in> backward_slice S\n  V \\<in> Use nx\n  \\<forall>nx'\\<in>set (sourcenodes (a # xs)). V \\<notin> Def nx'", "have \"V \\<in> rv S n\""], ["proof (prove)\nusing this:\n  n -a # xs\\<rightarrow>* nx\n  nx \\<in> backward_slice S\n  V \\<in> Use nx\n  \\<forall>nx'\\<in>set (sourcenodes (a # xs)). V \\<notin> Def nx'\n\ngoal (1 subgoal):\n 1. V \\<in> rv S n", "by(rule rvI)"], ["proof (state)\nthis:\n  V \\<in> rv S n\n\ngoal (1 subgoal):\n 1. V \\<notin> Def n \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "proof(cases \"kind a\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       kind a = \\<Up>x1 \\<Longrightarrow>\n       state_val (transfer (slice_kind S a) s) V =\n       state_val (transfer (slice_kind S a) s') V\n 2. \\<And>x2.\n       kind a = (x2)\\<^sub>\\<surd> \\<Longrightarrow>\n       state_val (transfer (slice_kind S a) s) V =\n       state_val (transfer (slice_kind S a) s') V", "case (Predicate Q)"], ["proof (state)\nthis:\n  kind a = (Q)\\<^sub>\\<surd>\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       kind a = \\<Up>x1 \\<Longrightarrow>\n       state_val (transfer (slice_kind S a) s) V =\n       state_val (transfer (slice_kind S a) s') V\n 2. \\<And>x2.\n       kind a = (x2)\\<^sub>\\<surd> \\<Longrightarrow>\n       state_val (transfer (slice_kind S a) s) V =\n       state_val (transfer (slice_kind S a) s') V", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "proof(cases \"sourcenode a \\<in> backward_slice S\")"], ["proof (state)\ngoal (2 subgoals):\n 1. sourcenode a \\<in> backward_slice S \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V\n 2. sourcenode a \\<notin> backward_slice S \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "case True"], ["proof (state)\nthis:\n  sourcenode a \\<in> backward_slice S\n\ngoal (2 subgoals):\n 1. sourcenode a \\<in> backward_slice S \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V\n 2. sourcenode a \\<notin> backward_slice S \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "with Predicate"], ["proof (chain)\npicking this:\n  kind a = (Q)\\<^sub>\\<surd>\n  sourcenode a \\<in> backward_slice S", "have \"slice_kind S a = (Q)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  kind a = (Q)\\<^sub>\\<surd>\n  sourcenode a \\<in> backward_slice S\n\ngoal (1 subgoal):\n 1. slice_kind S a = (Q)\\<^sub>\\<surd>", "by(simp add:slice_kind_in_slice)"], ["proof (state)\nthis:\n  slice_kind S a = (Q)\\<^sub>\\<surd>\n\ngoal (2 subgoals):\n 1. sourcenode a \\<in> backward_slice S \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V\n 2. sourcenode a \\<notin> backward_slice S \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "with \\<open>\\<forall>V\\<in>rv S n. state_val s V = state_val s' V\\<close> \\<open>V \\<in> rv S n\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>rv S n. state_val s V = state_val s' V\n  V \\<in> rv S n\n  slice_kind S a = (Q)\\<^sub>\\<surd>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>rv S n. state_val s V = state_val s' V\n  V \\<in> rv S n\n  slice_kind S a = (Q)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "by simp"], ["proof (state)\nthis:\n  state_val (transfer (slice_kind S a) s) V =\n  state_val (transfer (slice_kind S a) s') V\n\ngoal (1 subgoal):\n 1. sourcenode a \\<notin> backward_slice S \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. sourcenode a \\<notin> backward_slice S \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "case False"], ["proof (state)\nthis:\n  sourcenode a \\<notin> backward_slice S\n\ngoal (1 subgoal):\n 1. sourcenode a \\<notin> backward_slice S \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "with Predicate"], ["proof (chain)\npicking this:\n  kind a = (Q)\\<^sub>\\<surd>\n  sourcenode a \\<notin> backward_slice S", "obtain Q' where \"slice_kind S a = (Q')\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  kind a = (Q)\\<^sub>\\<surd>\n  sourcenode a \\<notin> backward_slice S\n\ngoal (1 subgoal):\n 1. (\\<And>Q'.\n        slice_kind S a = (Q')\\<^sub>\\<surd> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by -(erule kind_Predicate_notin_slice_slice_kind_Predicate)"], ["proof (state)\nthis:\n  slice_kind S a = (Q')\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. sourcenode a \\<notin> backward_slice S \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "with \\<open>\\<forall>V\\<in>rv S n. state_val s V = state_val s' V\\<close> \\<open>V \\<in> rv S n\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>rv S n. state_val s V = state_val s' V\n  V \\<in> rv S n\n  slice_kind S a = (Q')\\<^sub>\\<surd>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>rv S n. state_val s V = state_val s' V\n  V \\<in> rv S n\n  slice_kind S a = (Q')\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "by simp"], ["proof (state)\nthis:\n  state_val (transfer (slice_kind S a) s) V =\n  state_val (transfer (slice_kind S a) s') V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  state_val (transfer (slice_kind S a) s) V =\n  state_val (transfer (slice_kind S a) s') V\n\ngoal (1 subgoal):\n 1. \\<And>x1.\n       kind a = \\<Up>x1 \\<Longrightarrow>\n       state_val (transfer (slice_kind S a) s) V =\n       state_val (transfer (slice_kind S a) s') V", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1.\n       kind a = \\<Up>x1 \\<Longrightarrow>\n       state_val (transfer (slice_kind S a) s) V =\n       state_val (transfer (slice_kind S a) s') V", "case (Update f)"], ["proof (state)\nthis:\n  kind a = \\<Up>f\n\ngoal (1 subgoal):\n 1. \\<And>x1.\n       kind a = \\<Up>x1 \\<Longrightarrow>\n       state_val (transfer (slice_kind S a) s) V =\n       state_val (transfer (slice_kind S a) s') V", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "proof(cases \"sourcenode a \\<in> backward_slice S\")"], ["proof (state)\ngoal (2 subgoals):\n 1. sourcenode a \\<in> backward_slice S \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V\n 2. sourcenode a \\<notin> backward_slice S \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "case True"], ["proof (state)\nthis:\n  sourcenode a \\<in> backward_slice S\n\ngoal (2 subgoals):\n 1. sourcenode a \\<in> backward_slice S \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V\n 2. sourcenode a \\<notin> backward_slice S \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "hence \"slice_kind S a = kind a\""], ["proof (prove)\nusing this:\n  sourcenode a \\<in> backward_slice S\n\ngoal (1 subgoal):\n 1. slice_kind S a = kind a", "by(rule slice_kind_in_slice)"], ["proof (state)\nthis:\n  slice_kind S a = kind a\n\ngoal (2 subgoals):\n 1. sourcenode a \\<in> backward_slice S \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V\n 2. sourcenode a \\<notin> backward_slice S \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "from Update"], ["proof (chain)\npicking this:\n  kind a = \\<Up>f", "have \"pred (kind a) s\""], ["proof (prove)\nusing this:\n  kind a = \\<Up>f\n\ngoal (1 subgoal):\n 1. pred (kind a) s", "by simp"], ["proof (state)\nthis:\n  pred (kind a) s\n\ngoal (2 subgoals):\n 1. sourcenode a \\<in> backward_slice S \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V\n 2. sourcenode a \\<notin> backward_slice S \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "with \\<open>valid_edge a\\<close> \\<open>sourcenode a = n\\<close> \\<open>V \\<notin> Def n\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  sourcenode a = n\n  V \\<notin> Def n\n  pred (kind a) s", "have \"state_val (transfer (kind a) s) V = state_val s V\""], ["proof (prove)\nusing this:\n  valid_edge a\n  sourcenode a = n\n  V \\<notin> Def n\n  pred (kind a) s\n\ngoal (1 subgoal):\n 1. state_val (transfer (kind a) s) V = state_val s V", "by(fastforce intro:CFG_edge_no_Def_equal)"], ["proof (state)\nthis:\n  state_val (transfer (kind a) s) V = state_val s V\n\ngoal (2 subgoals):\n 1. sourcenode a \\<in> backward_slice S \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V\n 2. sourcenode a \\<notin> backward_slice S \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "from Update"], ["proof (chain)\npicking this:\n  kind a = \\<Up>f", "have \"pred (kind a) s'\""], ["proof (prove)\nusing this:\n  kind a = \\<Up>f\n\ngoal (1 subgoal):\n 1. pred (kind a) s'", "by simp"], ["proof (state)\nthis:\n  pred (kind a) s'\n\ngoal (2 subgoals):\n 1. sourcenode a \\<in> backward_slice S \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V\n 2. sourcenode a \\<notin> backward_slice S \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "with \\<open>valid_edge a\\<close> \\<open>sourcenode a = n\\<close> \\<open>V \\<notin> Def n\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  sourcenode a = n\n  V \\<notin> Def n\n  pred (kind a) s'", "have \"state_val (transfer (kind a) s') V = state_val s' V\""], ["proof (prove)\nusing this:\n  valid_edge a\n  sourcenode a = n\n  V \\<notin> Def n\n  pred (kind a) s'\n\ngoal (1 subgoal):\n 1. state_val (transfer (kind a) s') V = state_val s' V", "by(fastforce intro:CFG_edge_no_Def_equal)"], ["proof (state)\nthis:\n  state_val (transfer (kind a) s') V = state_val s' V\n\ngoal (2 subgoals):\n 1. sourcenode a \\<in> backward_slice S \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V\n 2. sourcenode a \\<notin> backward_slice S \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "with \\<open>\\<forall>V\\<in>rv S n. state_val s V = state_val s' V\\<close> \\<open>V \\<in> rv S n\\<close>\n          \\<open>state_val (transfer (kind a) s) V = state_val s V\\<close>\n          \\<open>slice_kind S a = kind a\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>rv S n. state_val s V = state_val s' V\n  V \\<in> rv S n\n  state_val (transfer (kind a) s) V = state_val s V\n  slice_kind S a = kind a\n  state_val (transfer (kind a) s') V = state_val s' V", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>rv S n. state_val s V = state_val s' V\n  V \\<in> rv S n\n  state_val (transfer (kind a) s) V = state_val s V\n  slice_kind S a = kind a\n  state_val (transfer (kind a) s') V = state_val s' V\n\ngoal (1 subgoal):\n 1. state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "by fastforce"], ["proof (state)\nthis:\n  state_val (transfer (slice_kind S a) s) V =\n  state_val (transfer (slice_kind S a) s') V\n\ngoal (1 subgoal):\n 1. sourcenode a \\<notin> backward_slice S \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. sourcenode a \\<notin> backward_slice S \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "case False"], ["proof (state)\nthis:\n  sourcenode a \\<notin> backward_slice S\n\ngoal (1 subgoal):\n 1. sourcenode a \\<notin> backward_slice S \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "with Update"], ["proof (chain)\npicking this:\n  kind a = \\<Up>f\n  sourcenode a \\<notin> backward_slice S", "have \"slice_kind S a = \\<Up>id\""], ["proof (prove)\nusing this:\n  kind a = \\<Up>f\n  sourcenode a \\<notin> backward_slice S\n\ngoal (1 subgoal):\n 1. slice_kind S a = \\<Up>id", "by -(rule slice_kind_Upd)"], ["proof (state)\nthis:\n  slice_kind S a = \\<Up>id\n\ngoal (1 subgoal):\n 1. sourcenode a \\<notin> backward_slice S \\<Longrightarrow>\n    state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "with \\<open>\\<forall>V\\<in>rv S n. state_val s V = state_val s' V\\<close> \\<open>V \\<in> rv S n\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>rv S n. state_val s V = state_val s' V\n  V \\<in> rv S n\n  slice_kind S a = \\<Up>id", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>rv S n. state_val s V = state_val s' V\n  V \\<in> rv S n\n  slice_kind S a = \\<Up>id\n\ngoal (1 subgoal):\n 1. state_val (transfer (slice_kind S a) s) V =\n    state_val (transfer (slice_kind S a) s') V", "by fastforce"], ["proof (state)\nthis:\n  state_val (transfer (slice_kind S a) s) V =\n  state_val (transfer (slice_kind S a) s') V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  state_val (transfer (slice_kind S a) s) V =\n  state_val (transfer (slice_kind S a) s') V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  state_val (transfer (slice_kind S a) s) V =\n  state_val (transfer (slice_kind S a) s') V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  state_val (transfer (slice_kind S a) s) V =\n  state_val (transfer (slice_kind S a) s') V\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rv_branching_edges_slice_kinds_False:\n  assumes \"valid_edge a\" and \"valid_edge ax\" \n  and \"sourcenode a = n\" and \"sourcenode ax = n\"\n  and \"targetnode a = n''\" and \"targetnode ax \\<noteq> n''\"\n  and \"preds (slice_kinds S (a#as)) s\" and \"preds (slice_kinds S (ax#asx)) s'\"\n  and \"\\<forall>V\\<in>rv S n. state_val s V = state_val s' V\"\n  shows False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "from \\<open>valid_edge a\\<close> \\<open>valid_edge ax\\<close> \\<open>sourcenode a = n\\<close> \\<open>sourcenode ax = n\\<close>\n    \\<open>targetnode a = n''\\<close> \\<open>targetnode ax \\<noteq> n''\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  valid_edge ax\n  sourcenode a = n\n  sourcenode ax = n\n  targetnode a = n''\n  targetnode ax \\<noteq> n''", "obtain Q Q' where \"kind a = (Q)\\<^sub>\\<surd>\" and \"kind ax = (Q')\\<^sub>\\<surd>\"\n    and \"\\<forall>s. (Q s \\<longrightarrow> \\<not> Q' s) \\<and> (Q' s \\<longrightarrow> \\<not> Q s)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  valid_edge ax\n  sourcenode a = n\n  sourcenode ax = n\n  targetnode a = n''\n  targetnode ax \\<noteq> n''\n\ngoal (1 subgoal):\n 1. (\\<And>Q Q'.\n        \\<lbrakk>kind a = (Q)\\<^sub>\\<surd>; kind ax = (Q')\\<^sub>\\<surd>;\n         \\<forall>s.\n            (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n            (Q' s \\<longrightarrow> \\<not> Q s)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto dest:deterministic)"], ["proof (state)\nthis:\n  kind a = (Q)\\<^sub>\\<surd>\n  kind ax = (Q')\\<^sub>\\<surd>\n  \\<forall>s.\n     (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n     (Q' s \\<longrightarrow> \\<not> Q s)\n\ngoal (1 subgoal):\n 1. False", "from \\<open>valid_edge a\\<close> \\<open>valid_edge ax\\<close> \\<open>sourcenode a = n\\<close> \\<open>sourcenode ax = n\\<close>\n    \\<open>targetnode a = n''\\<close> \\<open>targetnode ax \\<noteq> n''\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  valid_edge ax\n  sourcenode a = n\n  sourcenode ax = n\n  targetnode a = n''\n  targetnode ax \\<noteq> n''", "obtain P P' where \"slice_kind S a = (P)\\<^sub>\\<surd>\" \n    and \"slice_kind S ax = (P')\\<^sub>\\<surd>\"\n    and \"\\<forall>s. (P s \\<longrightarrow> \\<not> P' s) \\<and> (P' s \\<longrightarrow> \\<not> P s)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  valid_edge ax\n  sourcenode a = n\n  sourcenode ax = n\n  targetnode a = n''\n  targetnode ax \\<noteq> n''\n\ngoal (1 subgoal):\n 1. (\\<And>P P'.\n        \\<lbrakk>slice_kind S a = (P)\\<^sub>\\<surd>;\n         slice_kind S ax = (P')\\<^sub>\\<surd>;\n         \\<forall>s.\n            (P s \\<longrightarrow> \\<not> P' s) \\<and>\n            (P' s \\<longrightarrow> \\<not> P s)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(erule slice_deterministic,auto)"], ["proof (state)\nthis:\n  slice_kind S a = (P)\\<^sub>\\<surd>\n  slice_kind S ax = (P')\\<^sub>\\<surd>\n  \\<forall>s.\n     (P s \\<longrightarrow> \\<not> P' s) \\<and>\n     (P' s \\<longrightarrow> \\<not> P s)\n\ngoal (1 subgoal):\n 1. False", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof(cases \"sourcenode a \\<in> backward_slice S\")"], ["proof (state)\ngoal (2 subgoals):\n 1. sourcenode a \\<in> backward_slice S \\<Longrightarrow> False\n 2. sourcenode a \\<notin> backward_slice S \\<Longrightarrow> False", "case True"], ["proof (state)\nthis:\n  sourcenode a \\<in> backward_slice S\n\ngoal (2 subgoals):\n 1. sourcenode a \\<in> backward_slice S \\<Longrightarrow> False\n 2. sourcenode a \\<notin> backward_slice S \\<Longrightarrow> False", "hence \"slice_kind S a = kind a\""], ["proof (prove)\nusing this:\n  sourcenode a \\<in> backward_slice S\n\ngoal (1 subgoal):\n 1. slice_kind S a = kind a", "by(rule slice_kind_in_slice)"], ["proof (state)\nthis:\n  slice_kind S a = kind a\n\ngoal (2 subgoals):\n 1. sourcenode a \\<in> backward_slice S \\<Longrightarrow> False\n 2. sourcenode a \\<notin> backward_slice S \\<Longrightarrow> False", "with \\<open>preds (slice_kinds S (a#as)) s\\<close> \\<open>kind a = (Q)\\<^sub>\\<surd>\\<close> \n      \\<open>slice_kind S a = (P)\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  preds (slice_kinds S (a # as)) s\n  kind a = (Q)\\<^sub>\\<surd>\n  slice_kind S a = (P)\\<^sub>\\<surd>\n  slice_kind S a = kind a", "have \"pred (kind a) s\""], ["proof (prove)\nusing this:\n  preds (slice_kinds S (a # as)) s\n  kind a = (Q)\\<^sub>\\<surd>\n  slice_kind S a = (P)\\<^sub>\\<surd>\n  slice_kind S a = kind a\n\ngoal (1 subgoal):\n 1. pred (kind a) s", "by(simp add:slice_kinds_def)"], ["proof (state)\nthis:\n  pred (kind a) s\n\ngoal (2 subgoals):\n 1. sourcenode a \\<in> backward_slice S \\<Longrightarrow> False\n 2. sourcenode a \\<notin> backward_slice S \\<Longrightarrow> False", "from True \\<open>sourcenode a = n\\<close> \\<open>sourcenode ax = n\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a \\<in> backward_slice S\n  sourcenode a = n\n  sourcenode ax = n", "have \"slice_kind S ax = kind ax\""], ["proof (prove)\nusing this:\n  sourcenode a \\<in> backward_slice S\n  sourcenode a = n\n  sourcenode ax = n\n\ngoal (1 subgoal):\n 1. slice_kind S ax = kind ax", "by(fastforce simp:slice_kind_in_slice)"], ["proof (state)\nthis:\n  slice_kind S ax = kind ax\n\ngoal (2 subgoals):\n 1. sourcenode a \\<in> backward_slice S \\<Longrightarrow> False\n 2. sourcenode a \\<notin> backward_slice S \\<Longrightarrow> False", "with \\<open>preds (slice_kinds S (ax#asx)) s'\\<close> \\<open>kind ax = (Q')\\<^sub>\\<surd>\\<close>\n      \\<open>slice_kind S ax = (P')\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  preds (slice_kinds S (ax # asx)) s'\n  kind ax = (Q')\\<^sub>\\<surd>\n  slice_kind S ax = (P')\\<^sub>\\<surd>\n  slice_kind S ax = kind ax", "have \"pred (kind ax) s'\""], ["proof (prove)\nusing this:\n  preds (slice_kinds S (ax # asx)) s'\n  kind ax = (Q')\\<^sub>\\<surd>\n  slice_kind S ax = (P')\\<^sub>\\<surd>\n  slice_kind S ax = kind ax\n\ngoal (1 subgoal):\n 1. pred (kind ax) s'", "by(simp add:slice_kinds_def)"], ["proof (state)\nthis:\n  pred (kind ax) s'\n\ngoal (2 subgoals):\n 1. sourcenode a \\<in> backward_slice S \\<Longrightarrow> False\n 2. sourcenode a \\<notin> backward_slice S \\<Longrightarrow> False", "with \\<open>kind ax = (Q')\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  kind ax = (Q')\\<^sub>\\<surd>\n  pred (kind ax) s'", "have \"Q' s'\""], ["proof (prove)\nusing this:\n  kind ax = (Q')\\<^sub>\\<surd>\n  pred (kind ax) s'\n\ngoal (1 subgoal):\n 1. Q' s'", "by simp"], ["proof (state)\nthis:\n  Q' s'\n\ngoal (2 subgoals):\n 1. sourcenode a \\<in> backward_slice S \\<Longrightarrow> False\n 2. sourcenode a \\<notin> backward_slice S \\<Longrightarrow> False", "from \\<open>valid_edge a\\<close> \\<open>sourcenode a = n\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  sourcenode a = n", "have \"n -[]\\<rightarrow>* n\""], ["proof (prove)\nusing this:\n  valid_edge a\n  sourcenode a = n\n\ngoal (1 subgoal):\n 1. n -[]\\<rightarrow>* n", "by(fastforce intro:empty_path)"], ["proof (state)\nthis:\n  n -[]\\<rightarrow>* n\n\ngoal (2 subgoals):\n 1. sourcenode a \\<in> backward_slice S \\<Longrightarrow> False\n 2. sourcenode a \\<notin> backward_slice S \\<Longrightarrow> False", "with True \\<open>sourcenode a = n\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a \\<in> backward_slice S\n  sourcenode a = n\n  n -[]\\<rightarrow>* n", "have \"\\<forall>V \\<in> Use n. V \\<in> rv S n\""], ["proof (prove)\nusing this:\n  sourcenode a \\<in> backward_slice S\n  sourcenode a = n\n  n -[]\\<rightarrow>* n\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use n. V \\<in> rv S n", "by(fastforce intro:rvI simp:sourcenodes_def)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use n. V \\<in> rv S n\n\ngoal (2 subgoals):\n 1. sourcenode a \\<in> backward_slice S \\<Longrightarrow> False\n 2. sourcenode a \\<notin> backward_slice S \\<Longrightarrow> False", "with \\<open>\\<forall>V\\<in>rv S n. state_val s V = state_val s' V\\<close> \\<open>sourcenode a = n\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>rv S n. state_val s V = state_val s' V\n  sourcenode a = n\n  \\<forall>V\\<in>Use n. V \\<in> rv S n", "have \"\\<forall>V \\<in> Use (sourcenode a). state_val s V = state_val s' V\""], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>rv S n. state_val s V = state_val s' V\n  sourcenode a = n\n  \\<forall>V\\<in>Use n. V \\<in> rv S n\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use (sourcenode a). state_val s V = state_val s' V", "by blast"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use (sourcenode a). state_val s V = state_val s' V\n\ngoal (2 subgoals):\n 1. sourcenode a \\<in> backward_slice S \\<Longrightarrow> False\n 2. sourcenode a \\<notin> backward_slice S \\<Longrightarrow> False", "with \\<open>valid_edge a\\<close> \\<open>pred (kind a) s\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  pred (kind a) s\n  \\<forall>V\\<in>Use (sourcenode a). state_val s V = state_val s' V", "have \"pred (kind a) s'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  pred (kind a) s\n  \\<forall>V\\<in>Use (sourcenode a). state_val s V = state_val s' V\n\ngoal (1 subgoal):\n 1. pred (kind a) s'", "by(rule CFG_edge_Uses_pred_equal)"], ["proof (state)\nthis:\n  pred (kind a) s'\n\ngoal (2 subgoals):\n 1. sourcenode a \\<in> backward_slice S \\<Longrightarrow> False\n 2. sourcenode a \\<notin> backward_slice S \\<Longrightarrow> False", "with \\<open>kind a = (Q)\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  kind a = (Q)\\<^sub>\\<surd>\n  pred (kind a) s'", "have \"Q s'\""], ["proof (prove)\nusing this:\n  kind a = (Q)\\<^sub>\\<surd>\n  pred (kind a) s'\n\ngoal (1 subgoal):\n 1. Q s'", "by simp"], ["proof (state)\nthis:\n  Q s'\n\ngoal (2 subgoals):\n 1. sourcenode a \\<in> backward_slice S \\<Longrightarrow> False\n 2. sourcenode a \\<notin> backward_slice S \\<Longrightarrow> False", "with \\<open>Q' s'\\<close> \\<open>\\<forall>s. (Q s \\<longrightarrow> \\<not> Q' s) \\<and> (Q' s \\<longrightarrow> \\<not> Q s)\\<close>"], ["proof (chain)\npicking this:\n  Q' s'\n  \\<forall>s.\n     (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n     (Q' s \\<longrightarrow> \\<not> Q s)\n  Q s'", "have False"], ["proof (prove)\nusing this:\n  Q' s'\n  \\<forall>s.\n     (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n     (Q' s \\<longrightarrow> \\<not> Q s)\n  Q s'\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. sourcenode a \\<in> backward_slice S \\<Longrightarrow> False\n 2. sourcenode a \\<notin> backward_slice S \\<Longrightarrow> False", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. sourcenode a \\<notin> backward_slice S \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. sourcenode a \\<notin> backward_slice S \\<Longrightarrow> False", "case False"], ["proof (state)\nthis:\n  sourcenode a \\<notin> backward_slice S\n\ngoal (1 subgoal):\n 1. sourcenode a \\<notin> backward_slice S \\<Longrightarrow> False", "with \\<open>kind a = (Q)\\<^sub>\\<surd>\\<close> \\<open>slice_kind S a = (P)\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  kind a = (Q)\\<^sub>\\<surd>\n  slice_kind S a = (P)\\<^sub>\\<surd>\n  sourcenode a \\<notin> backward_slice S", "have \"P = (\\<lambda>s. False) \\<or> P = (\\<lambda>s. True)\""], ["proof (prove)\nusing this:\n  kind a = (Q)\\<^sub>\\<surd>\n  slice_kind S a = (P)\\<^sub>\\<surd>\n  sourcenode a \\<notin> backward_slice S\n\ngoal (1 subgoal):\n 1. P = (\\<lambda>s. False) \\<or> P = (\\<lambda>s. True)", "by(fastforce elim:kind_Predicate_notin_slice_slice_kind_Predicate)"], ["proof (state)\nthis:\n  P = (\\<lambda>s. False) \\<or> P = (\\<lambda>s. True)\n\ngoal (1 subgoal):\n 1. sourcenode a \\<notin> backward_slice S \\<Longrightarrow> False", "with \\<open>slice_kind S a = (P)\\<^sub>\\<surd>\\<close> \\<open>preds (slice_kinds S (a#as)) s\\<close>"], ["proof (chain)\npicking this:\n  slice_kind S a = (P)\\<^sub>\\<surd>\n  preds (slice_kinds S (a # as)) s\n  P = (\\<lambda>s. False) \\<or> P = (\\<lambda>s. True)", "have \"P = (\\<lambda>s. True)\""], ["proof (prove)\nusing this:\n  slice_kind S a = (P)\\<^sub>\\<surd>\n  preds (slice_kinds S (a # as)) s\n  P = (\\<lambda>s. False) \\<or> P = (\\<lambda>s. True)\n\ngoal (1 subgoal):\n 1. P = (\\<lambda>s. True)", "by(fastforce simp:slice_kinds_def)"], ["proof (state)\nthis:\n  P = (\\<lambda>s. True)\n\ngoal (1 subgoal):\n 1. sourcenode a \\<notin> backward_slice S \\<Longrightarrow> False", "from \\<open>kind ax = (Q')\\<^sub>\\<surd>\\<close> \\<open>slice_kind S ax = (P')\\<^sub>\\<surd>\\<close> \n      \\<open>sourcenode a = n\\<close> \\<open>sourcenode ax = n\\<close> False"], ["proof (chain)\npicking this:\n  kind ax = (Q')\\<^sub>\\<surd>\n  slice_kind S ax = (P')\\<^sub>\\<surd>\n  sourcenode a = n\n  sourcenode ax = n\n  sourcenode a \\<notin> backward_slice S", "have \"P' = (\\<lambda>s. False) \\<or> P' = (\\<lambda>s. True)\""], ["proof (prove)\nusing this:\n  kind ax = (Q')\\<^sub>\\<surd>\n  slice_kind S ax = (P')\\<^sub>\\<surd>\n  sourcenode a = n\n  sourcenode ax = n\n  sourcenode a \\<notin> backward_slice S\n\ngoal (1 subgoal):\n 1. P' = (\\<lambda>s. False) \\<or> P' = (\\<lambda>s. True)", "by(fastforce elim:kind_Predicate_notin_slice_slice_kind_Predicate)"], ["proof (state)\nthis:\n  P' = (\\<lambda>s. False) \\<or> P' = (\\<lambda>s. True)\n\ngoal (1 subgoal):\n 1. sourcenode a \\<notin> backward_slice S \\<Longrightarrow> False", "with \\<open>slice_kind S ax = (P')\\<^sub>\\<surd>\\<close> \\<open>preds (slice_kinds S (ax#asx)) s'\\<close>"], ["proof (chain)\npicking this:\n  slice_kind S ax = (P')\\<^sub>\\<surd>\n  preds (slice_kinds S (ax # asx)) s'\n  P' = (\\<lambda>s. False) \\<or> P' = (\\<lambda>s. True)", "have \"P' = (\\<lambda>s. True)\""], ["proof (prove)\nusing this:\n  slice_kind S ax = (P')\\<^sub>\\<surd>\n  preds (slice_kinds S (ax # asx)) s'\n  P' = (\\<lambda>s. False) \\<or> P' = (\\<lambda>s. True)\n\ngoal (1 subgoal):\n 1. P' = (\\<lambda>s. True)", "by(fastforce simp:slice_kinds_def)"], ["proof (state)\nthis:\n  P' = (\\<lambda>s. True)\n\ngoal (1 subgoal):\n 1. sourcenode a \\<notin> backward_slice S \\<Longrightarrow> False", "with \\<open>P = (\\<lambda>s. True)\\<close> \\<open>\\<forall>s. (P s \\<longrightarrow> \\<not> P' s) \\<and> (P' s \\<longrightarrow> \\<not> P s)\\<close>"], ["proof (chain)\npicking this:\n  P = (\\<lambda>s. True)\n  \\<forall>s.\n     (P s \\<longrightarrow> \\<not> P' s) \\<and>\n     (P' s \\<longrightarrow> \\<not> P s)\n  P' = (\\<lambda>s. True)", "have False"], ["proof (prove)\nusing this:\n  P = (\\<lambda>s. True)\n  \\<forall>s.\n     (P s \\<longrightarrow> \\<not> P' s) \\<and>\n     (P' s \\<longrightarrow> \\<not> P s)\n  P' = (\\<lambda>s. True)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. sourcenode a \\<notin> backward_slice S \\<Longrightarrow> False", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>The set \\<open>WS\\<close>\\<close>"], ["", "inductive_set WS :: \"'node set \\<Rightarrow> (('node \\<times> 'state) \\<times> ('node \\<times> 'state)) set\"\nfor S :: \"'node set\"\nwhere WSI:\"\\<lbrakk>obs n (backward_slice S) = obs n' (backward_slice S); \n            \\<forall>V \\<in> rv S n. state_val s V = state_val s' V;\n            valid_node n; valid_node n'\\<rbrakk>\n  \\<Longrightarrow> ((n,s),(n',s')) \\<in> WS S\""], ["", "lemma WSD:\n  \"((n,s),(n',s')) \\<in> WS S \n  \\<Longrightarrow> obs n (backward_slice S) = obs n' (backward_slice S) \\<and> \n      (\\<forall>V \\<in> rv S n. state_val s V = state_val s' V) \\<and>\n      valid_node n \\<and> valid_node n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((n, s), n', s') \\<in> WS S \\<Longrightarrow>\n    obs n (backward_slice S) = obs n' (backward_slice S) \\<and>\n    (\\<forall>V\\<in>rv S n. state_val s V = state_val s' V) \\<and>\n    valid_node n \\<and> valid_node n'", "by(auto elim:WS.cases)"], ["", "lemma WS_silent_move:\n  assumes \"((n\\<^sub>1,s\\<^sub>1),(n\\<^sub>2,s\\<^sub>2)) \\<in> WS S\" and \"S,kind \\<turnstile> (n\\<^sub>1,s\\<^sub>1) -a\\<rightarrow>\\<^sub>\\<tau> (n\\<^sub>1',s\\<^sub>1')\"\n  and \"obs n\\<^sub>1' (backward_slice S) \\<noteq> {}\" shows \"((n\\<^sub>1',s\\<^sub>1'),(n\\<^sub>2,s\\<^sub>2)) \\<in> WS S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((n\\<^sub>1', s\\<^sub>1'), n\\<^sub>2, s\\<^sub>2) \\<in> WS S", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((n\\<^sub>1', s\\<^sub>1'), n\\<^sub>2, s\\<^sub>2) \\<in> WS S", "from \\<open>((n\\<^sub>1,s\\<^sub>1),(n\\<^sub>2,s\\<^sub>2)) \\<in> WS S\\<close>"], ["proof (chain)\npicking this:\n  ((n\\<^sub>1, s\\<^sub>1), n\\<^sub>2, s\\<^sub>2) \\<in> WS S", "have \"valid_node n\\<^sub>1\" and \"valid_node n\\<^sub>2\""], ["proof (prove)\nusing this:\n  ((n\\<^sub>1, s\\<^sub>1), n\\<^sub>2, s\\<^sub>2) \\<in> WS S\n\ngoal (1 subgoal):\n 1. valid_node n\\<^sub>1 &&& valid_node n\\<^sub>2", "by(auto dest:WSD)"], ["proof (state)\nthis:\n  valid_node n\\<^sub>1\n  valid_node n\\<^sub>2\n\ngoal (1 subgoal):\n 1. ((n\\<^sub>1', s\\<^sub>1'), n\\<^sub>2, s\\<^sub>2) \\<in> WS S", "from \\<open>S,kind \\<turnstile> (n\\<^sub>1,s\\<^sub>1) -a\\<rightarrow>\\<^sub>\\<tau> (n\\<^sub>1',s\\<^sub>1')\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (n\\<^sub>1,s\\<^sub>1) -a\\<rightarrow>\\<^sub>\\<tau> (n\\<^sub>1',s\\<^sub>1')", "have \"sourcenode a = n\\<^sub>1\"\n    and \"targetnode a = n\\<^sub>1'\" and \"transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\"\n    and \"n\\<^sub>1 \\<notin> backward_slice S\" and \"valid_edge a\" and \"pred (kind a) s\\<^sub>1\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (n\\<^sub>1,s\\<^sub>1) -a\\<rightarrow>\\<^sub>\\<tau> (n\\<^sub>1',s\\<^sub>1')\n\ngoal (1 subgoal):\n 1. (sourcenode a = n\\<^sub>1 &&&\n     targetnode a = n\\<^sub>1' &&&\n     transfer (kind a) s\\<^sub>1 = s\\<^sub>1') &&&\n    n\\<^sub>1 \\<notin> backward_slice S &&&\n    valid_edge a &&& pred (kind a) s\\<^sub>1", "by(auto elim:silent_move.cases)"], ["proof (state)\nthis:\n  sourcenode a = n\\<^sub>1\n  targetnode a = n\\<^sub>1'\n  transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\n  n\\<^sub>1 \\<notin> backward_slice S\n  valid_edge a\n  pred (kind a) s\\<^sub>1\n\ngoal (1 subgoal):\n 1. ((n\\<^sub>1', s\\<^sub>1'), n\\<^sub>2, s\\<^sub>2) \\<in> WS S", "from \\<open>targetnode a = n\\<^sub>1'\\<close> \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  targetnode a = n\\<^sub>1'\n  valid_edge a", "have \"valid_node n\\<^sub>1'\""], ["proof (prove)\nusing this:\n  targetnode a = n\\<^sub>1'\n  valid_edge a\n\ngoal (1 subgoal):\n 1. valid_node n\\<^sub>1'", "by(auto simp:valid_node_def)"], ["proof (state)\nthis:\n  valid_node n\\<^sub>1'\n\ngoal (1 subgoal):\n 1. ((n\\<^sub>1', s\\<^sub>1'), n\\<^sub>2, s\\<^sub>2) \\<in> WS S", "have \"(\\<exists>m. obs n\\<^sub>1' (backward_slice S) = {m}) \\<or> obs n\\<^sub>1' (backward_slice S) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>m. obs n\\<^sub>1' (backward_slice S) = {m}) \\<or>\n    obs n\\<^sub>1' (backward_slice S) = {}", "by(rule obs_singleton_disj)"], ["proof (state)\nthis:\n  (\\<exists>m. obs n\\<^sub>1' (backward_slice S) = {m}) \\<or>\n  obs n\\<^sub>1' (backward_slice S) = {}\n\ngoal (1 subgoal):\n 1. ((n\\<^sub>1', s\\<^sub>1'), n\\<^sub>2, s\\<^sub>2) \\<in> WS S", "with \\<open>obs n\\<^sub>1' (backward_slice S) \\<noteq> {}\\<close>"], ["proof (chain)\npicking this:\n  obs n\\<^sub>1' (backward_slice S) \\<noteq> {}\n  (\\<exists>m. obs n\\<^sub>1' (backward_slice S) = {m}) \\<or>\n  obs n\\<^sub>1' (backward_slice S) = {}", "obtain n \n    where \"obs n\\<^sub>1' (backward_slice S) = {n}\""], ["proof (prove)\nusing this:\n  obs n\\<^sub>1' (backward_slice S) \\<noteq> {}\n  (\\<exists>m. obs n\\<^sub>1' (backward_slice S) = {m}) \\<or>\n  obs n\\<^sub>1' (backward_slice S) = {}\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        obs n\\<^sub>1' (backward_slice S) = {n} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  obs n\\<^sub>1' (backward_slice S) = {n}\n\ngoal (1 subgoal):\n 1. ((n\\<^sub>1', s\\<^sub>1'), n\\<^sub>2, s\\<^sub>2) \\<in> WS S", "hence \"n \\<in> obs n\\<^sub>1' (backward_slice S)\""], ["proof (prove)\nusing this:\n  obs n\\<^sub>1' (backward_slice S) = {n}\n\ngoal (1 subgoal):\n 1. n \\<in> obs n\\<^sub>1' (backward_slice S)", "by auto"], ["proof (state)\nthis:\n  n \\<in> obs n\\<^sub>1' (backward_slice S)\n\ngoal (1 subgoal):\n 1. ((n\\<^sub>1', s\\<^sub>1'), n\\<^sub>2, s\\<^sub>2) \\<in> WS S", "then"], ["proof (chain)\npicking this:\n  n \\<in> obs n\\<^sub>1' (backward_slice S)", "obtain as where \"n\\<^sub>1' -as\\<rightarrow>* n\" \n    and \"\\<forall>nx \\<in> set(sourcenodes as). nx \\<notin> (backward_slice S)\" \n    and \"n \\<in> (backward_slice S)\""], ["proof (prove)\nusing this:\n  n \\<in> obs n\\<^sub>1' (backward_slice S)\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        \\<lbrakk>n\\<^sub>1' -as\\<rightarrow>* n;\n         \\<forall>nx\\<in>set (sourcenodes as). nx \\<notin> backward_slice S;\n         n \\<in> backward_slice S\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule obsE)"], ["proof (state)\nthis:\n  n\\<^sub>1' -as\\<rightarrow>* n\n  \\<forall>nx\\<in>set (sourcenodes as). nx \\<notin> backward_slice S\n  n \\<in> backward_slice S\n\ngoal (1 subgoal):\n 1. ((n\\<^sub>1', s\\<^sub>1'), n\\<^sub>2, s\\<^sub>2) \\<in> WS S", "from \\<open>n\\<^sub>1' -as\\<rightarrow>* n\\<close> \\<open>valid_edge a\\<close> \\<open>sourcenode a = n\\<^sub>1\\<close> \\<open>targetnode a = n\\<^sub>1'\\<close>"], ["proof (chain)\npicking this:\n  n\\<^sub>1' -as\\<rightarrow>* n\n  valid_edge a\n  sourcenode a = n\\<^sub>1\n  targetnode a = n\\<^sub>1'", "have \"n\\<^sub>1 -a#as\\<rightarrow>* n\""], ["proof (prove)\nusing this:\n  n\\<^sub>1' -as\\<rightarrow>* n\n  valid_edge a\n  sourcenode a = n\\<^sub>1\n  targetnode a = n\\<^sub>1'\n\ngoal (1 subgoal):\n 1. n\\<^sub>1 -a # as\\<rightarrow>* n", "by(rule Cons_path)"], ["proof (state)\nthis:\n  n\\<^sub>1 -a # as\\<rightarrow>* n\n\ngoal (1 subgoal):\n 1. ((n\\<^sub>1', s\\<^sub>1'), n\\<^sub>2, s\\<^sub>2) \\<in> WS S", "moreover"], ["proof (state)\nthis:\n  n\\<^sub>1 -a # as\\<rightarrow>* n\n\ngoal (1 subgoal):\n 1. ((n\\<^sub>1', s\\<^sub>1'), n\\<^sub>2, s\\<^sub>2) \\<in> WS S", "from \\<open>\\<forall>nx \\<in> set(sourcenodes as). nx \\<notin> (backward_slice S)\\<close> \\<open>sourcenode a = n\\<^sub>1\\<close>\n    \\<open>n\\<^sub>1 \\<notin> backward_slice S\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>nx\\<in>set (sourcenodes as). nx \\<notin> backward_slice S\n  sourcenode a = n\\<^sub>1\n  n\\<^sub>1 \\<notin> backward_slice S", "have \"\\<forall>nx \\<in> set(sourcenodes (a#as)). nx \\<notin> (backward_slice S)\""], ["proof (prove)\nusing this:\n  \\<forall>nx\\<in>set (sourcenodes as). nx \\<notin> backward_slice S\n  sourcenode a = n\\<^sub>1\n  n\\<^sub>1 \\<notin> backward_slice S\n\ngoal (1 subgoal):\n 1. \\<forall>nx\\<in>set (sourcenodes (a # as)). nx \\<notin> backward_slice S", "by(simp add:sourcenodes_def)"], ["proof (state)\nthis:\n  \\<forall>nx\\<in>set (sourcenodes (a # as)). nx \\<notin> backward_slice S\n\ngoal (1 subgoal):\n 1. ((n\\<^sub>1', s\\<^sub>1'), n\\<^sub>2, s\\<^sub>2) \\<in> WS S", "ultimately"], ["proof (chain)\npicking this:\n  n\\<^sub>1 -a # as\\<rightarrow>* n\n  \\<forall>nx\\<in>set (sourcenodes (a # as)). nx \\<notin> backward_slice S", "have \"n \\<in> obs n\\<^sub>1 (backward_slice S)\""], ["proof (prove)\nusing this:\n  n\\<^sub>1 -a # as\\<rightarrow>* n\n  \\<forall>nx\\<in>set (sourcenodes (a # as)). nx \\<notin> backward_slice S\n\ngoal (1 subgoal):\n 1. n \\<in> obs n\\<^sub>1 (backward_slice S)", "using \\<open>n \\<in> (backward_slice S)\\<close>"], ["proof (prove)\nusing this:\n  n\\<^sub>1 -a # as\\<rightarrow>* n\n  \\<forall>nx\\<in>set (sourcenodes (a # as)). nx \\<notin> backward_slice S\n  n \\<in> backward_slice S\n\ngoal (1 subgoal):\n 1. n \\<in> obs n\\<^sub>1 (backward_slice S)", "by(rule obs_elem)"], ["proof (state)\nthis:\n  n \\<in> obs n\\<^sub>1 (backward_slice S)\n\ngoal (1 subgoal):\n 1. ((n\\<^sub>1', s\\<^sub>1'), n\\<^sub>2, s\\<^sub>2) \\<in> WS S", "hence \"obs n\\<^sub>1 (backward_slice S) = {n}\""], ["proof (prove)\nusing this:\n  n \\<in> obs n\\<^sub>1 (backward_slice S)\n\ngoal (1 subgoal):\n 1. obs n\\<^sub>1 (backward_slice S) = {n}", "by(rule obs_singleton_element)"], ["proof (state)\nthis:\n  obs n\\<^sub>1 (backward_slice S) = {n}\n\ngoal (1 subgoal):\n 1. ((n\\<^sub>1', s\\<^sub>1'), n\\<^sub>2, s\\<^sub>2) \\<in> WS S", "with \\<open>obs n\\<^sub>1' (backward_slice S) = {n}\\<close>"], ["proof (chain)\npicking this:\n  obs n\\<^sub>1' (backward_slice S) = {n}\n  obs n\\<^sub>1 (backward_slice S) = {n}", "have \"obs n\\<^sub>1 (backward_slice S) = obs n\\<^sub>1' (backward_slice S)\""], ["proof (prove)\nusing this:\n  obs n\\<^sub>1' (backward_slice S) = {n}\n  obs n\\<^sub>1 (backward_slice S) = {n}\n\ngoal (1 subgoal):\n 1. obs n\\<^sub>1 (backward_slice S) = obs n\\<^sub>1' (backward_slice S)", "by simp"], ["proof (state)\nthis:\n  obs n\\<^sub>1 (backward_slice S) = obs n\\<^sub>1' (backward_slice S)\n\ngoal (1 subgoal):\n 1. ((n\\<^sub>1', s\\<^sub>1'), n\\<^sub>2, s\\<^sub>2) \\<in> WS S", "with \\<open>valid_node n\\<^sub>1\\<close> \\<open>valid_node n\\<^sub>1'\\<close>"], ["proof (chain)\npicking this:\n  valid_node n\\<^sub>1\n  valid_node n\\<^sub>1'\n  obs n\\<^sub>1 (backward_slice S) = obs n\\<^sub>1' (backward_slice S)", "have \"rv S n\\<^sub>1 = rv S n\\<^sub>1'\""], ["proof (prove)\nusing this:\n  valid_node n\\<^sub>1\n  valid_node n\\<^sub>1'\n  obs n\\<^sub>1 (backward_slice S) = obs n\\<^sub>1' (backward_slice S)\n\ngoal (1 subgoal):\n 1. rv S n\\<^sub>1 = rv S n\\<^sub>1'", "by(rule closed_eq_obs_eq_rvs)"], ["proof (state)\nthis:\n  rv S n\\<^sub>1 = rv S n\\<^sub>1'\n\ngoal (1 subgoal):\n 1. ((n\\<^sub>1', s\\<^sub>1'), n\\<^sub>2, s\\<^sub>2) \\<in> WS S", "from \\<open>n \\<in> obs n\\<^sub>1 (backward_slice S)\\<close> \\<open>((n\\<^sub>1,s\\<^sub>1),(n\\<^sub>2,s\\<^sub>2)) \\<in> WS S\\<close>"], ["proof (chain)\npicking this:\n  n \\<in> obs n\\<^sub>1 (backward_slice S)\n  ((n\\<^sub>1, s\\<^sub>1), n\\<^sub>2, s\\<^sub>2) \\<in> WS S", "have \"obs n\\<^sub>1 (backward_slice S) = obs n\\<^sub>2 (backward_slice S)\"\n    and \"\\<forall>V \\<in> rv S n\\<^sub>1. state_val s\\<^sub>1 V = state_val s\\<^sub>2 V\""], ["proof (prove)\nusing this:\n  n \\<in> obs n\\<^sub>1 (backward_slice S)\n  ((n\\<^sub>1, s\\<^sub>1), n\\<^sub>2, s\\<^sub>2) \\<in> WS S\n\ngoal (1 subgoal):\n 1. obs n\\<^sub>1 (backward_slice S) = obs n\\<^sub>2 (backward_slice S) &&&\n    \\<forall>V\\<in>rv S n\\<^sub>1.\n       state_val s\\<^sub>1 V = state_val s\\<^sub>2 V", "by(fastforce dest:WSD)+"], ["proof (state)\nthis:\n  obs n\\<^sub>1 (backward_slice S) = obs n\\<^sub>2 (backward_slice S)\n  \\<forall>V\\<in>rv S n\\<^sub>1.\n     state_val s\\<^sub>1 V = state_val s\\<^sub>2 V\n\ngoal (1 subgoal):\n 1. ((n\\<^sub>1', s\\<^sub>1'), n\\<^sub>2, s\\<^sub>2) \\<in> WS S", "from \\<open>obs n\\<^sub>1 (backward_slice S) = obs n\\<^sub>2 (backward_slice S)\\<close>\n    \\<open>obs n\\<^sub>1 (backward_slice S) = {n}\\<close> \\<open>obs n\\<^sub>1' (backward_slice S) = {n}\\<close>"], ["proof (chain)\npicking this:\n  obs n\\<^sub>1 (backward_slice S) = obs n\\<^sub>2 (backward_slice S)\n  obs n\\<^sub>1 (backward_slice S) = {n}\n  obs n\\<^sub>1' (backward_slice S) = {n}", "have \"obs n\\<^sub>1' (backward_slice S) = obs n\\<^sub>2 (backward_slice S)\""], ["proof (prove)\nusing this:\n  obs n\\<^sub>1 (backward_slice S) = obs n\\<^sub>2 (backward_slice S)\n  obs n\\<^sub>1 (backward_slice S) = {n}\n  obs n\\<^sub>1' (backward_slice S) = {n}\n\ngoal (1 subgoal):\n 1. obs n\\<^sub>1' (backward_slice S) = obs n\\<^sub>2 (backward_slice S)", "by simp"], ["proof (state)\nthis:\n  obs n\\<^sub>1' (backward_slice S) = obs n\\<^sub>2 (backward_slice S)\n\ngoal (1 subgoal):\n 1. ((n\\<^sub>1', s\\<^sub>1'), n\\<^sub>2, s\\<^sub>2) \\<in> WS S", "have \"\\<forall>V \\<in> rv S n\\<^sub>1'. state_val s\\<^sub>1' V = state_val s\\<^sub>2 V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>rv S n\\<^sub>1'.\n       state_val s\\<^sub>1' V = state_val s\\<^sub>2 V", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S n\\<^sub>1' \\<Longrightarrow>\n       state_val s\\<^sub>1' V = state_val s\\<^sub>2 V", "fix V"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S n\\<^sub>1' \\<Longrightarrow>\n       state_val s\\<^sub>1' V = state_val s\\<^sub>2 V", "assume \"V \\<in> rv S n\\<^sub>1'\""], ["proof (state)\nthis:\n  V \\<in> rv S n\\<^sub>1'\n\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S n\\<^sub>1' \\<Longrightarrow>\n       state_val s\\<^sub>1' V = state_val s\\<^sub>2 V", "with \\<open>rv S n\\<^sub>1 = rv S n\\<^sub>1'\\<close>"], ["proof (chain)\npicking this:\n  rv S n\\<^sub>1 = rv S n\\<^sub>1'\n  V \\<in> rv S n\\<^sub>1'", "have \"V \\<in> rv S n\\<^sub>1\""], ["proof (prove)\nusing this:\n  rv S n\\<^sub>1 = rv S n\\<^sub>1'\n  V \\<in> rv S n\\<^sub>1'\n\ngoal (1 subgoal):\n 1. V \\<in> rv S n\\<^sub>1", "by simp"], ["proof (state)\nthis:\n  V \\<in> rv S n\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S n\\<^sub>1' \\<Longrightarrow>\n       state_val s\\<^sub>1' V = state_val s\\<^sub>2 V", "then"], ["proof (chain)\npicking this:\n  V \\<in> rv S n\\<^sub>1", "obtain as n' where \"n\\<^sub>1 -as\\<rightarrow>* n'\" and \"n' \\<in> (backward_slice S)\"\n      and \"V \\<in> Use n'\" and \"\\<forall>nx \\<in> set(sourcenodes as). V \\<notin> Def nx\""], ["proof (prove)\nusing this:\n  V \\<in> rv S n\\<^sub>1\n\ngoal (1 subgoal):\n 1. (\\<And>as n'.\n        \\<lbrakk>n\\<^sub>1 -as\\<rightarrow>* n'; n' \\<in> backward_slice S;\n         V \\<in> Use n';\n         \\<forall>nx\\<in>set (sourcenodes as). V \\<notin> Def nx\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule rvE)"], ["proof (state)\nthis:\n  n\\<^sub>1 -as\\<rightarrow>* n'\n  n' \\<in> backward_slice S\n  V \\<in> Use n'\n  \\<forall>nx\\<in>set (sourcenodes as). V \\<notin> Def nx\n\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S n\\<^sub>1' \\<Longrightarrow>\n       state_val s\\<^sub>1' V = state_val s\\<^sub>2 V", "with \\<open>n\\<^sub>1 \\<notin> backward_slice S\\<close>"], ["proof (chain)\npicking this:\n  n\\<^sub>1 \\<notin> backward_slice S\n  n\\<^sub>1 -as\\<rightarrow>* n'\n  n' \\<in> backward_slice S\n  V \\<in> Use n'\n  \\<forall>nx\\<in>set (sourcenodes as). V \\<notin> Def nx", "have \"V \\<notin> Def n\\<^sub>1\""], ["proof (prove)\nusing this:\n  n\\<^sub>1 \\<notin> backward_slice S\n  n\\<^sub>1 -as\\<rightarrow>* n'\n  n' \\<in> backward_slice S\n  V \\<in> Use n'\n  \\<forall>nx\\<in>set (sourcenodes as). V \\<notin> Def nx\n\ngoal (1 subgoal):\n 1. V \\<notin> Def n\\<^sub>1", "by(auto elim:path.cases simp:sourcenodes_def)"], ["proof (state)\nthis:\n  V \\<notin> Def n\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S n\\<^sub>1' \\<Longrightarrow>\n       state_val s\\<^sub>1' V = state_val s\\<^sub>2 V", "with \\<open>valid_edge a\\<close> \\<open>sourcenode a = n\\<^sub>1\\<close> \\<open>pred (kind a) s\\<^sub>1\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  sourcenode a = n\\<^sub>1\n  pred (kind a) s\\<^sub>1\n  V \\<notin> Def n\\<^sub>1", "have \"state_val (transfer (kind a) s\\<^sub>1) V = state_val s\\<^sub>1 V\""], ["proof (prove)\nusing this:\n  valid_edge a\n  sourcenode a = n\\<^sub>1\n  pred (kind a) s\\<^sub>1\n  V \\<notin> Def n\\<^sub>1\n\ngoal (1 subgoal):\n 1. state_val (transfer (kind a) s\\<^sub>1) V = state_val s\\<^sub>1 V", "by(fastforce intro:CFG_edge_no_Def_equal)"], ["proof (state)\nthis:\n  state_val (transfer (kind a) s\\<^sub>1) V = state_val s\\<^sub>1 V\n\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S n\\<^sub>1' \\<Longrightarrow>\n       state_val s\\<^sub>1' V = state_val s\\<^sub>2 V", "with \\<open>transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\\<close>"], ["proof (chain)\npicking this:\n  transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\n  state_val (transfer (kind a) s\\<^sub>1) V = state_val s\\<^sub>1 V", "have \"state_val s\\<^sub>1' V = state_val s\\<^sub>1 V\""], ["proof (prove)\nusing this:\n  transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\n  state_val (transfer (kind a) s\\<^sub>1) V = state_val s\\<^sub>1 V\n\ngoal (1 subgoal):\n 1. state_val s\\<^sub>1' V = state_val s\\<^sub>1 V", "by simp"], ["proof (state)\nthis:\n  state_val s\\<^sub>1' V = state_val s\\<^sub>1 V\n\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S n\\<^sub>1' \\<Longrightarrow>\n       state_val s\\<^sub>1' V = state_val s\\<^sub>2 V", "from \\<open>V \\<in> rv S n\\<^sub>1\\<close> \\<open>\\<forall>V \\<in> rv S n\\<^sub>1. state_val s\\<^sub>1 V = state_val s\\<^sub>2 V\\<close>"], ["proof (chain)\npicking this:\n  V \\<in> rv S n\\<^sub>1\n  \\<forall>V\\<in>rv S n\\<^sub>1.\n     state_val s\\<^sub>1 V = state_val s\\<^sub>2 V", "have \"state_val s\\<^sub>1 V = state_val s\\<^sub>2 V\""], ["proof (prove)\nusing this:\n  V \\<in> rv S n\\<^sub>1\n  \\<forall>V\\<in>rv S n\\<^sub>1.\n     state_val s\\<^sub>1 V = state_val s\\<^sub>2 V\n\ngoal (1 subgoal):\n 1. state_val s\\<^sub>1 V = state_val s\\<^sub>2 V", "by simp"], ["proof (state)\nthis:\n  state_val s\\<^sub>1 V = state_val s\\<^sub>2 V\n\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S n\\<^sub>1' \\<Longrightarrow>\n       state_val s\\<^sub>1' V = state_val s\\<^sub>2 V", "with \\<open>state_val s\\<^sub>1' V = state_val s\\<^sub>1 V\\<close>"], ["proof (chain)\npicking this:\n  state_val s\\<^sub>1' V = state_val s\\<^sub>1 V\n  state_val s\\<^sub>1 V = state_val s\\<^sub>2 V", "show \"state_val s\\<^sub>1' V = state_val s\\<^sub>2 V\""], ["proof (prove)\nusing this:\n  state_val s\\<^sub>1' V = state_val s\\<^sub>1 V\n  state_val s\\<^sub>1 V = state_val s\\<^sub>2 V\n\ngoal (1 subgoal):\n 1. state_val s\\<^sub>1' V = state_val s\\<^sub>2 V", "by simp"], ["proof (state)\nthis:\n  state_val s\\<^sub>1' V = state_val s\\<^sub>2 V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>V\\<in>rv S n\\<^sub>1'.\n     state_val s\\<^sub>1' V = state_val s\\<^sub>2 V\n\ngoal (1 subgoal):\n 1. ((n\\<^sub>1', s\\<^sub>1'), n\\<^sub>2, s\\<^sub>2) \\<in> WS S", "with \\<open>obs n\\<^sub>1' (backward_slice S) = obs n\\<^sub>2 (backward_slice S)\\<close>\n    \\<open>valid_node n\\<^sub>1'\\<close> \\<open>valid_node n\\<^sub>2\\<close>"], ["proof (chain)\npicking this:\n  obs n\\<^sub>1' (backward_slice S) = obs n\\<^sub>2 (backward_slice S)\n  valid_node n\\<^sub>1'\n  valid_node n\\<^sub>2\n  \\<forall>V\\<in>rv S n\\<^sub>1'.\n     state_val s\\<^sub>1' V = state_val s\\<^sub>2 V", "show ?thesis"], ["proof (prove)\nusing this:\n  obs n\\<^sub>1' (backward_slice S) = obs n\\<^sub>2 (backward_slice S)\n  valid_node n\\<^sub>1'\n  valid_node n\\<^sub>2\n  \\<forall>V\\<in>rv S n\\<^sub>1'.\n     state_val s\\<^sub>1' V = state_val s\\<^sub>2 V\n\ngoal (1 subgoal):\n 1. ((n\\<^sub>1', s\\<^sub>1'), n\\<^sub>2, s\\<^sub>2) \\<in> WS S", "by(fastforce intro:WSI)"], ["proof (state)\nthis:\n  ((n\\<^sub>1', s\\<^sub>1'), n\\<^sub>2, s\\<^sub>2) \\<in> WS S\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma WS_silent_moves:\n  \"\\<lbrakk>S,f \\<turnstile> (n\\<^sub>1,s\\<^sub>1) =as\\<Rightarrow>\\<^sub>\\<tau> (n\\<^sub>1',s\\<^sub>1'); ((n\\<^sub>1,s\\<^sub>1),(n\\<^sub>2,s\\<^sub>2)) \\<in> WS S; f = kind;\n    obs n\\<^sub>1' (backward_slice S) \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> ((n\\<^sub>1',s\\<^sub>1'),(n\\<^sub>2,s\\<^sub>2)) \\<in> WS S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,f \\<turnstile> (n\\<^sub>1,s\\<^sub>1) =as\\<Rightarrow>\\<^sub>\\<tau> (n\\<^sub>1',s\\<^sub>1');\n     ((n\\<^sub>1, s\\<^sub>1), n\\<^sub>2, s\\<^sub>2) \\<in> WS S; f = kind;\n     obs n\\<^sub>1' (backward_slice S) \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> ((n\\<^sub>1', s\\<^sub>1'), n\\<^sub>2, s\\<^sub>2)\n                      \\<in> WS S", "proof(induct rule:silent_moves.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>S f n s.\n       \\<lbrakk>((n, s), n\\<^sub>2, s\\<^sub>2) \\<in> WS S; f = kind;\n        obs n (backward_slice S) \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> ((n, s), n\\<^sub>2, s\\<^sub>2) \\<in> WS S\n 2. \\<And>S f n s a n' s' as n'' s''.\n       \\<lbrakk>S,f \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n',s');\n        S,f \\<turnstile> (n',s') =as\\<Rightarrow>\\<^sub>\\<tau> (n'',s'');\n        \\<lbrakk>((n', s'), n\\<^sub>2, s\\<^sub>2) \\<in> WS S; f = kind;\n         obs n'' (backward_slice S) \\<noteq> {}\\<rbrakk>\n        \\<Longrightarrow> ((n'', s''), n\\<^sub>2, s\\<^sub>2) \\<in> WS S;\n        ((n, s), n\\<^sub>2, s\\<^sub>2) \\<in> WS S; f = kind;\n        obs n'' (backward_slice S) \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> ((n'', s''), n\\<^sub>2, s\\<^sub>2) \\<in> WS S", "case silent_moves_Nil"], ["proof (state)\nthis:\n  ((n_, s_), n\\<^sub>2, s\\<^sub>2) \\<in> WS S_\n  f_ = kind\n  obs n_ (backward_slice S_) \\<noteq> {}\n\ngoal (2 subgoals):\n 1. \\<And>S f n s.\n       \\<lbrakk>((n, s), n\\<^sub>2, s\\<^sub>2) \\<in> WS S; f = kind;\n        obs n (backward_slice S) \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> ((n, s), n\\<^sub>2, s\\<^sub>2) \\<in> WS S\n 2. \\<And>S f n s a n' s' as n'' s''.\n       \\<lbrakk>S,f \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n',s');\n        S,f \\<turnstile> (n',s') =as\\<Rightarrow>\\<^sub>\\<tau> (n'',s'');\n        \\<lbrakk>((n', s'), n\\<^sub>2, s\\<^sub>2) \\<in> WS S; f = kind;\n         obs n'' (backward_slice S) \\<noteq> {}\\<rbrakk>\n        \\<Longrightarrow> ((n'', s''), n\\<^sub>2, s\\<^sub>2) \\<in> WS S;\n        ((n, s), n\\<^sub>2, s\\<^sub>2) \\<in> WS S; f = kind;\n        obs n'' (backward_slice S) \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> ((n'', s''), n\\<^sub>2, s\\<^sub>2) \\<in> WS S", "thus ?case"], ["proof (prove)\nusing this:\n  ((n_, s_), n\\<^sub>2, s\\<^sub>2) \\<in> WS S_\n  f_ = kind\n  obs n_ (backward_slice S_) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. ((n_, s_), n\\<^sub>2, s\\<^sub>2) \\<in> WS S_", "by simp"], ["proof (state)\nthis:\n  ((n_, s_), n\\<^sub>2, s\\<^sub>2) \\<in> WS S_\n\ngoal (1 subgoal):\n 1. \\<And>S f n s a n' s' as n'' s''.\n       \\<lbrakk>S,f \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n',s');\n        S,f \\<turnstile> (n',s') =as\\<Rightarrow>\\<^sub>\\<tau> (n'',s'');\n        \\<lbrakk>((n', s'), n\\<^sub>2, s\\<^sub>2) \\<in> WS S; f = kind;\n         obs n'' (backward_slice S) \\<noteq> {}\\<rbrakk>\n        \\<Longrightarrow> ((n'', s''), n\\<^sub>2, s\\<^sub>2) \\<in> WS S;\n        ((n, s), n\\<^sub>2, s\\<^sub>2) \\<in> WS S; f = kind;\n        obs n'' (backward_slice S) \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> ((n'', s''), n\\<^sub>2, s\\<^sub>2) \\<in> WS S", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S f n s a n' s' as n'' s''.\n       \\<lbrakk>S,f \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n',s');\n        S,f \\<turnstile> (n',s') =as\\<Rightarrow>\\<^sub>\\<tau> (n'',s'');\n        \\<lbrakk>((n', s'), n\\<^sub>2, s\\<^sub>2) \\<in> WS S; f = kind;\n         obs n'' (backward_slice S) \\<noteq> {}\\<rbrakk>\n        \\<Longrightarrow> ((n'', s''), n\\<^sub>2, s\\<^sub>2) \\<in> WS S;\n        ((n, s), n\\<^sub>2, s\\<^sub>2) \\<in> WS S; f = kind;\n        obs n'' (backward_slice S) \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> ((n'', s''), n\\<^sub>2, s\\<^sub>2) \\<in> WS S", "case (silent_moves_Cons S f n s a n' s' as n'' s'')"], ["proof (state)\nthis:\n  S,f \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n',s')\n  S,f \\<turnstile> (n',s') =as\\<Rightarrow>\\<^sub>\\<tau> (n'',s'')\n  \\<lbrakk>((n', s'), n\\<^sub>2, s\\<^sub>2) \\<in> WS S; f = kind;\n   obs n'' (backward_slice S) \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> ((n'', s''), n\\<^sub>2, s\\<^sub>2) \\<in> WS S\n  ((n, s), n\\<^sub>2, s\\<^sub>2) \\<in> WS S\n  f = kind\n  obs n'' (backward_slice S) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>S f n s a n' s' as n'' s''.\n       \\<lbrakk>S,f \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n',s');\n        S,f \\<turnstile> (n',s') =as\\<Rightarrow>\\<^sub>\\<tau> (n'',s'');\n        \\<lbrakk>((n', s'), n\\<^sub>2, s\\<^sub>2) \\<in> WS S; f = kind;\n         obs n'' (backward_slice S) \\<noteq> {}\\<rbrakk>\n        \\<Longrightarrow> ((n'', s''), n\\<^sub>2, s\\<^sub>2) \\<in> WS S;\n        ((n, s), n\\<^sub>2, s\\<^sub>2) \\<in> WS S; f = kind;\n        obs n'' (backward_slice S) \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> ((n'', s''), n\\<^sub>2, s\\<^sub>2) \\<in> WS S", "note IH = \\<open>\\<lbrakk>((n',s'),(n\\<^sub>2,s\\<^sub>2)) \\<in> WS S; f = kind; obs n'' (backward_slice S) \\<noteq> {}\\<rbrakk>\n             \\<Longrightarrow> ((n'',s''),(n\\<^sub>2,s\\<^sub>2)) \\<in> WS S\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>((n', s'), n\\<^sub>2, s\\<^sub>2) \\<in> WS S; f = kind;\n   obs n'' (backward_slice S) \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> ((n'', s''), n\\<^sub>2, s\\<^sub>2) \\<in> WS S\n\ngoal (1 subgoal):\n 1. \\<And>S f n s a n' s' as n'' s''.\n       \\<lbrakk>S,f \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n',s');\n        S,f \\<turnstile> (n',s') =as\\<Rightarrow>\\<^sub>\\<tau> (n'',s'');\n        \\<lbrakk>((n', s'), n\\<^sub>2, s\\<^sub>2) \\<in> WS S; f = kind;\n         obs n'' (backward_slice S) \\<noteq> {}\\<rbrakk>\n        \\<Longrightarrow> ((n'', s''), n\\<^sub>2, s\\<^sub>2) \\<in> WS S;\n        ((n, s), n\\<^sub>2, s\\<^sub>2) \\<in> WS S; f = kind;\n        obs n'' (backward_slice S) \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> ((n'', s''), n\\<^sub>2, s\\<^sub>2) \\<in> WS S", "from \\<open>S,f \\<turnstile> (n',s') =as\\<Rightarrow>\\<^sub>\\<tau> (n'',s'')\\<close> \\<open>obs n'' (backward_slice S) \\<noteq> {}\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (n',s') =as\\<Rightarrow>\\<^sub>\\<tau> (n'',s'')\n  obs n'' (backward_slice S) \\<noteq> {}", "have \"obs n' (backward_slice S) \\<noteq> {}\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (n',s') =as\\<Rightarrow>\\<^sub>\\<tau> (n'',s'')\n  obs n'' (backward_slice S) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. obs n' (backward_slice S) \\<noteq> {}", "by(fastforce dest:silent_moves_obs_slice)"], ["proof (state)\nthis:\n  obs n' (backward_slice S) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>S f n s a n' s' as n'' s''.\n       \\<lbrakk>S,f \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n',s');\n        S,f \\<turnstile> (n',s') =as\\<Rightarrow>\\<^sub>\\<tau> (n'',s'');\n        \\<lbrakk>((n', s'), n\\<^sub>2, s\\<^sub>2) \\<in> WS S; f = kind;\n         obs n'' (backward_slice S) \\<noteq> {}\\<rbrakk>\n        \\<Longrightarrow> ((n'', s''), n\\<^sub>2, s\\<^sub>2) \\<in> WS S;\n        ((n, s), n\\<^sub>2, s\\<^sub>2) \\<in> WS S; f = kind;\n        obs n'' (backward_slice S) \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> ((n'', s''), n\\<^sub>2, s\\<^sub>2) \\<in> WS S", "with \\<open>((n,s),(n\\<^sub>2,s\\<^sub>2)) \\<in> WS S\\<close> \\<open>S,f \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n',s')\\<close> \\<open>f = kind\\<close>"], ["proof (chain)\npicking this:\n  ((n, s), n\\<^sub>2, s\\<^sub>2) \\<in> WS S\n  S,f \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n',s')\n  f = kind\n  obs n' (backward_slice S) \\<noteq> {}", "have \"((n',s'),(n\\<^sub>2,s\\<^sub>2)) \\<in> WS S\""], ["proof (prove)\nusing this:\n  ((n, s), n\\<^sub>2, s\\<^sub>2) \\<in> WS S\n  S,f \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n',s')\n  f = kind\n  obs n' (backward_slice S) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. ((n', s'), n\\<^sub>2, s\\<^sub>2) \\<in> WS S", "by -(rule WS_silent_move,simp+)"], ["proof (state)\nthis:\n  ((n', s'), n\\<^sub>2, s\\<^sub>2) \\<in> WS S\n\ngoal (1 subgoal):\n 1. \\<And>S f n s a n' s' as n'' s''.\n       \\<lbrakk>S,f \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n',s');\n        S,f \\<turnstile> (n',s') =as\\<Rightarrow>\\<^sub>\\<tau> (n'',s'');\n        \\<lbrakk>((n', s'), n\\<^sub>2, s\\<^sub>2) \\<in> WS S; f = kind;\n         obs n'' (backward_slice S) \\<noteq> {}\\<rbrakk>\n        \\<Longrightarrow> ((n'', s''), n\\<^sub>2, s\\<^sub>2) \\<in> WS S;\n        ((n, s), n\\<^sub>2, s\\<^sub>2) \\<in> WS S; f = kind;\n        obs n'' (backward_slice S) \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> ((n'', s''), n\\<^sub>2, s\\<^sub>2) \\<in> WS S", "from IH[OF this \\<open>f = kind\\<close> \\<open>obs n'' (backward_slice S) \\<noteq> {}\\<close>]"], ["proof (chain)\npicking this:\n  ((n'', s''), n\\<^sub>2, s\\<^sub>2) \\<in> WS S", "show ?case"], ["proof (prove)\nusing this:\n  ((n'', s''), n\\<^sub>2, s\\<^sub>2) \\<in> WS S\n\ngoal (1 subgoal):\n 1. ((n'', s''), n\\<^sub>2, s\\<^sub>2) \\<in> WS S", "."], ["proof (state)\nthis:\n  ((n'', s''), n\\<^sub>2, s\\<^sub>2) \\<in> WS S\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma WS_observable_move:\n  assumes \"((n\\<^sub>1,s\\<^sub>1),(n\\<^sub>2,s\\<^sub>2)) \\<in> WS S\" and \"S,kind \\<turnstile> (n\\<^sub>1,s\\<^sub>1) -a\\<rightarrow> (n\\<^sub>1',s\\<^sub>1')\"\n  obtains as where \"((n\\<^sub>1',s\\<^sub>1'),(n\\<^sub>1',transfer (slice_kind S a) s\\<^sub>2)) \\<in> WS S\"\n  and \"S,slice_kind S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =as@[a]\\<Rightarrow> (n\\<^sub>1',transfer (slice_kind S a) s\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as.\n        \\<lbrakk>((n\\<^sub>1', s\\<^sub>1'), n\\<^sub>1',\n                  transfer (slice_kind S a) s\\<^sub>2)\n                 \\<in> WS S;\n         S,slice_kind\n            S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =as @\n            [a]\\<Rightarrow> (n\\<^sub>1',transfer (slice_kind S a)\n    s\\<^sub>2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as.\n       ((n\\<^sub>1', s\\<^sub>1'), n\\<^sub>1',\n        transfer (slice_kind S a) s\\<^sub>2)\n       \\<in> WS S \\<and>\n       S,slice_kind\n          S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =as @\n          [a]\\<Rightarrow> (n\\<^sub>1',transfer (slice_kind S a) s\\<^sub>2)", "from \\<open>((n\\<^sub>1,s\\<^sub>1),(n\\<^sub>2,s\\<^sub>2)) \\<in> WS S\\<close>"], ["proof (chain)\npicking this:\n  ((n\\<^sub>1, s\\<^sub>1), n\\<^sub>2, s\\<^sub>2) \\<in> WS S", "have \"valid_node n\\<^sub>1\""], ["proof (prove)\nusing this:\n  ((n\\<^sub>1, s\\<^sub>1), n\\<^sub>2, s\\<^sub>2) \\<in> WS S\n\ngoal (1 subgoal):\n 1. valid_node n\\<^sub>1", "by(auto dest:WSD)"], ["proof (state)\nthis:\n  valid_node n\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       ((n\\<^sub>1', s\\<^sub>1'), n\\<^sub>1',\n        transfer (slice_kind S a) s\\<^sub>2)\n       \\<in> WS S \\<and>\n       S,slice_kind\n          S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =as @\n          [a]\\<Rightarrow> (n\\<^sub>1',transfer (slice_kind S a) s\\<^sub>2)", "from \\<open>S,kind \\<turnstile> (n\\<^sub>1,s\\<^sub>1) -a\\<rightarrow> (n\\<^sub>1',s\\<^sub>1')\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (n\\<^sub>1,s\\<^sub>1) -a\\<rightarrow> (n\\<^sub>1',s\\<^sub>1')", "have [simp]:\"n\\<^sub>1 = sourcenode a\" \n    and [simp]:\"n\\<^sub>1' = targetnode a\" and \"pred (kind a) s\\<^sub>1\"\n    and \"transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\" and \"n\\<^sub>1 \\<in> (backward_slice S)\" \n    and \"valid_edge a\" and \"pred (kind a) s\\<^sub>1\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (n\\<^sub>1,s\\<^sub>1) -a\\<rightarrow> (n\\<^sub>1',s\\<^sub>1')\n\ngoal (1 subgoal):\n 1. (n\\<^sub>1 = sourcenode a &&&\n     n\\<^sub>1' = targetnode a &&& pred (kind a) s\\<^sub>1) &&&\n    (transfer (kind a) s\\<^sub>1 = s\\<^sub>1' &&&\n     n\\<^sub>1 \\<in> backward_slice S) &&&\n    valid_edge a &&& pred (kind a) s\\<^sub>1", "by(auto elim:observable_move.cases)"], ["proof (state)\nthis:\n  n\\<^sub>1 = sourcenode a\n  n\\<^sub>1' = targetnode a\n  pred (kind a) s\\<^sub>1\n  transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\n  n\\<^sub>1 \\<in> backward_slice S\n  valid_edge a\n  pred (kind a) s\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       ((n\\<^sub>1', s\\<^sub>1'), n\\<^sub>1',\n        transfer (slice_kind S a) s\\<^sub>2)\n       \\<in> WS S \\<and>\n       S,slice_kind\n          S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =as @\n          [a]\\<Rightarrow> (n\\<^sub>1',transfer (slice_kind S a) s\\<^sub>2)", "from  \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a", "have \"valid_node n\\<^sub>1'\""], ["proof (prove)\nusing this:\n  valid_edge a\n\ngoal (1 subgoal):\n 1. valid_node n\\<^sub>1'", "by(auto simp:valid_node_def)"], ["proof (state)\nthis:\n  valid_node n\\<^sub>1'\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       ((n\\<^sub>1', s\\<^sub>1'), n\\<^sub>1',\n        transfer (slice_kind S a) s\\<^sub>2)\n       \\<in> WS S \\<and>\n       S,slice_kind\n          S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =as @\n          [a]\\<Rightarrow> (n\\<^sub>1',transfer (slice_kind S a) s\\<^sub>2)", "from \\<open>valid_node n\\<^sub>1\\<close> \\<open>n\\<^sub>1 \\<in> (backward_slice S)\\<close>"], ["proof (chain)\npicking this:\n  valid_node n\\<^sub>1\n  n\\<^sub>1 \\<in> backward_slice S", "have \"obs n\\<^sub>1 (backward_slice S) = {n\\<^sub>1}\""], ["proof (prove)\nusing this:\n  valid_node n\\<^sub>1\n  n\\<^sub>1 \\<in> backward_slice S\n\ngoal (1 subgoal):\n 1. obs n\\<^sub>1 (backward_slice S) = {n\\<^sub>1}", "by(rule n_in_obs)"], ["proof (state)\nthis:\n  obs n\\<^sub>1 (backward_slice S) = {n\\<^sub>1}\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       ((n\\<^sub>1', s\\<^sub>1'), n\\<^sub>1',\n        transfer (slice_kind S a) s\\<^sub>2)\n       \\<in> WS S \\<and>\n       S,slice_kind\n          S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =as @\n          [a]\\<Rightarrow> (n\\<^sub>1',transfer (slice_kind S a) s\\<^sub>2)", "with \\<open>((n\\<^sub>1,s\\<^sub>1),(n\\<^sub>2,s\\<^sub>2)) \\<in> WS S\\<close>"], ["proof (chain)\npicking this:\n  ((n\\<^sub>1, s\\<^sub>1), n\\<^sub>2, s\\<^sub>2) \\<in> WS S\n  obs n\\<^sub>1 (backward_slice S) = {n\\<^sub>1}", "have \"obs n\\<^sub>2 (backward_slice S) = {n\\<^sub>1}\" \n    and \"\\<forall>V \\<in> rv S n\\<^sub>1. state_val s\\<^sub>1 V = state_val s\\<^sub>2 V\""], ["proof (prove)\nusing this:\n  ((n\\<^sub>1, s\\<^sub>1), n\\<^sub>2, s\\<^sub>2) \\<in> WS S\n  obs n\\<^sub>1 (backward_slice S) = {n\\<^sub>1}\n\ngoal (1 subgoal):\n 1. obs n\\<^sub>2 (backward_slice S) = {n\\<^sub>1} &&&\n    \\<forall>V\\<in>rv S n\\<^sub>1.\n       state_val s\\<^sub>1 V = state_val s\\<^sub>2 V", "by(auto dest:WSD)"], ["proof (state)\nthis:\n  obs n\\<^sub>2 (backward_slice S) = {n\\<^sub>1}\n  \\<forall>V\\<in>rv S n\\<^sub>1.\n     state_val s\\<^sub>1 V = state_val s\\<^sub>2 V\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       ((n\\<^sub>1', s\\<^sub>1'), n\\<^sub>1',\n        transfer (slice_kind S a) s\\<^sub>2)\n       \\<in> WS S \\<and>\n       S,slice_kind\n          S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =as @\n          [a]\\<Rightarrow> (n\\<^sub>1',transfer (slice_kind S a) s\\<^sub>2)", "from \\<open>valid_node n\\<^sub>1\\<close>"], ["proof (chain)\npicking this:\n  valid_node n\\<^sub>1", "have \"n\\<^sub>1 -[]\\<rightarrow>* n\\<^sub>1\""], ["proof (prove)\nusing this:\n  valid_node n\\<^sub>1\n\ngoal (1 subgoal):\n 1. n\\<^sub>1 -[]\\<rightarrow>* n\\<^sub>1", "by(rule empty_path)"], ["proof (state)\nthis:\n  n\\<^sub>1 -[]\\<rightarrow>* n\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       ((n\\<^sub>1', s\\<^sub>1'), n\\<^sub>1',\n        transfer (slice_kind S a) s\\<^sub>2)\n       \\<in> WS S \\<and>\n       S,slice_kind\n          S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =as @\n          [a]\\<Rightarrow> (n\\<^sub>1',transfer (slice_kind S a) s\\<^sub>2)", "with \\<open>n\\<^sub>1 \\<in> (backward_slice S)\\<close>"], ["proof (chain)\npicking this:\n  n\\<^sub>1 \\<in> backward_slice S\n  n\\<^sub>1 -[]\\<rightarrow>* n\\<^sub>1", "have \"\\<forall>V \\<in> Use n\\<^sub>1. V \\<in> rv S n\\<^sub>1\""], ["proof (prove)\nusing this:\n  n\\<^sub>1 \\<in> backward_slice S\n  n\\<^sub>1 -[]\\<rightarrow>* n\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use n\\<^sub>1. V \\<in> rv S n\\<^sub>1", "by(fastforce intro:rvI simp:sourcenodes_def)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use n\\<^sub>1. V \\<in> rv S n\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       ((n\\<^sub>1', s\\<^sub>1'), n\\<^sub>1',\n        transfer (slice_kind S a) s\\<^sub>2)\n       \\<in> WS S \\<and>\n       S,slice_kind\n          S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =as @\n          [a]\\<Rightarrow> (n\\<^sub>1',transfer (slice_kind S a) s\\<^sub>2)", "with \\<open>\\<forall>V \\<in> rv S n\\<^sub>1. state_val s\\<^sub>1 V = state_val s\\<^sub>2 V\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>rv S n\\<^sub>1.\n     state_val s\\<^sub>1 V = state_val s\\<^sub>2 V\n  \\<forall>V\\<in>Use n\\<^sub>1. V \\<in> rv S n\\<^sub>1", "have \"\\<forall>V \\<in> Use n\\<^sub>1. state_val s\\<^sub>1 V = state_val s\\<^sub>2 V\""], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>rv S n\\<^sub>1.\n     state_val s\\<^sub>1 V = state_val s\\<^sub>2 V\n  \\<forall>V\\<in>Use n\\<^sub>1. V \\<in> rv S n\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use n\\<^sub>1.\n       state_val s\\<^sub>1 V = state_val s\\<^sub>2 V", "by blast"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use n\\<^sub>1.\n     state_val s\\<^sub>1 V = state_val s\\<^sub>2 V\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       ((n\\<^sub>1', s\\<^sub>1'), n\\<^sub>1',\n        transfer (slice_kind S a) s\\<^sub>2)\n       \\<in> WS S \\<and>\n       S,slice_kind\n          S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =as @\n          [a]\\<Rightarrow> (n\\<^sub>1',transfer (slice_kind S a) s\\<^sub>2)", "with \\<open>valid_edge a\\<close>  \\<open>pred (kind a) s\\<^sub>1\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  pred (kind a) s\\<^sub>1\n  \\<forall>V\\<in>Use n\\<^sub>1.\n     state_val s\\<^sub>1 V = state_val s\\<^sub>2 V", "have \"pred (kind a) s\\<^sub>2\""], ["proof (prove)\nusing this:\n  valid_edge a\n  pred (kind a) s\\<^sub>1\n  \\<forall>V\\<in>Use n\\<^sub>1.\n     state_val s\\<^sub>1 V = state_val s\\<^sub>2 V\n\ngoal (1 subgoal):\n 1. pred (kind a) s\\<^sub>2", "by(fastforce intro:CFG_edge_Uses_pred_equal)"], ["proof (state)\nthis:\n  pred (kind a) s\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       ((n\\<^sub>1', s\\<^sub>1'), n\\<^sub>1',\n        transfer (slice_kind S a) s\\<^sub>2)\n       \\<in> WS S \\<and>\n       S,slice_kind\n          S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =as @\n          [a]\\<Rightarrow> (n\\<^sub>1',transfer (slice_kind S a) s\\<^sub>2)", "with \\<open>n\\<^sub>1 \\<in> (backward_slice S)\\<close>"], ["proof (chain)\npicking this:\n  n\\<^sub>1 \\<in> backward_slice S\n  pred (kind a) s\\<^sub>2", "have \"pred (slice_kind S a) s\\<^sub>2\""], ["proof (prove)\nusing this:\n  n\\<^sub>1 \\<in> backward_slice S\n  pred (kind a) s\\<^sub>2\n\ngoal (1 subgoal):\n 1. pred (slice_kind S a) s\\<^sub>2", "by(simp add:slice_kind_in_slice)"], ["proof (state)\nthis:\n  pred (slice_kind S a) s\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       ((n\\<^sub>1', s\\<^sub>1'), n\\<^sub>1',\n        transfer (slice_kind S a) s\\<^sub>2)\n       \\<in> WS S \\<and>\n       S,slice_kind\n          S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =as @\n          [a]\\<Rightarrow> (n\\<^sub>1',transfer (slice_kind S a) s\\<^sub>2)", "from \\<open>n\\<^sub>1 \\<in> (backward_slice S)\\<close>"], ["proof (chain)\npicking this:\n  n\\<^sub>1 \\<in> backward_slice S", "obtain s\\<^sub>2' \n    where \"transfer (slice_kind S a) s\\<^sub>2 = s\\<^sub>2'\""], ["proof (prove)\nusing this:\n  n\\<^sub>1 \\<in> backward_slice S\n\ngoal (1 subgoal):\n 1. (\\<And>s\\<^sub>2'.\n        transfer (slice_kind S a) s\\<^sub>2 = s\\<^sub>2' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(simp add:slice_kind_in_slice)"], ["proof (state)\nthis:\n  transfer (slice_kind S a) s\\<^sub>2 = s\\<^sub>2'\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       ((n\\<^sub>1', s\\<^sub>1'), n\\<^sub>1',\n        transfer (slice_kind S a) s\\<^sub>2)\n       \\<in> WS S \\<and>\n       S,slice_kind\n          S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =as @\n          [a]\\<Rightarrow> (n\\<^sub>1',transfer (slice_kind S a) s\\<^sub>2)", "with \\<open>pred (slice_kind S a) s\\<^sub>2\\<close> \\<open>n\\<^sub>1 \\<in> (backward_slice S)\\<close> \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  pred (slice_kind S a) s\\<^sub>2\n  n\\<^sub>1 \\<in> backward_slice S\n  valid_edge a\n  transfer (slice_kind S a) s\\<^sub>2 = s\\<^sub>2'", "have \"S,slice_kind S \\<turnstile> (n\\<^sub>1,s\\<^sub>2) -a\\<rightarrow> (n\\<^sub>1',s\\<^sub>2')\""], ["proof (prove)\nusing this:\n  pred (slice_kind S a) s\\<^sub>2\n  n\\<^sub>1 \\<in> backward_slice S\n  valid_edge a\n  transfer (slice_kind S a) s\\<^sub>2 = s\\<^sub>2'\n\ngoal (1 subgoal):\n 1. S,slice_kind\n       S \\<turnstile> (n\\<^sub>1,s\\<^sub>2) -a\\<rightarrow> (n\\<^sub>1',s\\<^sub>2')", "by(fastforce intro:observable_moveI)"], ["proof (state)\nthis:\n  S,slice_kind\n     S \\<turnstile> (n\\<^sub>1,s\\<^sub>2) -a\\<rightarrow> (n\\<^sub>1',s\\<^sub>2')\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       ((n\\<^sub>1', s\\<^sub>1'), n\\<^sub>1',\n        transfer (slice_kind S a) s\\<^sub>2)\n       \\<in> WS S \\<and>\n       S,slice_kind\n          S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =as @\n          [a]\\<Rightarrow> (n\\<^sub>1',transfer (slice_kind S a) s\\<^sub>2)", "from \\<open>obs n\\<^sub>2 (backward_slice S) = {n\\<^sub>1}\\<close>"], ["proof (chain)\npicking this:\n  obs n\\<^sub>2 (backward_slice S) = {n\\<^sub>1}", "obtain as where \"S,slice_kind S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (n\\<^sub>1,s\\<^sub>2)\""], ["proof (prove)\nusing this:\n  obs n\\<^sub>2 (backward_slice S) = {n\\<^sub>1}\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        S,slice_kind\n           S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (n\\<^sub>1,s\\<^sub>2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(erule obs_silent_moves)"], ["proof (state)\nthis:\n  S,slice_kind\n     S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (n\\<^sub>1,s\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       ((n\\<^sub>1', s\\<^sub>1'), n\\<^sub>1',\n        transfer (slice_kind S a) s\\<^sub>2)\n       \\<in> WS S \\<and>\n       S,slice_kind\n          S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =as @\n          [a]\\<Rightarrow> (n\\<^sub>1',transfer (slice_kind S a) s\\<^sub>2)", "with \\<open>S,slice_kind S \\<turnstile> (n\\<^sub>1,s\\<^sub>2) -a\\<rightarrow> (n\\<^sub>1',s\\<^sub>2')\\<close>"], ["proof (chain)\npicking this:\n  S,slice_kind\n     S \\<turnstile> (n\\<^sub>1,s\\<^sub>2) -a\\<rightarrow> (n\\<^sub>1',s\\<^sub>2')\n  S,slice_kind\n     S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (n\\<^sub>1,s\\<^sub>2)", "have \"S,slice_kind S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =as@[a]\\<Rightarrow> (n\\<^sub>1',s\\<^sub>2')\""], ["proof (prove)\nusing this:\n  S,slice_kind\n     S \\<turnstile> (n\\<^sub>1,s\\<^sub>2) -a\\<rightarrow> (n\\<^sub>1',s\\<^sub>2')\n  S,slice_kind\n     S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>\\<^sub>\\<tau> (n\\<^sub>1,s\\<^sub>2)\n\ngoal (1 subgoal):\n 1. S,slice_kind\n       S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =as @\n       [a]\\<Rightarrow> (n\\<^sub>1',s\\<^sub>2')", "by -(rule observable_moves_snoc)"], ["proof (state)\nthis:\n  S,slice_kind\n     S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =as @\n     [a]\\<Rightarrow> (n\\<^sub>1',s\\<^sub>2')\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       ((n\\<^sub>1', s\\<^sub>1'), n\\<^sub>1',\n        transfer (slice_kind S a) s\\<^sub>2)\n       \\<in> WS S \\<and>\n       S,slice_kind\n          S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =as @\n          [a]\\<Rightarrow> (n\\<^sub>1',transfer (slice_kind S a) s\\<^sub>2)", "have \"\\<forall>V \\<in> rv S n\\<^sub>1'. state_val s\\<^sub>1' V = state_val s\\<^sub>2' V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>rv S n\\<^sub>1'.\n       state_val s\\<^sub>1' V = state_val s\\<^sub>2' V", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S n\\<^sub>1' \\<Longrightarrow>\n       state_val s\\<^sub>1' V = state_val s\\<^sub>2' V", "fix V"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S n\\<^sub>1' \\<Longrightarrow>\n       state_val s\\<^sub>1' V = state_val s\\<^sub>2' V", "assume rv:\"V \\<in> rv S n\\<^sub>1'\""], ["proof (state)\nthis:\n  V \\<in> rv S n\\<^sub>1'\n\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S n\\<^sub>1' \\<Longrightarrow>\n       state_val s\\<^sub>1' V = state_val s\\<^sub>2' V", "show \"state_val s\\<^sub>1' V = state_val s\\<^sub>2' V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state_val s\\<^sub>1' V = state_val s\\<^sub>2' V", "proof(cases \"V \\<in> Def n\\<^sub>1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. V \\<in> Def n\\<^sub>1 \\<Longrightarrow>\n    state_val s\\<^sub>1' V = state_val s\\<^sub>2' V\n 2. V \\<notin> Def n\\<^sub>1 \\<Longrightarrow>\n    state_val s\\<^sub>1' V = state_val s\\<^sub>2' V", "case True"], ["proof (state)\nthis:\n  V \\<in> Def n\\<^sub>1\n\ngoal (2 subgoals):\n 1. V \\<in> Def n\\<^sub>1 \\<Longrightarrow>\n    state_val s\\<^sub>1' V = state_val s\\<^sub>2' V\n 2. V \\<notin> Def n\\<^sub>1 \\<Longrightarrow>\n    state_val s\\<^sub>1' V = state_val s\\<^sub>2' V", "thus ?thesis"], ["proof (prove)\nusing this:\n  V \\<in> Def n\\<^sub>1\n\ngoal (1 subgoal):\n 1. state_val s\\<^sub>1' V = state_val s\\<^sub>2' V", "proof(cases \"kind a\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>V \\<in> Def n\\<^sub>1; kind a = \\<Up>x1\\<rbrakk>\n       \\<Longrightarrow> state_val s\\<^sub>1' V = state_val s\\<^sub>2' V\n 2. \\<And>x2.\n       \\<lbrakk>V \\<in> Def n\\<^sub>1; kind a = (x2)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> state_val s\\<^sub>1' V = state_val s\\<^sub>2' V", "case (Update f)"], ["proof (state)\nthis:\n  kind a = \\<Up>f\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>V \\<in> Def n\\<^sub>1; kind a = \\<Up>x1\\<rbrakk>\n       \\<Longrightarrow> state_val s\\<^sub>1' V = state_val s\\<^sub>2' V\n 2. \\<And>x2.\n       \\<lbrakk>V \\<in> Def n\\<^sub>1; kind a = (x2)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> state_val s\\<^sub>1' V = state_val s\\<^sub>2' V", "with \\<open>transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\\<close>"], ["proof (chain)\npicking this:\n  transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\n  kind a = \\<Up>f", "have \"s\\<^sub>1' = f s\\<^sub>1\""], ["proof (prove)\nusing this:\n  transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\n  kind a = \\<Up>f\n\ngoal (1 subgoal):\n 1. s\\<^sub>1' = f s\\<^sub>1", "by simp"], ["proof (state)\nthis:\n  s\\<^sub>1' = f s\\<^sub>1\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>V \\<in> Def n\\<^sub>1; kind a = \\<Up>x1\\<rbrakk>\n       \\<Longrightarrow> state_val s\\<^sub>1' V = state_val s\\<^sub>2' V\n 2. \\<And>x2.\n       \\<lbrakk>V \\<in> Def n\\<^sub>1; kind a = (x2)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> state_val s\\<^sub>1' V = state_val s\\<^sub>2' V", "from Update[THEN sym] \\<open>n\\<^sub>1 \\<in> (backward_slice S)\\<close>"], ["proof (chain)\npicking this:\n  \\<Up>f = kind a\n  n\\<^sub>1 \\<in> backward_slice S", "have \"slice_kind S a = \\<Up>f\""], ["proof (prove)\nusing this:\n  \\<Up>f = kind a\n  n\\<^sub>1 \\<in> backward_slice S\n\ngoal (1 subgoal):\n 1. slice_kind S a = \\<Up>f", "by(fastforce intro:slice_kind_in_slice)"], ["proof (state)\nthis:\n  slice_kind S a = \\<Up>f\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>V \\<in> Def n\\<^sub>1; kind a = \\<Up>x1\\<rbrakk>\n       \\<Longrightarrow> state_val s\\<^sub>1' V = state_val s\\<^sub>2' V\n 2. \\<And>x2.\n       \\<lbrakk>V \\<in> Def n\\<^sub>1; kind a = (x2)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> state_val s\\<^sub>1' V = state_val s\\<^sub>2' V", "with \\<open>transfer (slice_kind S a) s\\<^sub>2 = s\\<^sub>2'\\<close>"], ["proof (chain)\npicking this:\n  transfer (slice_kind S a) s\\<^sub>2 = s\\<^sub>2'\n  slice_kind S a = \\<Up>f", "have \"s\\<^sub>2' = f s\\<^sub>2\""], ["proof (prove)\nusing this:\n  transfer (slice_kind S a) s\\<^sub>2 = s\\<^sub>2'\n  slice_kind S a = \\<Up>f\n\ngoal (1 subgoal):\n 1. s\\<^sub>2' = f s\\<^sub>2", "by simp"], ["proof (state)\nthis:\n  s\\<^sub>2' = f s\\<^sub>2\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>V \\<in> Def n\\<^sub>1; kind a = \\<Up>x1\\<rbrakk>\n       \\<Longrightarrow> state_val s\\<^sub>1' V = state_val s\\<^sub>2' V\n 2. \\<And>x2.\n       \\<lbrakk>V \\<in> Def n\\<^sub>1; kind a = (x2)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> state_val s\\<^sub>1' V = state_val s\\<^sub>2' V", "from \\<open>valid_edge a\\<close> \\<open>\\<forall>V \\<in> Use n\\<^sub>1. state_val s\\<^sub>1 V = state_val s\\<^sub>2 V\\<close>\n          True Update \\<open>s\\<^sub>1' = f s\\<^sub>1\\<close> \\<open>s\\<^sub>2' = f s\\<^sub>2\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  \\<forall>V\\<in>Use n\\<^sub>1.\n     state_val s\\<^sub>1 V = state_val s\\<^sub>2 V\n  V \\<in> Def n\\<^sub>1\n  kind a = \\<Up>f\n  s\\<^sub>1' = f s\\<^sub>1\n  s\\<^sub>2' = f s\\<^sub>2", "show ?thesis"], ["proof (prove)\nusing this:\n  valid_edge a\n  \\<forall>V\\<in>Use n\\<^sub>1.\n     state_val s\\<^sub>1 V = state_val s\\<^sub>2 V\n  V \\<in> Def n\\<^sub>1\n  kind a = \\<Up>f\n  s\\<^sub>1' = f s\\<^sub>1\n  s\\<^sub>2' = f s\\<^sub>2\n\ngoal (1 subgoal):\n 1. state_val s\\<^sub>1' V = state_val s\\<^sub>2' V", "by(fastforce dest:CFG_edge_transfer_uses_only_Use)"], ["proof (state)\nthis:\n  state_val s\\<^sub>1' V = state_val s\\<^sub>2' V\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>V \\<in> Def n\\<^sub>1; kind a = (x2)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> state_val s\\<^sub>1' V = state_val s\\<^sub>2' V", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>V \\<in> Def n\\<^sub>1; kind a = (x2)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> state_val s\\<^sub>1' V = state_val s\\<^sub>2' V", "case (Predicate Q)"], ["proof (state)\nthis:\n  kind a = (Q)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>V \\<in> Def n\\<^sub>1; kind a = (x2)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> state_val s\\<^sub>1' V = state_val s\\<^sub>2' V", "with \\<open>transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\\<close>"], ["proof (chain)\npicking this:\n  transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\n  kind a = (Q)\\<^sub>\\<surd>", "have \"s\\<^sub>1' = s\\<^sub>1\""], ["proof (prove)\nusing this:\n  transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\n  kind a = (Q)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. s\\<^sub>1' = s\\<^sub>1", "by simp"], ["proof (state)\nthis:\n  s\\<^sub>1' = s\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>V \\<in> Def n\\<^sub>1; kind a = (x2)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> state_val s\\<^sub>1' V = state_val s\\<^sub>2' V", "from Predicate[THEN sym] \\<open>n\\<^sub>1 \\<in> (backward_slice S)\\<close>"], ["proof (chain)\npicking this:\n  (Q)\\<^sub>\\<surd> = kind a\n  n\\<^sub>1 \\<in> backward_slice S", "have \"slice_kind S a = (Q)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  (Q)\\<^sub>\\<surd> = kind a\n  n\\<^sub>1 \\<in> backward_slice S\n\ngoal (1 subgoal):\n 1. slice_kind S a = (Q)\\<^sub>\\<surd>", "by(fastforce intro:slice_kind_in_slice)"], ["proof (state)\nthis:\n  slice_kind S a = (Q)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>V \\<in> Def n\\<^sub>1; kind a = (x2)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> state_val s\\<^sub>1' V = state_val s\\<^sub>2' V", "with \\<open>transfer (slice_kind S a) s\\<^sub>2 = s\\<^sub>2'\\<close>"], ["proof (chain)\npicking this:\n  transfer (slice_kind S a) s\\<^sub>2 = s\\<^sub>2'\n  slice_kind S a = (Q)\\<^sub>\\<surd>", "have \"s\\<^sub>2' = s\\<^sub>2\""], ["proof (prove)\nusing this:\n  transfer (slice_kind S a) s\\<^sub>2 = s\\<^sub>2'\n  slice_kind S a = (Q)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. s\\<^sub>2' = s\\<^sub>2", "by simp"], ["proof (state)\nthis:\n  s\\<^sub>2' = s\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>V \\<in> Def n\\<^sub>1; kind a = (x2)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> state_val s\\<^sub>1' V = state_val s\\<^sub>2' V", "with \\<open>valid_edge a\\<close> \\<open>\\<forall>V \\<in> Use n\\<^sub>1. state_val s\\<^sub>1 V = state_val s\\<^sub>2 V\\<close> \n          True Predicate \\<open>s\\<^sub>1' = s\\<^sub>1\\<close> \\<open>pred (kind a) s\\<^sub>1\\<close> \\<open>pred (kind a) s\\<^sub>2\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  \\<forall>V\\<in>Use n\\<^sub>1.\n     state_val s\\<^sub>1 V = state_val s\\<^sub>2 V\n  V \\<in> Def n\\<^sub>1\n  kind a = (Q)\\<^sub>\\<surd>\n  s\\<^sub>1' = s\\<^sub>1\n  pred (kind a) s\\<^sub>1\n  pred (kind a) s\\<^sub>2\n  s\\<^sub>2' = s\\<^sub>2", "show ?thesis"], ["proof (prove)\nusing this:\n  valid_edge a\n  \\<forall>V\\<in>Use n\\<^sub>1.\n     state_val s\\<^sub>1 V = state_val s\\<^sub>2 V\n  V \\<in> Def n\\<^sub>1\n  kind a = (Q)\\<^sub>\\<surd>\n  s\\<^sub>1' = s\\<^sub>1\n  pred (kind a) s\\<^sub>1\n  pred (kind a) s\\<^sub>2\n  s\\<^sub>2' = s\\<^sub>2\n\ngoal (1 subgoal):\n 1. state_val s\\<^sub>1' V = state_val s\\<^sub>2' V", "by(auto dest:CFG_edge_transfer_uses_only_Use)"], ["proof (state)\nthis:\n  state_val s\\<^sub>1' V = state_val s\\<^sub>2' V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  state_val s\\<^sub>1' V = state_val s\\<^sub>2' V\n\ngoal (1 subgoal):\n 1. V \\<notin> Def n\\<^sub>1 \\<Longrightarrow>\n    state_val s\\<^sub>1' V = state_val s\\<^sub>2' V", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. V \\<notin> Def n\\<^sub>1 \\<Longrightarrow>\n    state_val s\\<^sub>1' V = state_val s\\<^sub>2' V", "case False"], ["proof (state)\nthis:\n  V \\<notin> Def n\\<^sub>1\n\ngoal (1 subgoal):\n 1. V \\<notin> Def n\\<^sub>1 \\<Longrightarrow>\n    state_val s\\<^sub>1' V = state_val s\\<^sub>2' V", "with \\<open>valid_edge a\\<close> \\<open>transfer (kind a) s\\<^sub>1 = s\\<^sub>1'\\<close>[THEN sym] \n        \\<open>pred (kind a) s\\<^sub>1\\<close> \\<open>pred (kind a) s\\<^sub>2\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  s\\<^sub>1' = transfer (kind a) s\\<^sub>1\n  pred (kind a) s\\<^sub>1\n  pred (kind a) s\\<^sub>2\n  V \\<notin> Def n\\<^sub>1", "have \"state_val s\\<^sub>1' V = state_val s\\<^sub>1 V\""], ["proof (prove)\nusing this:\n  valid_edge a\n  s\\<^sub>1' = transfer (kind a) s\\<^sub>1\n  pred (kind a) s\\<^sub>1\n  pred (kind a) s\\<^sub>2\n  V \\<notin> Def n\\<^sub>1\n\ngoal (1 subgoal):\n 1. state_val s\\<^sub>1' V = state_val s\\<^sub>1 V", "by(fastforce intro:CFG_edge_no_Def_equal)"], ["proof (state)\nthis:\n  state_val s\\<^sub>1' V = state_val s\\<^sub>1 V\n\ngoal (1 subgoal):\n 1. V \\<notin> Def n\\<^sub>1 \\<Longrightarrow>\n    state_val s\\<^sub>1' V = state_val s\\<^sub>2' V", "have \"state_val s\\<^sub>2' V = state_val s\\<^sub>2 V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state_val s\\<^sub>2' V = state_val s\\<^sub>2 V", "proof(cases \"kind a\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       kind a = \\<Up>x1 \\<Longrightarrow>\n       state_val s\\<^sub>2' V = state_val s\\<^sub>2 V\n 2. \\<And>x2.\n       kind a = (x2)\\<^sub>\\<surd> \\<Longrightarrow>\n       state_val s\\<^sub>2' V = state_val s\\<^sub>2 V", "case (Update f)"], ["proof (state)\nthis:\n  kind a = \\<Up>f\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       kind a = \\<Up>x1 \\<Longrightarrow>\n       state_val s\\<^sub>2' V = state_val s\\<^sub>2 V\n 2. \\<And>x2.\n       kind a = (x2)\\<^sub>\\<surd> \\<Longrightarrow>\n       state_val s\\<^sub>2' V = state_val s\\<^sub>2 V", "with  \\<open>n\\<^sub>1 \\<in> (backward_slice S)\\<close>"], ["proof (chain)\npicking this:\n  n\\<^sub>1 \\<in> backward_slice S\n  kind a = \\<Up>f", "have \"slice_kind S a = kind a\""], ["proof (prove)\nusing this:\n  n\\<^sub>1 \\<in> backward_slice S\n  kind a = \\<Up>f\n\ngoal (1 subgoal):\n 1. slice_kind S a = kind a", "by(fastforce intro:slice_kind_in_slice)"], ["proof (state)\nthis:\n  slice_kind S a = kind a\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       kind a = \\<Up>x1 \\<Longrightarrow>\n       state_val s\\<^sub>2' V = state_val s\\<^sub>2 V\n 2. \\<And>x2.\n       kind a = (x2)\\<^sub>\\<surd> \\<Longrightarrow>\n       state_val s\\<^sub>2' V = state_val s\\<^sub>2 V", "with \\<open>valid_edge a\\<close> \\<open>transfer (slice_kind S a) s\\<^sub>2 = s\\<^sub>2'\\<close>[THEN sym] \n          False \\<open>pred (kind a) s\\<^sub>2\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  s\\<^sub>2' = transfer (slice_kind S a) s\\<^sub>2\n  V \\<notin> Def n\\<^sub>1\n  pred (kind a) s\\<^sub>2\n  slice_kind S a = kind a", "show ?thesis"], ["proof (prove)\nusing this:\n  valid_edge a\n  s\\<^sub>2' = transfer (slice_kind S a) s\\<^sub>2\n  V \\<notin> Def n\\<^sub>1\n  pred (kind a) s\\<^sub>2\n  slice_kind S a = kind a\n\ngoal (1 subgoal):\n 1. state_val s\\<^sub>2' V = state_val s\\<^sub>2 V", "by(fastforce intro:CFG_edge_no_Def_equal)"], ["proof (state)\nthis:\n  state_val s\\<^sub>2' V = state_val s\\<^sub>2 V\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       kind a = (x2)\\<^sub>\\<surd> \\<Longrightarrow>\n       state_val s\\<^sub>2' V = state_val s\\<^sub>2 V", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       kind a = (x2)\\<^sub>\\<surd> \\<Longrightarrow>\n       state_val s\\<^sub>2' V = state_val s\\<^sub>2 V", "case (Predicate Q)"], ["proof (state)\nthis:\n  kind a = (Q)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       kind a = (x2)\\<^sub>\\<surd> \\<Longrightarrow>\n       state_val s\\<^sub>2' V = state_val s\\<^sub>2 V", "with \\<open>transfer (slice_kind S a) s\\<^sub>2 = s\\<^sub>2'\\<close>"], ["proof (chain)\npicking this:\n  transfer (slice_kind S a) s\\<^sub>2 = s\\<^sub>2'\n  kind a = (Q)\\<^sub>\\<surd>", "have \"s\\<^sub>2 = s\\<^sub>2'\""], ["proof (prove)\nusing this:\n  transfer (slice_kind S a) s\\<^sub>2 = s\\<^sub>2'\n  kind a = (Q)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. s\\<^sub>2 = s\\<^sub>2'", "by(cases \"slice_kind S a\",\n            auto split:if_split_asm simp:slice_kind_def Let_def)"], ["proof (state)\nthis:\n  s\\<^sub>2 = s\\<^sub>2'\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       kind a = (x2)\\<^sub>\\<surd> \\<Longrightarrow>\n       state_val s\\<^sub>2' V = state_val s\\<^sub>2 V", "thus ?thesis"], ["proof (prove)\nusing this:\n  s\\<^sub>2 = s\\<^sub>2'\n\ngoal (1 subgoal):\n 1. state_val s\\<^sub>2' V = state_val s\\<^sub>2 V", "by simp"], ["proof (state)\nthis:\n  state_val s\\<^sub>2' V = state_val s\\<^sub>2 V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  state_val s\\<^sub>2' V = state_val s\\<^sub>2 V\n\ngoal (1 subgoal):\n 1. V \\<notin> Def n\\<^sub>1 \\<Longrightarrow>\n    state_val s\\<^sub>1' V = state_val s\\<^sub>2' V", "from rv"], ["proof (chain)\npicking this:\n  V \\<in> rv S n\\<^sub>1'", "obtain as' nx where \"n\\<^sub>1' -as'\\<rightarrow>* nx\" \n        and \"nx \\<in> (backward_slice S)\"\n        and \"V \\<in> Use nx\" and \"\\<forall>nx \\<in> set(sourcenodes as'). V \\<notin> Def nx\""], ["proof (prove)\nusing this:\n  V \\<in> rv S n\\<^sub>1'\n\ngoal (1 subgoal):\n 1. (\\<And>as' nx.\n        \\<lbrakk>n\\<^sub>1' -as'\\<rightarrow>* nx;\n         nx \\<in> backward_slice S; V \\<in> Use nx;\n         \\<forall>nx\\<in>set (sourcenodes as'). V \\<notin> Def nx\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule rvE)"], ["proof (state)\nthis:\n  n\\<^sub>1' -as'\\<rightarrow>* nx\n  nx \\<in> backward_slice S\n  V \\<in> Use nx\n  \\<forall>nx\\<in>set (sourcenodes as'). V \\<notin> Def nx\n\ngoal (1 subgoal):\n 1. V \\<notin> Def n\\<^sub>1 \\<Longrightarrow>\n    state_val s\\<^sub>1' V = state_val s\\<^sub>2' V", "from \\<open>\\<forall>nx \\<in> set(sourcenodes as'). V \\<notin> Def nx\\<close> False"], ["proof (chain)\npicking this:\n  \\<forall>nx\\<in>set (sourcenodes as'). V \\<notin> Def nx\n  V \\<notin> Def n\\<^sub>1", "have \"\\<forall>nx \\<in> set(sourcenodes (a#as')). V \\<notin> Def nx\""], ["proof (prove)\nusing this:\n  \\<forall>nx\\<in>set (sourcenodes as'). V \\<notin> Def nx\n  V \\<notin> Def n\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<forall>nx\\<in>set (sourcenodes (a # as')). V \\<notin> Def nx", "by(auto simp:sourcenodes_def)"], ["proof (state)\nthis:\n  \\<forall>nx\\<in>set (sourcenodes (a # as')). V \\<notin> Def nx\n\ngoal (1 subgoal):\n 1. V \\<notin> Def n\\<^sub>1 \\<Longrightarrow>\n    state_val s\\<^sub>1' V = state_val s\\<^sub>2' V", "from  \\<open>valid_edge a\\<close> \\<open>n\\<^sub>1' -as'\\<rightarrow>* nx\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  n\\<^sub>1' -as'\\<rightarrow>* nx", "have \"n\\<^sub>1 -a#as'\\<rightarrow>* nx\""], ["proof (prove)\nusing this:\n  valid_edge a\n  n\\<^sub>1' -as'\\<rightarrow>* nx\n\ngoal (1 subgoal):\n 1. n\\<^sub>1 -a # as'\\<rightarrow>* nx", "by(fastforce intro:Cons_path)"], ["proof (state)\nthis:\n  n\\<^sub>1 -a # as'\\<rightarrow>* nx\n\ngoal (1 subgoal):\n 1. V \\<notin> Def n\\<^sub>1 \\<Longrightarrow>\n    state_val s\\<^sub>1' V = state_val s\\<^sub>2' V", "with \\<open>nx \\<in> (backward_slice S)\\<close> \\<open>V \\<in> Use nx\\<close> \n        \\<open>\\<forall>nx \\<in> set(sourcenodes (a#as')). V \\<notin> Def nx\\<close>"], ["proof (chain)\npicking this:\n  nx \\<in> backward_slice S\n  V \\<in> Use nx\n  \\<forall>nx\\<in>set (sourcenodes (a # as')). V \\<notin> Def nx\n  n\\<^sub>1 -a # as'\\<rightarrow>* nx", "have \"V \\<in> rv S n\\<^sub>1\""], ["proof (prove)\nusing this:\n  nx \\<in> backward_slice S\n  V \\<in> Use nx\n  \\<forall>nx\\<in>set (sourcenodes (a # as')). V \\<notin> Def nx\n  n\\<^sub>1 -a # as'\\<rightarrow>* nx\n\ngoal (1 subgoal):\n 1. V \\<in> rv S n\\<^sub>1", "by -(rule rvI)"], ["proof (state)\nthis:\n  V \\<in> rv S n\\<^sub>1\n\ngoal (1 subgoal):\n 1. V \\<notin> Def n\\<^sub>1 \\<Longrightarrow>\n    state_val s\\<^sub>1' V = state_val s\\<^sub>2' V", "with \\<open>\\<forall>V \\<in> rv S n\\<^sub>1. state_val s\\<^sub>1 V = state_val s\\<^sub>2 V\\<close> \n        \\<open>state_val s\\<^sub>1' V = state_val s\\<^sub>1 V\\<close> \\<open>state_val s\\<^sub>2' V = state_val s\\<^sub>2 V\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>rv S n\\<^sub>1.\n     state_val s\\<^sub>1 V = state_val s\\<^sub>2 V\n  state_val s\\<^sub>1' V = state_val s\\<^sub>1 V\n  state_val s\\<^sub>2' V = state_val s\\<^sub>2 V\n  V \\<in> rv S n\\<^sub>1", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>rv S n\\<^sub>1.\n     state_val s\\<^sub>1 V = state_val s\\<^sub>2 V\n  state_val s\\<^sub>1' V = state_val s\\<^sub>1 V\n  state_val s\\<^sub>2' V = state_val s\\<^sub>2 V\n  V \\<in> rv S n\\<^sub>1\n\ngoal (1 subgoal):\n 1. state_val s\\<^sub>1' V = state_val s\\<^sub>2' V", "by fastforce"], ["proof (state)\nthis:\n  state_val s\\<^sub>1' V = state_val s\\<^sub>2' V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  state_val s\\<^sub>1' V = state_val s\\<^sub>2' V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>V\\<in>rv S n\\<^sub>1'.\n     state_val s\\<^sub>1' V = state_val s\\<^sub>2' V\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       ((n\\<^sub>1', s\\<^sub>1'), n\\<^sub>1',\n        transfer (slice_kind S a) s\\<^sub>2)\n       \\<in> WS S \\<and>\n       S,slice_kind\n          S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =as @\n          [a]\\<Rightarrow> (n\\<^sub>1',transfer (slice_kind S a) s\\<^sub>2)", "with \\<open>valid_node n\\<^sub>1'\\<close>"], ["proof (chain)\npicking this:\n  valid_node n\\<^sub>1'\n  \\<forall>V\\<in>rv S n\\<^sub>1'.\n     state_val s\\<^sub>1' V = state_val s\\<^sub>2' V", "have \"((n\\<^sub>1',s\\<^sub>1'),(n\\<^sub>1',s\\<^sub>2')) \\<in> WS S\""], ["proof (prove)\nusing this:\n  valid_node n\\<^sub>1'\n  \\<forall>V\\<in>rv S n\\<^sub>1'.\n     state_val s\\<^sub>1' V = state_val s\\<^sub>2' V\n\ngoal (1 subgoal):\n 1. ((n\\<^sub>1', s\\<^sub>1'), n\\<^sub>1', s\\<^sub>2') \\<in> WS S", "by(fastforce intro:WSI)"], ["proof (state)\nthis:\n  ((n\\<^sub>1', s\\<^sub>1'), n\\<^sub>1', s\\<^sub>2') \\<in> WS S\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       ((n\\<^sub>1', s\\<^sub>1'), n\\<^sub>1',\n        transfer (slice_kind S a) s\\<^sub>2)\n       \\<in> WS S \\<and>\n       S,slice_kind\n          S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =as @\n          [a]\\<Rightarrow> (n\\<^sub>1',transfer (slice_kind S a) s\\<^sub>2)", "with \\<open>S,slice_kind S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =as@[a]\\<Rightarrow> (n\\<^sub>1',s\\<^sub>2')\\<close>\n    \\<open>transfer (slice_kind S a) s\\<^sub>2 = s\\<^sub>2'\\<close>"], ["proof (chain)\npicking this:\n  S,slice_kind\n     S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =as @\n     [a]\\<Rightarrow> (n\\<^sub>1',s\\<^sub>2')\n  transfer (slice_kind S a) s\\<^sub>2 = s\\<^sub>2'\n  ((n\\<^sub>1', s\\<^sub>1'), n\\<^sub>1', s\\<^sub>2') \\<in> WS S", "show \"\\<exists>as. ((n\\<^sub>1',s\\<^sub>1'),(n\\<^sub>1',transfer (slice_kind S a) s\\<^sub>2)) \\<in> WS S \\<and>\n    S,slice_kind S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =as@[a]\\<Rightarrow> (n\\<^sub>1',transfer (slice_kind S a) s\\<^sub>2)\""], ["proof (prove)\nusing this:\n  S,slice_kind\n     S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =as @\n     [a]\\<Rightarrow> (n\\<^sub>1',s\\<^sub>2')\n  transfer (slice_kind S a) s\\<^sub>2 = s\\<^sub>2'\n  ((n\\<^sub>1', s\\<^sub>1'), n\\<^sub>1', s\\<^sub>2') \\<in> WS S\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       ((n\\<^sub>1', s\\<^sub>1'), n\\<^sub>1',\n        transfer (slice_kind S a) s\\<^sub>2)\n       \\<in> WS S \\<and>\n       S,slice_kind\n          S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =as @\n          [a]\\<Rightarrow> (n\\<^sub>1',transfer (slice_kind S a) s\\<^sub>2)", "by blast"], ["proof (state)\nthis:\n  \\<exists>as.\n     ((n\\<^sub>1', s\\<^sub>1'), n\\<^sub>1',\n      transfer (slice_kind S a) s\\<^sub>2)\n     \\<in> WS S \\<and>\n     S,slice_kind\n        S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =as @\n        [a]\\<Rightarrow> (n\\<^sub>1',transfer (slice_kind S a) s\\<^sub>2)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition is_weak_sim :: \n  \"(('node \\<times> 'state) \\<times> ('node \\<times> 'state)) set \\<Rightarrow> 'node set \\<Rightarrow> bool\"\n  where \"is_weak_sim R S \\<equiv> \n  \\<forall>n\\<^sub>1 s\\<^sub>1 n\\<^sub>2 s\\<^sub>2 n\\<^sub>1' s\\<^sub>1' as. ((n\\<^sub>1,s\\<^sub>1),(n\\<^sub>2,s\\<^sub>2)) \\<in> R \\<and> S,kind \\<turnstile> (n\\<^sub>1,s\\<^sub>1) =as\\<Rightarrow> (n\\<^sub>1',s\\<^sub>1')\n  \\<longrightarrow> (\\<exists>n\\<^sub>2' s\\<^sub>2' as'. ((n\\<^sub>1',s\\<^sub>1'),(n\\<^sub>2',s\\<^sub>2')) \\<in> R \\<and> \n                      S,slice_kind S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =as'\\<Rightarrow> (n\\<^sub>2',s\\<^sub>2'))\""], ["", "lemma WS_weak_sim:\n  assumes \"((n\\<^sub>1,s\\<^sub>1),(n\\<^sub>2,s\\<^sub>2)) \\<in> WS S\" \n  and \"S,kind \\<turnstile> (n\\<^sub>1,s\\<^sub>1) =as\\<Rightarrow> (n\\<^sub>1',s\\<^sub>1')\"\n  shows \"((n\\<^sub>1',s\\<^sub>1'),(n\\<^sub>1',transfer (slice_kind S (last as)) s\\<^sub>2)) \\<in> WS S \\<and>\n  (\\<exists>as'. S,slice_kind S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =as'@[last as]\\<Rightarrow> \n                             (n\\<^sub>1',transfer (slice_kind S (last as)) s\\<^sub>2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((n\\<^sub>1', s\\<^sub>1'), n\\<^sub>1',\n     transfer (slice_kind S (last as)) s\\<^sub>2)\n    \\<in> WS S \\<and>\n    (\\<exists>as'.\n        S,slice_kind\n           S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =as' @\n           [last\n             as]\\<Rightarrow> (n\\<^sub>1',transfer (slice_kind S (last as))\n     s\\<^sub>2))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((n\\<^sub>1', s\\<^sub>1'), n\\<^sub>1',\n     transfer (slice_kind S (last as)) s\\<^sub>2)\n    \\<in> WS S \\<and>\n    (\\<exists>as'.\n        S,slice_kind\n           S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =as' @\n           [last\n             as]\\<Rightarrow> (n\\<^sub>1',transfer (slice_kind S (last as))\n     s\\<^sub>2))", "from \\<open>S,kind \\<turnstile> (n\\<^sub>1,s\\<^sub>1) =as\\<Rightarrow> (n\\<^sub>1',s\\<^sub>1')\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (n\\<^sub>1,s\\<^sub>1) =as\\<Rightarrow> (n\\<^sub>1',s\\<^sub>1')", "obtain a' as' n' s'\n    where \"S,kind \\<turnstile> (n\\<^sub>1,s\\<^sub>1) =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s')\" \n    and \"S,kind \\<turnstile> (n',s') -a'\\<rightarrow> (n\\<^sub>1',s\\<^sub>1')\" and \"as = as'@[a']\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (n\\<^sub>1,s\\<^sub>1) =as\\<Rightarrow> (n\\<^sub>1',s\\<^sub>1')\n\ngoal (1 subgoal):\n 1. (\\<And>as' n' s' a'.\n        \\<lbrakk>S,kind \\<turnstile> (n\\<^sub>1,s\\<^sub>1) =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s');\n         S,kind \\<turnstile> (n',s') -a'\\<rightarrow> (n\\<^sub>1',s\\<^sub>1');\n         as = as' @ [a']\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:observable_moves.cases)"], ["proof (state)\nthis:\n  S,kind \\<turnstile> (n\\<^sub>1,s\\<^sub>1) =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s')\n  S,kind \\<turnstile> (n',s') -a'\\<rightarrow> (n\\<^sub>1',s\\<^sub>1')\n  as = as' @ [a']\n\ngoal (1 subgoal):\n 1. ((n\\<^sub>1', s\\<^sub>1'), n\\<^sub>1',\n     transfer (slice_kind S (last as)) s\\<^sub>2)\n    \\<in> WS S \\<and>\n    (\\<exists>as'.\n        S,slice_kind\n           S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =as' @\n           [last\n             as]\\<Rightarrow> (n\\<^sub>1',transfer (slice_kind S (last as))\n     s\\<^sub>2))", "from \\<open>S,kind \\<turnstile> (n',s') -a'\\<rightarrow> (n\\<^sub>1',s\\<^sub>1')\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (n',s') -a'\\<rightarrow> (n\\<^sub>1',s\\<^sub>1')", "have \"obs n' (backward_slice S) = {n'}\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (n',s') -a'\\<rightarrow> (n\\<^sub>1',s\\<^sub>1')\n\ngoal (1 subgoal):\n 1. obs n' (backward_slice S) = {n'}", "by(fastforce elim:observable_move.cases intro!:n_in_obs)"], ["proof (state)\nthis:\n  obs n' (backward_slice S) = {n'}\n\ngoal (1 subgoal):\n 1. ((n\\<^sub>1', s\\<^sub>1'), n\\<^sub>1',\n     transfer (slice_kind S (last as)) s\\<^sub>2)\n    \\<in> WS S \\<and>\n    (\\<exists>as'.\n        S,slice_kind\n           S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =as' @\n           [last\n             as]\\<Rightarrow> (n\\<^sub>1',transfer (slice_kind S (last as))\n     s\\<^sub>2))", "hence \"obs n' (backward_slice S) \\<noteq> {}\""], ["proof (prove)\nusing this:\n  obs n' (backward_slice S) = {n'}\n\ngoal (1 subgoal):\n 1. obs n' (backward_slice S) \\<noteq> {}", "by fast"], ["proof (state)\nthis:\n  obs n' (backward_slice S) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. ((n\\<^sub>1', s\\<^sub>1'), n\\<^sub>1',\n     transfer (slice_kind S (last as)) s\\<^sub>2)\n    \\<in> WS S \\<and>\n    (\\<exists>as'.\n        S,slice_kind\n           S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =as' @\n           [last\n             as]\\<Rightarrow> (n\\<^sub>1',transfer (slice_kind S (last as))\n     s\\<^sub>2))", "with \\<open>S,kind \\<turnstile> (n\\<^sub>1,s\\<^sub>1) =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s')\\<close> \\<open>((n\\<^sub>1,s\\<^sub>1),(n\\<^sub>2,s\\<^sub>2)) \\<in> WS S\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (n\\<^sub>1,s\\<^sub>1) =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s')\n  ((n\\<^sub>1, s\\<^sub>1), n\\<^sub>2, s\\<^sub>2) \\<in> WS S\n  obs n' (backward_slice S) \\<noteq> {}", "have \"((n',s'),(n\\<^sub>2,s\\<^sub>2)) \\<in> WS S\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (n\\<^sub>1,s\\<^sub>1) =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s')\n  ((n\\<^sub>1, s\\<^sub>1), n\\<^sub>2, s\\<^sub>2) \\<in> WS S\n  obs n' (backward_slice S) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. ((n', s'), n\\<^sub>2, s\\<^sub>2) \\<in> WS S", "by -(rule WS_silent_moves,simp+)"], ["proof (state)\nthis:\n  ((n', s'), n\\<^sub>2, s\\<^sub>2) \\<in> WS S\n\ngoal (1 subgoal):\n 1. ((n\\<^sub>1', s\\<^sub>1'), n\\<^sub>1',\n     transfer (slice_kind S (last as)) s\\<^sub>2)\n    \\<in> WS S \\<and>\n    (\\<exists>as'.\n        S,slice_kind\n           S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =as' @\n           [last\n             as]\\<Rightarrow> (n\\<^sub>1',transfer (slice_kind S (last as))\n     s\\<^sub>2))", "with \\<open>S,kind \\<turnstile> (n',s') -a'\\<rightarrow> (n\\<^sub>1',s\\<^sub>1')\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (n',s') -a'\\<rightarrow> (n\\<^sub>1',s\\<^sub>1')\n  ((n', s'), n\\<^sub>2, s\\<^sub>2) \\<in> WS S", "obtain asx \n    where \"((n\\<^sub>1',s\\<^sub>1'),(n\\<^sub>1',transfer (slice_kind S a') s\\<^sub>2)) \\<in> WS S\"\n    and \"S,slice_kind S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =asx@[a']\\<Rightarrow> \n    (n\\<^sub>1',transfer (slice_kind S a') s\\<^sub>2)\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (n',s') -a'\\<rightarrow> (n\\<^sub>1',s\\<^sub>1')\n  ((n', s'), n\\<^sub>2, s\\<^sub>2) \\<in> WS S\n\ngoal (1 subgoal):\n 1. (\\<And>asx.\n        \\<lbrakk>((n\\<^sub>1', s\\<^sub>1'), n\\<^sub>1',\n                  transfer (slice_kind S a') s\\<^sub>2)\n                 \\<in> WS S;\n         S,slice_kind\n            S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =asx @\n            [a']\\<Rightarrow> (n\\<^sub>1',transfer (slice_kind S a')\n     s\\<^sub>2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:WS_observable_move)"], ["proof (state)\nthis:\n  ((n\\<^sub>1', s\\<^sub>1'), n\\<^sub>1',\n   transfer (slice_kind S a') s\\<^sub>2)\n  \\<in> WS S\n  S,slice_kind\n     S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =asx @\n     [a']\\<Rightarrow> (n\\<^sub>1',transfer (slice_kind S a') s\\<^sub>2)\n\ngoal (1 subgoal):\n 1. ((n\\<^sub>1', s\\<^sub>1'), n\\<^sub>1',\n     transfer (slice_kind S (last as)) s\\<^sub>2)\n    \\<in> WS S \\<and>\n    (\\<exists>as'.\n        S,slice_kind\n           S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =as' @\n           [last\n             as]\\<Rightarrow> (n\\<^sub>1',transfer (slice_kind S (last as))\n     s\\<^sub>2))", "with \\<open>as = as'@[a']\\<close>"], ["proof (chain)\npicking this:\n  as = as' @ [a']\n  ((n\\<^sub>1', s\\<^sub>1'), n\\<^sub>1',\n   transfer (slice_kind S a') s\\<^sub>2)\n  \\<in> WS S\n  S,slice_kind\n     S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =asx @\n     [a']\\<Rightarrow> (n\\<^sub>1',transfer (slice_kind S a') s\\<^sub>2)", "show\n    \"((n\\<^sub>1',s\\<^sub>1'),(n\\<^sub>1',transfer (slice_kind S (last as)) s\\<^sub>2)) \\<in> WS S \\<and>\n    (\\<exists>as'. S,slice_kind S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =as'@[last as]\\<Rightarrow> \n           (n\\<^sub>1',transfer (slice_kind S (last as)) s\\<^sub>2))\""], ["proof (prove)\nusing this:\n  as = as' @ [a']\n  ((n\\<^sub>1', s\\<^sub>1'), n\\<^sub>1',\n   transfer (slice_kind S a') s\\<^sub>2)\n  \\<in> WS S\n  S,slice_kind\n     S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =asx @\n     [a']\\<Rightarrow> (n\\<^sub>1',transfer (slice_kind S a') s\\<^sub>2)\n\ngoal (1 subgoal):\n 1. ((n\\<^sub>1', s\\<^sub>1'), n\\<^sub>1',\n     transfer (slice_kind S (last as)) s\\<^sub>2)\n    \\<in> WS S \\<and>\n    (\\<exists>as'.\n        S,slice_kind\n           S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =as' @\n           [last\n             as]\\<Rightarrow> (n\\<^sub>1',transfer (slice_kind S (last as))\n     s\\<^sub>2))", "by simp blast"], ["proof (state)\nthis:\n  ((n\\<^sub>1', s\\<^sub>1'), n\\<^sub>1',\n   transfer (slice_kind S (last as)) s\\<^sub>2)\n  \\<in> WS S \\<and>\n  (\\<exists>as'.\n      S,slice_kind\n         S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =as' @\n         [last\n           as]\\<Rightarrow> (n\\<^sub>1',transfer (slice_kind S (last as))\n   s\\<^sub>2))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The following lemma states the correctness of static intraprocedural slicing:\\\\\n  the simulation \\<open>WS S\\<close> is a desired weak simulation\\<close>"], ["", "theorem WS_is_weak_sim:\"is_weak_sim (WS S) S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_weak_sim (WS S) S", "by(fastforce dest:WS_weak_sim simp:is_weak_sim_def)"], ["", "subsection \\<open>@{term \"n -as\\<rightarrow>* n'\"} and transitive closure of \n  @{term \"S,f \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s')\"}\\<close>"], ["", "inductive trans_observable_moves :: \n  \"'node set \\<Rightarrow> ('edge \\<Rightarrow> 'state edge_kind) \\<Rightarrow> 'node \\<Rightarrow> 'state \\<Rightarrow> 'edge list \\<Rightarrow> \n  'node \\<Rightarrow> 'state \\<Rightarrow> bool\" (\"_,_ \\<turnstile> '(_,_') =_\\<Rightarrow>* '(_,_')\" [51,50,0,0,50,0,0] 51) \n\nwhere tom_Nil:\n  \"S,f \\<turnstile> (n,s) =[]\\<Rightarrow>* (n,s)\"\n\n| tom_Cons:\n  \"\\<lbrakk>S,f \\<turnstile> (n,s) =as\\<Rightarrow> (n',s'); S,f \\<turnstile> (n',s') =as'\\<Rightarrow>* (n'',s'')\\<rbrakk>\n  \\<Longrightarrow> S,f \\<turnstile> (n,s) =(last as)#as'\\<Rightarrow>* (n'',s'')\""], ["", "definition slice_edges :: \"'node set \\<Rightarrow> 'edge list \\<Rightarrow> 'edge list\"\n  where \"slice_edges S as \\<equiv> [a \\<leftarrow> as. sourcenode a \\<in> backward_slice S]\""], ["", "lemma silent_moves_no_slice_edges:\n  \"S,f \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<Longrightarrow> slice_edges S as = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S,f \\<turnstile> (n,s) =as\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<Longrightarrow>\n    slice_edges S as = []", "by(induct rule:silent_moves.induct,auto elim:silent_move.cases simp:slice_edges_def)"], ["", "lemma observable_moves_last_slice_edges:\n  \"S,f \\<turnstile> (n,s) =as\\<Rightarrow> (n',s') \\<Longrightarrow> slice_edges S as = [last as]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S,f \\<turnstile> (n,s) =as\\<Rightarrow> (n',s') \\<Longrightarrow>\n    slice_edges S as = [last as]", "by(induct rule:observable_moves.induct,\n   fastforce dest:silent_moves_no_slice_edges elim:observable_move.cases \n            simp:slice_edges_def)"], ["", "lemma slice_edges_no_nodes_in_slice:\n  \"slice_edges S as = [] \n  \\<Longrightarrow> \\<forall>nx \\<in> set(sourcenodes as). nx \\<notin> (backward_slice S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. slice_edges S as = [] \\<Longrightarrow>\n    \\<forall>nx\\<in>set (sourcenodes as). nx \\<notin> backward_slice S", "proof(induct as)"], ["proof (state)\ngoal (2 subgoals):\n 1. slice_edges S [] = [] \\<Longrightarrow>\n    \\<forall>nx\\<in>set (sourcenodes []). nx \\<notin> backward_slice S\n 2. \\<And>a as.\n       \\<lbrakk>slice_edges S as = [] \\<Longrightarrow>\n                \\<forall>nx\\<in>set (sourcenodes as).\n                   nx \\<notin> backward_slice S;\n        slice_edges S (a # as) = []\\<rbrakk>\n       \\<Longrightarrow> \\<forall>nx\\<in>set (sourcenodes (a # as)).\n                            nx \\<notin> backward_slice S", "case Nil"], ["proof (state)\nthis:\n  slice_edges S [] = []\n\ngoal (2 subgoals):\n 1. slice_edges S [] = [] \\<Longrightarrow>\n    \\<forall>nx\\<in>set (sourcenodes []). nx \\<notin> backward_slice S\n 2. \\<And>a as.\n       \\<lbrakk>slice_edges S as = [] \\<Longrightarrow>\n                \\<forall>nx\\<in>set (sourcenodes as).\n                   nx \\<notin> backward_slice S;\n        slice_edges S (a # as) = []\\<rbrakk>\n       \\<Longrightarrow> \\<forall>nx\\<in>set (sourcenodes (a # as)).\n                            nx \\<notin> backward_slice S", "thus ?case"], ["proof (prove)\nusing this:\n  slice_edges S [] = []\n\ngoal (1 subgoal):\n 1. \\<forall>nx\\<in>set (sourcenodes []). nx \\<notin> backward_slice S", "by(simp add:slice_edges_def sourcenodes_def)"], ["proof (state)\nthis:\n  \\<forall>nx\\<in>set (sourcenodes []). nx \\<notin> backward_slice S\n\ngoal (1 subgoal):\n 1. \\<And>a as.\n       \\<lbrakk>slice_edges S as = [] \\<Longrightarrow>\n                \\<forall>nx\\<in>set (sourcenodes as).\n                   nx \\<notin> backward_slice S;\n        slice_edges S (a # as) = []\\<rbrakk>\n       \\<Longrightarrow> \\<forall>nx\\<in>set (sourcenodes (a # as)).\n                            nx \\<notin> backward_slice S", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a as.\n       \\<lbrakk>slice_edges S as = [] \\<Longrightarrow>\n                \\<forall>nx\\<in>set (sourcenodes as).\n                   nx \\<notin> backward_slice S;\n        slice_edges S (a # as) = []\\<rbrakk>\n       \\<Longrightarrow> \\<forall>nx\\<in>set (sourcenodes (a # as)).\n                            nx \\<notin> backward_slice S", "case (Cons a' as')"], ["proof (state)\nthis:\n  slice_edges S as' = [] \\<Longrightarrow>\n  \\<forall>nx\\<in>set (sourcenodes as'). nx \\<notin> backward_slice S\n  slice_edges S (a' # as') = []\n\ngoal (1 subgoal):\n 1. \\<And>a as.\n       \\<lbrakk>slice_edges S as = [] \\<Longrightarrow>\n                \\<forall>nx\\<in>set (sourcenodes as).\n                   nx \\<notin> backward_slice S;\n        slice_edges S (a # as) = []\\<rbrakk>\n       \\<Longrightarrow> \\<forall>nx\\<in>set (sourcenodes (a # as)).\n                            nx \\<notin> backward_slice S", "note IH = \\<open>slice_edges S as' = [] \\<Longrightarrow>\n    \\<forall>nx\\<in>set (sourcenodes as'). nx \\<notin> backward_slice S\\<close>"], ["proof (state)\nthis:\n  slice_edges S as' = [] \\<Longrightarrow>\n  \\<forall>nx\\<in>set (sourcenodes as'). nx \\<notin> backward_slice S\n\ngoal (1 subgoal):\n 1. \\<And>a as.\n       \\<lbrakk>slice_edges S as = [] \\<Longrightarrow>\n                \\<forall>nx\\<in>set (sourcenodes as).\n                   nx \\<notin> backward_slice S;\n        slice_edges S (a # as) = []\\<rbrakk>\n       \\<Longrightarrow> \\<forall>nx\\<in>set (sourcenodes (a # as)).\n                            nx \\<notin> backward_slice S", "from \\<open>slice_edges S (a'#as') = []\\<close>"], ["proof (chain)\npicking this:\n  slice_edges S (a' # as') = []", "have \"slice_edges S as' = []\"\n    and \"sourcenode a' \\<notin> backward_slice S\""], ["proof (prove)\nusing this:\n  slice_edges S (a' # as') = []\n\ngoal (1 subgoal):\n 1. slice_edges S as' = [] &&& sourcenode a' \\<notin> backward_slice S", "by(auto simp:slice_edges_def split:if_split_asm)"], ["proof (state)\nthis:\n  slice_edges S as' = []\n  sourcenode a' \\<notin> backward_slice S\n\ngoal (1 subgoal):\n 1. \\<And>a as.\n       \\<lbrakk>slice_edges S as = [] \\<Longrightarrow>\n                \\<forall>nx\\<in>set (sourcenodes as).\n                   nx \\<notin> backward_slice S;\n        slice_edges S (a # as) = []\\<rbrakk>\n       \\<Longrightarrow> \\<forall>nx\\<in>set (sourcenodes (a # as)).\n                            nx \\<notin> backward_slice S", "from IH[OF \\<open>slice_edges S as' = []\\<close>] \\<open>sourcenode a' \\<notin> backward_slice S\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>nx\\<in>set (sourcenodes as'). nx \\<notin> backward_slice S\n  sourcenode a' \\<notin> backward_slice S", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>nx\\<in>set (sourcenodes as'). nx \\<notin> backward_slice S\n  sourcenode a' \\<notin> backward_slice S\n\ngoal (1 subgoal):\n 1. \\<forall>nx\\<in>set (sourcenodes (a' # as')).\n       nx \\<notin> backward_slice S", "by(simp add:sourcenodes_def)"], ["proof (state)\nthis:\n  \\<forall>nx\\<in>set (sourcenodes (a' # as')). nx \\<notin> backward_slice S\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sliced_path_determ:\n  \"\\<lbrakk>n -as\\<rightarrow>* n'; n -as'\\<rightarrow>* n'; slice_edges S as = slice_edges S as';\n    preds (slice_kinds S as) s; preds (slice_kinds S as') s'; n' \\<in> S;\n    \\<forall>V \\<in> rv S n. state_val s V = state_val s' V\\<rbrakk> \\<Longrightarrow> as = as'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n -as\\<rightarrow>* n'; n -as'\\<rightarrow>* n';\n     slice_edges S as = slice_edges S as'; preds (slice_kinds S as) s;\n     preds (slice_kinds S as') s'; n' \\<in> S;\n     \\<forall>V\\<in>rv S n. state_val s V = state_val s' V\\<rbrakk>\n    \\<Longrightarrow> as = as'", "proof(induct arbitrary:as' s s' rule:path.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n as' s s'.\n       \\<lbrakk>valid_node n; n -as'\\<rightarrow>* n;\n        slice_edges S [] = slice_edges S as'; preds (slice_kinds S []) s;\n        preds (slice_kinds S as') s'; n \\<in> S;\n        \\<forall>V\\<in>rv S n. state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> [] = as'\n 2. \\<And>n'' as n' a n as' s s'.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        \\<And>as' s s'.\n           \\<lbrakk>n'' -as'\\<rightarrow>* n';\n            slice_edges S as = slice_edges S as';\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            n' \\<in> S;\n            \\<forall>V\\<in>rv S n''. state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> as = as';\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        n -as'\\<rightarrow>* n'; slice_edges S (a # as) = slice_edges S as';\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        n' \\<in> S;\n        \\<forall>V\\<in>rv S n. state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> a # as = as'", "case (empty_path n)"], ["proof (state)\nthis:\n  valid_node n\n  n -as'\\<rightarrow>* n\n  slice_edges S [] = slice_edges S as'\n  preds (slice_kinds S []) s\n  preds (slice_kinds S as') s'\n  n \\<in> S\n  \\<forall>V\\<in>rv S n. state_val s V = state_val s' V\n\ngoal (2 subgoals):\n 1. \\<And>n as' s s'.\n       \\<lbrakk>valid_node n; n -as'\\<rightarrow>* n;\n        slice_edges S [] = slice_edges S as'; preds (slice_kinds S []) s;\n        preds (slice_kinds S as') s'; n \\<in> S;\n        \\<forall>V\\<in>rv S n. state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> [] = as'\n 2. \\<And>n'' as n' a n as' s s'.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        \\<And>as' s s'.\n           \\<lbrakk>n'' -as'\\<rightarrow>* n';\n            slice_edges S as = slice_edges S as';\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            n' \\<in> S;\n            \\<forall>V\\<in>rv S n''. state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> as = as';\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        n -as'\\<rightarrow>* n'; slice_edges S (a # as) = slice_edges S as';\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        n' \\<in> S;\n        \\<forall>V\\<in>rv S n. state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> a # as = as'", "from \\<open>slice_edges S [] = slice_edges S as'\\<close>"], ["proof (chain)\npicking this:\n  slice_edges S [] = slice_edges S as'", "have \"\\<forall>nx \\<in> set(sourcenodes as'). nx \\<notin> (backward_slice S)\""], ["proof (prove)\nusing this:\n  slice_edges S [] = slice_edges S as'\n\ngoal (1 subgoal):\n 1. \\<forall>nx\\<in>set (sourcenodes as'). nx \\<notin> backward_slice S", "by(fastforce intro!:slice_edges_no_nodes_in_slice simp:slice_edges_def)"], ["proof (state)\nthis:\n  \\<forall>nx\\<in>set (sourcenodes as'). nx \\<notin> backward_slice S\n\ngoal (2 subgoals):\n 1. \\<And>n as' s s'.\n       \\<lbrakk>valid_node n; n -as'\\<rightarrow>* n;\n        slice_edges S [] = slice_edges S as'; preds (slice_kinds S []) s;\n        preds (slice_kinds S as') s'; n \\<in> S;\n        \\<forall>V\\<in>rv S n. state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> [] = as'\n 2. \\<And>n'' as n' a n as' s s'.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        \\<And>as' s s'.\n           \\<lbrakk>n'' -as'\\<rightarrow>* n';\n            slice_edges S as = slice_edges S as';\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            n' \\<in> S;\n            \\<forall>V\\<in>rv S n''. state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> as = as';\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        n -as'\\<rightarrow>* n'; slice_edges S (a # as) = slice_edges S as';\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        n' \\<in> S;\n        \\<forall>V\\<in>rv S n. state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> a # as = as'", "with \\<open>n -as'\\<rightarrow>* n\\<close>"], ["proof (chain)\npicking this:\n  n -as'\\<rightarrow>* n\n  \\<forall>nx\\<in>set (sourcenodes as'). nx \\<notin> backward_slice S", "show ?case"], ["proof (prove)\nusing this:\n  n -as'\\<rightarrow>* n\n  \\<forall>nx\\<in>set (sourcenodes as'). nx \\<notin> backward_slice S\n\ngoal (1 subgoal):\n 1. [] = as'", "proof(induct nx\\<equiv>\"n\" as' nx'\\<equiv>\"n\" rule:path.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>valid_node n;\n     \\<forall>nx\\<in>set (sourcenodes []).\n        nx \\<notin> backward_slice S\\<rbrakk>\n    \\<Longrightarrow> [] = []\n 2. \\<And>n'' as a.\n       \\<lbrakk>n'' -as\\<rightarrow>* n;\n        \\<lbrakk>n'' = n;\n         \\<forall>nx\\<in>set (sourcenodes as).\n            nx \\<notin> backward_slice S\\<rbrakk>\n        \\<Longrightarrow> [] = as;\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        \\<forall>nx\\<in>set (sourcenodes (a # as)).\n           nx \\<notin> backward_slice S\\<rbrakk>\n       \\<Longrightarrow> [] = a # as", "case (Cons_path n'' as a)"], ["proof (state)\nthis:\n  n'' -as\\<rightarrow>* n\n  \\<lbrakk>n'' = n;\n   \\<forall>nx\\<in>set (sourcenodes as).\n      nx \\<notin> backward_slice S\\<rbrakk>\n  \\<Longrightarrow> [] = as\n  valid_edge a\n  sourcenode a = n\n  targetnode a = n''\n  \\<forall>nx\\<in>set (sourcenodes (a # as)). nx \\<notin> backward_slice S\n\ngoal (2 subgoals):\n 1. \\<lbrakk>valid_node n;\n     \\<forall>nx\\<in>set (sourcenodes []).\n        nx \\<notin> backward_slice S\\<rbrakk>\n    \\<Longrightarrow> [] = []\n 2. \\<And>n'' as a.\n       \\<lbrakk>n'' -as\\<rightarrow>* n;\n        \\<lbrakk>n'' = n;\n         \\<forall>nx\\<in>set (sourcenodes as).\n            nx \\<notin> backward_slice S\\<rbrakk>\n        \\<Longrightarrow> [] = as;\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        \\<forall>nx\\<in>set (sourcenodes (a # as)).\n           nx \\<notin> backward_slice S\\<rbrakk>\n       \\<Longrightarrow> [] = a # as", "from \\<open>valid_node n\\<close> \\<open>n \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  valid_node n\n  n \\<in> S", "have \"n \\<in> backward_slice S\""], ["proof (prove)\nusing this:\n  valid_node n\n  n \\<in> S\n\ngoal (1 subgoal):\n 1. n \\<in> backward_slice S", "by(rule refl)"], ["proof (state)\nthis:\n  n \\<in> backward_slice S\n\ngoal (2 subgoals):\n 1. \\<lbrakk>valid_node n;\n     \\<forall>nx\\<in>set (sourcenodes []).\n        nx \\<notin> backward_slice S\\<rbrakk>\n    \\<Longrightarrow> [] = []\n 2. \\<And>n'' as a.\n       \\<lbrakk>n'' -as\\<rightarrow>* n;\n        \\<lbrakk>n'' = n;\n         \\<forall>nx\\<in>set (sourcenodes as).\n            nx \\<notin> backward_slice S\\<rbrakk>\n        \\<Longrightarrow> [] = as;\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        \\<forall>nx\\<in>set (sourcenodes (a # as)).\n           nx \\<notin> backward_slice S\\<rbrakk>\n       \\<Longrightarrow> [] = a # as", "with \\<open>\\<forall>nx\\<in>set (sourcenodes (a # as)). nx \\<notin> backward_slice S\\<close> \n      \\<open>sourcenode a = n\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>nx\\<in>set (sourcenodes (a # as)). nx \\<notin> backward_slice S\n  sourcenode a = n\n  n \\<in> backward_slice S", "have False"], ["proof (prove)\nusing this:\n  \\<forall>nx\\<in>set (sourcenodes (a # as)). nx \\<notin> backward_slice S\n  sourcenode a = n\n  n \\<in> backward_slice S\n\ngoal (1 subgoal):\n 1. False", "by(simp add:sourcenodes_def)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<lbrakk>valid_node n;\n     \\<forall>nx\\<in>set (sourcenodes []).\n        nx \\<notin> backward_slice S\\<rbrakk>\n    \\<Longrightarrow> [] = []\n 2. \\<And>n'' as a.\n       \\<lbrakk>n'' -as\\<rightarrow>* n;\n        \\<lbrakk>n'' = n;\n         \\<forall>nx\\<in>set (sourcenodes as).\n            nx \\<notin> backward_slice S\\<rbrakk>\n        \\<Longrightarrow> [] = as;\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        \\<forall>nx\\<in>set (sourcenodes (a # as)).\n           nx \\<notin> backward_slice S\\<rbrakk>\n       \\<Longrightarrow> [] = a # as", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. [] = a # as", "by simp"], ["proof (state)\nthis:\n  [] = a # as\n\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_node n;\n     \\<forall>nx\\<in>set (sourcenodes []).\n        nx \\<notin> backward_slice S\\<rbrakk>\n    \\<Longrightarrow> [] = []", "qed simp"], ["proof (state)\nthis:\n  [] = as'\n\ngoal (1 subgoal):\n 1. \\<And>n'' as n' a n as' s s'.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        \\<And>as' s s'.\n           \\<lbrakk>n'' -as'\\<rightarrow>* n';\n            slice_edges S as = slice_edges S as';\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            n' \\<in> S;\n            \\<forall>V\\<in>rv S n''. state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> as = as';\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        n -as'\\<rightarrow>* n'; slice_edges S (a # as) = slice_edges S as';\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        n' \\<in> S;\n        \\<forall>V\\<in>rv S n. state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> a # as = as'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n'' as n' a n as' s s'.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        \\<And>as' s s'.\n           \\<lbrakk>n'' -as'\\<rightarrow>* n';\n            slice_edges S as = slice_edges S as';\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            n' \\<in> S;\n            \\<forall>V\\<in>rv S n''. state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> as = as';\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        n -as'\\<rightarrow>* n'; slice_edges S (a # as) = slice_edges S as';\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        n' \\<in> S;\n        \\<forall>V\\<in>rv S n. state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> a # as = as'", "case (Cons_path n'' as n' a n)"], ["proof (state)\nthis:\n  n'' -as\\<rightarrow>* n'\n  \\<lbrakk>n'' -?as'\\<rightarrow>* n';\n   slice_edges S as = slice_edges S ?as'; preds (slice_kinds S as) ?s;\n   preds (slice_kinds S ?as') ?s'; n' \\<in> S;\n   \\<forall>V\\<in>rv S n''. state_val ?s V = state_val ?s' V\\<rbrakk>\n  \\<Longrightarrow> as = ?as'\n  valid_edge a\n  sourcenode a = n\n  targetnode a = n''\n  n -as'\\<rightarrow>* n'\n  slice_edges S (a # as) = slice_edges S as'\n  preds (slice_kinds S (a # as)) s\n  preds (slice_kinds S as') s'\n  n' \\<in> S\n  \\<forall>V\\<in>rv S n. state_val s V = state_val s' V\n\ngoal (1 subgoal):\n 1. \\<And>n'' as n' a n as' s s'.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        \\<And>as' s s'.\n           \\<lbrakk>n'' -as'\\<rightarrow>* n';\n            slice_edges S as = slice_edges S as';\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            n' \\<in> S;\n            \\<forall>V\\<in>rv S n''. state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> as = as';\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        n -as'\\<rightarrow>* n'; slice_edges S (a # as) = slice_edges S as';\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        n' \\<in> S;\n        \\<forall>V\\<in>rv S n. state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> a # as = as'", "note IH = \\<open>\\<And>as' s s'. \\<lbrakk>n'' -as'\\<rightarrow>* n'; slice_edges S as = slice_edges S as';\n    preds (slice_kinds S as) s; preds (slice_kinds S as') s'; n' \\<in> S;\n    \\<forall>V\\<in>rv S n''. state_val s V = state_val s' V\\<rbrakk> \\<Longrightarrow> as = as'\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>n'' -?as'\\<rightarrow>* n';\n   slice_edges S as = slice_edges S ?as'; preds (slice_kinds S as) ?s;\n   preds (slice_kinds S ?as') ?s'; n' \\<in> S;\n   \\<forall>V\\<in>rv S n''. state_val ?s V = state_val ?s' V\\<rbrakk>\n  \\<Longrightarrow> as = ?as'\n\ngoal (1 subgoal):\n 1. \\<And>n'' as n' a n as' s s'.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        \\<And>as' s s'.\n           \\<lbrakk>n'' -as'\\<rightarrow>* n';\n            slice_edges S as = slice_edges S as';\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            n' \\<in> S;\n            \\<forall>V\\<in>rv S n''. state_val s V = state_val s' V\\<rbrakk>\n           \\<Longrightarrow> as = as';\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        n -as'\\<rightarrow>* n'; slice_edges S (a # as) = slice_edges S as';\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        n' \\<in> S;\n        \\<forall>V\\<in>rv S n. state_val s V = state_val s' V\\<rbrakk>\n       \\<Longrightarrow> a # as = as'", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. a # as = as'", "proof(cases as')"], ["proof (state)\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow> a # as = as'\n 2. \\<And>aa list. as' = aa # list \\<Longrightarrow> a # as = as'", "case Nil"], ["proof (state)\nthis:\n  as' = []\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow> a # as = as'\n 2. \\<And>aa list. as' = aa # list \\<Longrightarrow> a # as = as'", "with \\<open>n -as'\\<rightarrow>* n'\\<close>"], ["proof (chain)\npicking this:\n  n -as'\\<rightarrow>* n'\n  as' = []", "have \"n = n'\""], ["proof (prove)\nusing this:\n  n -as'\\<rightarrow>* n'\n  as' = []\n\ngoal (1 subgoal):\n 1. n = n'", "by fastforce"], ["proof (state)\nthis:\n  n = n'\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow> a # as = as'\n 2. \\<And>aa list. as' = aa # list \\<Longrightarrow> a # as = as'", "from Nil \\<open>slice_edges S (a#as) = slice_edges S as'\\<close> \\<open>sourcenode a = n\\<close>"], ["proof (chain)\npicking this:\n  as' = []\n  slice_edges S (a # as) = slice_edges S as'\n  sourcenode a = n", "have \"n \\<notin> backward_slice S\""], ["proof (prove)\nusing this:\n  as' = []\n  slice_edges S (a # as) = slice_edges S as'\n  sourcenode a = n\n\ngoal (1 subgoal):\n 1. n \\<notin> backward_slice S", "by(fastforce simp:slice_edges_def)"], ["proof (state)\nthis:\n  n \\<notin> backward_slice S\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow> a # as = as'\n 2. \\<And>aa list. as' = aa # list \\<Longrightarrow> a # as = as'", "from \\<open>valid_edge a\\<close> \\<open>sourcenode a = n\\<close> \\<open>n = n'\\<close> \\<open>n' \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  sourcenode a = n\n  n = n'\n  n' \\<in> S", "have \"n \\<in> backward_slice S\""], ["proof (prove)\nusing this:\n  valid_edge a\n  sourcenode a = n\n  n = n'\n  n' \\<in> S\n\ngoal (1 subgoal):\n 1. n \\<in> backward_slice S", "by(fastforce intro:refl)"], ["proof (state)\nthis:\n  n \\<in> backward_slice S\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow> a # as = as'\n 2. \\<And>aa list. as' = aa # list \\<Longrightarrow> a # as = as'", "with \\<open>n = n'\\<close> \\<open>n \\<notin> backward_slice S\\<close>"], ["proof (chain)\npicking this:\n  n = n'\n  n \\<notin> backward_slice S\n  n \\<in> backward_slice S", "have False"], ["proof (prove)\nusing this:\n  n = n'\n  n \\<notin> backward_slice S\n  n \\<in> backward_slice S\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow> a # as = as'\n 2. \\<And>aa list. as' = aa # list \\<Longrightarrow> a # as = as'", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. a # as = as'", "by simp"], ["proof (state)\nthis:\n  a # as = as'\n\ngoal (1 subgoal):\n 1. \\<And>aa list. as' = aa # list \\<Longrightarrow> a # as = as'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa list. as' = aa # list \\<Longrightarrow> a # as = as'", "case (Cons ax asx)"], ["proof (state)\nthis:\n  as' = ax # asx\n\ngoal (1 subgoal):\n 1. \\<And>aa list. as' = aa # list \\<Longrightarrow> a # as = as'", "with \\<open>n -as'\\<rightarrow>* n'\\<close>"], ["proof (chain)\npicking this:\n  n -as'\\<rightarrow>* n'\n  as' = ax # asx", "have \"n = sourcenode ax\" and \"valid_edge ax\" \n      and \"targetnode ax -asx\\<rightarrow>* n'\""], ["proof (prove)\nusing this:\n  n -as'\\<rightarrow>* n'\n  as' = ax # asx\n\ngoal (1 subgoal):\n 1. n = sourcenode ax &&&\n    valid_edge ax &&& targetnode ax -asx\\<rightarrow>* n'", "by(auto elim:path_split_Cons)"], ["proof (state)\nthis:\n  n = sourcenode ax\n  valid_edge ax\n  targetnode ax -asx\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. \\<And>aa list. as' = aa # list \\<Longrightarrow> a # as = as'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. a # as = as'", "proof(cases \"targetnode ax = n''\")"], ["proof (state)\ngoal (2 subgoals):\n 1. targetnode ax = n'' \\<Longrightarrow> a # as = as'\n 2. targetnode ax \\<noteq> n'' \\<Longrightarrow> a # as = as'", "case True"], ["proof (state)\nthis:\n  targetnode ax = n''\n\ngoal (2 subgoals):\n 1. targetnode ax = n'' \\<Longrightarrow> a # as = as'\n 2. targetnode ax \\<noteq> n'' \\<Longrightarrow> a # as = as'", "with \\<open>targetnode ax -asx\\<rightarrow>* n'\\<close>"], ["proof (chain)\npicking this:\n  targetnode ax -asx\\<rightarrow>* n'\n  targetnode ax = n''", "have \"n'' -asx\\<rightarrow>* n'\""], ["proof (prove)\nusing this:\n  targetnode ax -asx\\<rightarrow>* n'\n  targetnode ax = n''\n\ngoal (1 subgoal):\n 1. n'' -asx\\<rightarrow>* n'", "by simp"], ["proof (state)\nthis:\n  n'' -asx\\<rightarrow>* n'\n\ngoal (2 subgoals):\n 1. targetnode ax = n'' \\<Longrightarrow> a # as = as'\n 2. targetnode ax \\<noteq> n'' \\<Longrightarrow> a # as = as'", "from \\<open>valid_edge ax\\<close> \\<open>valid_edge a\\<close> \\<open>n = sourcenode ax\\<close> \\<open>sourcenode a = n\\<close>\n        True \\<open>targetnode a = n''\\<close>"], ["proof (chain)\npicking this:\n  valid_edge ax\n  valid_edge a\n  n = sourcenode ax\n  sourcenode a = n\n  targetnode ax = n''\n  targetnode a = n''", "have \"ax = a\""], ["proof (prove)\nusing this:\n  valid_edge ax\n  valid_edge a\n  n = sourcenode ax\n  sourcenode a = n\n  targetnode ax = n''\n  targetnode a = n''\n\ngoal (1 subgoal):\n 1. ax = a", "by(fastforce intro:edge_det)"], ["proof (state)\nthis:\n  ax = a\n\ngoal (2 subgoals):\n 1. targetnode ax = n'' \\<Longrightarrow> a # as = as'\n 2. targetnode ax \\<noteq> n'' \\<Longrightarrow> a # as = as'", "from \\<open>slice_edges S (a#as) = slice_edges S as'\\<close> Cons \n        \\<open>n = sourcenode ax\\<close> \\<open>sourcenode a = n\\<close>"], ["proof (chain)\npicking this:\n  slice_edges S (a # as) = slice_edges S as'\n  as' = ax # asx\n  n = sourcenode ax\n  sourcenode a = n", "have \"slice_edges S as = slice_edges S asx\""], ["proof (prove)\nusing this:\n  slice_edges S (a # as) = slice_edges S as'\n  as' = ax # asx\n  n = sourcenode ax\n  sourcenode a = n\n\ngoal (1 subgoal):\n 1. slice_edges S as = slice_edges S asx", "by(cases \"n \\<in> backward_slice S\")(auto simp:slice_edges_def)"], ["proof (state)\nthis:\n  slice_edges S as = slice_edges S asx\n\ngoal (2 subgoals):\n 1. targetnode ax = n'' \\<Longrightarrow> a # as = as'\n 2. targetnode ax \\<noteq> n'' \\<Longrightarrow> a # as = as'", "from \\<open>preds (slice_kinds S (a#as)) s\\<close>"], ["proof (chain)\npicking this:\n  preds (slice_kinds S (a # as)) s", "have preds1:\"preds (slice_kinds S as) (transfer (slice_kind S a) s)\""], ["proof (prove)\nusing this:\n  preds (slice_kinds S (a # as)) s\n\ngoal (1 subgoal):\n 1. preds (slice_kinds S as) (transfer (slice_kind S a) s)", "by(simp add:slice_kinds_def)"], ["proof (state)\nthis:\n  preds (slice_kinds S as) (transfer (slice_kind S a) s)\n\ngoal (2 subgoals):\n 1. targetnode ax = n'' \\<Longrightarrow> a # as = as'\n 2. targetnode ax \\<noteq> n'' \\<Longrightarrow> a # as = as'", "from \\<open>preds (slice_kinds S as') s'\\<close> Cons \\<open>ax = a\\<close>"], ["proof (chain)\npicking this:\n  preds (slice_kinds S as') s'\n  as' = ax # asx\n  ax = a", "have preds2:\"preds (slice_kinds S asx) (transfer (slice_kind S a) s')\""], ["proof (prove)\nusing this:\n  preds (slice_kinds S as') s'\n  as' = ax # asx\n  ax = a\n\ngoal (1 subgoal):\n 1. preds (slice_kinds S asx) (transfer (slice_kind S a) s')", "by(simp add:slice_kinds_def)"], ["proof (state)\nthis:\n  preds (slice_kinds S asx) (transfer (slice_kind S a) s')\n\ngoal (2 subgoals):\n 1. targetnode ax = n'' \\<Longrightarrow> a # as = as'\n 2. targetnode ax \\<noteq> n'' \\<Longrightarrow> a # as = as'", "from \\<open>valid_edge a\\<close> \\<open>sourcenode a = n\\<close> \\<open>targetnode a = n''\\<close>\n        \\<open>preds (slice_kinds S (a#as)) s\\<close> \\<open>preds (slice_kinds S as') s'\\<close>\n        \\<open>ax = a\\<close> Cons \\<open>\\<forall>V\\<in>rv S n. state_val s V = state_val s' V\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  sourcenode a = n\n  targetnode a = n''\n  preds (slice_kinds S (a # as)) s\n  preds (slice_kinds S as') s'\n  ax = a\n  as' = ax # asx\n  \\<forall>V\\<in>rv S n. state_val s V = state_val s' V", "have \"\\<forall>V\\<in>rv S n''. state_val (transfer (slice_kind S a) s) V =\n                          state_val (transfer (slice_kind S a) s') V\""], ["proof (prove)\nusing this:\n  valid_edge a\n  sourcenode a = n\n  targetnode a = n''\n  preds (slice_kinds S (a # as)) s\n  preds (slice_kinds S as') s'\n  ax = a\n  as' = ax # asx\n  \\<forall>V\\<in>rv S n. state_val s V = state_val s' V\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>rv S n''.\n       state_val (transfer (slice_kind S a) s) V =\n       state_val (transfer (slice_kind S a) s') V", "by -(rule rv_edge_slice_kinds,auto)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>rv S n''.\n     state_val (transfer (slice_kind S a) s) V =\n     state_val (transfer (slice_kind S a) s') V\n\ngoal (2 subgoals):\n 1. targetnode ax = n'' \\<Longrightarrow> a # as = as'\n 2. targetnode ax \\<noteq> n'' \\<Longrightarrow> a # as = as'", "from IH[OF \\<open>n'' -asx\\<rightarrow>* n'\\<close> \\<open>slice_edges S as = slice_edges S asx\\<close>\n        preds1 preds2 \\<open>n' \\<in> S\\<close> this] Cons \\<open>ax = a\\<close>"], ["proof (chain)\npicking this:\n  as = asx\n  as' = ax # asx\n  ax = a", "show ?thesis"], ["proof (prove)\nusing this:\n  as = asx\n  as' = ax # asx\n  ax = a\n\ngoal (1 subgoal):\n 1. a # as = as'", "by simp"], ["proof (state)\nthis:\n  a # as = as'\n\ngoal (1 subgoal):\n 1. targetnode ax \\<noteq> n'' \\<Longrightarrow> a # as = as'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. targetnode ax \\<noteq> n'' \\<Longrightarrow> a # as = as'", "case False"], ["proof (state)\nthis:\n  targetnode ax \\<noteq> n''\n\ngoal (1 subgoal):\n 1. targetnode ax \\<noteq> n'' \\<Longrightarrow> a # as = as'", "with \\<open>valid_edge a\\<close> \\<open>valid_edge ax\\<close> \\<open>sourcenode a = n\\<close> \\<open>n = sourcenode ax\\<close>\n        \\<open>targetnode a = n''\\<close> \\<open>preds (slice_kinds S (a#as)) s\\<close>\n        \\<open>preds (slice_kinds S as') s'\\<close> Cons\n        \\<open>\\<forall>V\\<in>rv S n. state_val s V = state_val s' V\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  valid_edge ax\n  sourcenode a = n\n  n = sourcenode ax\n  targetnode a = n''\n  preds (slice_kinds S (a # as)) s\n  preds (slice_kinds S as') s'\n  as' = ax # asx\n  \\<forall>V\\<in>rv S n. state_val s V = state_val s' V\n  targetnode ax \\<noteq> n''", "have False"], ["proof (prove)\nusing this:\n  valid_edge a\n  valid_edge ax\n  sourcenode a = n\n  n = sourcenode ax\n  targetnode a = n''\n  preds (slice_kinds S (a # as)) s\n  preds (slice_kinds S as') s'\n  as' = ax # asx\n  \\<forall>V\\<in>rv S n. state_val s V = state_val s' V\n  targetnode ax \\<noteq> n''\n\ngoal (1 subgoal):\n 1. False", "by -(erule rv_branching_edges_slice_kinds_False,auto)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. targetnode ax \\<noteq> n'' \\<Longrightarrow> a # as = as'", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. a # as = as'", "by simp"], ["proof (state)\nthis:\n  a # as = as'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a # as = as'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a # as = as'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma path_trans_observable_moves:\n  assumes \"n -as\\<rightarrow>* n'\" and \"preds (kinds as) s\" and \"transfers (kinds as) s = s'\"\n  obtains n'' s'' as' as'' where \"S,kind \\<turnstile> (n,s) =slice_edges S as\\<Rightarrow>* (n'',s'')\"\n  and \"S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s')\" \n  and \"slice_edges S as = slice_edges S as''\" and \"n -as''@as'\\<rightarrow>* n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n'' s'' as' as''.\n        \\<lbrakk>S,kind \\<turnstile> (n,s) =slice_edges S\n       as\\<Rightarrow>* (n'',s'');\n         S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s');\n         slice_edges S as = slice_edges S as'';\n         n -as'' @ as'\\<rightarrow>* n'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n'' s'' as' as''.\n       S,kind \\<turnstile> (n,s) =slice_edges S\n                                   as\\<Rightarrow>* (n'',s'') \\<and>\n       S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n       slice_edges S as = slice_edges S as'' \\<and>\n       n -as'' @ as'\\<rightarrow>* n'", "from \\<open>n -as\\<rightarrow>* n'\\<close> \\<open>preds (kinds as) s\\<close> \\<open>transfers (kinds as) s = s'\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>* n'\n  preds (kinds as) s\n  transfers (kinds as) s = s'", "show \"\\<exists>n'' s'' as' as''. \n    S,kind \\<turnstile> (n,s) =slice_edges S as\\<Rightarrow>* (n'',s'') \\<and>\n    S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and> slice_edges S as = slice_edges S as'' \\<and>\n    n -as''@as'\\<rightarrow>* n'\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>* n'\n  preds (kinds as) s\n  transfers (kinds as) s = s'\n\ngoal (1 subgoal):\n 1. \\<exists>n'' s'' as' as''.\n       S,kind \\<turnstile> (n,s) =slice_edges S\n                                   as\\<Rightarrow>* (n'',s'') \\<and>\n       S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n       slice_edges S as = slice_edges S as'' \\<and>\n       n -as'' @ as'\\<rightarrow>* n'", "proof(induct arbitrary:s rule:path.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n s.\n       \\<lbrakk>valid_node n; preds (kinds []) s;\n        transfers (kinds []) s = s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n'' s'' as' as''.\n                            S,kind \\<turnstile> (n,s) =slice_edges S\n                  []\\<Rightarrow>* (n'',s'') \\<and>\n                            S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n,s') \\<and>\n                            slice_edges S [] = slice_edges S as'' \\<and>\n                            n -as'' @ as'\\<rightarrow>* n\n 2. \\<And>n'' as n' a n s.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        \\<And>s.\n           \\<lbrakk>preds (kinds as) s; transfers (kinds as) s = s'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>n''a s'' as' as''.\n                                S,kind \\<turnstile> (n'',s) =slice_edges S\n                        as\\<Rightarrow>* (n''a,s'') \\<and>\n                                S,kind \\<turnstile> (n''a,s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n                                slice_edges S as = slice_edges S as'' \\<and>\n                                n'' -as'' @ as'\\<rightarrow>* n';\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        preds (kinds (a # as)) s; transfers (kinds (a # as)) s = s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n'' s'' as' as''.\n                            S,kind \\<turnstile> (n,s) =slice_edges S\n                  (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n                            S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n                            slice_edges S (a # as) =\n                            slice_edges S as'' \\<and>\n                            n -as'' @ as'\\<rightarrow>* n'", "case (empty_path n)"], ["proof (state)\nthis:\n  valid_node n\n  preds (kinds []) s\n  transfers (kinds []) s = s'\n\ngoal (2 subgoals):\n 1. \\<And>n s.\n       \\<lbrakk>valid_node n; preds (kinds []) s;\n        transfers (kinds []) s = s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n'' s'' as' as''.\n                            S,kind \\<turnstile> (n,s) =slice_edges S\n                  []\\<Rightarrow>* (n'',s'') \\<and>\n                            S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n,s') \\<and>\n                            slice_edges S [] = slice_edges S as'' \\<and>\n                            n -as'' @ as'\\<rightarrow>* n\n 2. \\<And>n'' as n' a n s.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        \\<And>s.\n           \\<lbrakk>preds (kinds as) s; transfers (kinds as) s = s'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>n''a s'' as' as''.\n                                S,kind \\<turnstile> (n'',s) =slice_edges S\n                        as\\<Rightarrow>* (n''a,s'') \\<and>\n                                S,kind \\<turnstile> (n''a,s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n                                slice_edges S as = slice_edges S as'' \\<and>\n                                n'' -as'' @ as'\\<rightarrow>* n';\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        preds (kinds (a # as)) s; transfers (kinds (a # as)) s = s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n'' s'' as' as''.\n                            S,kind \\<turnstile> (n,s) =slice_edges S\n                  (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n                            S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n                            slice_edges S (a # as) =\n                            slice_edges S as'' \\<and>\n                            n -as'' @ as'\\<rightarrow>* n'", "from \\<open>transfers (kinds []) s = s'\\<close>"], ["proof (chain)\npicking this:\n  transfers (kinds []) s = s'", "have \"s = s'\""], ["proof (prove)\nusing this:\n  transfers (kinds []) s = s'\n\ngoal (1 subgoal):\n 1. s = s'", "by(simp add:kinds_def)"], ["proof (state)\nthis:\n  s = s'\n\ngoal (2 subgoals):\n 1. \\<And>n s.\n       \\<lbrakk>valid_node n; preds (kinds []) s;\n        transfers (kinds []) s = s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n'' s'' as' as''.\n                            S,kind \\<turnstile> (n,s) =slice_edges S\n                  []\\<Rightarrow>* (n'',s'') \\<and>\n                            S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n,s') \\<and>\n                            slice_edges S [] = slice_edges S as'' \\<and>\n                            n -as'' @ as'\\<rightarrow>* n\n 2. \\<And>n'' as n' a n s.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        \\<And>s.\n           \\<lbrakk>preds (kinds as) s; transfers (kinds as) s = s'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>n''a s'' as' as''.\n                                S,kind \\<turnstile> (n'',s) =slice_edges S\n                        as\\<Rightarrow>* (n''a,s'') \\<and>\n                                S,kind \\<turnstile> (n''a,s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n                                slice_edges S as = slice_edges S as'' \\<and>\n                                n'' -as'' @ as'\\<rightarrow>* n';\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        preds (kinds (a # as)) s; transfers (kinds (a # as)) s = s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n'' s'' as' as''.\n                            S,kind \\<turnstile> (n,s) =slice_edges S\n                  (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n                            S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n                            slice_edges S (a # as) =\n                            slice_edges S as'' \\<and>\n                            n -as'' @ as'\\<rightarrow>* n'", "have \"S,kind \\<turnstile> (n,s) =[]\\<Rightarrow>* (n,s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S,kind \\<turnstile> (n,s) =[]\\<Rightarrow>* (n,s)", "by(rule tom_Nil)"], ["proof (state)\nthis:\n  S,kind \\<turnstile> (n,s) =[]\\<Rightarrow>* (n,s)\n\ngoal (2 subgoals):\n 1. \\<And>n s.\n       \\<lbrakk>valid_node n; preds (kinds []) s;\n        transfers (kinds []) s = s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n'' s'' as' as''.\n                            S,kind \\<turnstile> (n,s) =slice_edges S\n                  []\\<Rightarrow>* (n'',s'') \\<and>\n                            S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n,s') \\<and>\n                            slice_edges S [] = slice_edges S as'' \\<and>\n                            n -as'' @ as'\\<rightarrow>* n\n 2. \\<And>n'' as n' a n s.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        \\<And>s.\n           \\<lbrakk>preds (kinds as) s; transfers (kinds as) s = s'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>n''a s'' as' as''.\n                                S,kind \\<turnstile> (n'',s) =slice_edges S\n                        as\\<Rightarrow>* (n''a,s'') \\<and>\n                                S,kind \\<turnstile> (n''a,s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n                                slice_edges S as = slice_edges S as'' \\<and>\n                                n'' -as'' @ as'\\<rightarrow>* n';\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        preds (kinds (a # as)) s; transfers (kinds (a # as)) s = s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n'' s'' as' as''.\n                            S,kind \\<turnstile> (n,s) =slice_edges S\n                  (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n                            S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n                            slice_edges S (a # as) =\n                            slice_edges S as'' \\<and>\n                            n -as'' @ as'\\<rightarrow>* n'", "have \"S,kind \\<turnstile> (n,s) =[]\\<Rightarrow>\\<^sub>\\<tau> (n,s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S,kind \\<turnstile> (n,s) =[]\\<Rightarrow>\\<^sub>\\<tau> (n,s)", "by(rule silent_moves_Nil)"], ["proof (state)\nthis:\n  S,kind \\<turnstile> (n,s) =[]\\<Rightarrow>\\<^sub>\\<tau> (n,s)\n\ngoal (2 subgoals):\n 1. \\<And>n s.\n       \\<lbrakk>valid_node n; preds (kinds []) s;\n        transfers (kinds []) s = s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n'' s'' as' as''.\n                            S,kind \\<turnstile> (n,s) =slice_edges S\n                  []\\<Rightarrow>* (n'',s'') \\<and>\n                            S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n,s') \\<and>\n                            slice_edges S [] = slice_edges S as'' \\<and>\n                            n -as'' @ as'\\<rightarrow>* n\n 2. \\<And>n'' as n' a n s.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        \\<And>s.\n           \\<lbrakk>preds (kinds as) s; transfers (kinds as) s = s'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>n''a s'' as' as''.\n                                S,kind \\<turnstile> (n'',s) =slice_edges S\n                        as\\<Rightarrow>* (n''a,s'') \\<and>\n                                S,kind \\<turnstile> (n''a,s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n                                slice_edges S as = slice_edges S as'' \\<and>\n                                n'' -as'' @ as'\\<rightarrow>* n';\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        preds (kinds (a # as)) s; transfers (kinds (a # as)) s = s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n'' s'' as' as''.\n                            S,kind \\<turnstile> (n,s) =slice_edges S\n                  (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n                            S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n                            slice_edges S (a # as) =\n                            slice_edges S as'' \\<and>\n                            n -as'' @ as'\\<rightarrow>* n'", "with \\<open>S,kind \\<turnstile> (n,s) =[]\\<Rightarrow>* (n,s)\\<close> \\<open>s = s'\\<close> \\<open>valid_node n\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (n,s) =[]\\<Rightarrow>* (n,s)\n  s = s'\n  valid_node n\n  S,kind \\<turnstile> (n,s) =[]\\<Rightarrow>\\<^sub>\\<tau> (n,s)", "show ?case"], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (n,s) =[]\\<Rightarrow>* (n,s)\n  s = s'\n  valid_node n\n  S,kind \\<turnstile> (n,s) =[]\\<Rightarrow>\\<^sub>\\<tau> (n,s)\n\ngoal (1 subgoal):\n 1. \\<exists>n'' s'' as' as''.\n       S,kind \\<turnstile> (n,s) =slice_edges S\n                                   []\\<Rightarrow>* (n'',s'') \\<and>\n       S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n,s') \\<and>\n       slice_edges S [] = slice_edges S as'' \\<and>\n       n -as'' @ as'\\<rightarrow>* n", "apply(rule_tac x=\"n\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,kind \\<turnstile> (n,s) =[]\\<Rightarrow>* (n,s); s = s';\n     valid_node n;\n     S,kind \\<turnstile> (n,s) =[]\\<Rightarrow>\\<^sub>\\<tau> (n,s)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s'' as' as''.\n                         S,kind \\<turnstile> (n,s) =slice_edges S\n               []\\<Rightarrow>* (n,s'') \\<and>\n                         S,kind \\<turnstile> (n,s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n,s') \\<and>\n                         slice_edges S [] = slice_edges S as'' \\<and>\n                         n -as'' @ as'\\<rightarrow>* n", "apply(rule_tac x=\"s\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,kind \\<turnstile> (n,s) =[]\\<Rightarrow>* (n,s); s = s';\n     valid_node n;\n     S,kind \\<turnstile> (n,s) =[]\\<Rightarrow>\\<^sub>\\<tau> (n,s)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as' as''.\n                         S,kind \\<turnstile> (n,s) =slice_edges S\n               []\\<Rightarrow>* (n,s) \\<and>\n                         S,kind \\<turnstile> (n,s) =as'\\<Rightarrow>\\<^sub>\\<tau> (n,s') \\<and>\n                         slice_edges S [] = slice_edges S as'' \\<and>\n                         n -as'' @ as'\\<rightarrow>* n", "apply(rule_tac x=\"[]\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,kind \\<turnstile> (n,s) =[]\\<Rightarrow>* (n,s); s = s';\n     valid_node n;\n     S,kind \\<turnstile> (n,s) =[]\\<Rightarrow>\\<^sub>\\<tau> (n,s)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as''.\n                         S,kind \\<turnstile> (n,s) =slice_edges S\n               []\\<Rightarrow>* (n,s) \\<and>\n                         S,kind \\<turnstile> (n,s) =[]\\<Rightarrow>\\<^sub>\\<tau> (n,s') \\<and>\n                         slice_edges S [] = slice_edges S as'' \\<and>\n                         n -as'' @ []\\<rightarrow>* n", "apply(rule_tac x=\"[]\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,kind \\<turnstile> (n,s) =[]\\<Rightarrow>* (n,s); s = s';\n     valid_node n;\n     S,kind \\<turnstile> (n,s) =[]\\<Rightarrow>\\<^sub>\\<tau> (n,s)\\<rbrakk>\n    \\<Longrightarrow> S,kind \\<turnstile> (n,s) =slice_edges S\n            []\\<Rightarrow>* (n,s) \\<and>\n                      S,kind \\<turnstile> (n,s) =[]\\<Rightarrow>\\<^sub>\\<tau> (n,s') \\<and>\n                      slice_edges S [] = slice_edges S [] \\<and>\n                      n -[] @ []\\<rightarrow>* n", "by(fastforce intro:path.empty_path simp:slice_edges_def)"], ["proof (state)\nthis:\n  \\<exists>n'' s'' as' as''.\n     S,kind \\<turnstile> (n,s) =slice_edges S\n                                 []\\<Rightarrow>* (n'',s'') \\<and>\n     S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n,s') \\<and>\n     slice_edges S [] = slice_edges S as'' \\<and>\n     n -as'' @ as'\\<rightarrow>* n\n\ngoal (1 subgoal):\n 1. \\<And>n'' as n' a n s.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        \\<And>s.\n           \\<lbrakk>preds (kinds as) s; transfers (kinds as) s = s'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>n''a s'' as' as''.\n                                S,kind \\<turnstile> (n'',s) =slice_edges S\n                        as\\<Rightarrow>* (n''a,s'') \\<and>\n                                S,kind \\<turnstile> (n''a,s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n                                slice_edges S as = slice_edges S as'' \\<and>\n                                n'' -as'' @ as'\\<rightarrow>* n';\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        preds (kinds (a # as)) s; transfers (kinds (a # as)) s = s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n'' s'' as' as''.\n                            S,kind \\<turnstile> (n,s) =slice_edges S\n                  (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n                            S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n                            slice_edges S (a # as) =\n                            slice_edges S as'' \\<and>\n                            n -as'' @ as'\\<rightarrow>* n'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n'' as n' a n s.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        \\<And>s.\n           \\<lbrakk>preds (kinds as) s; transfers (kinds as) s = s'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>n''a s'' as' as''.\n                                S,kind \\<turnstile> (n'',s) =slice_edges S\n                        as\\<Rightarrow>* (n''a,s'') \\<and>\n                                S,kind \\<turnstile> (n''a,s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n                                slice_edges S as = slice_edges S as'' \\<and>\n                                n'' -as'' @ as'\\<rightarrow>* n';\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        preds (kinds (a # as)) s; transfers (kinds (a # as)) s = s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n'' s'' as' as''.\n                            S,kind \\<turnstile> (n,s) =slice_edges S\n                  (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n                            S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n                            slice_edges S (a # as) =\n                            slice_edges S as'' \\<and>\n                            n -as'' @ as'\\<rightarrow>* n'", "case (Cons_path n'' as n' a n)"], ["proof (state)\nthis:\n  n'' -as\\<rightarrow>* n'\n  \\<lbrakk>preds (kinds as) ?s; transfers (kinds as) ?s = s'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>n''a s'' as' as''.\n                       S,kind \\<turnstile> (n'',?s) =slice_edges S\n                as\\<Rightarrow>* (n''a,s'') \\<and>\n                       S,kind \\<turnstile> (n''a,s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n                       slice_edges S as = slice_edges S as'' \\<and>\n                       n'' -as'' @ as'\\<rightarrow>* n'\n  valid_edge a\n  sourcenode a = n\n  targetnode a = n''\n  preds (kinds (a # as)) s\n  transfers (kinds (a # as)) s = s'\n\ngoal (1 subgoal):\n 1. \\<And>n'' as n' a n s.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        \\<And>s.\n           \\<lbrakk>preds (kinds as) s; transfers (kinds as) s = s'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>n''a s'' as' as''.\n                                S,kind \\<turnstile> (n'',s) =slice_edges S\n                        as\\<Rightarrow>* (n''a,s'') \\<and>\n                                S,kind \\<turnstile> (n''a,s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n                                slice_edges S as = slice_edges S as'' \\<and>\n                                n'' -as'' @ as'\\<rightarrow>* n';\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        preds (kinds (a # as)) s; transfers (kinds (a # as)) s = s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n'' s'' as' as''.\n                            S,kind \\<turnstile> (n,s) =slice_edges S\n                  (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n                            S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n                            slice_edges S (a # as) =\n                            slice_edges S as'' \\<and>\n                            n -as'' @ as'\\<rightarrow>* n'", "note IH = \\<open>\\<And>s. \\<lbrakk>preds (kinds as) s; transfers (kinds as) s = s'\\<rbrakk>\n      \\<Longrightarrow> \\<exists>nx s'' as' as''. S,kind \\<turnstile> (n'',s) =slice_edges S as\\<Rightarrow>* (nx,s'') \\<and>\n            S,kind \\<turnstile> (nx,s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and> \n            slice_edges S as = slice_edges S as'' \\<and> n'' -as''@as'\\<rightarrow>* n'\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>preds (kinds as) ?s; transfers (kinds as) ?s = s'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>nx s'' as' as''.\n                       S,kind \\<turnstile> (n'',?s) =slice_edges S\n                as\\<Rightarrow>* (nx,s'') \\<and>\n                       S,kind \\<turnstile> (nx,s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n                       slice_edges S as = slice_edges S as'' \\<and>\n                       n'' -as'' @ as'\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. \\<And>n'' as n' a n s.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        \\<And>s.\n           \\<lbrakk>preds (kinds as) s; transfers (kinds as) s = s'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>n''a s'' as' as''.\n                                S,kind \\<turnstile> (n'',s) =slice_edges S\n                        as\\<Rightarrow>* (n''a,s'') \\<and>\n                                S,kind \\<turnstile> (n''a,s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n                                slice_edges S as = slice_edges S as'' \\<and>\n                                n'' -as'' @ as'\\<rightarrow>* n';\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        preds (kinds (a # as)) s; transfers (kinds (a # as)) s = s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n'' s'' as' as''.\n                            S,kind \\<turnstile> (n,s) =slice_edges S\n                  (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n                            S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n                            slice_edges S (a # as) =\n                            slice_edges S as'' \\<and>\n                            n -as'' @ as'\\<rightarrow>* n'", "from \\<open>preds (kinds (a#as)) s\\<close> \\<open>transfers (kinds (a#as)) s = s'\\<close>"], ["proof (chain)\npicking this:\n  preds (kinds (a # as)) s\n  transfers (kinds (a # as)) s = s'", "have \"preds (kinds as) (transfer (kind a) s)\" \n      \"transfers (kinds as) (transfer (kind a) s) = s'\""], ["proof (prove)\nusing this:\n  preds (kinds (a # as)) s\n  transfers (kinds (a # as)) s = s'\n\ngoal (1 subgoal):\n 1. preds (kinds as) (transfer (kind a) s) &&&\n    transfers (kinds as) (transfer (kind a) s) = s'", "by(simp_all add:kinds_def)"], ["proof (state)\nthis:\n  preds (kinds as) (transfer (kind a) s)\n  transfers (kinds as) (transfer (kind a) s) = s'\n\ngoal (1 subgoal):\n 1. \\<And>n'' as n' a n s.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        \\<And>s.\n           \\<lbrakk>preds (kinds as) s; transfers (kinds as) s = s'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>n''a s'' as' as''.\n                                S,kind \\<turnstile> (n'',s) =slice_edges S\n                        as\\<Rightarrow>* (n''a,s'') \\<and>\n                                S,kind \\<turnstile> (n''a,s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n                                slice_edges S as = slice_edges S as'' \\<and>\n                                n'' -as'' @ as'\\<rightarrow>* n';\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        preds (kinds (a # as)) s; transfers (kinds (a # as)) s = s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n'' s'' as' as''.\n                            S,kind \\<turnstile> (n,s) =slice_edges S\n                  (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n                            S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n                            slice_edges S (a # as) =\n                            slice_edges S as'' \\<and>\n                            n -as'' @ as'\\<rightarrow>* n'", "from IH[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>nx s'' as' as''.\n     S,kind \\<turnstile> (n'',transfer (kind a)\n                               s) =slice_edges S\n                                    as\\<Rightarrow>* (nx,s'') \\<and>\n     S,kind \\<turnstile> (nx,s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n     slice_edges S as = slice_edges S as'' \\<and>\n     n'' -as'' @ as'\\<rightarrow>* n'", "obtain nx sx asx asx'\n      where \"S,kind \\<turnstile> (n'',transfer (kind a) s) =slice_edges S as\\<Rightarrow>* (nx,sx)\"\n      and \"S,kind \\<turnstile> (nx,sx) =asx\\<Rightarrow>\\<^sub>\\<tau> (n',s')\"\n      and \"slice_edges S as = slice_edges S asx'\"\n      and \"n'' -asx'@asx\\<rightarrow>* n'\""], ["proof (prove)\nusing this:\n  \\<exists>nx s'' as' as''.\n     S,kind \\<turnstile> (n'',transfer (kind a)\n                               s) =slice_edges S\n                                    as\\<Rightarrow>* (nx,s'') \\<and>\n     S,kind \\<turnstile> (nx,s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n     slice_edges S as = slice_edges S as'' \\<and>\n     n'' -as'' @ as'\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. (\\<And>nx sx asx asx'.\n        \\<lbrakk>S,kind \\<turnstile> (n'',transfer (kind a)\n     s) =slice_edges S as\\<Rightarrow>* (nx,sx);\n         S,kind \\<turnstile> (nx,sx) =asx\\<Rightarrow>\\<^sub>\\<tau> (n',s');\n         slice_edges S as = slice_edges S asx';\n         n'' -asx' @ asx\\<rightarrow>* n'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by clarsimp"], ["proof (state)\nthis:\n  S,kind \\<turnstile> (n'',transfer (kind a)\n                            s) =slice_edges S as\\<Rightarrow>* (nx,sx)\n  S,kind \\<turnstile> (nx,sx) =asx\\<Rightarrow>\\<^sub>\\<tau> (n',s')\n  slice_edges S as = slice_edges S asx'\n  n'' -asx' @ asx\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. \\<And>n'' as n' a n s.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        \\<And>s.\n           \\<lbrakk>preds (kinds as) s; transfers (kinds as) s = s'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>n''a s'' as' as''.\n                                S,kind \\<turnstile> (n'',s) =slice_edges S\n                        as\\<Rightarrow>* (n''a,s'') \\<and>\n                                S,kind \\<turnstile> (n''a,s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n                                slice_edges S as = slice_edges S as'' \\<and>\n                                n'' -as'' @ as'\\<rightarrow>* n';\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        preds (kinds (a # as)) s; transfers (kinds (a # as)) s = s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n'' s'' as' as''.\n                            S,kind \\<turnstile> (n,s) =slice_edges S\n                  (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n                            S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n                            slice_edges S (a # as) =\n                            slice_edges S as'' \\<and>\n                            n -as'' @ as'\\<rightarrow>* n'", "from \\<open>preds (kinds (a#as)) s\\<close>"], ["proof (chain)\npicking this:\n  preds (kinds (a # as)) s", "have \"pred (kind a) s\""], ["proof (prove)\nusing this:\n  preds (kinds (a # as)) s\n\ngoal (1 subgoal):\n 1. pred (kind a) s", "by(simp add:kinds_def)"], ["proof (state)\nthis:\n  pred (kind a) s\n\ngoal (1 subgoal):\n 1. \\<And>n'' as n' a n s.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        \\<And>s.\n           \\<lbrakk>preds (kinds as) s; transfers (kinds as) s = s'\\<rbrakk>\n           \\<Longrightarrow> \\<exists>n''a s'' as' as''.\n                                S,kind \\<turnstile> (n'',s) =slice_edges S\n                        as\\<Rightarrow>* (n''a,s'') \\<and>\n                                S,kind \\<turnstile> (n''a,s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n                                slice_edges S as = slice_edges S as'' \\<and>\n                                n'' -as'' @ as'\\<rightarrow>* n';\n        valid_edge a; sourcenode a = n; targetnode a = n'';\n        preds (kinds (a # as)) s; transfers (kinds (a # as)) s = s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n'' s'' as' as''.\n                            S,kind \\<turnstile> (n,s) =slice_edges S\n                  (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n                            S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n                            slice_edges S (a # as) =\n                            slice_edges S as'' \\<and>\n                            n -as'' @ as'\\<rightarrow>* n'", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n'' s'' as' as''.\n       S,kind \\<turnstile> (n,s) =slice_edges S\n                                   (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n       S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n       slice_edges S (a # as) = slice_edges S as'' \\<and>\n       n -as'' @ as'\\<rightarrow>* n'", "proof(cases \"n \\<in> backward_slice S\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n \\<in> backward_slice S \\<Longrightarrow>\n    \\<exists>n'' s'' as' as''.\n       S,kind \\<turnstile> (n,s) =slice_edges S\n                                   (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n       S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n       slice_edges S (a # as) = slice_edges S as'' \\<and>\n       n -as'' @ as'\\<rightarrow>* n'\n 2. n \\<notin> backward_slice S \\<Longrightarrow>\n    \\<exists>n'' s'' as' as''.\n       S,kind \\<turnstile> (n,s) =slice_edges S\n                                   (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n       S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n       slice_edges S (a # as) = slice_edges S as'' \\<and>\n       n -as'' @ as'\\<rightarrow>* n'", "case True"], ["proof (state)\nthis:\n  n \\<in> backward_slice S\n\ngoal (2 subgoals):\n 1. n \\<in> backward_slice S \\<Longrightarrow>\n    \\<exists>n'' s'' as' as''.\n       S,kind \\<turnstile> (n,s) =slice_edges S\n                                   (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n       S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n       slice_edges S (a # as) = slice_edges S as'' \\<and>\n       n -as'' @ as'\\<rightarrow>* n'\n 2. n \\<notin> backward_slice S \\<Longrightarrow>\n    \\<exists>n'' s'' as' as''.\n       S,kind \\<turnstile> (n,s) =slice_edges S\n                                   (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n       S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n       slice_edges S (a # as) = slice_edges S as'' \\<and>\n       n -as'' @ as'\\<rightarrow>* n'", "with \\<open>valid_edge a\\<close> \\<open>sourcenode a = n\\<close> \\<open>targetnode a = n''\\<close> \\<open>pred (kind a) s\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  sourcenode a = n\n  targetnode a = n''\n  pred (kind a) s\n  n \\<in> backward_slice S", "have \"S,kind \\<turnstile> (n,s) -a\\<rightarrow> (n'',transfer (kind a) s)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  sourcenode a = n\n  targetnode a = n''\n  pred (kind a) s\n  n \\<in> backward_slice S\n\ngoal (1 subgoal):\n 1. S,kind \\<turnstile> (n,s) -a\\<rightarrow> (n'',transfer (kind a) s)", "by(fastforce intro:observable_moveI)"], ["proof (state)\nthis:\n  S,kind \\<turnstile> (n,s) -a\\<rightarrow> (n'',transfer (kind a) s)\n\ngoal (2 subgoals):\n 1. n \\<in> backward_slice S \\<Longrightarrow>\n    \\<exists>n'' s'' as' as''.\n       S,kind \\<turnstile> (n,s) =slice_edges S\n                                   (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n       S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n       slice_edges S (a # as) = slice_edges S as'' \\<and>\n       n -as'' @ as'\\<rightarrow>* n'\n 2. n \\<notin> backward_slice S \\<Longrightarrow>\n    \\<exists>n'' s'' as' as''.\n       S,kind \\<turnstile> (n,s) =slice_edges S\n                                   (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n       S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n       slice_edges S (a # as) = slice_edges S as'' \\<and>\n       n -as'' @ as'\\<rightarrow>* n'", "hence \"S,kind \\<turnstile> (n,s) =[]@[a]\\<Rightarrow> (n'',transfer (kind a) s)\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (n,s) -a\\<rightarrow> (n'',transfer (kind a) s)\n\ngoal (1 subgoal):\n 1. S,kind \\<turnstile> (n,s) =[] @\n                               [a]\\<Rightarrow> (n'',transfer (kind a) s)", "by(fastforce intro:observable_moves_snoc silent_moves_Nil)"], ["proof (state)\nthis:\n  S,kind \\<turnstile> (n,s) =[] @ [a]\\<Rightarrow> (n'',transfer (kind a) s)\n\ngoal (2 subgoals):\n 1. n \\<in> backward_slice S \\<Longrightarrow>\n    \\<exists>n'' s'' as' as''.\n       S,kind \\<turnstile> (n,s) =slice_edges S\n                                   (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n       S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n       slice_edges S (a # as) = slice_edges S as'' \\<and>\n       n -as'' @ as'\\<rightarrow>* n'\n 2. n \\<notin> backward_slice S \\<Longrightarrow>\n    \\<exists>n'' s'' as' as''.\n       S,kind \\<turnstile> (n,s) =slice_edges S\n                                   (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n       S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n       slice_edges S (a # as) = slice_edges S as'' \\<and>\n       n -as'' @ as'\\<rightarrow>* n'", "with \\<open>S,kind \\<turnstile> (n'',transfer (kind a) s) =slice_edges S as\\<Rightarrow>* (nx,sx)\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (n'',transfer (kind a)\n                            s) =slice_edges S as\\<Rightarrow>* (nx,sx)\n  S,kind \\<turnstile> (n,s) =[] @ [a]\\<Rightarrow> (n'',transfer (kind a) s)", "have \"S,kind \\<turnstile> (n,s) =a#slice_edges S as\\<Rightarrow>* (nx,sx)\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (n'',transfer (kind a)\n                            s) =slice_edges S as\\<Rightarrow>* (nx,sx)\n  S,kind \\<turnstile> (n,s) =[] @ [a]\\<Rightarrow> (n'',transfer (kind a) s)\n\ngoal (1 subgoal):\n 1. S,kind \\<turnstile> (n,s) =a # slice_edges S as\\<Rightarrow>* (nx,sx)", "by(fastforce dest:tom_Cons)"], ["proof (state)\nthis:\n  S,kind \\<turnstile> (n,s) =a # slice_edges S as\\<Rightarrow>* (nx,sx)\n\ngoal (2 subgoals):\n 1. n \\<in> backward_slice S \\<Longrightarrow>\n    \\<exists>n'' s'' as' as''.\n       S,kind \\<turnstile> (n,s) =slice_edges S\n                                   (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n       S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n       slice_edges S (a # as) = slice_edges S as'' \\<and>\n       n -as'' @ as'\\<rightarrow>* n'\n 2. n \\<notin> backward_slice S \\<Longrightarrow>\n    \\<exists>n'' s'' as' as''.\n       S,kind \\<turnstile> (n,s) =slice_edges S\n                                   (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n       S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n       slice_edges S (a # as) = slice_edges S as'' \\<and>\n       n -as'' @ as'\\<rightarrow>* n'", "with \\<open>S,kind \\<turnstile> (nx,sx) =asx\\<Rightarrow>\\<^sub>\\<tau> (n',s')\\<close>\n        \\<open>slice_edges S as = slice_edges S asx'\\<close> \\<open>n'' -asx'@asx\\<rightarrow>* n'\\<close>\n        \\<open>sourcenode a = n\\<close> \\<open>valid_edge a\\<close> \\<open>targetnode a = n''\\<close> True"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (nx,sx) =asx\\<Rightarrow>\\<^sub>\\<tau> (n',s')\n  slice_edges S as = slice_edges S asx'\n  n'' -asx' @ asx\\<rightarrow>* n'\n  sourcenode a = n\n  valid_edge a\n  targetnode a = n''\n  n \\<in> backward_slice S\n  S,kind \\<turnstile> (n,s) =a # slice_edges S as\\<Rightarrow>* (nx,sx)", "show ?thesis"], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (nx,sx) =asx\\<Rightarrow>\\<^sub>\\<tau> (n',s')\n  slice_edges S as = slice_edges S asx'\n  n'' -asx' @ asx\\<rightarrow>* n'\n  sourcenode a = n\n  valid_edge a\n  targetnode a = n''\n  n \\<in> backward_slice S\n  S,kind \\<turnstile> (n,s) =a # slice_edges S as\\<Rightarrow>* (nx,sx)\n\ngoal (1 subgoal):\n 1. \\<exists>n'' s'' as' as''.\n       S,kind \\<turnstile> (n,s) =slice_edges S\n                                   (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n       S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n       slice_edges S (a # as) = slice_edges S as'' \\<and>\n       n -as'' @ as'\\<rightarrow>* n'", "apply(rule_tac x=\"nx\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,kind \\<turnstile> (nx,sx) =asx\\<Rightarrow>\\<^sub>\\<tau> (n',s');\n     slice_edges S as = slice_edges S asx';\n     n'' -asx' @ asx\\<rightarrow>* n'; sourcenode a = n; valid_edge a;\n     targetnode a = n''; n \\<in> backward_slice S;\n     S,kind \\<turnstile> (n,s) =a #\n                                slice_edges S\n                                 as\\<Rightarrow>* (nx,sx)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s'' as' as''.\n                         S,kind \\<turnstile> (n,s) =slice_edges S\n               (a # as)\\<Rightarrow>* (nx,s'') \\<and>\n                         S,kind \\<turnstile> (nx,s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n                         slice_edges S (a # as) = slice_edges S as'' \\<and>\n                         n -as'' @ as'\\<rightarrow>* n'", "apply(rule_tac x=\"sx\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,kind \\<turnstile> (nx,sx) =asx\\<Rightarrow>\\<^sub>\\<tau> (n',s');\n     slice_edges S as = slice_edges S asx';\n     n'' -asx' @ asx\\<rightarrow>* n'; sourcenode a = n; valid_edge a;\n     targetnode a = n''; n \\<in> backward_slice S;\n     S,kind \\<turnstile> (n,s) =a #\n                                slice_edges S\n                                 as\\<Rightarrow>* (nx,sx)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as' as''.\n                         S,kind \\<turnstile> (n,s) =slice_edges S\n               (a # as)\\<Rightarrow>* (nx,sx) \\<and>\n                         S,kind \\<turnstile> (nx,sx) =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n                         slice_edges S (a # as) = slice_edges S as'' \\<and>\n                         n -as'' @ as'\\<rightarrow>* n'", "apply(rule_tac x=\"asx\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,kind \\<turnstile> (nx,sx) =asx\\<Rightarrow>\\<^sub>\\<tau> (n',s');\n     slice_edges S as = slice_edges S asx';\n     n'' -asx' @ asx\\<rightarrow>* n'; sourcenode a = n; valid_edge a;\n     targetnode a = n''; n \\<in> backward_slice S;\n     S,kind \\<turnstile> (n,s) =a #\n                                slice_edges S\n                                 as\\<Rightarrow>* (nx,sx)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as''.\n                         S,kind \\<turnstile> (n,s) =slice_edges S\n               (a # as)\\<Rightarrow>* (nx,sx) \\<and>\n                         S,kind \\<turnstile> (nx,sx) =asx\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n                         slice_edges S (a # as) = slice_edges S as'' \\<and>\n                         n -as'' @ asx\\<rightarrow>* n'", "apply(rule_tac x=\"a#asx'\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S,kind \\<turnstile> (nx,sx) =asx\\<Rightarrow>\\<^sub>\\<tau> (n',s');\n     slice_edges S as = slice_edges S asx';\n     n'' -asx' @ asx\\<rightarrow>* n'; sourcenode a = n; valid_edge a;\n     targetnode a = n''; n \\<in> backward_slice S;\n     S,kind \\<turnstile> (n,s) =a #\n                                slice_edges S\n                                 as\\<Rightarrow>* (nx,sx)\\<rbrakk>\n    \\<Longrightarrow> S,kind \\<turnstile> (n,s) =slice_edges S\n            (a # as)\\<Rightarrow>* (nx,sx) \\<and>\n                      S,kind \\<turnstile> (nx,sx) =asx\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n                      slice_edges S (a # as) =\n                      slice_edges S (a # asx') \\<and>\n                      n -(a # asx') @ asx\\<rightarrow>* n'", "by(auto intro:path.Cons_path simp:slice_edges_def)"], ["proof (state)\nthis:\n  \\<exists>n'' s'' as' as''.\n     S,kind \\<turnstile> (n,s) =slice_edges S\n                                 (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n     S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n     slice_edges S (a # as) = slice_edges S as'' \\<and>\n     n -as'' @ as'\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. n \\<notin> backward_slice S \\<Longrightarrow>\n    \\<exists>n'' s'' as' as''.\n       S,kind \\<turnstile> (n,s) =slice_edges S\n                                   (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n       S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n       slice_edges S (a # as) = slice_edges S as'' \\<and>\n       n -as'' @ as'\\<rightarrow>* n'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<notin> backward_slice S \\<Longrightarrow>\n    \\<exists>n'' s'' as' as''.\n       S,kind \\<turnstile> (n,s) =slice_edges S\n                                   (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n       S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n       slice_edges S (a # as) = slice_edges S as'' \\<and>\n       n -as'' @ as'\\<rightarrow>* n'", "case False"], ["proof (state)\nthis:\n  n \\<notin> backward_slice S\n\ngoal (1 subgoal):\n 1. n \\<notin> backward_slice S \\<Longrightarrow>\n    \\<exists>n'' s'' as' as''.\n       S,kind \\<turnstile> (n,s) =slice_edges S\n                                   (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n       S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n       slice_edges S (a # as) = slice_edges S as'' \\<and>\n       n -as'' @ as'\\<rightarrow>* n'", "with \\<open>valid_edge a\\<close> \\<open>sourcenode a = n\\<close> \\<open>targetnode a = n''\\<close> \\<open>pred (kind a) s\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  sourcenode a = n\n  targetnode a = n''\n  pred (kind a) s\n  n \\<notin> backward_slice S", "have \"S,kind \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n'',transfer (kind a) s)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  sourcenode a = n\n  targetnode a = n''\n  pred (kind a) s\n  n \\<notin> backward_slice S\n\ngoal (1 subgoal):\n 1. S,kind \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n'',transfer\n                           (kind a) s)", "by(fastforce intro:silent_moveI)"], ["proof (state)\nthis:\n  S,kind \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n'',transfer\n                         (kind a) s)\n\ngoal (1 subgoal):\n 1. n \\<notin> backward_slice S \\<Longrightarrow>\n    \\<exists>n'' s'' as' as''.\n       S,kind \\<turnstile> (n,s) =slice_edges S\n                                   (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n       S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n       slice_edges S (a # as) = slice_edges S as'' \\<and>\n       n -as'' @ as'\\<rightarrow>* n'", "from \\<open>S,kind \\<turnstile> (n'',transfer (kind a) s) =slice_edges S as\\<Rightarrow>* (nx,sx)\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (n'',transfer (kind a)\n                            s) =slice_edges S as\\<Rightarrow>* (nx,sx)", "obtain f s'' asx'' where \"S,f \\<turnstile> (n'',s'') =asx''\\<Rightarrow>* (nx,sx)\"\n        and \"f = kind\" and \"s'' = transfer (kind a) s\" \n        and \"asx'' = slice_edges S as\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (n'',transfer (kind a)\n                            s) =slice_edges S as\\<Rightarrow>* (nx,sx)\n\ngoal (1 subgoal):\n 1. (\\<And>f s'' asx''.\n        \\<lbrakk>S,f \\<turnstile> (n'',s'') =asx''\\<Rightarrow>* (nx,sx);\n         f = kind; s'' = transfer (kind a) s;\n         asx'' = slice_edges S as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by simp"], ["proof (state)\nthis:\n  S,f \\<turnstile> (n'',s'') =asx''\\<Rightarrow>* (nx,sx)\n  f = kind\n  s'' = transfer (kind a) s\n  asx'' = slice_edges S as\n\ngoal (1 subgoal):\n 1. n \\<notin> backward_slice S \\<Longrightarrow>\n    \\<exists>n'' s'' as' as''.\n       S,kind \\<turnstile> (n,s) =slice_edges S\n                                   (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n       S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n       slice_edges S (a # as) = slice_edges S as'' \\<and>\n       n -as'' @ as'\\<rightarrow>* n'", "from \\<open>S,f \\<turnstile> (n'',s'') =asx''\\<Rightarrow>* (nx,sx)\\<close> \\<open>f = kind\\<close>\n        \\<open>asx'' = slice_edges S as\\<close> \\<open>s'' = transfer (kind a) s\\<close>\n        \\<open>S,kind \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n'',transfer (kind a) s)\\<close> \n        \\<open>S,kind \\<turnstile> (nx,sx) =asx\\<Rightarrow>\\<^sub>\\<tau> (n',s')\\<close> \\<open>slice_edges S as = slice_edges S asx'\\<close>\n        \\<open>n'' -asx'@asx\\<rightarrow>* n'\\<close> False"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (n'',s'') =asx''\\<Rightarrow>* (nx,sx)\n  f = kind\n  asx'' = slice_edges S as\n  s'' = transfer (kind a) s\n  S,kind \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n'',transfer\n                         (kind a) s)\n  S,kind \\<turnstile> (nx,sx) =asx\\<Rightarrow>\\<^sub>\\<tau> (n',s')\n  slice_edges S as = slice_edges S asx'\n  n'' -asx' @ asx\\<rightarrow>* n'\n  n \\<notin> backward_slice S", "show ?thesis"], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (n'',s'') =asx''\\<Rightarrow>* (nx,sx)\n  f = kind\n  asx'' = slice_edges S as\n  s'' = transfer (kind a) s\n  S,kind \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n'',transfer\n                         (kind a) s)\n  S,kind \\<turnstile> (nx,sx) =asx\\<Rightarrow>\\<^sub>\\<tau> (n',s')\n  slice_edges S as = slice_edges S asx'\n  n'' -asx' @ asx\\<rightarrow>* n'\n  n \\<notin> backward_slice S\n\ngoal (1 subgoal):\n 1. \\<exists>n'' s'' as' as''.\n       S,kind \\<turnstile> (n,s) =slice_edges S\n                                   (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n       S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n       slice_edges S (a # as) = slice_edges S as'' \\<and>\n       n -as'' @ as'\\<rightarrow>* n'", "proof(induct rule:trans_observable_moves.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>S f n s.\n       \\<lbrakk>f = kind; [] = slice_edges S as; s = transfer (kind a) s;\n        S,kind \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n,transfer\n                             (kind a) s);\n        S,kind \\<turnstile> (n,s) =asx\\<Rightarrow>\\<^sub>\\<tau> (n',s');\n        slice_edges S as = slice_edges S asx';\n        n -asx' @ asx\\<rightarrow>* n'; n \\<notin> backward_slice S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n'' s'' as' as''.\n                            S,kind \\<turnstile> (n,s) =slice_edges S\n                  (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n                            S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n                            slice_edges S (a # as) =\n                            slice_edges S as'' \\<and>\n                            n -as'' @ as'\\<rightarrow>* n'\n 2. \\<And>S f n s as n' s'a as' n'' s''.\n       \\<lbrakk>S,f \\<turnstile> (n,s) =as\\<Rightarrow> (n',s'a);\n        S,f \\<turnstile> (n',s'a) =as'\\<Rightarrow>* (n'',s'');\n        \\<lbrakk>f = kind; as' = slice_edges S as;\n         s'a = transfer (kind a) s;\n         S,kind \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n',transfer\n                               (kind a) s);\n         S,kind \\<turnstile> (n'',s'') =asx\\<Rightarrow>\\<^sub>\\<tau> (n',s');\n         slice_edges S as = slice_edges S asx';\n         n' -asx' @ asx\\<rightarrow>* n';\n         n \\<notin> backward_slice S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>n'' s'' as' as''.\n                             S,kind \\<turnstile> (n,s) =slice_edges S\n                   (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n                             S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n                             slice_edges S (a # as) =\n                             slice_edges S as'' \\<and>\n                             n -as'' @ as'\\<rightarrow>* n';\n        f = kind; last as # as' = slice_edges S as; s = transfer (kind a) s;\n        S,kind \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n,transfer\n                             (kind a) s);\n        S,kind \\<turnstile> (n'',s'') =asx\\<Rightarrow>\\<^sub>\\<tau> (n',s');\n        slice_edges S as = slice_edges S asx';\n        n -asx' @ asx\\<rightarrow>* n'; n \\<notin> backward_slice S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n'' s'' as' as''.\n                            S,kind \\<turnstile> (n,s) =slice_edges S\n                  (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n                            S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n                            slice_edges S (a # as) =\n                            slice_edges S as'' \\<and>\n                            n -as'' @ as'\\<rightarrow>* n'", "case (tom_Nil S f ni si)"], ["proof (state)\nthis:\n  f = kind\n  [] = slice_edges S as\n  si = transfer (kind a) s\n  S,kind \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (ni,transfer\n                        (kind a) s)\n  S,kind \\<turnstile> (ni,si) =asx\\<Rightarrow>\\<^sub>\\<tau> (n',s')\n  slice_edges S as = slice_edges S asx'\n  ni -asx' @ asx\\<rightarrow>* n'\n  n \\<notin> backward_slice S\n\ngoal (2 subgoals):\n 1. \\<And>S f n s.\n       \\<lbrakk>f = kind; [] = slice_edges S as; s = transfer (kind a) s;\n        S,kind \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n,transfer\n                             (kind a) s);\n        S,kind \\<turnstile> (n,s) =asx\\<Rightarrow>\\<^sub>\\<tau> (n',s');\n        slice_edges S as = slice_edges S asx';\n        n -asx' @ asx\\<rightarrow>* n'; n \\<notin> backward_slice S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n'' s'' as' as''.\n                            S,kind \\<turnstile> (n,s) =slice_edges S\n                  (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n                            S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n                            slice_edges S (a # as) =\n                            slice_edges S as'' \\<and>\n                            n -as'' @ as'\\<rightarrow>* n'\n 2. \\<And>S f n s as n' s'a as' n'' s''.\n       \\<lbrakk>S,f \\<turnstile> (n,s) =as\\<Rightarrow> (n',s'a);\n        S,f \\<turnstile> (n',s'a) =as'\\<Rightarrow>* (n'',s'');\n        \\<lbrakk>f = kind; as' = slice_edges S as;\n         s'a = transfer (kind a) s;\n         S,kind \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n',transfer\n                               (kind a) s);\n         S,kind \\<turnstile> (n'',s'') =asx\\<Rightarrow>\\<^sub>\\<tau> (n',s');\n         slice_edges S as = slice_edges S asx';\n         n' -asx' @ asx\\<rightarrow>* n';\n         n \\<notin> backward_slice S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>n'' s'' as' as''.\n                             S,kind \\<turnstile> (n,s) =slice_edges S\n                   (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n                             S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n                             slice_edges S (a # as) =\n                             slice_edges S as'' \\<and>\n                             n -as'' @ as'\\<rightarrow>* n';\n        f = kind; last as # as' = slice_edges S as; s = transfer (kind a) s;\n        S,kind \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n,transfer\n                             (kind a) s);\n        S,kind \\<turnstile> (n'',s'') =asx\\<Rightarrow>\\<^sub>\\<tau> (n',s');\n        slice_edges S as = slice_edges S asx';\n        n -asx' @ asx\\<rightarrow>* n'; n \\<notin> backward_slice S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n'' s'' as' as''.\n                            S,kind \\<turnstile> (n,s) =slice_edges S\n                  (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n                            S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n                            slice_edges S (a # as) =\n                            slice_edges S as'' \\<and>\n                            n -as'' @ as'\\<rightarrow>* n'", "have \"S,kind \\<turnstile> (n,s) =[]\\<Rightarrow>* (n,s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S,kind \\<turnstile> (n,s) =[]\\<Rightarrow>* (n,s)", "by(rule trans_observable_moves.tom_Nil)"], ["proof (state)\nthis:\n  S,kind \\<turnstile> (n,s) =[]\\<Rightarrow>* (n,s)\n\ngoal (2 subgoals):\n 1. \\<And>S f n s.\n       \\<lbrakk>f = kind; [] = slice_edges S as; s = transfer (kind a) s;\n        S,kind \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n,transfer\n                             (kind a) s);\n        S,kind \\<turnstile> (n,s) =asx\\<Rightarrow>\\<^sub>\\<tau> (n',s');\n        slice_edges S as = slice_edges S asx';\n        n -asx' @ asx\\<rightarrow>* n'; n \\<notin> backward_slice S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n'' s'' as' as''.\n                            S,kind \\<turnstile> (n,s) =slice_edges S\n                  (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n                            S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n                            slice_edges S (a # as) =\n                            slice_edges S as'' \\<and>\n                            n -as'' @ as'\\<rightarrow>* n'\n 2. \\<And>S f n s as n' s'a as' n'' s''.\n       \\<lbrakk>S,f \\<turnstile> (n,s) =as\\<Rightarrow> (n',s'a);\n        S,f \\<turnstile> (n',s'a) =as'\\<Rightarrow>* (n'',s'');\n        \\<lbrakk>f = kind; as' = slice_edges S as;\n         s'a = transfer (kind a) s;\n         S,kind \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n',transfer\n                               (kind a) s);\n         S,kind \\<turnstile> (n'',s'') =asx\\<Rightarrow>\\<^sub>\\<tau> (n',s');\n         slice_edges S as = slice_edges S asx';\n         n' -asx' @ asx\\<rightarrow>* n';\n         n \\<notin> backward_slice S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>n'' s'' as' as''.\n                             S,kind \\<turnstile> (n,s) =slice_edges S\n                   (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n                             S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n                             slice_edges S (a # as) =\n                             slice_edges S as'' \\<and>\n                             n -as'' @ as'\\<rightarrow>* n';\n        f = kind; last as # as' = slice_edges S as; s = transfer (kind a) s;\n        S,kind \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n,transfer\n                             (kind a) s);\n        S,kind \\<turnstile> (n'',s'') =asx\\<Rightarrow>\\<^sub>\\<tau> (n',s');\n        slice_edges S as = slice_edges S asx';\n        n -asx' @ asx\\<rightarrow>* n'; n \\<notin> backward_slice S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n'' s'' as' as''.\n                            S,kind \\<turnstile> (n,s) =slice_edges S\n                  (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n                            S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n                            slice_edges S (a # as) =\n                            slice_edges S as'' \\<and>\n                            n -as'' @ as'\\<rightarrow>* n'", "from \\<open>S,kind \\<turnstile> (ni,si) =asx\\<Rightarrow>\\<^sub>\\<tau> (n',s')\\<close>\n          \\<open>S,kind \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (ni,transfer (kind a) s)\\<close> \n          \\<open>si = transfer (kind a) s\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (ni,si) =asx\\<Rightarrow>\\<^sub>\\<tau> (n',s')\n  S,kind \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (ni,transfer\n                        (kind a) s)\n  si = transfer (kind a) s", "have \"S,kind \\<turnstile> (n,s) =a#asx\\<Rightarrow>\\<^sub>\\<tau> (n',s')\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (ni,si) =asx\\<Rightarrow>\\<^sub>\\<tau> (n',s')\n  S,kind \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (ni,transfer\n                        (kind a) s)\n  si = transfer (kind a) s\n\ngoal (1 subgoal):\n 1. S,kind \\<turnstile> (n,s) =a # asx\\<Rightarrow>\\<^sub>\\<tau> (n',s')", "by(fastforce intro:silent_moves_Cons)"], ["proof (state)\nthis:\n  S,kind \\<turnstile> (n,s) =a # asx\\<Rightarrow>\\<^sub>\\<tau> (n',s')\n\ngoal (2 subgoals):\n 1. \\<And>S f n s.\n       \\<lbrakk>f = kind; [] = slice_edges S as; s = transfer (kind a) s;\n        S,kind \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n,transfer\n                             (kind a) s);\n        S,kind \\<turnstile> (n,s) =asx\\<Rightarrow>\\<^sub>\\<tau> (n',s');\n        slice_edges S as = slice_edges S asx';\n        n -asx' @ asx\\<rightarrow>* n'; n \\<notin> backward_slice S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n'' s'' as' as''.\n                            S,kind \\<turnstile> (n,s) =slice_edges S\n                  (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n                            S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n                            slice_edges S (a # as) =\n                            slice_edges S as'' \\<and>\n                            n -as'' @ as'\\<rightarrow>* n'\n 2. \\<And>S f n s as n' s'a as' n'' s''.\n       \\<lbrakk>S,f \\<turnstile> (n,s) =as\\<Rightarrow> (n',s'a);\n        S,f \\<turnstile> (n',s'a) =as'\\<Rightarrow>* (n'',s'');\n        \\<lbrakk>f = kind; as' = slice_edges S as;\n         s'a = transfer (kind a) s;\n         S,kind \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n',transfer\n                               (kind a) s);\n         S,kind \\<turnstile> (n'',s'') =asx\\<Rightarrow>\\<^sub>\\<tau> (n',s');\n         slice_edges S as = slice_edges S asx';\n         n' -asx' @ asx\\<rightarrow>* n';\n         n \\<notin> backward_slice S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>n'' s'' as' as''.\n                             S,kind \\<turnstile> (n,s) =slice_edges S\n                   (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n                             S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n                             slice_edges S (a # as) =\n                             slice_edges S as'' \\<and>\n                             n -as'' @ as'\\<rightarrow>* n';\n        f = kind; last as # as' = slice_edges S as; s = transfer (kind a) s;\n        S,kind \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n,transfer\n                             (kind a) s);\n        S,kind \\<turnstile> (n'',s'') =asx\\<Rightarrow>\\<^sub>\\<tau> (n',s');\n        slice_edges S as = slice_edges S asx';\n        n -asx' @ asx\\<rightarrow>* n'; n \\<notin> backward_slice S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n'' s'' as' as''.\n                            S,kind \\<turnstile> (n,s) =slice_edges S\n                  (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n                            S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n                            slice_edges S (a # as) =\n                            slice_edges S as'' \\<and>\n                            n -as'' @ as'\\<rightarrow>* n'", "with \\<open>valid_edge a\\<close> \\<open>sourcenode a = n\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  sourcenode a = n\n  S,kind \\<turnstile> (n,s) =a # asx\\<Rightarrow>\\<^sub>\\<tau> (n',s')", "have \"n -a#asx\\<rightarrow>* n'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  sourcenode a = n\n  S,kind \\<turnstile> (n,s) =a # asx\\<Rightarrow>\\<^sub>\\<tau> (n',s')\n\ngoal (1 subgoal):\n 1. n -a # asx\\<rightarrow>* n'", "by(fastforce dest:silent_moves_preds_transfers_path)"], ["proof (state)\nthis:\n  n -a # asx\\<rightarrow>* n'\n\ngoal (2 subgoals):\n 1. \\<And>S f n s.\n       \\<lbrakk>f = kind; [] = slice_edges S as; s = transfer (kind a) s;\n        S,kind \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n,transfer\n                             (kind a) s);\n        S,kind \\<turnstile> (n,s) =asx\\<Rightarrow>\\<^sub>\\<tau> (n',s');\n        slice_edges S as = slice_edges S asx';\n        n -asx' @ asx\\<rightarrow>* n'; n \\<notin> backward_slice S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n'' s'' as' as''.\n                            S,kind \\<turnstile> (n,s) =slice_edges S\n                  (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n                            S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n                            slice_edges S (a # as) =\n                            slice_edges S as'' \\<and>\n                            n -as'' @ as'\\<rightarrow>* n'\n 2. \\<And>S f n s as n' s'a as' n'' s''.\n       \\<lbrakk>S,f \\<turnstile> (n,s) =as\\<Rightarrow> (n',s'a);\n        S,f \\<turnstile> (n',s'a) =as'\\<Rightarrow>* (n'',s'');\n        \\<lbrakk>f = kind; as' = slice_edges S as;\n         s'a = transfer (kind a) s;\n         S,kind \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n',transfer\n                               (kind a) s);\n         S,kind \\<turnstile> (n'',s'') =asx\\<Rightarrow>\\<^sub>\\<tau> (n',s');\n         slice_edges S as = slice_edges S asx';\n         n' -asx' @ asx\\<rightarrow>* n';\n         n \\<notin> backward_slice S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>n'' s'' as' as''.\n                             S,kind \\<turnstile> (n,s) =slice_edges S\n                   (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n                             S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n                             slice_edges S (a # as) =\n                             slice_edges S as'' \\<and>\n                             n -as'' @ as'\\<rightarrow>* n';\n        f = kind; last as # as' = slice_edges S as; s = transfer (kind a) s;\n        S,kind \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n,transfer\n                             (kind a) s);\n        S,kind \\<turnstile> (n'',s'') =asx\\<Rightarrow>\\<^sub>\\<tau> (n',s');\n        slice_edges S as = slice_edges S asx';\n        n -asx' @ asx\\<rightarrow>* n'; n \\<notin> backward_slice S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n'' s'' as' as''.\n                            S,kind \\<turnstile> (n,s) =slice_edges S\n                  (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n                            S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n                            slice_edges S (a # as) =\n                            slice_edges S as'' \\<and>\n                            n -as'' @ as'\\<rightarrow>* n'", "with \\<open>sourcenode a = n\\<close> \\<open>valid_edge a\\<close> \\<open>targetnode a = n''\\<close>\n          \\<open>[] = slice_edges S as\\<close> \\<open>n \\<notin> backward_slice S\\<close>\n          \\<open>S,kind \\<turnstile> (n,s) =a#asx\\<Rightarrow>\\<^sub>\\<tau> (n',s')\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a = n\n  valid_edge a\n  targetnode a = n''\n  [] = slice_edges S as\n  n \\<notin> backward_slice S\n  S,kind \\<turnstile> (n,s) =a # asx\\<Rightarrow>\\<^sub>\\<tau> (n',s')\n  n -a # asx\\<rightarrow>* n'", "show ?case"], ["proof (prove)\nusing this:\n  sourcenode a = n\n  valid_edge a\n  targetnode a = n''\n  [] = slice_edges S as\n  n \\<notin> backward_slice S\n  S,kind \\<turnstile> (n,s) =a # asx\\<Rightarrow>\\<^sub>\\<tau> (n',s')\n  n -a # asx\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. \\<exists>n'' s'' as' as''.\n       S,kind \\<turnstile> (n,s) =slice_edges S\n                                   (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n       S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n       slice_edges S (a # as) = slice_edges S as'' \\<and>\n       n -as'' @ as'\\<rightarrow>* n'", "apply(rule_tac x=\"n\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sourcenode a = n; valid_edge a; targetnode a = n'';\n     [] = slice_edges S as; n \\<notin> backward_slice S;\n     S,kind \\<turnstile> (n,s) =a # asx\\<Rightarrow>\\<^sub>\\<tau> (n',s');\n     n -a # asx\\<rightarrow>* n'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s'' as' as''.\n                         S,kind \\<turnstile> (n,s) =slice_edges S\n               (a # as)\\<Rightarrow>* (n,s'') \\<and>\n                         S,kind \\<turnstile> (n,s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n                         slice_edges S (a # as) = slice_edges S as'' \\<and>\n                         n -as'' @ as'\\<rightarrow>* n'", "apply(rule_tac x=\"s\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sourcenode a = n; valid_edge a; targetnode a = n'';\n     [] = slice_edges S as; n \\<notin> backward_slice S;\n     S,kind \\<turnstile> (n,s) =a # asx\\<Rightarrow>\\<^sub>\\<tau> (n',s');\n     n -a # asx\\<rightarrow>* n'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as' as''.\n                         S,kind \\<turnstile> (n,s) =slice_edges S\n               (a # as)\\<Rightarrow>* (n,s) \\<and>\n                         S,kind \\<turnstile> (n,s) =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n                         slice_edges S (a # as) = slice_edges S as'' \\<and>\n                         n -as'' @ as'\\<rightarrow>* n'", "apply(rule_tac x=\"a#asx\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sourcenode a = n; valid_edge a; targetnode a = n'';\n     [] = slice_edges S as; n \\<notin> backward_slice S;\n     S,kind \\<turnstile> (n,s) =a # asx\\<Rightarrow>\\<^sub>\\<tau> (n',s');\n     n -a # asx\\<rightarrow>* n'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as''.\n                         S,kind \\<turnstile> (n,s) =slice_edges S\n               (a # as)\\<Rightarrow>* (n,s) \\<and>\n                         S,kind \\<turnstile> (n,s) =a #\n              asx\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n                         slice_edges S (a # as) = slice_edges S as'' \\<and>\n                         n -as'' @ a # asx\\<rightarrow>* n'", "apply(rule_tac x=\"[]\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sourcenode a = n; valid_edge a; targetnode a = n'';\n     [] = slice_edges S as; n \\<notin> backward_slice S;\n     S,kind \\<turnstile> (n,s) =a # asx\\<Rightarrow>\\<^sub>\\<tau> (n',s');\n     n -a # asx\\<rightarrow>* n'\\<rbrakk>\n    \\<Longrightarrow> S,kind \\<turnstile> (n,s) =slice_edges S\n            (a # as)\\<Rightarrow>* (n,s) \\<and>\n                      S,kind \\<turnstile> (n,s) =a #\n           asx\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n                      slice_edges S (a # as) = slice_edges S [] \\<and>\n                      n -[] @ a # asx\\<rightarrow>* n'", "by(fastforce simp:slice_edges_def intro:trans_observable_moves.tom_Nil)"], ["proof (state)\nthis:\n  \\<exists>n'' s'' as' as''.\n     S,kind \\<turnstile> (n,s) =slice_edges S\n                                 (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n     S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n     slice_edges S (a # as) = slice_edges S as'' \\<and>\n     n -as'' @ as'\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. \\<And>S f n s as n' s'a as' n'' s''.\n       \\<lbrakk>S,f \\<turnstile> (n,s) =as\\<Rightarrow> (n',s'a);\n        S,f \\<turnstile> (n',s'a) =as'\\<Rightarrow>* (n'',s'');\n        \\<lbrakk>f = kind; as' = slice_edges S as;\n         s'a = transfer (kind a) s;\n         S,kind \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n',transfer\n                               (kind a) s);\n         S,kind \\<turnstile> (n'',s'') =asx\\<Rightarrow>\\<^sub>\\<tau> (n',s');\n         slice_edges S as = slice_edges S asx';\n         n' -asx' @ asx\\<rightarrow>* n';\n         n \\<notin> backward_slice S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>n'' s'' as' as''.\n                             S,kind \\<turnstile> (n,s) =slice_edges S\n                   (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n                             S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n                             slice_edges S (a # as) =\n                             slice_edges S as'' \\<and>\n                             n -as'' @ as'\\<rightarrow>* n';\n        f = kind; last as # as' = slice_edges S as; s = transfer (kind a) s;\n        S,kind \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n,transfer\n                             (kind a) s);\n        S,kind \\<turnstile> (n'',s'') =asx\\<Rightarrow>\\<^sub>\\<tau> (n',s');\n        slice_edges S as = slice_edges S asx';\n        n -asx' @ asx\\<rightarrow>* n'; n \\<notin> backward_slice S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n'' s'' as' as''.\n                            S,kind \\<turnstile> (n,s) =slice_edges S\n                  (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n                            S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n                            slice_edges S (a # as) =\n                            slice_edges S as'' \\<and>\n                            n -as'' @ as'\\<rightarrow>* n'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S f n s as n' s'a as' n'' s''.\n       \\<lbrakk>S,f \\<turnstile> (n,s) =as\\<Rightarrow> (n',s'a);\n        S,f \\<turnstile> (n',s'a) =as'\\<Rightarrow>* (n'',s'');\n        \\<lbrakk>f = kind; as' = slice_edges S as;\n         s'a = transfer (kind a) s;\n         S,kind \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n',transfer\n                               (kind a) s);\n         S,kind \\<turnstile> (n'',s'') =asx\\<Rightarrow>\\<^sub>\\<tau> (n',s');\n         slice_edges S as = slice_edges S asx';\n         n' -asx' @ asx\\<rightarrow>* n';\n         n \\<notin> backward_slice S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>n'' s'' as' as''.\n                             S,kind \\<turnstile> (n,s) =slice_edges S\n                   (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n                             S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n                             slice_edges S (a # as) =\n                             slice_edges S as'' \\<and>\n                             n -as'' @ as'\\<rightarrow>* n';\n        f = kind; last as # as' = slice_edges S as; s = transfer (kind a) s;\n        S,kind \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n,transfer\n                             (kind a) s);\n        S,kind \\<turnstile> (n'',s'') =asx\\<Rightarrow>\\<^sub>\\<tau> (n',s');\n        slice_edges S as = slice_edges S asx';\n        n -asx' @ asx\\<rightarrow>* n'; n \\<notin> backward_slice S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n'' s'' as' as''.\n                            S,kind \\<turnstile> (n,s) =slice_edges S\n                  (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n                            S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n                            slice_edges S (a # as) =\n                            slice_edges S as'' \\<and>\n                            n -as'' @ as'\\<rightarrow>* n'", "case (tom_Cons S f ni si asi ni' si' asi' n'' s'')"], ["proof (state)\nthis:\n  S,f \\<turnstile> (ni,si) =asi\\<Rightarrow> (ni',si')\n  S,f \\<turnstile> (ni',si') =asi'\\<Rightarrow>* (n'',s'')\n  \\<lbrakk>f = kind; asi' = slice_edges S as; si' = transfer (kind a) s;\n   S,kind \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (ni',transfer\n                          (kind a) s);\n   S,kind \\<turnstile> (n'',s'') =asx\\<Rightarrow>\\<^sub>\\<tau> (n',s');\n   slice_edges S as = slice_edges S asx'; ni' -asx' @ asx\\<rightarrow>* n';\n   n \\<notin> backward_slice S\\<rbrakk>\n  \\<Longrightarrow> \\<exists>n'' s'' as' as''.\n                       S,kind \\<turnstile> (n,s) =slice_edges S\n             (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n                       S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n                       slice_edges S (a # as) = slice_edges S as'' \\<and>\n                       n -as'' @ as'\\<rightarrow>* n'\n  f = kind\n  last asi # asi' = slice_edges S as\n  si = transfer (kind a) s\n  S,kind \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (ni,transfer\n                        (kind a) s)\n  S,kind \\<turnstile> (n'',s'') =asx\\<Rightarrow>\\<^sub>\\<tau> (n',s')\n  slice_edges S as = slice_edges S asx'\n  ni -asx' @ asx\\<rightarrow>* n'\n  n \\<notin> backward_slice S\n\ngoal (1 subgoal):\n 1. \\<And>S f n s as n' s'a as' n'' s''.\n       \\<lbrakk>S,f \\<turnstile> (n,s) =as\\<Rightarrow> (n',s'a);\n        S,f \\<turnstile> (n',s'a) =as'\\<Rightarrow>* (n'',s'');\n        \\<lbrakk>f = kind; as' = slice_edges S as;\n         s'a = transfer (kind a) s;\n         S,kind \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n',transfer\n                               (kind a) s);\n         S,kind \\<turnstile> (n'',s'') =asx\\<Rightarrow>\\<^sub>\\<tau> (n',s');\n         slice_edges S as = slice_edges S asx';\n         n' -asx' @ asx\\<rightarrow>* n';\n         n \\<notin> backward_slice S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>n'' s'' as' as''.\n                             S,kind \\<turnstile> (n,s) =slice_edges S\n                   (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n                             S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n                             slice_edges S (a # as) =\n                             slice_edges S as'' \\<and>\n                             n -as'' @ as'\\<rightarrow>* n';\n        f = kind; last as # as' = slice_edges S as; s = transfer (kind a) s;\n        S,kind \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n,transfer\n                             (kind a) s);\n        S,kind \\<turnstile> (n'',s'') =asx\\<Rightarrow>\\<^sub>\\<tau> (n',s');\n        slice_edges S as = slice_edges S asx';\n        n -asx' @ asx\\<rightarrow>* n'; n \\<notin> backward_slice S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n'' s'' as' as''.\n                            S,kind \\<turnstile> (n,s) =slice_edges S\n                  (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n                            S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n                            slice_edges S (a # as) =\n                            slice_edges S as'' \\<and>\n                            n -as'' @ as'\\<rightarrow>* n'", "from \\<open>S,f \\<turnstile> (ni,si) =asi\\<Rightarrow> (ni',si')\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (ni,si) =asi\\<Rightarrow> (ni',si')", "have \"asi \\<noteq> []\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (ni,si) =asi\\<Rightarrow> (ni',si')\n\ngoal (1 subgoal):\n 1. asi \\<noteq> []", "by(fastforce dest:observable_move_notempty)"], ["proof (state)\nthis:\n  asi \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>S f n s as n' s'a as' n'' s''.\n       \\<lbrakk>S,f \\<turnstile> (n,s) =as\\<Rightarrow> (n',s'a);\n        S,f \\<turnstile> (n',s'a) =as'\\<Rightarrow>* (n'',s'');\n        \\<lbrakk>f = kind; as' = slice_edges S as;\n         s'a = transfer (kind a) s;\n         S,kind \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n',transfer\n                               (kind a) s);\n         S,kind \\<turnstile> (n'',s'') =asx\\<Rightarrow>\\<^sub>\\<tau> (n',s');\n         slice_edges S as = slice_edges S asx';\n         n' -asx' @ asx\\<rightarrow>* n';\n         n \\<notin> backward_slice S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>n'' s'' as' as''.\n                             S,kind \\<turnstile> (n,s) =slice_edges S\n                   (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n                             S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n                             slice_edges S (a # as) =\n                             slice_edges S as'' \\<and>\n                             n -as'' @ as'\\<rightarrow>* n';\n        f = kind; last as # as' = slice_edges S as; s = transfer (kind a) s;\n        S,kind \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n,transfer\n                             (kind a) s);\n        S,kind \\<turnstile> (n'',s'') =asx\\<Rightarrow>\\<^sub>\\<tau> (n',s');\n        slice_edges S as = slice_edges S asx';\n        n -asx' @ asx\\<rightarrow>* n'; n \\<notin> backward_slice S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n'' s'' as' as''.\n                            S,kind \\<turnstile> (n,s) =slice_edges S\n                  (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n                            S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n                            slice_edges S (a # as) =\n                            slice_edges S as'' \\<and>\n                            n -as'' @ as'\\<rightarrow>* n'", "from \\<open>S,kind \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (ni,transfer (kind a) s)\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (ni,transfer\n                        (kind a) s)", "have \"valid_edge a\" and \"sourcenode a = n\" and \"targetnode a = ni\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (ni,transfer\n                        (kind a) s)\n\ngoal (1 subgoal):\n 1. valid_edge a &&& sourcenode a = n &&& targetnode a = ni", "by(auto elim:silent_move.cases)"], ["proof (state)\nthis:\n  valid_edge a\n  sourcenode a = n\n  targetnode a = ni\n\ngoal (1 subgoal):\n 1. \\<And>S f n s as n' s'a as' n'' s''.\n       \\<lbrakk>S,f \\<turnstile> (n,s) =as\\<Rightarrow> (n',s'a);\n        S,f \\<turnstile> (n',s'a) =as'\\<Rightarrow>* (n'',s'');\n        \\<lbrakk>f = kind; as' = slice_edges S as;\n         s'a = transfer (kind a) s;\n         S,kind \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n',transfer\n                               (kind a) s);\n         S,kind \\<turnstile> (n'',s'') =asx\\<Rightarrow>\\<^sub>\\<tau> (n',s');\n         slice_edges S as = slice_edges S asx';\n         n' -asx' @ asx\\<rightarrow>* n';\n         n \\<notin> backward_slice S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>n'' s'' as' as''.\n                             S,kind \\<turnstile> (n,s) =slice_edges S\n                   (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n                             S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n                             slice_edges S (a # as) =\n                             slice_edges S as'' \\<and>\n                             n -as'' @ as'\\<rightarrow>* n';\n        f = kind; last as # as' = slice_edges S as; s = transfer (kind a) s;\n        S,kind \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n,transfer\n                             (kind a) s);\n        S,kind \\<turnstile> (n'',s'') =asx\\<Rightarrow>\\<^sub>\\<tau> (n',s');\n        slice_edges S as = slice_edges S asx';\n        n -asx' @ asx\\<rightarrow>* n'; n \\<notin> backward_slice S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n'' s'' as' as''.\n                            S,kind \\<turnstile> (n,s) =slice_edges S\n                  (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n                            S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n                            slice_edges S (a # as) =\n                            slice_edges S as'' \\<and>\n                            n -as'' @ as'\\<rightarrow>* n'", "from \\<open>S,kind \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (ni,transfer (kind a) s)\\<close> \\<open>f = kind\\<close>\n          \\<open>si = transfer (kind a) s\\<close> \\<open>S,f \\<turnstile> (ni,si) =asi\\<Rightarrow> (ni',si')\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (ni,transfer\n                        (kind a) s)\n  f = kind\n  si = transfer (kind a) s\n  S,f \\<turnstile> (ni,si) =asi\\<Rightarrow> (ni',si')", "have \"S,f \\<turnstile> (n,s) =a#asi\\<Rightarrow> (ni',si')\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (ni,transfer\n                        (kind a) s)\n  f = kind\n  si = transfer (kind a) s\n  S,f \\<turnstile> (ni,si) =asi\\<Rightarrow> (ni',si')\n\ngoal (1 subgoal):\n 1. S,f \\<turnstile> (n,s) =a # asi\\<Rightarrow> (ni',si')", "by(fastforce intro:silent_move_observable_moves)"], ["proof (state)\nthis:\n  S,f \\<turnstile> (n,s) =a # asi\\<Rightarrow> (ni',si')\n\ngoal (1 subgoal):\n 1. \\<And>S f n s as n' s'a as' n'' s''.\n       \\<lbrakk>S,f \\<turnstile> (n,s) =as\\<Rightarrow> (n',s'a);\n        S,f \\<turnstile> (n',s'a) =as'\\<Rightarrow>* (n'',s'');\n        \\<lbrakk>f = kind; as' = slice_edges S as;\n         s'a = transfer (kind a) s;\n         S,kind \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n',transfer\n                               (kind a) s);\n         S,kind \\<turnstile> (n'',s'') =asx\\<Rightarrow>\\<^sub>\\<tau> (n',s');\n         slice_edges S as = slice_edges S asx';\n         n' -asx' @ asx\\<rightarrow>* n';\n         n \\<notin> backward_slice S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>n'' s'' as' as''.\n                             S,kind \\<turnstile> (n,s) =slice_edges S\n                   (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n                             S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n                             slice_edges S (a # as) =\n                             slice_edges S as'' \\<and>\n                             n -as'' @ as'\\<rightarrow>* n';\n        f = kind; last as # as' = slice_edges S as; s = transfer (kind a) s;\n        S,kind \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n,transfer\n                             (kind a) s);\n        S,kind \\<turnstile> (n'',s'') =asx\\<Rightarrow>\\<^sub>\\<tau> (n',s');\n        slice_edges S as = slice_edges S asx';\n        n -asx' @ asx\\<rightarrow>* n'; n \\<notin> backward_slice S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n'' s'' as' as''.\n                            S,kind \\<turnstile> (n,s) =slice_edges S\n                  (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n                            S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n                            slice_edges S (a # as) =\n                            slice_edges S as'' \\<and>\n                            n -as'' @ as'\\<rightarrow>* n'", "with \\<open>S,f \\<turnstile> (ni',si') =asi'\\<Rightarrow>* (n'',s'')\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (ni',si') =asi'\\<Rightarrow>* (n'',s'')\n  S,f \\<turnstile> (n,s) =a # asi\\<Rightarrow> (ni',si')", "have \"S,f \\<turnstile> (n,s) =(last (a#asi))#asi'\\<Rightarrow>* (n'',s'')\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (ni',si') =asi'\\<Rightarrow>* (n'',s'')\n  S,f \\<turnstile> (n,s) =a # asi\\<Rightarrow> (ni',si')\n\ngoal (1 subgoal):\n 1. S,f \\<turnstile> (n,s) =last (a # asi) # asi'\\<Rightarrow>* (n'',s'')", "by -(rule trans_observable_moves.tom_Cons)"], ["proof (state)\nthis:\n  S,f \\<turnstile> (n,s) =last (a # asi) # asi'\\<Rightarrow>* (n'',s'')\n\ngoal (1 subgoal):\n 1. \\<And>S f n s as n' s'a as' n'' s''.\n       \\<lbrakk>S,f \\<turnstile> (n,s) =as\\<Rightarrow> (n',s'a);\n        S,f \\<turnstile> (n',s'a) =as'\\<Rightarrow>* (n'',s'');\n        \\<lbrakk>f = kind; as' = slice_edges S as;\n         s'a = transfer (kind a) s;\n         S,kind \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n',transfer\n                               (kind a) s);\n         S,kind \\<turnstile> (n'',s'') =asx\\<Rightarrow>\\<^sub>\\<tau> (n',s');\n         slice_edges S as = slice_edges S asx';\n         n' -asx' @ asx\\<rightarrow>* n';\n         n \\<notin> backward_slice S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>n'' s'' as' as''.\n                             S,kind \\<turnstile> (n,s) =slice_edges S\n                   (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n                             S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n                             slice_edges S (a # as) =\n                             slice_edges S as'' \\<and>\n                             n -as'' @ as'\\<rightarrow>* n';\n        f = kind; last as # as' = slice_edges S as; s = transfer (kind a) s;\n        S,kind \\<turnstile> (n,s) -a\\<rightarrow>\\<^sub>\\<tau> (n,transfer\n                             (kind a) s);\n        S,kind \\<turnstile> (n'',s'') =asx\\<Rightarrow>\\<^sub>\\<tau> (n',s');\n        slice_edges S as = slice_edges S asx';\n        n -asx' @ asx\\<rightarrow>* n'; n \\<notin> backward_slice S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n'' s'' as' as''.\n                            S,kind \\<turnstile> (n,s) =slice_edges S\n                  (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n                            S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n                            slice_edges S (a # as) =\n                            slice_edges S as'' \\<and>\n                            n -as'' @ as'\\<rightarrow>* n'", "with \\<open>f = kind\\<close> \\<open>last asi # asi' = slice_edges S as\\<close> \\<open>n \\<notin> backward_slice S\\<close>\n          \\<open>S,kind \\<turnstile> (n'',s'') =asx\\<Rightarrow>\\<^sub>\\<tau> (n',s')\\<close>  \\<open>sourcenode a = n\\<close> \\<open>asi \\<noteq> []\\<close>\n          \\<open>ni -asx'@asx\\<rightarrow>* n'\\<close> \\<open>slice_edges S as = slice_edges S asx'\\<close>\n          \\<open>valid_edge a\\<close> \\<open>sourcenode a = n\\<close> \\<open>targetnode a = ni\\<close>"], ["proof (chain)\npicking this:\n  f = kind\n  last asi # asi' = slice_edges S as\n  n \\<notin> backward_slice S\n  S,kind \\<turnstile> (n'',s'') =asx\\<Rightarrow>\\<^sub>\\<tau> (n',s')\n  sourcenode a = n\n  asi \\<noteq> []\n  ni -asx' @ asx\\<rightarrow>* n'\n  slice_edges S as = slice_edges S asx'\n  valid_edge a\n  sourcenode a = n\n  targetnode a = ni\n  S,f \\<turnstile> (n,s) =last (a # asi) # asi'\\<Rightarrow>* (n'',s'')", "show ?case"], ["proof (prove)\nusing this:\n  f = kind\n  last asi # asi' = slice_edges S as\n  n \\<notin> backward_slice S\n  S,kind \\<turnstile> (n'',s'') =asx\\<Rightarrow>\\<^sub>\\<tau> (n',s')\n  sourcenode a = n\n  asi \\<noteq> []\n  ni -asx' @ asx\\<rightarrow>* n'\n  slice_edges S as = slice_edges S asx'\n  valid_edge a\n  sourcenode a = n\n  targetnode a = ni\n  S,f \\<turnstile> (n,s) =last (a # asi) # asi'\\<Rightarrow>* (n'',s'')\n\ngoal (1 subgoal):\n 1. \\<exists>n'' s'' as' as''.\n       S,kind \\<turnstile> (n,s) =slice_edges S\n                                   (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n       S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n       slice_edges S (a # as) = slice_edges S as'' \\<and>\n       n -as'' @ as'\\<rightarrow>* n'", "apply(rule_tac x=\"n''\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f = kind; last asi # asi' = slice_edges S as;\n     n \\<notin> backward_slice S;\n     S,kind \\<turnstile> (n'',s'') =asx\\<Rightarrow>\\<^sub>\\<tau> (n',s');\n     sourcenode a = n; asi \\<noteq> []; ni -asx' @ asx\\<rightarrow>* n';\n     slice_edges S as = slice_edges S asx'; valid_edge a; sourcenode a = n;\n     targetnode a = ni;\n     S,f \\<turnstile> (n,s) =last (a # asi) #\n                             asi'\\<Rightarrow>* (n'',s'')\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s'' as' as''.\n                         S,kind \\<turnstile> (n,s) =slice_edges S\n               (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n                         S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n                         slice_edges S (a # as) = slice_edges S as'' \\<and>\n                         n -as'' @ as'\\<rightarrow>* n'", "apply(rule_tac x=\"s''\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f = kind; last asi # asi' = slice_edges S as;\n     n \\<notin> backward_slice S;\n     S,kind \\<turnstile> (n'',s'') =asx\\<Rightarrow>\\<^sub>\\<tau> (n',s');\n     sourcenode a = n; asi \\<noteq> []; ni -asx' @ asx\\<rightarrow>* n';\n     slice_edges S as = slice_edges S asx'; valid_edge a; sourcenode a = n;\n     targetnode a = ni;\n     S,f \\<turnstile> (n,s) =last (a # asi) #\n                             asi'\\<Rightarrow>* (n'',s'')\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as' as''.\n                         S,kind \\<turnstile> (n,s) =slice_edges S\n               (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n                         S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n                         slice_edges S (a # as) = slice_edges S as'' \\<and>\n                         n -as'' @ as'\\<rightarrow>* n'", "apply(rule_tac x=\"asx\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f = kind; last asi # asi' = slice_edges S as;\n     n \\<notin> backward_slice S;\n     S,kind \\<turnstile> (n'',s'') =asx\\<Rightarrow>\\<^sub>\\<tau> (n',s');\n     sourcenode a = n; asi \\<noteq> []; ni -asx' @ asx\\<rightarrow>* n';\n     slice_edges S as = slice_edges S asx'; valid_edge a; sourcenode a = n;\n     targetnode a = ni;\n     S,f \\<turnstile> (n,s) =last (a # asi) #\n                             asi'\\<Rightarrow>* (n'',s'')\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as''.\n                         S,kind \\<turnstile> (n,s) =slice_edges S\n               (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n                         S,kind \\<turnstile> (n'',s'') =asx\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n                         slice_edges S (a # as) = slice_edges S as'' \\<and>\n                         n -as'' @ asx\\<rightarrow>* n'", "apply(rule_tac x=\"a#asx'\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f = kind; last asi # asi' = slice_edges S as;\n     n \\<notin> backward_slice S;\n     S,kind \\<turnstile> (n'',s'') =asx\\<Rightarrow>\\<^sub>\\<tau> (n',s');\n     sourcenode a = n; asi \\<noteq> []; ni -asx' @ asx\\<rightarrow>* n';\n     slice_edges S as = slice_edges S asx'; valid_edge a; sourcenode a = n;\n     targetnode a = ni;\n     S,f \\<turnstile> (n,s) =last (a # asi) #\n                             asi'\\<Rightarrow>* (n'',s'')\\<rbrakk>\n    \\<Longrightarrow> S,kind \\<turnstile> (n,s) =slice_edges S\n            (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n                      S,kind \\<turnstile> (n'',s'') =asx\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n                      slice_edges S (a # as) =\n                      slice_edges S (a # asx') \\<and>\n                      n -(a # asx') @ asx\\<rightarrow>* n'", "by(auto intro:path.Cons_path simp:slice_edges_def)"], ["proof (state)\nthis:\n  \\<exists>n'' s'' as' as''.\n     S,kind \\<turnstile> (n,s) =slice_edges S\n                                 (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n     S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n     slice_edges S (a # as) = slice_edges S as'' \\<and>\n     n -as'' @ as'\\<rightarrow>* n'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>n'' s'' as' as''.\n     S,kind \\<turnstile> (n,s) =slice_edges S\n                                 (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n     S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n     slice_edges S (a # as) = slice_edges S as'' \\<and>\n     n -as'' @ as'\\<rightarrow>* n'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>n'' s'' as' as''.\n     S,kind \\<turnstile> (n,s) =slice_edges S\n                                 (a # as)\\<Rightarrow>* (n'',s'') \\<and>\n     S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n     slice_edges S (a # as) = slice_edges S as'' \\<and>\n     n -as'' @ as'\\<rightarrow>* n'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>n'' s'' as' as''.\n     S,kind \\<turnstile> (n,s) =slice_edges S\n                                 as\\<Rightarrow>* (n'',s'') \\<and>\n     S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',s') \\<and>\n     slice_edges S as = slice_edges S as'' \\<and>\n     n -as'' @ as'\\<rightarrow>* n'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma WS_weak_sim_trans:\n  assumes \"((n\\<^sub>1,s\\<^sub>1),(n\\<^sub>2,s\\<^sub>2)) \\<in> WS S\"\n  and \"S,kind \\<turnstile> (n\\<^sub>1,s\\<^sub>1) =as\\<Rightarrow>* (n\\<^sub>1',s\\<^sub>1')\" and \"as \\<noteq> []\"\n  shows \"((n\\<^sub>1',s\\<^sub>1'),(n\\<^sub>1',transfers (slice_kinds S as) s\\<^sub>2)) \\<in> WS S \\<and> \n         S,slice_kind S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>* (n\\<^sub>1',transfers (slice_kinds S as) s\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((n\\<^sub>1', s\\<^sub>1'), n\\<^sub>1',\n     transfers (slice_kinds S as) s\\<^sub>2)\n    \\<in> WS S \\<and>\n    S,slice_kind\n       S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>* (n\\<^sub>1',transfers\n                                     (slice_kinds S as) s\\<^sub>2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((n\\<^sub>1', s\\<^sub>1'), n\\<^sub>1',\n     transfers (slice_kinds S as) s\\<^sub>2)\n    \\<in> WS S \\<and>\n    S,slice_kind\n       S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>* (n\\<^sub>1',transfers\n                                     (slice_kinds S as) s\\<^sub>2)", "obtain f where \"f = kind\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f. f = kind \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by simp"], ["proof (state)\nthis:\n  f = kind\n\ngoal (1 subgoal):\n 1. ((n\\<^sub>1', s\\<^sub>1'), n\\<^sub>1',\n     transfers (slice_kinds S as) s\\<^sub>2)\n    \\<in> WS S \\<and>\n    S,slice_kind\n       S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>* (n\\<^sub>1',transfers\n                                     (slice_kinds S as) s\\<^sub>2)", "with \\<open>S,kind \\<turnstile> (n\\<^sub>1,s\\<^sub>1) =as\\<Rightarrow>* (n\\<^sub>1',s\\<^sub>1')\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (n\\<^sub>1,s\\<^sub>1) =as\\<Rightarrow>* (n\\<^sub>1',s\\<^sub>1')\n  f = kind", "have \"S,f \\<turnstile> (n\\<^sub>1,s\\<^sub>1) =as\\<Rightarrow>* (n\\<^sub>1',s\\<^sub>1')\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (n\\<^sub>1,s\\<^sub>1) =as\\<Rightarrow>* (n\\<^sub>1',s\\<^sub>1')\n  f = kind\n\ngoal (1 subgoal):\n 1. S,f \\<turnstile> (n\\<^sub>1,s\\<^sub>1) =as\\<Rightarrow>* (n\\<^sub>1',s\\<^sub>1')", "by simp"], ["proof (state)\nthis:\n  S,f \\<turnstile> (n\\<^sub>1,s\\<^sub>1) =as\\<Rightarrow>* (n\\<^sub>1',s\\<^sub>1')\n\ngoal (1 subgoal):\n 1. ((n\\<^sub>1', s\\<^sub>1'), n\\<^sub>1',\n     transfers (slice_kinds S as) s\\<^sub>2)\n    \\<in> WS S \\<and>\n    S,slice_kind\n       S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>* (n\\<^sub>1',transfers\n                                     (slice_kinds S as) s\\<^sub>2)", "from \\<open>S,f \\<turnstile> (n\\<^sub>1,s\\<^sub>1) =as\\<Rightarrow>* (n\\<^sub>1',s\\<^sub>1')\\<close> \\<open>((n\\<^sub>1,s\\<^sub>1),(n\\<^sub>2,s\\<^sub>2)) \\<in> WS S\\<close> \\<open>as \\<noteq> []\\<close> \\<open>f = kind\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (n\\<^sub>1,s\\<^sub>1) =as\\<Rightarrow>* (n\\<^sub>1',s\\<^sub>1')\n  ((n\\<^sub>1, s\\<^sub>1), n\\<^sub>2, s\\<^sub>2) \\<in> WS S\n  as \\<noteq> []\n  f = kind", "show \"((n\\<^sub>1',s\\<^sub>1'),(n\\<^sub>1',transfers (slice_kinds S as) s\\<^sub>2)) \\<in> WS S \\<and>\n    S,slice_kind S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>* (n\\<^sub>1',transfers (slice_kinds S as) s\\<^sub>2)\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (n\\<^sub>1,s\\<^sub>1) =as\\<Rightarrow>* (n\\<^sub>1',s\\<^sub>1')\n  ((n\\<^sub>1, s\\<^sub>1), n\\<^sub>2, s\\<^sub>2) \\<in> WS S\n  as \\<noteq> []\n  f = kind\n\ngoal (1 subgoal):\n 1. ((n\\<^sub>1', s\\<^sub>1'), n\\<^sub>1',\n     transfers (slice_kinds S as) s\\<^sub>2)\n    \\<in> WS S \\<and>\n    S,slice_kind\n       S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>* (n\\<^sub>1',transfers\n                                     (slice_kinds S as) s\\<^sub>2)", "proof(induct arbitrary:n\\<^sub>2 s\\<^sub>2 rule:trans_observable_moves.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>S f n s n\\<^sub>2 s\\<^sub>2.\n       \\<lbrakk>((n, s), n\\<^sub>2, s\\<^sub>2) \\<in> WS S; [] \\<noteq> [];\n        f = kind\\<rbrakk>\n       \\<Longrightarrow> ((n, s), n, transfers (slice_kinds S []) s\\<^sub>2)\n                         \\<in> WS S \\<and>\n                         S,slice_kind\n                            S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =[]\\<Rightarrow>* (n,transfers\n           (slice_kinds S []) s\\<^sub>2)\n 2. \\<And>S f n s as n' s' as' n'' s'' n\\<^sub>2 s\\<^sub>2.\n       \\<lbrakk>S,f \\<turnstile> (n,s) =as\\<Rightarrow> (n',s');\n        S,f \\<turnstile> (n',s') =as'\\<Rightarrow>* (n'',s'');\n        \\<And>n\\<^sub>2 s\\<^sub>2.\n           \\<lbrakk>((n', s'), n\\<^sub>2, s\\<^sub>2) \\<in> WS S;\n            as' \\<noteq> []; f = kind\\<rbrakk>\n           \\<Longrightarrow> ((n'', s''), n'',\n                              transfers (slice_kinds S as') s\\<^sub>2)\n                             \\<in> WS S \\<and>\n                             S,slice_kind\n                                S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =as'\\<Rightarrow>* (n'',transfers\n                  (slice_kinds S as') s\\<^sub>2);\n        ((n, s), n\\<^sub>2, s\\<^sub>2) \\<in> WS S;\n        last as # as' \\<noteq> []; f = kind\\<rbrakk>\n       \\<Longrightarrow> ((n'', s''), n'',\n                          transfers (slice_kinds S (last as # as'))\n                           s\\<^sub>2)\n                         \\<in> WS S \\<and>\n                         S,slice_kind\n                            S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =last as #\n                            as'\\<Rightarrow>* (n'',transfers\n              (slice_kinds S (last as # as')) s\\<^sub>2)", "case tom_Nil"], ["proof (state)\nthis:\n  ((n_, s_), n\\<^sub>2, s\\<^sub>2) \\<in> WS S_\n  [] \\<noteq> []\n  f_ = kind\n\ngoal (2 subgoals):\n 1. \\<And>S f n s n\\<^sub>2 s\\<^sub>2.\n       \\<lbrakk>((n, s), n\\<^sub>2, s\\<^sub>2) \\<in> WS S; [] \\<noteq> [];\n        f = kind\\<rbrakk>\n       \\<Longrightarrow> ((n, s), n, transfers (slice_kinds S []) s\\<^sub>2)\n                         \\<in> WS S \\<and>\n                         S,slice_kind\n                            S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =[]\\<Rightarrow>* (n,transfers\n           (slice_kinds S []) s\\<^sub>2)\n 2. \\<And>S f n s as n' s' as' n'' s'' n\\<^sub>2 s\\<^sub>2.\n       \\<lbrakk>S,f \\<turnstile> (n,s) =as\\<Rightarrow> (n',s');\n        S,f \\<turnstile> (n',s') =as'\\<Rightarrow>* (n'',s'');\n        \\<And>n\\<^sub>2 s\\<^sub>2.\n           \\<lbrakk>((n', s'), n\\<^sub>2, s\\<^sub>2) \\<in> WS S;\n            as' \\<noteq> []; f = kind\\<rbrakk>\n           \\<Longrightarrow> ((n'', s''), n'',\n                              transfers (slice_kinds S as') s\\<^sub>2)\n                             \\<in> WS S \\<and>\n                             S,slice_kind\n                                S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =as'\\<Rightarrow>* (n'',transfers\n                  (slice_kinds S as') s\\<^sub>2);\n        ((n, s), n\\<^sub>2, s\\<^sub>2) \\<in> WS S;\n        last as # as' \\<noteq> []; f = kind\\<rbrakk>\n       \\<Longrightarrow> ((n'', s''), n'',\n                          transfers (slice_kinds S (last as # as'))\n                           s\\<^sub>2)\n                         \\<in> WS S \\<and>\n                         S,slice_kind\n                            S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =last as #\n                            as'\\<Rightarrow>* (n'',transfers\n              (slice_kinds S (last as # as')) s\\<^sub>2)", "thus ?case"], ["proof (prove)\nusing this:\n  ((n_, s_), n\\<^sub>2, s\\<^sub>2) \\<in> WS S_\n  [] \\<noteq> []\n  f_ = kind\n\ngoal (1 subgoal):\n 1. ((n_, s_), n_, transfers (slice_kinds S_ []) s\\<^sub>2)\n    \\<in> WS S_ \\<and>\n    S_,slice_kind\n        S_ \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =[]\\<Rightarrow>* (n_,transfers\n                               (slice_kinds S_ []) s\\<^sub>2)", "by simp"], ["proof (state)\nthis:\n  ((n_, s_), n_, transfers (slice_kinds S_ []) s\\<^sub>2) \\<in> WS S_ \\<and>\n  S_,slice_kind\n      S_ \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =[]\\<Rightarrow>* (n_,transfers\n                             (slice_kinds S_ []) s\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<And>S f n s as n' s' as' n'' s'' n\\<^sub>2 s\\<^sub>2.\n       \\<lbrakk>S,f \\<turnstile> (n,s) =as\\<Rightarrow> (n',s');\n        S,f \\<turnstile> (n',s') =as'\\<Rightarrow>* (n'',s'');\n        \\<And>n\\<^sub>2 s\\<^sub>2.\n           \\<lbrakk>((n', s'), n\\<^sub>2, s\\<^sub>2) \\<in> WS S;\n            as' \\<noteq> []; f = kind\\<rbrakk>\n           \\<Longrightarrow> ((n'', s''), n'',\n                              transfers (slice_kinds S as') s\\<^sub>2)\n                             \\<in> WS S \\<and>\n                             S,slice_kind\n                                S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =as'\\<Rightarrow>* (n'',transfers\n                  (slice_kinds S as') s\\<^sub>2);\n        ((n, s), n\\<^sub>2, s\\<^sub>2) \\<in> WS S;\n        last as # as' \\<noteq> []; f = kind\\<rbrakk>\n       \\<Longrightarrow> ((n'', s''), n'',\n                          transfers (slice_kinds S (last as # as'))\n                           s\\<^sub>2)\n                         \\<in> WS S \\<and>\n                         S,slice_kind\n                            S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =last as #\n                            as'\\<Rightarrow>* (n'',transfers\n              (slice_kinds S (last as # as')) s\\<^sub>2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S f n s as n' s' as' n'' s'' n\\<^sub>2 s\\<^sub>2.\n       \\<lbrakk>S,f \\<turnstile> (n,s) =as\\<Rightarrow> (n',s');\n        S,f \\<turnstile> (n',s') =as'\\<Rightarrow>* (n'',s'');\n        \\<And>n\\<^sub>2 s\\<^sub>2.\n           \\<lbrakk>((n', s'), n\\<^sub>2, s\\<^sub>2) \\<in> WS S;\n            as' \\<noteq> []; f = kind\\<rbrakk>\n           \\<Longrightarrow> ((n'', s''), n'',\n                              transfers (slice_kinds S as') s\\<^sub>2)\n                             \\<in> WS S \\<and>\n                             S,slice_kind\n                                S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =as'\\<Rightarrow>* (n'',transfers\n                  (slice_kinds S as') s\\<^sub>2);\n        ((n, s), n\\<^sub>2, s\\<^sub>2) \\<in> WS S;\n        last as # as' \\<noteq> []; f = kind\\<rbrakk>\n       \\<Longrightarrow> ((n'', s''), n'',\n                          transfers (slice_kinds S (last as # as'))\n                           s\\<^sub>2)\n                         \\<in> WS S \\<and>\n                         S,slice_kind\n                            S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =last as #\n                            as'\\<Rightarrow>* (n'',transfers\n              (slice_kinds S (last as # as')) s\\<^sub>2)", "case (tom_Cons S f n s as n' s' as' n'' s'')"], ["proof (state)\nthis:\n  S,f \\<turnstile> (n,s) =as\\<Rightarrow> (n',s')\n  S,f \\<turnstile> (n',s') =as'\\<Rightarrow>* (n'',s'')\n  \\<lbrakk>((n', s'), ?n\\<^sub>2, ?s\\<^sub>2) \\<in> WS S; as' \\<noteq> [];\n   f = kind\\<rbrakk>\n  \\<Longrightarrow> ((n'', s''), n'',\n                     transfers (slice_kinds S as') ?s\\<^sub>2)\n                    \\<in> WS S \\<and>\n                    S,slice_kind\n                       S \\<turnstile> (?n\\<^sub>2,?s\\<^sub>2) =as'\\<Rightarrow>* (n'',transfers\n           (slice_kinds S as') ?s\\<^sub>2)\n  ((n, s), n\\<^sub>2, s\\<^sub>2) \\<in> WS S\n  last as # as' \\<noteq> []\n  f = kind\n\ngoal (1 subgoal):\n 1. \\<And>S f n s as n' s' as' n'' s'' n\\<^sub>2 s\\<^sub>2.\n       \\<lbrakk>S,f \\<turnstile> (n,s) =as\\<Rightarrow> (n',s');\n        S,f \\<turnstile> (n',s') =as'\\<Rightarrow>* (n'',s'');\n        \\<And>n\\<^sub>2 s\\<^sub>2.\n           \\<lbrakk>((n', s'), n\\<^sub>2, s\\<^sub>2) \\<in> WS S;\n            as' \\<noteq> []; f = kind\\<rbrakk>\n           \\<Longrightarrow> ((n'', s''), n'',\n                              transfers (slice_kinds S as') s\\<^sub>2)\n                             \\<in> WS S \\<and>\n                             S,slice_kind\n                                S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =as'\\<Rightarrow>* (n'',transfers\n                  (slice_kinds S as') s\\<^sub>2);\n        ((n, s), n\\<^sub>2, s\\<^sub>2) \\<in> WS S;\n        last as # as' \\<noteq> []; f = kind\\<rbrakk>\n       \\<Longrightarrow> ((n'', s''), n'',\n                          transfers (slice_kinds S (last as # as'))\n                           s\\<^sub>2)\n                         \\<in> WS S \\<and>\n                         S,slice_kind\n                            S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =last as #\n                            as'\\<Rightarrow>* (n'',transfers\n              (slice_kinds S (last as # as')) s\\<^sub>2)", "note IH = \\<open>\\<And>n\\<^sub>2 s\\<^sub>2. \\<lbrakk>((n',s'),(n\\<^sub>2,s\\<^sub>2)) \\<in> WS S; as' \\<noteq> []; f = kind\\<rbrakk>\n      \\<Longrightarrow> ((n'',s''),(n'',transfers (slice_kinds S as') s\\<^sub>2)) \\<in> WS S \\<and>\n      S,slice_kind S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =as'\\<Rightarrow>* (n'',transfers (slice_kinds S as') s\\<^sub>2)\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>((n', s'), ?n\\<^sub>2, ?s\\<^sub>2) \\<in> WS S; as' \\<noteq> [];\n   f = kind\\<rbrakk>\n  \\<Longrightarrow> ((n'', s''), n'',\n                     transfers (slice_kinds S as') ?s\\<^sub>2)\n                    \\<in> WS S \\<and>\n                    S,slice_kind\n                       S \\<turnstile> (?n\\<^sub>2,?s\\<^sub>2) =as'\\<Rightarrow>* (n'',transfers\n           (slice_kinds S as') ?s\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<And>S f n s as n' s' as' n'' s'' n\\<^sub>2 s\\<^sub>2.\n       \\<lbrakk>S,f \\<turnstile> (n,s) =as\\<Rightarrow> (n',s');\n        S,f \\<turnstile> (n',s') =as'\\<Rightarrow>* (n'',s'');\n        \\<And>n\\<^sub>2 s\\<^sub>2.\n           \\<lbrakk>((n', s'), n\\<^sub>2, s\\<^sub>2) \\<in> WS S;\n            as' \\<noteq> []; f = kind\\<rbrakk>\n           \\<Longrightarrow> ((n'', s''), n'',\n                              transfers (slice_kinds S as') s\\<^sub>2)\n                             \\<in> WS S \\<and>\n                             S,slice_kind\n                                S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =as'\\<Rightarrow>* (n'',transfers\n                  (slice_kinds S as') s\\<^sub>2);\n        ((n, s), n\\<^sub>2, s\\<^sub>2) \\<in> WS S;\n        last as # as' \\<noteq> []; f = kind\\<rbrakk>\n       \\<Longrightarrow> ((n'', s''), n'',\n                          transfers (slice_kinds S (last as # as'))\n                           s\\<^sub>2)\n                         \\<in> WS S \\<and>\n                         S,slice_kind\n                            S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =last as #\n                            as'\\<Rightarrow>* (n'',transfers\n              (slice_kinds S (last as # as')) s\\<^sub>2)", "from \\<open>S,f \\<turnstile> (n,s) =as\\<Rightarrow> (n',s')\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (n,s) =as\\<Rightarrow> (n',s')", "obtain asx ax nx sx where \"S,f \\<turnstile> (n,s) =asx\\<Rightarrow>\\<^sub>\\<tau> (nx,sx)\"\n      and \"S,f \\<turnstile> (nx,sx) -ax\\<rightarrow> (n',s')\" and \"as = asx@[ax]\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (n,s) =as\\<Rightarrow> (n',s')\n\ngoal (1 subgoal):\n 1. (\\<And>asx nx sx ax.\n        \\<lbrakk>S,f \\<turnstile> (n,s) =asx\\<Rightarrow>\\<^sub>\\<tau> (nx,sx);\n         S,f \\<turnstile> (nx,sx) -ax\\<rightarrow> (n',s');\n         as = asx @ [ax]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:observable_moves.cases)"], ["proof (state)\nthis:\n  S,f \\<turnstile> (n,s) =asx\\<Rightarrow>\\<^sub>\\<tau> (nx,sx)\n  S,f \\<turnstile> (nx,sx) -ax\\<rightarrow> (n',s')\n  as = asx @ [ax]\n\ngoal (1 subgoal):\n 1. \\<And>S f n s as n' s' as' n'' s'' n\\<^sub>2 s\\<^sub>2.\n       \\<lbrakk>S,f \\<turnstile> (n,s) =as\\<Rightarrow> (n',s');\n        S,f \\<turnstile> (n',s') =as'\\<Rightarrow>* (n'',s'');\n        \\<And>n\\<^sub>2 s\\<^sub>2.\n           \\<lbrakk>((n', s'), n\\<^sub>2, s\\<^sub>2) \\<in> WS S;\n            as' \\<noteq> []; f = kind\\<rbrakk>\n           \\<Longrightarrow> ((n'', s''), n'',\n                              transfers (slice_kinds S as') s\\<^sub>2)\n                             \\<in> WS S \\<and>\n                             S,slice_kind\n                                S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =as'\\<Rightarrow>* (n'',transfers\n                  (slice_kinds S as') s\\<^sub>2);\n        ((n, s), n\\<^sub>2, s\\<^sub>2) \\<in> WS S;\n        last as # as' \\<noteq> []; f = kind\\<rbrakk>\n       \\<Longrightarrow> ((n'', s''), n'',\n                          transfers (slice_kinds S (last as # as'))\n                           s\\<^sub>2)\n                         \\<in> WS S \\<and>\n                         S,slice_kind\n                            S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =last as #\n                            as'\\<Rightarrow>* (n'',transfers\n              (slice_kinds S (last as # as')) s\\<^sub>2)", "from \\<open>S,f \\<turnstile> (nx,sx) -ax\\<rightarrow> (n',s')\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (nx,sx) -ax\\<rightarrow> (n',s')", "have \"obs nx (backward_slice S) = {nx}\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (nx,sx) -ax\\<rightarrow> (n',s')\n\ngoal (1 subgoal):\n 1. obs nx (backward_slice S) = {nx}", "by(fastforce intro!:n_in_obs elim:observable_move.cases)"], ["proof (state)\nthis:\n  obs nx (backward_slice S) = {nx}\n\ngoal (1 subgoal):\n 1. \\<And>S f n s as n' s' as' n'' s'' n\\<^sub>2 s\\<^sub>2.\n       \\<lbrakk>S,f \\<turnstile> (n,s) =as\\<Rightarrow> (n',s');\n        S,f \\<turnstile> (n',s') =as'\\<Rightarrow>* (n'',s'');\n        \\<And>n\\<^sub>2 s\\<^sub>2.\n           \\<lbrakk>((n', s'), n\\<^sub>2, s\\<^sub>2) \\<in> WS S;\n            as' \\<noteq> []; f = kind\\<rbrakk>\n           \\<Longrightarrow> ((n'', s''), n'',\n                              transfers (slice_kinds S as') s\\<^sub>2)\n                             \\<in> WS S \\<and>\n                             S,slice_kind\n                                S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =as'\\<Rightarrow>* (n'',transfers\n                  (slice_kinds S as') s\\<^sub>2);\n        ((n, s), n\\<^sub>2, s\\<^sub>2) \\<in> WS S;\n        last as # as' \\<noteq> []; f = kind\\<rbrakk>\n       \\<Longrightarrow> ((n'', s''), n'',\n                          transfers (slice_kinds S (last as # as'))\n                           s\\<^sub>2)\n                         \\<in> WS S \\<and>\n                         S,slice_kind\n                            S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =last as #\n                            as'\\<Rightarrow>* (n'',transfers\n              (slice_kinds S (last as # as')) s\\<^sub>2)", "with \\<open>S,f \\<turnstile> (n,s) =asx\\<Rightarrow>\\<^sub>\\<tau> (nx,sx)\\<close> \\<open>((n,s),(n\\<^sub>2,s\\<^sub>2)) \\<in> WS S\\<close> \\<open>f = kind\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (n,s) =asx\\<Rightarrow>\\<^sub>\\<tau> (nx,sx)\n  ((n, s), n\\<^sub>2, s\\<^sub>2) \\<in> WS S\n  f = kind\n  obs nx (backward_slice S) = {nx}", "have \"((nx,sx),(n\\<^sub>2,s\\<^sub>2)) \\<in> WS S\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (n,s) =asx\\<Rightarrow>\\<^sub>\\<tau> (nx,sx)\n  ((n, s), n\\<^sub>2, s\\<^sub>2) \\<in> WS S\n  f = kind\n  obs nx (backward_slice S) = {nx}\n\ngoal (1 subgoal):\n 1. ((nx, sx), n\\<^sub>2, s\\<^sub>2) \\<in> WS S", "by(fastforce intro:WS_silent_moves)"], ["proof (state)\nthis:\n  ((nx, sx), n\\<^sub>2, s\\<^sub>2) \\<in> WS S\n\ngoal (1 subgoal):\n 1. \\<And>S f n s as n' s' as' n'' s'' n\\<^sub>2 s\\<^sub>2.\n       \\<lbrakk>S,f \\<turnstile> (n,s) =as\\<Rightarrow> (n',s');\n        S,f \\<turnstile> (n',s') =as'\\<Rightarrow>* (n'',s'');\n        \\<And>n\\<^sub>2 s\\<^sub>2.\n           \\<lbrakk>((n', s'), n\\<^sub>2, s\\<^sub>2) \\<in> WS S;\n            as' \\<noteq> []; f = kind\\<rbrakk>\n           \\<Longrightarrow> ((n'', s''), n'',\n                              transfers (slice_kinds S as') s\\<^sub>2)\n                             \\<in> WS S \\<and>\n                             S,slice_kind\n                                S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =as'\\<Rightarrow>* (n'',transfers\n                  (slice_kinds S as') s\\<^sub>2);\n        ((n, s), n\\<^sub>2, s\\<^sub>2) \\<in> WS S;\n        last as # as' \\<noteq> []; f = kind\\<rbrakk>\n       \\<Longrightarrow> ((n'', s''), n'',\n                          transfers (slice_kinds S (last as # as'))\n                           s\\<^sub>2)\n                         \\<in> WS S \\<and>\n                         S,slice_kind\n                            S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =last as #\n                            as'\\<Rightarrow>* (n'',transfers\n              (slice_kinds S (last as # as')) s\\<^sub>2)", "with \\<open>S,f \\<turnstile> (nx,sx) -ax\\<rightarrow> (n',s')\\<close> \\<open>f = kind\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (nx,sx) -ax\\<rightarrow> (n',s')\n  f = kind\n  ((nx, sx), n\\<^sub>2, s\\<^sub>2) \\<in> WS S", "obtain asx' where \"((n',s'),(n',transfer (slice_kind S ax) s\\<^sub>2)) \\<in> WS S\"\n      and \"S,slice_kind S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =asx'@[ax]\\<Rightarrow> \n      (n',transfer (slice_kind S ax) s\\<^sub>2)\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (nx,sx) -ax\\<rightarrow> (n',s')\n  f = kind\n  ((nx, sx), n\\<^sub>2, s\\<^sub>2) \\<in> WS S\n\ngoal (1 subgoal):\n 1. (\\<And>asx'.\n        \\<lbrakk>((n', s'), n', transfer (slice_kind S ax) s\\<^sub>2)\n                 \\<in> WS S;\n         S,slice_kind\n            S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =asx' @\n            [ax]\\<Rightarrow> (n',transfer (slice_kind S ax)\n                                   s\\<^sub>2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:WS_observable_move)"], ["proof (state)\nthis:\n  ((n', s'), n', transfer (slice_kind S ax) s\\<^sub>2) \\<in> WS S\n  S,slice_kind\n     S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =asx' @\n     [ax]\\<Rightarrow> (n',transfer (slice_kind S ax) s\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<And>S f n s as n' s' as' n'' s'' n\\<^sub>2 s\\<^sub>2.\n       \\<lbrakk>S,f \\<turnstile> (n,s) =as\\<Rightarrow> (n',s');\n        S,f \\<turnstile> (n',s') =as'\\<Rightarrow>* (n'',s'');\n        \\<And>n\\<^sub>2 s\\<^sub>2.\n           \\<lbrakk>((n', s'), n\\<^sub>2, s\\<^sub>2) \\<in> WS S;\n            as' \\<noteq> []; f = kind\\<rbrakk>\n           \\<Longrightarrow> ((n'', s''), n'',\n                              transfers (slice_kinds S as') s\\<^sub>2)\n                             \\<in> WS S \\<and>\n                             S,slice_kind\n                                S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =as'\\<Rightarrow>* (n'',transfers\n                  (slice_kinds S as') s\\<^sub>2);\n        ((n, s), n\\<^sub>2, s\\<^sub>2) \\<in> WS S;\n        last as # as' \\<noteq> []; f = kind\\<rbrakk>\n       \\<Longrightarrow> ((n'', s''), n'',\n                          transfers (slice_kinds S (last as # as'))\n                           s\\<^sub>2)\n                         \\<in> WS S \\<and>\n                         S,slice_kind\n                            S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =last as #\n                            as'\\<Rightarrow>* (n'',transfers\n              (slice_kinds S (last as # as')) s\\<^sub>2)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((n'', s''), n'', transfers (slice_kinds S (last as # as')) s\\<^sub>2)\n    \\<in> WS S \\<and>\n    S,slice_kind\n       S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =last as #\n       as'\\<Rightarrow>* (n'',transfers (slice_kinds S (last as # as'))\n                               s\\<^sub>2)", "proof(cases \"as' = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    ((n'', s''), n'', transfers (slice_kinds S (last as # as')) s\\<^sub>2)\n    \\<in> WS S \\<and>\n    S,slice_kind\n       S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =last as #\n       as'\\<Rightarrow>* (n'',transfers (slice_kinds S (last as # as'))\n                               s\\<^sub>2)\n 2. as' \\<noteq> [] \\<Longrightarrow>\n    ((n'', s''), n'', transfers (slice_kinds S (last as # as')) s\\<^sub>2)\n    \\<in> WS S \\<and>\n    S,slice_kind\n       S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =last as #\n       as'\\<Rightarrow>* (n'',transfers (slice_kinds S (last as # as'))\n                               s\\<^sub>2)", "case True"], ["proof (state)\nthis:\n  as' = []\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    ((n'', s''), n'', transfers (slice_kinds S (last as # as')) s\\<^sub>2)\n    \\<in> WS S \\<and>\n    S,slice_kind\n       S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =last as #\n       as'\\<Rightarrow>* (n'',transfers (slice_kinds S (last as # as'))\n                               s\\<^sub>2)\n 2. as' \\<noteq> [] \\<Longrightarrow>\n    ((n'', s''), n'', transfers (slice_kinds S (last as # as')) s\\<^sub>2)\n    \\<in> WS S \\<and>\n    S,slice_kind\n       S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =last as #\n       as'\\<Rightarrow>* (n'',transfers (slice_kinds S (last as # as'))\n                               s\\<^sub>2)", "with \\<open>S,f \\<turnstile> (n',s') =as'\\<Rightarrow>* (n'',s'')\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (n',s') =as'\\<Rightarrow>* (n'',s'')\n  as' = []", "have \"n' = n'' \\<and> s' = s''\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (n',s') =as'\\<Rightarrow>* (n'',s'')\n  as' = []\n\ngoal (1 subgoal):\n 1. n' = n'' \\<and> s' = s''", "by(fastforce elim:trans_observable_moves.cases dest:observable_move_notempty)"], ["proof (state)\nthis:\n  n' = n'' \\<and> s' = s''\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    ((n'', s''), n'', transfers (slice_kinds S (last as # as')) s\\<^sub>2)\n    \\<in> WS S \\<and>\n    S,slice_kind\n       S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =last as #\n       as'\\<Rightarrow>* (n'',transfers (slice_kinds S (last as # as'))\n                               s\\<^sub>2)\n 2. as' \\<noteq> [] \\<Longrightarrow>\n    ((n'', s''), n'', transfers (slice_kinds S (last as # as')) s\\<^sub>2)\n    \\<in> WS S \\<and>\n    S,slice_kind\n       S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =last as #\n       as'\\<Rightarrow>* (n'',transfers (slice_kinds S (last as # as'))\n                               s\\<^sub>2)", "from \\<open>S,slice_kind S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =asx'@[ax]\\<Rightarrow> \n                               (n',transfer (slice_kind S ax) s\\<^sub>2)\\<close>"], ["proof (chain)\npicking this:\n  S,slice_kind\n     S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =asx' @\n     [ax]\\<Rightarrow> (n',transfer (slice_kind S ax) s\\<^sub>2)", "have \"S,slice_kind S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =(last (asx'@[ax]))#[]\\<Rightarrow>* \n                               (n',transfer (slice_kind S ax) s\\<^sub>2)\""], ["proof (prove)\nusing this:\n  S,slice_kind\n     S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =asx' @\n     [ax]\\<Rightarrow> (n',transfer (slice_kind S ax) s\\<^sub>2)\n\ngoal (1 subgoal):\n 1. S,slice_kind\n       S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =[last\n         (asx' @\n          [ax])]\\<Rightarrow>* (n',transfer (slice_kind S ax) s\\<^sub>2)", "by(fastforce intro:trans_observable_moves.intros)"], ["proof (state)\nthis:\n  S,slice_kind\n     S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =[last\n       (asx' @\n        [ax])]\\<Rightarrow>* (n',transfer (slice_kind S ax) s\\<^sub>2)\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    ((n'', s''), n'', transfers (slice_kinds S (last as # as')) s\\<^sub>2)\n    \\<in> WS S \\<and>\n    S,slice_kind\n       S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =last as #\n       as'\\<Rightarrow>* (n'',transfers (slice_kinds S (last as # as'))\n                               s\\<^sub>2)\n 2. as' \\<noteq> [] \\<Longrightarrow>\n    ((n'', s''), n'', transfers (slice_kinds S (last as # as')) s\\<^sub>2)\n    \\<in> WS S \\<and>\n    S,slice_kind\n       S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =last as #\n       as'\\<Rightarrow>* (n'',transfers (slice_kinds S (last as # as'))\n                               s\\<^sub>2)", "with \\<open>((n',s'),(n',transfer (slice_kind S ax) s\\<^sub>2)) \\<in> WS S\\<close> \\<open>as = asx@[ax]\\<close>\n        \\<open>n' = n'' \\<and> s' = s''\\<close> True"], ["proof (chain)\npicking this:\n  ((n', s'), n', transfer (slice_kind S ax) s\\<^sub>2) \\<in> WS S\n  as = asx @ [ax]\n  n' = n'' \\<and> s' = s''\n  as' = []\n  S,slice_kind\n     S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =[last\n       (asx' @\n        [ax])]\\<Rightarrow>* (n',transfer (slice_kind S ax) s\\<^sub>2)", "show ?thesis"], ["proof (prove)\nusing this:\n  ((n', s'), n', transfer (slice_kind S ax) s\\<^sub>2) \\<in> WS S\n  as = asx @ [ax]\n  n' = n'' \\<and> s' = s''\n  as' = []\n  S,slice_kind\n     S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =[last\n       (asx' @\n        [ax])]\\<Rightarrow>* (n',transfer (slice_kind S ax) s\\<^sub>2)\n\ngoal (1 subgoal):\n 1. ((n'', s''), n'', transfers (slice_kinds S (last as # as')) s\\<^sub>2)\n    \\<in> WS S \\<and>\n    S,slice_kind\n       S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =last as #\n       as'\\<Rightarrow>* (n'',transfers (slice_kinds S (last as # as'))\n                               s\\<^sub>2)", "by(fastforce simp:slice_kinds_def)"], ["proof (state)\nthis:\n  ((n'', s''), n'', transfers (slice_kinds S (last as # as')) s\\<^sub>2)\n  \\<in> WS S \\<and>\n  S,slice_kind\n     S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =last as #\n     as'\\<Rightarrow>* (n'',transfers (slice_kinds S (last as # as'))\n                             s\\<^sub>2)\n\ngoal (1 subgoal):\n 1. as' \\<noteq> [] \\<Longrightarrow>\n    ((n'', s''), n'', transfers (slice_kinds S (last as # as')) s\\<^sub>2)\n    \\<in> WS S \\<and>\n    S,slice_kind\n       S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =last as #\n       as'\\<Rightarrow>* (n'',transfers (slice_kinds S (last as # as'))\n                               s\\<^sub>2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. as' \\<noteq> [] \\<Longrightarrow>\n    ((n'', s''), n'', transfers (slice_kinds S (last as # as')) s\\<^sub>2)\n    \\<in> WS S \\<and>\n    S,slice_kind\n       S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =last as #\n       as'\\<Rightarrow>* (n'',transfers (slice_kinds S (last as # as'))\n                               s\\<^sub>2)", "case False"], ["proof (state)\nthis:\n  as' \\<noteq> []\n\ngoal (1 subgoal):\n 1. as' \\<noteq> [] \\<Longrightarrow>\n    ((n'', s''), n'', transfers (slice_kinds S (last as # as')) s\\<^sub>2)\n    \\<in> WS S \\<and>\n    S,slice_kind\n       S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =last as #\n       as'\\<Rightarrow>* (n'',transfers (slice_kinds S (last as # as'))\n                               s\\<^sub>2)", "from IH[OF \\<open>((n',s'),(n',transfer (slice_kind S ax) s\\<^sub>2)) \\<in> WS S\\<close> this \n        \\<open>f = kind\\<close>]"], ["proof (chain)\npicking this:\n  ((n'', s''), n'',\n   transfers (slice_kinds S as') (transfer (slice_kind S ax) s\\<^sub>2))\n  \\<in> WS S \\<and>\n  S,slice_kind\n     S \\<turnstile> (n',transfer (slice_kind S ax)\n                         s\\<^sub>2) =as'\\<Rightarrow>* (n'',transfers\n                       (slice_kinds S as')\n                       (transfer (slice_kind S ax) s\\<^sub>2))", "have \"((n'',s''),(n'',transfers (slice_kinds S as') \n        (transfer (slice_kind S ax) s\\<^sub>2))) \\<in> WS S\"\n        and \"S,slice_kind S \\<turnstile> (n',transfer (slice_kind S ax) s\\<^sub>2) \n        =as'\\<Rightarrow>* (n'',transfers (slice_kinds S as')\n                     (transfer (slice_kind S ax) s\\<^sub>2))\""], ["proof (prove)\nusing this:\n  ((n'', s''), n'',\n   transfers (slice_kinds S as') (transfer (slice_kind S ax) s\\<^sub>2))\n  \\<in> WS S \\<and>\n  S,slice_kind\n     S \\<turnstile> (n',transfer (slice_kind S ax)\n                         s\\<^sub>2) =as'\\<Rightarrow>* (n'',transfers\n                       (slice_kinds S as')\n                       (transfer (slice_kind S ax) s\\<^sub>2))\n\ngoal (1 subgoal):\n 1. ((n'', s''), n'',\n     transfers (slice_kinds S as') (transfer (slice_kind S ax) s\\<^sub>2))\n    \\<in> WS S &&&\n    S,slice_kind\n       S \\<turnstile> (n',transfer (slice_kind S ax)\n                           s\\<^sub>2) =as'\\<Rightarrow>* (n'',transfers\n                         (slice_kinds S as')\n                         (transfer (slice_kind S ax) s\\<^sub>2))", "by simp_all"], ["proof (state)\nthis:\n  ((n'', s''), n'',\n   transfers (slice_kinds S as') (transfer (slice_kind S ax) s\\<^sub>2))\n  \\<in> WS S\n  S,slice_kind\n     S \\<turnstile> (n',transfer (slice_kind S ax)\n                         s\\<^sub>2) =as'\\<Rightarrow>* (n'',transfers\n                       (slice_kinds S as')\n                       (transfer (slice_kind S ax) s\\<^sub>2))\n\ngoal (1 subgoal):\n 1. as' \\<noteq> [] \\<Longrightarrow>\n    ((n'', s''), n'', transfers (slice_kinds S (last as # as')) s\\<^sub>2)\n    \\<in> WS S \\<and>\n    S,slice_kind\n       S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =last as #\n       as'\\<Rightarrow>* (n'',transfers (slice_kinds S (last as # as'))\n                               s\\<^sub>2)", "with \\<open>S,slice_kind S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =asx'@[ax]\\<Rightarrow> \n                               (n',transfer (slice_kind S ax) s\\<^sub>2)\\<close>"], ["proof (chain)\npicking this:\n  S,slice_kind\n     S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =asx' @\n     [ax]\\<Rightarrow> (n',transfer (slice_kind S ax) s\\<^sub>2)\n  ((n'', s''), n'',\n   transfers (slice_kinds S as') (transfer (slice_kind S ax) s\\<^sub>2))\n  \\<in> WS S\n  S,slice_kind\n     S \\<turnstile> (n',transfer (slice_kind S ax)\n                         s\\<^sub>2) =as'\\<Rightarrow>* (n'',transfers\n                       (slice_kinds S as')\n                       (transfer (slice_kind S ax) s\\<^sub>2))", "have \"S,slice_kind S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =(last (asx'@[ax]))#as'\\<Rightarrow>* \n        (n'',transfers (slice_kinds S as') (transfer (slice_kind S ax) s\\<^sub>2))\""], ["proof (prove)\nusing this:\n  S,slice_kind\n     S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =asx' @\n     [ax]\\<Rightarrow> (n',transfer (slice_kind S ax) s\\<^sub>2)\n  ((n'', s''), n'',\n   transfers (slice_kinds S as') (transfer (slice_kind S ax) s\\<^sub>2))\n  \\<in> WS S\n  S,slice_kind\n     S \\<turnstile> (n',transfer (slice_kind S ax)\n                         s\\<^sub>2) =as'\\<Rightarrow>* (n'',transfers\n                       (slice_kinds S as')\n                       (transfer (slice_kind S ax) s\\<^sub>2))\n\ngoal (1 subgoal):\n 1. S,slice_kind\n       S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =last (asx' @ [ax]) #\n       as'\\<Rightarrow>* (n'',transfers (slice_kinds S as')\n                               (transfer (slice_kind S ax) s\\<^sub>2))", "by(fastforce intro:trans_observable_moves.tom_Cons)"], ["proof (state)\nthis:\n  S,slice_kind\n     S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =last (asx' @ [ax]) #\n     as'\\<Rightarrow>* (n'',transfers (slice_kinds S as')\n                             (transfer (slice_kind S ax) s\\<^sub>2))\n\ngoal (1 subgoal):\n 1. as' \\<noteq> [] \\<Longrightarrow>\n    ((n'', s''), n'', transfers (slice_kinds S (last as # as')) s\\<^sub>2)\n    \\<in> WS S \\<and>\n    S,slice_kind\n       S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =last as #\n       as'\\<Rightarrow>* (n'',transfers (slice_kinds S (last as # as'))\n                               s\\<^sub>2)", "with \\<open>((n'',s''),(n'',transfers (slice_kinds S as') \n        (transfer (slice_kind S ax) s\\<^sub>2))) \\<in> WS S\\<close> False \\<open>as = asx@[ax]\\<close>"], ["proof (chain)\npicking this:\n  ((n'', s''), n'',\n   transfers (slice_kinds S as') (transfer (slice_kind S ax) s\\<^sub>2))\n  \\<in> WS S\n  as' \\<noteq> []\n  as = asx @ [ax]\n  S,slice_kind\n     S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =last (asx' @ [ax]) #\n     as'\\<Rightarrow>* (n'',transfers (slice_kinds S as')\n                             (transfer (slice_kind S ax) s\\<^sub>2))", "show ?thesis"], ["proof (prove)\nusing this:\n  ((n'', s''), n'',\n   transfers (slice_kinds S as') (transfer (slice_kind S ax) s\\<^sub>2))\n  \\<in> WS S\n  as' \\<noteq> []\n  as = asx @ [ax]\n  S,slice_kind\n     S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =last (asx' @ [ax]) #\n     as'\\<Rightarrow>* (n'',transfers (slice_kinds S as')\n                             (transfer (slice_kind S ax) s\\<^sub>2))\n\ngoal (1 subgoal):\n 1. ((n'', s''), n'', transfers (slice_kinds S (last as # as')) s\\<^sub>2)\n    \\<in> WS S \\<and>\n    S,slice_kind\n       S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =last as #\n       as'\\<Rightarrow>* (n'',transfers (slice_kinds S (last as # as'))\n                               s\\<^sub>2)", "by(fastforce simp:slice_kinds_def)"], ["proof (state)\nthis:\n  ((n'', s''), n'', transfers (slice_kinds S (last as # as')) s\\<^sub>2)\n  \\<in> WS S \\<and>\n  S,slice_kind\n     S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =last as #\n     as'\\<Rightarrow>* (n'',transfers (slice_kinds S (last as # as'))\n                             s\\<^sub>2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((n'', s''), n'', transfers (slice_kinds S (last as # as')) s\\<^sub>2)\n  \\<in> WS S \\<and>\n  S,slice_kind\n     S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =last as #\n     as'\\<Rightarrow>* (n'',transfers (slice_kinds S (last as # as'))\n                             s\\<^sub>2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((n\\<^sub>1', s\\<^sub>1'), n\\<^sub>1',\n   transfers (slice_kinds S as) s\\<^sub>2)\n  \\<in> WS S \\<and>\n  S,slice_kind\n     S \\<turnstile> (n\\<^sub>2,s\\<^sub>2) =as\\<Rightarrow>* (n\\<^sub>1',transfers\n                                   (slice_kinds S as) s\\<^sub>2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma transfers_slice_kinds_slice_edges:\n  \"transfers (slice_kinds S (slice_edges S as)) s = transfers (slice_kinds S as) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transfers (slice_kinds S (slice_edges S as)) s =\n    transfers (slice_kinds S as) s", "proof(induct as arbitrary:s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       transfers (slice_kinds S (slice_edges S [])) s =\n       transfers (slice_kinds S []) s\n 2. \\<And>a as s.\n       (\\<And>s.\n           transfers (slice_kinds S (slice_edges S as)) s =\n           transfers (slice_kinds S as) s) \\<Longrightarrow>\n       transfers (slice_kinds S (slice_edges S (a # as))) s =\n       transfers (slice_kinds S (a # as)) s", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>s.\n       transfers (slice_kinds S (slice_edges S [])) s =\n       transfers (slice_kinds S []) s\n 2. \\<And>a as s.\n       (\\<And>s.\n           transfers (slice_kinds S (slice_edges S as)) s =\n           transfers (slice_kinds S as) s) \\<Longrightarrow>\n       transfers (slice_kinds S (slice_edges S (a # as))) s =\n       transfers (slice_kinds S (a # as)) s", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. transfers (slice_kinds S (slice_edges S [])) s =\n    transfers (slice_kinds S []) s", "by(simp add:slice_kinds_def slice_edges_def)"], ["proof (state)\nthis:\n  transfers (slice_kinds S (slice_edges S [])) s =\n  transfers (slice_kinds S []) s\n\ngoal (1 subgoal):\n 1. \\<And>a as s.\n       (\\<And>s.\n           transfers (slice_kinds S (slice_edges S as)) s =\n           transfers (slice_kinds S as) s) \\<Longrightarrow>\n       transfers (slice_kinds S (slice_edges S (a # as))) s =\n       transfers (slice_kinds S (a # as)) s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a as s.\n       (\\<And>s.\n           transfers (slice_kinds S (slice_edges S as)) s =\n           transfers (slice_kinds S as) s) \\<Longrightarrow>\n       transfers (slice_kinds S (slice_edges S (a # as))) s =\n       transfers (slice_kinds S (a # as)) s", "case (Cons a' as')"], ["proof (state)\nthis:\n  transfers (slice_kinds S (slice_edges S as')) ?s =\n  transfers (slice_kinds S as') ?s\n\ngoal (1 subgoal):\n 1. \\<And>a as s.\n       (\\<And>s.\n           transfers (slice_kinds S (slice_edges S as)) s =\n           transfers (slice_kinds S as) s) \\<Longrightarrow>\n       transfers (slice_kinds S (slice_edges S (a # as))) s =\n       transfers (slice_kinds S (a # as)) s", "note IH = \\<open>\\<And>s. transfers (slice_kinds S (slice_edges S as')) s =\n                  transfers (slice_kinds S as') s\\<close>"], ["proof (state)\nthis:\n  transfers (slice_kinds S (slice_edges S as')) ?s =\n  transfers (slice_kinds S as') ?s\n\ngoal (1 subgoal):\n 1. \\<And>a as s.\n       (\\<And>s.\n           transfers (slice_kinds S (slice_edges S as)) s =\n           transfers (slice_kinds S as) s) \\<Longrightarrow>\n       transfers (slice_kinds S (slice_edges S (a # as))) s =\n       transfers (slice_kinds S (a # as)) s", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. transfers (slice_kinds S (slice_edges S (a' # as'))) s =\n    transfers (slice_kinds S (a' # as')) s", "proof(cases \"sourcenode a' \\<in> backward_slice S\")"], ["proof (state)\ngoal (2 subgoals):\n 1. sourcenode a' \\<in> backward_slice S \\<Longrightarrow>\n    transfers (slice_kinds S (slice_edges S (a' # as'))) s =\n    transfers (slice_kinds S (a' # as')) s\n 2. sourcenode a' \\<notin> backward_slice S \\<Longrightarrow>\n    transfers (slice_kinds S (slice_edges S (a' # as'))) s =\n    transfers (slice_kinds S (a' # as')) s", "case True"], ["proof (state)\nthis:\n  sourcenode a' \\<in> backward_slice S\n\ngoal (2 subgoals):\n 1. sourcenode a' \\<in> backward_slice S \\<Longrightarrow>\n    transfers (slice_kinds S (slice_edges S (a' # as'))) s =\n    transfers (slice_kinds S (a' # as')) s\n 2. sourcenode a' \\<notin> backward_slice S \\<Longrightarrow>\n    transfers (slice_kinds S (slice_edges S (a' # as'))) s =\n    transfers (slice_kinds S (a' # as')) s", "hence eq:\"transfers (slice_kinds S (slice_edges S (a'#as'))) s\n            = transfers (slice_kinds S (slice_edges S as')) \n                (transfer (slice_kind S a') s)\""], ["proof (prove)\nusing this:\n  sourcenode a' \\<in> backward_slice S\n\ngoal (1 subgoal):\n 1. transfers (slice_kinds S (slice_edges S (a' # as'))) s =\n    transfers (slice_kinds S (slice_edges S as'))\n     (transfer (slice_kind S a') s)", "by(simp add:slice_edges_def slice_kinds_def)"], ["proof (state)\nthis:\n  transfers (slice_kinds S (slice_edges S (a' # as'))) s =\n  transfers (slice_kinds S (slice_edges S as'))\n   (transfer (slice_kind S a') s)\n\ngoal (2 subgoals):\n 1. sourcenode a' \\<in> backward_slice S \\<Longrightarrow>\n    transfers (slice_kinds S (slice_edges S (a' # as'))) s =\n    transfers (slice_kinds S (a' # as')) s\n 2. sourcenode a' \\<notin> backward_slice S \\<Longrightarrow>\n    transfers (slice_kinds S (slice_edges S (a' # as'))) s =\n    transfers (slice_kinds S (a' # as')) s", "have \"transfers (slice_kinds S (a'#as')) s\n        = transfers (slice_kinds S as') (transfer (slice_kind S a') s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transfers (slice_kinds S (a' # as')) s =\n    transfers (slice_kinds S as') (transfer (slice_kind S a') s)", "by(simp add:slice_kinds_def)"], ["proof (state)\nthis:\n  transfers (slice_kinds S (a' # as')) s =\n  transfers (slice_kinds S as') (transfer (slice_kind S a') s)\n\ngoal (2 subgoals):\n 1. sourcenode a' \\<in> backward_slice S \\<Longrightarrow>\n    transfers (slice_kinds S (slice_edges S (a' # as'))) s =\n    transfers (slice_kinds S (a' # as')) s\n 2. sourcenode a' \\<notin> backward_slice S \\<Longrightarrow>\n    transfers (slice_kinds S (slice_edges S (a' # as'))) s =\n    transfers (slice_kinds S (a' # as')) s", "with eq IH[of \"transfer (slice_kind S a') s\"]"], ["proof (chain)\npicking this:\n  transfers (slice_kinds S (slice_edges S (a' # as'))) s =\n  transfers (slice_kinds S (slice_edges S as'))\n   (transfer (slice_kind S a') s)\n  transfers (slice_kinds S (slice_edges S as'))\n   (transfer (slice_kind S a') s) =\n  transfers (slice_kinds S as') (transfer (slice_kind S a') s)\n  transfers (slice_kinds S (a' # as')) s =\n  transfers (slice_kinds S as') (transfer (slice_kind S a') s)", "show ?thesis"], ["proof (prove)\nusing this:\n  transfers (slice_kinds S (slice_edges S (a' # as'))) s =\n  transfers (slice_kinds S (slice_edges S as'))\n   (transfer (slice_kind S a') s)\n  transfers (slice_kinds S (slice_edges S as'))\n   (transfer (slice_kind S a') s) =\n  transfers (slice_kinds S as') (transfer (slice_kind S a') s)\n  transfers (slice_kinds S (a' # as')) s =\n  transfers (slice_kinds S as') (transfer (slice_kind S a') s)\n\ngoal (1 subgoal):\n 1. transfers (slice_kinds S (slice_edges S (a' # as'))) s =\n    transfers (slice_kinds S (a' # as')) s", "by simp"], ["proof (state)\nthis:\n  transfers (slice_kinds S (slice_edges S (a' # as'))) s =\n  transfers (slice_kinds S (a' # as')) s\n\ngoal (1 subgoal):\n 1. sourcenode a' \\<notin> backward_slice S \\<Longrightarrow>\n    transfers (slice_kinds S (slice_edges S (a' # as'))) s =\n    transfers (slice_kinds S (a' # as')) s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. sourcenode a' \\<notin> backward_slice S \\<Longrightarrow>\n    transfers (slice_kinds S (slice_edges S (a' # as'))) s =\n    transfers (slice_kinds S (a' # as')) s", "case False"], ["proof (state)\nthis:\n  sourcenode a' \\<notin> backward_slice S\n\ngoal (1 subgoal):\n 1. sourcenode a' \\<notin> backward_slice S \\<Longrightarrow>\n    transfers (slice_kinds S (slice_edges S (a' # as'))) s =\n    transfers (slice_kinds S (a' # as')) s", "hence eq:\"transfers (slice_kinds S (slice_edges S (a'#as'))) s\n            = transfers (slice_kinds S (slice_edges S as')) s\""], ["proof (prove)\nusing this:\n  sourcenode a' \\<notin> backward_slice S\n\ngoal (1 subgoal):\n 1. transfers (slice_kinds S (slice_edges S (a' # as'))) s =\n    transfers (slice_kinds S (slice_edges S as')) s", "by(simp add:slice_edges_def slice_kinds_def)"], ["proof (state)\nthis:\n  transfers (slice_kinds S (slice_edges S (a' # as'))) s =\n  transfers (slice_kinds S (slice_edges S as')) s\n\ngoal (1 subgoal):\n 1. sourcenode a' \\<notin> backward_slice S \\<Longrightarrow>\n    transfers (slice_kinds S (slice_edges S (a' # as'))) s =\n    transfers (slice_kinds S (a' # as')) s", "from False"], ["proof (chain)\npicking this:\n  sourcenode a' \\<notin> backward_slice S", "have \"transfer (slice_kind S a') s = s\""], ["proof (prove)\nusing this:\n  sourcenode a' \\<notin> backward_slice S\n\ngoal (1 subgoal):\n 1. transfer (slice_kind S a') s = s", "by(cases \"kind a'\",auto simp:slice_kind_def Let_def)"], ["proof (state)\nthis:\n  transfer (slice_kind S a') s = s\n\ngoal (1 subgoal):\n 1. sourcenode a' \\<notin> backward_slice S \\<Longrightarrow>\n    transfers (slice_kinds S (slice_edges S (a' # as'))) s =\n    transfers (slice_kinds S (a' # as')) s", "hence \"transfers (slice_kinds S (a'#as')) s\n         = transfers (slice_kinds S as') s\""], ["proof (prove)\nusing this:\n  transfer (slice_kind S a') s = s\n\ngoal (1 subgoal):\n 1. transfers (slice_kinds S (a' # as')) s = transfers (slice_kinds S as') s", "by(simp add:slice_kinds_def)"], ["proof (state)\nthis:\n  transfers (slice_kinds S (a' # as')) s = transfers (slice_kinds S as') s\n\ngoal (1 subgoal):\n 1. sourcenode a' \\<notin> backward_slice S \\<Longrightarrow>\n    transfers (slice_kinds S (slice_edges S (a' # as'))) s =\n    transfers (slice_kinds S (a' # as')) s", "with eq IH[of s]"], ["proof (chain)\npicking this:\n  transfers (slice_kinds S (slice_edges S (a' # as'))) s =\n  transfers (slice_kinds S (slice_edges S as')) s\n  transfers (slice_kinds S (slice_edges S as')) s =\n  transfers (slice_kinds S as') s\n  transfers (slice_kinds S (a' # as')) s = transfers (slice_kinds S as') s", "show ?thesis"], ["proof (prove)\nusing this:\n  transfers (slice_kinds S (slice_edges S (a' # as'))) s =\n  transfers (slice_kinds S (slice_edges S as')) s\n  transfers (slice_kinds S (slice_edges S as')) s =\n  transfers (slice_kinds S as') s\n  transfers (slice_kinds S (a' # as')) s = transfers (slice_kinds S as') s\n\ngoal (1 subgoal):\n 1. transfers (slice_kinds S (slice_edges S (a' # as'))) s =\n    transfers (slice_kinds S (a' # as')) s", "by simp"], ["proof (state)\nthis:\n  transfers (slice_kinds S (slice_edges S (a' # as'))) s =\n  transfers (slice_kinds S (a' # as')) s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  transfers (slice_kinds S (slice_edges S (a' # as'))) s =\n  transfers (slice_kinds S (a' # as')) s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma trans_observable_moves_preds:\n  assumes \"S,f \\<turnstile> (n,s) =as\\<Rightarrow>* (n',s')\" and \"valid_node n\"\n  obtains as' where \"preds (map f as') s\" and \"slice_edges S as' = as\"\n  and \"n -as'\\<rightarrow>* n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as'.\n        \\<lbrakk>preds (map f as') s; slice_edges S as' = as;\n         n -as'\\<rightarrow>* n'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       preds (map f as') s \\<and>\n       slice_edges S as' = as \\<and> n -as'\\<rightarrow>* n'", "from \\<open>S,f \\<turnstile> (n,s) =as\\<Rightarrow>* (n',s')\\<close> \\<open>valid_node n\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (n,s) =as\\<Rightarrow>* (n',s')\n  valid_node n", "show \"\\<exists>as'. preds (map f as') s \\<and> slice_edges S as' = as \\<and> n -as'\\<rightarrow>* n'\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (n,s) =as\\<Rightarrow>* (n',s')\n  valid_node n\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       preds (map f as') s \\<and>\n       slice_edges S as' = as \\<and> n -as'\\<rightarrow>* n'", "proof(induct rule:trans_observable_moves.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>S f n s.\n       valid_node n \\<Longrightarrow>\n       \\<exists>as'.\n          preds (map f as') s \\<and>\n          slice_edges S as' = [] \\<and> n -as'\\<rightarrow>* n\n 2. \\<And>S f n s as n' s' as' n'' s''.\n       \\<lbrakk>S,f \\<turnstile> (n,s) =as\\<Rightarrow> (n',s');\n        S,f \\<turnstile> (n',s') =as'\\<Rightarrow>* (n'',s'');\n        valid_node n' \\<Longrightarrow>\n        \\<exists>as'a.\n           preds (map f as'a) s' \\<and>\n           slice_edges S as'a = as' \\<and> n' -as'a\\<rightarrow>* n'';\n        valid_node n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a.\n                            preds (map f as'a) s \\<and>\n                            slice_edges S as'a = last as # as' \\<and>\n                            n -as'a\\<rightarrow>* n''", "case tom_Nil"], ["proof (state)\nthis:\n  valid_node n_\n\ngoal (2 subgoals):\n 1. \\<And>S f n s.\n       valid_node n \\<Longrightarrow>\n       \\<exists>as'.\n          preds (map f as') s \\<and>\n          slice_edges S as' = [] \\<and> n -as'\\<rightarrow>* n\n 2. \\<And>S f n s as n' s' as' n'' s''.\n       \\<lbrakk>S,f \\<turnstile> (n,s) =as\\<Rightarrow> (n',s');\n        S,f \\<turnstile> (n',s') =as'\\<Rightarrow>* (n'',s'');\n        valid_node n' \\<Longrightarrow>\n        \\<exists>as'a.\n           preds (map f as'a) s' \\<and>\n           slice_edges S as'a = as' \\<and> n' -as'a\\<rightarrow>* n'';\n        valid_node n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a.\n                            preds (map f as'a) s \\<and>\n                            slice_edges S as'a = last as # as' \\<and>\n                            n -as'a\\<rightarrow>* n''", "thus ?case"], ["proof (prove)\nusing this:\n  valid_node n_\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       preds (map f_ as') s_ \\<and>\n       slice_edges S_ as' = [] \\<and> n_ -as'\\<rightarrow>* n_", "by(rule_tac x=\"[]\" in exI,fastforce intro:empty_path simp:slice_edges_def)"], ["proof (state)\nthis:\n  \\<exists>as'.\n     preds (map f_ as') s_ \\<and>\n     slice_edges S_ as' = [] \\<and> n_ -as'\\<rightarrow>* n_\n\ngoal (1 subgoal):\n 1. \\<And>S f n s as n' s' as' n'' s''.\n       \\<lbrakk>S,f \\<turnstile> (n,s) =as\\<Rightarrow> (n',s');\n        S,f \\<turnstile> (n',s') =as'\\<Rightarrow>* (n'',s'');\n        valid_node n' \\<Longrightarrow>\n        \\<exists>as'a.\n           preds (map f as'a) s' \\<and>\n           slice_edges S as'a = as' \\<and> n' -as'a\\<rightarrow>* n'';\n        valid_node n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a.\n                            preds (map f as'a) s \\<and>\n                            slice_edges S as'a = last as # as' \\<and>\n                            n -as'a\\<rightarrow>* n''", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S f n s as n' s' as' n'' s''.\n       \\<lbrakk>S,f \\<turnstile> (n,s) =as\\<Rightarrow> (n',s');\n        S,f \\<turnstile> (n',s') =as'\\<Rightarrow>* (n'',s'');\n        valid_node n' \\<Longrightarrow>\n        \\<exists>as'a.\n           preds (map f as'a) s' \\<and>\n           slice_edges S as'a = as' \\<and> n' -as'a\\<rightarrow>* n'';\n        valid_node n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a.\n                            preds (map f as'a) s \\<and>\n                            slice_edges S as'a = last as # as' \\<and>\n                            n -as'a\\<rightarrow>* n''", "case (tom_Cons S f n s as n' s' as' n'' s'')"], ["proof (state)\nthis:\n  S,f \\<turnstile> (n,s) =as\\<Rightarrow> (n',s')\n  S,f \\<turnstile> (n',s') =as'\\<Rightarrow>* (n'',s'')\n  valid_node n' \\<Longrightarrow>\n  \\<exists>as'a.\n     preds (map f as'a) s' \\<and>\n     slice_edges S as'a = as' \\<and> n' -as'a\\<rightarrow>* n''\n  valid_node n\n\ngoal (1 subgoal):\n 1. \\<And>S f n s as n' s' as' n'' s''.\n       \\<lbrakk>S,f \\<turnstile> (n,s) =as\\<Rightarrow> (n',s');\n        S,f \\<turnstile> (n',s') =as'\\<Rightarrow>* (n'',s'');\n        valid_node n' \\<Longrightarrow>\n        \\<exists>as'a.\n           preds (map f as'a) s' \\<and>\n           slice_edges S as'a = as' \\<and> n' -as'a\\<rightarrow>* n'';\n        valid_node n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a.\n                            preds (map f as'a) s \\<and>\n                            slice_edges S as'a = last as # as' \\<and>\n                            n -as'a\\<rightarrow>* n''", "note IH = \\<open>valid_node n' \n      \\<Longrightarrow> \\<exists>asx. preds (map f asx) s' \\<and> slice_edges S asx = as' \\<and> n' -asx\\<rightarrow>* n''\\<close>"], ["proof (state)\nthis:\n  valid_node n' \\<Longrightarrow>\n  \\<exists>asx.\n     preds (map f asx) s' \\<and>\n     slice_edges S asx = as' \\<and> n' -asx\\<rightarrow>* n''\n\ngoal (1 subgoal):\n 1. \\<And>S f n s as n' s' as' n'' s''.\n       \\<lbrakk>S,f \\<turnstile> (n,s) =as\\<Rightarrow> (n',s');\n        S,f \\<turnstile> (n',s') =as'\\<Rightarrow>* (n'',s'');\n        valid_node n' \\<Longrightarrow>\n        \\<exists>as'a.\n           preds (map f as'a) s' \\<and>\n           slice_edges S as'a = as' \\<and> n' -as'a\\<rightarrow>* n'';\n        valid_node n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a.\n                            preds (map f as'a) s \\<and>\n                            slice_edges S as'a = last as # as' \\<and>\n                            n -as'a\\<rightarrow>* n''", "from \\<open>S,f \\<turnstile> (n,s) =as\\<Rightarrow> (n',s')\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (n,s) =as\\<Rightarrow> (n',s')", "have \"preds (map f as) s\" and \"transfers (map f as) s = s'\"\n      and \"n -as\\<rightarrow>* n'\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (n,s) =as\\<Rightarrow> (n',s')\n\ngoal (1 subgoal):\n 1. preds (map f as) s &&&\n    transfers (map f as) s = s' &&& n -as\\<rightarrow>* n'", "by(fastforce dest:observable_moves_preds_transfers_path)+"], ["proof (state)\nthis:\n  preds (map f as) s\n  transfers (map f as) s = s'\n  n -as\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. \\<And>S f n s as n' s' as' n'' s''.\n       \\<lbrakk>S,f \\<turnstile> (n,s) =as\\<Rightarrow> (n',s');\n        S,f \\<turnstile> (n',s') =as'\\<Rightarrow>* (n'',s'');\n        valid_node n' \\<Longrightarrow>\n        \\<exists>as'a.\n           preds (map f as'a) s' \\<and>\n           slice_edges S as'a = as' \\<and> n' -as'a\\<rightarrow>* n'';\n        valid_node n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a.\n                            preds (map f as'a) s \\<and>\n                            slice_edges S as'a = last as # as' \\<and>\n                            n -as'a\\<rightarrow>* n''", "from \\<open>n -as\\<rightarrow>* n'\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>* n'", "have \"valid_node n'\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. valid_node n'", "by(fastforce dest:path_valid_node)"], ["proof (state)\nthis:\n  valid_node n'\n\ngoal (1 subgoal):\n 1. \\<And>S f n s as n' s' as' n'' s''.\n       \\<lbrakk>S,f \\<turnstile> (n,s) =as\\<Rightarrow> (n',s');\n        S,f \\<turnstile> (n',s') =as'\\<Rightarrow>* (n'',s'');\n        valid_node n' \\<Longrightarrow>\n        \\<exists>as'a.\n           preds (map f as'a) s' \\<and>\n           slice_edges S as'a = as' \\<and> n' -as'a\\<rightarrow>* n'';\n        valid_node n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a.\n                            preds (map f as'a) s \\<and>\n                            slice_edges S as'a = last as # as' \\<and>\n                            n -as'a\\<rightarrow>* n''", "from \\<open>S,f \\<turnstile> (n,s) =as\\<Rightarrow> (n',s')\\<close>"], ["proof (chain)\npicking this:\n  S,f \\<turnstile> (n,s) =as\\<Rightarrow> (n',s')", "have \"slice_edges S as = [last as]\""], ["proof (prove)\nusing this:\n  S,f \\<turnstile> (n,s) =as\\<Rightarrow> (n',s')\n\ngoal (1 subgoal):\n 1. slice_edges S as = [last as]", "by(rule observable_moves_last_slice_edges)"], ["proof (state)\nthis:\n  slice_edges S as = [last as]\n\ngoal (1 subgoal):\n 1. \\<And>S f n s as n' s' as' n'' s''.\n       \\<lbrakk>S,f \\<turnstile> (n,s) =as\\<Rightarrow> (n',s');\n        S,f \\<turnstile> (n',s') =as'\\<Rightarrow>* (n'',s'');\n        valid_node n' \\<Longrightarrow>\n        \\<exists>as'a.\n           preds (map f as'a) s' \\<and>\n           slice_edges S as'a = as' \\<and> n' -as'a\\<rightarrow>* n'';\n        valid_node n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a.\n                            preds (map f as'a) s \\<and>\n                            slice_edges S as'a = last as # as' \\<and>\n                            n -as'a\\<rightarrow>* n''", "from IH[OF \\<open>valid_node n'\\<close>]"], ["proof (chain)\npicking this:\n  \\<exists>asx.\n     preds (map f asx) s' \\<and>\n     slice_edges S asx = as' \\<and> n' -asx\\<rightarrow>* n''", "obtain asx where \"preds (map f asx) s'\" and \"slice_edges S asx = as'\"\n      and \"n' -asx\\<rightarrow>* n''\""], ["proof (prove)\nusing this:\n  \\<exists>asx.\n     preds (map f asx) s' \\<and>\n     slice_edges S asx = as' \\<and> n' -asx\\<rightarrow>* n''\n\ngoal (1 subgoal):\n 1. (\\<And>asx.\n        \\<lbrakk>preds (map f asx) s'; slice_edges S asx = as';\n         n' -asx\\<rightarrow>* n''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  preds (map f asx) s'\n  slice_edges S asx = as'\n  n' -asx\\<rightarrow>* n''\n\ngoal (1 subgoal):\n 1. \\<And>S f n s as n' s' as' n'' s''.\n       \\<lbrakk>S,f \\<turnstile> (n,s) =as\\<Rightarrow> (n',s');\n        S,f \\<turnstile> (n',s') =as'\\<Rightarrow>* (n'',s'');\n        valid_node n' \\<Longrightarrow>\n        \\<exists>as'a.\n           preds (map f as'a) s' \\<and>\n           slice_edges S as'a = as' \\<and> n' -as'a\\<rightarrow>* n'';\n        valid_node n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a.\n                            preds (map f as'a) s \\<and>\n                            slice_edges S as'a = last as # as' \\<and>\n                            n -as'a\\<rightarrow>* n''", "from \\<open>n -as\\<rightarrow>* n'\\<close> \\<open>n' -asx\\<rightarrow>* n''\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>* n'\n  n' -asx\\<rightarrow>* n''", "have \"n -as@asx\\<rightarrow>* n''\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>* n'\n  n' -asx\\<rightarrow>* n''\n\ngoal (1 subgoal):\n 1. n -as @ asx\\<rightarrow>* n''", "by(rule path_Append)"], ["proof (state)\nthis:\n  n -as @ asx\\<rightarrow>* n''\n\ngoal (1 subgoal):\n 1. \\<And>S f n s as n' s' as' n'' s''.\n       \\<lbrakk>S,f \\<turnstile> (n,s) =as\\<Rightarrow> (n',s');\n        S,f \\<turnstile> (n',s') =as'\\<Rightarrow>* (n'',s'');\n        valid_node n' \\<Longrightarrow>\n        \\<exists>as'a.\n           preds (map f as'a) s' \\<and>\n           slice_edges S as'a = as' \\<and> n' -as'a\\<rightarrow>* n'';\n        valid_node n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a.\n                            preds (map f as'a) s \\<and>\n                            slice_edges S as'a = last as # as' \\<and>\n                            n -as'a\\<rightarrow>* n''", "from \\<open>preds (map f asx) s'\\<close> \\<open>transfers (map f as) s = s'\\<close>[THEN sym]\n      \\<open>preds (map f as) s\\<close>"], ["proof (chain)\npicking this:\n  preds (map f asx) s'\n  s' = transfers (map f as) s\n  preds (map f as) s", "have \"preds (map f (as@asx)) s\""], ["proof (prove)\nusing this:\n  preds (map f asx) s'\n  s' = transfers (map f as) s\n  preds (map f as) s\n\ngoal (1 subgoal):\n 1. preds (map f (as @ asx)) s", "by(simp add:preds_split)"], ["proof (state)\nthis:\n  preds (map f (as @ asx)) s\n\ngoal (1 subgoal):\n 1. \\<And>S f n s as n' s' as' n'' s''.\n       \\<lbrakk>S,f \\<turnstile> (n,s) =as\\<Rightarrow> (n',s');\n        S,f \\<turnstile> (n',s') =as'\\<Rightarrow>* (n'',s'');\n        valid_node n' \\<Longrightarrow>\n        \\<exists>as'a.\n           preds (map f as'a) s' \\<and>\n           slice_edges S as'a = as' \\<and> n' -as'a\\<rightarrow>* n'';\n        valid_node n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'a.\n                            preds (map f as'a) s \\<and>\n                            slice_edges S as'a = last as # as' \\<and>\n                            n -as'a\\<rightarrow>* n''", "with \\<open>slice_edges S as = [last as]\\<close> \\<open>slice_edges S asx = as'\\<close> \n      \\<open>n -as@asx\\<rightarrow>* n''\\<close>"], ["proof (chain)\npicking this:\n  slice_edges S as = [last as]\n  slice_edges S asx = as'\n  n -as @ asx\\<rightarrow>* n''\n  preds (map f (as @ asx)) s", "show ?case"], ["proof (prove)\nusing this:\n  slice_edges S as = [last as]\n  slice_edges S asx = as'\n  n -as @ asx\\<rightarrow>* n''\n  preds (map f (as @ asx)) s\n\ngoal (1 subgoal):\n 1. \\<exists>as'a.\n       preds (map f as'a) s \\<and>\n       slice_edges S as'a = last as # as' \\<and> n -as'a\\<rightarrow>* n''", "by(rule_tac x=\"as@asx\" in exI,auto simp:slice_edges_def)"], ["proof (state)\nthis:\n  \\<exists>as'a.\n     preds (map f as'a) s \\<and>\n     slice_edges S as'a = last as # as' \\<and> n -as'a\\<rightarrow>* n''\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as'.\n     preds (map f as') s \\<and>\n     slice_edges S as' = as \\<and> n -as'\\<rightarrow>* n'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exists_sliced_path_preds:\n  assumes \"n -as\\<rightarrow>* n'\" and \"slice_edges S as = []\" and \"n' \\<in> backward_slice S\"\n  obtains as' where \"n -as'\\<rightarrow>* n'\" and \"preds (slice_kinds S as') s\"\n  and \"slice_edges S as' = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as'.\n        \\<lbrakk>n -as'\\<rightarrow>* n'; preds (slice_kinds S as') s;\n         slice_edges S as' = []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       n -as'\\<rightarrow>* n' \\<and>\n       preds (slice_kinds S as') s \\<and> slice_edges S as' = []", "from \\<open>slice_edges S as = []\\<close>"], ["proof (chain)\npicking this:\n  slice_edges S as = []", "have \"\\<forall>nx \\<in> set(sourcenodes as). nx \\<notin> (backward_slice S)\""], ["proof (prove)\nusing this:\n  slice_edges S as = []\n\ngoal (1 subgoal):\n 1. \\<forall>nx\\<in>set (sourcenodes as). nx \\<notin> backward_slice S", "by(rule slice_edges_no_nodes_in_slice)"], ["proof (state)\nthis:\n  \\<forall>nx\\<in>set (sourcenodes as). nx \\<notin> backward_slice S\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       n -as'\\<rightarrow>* n' \\<and>\n       preds (slice_kinds S as') s \\<and> slice_edges S as' = []", "with \\<open>n -as\\<rightarrow>* n'\\<close> \\<open>n' \\<in> backward_slice S\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>* n'\n  n' \\<in> backward_slice S\n  \\<forall>nx\\<in>set (sourcenodes as). nx \\<notin> backward_slice S", "have \"n' \\<in> obs n (backward_slice S)\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>* n'\n  n' \\<in> backward_slice S\n  \\<forall>nx\\<in>set (sourcenodes as). nx \\<notin> backward_slice S\n\ngoal (1 subgoal):\n 1. n' \\<in> obs n (backward_slice S)", "by -(rule obs_elem)"], ["proof (state)\nthis:\n  n' \\<in> obs n (backward_slice S)\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       n -as'\\<rightarrow>* n' \\<and>\n       preds (slice_kinds S as') s \\<and> slice_edges S as' = []", "hence \"obs n (backward_slice S) = {n'}\""], ["proof (prove)\nusing this:\n  n' \\<in> obs n (backward_slice S)\n\ngoal (1 subgoal):\n 1. obs n (backward_slice S) = {n'}", "by(rule obs_singleton_element)"], ["proof (state)\nthis:\n  obs n (backward_slice S) = {n'}\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       n -as'\\<rightarrow>* n' \\<and>\n       preds (slice_kinds S as') s \\<and> slice_edges S as' = []", "from \\<open>n -as\\<rightarrow>* n'\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>* n'", "have \"valid_node n\" and \"valid_node n'\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. valid_node n &&& valid_node n'", "by(fastforce dest:path_valid_node)+"], ["proof (state)\nthis:\n  valid_node n\n  valid_node n'\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       n -as'\\<rightarrow>* n' \\<and>\n       preds (slice_kinds S as') s \\<and> slice_edges S as' = []", "from \\<open>n -as\\<rightarrow>* n'\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>* n'", "obtain x where \"distance n n' x\" and \"x \\<le> length as\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>distance n n' x; x \\<le> length as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule every_path_distance)"], ["proof (state)\nthis:\n  distance n n' x\n  x \\<le> length as\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       n -as'\\<rightarrow>* n' \\<and>\n       preds (slice_kinds S as') s \\<and> slice_edges S as' = []", "from \\<open>distance n n' x\\<close> \\<open>obs n (backward_slice S) = {n'}\\<close>"], ["proof (chain)\npicking this:\n  distance n n' x\n  obs n (backward_slice S) = {n'}", "show \"\\<exists>as'. n -as'\\<rightarrow>* n' \\<and> preds (slice_kinds S as') s \\<and> \n              slice_edges S as' = []\""], ["proof (prove)\nusing this:\n  distance n n' x\n  obs n (backward_slice S) = {n'}\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       n -as'\\<rightarrow>* n' \\<and>\n       preds (slice_kinds S as') s \\<and> slice_edges S as' = []", "proof(induct x arbitrary:n rule:nat.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>distance n n' 0; obs n (backward_slice S) = {n'}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            n -as'\\<rightarrow>* n' \\<and>\n                            preds (slice_kinds S as') s \\<and>\n                            slice_edges S as' = []\n 2. \\<And>nat n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>distance n n' nat;\n                    obs n (backward_slice S) = {n'}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  n -as'\\<rightarrow>* n' \\<and>\n  preds (slice_kinds S as') s \\<and> slice_edges S as' = [];\n        distance n n' (Suc nat); obs n (backward_slice S) = {n'}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            n -as'\\<rightarrow>* n' \\<and>\n                            preds (slice_kinds S as') s \\<and>\n                            slice_edges S as' = []", "case zero"], ["proof (state)\nthis:\n  distance n n' 0\n  obs n (backward_slice S) = {n'}\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>distance n n' 0; obs n (backward_slice S) = {n'}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            n -as'\\<rightarrow>* n' \\<and>\n                            preds (slice_kinds S as') s \\<and>\n                            slice_edges S as' = []\n 2. \\<And>nat n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>distance n n' nat;\n                    obs n (backward_slice S) = {n'}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  n -as'\\<rightarrow>* n' \\<and>\n  preds (slice_kinds S as') s \\<and> slice_edges S as' = [];\n        distance n n' (Suc nat); obs n (backward_slice S) = {n'}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            n -as'\\<rightarrow>* n' \\<and>\n                            preds (slice_kinds S as') s \\<and>\n                            slice_edges S as' = []", "from \\<open>distance n n' 0\\<close>"], ["proof (chain)\npicking this:\n  distance n n' 0", "have \"n = n'\""], ["proof (prove)\nusing this:\n  distance n n' 0\n\ngoal (1 subgoal):\n 1. n = n'", "by(fastforce elim:distance.cases)"], ["proof (state)\nthis:\n  n = n'\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>distance n n' 0; obs n (backward_slice S) = {n'}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            n -as'\\<rightarrow>* n' \\<and>\n                            preds (slice_kinds S as') s \\<and>\n                            slice_edges S as' = []\n 2. \\<And>nat n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>distance n n' nat;\n                    obs n (backward_slice S) = {n'}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  n -as'\\<rightarrow>* n' \\<and>\n  preds (slice_kinds S as') s \\<and> slice_edges S as' = [];\n        distance n n' (Suc nat); obs n (backward_slice S) = {n'}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            n -as'\\<rightarrow>* n' \\<and>\n                            preds (slice_kinds S as') s \\<and>\n                            slice_edges S as' = []", "with \\<open>valid_node n'\\<close>"], ["proof (chain)\npicking this:\n  valid_node n'\n  n = n'", "show ?case"], ["proof (prove)\nusing this:\n  valid_node n'\n  n = n'\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       n -as'\\<rightarrow>* n' \\<and>\n       preds (slice_kinds S as') s \\<and> slice_edges S as' = []", "by(rule_tac x=\"[]\" in exI,\n        auto intro:empty_path simp:slice_kinds_def slice_edges_def)"], ["proof (state)\nthis:\n  \\<exists>as'.\n     n -as'\\<rightarrow>* n' \\<and>\n     preds (slice_kinds S as') s \\<and> slice_edges S as' = []\n\ngoal (1 subgoal):\n 1. \\<And>nat n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>distance n n' nat;\n                    obs n (backward_slice S) = {n'}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  n -as'\\<rightarrow>* n' \\<and>\n  preds (slice_kinds S as') s \\<and> slice_edges S as' = [];\n        distance n n' (Suc nat); obs n (backward_slice S) = {n'}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            n -as'\\<rightarrow>* n' \\<and>\n                            preds (slice_kinds S as') s \\<and>\n                            slice_edges S as' = []", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>distance n n' nat;\n                    obs n (backward_slice S) = {n'}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  n -as'\\<rightarrow>* n' \\<and>\n  preds (slice_kinds S as') s \\<and> slice_edges S as' = [];\n        distance n n' (Suc nat); obs n (backward_slice S) = {n'}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            n -as'\\<rightarrow>* n' \\<and>\n                            preds (slice_kinds S as') s \\<and>\n                            slice_edges S as' = []", "case (Suc x)"], ["proof (state)\nthis:\n  \\<lbrakk>distance ?n n' x; obs ?n (backward_slice S) = {n'}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as'.\n                       ?n -as'\\<rightarrow>* n' \\<and>\n                       preds (slice_kinds S as') s \\<and>\n                       slice_edges S as' = []\n  distance n n' (Suc x)\n  obs n (backward_slice S) = {n'}\n\ngoal (1 subgoal):\n 1. \\<And>nat n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>distance n n' nat;\n                    obs n (backward_slice S) = {n'}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  n -as'\\<rightarrow>* n' \\<and>\n  preds (slice_kinds S as') s \\<and> slice_edges S as' = [];\n        distance n n' (Suc nat); obs n (backward_slice S) = {n'}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            n -as'\\<rightarrow>* n' \\<and>\n                            preds (slice_kinds S as') s \\<and>\n                            slice_edges S as' = []", "note IH = \\<open>\\<And>n. \\<lbrakk>distance n n' x; obs n (backward_slice S) = {n'}\\<rbrakk>\n      \\<Longrightarrow> \\<exists>as'. n -as'\\<rightarrow>* n' \\<and> preds (slice_kinds S as') s \\<and> \n               slice_edges S as' = []\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>distance ?n n' x; obs ?n (backward_slice S) = {n'}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as'.\n                       ?n -as'\\<rightarrow>* n' \\<and>\n                       preds (slice_kinds S as') s \\<and>\n                       slice_edges S as' = []\n\ngoal (1 subgoal):\n 1. \\<And>nat n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>distance n n' nat;\n                    obs n (backward_slice S) = {n'}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  n -as'\\<rightarrow>* n' \\<and>\n  preds (slice_kinds S as') s \\<and> slice_edges S as' = [];\n        distance n n' (Suc nat); obs n (backward_slice S) = {n'}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            n -as'\\<rightarrow>* n' \\<and>\n                            preds (slice_kinds S as') s \\<and>\n                            slice_edges S as' = []", "from \\<open>distance n n' (Suc x)\\<close>"], ["proof (chain)\npicking this:\n  distance n n' (Suc x)", "obtain a \n      where \"valid_edge a\" and \"n = sourcenode a\" \n      and \"distance (targetnode a) n' x\"\n      and target:\"targetnode a = (SOME nx. \\<exists>a'. sourcenode a = sourcenode a' \\<and> \n      distance (targetnode a') n' x \\<and>\n      valid_edge a' \\<and> targetnode a' = nx)\""], ["proof (prove)\nusing this:\n  distance n n' (Suc x)\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>valid_edge a; n = sourcenode a;\n         distance (targetnode a) n' x;\n         targetnode a =\n         (SOME nx.\n             \\<exists>a'.\n                sourcenode a = sourcenode a' \\<and>\n                distance (targetnode a') n' x \\<and>\n                valid_edge a' \\<and> targetnode a' = nx)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto elim:distance_successor_distance)"], ["proof (state)\nthis:\n  valid_edge a\n  n = sourcenode a\n  distance (targetnode a) n' x\n  targetnode a =\n  (SOME nx.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') n' x \\<and>\n         valid_edge a' \\<and> targetnode a' = nx)\n\ngoal (1 subgoal):\n 1. \\<And>nat n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>distance n n' nat;\n                    obs n (backward_slice S) = {n'}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  n -as'\\<rightarrow>* n' \\<and>\n  preds (slice_kinds S as') s \\<and> slice_edges S as' = [];\n        distance n n' (Suc nat); obs n (backward_slice S) = {n'}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            n -as'\\<rightarrow>* n' \\<and>\n                            preds (slice_kinds S as') s \\<and>\n                            slice_edges S as' = []", "have \"n \\<notin> backward_slice S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<notin> backward_slice S", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<in> backward_slice S \\<Longrightarrow> False", "assume \"n \\<in> backward_slice S\""], ["proof (state)\nthis:\n  n \\<in> backward_slice S\n\ngoal (1 subgoal):\n 1. n \\<in> backward_slice S \\<Longrightarrow> False", "from \\<open>valid_edge a\\<close> \\<open>n = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  n = sourcenode a", "have \"valid_node n\""], ["proof (prove)\nusing this:\n  valid_edge a\n  n = sourcenode a\n\ngoal (1 subgoal):\n 1. valid_node n", "by simp"], ["proof (state)\nthis:\n  valid_node n\n\ngoal (1 subgoal):\n 1. n \\<in> backward_slice S \\<Longrightarrow> False", "with \\<open>n \\<in> backward_slice S\\<close>"], ["proof (chain)\npicking this:\n  n \\<in> backward_slice S\n  valid_node n", "have \"obs n (backward_slice S) = {n}\""], ["proof (prove)\nusing this:\n  n \\<in> backward_slice S\n  valid_node n\n\ngoal (1 subgoal):\n 1. obs n (backward_slice S) = {n}", "by -(rule n_in_obs)"], ["proof (state)\nthis:\n  obs n (backward_slice S) = {n}\n\ngoal (1 subgoal):\n 1. n \\<in> backward_slice S \\<Longrightarrow> False", "with \\<open>obs n (backward_slice S) = {n'}\\<close>"], ["proof (chain)\npicking this:\n  obs n (backward_slice S) = {n'}\n  obs n (backward_slice S) = {n}", "have \"n = n'\""], ["proof (prove)\nusing this:\n  obs n (backward_slice S) = {n'}\n  obs n (backward_slice S) = {n}\n\ngoal (1 subgoal):\n 1. n = n'", "by simp"], ["proof (state)\nthis:\n  n = n'\n\ngoal (1 subgoal):\n 1. n \\<in> backward_slice S \\<Longrightarrow> False", "with \\<open>valid_node n\\<close>"], ["proof (chain)\npicking this:\n  valid_node n\n  n = n'", "have \"n -[]\\<rightarrow>* n'\""], ["proof (prove)\nusing this:\n  valid_node n\n  n = n'\n\ngoal (1 subgoal):\n 1. n -[]\\<rightarrow>* n'", "by(fastforce intro:empty_path)"], ["proof (state)\nthis:\n  n -[]\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. n \\<in> backward_slice S \\<Longrightarrow> False", "with \\<open>distance n n' (Suc x)\\<close>"], ["proof (chain)\npicking this:\n  distance n n' (Suc x)\n  n -[]\\<rightarrow>* n'", "show False"], ["proof (prove)\nusing this:\n  distance n n' (Suc x)\n  n -[]\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. False", "by(fastforce elim:distance.cases)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n \\<notin> backward_slice S\n\ngoal (1 subgoal):\n 1. \\<And>nat n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>distance n n' nat;\n                    obs n (backward_slice S) = {n'}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  n -as'\\<rightarrow>* n' \\<and>\n  preds (slice_kinds S as') s \\<and> slice_edges S as' = [];\n        distance n n' (Suc nat); obs n (backward_slice S) = {n'}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            n -as'\\<rightarrow>* n' \\<and>\n                            preds (slice_kinds S as') s \\<and>\n                            slice_edges S as' = []", "from \\<open>distance (targetnode a) n' x\\<close> \\<open>n' \\<in> backward_slice S\\<close>"], ["proof (chain)\npicking this:\n  distance (targetnode a) n' x\n  n' \\<in> backward_slice S", "obtain m where \"m \\<in> obs (targetnode a) (backward_slice S)\""], ["proof (prove)\nusing this:\n  distance (targetnode a) n' x\n  n' \\<in> backward_slice S\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        m \\<in> obs (targetnode a) (backward_slice S) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:distance.cases path_ex_obs)"], ["proof (state)\nthis:\n  m \\<in> obs (targetnode a) (backward_slice S)\n\ngoal (1 subgoal):\n 1. \\<And>nat n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>distance n n' nat;\n                    obs n (backward_slice S) = {n'}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  n -as'\\<rightarrow>* n' \\<and>\n  preds (slice_kinds S as') s \\<and> slice_edges S as' = [];\n        distance n n' (Suc nat); obs n (backward_slice S) = {n'}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            n -as'\\<rightarrow>* n' \\<and>\n                            preds (slice_kinds S as') s \\<and>\n                            slice_edges S as' = []", "from \\<open>valid_edge a\\<close> \\<open>n \\<notin> backward_slice S\\<close> \\<open>n = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  n \\<notin> backward_slice S\n  n = sourcenode a", "have \"obs (targetnode a) (backward_slice S) \\<subseteq> \n      obs (sourcenode a) (backward_slice S)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  n \\<notin> backward_slice S\n  n = sourcenode a\n\ngoal (1 subgoal):\n 1. obs (targetnode a) (backward_slice S)\n    \\<subseteq> obs (sourcenode a) (backward_slice S)", "by -(rule edge_obs_subset,auto)"], ["proof (state)\nthis:\n  obs (targetnode a) (backward_slice S)\n  \\<subseteq> obs (sourcenode a) (backward_slice S)\n\ngoal (1 subgoal):\n 1. \\<And>nat n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>distance n n' nat;\n                    obs n (backward_slice S) = {n'}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  n -as'\\<rightarrow>* n' \\<and>\n  preds (slice_kinds S as') s \\<and> slice_edges S as' = [];\n        distance n n' (Suc nat); obs n (backward_slice S) = {n'}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            n -as'\\<rightarrow>* n' \\<and>\n                            preds (slice_kinds S as') s \\<and>\n                            slice_edges S as' = []", "with \\<open>m \\<in> obs (targetnode a) (backward_slice S)\\<close> \\<open>n = sourcenode a\\<close>\n      \\<open>obs n (backward_slice S) = {n'}\\<close>"], ["proof (chain)\npicking this:\n  m \\<in> obs (targetnode a) (backward_slice S)\n  n = sourcenode a\n  obs n (backward_slice S) = {n'}\n  obs (targetnode a) (backward_slice S)\n  \\<subseteq> obs (sourcenode a) (backward_slice S)", "have \"n' \\<in> obs (targetnode a) (backward_slice S)\""], ["proof (prove)\nusing this:\n  m \\<in> obs (targetnode a) (backward_slice S)\n  n = sourcenode a\n  obs n (backward_slice S) = {n'}\n  obs (targetnode a) (backward_slice S)\n  \\<subseteq> obs (sourcenode a) (backward_slice S)\n\ngoal (1 subgoal):\n 1. n' \\<in> obs (targetnode a) (backward_slice S)", "by auto"], ["proof (state)\nthis:\n  n' \\<in> obs (targetnode a) (backward_slice S)\n\ngoal (1 subgoal):\n 1. \\<And>nat n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>distance n n' nat;\n                    obs n (backward_slice S) = {n'}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  n -as'\\<rightarrow>* n' \\<and>\n  preds (slice_kinds S as') s \\<and> slice_edges S as' = [];\n        distance n n' (Suc nat); obs n (backward_slice S) = {n'}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            n -as'\\<rightarrow>* n' \\<and>\n                            preds (slice_kinds S as') s \\<and>\n                            slice_edges S as' = []", "hence \"obs (targetnode a) (backward_slice S) = {n'}\""], ["proof (prove)\nusing this:\n  n' \\<in> obs (targetnode a) (backward_slice S)\n\ngoal (1 subgoal):\n 1. obs (targetnode a) (backward_slice S) = {n'}", "by(rule obs_singleton_element)"], ["proof (state)\nthis:\n  obs (targetnode a) (backward_slice S) = {n'}\n\ngoal (1 subgoal):\n 1. \\<And>nat n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>distance n n' nat;\n                    obs n (backward_slice S) = {n'}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  n -as'\\<rightarrow>* n' \\<and>\n  preds (slice_kinds S as') s \\<and> slice_edges S as' = [];\n        distance n n' (Suc nat); obs n (backward_slice S) = {n'}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            n -as'\\<rightarrow>* n' \\<and>\n                            preds (slice_kinds S as') s \\<and>\n                            slice_edges S as' = []", "from IH[OF \\<open>distance (targetnode a) n' x\\<close> this]"], ["proof (chain)\npicking this:\n  \\<exists>as'.\n     targetnode a -as'\\<rightarrow>* n' \\<and>\n     preds (slice_kinds S as') s \\<and> slice_edges S as' = []", "obtain as where \"targetnode a -as\\<rightarrow>* n'\" and \"preds (slice_kinds S as) s\"\n      and \"slice_edges S as = []\""], ["proof (prove)\nusing this:\n  \\<exists>as'.\n     targetnode a -as'\\<rightarrow>* n' \\<and>\n     preds (slice_kinds S as') s \\<and> slice_edges S as' = []\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        \\<lbrakk>targetnode a -as\\<rightarrow>* n';\n         preds (slice_kinds S as) s; slice_edges S as = []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  targetnode a -as\\<rightarrow>* n'\n  preds (slice_kinds S as) s\n  slice_edges S as = []\n\ngoal (1 subgoal):\n 1. \\<And>nat n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>distance n n' nat;\n                    obs n (backward_slice S) = {n'}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  n -as'\\<rightarrow>* n' \\<and>\n  preds (slice_kinds S as') s \\<and> slice_edges S as' = [];\n        distance n n' (Suc nat); obs n (backward_slice S) = {n'}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            n -as'\\<rightarrow>* n' \\<and>\n                            preds (slice_kinds S as') s \\<and>\n                            slice_edges S as' = []", "from \\<open>targetnode a -as\\<rightarrow>* n'\\<close> \\<open>valid_edge a\\<close> \\<open>n = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  targetnode a -as\\<rightarrow>* n'\n  valid_edge a\n  n = sourcenode a", "have \"n -a#as\\<rightarrow>* n'\""], ["proof (prove)\nusing this:\n  targetnode a -as\\<rightarrow>* n'\n  valid_edge a\n  n = sourcenode a\n\ngoal (1 subgoal):\n 1. n -a # as\\<rightarrow>* n'", "by(fastforce intro:Cons_path)"], ["proof (state)\nthis:\n  n -a # as\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. \\<And>nat n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>distance n n' nat;\n                    obs n (backward_slice S) = {n'}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  n -as'\\<rightarrow>* n' \\<and>\n  preds (slice_kinds S as') s \\<and> slice_edges S as' = [];\n        distance n n' (Suc nat); obs n (backward_slice S) = {n'}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            n -as'\\<rightarrow>* n' \\<and>\n                            preds (slice_kinds S as') s \\<and>\n                            slice_edges S as' = []", "from \\<open>slice_edges S as = []\\<close> \\<open>n \\<notin> backward_slice S\\<close> \\<open>n = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  slice_edges S as = []\n  n \\<notin> backward_slice S\n  n = sourcenode a", "have \"slice_edges S (a#as) = []\""], ["proof (prove)\nusing this:\n  slice_edges S as = []\n  n \\<notin> backward_slice S\n  n = sourcenode a\n\ngoal (1 subgoal):\n 1. slice_edges S (a # as) = []", "by(simp add:slice_edges_def)"], ["proof (state)\nthis:\n  slice_edges S (a # as) = []\n\ngoal (1 subgoal):\n 1. \\<And>nat n.\n       \\<lbrakk>\\<And>n.\n                   \\<lbrakk>distance n n' nat;\n                    obs n (backward_slice S) = {n'}\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  n -as'\\<rightarrow>* n' \\<and>\n  preds (slice_kinds S as') s \\<and> slice_edges S as' = [];\n        distance n n' (Suc nat); obs n (backward_slice S) = {n'}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            n -as'\\<rightarrow>* n' \\<and>\n                            preds (slice_kinds S as') s \\<and>\n                            slice_edges S as' = []", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       n -as'\\<rightarrow>* n' \\<and>\n       preds (slice_kinds S as') s \\<and> slice_edges S as' = []", "proof(cases \"kind a\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       kind a = \\<Up>x1 \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>* n' \\<and>\n          preds (slice_kinds S as') s \\<and> slice_edges S as' = []\n 2. \\<And>x2.\n       kind a = (x2)\\<^sub>\\<surd> \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>* n' \\<and>\n          preds (slice_kinds S as') s \\<and> slice_edges S as' = []", "case (Update f)"], ["proof (state)\nthis:\n  kind a = \\<Up>f\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       kind a = \\<Up>x1 \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>* n' \\<and>\n          preds (slice_kinds S as') s \\<and> slice_edges S as' = []\n 2. \\<And>x2.\n       kind a = (x2)\\<^sub>\\<surd> \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>* n' \\<and>\n          preds (slice_kinds S as') s \\<and> slice_edges S as' = []", "with \\<open>n \\<notin> backward_slice S\\<close> \\<open>n = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  n \\<notin> backward_slice S\n  n = sourcenode a\n  kind a = \\<Up>f", "have \"slice_kind S a = \\<Up>id\""], ["proof (prove)\nusing this:\n  n \\<notin> backward_slice S\n  n = sourcenode a\n  kind a = \\<Up>f\n\ngoal (1 subgoal):\n 1. slice_kind S a = \\<Up>id", "by(fastforce intro:slice_kind_Upd)"], ["proof (state)\nthis:\n  slice_kind S a = \\<Up>id\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       kind a = \\<Up>x1 \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>* n' \\<and>\n          preds (slice_kinds S as') s \\<and> slice_edges S as' = []\n 2. \\<And>x2.\n       kind a = (x2)\\<^sub>\\<surd> \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>* n' \\<and>\n          preds (slice_kinds S as') s \\<and> slice_edges S as' = []", "hence \"transfer (slice_kind S a) s = s\" and \"pred (slice_kind S a) s\""], ["proof (prove)\nusing this:\n  slice_kind S a = \\<Up>id\n\ngoal (1 subgoal):\n 1. transfer (slice_kind S a) s = s &&& pred (slice_kind S a) s", "by simp_all"], ["proof (state)\nthis:\n  transfer (slice_kind S a) s = s\n  pred (slice_kind S a) s\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       kind a = \\<Up>x1 \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>* n' \\<and>\n          preds (slice_kinds S as') s \\<and> slice_edges S as' = []\n 2. \\<And>x2.\n       kind a = (x2)\\<^sub>\\<surd> \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>* n' \\<and>\n          preds (slice_kinds S as') s \\<and> slice_edges S as' = []", "with \\<open>preds (slice_kinds S as) s\\<close>"], ["proof (chain)\npicking this:\n  preds (slice_kinds S as) s\n  transfer (slice_kind S a) s = s\n  pred (slice_kind S a) s", "have \"preds (slice_kinds S (a#as)) s\""], ["proof (prove)\nusing this:\n  preds (slice_kinds S as) s\n  transfer (slice_kind S a) s = s\n  pred (slice_kind S a) s\n\ngoal (1 subgoal):\n 1. preds (slice_kinds S (a # as)) s", "by(simp add:slice_kinds_def)"], ["proof (state)\nthis:\n  preds (slice_kinds S (a # as)) s\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       kind a = \\<Up>x1 \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>* n' \\<and>\n          preds (slice_kinds S as') s \\<and> slice_edges S as' = []\n 2. \\<And>x2.\n       kind a = (x2)\\<^sub>\\<surd> \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>* n' \\<and>\n          preds (slice_kinds S as') s \\<and> slice_edges S as' = []", "with \\<open>n -a#as\\<rightarrow>* n'\\<close> \\<open>slice_edges S (a#as) = []\\<close>"], ["proof (chain)\npicking this:\n  n -a # as\\<rightarrow>* n'\n  slice_edges S (a # as) = []\n  preds (slice_kinds S (a # as)) s", "show ?thesis"], ["proof (prove)\nusing this:\n  n -a # as\\<rightarrow>* n'\n  slice_edges S (a # as) = []\n  preds (slice_kinds S (a # as)) s\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       n -as'\\<rightarrow>* n' \\<and>\n       preds (slice_kinds S as') s \\<and> slice_edges S as' = []", "by blast"], ["proof (state)\nthis:\n  \\<exists>as'.\n     n -as'\\<rightarrow>* n' \\<and>\n     preds (slice_kinds S as') s \\<and> slice_edges S as' = []\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       kind a = (x2)\\<^sub>\\<surd> \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>* n' \\<and>\n          preds (slice_kinds S as') s \\<and> slice_edges S as' = []", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       kind a = (x2)\\<^sub>\\<surd> \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>* n' \\<and>\n          preds (slice_kinds S as') s \\<and> slice_edges S as' = []", "case (Predicate Q)"], ["proof (state)\nthis:\n  kind a = (Q)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       kind a = (x2)\\<^sub>\\<surd> \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>* n' \\<and>\n          preds (slice_kinds S as') s \\<and> slice_edges S as' = []", "with \\<open>n \\<notin> backward_slice S\\<close> \\<open>n = sourcenode a\\<close> \\<open>distance n n' (Suc x)\\<close>  \n        \\<open>obs n (backward_slice S) = {n'}\\<close> \\<open>distance (targetnode a) n' x\\<close>\n        \\<open>targetnode a = (SOME nx. \\<exists>a'. sourcenode a = sourcenode a' \\<and> \n        distance (targetnode a') n' x \\<and>\n        valid_edge a' \\<and> targetnode a' = nx)\\<close>"], ["proof (chain)\npicking this:\n  n \\<notin> backward_slice S\n  n = sourcenode a\n  distance n n' (Suc x)\n  obs n (backward_slice S) = {n'}\n  distance (targetnode a) n' x\n  targetnode a =\n  (SOME nx.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') n' x \\<and>\n         valid_edge a' \\<and> targetnode a' = nx)\n  kind a = (Q)\\<^sub>\\<surd>", "have \"slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  n \\<notin> backward_slice S\n  n = sourcenode a\n  distance n n' (Suc x)\n  obs n (backward_slice S) = {n'}\n  distance (targetnode a) n' x\n  targetnode a =\n  (SOME nx.\n      \\<exists>a'.\n         sourcenode a = sourcenode a' \\<and>\n         distance (targetnode a') n' x \\<and>\n         valid_edge a' \\<and> targetnode a' = nx)\n  kind a = (Q)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>", "by(fastforce intro:slice_kind_Pred_obs_nearer_SOME)"], ["proof (state)\nthis:\n  slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       kind a = (x2)\\<^sub>\\<surd> \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>* n' \\<and>\n          preds (slice_kinds S as') s \\<and> slice_edges S as' = []", "hence \"transfer (slice_kind S a) s = s\" and \"pred (slice_kind S a) s\""], ["proof (prove)\nusing this:\n  slice_kind S a = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. transfer (slice_kind S a) s = s &&& pred (slice_kind S a) s", "by simp_all"], ["proof (state)\nthis:\n  transfer (slice_kind S a) s = s\n  pred (slice_kind S a) s\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       kind a = (x2)\\<^sub>\\<surd> \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>* n' \\<and>\n          preds (slice_kinds S as') s \\<and> slice_edges S as' = []", "with \\<open>preds (slice_kinds S as) s\\<close>"], ["proof (chain)\npicking this:\n  preds (slice_kinds S as) s\n  transfer (slice_kind S a) s = s\n  pred (slice_kind S a) s", "have \"preds (slice_kinds S (a#as)) s\""], ["proof (prove)\nusing this:\n  preds (slice_kinds S as) s\n  transfer (slice_kind S a) s = s\n  pred (slice_kind S a) s\n\ngoal (1 subgoal):\n 1. preds (slice_kinds S (a # as)) s", "by(simp add:slice_kinds_def)"], ["proof (state)\nthis:\n  preds (slice_kinds S (a # as)) s\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       kind a = (x2)\\<^sub>\\<surd> \\<Longrightarrow>\n       \\<exists>as'.\n          n -as'\\<rightarrow>* n' \\<and>\n          preds (slice_kinds S as') s \\<and> slice_edges S as' = []", "with \\<open>n -a#as\\<rightarrow>* n'\\<close> \\<open>slice_edges S (a#as) = []\\<close>"], ["proof (chain)\npicking this:\n  n -a # as\\<rightarrow>* n'\n  slice_edges S (a # as) = []\n  preds (slice_kinds S (a # as)) s", "show ?thesis"], ["proof (prove)\nusing this:\n  n -a # as\\<rightarrow>* n'\n  slice_edges S (a # as) = []\n  preds (slice_kinds S (a # as)) s\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       n -as'\\<rightarrow>* n' \\<and>\n       preds (slice_kinds S as') s \\<and> slice_edges S as' = []", "by blast"], ["proof (state)\nthis:\n  \\<exists>as'.\n     n -as'\\<rightarrow>* n' \\<and>\n     preds (slice_kinds S as') s \\<and> slice_edges S as' = []\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as'.\n     n -as'\\<rightarrow>* n' \\<and>\n     preds (slice_kinds S as') s \\<and> slice_edges S as' = []\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as'.\n     n -as'\\<rightarrow>* n' \\<and>\n     preds (slice_kinds S as') s \\<and> slice_edges S as' = []\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem fundamental_property_of_static_slicing:\n  assumes path:\"n -as\\<rightarrow>* n'\" and preds:\"preds (kinds as) s\" and \"n' \\<in> S\"\n  obtains as' where \"preds (slice_kinds S as') s\"\n  and \"(\\<forall>V \\<in> Use n'. state_val (transfers (slice_kinds S as') s) V = \n                     state_val (transfers (kinds as) s) V)\"\n  and \"slice_edges S as = slice_edges S as'\" and \"n -as'\\<rightarrow>* n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as'.\n        \\<lbrakk>preds (slice_kinds S as') s;\n         \\<forall>V\\<in>Use n'.\n            state_val (transfers (slice_kinds S as') s) V =\n            state_val (transfers (kinds as) s) V;\n         slice_edges S as = slice_edges S as';\n         n -as'\\<rightarrow>* n'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       preds (slice_kinds S as') s \\<and>\n       (\\<forall>V\\<in>Use n'.\n           state_val (transfers (slice_kinds S as') s) V =\n           state_val (transfers (kinds as) s) V) \\<and>\n       slice_edges S as = slice_edges S as' \\<and> n -as'\\<rightarrow>* n'", "from path preds"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>* n'\n  preds (kinds as) s", "obtain n'' s'' as' as''\n    where \"S,kind \\<turnstile> (n,s) =slice_edges S as\\<Rightarrow>* (n'',s'')\"\n    and \"S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',transfers (kinds as) s)\"\n    and \"slice_edges S as = slice_edges S as''\"\n    and \"n -as''@as'\\<rightarrow>* n'\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>* n'\n  preds (kinds as) s\n\ngoal (1 subgoal):\n 1. (\\<And>n'' s'' as' as''.\n        \\<lbrakk>S,kind \\<turnstile> (n,s) =slice_edges S\n       as\\<Rightarrow>* (n'',s'');\n         S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',transfers\n                                     (kinds as) s);\n         slice_edges S as = slice_edges S as'';\n         n -as'' @ as'\\<rightarrow>* n'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(erule_tac S=\"S\" in path_trans_observable_moves,auto)"], ["proof (state)\nthis:\n  S,kind \\<turnstile> (n,s) =slice_edges S as\\<Rightarrow>* (n'',s'')\n  S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',transfers\n                              (kinds as) s)\n  slice_edges S as = slice_edges S as''\n  n -as'' @ as'\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       preds (slice_kinds S as') s \\<and>\n       (\\<forall>V\\<in>Use n'.\n           state_val (transfers (slice_kinds S as') s) V =\n           state_val (transfers (kinds as) s) V) \\<and>\n       slice_edges S as = slice_edges S as' \\<and> n -as'\\<rightarrow>* n'", "from path"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>* n'", "have \"valid_node n\" and \"valid_node n'\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. valid_node n &&& valid_node n'", "by(fastforce dest:path_valid_node)+"], ["proof (state)\nthis:\n  valid_node n\n  valid_node n'\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       preds (slice_kinds S as') s \\<and>\n       (\\<forall>V\\<in>Use n'.\n           state_val (transfers (slice_kinds S as') s) V =\n           state_val (transfers (kinds as) s) V) \\<and>\n       slice_edges S as = slice_edges S as' \\<and> n -as'\\<rightarrow>* n'", "from \\<open>valid_node n\\<close>"], ["proof (chain)\npicking this:\n  valid_node n", "have \"((n,s),(n,s)) \\<in> WS S\""], ["proof (prove)\nusing this:\n  valid_node n\n\ngoal (1 subgoal):\n 1. ((n, s), n, s) \\<in> WS S", "by(fastforce intro:WSI)"], ["proof (state)\nthis:\n  ((n, s), n, s) \\<in> WS S\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       preds (slice_kinds S as') s \\<and>\n       (\\<forall>V\\<in>Use n'.\n           state_val (transfers (slice_kinds S as') s) V =\n           state_val (transfers (kinds as) s) V) \\<and>\n       slice_edges S as = slice_edges S as' \\<and> n -as'\\<rightarrow>* n'", "from \\<open>valid_node n'\\<close> \\<open>n' \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  valid_node n'\n  n' \\<in> S", "have \"obs n' (backward_slice S) = {n'}\""], ["proof (prove)\nusing this:\n  valid_node n'\n  n' \\<in> S\n\ngoal (1 subgoal):\n 1. obs n' (backward_slice S) = {n'}", "by(fastforce intro!:n_in_obs refl)"], ["proof (state)\nthis:\n  obs n' (backward_slice S) = {n'}\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       preds (slice_kinds S as') s \\<and>\n       (\\<forall>V\\<in>Use n'.\n           state_val (transfers (slice_kinds S as') s) V =\n           state_val (transfers (kinds as) s) V) \\<and>\n       slice_edges S as = slice_edges S as' \\<and> n -as'\\<rightarrow>* n'", "from \\<open>valid_node n'\\<close>"], ["proof (chain)\npicking this:\n  valid_node n'", "have \"n'-[]\\<rightarrow>* n'\""], ["proof (prove)\nusing this:\n  valid_node n'\n\ngoal (1 subgoal):\n 1. n' -[]\\<rightarrow>* n'", "by(fastforce intro:empty_path)"], ["proof (state)\nthis:\n  n' -[]\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       preds (slice_kinds S as') s \\<and>\n       (\\<forall>V\\<in>Use n'.\n           state_val (transfers (slice_kinds S as') s) V =\n           state_val (transfers (kinds as) s) V) \\<and>\n       slice_edges S as = slice_edges S as' \\<and> n -as'\\<rightarrow>* n'", "with \\<open>valid_node n'\\<close> \\<open>n' \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  valid_node n'\n  n' \\<in> S\n  n' -[]\\<rightarrow>* n'", "have \"\\<forall>V \\<in> Use n'. V \\<in> rv S n'\""], ["proof (prove)\nusing this:\n  valid_node n'\n  n' \\<in> S\n  n' -[]\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use n'. V \\<in> rv S n'", "by(fastforce intro:rvI refl simp:sourcenodes_def)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use n'. V \\<in> rv S n'\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       preds (slice_kinds S as') s \\<and>\n       (\\<forall>V\\<in>Use n'.\n           state_val (transfers (slice_kinds S as') s) V =\n           state_val (transfers (kinds as) s) V) \\<and>\n       slice_edges S as = slice_edges S as' \\<and> n -as'\\<rightarrow>* n'", "show \"\\<exists>as'. preds (slice_kinds S as') s \\<and>\n    (\\<forall>V \\<in> Use n'. state_val (transfers (slice_kinds S as') s) V = \n                  state_val (transfers (kinds as) s) V) \\<and>\n    slice_edges S as = slice_edges S as' \\<and> n -as'\\<rightarrow>* n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       preds (slice_kinds S as') s \\<and>\n       (\\<forall>V\\<in>Use n'.\n           state_val (transfers (slice_kinds S as') s) V =\n           state_val (transfers (kinds as) s) V) \\<and>\n       slice_edges S as = slice_edges S as' \\<and> n -as'\\<rightarrow>* n'", "proof(cases \"slice_edges S as = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. slice_edges S as = [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') s \\<and>\n       (\\<forall>V\\<in>Use n'.\n           state_val (transfers (slice_kinds S as') s) V =\n           state_val (transfers (kinds as) s) V) \\<and>\n       slice_edges S as = slice_edges S as' \\<and> n -as'\\<rightarrow>* n'\n 2. slice_edges S as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') s \\<and>\n       (\\<forall>V\\<in>Use n'.\n           state_val (transfers (slice_kinds S as') s) V =\n           state_val (transfers (kinds as) s) V) \\<and>\n       slice_edges S as = slice_edges S as' \\<and> n -as'\\<rightarrow>* n'", "case True"], ["proof (state)\nthis:\n  slice_edges S as = []\n\ngoal (2 subgoals):\n 1. slice_edges S as = [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') s \\<and>\n       (\\<forall>V\\<in>Use n'.\n           state_val (transfers (slice_kinds S as') s) V =\n           state_val (transfers (kinds as) s) V) \\<and>\n       slice_edges S as = slice_edges S as' \\<and> n -as'\\<rightarrow>* n'\n 2. slice_edges S as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') s \\<and>\n       (\\<forall>V\\<in>Use n'.\n           state_val (transfers (slice_kinds S as') s) V =\n           state_val (transfers (kinds as) s) V) \\<and>\n       slice_edges S as = slice_edges S as' \\<and> n -as'\\<rightarrow>* n'", "hence \"preds (slice_kinds S []) s\" and \"slice_edges S [] = slice_edges S as\""], ["proof (prove)\nusing this:\n  slice_edges S as = []\n\ngoal (1 subgoal):\n 1. preds (slice_kinds S []) s &&& slice_edges S [] = slice_edges S as", "by(simp_all add:slice_kinds_def slice_edges_def)"], ["proof (state)\nthis:\n  preds (slice_kinds S []) s\n  slice_edges S [] = slice_edges S as\n\ngoal (2 subgoals):\n 1. slice_edges S as = [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') s \\<and>\n       (\\<forall>V\\<in>Use n'.\n           state_val (transfers (slice_kinds S as') s) V =\n           state_val (transfers (kinds as) s) V) \\<and>\n       slice_edges S as = slice_edges S as' \\<and> n -as'\\<rightarrow>* n'\n 2. slice_edges S as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') s \\<and>\n       (\\<forall>V\\<in>Use n'.\n           state_val (transfers (slice_kinds S as') s) V =\n           state_val (transfers (kinds as) s) V) \\<and>\n       slice_edges S as = slice_edges S as' \\<and> n -as'\\<rightarrow>* n'", "from \\<open>S,kind \\<turnstile> (n,s) =slice_edges S as\\<Rightarrow>* (n'',s'')\\<close> True"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (n,s) =slice_edges S as\\<Rightarrow>* (n'',s'')\n  slice_edges S as = []", "have \"n = n''\" and \"s = s''\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (n,s) =slice_edges S as\\<Rightarrow>* (n'',s'')\n  slice_edges S as = []\n\ngoal (1 subgoal):\n 1. n = n'' &&& s = s''", "by(fastforce elim:trans_observable_moves.cases)+"], ["proof (state)\nthis:\n  n = n''\n  s = s''\n\ngoal (2 subgoals):\n 1. slice_edges S as = [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') s \\<and>\n       (\\<forall>V\\<in>Use n'.\n           state_val (transfers (slice_kinds S as') s) V =\n           state_val (transfers (kinds as) s) V) \\<and>\n       slice_edges S as = slice_edges S as' \\<and> n -as'\\<rightarrow>* n'\n 2. slice_edges S as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') s \\<and>\n       (\\<forall>V\\<in>Use n'.\n           state_val (transfers (slice_kinds S as') s) V =\n           state_val (transfers (kinds as) s) V) \\<and>\n       slice_edges S as = slice_edges S as' \\<and> n -as'\\<rightarrow>* n'", "with \\<open>S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',transfers (kinds as) s)\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',transfers\n                              (kinds as) s)\n  n = n''\n  s = s''", "have \"S,kind \\<turnstile> (n,s) =as'\\<Rightarrow>\\<^sub>\\<tau> (n',transfers (kinds as) s)\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',transfers\n                              (kinds as) s)\n  n = n''\n  s = s''\n\ngoal (1 subgoal):\n 1. S,kind \\<turnstile> (n,s) =as'\\<Rightarrow>\\<^sub>\\<tau> (n',transfers\n                            (kinds as) s)", "by simp"], ["proof (state)\nthis:\n  S,kind \\<turnstile> (n,s) =as'\\<Rightarrow>\\<^sub>\\<tau> (n',transfers\n                          (kinds as) s)\n\ngoal (2 subgoals):\n 1. slice_edges S as = [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') s \\<and>\n       (\\<forall>V\\<in>Use n'.\n           state_val (transfers (slice_kinds S as') s) V =\n           state_val (transfers (kinds as) s) V) \\<and>\n       slice_edges S as = slice_edges S as' \\<and> n -as'\\<rightarrow>* n'\n 2. slice_edges S as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') s \\<and>\n       (\\<forall>V\\<in>Use n'.\n           state_val (transfers (slice_kinds S as') s) V =\n           state_val (transfers (kinds as) s) V) \\<and>\n       slice_edges S as = slice_edges S as' \\<and> n -as'\\<rightarrow>* n'", "with \\<open>valid_node n\\<close>"], ["proof (chain)\npicking this:\n  valid_node n\n  S,kind \\<turnstile> (n,s) =as'\\<Rightarrow>\\<^sub>\\<tau> (n',transfers\n                          (kinds as) s)", "have \"n -as'\\<rightarrow>* n'\""], ["proof (prove)\nusing this:\n  valid_node n\n  S,kind \\<turnstile> (n,s) =as'\\<Rightarrow>\\<^sub>\\<tau> (n',transfers\n                          (kinds as) s)\n\ngoal (1 subgoal):\n 1. n -as'\\<rightarrow>* n'", "by(fastforce dest:silent_moves_preds_transfers_path)"], ["proof (state)\nthis:\n  n -as'\\<rightarrow>* n'\n\ngoal (2 subgoals):\n 1. slice_edges S as = [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') s \\<and>\n       (\\<forall>V\\<in>Use n'.\n           state_val (transfers (slice_kinds S as') s) V =\n           state_val (transfers (kinds as) s) V) \\<and>\n       slice_edges S as = slice_edges S as' \\<and> n -as'\\<rightarrow>* n'\n 2. slice_edges S as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') s \\<and>\n       (\\<forall>V\\<in>Use n'.\n           state_val (transfers (slice_kinds S as') s) V =\n           state_val (transfers (kinds as) s) V) \\<and>\n       slice_edges S as = slice_edges S as' \\<and> n -as'\\<rightarrow>* n'", "from \\<open>S,kind \\<turnstile> (n,s) =as'\\<Rightarrow>\\<^sub>\\<tau> (n',transfers (kinds as) s)\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (n,s) =as'\\<Rightarrow>\\<^sub>\\<tau> (n',transfers\n                          (kinds as) s)", "have \"slice_edges S as' = []\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (n,s) =as'\\<Rightarrow>\\<^sub>\\<tau> (n',transfers\n                          (kinds as) s)\n\ngoal (1 subgoal):\n 1. slice_edges S as' = []", "by(fastforce dest:silent_moves_no_slice_edges)"], ["proof (state)\nthis:\n  slice_edges S as' = []\n\ngoal (2 subgoals):\n 1. slice_edges S as = [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') s \\<and>\n       (\\<forall>V\\<in>Use n'.\n           state_val (transfers (slice_kinds S as') s) V =\n           state_val (transfers (kinds as) s) V) \\<and>\n       slice_edges S as = slice_edges S as' \\<and> n -as'\\<rightarrow>* n'\n 2. slice_edges S as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') s \\<and>\n       (\\<forall>V\\<in>Use n'.\n           state_val (transfers (slice_kinds S as') s) V =\n           state_val (transfers (kinds as) s) V) \\<and>\n       slice_edges S as = slice_edges S as' \\<and> n -as'\\<rightarrow>* n'", "with \\<open>n -as'\\<rightarrow>* n'\\<close> \\<open>valid_node n'\\<close> \\<open>n' \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  n -as'\\<rightarrow>* n'\n  valid_node n'\n  n' \\<in> S\n  slice_edges S as' = []", "obtain asx\n      where \"n -asx\\<rightarrow>* n'\" and \"preds (slice_kinds S asx) s\"\n      and \"slice_edges S asx = []\""], ["proof (prove)\nusing this:\n  n -as'\\<rightarrow>* n'\n  valid_node n'\n  n' \\<in> S\n  slice_edges S as' = []\n\ngoal (1 subgoal):\n 1. (\\<And>asx.\n        \\<lbrakk>n -asx\\<rightarrow>* n'; preds (slice_kinds S asx) s;\n         slice_edges S asx = []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(erule exists_sliced_path_preds,auto intro:refl)"], ["proof (state)\nthis:\n  n -asx\\<rightarrow>* n'\n  preds (slice_kinds S asx) s\n  slice_edges S asx = []\n\ngoal (2 subgoals):\n 1. slice_edges S as = [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') s \\<and>\n       (\\<forall>V\\<in>Use n'.\n           state_val (transfers (slice_kinds S as') s) V =\n           state_val (transfers (kinds as) s) V) \\<and>\n       slice_edges S as = slice_edges S as' \\<and> n -as'\\<rightarrow>* n'\n 2. slice_edges S as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') s \\<and>\n       (\\<forall>V\\<in>Use n'.\n           state_val (transfers (slice_kinds S as') s) V =\n           state_val (transfers (kinds as) s) V) \\<and>\n       slice_edges S as = slice_edges S as' \\<and> n -as'\\<rightarrow>* n'", "from \\<open>S,kind \\<turnstile> (n,s) =as'\\<Rightarrow>\\<^sub>\\<tau> (n',transfers (kinds as) s)\\<close>\n      \\<open>((n,s),(n,s)) \\<in> WS S\\<close> \\<open>obs n' (backward_slice S) = {n'}\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (n,s) =as'\\<Rightarrow>\\<^sub>\\<tau> (n',transfers\n                          (kinds as) s)\n  ((n, s), n, s) \\<in> WS S\n  obs n' (backward_slice S) = {n'}", "have \"((n',transfers (kinds as) s),(n,s)) \\<in> WS S\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (n,s) =as'\\<Rightarrow>\\<^sub>\\<tau> (n',transfers\n                          (kinds as) s)\n  ((n, s), n, s) \\<in> WS S\n  obs n' (backward_slice S) = {n'}\n\ngoal (1 subgoal):\n 1. ((n', transfers (kinds as) s), n, s) \\<in> WS S", "by(fastforce intro:WS_silent_moves)"], ["proof (state)\nthis:\n  ((n', transfers (kinds as) s), n, s) \\<in> WS S\n\ngoal (2 subgoals):\n 1. slice_edges S as = [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') s \\<and>\n       (\\<forall>V\\<in>Use n'.\n           state_val (transfers (slice_kinds S as') s) V =\n           state_val (transfers (kinds as) s) V) \\<and>\n       slice_edges S as = slice_edges S as' \\<and> n -as'\\<rightarrow>* n'\n 2. slice_edges S as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') s \\<and>\n       (\\<forall>V\\<in>Use n'.\n           state_val (transfers (slice_kinds S as') s) V =\n           state_val (transfers (kinds as) s) V) \\<and>\n       slice_edges S as = slice_edges S as' \\<and> n -as'\\<rightarrow>* n'", "with True"], ["proof (chain)\npicking this:\n  slice_edges S as = []\n  ((n', transfers (kinds as) s), n, s) \\<in> WS S", "have \"\\<forall>V \\<in> rv S n'. state_val (transfers (kinds as) s) V = \n      state_val (transfers (slice_kinds S (slice_edges S as)) s) V\""], ["proof (prove)\nusing this:\n  slice_edges S as = []\n  ((n', transfers (kinds as) s), n, s) \\<in> WS S\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>rv S n'.\n       state_val (transfers (kinds as) s) V =\n       state_val (transfers (slice_kinds S (slice_edges S as)) s) V", "by(fastforce dest:WSD simp:slice_edges_def slice_kinds_def)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>rv S n'.\n     state_val (transfers (kinds as) s) V =\n     state_val (transfers (slice_kinds S (slice_edges S as)) s) V\n\ngoal (2 subgoals):\n 1. slice_edges S as = [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') s \\<and>\n       (\\<forall>V\\<in>Use n'.\n           state_val (transfers (slice_kinds S as') s) V =\n           state_val (transfers (kinds as) s) V) \\<and>\n       slice_edges S as = slice_edges S as' \\<and> n -as'\\<rightarrow>* n'\n 2. slice_edges S as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') s \\<and>\n       (\\<forall>V\\<in>Use n'.\n           state_val (transfers (slice_kinds S as') s) V =\n           state_val (transfers (kinds as) s) V) \\<and>\n       slice_edges S as = slice_edges S as' \\<and> n -as'\\<rightarrow>* n'", "with \\<open>\\<forall>V \\<in> Use n'. V \\<in> rv S n'\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>Use n'. V \\<in> rv S n'\n  \\<forall>V\\<in>rv S n'.\n     state_val (transfers (kinds as) s) V =\n     state_val (transfers (slice_kinds S (slice_edges S as)) s) V", "have \"\\<forall>V \\<in> Use n'. state_val (transfers (kinds as) s) V = \n      state_val (transfers (slice_kinds S (slice_edges S as)) s) V\""], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>Use n'. V \\<in> rv S n'\n  \\<forall>V\\<in>rv S n'.\n     state_val (transfers (kinds as) s) V =\n     state_val (transfers (slice_kinds S (slice_edges S as)) s) V\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use n'.\n       state_val (transfers (kinds as) s) V =\n       state_val (transfers (slice_kinds S (slice_edges S as)) s) V", "by simp"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use n'.\n     state_val (transfers (kinds as) s) V =\n     state_val (transfers (slice_kinds S (slice_edges S as)) s) V\n\ngoal (2 subgoals):\n 1. slice_edges S as = [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') s \\<and>\n       (\\<forall>V\\<in>Use n'.\n           state_val (transfers (slice_kinds S as') s) V =\n           state_val (transfers (kinds as) s) V) \\<and>\n       slice_edges S as = slice_edges S as' \\<and> n -as'\\<rightarrow>* n'\n 2. slice_edges S as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') s \\<and>\n       (\\<forall>V\\<in>Use n'.\n           state_val (transfers (slice_kinds S as') s) V =\n           state_val (transfers (kinds as) s) V) \\<and>\n       slice_edges S as = slice_edges S as' \\<and> n -as'\\<rightarrow>* n'", "with \\<open>slice_edges S asx = []\\<close> \\<open>slice_edges S [] = slice_edges S as\\<close>"], ["proof (chain)\npicking this:\n  slice_edges S asx = []\n  slice_edges S [] = slice_edges S as\n  \\<forall>V\\<in>Use n'.\n     state_val (transfers (kinds as) s) V =\n     state_val (transfers (slice_kinds S (slice_edges S as)) s) V", "have \"\\<forall>V \\<in> Use n'. state_val (transfers (kinds as) s) V = \n      state_val (transfers (slice_kinds S (slice_edges S asx)) s) V\""], ["proof (prove)\nusing this:\n  slice_edges S asx = []\n  slice_edges S [] = slice_edges S as\n  \\<forall>V\\<in>Use n'.\n     state_val (transfers (kinds as) s) V =\n     state_val (transfers (slice_kinds S (slice_edges S as)) s) V\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use n'.\n       state_val (transfers (kinds as) s) V =\n       state_val (transfers (slice_kinds S (slice_edges S asx)) s) V", "by(simp add:slice_edges_def)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use n'.\n     state_val (transfers (kinds as) s) V =\n     state_val (transfers (slice_kinds S (slice_edges S asx)) s) V\n\ngoal (2 subgoals):\n 1. slice_edges S as = [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') s \\<and>\n       (\\<forall>V\\<in>Use n'.\n           state_val (transfers (slice_kinds S as') s) V =\n           state_val (transfers (kinds as) s) V) \\<and>\n       slice_edges S as = slice_edges S as' \\<and> n -as'\\<rightarrow>* n'\n 2. slice_edges S as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') s \\<and>\n       (\\<forall>V\\<in>Use n'.\n           state_val (transfers (slice_kinds S as') s) V =\n           state_val (transfers (kinds as) s) V) \\<and>\n       slice_edges S as = slice_edges S as' \\<and> n -as'\\<rightarrow>* n'", "hence \"\\<forall>V \\<in> Use n'. state_val (transfers (kinds as) s) V = \n      state_val (transfers (slice_kinds S asx) s) V\""], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>Use n'.\n     state_val (transfers (kinds as) s) V =\n     state_val (transfers (slice_kinds S (slice_edges S asx)) s) V\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use n'.\n       state_val (transfers (kinds as) s) V =\n       state_val (transfers (slice_kinds S asx) s) V", "by(simp add:transfers_slice_kinds_slice_edges)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use n'.\n     state_val (transfers (kinds as) s) V =\n     state_val (transfers (slice_kinds S asx) s) V\n\ngoal (2 subgoals):\n 1. slice_edges S as = [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') s \\<and>\n       (\\<forall>V\\<in>Use n'.\n           state_val (transfers (slice_kinds S as') s) V =\n           state_val (transfers (kinds as) s) V) \\<and>\n       slice_edges S as = slice_edges S as' \\<and> n -as'\\<rightarrow>* n'\n 2. slice_edges S as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') s \\<and>\n       (\\<forall>V\\<in>Use n'.\n           state_val (transfers (slice_kinds S as') s) V =\n           state_val (transfers (kinds as) s) V) \\<and>\n       slice_edges S as = slice_edges S as' \\<and> n -as'\\<rightarrow>* n'", "with \\<open>n -asx\\<rightarrow>* n'\\<close> \\<open>preds (slice_kinds S asx) s\\<close>\n      \\<open>slice_edges S asx = []\\<close> \\<open>slice_edges S [] = slice_edges S as\\<close>"], ["proof (chain)\npicking this:\n  n -asx\\<rightarrow>* n'\n  preds (slice_kinds S asx) s\n  slice_edges S asx = []\n  slice_edges S [] = slice_edges S as\n  \\<forall>V\\<in>Use n'.\n     state_val (transfers (kinds as) s) V =\n     state_val (transfers (slice_kinds S asx) s) V", "show ?thesis"], ["proof (prove)\nusing this:\n  n -asx\\<rightarrow>* n'\n  preds (slice_kinds S asx) s\n  slice_edges S asx = []\n  slice_edges S [] = slice_edges S as\n  \\<forall>V\\<in>Use n'.\n     state_val (transfers (kinds as) s) V =\n     state_val (transfers (slice_kinds S asx) s) V\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       preds (slice_kinds S as') s \\<and>\n       (\\<forall>V\\<in>Use n'.\n           state_val (transfers (slice_kinds S as') s) V =\n           state_val (transfers (kinds as) s) V) \\<and>\n       slice_edges S as = slice_edges S as' \\<and> n -as'\\<rightarrow>* n'", "by(rule_tac x=\"asx\" in exI,simp add:slice_edges_def)"], ["proof (state)\nthis:\n  \\<exists>as'.\n     preds (slice_kinds S as') s \\<and>\n     (\\<forall>V\\<in>Use n'.\n         state_val (transfers (slice_kinds S as') s) V =\n         state_val (transfers (kinds as) s) V) \\<and>\n     slice_edges S as = slice_edges S as' \\<and> n -as'\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. slice_edges S as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') s \\<and>\n       (\\<forall>V\\<in>Use n'.\n           state_val (transfers (slice_kinds S as') s) V =\n           state_val (transfers (kinds as) s) V) \\<and>\n       slice_edges S as = slice_edges S as' \\<and> n -as'\\<rightarrow>* n'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. slice_edges S as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') s \\<and>\n       (\\<forall>V\\<in>Use n'.\n           state_val (transfers (slice_kinds S as') s) V =\n           state_val (transfers (kinds as) s) V) \\<and>\n       slice_edges S as = slice_edges S as' \\<and> n -as'\\<rightarrow>* n'", "case False"], ["proof (state)\nthis:\n  slice_edges S as \\<noteq> []\n\ngoal (1 subgoal):\n 1. slice_edges S as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') s \\<and>\n       (\\<forall>V\\<in>Use n'.\n           state_val (transfers (slice_kinds S as') s) V =\n           state_val (transfers (kinds as) s) V) \\<and>\n       slice_edges S as = slice_edges S as' \\<and> n -as'\\<rightarrow>* n'", "with \\<open>S,kind \\<turnstile> (n,s) =slice_edges S as\\<Rightarrow>* (n'',s'')\\<close> \\<open>((n,s),(n,s)) \\<in> WS S\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (n,s) =slice_edges S as\\<Rightarrow>* (n'',s'')\n  ((n, s), n, s) \\<in> WS S\n  slice_edges S as \\<noteq> []", "have \"((n'',s''),(n'',transfers (slice_kinds S (slice_edges S as)) s)) \\<in> WS S\"\n      \"S,slice_kind S \\<turnstile> (n,s) =slice_edges S as\\<Rightarrow>* \n      (n'',transfers (slice_kinds S (slice_edges S as)) s)\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (n,s) =slice_edges S as\\<Rightarrow>* (n'',s'')\n  ((n, s), n, s) \\<in> WS S\n  slice_edges S as \\<noteq> []\n\ngoal (1 subgoal):\n 1. ((n'', s''), n'', transfers (slice_kinds S (slice_edges S as)) s)\n    \\<in> WS S &&&\n    S,slice_kind\n       S \\<turnstile> (n,s) =slice_edges S\n                              as\\<Rightarrow>* (n'',transfers\n               (slice_kinds S (slice_edges S as)) s)", "by(fastforce dest:WS_weak_sim_trans)+"], ["proof (state)\nthis:\n  ((n'', s''), n'', transfers (slice_kinds S (slice_edges S as)) s)\n  \\<in> WS S\n  S,slice_kind\n     S \\<turnstile> (n,s) =slice_edges S\n                            as\\<Rightarrow>* (n'',transfers\n             (slice_kinds S (slice_edges S as)) s)\n\ngoal (1 subgoal):\n 1. slice_edges S as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') s \\<and>\n       (\\<forall>V\\<in>Use n'.\n           state_val (transfers (slice_kinds S as') s) V =\n           state_val (transfers (kinds as) s) V) \\<and>\n       slice_edges S as = slice_edges S as' \\<and> n -as'\\<rightarrow>* n'", "from \\<open>S,slice_kind S \\<turnstile> (n,s) =slice_edges S as\\<Rightarrow>* \n                             (n'',transfers (slice_kinds S (slice_edges S as)) s)\\<close>\n      \\<open>valid_node n\\<close>"], ["proof (chain)\npicking this:\n  S,slice_kind\n     S \\<turnstile> (n,s) =slice_edges S\n                            as\\<Rightarrow>* (n'',transfers\n             (slice_kinds S (slice_edges S as)) s)\n  valid_node n", "obtain asx where \"preds (slice_kinds S asx) s\" \n      and \"slice_edges S asx = slice_edges S as\"\n      and \"n -asx\\<rightarrow>* n''\""], ["proof (prove)\nusing this:\n  S,slice_kind\n     S \\<turnstile> (n,s) =slice_edges S\n                            as\\<Rightarrow>* (n'',transfers\n             (slice_kinds S (slice_edges S as)) s)\n  valid_node n\n\ngoal (1 subgoal):\n 1. (\\<And>asx.\n        \\<lbrakk>preds (slice_kinds S asx) s;\n         slice_edges S asx = slice_edges S as;\n         n -asx\\<rightarrow>* n''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:trans_observable_moves_preds simp:slice_kinds_def)"], ["proof (state)\nthis:\n  preds (slice_kinds S asx) s\n  slice_edges S asx = slice_edges S as\n  n -asx\\<rightarrow>* n''\n\ngoal (1 subgoal):\n 1. slice_edges S as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') s \\<and>\n       (\\<forall>V\\<in>Use n'.\n           state_val (transfers (slice_kinds S as') s) V =\n           state_val (transfers (kinds as) s) V) \\<and>\n       slice_edges S as = slice_edges S as' \\<and> n -as'\\<rightarrow>* n'", "from \\<open>n -asx\\<rightarrow>* n''\\<close>"], ["proof (chain)\npicking this:\n  n -asx\\<rightarrow>* n''", "have \"valid_node n''\""], ["proof (prove)\nusing this:\n  n -asx\\<rightarrow>* n''\n\ngoal (1 subgoal):\n 1. valid_node n''", "by(fastforce dest:path_valid_node)"], ["proof (state)\nthis:\n  valid_node n''\n\ngoal (1 subgoal):\n 1. slice_edges S as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') s \\<and>\n       (\\<forall>V\\<in>Use n'.\n           state_val (transfers (slice_kinds S as') s) V =\n           state_val (transfers (kinds as) s) V) \\<and>\n       slice_edges S as = slice_edges S as' \\<and> n -as'\\<rightarrow>* n'", "with \\<open>S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',transfers (kinds as) s)\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',transfers\n                              (kinds as) s)\n  valid_node n''", "have \"n'' -as'\\<rightarrow>* n'\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',transfers\n                              (kinds as) s)\n  valid_node n''\n\ngoal (1 subgoal):\n 1. n'' -as'\\<rightarrow>* n'", "by(fastforce dest:silent_moves_preds_transfers_path)"], ["proof (state)\nthis:\n  n'' -as'\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. slice_edges S as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') s \\<and>\n       (\\<forall>V\\<in>Use n'.\n           state_val (transfers (slice_kinds S as') s) V =\n           state_val (transfers (kinds as) s) V) \\<and>\n       slice_edges S as = slice_edges S as' \\<and> n -as'\\<rightarrow>* n'", "from \\<open>S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',transfers (kinds as) s)\\<close>"], ["proof (chain)\npicking this:\n  S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',transfers\n                              (kinds as) s)", "have \"slice_edges S as' = []\""], ["proof (prove)\nusing this:\n  S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',transfers\n                              (kinds as) s)\n\ngoal (1 subgoal):\n 1. slice_edges S as' = []", "by(fastforce dest:silent_moves_no_slice_edges)"], ["proof (state)\nthis:\n  slice_edges S as' = []\n\ngoal (1 subgoal):\n 1. slice_edges S as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') s \\<and>\n       (\\<forall>V\\<in>Use n'.\n           state_val (transfers (slice_kinds S as') s) V =\n           state_val (transfers (kinds as) s) V) \\<and>\n       slice_edges S as = slice_edges S as' \\<and> n -as'\\<rightarrow>* n'", "with \\<open>n'' -as'\\<rightarrow>* n'\\<close> \\<open>valid_node n'\\<close> \\<open>n' \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  n'' -as'\\<rightarrow>* n'\n  valid_node n'\n  n' \\<in> S\n  slice_edges S as' = []", "obtain asx'\n      where \"n'' -asx'\\<rightarrow>* n'\" and \"slice_edges S asx' = []\"\n      and \"preds (slice_kinds S asx') (transfers (slice_kinds S asx) s)\""], ["proof (prove)\nusing this:\n  n'' -as'\\<rightarrow>* n'\n  valid_node n'\n  n' \\<in> S\n  slice_edges S as' = []\n\ngoal (1 subgoal):\n 1. (\\<And>asx'.\n        \\<lbrakk>n'' -asx'\\<rightarrow>* n'; slice_edges S asx' = [];\n         preds (slice_kinds S asx')\n          (transfers (slice_kinds S asx) s)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(erule exists_sliced_path_preds,auto intro:refl)"], ["proof (state)\nthis:\n  n'' -asx'\\<rightarrow>* n'\n  slice_edges S asx' = []\n  preds (slice_kinds S asx') (transfers (slice_kinds S asx) s)\n\ngoal (1 subgoal):\n 1. slice_edges S as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') s \\<and>\n       (\\<forall>V\\<in>Use n'.\n           state_val (transfers (slice_kinds S as') s) V =\n           state_val (transfers (kinds as) s) V) \\<and>\n       slice_edges S as = slice_edges S as' \\<and> n -as'\\<rightarrow>* n'", "from \\<open>n -asx\\<rightarrow>* n''\\<close> \\<open>n'' -asx'\\<rightarrow>* n'\\<close>"], ["proof (chain)\npicking this:\n  n -asx\\<rightarrow>* n''\n  n'' -asx'\\<rightarrow>* n'", "have \"n -asx@asx'\\<rightarrow>* n'\""], ["proof (prove)\nusing this:\n  n -asx\\<rightarrow>* n''\n  n'' -asx'\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. n -asx @ asx'\\<rightarrow>* n'", "by(rule path_Append)"], ["proof (state)\nthis:\n  n -asx @ asx'\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. slice_edges S as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') s \\<and>\n       (\\<forall>V\\<in>Use n'.\n           state_val (transfers (slice_kinds S as') s) V =\n           state_val (transfers (kinds as) s) V) \\<and>\n       slice_edges S as = slice_edges S as' \\<and> n -as'\\<rightarrow>* n'", "from \\<open>slice_edges S asx = slice_edges S as\\<close> \\<open>slice_edges S asx' = []\\<close>"], ["proof (chain)\npicking this:\n  slice_edges S asx = slice_edges S as\n  slice_edges S asx' = []", "have \"slice_edges S as = slice_edges S (asx@asx')\""], ["proof (prove)\nusing this:\n  slice_edges S asx = slice_edges S as\n  slice_edges S asx' = []\n\ngoal (1 subgoal):\n 1. slice_edges S as = slice_edges S (asx @ asx')", "by(auto simp:slice_edges_def)"], ["proof (state)\nthis:\n  slice_edges S as = slice_edges S (asx @ asx')\n\ngoal (1 subgoal):\n 1. slice_edges S as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') s \\<and>\n       (\\<forall>V\\<in>Use n'.\n           state_val (transfers (slice_kinds S as') s) V =\n           state_val (transfers (kinds as) s) V) \\<and>\n       slice_edges S as = slice_edges S as' \\<and> n -as'\\<rightarrow>* n'", "from \\<open>preds (slice_kinds S asx') (transfers (slice_kinds S asx) s)\\<close>\n      \\<open>preds (slice_kinds S asx) s\\<close>"], ["proof (chain)\npicking this:\n  preds (slice_kinds S asx') (transfers (slice_kinds S asx) s)\n  preds (slice_kinds S asx) s", "have \"preds (slice_kinds S (asx@asx')) s\""], ["proof (prove)\nusing this:\n  preds (slice_kinds S asx') (transfers (slice_kinds S asx) s)\n  preds (slice_kinds S asx) s\n\ngoal (1 subgoal):\n 1. preds (slice_kinds S (asx @ asx')) s", "by(simp add:slice_kinds_def preds_split)"], ["proof (state)\nthis:\n  preds (slice_kinds S (asx @ asx')) s\n\ngoal (1 subgoal):\n 1. slice_edges S as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') s \\<and>\n       (\\<forall>V\\<in>Use n'.\n           state_val (transfers (slice_kinds S as') s) V =\n           state_val (transfers (kinds as) s) V) \\<and>\n       slice_edges S as = slice_edges S as' \\<and> n -as'\\<rightarrow>* n'", "from \\<open>obs n' (backward_slice S) = {n'}\\<close>\n      \\<open>S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',transfers (kinds as) s)\\<close>\n      \\<open>((n'',s''),(n'',transfers (slice_kinds S (slice_edges S as)) s)) \\<in> WS S\\<close>"], ["proof (chain)\npicking this:\n  obs n' (backward_slice S) = {n'}\n  S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',transfers\n                              (kinds as) s)\n  ((n'', s''), n'', transfers (slice_kinds S (slice_edges S as)) s)\n  \\<in> WS S", "have \"((n',transfers (kinds as) s),\n      (n'',transfers (slice_kinds S (slice_edges S as)) s)) \\<in> WS S\""], ["proof (prove)\nusing this:\n  obs n' (backward_slice S) = {n'}\n  S,kind \\<turnstile> (n'',s'') =as'\\<Rightarrow>\\<^sub>\\<tau> (n',transfers\n                              (kinds as) s)\n  ((n'', s''), n'', transfers (slice_kinds S (slice_edges S as)) s)\n  \\<in> WS S\n\ngoal (1 subgoal):\n 1. ((n', transfers (kinds as) s), n'',\n     transfers (slice_kinds S (slice_edges S as)) s)\n    \\<in> WS S", "by(fastforce intro:WS_silent_moves)"], ["proof (state)\nthis:\n  ((n', transfers (kinds as) s), n'',\n   transfers (slice_kinds S (slice_edges S as)) s)\n  \\<in> WS S\n\ngoal (1 subgoal):\n 1. slice_edges S as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') s \\<and>\n       (\\<forall>V\\<in>Use n'.\n           state_val (transfers (slice_kinds S as') s) V =\n           state_val (transfers (kinds as) s) V) \\<and>\n       slice_edges S as = slice_edges S as' \\<and> n -as'\\<rightarrow>* n'", "hence \"\\<forall>V \\<in> rv S n'. state_val (transfers (kinds as) s) V = \n      state_val (transfers (slice_kinds S (slice_edges S as)) s) V\""], ["proof (prove)\nusing this:\n  ((n', transfers (kinds as) s), n'',\n   transfers (slice_kinds S (slice_edges S as)) s)\n  \\<in> WS S\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>rv S n'.\n       state_val (transfers (kinds as) s) V =\n       state_val (transfers (slice_kinds S (slice_edges S as)) s) V", "by(fastforce dest:WSD)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>rv S n'.\n     state_val (transfers (kinds as) s) V =\n     state_val (transfers (slice_kinds S (slice_edges S as)) s) V\n\ngoal (1 subgoal):\n 1. slice_edges S as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') s \\<and>\n       (\\<forall>V\\<in>Use n'.\n           state_val (transfers (slice_kinds S as') s) V =\n           state_val (transfers (kinds as) s) V) \\<and>\n       slice_edges S as = slice_edges S as' \\<and> n -as'\\<rightarrow>* n'", "with \\<open>\\<forall>V \\<in> Use n'. V \\<in> rv S n'\\<close> \\<open>slice_edges S asx = slice_edges S as\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>Use n'. V \\<in> rv S n'\n  slice_edges S asx = slice_edges S as\n  \\<forall>V\\<in>rv S n'.\n     state_val (transfers (kinds as) s) V =\n     state_val (transfers (slice_kinds S (slice_edges S as)) s) V", "have \"\\<forall>V \\<in> Use n'. state_val (transfers (kinds as) s) V = \n      state_val (transfers (slice_kinds S (slice_edges S asx)) s) V\""], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>Use n'. V \\<in> rv S n'\n  slice_edges S asx = slice_edges S as\n  \\<forall>V\\<in>rv S n'.\n     state_val (transfers (kinds as) s) V =\n     state_val (transfers (slice_kinds S (slice_edges S as)) s) V\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use n'.\n       state_val (transfers (kinds as) s) V =\n       state_val (transfers (slice_kinds S (slice_edges S asx)) s) V", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use n'.\n     state_val (transfers (kinds as) s) V =\n     state_val (transfers (slice_kinds S (slice_edges S asx)) s) V\n\ngoal (1 subgoal):\n 1. slice_edges S as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') s \\<and>\n       (\\<forall>V\\<in>Use n'.\n           state_val (transfers (slice_kinds S as') s) V =\n           state_val (transfers (kinds as) s) V) \\<and>\n       slice_edges S as = slice_edges S as' \\<and> n -as'\\<rightarrow>* n'", "with \\<open>slice_edges S asx' = []\\<close>"], ["proof (chain)\npicking this:\n  slice_edges S asx' = []\n  \\<forall>V\\<in>Use n'.\n     state_val (transfers (kinds as) s) V =\n     state_val (transfers (slice_kinds S (slice_edges S asx)) s) V", "have \"\\<forall>V \\<in> Use n'. state_val (transfers (kinds as) s) V = \n      state_val (transfers (slice_kinds S (slice_edges S (asx@asx'))) s) V\""], ["proof (prove)\nusing this:\n  slice_edges S asx' = []\n  \\<forall>V\\<in>Use n'.\n     state_val (transfers (kinds as) s) V =\n     state_val (transfers (slice_kinds S (slice_edges S asx)) s) V\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use n'.\n       state_val (transfers (kinds as) s) V =\n       state_val (transfers (slice_kinds S (slice_edges S (asx @ asx'))) s)\n        V", "by(auto simp:slice_edges_def)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use n'.\n     state_val (transfers (kinds as) s) V =\n     state_val (transfers (slice_kinds S (slice_edges S (asx @ asx'))) s) V\n\ngoal (1 subgoal):\n 1. slice_edges S as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') s \\<and>\n       (\\<forall>V\\<in>Use n'.\n           state_val (transfers (slice_kinds S as') s) V =\n           state_val (transfers (kinds as) s) V) \\<and>\n       slice_edges S as = slice_edges S as' \\<and> n -as'\\<rightarrow>* n'", "hence \"\\<forall>V \\<in> Use n'. state_val (transfers (kinds as) s) V = \n      state_val (transfers (slice_kinds S (asx@asx')) s) V\""], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>Use n'.\n     state_val (transfers (kinds as) s) V =\n     state_val (transfers (slice_kinds S (slice_edges S (asx @ asx'))) s) V\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use n'.\n       state_val (transfers (kinds as) s) V =\n       state_val (transfers (slice_kinds S (asx @ asx')) s) V", "by(simp add:transfers_slice_kinds_slice_edges)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use n'.\n     state_val (transfers (kinds as) s) V =\n     state_val (transfers (slice_kinds S (asx @ asx')) s) V\n\ngoal (1 subgoal):\n 1. slice_edges S as \\<noteq> [] \\<Longrightarrow>\n    \\<exists>as'.\n       preds (slice_kinds S as') s \\<and>\n       (\\<forall>V\\<in>Use n'.\n           state_val (transfers (slice_kinds S as') s) V =\n           state_val (transfers (kinds as) s) V) \\<and>\n       slice_edges S as = slice_edges S as' \\<and> n -as'\\<rightarrow>* n'", "with \\<open>preds (slice_kinds S (asx@asx')) s\\<close> \\<open>n -asx@asx'\\<rightarrow>* n'\\<close>\n      \\<open>slice_edges S as = slice_edges S (asx@asx')\\<close>"], ["proof (chain)\npicking this:\n  preds (slice_kinds S (asx @ asx')) s\n  n -asx @ asx'\\<rightarrow>* n'\n  slice_edges S as = slice_edges S (asx @ asx')\n  \\<forall>V\\<in>Use n'.\n     state_val (transfers (kinds as) s) V =\n     state_val (transfers (slice_kinds S (asx @ asx')) s) V", "show ?thesis"], ["proof (prove)\nusing this:\n  preds (slice_kinds S (asx @ asx')) s\n  n -asx @ asx'\\<rightarrow>* n'\n  slice_edges S as = slice_edges S (asx @ asx')\n  \\<forall>V\\<in>Use n'.\n     state_val (transfers (kinds as) s) V =\n     state_val (transfers (slice_kinds S (asx @ asx')) s) V\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       preds (slice_kinds S as') s \\<and>\n       (\\<forall>V\\<in>Use n'.\n           state_val (transfers (slice_kinds S as') s) V =\n           state_val (transfers (kinds as) s) V) \\<and>\n       slice_edges S as = slice_edges S as' \\<and> n -as'\\<rightarrow>* n'", "by simp blast"], ["proof (state)\nthis:\n  \\<exists>as'.\n     preds (slice_kinds S as') s \\<and>\n     (\\<forall>V\\<in>Use n'.\n         state_val (transfers (slice_kinds S as') s) V =\n         state_val (transfers (kinds as) s) V) \\<and>\n     slice_edges S as = slice_edges S as' \\<and> n -as'\\<rightarrow>* n'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as'.\n     preds (slice_kinds S as') s \\<and>\n     (\\<forall>V\\<in>Use n'.\n         state_val (transfers (slice_kinds S as') s) V =\n         state_val (transfers (kinds as) s) V) \\<and>\n     slice_edges S as = slice_edges S as' \\<and> n -as'\\<rightarrow>* n'\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>The fundamental property of (static) slicing related to the semantics\\<close>"], ["", "locale BackwardSlice_wf = \n  BackwardSlice sourcenode targetnode kind valid_edge Entry Def Use state_val \n  backward_slice +\n  CFG_semantics_wf sourcenode targetnode kind valid_edge Entry sem identifies\n  for sourcenode :: \"'edge \\<Rightarrow> 'node\" and targetnode :: \"'edge \\<Rightarrow> 'node\"\n  and kind :: \"'edge \\<Rightarrow> 'state edge_kind\" and valid_edge :: \"'edge \\<Rightarrow> bool\"\n  and Entry :: \"'node\" (\"'('_Entry'_')\") and Def :: \"'node \\<Rightarrow> 'var set\"\n  and Use :: \"'node \\<Rightarrow> 'var set\" and state_val :: \"'state \\<Rightarrow> 'var \\<Rightarrow> 'val\"\n  and backward_slice :: \"'node set \\<Rightarrow> 'node set\" \n  and sem :: \"'com \\<Rightarrow> 'state \\<Rightarrow> 'com \\<Rightarrow> 'state \\<Rightarrow> bool\" \n    (\"((1\\<langle>_,/_\\<rangle>) \\<Rightarrow>/ (1\\<langle>_,/_\\<rangle>))\" [0,0,0,0] 81)\n  and identifies :: \"'node \\<Rightarrow> 'com \\<Rightarrow> bool\" (\"_ \\<triangleq> _\" [51, 0] 80)\n\nbegin"], ["", "theorem fundamental_property_of_path_slicing_semantically:\n  assumes \"n \\<triangleq> c\" and \"\\<langle>c,s\\<rangle> \\<Rightarrow> \\<langle>c',s'\\<rangle>\"\n  obtains n' as where \"n -as\\<rightarrow>* n'\" and \"preds (slice_kinds {n'} as) s\" and \"n' \\<triangleq> c'\"\n  and \"\\<forall>V \\<in> Use n'. state_val (transfers (slice_kinds {n'} as) s) V = state_val s' V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as n'.\n        \\<lbrakk>n -as\\<rightarrow>* n'; preds (slice_kinds {n'} as) s;\n         n' \\<triangleq> c';\n         \\<forall>V\\<in>Use n'.\n            state_val (transfers (slice_kinds {n'} as) s) V =\n            state_val s' V\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as n'.\n       n -as\\<rightarrow>* n' \\<and>\n       preds (slice_kinds {n'} as) s \\<and>\n       n' \\<triangleq> c' \\<and>\n       (\\<forall>V\\<in>Use n'.\n           state_val (transfers (slice_kinds {n'} as) s) V = state_val s' V)", "from \\<open>n \\<triangleq> c\\<close> \\<open>\\<langle>c,s\\<rangle> \\<Rightarrow> \\<langle>c',s'\\<rangle>\\<close>"], ["proof (chain)\npicking this:\n  n \\<triangleq> c\n  \\<langle>c,s\\<rangle> \\<Rightarrow> \\<langle>c',s'\\<rangle>", "obtain n' as where \"n -as\\<rightarrow>* n'\"\n    and \"transfers (kinds as) s = s'\" and \"preds (kinds as) s\" and \"n' \\<triangleq> c'\""], ["proof (prove)\nusing this:\n  n \\<triangleq> c\n  \\<langle>c,s\\<rangle> \\<Rightarrow> \\<langle>c',s'\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<And>as n'.\n        \\<lbrakk>n -as\\<rightarrow>* n'; transfers (kinds as) s = s';\n         preds (kinds as) s; n' \\<triangleq> c'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest:fundamental_property)"], ["proof (state)\nthis:\n  n -as\\<rightarrow>* n'\n  transfers (kinds as) s = s'\n  preds (kinds as) s\n  n' \\<triangleq> c'\n\ngoal (1 subgoal):\n 1. \\<exists>as n'.\n       n -as\\<rightarrow>* n' \\<and>\n       preds (slice_kinds {n'} as) s \\<and>\n       n' \\<triangleq> c' \\<and>\n       (\\<forall>V\\<in>Use n'.\n           state_val (transfers (slice_kinds {n'} as) s) V = state_val s' V)", "from \\<open>n -as\\<rightarrow>* n'\\<close> \\<open>preds (kinds as) s\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>* n'\n  preds (kinds as) s", "obtain as'\n    where \"preds (slice_kinds {n'} as') s\"\n    and vals:\"\\<forall>V \\<in> Use n'. state_val (transfers (slice_kinds {n'} as') s) V = \n    state_val (transfers (kinds as) s) V\" and \"n -as'\\<rightarrow>* n'\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>* n'\n  preds (kinds as) s\n\ngoal (1 subgoal):\n 1. (\\<And>as'.\n        \\<lbrakk>preds (slice_kinds {n'} as') s;\n         \\<forall>V\\<in>Use n'.\n            state_val (transfers (slice_kinds {n'} as') s) V =\n            state_val (transfers (kinds as) s) V;\n         n -as'\\<rightarrow>* n'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(erule fundamental_property_of_static_slicing,auto)"], ["proof (state)\nthis:\n  preds (slice_kinds {n'} as') s\n  \\<forall>V\\<in>Use n'.\n     state_val (transfers (slice_kinds {n'} as') s) V =\n     state_val (transfers (kinds as) s) V\n  n -as'\\<rightarrow>* n'\n\ngoal (1 subgoal):\n 1. \\<exists>as n'.\n       n -as\\<rightarrow>* n' \\<and>\n       preds (slice_kinds {n'} as) s \\<and>\n       n' \\<triangleq> c' \\<and>\n       (\\<forall>V\\<in>Use n'.\n           state_val (transfers (slice_kinds {n'} as) s) V = state_val s' V)", "from \\<open>transfers (kinds as) s = s'\\<close> vals"], ["proof (chain)\npicking this:\n  transfers (kinds as) s = s'\n  \\<forall>V\\<in>Use n'.\n     state_val (transfers (slice_kinds {n'} as') s) V =\n     state_val (transfers (kinds as) s) V", "have \"\\<forall>V \\<in> Use n'.\n    state_val (transfers (slice_kinds {n'} as') s) V = state_val s' V\""], ["proof (prove)\nusing this:\n  transfers (kinds as) s = s'\n  \\<forall>V\\<in>Use n'.\n     state_val (transfers (slice_kinds {n'} as') s) V =\n     state_val (transfers (kinds as) s) V\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use n'.\n       state_val (transfers (slice_kinds {n'} as') s) V = state_val s' V", "by simp"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use n'.\n     state_val (transfers (slice_kinds {n'} as') s) V = state_val s' V\n\ngoal (1 subgoal):\n 1. \\<exists>as n'.\n       n -as\\<rightarrow>* n' \\<and>\n       preds (slice_kinds {n'} as) s \\<and>\n       n' \\<triangleq> c' \\<and>\n       (\\<forall>V\\<in>Use n'.\n           state_val (transfers (slice_kinds {n'} as) s) V = state_val s' V)", "with \\<open>preds (slice_kinds {n'} as') s\\<close> \\<open>n -as'\\<rightarrow>* n'\\<close> \\<open> n' \\<triangleq> c'\\<close>"], ["proof (chain)\npicking this:\n  preds (slice_kinds {n'} as') s\n  n -as'\\<rightarrow>* n'\n  n' \\<triangleq> c'\n  \\<forall>V\\<in>Use n'.\n     state_val (transfers (slice_kinds {n'} as') s) V = state_val s' V", "show \"\\<exists>as n'. n -as\\<rightarrow>* n' \\<and> preds (slice_kinds {n'} as) s \\<and> n' \\<triangleq> c' \\<and>\n    (\\<forall>V\\<in>Use n'. state_val (transfers (slice_kinds {n'} as) s) V = state_val s' V)\""], ["proof (prove)\nusing this:\n  preds (slice_kinds {n'} as') s\n  n -as'\\<rightarrow>* n'\n  n' \\<triangleq> c'\n  \\<forall>V\\<in>Use n'.\n     state_val (transfers (slice_kinds {n'} as') s) V = state_val s' V\n\ngoal (1 subgoal):\n 1. \\<exists>as n'.\n       n -as\\<rightarrow>* n' \\<and>\n       preds (slice_kinds {n'} as) s \\<and>\n       n' \\<triangleq> c' \\<and>\n       (\\<forall>V\\<in>Use n'.\n           state_val (transfers (slice_kinds {n'} as) s) V = state_val s' V)", "by blast"], ["proof (state)\nthis:\n  \\<exists>as n'.\n     n -as\\<rightarrow>* n' \\<and>\n     preds (slice_kinds {n'} as) s \\<and>\n     n' \\<triangleq> c' \\<and>\n     (\\<forall>V\\<in>Use n'.\n         state_val (transfers (slice_kinds {n'} as) s) V = state_val s' V)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}