{"file_name": "/home/qj213/afp-2021-10-22/thys/Slicing/JinjaVM/JVMPostdomination.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Slicing", "problem_names": ["lemma distinct_classes'':\n  \"''C'' \\<noteq> Object\"\n  \"''C'' \\<noteq> NullPointer\"\n  \"''C'' \\<noteq> OutOfMemory\"\n  \"''C'' \\<noteq> ClassCast\"", "lemmas distinct_classes =\n  distinct_classes distinct_classes'' distinct_classes'' [symmetric]", "lemma i_max_2D: \"i < Suc (Suc 0) \\<Longrightarrow> i = 0 \\<or> i = 1\"", "lemma EP_wf: \"wf_jvm_prog\\<^bsub>Phi_EP\\<^esub> EP\"", "lemma [simp]: \"Abs_wf_jvmprog (EP, Phi_EP)\\<^bsub>wf\\<^esub> = EP\"", "lemma [simp]: \"Abs_wf_jvmprog (EP, Phi_EP)\\<^bsub>\\<Phi>\\<^esub> = Phi_EP\"", "lemma method_in_EP_is_M:\n  \"EP \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl, is, xt) in D\n  \\<Longrightarrow> C = ''C'' \\<and>\n     M = ''M'' \\<and>\n     Ts = [] \\<and>\n     T = Void \\<and>\n     mxs = 1 \\<and>\n     mxl = 0 \\<and>\n     is = [Push Unit, Return] \\<and>\n     xt = [] \\<and>\n     D = ''C''\"", "lemma [simp]:\n  \"\\<exists>T Ts mxs mxl is. (\\<exists>xt. EP \\<turnstile> ''C'' sees ''M'': Ts\\<rightarrow>T = (mxs, mxl, is, xt) in ''C'') \\<and> is \\<noteq> []\"", "lemma [simp]:\n  \"\\<exists>T Ts mxs mxl is. (\\<exists>xt. EP \\<turnstile> ''C'' sees ''M'': Ts\\<rightarrow>T = (mxs, mxl, is, xt) in ''C'') \\<and> \n  Suc 0 < length is\"", "lemma C_sees_M_in_EP [simp]:\n  \"EP \\<turnstile> ''C'' sees ''M'': []\\<rightarrow>Void = (1, 0, [Push Unit, Return], []) in ''C''\"", "lemma instrs_of_EP_C_M [simp]:\n  \"instrs_of EP ''C'' ''M'' = [Push Unit, Return]\"", "lemma valid_node_in_EP_D:\n  \"valid_node (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') n\n  \\<Longrightarrow> n \\<in> {(_Entry_), (_ [(''C'', ''M'', 0)],None _), (_ [(''C'', ''M'', 1)],None _), (_Exit_)}\"", "lemma EP_C_M_0_valid [simp]:\n  \"JVM_CFG_Interpret.valid_node (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') \n    (_ [(''C'', ''M'', 0)],None _)\"", "lemma EP_C_M_Suc_0_valid [simp]:\n  \"JVM_CFG_Interpret.valid_node (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') \n    (_ [(''C'', ''M'', Suc 0)],None _)\"", "lemma find_handler_for_tl_eq:\n  \"find_handler_for P Exc cs = (C,M,pcx)#cs' \\<Longrightarrow> \\<exists>cs'' pc. cs = cs'' @ [(C,M,pc)] @ cs'\"", "lemma valid_callstack_tl:\n  \"valid_callstack prog ((C,M,pc)#cs) \\<Longrightarrow> valid_callstack prog cs\"", "lemma find_handler_Throw_Invoke_pc_in_range:\n  \"\\<lbrakk>cs = (C',M',pc')#cs'; valid_callstack (P,C0,Main) cs;\n  instrs_of (P\\<^bsub>wf\\<^esub>) C' M' ! pc' = Throw \\<or> (\\<exists>M'' n''. instrs_of (P\\<^bsub>wf\\<^esub>) C' M' ! pc' = Invoke M'' n'');\n  find_handler_for P Exc cs = (C,M,pc)#cs'' \\<rbrakk>\n  \\<Longrightarrow> pc < length (instrs_of (P\\<^bsub>wf\\<^esub>) C M)\"", "lemma successor_set_finite:\n  \"JVM_CFG_Interpret.valid_node prog n \n  \\<Longrightarrow> finite {n'. \\<exists>a'. valid_edge prog a' \\<and> sourcenode a' = n \\<and>\n                      targetnode a' = n'}\""], "translations": [["", "lemma distinct_classes'':\n  \"''C'' \\<noteq> Object\"\n  \"''C'' \\<noteq> NullPointer\"\n  \"''C'' \\<noteq> OutOfMemory\"\n  \"''C'' \\<noteq> ClassCast\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (''C'' \\<noteq> Object &&& ''C'' \\<noteq> NullPointer) &&&\n    ''C'' \\<noteq> OutOfMemory &&& ''C'' \\<noteq> ClassCast", "by (simp_all add: Object_def NullPointer_def OutOfMemory_def ClassCast_def)"], ["", "lemmas distinct_classes =\n  distinct_classes distinct_classes'' distinct_classes'' [symmetric]"], ["", "declare distinct_classes [simp add]"], ["", "lemma i_max_2D: \"i < Suc (Suc 0) \\<Longrightarrow> i = 0 \\<or> i = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < Suc (Suc 0) \\<Longrightarrow> i = 0 \\<or> i = 1", "by auto"], ["", "lemma EP_wf: \"wf_jvm_prog\\<^bsub>Phi_EP\\<^esub> EP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_jvm_prog\\<^bsub>Phi_EP\\<^esub> EP", "unfolding wf_jvm_prog_phi_def wf_prog_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_syscls EP \\<and>\n    (\\<forall>c\\<in>set EP.\n        wf_cdecl\n         (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n             wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (Phi_EP C M))\n         EP c) \\<and>\n    distinct_fst EP", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. wf_syscls EP\n 2. (\\<forall>c\\<in>set EP.\n        wf_cdecl\n         (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n             wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (Phi_EP C M))\n         EP c) \\<and>\n    distinct_fst EP", "show \"wf_syscls EP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_syscls EP", "by (simp add: EP_def wf_syscls_def SystemClasses_def sys_xcpts_def\n                  ObjectC_def NullPointerC_def OutOfMemoryC_def ClassCastC_def)"], ["proof (state)\nthis:\n  wf_syscls EP\n\ngoal (1 subgoal):\n 1. (\\<forall>c\\<in>set EP.\n        wf_cdecl\n         (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n             wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (Phi_EP C M))\n         EP c) \\<and>\n    distinct_fst EP", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<forall>c\\<in>set EP.\n        wf_cdecl\n         (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n             wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (Phi_EP C M))\n         EP c) \\<and>\n    distinct_fst EP", "have distinct_EP: \"distinct_fst EP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct_fst EP", "by (auto simp:\n      EP_def SystemClasses_def ObjectC_def NullPointerC_def OutOfMemoryC_def ClassCastC_def)"], ["proof (state)\nthis:\n  distinct_fst EP\n\ngoal (1 subgoal):\n 1. (\\<forall>c\\<in>set EP.\n        wf_cdecl\n         (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n             wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (Phi_EP C M))\n         EP c) \\<and>\n    distinct_fst EP", "have classes_wf:\n    \"\\<forall>c\\<in>set EP.\n        wf_cdecl\n         (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt). wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (Phi_EP C M))\n         EP c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>set EP.\n       wf_cdecl\n        (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n            wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (Phi_EP C M))\n        EP c", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c.\n       c \\<in> set EP \\<Longrightarrow>\n       wf_cdecl\n        (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n            wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (Phi_EP C M))\n        EP c", "fix C"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c.\n       c \\<in> set EP \\<Longrightarrow>\n       wf_cdecl\n        (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n            wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (Phi_EP C M))\n        EP c", "assume C_in_EP: \"C \\<in> set EP\""], ["proof (state)\nthis:\n  C \\<in> set EP\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       c \\<in> set EP \\<Longrightarrow>\n       wf_cdecl\n        (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n            wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (Phi_EP C M))\n        EP c", "show \"wf_cdecl\n         (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt). wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (Phi_EP C M))\n         EP C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_cdecl\n     (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n         wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (Phi_EP C M))\n     EP C", "proof (cases \"C \\<in> set SystemClasses\")"], ["proof (state)\ngoal (2 subgoals):\n 1. C \\<in> set SystemClasses \\<Longrightarrow>\n    wf_cdecl\n     (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n         wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (Phi_EP C M))\n     EP C\n 2. C \\<notin> set SystemClasses \\<Longrightarrow>\n    wf_cdecl\n     (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n         wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (Phi_EP C M))\n     EP C", "case True"], ["proof (state)\nthis:\n  C \\<in> set SystemClasses\n\ngoal (2 subgoals):\n 1. C \\<in> set SystemClasses \\<Longrightarrow>\n    wf_cdecl\n     (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n         wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (Phi_EP C M))\n     EP C\n 2. C \\<notin> set SystemClasses \\<Longrightarrow>\n    wf_cdecl\n     (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n         wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (Phi_EP C M))\n     EP C", "thus ?thesis"], ["proof (prove)\nusing this:\n  C \\<in> set SystemClasses\n\ngoal (1 subgoal):\n 1. wf_cdecl\n     (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n         wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (Phi_EP C M))\n     EP C", "by (auto simp: wf_cdecl_def SystemClasses_def ObjectC_def NullPointerC_def\n                       OutOfMemoryC_def ClassCastC_def EP_def class_def)"], ["proof (state)\nthis:\n  wf_cdecl\n   (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n       wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (Phi_EP C M))\n   EP C\n\ngoal (1 subgoal):\n 1. C \\<notin> set SystemClasses \\<Longrightarrow>\n    wf_cdecl\n     (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n         wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (Phi_EP C M))\n     EP C", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. C \\<notin> set SystemClasses \\<Longrightarrow>\n    wf_cdecl\n     (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n         wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (Phi_EP C M))\n     EP C", "case False"], ["proof (state)\nthis:\n  C \\<notin> set SystemClasses\n\ngoal (1 subgoal):\n 1. C \\<notin> set SystemClasses \\<Longrightarrow>\n    wf_cdecl\n     (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n         wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (Phi_EP C M))\n     EP C", "with C_in_EP"], ["proof (chain)\npicking this:\n  C \\<in> set EP\n  C \\<notin> set SystemClasses", "have [simp]: \"C = (''C'', the (class EP ''C''))\""], ["proof (prove)\nusing this:\n  C \\<in> set EP\n  C \\<notin> set SystemClasses\n\ngoal (1 subgoal):\n 1. C = (''C'', the (class EP ''C''))", "by (auto simp: EP_def SystemClasses_def class_def)"], ["proof (state)\nthis:\n  C = (''C'', the (class EP ''C''))\n\ngoal (1 subgoal):\n 1. C \\<notin> set SystemClasses \\<Longrightarrow>\n    wf_cdecl\n     (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n         wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (Phi_EP C M))\n     EP C", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_cdecl\n     (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n         wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (Phi_EP C M))\n     EP C", "apply (auto dest!: i_max_2D\n                     simp: wf_cdecl_def class_def EP_def wf_mdecl_def wt_method_def Phi_EP_def\n                           wt_start_def check_types_def states_def JVM_SemiType.sl_def\n                           stk_esl_def upto_esl_def loc_sl_def SemiType.esl_def\n                           SemiType.sup_def Err.sl_def Err.le_def err_def Listn.sl_def\n                           Err.esl_def Opt.esl_def Product.esl_def relevant_entries_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<exists>a aa b.\n       map_of SystemClasses Object = \\<lfloor>(a, aa, b)\\<rfloor>\n 2. \\<And>D' Ts' T' a aa ab b.\n       (''C'', Object, [],\n        [(''M'', [], Void, Suc 0, 0, [Push Unit, Return], [])]) #\n       SystemClasses \\<turnstile> Object sees ''M'': Ts'\\<rightarrow>T' = (a,\n                                     aa, ab, b) in D' \\<Longrightarrow>\n       Ts' = []\n 3. \\<And>D' Ts' T' a aa ab b.\n       (''C'', Object, [],\n        [(''M'', [], Void, Suc 0, 0, [Push Unit, Return], [])]) #\n       SystemClasses \\<turnstile> Object sees ''M'': Ts'\\<rightarrow>T' = (a,\n                                     aa, ab, b) in D' \\<Longrightarrow>\n       T' = Void", "apply (fastforce simp: SystemClasses_def ObjectC_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>D' Ts' T' a aa ab b.\n       (''C'', Object, [],\n        [(''M'', [], Void, Suc 0, 0, [Push Unit, Return], [])]) #\n       SystemClasses \\<turnstile> Object sees ''M'': Ts'\\<rightarrow>T' = (a,\n                                     aa, ab, b) in D' \\<Longrightarrow>\n       Ts' = []\n 2. \\<And>D' Ts' T' a aa ab b.\n       (''C'', Object, [],\n        [(''M'', [], Void, Suc 0, 0, [Push Unit, Return], [])]) #\n       SystemClasses \\<turnstile> Object sees ''M'': Ts'\\<rightarrow>T' = (a,\n                                     aa, ab, b) in D' \\<Longrightarrow>\n       T' = Void", "apply (clarsimp simp: Method_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>D' Ts' T' a aa ab b Mm.\n       \\<lbrakk>(''C'', Object, [],\n                 [(''M'', [], Void, Suc 0, 0, [Push Unit, Return], [])]) #\n                SystemClasses \\<turnstile> Object sees_methods Mm;\n        Mm ''M'' = \\<lfloor>((Ts', T', a, aa, ab, b), D')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> Ts' = []\n 2. \\<And>D' Ts' T' a aa ab b.\n       (''C'', Object, [],\n        [(''M'', [], Void, Suc 0, 0, [Push Unit, Return], [])]) #\n       SystemClasses \\<turnstile> Object sees ''M'': Ts'\\<rightarrow>T' = (a,\n                                     aa, ab, b) in D' \\<Longrightarrow>\n       T' = Void", "apply (cases rule: Methods.cases,\n                (fastforce simp: class_def SystemClasses_def ObjectC_def)+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>D' Ts' T' a aa ab b.\n       (''C'', Object, [],\n        [(''M'', [], Void, Suc 0, 0, [Push Unit, Return], [])]) #\n       SystemClasses \\<turnstile> Object sees ''M'': Ts'\\<rightarrow>T' = (a,\n                                     aa, ab, b) in D' \\<Longrightarrow>\n       T' = Void", "apply (clarsimp simp: Method_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>D' Ts' T' a aa ab b Mm.\n       \\<lbrakk>(''C'', Object, [],\n                 [(''M'', [], Void, Suc 0, 0, [Push Unit, Return], [])]) #\n                SystemClasses \\<turnstile> Object sees_methods Mm;\n        Mm ''M'' = \\<lfloor>((Ts', T', a, aa, ab, b), D')\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> T' = Void", "by (cases rule: Methods.cases,\n            (fastforce simp: class_def SystemClasses_def ObjectC_def)+)"], ["proof (state)\nthis:\n  wf_cdecl\n   (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n       wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (Phi_EP C M))\n   EP C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wf_cdecl\n   (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n       wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (Phi_EP C M))\n   EP C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>c\\<in>set EP.\n     wf_cdecl\n      (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n          wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (Phi_EP C M))\n      EP c\n\ngoal (1 subgoal):\n 1. (\\<forall>c\\<in>set EP.\n        wf_cdecl\n         (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n             wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (Phi_EP C M))\n         EP c) \\<and>\n    distinct_fst EP", "with distinct_EP"], ["proof (chain)\npicking this:\n  distinct_fst EP\n  \\<forall>c\\<in>set EP.\n     wf_cdecl\n      (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n          wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (Phi_EP C M))\n      EP c", "show \"(\\<forall>c\\<in>set EP.\n    wf_cdecl\n      (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt). wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (Phi_EP C M))\n      EP c) \\<and>\n    distinct_fst EP\""], ["proof (prove)\nusing this:\n  distinct_fst EP\n  \\<forall>c\\<in>set EP.\n     wf_cdecl\n      (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n          wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (Phi_EP C M))\n      EP c\n\ngoal (1 subgoal):\n 1. (\\<forall>c\\<in>set EP.\n        wf_cdecl\n         (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n             wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (Phi_EP C M))\n         EP c) \\<and>\n    distinct_fst EP", "by simp"], ["proof (state)\nthis:\n  (\\<forall>c\\<in>set EP.\n      wf_cdecl\n       (\\<lambda>P C (M, Ts, T\\<^sub>r, mxs, mxl\\<^sub>0, is, xt).\n           wt_method P C Ts T\\<^sub>r mxs mxl\\<^sub>0 is xt (Phi_EP C M))\n       EP c) \\<and>\n  distinct_fst EP\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma [simp]: \"Abs_wf_jvmprog (EP, Phi_EP)\\<^bsub>wf\\<^esub> = EP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_wf_jvmprog (EP, Phi_EP)\\<^bsub>wf\\<^esub> = EP", "proof (cases \"(EP, Phi_EP) \\<in> wf_jvmprog\")"], ["proof (state)\ngoal (2 subgoals):\n 1. (EP, Phi_EP) \\<in> wf_jvmprog \\<Longrightarrow>\n    Abs_wf_jvmprog (EP, Phi_EP)\\<^bsub>wf\\<^esub> = EP\n 2. (EP, Phi_EP) \\<notin> wf_jvmprog \\<Longrightarrow>\n    Abs_wf_jvmprog (EP, Phi_EP)\\<^bsub>wf\\<^esub> = EP", "case True"], ["proof (state)\nthis:\n  (EP, Phi_EP) \\<in> wf_jvmprog\n\ngoal (2 subgoals):\n 1. (EP, Phi_EP) \\<in> wf_jvmprog \\<Longrightarrow>\n    Abs_wf_jvmprog (EP, Phi_EP)\\<^bsub>wf\\<^esub> = EP\n 2. (EP, Phi_EP) \\<notin> wf_jvmprog \\<Longrightarrow>\n    Abs_wf_jvmprog (EP, Phi_EP)\\<^bsub>wf\\<^esub> = EP", "thus ?thesis"], ["proof (prove)\nusing this:\n  (EP, Phi_EP) \\<in> wf_jvmprog\n\ngoal (1 subgoal):\n 1. Abs_wf_jvmprog (EP, Phi_EP)\\<^bsub>wf\\<^esub> = EP", "by (simp add: Abs_wf_jvmprog_inverse)"], ["proof (state)\nthis:\n  Abs_wf_jvmprog (EP, Phi_EP)\\<^bsub>wf\\<^esub> = EP\n\ngoal (1 subgoal):\n 1. (EP, Phi_EP) \\<notin> wf_jvmprog \\<Longrightarrow>\n    Abs_wf_jvmprog (EP, Phi_EP)\\<^bsub>wf\\<^esub> = EP", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (EP, Phi_EP) \\<notin> wf_jvmprog \\<Longrightarrow>\n    Abs_wf_jvmprog (EP, Phi_EP)\\<^bsub>wf\\<^esub> = EP", "case False"], ["proof (state)\nthis:\n  (EP, Phi_EP) \\<notin> wf_jvmprog\n\ngoal (1 subgoal):\n 1. (EP, Phi_EP) \\<notin> wf_jvmprog \\<Longrightarrow>\n    Abs_wf_jvmprog (EP, Phi_EP)\\<^bsub>wf\\<^esub> = EP", "with EP_wf"], ["proof (chain)\npicking this:\n  wf_jvm_prog\\<^bsub>Phi_EP\\<^esub> EP\n  (EP, Phi_EP) \\<notin> wf_jvmprog", "show ?thesis"], ["proof (prove)\nusing this:\n  wf_jvm_prog\\<^bsub>Phi_EP\\<^esub> EP\n  (EP, Phi_EP) \\<notin> wf_jvmprog\n\ngoal (1 subgoal):\n 1. Abs_wf_jvmprog (EP, Phi_EP)\\<^bsub>wf\\<^esub> = EP", "by (simp add: wf_jvmprog_def)"], ["proof (state)\nthis:\n  Abs_wf_jvmprog (EP, Phi_EP)\\<^bsub>wf\\<^esub> = EP\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma [simp]: \"Abs_wf_jvmprog (EP, Phi_EP)\\<^bsub>\\<Phi>\\<^esub> = Phi_EP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_wf_jvmprog (EP, Phi_EP)\\<^bsub>\\<Phi>\\<^esub> = Phi_EP", "proof (cases \"(EP, Phi_EP) \\<in> wf_jvmprog\")"], ["proof (state)\ngoal (2 subgoals):\n 1. (EP, Phi_EP) \\<in> wf_jvmprog \\<Longrightarrow>\n    Abs_wf_jvmprog (EP, Phi_EP)\\<^bsub>\\<Phi>\\<^esub> = Phi_EP\n 2. (EP, Phi_EP) \\<notin> wf_jvmprog \\<Longrightarrow>\n    Abs_wf_jvmprog (EP, Phi_EP)\\<^bsub>\\<Phi>\\<^esub> = Phi_EP", "case True"], ["proof (state)\nthis:\n  (EP, Phi_EP) \\<in> wf_jvmprog\n\ngoal (2 subgoals):\n 1. (EP, Phi_EP) \\<in> wf_jvmprog \\<Longrightarrow>\n    Abs_wf_jvmprog (EP, Phi_EP)\\<^bsub>\\<Phi>\\<^esub> = Phi_EP\n 2. (EP, Phi_EP) \\<notin> wf_jvmprog \\<Longrightarrow>\n    Abs_wf_jvmprog (EP, Phi_EP)\\<^bsub>\\<Phi>\\<^esub> = Phi_EP", "thus ?thesis"], ["proof (prove)\nusing this:\n  (EP, Phi_EP) \\<in> wf_jvmprog\n\ngoal (1 subgoal):\n 1. Abs_wf_jvmprog (EP, Phi_EP)\\<^bsub>\\<Phi>\\<^esub> = Phi_EP", "by (simp add: Abs_wf_jvmprog_inverse)"], ["proof (state)\nthis:\n  Abs_wf_jvmprog (EP, Phi_EP)\\<^bsub>\\<Phi>\\<^esub> = Phi_EP\n\ngoal (1 subgoal):\n 1. (EP, Phi_EP) \\<notin> wf_jvmprog \\<Longrightarrow>\n    Abs_wf_jvmprog (EP, Phi_EP)\\<^bsub>\\<Phi>\\<^esub> = Phi_EP", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (EP, Phi_EP) \\<notin> wf_jvmprog \\<Longrightarrow>\n    Abs_wf_jvmprog (EP, Phi_EP)\\<^bsub>\\<Phi>\\<^esub> = Phi_EP", "case False"], ["proof (state)\nthis:\n  (EP, Phi_EP) \\<notin> wf_jvmprog\n\ngoal (1 subgoal):\n 1. (EP, Phi_EP) \\<notin> wf_jvmprog \\<Longrightarrow>\n    Abs_wf_jvmprog (EP, Phi_EP)\\<^bsub>\\<Phi>\\<^esub> = Phi_EP", "with EP_wf"], ["proof (chain)\npicking this:\n  wf_jvm_prog\\<^bsub>Phi_EP\\<^esub> EP\n  (EP, Phi_EP) \\<notin> wf_jvmprog", "show ?thesis"], ["proof (prove)\nusing this:\n  wf_jvm_prog\\<^bsub>Phi_EP\\<^esub> EP\n  (EP, Phi_EP) \\<notin> wf_jvmprog\n\ngoal (1 subgoal):\n 1. Abs_wf_jvmprog (EP, Phi_EP)\\<^bsub>\\<Phi>\\<^esub> = Phi_EP", "by (simp add: wf_jvmprog_def)"], ["proof (state)\nthis:\n  Abs_wf_jvmprog (EP, Phi_EP)\\<^bsub>\\<Phi>\\<^esub> = Phi_EP\n\ngoal:\nNo subgoals!", "qed"], ["", "(*\nlemma sees_method_instruct_listD:\n  \"((C, D, Fds, (((M::char list), (Ts:: ty list), (T:: ty), mxs, mxl, is, xt) # meths) ) # cs) \\<turnstile> C sees M: Tsa\\<rightarrow>Ta = (mxsa, mxla, isa, xta) in C \\<Longrightarrow> mxsa = mxs \\<and> mxla = mxl \\<and> xta = xt \\<and> isa = is\"\napply (clarsimp simp: Method_def)\napply (erule Methods.cases)\n apply (clarsimp simp: class_def)\nby (clarsimp simp: class_def)\n*)"], ["", "lemma method_in_EP_is_M:\n  \"EP \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl, is, xt) in D\n  \\<Longrightarrow> C = ''C'' \\<and>\n     M = ''M'' \\<and>\n     Ts = [] \\<and>\n     T = Void \\<and>\n     mxs = 1 \\<and>\n     mxl = 0 \\<and>\n     is = [Push Unit, Return] \\<and>\n     xt = [] \\<and>\n     D = ''C''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. EP \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl, is,\n            xt) in D \\<Longrightarrow>\n    C = ''C'' \\<and>\n    M = ''M'' \\<and>\n    Ts = [] \\<and>\n    T = Void \\<and>\n    mxs = 1 \\<and>\n    mxl = 0 \\<and> is = [Push Unit, Return] \\<and> xt = [] \\<and> D = ''C''", "apply (clarsimp simp: Method_def EP_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Mm.\n       \\<lbrakk>(''C'', Object, [],\n                 [(''M'', [], Void, Suc 0, 0, [Push Unit, Return], [])]) #\n                SystemClasses \\<turnstile> C sees_methods Mm;\n        Mm M = \\<lfloor>((Ts, T, mxs, mxl, is, xt), D)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> C = ''C'' \\<and>\n                         M = ''M'' \\<and>\n                         Ts = [] \\<and>\n                         T = Void \\<and>\n                         mxs = Suc 0 \\<and>\n                         mxl = 0 \\<and>\n                         is = [Push Unit, Return] \\<and>\n                         xt = [] \\<and> D = ''C''", "apply (erule Methods.cases, clarsimp simp: class_def SystemClasses_def ObjectC_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Mm Ca Da fs ms Mma Mm'.\n       \\<lbrakk>Mm M = \\<lfloor>((Ts, T, mxs, mxl, is, xt), D)\\<rfloor>;\n        C = Ca; Mm = Mm';\n        class\n         ((''C'', Object, [],\n           [(''M'', [], Void, Suc 0, 0, [Push Unit, Return], [])]) #\n          SystemClasses)\n         Ca =\n        \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        Ca \\<noteq> Object;\n        (''C'', Object, [],\n         [(''M'', [], Void, Suc 0, 0, [Push Unit, Return], [])]) #\n        SystemClasses \\<turnstile> Da sees_methods Mma;\n        Mm' =\n        Mma ++ (map_option (\\<lambda>m. (m, Ca)) \\<circ> map_of ms)\\<rbrakk>\n       \\<Longrightarrow> C = ''C'' \\<and>\n                         M = ''M'' \\<and>\n                         Ts = [] \\<and>\n                         T = Void \\<and>\n                         mxs = Suc 0 \\<and>\n                         mxl = 0 \\<and>\n                         is = [Push Unit, Return] \\<and>\n                         xt = [] \\<and> D = ''C''", "apply (clarsimp simp: class_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Da fs ms Mma.\n       \\<lbrakk>(if C = ''C''\n                 then \\<lfloor>(Object, [],\n                                [(''M'', [], Void, Suc 0, 0,\n                                  [Push Unit, Return], [])])\\<rfloor>\n                 else map_of SystemClasses C) =\n                \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        C \\<noteq> Object;\n        (''C'', Object, [],\n         [(''M'', [], Void, Suc 0, 0, [Push Unit, Return], [])]) #\n        SystemClasses \\<turnstile> Da sees_methods Mma;\n        map_of ms M = \\<lfloor>(Ts, T, mxs, mxl, is, xt)\\<rfloor> \\<and>\n        C = D \\<or>\n        map_of ms M = None \\<and>\n        Mma M = \\<lfloor>((Ts, T, mxs, mxl, is, xt), D)\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> C = ''C'' \\<and>\n                         M = ''M'' \\<and>\n                         Ts = [] \\<and>\n                         T = Void \\<and>\n                         mxs = Suc 0 \\<and>\n                         mxl = 0 \\<and>\n                         is = [Push Unit, Return] \\<and>\n                         xt = [] \\<and> D = ''C''", "apply (erule Methods.cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Da fs ms Mma Daa fsa msa Mm.\n       \\<lbrakk>(if C = ''C''\n                 then \\<lfloor>(Object, [],\n                                [(''M'', [], Void, Suc 0, 0,\n                                  [Push Unit, Return], [])])\\<rfloor>\n                 else map_of SystemClasses C) =\n                \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        C \\<noteq> Object;\n        map_of ms M = \\<lfloor>(Ts, T, mxs, mxl, is, xt)\\<rfloor> \\<and>\n        C = D \\<or>\n        map_of ms M = None \\<and>\n        Mma M = \\<lfloor>((Ts, T, mxs, mxl, is, xt), D)\\<rfloor>;\n        Da = Object; Mma = Mm;\n        class\n         ((''C'', Object, [],\n           [(''M'', [], Void, Suc 0, 0, [Push Unit, Return], [])]) #\n          SystemClasses)\n         Object =\n        \\<lfloor>(Daa, fsa, msa)\\<rfloor>;\n        Mm =\n        map_option (\\<lambda>m. (m, Object)) \\<circ> map_of msa\\<rbrakk>\n       \\<Longrightarrow> C = ''C'' \\<and>\n                         M = ''M'' \\<and>\n                         Ts = [] \\<and>\n                         T = Void \\<and>\n                         mxs = Suc 0 \\<and>\n                         mxl = 0 \\<and>\n                         is = [Push Unit, Return] \\<and>\n                         xt = [] \\<and> D = ''C''\n 2. \\<And>Da fs ms Mma Ca Daa fsa msa Mm Mm'.\n       \\<lbrakk>(if C = ''C''\n                 then \\<lfloor>(Object, [],\n                                [(''M'', [], Void, Suc 0, 0,\n                                  [Push Unit, Return], [])])\\<rfloor>\n                 else map_of SystemClasses C) =\n                \\<lfloor>(Da, fs, ms)\\<rfloor>;\n        C \\<noteq> Object;\n        map_of ms M = \\<lfloor>(Ts, T, mxs, mxl, is, xt)\\<rfloor> \\<and>\n        C = D \\<or>\n        map_of ms M = None \\<and>\n        Mma M = \\<lfloor>((Ts, T, mxs, mxl, is, xt), D)\\<rfloor>;\n        Da = Ca; Mma = Mm';\n        class\n         ((''C'', Object, [],\n           [(''M'', [], Void, Suc 0, 0, [Push Unit, Return], [])]) #\n          SystemClasses)\n         Ca =\n        \\<lfloor>(Daa, fsa, msa)\\<rfloor>;\n        Ca \\<noteq> Object;\n        (''C'', Object, [],\n         [(''M'', [], Void, Suc 0, 0, [Push Unit, Return], [])]) #\n        SystemClasses \\<turnstile> Daa sees_methods Mm;\n        Mm' =\n        Mm ++ (map_option (\\<lambda>m. (m, Ca)) \\<circ> map_of msa)\\<rbrakk>\n       \\<Longrightarrow> C = ''C'' \\<and>\n                         M = ''M'' \\<and>\n                         Ts = [] \\<and>\n                         T = Void \\<and>\n                         mxs = Suc 0 \\<and>\n                         mxl = 0 \\<and>\n                         is = [Push Unit, Return] \\<and>\n                         xt = [] \\<and> D = ''C''", "by (fastforce simp: class_def SystemClasses_def ObjectC_def NullPointerC_def\n                       OutOfMemoryC_def ClassCastC_def if_split_eq1)+"], ["", "lemma [simp]:\n  \"\\<exists>T Ts mxs mxl is. (\\<exists>xt. EP \\<turnstile> ''C'' sees ''M'': Ts\\<rightarrow>T = (mxs, mxl, is, xt) in ''C'') \\<and> is \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>T Ts mxs mxl is.\n       (\\<exists>xt.\n           EP \\<turnstile> ''C'' sees ''M'': Ts\\<rightarrow>T = (mxs, mxl,\n                           is, xt) in ''C'') \\<and>\n       is \\<noteq> []", "using EP_wf"], ["proof (prove)\nusing this:\n  wf_jvm_prog\\<^bsub>Phi_EP\\<^esub> EP\n\ngoal (1 subgoal):\n 1. \\<exists>T Ts mxs mxl is.\n       (\\<exists>xt.\n           EP \\<turnstile> ''C'' sees ''M'': Ts\\<rightarrow>T = (mxs, mxl,\n                           is, xt) in ''C'') \\<and>\n       is \\<noteq> []", "by (fastforce dest: mdecl_visible simp: wf_jvm_prog_phi_def EP_def)"], ["", "lemma [simp]:\n  \"\\<exists>T Ts mxs mxl is. (\\<exists>xt. EP \\<turnstile> ''C'' sees ''M'': Ts\\<rightarrow>T = (mxs, mxl, is, xt) in ''C'') \\<and> \n  Suc 0 < length is\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>T Ts mxs mxl is.\n       (\\<exists>xt.\n           EP \\<turnstile> ''C'' sees ''M'': Ts\\<rightarrow>T = (mxs, mxl,\n                           is, xt) in ''C'') \\<and>\n       Suc 0 < length is", "using EP_wf"], ["proof (prove)\nusing this:\n  wf_jvm_prog\\<^bsub>Phi_EP\\<^esub> EP\n\ngoal (1 subgoal):\n 1. \\<exists>T Ts mxs mxl is.\n       (\\<exists>xt.\n           EP \\<turnstile> ''C'' sees ''M'': Ts\\<rightarrow>T = (mxs, mxl,\n                           is, xt) in ''C'') \\<and>\n       Suc 0 < length is", "by (fastforce dest: mdecl_visible simp: wf_jvm_prog_phi_def EP_def)"], ["", "lemma C_sees_M_in_EP [simp]:\n  \"EP \\<turnstile> ''C'' sees ''M'': []\\<rightarrow>Void = (1, 0, [Push Unit, Return], []) in ''C''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. EP \\<turnstile> ''C'' sees ''M'': []\\<rightarrow>Void = (1, 0,\n                       [Push Unit, Return], []) in ''C''", "apply (auto simp: Method_def EP_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Mm.\n       (''C'', Object, [],\n        [(''M'', [], Void, Suc 0, 0, [Push Unit, Return], [])]) #\n       SystemClasses \\<turnstile> ''C'' sees_methods Mm \\<and>\n       Mm ''M'' =\n       \\<lfloor>(([], Void, Suc 0, 0, [Push Unit, Return], []),\n                 ''C'')\\<rfloor>", "apply (rule_tac x=\"Map.empty(''M'' \\<mapsto> (([], Void, 1, 0, [Push Unit, Return], []),''C''))\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (''C'', Object, [],\n     [(''M'', [], Void, Suc 0, 0, [Push Unit, Return], [])]) #\n    SystemClasses \\<turnstile> ''C'' sees_methods [''M'' \\<mapsto>\n             (([], Void, 1, 0, [Push Unit, Return], []), ''C'')] \\<and>\n    [''M'' \\<mapsto> (([], Void, 1, 0, [Push Unit, Return], []), ''C'')]\n     ''M'' =\n    \\<lfloor>(([], Void, Suc 0, 0, [Push Unit, Return], []), ''C'')\\<rfloor>", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. (''C'', Object, [],\n     [(''M'', [], Void, Suc 0, 0, [Push Unit, Return], [])]) #\n    SystemClasses \\<turnstile> ''C'' sees_methods [''M'' \\<mapsto>\n             (([], Void, Suc 0, 0, [Push Unit, Return], []), ''C'')]", "apply (rule Methods.intros(2))"], ["proof (prove)\ngoal (4 subgoals):\n 1. class\n     ((''C'', Object, [],\n       [(''M'', [], Void, Suc 0, 0, [Push Unit, Return], [])]) #\n      SystemClasses)\n     ''C'' =\n    \\<lfloor>(?D3, ?fs3, ?ms3)\\<rfloor>\n 2. ''C'' \\<noteq> Object\n 3. (''C'', Object, [],\n     [(''M'', [], Void, Suc 0, 0, [Push Unit, Return], [])]) #\n    SystemClasses \\<turnstile> ?D3 sees_methods ?Mm3\n 4. [''M'' \\<mapsto>\n     (([], Void, Suc 0, 0, [Push Unit, Return], []), ''C'')] =\n    ?Mm3 ++ (map_option (\\<lambda>m. (m, ''C'')) \\<circ> map_of ?ms3)", "apply (fastforce simp: class_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ''C'' \\<noteq> Object\n 2. (''C'', Object, [],\n     [(''M'', [], Void, Suc 0, 0, [Push Unit, Return], [])]) #\n    SystemClasses \\<turnstile> Object sees_methods ?Mm3\n 3. [''M'' \\<mapsto>\n     (([], Void, Suc 0, 0, [Push Unit, Return], []), ''C'')] =\n    ?Mm3 ++\n    (map_option (\\<lambda>m. (m, ''C'')) \\<circ>\n     map_of [(''M'', [], Void, Suc 0, 0, [Push Unit, Return], [])])", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. (''C'', Object, [],\n     [(''M'', [], Void, Suc 0, 0, [Push Unit, Return], [])]) #\n    SystemClasses \\<turnstile> Object sees_methods ?Mm3\n 2. [''M'' \\<mapsto>\n     (([], Void, Suc 0, 0, [Push Unit, Return], []), ''C'')] =\n    ?Mm3 ++\n    (map_option (\\<lambda>m. (m, ''C'')) \\<circ>\n     map_of [(''M'', [], Void, Suc 0, 0, [Push Unit, Return], [])])", "apply (rule Methods.intros(1))"], ["proof (prove)\ngoal (3 subgoals):\n 1. class\n     ((''C'', Object, [],\n       [(''M'', [], Void, Suc 0, 0, [Push Unit, Return], [])]) #\n      SystemClasses)\n     Object =\n    \\<lfloor>(?D15, ?fs15, ?ms15)\\<rfloor>\n 2. ?Mm3 = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of ?ms15\n 3. [''M'' \\<mapsto>\n     (([], Void, Suc 0, 0, [Push Unit, Return], []), ''C'')] =\n    ?Mm3 ++\n    (map_option (\\<lambda>m. (m, ''C'')) \\<circ>\n     map_of [(''M'', [], Void, Suc 0, 0, [Push Unit, Return], [])])", "apply (fastforce simp: class_def SystemClasses_def ObjectC_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ?Mm3 = map_option (\\<lambda>m. (m, Object)) \\<circ> map_of []\n 2. [''M'' \\<mapsto>\n     (([], Void, Suc 0, 0, [Push Unit, Return], []), ''C'')] =\n    ?Mm3 ++\n    (map_option (\\<lambda>m. (m, ''C'')) \\<circ>\n     map_of [(''M'', [], Void, Suc 0, 0, [Push Unit, Return], [])])", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. [''M'' \\<mapsto>\n     (([], Void, Suc 0, 0, [Push Unit, Return], []), ''C'')] =\n    Map.empty ++\n    (map_option (\\<lambda>m. (m, ''C'')) \\<circ>\n     map_of [(''M'', [], Void, Suc 0, 0, [Push Unit, Return], [])])", "by fastforce"], ["", "lemma instrs_of_EP_C_M [simp]:\n  \"instrs_of EP ''C'' ''M'' = [Push Unit, Return]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. instrs_of EP ''C'' ''M'' = [Push Unit, Return]", "using C_sees_M_in_EP"], ["proof (prove)\nusing this:\n  EP \\<turnstile> ''C'' sees ''M'': []\\<rightarrow>Void = (1, 0,\n                     [Push Unit, Return], []) in ''C''\n\ngoal (1 subgoal):\n 1. instrs_of EP ''C'' ''M'' = [Push Unit, Return]", "apply (simp add: method_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. EP \\<turnstile> ''C'' sees ''M'': []\\<rightarrow>Void = (Suc 0, 0,\n                       [Push Unit, Return], []) in ''C'' \\<Longrightarrow>\n    fst (snd (snd (snd (snd (snd (THE (D, Ts, T, m).\n                                     EP \\<turnstile> ''C'' sees ''M'': Ts\\<rightarrow>T = m in D)))))) =\n    [Push Unit, Return]", "apply (rule theI2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. EP \\<turnstile> ''C'' sees ''M'': []\\<rightarrow>Void = (Suc 0, 0,\n                       [Push Unit, Return], []) in ''C'' \\<Longrightarrow>\n    case ?a1 of\n    (D, Ts, T, m) \\<Rightarrow>\n      EP \\<turnstile> ''C'' sees ''M'': Ts\\<rightarrow>T = m in D\n 2. \\<And>x.\n       \\<lbrakk>EP \\<turnstile> ''C'' sees ''M'': []\\<rightarrow>Void = (Suc\n                                    0,\n                                   0, [Push Unit, Return], []) in ''C'';\n        case x of\n        (D, Ts, T, m) \\<Rightarrow>\n          EP \\<turnstile> ''C'' sees ''M'': Ts\\<rightarrow>T = m in D\\<rbrakk>\n       \\<Longrightarrow> x = ?a1\n 3. \\<And>x.\n       \\<lbrakk>EP \\<turnstile> ''C'' sees ''M'': []\\<rightarrow>Void = (Suc\n                                    0,\n                                   0, [Push Unit, Return], []) in ''C'';\n        case x of\n        (D, Ts, T, m) \\<Rightarrow>\n          EP \\<turnstile> ''C'' sees ''M'': Ts\\<rightarrow>T = m in D\\<rbrakk>\n       \\<Longrightarrow> fst (snd (snd (snd (snd (snd x))))) =\n                         [Push Unit, Return]", "apply fastforce"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>EP \\<turnstile> ''C'' sees ''M'': []\\<rightarrow>Void = (Suc\n                                    0,\n                                   0, [Push Unit, Return], []) in ''C'';\n        case x of\n        (D, Ts, T, m) \\<Rightarrow>\n          EP \\<turnstile> ''C'' sees ''M'': Ts\\<rightarrow>T = m in D\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (''C'', [], Void, Suc 0, 0, [Push Unit, Return],\n                          [])\n 2. \\<And>x.\n       \\<lbrakk>EP \\<turnstile> ''C'' sees ''M'': []\\<rightarrow>Void = (Suc\n                                    0,\n                                   0, [Push Unit, Return], []) in ''C'';\n        case x of\n        (D, Ts, T, m) \\<Rightarrow>\n          EP \\<turnstile> ''C'' sees ''M'': Ts\\<rightarrow>T = m in D\\<rbrakk>\n       \\<Longrightarrow> fst (snd (snd (snd (snd (snd x))))) =\n                         [Push Unit, Return]", "apply (clarsimp dest!: method_in_EP_is_M)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>EP \\<turnstile> ''C'' sees ''M'': []\\<rightarrow>Void = (Suc\n                                    0,\n                                   0, [Push Unit, Return], []) in ''C'';\n        case x of\n        (D, Ts, T, m) \\<Rightarrow>\n          EP \\<turnstile> ''C'' sees ''M'': Ts\\<rightarrow>T = m in D\\<rbrakk>\n       \\<Longrightarrow> fst (snd (snd (snd (snd (snd x))))) =\n                         [Push Unit, Return]", "by (clarsimp dest!: method_in_EP_is_M)"], ["", "(*\nlemma valid_cs_seesM_D: \n  \"valid_callstack (P, C0, Main) ((C, M, pc)#cs) \\<Longrightarrow>\n  \\<exists>Ts T mxs mxl is xt. (P\\<^bsub>wf\\<^esub>) \\<turnstile> C sees M:Ts\\<rightarrow>T=(mxs, mxl, is, xt) in C \\<and> pc < length is\"\n  by (cases cs, fastforce+)\n*)"], ["", "lemma valid_node_in_EP_D:\n  \"valid_node (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') n\n  \\<Longrightarrow> n \\<in> {(_Entry_), (_ [(''C'', ''M'', 0)],None _), (_ [(''C'', ''M'', 1)],None _), (_Exit_)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_node (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n     n \\<Longrightarrow>\n    n \\<in> {(_Entry_), (_ [(''C'', ''M'', 0)],None _),\n             (_ [(''C'', ''M'', 1)],None _), (_Exit_)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. valid_node (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n     n \\<Longrightarrow>\n    n \\<in> {(_Entry_), (_ [(''C'', ''M'', 0)],None _),\n             (_ [(''C'', ''M'', 1)],None _), (_Exit_)}", "assume vn: \"valid_node (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') n\""], ["proof (state)\nthis:\n  valid_node (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') n\n\ngoal (1 subgoal):\n 1. valid_node (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n     n \\<Longrightarrow>\n    n \\<in> {(_Entry_), (_ [(''C'', ''M'', 0)],None _),\n             (_ [(''C'', ''M'', 1)],None _), (_Exit_)}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<in> {(_Entry_), (_ [(''C'', ''M'', 0)],None _),\n             (_ [(''C'', ''M'', 1)],None _), (_Exit_)}", "proof (cases n)"], ["proof (state)\ngoal (2 subgoals):\n 1. n = (_Entry_) \\<Longrightarrow>\n    n \\<in> {(_Entry_), (_ [(''C'', ''M'', 0)],None _),\n             (_ [(''C'', ''M'', 1)],None _), (_Exit_)}\n 2. \\<And>x21 x22.\n       n = (_ x21,x22 _) \\<Longrightarrow>\n       n \\<in> {(_Entry_), (_ [(''C'', ''M'', 0)],None _),\n                (_ [(''C'', ''M'', 1)],None _), (_Exit_)}", "case Entry"], ["proof (state)\nthis:\n  n = (_Entry_)\n\ngoal (2 subgoals):\n 1. n = (_Entry_) \\<Longrightarrow>\n    n \\<in> {(_Entry_), (_ [(''C'', ''M'', 0)],None _),\n             (_ [(''C'', ''M'', 1)],None _), (_Exit_)}\n 2. \\<And>x21 x22.\n       n = (_ x21,x22 _) \\<Longrightarrow>\n       n \\<in> {(_Entry_), (_ [(''C'', ''M'', 0)],None _),\n                (_ [(''C'', ''M'', 1)],None _), (_Exit_)}", "thus ?thesis"], ["proof (prove)\nusing this:\n  n = (_Entry_)\n\ngoal (1 subgoal):\n 1. n \\<in> {(_Entry_), (_ [(''C'', ''M'', 0)],None _),\n             (_ [(''C'', ''M'', 1)],None _), (_Exit_)}", "by simp"], ["proof (state)\nthis:\n  n \\<in> {(_Entry_), (_ [(''C'', ''M'', 0)],None _),\n           (_ [(''C'', ''M'', 1)],None _), (_Exit_)}\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       n = (_ x21,x22 _) \\<Longrightarrow>\n       n \\<in> {(_Entry_), (_ [(''C'', ''M'', 0)],None _),\n                (_ [(''C'', ''M'', 1)],None _), (_Exit_)}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       n = (_ x21,x22 _) \\<Longrightarrow>\n       n \\<in> {(_Entry_), (_ [(''C'', ''M'', 0)],None _),\n                (_ [(''C'', ''M'', 1)],None _), (_Exit_)}", "case [simp]: (Node cs opt)"], ["proof (state)\nthis:\n  n = (_ cs,opt _)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       n = (_ x21,x22 _) \\<Longrightarrow>\n       n \\<in> {(_Entry_), (_ [(''C'', ''M'', 0)],None _),\n                (_ [(''C'', ''M'', 1)],None _), (_Exit_)}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<in> {(_Entry_), (_ [(''C'', ''M'', 0)],None _),\n             (_ [(''C'', ''M'', 1)],None _), (_Exit_)}", "proof (cases opt)"], ["proof (state)\ngoal (2 subgoals):\n 1. opt = None \\<Longrightarrow>\n    n \\<in> {(_Entry_), (_ [(''C'', ''M'', 0)],None _),\n             (_ [(''C'', ''M'', 1)],None _), (_Exit_)}\n 2. \\<And>a.\n       opt = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       n \\<in> {(_Entry_), (_ [(''C'', ''M'', 0)],None _),\n                (_ [(''C'', ''M'', 1)],None _), (_Exit_)}", "case [simp]: None"], ["proof (state)\nthis:\n  opt = None\n\ngoal (2 subgoals):\n 1. opt = None \\<Longrightarrow>\n    n \\<in> {(_Entry_), (_ [(''C'', ''M'', 0)],None _),\n             (_ [(''C'', ''M'', 1)],None _), (_Exit_)}\n 2. \\<And>a.\n       opt = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       n \\<in> {(_Entry_), (_ [(''C'', ''M'', 0)],None _),\n                (_ [(''C'', ''M'', 1)],None _), (_Exit_)}", "from vn"], ["proof (chain)\npicking this:\n  valid_node (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') n", "show ?thesis"], ["proof (prove)\nusing this:\n  valid_node (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') n\n\ngoal (1 subgoal):\n 1. n \\<in> {(_Entry_), (_ [(''C'', ''M'', 0)],None _),\n             (_ [(''C'', ''M'', 1)],None _), (_Exit_)}", "apply (cases cs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>valid_node (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') n;\n     cs = []\\<rbrakk>\n    \\<Longrightarrow> n \\<in> {(_Entry_), (_ [(''C'', ''M'', 0)],None _),\n                               (_ [(''C'', ''M'', 1)],None _), (_Exit_)}\n 2. \\<And>a list.\n       \\<lbrakk>valid_node (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') n;\n        cs = a # list\\<rbrakk>\n       \\<Longrightarrow> n \\<in> {(_Entry_), (_ [(''C'', ''M'', 0)],None _),\n                                  (_ [(''C'', ''M'', 1)],None _), (_Exit_)}", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>valid_node (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') n;\n        cs = a # list\\<rbrakk>\n       \\<Longrightarrow> n \\<in> {(_Entry_), (_ [(''C'', ''M'', 0)],None _),\n                                  (_ [(''C'', ''M'', 1)],None _), (_Exit_)}", "apply (case_tac list)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a list.\n       \\<lbrakk>valid_node (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') n;\n        cs = a # list; list = []\\<rbrakk>\n       \\<Longrightarrow> n \\<in> {(_Entry_), (_ [(''C'', ''M'', 0)],None _),\n                                  (_ [(''C'', ''M'', 1)],None _), (_Exit_)}\n 2. \\<And>a list aa lista.\n       \\<lbrakk>valid_node (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') n;\n        cs = a # list; list = aa # lista\\<rbrakk>\n       \\<Longrightarrow> n \\<in> {(_Entry_), (_ [(''C'', ''M'', 0)],None _),\n                                  (_ [(''C'', ''M'', 1)],None _), (_Exit_)}", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b a T ba Ts mxs mxl is xt.\n       \\<lbrakk>cs = [(''C'', ''M'', b)]; b \\<noteq> Suc 0;\n        Phi_EP ''C'' ''M'' ! b = \\<lfloor>(a, ba)\\<rfloor>; b < length is;\n        EP \\<turnstile> ''C'' sees ''M'': Ts\\<rightarrow>T = (mxs, mxl, is,\n                        xt) in ''C''\\<rbrakk>\n       \\<Longrightarrow> b = 0\n 2. \\<And>a list aa lista.\n       \\<lbrakk>valid_node (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') n;\n        cs = a # list; list = aa # lista\\<rbrakk>\n       \\<Longrightarrow> n \\<in> {(_Entry_), (_ [(''C'', ''M'', 0)],None _),\n                                  (_ [(''C'', ''M'', 1)],None _), (_Exit_)}", "apply (drule method_in_EP_is_M)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b a T ba Ts mxs mxl is xt.\n       \\<lbrakk>cs = [(''C'', ''M'', b)]; b \\<noteq> Suc 0;\n        Phi_EP ''C'' ''M'' ! b = \\<lfloor>(a, ba)\\<rfloor>; b < length is;\n        ''C'' = ''C'' \\<and>\n        ''M'' = ''M'' \\<and>\n        Ts = [] \\<and>\n        T = Void \\<and>\n        mxs = 1 \\<and>\n        mxl = 0 \\<and>\n        is = [Push Unit, Return] \\<and>\n        xt = [] \\<and> ''C'' = ''C''\\<rbrakk>\n       \\<Longrightarrow> b = 0\n 2. \\<And>a list aa lista.\n       \\<lbrakk>valid_node (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') n;\n        cs = a # list; list = aa # lista\\<rbrakk>\n       \\<Longrightarrow> n \\<in> {(_Entry_), (_ [(''C'', ''M'', 0)],None _),\n                                  (_ [(''C'', ''M'', 1)],None _), (_Exit_)}", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list aa lista.\n       \\<lbrakk>valid_node (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') n;\n        cs = a # list; list = aa # lista\\<rbrakk>\n       \\<Longrightarrow> n \\<in> {(_Entry_), (_ [(''C'', ''M'', 0)],None _),\n                                  (_ [(''C'', ''M'', 1)],None _), (_Exit_)}", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa b ab ac ba lista ad bb T Ts mxs mxl is xt.\n       \\<lbrakk>cs = (a, aa, b) # (ab, ac, ba) # lista;\n        instrs_of EP ab ac ! ba =\n        Invoke aa (length (snd (the (Phi_EP a aa ! 0))) - Suc mxl);\n        Phi_EP a aa ! b = \\<lfloor>(ad, bb)\\<rfloor>;\n        valid_callstack (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n         ((ab, ac, ba) # lista);\n        b < length is;\n        EP \\<turnstile> a sees aa: Ts\\<rightarrow>T = (mxs, mxl, is,\n                 xt) in a\\<rbrakk>\n       \\<Longrightarrow> False", "apply (drule method_in_EP_is_M)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa b ab ac ba lista ad bb T Ts mxs mxl is xt.\n       \\<lbrakk>cs = (a, aa, b) # (ab, ac, ba) # lista;\n        instrs_of EP ab ac ! ba =\n        Invoke aa (length (snd (the (Phi_EP a aa ! 0))) - Suc mxl);\n        Phi_EP a aa ! b = \\<lfloor>(ad, bb)\\<rfloor>;\n        valid_callstack (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n         ((ab, ac, ba) # lista);\n        b < length is;\n        a = ''C'' \\<and>\n        aa = ''M'' \\<and>\n        Ts = [] \\<and>\n        T = Void \\<and>\n        mxs = 1 \\<and>\n        mxl = 0 \\<and>\n        is = [Push Unit, Return] \\<and> xt = [] \\<and> a = ''C''\\<rbrakk>\n       \\<Longrightarrow> False", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b ab ac ba lista ad bb.\n       \\<lbrakk>cs = (''C'', ''M'', b) # (ab, ac, ba) # lista;\n        instrs_of EP ab ac ! ba =\n        Invoke ''M'' (length (snd (the (Phi_EP ''C'' ''M'' ! 0))) - Suc 0);\n        Phi_EP ''C'' ''M'' ! b = \\<lfloor>(ad, bb)\\<rfloor>;\n        valid_callstack (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n         ((ab, ac, ba) # lista);\n        b < Suc (Suc 0)\\<rbrakk>\n       \\<Longrightarrow> False", "apply (case_tac lista)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b ab ac ba lista ad bb.\n       \\<lbrakk>cs = (''C'', ''M'', b) # (ab, ac, ba) # lista;\n        instrs_of EP ab ac ! ba =\n        Invoke ''M'' (length (snd (the (Phi_EP ''C'' ''M'' ! 0))) - Suc 0);\n        Phi_EP ''C'' ''M'' ! b = \\<lfloor>(ad, bb)\\<rfloor>;\n        valid_callstack (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n         ((ab, ac, ba) # lista);\n        b < Suc (Suc 0); lista = []\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>b ab ac ba lista ad bb a list.\n       \\<lbrakk>cs = (''C'', ''M'', b) # (ab, ac, ba) # lista;\n        instrs_of EP ab ac ! ba =\n        Invoke ''M'' (length (snd (the (Phi_EP ''C'' ''M'' ! 0))) - Suc 0);\n        Phi_EP ''C'' ''M'' ! b = \\<lfloor>(ad, bb)\\<rfloor>;\n        valid_callstack (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n         ((ab, ac, ba) # lista);\n        b < Suc (Suc 0); lista = a # list\\<rbrakk>\n       \\<Longrightarrow> False", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b ba ad bb a T bc Ts mxs mxl is xt.\n       \\<lbrakk>cs = [(''C'', ''M'', b), (''C'', ''M'', ba)];\n        [Push Unit, Return] ! ba =\n        Invoke ''M'' (length (snd (the (Phi_EP ''C'' ''M'' ! 0))) - Suc 0);\n        Phi_EP ''C'' ''M'' ! b = \\<lfloor>(ad, bb)\\<rfloor>;\n        b < Suc (Suc 0);\n        Phi_EP ''C'' ''M'' ! ba = \\<lfloor>(a, bc)\\<rfloor>; ba < length is;\n        EP \\<turnstile> ''C'' sees ''M'': Ts\\<rightarrow>T = (mxs, mxl, is,\n                        xt) in ''C''\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>b ab ac ba lista ad bb a list.\n       \\<lbrakk>cs = (''C'', ''M'', b) # (ab, ac, ba) # lista;\n        instrs_of EP ab ac ! ba =\n        Invoke ''M'' (length (snd (the (Phi_EP ''C'' ''M'' ! 0))) - Suc 0);\n        Phi_EP ''C'' ''M'' ! b = \\<lfloor>(ad, bb)\\<rfloor>;\n        valid_callstack (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n         ((ab, ac, ba) # lista);\n        b < Suc (Suc 0); lista = a # list\\<rbrakk>\n       \\<Longrightarrow> False", "apply (drule method_in_EP_is_M)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b ba ad bb a T bc Ts mxs mxl is xt.\n       \\<lbrakk>cs = [(''C'', ''M'', b), (''C'', ''M'', ba)];\n        [Push Unit, Return] ! ba =\n        Invoke ''M'' (length (snd (the (Phi_EP ''C'' ''M'' ! 0))) - Suc 0);\n        Phi_EP ''C'' ''M'' ! b = \\<lfloor>(ad, bb)\\<rfloor>;\n        b < Suc (Suc 0);\n        Phi_EP ''C'' ''M'' ! ba = \\<lfloor>(a, bc)\\<rfloor>; ba < length is;\n        ''C'' = ''C'' \\<and>\n        ''M'' = ''M'' \\<and>\n        Ts = [] \\<and>\n        T = Void \\<and>\n        mxs = 1 \\<and>\n        mxl = 0 \\<and>\n        is = [Push Unit, Return] \\<and>\n        xt = [] \\<and> ''C'' = ''C''\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>b ab ac ba lista ad bb a list.\n       \\<lbrakk>cs = (''C'', ''M'', b) # (ab, ac, ba) # lista;\n        instrs_of EP ab ac ! ba =\n        Invoke ''M'' (length (snd (the (Phi_EP ''C'' ''M'' ! 0))) - Suc 0);\n        Phi_EP ''C'' ''M'' ! b = \\<lfloor>(ad, bb)\\<rfloor>;\n        valid_callstack (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n         ((ab, ac, ba) # lista);\n        b < Suc (Suc 0); lista = a # list\\<rbrakk>\n       \\<Longrightarrow> False", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b ba ad bb a bc.\n       \\<lbrakk>cs = [(''C'', ''M'', b), (''C'', ''M'', ba)];\n        [Push Unit, Return] ! ba =\n        Invoke ''M'' (length (snd (the (Phi_EP ''C'' ''M'' ! 0))) - Suc 0);\n        Phi_EP ''C'' ''M'' ! b = \\<lfloor>(ad, bb)\\<rfloor>;\n        b < Suc (Suc 0);\n        Phi_EP ''C'' ''M'' ! ba = \\<lfloor>(a, bc)\\<rfloor>;\n        ba < Suc (Suc 0)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>b ab ac ba lista ad bb a list.\n       \\<lbrakk>cs = (''C'', ''M'', b) # (ab, ac, ba) # lista;\n        instrs_of EP ab ac ! ba =\n        Invoke ''M'' (length (snd (the (Phi_EP ''C'' ''M'' ! 0))) - Suc 0);\n        Phi_EP ''C'' ''M'' ! b = \\<lfloor>(ad, bb)\\<rfloor>;\n        valid_callstack (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n         ((ab, ac, ba) # lista);\n        b < Suc (Suc 0); lista = a # list\\<rbrakk>\n       \\<Longrightarrow> False", "apply (case_tac ba, clarsimp, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b ab ac ba lista ad bb a list.\n       \\<lbrakk>cs = (''C'', ''M'', b) # (ab, ac, ba) # lista;\n        instrs_of EP ab ac ! ba =\n        Invoke ''M'' (length (snd (the (Phi_EP ''C'' ''M'' ! 0))) - Suc 0);\n        Phi_EP ''C'' ''M'' ! b = \\<lfloor>(ad, bb)\\<rfloor>;\n        valid_callstack (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n         ((ab, ac, ba) # lista);\n        b < Suc (Suc 0); lista = a # list\\<rbrakk>\n       \\<Longrightarrow> False", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b ab ac ba ad bb a aa bc list ae bd T Ts mxs mxl is xt.\n       \\<lbrakk>cs = (''C'', ''M'', b) # (ab, ac, ba) # (a, aa, bc) # list;\n        is ! ba =\n        Invoke ''M'' (length (snd (the (Phi_EP ''C'' ''M'' ! 0))) - Suc 0);\n        Phi_EP ''C'' ''M'' ! b = \\<lfloor>(ad, bb)\\<rfloor>;\n        b < Suc (Suc 0);\n        instrs_of EP a aa ! bc =\n        Invoke ac (length (snd (the (Phi_EP ab ac ! 0))) - Suc mxl);\n        Phi_EP ab ac ! ba = \\<lfloor>(ae, bd)\\<rfloor>;\n        valid_callstack (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n         ((a, aa, bc) # list);\n        ba < length is;\n        EP \\<turnstile> ab sees ac: Ts\\<rightarrow>T = (mxs, mxl, is,\n                  xt) in ab\\<rbrakk>\n       \\<Longrightarrow> False", "apply (drule method_in_EP_is_M)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b ab ac ba ad bb a aa bc list ae bd T Ts mxs mxl is xt.\n       \\<lbrakk>cs = (''C'', ''M'', b) # (ab, ac, ba) # (a, aa, bc) # list;\n        is ! ba =\n        Invoke ''M'' (length (snd (the (Phi_EP ''C'' ''M'' ! 0))) - Suc 0);\n        Phi_EP ''C'' ''M'' ! b = \\<lfloor>(ad, bb)\\<rfloor>;\n        b < Suc (Suc 0);\n        instrs_of EP a aa ! bc =\n        Invoke ac (length (snd (the (Phi_EP ab ac ! 0))) - Suc mxl);\n        Phi_EP ab ac ! ba = \\<lfloor>(ae, bd)\\<rfloor>;\n        valid_callstack (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n         ((a, aa, bc) # list);\n        ba < length is;\n        ab = ''C'' \\<and>\n        ac = ''M'' \\<and>\n        Ts = [] \\<and>\n        T = Void \\<and>\n        mxs = 1 \\<and>\n        mxl = 0 \\<and>\n        is = [Push Unit, Return] \\<and> xt = [] \\<and> ab = ''C''\\<rbrakk>\n       \\<Longrightarrow> False", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b ba ad bb a aa bc list ae bd.\n       \\<lbrakk>cs =\n                (''C'', ''M'', b) # (''C'', ''M'', ba) # (a, aa, bc) # list;\n        [Push Unit, Return] ! ba =\n        Invoke ''M'' (length (snd (the (Phi_EP ''C'' ''M'' ! 0))) - Suc 0);\n        Phi_EP ''C'' ''M'' ! b = \\<lfloor>(ad, bb)\\<rfloor>;\n        b < Suc (Suc 0);\n        instrs_of EP a aa ! bc =\n        Invoke ''M'' (length (snd (the (Phi_EP ''C'' ''M'' ! 0))) - Suc 0);\n        Phi_EP ''C'' ''M'' ! ba = \\<lfloor>(ae, bd)\\<rfloor>;\n        valid_callstack (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n         ((a, aa, bc) # list);\n        ba < Suc (Suc 0)\\<rbrakk>\n       \\<Longrightarrow> False", "by (case_tac ba, clarsimp, clarsimp)"], ["proof (state)\nthis:\n  n \\<in> {(_Entry_), (_ [(''C'', ''M'', 0)],None _),\n           (_ [(''C'', ''M'', 1)],None _), (_Exit_)}\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       opt = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       n \\<in> {(_Entry_), (_ [(''C'', ''M'', 0)],None _),\n                (_ [(''C'', ''M'', 1)],None _), (_Exit_)}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       opt = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       n \\<in> {(_Entry_), (_ [(''C'', ''M'', 0)],None _),\n                (_ [(''C'', ''M'', 1)],None _), (_Exit_)}", "case [simp]: (Some f)"], ["proof (state)\nthis:\n  opt = \\<lfloor>f\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       opt = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       n \\<in> {(_Entry_), (_ [(''C'', ''M'', 0)],None _),\n                (_ [(''C'', ''M'', 1)],None _), (_Exit_)}", "obtain cs'' xf where [simp]: \"f = (cs'', xf)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>cs'' xf.\n        f = (cs'', xf) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases f, fastforce)"], ["proof (state)\nthis:\n  f = (cs'', xf)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       opt = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       n \\<in> {(_Entry_), (_ [(''C'', ''M'', 0)],None _),\n                (_ [(''C'', ''M'', 1)],None _), (_Exit_)}", "from vn"], ["proof (chain)\npicking this:\n  valid_node (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') n", "show ?thesis"], ["proof (prove)\nusing this:\n  valid_node (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') n\n\ngoal (1 subgoal):\n 1. n \\<in> {(_Entry_), (_ [(''C'', ''M'', 0)],None _),\n             (_ [(''C'', ''M'', 1)],None _), (_Exit_)}", "apply (cases cs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>valid_node (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') n;\n     cs = []\\<rbrakk>\n    \\<Longrightarrow> n \\<in> {(_Entry_), (_ [(''C'', ''M'', 0)],None _),\n                               (_ [(''C'', ''M'', 1)],None _), (_Exit_)}\n 2. \\<And>a list.\n       \\<lbrakk>valid_node (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') n;\n        cs = a # list\\<rbrakk>\n       \\<Longrightarrow> n \\<in> {(_Entry_), (_ [(''C'', ''M'', 0)],None _),\n                                  (_ [(''C'', ''M'', 1)],None _), (_Exit_)}", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Q f.\n       \\<lbrakk>cs = [];\n        valid_callstack (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') cs'';\n        (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n         ''M'') \\<turnstile> (_Exit_) -(Q)\\<^sub>\\<surd>\\<rightarrow> (_ [],\\<lfloor>(cs'',\n          xf)\\<rfloor> _);\n        (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n         ''M'') \\<turnstile> (_ [],\\<lfloor>(cs'',\n       xf)\\<rfloor> _) -\\<Up>f\\<rightarrow> (_ cs'',None _)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a list.\n       \\<lbrakk>valid_node (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') n;\n        cs = a # list\\<rbrakk>\n       \\<Longrightarrow> n \\<in> {(_Entry_), (_ [(''C'', ''M'', 0)],None _),\n                                  (_ [(''C'', ''M'', 1)],None _), (_Exit_)}", "apply (erule JVM_CFG.cases, clarsimp+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa b list Q f.\n       \\<lbrakk>cs = (a, aa, b) # list;\n        valid_callstack (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n         ((a, aa, b) # list);\n        valid_callstack (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') cs'';\n        (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n         ''M'') \\<turnstile> (_ (a, aa, b) #\n                                list,None _) -(Q)\\<^sub>\\<surd>\\<rightarrow> (_ (a,\n     aa, b) #\n    list,\\<lfloor>(cs'', xf)\\<rfloor> _);\n        (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n         ''M'') \\<turnstile> (_ (a, aa, b) #\n                                list,\\<lfloor>(cs'',\n         xf)\\<rfloor> _) -\\<Up>f\\<rightarrow> (_ cs'',None _)\\<rbrakk>\n       \\<Longrightarrow> False", "apply (case_tac list)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a aa b list Q f.\n       \\<lbrakk>cs = (a, aa, b) # list;\n        valid_callstack (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n         ((a, aa, b) # list);\n        valid_callstack (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') cs'';\n        (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n         ''M'') \\<turnstile> (_ (a, aa, b) #\n                                list,None _) -(Q)\\<^sub>\\<surd>\\<rightarrow> (_ (a,\n     aa, b) #\n    list,\\<lfloor>(cs'', xf)\\<rfloor> _);\n        (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n         ''M'') \\<turnstile> (_ (a, aa, b) #\n                                list,\\<lfloor>(cs'',\n         xf)\\<rfloor> _) -\\<Up>f\\<rightarrow> (_ cs'',None _);\n        list = []\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a aa b list Q f ab lista.\n       \\<lbrakk>cs = (a, aa, b) # list;\n        valid_callstack (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n         ((a, aa, b) # list);\n        valid_callstack (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') cs'';\n        (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n         ''M'') \\<turnstile> (_ (a, aa, b) #\n                                list,None _) -(Q)\\<^sub>\\<surd>\\<rightarrow> (_ (a,\n     aa, b) #\n    list,\\<lfloor>(cs'', xf)\\<rfloor> _);\n        (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n         ''M'') \\<turnstile> (_ (a, aa, b) #\n                                list,\\<lfloor>(cs'',\n         xf)\\<rfloor> _) -\\<Up>f\\<rightarrow> (_ cs'',None _);\n        list = ab # lista\\<rbrakk>\n       \\<Longrightarrow> False", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b Q f a T ba Ts mxs mxl is xt.\n       \\<lbrakk>cs = [(''C'', ''M'', b)];\n        valid_callstack (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') cs'';\n        (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n         ''M'') \\<turnstile> (_ [(''C'', ''M'',\n                                  b)],None _) -(Q)\\<^sub>\\<surd>\\<rightarrow> (_ [(''C'',\n       ''M'', b)],\\<lfloor>(cs'', xf)\\<rfloor> _);\n        (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n         ''M'') \\<turnstile> (_ [(''C'', ''M'',\n                                  b)],\\<lfloor>(cs'',\n          xf)\\<rfloor> _) -\\<Up>f\\<rightarrow> (_ cs'',None _);\n        Phi_EP ''C'' ''M'' ! b = \\<lfloor>(a, ba)\\<rfloor>; b < length is;\n        EP \\<turnstile> ''C'' sees ''M'': Ts\\<rightarrow>T = (mxs, mxl, is,\n                        xt) in ''C''\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a aa b list Q f ab lista.\n       \\<lbrakk>cs = (a, aa, b) # list;\n        valid_callstack (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n         ((a, aa, b) # list);\n        valid_callstack (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') cs'';\n        (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n         ''M'') \\<turnstile> (_ (a, aa, b) #\n                                list,None _) -(Q)\\<^sub>\\<surd>\\<rightarrow> (_ (a,\n     aa, b) #\n    list,\\<lfloor>(cs'', xf)\\<rfloor> _);\n        (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n         ''M'') \\<turnstile> (_ (a, aa, b) #\n                                list,\\<lfloor>(cs'',\n         xf)\\<rfloor> _) -\\<Up>f\\<rightarrow> (_ cs'',None _);\n        list = ab # lista\\<rbrakk>\n       \\<Longrightarrow> False", "apply (frule method_in_EP_is_M)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b Q f a T ba Ts mxs mxl is xt.\n       \\<lbrakk>cs = [(''C'', ''M'', b)];\n        valid_callstack (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') cs'';\n        (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n         ''M'') \\<turnstile> (_ [(''C'', ''M'',\n                                  b)],None _) -(Q)\\<^sub>\\<surd>\\<rightarrow> (_ [(''C'',\n       ''M'', b)],\\<lfloor>(cs'', xf)\\<rfloor> _);\n        (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n         ''M'') \\<turnstile> (_ [(''C'', ''M'',\n                                  b)],\\<lfloor>(cs'',\n          xf)\\<rfloor> _) -\\<Up>f\\<rightarrow> (_ cs'',None _);\n        Phi_EP ''C'' ''M'' ! b = \\<lfloor>(a, ba)\\<rfloor>; b < length is;\n        EP \\<turnstile> ''C'' sees ''M'': Ts\\<rightarrow>T = (mxs, mxl, is,\n                        xt) in ''C'';\n        ''C'' = ''C'' \\<and>\n        ''M'' = ''M'' \\<and>\n        Ts = [] \\<and>\n        T = Void \\<and>\n        mxs = 1 \\<and>\n        mxl = 0 \\<and>\n        is = [Push Unit, Return] \\<and>\n        xt = [] \\<and> ''C'' = ''C''\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a aa b list Q f ab lista.\n       \\<lbrakk>cs = (a, aa, b) # list;\n        valid_callstack (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n         ((a, aa, b) # list);\n        valid_callstack (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') cs'';\n        (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n         ''M'') \\<turnstile> (_ (a, aa, b) #\n                                list,None _) -(Q)\\<^sub>\\<surd>\\<rightarrow> (_ (a,\n     aa, b) #\n    list,\\<lfloor>(cs'', xf)\\<rfloor> _);\n        (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n         ''M'') \\<turnstile> (_ (a, aa, b) #\n                                list,\\<lfloor>(cs'',\n         xf)\\<rfloor> _) -\\<Up>f\\<rightarrow> (_ cs'',None _);\n        list = ab # lista\\<rbrakk>\n       \\<Longrightarrow> False", "apply (case_tac b)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>b Q f a T ba Ts mxs mxl is xt.\n       \\<lbrakk>cs = [(''C'', ''M'', b)];\n        valid_callstack (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') cs'';\n        (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n         ''M'') \\<turnstile> (_ [(''C'', ''M'',\n                                  b)],None _) -(Q)\\<^sub>\\<surd>\\<rightarrow> (_ [(''C'',\n       ''M'', b)],\\<lfloor>(cs'', xf)\\<rfloor> _);\n        (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n         ''M'') \\<turnstile> (_ [(''C'', ''M'',\n                                  b)],\\<lfloor>(cs'',\n          xf)\\<rfloor> _) -\\<Up>f\\<rightarrow> (_ cs'',None _);\n        Phi_EP ''C'' ''M'' ! b = \\<lfloor>(a, ba)\\<rfloor>; b < length is;\n        EP \\<turnstile> ''C'' sees ''M'': Ts\\<rightarrow>T = (mxs, mxl, is,\n                        xt) in ''C'';\n        ''C'' = ''C'' \\<and>\n        ''M'' = ''M'' \\<and>\n        Ts = [] \\<and>\n        T = Void \\<and>\n        mxs = 1 \\<and>\n        mxl = 0 \\<and>\n        is = [Push Unit, Return] \\<and> xt = [] \\<and> ''C'' = ''C'';\n        b = 0\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>b Q f a T ba Ts mxs mxl is xt nat.\n       \\<lbrakk>cs = [(''C'', ''M'', b)];\n        valid_callstack (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') cs'';\n        (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n         ''M'') \\<turnstile> (_ [(''C'', ''M'',\n                                  b)],None _) -(Q)\\<^sub>\\<surd>\\<rightarrow> (_ [(''C'',\n       ''M'', b)],\\<lfloor>(cs'', xf)\\<rfloor> _);\n        (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n         ''M'') \\<turnstile> (_ [(''C'', ''M'',\n                                  b)],\\<lfloor>(cs'',\n          xf)\\<rfloor> _) -\\<Up>f\\<rightarrow> (_ cs'',None _);\n        Phi_EP ''C'' ''M'' ! b = \\<lfloor>(a, ba)\\<rfloor>; b < length is;\n        EP \\<turnstile> ''C'' sees ''M'': Ts\\<rightarrow>T = (mxs, mxl, is,\n                        xt) in ''C'';\n        ''C'' = ''C'' \\<and>\n        ''M'' = ''M'' \\<and>\n        Ts = [] \\<and>\n        T = Void \\<and>\n        mxs = 1 \\<and>\n        mxl = 0 \\<and>\n        is = [Push Unit, Return] \\<and> xt = [] \\<and> ''C'' = ''C'';\n        b = Suc nat\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a aa b list Q f ab lista.\n       \\<lbrakk>cs = (a, aa, b) # list;\n        valid_callstack (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n         ((a, aa, b) # list);\n        valid_callstack (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') cs'';\n        (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n         ''M'') \\<turnstile> (_ (a, aa, b) #\n                                list,None _) -(Q)\\<^sub>\\<surd>\\<rightarrow> (_ (a,\n     aa, b) #\n    list,\\<lfloor>(cs'', xf)\\<rfloor> _);\n        (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n         ''M'') \\<turnstile> (_ (a, aa, b) #\n                                list,\\<lfloor>(cs'',\n         xf)\\<rfloor> _) -\\<Up>f\\<rightarrow> (_ cs'',None _);\n        list = ab # lista\\<rbrakk>\n       \\<Longrightarrow> False", "apply (erule JVM_CFG.cases, clarsimp+)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Q f a ba.\n       \\<lbrakk>cs = [(''C'', ''M'', Suc 0)];\n        valid_callstack (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') cs'';\n        (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n         ''M'') \\<turnstile> (_ [(''C'', ''M'',\n                                  Suc 0)],None _) -(Q)\\<^sub>\\<surd>\\<rightarrow> (_ [(''C'',\n           ''M'', Suc 0)],\\<lfloor>(cs'', xf)\\<rfloor> _);\n        (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n         ''M'') \\<turnstile> (_ [(''C'', ''M'',\n                                  Suc 0)],\\<lfloor>(cs'',\n              xf)\\<rfloor> _) -\\<Up>f\\<rightarrow> (_ cs'',None _);\n        Phi_EP ''C'' ''M'' ! Suc 0 = \\<lfloor>(a, ba)\\<rfloor>;\n        EP \\<turnstile> ''C'' sees ''M'': []\\<rightarrow>Void = (Suc 0, 0,\n                           [Push Unit, Return], []) in ''C''\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a aa b list Q f ab lista.\n       \\<lbrakk>cs = (a, aa, b) # list;\n        valid_callstack (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n         ((a, aa, b) # list);\n        valid_callstack (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') cs'';\n        (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n         ''M'') \\<turnstile> (_ (a, aa, b) #\n                                list,None _) -(Q)\\<^sub>\\<surd>\\<rightarrow> (_ (a,\n     aa, b) #\n    list,\\<lfloor>(cs'', xf)\\<rfloor> _);\n        (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n         ''M'') \\<turnstile> (_ (a, aa, b) #\n                                list,\\<lfloor>(cs'',\n         xf)\\<rfloor> _) -\\<Up>f\\<rightarrow> (_ cs'',None _);\n        list = ab # lista\\<rbrakk>\n       \\<Longrightarrow> False", "apply (erule JVM_CFG.cases, clarsimp+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa b Q f ab ac ba lista ad bb T Ts mxs mxl is xt.\n       \\<lbrakk>cs = (a, aa, b) # (ab, ac, ba) # lista;\n        valid_callstack (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') cs'';\n        (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n         ''M'') \\<turnstile> (_ (a, aa, b) #\n                                (ab, ac, ba) #\n                                lista,None _) -(Q)\\<^sub>\\<surd>\\<rightarrow> (_ (a,\n      aa, b) #\n     (ab, ac, ba) # lista,\\<lfloor>(cs'', xf)\\<rfloor> _);\n        (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n         ''M'') \\<turnstile> (_ (a, aa, b) #\n                                (ab, ac, ba) #\n                                lista,\\<lfloor>(cs'',\n          xf)\\<rfloor> _) -\\<Up>f\\<rightarrow> (_ cs'',None _);\n        instrs_of EP ab ac ! ba =\n        Invoke aa (length (snd (the (Phi_EP a aa ! 0))) - Suc mxl);\n        Phi_EP a aa ! b = \\<lfloor>(ad, bb)\\<rfloor>;\n        valid_callstack (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n         ((ab, ac, ba) # lista);\n        b < length is;\n        EP \\<turnstile> a sees aa: Ts\\<rightarrow>T = (mxs, mxl, is,\n                 xt) in a\\<rbrakk>\n       \\<Longrightarrow> False", "apply (frule method_in_EP_is_M)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa b Q f ab ac ba lista ad bb T Ts mxs mxl is xt.\n       \\<lbrakk>cs = (a, aa, b) # (ab, ac, ba) # lista;\n        valid_callstack (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') cs'';\n        (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n         ''M'') \\<turnstile> (_ (a, aa, b) #\n                                (ab, ac, ba) #\n                                lista,None _) -(Q)\\<^sub>\\<surd>\\<rightarrow> (_ (a,\n      aa, b) #\n     (ab, ac, ba) # lista,\\<lfloor>(cs'', xf)\\<rfloor> _);\n        (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n         ''M'') \\<turnstile> (_ (a, aa, b) #\n                                (ab, ac, ba) #\n                                lista,\\<lfloor>(cs'',\n          xf)\\<rfloor> _) -\\<Up>f\\<rightarrow> (_ cs'',None _);\n        instrs_of EP ab ac ! ba =\n        Invoke aa (length (snd (the (Phi_EP a aa ! 0))) - Suc mxl);\n        Phi_EP a aa ! b = \\<lfloor>(ad, bb)\\<rfloor>;\n        valid_callstack (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n         ((ab, ac, ba) # lista);\n        b < length is;\n        EP \\<turnstile> a sees aa: Ts\\<rightarrow>T = (mxs, mxl, is,\n                 xt) in a;\n        a = ''C'' \\<and>\n        aa = ''M'' \\<and>\n        Ts = [] \\<and>\n        T = Void \\<and>\n        mxs = 1 \\<and>\n        mxl = 0 \\<and>\n        is = [Push Unit, Return] \\<and> xt = [] \\<and> a = ''C''\\<rbrakk>\n       \\<Longrightarrow> False", "apply (case_tac b)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a aa b Q f ab ac ba lista ad bb T Ts mxs mxl is xt.\n       \\<lbrakk>cs = (a, aa, b) # (ab, ac, ba) # lista;\n        valid_callstack (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') cs'';\n        (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n         ''M'') \\<turnstile> (_ (a, aa, b) #\n                                (ab, ac, ba) #\n                                lista,None _) -(Q)\\<^sub>\\<surd>\\<rightarrow> (_ (a,\n      aa, b) #\n     (ab, ac, ba) # lista,\\<lfloor>(cs'', xf)\\<rfloor> _);\n        (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n         ''M'') \\<turnstile> (_ (a, aa, b) #\n                                (ab, ac, ba) #\n                                lista,\\<lfloor>(cs'',\n          xf)\\<rfloor> _) -\\<Up>f\\<rightarrow> (_ cs'',None _);\n        instrs_of EP ab ac ! ba =\n        Invoke aa (length (snd (the (Phi_EP a aa ! 0))) - Suc mxl);\n        Phi_EP a aa ! b = \\<lfloor>(ad, bb)\\<rfloor>;\n        valid_callstack (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n         ((ab, ac, ba) # lista);\n        b < length is;\n        EP \\<turnstile> a sees aa: Ts\\<rightarrow>T = (mxs, mxl, is,\n                 xt) in a;\n        a = ''C'' \\<and>\n        aa = ''M'' \\<and>\n        Ts = [] \\<and>\n        T = Void \\<and>\n        mxs = 1 \\<and>\n        mxl = 0 \\<and>\n        is = [Push Unit, Return] \\<and> xt = [] \\<and> a = ''C'';\n        b = 0\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a aa b Q f ab ac ba lista ad bb T Ts mxs mxl is xt nat.\n       \\<lbrakk>cs = (a, aa, b) # (ab, ac, ba) # lista;\n        valid_callstack (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') cs'';\n        (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n         ''M'') \\<turnstile> (_ (a, aa, b) #\n                                (ab, ac, ba) #\n                                lista,None _) -(Q)\\<^sub>\\<surd>\\<rightarrow> (_ (a,\n      aa, b) #\n     (ab, ac, ba) # lista,\\<lfloor>(cs'', xf)\\<rfloor> _);\n        (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n         ''M'') \\<turnstile> (_ (a, aa, b) #\n                                (ab, ac, ba) #\n                                lista,\\<lfloor>(cs'',\n          xf)\\<rfloor> _) -\\<Up>f\\<rightarrow> (_ cs'',None _);\n        instrs_of EP ab ac ! ba =\n        Invoke aa (length (snd (the (Phi_EP a aa ! 0))) - Suc mxl);\n        Phi_EP a aa ! b = \\<lfloor>(ad, bb)\\<rfloor>;\n        valid_callstack (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n         ((ab, ac, ba) # lista);\n        b < length is;\n        EP \\<turnstile> a sees aa: Ts\\<rightarrow>T = (mxs, mxl, is,\n                 xt) in a;\n        a = ''C'' \\<and>\n        aa = ''M'' \\<and>\n        Ts = [] \\<and>\n        T = Void \\<and>\n        mxs = 1 \\<and>\n        mxl = 0 \\<and>\n        is = [Push Unit, Return] \\<and> xt = [] \\<and> a = ''C'';\n        b = Suc nat\\<rbrakk>\n       \\<Longrightarrow> False", "apply (erule JVM_CFG.cases, clarsimp+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Q f ab ac ba lista ad bb.\n       \\<lbrakk>cs = (''C'', ''M'', Suc 0) # (ab, ac, ba) # lista;\n        valid_callstack (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') cs'';\n        (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n         ''M'') \\<turnstile> (_ (''C'', ''M'', Suc 0) #\n                                (ab, ac, ba) #\n                                lista,None _) -(Q)\\<^sub>\\<surd>\\<rightarrow> (_ (''C'',\n      ''M'', Suc 0) #\n     (ab, ac, ba) # lista,\\<lfloor>(cs'', xf)\\<rfloor> _);\n        (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n         ''M'') \\<turnstile> (_ (''C'', ''M'', Suc 0) #\n                                (ab, ac, ba) #\n                                lista,\\<lfloor>(cs'',\n          xf)\\<rfloor> _) -\\<Up>f\\<rightarrow> (_ cs'',None _);\n        instrs_of EP ab ac ! ba =\n        Invoke ''M'' (length (snd (the (Phi_EP ''C'' ''M'' ! 0))) - Suc 0);\n        Phi_EP ''C'' ''M'' ! Suc 0 = \\<lfloor>(ad, bb)\\<rfloor>;\n        valid_callstack (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n         ((ab, ac, ba) # lista);\n        EP \\<turnstile> ''C'' sees ''M'': []\\<rightarrow>Void = (Suc 0, 0,\n                           [Push Unit, Return], []) in ''C''\\<rbrakk>\n       \\<Longrightarrow> False", "by (erule JVM_CFG.cases, clarsimp+)"], ["proof (state)\nthis:\n  n \\<in> {(_Entry_), (_ [(''C'', ''M'', 0)],None _),\n           (_ [(''C'', ''M'', 1)],None _), (_Exit_)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n \\<in> {(_Entry_), (_ [(''C'', ''M'', 0)],None _),\n           (_ [(''C'', ''M'', 1)],None _), (_Exit_)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n \\<in> {(_Entry_), (_ [(''C'', ''M'', 0)],None _),\n           (_ [(''C'', ''M'', 1)],None _), (_Exit_)}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma EP_C_M_0_valid [simp]:\n  \"JVM_CFG_Interpret.valid_node (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') \n    (_ [(''C'', ''M'', 0)],None _)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. JVM_CFG_Interpret.valid_node (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n     (_ [(''C'', ''M'', 0)],None _)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. JVM_CFG_Interpret.valid_node (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n     (_ [(''C'', ''M'', 0)],None _)", "have \"valid_edge (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n    ((_Entry_), (\\<lambda>s. True)\\<^sub>\\<surd>, (_ [(''C'', ''M'', 0)],None _))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_edge (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n     ((_Entry_), (\\<lambda>s. True)\\<^sub>\\<surd>,\n      (_ [(''C'', ''M'', 0)],None _))", "apply (auto simp: Phi_EP_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n     ''M'') \\<turnstile> (_Entry_) -(\\<lambda>s.\n  True)\\<^sub>\\<surd>\\<rightarrow> (_ [(''C'', ''M'', 0)],None _)", "by rule auto"], ["proof (state)\nthis:\n  valid_edge (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n   ((_Entry_), (\\<lambda>s. True)\\<^sub>\\<surd>,\n    (_ [(''C'', ''M'', 0)],None _))\n\ngoal (1 subgoal):\n 1. JVM_CFG_Interpret.valid_node (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n     (_ [(''C'', ''M'', 0)],None _)", "thus ?thesis"], ["proof (prove)\nusing this:\n  valid_edge (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n   ((_Entry_), (\\<lambda>s. True)\\<^sub>\\<surd>,\n    (_ [(''C'', ''M'', 0)],None _))\n\ngoal (1 subgoal):\n 1. JVM_CFG_Interpret.valid_node (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n     (_ [(''C'', ''M'', 0)],None _)", "by (fastforce simp: JVM_CFG_Interpret.valid_node_def)"], ["proof (state)\nthis:\n  JVM_CFG_Interpret.valid_node (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n   (_ [(''C'', ''M'', 0)],None _)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma EP_C_M_Suc_0_valid [simp]:\n  \"JVM_CFG_Interpret.valid_node (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') \n    (_ [(''C'', ''M'', Suc 0)],None _)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. JVM_CFG_Interpret.valid_node (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n     (_ [(''C'', ''M'', Suc 0)],None _)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. JVM_CFG_Interpret.valid_node (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n     (_ [(''C'', ''M'', Suc 0)],None _)", "have \"valid_edge (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n    ((_ [(''C'', ''M'', Suc 0)],None _), \\<Up>id, (_Exit_))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_edge (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n     ((_ [(''C'', ''M'', Suc 0)],None _), \\<Up>id, (_Exit_))", "apply (auto simp: Phi_EP_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n     ''M'') \\<turnstile> (_ [(''C'', ''M'',\n                              Suc 0)],None _) -\\<Up>id\\<rightarrow> (_Exit_)", "by rule auto"], ["proof (state)\nthis:\n  valid_edge (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n   ((_ [(''C'', ''M'', Suc 0)],None _), \\<Up>id, (_Exit_))\n\ngoal (1 subgoal):\n 1. JVM_CFG_Interpret.valid_node (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n     (_ [(''C'', ''M'', Suc 0)],None _)", "thus ?thesis"], ["proof (prove)\nusing this:\n  valid_edge (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n   ((_ [(''C'', ''M'', Suc 0)],None _), \\<Up>id, (_Exit_))\n\ngoal (1 subgoal):\n 1. JVM_CFG_Interpret.valid_node (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n     (_ [(''C'', ''M'', Suc 0)],None _)", "by (fastforce simp: JVM_CFG_Interpret.valid_node_def)"], ["proof (state)\nthis:\n  JVM_CFG_Interpret.valid_node (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n   (_ [(''C'', ''M'', Suc 0)],None _)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition\n  \"cfg_wf_prog =\n    {P. (\\<forall>n. valid_node P n \\<longrightarrow>\n         (\\<exists>as. JVM_CFG_Interpret.path P (_Entry_) as n) \\<and>\n         (\\<exists>as. JVM_CFG_Interpret.path P n as (_Exit_)))}\""], ["", "typedef cfg_wf_prog = cfg_wf_prog"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> cfg_wf_prog", "unfolding cfg_wf_prog_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<in> {P. \\<forall>n.\n                      valid_node P n \\<longrightarrow>\n                      (\\<exists>as.\n                          JVM_CFG_Interpret.path P (_Entry_) as n) \\<and>\n                      (\\<exists>as. JVM_CFG_Interpret.path P n as (_Exit_))}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. ?x \\<in> {P. \\<forall>n.\n                    valid_node P n \\<longrightarrow>\n                    (\\<exists>as.\n                        JVM_CFG_Interpret.path P (_Entry_) as n) \\<and>\n                    (\\<exists>as. JVM_CFG_Interpret.path P n as (_Exit_))}", "let ?prog = \"((Abs_wf_jvmprog (EP, Phi_EP)), ''C'', ''M'')\""], ["proof (state)\ngoal (1 subgoal):\n 1. ?x \\<in> {P. \\<forall>n.\n                    valid_node P n \\<longrightarrow>\n                    (\\<exists>as.\n                        JVM_CFG_Interpret.path P (_Entry_) as n) \\<and>\n                    (\\<exists>as. JVM_CFG_Interpret.path P n as (_Exit_))}", "let ?edge0 = \"((_Entry_), (\\<lambda>s. False)\\<^sub>\\<surd>, (_Exit_))\""], ["proof (state)\ngoal (1 subgoal):\n 1. ?x \\<in> {P. \\<forall>n.\n                    valid_node P n \\<longrightarrow>\n                    (\\<exists>as.\n                        JVM_CFG_Interpret.path P (_Entry_) as n) \\<and>\n                    (\\<exists>as. JVM_CFG_Interpret.path P n as (_Exit_))}", "let ?edge1 = \"((_Entry_), (\\<lambda>s. True)\\<^sub>\\<surd>, (_ [(''C'', ''M'', 0)],None _))\""], ["proof (state)\ngoal (1 subgoal):\n 1. ?x \\<in> {P. \\<forall>n.\n                    valid_node P n \\<longrightarrow>\n                    (\\<exists>as.\n                        JVM_CFG_Interpret.path P (_Entry_) as n) \\<and>\n                    (\\<exists>as. JVM_CFG_Interpret.path P n as (_Exit_))}", "let ?edge2 = \"((_ [(''C'', ''M'', 0)],None _),\n                 \\<Up>(\\<lambda>(h, stk, loc). (h, stk((0, 0) := Unit), loc)),\n                 (_ [(''C'', ''M'', 1)],None _))\""], ["proof (state)\ngoal (1 subgoal):\n 1. ?x \\<in> {P. \\<forall>n.\n                    valid_node P n \\<longrightarrow>\n                    (\\<exists>as.\n                        JVM_CFG_Interpret.path P (_Entry_) as n) \\<and>\n                    (\\<exists>as. JVM_CFG_Interpret.path P n as (_Exit_))}", "let ?edge3 = \"((_ [(''C'', ''M'', 1)],None _), \\<Up>id, (_Exit_))\""], ["proof (state)\ngoal (1 subgoal):\n 1. ?x \\<in> {P. \\<forall>n.\n                    valid_node P n \\<longrightarrow>\n                    (\\<exists>as.\n                        JVM_CFG_Interpret.path P (_Entry_) as n) \\<and>\n                    (\\<exists>as. JVM_CFG_Interpret.path P n as (_Exit_))}", "show \"?prog \\<in> {P. \\<forall>n. valid_node P n \\<longrightarrow>\n                 (\\<exists>as. CFG.path sourcenode targetnode (valid_edge P) (_Entry_) as n) \\<and>\n                 (\\<exists>as. CFG.path sourcenode targetnode (valid_edge P) n as (_Exit_))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n    \\<in> {P. \\<forall>n.\n                 valid_node P n \\<longrightarrow>\n                 (\\<exists>as.\n                     JVM_CFG_Interpret.path P (_Entry_) as n) \\<and>\n                 (\\<exists>as. JVM_CFG_Interpret.path P n as (_Exit_))}", "proof (auto dest!: valid_node_in_EP_D)"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Entry_) as (_Entry_)\n 2. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Entry_) as (_Exit_)\n 3. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Entry_) as (_ [(''C'', ''M'', 0)],None _)\n 4. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_ [(''C'', ''M'', 0)],None _) as (_Exit_)\n 5. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Entry_) as (_ [(''C'', ''M'', Suc 0)],None _)\n 6. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_ [(''C'', ''M'', Suc 0)],None _) as (_Exit_)\n 7. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Entry_) as (_Exit_)\n 8. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Exit_) as (_Exit_)", "have \"JVM_CFG_Interpret.path ?prog (_Entry_) [] (_Entry_)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n     (_Entry_) [] (_Entry_)", "by (simp add: JVM_CFG_Interpret.path.empty_path)"], ["proof (state)\nthis:\n  JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n   (_Entry_) [] (_Entry_)\n\ngoal (8 subgoals):\n 1. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Entry_) as (_Entry_)\n 2. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Entry_) as (_Exit_)\n 3. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Entry_) as (_ [(''C'', ''M'', 0)],None _)\n 4. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_ [(''C'', ''M'', 0)],None _) as (_Exit_)\n 5. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Entry_) as (_ [(''C'', ''M'', Suc 0)],None _)\n 6. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_ [(''C'', ''M'', Suc 0)],None _) as (_Exit_)\n 7. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Entry_) as (_Exit_)\n 8. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Exit_) as (_Exit_)", "thus \"\\<exists>as. JVM_CFG_Interpret.path ?prog (_Entry_) as (_Entry_)\""], ["proof (prove)\nusing this:\n  JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n   (_Entry_) [] (_Entry_)\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Entry_) as (_Entry_)", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>as.\n     JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n      (_Entry_) as (_Entry_)\n\ngoal (7 subgoals):\n 1. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Entry_) as (_Exit_)\n 2. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Entry_) as (_ [(''C'', ''M'', 0)],None _)\n 3. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_ [(''C'', ''M'', 0)],None _) as (_Exit_)\n 4. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Entry_) as (_ [(''C'', ''M'', Suc 0)],None _)\n 5. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_ [(''C'', ''M'', Suc 0)],None _) as (_Exit_)\n 6. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Entry_) as (_Exit_)\n 7. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Exit_) as (_Exit_)", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Entry_) as (_Exit_)\n 2. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Entry_) as (_ [(''C'', ''M'', 0)],None _)\n 3. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_ [(''C'', ''M'', 0)],None _) as (_Exit_)\n 4. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Entry_) as (_ [(''C'', ''M'', Suc 0)],None _)\n 5. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_ [(''C'', ''M'', Suc 0)],None _) as (_Exit_)\n 6. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Entry_) as (_Exit_)\n 7. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Exit_) as (_Exit_)", "have \"JVM_CFG_Interpret.path ?prog (_Entry_) [?edge0] (_Exit_)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n     (_Entry_) [((_Entry_), (\\<lambda>s. False)\\<^sub>\\<surd>, (_Exit_))]\n     (_Exit_)", "by rule (auto intro: JCFG_EntryExit JVM_CFG_Interpret.path.empty_path)"], ["proof (state)\nthis:\n  JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n   (_Entry_) [((_Entry_), (\\<lambda>s. False)\\<^sub>\\<surd>, (_Exit_))]\n   (_Exit_)\n\ngoal (7 subgoals):\n 1. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Entry_) as (_Exit_)\n 2. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Entry_) as (_ [(''C'', ''M'', 0)],None _)\n 3. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_ [(''C'', ''M'', 0)],None _) as (_Exit_)\n 4. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Entry_) as (_ [(''C'', ''M'', Suc 0)],None _)\n 5. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_ [(''C'', ''M'', Suc 0)],None _) as (_Exit_)\n 6. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Entry_) as (_Exit_)\n 7. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Exit_) as (_Exit_)", "thus \"\\<exists>as. JVM_CFG_Interpret.path ?prog (_Entry_) as (_Exit_)\""], ["proof (prove)\nusing this:\n  JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n   (_Entry_) [((_Entry_), (\\<lambda>s. False)\\<^sub>\\<surd>, (_Exit_))]\n   (_Exit_)\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Entry_) as (_Exit_)", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>as.\n     JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n      (_Entry_) as (_Exit_)\n\ngoal (6 subgoals):\n 1. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Entry_) as (_ [(''C'', ''M'', 0)],None _)\n 2. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_ [(''C'', ''M'', 0)],None _) as (_Exit_)\n 3. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Entry_) as (_ [(''C'', ''M'', Suc 0)],None _)\n 4. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_ [(''C'', ''M'', Suc 0)],None _) as (_Exit_)\n 5. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Entry_) as (_Exit_)\n 6. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Exit_) as (_Exit_)", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Entry_) as (_ [(''C'', ''M'', 0)],None _)\n 2. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_ [(''C'', ''M'', 0)],None _) as (_Exit_)\n 3. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Entry_) as (_ [(''C'', ''M'', Suc 0)],None _)\n 4. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_ [(''C'', ''M'', Suc 0)],None _) as (_Exit_)\n 5. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Entry_) as (_Exit_)\n 6. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Exit_) as (_Exit_)", "have \"JVM_CFG_Interpret.path ?prog (_Entry_) [?edge1] (_ [(''C'', ''M'', 0)],None _)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n     (_Entry_)\n     [((_Entry_), (\\<lambda>s. True)\\<^sub>\\<surd>,\n       (_ [(''C'', ''M'', 0)],None _))]\n     (_ [(''C'', ''M'', 0)],None _)", "by rule (auto intro: JCFG_EntryStart simp: JVM_CFG_Interpret.path.empty_path Phi_EP_def)"], ["proof (state)\nthis:\n  JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n   (_Entry_)\n   [((_Entry_), (\\<lambda>s. True)\\<^sub>\\<surd>,\n     (_ [(''C'', ''M'', 0)],None _))]\n   (_ [(''C'', ''M'', 0)],None _)\n\ngoal (6 subgoals):\n 1. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Entry_) as (_ [(''C'', ''M'', 0)],None _)\n 2. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_ [(''C'', ''M'', 0)],None _) as (_Exit_)\n 3. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Entry_) as (_ [(''C'', ''M'', Suc 0)],None _)\n 4. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_ [(''C'', ''M'', Suc 0)],None _) as (_Exit_)\n 5. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Entry_) as (_Exit_)\n 6. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Exit_) as (_Exit_)", "thus \"\\<exists>as. JVM_CFG_Interpret.path ?prog (_Entry_) as (_ [(''C'', ''M'', 0)],None _)\""], ["proof (prove)\nusing this:\n  JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n   (_Entry_)\n   [((_Entry_), (\\<lambda>s. True)\\<^sub>\\<surd>,\n     (_ [(''C'', ''M'', 0)],None _))]\n   (_ [(''C'', ''M'', 0)],None _)\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Entry_) as (_ [(''C'', ''M'', 0)],None _)", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>as.\n     JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n      (_Entry_) as (_ [(''C'', ''M'', 0)],None _)\n\ngoal (5 subgoals):\n 1. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_ [(''C'', ''M'', 0)],None _) as (_Exit_)\n 2. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Entry_) as (_ [(''C'', ''M'', Suc 0)],None _)\n 3. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_ [(''C'', ''M'', Suc 0)],None _) as (_Exit_)\n 4. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Entry_) as (_Exit_)\n 5. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Exit_) as (_Exit_)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_ [(''C'', ''M'', 0)],None _) as (_Exit_)\n 2. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Entry_) as (_ [(''C'', ''M'', Suc 0)],None _)\n 3. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_ [(''C'', ''M'', Suc 0)],None _) as (_Exit_)\n 4. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Entry_) as (_Exit_)\n 5. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Exit_) as (_Exit_)", "have \"JVM_CFG_Interpret.path ?prog (_ [(''C'', ''M'', 0)],None _) [?edge2, ?edge3] (_Exit_)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n     (_ [(''C'', ''M'', 0)],None _)\n     [((_ [(''C'', ''M'', 0)],None _),\n       \\<Up>\\<lambda>(h, stk, loc). (h, stk((0, 0) := Unit), loc),\n       (_ [(''C'', ''M'', 1)],None _)),\n      ((_ [(''C'', ''M'', 1)],None _), \\<Up>id, (_Exit_))]\n     (_Exit_)", "apply rule"], ["proof (prove)\ngoal (4 subgoals):\n 1. JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') ?n''\n     [((_ [(''C'', ''M'', 1)],None _), \\<Up>id, (_Exit_))] (_Exit_)\n 2. valid_edge (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n     ((_ [(''C'', ''M'', 0)],None _),\n      \\<Up>\\<lambda>(h, stk, loc). (h, stk((0, 0) := Unit), loc),\n      (_ [(''C'', ''M'', 1)],None _))\n 3. sourcenode\n     ((_ [(''C'', ''M'', 0)],None _),\n      \\<Up>\\<lambda>(h, stk, loc). (h, stk((0, 0) := Unit), loc),\n      (_ [(''C'', ''M'', 1)],None _)) =\n    (_ [(''C'', ''M'', 0)],None _)\n 4. targetnode\n     ((_ [(''C'', ''M'', 0)],None _),\n      \\<Up>\\<lambda>(h, stk, loc). (h, stk((0, 0) := Unit), loc),\n      (_ [(''C'', ''M'', 1)],None _)) =\n    ?n''", "apply rule"], ["proof (prove)\ngoal (7 subgoals):\n 1. JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') ?n''5\n     [] (_Exit_)\n 2. valid_edge (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n     ((_ [(''C'', ''M'', 1)],None _), \\<Up>id, (_Exit_))\n 3. sourcenode ((_ [(''C'', ''M'', 1)],None _), \\<Up>id, (_Exit_)) = ?n''\n 4. targetnode ((_ [(''C'', ''M'', 1)],None _), \\<Up>id, (_Exit_)) = ?n''5\n 5. valid_edge (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n     ((_ [(''C'', ''M'', 0)],None _),\n      \\<Up>\\<lambda>(h, stk, loc). (h, stk((0, 0) := Unit), loc),\n      (_ [(''C'', ''M'', 1)],None _))\n 6. sourcenode\n     ((_ [(''C'', ''M'', 0)],None _),\n      \\<Up>\\<lambda>(h, stk, loc). (h, stk((0, 0) := Unit), loc),\n      (_ [(''C'', ''M'', 1)],None _)) =\n    (_ [(''C'', ''M'', 0)],None _)\n 7. targetnode\n     ((_ [(''C'', ''M'', 0)],None _),\n      \\<Up>\\<lambda>(h, stk, loc). (h, stk((0, 0) := Unit), loc),\n      (_ [(''C'', ''M'', 1)],None _)) =\n    ?n''", "apply (auto simp: JVM_CFG_Interpret.path.empty_path Phi_EP_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n     ''M'') \\<turnstile> (_ [(''C'', ''M'',\n                              Suc 0)],None _) -\\<Up>id\\<rightarrow> (_Exit_)\n 2. (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n     ''M'') \\<turnstile> (_ [(''C'', ''M'',\n                              0)],None _) -\\<Up>\\<lambda>(h, stk, loc).\n             (h, stk((0, 0) := Unit),\n              loc)\\<rightarrow> (_ [(''C'', ''M'', Suc 0)],None _)", "apply (rule JCFG_ReturnExit, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n     ''M'') \\<turnstile> (_ [(''C'', ''M'',\n                              0)],None _) -\\<Up>\\<lambda>(h, stk, loc).\n             (h, stk((0, 0) := Unit),\n              loc)\\<rightarrow> (_ [(''C'', ''M'', Suc 0)],None _)", "by (rule JCFG_Straight_NoExc, auto simp: Phi_EP_def)"], ["proof (state)\nthis:\n  JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n   (_ [(''C'', ''M'', 0)],None _)\n   [((_ [(''C'', ''M'', 0)],None _),\n     \\<Up>\\<lambda>(h, stk, loc). (h, stk((0, 0) := Unit), loc),\n     (_ [(''C'', ''M'', 1)],None _)),\n    ((_ [(''C'', ''M'', 1)],None _), \\<Up>id, (_Exit_))]\n   (_Exit_)\n\ngoal (5 subgoals):\n 1. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_ [(''C'', ''M'', 0)],None _) as (_Exit_)\n 2. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Entry_) as (_ [(''C'', ''M'', Suc 0)],None _)\n 3. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_ [(''C'', ''M'', Suc 0)],None _) as (_Exit_)\n 4. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Entry_) as (_Exit_)\n 5. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Exit_) as (_Exit_)", "thus \"\\<exists>as. JVM_CFG_Interpret.path ?prog (_ [(''C'', ''M'', 0)],None _) as (_Exit_)\""], ["proof (prove)\nusing this:\n  JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n   (_ [(''C'', ''M'', 0)],None _)\n   [((_ [(''C'', ''M'', 0)],None _),\n     \\<Up>\\<lambda>(h, stk, loc). (h, stk((0, 0) := Unit), loc),\n     (_ [(''C'', ''M'', 1)],None _)),\n    ((_ [(''C'', ''M'', 1)],None _), \\<Up>id, (_Exit_))]\n   (_Exit_)\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_ [(''C'', ''M'', 0)],None _) as (_Exit_)", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>as.\n     JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n      (_ [(''C'', ''M'', 0)],None _) as (_Exit_)\n\ngoal (4 subgoals):\n 1. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Entry_) as (_ [(''C'', ''M'', Suc 0)],None _)\n 2. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_ [(''C'', ''M'', Suc 0)],None _) as (_Exit_)\n 3. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Entry_) as (_Exit_)\n 4. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Exit_) as (_Exit_)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Entry_) as (_ [(''C'', ''M'', Suc 0)],None _)\n 2. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_ [(''C'', ''M'', Suc 0)],None _) as (_Exit_)\n 3. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Entry_) as (_Exit_)\n 4. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Exit_) as (_Exit_)", "have \"JVM_CFG_Interpret.path ?prog (_Entry_) [?edge1, ?edge2] (_ [(''C'', ''M'', 1)],None _)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n     (_Entry_)\n     [((_Entry_), (\\<lambda>s. True)\\<^sub>\\<surd>,\n       (_ [(''C'', ''M'', 0)],None _)),\n      ((_ [(''C'', ''M'', 0)],None _),\n       \\<Up>\\<lambda>(h, stk, loc). (h, stk((0, 0) := Unit), loc),\n       (_ [(''C'', ''M'', 1)],None _))]\n     (_ [(''C'', ''M'', 1)],None _)", "apply rule"], ["proof (prove)\ngoal (4 subgoals):\n 1. JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') ?n''\n     [((_ [(''C'', ''M'', 0)],None _),\n       \\<Up>\\<lambda>(h, stk, loc). (h, stk((0, 0) := Unit), loc),\n       (_ [(''C'', ''M'', 1)],None _))]\n     (_ [(''C'', ''M'', 1)],None _)\n 2. valid_edge (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n     ((_Entry_), (\\<lambda>s. True)\\<^sub>\\<surd>,\n      (_ [(''C'', ''M'', 0)],None _))\n 3. sourcenode\n     ((_Entry_), (\\<lambda>s. True)\\<^sub>\\<surd>,\n      (_ [(''C'', ''M'', 0)],None _)) =\n    (_Entry_)\n 4. targetnode\n     ((_Entry_), (\\<lambda>s. True)\\<^sub>\\<surd>,\n      (_ [(''C'', ''M'', 0)],None _)) =\n    ?n''", "apply rule"], ["proof (prove)\ngoal (7 subgoals):\n 1. JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') ?n''5\n     [] (_ [(''C'', ''M'', 1)],None _)\n 2. valid_edge (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n     ((_ [(''C'', ''M'', 0)],None _),\n      \\<Up>\\<lambda>(h, stk, loc). (h, stk((0, 0) := Unit), loc),\n      (_ [(''C'', ''M'', 1)],None _))\n 3. sourcenode\n     ((_ [(''C'', ''M'', 0)],None _),\n      \\<Up>\\<lambda>(h, stk, loc). (h, stk((0, 0) := Unit), loc),\n      (_ [(''C'', ''M'', 1)],None _)) =\n    ?n''\n 4. targetnode\n     ((_ [(''C'', ''M'', 0)],None _),\n      \\<Up>\\<lambda>(h, stk, loc). (h, stk((0, 0) := Unit), loc),\n      (_ [(''C'', ''M'', 1)],None _)) =\n    ?n''5\n 5. valid_edge (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n     ((_Entry_), (\\<lambda>s. True)\\<^sub>\\<surd>,\n      (_ [(''C'', ''M'', 0)],None _))\n 6. sourcenode\n     ((_Entry_), (\\<lambda>s. True)\\<^sub>\\<surd>,\n      (_ [(''C'', ''M'', 0)],None _)) =\n    (_Entry_)\n 7. targetnode\n     ((_Entry_), (\\<lambda>s. True)\\<^sub>\\<surd>,\n      (_ [(''C'', ''M'', 0)],None _)) =\n    ?n''", "apply (auto simp: JVM_CFG_Interpret.path.empty_path Phi_EP_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n     ''M'') \\<turnstile> (_ [(''C'', ''M'',\n                              0)],None _) -\\<Up>\\<lambda>(h, stk, loc).\n             (h, stk((0, 0) := Unit),\n              loc)\\<rightarrow> (_ [(''C'', ''M'', Suc 0)],None _)\n 2. (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n     ''M'') \\<turnstile> (_Entry_) -(\\<lambda>s.\n  True)\\<^sub>\\<surd>\\<rightarrow> (_ [(''C'', ''M'', 0)],None _)", "apply (rule JCFG_Straight_NoExc, auto simp: Phi_EP_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n     ''M'') \\<turnstile> (_Entry_) -(\\<lambda>s.\n  True)\\<^sub>\\<surd>\\<rightarrow> (_ [(''C'', ''M'', 0)],None _)", "by (rule JCFG_EntryStart, auto)"], ["proof (state)\nthis:\n  JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n   (_Entry_)\n   [((_Entry_), (\\<lambda>s. True)\\<^sub>\\<surd>,\n     (_ [(''C'', ''M'', 0)],None _)),\n    ((_ [(''C'', ''M'', 0)],None _),\n     \\<Up>\\<lambda>(h, stk, loc). (h, stk((0, 0) := Unit), loc),\n     (_ [(''C'', ''M'', 1)],None _))]\n   (_ [(''C'', ''M'', 1)],None _)\n\ngoal (4 subgoals):\n 1. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Entry_) as (_ [(''C'', ''M'', Suc 0)],None _)\n 2. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_ [(''C'', ''M'', Suc 0)],None _) as (_Exit_)\n 3. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Entry_) as (_Exit_)\n 4. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Exit_) as (_Exit_)", "thus \"\\<exists>as. JVM_CFG_Interpret.path ?prog (_Entry_) as (_ [(''C'', ''M'', Suc 0)],None _)\""], ["proof (prove)\nusing this:\n  JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n   (_Entry_)\n   [((_Entry_), (\\<lambda>s. True)\\<^sub>\\<surd>,\n     (_ [(''C'', ''M'', 0)],None _)),\n    ((_ [(''C'', ''M'', 0)],None _),\n     \\<Up>\\<lambda>(h, stk, loc). (h, stk((0, 0) := Unit), loc),\n     (_ [(''C'', ''M'', 1)],None _))]\n   (_ [(''C'', ''M'', 1)],None _)\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Entry_) as (_ [(''C'', ''M'', Suc 0)],None _)", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>as.\n     JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n      (_Entry_) as (_ [(''C'', ''M'', Suc 0)],None _)\n\ngoal (3 subgoals):\n 1. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_ [(''C'', ''M'', Suc 0)],None _) as (_Exit_)\n 2. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Entry_) as (_Exit_)\n 3. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Exit_) as (_Exit_)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_ [(''C'', ''M'', Suc 0)],None _) as (_Exit_)\n 2. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Entry_) as (_Exit_)\n 3. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Exit_) as (_Exit_)", "have \"JVM_CFG_Interpret.path ?prog (_ [(''C'', ''M'', Suc 0)],None _) [?edge3] (_Exit_)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n     (_ [(''C'', ''M'', Suc 0)],None _)\n     [((_ [(''C'', ''M'', 1)],None _), \\<Up>id, (_Exit_))] (_Exit_)", "apply rule"], ["proof (prove)\ngoal (4 subgoals):\n 1. JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'') ?n''\n     [] (_Exit_)\n 2. valid_edge (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n     ((_ [(''C'', ''M'', 1)],None _), \\<Up>id, (_Exit_))\n 3. sourcenode ((_ [(''C'', ''M'', 1)],None _), \\<Up>id, (_Exit_)) =\n    (_ [(''C'', ''M'', Suc 0)],None _)\n 4. targetnode ((_ [(''C'', ''M'', 1)],None _), \\<Up>id, (_Exit_)) = ?n''", "apply (auto simp: JVM_CFG_Interpret.path.empty_path Phi_EP_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Abs_wf_jvmprog (EP, Phi_EP), ''C'',\n     ''M'') \\<turnstile> (_ [(''C'', ''M'',\n                              Suc 0)],None _) -\\<Up>id\\<rightarrow> (_Exit_)", "by (rule JCFG_ReturnExit, auto)"], ["proof (state)\nthis:\n  JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n   (_ [(''C'', ''M'', Suc 0)],None _)\n   [((_ [(''C'', ''M'', 1)],None _), \\<Up>id, (_Exit_))] (_Exit_)\n\ngoal (3 subgoals):\n 1. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_ [(''C'', ''M'', Suc 0)],None _) as (_Exit_)\n 2. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Entry_) as (_Exit_)\n 3. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Exit_) as (_Exit_)", "thus \"\\<exists>as. JVM_CFG_Interpret.path ?prog (_ [(''C'', ''M'', Suc 0)],None _) as (_Exit_)\""], ["proof (prove)\nusing this:\n  JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n   (_ [(''C'', ''M'', Suc 0)],None _)\n   [((_ [(''C'', ''M'', 1)],None _), \\<Up>id, (_Exit_))] (_Exit_)\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_ [(''C'', ''M'', Suc 0)],None _) as (_Exit_)", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>as.\n     JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n      (_ [(''C'', ''M'', Suc 0)],None _) as (_Exit_)\n\ngoal (2 subgoals):\n 1. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Entry_) as (_Exit_)\n 2. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Exit_) as (_Exit_)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Entry_) as (_Exit_)\n 2. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Exit_) as (_Exit_)", "have \"JVM_CFG_Interpret.path ?prog (_Entry_) [?edge0] (_Exit_)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n     (_Entry_) [((_Entry_), (\\<lambda>s. False)\\<^sub>\\<surd>, (_Exit_))]\n     (_Exit_)", "by rule (auto intro: JCFG_EntryExit JVM_CFG_Interpret.path.empty_path)"], ["proof (state)\nthis:\n  JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n   (_Entry_) [((_Entry_), (\\<lambda>s. False)\\<^sub>\\<surd>, (_Exit_))]\n   (_Exit_)\n\ngoal (2 subgoals):\n 1. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Entry_) as (_Exit_)\n 2. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Exit_) as (_Exit_)", "thus \"\\<exists>as. JVM_CFG_Interpret.path ?prog (_Entry_) as (_Exit_)\""], ["proof (prove)\nusing this:\n  JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n   (_Entry_) [((_Entry_), (\\<lambda>s. False)\\<^sub>\\<surd>, (_Exit_))]\n   (_Exit_)\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Entry_) as (_Exit_)", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>as.\n     JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n      (_Entry_) as (_Exit_)\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Exit_) as (_Exit_)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Exit_) as (_Exit_)", "have \"JVM_CFG_Interpret.path ?prog (_Exit_) [] (_Exit_)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n     (_Exit_) [] (_Exit_)", "by (simp add: JVM_CFG_Interpret.path.empty_path)"], ["proof (state)\nthis:\n  JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n   (_Exit_) [] (_Exit_)\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Exit_) as (_Exit_)", "thus \"\\<exists>as. JVM_CFG_Interpret.path ?prog (_Exit_) as (_Exit_)\""], ["proof (prove)\nusing this:\n  JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n   (_Exit_) [] (_Exit_)\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n        (_Exit_) as (_Exit_)", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>as.\n     JVM_CFG_Interpret.path (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n      (_Exit_) as (_Exit_)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (Abs_wf_jvmprog (EP, Phi_EP), ''C'', ''M'')\n  \\<in> {P. \\<forall>n.\n               valid_node P n \\<longrightarrow>\n               (\\<exists>as. JVM_CFG_Interpret.path P (_Entry_) as n) \\<and>\n               (\\<exists>as. JVM_CFG_Interpret.path P n as (_Exit_))}\n\ngoal:\nNo subgoals!", "qed"], ["", "abbreviation lift_to_cfg_wf_prog :: \"(jvmprog \\<Rightarrow> 'a) \\<Rightarrow> (cfg_wf_prog \\<Rightarrow> 'a)\"\n  (\"_\\<^bsub>CFG\\<^esub>\")\n  where \"f\\<^bsub>CFG\\<^esub> \\<equiv> (\\<lambda>P. f (Rep_cfg_wf_prog P))\""], ["", "section \\<open>Interpretation of the \\<open>Postdomination\\<close> locale\\<close>"], ["", "interpretation JVM_CFG_Postdomination:\n  Postdomination \"sourcenode\" \"targetnode\" \"kind\" \"valid_edge\\<^bsub>CFG\\<^esub> prog\" \"Entry\" \"(_Exit_)\"\n  for prog"], ["proof (prove)\ngoal (1 subgoal):\n 1. Postdomination sourcenode targetnode kind\n     (valid_edge\\<^bsub>CFG\\<^esub> prog) (_Entry_) (_Exit_)", "proof(unfold_locales)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n.\n       JVM_CFG_Interpret.valid_node\\<^bsub>CFG\\<^esub> prog\n        n \\<Longrightarrow>\n       \\<exists>as.\n          JVM_CFG_Interpret.path\\<^bsub>CFG\\<^esub> prog (_Entry_) as n\n 2. \\<And>n.\n       JVM_CFG_Interpret.valid_node\\<^bsub>CFG\\<^esub> prog\n        n \\<Longrightarrow>\n       \\<exists>as.\n          JVM_CFG_Interpret.path\\<^bsub>CFG\\<^esub> prog n as (_Exit_)", "fix n"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n.\n       JVM_CFG_Interpret.valid_node\\<^bsub>CFG\\<^esub> prog\n        n \\<Longrightarrow>\n       \\<exists>as.\n          JVM_CFG_Interpret.path\\<^bsub>CFG\\<^esub> prog (_Entry_) as n\n 2. \\<And>n.\n       JVM_CFG_Interpret.valid_node\\<^bsub>CFG\\<^esub> prog\n        n \\<Longrightarrow>\n       \\<exists>as.\n          JVM_CFG_Interpret.path\\<^bsub>CFG\\<^esub> prog n as (_Exit_)", "assume vn: \"CFG.valid_node sourcenode targetnode (valid_edge\\<^bsub>CFG\\<^esub> prog) n\""], ["proof (state)\nthis:\n  JVM_CFG_Interpret.valid_node\\<^bsub>CFG\\<^esub> prog n\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       JVM_CFG_Interpret.valid_node\\<^bsub>CFG\\<^esub> prog\n        n \\<Longrightarrow>\n       \\<exists>as.\n          JVM_CFG_Interpret.path\\<^bsub>CFG\\<^esub> prog (_Entry_) as n\n 2. \\<And>n.\n       JVM_CFG_Interpret.valid_node\\<^bsub>CFG\\<^esub> prog\n        n \\<Longrightarrow>\n       \\<exists>as.\n          JVM_CFG_Interpret.path\\<^bsub>CFG\\<^esub> prog n as (_Exit_)", "have prog_is_cfg_wf_prog: \"Rep_cfg_wf_prog prog \\<in> cfg_wf_prog\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<in>)\\<^bsub>CFG\\<^esub> prog cfg_wf_prog", "by (rule Rep_cfg_wf_prog)"], ["proof (state)\nthis:\n  (\\<in>)\\<^bsub>CFG\\<^esub> prog cfg_wf_prog\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       JVM_CFG_Interpret.valid_node\\<^bsub>CFG\\<^esub> prog\n        n \\<Longrightarrow>\n       \\<exists>as.\n          JVM_CFG_Interpret.path\\<^bsub>CFG\\<^esub> prog (_Entry_) as n\n 2. \\<And>n.\n       JVM_CFG_Interpret.valid_node\\<^bsub>CFG\\<^esub> prog\n        n \\<Longrightarrow>\n       \\<exists>as.\n          JVM_CFG_Interpret.path\\<^bsub>CFG\\<^esub> prog n as (_Exit_)", "obtain P C0 Main where [simp]: \"Rep_cfg_wf_prog prog = (P,C0,Main)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P C0 Main.\n        (=)\\<^bsub>CFG\\<^esub> prog (P, C0, Main) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"Rep_cfg_wf_prog prog\", fastforce)"], ["proof (state)\nthis:\n  (=)\\<^bsub>CFG\\<^esub> prog (P, C0, Main)\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       JVM_CFG_Interpret.valid_node\\<^bsub>CFG\\<^esub> prog\n        n \\<Longrightarrow>\n       \\<exists>as.\n          JVM_CFG_Interpret.path\\<^bsub>CFG\\<^esub> prog (_Entry_) as n\n 2. \\<And>n.\n       JVM_CFG_Interpret.valid_node\\<^bsub>CFG\\<^esub> prog\n        n \\<Longrightarrow>\n       \\<exists>as.\n          JVM_CFG_Interpret.path\\<^bsub>CFG\\<^esub> prog n as (_Exit_)", "from prog_is_cfg_wf_prog"], ["proof (chain)\npicking this:\n  (\\<in>)\\<^bsub>CFG\\<^esub> prog cfg_wf_prog", "have \"(P, C0, Main) \\<in> cfg_wf_prog\""], ["proof (prove)\nusing this:\n  (\\<in>)\\<^bsub>CFG\\<^esub> prog cfg_wf_prog\n\ngoal (1 subgoal):\n 1. (P, C0, Main) \\<in> cfg_wf_prog", "by simp"], ["proof (state)\nthis:\n  (P, C0, Main) \\<in> cfg_wf_prog\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       JVM_CFG_Interpret.valid_node\\<^bsub>CFG\\<^esub> prog\n        n \\<Longrightarrow>\n       \\<exists>as.\n          JVM_CFG_Interpret.path\\<^bsub>CFG\\<^esub> prog (_Entry_) as n\n 2. \\<And>n.\n       JVM_CFG_Interpret.valid_node\\<^bsub>CFG\\<^esub> prog\n        n \\<Longrightarrow>\n       \\<exists>as.\n          JVM_CFG_Interpret.path\\<^bsub>CFG\\<^esub> prog n as (_Exit_)", "hence \"valid_node (P, C0, Main) n \\<longrightarrow>\n    (\\<exists>as. CFG.path sourcenode targetnode (valid_edge (P, C0, Main)) (_Entry_) as n)\""], ["proof (prove)\nusing this:\n  (P, C0, Main) \\<in> cfg_wf_prog\n\ngoal (1 subgoal):\n 1. valid_node (P, C0, Main) n \\<longrightarrow>\n    (\\<exists>as. JVM_CFG_Interpret.path (P, C0, Main) (_Entry_) as n)", "by (fastforce simp: cfg_wf_prog_def)"], ["proof (state)\nthis:\n  valid_node (P, C0, Main) n \\<longrightarrow>\n  (\\<exists>as. JVM_CFG_Interpret.path (P, C0, Main) (_Entry_) as n)\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       JVM_CFG_Interpret.valid_node\\<^bsub>CFG\\<^esub> prog\n        n \\<Longrightarrow>\n       \\<exists>as.\n          JVM_CFG_Interpret.path\\<^bsub>CFG\\<^esub> prog (_Entry_) as n\n 2. \\<And>n.\n       JVM_CFG_Interpret.valid_node\\<^bsub>CFG\\<^esub> prog\n        n \\<Longrightarrow>\n       \\<exists>as.\n          JVM_CFG_Interpret.path\\<^bsub>CFG\\<^esub> prog n as (_Exit_)", "moreover"], ["proof (state)\nthis:\n  valid_node (P, C0, Main) n \\<longrightarrow>\n  (\\<exists>as. JVM_CFG_Interpret.path (P, C0, Main) (_Entry_) as n)\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       JVM_CFG_Interpret.valid_node\\<^bsub>CFG\\<^esub> prog\n        n \\<Longrightarrow>\n       \\<exists>as.\n          JVM_CFG_Interpret.path\\<^bsub>CFG\\<^esub> prog (_Entry_) as n\n 2. \\<And>n.\n       JVM_CFG_Interpret.valid_node\\<^bsub>CFG\\<^esub> prog\n        n \\<Longrightarrow>\n       \\<exists>as.\n          JVM_CFG_Interpret.path\\<^bsub>CFG\\<^esub> prog n as (_Exit_)", "from vn"], ["proof (chain)\npicking this:\n  JVM_CFG_Interpret.valid_node\\<^bsub>CFG\\<^esub> prog n", "have \"valid_node (P, C0, Main) n\""], ["proof (prove)\nusing this:\n  JVM_CFG_Interpret.valid_node\\<^bsub>CFG\\<^esub> prog n\n\ngoal (1 subgoal):\n 1. valid_node (P, C0, Main) n", "by (auto simp: JVM_CFG_Interpret.valid_node_def)"], ["proof (state)\nthis:\n  valid_node (P, C0, Main) n\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       JVM_CFG_Interpret.valid_node\\<^bsub>CFG\\<^esub> prog\n        n \\<Longrightarrow>\n       \\<exists>as.\n          JVM_CFG_Interpret.path\\<^bsub>CFG\\<^esub> prog (_Entry_) as n\n 2. \\<And>n.\n       JVM_CFG_Interpret.valid_node\\<^bsub>CFG\\<^esub> prog\n        n \\<Longrightarrow>\n       \\<exists>as.\n          JVM_CFG_Interpret.path\\<^bsub>CFG\\<^esub> prog n as (_Exit_)", "ultimately"], ["proof (chain)\npicking this:\n  valid_node (P, C0, Main) n \\<longrightarrow>\n  (\\<exists>as. JVM_CFG_Interpret.path (P, C0, Main) (_Entry_) as n)\n  valid_node (P, C0, Main) n", "show \"\\<exists>as. CFG.path sourcenode targetnode (valid_edge\\<^bsub>CFG\\<^esub> prog) (_Entry_) as n\""], ["proof (prove)\nusing this:\n  valid_node (P, C0, Main) n \\<longrightarrow>\n  (\\<exists>as. JVM_CFG_Interpret.path (P, C0, Main) (_Entry_) as n)\n  valid_node (P, C0, Main) n\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       JVM_CFG_Interpret.path\\<^bsub>CFG\\<^esub> prog (_Entry_) as n", "by simp"], ["proof (state)\nthis:\n  \\<exists>as. JVM_CFG_Interpret.path\\<^bsub>CFG\\<^esub> prog (_Entry_) as n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       JVM_CFG_Interpret.valid_node\\<^bsub>CFG\\<^esub> prog\n        n \\<Longrightarrow>\n       \\<exists>as.\n          JVM_CFG_Interpret.path\\<^bsub>CFG\\<^esub> prog n as (_Exit_)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       JVM_CFG_Interpret.valid_node\\<^bsub>CFG\\<^esub> prog\n        n \\<Longrightarrow>\n       \\<exists>as.\n          JVM_CFG_Interpret.path\\<^bsub>CFG\\<^esub> prog n as (_Exit_)", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       JVM_CFG_Interpret.valid_node\\<^bsub>CFG\\<^esub> prog\n        n \\<Longrightarrow>\n       \\<exists>as.\n          JVM_CFG_Interpret.path\\<^bsub>CFG\\<^esub> prog n as (_Exit_)", "assume vn: \"CFG.valid_node sourcenode targetnode (valid_edge\\<^bsub>CFG\\<^esub> prog) n\""], ["proof (state)\nthis:\n  JVM_CFG_Interpret.valid_node\\<^bsub>CFG\\<^esub> prog n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       JVM_CFG_Interpret.valid_node\\<^bsub>CFG\\<^esub> prog\n        n \\<Longrightarrow>\n       \\<exists>as.\n          JVM_CFG_Interpret.path\\<^bsub>CFG\\<^esub> prog n as (_Exit_)", "have prog_is_cfg_wf_prog: \"Rep_cfg_wf_prog prog \\<in> cfg_wf_prog\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<in>)\\<^bsub>CFG\\<^esub> prog cfg_wf_prog", "by (rule Rep_cfg_wf_prog)"], ["proof (state)\nthis:\n  (\\<in>)\\<^bsub>CFG\\<^esub> prog cfg_wf_prog\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       JVM_CFG_Interpret.valid_node\\<^bsub>CFG\\<^esub> prog\n        n \\<Longrightarrow>\n       \\<exists>as.\n          JVM_CFG_Interpret.path\\<^bsub>CFG\\<^esub> prog n as (_Exit_)", "obtain P C0 Main where [simp]: \"Rep_cfg_wf_prog prog = (P,C0,Main)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P C0 Main.\n        (=)\\<^bsub>CFG\\<^esub> prog (P, C0, Main) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"Rep_cfg_wf_prog prog\", fastforce)"], ["proof (state)\nthis:\n  (=)\\<^bsub>CFG\\<^esub> prog (P, C0, Main)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       JVM_CFG_Interpret.valid_node\\<^bsub>CFG\\<^esub> prog\n        n \\<Longrightarrow>\n       \\<exists>as.\n          JVM_CFG_Interpret.path\\<^bsub>CFG\\<^esub> prog n as (_Exit_)", "from prog_is_cfg_wf_prog"], ["proof (chain)\npicking this:\n  (\\<in>)\\<^bsub>CFG\\<^esub> prog cfg_wf_prog", "have \"(P, C0, Main) \\<in> cfg_wf_prog\""], ["proof (prove)\nusing this:\n  (\\<in>)\\<^bsub>CFG\\<^esub> prog cfg_wf_prog\n\ngoal (1 subgoal):\n 1. (P, C0, Main) \\<in> cfg_wf_prog", "by simp"], ["proof (state)\nthis:\n  (P, C0, Main) \\<in> cfg_wf_prog\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       JVM_CFG_Interpret.valid_node\\<^bsub>CFG\\<^esub> prog\n        n \\<Longrightarrow>\n       \\<exists>as.\n          JVM_CFG_Interpret.path\\<^bsub>CFG\\<^esub> prog n as (_Exit_)", "hence \"valid_node (P, C0, Main) n \\<longrightarrow>\n    (\\<exists>as. CFG.path sourcenode targetnode (valid_edge (P, C0, Main)) n as (_Exit_))\""], ["proof (prove)\nusing this:\n  (P, C0, Main) \\<in> cfg_wf_prog\n\ngoal (1 subgoal):\n 1. valid_node (P, C0, Main) n \\<longrightarrow>\n    (\\<exists>as. JVM_CFG_Interpret.path (P, C0, Main) n as (_Exit_))", "by (fastforce simp: cfg_wf_prog_def)"], ["proof (state)\nthis:\n  valid_node (P, C0, Main) n \\<longrightarrow>\n  (\\<exists>as. JVM_CFG_Interpret.path (P, C0, Main) n as (_Exit_))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       JVM_CFG_Interpret.valid_node\\<^bsub>CFG\\<^esub> prog\n        n \\<Longrightarrow>\n       \\<exists>as.\n          JVM_CFG_Interpret.path\\<^bsub>CFG\\<^esub> prog n as (_Exit_)", "moreover"], ["proof (state)\nthis:\n  valid_node (P, C0, Main) n \\<longrightarrow>\n  (\\<exists>as. JVM_CFG_Interpret.path (P, C0, Main) n as (_Exit_))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       JVM_CFG_Interpret.valid_node\\<^bsub>CFG\\<^esub> prog\n        n \\<Longrightarrow>\n       \\<exists>as.\n          JVM_CFG_Interpret.path\\<^bsub>CFG\\<^esub> prog n as (_Exit_)", "from vn"], ["proof (chain)\npicking this:\n  JVM_CFG_Interpret.valid_node\\<^bsub>CFG\\<^esub> prog n", "have \"valid_node (P, C0, Main) n\""], ["proof (prove)\nusing this:\n  JVM_CFG_Interpret.valid_node\\<^bsub>CFG\\<^esub> prog n\n\ngoal (1 subgoal):\n 1. valid_node (P, C0, Main) n", "by (auto simp: JVM_CFG_Interpret.valid_node_def)"], ["proof (state)\nthis:\n  valid_node (P, C0, Main) n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       JVM_CFG_Interpret.valid_node\\<^bsub>CFG\\<^esub> prog\n        n \\<Longrightarrow>\n       \\<exists>as.\n          JVM_CFG_Interpret.path\\<^bsub>CFG\\<^esub> prog n as (_Exit_)", "ultimately"], ["proof (chain)\npicking this:\n  valid_node (P, C0, Main) n \\<longrightarrow>\n  (\\<exists>as. JVM_CFG_Interpret.path (P, C0, Main) n as (_Exit_))\n  valid_node (P, C0, Main) n", "show \"\\<exists>as. CFG.path sourcenode targetnode (valid_edge\\<^bsub>CFG\\<^esub> prog) n as (_Exit_)\""], ["proof (prove)\nusing this:\n  valid_node (P, C0, Main) n \\<longrightarrow>\n  (\\<exists>as. JVM_CFG_Interpret.path (P, C0, Main) n as (_Exit_))\n  valid_node (P, C0, Main) n\n\ngoal (1 subgoal):\n 1. \\<exists>as.\n       JVM_CFG_Interpret.path\\<^bsub>CFG\\<^esub> prog n as (_Exit_)", "by simp"], ["proof (state)\nthis:\n  \\<exists>as. JVM_CFG_Interpret.path\\<^bsub>CFG\\<^esub> prog n as (_Exit_)\n\ngoal:\nNo subgoals!", "qed"], ["", "section \\<open>Interpretation of the \\<open>StrongPostdomination\\<close> locale\\<close>"], ["", "subsection \\<open>Some helpfull lemmas\\<close>"], ["", "lemma find_handler_for_tl_eq:\n  \"find_handler_for P Exc cs = (C,M,pcx)#cs' \\<Longrightarrow> \\<exists>cs'' pc. cs = cs'' @ [(C,M,pc)] @ cs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. find_handler_for P Exc cs = (C, M, pcx) # cs' \\<Longrightarrow>\n    \\<exists>cs'' pc. cs = cs'' @ [(C, M, pc)] @ cs'", "by (induct cs, auto)"], ["", "lemma valid_callstack_tl:\n  \"valid_callstack prog ((C,M,pc)#cs) \\<Longrightarrow> valid_callstack prog cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_callstack prog ((C, M, pc) # cs) \\<Longrightarrow>\n    valid_callstack prog cs", "by (cases prog, cases cs, auto)"], ["", "lemma find_handler_Throw_Invoke_pc_in_range:\n  \"\\<lbrakk>cs = (C',M',pc')#cs'; valid_callstack (P,C0,Main) cs;\n  instrs_of (P\\<^bsub>wf\\<^esub>) C' M' ! pc' = Throw \\<or> (\\<exists>M'' n''. instrs_of (P\\<^bsub>wf\\<^esub>) C' M' ! pc' = Invoke M'' n'');\n  find_handler_for P Exc cs = (C,M,pc)#cs'' \\<rbrakk>\n  \\<Longrightarrow> pc < length (instrs_of (P\\<^bsub>wf\\<^esub>) C M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cs = (C', M', pc') # cs'; valid_callstack (P, C0, Main) cs;\n     instrs_of P\\<^bsub>wf\\<^esub> C' M' ! pc' = Throw \\<or>\n     (\\<exists>M'' n''.\n         instrs_of P\\<^bsub>wf\\<^esub> C' M' ! pc' = Invoke M'' n'');\n     find_handler_for P Exc cs = (C, M, pc) # cs''\\<rbrakk>\n    \\<Longrightarrow> pc < length (instrs_of P\\<^bsub>wf\\<^esub> C M)", "proof (induct cs arbitrary: C' M' pc' cs')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C' M' pc' cs'.\n       \\<lbrakk>[] = (C', M', pc') # cs'; valid_callstack (P, C0, Main) [];\n        instrs_of P\\<^bsub>wf\\<^esub> C' M' ! pc' = Throw \\<or>\n        (\\<exists>M'' n''.\n            instrs_of P\\<^bsub>wf\\<^esub> C' M' ! pc' = Invoke M'' n'');\n        find_handler_for P Exc [] = (C, M, pc) # cs''\\<rbrakk>\n       \\<Longrightarrow> pc < length (instrs_of P\\<^bsub>wf\\<^esub> C M)\n 2. \\<And>a cs C' M' pc' cs'.\n       \\<lbrakk>\\<And>C' M' pc' cs'.\n                   \\<lbrakk>cs = (C', M', pc') # cs';\n                    valid_callstack (P, C0, Main) cs;\n                    instrs_of P\\<^bsub>wf\\<^esub> C' M' ! pc' = Throw \\<or>\n                    (\\<exists>M'' n''.\n                        instrs_of P\\<^bsub>wf\\<^esub> C' M' ! pc' =\n                        Invoke M'' n'');\n                    find_handler_for P Exc cs = (C, M, pc) # cs''\\<rbrakk>\n                   \\<Longrightarrow> pc < length\n     (instrs_of P\\<^bsub>wf\\<^esub> C M);\n        a # cs = (C', M', pc') # cs';\n        valid_callstack (P, C0, Main) (a # cs);\n        instrs_of P\\<^bsub>wf\\<^esub> C' M' ! pc' = Throw \\<or>\n        (\\<exists>M'' n''.\n            instrs_of P\\<^bsub>wf\\<^esub> C' M' ! pc' = Invoke M'' n'');\n        find_handler_for P Exc (a # cs) = (C, M, pc) # cs''\\<rbrakk>\n       \\<Longrightarrow> pc < length (instrs_of P\\<^bsub>wf\\<^esub> C M)", "case Nil"], ["proof (state)\nthis:\n  [] = (C', M', pc') # cs'\n  valid_callstack (P, C0, Main) []\n  instrs_of P\\<^bsub>wf\\<^esub> C' M' ! pc' = Throw \\<or>\n  (\\<exists>M'' n''.\n      instrs_of P\\<^bsub>wf\\<^esub> C' M' ! pc' = Invoke M'' n'')\n  find_handler_for P Exc [] = (C, M, pc) # cs''\n\ngoal (2 subgoals):\n 1. \\<And>C' M' pc' cs'.\n       \\<lbrakk>[] = (C', M', pc') # cs'; valid_callstack (P, C0, Main) [];\n        instrs_of P\\<^bsub>wf\\<^esub> C' M' ! pc' = Throw \\<or>\n        (\\<exists>M'' n''.\n            instrs_of P\\<^bsub>wf\\<^esub> C' M' ! pc' = Invoke M'' n'');\n        find_handler_for P Exc [] = (C, M, pc) # cs''\\<rbrakk>\n       \\<Longrightarrow> pc < length (instrs_of P\\<^bsub>wf\\<^esub> C M)\n 2. \\<And>a cs C' M' pc' cs'.\n       \\<lbrakk>\\<And>C' M' pc' cs'.\n                   \\<lbrakk>cs = (C', M', pc') # cs';\n                    valid_callstack (P, C0, Main) cs;\n                    instrs_of P\\<^bsub>wf\\<^esub> C' M' ! pc' = Throw \\<or>\n                    (\\<exists>M'' n''.\n                        instrs_of P\\<^bsub>wf\\<^esub> C' M' ! pc' =\n                        Invoke M'' n'');\n                    find_handler_for P Exc cs = (C, M, pc) # cs''\\<rbrakk>\n                   \\<Longrightarrow> pc < length\n     (instrs_of P\\<^bsub>wf\\<^esub> C M);\n        a # cs = (C', M', pc') # cs';\n        valid_callstack (P, C0, Main) (a # cs);\n        instrs_of P\\<^bsub>wf\\<^esub> C' M' ! pc' = Throw \\<or>\n        (\\<exists>M'' n''.\n            instrs_of P\\<^bsub>wf\\<^esub> C' M' ! pc' = Invoke M'' n'');\n        find_handler_for P Exc (a # cs) = (C, M, pc) # cs''\\<rbrakk>\n       \\<Longrightarrow> pc < length (instrs_of P\\<^bsub>wf\\<^esub> C M)", "thus ?case"], ["proof (prove)\nusing this:\n  [] = (C', M', pc') # cs'\n  valid_callstack (P, C0, Main) []\n  instrs_of P\\<^bsub>wf\\<^esub> C' M' ! pc' = Throw \\<or>\n  (\\<exists>M'' n''.\n      instrs_of P\\<^bsub>wf\\<^esub> C' M' ! pc' = Invoke M'' n'')\n  find_handler_for P Exc [] = (C, M, pc) # cs''\n\ngoal (1 subgoal):\n 1. pc < length (instrs_of P\\<^bsub>wf\\<^esub> C M)", "by simp"], ["proof (state)\nthis:\n  pc < length (instrs_of P\\<^bsub>wf\\<^esub> C M)\n\ngoal (1 subgoal):\n 1. \\<And>a cs C' M' pc' cs'.\n       \\<lbrakk>\\<And>C' M' pc' cs'.\n                   \\<lbrakk>cs = (C', M', pc') # cs';\n                    valid_callstack (P, C0, Main) cs;\n                    instrs_of P\\<^bsub>wf\\<^esub> C' M' ! pc' = Throw \\<or>\n                    (\\<exists>M'' n''.\n                        instrs_of P\\<^bsub>wf\\<^esub> C' M' ! pc' =\n                        Invoke M'' n'');\n                    find_handler_for P Exc cs = (C, M, pc) # cs''\\<rbrakk>\n                   \\<Longrightarrow> pc < length\n     (instrs_of P\\<^bsub>wf\\<^esub> C M);\n        a # cs = (C', M', pc') # cs';\n        valid_callstack (P, C0, Main) (a # cs);\n        instrs_of P\\<^bsub>wf\\<^esub> C' M' ! pc' = Throw \\<or>\n        (\\<exists>M'' n''.\n            instrs_of P\\<^bsub>wf\\<^esub> C' M' ! pc' = Invoke M'' n'');\n        find_handler_for P Exc (a # cs) = (C, M, pc) # cs''\\<rbrakk>\n       \\<Longrightarrow> pc < length (instrs_of P\\<^bsub>wf\\<^esub> C M)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a cs C' M' pc' cs'.\n       \\<lbrakk>\\<And>C' M' pc' cs'.\n                   \\<lbrakk>cs = (C', M', pc') # cs';\n                    valid_callstack (P, C0, Main) cs;\n                    instrs_of P\\<^bsub>wf\\<^esub> C' M' ! pc' = Throw \\<or>\n                    (\\<exists>M'' n''.\n                        instrs_of P\\<^bsub>wf\\<^esub> C' M' ! pc' =\n                        Invoke M'' n'');\n                    find_handler_for P Exc cs = (C, M, pc) # cs''\\<rbrakk>\n                   \\<Longrightarrow> pc < length\n     (instrs_of P\\<^bsub>wf\\<^esub> C M);\n        a # cs = (C', M', pc') # cs';\n        valid_callstack (P, C0, Main) (a # cs);\n        instrs_of P\\<^bsub>wf\\<^esub> C' M' ! pc' = Throw \\<or>\n        (\\<exists>M'' n''.\n            instrs_of P\\<^bsub>wf\\<^esub> C' M' ! pc' = Invoke M'' n'');\n        find_handler_for P Exc (a # cs) = (C, M, pc) # cs''\\<rbrakk>\n       \\<Longrightarrow> pc < length (instrs_of P\\<^bsub>wf\\<^esub> C M)", "case (Cons a cs)"], ["proof (state)\nthis:\n  \\<lbrakk>cs = (?C', ?M', ?pc') # ?cs'; valid_callstack (P, C0, Main) cs;\n   instrs_of P\\<^bsub>wf\\<^esub> ?C' ?M' ! ?pc' = Throw \\<or>\n   (\\<exists>M'' n''.\n       instrs_of P\\<^bsub>wf\\<^esub> ?C' ?M' ! ?pc' = Invoke M'' n'');\n   find_handler_for P Exc cs = (C, M, pc) # cs''\\<rbrakk>\n  \\<Longrightarrow> pc < length (instrs_of P\\<^bsub>wf\\<^esub> C M)\n  a # cs = (C', M', pc') # cs'\n  valid_callstack (P, C0, Main) (a # cs)\n  instrs_of P\\<^bsub>wf\\<^esub> C' M' ! pc' = Throw \\<or>\n  (\\<exists>M'' n''.\n      instrs_of P\\<^bsub>wf\\<^esub> C' M' ! pc' = Invoke M'' n'')\n  find_handler_for P Exc (a # cs) = (C, M, pc) # cs''\n\ngoal (1 subgoal):\n 1. \\<And>a cs C' M' pc' cs'.\n       \\<lbrakk>\\<And>C' M' pc' cs'.\n                   \\<lbrakk>cs = (C', M', pc') # cs';\n                    valid_callstack (P, C0, Main) cs;\n                    instrs_of P\\<^bsub>wf\\<^esub> C' M' ! pc' = Throw \\<or>\n                    (\\<exists>M'' n''.\n                        instrs_of P\\<^bsub>wf\\<^esub> C' M' ! pc' =\n                        Invoke M'' n'');\n                    find_handler_for P Exc cs = (C, M, pc) # cs''\\<rbrakk>\n                   \\<Longrightarrow> pc < length\n     (instrs_of P\\<^bsub>wf\\<^esub> C M);\n        a # cs = (C', M', pc') # cs';\n        valid_callstack (P, C0, Main) (a # cs);\n        instrs_of P\\<^bsub>wf\\<^esub> C' M' ! pc' = Throw \\<or>\n        (\\<exists>M'' n''.\n            instrs_of P\\<^bsub>wf\\<^esub> C' M' ! pc' = Invoke M'' n'');\n        find_handler_for P Exc (a # cs) = (C, M, pc) # cs''\\<rbrakk>\n       \\<Longrightarrow> pc < length (instrs_of P\\<^bsub>wf\\<^esub> C M)", "hence [simp]: \"a = (C',M',pc')\" and [simp]: \"cs = cs'\""], ["proof (prove)\nusing this:\n  \\<lbrakk>cs = (?C', ?M', ?pc') # ?cs'; valid_callstack (P, C0, Main) cs;\n   instrs_of P\\<^bsub>wf\\<^esub> ?C' ?M' ! ?pc' = Throw \\<or>\n   (\\<exists>M'' n''.\n       instrs_of P\\<^bsub>wf\\<^esub> ?C' ?M' ! ?pc' = Invoke M'' n'');\n   find_handler_for P Exc cs = (C, M, pc) # cs''\\<rbrakk>\n  \\<Longrightarrow> pc < length (instrs_of P\\<^bsub>wf\\<^esub> C M)\n  a # cs = (C', M', pc') # cs'\n  valid_callstack (P, C0, Main) (a # cs)\n  instrs_of P\\<^bsub>wf\\<^esub> C' M' ! pc' = Throw \\<or>\n  (\\<exists>M'' n''.\n      instrs_of P\\<^bsub>wf\\<^esub> C' M' ! pc' = Invoke M'' n'')\n  find_handler_for P Exc (a # cs) = (C, M, pc) # cs''\n\ngoal (1 subgoal):\n 1. a = (C', M', pc') &&& cs = cs'", "by simp_all"], ["proof (state)\nthis:\n  a = (C', M', pc')\n  cs = cs'\n\ngoal (1 subgoal):\n 1. \\<And>a cs C' M' pc' cs'.\n       \\<lbrakk>\\<And>C' M' pc' cs'.\n                   \\<lbrakk>cs = (C', M', pc') # cs';\n                    valid_callstack (P, C0, Main) cs;\n                    instrs_of P\\<^bsub>wf\\<^esub> C' M' ! pc' = Throw \\<or>\n                    (\\<exists>M'' n''.\n                        instrs_of P\\<^bsub>wf\\<^esub> C' M' ! pc' =\n                        Invoke M'' n'');\n                    find_handler_for P Exc cs = (C, M, pc) # cs''\\<rbrakk>\n                   \\<Longrightarrow> pc < length\n     (instrs_of P\\<^bsub>wf\\<^esub> C M);\n        a # cs = (C', M', pc') # cs';\n        valid_callstack (P, C0, Main) (a # cs);\n        instrs_of P\\<^bsub>wf\\<^esub> C' M' ! pc' = Throw \\<or>\n        (\\<exists>M'' n''.\n            instrs_of P\\<^bsub>wf\\<^esub> C' M' ! pc' = Invoke M'' n'');\n        find_handler_for P Exc (a # cs) = (C, M, pc) # cs''\\<rbrakk>\n       \\<Longrightarrow> pc < length (instrs_of P\\<^bsub>wf\\<^esub> C M)", "note IH = \\<open>\\<And>C' M' pc' cs'.\n           \\<lbrakk>cs = (C', M', pc') # cs'; valid_callstack (P, C0, Main) cs;\n            instrs_of P\\<^bsub>wf\\<^esub> C' M' ! pc' = Throw \\<or>\n            (\\<exists>M'' n''. instrs_of P\\<^bsub>wf\\<^esub> C' M' ! pc' = Invoke M'' n'');\n            find_handler_for P Exc cs = (C, M, pc) # cs''\\<rbrakk>\n           \\<Longrightarrow> pc < length (instrs_of P\\<^bsub>wf\\<^esub> C M)\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>cs = (?C', ?M', ?pc') # ?cs'; valid_callstack (P, C0, Main) cs;\n   instrs_of P\\<^bsub>wf\\<^esub> ?C' ?M' ! ?pc' = Throw \\<or>\n   (\\<exists>M'' n''.\n       instrs_of P\\<^bsub>wf\\<^esub> ?C' ?M' ! ?pc' = Invoke M'' n'');\n   find_handler_for P Exc cs = (C, M, pc) # cs''\\<rbrakk>\n  \\<Longrightarrow> pc < length (instrs_of P\\<^bsub>wf\\<^esub> C M)\n\ngoal (1 subgoal):\n 1. \\<And>a cs C' M' pc' cs'.\n       \\<lbrakk>\\<And>C' M' pc' cs'.\n                   \\<lbrakk>cs = (C', M', pc') # cs';\n                    valid_callstack (P, C0, Main) cs;\n                    instrs_of P\\<^bsub>wf\\<^esub> C' M' ! pc' = Throw \\<or>\n                    (\\<exists>M'' n''.\n                        instrs_of P\\<^bsub>wf\\<^esub> C' M' ! pc' =\n                        Invoke M'' n'');\n                    find_handler_for P Exc cs = (C, M, pc) # cs''\\<rbrakk>\n                   \\<Longrightarrow> pc < length\n     (instrs_of P\\<^bsub>wf\\<^esub> C M);\n        a # cs = (C', M', pc') # cs';\n        valid_callstack (P, C0, Main) (a # cs);\n        instrs_of P\\<^bsub>wf\\<^esub> C' M' ! pc' = Throw \\<or>\n        (\\<exists>M'' n''.\n            instrs_of P\\<^bsub>wf\\<^esub> C' M' ! pc' = Invoke M'' n'');\n        find_handler_for P Exc (a # cs) = (C, M, pc) # cs''\\<rbrakk>\n       \\<Longrightarrow> pc < length (instrs_of P\\<^bsub>wf\\<^esub> C M)", "note throw = \\<open>instrs_of P\\<^bsub>wf\\<^esub> C' M' ! pc' = Throw \\<or> (\\<exists>M'' n''. instrs_of P\\<^bsub>wf\\<^esub> C' M' ! pc' = Invoke M'' n'')\\<close>"], ["proof (state)\nthis:\n  instrs_of P\\<^bsub>wf\\<^esub> C' M' ! pc' = Throw \\<or>\n  (\\<exists>M'' n''.\n      instrs_of P\\<^bsub>wf\\<^esub> C' M' ! pc' = Invoke M'' n'')\n\ngoal (1 subgoal):\n 1. \\<And>a cs C' M' pc' cs'.\n       \\<lbrakk>\\<And>C' M' pc' cs'.\n                   \\<lbrakk>cs = (C', M', pc') # cs';\n                    valid_callstack (P, C0, Main) cs;\n                    instrs_of P\\<^bsub>wf\\<^esub> C' M' ! pc' = Throw \\<or>\n                    (\\<exists>M'' n''.\n                        instrs_of P\\<^bsub>wf\\<^esub> C' M' ! pc' =\n                        Invoke M'' n'');\n                    find_handler_for P Exc cs = (C, M, pc) # cs''\\<rbrakk>\n                   \\<Longrightarrow> pc < length\n     (instrs_of P\\<^bsub>wf\\<^esub> C M);\n        a # cs = (C', M', pc') # cs';\n        valid_callstack (P, C0, Main) (a # cs);\n        instrs_of P\\<^bsub>wf\\<^esub> C' M' ! pc' = Throw \\<or>\n        (\\<exists>M'' n''.\n            instrs_of P\\<^bsub>wf\\<^esub> C' M' ! pc' = Invoke M'' n'');\n        find_handler_for P Exc (a # cs) = (C, M, pc) # cs''\\<rbrakk>\n       \\<Longrightarrow> pc < length (instrs_of P\\<^bsub>wf\\<^esub> C M)", "note fhf = \\<open>find_handler_for P Exc (a # cs) = (C, M, pc) # cs''\\<close>"], ["proof (state)\nthis:\n  find_handler_for P Exc (a # cs) = (C, M, pc) # cs''\n\ngoal (1 subgoal):\n 1. \\<And>a cs C' M' pc' cs'.\n       \\<lbrakk>\\<And>C' M' pc' cs'.\n                   \\<lbrakk>cs = (C', M', pc') # cs';\n                    valid_callstack (P, C0, Main) cs;\n                    instrs_of P\\<^bsub>wf\\<^esub> C' M' ! pc' = Throw \\<or>\n                    (\\<exists>M'' n''.\n                        instrs_of P\\<^bsub>wf\\<^esub> C' M' ! pc' =\n                        Invoke M'' n'');\n                    find_handler_for P Exc cs = (C, M, pc) # cs''\\<rbrakk>\n                   \\<Longrightarrow> pc < length\n     (instrs_of P\\<^bsub>wf\\<^esub> C M);\n        a # cs = (C', M', pc') # cs';\n        valid_callstack (P, C0, Main) (a # cs);\n        instrs_of P\\<^bsub>wf\\<^esub> C' M' ! pc' = Throw \\<or>\n        (\\<exists>M'' n''.\n            instrs_of P\\<^bsub>wf\\<^esub> C' M' ! pc' = Invoke M'' n'');\n        find_handler_for P Exc (a # cs) = (C, M, pc) # cs''\\<rbrakk>\n       \\<Longrightarrow> pc < length (instrs_of P\\<^bsub>wf\\<^esub> C M)", "note v_cs_a_cs = \\<open>valid_callstack (P, C0, Main) (a # cs)\\<close>"], ["proof (state)\nthis:\n  valid_callstack (P, C0, Main) (a # cs)\n\ngoal (1 subgoal):\n 1. \\<And>a cs C' M' pc' cs'.\n       \\<lbrakk>\\<And>C' M' pc' cs'.\n                   \\<lbrakk>cs = (C', M', pc') # cs';\n                    valid_callstack (P, C0, Main) cs;\n                    instrs_of P\\<^bsub>wf\\<^esub> C' M' ! pc' = Throw \\<or>\n                    (\\<exists>M'' n''.\n                        instrs_of P\\<^bsub>wf\\<^esub> C' M' ! pc' =\n                        Invoke M'' n'');\n                    find_handler_for P Exc cs = (C, M, pc) # cs''\\<rbrakk>\n                   \\<Longrightarrow> pc < length\n     (instrs_of P\\<^bsub>wf\\<^esub> C M);\n        a # cs = (C', M', pc') # cs';\n        valid_callstack (P, C0, Main) (a # cs);\n        instrs_of P\\<^bsub>wf\\<^esub> C' M' ! pc' = Throw \\<or>\n        (\\<exists>M'' n''.\n            instrs_of P\\<^bsub>wf\\<^esub> C' M' ! pc' = Invoke M'' n'');\n        find_handler_for P Exc (a # cs) = (C, M, pc) # cs''\\<rbrakk>\n       \\<Longrightarrow> pc < length (instrs_of P\\<^bsub>wf\\<^esub> C M)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. pc < length (instrs_of P\\<^bsub>wf\\<^esub> C M)", "proof (cases \"match_ex_table (P\\<^bsub>wf\\<^esub>) Exc pc' (ex_table_of (P\\<^bsub>wf\\<^esub>) C' M')\")"], ["proof (state)\ngoal (2 subgoals):\n 1. match_ex_table P\\<^bsub>wf\\<^esub> Exc pc'\n     (ex_table_of P\\<^bsub>wf\\<^esub> C' M') =\n    None \\<Longrightarrow>\n    pc < length (instrs_of P\\<^bsub>wf\\<^esub> C M)\n 2. \\<And>a.\n       match_ex_table P\\<^bsub>wf\\<^esub> Exc pc'\n        (ex_table_of P\\<^bsub>wf\\<^esub> C' M') =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       pc < length (instrs_of P\\<^bsub>wf\\<^esub> C M)", "case None"], ["proof (state)\nthis:\n  match_ex_table P\\<^bsub>wf\\<^esub> Exc pc'\n   (ex_table_of P\\<^bsub>wf\\<^esub> C' M') =\n  None\n\ngoal (2 subgoals):\n 1. match_ex_table P\\<^bsub>wf\\<^esub> Exc pc'\n     (ex_table_of P\\<^bsub>wf\\<^esub> C' M') =\n    None \\<Longrightarrow>\n    pc < length (instrs_of P\\<^bsub>wf\\<^esub> C M)\n 2. \\<And>a.\n       match_ex_table P\\<^bsub>wf\\<^esub> Exc pc'\n        (ex_table_of P\\<^bsub>wf\\<^esub> C' M') =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       pc < length (instrs_of P\\<^bsub>wf\\<^esub> C M)", "with fhf"], ["proof (chain)\npicking this:\n  find_handler_for P Exc (a # cs) = (C, M, pc) # cs''\n  match_ex_table P\\<^bsub>wf\\<^esub> Exc pc'\n   (ex_table_of P\\<^bsub>wf\\<^esub> C' M') =\n  None", "have fhf_tl: \"find_handler_for P Exc cs = (C,M,pc)#cs''\""], ["proof (prove)\nusing this:\n  find_handler_for P Exc (a # cs) = (C, M, pc) # cs''\n  match_ex_table P\\<^bsub>wf\\<^esub> Exc pc'\n   (ex_table_of P\\<^bsub>wf\\<^esub> C' M') =\n  None\n\ngoal (1 subgoal):\n 1. find_handler_for P Exc cs = (C, M, pc) # cs''", "by simp"], ["proof (state)\nthis:\n  find_handler_for P Exc cs = (C, M, pc) # cs''\n\ngoal (2 subgoals):\n 1. match_ex_table P\\<^bsub>wf\\<^esub> Exc pc'\n     (ex_table_of P\\<^bsub>wf\\<^esub> C' M') =\n    None \\<Longrightarrow>\n    pc < length (instrs_of P\\<^bsub>wf\\<^esub> C M)\n 2. \\<And>a.\n       match_ex_table P\\<^bsub>wf\\<^esub> Exc pc'\n        (ex_table_of P\\<^bsub>wf\\<^esub> C' M') =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       pc < length (instrs_of P\\<^bsub>wf\\<^esub> C M)", "from v_cs_a_cs"], ["proof (chain)\npicking this:\n  valid_callstack (P, C0, Main) (a # cs)", "have \"valid_callstack (P, C0, Main) cs\""], ["proof (prove)\nusing this:\n  valid_callstack (P, C0, Main) (a # cs)\n\ngoal (1 subgoal):\n 1. valid_callstack (P, C0, Main) cs", "by (auto dest: valid_callstack_tl)"], ["proof (state)\nthis:\n  valid_callstack (P, C0, Main) cs\n\ngoal (2 subgoals):\n 1. match_ex_table P\\<^bsub>wf\\<^esub> Exc pc'\n     (ex_table_of P\\<^bsub>wf\\<^esub> C' M') =\n    None \\<Longrightarrow>\n    pc < length (instrs_of P\\<^bsub>wf\\<^esub> C M)\n 2. \\<And>a.\n       match_ex_table P\\<^bsub>wf\\<^esub> Exc pc'\n        (ex_table_of P\\<^bsub>wf\\<^esub> C' M') =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       pc < length (instrs_of P\\<^bsub>wf\\<^esub> C M)", "from v_cs_a_cs"], ["proof (chain)\npicking this:\n  valid_callstack (P, C0, Main) (a # cs)", "have \"cs \\<noteq> [] \\<longrightarrow> (let (C,M,pc) = hd cs in \\<exists>n. instrs_of (P\\<^bsub>wf\\<^esub>) C M ! pc = Invoke M' n)\""], ["proof (prove)\nusing this:\n  valid_callstack (P, C0, Main) (a # cs)\n\ngoal (1 subgoal):\n 1. cs \\<noteq> [] \\<longrightarrow>\n    (let (C, M, pc) = hd cs\n     in \\<exists>n. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Invoke M' n)", "by (cases cs', auto)"], ["proof (state)\nthis:\n  cs \\<noteq> [] \\<longrightarrow>\n  (let (C, M, pc) = hd cs\n   in \\<exists>n. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Invoke M' n)\n\ngoal (2 subgoals):\n 1. match_ex_table P\\<^bsub>wf\\<^esub> Exc pc'\n     (ex_table_of P\\<^bsub>wf\\<^esub> C' M') =\n    None \\<Longrightarrow>\n    pc < length (instrs_of P\\<^bsub>wf\\<^esub> C M)\n 2. \\<And>a.\n       match_ex_table P\\<^bsub>wf\\<^esub> Exc pc'\n        (ex_table_of P\\<^bsub>wf\\<^esub> C' M') =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       pc < length (instrs_of P\\<^bsub>wf\\<^esub> C M)", "with IH None fhf_tl \\<open>valid_callstack (P, C0, Main) cs\\<close>"], ["proof (chain)\npicking this:\n  \\<lbrakk>cs = (?C', ?M', ?pc') # ?cs'; valid_callstack (P, C0, Main) cs;\n   instrs_of P\\<^bsub>wf\\<^esub> ?C' ?M' ! ?pc' = Throw \\<or>\n   (\\<exists>M'' n''.\n       instrs_of P\\<^bsub>wf\\<^esub> ?C' ?M' ! ?pc' = Invoke M'' n'');\n   find_handler_for P Exc cs = (C, M, pc) # cs''\\<rbrakk>\n  \\<Longrightarrow> pc < length (instrs_of P\\<^bsub>wf\\<^esub> C M)\n  match_ex_table P\\<^bsub>wf\\<^esub> Exc pc'\n   (ex_table_of P\\<^bsub>wf\\<^esub> C' M') =\n  None\n  find_handler_for P Exc cs = (C, M, pc) # cs''\n  valid_callstack (P, C0, Main) cs\n  cs \\<noteq> [] \\<longrightarrow>\n  (let (C, M, pc) = hd cs\n   in \\<exists>n. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Invoke M' n)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>cs = (?C', ?M', ?pc') # ?cs'; valid_callstack (P, C0, Main) cs;\n   instrs_of P\\<^bsub>wf\\<^esub> ?C' ?M' ! ?pc' = Throw \\<or>\n   (\\<exists>M'' n''.\n       instrs_of P\\<^bsub>wf\\<^esub> ?C' ?M' ! ?pc' = Invoke M'' n'');\n   find_handler_for P Exc cs = (C, M, pc) # cs''\\<rbrakk>\n  \\<Longrightarrow> pc < length (instrs_of P\\<^bsub>wf\\<^esub> C M)\n  match_ex_table P\\<^bsub>wf\\<^esub> Exc pc'\n   (ex_table_of P\\<^bsub>wf\\<^esub> C' M') =\n  None\n  find_handler_for P Exc cs = (C, M, pc) # cs''\n  valid_callstack (P, C0, Main) cs\n  cs \\<noteq> [] \\<longrightarrow>\n  (let (C, M, pc) = hd cs\n   in \\<exists>n. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Invoke M' n)\n\ngoal (1 subgoal):\n 1. pc < length (instrs_of P\\<^bsub>wf\\<^esub> C M)", "by (cases cs) fastforce+"], ["proof (state)\nthis:\n  pc < length (instrs_of P\\<^bsub>wf\\<^esub> C M)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       match_ex_table P\\<^bsub>wf\\<^esub> Exc pc'\n        (ex_table_of P\\<^bsub>wf\\<^esub> C' M') =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       pc < length (instrs_of P\\<^bsub>wf\\<^esub> C M)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       match_ex_table P\\<^bsub>wf\\<^esub> Exc pc'\n        (ex_table_of P\\<^bsub>wf\\<^esub> C' M') =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       pc < length (instrs_of P\\<^bsub>wf\\<^esub> C M)", "case (Some xte)"], ["proof (state)\nthis:\n  match_ex_table P\\<^bsub>wf\\<^esub> Exc pc'\n   (ex_table_of P\\<^bsub>wf\\<^esub> C' M') =\n  \\<lfloor>xte\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       match_ex_table P\\<^bsub>wf\\<^esub> Exc pc'\n        (ex_table_of P\\<^bsub>wf\\<^esub> C' M') =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       pc < length (instrs_of P\\<^bsub>wf\\<^esub> C M)", "with fhf"], ["proof (chain)\npicking this:\n  find_handler_for P Exc (a # cs) = (C, M, pc) # cs''\n  match_ex_table P\\<^bsub>wf\\<^esub> Exc pc'\n   (ex_table_of P\\<^bsub>wf\\<^esub> C' M') =\n  \\<lfloor>xte\\<rfloor>", "have [simp]: \"C' = C\" and [simp]: \"M' = M\""], ["proof (prove)\nusing this:\n  find_handler_for P Exc (a # cs) = (C, M, pc) # cs''\n  match_ex_table P\\<^bsub>wf\\<^esub> Exc pc'\n   (ex_table_of P\\<^bsub>wf\\<^esub> C' M') =\n  \\<lfloor>xte\\<rfloor>\n\ngoal (1 subgoal):\n 1. C' = C &&& M' = M", "by simp_all"], ["proof (state)\nthis:\n  C' = C\n  M' = M\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       match_ex_table P\\<^bsub>wf\\<^esub> Exc pc'\n        (ex_table_of P\\<^bsub>wf\\<^esub> C' M') =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       pc < length (instrs_of P\\<^bsub>wf\\<^esub> C M)", "from v_cs_a_cs fhf Some"], ["proof (chain)\npicking this:\n  valid_callstack (P, C0, Main) (a # cs)\n  find_handler_for P Exc (a # cs) = (C, M, pc) # cs''\n  match_ex_table P\\<^bsub>wf\\<^esub> Exc pc'\n   (ex_table_of P\\<^bsub>wf\\<^esub> C' M') =\n  \\<lfloor>xte\\<rfloor>", "obtain Ts T mxs mxl \"is\" xt where wt_class:\n      \"(P\\<^bsub>wf\\<^esub>) \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl, is, xt) in C \\<and>\n      pc' < length is \\<and> (P\\<^bsub>\\<Phi>\\<^esub>) C M ! pc' \\<noteq> None\""], ["proof (prove)\nusing this:\n  valid_callstack (P, C0, Main) (a # cs)\n  find_handler_for P Exc (a # cs) = (C, M, pc) # cs''\n  match_ex_table P\\<^bsub>wf\\<^esub> Exc pc'\n   (ex_table_of P\\<^bsub>wf\\<^esub> C' M') =\n  \\<lfloor>xte\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<And>Ts T mxs mxl is xt.\n        P\\<^bsub>wf\\<^esub> \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs,\n                                 mxl, is, xt) in C \\<and>\n        pc' < length is \\<and>\n        P\\<^bsub>\\<Phi>\\<^esub> C M ! pc' \\<noteq> None \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases cs) fastforce+"], ["proof (state)\nthis:\n  P\\<^bsub>wf\\<^esub> \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl,\n                           is, xt) in C \\<and>\n  pc' < length is \\<and> P\\<^bsub>\\<Phi>\\<^esub> C M ! pc' \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       match_ex_table P\\<^bsub>wf\\<^esub> Exc pc'\n        (ex_table_of P\\<^bsub>wf\\<^esub> C' M') =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       pc < length (instrs_of P\\<^bsub>wf\\<^esub> C M)", "with wf_jvmprog_is_wf [of P]"], ["proof (chain)\npicking this:\n  wf_jvm_prog\\<^bsub>P\\<^bsub>\\<Phi>\\<^esub>\\<^esub> P\\<^bsub>wf\\<^esub>\n  P\\<^bsub>wf\\<^esub> \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl,\n                           is, xt) in C \\<and>\n  pc' < length is \\<and> P\\<^bsub>\\<Phi>\\<^esub> C M ! pc' \\<noteq> None", "have wt_instr:\"(P\\<^bsub>wf\\<^esub>),T,mxs,length is,xt \\<turnstile> is ! pc',pc' :: (P\\<^bsub>\\<Phi>\\<^esub>) C M\""], ["proof (prove)\nusing this:\n  wf_jvm_prog\\<^bsub>P\\<^bsub>\\<Phi>\\<^esub>\\<^esub> P\\<^bsub>wf\\<^esub>\n  P\\<^bsub>wf\\<^esub> \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl,\n                           is, xt) in C \\<and>\n  pc' < length is \\<and> P\\<^bsub>\\<Phi>\\<^esub> C M ! pc' \\<noteq> None\n\ngoal (1 subgoal):\n 1. P\\<^bsub>wf\\<^esub>,T,mxs,length\n                               is,xt \\<turnstile> is !\n            pc',pc' :: P\\<^bsub>\\<Phi>\\<^esub> C M", "by (fastforce dest!: wt_jvm_prog_impl_wt_instr)"], ["proof (state)\nthis:\n  P\\<^bsub>wf\\<^esub>,T,mxs,length\n                             is,xt \\<turnstile> is !\n          pc',pc' :: P\\<^bsub>\\<Phi>\\<^esub> C M\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       match_ex_table P\\<^bsub>wf\\<^esub> Exc pc'\n        (ex_table_of P\\<^bsub>wf\\<^esub> C' M') =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       pc < length (instrs_of P\\<^bsub>wf\\<^esub> C M)", "from Some fhf"], ["proof (chain)\npicking this:\n  match_ex_table P\\<^bsub>wf\\<^esub> Exc pc'\n   (ex_table_of P\\<^bsub>wf\\<^esub> C' M') =\n  \\<lfloor>xte\\<rfloor>\n  find_handler_for P Exc (a # cs) = (C, M, pc) # cs''", "obtain f t D d where \"(f,t,D,pc,d)\\<in> set (ex_table_of (P\\<^bsub>wf\\<^esub>) C M) \\<and>\n      matches_ex_entry (P\\<^bsub>wf\\<^esub>) Exc pc' (f,t,D,pc,d)\""], ["proof (prove)\nusing this:\n  match_ex_table P\\<^bsub>wf\\<^esub> Exc pc'\n   (ex_table_of P\\<^bsub>wf\\<^esub> C' M') =\n  \\<lfloor>xte\\<rfloor>\n  find_handler_for P Exc (a # cs) = (C, M, pc) # cs''\n\ngoal (1 subgoal):\n 1. (\\<And>f t D d.\n        (f, t, D, pc, d)\n        \\<in> set (ex_table_of P\\<^bsub>wf\\<^esub> C M) \\<and>\n        matches_ex_entry P\\<^bsub>wf\\<^esub> Exc pc'\n         (f, t, D, pc, d) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases xte, fastforce dest: match_ex_table_SomeD)"], ["proof (state)\nthis:\n  (f, t, D, pc, d) \\<in> set (ex_table_of P\\<^bsub>wf\\<^esub> C M) \\<and>\n  matches_ex_entry P\\<^bsub>wf\\<^esub> Exc pc' (f, t, D, pc, d)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       match_ex_table P\\<^bsub>wf\\<^esub> Exc pc'\n        (ex_table_of P\\<^bsub>wf\\<^esub> C' M') =\n       \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       pc < length (instrs_of P\\<^bsub>wf\\<^esub> C M)", "with wt_instr throw wt_class"], ["proof (chain)\npicking this:\n  P\\<^bsub>wf\\<^esub>,T,mxs,length\n                             is,xt \\<turnstile> is !\n          pc',pc' :: P\\<^bsub>\\<Phi>\\<^esub> C M\n  instrs_of P\\<^bsub>wf\\<^esub> C' M' ! pc' = Throw \\<or>\n  (\\<exists>M'' n''.\n      instrs_of P\\<^bsub>wf\\<^esub> C' M' ! pc' = Invoke M'' n'')\n  P\\<^bsub>wf\\<^esub> \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl,\n                           is, xt) in C \\<and>\n  pc' < length is \\<and> P\\<^bsub>\\<Phi>\\<^esub> C M ! pc' \\<noteq> None\n  (f, t, D, pc, d) \\<in> set (ex_table_of P\\<^bsub>wf\\<^esub> C M) \\<and>\n  matches_ex_entry P\\<^bsub>wf\\<^esub> Exc pc' (f, t, D, pc, d)", "show ?thesis"], ["proof (prove)\nusing this:\n  P\\<^bsub>wf\\<^esub>,T,mxs,length\n                             is,xt \\<turnstile> is !\n          pc',pc' :: P\\<^bsub>\\<Phi>\\<^esub> C M\n  instrs_of P\\<^bsub>wf\\<^esub> C' M' ! pc' = Throw \\<or>\n  (\\<exists>M'' n''.\n      instrs_of P\\<^bsub>wf\\<^esub> C' M' ! pc' = Invoke M'' n'')\n  P\\<^bsub>wf\\<^esub> \\<turnstile> C sees M: Ts\\<rightarrow>T = (mxs, mxl,\n                           is, xt) in C \\<and>\n  pc' < length is \\<and> P\\<^bsub>\\<Phi>\\<^esub> C M ! pc' \\<noteq> None\n  (f, t, D, pc, d) \\<in> set (ex_table_of P\\<^bsub>wf\\<^esub> C M) \\<and>\n  matches_ex_entry P\\<^bsub>wf\\<^esub> Exc pc' (f, t, D, pc, d)\n\ngoal (1 subgoal):\n 1. pc < length (instrs_of P\\<^bsub>wf\\<^esub> C M)", "by (fastforce simp: relevant_entries_def is_relevant_entry_def matches_ex_entry_def)"], ["proof (state)\nthis:\n  pc < length (instrs_of P\\<^bsub>wf\\<^esub> C M)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pc < length (instrs_of P\\<^bsub>wf\\<^esub> C M)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Every node has only finitely many successors\\<close>"], ["", "lemma successor_set_finite:\n  \"JVM_CFG_Interpret.valid_node prog n \n  \\<Longrightarrow> finite {n'. \\<exists>a'. valid_edge prog a' \\<and> sourcenode a' = n \\<and>\n                      targetnode a' = n'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. JVM_CFG_Interpret.valid_node prog n \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. JVM_CFG_Interpret.valid_node prog n \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}", "assume valid_node: \"JVM_CFG_Interpret.valid_node prog n\""], ["proof (state)\nthis:\n  JVM_CFG_Interpret.valid_node prog n\n\ngoal (1 subgoal):\n 1. JVM_CFG_Interpret.valid_node prog n \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}", "obtain P C0 Main where [simp]: \"prog = (P, C0, Main)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P C0 Main.\n        prog = (P, C0, Main) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases prog, fastforce)"], ["proof (state)\nthis:\n  prog = (P, C0, Main)\n\ngoal (1 subgoal):\n 1. JVM_CFG_Interpret.valid_node prog n \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}", "note P_wf = wf_jvmprog_is_wf [of P]"], ["proof (state)\nthis:\n  wf_jvm_prog\\<^bsub>P\\<^bsub>\\<Phi>\\<^esub>\\<^esub> P\\<^bsub>wf\\<^esub>\n\ngoal (1 subgoal):\n 1. JVM_CFG_Interpret.valid_node prog n \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}", "proof (cases n)"], ["proof (state)\ngoal (2 subgoals):\n 1. n = (_Entry_) \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 2. \\<And>x21 x22.\n       n = (_ x21,x22 _) \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}", "case Entry"], ["proof (state)\nthis:\n  n = (_Entry_)\n\ngoal (2 subgoals):\n 1. n = (_Entry_) \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 2. \\<And>x21 x22.\n       n = (_ x21,x22 _) \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}", "thus ?thesis"], ["proof (prove)\nusing this:\n  n = (_Entry_)\n\ngoal (1 subgoal):\n 1. finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}", "by (rule_tac B=\"{(_Exit_), (_ [(C0, Main, 0)],None _)}\" in finite_subset,\n        auto dest: JVMCFG_EntryD)"], ["proof (state)\nthis:\n  finite\n   {n'.\n    \\<exists>a'.\n       valid_edge prog a' \\<and>\n       sourcenode a' = n \\<and> targetnode a' = n'}\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       n = (_ x21,x22 _) \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       n = (_ x21,x22 _) \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}", "case [simp]: (Node cs x)"], ["proof (state)\nthis:\n  n = (_ cs,x _)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       n = (_ x21,x22 _) \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}", "proof (cases cs)"], ["proof (state)\ngoal (2 subgoals):\n 1. cs = [] \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 2. \\<And>a list.\n       cs = a # list \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}", "case Nil"], ["proof (state)\nthis:\n  cs = []\n\ngoal (2 subgoals):\n 1. cs = [] \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 2. \\<And>a list.\n       cs = a # list \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}", "thus ?thesis"], ["proof (prove)\nusing this:\n  cs = []\n\ngoal (1 subgoal):\n 1. finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}", "by (rule_tac B=\"{}\" in finite_subset,\n          auto elim: JVM_CFG.cases)"], ["proof (state)\nthis:\n  finite\n   {n'.\n    \\<exists>a'.\n       valid_edge prog a' \\<and>\n       sourcenode a' = n \\<and> targetnode a' = n'}\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       cs = a # list \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       cs = a # list \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}", "case [simp]: (Cons a cs')"], ["proof (state)\nthis:\n  cs = a # cs'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       cs = a # list \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}", "obtain C M pc where [simp]: \"a = (C,M,pc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>C M pc.\n        a = (C, M, pc) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases a, fastforce)"], ["proof (state)\nthis:\n  a = (C, M, pc)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       cs = a # list \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}", "have finite_classes: \"finite {C. is_class (P\\<^bsub>wf\\<^esub>) C}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {C. is_class P\\<^bsub>wf\\<^esub> C}", "by (rule finite_is_class)"], ["proof (state)\nthis:\n  finite {C. is_class P\\<^bsub>wf\\<^esub> C}\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       cs = a # list \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}", "from valid_node"], ["proof (chain)\npicking this:\n  JVM_CFG_Interpret.valid_node prog n", "have \"is_class (P\\<^bsub>wf\\<^esub>) C\""], ["proof (prove)\nusing this:\n  JVM_CFG_Interpret.valid_node prog n\n\ngoal (1 subgoal):\n 1. is_class P\\<^bsub>wf\\<^esub> C", "apply (auto simp: JVM_CFG_Interpret.valid_node_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b.\n       \\<lbrakk>(P, C0,\n                 Main) \\<turnstile> (_ (C, M, pc) #\n cs',x _) -aa\\<rightarrow> b;\n        valid_node (P, C0, Main) (_ (C, M, pc) # cs',x _);\n        valid_node (P, C0, Main) b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            class P\\<^bsub>wf\\<^esub> C =\n                            \\<lfloor>(a, aa, b)\\<rfloor>\n 2. \\<And>a aa.\n       \\<lbrakk>(P, C0,\n                 Main) \\<turnstile> a -aa\\<rightarrow> (_ (C, M, pc) #\n                    cs',x _);\n        valid_node (P, C0, Main) a;\n        valid_node (P, C0, Main) (_ (C, M, pc) # cs',x _)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            class P\\<^bsub>wf\\<^esub> C =\n                            \\<lfloor>(a, aa, b)\\<rfloor>", "apply (cases x, auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>aa b.\n       \\<lbrakk>(P, C0,\n                 Main) \\<turnstile> (_ (C, M, pc) #\n cs',None _) -aa\\<rightarrow> b;\n        valid_callstack (P, C0, Main) ((C, M, pc) # cs');\n        valid_node (P, C0, Main) b; x = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            class P\\<^bsub>wf\\<^esub> C =\n                            \\<lfloor>(a, aa, b)\\<rfloor>\n 2. \\<And>aa b a ba Q f.\n       \\<lbrakk>(P, C0,\n                 Main) \\<turnstile> (_ (C, M, pc) #\n cs',\\<lfloor>(a, ba)\\<rfloor> _) -aa\\<rightarrow> b;\n        valid_node (P, C0, Main) b; x = \\<lfloor>(a, ba)\\<rfloor>;\n        valid_callstack (P, C0, Main) ((C, M, pc) # cs');\n        valid_callstack (P, C0, Main) a;\n        (P, C0,\n         Main) \\<turnstile> (_ (C, M, pc) #\n                               cs',None _) -(Q)\\<^sub>\\<surd>\\<rightarrow> (_ (C,\n   M, pc) #\n  cs',\\<lfloor>(a, ba)\\<rfloor> _);\n        (P, C0,\n         Main) \\<turnstile> (_ (C, M, pc) #\n                               cs',\\<lfloor>(a,\n       ba)\\<rfloor> _) -\\<Up>f\\<rightarrow> (_ a,None _)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            class P\\<^bsub>wf\\<^esub> C =\n                            \\<lfloor>(a, aa, b)\\<rfloor>\n 3. \\<And>a aa.\n       \\<lbrakk>(P, C0,\n                 Main) \\<turnstile> a -aa\\<rightarrow> (_ (C, M, pc) #\n                    cs',x _);\n        valid_node (P, C0, Main) a;\n        valid_node (P, C0, Main) (_ (C, M, pc) # cs',x _)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            class P\\<^bsub>wf\\<^esub> C =\n                            \\<lfloor>(a, aa, b)\\<rfloor>", "apply (cases cs', auto dest!: sees_method_is_class)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b a ba Q f.\n       \\<lbrakk>(P, C0,\n                 Main) \\<turnstile> (_ (C, M, pc) #\n cs',\\<lfloor>(a, ba)\\<rfloor> _) -aa\\<rightarrow> b;\n        valid_node (P, C0, Main) b; x = \\<lfloor>(a, ba)\\<rfloor>;\n        valid_callstack (P, C0, Main) ((C, M, pc) # cs');\n        valid_callstack (P, C0, Main) a;\n        (P, C0,\n         Main) \\<turnstile> (_ (C, M, pc) #\n                               cs',None _) -(Q)\\<^sub>\\<surd>\\<rightarrow> (_ (C,\n   M, pc) #\n  cs',\\<lfloor>(a, ba)\\<rfloor> _);\n        (P, C0,\n         Main) \\<turnstile> (_ (C, M, pc) #\n                               cs',\\<lfloor>(a,\n       ba)\\<rfloor> _) -\\<Up>f\\<rightarrow> (_ a,None _)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            class P\\<^bsub>wf\\<^esub> C =\n                            \\<lfloor>(a, aa, b)\\<rfloor>\n 2. \\<And>a aa.\n       \\<lbrakk>(P, C0,\n                 Main) \\<turnstile> a -aa\\<rightarrow> (_ (C, M, pc) #\n                    cs',x _);\n        valid_node (P, C0, Main) a;\n        valid_node (P, C0, Main) (_ (C, M, pc) # cs',x _)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            class P\\<^bsub>wf\\<^esub> C =\n                            \\<lfloor>(a, aa, b)\\<rfloor>", "apply (cases cs', auto dest!: sees_method_is_class)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa.\n       \\<lbrakk>(P, C0,\n                 Main) \\<turnstile> a -aa\\<rightarrow> (_ (C, M, pc) #\n                    cs',x _);\n        valid_node (P, C0, Main) a;\n        valid_node (P, C0, Main) (_ (C, M, pc) # cs',x _)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            class P\\<^bsub>wf\\<^esub> C =\n                            \\<lfloor>(a, aa, b)\\<rfloor>", "apply (cases cs', auto dest!: sees_method_is_class)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a aa.\n       \\<lbrakk>(P, C0,\n                 Main) \\<turnstile> a -aa\\<rightarrow> (_ [(C, M, pc)],x _);\n        valid_node (P, C0, Main) a;\n        valid_node (P, C0, Main) (_ [(C, M, pc)],x _); cs' = []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            class P\\<^bsub>wf\\<^esub> C =\n                            \\<lfloor>(a, aa, b)\\<rfloor>\n 2. \\<And>a aa ab ac b list.\n       \\<lbrakk>(P, C0,\n                 Main) \\<turnstile> a -aa\\<rightarrow> (_ (C, M, pc) #\n                    (ab, ac, b) # list,x _);\n        valid_node (P, C0, Main) a;\n        valid_node (P, C0, Main) (_ (C, M, pc) # (ab, ac, b) # list,x _);\n        cs' = (ab, ac, b) # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            class P\\<^bsub>wf\\<^esub> C =\n                            \\<lfloor>(a, aa, b)\\<rfloor>", "apply (cases x, auto dest!: sees_method_is_class)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa ab ac b list.\n       \\<lbrakk>(P, C0,\n                 Main) \\<turnstile> a -aa\\<rightarrow> (_ (C, M, pc) #\n                    (ab, ac, b) # list,x _);\n        valid_node (P, C0, Main) a;\n        valid_node (P, C0, Main) (_ (C, M, pc) # (ab, ac, b) # list,x _);\n        cs' = (ab, ac, b) # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            class P\\<^bsub>wf\\<^esub> C =\n                            \\<lfloor>(a, aa, b)\\<rfloor>", "by (cases x, auto dest!: sees_method_is_class)"], ["proof (state)\nthis:\n  is_class P\\<^bsub>wf\\<^esub> C\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       cs = a # list \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}", "proof (cases \"instrs_of (P\\<^bsub>wf\\<^esub>) C M ! pc\")"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>x1.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Load x1 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 2. \\<And>x2.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Store x2 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 3. \\<And>x3.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Push x3 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 4. \\<And>x4.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = New x4 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 5. \\<And>x51 x52.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Getfield x51 x52 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 6. \\<And>x61 x62.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Putfield x61 x62 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 7. \\<And>x7.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Checkcast x7 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 8. \\<And>x81 x82.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Invoke x81 x82 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 9. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Return \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 10. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Pop \\<Longrightarrow>\n     finite\n      {n'.\n       \\<exists>a'.\n          valid_edge prog a' \\<and>\n          sourcenode a' = n \\<and> targetnode a' = n'}\nA total of 15 subgoals...", "case (Load nat)"], ["proof (state)\nthis:\n  instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Load nat\n\ngoal (15 subgoals):\n 1. \\<And>x1.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Load x1 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 2. \\<And>x2.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Store x2 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 3. \\<And>x3.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Push x3 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 4. \\<And>x4.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = New x4 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 5. \\<And>x51 x52.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Getfield x51 x52 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 6. \\<And>x61 x62.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Putfield x61 x62 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 7. \\<And>x7.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Checkcast x7 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 8. \\<And>x81 x82.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Invoke x81 x82 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 9. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Return \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 10. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Pop \\<Longrightarrow>\n     finite\n      {n'.\n       \\<exists>a'.\n          valid_edge prog a' \\<and>\n          sourcenode a' = n \\<and> targetnode a' = n'}\nA total of 15 subgoals...", "with valid_node"], ["proof (chain)\npicking this:\n  JVM_CFG_Interpret.valid_node prog n\n  instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Load nat", "show ?thesis"], ["proof (prove)\nusing this:\n  JVM_CFG_Interpret.valid_node prog n\n  instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Load nat\n\ngoal (1 subgoal):\n 1. finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Load nat\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {n'.\n                        (\\<exists>a.\n                            (P, C0,\n                             Main) \\<turnstile> (_ (C, M, pc) #\n             cs',x _) -a\\<rightarrow> n') \\<and>\n                        valid_node (P, C0, Main)\n                         (_ (C, M, pc) # cs',x _) \\<and>\n                        valid_node (P, C0, Main) n'}", "apply (rule_tac B=\"{(_ (C,M,Suc pc)#cs',x _)}\" in finite_subset)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Load nat\\<rbrakk>\n    \\<Longrightarrow> {n'.\n                       (\\<exists>a.\n                           (P, C0,\n                            Main) \\<turnstile> (_ (C, M, pc) #\n            cs',x _) -a\\<rightarrow> n') \\<and>\n                       valid_node (P, C0, Main)\n                        (_ (C, M, pc) # cs',x _) \\<and>\n                       valid_node (P, C0, Main) n'}\n                      \\<subseteq> {(_ (C, M, Suc pc) # cs',x _)}\n 2. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Load nat\\<rbrakk>\n    \\<Longrightarrow> finite {(_ (C, M, Suc pc) # cs',x _)}", "by (auto elim: JVM_CFG.cases)"], ["proof (state)\nthis:\n  finite\n   {n'.\n    \\<exists>a'.\n       valid_edge prog a' \\<and>\n       sourcenode a' = n \\<and> targetnode a' = n'}\n\ngoal (14 subgoals):\n 1. \\<And>x2.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Store x2 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 2. \\<And>x3.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Push x3 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 3. \\<And>x4.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = New x4 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 4. \\<And>x51 x52.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Getfield x51 x52 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 5. \\<And>x61 x62.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Putfield x61 x62 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 6. \\<And>x7.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Checkcast x7 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 7. \\<And>x81 x82.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Invoke x81 x82 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 8. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Return \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 9. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Pop \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 10. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = IAdd \\<Longrightarrow>\n     finite\n      {n'.\n       \\<exists>a'.\n          valid_edge prog a' \\<and>\n          sourcenode a' = n \\<and> targetnode a' = n'}\nA total of 14 subgoals...", "next"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>x2.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Store x2 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 2. \\<And>x3.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Push x3 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 3. \\<And>x4.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = New x4 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 4. \\<And>x51 x52.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Getfield x51 x52 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 5. \\<And>x61 x62.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Putfield x61 x62 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 6. \\<And>x7.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Checkcast x7 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 7. \\<And>x81 x82.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Invoke x81 x82 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 8. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Return \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 9. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Pop \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 10. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = IAdd \\<Longrightarrow>\n     finite\n      {n'.\n       \\<exists>a'.\n          valid_edge prog a' \\<and>\n          sourcenode a' = n \\<and> targetnode a' = n'}\nA total of 14 subgoals...", "case (Store nat)"], ["proof (state)\nthis:\n  instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Store nat\n\ngoal (14 subgoals):\n 1. \\<And>x2.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Store x2 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 2. \\<And>x3.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Push x3 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 3. \\<And>x4.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = New x4 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 4. \\<And>x51 x52.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Getfield x51 x52 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 5. \\<And>x61 x62.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Putfield x61 x62 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 6. \\<And>x7.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Checkcast x7 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 7. \\<And>x81 x82.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Invoke x81 x82 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 8. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Return \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 9. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Pop \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 10. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = IAdd \\<Longrightarrow>\n     finite\n      {n'.\n       \\<exists>a'.\n          valid_edge prog a' \\<and>\n          sourcenode a' = n \\<and> targetnode a' = n'}\nA total of 14 subgoals...", "with valid_node"], ["proof (chain)\npicking this:\n  JVM_CFG_Interpret.valid_node prog n\n  instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Store nat", "show ?thesis"], ["proof (prove)\nusing this:\n  JVM_CFG_Interpret.valid_node prog n\n  instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Store nat\n\ngoal (1 subgoal):\n 1. finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Store nat\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {n'.\n                        (\\<exists>a.\n                            (P, C0,\n                             Main) \\<turnstile> (_ (C, M, pc) #\n             cs',x _) -a\\<rightarrow> n') \\<and>\n                        valid_node (P, C0, Main)\n                         (_ (C, M, pc) # cs',x _) \\<and>\n                        valid_node (P, C0, Main) n'}", "apply (rule_tac B=\"{(_ (C,M,Suc pc)#cs',x _)}\" in finite_subset)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Store nat\\<rbrakk>\n    \\<Longrightarrow> {n'.\n                       (\\<exists>a.\n                           (P, C0,\n                            Main) \\<turnstile> (_ (C, M, pc) #\n            cs',x _) -a\\<rightarrow> n') \\<and>\n                       valid_node (P, C0, Main)\n                        (_ (C, M, pc) # cs',x _) \\<and>\n                       valid_node (P, C0, Main) n'}\n                      \\<subseteq> {(_ (C, M, Suc pc) # cs',x _)}\n 2. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Store nat\\<rbrakk>\n    \\<Longrightarrow> finite {(_ (C, M, Suc pc) # cs',x _)}", "by (auto elim: JVM_CFG.cases)"], ["proof (state)\nthis:\n  finite\n   {n'.\n    \\<exists>a'.\n       valid_edge prog a' \\<and>\n       sourcenode a' = n \\<and> targetnode a' = n'}\n\ngoal (13 subgoals):\n 1. \\<And>x3.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Push x3 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 2. \\<And>x4.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = New x4 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 3. \\<And>x51 x52.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Getfield x51 x52 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 4. \\<And>x61 x62.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Putfield x61 x62 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 5. \\<And>x7.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Checkcast x7 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 6. \\<And>x81 x82.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Invoke x81 x82 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 7. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Return \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 8. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Pop \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 9. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = IAdd \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 10. \\<And>x12.\n        instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Goto x12 \\<Longrightarrow>\n        finite\n         {n'.\n          \\<exists>a'.\n             valid_edge prog a' \\<and>\n             sourcenode a' = n \\<and> targetnode a' = n'}\nA total of 13 subgoals...", "next"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>x3.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Push x3 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 2. \\<And>x4.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = New x4 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 3. \\<And>x51 x52.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Getfield x51 x52 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 4. \\<And>x61 x62.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Putfield x61 x62 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 5. \\<And>x7.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Checkcast x7 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 6. \\<And>x81 x82.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Invoke x81 x82 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 7. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Return \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 8. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Pop \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 9. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = IAdd \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 10. \\<And>x12.\n        instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Goto x12 \\<Longrightarrow>\n        finite\n         {n'.\n          \\<exists>a'.\n             valid_edge prog a' \\<and>\n             sourcenode a' = n \\<and> targetnode a' = n'}\nA total of 13 subgoals...", "case (Push val)"], ["proof (state)\nthis:\n  instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Push val\n\ngoal (13 subgoals):\n 1. \\<And>x3.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Push x3 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 2. \\<And>x4.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = New x4 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 3. \\<And>x51 x52.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Getfield x51 x52 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 4. \\<And>x61 x62.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Putfield x61 x62 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 5. \\<And>x7.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Checkcast x7 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 6. \\<And>x81 x82.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Invoke x81 x82 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 7. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Return \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 8. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Pop \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 9. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = IAdd \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 10. \\<And>x12.\n        instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Goto x12 \\<Longrightarrow>\n        finite\n         {n'.\n          \\<exists>a'.\n             valid_edge prog a' \\<and>\n             sourcenode a' = n \\<and> targetnode a' = n'}\nA total of 13 subgoals...", "with valid_node"], ["proof (chain)\npicking this:\n  JVM_CFG_Interpret.valid_node prog n\n  instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Push val", "show ?thesis"], ["proof (prove)\nusing this:\n  JVM_CFG_Interpret.valid_node prog n\n  instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Push val\n\ngoal (1 subgoal):\n 1. finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Push val\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {n'.\n                        (\\<exists>a.\n                            (P, C0,\n                             Main) \\<turnstile> (_ (C, M, pc) #\n             cs',x _) -a\\<rightarrow> n') \\<and>\n                        valid_node (P, C0, Main)\n                         (_ (C, M, pc) # cs',x _) \\<and>\n                        valid_node (P, C0, Main) n'}", "apply (rule_tac B=\"{(_ (C,M,Suc pc)#cs',x _)}\" in finite_subset)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Push val\\<rbrakk>\n    \\<Longrightarrow> {n'.\n                       (\\<exists>a.\n                           (P, C0,\n                            Main) \\<turnstile> (_ (C, M, pc) #\n            cs',x _) -a\\<rightarrow> n') \\<and>\n                       valid_node (P, C0, Main)\n                        (_ (C, M, pc) # cs',x _) \\<and>\n                       valid_node (P, C0, Main) n'}\n                      \\<subseteq> {(_ (C, M, Suc pc) # cs',x _)}\n 2. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Push val\\<rbrakk>\n    \\<Longrightarrow> finite {(_ (C, M, Suc pc) # cs',x _)}", "by (auto elim: JVM_CFG.cases)"], ["proof (state)\nthis:\n  finite\n   {n'.\n    \\<exists>a'.\n       valid_edge prog a' \\<and>\n       sourcenode a' = n \\<and> targetnode a' = n'}\n\ngoal (12 subgoals):\n 1. \\<And>x4.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = New x4 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 2. \\<And>x51 x52.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Getfield x51 x52 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 3. \\<And>x61 x62.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Putfield x61 x62 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 4. \\<And>x7.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Checkcast x7 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 5. \\<And>x81 x82.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Invoke x81 x82 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 6. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Return \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 7. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Pop \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 8. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = IAdd \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 9. \\<And>x12.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Goto x12 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 10. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = CmpEq \\<Longrightarrow>\n     finite\n      {n'.\n       \\<exists>a'.\n          valid_edge prog a' \\<and>\n          sourcenode a' = n \\<and> targetnode a' = n'}\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>x4.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = New x4 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 2. \\<And>x51 x52.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Getfield x51 x52 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 3. \\<And>x61 x62.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Putfield x61 x62 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 4. \\<And>x7.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Checkcast x7 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 5. \\<And>x81 x82.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Invoke x81 x82 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 6. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Return \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 7. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Pop \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 8. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = IAdd \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 9. \\<And>x12.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Goto x12 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 10. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = CmpEq \\<Longrightarrow>\n     finite\n      {n'.\n       \\<exists>a'.\n          valid_edge prog a' \\<and>\n          sourcenode a' = n \\<and> targetnode a' = n'}\nA total of 12 subgoals...", "case (New C')"], ["proof (state)\nthis:\n  instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = New C'\n\ngoal (12 subgoals):\n 1. \\<And>x4.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = New x4 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 2. \\<And>x51 x52.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Getfield x51 x52 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 3. \\<And>x61 x62.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Putfield x61 x62 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 4. \\<And>x7.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Checkcast x7 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 5. \\<And>x81 x82.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Invoke x81 x82 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 6. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Return \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 7. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Pop \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 8. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = IAdd \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 9. \\<And>x12.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Goto x12 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 10. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = CmpEq \\<Longrightarrow>\n     finite\n      {n'.\n       \\<exists>a'.\n          valid_edge prog a' \\<and>\n          sourcenode a' = n \\<and> targetnode a' = n'}\nA total of 12 subgoals...", "with valid_node"], ["proof (chain)\npicking this:\n  JVM_CFG_Interpret.valid_node prog n\n  instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = New C'", "show ?thesis"], ["proof (prove)\nusing this:\n  JVM_CFG_Interpret.valid_node prog n\n  instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = New C'\n\ngoal (1 subgoal):\n 1. finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = New C'\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {n'.\n                        (\\<exists>a.\n                            (P, C0,\n                             Main) \\<turnstile> (_ (C, M, pc) #\n             cs',x _) -a\\<rightarrow> n') \\<and>\n                        valid_node (P, C0, Main)\n                         (_ (C, M, pc) # cs',x _) \\<and>\n                        valid_node (P, C0, Main) n'}", "apply (rule_tac B=\"{(_ (C,M,pc)#cs',\\<lfloor>((C,M,Suc pc)#cs',False)\\<rfloor> _),\n            (_ (C,M,pc)#cs',\\<lfloor>(find_handler_for P OutOfMemory ((C,M,pc)#cs'),True)\\<rfloor> _),\n            (_ fst(the(x)),None _)}\" in finite_subset)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = New C'\\<rbrakk>\n    \\<Longrightarrow> {n'.\n                       (\\<exists>a.\n                           (P, C0,\n                            Main) \\<turnstile> (_ (C, M, pc) #\n            cs',x _) -a\\<rightarrow> n') \\<and>\n                       valid_node (P, C0, Main)\n                        (_ (C, M, pc) # cs',x _) \\<and>\n                       valid_node (P, C0, Main) n'}\n                      \\<subseteq> {(_ (C, M, pc) #\ncs',\\<lfloor>((C, M, Suc pc) # cs', False)\\<rfloor> _),\n                                   (_ (C, M, pc) #\ncs',\\<lfloor>(find_handler_for P OutOfMemory ((C, M, pc) # cs'),\n              True)\\<rfloor> _),\n                                   (_ fst (the x),None _)}\n 2. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = New C'\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {(_ (C, M, pc) #\n                           cs',\\<lfloor>((C, M, Suc pc) # cs',\n   False)\\<rfloor> _),\n                        (_ (C, M, pc) #\n                           cs',\\<lfloor>(find_handler_for P OutOfMemory\n    ((C, M, pc) # cs'),\n   True)\\<rfloor> _),\n                        (_ fst (the x),None _)}", "apply (rule subsetI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n                 (_ (C, M, pc) # cs',x _);\n        instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = New C';\n        xa \\<in> {n'.\n                  (\\<exists>a.\n                      (P, C0,\n                       Main) \\<turnstile> (_ (C, M, pc) #\n       cs',x _) -a\\<rightarrow> n') \\<and>\n                  valid_node (P, C0, Main) (_ (C, M, pc) # cs',x _) \\<and>\n                  valid_node (P, C0, Main) n'}\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> {(_ (C, M, pc) #\ncs',\\<lfloor>((C, M, Suc pc) # cs', False)\\<rfloor> _),\n                                   (_ (C, M, pc) #\ncs',\\<lfloor>(find_handler_for P OutOfMemory ((C, M, pc) # cs'),\n              True)\\<rfloor> _),\n                                   (_ fst (the x),None _)}\n 2. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = New C'\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {(_ (C, M, pc) #\n                           cs',\\<lfloor>((C, M, Suc pc) # cs',\n   False)\\<rfloor> _),\n                        (_ (C, M, pc) #\n                           cs',\\<lfloor>(find_handler_for P OutOfMemory\n    ((C, M, pc) # cs'),\n   True)\\<rfloor> _),\n                        (_ fst (the x),None _)}", "apply (clarsimp simp del: find_handler_for.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa a.\n       \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n                 (_ (C, M, pc) # cs',x _);\n        instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = New C';\n        (P, C0,\n         Main) \\<turnstile> (_ (C, M, pc) # cs',x _) -a\\<rightarrow> xa;\n        valid_node (P, C0, Main) (_ (C, M, pc) # cs',x _);\n        valid_node (P, C0, Main) xa;\n        xa \\<noteq>\n        (_ (C, M, pc) #\n           cs',\\<lfloor>((C, M, Suc pc) # cs', False)\\<rfloor> _);\n        xa \\<noteq> (_ fst (the x),None _)\\<rbrakk>\n       \\<Longrightarrow> xa =\n                         (_ (C, M, pc) #\n                            cs',\\<lfloor>(find_handler_for P OutOfMemory\n     ((C, M, pc) # cs'),\n    True)\\<rfloor> _)\n 2. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = New C'\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {(_ (C, M, pc) #\n                           cs',\\<lfloor>((C, M, Suc pc) # cs',\n   False)\\<rfloor> _),\n                        (_ (C, M, pc) #\n                           cs',\\<lfloor>(find_handler_for P OutOfMemory\n    ((C, M, pc) # cs'),\n   True)\\<rfloor> _),\n                        (_ fst (the x),None _)}", "by (erule JVM_CFG.cases, simp_all del: find_handler_for.simps)"], ["proof (state)\nthis:\n  finite\n   {n'.\n    \\<exists>a'.\n       valid_edge prog a' \\<and>\n       sourcenode a' = n \\<and> targetnode a' = n'}\n\ngoal (11 subgoals):\n 1. \\<And>x51 x52.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Getfield x51 x52 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 2. \\<And>x61 x62.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Putfield x61 x62 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 3. \\<And>x7.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Checkcast x7 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 4. \\<And>x81 x82.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Invoke x81 x82 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 5. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Return \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 6. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Pop \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 7. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = IAdd \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 8. \\<And>x12.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Goto x12 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 9. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = CmpEq \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 10. \\<And>x14.\n        instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n        IfFalse x14 \\<Longrightarrow>\n        finite\n         {n'.\n          \\<exists>a'.\n             valid_edge prog a' \\<and>\n             sourcenode a' = n \\<and> targetnode a' = n'}\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>x51 x52.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Getfield x51 x52 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 2. \\<And>x61 x62.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Putfield x61 x62 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 3. \\<And>x7.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Checkcast x7 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 4. \\<And>x81 x82.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Invoke x81 x82 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 5. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Return \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 6. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Pop \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 7. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = IAdd \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 8. \\<And>x12.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Goto x12 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 9. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = CmpEq \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 10. \\<And>x14.\n        instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n        IfFalse x14 \\<Longrightarrow>\n        finite\n         {n'.\n          \\<exists>a'.\n             valid_edge prog a' \\<and>\n             sourcenode a' = n \\<and> targetnode a' = n'}\nA total of 11 subgoals...", "case (Getfield Fd C')"], ["proof (state)\nthis:\n  instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Getfield Fd C'\n\ngoal (11 subgoals):\n 1. \\<And>x51 x52.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Getfield x51 x52 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 2. \\<And>x61 x62.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Putfield x61 x62 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 3. \\<And>x7.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Checkcast x7 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 4. \\<And>x81 x82.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Invoke x81 x82 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 5. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Return \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 6. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Pop \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 7. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = IAdd \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 8. \\<And>x12.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Goto x12 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 9. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = CmpEq \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 10. \\<And>x14.\n        instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n        IfFalse x14 \\<Longrightarrow>\n        finite\n         {n'.\n          \\<exists>a'.\n             valid_edge prog a' \\<and>\n             sourcenode a' = n \\<and> targetnode a' = n'}\nA total of 11 subgoals...", "with valid_node"], ["proof (chain)\npicking this:\n  JVM_CFG_Interpret.valid_node prog n\n  instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Getfield Fd C'", "show ?thesis"], ["proof (prove)\nusing this:\n  JVM_CFG_Interpret.valid_node prog n\n  instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Getfield Fd C'\n\ngoal (1 subgoal):\n 1. finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Getfield Fd C'\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {n'.\n                        (\\<exists>a.\n                            (P, C0,\n                             Main) \\<turnstile> (_ (C, M, pc) #\n             cs',x _) -a\\<rightarrow> n') \\<and>\n                        valid_node (P, C0, Main)\n                         (_ (C, M, pc) # cs',x _) \\<and>\n                        valid_node (P, C0, Main) n'}", "apply (rule_tac B=\"{(_ (C,M,pc)#cs',\\<lfloor>((C,M,Suc pc)#cs',False)\\<rfloor> _),\n            (_ (C,M,pc)#cs',\\<lfloor>(find_handler_for P NullPointer ((C,M,pc)#cs'),True)\\<rfloor> _),\n            (_ fst(the(x)),None _)}\" in finite_subset)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Getfield Fd C'\\<rbrakk>\n    \\<Longrightarrow> {n'.\n                       (\\<exists>a.\n                           (P, C0,\n                            Main) \\<turnstile> (_ (C, M, pc) #\n            cs',x _) -a\\<rightarrow> n') \\<and>\n                       valid_node (P, C0, Main)\n                        (_ (C, M, pc) # cs',x _) \\<and>\n                       valid_node (P, C0, Main) n'}\n                      \\<subseteq> {(_ (C, M, pc) #\ncs',\\<lfloor>((C, M, Suc pc) # cs', False)\\<rfloor> _),\n                                   (_ (C, M, pc) #\ncs',\\<lfloor>(find_handler_for P NullPointer ((C, M, pc) # cs'),\n              True)\\<rfloor> _),\n                                   (_ fst (the x),None _)}\n 2. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Getfield Fd C'\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {(_ (C, M, pc) #\n                           cs',\\<lfloor>((C, M, Suc pc) # cs',\n   False)\\<rfloor> _),\n                        (_ (C, M, pc) #\n                           cs',\\<lfloor>(find_handler_for P NullPointer\n    ((C, M, pc) # cs'),\n   True)\\<rfloor> _),\n                        (_ fst (the x),None _)}", "apply (rule subsetI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n                 (_ (C, M, pc) # cs',x _);\n        instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Getfield Fd C';\n        xa \\<in> {n'.\n                  (\\<exists>a.\n                      (P, C0,\n                       Main) \\<turnstile> (_ (C, M, pc) #\n       cs',x _) -a\\<rightarrow> n') \\<and>\n                  valid_node (P, C0, Main) (_ (C, M, pc) # cs',x _) \\<and>\n                  valid_node (P, C0, Main) n'}\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> {(_ (C, M, pc) #\ncs',\\<lfloor>((C, M, Suc pc) # cs', False)\\<rfloor> _),\n                                   (_ (C, M, pc) #\ncs',\\<lfloor>(find_handler_for P NullPointer ((C, M, pc) # cs'),\n              True)\\<rfloor> _),\n                                   (_ fst (the x),None _)}\n 2. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Getfield Fd C'\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {(_ (C, M, pc) #\n                           cs',\\<lfloor>((C, M, Suc pc) # cs',\n   False)\\<rfloor> _),\n                        (_ (C, M, pc) #\n                           cs',\\<lfloor>(find_handler_for P NullPointer\n    ((C, M, pc) # cs'),\n   True)\\<rfloor> _),\n                        (_ fst (the x),None _)}", "apply (clarsimp simp del: find_handler_for.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa a.\n       \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n                 (_ (C, M, pc) # cs',x _);\n        instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Getfield Fd C';\n        (P, C0,\n         Main) \\<turnstile> (_ (C, M, pc) # cs',x _) -a\\<rightarrow> xa;\n        valid_node (P, C0, Main) (_ (C, M, pc) # cs',x _);\n        valid_node (P, C0, Main) xa;\n        xa \\<noteq>\n        (_ (C, M, pc) #\n           cs',\\<lfloor>((C, M, Suc pc) # cs', False)\\<rfloor> _);\n        xa \\<noteq> (_ fst (the x),None _)\\<rbrakk>\n       \\<Longrightarrow> xa =\n                         (_ (C, M, pc) #\n                            cs',\\<lfloor>(find_handler_for P NullPointer\n     ((C, M, pc) # cs'),\n    True)\\<rfloor> _)\n 2. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Getfield Fd C'\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {(_ (C, M, pc) #\n                           cs',\\<lfloor>((C, M, Suc pc) # cs',\n   False)\\<rfloor> _),\n                        (_ (C, M, pc) #\n                           cs',\\<lfloor>(find_handler_for P NullPointer\n    ((C, M, pc) # cs'),\n   True)\\<rfloor> _),\n                        (_ fst (the x),None _)}", "by (erule JVM_CFG.cases, simp_all del: find_handler_for.simps)"], ["proof (state)\nthis:\n  finite\n   {n'.\n    \\<exists>a'.\n       valid_edge prog a' \\<and>\n       sourcenode a' = n \\<and> targetnode a' = n'}\n\ngoal (10 subgoals):\n 1. \\<And>x61 x62.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Putfield x61 x62 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 2. \\<And>x7.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Checkcast x7 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 3. \\<And>x81 x82.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Invoke x81 x82 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 4. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Return \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 5. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Pop \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 6. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = IAdd \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 7. \\<And>x12.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Goto x12 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 8. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = CmpEq \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 9. \\<And>x14.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       IfFalse x14 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 10. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw \\<Longrightarrow>\n     finite\n      {n'.\n       \\<exists>a'.\n          valid_edge prog a' \\<and>\n          sourcenode a' = n \\<and> targetnode a' = n'}", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>x61 x62.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Putfield x61 x62 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 2. \\<And>x7.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Checkcast x7 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 3. \\<And>x81 x82.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Invoke x81 x82 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 4. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Return \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 5. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Pop \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 6. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = IAdd \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 7. \\<And>x12.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Goto x12 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 8. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = CmpEq \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 9. \\<And>x14.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       IfFalse x14 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 10. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw \\<Longrightarrow>\n     finite\n      {n'.\n       \\<exists>a'.\n          valid_edge prog a' \\<and>\n          sourcenode a' = n \\<and> targetnode a' = n'}", "case (Putfield Fd C')"], ["proof (state)\nthis:\n  instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Putfield Fd C'\n\ngoal (10 subgoals):\n 1. \\<And>x61 x62.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Putfield x61 x62 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 2. \\<And>x7.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Checkcast x7 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 3. \\<And>x81 x82.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Invoke x81 x82 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 4. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Return \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 5. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Pop \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 6. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = IAdd \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 7. \\<And>x12.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Goto x12 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 8. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = CmpEq \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 9. \\<And>x14.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       IfFalse x14 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 10. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw \\<Longrightarrow>\n     finite\n      {n'.\n       \\<exists>a'.\n          valid_edge prog a' \\<and>\n          sourcenode a' = n \\<and> targetnode a' = n'}", "with valid_node"], ["proof (chain)\npicking this:\n  JVM_CFG_Interpret.valid_node prog n\n  instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Putfield Fd C'", "show ?thesis"], ["proof (prove)\nusing this:\n  JVM_CFG_Interpret.valid_node prog n\n  instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Putfield Fd C'\n\ngoal (1 subgoal):\n 1. finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Putfield Fd C'\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {n'.\n                        (\\<exists>a.\n                            (P, C0,\n                             Main) \\<turnstile> (_ (C, M, pc) #\n             cs',x _) -a\\<rightarrow> n') \\<and>\n                        valid_node (P, C0, Main)\n                         (_ (C, M, pc) # cs',x _) \\<and>\n                        valid_node (P, C0, Main) n'}", "apply (rule_tac B=\"{(_ (C,M,pc)#cs',\\<lfloor>((C,M,Suc pc)#cs',False)\\<rfloor> _),\n            (_ (C,M,pc)#cs',\\<lfloor>(find_handler_for P NullPointer ((C,M,pc)#cs'),True)\\<rfloor> _),\n            (_ fst(the(x)),None _)}\" in finite_subset)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Putfield Fd C'\\<rbrakk>\n    \\<Longrightarrow> {n'.\n                       (\\<exists>a.\n                           (P, C0,\n                            Main) \\<turnstile> (_ (C, M, pc) #\n            cs',x _) -a\\<rightarrow> n') \\<and>\n                       valid_node (P, C0, Main)\n                        (_ (C, M, pc) # cs',x _) \\<and>\n                       valid_node (P, C0, Main) n'}\n                      \\<subseteq> {(_ (C, M, pc) #\ncs',\\<lfloor>((C, M, Suc pc) # cs', False)\\<rfloor> _),\n                                   (_ (C, M, pc) #\ncs',\\<lfloor>(find_handler_for P NullPointer ((C, M, pc) # cs'),\n              True)\\<rfloor> _),\n                                   (_ fst (the x),None _)}\n 2. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Putfield Fd C'\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {(_ (C, M, pc) #\n                           cs',\\<lfloor>((C, M, Suc pc) # cs',\n   False)\\<rfloor> _),\n                        (_ (C, M, pc) #\n                           cs',\\<lfloor>(find_handler_for P NullPointer\n    ((C, M, pc) # cs'),\n   True)\\<rfloor> _),\n                        (_ fst (the x),None _)}", "apply (rule subsetI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n                 (_ (C, M, pc) # cs',x _);\n        instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Putfield Fd C';\n        xa \\<in> {n'.\n                  (\\<exists>a.\n                      (P, C0,\n                       Main) \\<turnstile> (_ (C, M, pc) #\n       cs',x _) -a\\<rightarrow> n') \\<and>\n                  valid_node (P, C0, Main) (_ (C, M, pc) # cs',x _) \\<and>\n                  valid_node (P, C0, Main) n'}\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> {(_ (C, M, pc) #\ncs',\\<lfloor>((C, M, Suc pc) # cs', False)\\<rfloor> _),\n                                   (_ (C, M, pc) #\ncs',\\<lfloor>(find_handler_for P NullPointer ((C, M, pc) # cs'),\n              True)\\<rfloor> _),\n                                   (_ fst (the x),None _)}\n 2. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Putfield Fd C'\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {(_ (C, M, pc) #\n                           cs',\\<lfloor>((C, M, Suc pc) # cs',\n   False)\\<rfloor> _),\n                        (_ (C, M, pc) #\n                           cs',\\<lfloor>(find_handler_for P NullPointer\n    ((C, M, pc) # cs'),\n   True)\\<rfloor> _),\n                        (_ fst (the x),None _)}", "apply (clarsimp simp del: find_handler_for.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa a.\n       \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n                 (_ (C, M, pc) # cs',x _);\n        instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Putfield Fd C';\n        (P, C0,\n         Main) \\<turnstile> (_ (C, M, pc) # cs',x _) -a\\<rightarrow> xa;\n        valid_node (P, C0, Main) (_ (C, M, pc) # cs',x _);\n        valid_node (P, C0, Main) xa;\n        xa \\<noteq>\n        (_ (C, M, pc) #\n           cs',\\<lfloor>((C, M, Suc pc) # cs', False)\\<rfloor> _);\n        xa \\<noteq> (_ fst (the x),None _)\\<rbrakk>\n       \\<Longrightarrow> xa =\n                         (_ (C, M, pc) #\n                            cs',\\<lfloor>(find_handler_for P NullPointer\n     ((C, M, pc) # cs'),\n    True)\\<rfloor> _)\n 2. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Putfield Fd C'\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {(_ (C, M, pc) #\n                           cs',\\<lfloor>((C, M, Suc pc) # cs',\n   False)\\<rfloor> _),\n                        (_ (C, M, pc) #\n                           cs',\\<lfloor>(find_handler_for P NullPointer\n    ((C, M, pc) # cs'),\n   True)\\<rfloor> _),\n                        (_ fst (the x),None _)}", "by (erule JVM_CFG.cases, simp_all del: find_handler_for.simps)"], ["proof (state)\nthis:\n  finite\n   {n'.\n    \\<exists>a'.\n       valid_edge prog a' \\<and>\n       sourcenode a' = n \\<and> targetnode a' = n'}\n\ngoal (9 subgoals):\n 1. \\<And>x7.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Checkcast x7 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 2. \\<And>x81 x82.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Invoke x81 x82 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 3. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Return \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 4. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Pop \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 5. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = IAdd \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 6. \\<And>x12.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Goto x12 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 7. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = CmpEq \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 8. \\<And>x14.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       IfFalse x14 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 9. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>x7.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Checkcast x7 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 2. \\<And>x81 x82.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Invoke x81 x82 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 3. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Return \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 4. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Pop \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 5. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = IAdd \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 6. \\<And>x12.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Goto x12 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 7. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = CmpEq \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 8. \\<And>x14.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       IfFalse x14 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 9. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}", "case (Checkcast C')"], ["proof (state)\nthis:\n  instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Checkcast C'\n\ngoal (9 subgoals):\n 1. \\<And>x7.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Checkcast x7 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 2. \\<And>x81 x82.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Invoke x81 x82 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 3. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Return \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 4. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Pop \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 5. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = IAdd \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 6. \\<And>x12.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Goto x12 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 7. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = CmpEq \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 8. \\<And>x14.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       IfFalse x14 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 9. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}", "with valid_node"], ["proof (chain)\npicking this:\n  JVM_CFG_Interpret.valid_node prog n\n  instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Checkcast C'", "show ?thesis"], ["proof (prove)\nusing this:\n  JVM_CFG_Interpret.valid_node prog n\n  instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Checkcast C'\n\ngoal (1 subgoal):\n 1. finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Checkcast C'\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {n'.\n                        (\\<exists>a.\n                            (P, C0,\n                             Main) \\<turnstile> (_ (C, M, pc) #\n             cs',x _) -a\\<rightarrow> n') \\<and>\n                        valid_node (P, C0, Main)\n                         (_ (C, M, pc) # cs',x _) \\<and>\n                        valid_node (P, C0, Main) n'}", "apply (rule_tac B=\"{(_ (C,M,Suc pc)#cs',None _),\n            (_ (C,M,pc)#cs',\\<lfloor>(find_handler_for P ClassCast ((C,M,pc)#cs'),True)\\<rfloor> _),\n            (_ fst(the(x)),None _)}\" in finite_subset)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Checkcast C'\\<rbrakk>\n    \\<Longrightarrow> {n'.\n                       (\\<exists>a.\n                           (P, C0,\n                            Main) \\<turnstile> (_ (C, M, pc) #\n            cs',x _) -a\\<rightarrow> n') \\<and>\n                       valid_node (P, C0, Main)\n                        (_ (C, M, pc) # cs',x _) \\<and>\n                       valid_node (P, C0, Main) n'}\n                      \\<subseteq> {(_ (C, M, Suc pc) # cs',None _),\n                                   (_ (C, M, pc) #\ncs',\\<lfloor>(find_handler_for P ClassCast ((C, M, pc) # cs'),\n              True)\\<rfloor> _),\n                                   (_ fst (the x),None _)}\n 2. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Checkcast C'\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {(_ (C, M, Suc pc) # cs',None _),\n                        (_ (C, M, pc) #\n                           cs',\\<lfloor>(find_handler_for P ClassCast\n    ((C, M, pc) # cs'),\n   True)\\<rfloor> _),\n                        (_ fst (the x),None _)}", "apply (rule subsetI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n                 (_ (C, M, pc) # cs',x _);\n        instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Checkcast C';\n        xa \\<in> {n'.\n                  (\\<exists>a.\n                      (P, C0,\n                       Main) \\<turnstile> (_ (C, M, pc) #\n       cs',x _) -a\\<rightarrow> n') \\<and>\n                  valid_node (P, C0, Main) (_ (C, M, pc) # cs',x _) \\<and>\n                  valid_node (P, C0, Main) n'}\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> {(_ (C, M, Suc pc) # cs',None _),\n                                   (_ (C, M, pc) #\ncs',\\<lfloor>(find_handler_for P ClassCast ((C, M, pc) # cs'),\n              True)\\<rfloor> _),\n                                   (_ fst (the x),None _)}\n 2. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Checkcast C'\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {(_ (C, M, Suc pc) # cs',None _),\n                        (_ (C, M, pc) #\n                           cs',\\<lfloor>(find_handler_for P ClassCast\n    ((C, M, pc) # cs'),\n   True)\\<rfloor> _),\n                        (_ fst (the x),None _)}", "apply (clarsimp simp del: find_handler_for.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa a.\n       \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n                 (_ (C, M, pc) # cs',x _);\n        instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Checkcast C';\n        (P, C0,\n         Main) \\<turnstile> (_ (C, M, pc) # cs',x _) -a\\<rightarrow> xa;\n        valid_node (P, C0, Main) (_ (C, M, pc) # cs',x _);\n        valid_node (P, C0, Main) xa;\n        xa \\<noteq> (_ (C, M, Suc pc) # cs',None _);\n        xa \\<noteq> (_ fst (the x),None _)\\<rbrakk>\n       \\<Longrightarrow> xa =\n                         (_ (C, M, pc) #\n                            cs',\\<lfloor>(find_handler_for P ClassCast\n     ((C, M, pc) # cs'),\n    True)\\<rfloor> _)\n 2. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Checkcast C'\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {(_ (C, M, Suc pc) # cs',None _),\n                        (_ (C, M, pc) #\n                           cs',\\<lfloor>(find_handler_for P ClassCast\n    ((C, M, pc) # cs'),\n   True)\\<rfloor> _),\n                        (_ fst (the x),None _)}", "by (erule JVM_CFG.cases, simp_all del: find_handler_for.simps)"], ["proof (state)\nthis:\n  finite\n   {n'.\n    \\<exists>a'.\n       valid_edge prog a' \\<and>\n       sourcenode a' = n \\<and> targetnode a' = n'}\n\ngoal (8 subgoals):\n 1. \\<And>x81 x82.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Invoke x81 x82 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 2. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Return \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 3. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Pop \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 4. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = IAdd \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 5. \\<And>x12.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Goto x12 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 6. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = CmpEq \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 7. \\<And>x14.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       IfFalse x14 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 8. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>x81 x82.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Invoke x81 x82 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 2. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Return \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 3. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Pop \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 4. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = IAdd \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 5. \\<And>x12.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Goto x12 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 6. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = CmpEq \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 7. \\<And>x14.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       IfFalse x14 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 8. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}", "case (Invoke M' n')"], ["proof (state)\nthis:\n  instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Invoke M' n'\n\ngoal (8 subgoals):\n 1. \\<And>x81 x82.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       Invoke x81 x82 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 2. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Return \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 3. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Pop \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 4. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = IAdd \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 5. \\<And>x12.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Goto x12 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 6. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = CmpEq \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 7. \\<And>x14.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       IfFalse x14 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 8. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}", "with finite_classes valid_node"], ["proof (chain)\npicking this:\n  finite {C. is_class P\\<^bsub>wf\\<^esub> C}\n  JVM_CFG_Interpret.valid_node prog n\n  instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Invoke M' n'", "show ?thesis"], ["proof (prove)\nusing this:\n  finite {C. is_class P\\<^bsub>wf\\<^esub> C}\n  JVM_CFG_Interpret.valid_node prog n\n  instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Invoke M' n'\n\ngoal (1 subgoal):\n 1. finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite\n              {C. \\<exists>a aa b.\n                     class P\\<^bsub>wf\\<^esub> C =\n                     \\<lfloor>(a, aa, b)\\<rfloor>};\n     JVM_CFG_Interpret.valid_node (P, C0, Main) (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Invoke M' n'\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {n'.\n                        (\\<exists>a.\n                            (P, C0,\n                             Main) \\<turnstile> (_ (C, M, pc) #\n             cs',x _) -a\\<rightarrow> n') \\<and>\n                        valid_node (P, C0, Main)\n                         (_ (C, M, pc) # cs',x _) \\<and>\n                        valid_node (P, C0, Main) n'}", "apply (rule_tac B=\"\n            {n'. (\\<exists>D. is_class (P\\<^bsub>wf\\<^esub>) D \\<and> n' = (_ (C,M,pc)#cs',\\<lfloor>((D,M',0)#(C,M,pc)#cs',False)\\<rfloor> _))}\n            \\<union> {(_ (C,M,pc)#cs',\\<lfloor>(find_handler_for P NullPointer ((C,M,pc)#cs'),True)\\<rfloor> _),\n               (_ fst(the(x)),None _)}\"\n            in finite_subset)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>finite\n              {C. \\<exists>a aa b.\n                     class P\\<^bsub>wf\\<^esub> C =\n                     \\<lfloor>(a, aa, b)\\<rfloor>};\n     JVM_CFG_Interpret.valid_node (P, C0, Main) (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Invoke M' n'\\<rbrakk>\n    \\<Longrightarrow> {n'.\n                       (\\<exists>a.\n                           (P, C0,\n                            Main) \\<turnstile> (_ (C, M, pc) #\n            cs',x _) -a\\<rightarrow> n') \\<and>\n                       valid_node (P, C0, Main)\n                        (_ (C, M, pc) # cs',x _) \\<and>\n                       valid_node (P, C0, Main) n'}\n                      \\<subseteq> {n'.\n                                   \\<exists>D.\nis_class P\\<^bsub>wf\\<^esub> D \\<and>\nn' =\n(_ (C, M, pc) #\n   cs',\\<lfloor>((D, M', 0) # (C, M, pc) # cs', False)\\<rfloor> _)} \\<union>\n                                  {(_ (C, M, pc) #\ncs',\\<lfloor>(find_handler_for P NullPointer ((C, M, pc) # cs'),\n              True)\\<rfloor> _),\n                                   (_ fst (the x),None _)}\n 2. \\<lbrakk>finite\n              {C. \\<exists>a aa b.\n                     class P\\<^bsub>wf\\<^esub> C =\n                     \\<lfloor>(a, aa, b)\\<rfloor>};\n     JVM_CFG_Interpret.valid_node (P, C0, Main) (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Invoke M' n'\\<rbrakk>\n    \\<Longrightarrow> finite\n                       ({n'.\n                         \\<exists>D.\n                            is_class P\\<^bsub>wf\\<^esub> D \\<and>\n                            n' =\n                            (_ (C, M, pc) #\n                               cs',\\<lfloor>((D, M', 0) # (C, M, pc) # cs',\n       False)\\<rfloor> _)} \\<union>\n                        {(_ (C, M, pc) #\n                            cs',\\<lfloor>(find_handler_for P NullPointer\n     ((C, M, pc) # cs'),\n    True)\\<rfloor> _),\n                         (_ fst (the x),None _)})", "apply (rule subsetI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>finite\n                 {C. \\<exists>a aa b.\n                        class P\\<^bsub>wf\\<^esub> C =\n                        \\<lfloor>(a, aa, b)\\<rfloor>};\n        JVM_CFG_Interpret.valid_node (P, C0, Main) (_ (C, M, pc) # cs',x _);\n        instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Invoke M' n';\n        xa \\<in> {n'.\n                  (\\<exists>a.\n                      (P, C0,\n                       Main) \\<turnstile> (_ (C, M, pc) #\n       cs',x _) -a\\<rightarrow> n') \\<and>\n                  valid_node (P, C0, Main) (_ (C, M, pc) # cs',x _) \\<and>\n                  valid_node (P, C0, Main) n'}\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> {n'.\n                                   \\<exists>D.\nis_class P\\<^bsub>wf\\<^esub> D \\<and>\nn' =\n(_ (C, M, pc) #\n   cs',\\<lfloor>((D, M', 0) # (C, M, pc) # cs', False)\\<rfloor> _)} \\<union>\n                                  {(_ (C, M, pc) #\ncs',\\<lfloor>(find_handler_for P NullPointer ((C, M, pc) # cs'),\n              True)\\<rfloor> _),\n                                   (_ fst (the x),None _)}\n 2. \\<lbrakk>finite\n              {C. \\<exists>a aa b.\n                     class P\\<^bsub>wf\\<^esub> C =\n                     \\<lfloor>(a, aa, b)\\<rfloor>};\n     JVM_CFG_Interpret.valid_node (P, C0, Main) (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Invoke M' n'\\<rbrakk>\n    \\<Longrightarrow> finite\n                       ({n'.\n                         \\<exists>D.\n                            is_class P\\<^bsub>wf\\<^esub> D \\<and>\n                            n' =\n                            (_ (C, M, pc) #\n                               cs',\\<lfloor>((D, M', 0) # (C, M, pc) # cs',\n       False)\\<rfloor> _)} \\<union>\n                        {(_ (C, M, pc) #\n                            cs',\\<lfloor>(find_handler_for P NullPointer\n     ((C, M, pc) # cs'),\n    True)\\<rfloor> _),\n                         (_ fst (the x),None _)})", "apply (clarsimp simp del: find_handler_for.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa a.\n       \\<lbrakk>finite\n                 {C. \\<exists>a aa b.\n                        class P\\<^bsub>wf\\<^esub> C =\n                        \\<lfloor>(a, aa, b)\\<rfloor>};\n        JVM_CFG_Interpret.valid_node (P, C0, Main) (_ (C, M, pc) # cs',x _);\n        instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Invoke M' n';\n        (P, C0,\n         Main) \\<turnstile> (_ (C, M, pc) # cs',x _) -a\\<rightarrow> xa;\n        valid_node (P, C0, Main) (_ (C, M, pc) # cs',x _);\n        valid_node (P, C0, Main) xa;\n        xa \\<noteq>\n        (_ (C, M, pc) #\n           cs',\\<lfloor>(find_handler_for P NullPointer ((C, M, pc) # cs'),\n                         True)\\<rfloor> _);\n        \\<forall>D.\n           (\\<forall>a aa b.\n               class P\\<^bsub>wf\\<^esub> D \\<noteq>\n               \\<lfloor>(a, aa, b)\\<rfloor>) \\<or>\n           xa \\<noteq>\n           (_ (C, M, pc) #\n              cs',\\<lfloor>((D, M', 0) # (C, M, pc) # cs',\n                            False)\\<rfloor> _)\\<rbrakk>\n       \\<Longrightarrow> xa = (_ fst (the x),None _)\n 2. \\<lbrakk>finite\n              {C. \\<exists>a aa b.\n                     class P\\<^bsub>wf\\<^esub> C =\n                     \\<lfloor>(a, aa, b)\\<rfloor>};\n     JVM_CFG_Interpret.valid_node (P, C0, Main) (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Invoke M' n'\\<rbrakk>\n    \\<Longrightarrow> finite\n                       ({n'.\n                         \\<exists>D.\n                            is_class P\\<^bsub>wf\\<^esub> D \\<and>\n                            n' =\n                            (_ (C, M, pc) #\n                               cs',\\<lfloor>((D, M', 0) # (C, M, pc) # cs',\n       False)\\<rfloor> _)} \\<union>\n                        {(_ (C, M, pc) #\n                            cs',\\<lfloor>(find_handler_for P NullPointer\n     ((C, M, pc) # cs'),\n    True)\\<rfloor> _),\n                         (_ fst (the x),None _)})", "apply (erule JVM_CFG.cases, simp_all del: find_handler_for.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa a prog Pa cd stk_length ek D.\n       \\<lbrakk>finite\n                 {C. \\<exists>a aa b.\n                        class Pa\\<^bsub>wf\\<^esub> C =\n                        \\<lfloor>(a, aa, b)\\<rfloor>};\n        JVM_CFG_Interpret.valid_node (Pa, C0, Main)\n         (_ (C, M, pc) # cs',None _);\n        locLength Pa D M' 0 -\n        Suc (fst (snd (snd (snd (snd (method Pa\\<^bsub>wf\\<^esub> D\n M')))))) =\n        n';\n        valid_callstack (Pa, C0, Main) ((C, M, pc) # cs');\n        (\\<exists>a b.\n            Pa\\<^bsub>\\<Phi>\\<^esub> D M' ! 0 =\n            \\<lfloor>(a, b)\\<rfloor>) \\<and>\n        (\\<exists>T Ts mxs mxl is.\n            (\\<exists>xt.\n                Pa\\<^bsub>wf\\<^esub> \\<turnstile> D sees M': Ts\\<rightarrow>T = (mxs,\n     mxl, is, xt) in D) \\<and>\n            is \\<noteq> []) \\<and>\n        (\\<exists>Q.\n            (Pa, C0,\n             Main) \\<turnstile> (_ (C, M, pc) #\n                                   cs',None _) -(Q)\\<^sub>\\<surd>\\<rightarrow> (_ (C,\n       M, pc) #\n      cs',\\<lfloor>((D, M', 0) # (C, M, pc) # cs',\n                    False)\\<rfloor> _)) \\<and>\n        (\\<exists>f.\n            (Pa, C0,\n             Main) \\<turnstile> (_ (C, M, pc) #\n                                   cs',\\<lfloor>((D, M', 0) #\n           (C, M, pc) # cs',\n           False)\\<rfloor> _) -\\<Up>f\\<rightarrow> (_ (D, M', 0) #\n                (C, M, pc) # cs',None _));\n        \\<forall>a aa b.\n           class Pa\\<^bsub>wf\\<^esub> D \\<noteq>\n           \\<lfloor>(a, aa, b)\\<rfloor>;\n        P = Pa; x = None;\n        a =\n        (\\<lambda>(h, stk, loc).\n            stk (length cs', stkLength Pa C M pc - Suc n') \\<noteq>\n            Null \\<and>\n            fst (method Pa\\<^bsub>wf\\<^esub>\n                  (cname_of h\n                    (the_Addr\n                      (stk (length cs', stkLength Pa C M pc - Suc n'))))\n                  M') =\n            D)\\<^sub>\\<surd>;\n        xa =\n        (_ (C, M, pc) #\n           cs',\\<lfloor>((D, M', 0) # (C, M, pc) # cs', False)\\<rfloor> _);\n        prog = (Pa, C0, Main);\n        instrs_of Pa\\<^bsub>wf\\<^esub> C M ! pc = Invoke M' n';\n        cd = length cs'; stk_length = stkLength Pa C M pc;\n        ek =\n        (\\<lambda>(h, stk, loc).\n            stk (length cs', stkLength Pa C M pc - Suc n') \\<noteq>\n            Null \\<and>\n            fst (method Pa\\<^bsub>wf\\<^esub>\n                  (cname_of h\n                    (the_Addr\n                      (stk (length cs', stkLength Pa C M pc - Suc n'))))\n                  M') =\n            D)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> False", "apply (clarsimp simp del: find_handler_for.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>D ac ba T Ts mxs mxl is Q f xt.\n       \\<lbrakk>finite\n                 {C. \\<exists>a aa b.\n                        class P\\<^bsub>wf\\<^esub> C =\n                        \\<lfloor>(a, aa, b)\\<rfloor>};\n        JVM_CFG_Interpret.valid_node (P, C0, Main)\n         (_ (C, M, pc) # cs',None _);\n        valid_callstack (P, C0, Main) ((C, M, pc) # cs');\n        \\<forall>a aa b.\n           class P\\<^bsub>wf\\<^esub> D \\<noteq>\n           \\<lfloor>(a, aa, b)\\<rfloor>;\n        x = None;\n        instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n        Invoke M' (length ba - Suc mxl);\n        n' = length ba - Suc mxl;\n        P\\<^bsub>\\<Phi>\\<^esub> D M' ! 0 = \\<lfloor>(ac, ba)\\<rfloor>;\n        (P, C0,\n         Main) \\<turnstile> (_ (C, M, pc) #\n                               cs',None _) -(Q)\\<^sub>\\<surd>\\<rightarrow> (_ (C,\n   M, pc) #\n  cs',\\<lfloor>((D, M', 0) # (C, M, pc) # cs', False)\\<rfloor> _);\n        (P, C0,\n         Main) \\<turnstile> (_ (C, M, pc) #\n                               cs',\\<lfloor>((D, M', 0) # (C, M, pc) # cs',\n       False)\\<rfloor> _) -\\<Up>f\\<rightarrow> (_ (D, M', 0) #\n            (C, M, pc) # cs',None _);\n        is \\<noteq> [];\n        P\\<^bsub>wf\\<^esub> \\<turnstile> D sees M': Ts\\<rightarrow>T = (mxs,\n                                  mxl, is, xt) in D\\<rbrakk>\n       \\<Longrightarrow> False", "apply (drule sees_method_is_class)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>D ac ba T Ts mxs mxl is Q f xt.\n       \\<lbrakk>finite\n                 {C. \\<exists>a aa b.\n                        class P\\<^bsub>wf\\<^esub> C =\n                        \\<lfloor>(a, aa, b)\\<rfloor>};\n        JVM_CFG_Interpret.valid_node (P, C0, Main)\n         (_ (C, M, pc) # cs',None _);\n        valid_callstack (P, C0, Main) ((C, M, pc) # cs');\n        \\<forall>a aa b.\n           class P\\<^bsub>wf\\<^esub> D \\<noteq>\n           \\<lfloor>(a, aa, b)\\<rfloor>;\n        x = None;\n        instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n        Invoke M' (length ba - Suc mxl);\n        n' = length ba - Suc mxl;\n        P\\<^bsub>\\<Phi>\\<^esub> D M' ! 0 = \\<lfloor>(ac, ba)\\<rfloor>;\n        (P, C0,\n         Main) \\<turnstile> (_ (C, M, pc) #\n                               cs',None _) -(Q)\\<^sub>\\<surd>\\<rightarrow> (_ (C,\n   M, pc) #\n  cs',\\<lfloor>((D, M', 0) # (C, M, pc) # cs', False)\\<rfloor> _);\n        (P, C0,\n         Main) \\<turnstile> (_ (C, M, pc) #\n                               cs',\\<lfloor>((D, M', 0) # (C, M, pc) # cs',\n       False)\\<rfloor> _) -\\<Up>f\\<rightarrow> (_ (D, M', 0) #\n            (C, M, pc) # cs',None _);\n        is \\<noteq> []; is_class P\\<^bsub>wf\\<^esub> D\\<rbrakk>\n       \\<Longrightarrow> False", "by (clarsimp simp del: find_handler_for.simps)"], ["proof (state)\nthis:\n  finite\n   {n'.\n    \\<exists>a'.\n       valid_edge prog a' \\<and>\n       sourcenode a' = n \\<and> targetnode a' = n'}\n\ngoal (7 subgoals):\n 1. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Return \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 2. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Pop \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 3. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = IAdd \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 4. \\<And>x12.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Goto x12 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 5. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = CmpEq \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 6. \\<And>x14.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       IfFalse x14 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 7. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Return \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 2. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Pop \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 3. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = IAdd \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 4. \\<And>x12.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Goto x12 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 5. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = CmpEq \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 6. \\<And>x14.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       IfFalse x14 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 7. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}", "case Return"], ["proof (state)\nthis:\n  instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Return\n\ngoal (7 subgoals):\n 1. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Return \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 2. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Pop \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 3. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = IAdd \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 4. \\<And>x12.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Goto x12 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 5. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = CmpEq \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 6. \\<And>x14.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       IfFalse x14 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 7. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}", "with valid_node"], ["proof (chain)\npicking this:\n  JVM_CFG_Interpret.valid_node prog n\n  instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Return", "show ?thesis"], ["proof (prove)\nusing this:\n  JVM_CFG_Interpret.valid_node prog n\n  instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Return\n\ngoal (1 subgoal):\n 1. finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Return\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {n'.\n                        (\\<exists>a.\n                            (P, C0,\n                             Main) \\<turnstile> (_ (C, M, pc) #\n             cs',x _) -a\\<rightarrow> n') \\<and>\n                        valid_node (P, C0, Main)\n                         (_ (C, M, pc) # cs',x _) \\<and>\n                        valid_node (P, C0, Main) n'}", "apply (rule_tac B=\"\n            {(_ (fst(hd(cs')),fst(snd(hd(cs'))),Suc(snd(snd(hd(cs')))))#(tl cs'),None _),\n             (_Exit_)}\" in finite_subset)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Return\\<rbrakk>\n    \\<Longrightarrow> {n'.\n                       (\\<exists>a.\n                           (P, C0,\n                            Main) \\<turnstile> (_ (C, M, pc) #\n            cs',x _) -a\\<rightarrow> n') \\<and>\n                       valid_node (P, C0, Main)\n                        (_ (C, M, pc) # cs',x _) \\<and>\n                       valid_node (P, C0, Main) n'}\n                      \\<subseteq> {(_ (fst (hd cs'), fst (snd (hd cs')),\n Suc (snd (snd (hd cs')))) #\ntl cs',None _),\n                                   (_Exit_)}\n 2. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Return\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {(_ (fst (hd cs'), fst (snd (hd cs')),\n                            Suc (snd (snd (hd cs')))) #\n                           tl cs',None _),\n                        (_Exit_)}", "apply (rule subsetI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n                 (_ (C, M, pc) # cs',x _);\n        instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Return;\n        xa \\<in> {n'.\n                  (\\<exists>a.\n                      (P, C0,\n                       Main) \\<turnstile> (_ (C, M, pc) #\n       cs',x _) -a\\<rightarrow> n') \\<and>\n                  valid_node (P, C0, Main) (_ (C, M, pc) # cs',x _) \\<and>\n                  valid_node (P, C0, Main) n'}\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> {(_ (fst (hd cs'), fst (snd (hd cs')),\n Suc (snd (snd (hd cs')))) #\ntl cs',None _),\n                                   (_Exit_)}\n 2. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Return\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {(_ (fst (hd cs'), fst (snd (hd cs')),\n                            Suc (snd (snd (hd cs')))) #\n                           tl cs',None _),\n                        (_Exit_)}", "apply (clarsimp simp del: find_handler_for.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa a.\n       \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n                 (_ (C, M, pc) # cs',x _);\n        instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Return;\n        (P, C0,\n         Main) \\<turnstile> (_ (C, M, pc) # cs',x _) -a\\<rightarrow> xa;\n        valid_node (P, C0, Main) (_ (C, M, pc) # cs',x _);\n        valid_node (P, C0, Main) xa; xa \\<noteq> (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> xa =\n                         (_ (fst (hd cs'), fst (snd (hd cs')),\n                             Suc (snd (snd (hd cs')))) #\n                            tl cs',None _)\n 2. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Return\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {(_ (fst (hd cs'), fst (snd (hd cs')),\n                            Suc (snd (snd (hd cs')))) #\n                           tl cs',None _),\n                        (_Exit_)}", "by (erule JVM_CFG.cases, simp_all del: find_handler_for.simps)"], ["proof (state)\nthis:\n  finite\n   {n'.\n    \\<exists>a'.\n       valid_edge prog a' \\<and>\n       sourcenode a' = n \\<and> targetnode a' = n'}\n\ngoal (6 subgoals):\n 1. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Pop \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 2. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = IAdd \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 3. \\<And>x12.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Goto x12 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 4. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = CmpEq \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 5. \\<And>x14.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       IfFalse x14 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 6. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Pop \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 2. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = IAdd \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 3. \\<And>x12.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Goto x12 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 4. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = CmpEq \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 5. \\<And>x14.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       IfFalse x14 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 6. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}", "case Pop"], ["proof (state)\nthis:\n  instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Pop\n\ngoal (6 subgoals):\n 1. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Pop \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 2. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = IAdd \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 3. \\<And>x12.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Goto x12 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 4. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = CmpEq \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 5. \\<And>x14.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       IfFalse x14 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 6. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}", "with valid_node"], ["proof (chain)\npicking this:\n  JVM_CFG_Interpret.valid_node prog n\n  instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Pop", "show ?thesis"], ["proof (prove)\nusing this:\n  JVM_CFG_Interpret.valid_node prog n\n  instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Pop\n\ngoal (1 subgoal):\n 1. finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {n'.\n                        (\\<exists>a.\n                            (P, C0,\n                             Main) \\<turnstile> (_ (C, M, pc) #\n             cs',x _) -a\\<rightarrow> n') \\<and>\n                        valid_node (P, C0, Main)\n                         (_ (C, M, pc) # cs',x _) \\<and>\n                        valid_node (P, C0, Main) n'}", "apply (rule_tac B=\"{(_ (C,M,Suc pc)#cs',None _)}\" in finite_subset)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> {n'.\n                       (\\<exists>a.\n                           (P, C0,\n                            Main) \\<turnstile> (_ (C, M, pc) #\n            cs',x _) -a\\<rightarrow> n') \\<and>\n                       valid_node (P, C0, Main)\n                        (_ (C, M, pc) # cs',x _) \\<and>\n                       valid_node (P, C0, Main) n'}\n                      \\<subseteq> {(_ (C, M, Suc pc) # cs',None _)}\n 2. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Pop\\<rbrakk>\n    \\<Longrightarrow> finite {(_ (C, M, Suc pc) # cs',None _)}", "by (auto elim: JVM_CFG.cases)"], ["proof (state)\nthis:\n  finite\n   {n'.\n    \\<exists>a'.\n       valid_edge prog a' \\<and>\n       sourcenode a' = n \\<and> targetnode a' = n'}\n\ngoal (5 subgoals):\n 1. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = IAdd \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 2. \\<And>x12.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Goto x12 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 3. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = CmpEq \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 4. \\<And>x14.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       IfFalse x14 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 5. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = IAdd \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 2. \\<And>x12.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Goto x12 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 3. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = CmpEq \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 4. \\<And>x14.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       IfFalse x14 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 5. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}", "case IAdd"], ["proof (state)\nthis:\n  instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = IAdd\n\ngoal (5 subgoals):\n 1. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = IAdd \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 2. \\<And>x12.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Goto x12 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 3. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = CmpEq \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 4. \\<And>x14.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       IfFalse x14 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 5. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}", "with valid_node"], ["proof (chain)\npicking this:\n  JVM_CFG_Interpret.valid_node prog n\n  instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = IAdd", "show ?thesis"], ["proof (prove)\nusing this:\n  JVM_CFG_Interpret.valid_node prog n\n  instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = IAdd\n\ngoal (1 subgoal):\n 1. finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = IAdd\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {n'.\n                        (\\<exists>a.\n                            (P, C0,\n                             Main) \\<turnstile> (_ (C, M, pc) #\n             cs',x _) -a\\<rightarrow> n') \\<and>\n                        valid_node (P, C0, Main)\n                         (_ (C, M, pc) # cs',x _) \\<and>\n                        valid_node (P, C0, Main) n'}", "apply (rule_tac B=\"{(_ (C,M,Suc pc)#cs',None _)}\" in finite_subset)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = IAdd\\<rbrakk>\n    \\<Longrightarrow> {n'.\n                       (\\<exists>a.\n                           (P, C0,\n                            Main) \\<turnstile> (_ (C, M, pc) #\n            cs',x _) -a\\<rightarrow> n') \\<and>\n                       valid_node (P, C0, Main)\n                        (_ (C, M, pc) # cs',x _) \\<and>\n                       valid_node (P, C0, Main) n'}\n                      \\<subseteq> {(_ (C, M, Suc pc) # cs',None _)}\n 2. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = IAdd\\<rbrakk>\n    \\<Longrightarrow> finite {(_ (C, M, Suc pc) # cs',None _)}", "by (auto elim: JVM_CFG.cases)"], ["proof (state)\nthis:\n  finite\n   {n'.\n    \\<exists>a'.\n       valid_edge prog a' \\<and>\n       sourcenode a' = n \\<and> targetnode a' = n'}\n\ngoal (4 subgoals):\n 1. \\<And>x12.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Goto x12 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 2. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = CmpEq \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 3. \\<And>x14.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       IfFalse x14 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 4. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x12.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Goto x12 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 2. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = CmpEq \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 3. \\<And>x14.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       IfFalse x14 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 4. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}", "case (Goto i)"], ["proof (state)\nthis:\n  instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Goto i\n\ngoal (4 subgoals):\n 1. \\<And>x12.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Goto x12 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 2. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = CmpEq \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 3. \\<And>x14.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       IfFalse x14 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 4. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}", "with valid_node"], ["proof (chain)\npicking this:\n  JVM_CFG_Interpret.valid_node prog n\n  instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Goto i", "show ?thesis"], ["proof (prove)\nusing this:\n  JVM_CFG_Interpret.valid_node prog n\n  instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Goto i\n\ngoal (1 subgoal):\n 1. finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Goto i\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {n'.\n                        (\\<exists>a.\n                            (P, C0,\n                             Main) \\<turnstile> (_ (C, M, pc) #\n             cs',x _) -a\\<rightarrow> n') \\<and>\n                        valid_node (P, C0, Main)\n                         (_ (C, M, pc) # cs',x _) \\<and>\n                        valid_node (P, C0, Main) n'}", "apply (rule_tac B=\"{(_ (C,M,nat (int pc + i))#cs',None _)}\" in finite_subset)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Goto i\\<rbrakk>\n    \\<Longrightarrow> {n'.\n                       (\\<exists>a.\n                           (P, C0,\n                            Main) \\<turnstile> (_ (C, M, pc) #\n            cs',x _) -a\\<rightarrow> n') \\<and>\n                       valid_node (P, C0, Main)\n                        (_ (C, M, pc) # cs',x _) \\<and>\n                       valid_node (P, C0, Main) n'}\n                      \\<subseteq> {(_ (C, M, nat (int pc + i)) #\ncs',None _)}\n 2. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Goto i\\<rbrakk>\n    \\<Longrightarrow> finite {(_ (C, M, nat (int pc + i)) # cs',None _)}", "by (auto elim: JVM_CFG.cases)"], ["proof (state)\nthis:\n  finite\n   {n'.\n    \\<exists>a'.\n       valid_edge prog a' \\<and>\n       sourcenode a' = n \\<and> targetnode a' = n'}\n\ngoal (3 subgoals):\n 1. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = CmpEq \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 2. \\<And>x14.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       IfFalse x14 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 3. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = CmpEq \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 2. \\<And>x14.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       IfFalse x14 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 3. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}", "case CmpEq"], ["proof (state)\nthis:\n  instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = CmpEq\n\ngoal (3 subgoals):\n 1. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = CmpEq \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}\n 2. \\<And>x14.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       IfFalse x14 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 3. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}", "with valid_node"], ["proof (chain)\npicking this:\n  JVM_CFG_Interpret.valid_node prog n\n  instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = CmpEq", "show ?thesis"], ["proof (prove)\nusing this:\n  JVM_CFG_Interpret.valid_node prog n\n  instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = CmpEq\n\ngoal (1 subgoal):\n 1. finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = CmpEq\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {n'.\n                        (\\<exists>a.\n                            (P, C0,\n                             Main) \\<turnstile> (_ (C, M, pc) #\n             cs',x _) -a\\<rightarrow> n') \\<and>\n                        valid_node (P, C0, Main)\n                         (_ (C, M, pc) # cs',x _) \\<and>\n                        valid_node (P, C0, Main) n'}", "apply (rule_tac B=\"{(_ (C,M,Suc pc)#cs',None _)}\" in finite_subset)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = CmpEq\\<rbrakk>\n    \\<Longrightarrow> {n'.\n                       (\\<exists>a.\n                           (P, C0,\n                            Main) \\<turnstile> (_ (C, M, pc) #\n            cs',x _) -a\\<rightarrow> n') \\<and>\n                       valid_node (P, C0, Main)\n                        (_ (C, M, pc) # cs',x _) \\<and>\n                       valid_node (P, C0, Main) n'}\n                      \\<subseteq> {(_ (C, M, Suc pc) # cs',None _)}\n 2. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = CmpEq\\<rbrakk>\n    \\<Longrightarrow> finite {(_ (C, M, Suc pc) # cs',None _)}", "by (auto elim: JVM_CFG.cases)"], ["proof (state)\nthis:\n  finite\n   {n'.\n    \\<exists>a'.\n       valid_edge prog a' \\<and>\n       sourcenode a' = n \\<and> targetnode a' = n'}\n\ngoal (2 subgoals):\n 1. \\<And>x14.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       IfFalse x14 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 2. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x14.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       IfFalse x14 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 2. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}", "case (IfFalse i)"], ["proof (state)\nthis:\n  instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = IfFalse i\n\ngoal (2 subgoals):\n 1. \\<And>x14.\n       instrs_of P\\<^bsub>wf\\<^esub> C M ! pc =\n       IfFalse x14 \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}\n 2. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}", "with valid_node"], ["proof (chain)\npicking this:\n  JVM_CFG_Interpret.valid_node prog n\n  instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = IfFalse i", "show ?thesis"], ["proof (prove)\nusing this:\n  JVM_CFG_Interpret.valid_node prog n\n  instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = IfFalse i\n\ngoal (1 subgoal):\n 1. finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = IfFalse i\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {n'.\n                        (\\<exists>a.\n                            (P, C0,\n                             Main) \\<turnstile> (_ (C, M, pc) #\n             cs',x _) -a\\<rightarrow> n') \\<and>\n                        valid_node (P, C0, Main)\n                         (_ (C, M, pc) # cs',x _) \\<and>\n                        valid_node (P, C0, Main) n'}", "apply (rule_tac B=\"{(_ (C,M,Suc pc)#cs',None _),\n            (_ (C,M,nat (int pc + i))#cs',None _)}\" in finite_subset)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = IfFalse i\\<rbrakk>\n    \\<Longrightarrow> {n'.\n                       (\\<exists>a.\n                           (P, C0,\n                            Main) \\<turnstile> (_ (C, M, pc) #\n            cs',x _) -a\\<rightarrow> n') \\<and>\n                       valid_node (P, C0, Main)\n                        (_ (C, M, pc) # cs',x _) \\<and>\n                       valid_node (P, C0, Main) n'}\n                      \\<subseteq> {(_ (C, M, Suc pc) # cs',None _),\n                                   (_ (C, M, nat (int pc + i)) #\ncs',None _)}\n 2. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = IfFalse i\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {(_ (C, M, Suc pc) # cs',None _),\n                        (_ (C, M, nat (int pc + i)) # cs',None _)}", "by (auto elim: JVM_CFG.cases)"], ["proof (state)\nthis:\n  finite\n   {n'.\n    \\<exists>a'.\n       valid_edge prog a' \\<and>\n       sourcenode a' = n \\<and> targetnode a' = n'}\n\ngoal (1 subgoal):\n 1. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}", "case Throw"], ["proof (state)\nthis:\n  instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw\n\ngoal (1 subgoal):\n 1. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}", "have \"finite {(l,pc'). l < Suc (length cs') \\<and>\n          pc' < (\\<Sum>i\\<le>(length cs'). (length (instrs_of (P\\<^bsub>wf\\<^esub>) (fst (((C, M, pc) # cs') ! i))\n          (fst (snd (((C, M, pc) # cs') ! i))))))}\"\n          (is \"finite ?f1\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {(l, pc').\n      l < Suc (length cs') \\<and>\n      pc'\n      < (\\<Sum>i\\<le>length cs'.\n            length\n             (instrs_of P\\<^bsub>wf\\<^esub> (fst (((C, M, pc) # cs') ! i))\n               (fst (snd (((C, M, pc) # cs') ! i)))))}", "by (auto intro: finite_cartesian_product bounded_nat_set_is_finite)"], ["proof (state)\nthis:\n  finite\n   {(l, pc').\n    l < Suc (length cs') \\<and>\n    pc'\n    < (\\<Sum>i\\<le>length cs'.\n          length\n           (instrs_of P\\<^bsub>wf\\<^esub> (fst (((C, M, pc) # cs') ! i))\n             (fst (snd (((C, M, pc) # cs') ! i)))))}\n\ngoal (1 subgoal):\n 1. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}", "hence f_1: \"finite {(l,pc'). l < length ((C, M, pc) # cs') \\<and>\n            pc' < length (instrs_of (P\\<^bsub>wf\\<^esub>) (fst(((C,M,pc)#cs')!l)) (fst(snd(((C,M,pc)#cs')!l))))}\""], ["proof (prove)\nusing this:\n  finite\n   {(l, pc').\n    l < Suc (length cs') \\<and>\n    pc'\n    < (\\<Sum>i\\<le>length cs'.\n          length\n           (instrs_of P\\<^bsub>wf\\<^esub> (fst (((C, M, pc) # cs') ! i))\n             (fst (snd (((C, M, pc) # cs') ! i)))))}\n\ngoal (1 subgoal):\n 1. finite\n     {(l, pc').\n      l < length ((C, M, pc) # cs') \\<and>\n      pc'\n      < length\n         (instrs_of P\\<^bsub>wf\\<^esub> (fst (((C, M, pc) # cs') ! l))\n           (fst (snd (((C, M, pc) # cs') ! l))))}", "apply (rule_tac B=\"?f1\" in finite_subset)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite\n     {(l, pc').\n      l < Suc (length cs') \\<and>\n      pc'\n      < (\\<Sum>i\\<le>length cs'.\n            length\n             (instrs_of P\\<^bsub>wf\\<^esub> (fst (((C, M, pc) # cs') ! i))\n               (fst (snd (((C, M, pc) # cs') ! i)))))} \\<Longrightarrow>\n    {(l, pc').\n     l < length ((C, M, pc) # cs') \\<and>\n     pc'\n     < length\n        (instrs_of P\\<^bsub>wf\\<^esub> (fst (((C, M, pc) # cs') ! l))\n          (fst (snd (((C, M, pc) # cs') ! l))))}\n    \\<subseteq> {(l, pc').\n                 l < Suc (length cs') \\<and>\n                 pc'\n                 < (\\<Sum>i\\<le>length cs'.\n                       length\n                        (instrs_of P\\<^bsub>wf\\<^esub>\n                          (fst (((C, M, pc) # cs') ! i))\n                          (fst (snd (((C, M, pc) # cs') ! i)))))}\n 2. finite\n     {(l, pc').\n      l < Suc (length cs') \\<and>\n      pc'\n      < (\\<Sum>i\\<le>length cs'.\n            length\n             (instrs_of P\\<^bsub>wf\\<^esub> (fst (((C, M, pc) # cs') ! i))\n               (fst (snd (((C, M, pc) # cs') ! i)))))} \\<Longrightarrow>\n    finite\n     {(l, pc').\n      l < Suc (length cs') \\<and>\n      pc'\n      < (\\<Sum>i\\<le>length cs'.\n            length\n             (instrs_of P\\<^bsub>wf\\<^esub> (fst (((C, M, pc) # cs') ! i))\n               (fst (snd (((C, M, pc) # cs') ! i)))))}", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>a < Suc (length cs');\n        b < length\n             (instrs_of P\\<^bsub>wf\\<^esub> (fst (((C, M, pc) # cs') ! a))\n               (fst (snd (((C, M, pc) # cs') ! a))))\\<rbrakk>\n       \\<Longrightarrow> b < (\\<Sum>i\\<le>length cs'.\n                                 length\n                                  (instrs_of P\\<^bsub>wf\\<^esub>\n                                    (fst (((C, M, pc) # cs') ! i))\n                                    (fst (snd (((C, M, pc) # cs') ! i)))))\n 2. finite\n     {(l, pc').\n      l < Suc (length cs') \\<and>\n      pc'\n      < (\\<Sum>i\\<le>length cs'.\n            length\n             (instrs_of P\\<^bsub>wf\\<^esub> (fst (((C, M, pc) # cs') ! i))\n               (fst (snd (((C, M, pc) # cs') ! i)))))} \\<Longrightarrow>\n    finite\n     {(l, pc').\n      l < Suc (length cs') \\<and>\n      pc'\n      < (\\<Sum>i\\<le>length cs'.\n            length\n             (instrs_of P\\<^bsub>wf\\<^esub> (fst (((C, M, pc) # cs') ! i))\n               (fst (snd (((C, M, pc) # cs') ! i)))))}", "apply (rule less_le_trans)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>a < Suc (length cs');\n        b < length\n             (instrs_of P\\<^bsub>wf\\<^esub> (fst (((C, M, pc) # cs') ! a))\n               (fst (snd (((C, M, pc) # cs') ! a))))\\<rbrakk>\n       \\<Longrightarrow> b < ?y8 a b\n 2. \\<And>a b.\n       \\<lbrakk>a < Suc (length cs');\n        b < length\n             (instrs_of P\\<^bsub>wf\\<^esub> (fst (((C, M, pc) # cs') ! a))\n               (fst (snd (((C, M, pc) # cs') ! a))))\\<rbrakk>\n       \\<Longrightarrow> ?y8 a b\n                         \\<le> (\\<Sum>i\\<le>length cs'.\n                                   length\n                                    (instrs_of P\\<^bsub>wf\\<^esub>\n(fst (((C, M, pc) # cs') ! i)) (fst (snd (((C, M, pc) # cs') ! i)))))\n 3. finite\n     {(l, pc').\n      l < Suc (length cs') \\<and>\n      pc'\n      < (\\<Sum>i\\<le>length cs'.\n            length\n             (instrs_of P\\<^bsub>wf\\<^esub> (fst (((C, M, pc) # cs') ! i))\n               (fst (snd (((C, M, pc) # cs') ! i)))))} \\<Longrightarrow>\n    finite\n     {(l, pc').\n      l < Suc (length cs') \\<and>\n      pc'\n      < (\\<Sum>i\\<le>length cs'.\n            length\n             (instrs_of P\\<^bsub>wf\\<^esub> (fst (((C, M, pc) # cs') ! i))\n               (fst (snd (((C, M, pc) # cs') ! i)))))}", "defer"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>a < Suc (length cs');\n        b < length\n             (instrs_of P\\<^bsub>wf\\<^esub> (fst (((C, M, pc) # cs') ! a))\n               (fst (snd (((C, M, pc) # cs') ! a))))\\<rbrakk>\n       \\<Longrightarrow> ?y8 a b\n                         \\<le> (\\<Sum>i\\<le>length cs'.\n                                   length\n                                    (instrs_of P\\<^bsub>wf\\<^esub>\n(fst (((C, M, pc) # cs') ! i)) (fst (snd (((C, M, pc) # cs') ! i)))))\n 2. finite\n     {(l, pc').\n      l < Suc (length cs') \\<and>\n      pc'\n      < (\\<Sum>i\\<le>length cs'.\n            length\n             (instrs_of P\\<^bsub>wf\\<^esub> (fst (((C, M, pc) # cs') ! i))\n               (fst (snd (((C, M, pc) # cs') ! i)))))} \\<Longrightarrow>\n    finite\n     {(l, pc').\n      l < Suc (length cs') \\<and>\n      pc'\n      < (\\<Sum>i\\<le>length cs'.\n            length\n             (instrs_of P\\<^bsub>wf\\<^esub> (fst (((C, M, pc) # cs') ! i))\n               (fst (snd (((C, M, pc) # cs') ! i)))))}\n 3. \\<And>a b.\n       \\<lbrakk>a < Suc (length cs');\n        b < length\n             (instrs_of P\\<^bsub>wf\\<^esub> (fst (((C, M, pc) # cs') ! a))\n               (fst (snd (((C, M, pc) # cs') ! a))))\\<rbrakk>\n       \\<Longrightarrow> b < ?y8 a b", "apply (rule_tac A=\"{a}\" in sum_mono2)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>a < Suc (length cs');\n        b < length\n             (instrs_of P\\<^bsub>wf\\<^esub> (fst (((C, M, pc) # cs') ! a))\n               (fst (snd (((C, M, pc) # cs') ! a))))\\<rbrakk>\n       \\<Longrightarrow> finite {..length cs'}\n 2. \\<And>a b.\n       \\<lbrakk>a < Suc (length cs');\n        b < length\n             (instrs_of P\\<^bsub>wf\\<^esub> (fst (((C, M, pc) # cs') ! a))\n               (fst (snd (((C, M, pc) # cs') ! a))))\\<rbrakk>\n       \\<Longrightarrow> {a} \\<subseteq> {..length cs'}\n 3. \\<And>a b ba.\n       \\<lbrakk>a < Suc (length cs');\n        b < length\n             (instrs_of P\\<^bsub>wf\\<^esub> (fst (((C, M, pc) # cs') ! a))\n               (fst (snd (((C, M, pc) # cs') ! a))));\n        ba \\<in> {..length cs'} - {a}\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> length\n                                  (instrs_of P\\<^bsub>wf\\<^esub>\n                                    (fst (((C, M, pc) # cs') ! ba))\n                                    (fst (snd (((C, M, pc) # cs') ! ba))))\n 4. finite\n     {(l, pc').\n      l < Suc (length cs') \\<and>\n      pc'\n      < (\\<Sum>i\\<le>length cs'.\n            length\n             (instrs_of P\\<^bsub>wf\\<^esub> (fst (((C, M, pc) # cs') ! i))\n               (fst (snd (((C, M, pc) # cs') ! i)))))} \\<Longrightarrow>\n    finite\n     {(l, pc').\n      l < Suc (length cs') \\<and>\n      pc'\n      < (\\<Sum>i\\<le>length cs'.\n            length\n             (instrs_of P\\<^bsub>wf\\<^esub> (fst (((C, M, pc) # cs') ! i))\n               (fst (snd (((C, M, pc) # cs') ! i)))))}\n 5. \\<And>a b.\n       \\<lbrakk>a < Suc (length cs');\n        b < length\n             (instrs_of P\\<^bsub>wf\\<^esub> (fst (((C, M, pc) # cs') ! a))\n               (fst (snd (((C, M, pc) # cs') ! a))))\\<rbrakk>\n       \\<Longrightarrow> b < (\\<Sum>i\\<in>{a}.\n                                length\n                                 (instrs_of P\\<^bsub>wf\\<^esub>\n                                   (fst (((C, M, pc) # cs') ! i))\n                                   (fst (snd (((C, M, pc) # cs') ! i)))))", "by simp_all"], ["proof (state)\nthis:\n  finite\n   {(l, pc').\n    l < length ((C, M, pc) # cs') \\<and>\n    pc'\n    < length\n       (instrs_of P\\<^bsub>wf\\<^esub> (fst (((C, M, pc) # cs') ! l))\n         (fst (snd (((C, M, pc) # cs') ! l))))}\n\ngoal (1 subgoal):\n 1. instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw \\<Longrightarrow>\n    finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}", "from valid_node Throw"], ["proof (chain)\npicking this:\n  JVM_CFG_Interpret.valid_node prog n\n  instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw", "show ?thesis"], ["proof (prove)\nusing this:\n  JVM_CFG_Interpret.valid_node prog n\n  instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw\n\ngoal (1 subgoal):\n 1. finite\n     {n'.\n      \\<exists>a'.\n         valid_edge prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {n'.\n                        (\\<exists>a.\n                            (P, C0,\n                             Main) \\<turnstile> (_ (C, M, pc) #\n             cs',x _) -a\\<rightarrow> n') \\<and>\n                        valid_node (P, C0, Main)\n                         (_ (C, M, pc) # cs',x _) \\<and>\n                        valid_node (P, C0, Main) n'}", "apply (rule_tac B=\"\n            {n'. \\<exists>Cx Mx pc' h cs'' pcx. (C,M,pc)#cs' = cs''@[(Cx,Mx,pcx)]@h \\<and>\n              pc' < length (instrs_of (P\\<^bsub>wf\\<^esub>) Cx Mx) \\<and>\n              n' = (_ (C,M,pc)#cs',\\<lfloor>((Cx,Mx,pc')#h,True)\\<rfloor> _)}\n            \\<union> {(_ fst(the(x)),None _), (_Exit_), (_ (C,M,pc)#cs',\\<lfloor>([],True)\\<rfloor> _)}\"\n            in finite_subset)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw\\<rbrakk>\n    \\<Longrightarrow> {n'.\n                       (\\<exists>a.\n                           (P, C0,\n                            Main) \\<turnstile> (_ (C, M, pc) #\n            cs',x _) -a\\<rightarrow> n') \\<and>\n                       valid_node (P, C0, Main)\n                        (_ (C, M, pc) # cs',x _) \\<and>\n                       valid_node (P, C0, Main) n'}\n                      \\<subseteq> {n'.\n                                   \\<exists>Cx Mx pc' h cs'' pcx.\n(C, M, pc) # cs' = cs'' @ [(Cx, Mx, pcx)] @ h \\<and>\npc' < length (instrs_of P\\<^bsub>wf\\<^esub> Cx Mx) \\<and>\nn' =\n(_ (C, M, pc) # cs',\\<lfloor>((Cx, Mx, pc') # h, True)\\<rfloor> _)} \\<union>\n                                  {(_ fst (the x),None _), (_Exit_),\n                                   (_ (C, M, pc) #\ncs',\\<lfloor>([], True)\\<rfloor> _)}\n 2. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw\\<rbrakk>\n    \\<Longrightarrow> finite\n                       ({n'.\n                         \\<exists>Cx Mx pc' h cs'' pcx.\n                            (C, M, pc) # cs' =\n                            cs'' @ [(Cx, Mx, pcx)] @ h \\<and>\n                            pc'\n                            < length\n                               (instrs_of P\\<^bsub>wf\\<^esub> Cx Mx) \\<and>\n                            n' =\n                            (_ (C, M, pc) #\n                               cs',\\<lfloor>((Cx, Mx, pc') # h,\n       True)\\<rfloor> _)} \\<union>\n                        {(_ fst (the x),None _), (_Exit_),\n                         (_ (C, M, pc) #\n                            cs',\\<lfloor>([], True)\\<rfloor> _)})", "apply (rule subsetI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n                 (_ (C, M, pc) # cs',x _);\n        instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw;\n        xa \\<in> {n'.\n                  (\\<exists>a.\n                      (P, C0,\n                       Main) \\<turnstile> (_ (C, M, pc) #\n       cs',x _) -a\\<rightarrow> n') \\<and>\n                  valid_node (P, C0, Main) (_ (C, M, pc) # cs',x _) \\<and>\n                  valid_node (P, C0, Main) n'}\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> {n'.\n                                   \\<exists>Cx Mx pc' h cs'' pcx.\n(C, M, pc) # cs' = cs'' @ [(Cx, Mx, pcx)] @ h \\<and>\npc' < length (instrs_of P\\<^bsub>wf\\<^esub> Cx Mx) \\<and>\nn' =\n(_ (C, M, pc) # cs',\\<lfloor>((Cx, Mx, pc') # h, True)\\<rfloor> _)} \\<union>\n                                  {(_ fst (the x),None _), (_Exit_),\n                                   (_ (C, M, pc) #\ncs',\\<lfloor>([], True)\\<rfloor> _)}\n 2. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw\\<rbrakk>\n    \\<Longrightarrow> finite\n                       ({n'.\n                         \\<exists>Cx Mx pc' h cs'' pcx.\n                            (C, M, pc) # cs' =\n                            cs'' @ [(Cx, Mx, pcx)] @ h \\<and>\n                            pc'\n                            < length\n                               (instrs_of P\\<^bsub>wf\\<^esub> Cx Mx) \\<and>\n                            n' =\n                            (_ (C, M, pc) #\n                               cs',\\<lfloor>((Cx, Mx, pc') # h,\n       True)\\<rfloor> _)} \\<union>\n                        {(_ fst (the x),None _), (_Exit_),\n                         (_ (C, M, pc) #\n                            cs',\\<lfloor>([], True)\\<rfloor> _)})", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa a.\n       \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n                 (_ (C, M, pc) # cs',x _);\n        instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw;\n        (P, C0,\n         Main) \\<turnstile> (_ (C, M, pc) # cs',x _) -a\\<rightarrow> xa;\n        valid_node (P, C0, Main) (_ (C, M, pc) # cs',x _);\n        valid_node (P, C0, Main) xa; xa \\<noteq> (_ fst (the x),None _);\n        xa \\<noteq> (_Exit_);\n        \\<forall>Cx Mx pc'.\n           pc'\n           < length (instrs_of P\\<^bsub>wf\\<^esub> Cx Mx) \\<longrightarrow>\n           (\\<forall>h.\n               (\\<forall>cs'' pcx.\n                   (C, M, pc) # cs' \\<noteq> cs'' @ (Cx, Mx, pcx) # h) \\<or>\n               xa \\<noteq>\n               (_ (C, M, pc) #\n                  cs',\\<lfloor>((Cx, Mx, pc') # h,\n                                True)\\<rfloor> _))\\<rbrakk>\n       \\<Longrightarrow> xa =\n                         (_ (C, M, pc) # cs',\\<lfloor>([], True)\\<rfloor> _)\n 2. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw\\<rbrakk>\n    \\<Longrightarrow> finite\n                       ({n'.\n                         \\<exists>Cx Mx pc' h cs'' pcx.\n                            (C, M, pc) # cs' =\n                            cs'' @ [(Cx, Mx, pcx)] @ h \\<and>\n                            pc'\n                            < length\n                               (instrs_of P\\<^bsub>wf\\<^esub> Cx Mx) \\<and>\n                            n' =\n                            (_ (C, M, pc) #\n                               cs',\\<lfloor>((Cx, Mx, pc') # h,\n       True)\\<rfloor> _)} \\<union>\n                        {(_ fst (the x),None _), (_Exit_),\n                         (_ (C, M, pc) #\n                            cs',\\<lfloor>([], True)\\<rfloor> _)})", "apply (erule JVM_CFG.cases, simp_all del: find_handler_for.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa a prog Pa cd stk_length cs'a ek.\n       \\<lbrakk>JVM_CFG_Interpret.valid_node (Pa, C0, Main)\n                 (_ (C, M, pc) # cs',None _);\n        valid_callstack (Pa, C0, Main) ((C, M, pc) # cs');\n        valid_callstack (Pa, C0, Main) cs'a \\<and>\n        (\\<exists>Q.\n            (Pa, C0,\n             Main) \\<turnstile> (_ (C, M, pc) #\n                                   cs',None _) -(Q)\\<^sub>\\<surd>\\<rightarrow> (_ (C,\n       M, pc) #\n      cs',\\<lfloor>(cs'a, True)\\<rfloor> _)) \\<and>\n        (\\<exists>f.\n            (Pa, C0,\n             Main) \\<turnstile> (_ (C, M, pc) #\n                                   cs',\\<lfloor>(cs'a,\n           True)\\<rfloor> _) -\\<Up>f\\<rightarrow> (_ cs'a,None _));\n        \\<forall>Cx Mx pc'.\n           pc'\n           < length (instrs_of Pa\\<^bsub>wf\\<^esub> Cx Mx) \\<longrightarrow>\n           (\\<forall>h.\n               (\\<forall>cs'' pcx.\n                   (C, M, pc) # cs' \\<noteq> cs'' @ (Cx, Mx, pcx) # h) \\<or>\n               cs'a \\<noteq> (Cx, Mx, pc') # h);\n        P = Pa; x = None;\n        a =\n        (\\<lambda>(h, stk, loc).\n            stk (length cs', stkLength Pa C M pc - Suc 0) = Null \\<and>\n            find_handler_for Pa NullPointer ((C, M, pc) # cs') = cs'a \\<or>\n            stk (length cs', stkLength Pa C M pc - Suc 0) \\<noteq>\n            Null \\<and>\n            find_handler_for Pa\n             (cname_of h\n               (the_Addr (stk (length cs', stkLength Pa C M pc - Suc 0))))\n             ((C, M, pc) # cs') =\n            cs'a)\\<^sub>\\<surd>;\n        xa = (_ (C, M, pc) # cs',\\<lfloor>(cs'a, True)\\<rfloor> _);\n        prog = (Pa, C0, Main);\n        instrs_of Pa\\<^bsub>wf\\<^esub> C M ! pc = Throw; cd = length cs';\n        stk_length = stkLength Pa C M pc;\n        \\<exists>Exc. find_handler_for Pa Exc ((C, M, pc) # cs') = cs'a;\n        ek =\n        (\\<lambda>(h, stk, loc).\n            stk (length cs', stkLength Pa C M pc - Suc 0) = Null \\<and>\n            find_handler_for Pa NullPointer ((C, M, pc) # cs') = cs'a \\<or>\n            stk (length cs', stkLength Pa C M pc - Suc 0) \\<noteq>\n            Null \\<and>\n            find_handler_for Pa\n             (cname_of h\n               (the_Addr (stk (length cs', stkLength Pa C M pc - Suc 0))))\n             ((C, M, pc) # cs') =\n            cs'a)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> cs'a = []\n 2. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {n'.\n                        \\<exists>Cx Mx pc' h.\n                           (\\<exists>cs'' pcx.\n                               (C, M, pc) # cs' =\n                               cs'' @ (Cx, Mx, pcx) # h) \\<and>\n                           pc'\n                           < length\n                              (instrs_of P\\<^bsub>wf\\<^esub> Cx Mx) \\<and>\n                           n' =\n                           (_ (C, M, pc) #\n                              cs',\\<lfloor>((Cx, Mx, pc') # h,\n      True)\\<rfloor> _)}", "apply (clarsimp simp del: find_handler_for.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Exc Q f.\n       \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n                 (_ (C, M, pc) # cs',None _);\n        valid_callstack (P, C0, Main) ((C, M, pc) # cs');\n        \\<forall>Cx Mx pc'.\n           pc'\n           < length (instrs_of P\\<^bsub>wf\\<^esub> Cx Mx) \\<longrightarrow>\n           (\\<forall>h.\n               (\\<forall>cs'' pcx.\n                   (C, M, pc) # cs' \\<noteq> cs'' @ (Cx, Mx, pcx) # h) \\<or>\n               find_handler_for P Exc ((C, M, pc) # cs') \\<noteq>\n               (Cx, Mx, pc') # h);\n        x = None; instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw;\n        valid_callstack (P, C0, Main)\n         (find_handler_for P Exc ((C, M, pc) # cs'));\n        (P, C0,\n         Main) \\<turnstile> (_ (C, M, pc) #\n                               cs',None _) -(Q)\\<^sub>\\<surd>\\<rightarrow> (_ (C,\n   M, pc) #\n  cs',\\<lfloor>(find_handler_for P Exc ((C, M, pc) # cs'),\n                True)\\<rfloor> _);\n        (P, C0,\n         Main) \\<turnstile> (_ (C, M, pc) #\n                               cs',\\<lfloor>(find_handler_for P Exc\n        ((C, M, pc) # cs'),\n       True)\\<rfloor> _) -\\<Up>f\\<rightarrow> (_ find_handler_for P Exc\n            ((C, M, pc) # cs'),None _)\\<rbrakk>\n       \\<Longrightarrow> find_handler_for P Exc ((C, M, pc) # cs') = []\n 2. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {n'.\n                        \\<exists>Cx Mx pc' h.\n                           (\\<exists>cs'' pcx.\n                               (C, M, pc) # cs' =\n                               cs'' @ (Cx, Mx, pcx) # h) \\<and>\n                           pc'\n                           < length\n                              (instrs_of P\\<^bsub>wf\\<^esub> Cx Mx) \\<and>\n                           n' =\n                           (_ (C, M, pc) #\n                              cs',\\<lfloor>((Cx, Mx, pc') # h,\n      True)\\<rfloor> _)}", "apply (case_tac \"find_handler_for P Exc ((C,M,pc)#cs')\", simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Exc Q f a list.\n       \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n                 (_ (C, M, pc) # cs',None _);\n        valid_callstack (P, C0, Main) ((C, M, pc) # cs');\n        \\<forall>Cx Mx pc'.\n           pc'\n           < length (instrs_of P\\<^bsub>wf\\<^esub> Cx Mx) \\<longrightarrow>\n           (\\<forall>h.\n               (\\<forall>cs'' pcx.\n                   (C, M, pc) # cs' \\<noteq> cs'' @ (Cx, Mx, pcx) # h) \\<or>\n               find_handler_for P Exc ((C, M, pc) # cs') \\<noteq>\n               (Cx, Mx, pc') # h);\n        x = None; instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw;\n        valid_callstack (P, C0, Main)\n         (find_handler_for P Exc ((C, M, pc) # cs'));\n        (P, C0,\n         Main) \\<turnstile> (_ (C, M, pc) #\n                               cs',None _) -(Q)\\<^sub>\\<surd>\\<rightarrow> (_ (C,\n   M, pc) #\n  cs',\\<lfloor>(find_handler_for P Exc ((C, M, pc) # cs'),\n                True)\\<rfloor> _);\n        (P, C0,\n         Main) \\<turnstile> (_ (C, M, pc) #\n                               cs',\\<lfloor>(find_handler_for P Exc\n        ((C, M, pc) # cs'),\n       True)\\<rfloor> _) -\\<Up>f\\<rightarrow> (_ find_handler_for P Exc\n            ((C, M, pc) # cs'),None _);\n        find_handler_for P Exc ((C, M, pc) # cs') = a # list\\<rbrakk>\n       \\<Longrightarrow> find_handler_for P Exc ((C, M, pc) # cs') = []\n 2. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {n'.\n                        \\<exists>Cx Mx pc' h.\n                           (\\<exists>cs'' pcx.\n                               (C, M, pc) # cs' =\n                               cs'' @ (Cx, Mx, pcx) # h) \\<and>\n                           pc'\n                           < length\n                              (instrs_of P\\<^bsub>wf\\<^esub> Cx Mx) \\<and>\n                           n' =\n                           (_ (C, M, pc) #\n                              cs',\\<lfloor>((Cx, Mx, pc') # h,\n      True)\\<rfloor> _)}", "apply (clarsimp simp del: find_handler_for.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Exc Q f a aa b list.\n       \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n                 (_ (C, M, pc) # cs',None _);\n        valid_callstack (P, C0, Main) ((C, M, pc) # cs');\n        b < length (instrs_of P\\<^bsub>wf\\<^esub> a aa) \\<longrightarrow>\n        (\\<forall>h.\n            (\\<forall>cs'' pcx.\n                (C, M, pc) # cs' \\<noteq> cs'' @ (a, aa, pcx) # h) \\<or>\n            list \\<noteq> h);\n        x = None; instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw;\n        valid_callstack (P, C0, Main) ((a, aa, b) # list);\n        (P, C0,\n         Main) \\<turnstile> (_ (C, M, pc) #\n                               cs',None _) -(Q)\\<^sub>\\<surd>\\<rightarrow> (_ (C,\n   M, pc) #\n  cs',\\<lfloor>((a, aa, b) # list, True)\\<rfloor> _);\n        (P, C0,\n         Main) \\<turnstile> (_ (C, M, pc) #\n                               cs',\\<lfloor>((a, aa, b) # list,\n       True)\\<rfloor> _) -\\<Up>f\\<rightarrow> (_ (a, aa, b) # list,None _);\n        find_handler_for P Exc ((C, M, pc) # cs') =\n        (a, aa, b) # list\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {n'.\n                        \\<exists>Cx Mx pc' h.\n                           (\\<exists>cs'' pcx.\n                               (C, M, pc) # cs' =\n                               cs'' @ (Cx, Mx, pcx) # h) \\<and>\n                           pc'\n                           < length\n                              (instrs_of P\\<^bsub>wf\\<^esub> Cx Mx) \\<and>\n                           n' =\n                           (_ (C, M, pc) #\n                              cs',\\<lfloor>((Cx, Mx, pc') # h,\n      True)\\<rfloor> _)}", "apply (erule impE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Exc Q f a aa b list.\n       \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n                 (_ (C, M, pc) # cs',None _);\n        valid_callstack (P, C0, Main) ((C, M, pc) # cs'); x = None;\n        instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw;\n        valid_callstack (P, C0, Main) ((a, aa, b) # list);\n        (P, C0,\n         Main) \\<turnstile> (_ (C, M, pc) #\n                               cs',None _) -(Q)\\<^sub>\\<surd>\\<rightarrow> (_ (C,\n   M, pc) #\n  cs',\\<lfloor>((a, aa, b) # list, True)\\<rfloor> _);\n        (P, C0,\n         Main) \\<turnstile> (_ (C, M, pc) #\n                               cs',\\<lfloor>((a, aa, b) # list,\n       True)\\<rfloor> _) -\\<Up>f\\<rightarrow> (_ (a, aa, b) # list,None _);\n        find_handler_for P Exc ((C, M, pc) # cs') =\n        (a, aa, b) # list\\<rbrakk>\n       \\<Longrightarrow> b < length (instrs_of P\\<^bsub>wf\\<^esub> a aa)\n 2. \\<And>Exc Q f a aa b list.\n       \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n                 (_ (C, M, pc) # cs',None _);\n        valid_callstack (P, C0, Main) ((C, M, pc) # cs'); x = None;\n        instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw;\n        valid_callstack (P, C0, Main) ((a, aa, b) # list);\n        (P, C0,\n         Main) \\<turnstile> (_ (C, M, pc) #\n                               cs',None _) -(Q)\\<^sub>\\<surd>\\<rightarrow> (_ (C,\n   M, pc) #\n  cs',\\<lfloor>((a, aa, b) # list, True)\\<rfloor> _);\n        (P, C0,\n         Main) \\<turnstile> (_ (C, M, pc) #\n                               cs',\\<lfloor>((a, aa, b) # list,\n       True)\\<rfloor> _) -\\<Up>f\\<rightarrow> (_ (a, aa, b) # list,None _);\n        find_handler_for P Exc ((C, M, pc) # cs') = (a, aa, b) # list;\n        \\<forall>h.\n           (\\<forall>cs'' pcx.\n               (C, M, pc) # cs' \\<noteq> cs'' @ (a, aa, pcx) # h) \\<or>\n           list \\<noteq> h\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {n'.\n                        \\<exists>Cx Mx pc' h.\n                           (\\<exists>cs'' pcx.\n                               (C, M, pc) # cs' =\n                               cs'' @ (Cx, Mx, pcx) # h) \\<and>\n                           pc'\n                           < length\n                              (instrs_of P\\<^bsub>wf\\<^esub> Cx Mx) \\<and>\n                           n' =\n                           (_ (C, M, pc) #\n                              cs',\\<lfloor>((Cx, Mx, pc') # h,\n      True)\\<rfloor> _)}", "apply (case_tac \"list\", fastforce, fastforce)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Exc Q f a aa b list.\n       \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n                 (_ (C, M, pc) # cs',None _);\n        valid_callstack (P, C0, Main) ((C, M, pc) # cs'); x = None;\n        instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw;\n        valid_callstack (P, C0, Main) ((a, aa, b) # list);\n        (P, C0,\n         Main) \\<turnstile> (_ (C, M, pc) #\n                               cs',None _) -(Q)\\<^sub>\\<surd>\\<rightarrow> (_ (C,\n   M, pc) #\n  cs',\\<lfloor>((a, aa, b) # list, True)\\<rfloor> _);\n        (P, C0,\n         Main) \\<turnstile> (_ (C, M, pc) #\n                               cs',\\<lfloor>((a, aa, b) # list,\n       True)\\<rfloor> _) -\\<Up>f\\<rightarrow> (_ (a, aa, b) # list,None _);\n        find_handler_for P Exc ((C, M, pc) # cs') = (a, aa, b) # list;\n        \\<forall>h.\n           (\\<forall>cs'' pcx.\n               (C, M, pc) # cs' \\<noteq> cs'' @ (a, aa, pcx) # h) \\<or>\n           list \\<noteq> h\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {n'.\n                        \\<exists>Cx Mx pc' h.\n                           (\\<exists>cs'' pcx.\n                               (C, M, pc) # cs' =\n                               cs'' @ (Cx, Mx, pcx) # h) \\<and>\n                           pc'\n                           < length\n                              (instrs_of P\\<^bsub>wf\\<^esub> Cx Mx) \\<and>\n                           n' =\n                           (_ (C, M, pc) #\n                              cs',\\<lfloor>((Cx, Mx, pc') # h,\n      True)\\<rfloor> _)}", "apply (frule find_handler_for_tl_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Exc Q f a aa b list.\n       \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n                 (_ (C, M, pc) # cs',None _);\n        valid_callstack (P, C0, Main) ((C, M, pc) # cs'); x = None;\n        instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw;\n        valid_callstack (P, C0, Main) ((a, aa, b) # list);\n        (P, C0,\n         Main) \\<turnstile> (_ (C, M, pc) #\n                               cs',None _) -(Q)\\<^sub>\\<surd>\\<rightarrow> (_ (C,\n   M, pc) #\n  cs',\\<lfloor>((a, aa, b) # list, True)\\<rfloor> _);\n        (P, C0,\n         Main) \\<turnstile> (_ (C, M, pc) #\n                               cs',\\<lfloor>((a, aa, b) # list,\n       True)\\<rfloor> _) -\\<Up>f\\<rightarrow> (_ (a, aa, b) # list,None _);\n        find_handler_for P Exc ((C, M, pc) # cs') = (a, aa, b) # list;\n        \\<forall>h.\n           (\\<forall>cs'' pcx.\n               (C, M, pc) # cs' \\<noteq> cs'' @ (a, aa, pcx) # h) \\<or>\n           list \\<noteq> h;\n        \\<exists>cs'' pca.\n           (C, M, pc) # cs' = cs'' @ [(a, aa, pca)] @ list\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {n'.\n                        \\<exists>Cx Mx pc' h.\n                           (\\<exists>cs'' pcx.\n                               (C, M, pc) # cs' =\n                               cs'' @ (Cx, Mx, pcx) # h) \\<and>\n                           pc'\n                           < length\n                              (instrs_of P\\<^bsub>wf\\<^esub> Cx Mx) \\<and>\n                           n' =\n                           (_ (C, M, pc) #\n                              cs',\\<lfloor>((Cx, Mx, pc') # h,\n      True)\\<rfloor> _)}", "apply (clarsimp simp del: find_handler_for.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Exc Q f a aa b list cs'' pca.\n       \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n                 (_ cs'' @ (a, aa, pca) # list,None _);\n        valid_callstack (P, C0, Main) (cs'' @ (a, aa, pca) # list);\n        x = None; instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw;\n        valid_callstack (P, C0, Main) ((a, aa, b) # list);\n        (P, C0,\n         Main) \\<turnstile> (_ cs'' @\n                               (a, aa, pca) #\n                               list,None _) -(Q)\\<^sub>\\<surd>\\<rightarrow> (_ cs'' @\n   (a, aa, pca) # list,\\<lfloor>((a, aa, b) # list, True)\\<rfloor> _);\n        (P, C0,\n         Main) \\<turnstile> (_ cs'' @\n                               (a, aa, pca) #\n                               list,\\<lfloor>((a, aa, b) # list,\n        True)\\<rfloor> _) -\\<Up>f\\<rightarrow> (_ (a, aa, b) # list,None _);\n        find_handler_for P Exc (cs'' @ (a, aa, pca) # list) =\n        (a, aa, b) # list;\n        \\<forall>h.\n           (\\<forall>cs''a pcx.\n               cs'' @ (a, aa, pca) # list \\<noteq>\n               cs''a @ (a, aa, pcx) # h) \\<or>\n           list \\<noteq> h;\n        (C, M, pc) # cs' = cs'' @ (a, aa, pca) # list\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {n'.\n                        \\<exists>Cx Mx pc' h.\n                           (\\<exists>cs'' pcx.\n                               (C, M, pc) # cs' =\n                               cs'' @ (Cx, Mx, pcx) # h) \\<and>\n                           pc'\n                           < length\n                              (instrs_of P\\<^bsub>wf\\<^esub> Cx Mx) \\<and>\n                           n' =\n                           (_ (C, M, pc) #\n                              cs',\\<lfloor>((Cx, Mx, pc') # h,\n      True)\\<rfloor> _)}", "apply (erule_tac x=\"list\" in allE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Exc Q f a aa b list cs'' pca.\n       \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n                 (_ cs'' @ (a, aa, pca) # list,None _);\n        valid_callstack (P, C0, Main) (cs'' @ (a, aa, pca) # list);\n        x = None; instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw;\n        valid_callstack (P, C0, Main) ((a, aa, b) # list);\n        (P, C0,\n         Main) \\<turnstile> (_ cs'' @\n                               (a, aa, pca) #\n                               list,None _) -(Q)\\<^sub>\\<surd>\\<rightarrow> (_ cs'' @\n   (a, aa, pca) # list,\\<lfloor>((a, aa, b) # list, True)\\<rfloor> _);\n        (P, C0,\n         Main) \\<turnstile> (_ cs'' @\n                               (a, aa, pca) #\n                               list,\\<lfloor>((a, aa, b) # list,\n        True)\\<rfloor> _) -\\<Up>f\\<rightarrow> (_ (a, aa, b) # list,None _);\n        find_handler_for P Exc (cs'' @ (a, aa, pca) # list) =\n        (a, aa, b) # list;\n        (C, M, pc) # cs' = cs'' @ (a, aa, pca) # list;\n        (\\<forall>cs''a pcx.\n            cs'' @ (a, aa, pca) # list \\<noteq>\n            cs''a @ (a, aa, pcx) # list) \\<or>\n        list \\<noteq> list\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {n'.\n                        \\<exists>Cx Mx pc' h.\n                           (\\<exists>cs'' pcx.\n                               (C, M, pc) # cs' =\n                               cs'' @ (Cx, Mx, pcx) # h) \\<and>\n                           pc'\n                           < length\n                              (instrs_of P\\<^bsub>wf\\<^esub> Cx Mx) \\<and>\n                           n' =\n                           (_ (C, M, pc) #\n                              cs',\\<lfloor>((Cx, Mx, pc') # h,\n      True)\\<rfloor> _)}", "apply (clarsimp simp del: find_handler_for.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {n'.\n                        \\<exists>Cx Mx pc' h.\n                           (\\<exists>cs'' pcx.\n                               (C, M, pc) # cs' =\n                               cs'' @ (Cx, Mx, pcx) # h) \\<and>\n                           pc'\n                           < length\n                              (instrs_of P\\<^bsub>wf\\<^esub> Cx Mx) \\<and>\n                           n' =\n                           (_ (C, M, pc) #\n                              cs',\\<lfloor>((Cx, Mx, pc') # h,\n      True)\\<rfloor> _)}", "apply (subgoal_tac \n            \"finite (\n              (\\<lambda>(Cx,Mx,pc',h,cs'',pcx).  (_ (C, M, pc) # cs',\\<lfloor>((Cx, Mx, pc') # h, True)\\<rfloor> _)) `\n              {(Cx,Mx,pc',h,cs'',pcx). (C, M, pc) # cs' = cs'' @ (Cx, Mx, pcx) # h \\<and>\n                pc' < length (instrs_of P\\<^bsub>wf\\<^esub> Cx Mx)})\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw;\n     finite\n      ((\\<lambda>(Cx, Mx, pc', h, cs'', pcx).\n           (_ (C, M, pc) #\n              cs',\\<lfloor>((Cx, Mx, pc') # h, True)\\<rfloor> _)) `\n       {(Cx, Mx, pc', h, cs'', pcx).\n        (C, M, pc) # cs' = cs'' @ (Cx, Mx, pcx) # h \\<and>\n        pc' < length (instrs_of P\\<^bsub>wf\\<^esub> Cx Mx)})\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {n'.\n                        \\<exists>Cx Mx pc' h.\n                           (\\<exists>cs'' pcx.\n                               (C, M, pc) # cs' =\n                               cs'' @ (Cx, Mx, pcx) # h) \\<and>\n                           pc'\n                           < length\n                              (instrs_of P\\<^bsub>wf\\<^esub> Cx Mx) \\<and>\n                           n' =\n                           (_ (C, M, pc) #\n                              cs',\\<lfloor>((Cx, Mx, pc') # h,\n      True)\\<rfloor> _)}\n 2. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw\\<rbrakk>\n    \\<Longrightarrow> finite\n                       ((\\<lambda>(Cx, Mx, pc', h, cs'', pcx).\n                            (_ (C, M, pc) #\n                               cs',\\<lfloor>((Cx, Mx, pc') # h,\n       True)\\<rfloor> _)) `\n                        {(Cx, Mx, pc', h, cs'', pcx).\n                         (C, M, pc) # cs' = cs'' @ (Cx, Mx, pcx) # h \\<and>\n                         pc'\n                         < length (instrs_of P\\<^bsub>wf\\<^esub> Cx Mx)})", "apply (case_tac \"((\\<lambda>(Cx, Mx, pc', h, cs'', pcx).\n             (_ (C, M, pc) # cs',\\<lfloor>((Cx, Mx, pc') # h, True)\\<rfloor> _)) `\n             {(Cx, Mx, pc', h, cs'', pcx).\n               (C, M, pc) # cs' = cs'' @ (Cx, Mx, pcx) # h \\<and>\n               pc' < length (instrs_of (P\\<^bsub>wf\\<^esub>) Cx Mx)}) =\n             {n'. \\<exists>Cx Mx pc' h.\n                (\\<exists>cs'' pcx. (C, M, pc) # cs' = cs'' @ (Cx, Mx, pcx) # h) \\<and>\n                pc' < length (instrs_of (P\\<^bsub>wf\\<^esub>) Cx Mx) \\<and>\n                n' = (_ (C, M, pc) # cs',\\<lfloor>((Cx, Mx, pc') # h, True)\\<rfloor> _)}\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw;\n     finite\n      ((\\<lambda>(Cx, Mx, pc', h, cs'', pcx).\n           (_ (C, M, pc) #\n              cs',\\<lfloor>((Cx, Mx, pc') # h, True)\\<rfloor> _)) `\n       {(Cx, Mx, pc', h, cs'', pcx).\n        (C, M, pc) # cs' = cs'' @ (Cx, Mx, pcx) # h \\<and>\n        pc' < length (instrs_of P\\<^bsub>wf\\<^esub> Cx Mx)});\n     (\\<lambda>(Cx, Mx, pc', h, cs'', pcx).\n         (_ (C, M, pc) #\n            cs',\\<lfloor>((Cx, Mx, pc') # h, True)\\<rfloor> _)) `\n     {(Cx, Mx, pc', h, cs'', pcx).\n      (C, M, pc) # cs' = cs'' @ (Cx, Mx, pcx) # h \\<and>\n      pc' < length (instrs_of P\\<^bsub>wf\\<^esub> Cx Mx)} =\n     {n'.\n      \\<exists>Cx Mx pc' h.\n         (\\<exists>cs'' pcx.\n             (C, M, pc) # cs' = cs'' @ (Cx, Mx, pcx) # h) \\<and>\n         pc' < length (instrs_of P\\<^bsub>wf\\<^esub> Cx Mx) \\<and>\n         n' =\n         (_ (C, M, pc) #\n            cs',\\<lfloor>((Cx, Mx, pc') # h, True)\\<rfloor> _)}\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {n'.\n                        \\<exists>Cx Mx pc' h.\n                           (\\<exists>cs'' pcx.\n                               (C, M, pc) # cs' =\n                               cs'' @ (Cx, Mx, pcx) # h) \\<and>\n                           pc'\n                           < length\n                              (instrs_of P\\<^bsub>wf\\<^esub> Cx Mx) \\<and>\n                           n' =\n                           (_ (C, M, pc) #\n                              cs',\\<lfloor>((Cx, Mx, pc') # h,\n      True)\\<rfloor> _)}\n 2. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw;\n     finite\n      ((\\<lambda>(Cx, Mx, pc', h, cs'', pcx).\n           (_ (C, M, pc) #\n              cs',\\<lfloor>((Cx, Mx, pc') # h, True)\\<rfloor> _)) `\n       {(Cx, Mx, pc', h, cs'', pcx).\n        (C, M, pc) # cs' = cs'' @ (Cx, Mx, pcx) # h \\<and>\n        pc' < length (instrs_of P\\<^bsub>wf\\<^esub> Cx Mx)});\n     (\\<lambda>(Cx, Mx, pc', h, cs'', pcx).\n         (_ (C, M, pc) #\n            cs',\\<lfloor>((Cx, Mx, pc') # h, True)\\<rfloor> _)) `\n     {(Cx, Mx, pc', h, cs'', pcx).\n      (C, M, pc) # cs' = cs'' @ (Cx, Mx, pcx) # h \\<and>\n      pc' < length (instrs_of P\\<^bsub>wf\\<^esub> Cx Mx)} \\<noteq>\n     {n'.\n      \\<exists>Cx Mx pc' h.\n         (\\<exists>cs'' pcx.\n             (C, M, pc) # cs' = cs'' @ (Cx, Mx, pcx) # h) \\<and>\n         pc' < length (instrs_of P\\<^bsub>wf\\<^esub> Cx Mx) \\<and>\n         n' =\n         (_ (C, M, pc) #\n            cs',\\<lfloor>((Cx, Mx, pc') # h, True)\\<rfloor> _)}\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {n'.\n                        \\<exists>Cx Mx pc' h.\n                           (\\<exists>cs'' pcx.\n                               (C, M, pc) # cs' =\n                               cs'' @ (Cx, Mx, pcx) # h) \\<and>\n                           pc'\n                           < length\n                              (instrs_of P\\<^bsub>wf\\<^esub> Cx Mx) \\<and>\n                           n' =\n                           (_ (C, M, pc) #\n                              cs',\\<lfloor>((Cx, Mx, pc') # h,\n      True)\\<rfloor> _)}\n 3. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw\\<rbrakk>\n    \\<Longrightarrow> finite\n                       ((\\<lambda>(Cx, Mx, pc', h, cs'', pcx).\n                            (_ (C, M, pc) #\n                               cs',\\<lfloor>((Cx, Mx, pc') # h,\n       True)\\<rfloor> _)) `\n                        {(Cx, Mx, pc', h, cs'', pcx).\n                         (C, M, pc) # cs' = cs'' @ (Cx, Mx, pcx) # h \\<and>\n                         pc'\n                         < length (instrs_of P\\<^bsub>wf\\<^esub> Cx Mx)})", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw;\n     finite\n      ((\\<lambda>(Cx, Mx, pc', h, cs'', pcx).\n           (_ (C, M, pc) #\n              cs',\\<lfloor>((Cx, Mx, pc') # h, True)\\<rfloor> _)) `\n       {(Cx, Mx, pc', h, cs'', pcx).\n        (C, M, pc) # cs' = cs'' @ (Cx, Mx, pcx) # h \\<and>\n        pc' < length (instrs_of P\\<^bsub>wf\\<^esub> Cx Mx)});\n     (\\<lambda>(Cx, Mx, pc', h, cs'', pcx).\n         (_ (C, M, pc) #\n            cs',\\<lfloor>((Cx, Mx, pc') # h, True)\\<rfloor> _)) `\n     {(Cx, Mx, pc', h, cs'', pcx).\n      (C, M, pc) # cs' = cs'' @ (Cx, Mx, pcx) # h \\<and>\n      pc' < length (instrs_of P\\<^bsub>wf\\<^esub> Cx Mx)} \\<noteq>\n     {n'.\n      \\<exists>Cx Mx pc' h.\n         (\\<exists>cs'' pcx.\n             (C, M, pc) # cs' = cs'' @ (Cx, Mx, pcx) # h) \\<and>\n         pc' < length (instrs_of P\\<^bsub>wf\\<^esub> Cx Mx) \\<and>\n         n' =\n         (_ (C, M, pc) #\n            cs',\\<lfloor>((Cx, Mx, pc') # h, True)\\<rfloor> _)}\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {n'.\n                        \\<exists>Cx Mx pc' h.\n                           (\\<exists>cs'' pcx.\n                               (C, M, pc) # cs' =\n                               cs'' @ (Cx, Mx, pcx) # h) \\<and>\n                           pc'\n                           < length\n                              (instrs_of P\\<^bsub>wf\\<^esub> Cx Mx) \\<and>\n                           n' =\n                           (_ (C, M, pc) #\n                              cs',\\<lfloor>((Cx, Mx, pc') # h,\n      True)\\<rfloor> _)}\n 2. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw\\<rbrakk>\n    \\<Longrightarrow> finite\n                       ((\\<lambda>(Cx, Mx, pc', h, cs'', pcx).\n                            (_ (C, M, pc) #\n                               cs',\\<lfloor>((Cx, Mx, pc') # h,\n       True)\\<rfloor> _)) `\n                        {(Cx, Mx, pc', h, cs'', pcx).\n                         (C, M, pc) # cs' = cs'' @ (Cx, Mx, pcx) # h \\<and>\n                         pc'\n                         < length (instrs_of P\\<^bsub>wf\\<^esub> Cx Mx)})", "apply (erule notE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw;\n     finite\n      ((\\<lambda>(Cx, Mx, pc', h, cs'', pcx).\n           (_ (C, M, pc) #\n              cs',\\<lfloor>((Cx, Mx, pc') # h, True)\\<rfloor> _)) `\n       {(Cx, Mx, pc', h, cs'', pcx).\n        (C, M, pc) # cs' = cs'' @ (Cx, Mx, pcx) # h \\<and>\n        pc' < length (instrs_of P\\<^bsub>wf\\<^esub> Cx Mx)})\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>(Cx, Mx, pc', h, cs'', pcx).\n                          (_ (C, M, pc) #\n                             cs',\\<lfloor>((Cx, Mx, pc') # h,\n     True)\\<rfloor> _)) `\n                      {(Cx, Mx, pc', h, cs'', pcx).\n                       (C, M, pc) # cs' = cs'' @ (Cx, Mx, pcx) # h \\<and>\n                       pc' < length (instrs_of P\\<^bsub>wf\\<^esub> Cx Mx)} =\n                      {n'.\n                       \\<exists>Cx Mx pc' h.\n                          (\\<exists>cs'' pcx.\n                              (C, M, pc) # cs' =\n                              cs'' @ (Cx, Mx, pcx) # h) \\<and>\n                          pc'\n                          < length\n                             (instrs_of P\\<^bsub>wf\\<^esub> Cx Mx) \\<and>\n                          n' =\n                          (_ (C, M, pc) #\n                             cs',\\<lfloor>((Cx, Mx, pc') # h,\n     True)\\<rfloor> _)}\n 2. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw\\<rbrakk>\n    \\<Longrightarrow> finite\n                       ((\\<lambda>(Cx, Mx, pc', h, cs'', pcx).\n                            (_ (C, M, pc) #\n                               cs',\\<lfloor>((Cx, Mx, pc') # h,\n       True)\\<rfloor> _)) `\n                        {(Cx, Mx, pc', h, cs'', pcx).\n                         (C, M, pc) # cs' = cs'' @ (Cx, Mx, pcx) # h \\<and>\n                         pc'\n                         < length (instrs_of P\\<^bsub>wf\\<^esub> Cx Mx)})", "apply (rule equalityI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw;\n     finite\n      ((\\<lambda>(Cx, Mx, pc', h, cs'', pcx).\n           (_ (C, M, pc) #\n              cs',\\<lfloor>((Cx, Mx, pc') # h, True)\\<rfloor> _)) `\n       {(Cx, Mx, pc', h, cs'', pcx).\n        (C, M, pc) # cs' = cs'' @ (Cx, Mx, pcx) # h \\<and>\n        pc' < length (instrs_of P\\<^bsub>wf\\<^esub> Cx Mx)})\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>(Cx, Mx, pc', h, cs'', pcx).\n                          (_ (C, M, pc) #\n                             cs',\\<lfloor>((Cx, Mx, pc') # h,\n     True)\\<rfloor> _)) `\n                      {(Cx, Mx, pc', h, cs'', pcx).\n                       (C, M, pc) # cs' = cs'' @ (Cx, Mx, pcx) # h \\<and>\n                       pc' < length (instrs_of P\\<^bsub>wf\\<^esub> Cx Mx)}\n                      \\<subseteq> {n'.\n                                   \\<exists>Cx Mx pc' h.\n(\\<exists>cs'' pcx. (C, M, pc) # cs' = cs'' @ (Cx, Mx, pcx) # h) \\<and>\npc' < length (instrs_of P\\<^bsub>wf\\<^esub> Cx Mx) \\<and>\nn' = (_ (C, M, pc) # cs',\\<lfloor>((Cx, Mx, pc') # h, True)\\<rfloor> _)}\n 2. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw;\n     finite\n      ((\\<lambda>(Cx, Mx, pc', h, cs'', pcx).\n           (_ (C, M, pc) #\n              cs',\\<lfloor>((Cx, Mx, pc') # h, True)\\<rfloor> _)) `\n       {(Cx, Mx, pc', h, cs'', pcx).\n        (C, M, pc) # cs' = cs'' @ (Cx, Mx, pcx) # h \\<and>\n        pc' < length (instrs_of P\\<^bsub>wf\\<^esub> Cx Mx)})\\<rbrakk>\n    \\<Longrightarrow> {n'.\n                       \\<exists>Cx Mx pc' h.\n                          (\\<exists>cs'' pcx.\n                              (C, M, pc) # cs' =\n                              cs'' @ (Cx, Mx, pcx) # h) \\<and>\n                          pc'\n                          < length\n                             (instrs_of P\\<^bsub>wf\\<^esub> Cx Mx) \\<and>\n                          n' =\n                          (_ (C, M, pc) #\n                             cs',\\<lfloor>((Cx, Mx, pc') # h,\n     True)\\<rfloor> _)}\n                      \\<subseteq> (\\<lambda>(Cx, Mx, pc', h, cs'', pcx).\n(_ (C, M, pc) # cs',\\<lfloor>((Cx, Mx, pc') # h, True)\\<rfloor> _)) `\n                                  {(Cx, Mx, pc', h, cs'', pcx).\n                                   (C, M, pc) # cs' =\n                                   cs'' @ (Cx, Mx, pcx) # h \\<and>\n                                   pc'\n                                   < length\n(instrs_of P\\<^bsub>wf\\<^esub> Cx Mx)}\n 3. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw\\<rbrakk>\n    \\<Longrightarrow> finite\n                       ((\\<lambda>(Cx, Mx, pc', h, cs'', pcx).\n                            (_ (C, M, pc) #\n                               cs',\\<lfloor>((Cx, Mx, pc') # h,\n       True)\\<rfloor> _)) `\n                        {(Cx, Mx, pc', h, cs'', pcx).\n                         (C, M, pc) # cs' = cs'' @ (Cx, Mx, pcx) # h \\<and>\n                         pc'\n                         < length (instrs_of P\\<^bsub>wf\\<^esub> Cx Mx)})", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw;\n     finite\n      ((\\<lambda>(Cx, Mx, pc', h, cs'', pcx).\n           (_ (C, M, pc) #\n              cs',\\<lfloor>((Cx, Mx, pc') # h, True)\\<rfloor> _)) `\n       {(Cx, Mx, pc', h, cs'', pcx).\n        (C, M, pc) # cs' = cs'' @ (Cx, Mx, pcx) # h \\<and>\n        pc' < length (instrs_of P\\<^bsub>wf\\<^esub> Cx Mx)})\\<rbrakk>\n    \\<Longrightarrow> {n'.\n                       \\<exists>Cx Mx pc' h.\n                          (\\<exists>cs'' pcx.\n                              (C, M, pc) # cs' =\n                              cs'' @ (Cx, Mx, pcx) # h) \\<and>\n                          pc'\n                          < length\n                             (instrs_of P\\<^bsub>wf\\<^esub> Cx Mx) \\<and>\n                          n' =\n                          (_ (C, M, pc) #\n                             cs',\\<lfloor>((Cx, Mx, pc') # h,\n     True)\\<rfloor> _)}\n                      \\<subseteq> (\\<lambda>(Cx, Mx, pc', h, cs'', pcx).\n(_ (C, M, pc) # cs',\\<lfloor>((Cx, Mx, pc') # h, True)\\<rfloor> _)) `\n                                  {(Cx, Mx, pc', h, cs'', pcx).\n                                   (C, M, pc) # cs' =\n                                   cs'' @ (Cx, Mx, pcx) # h \\<and>\n                                   pc'\n                                   < length\n(instrs_of P\\<^bsub>wf\\<^esub> Cx Mx)}\n 2. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw\\<rbrakk>\n    \\<Longrightarrow> finite\n                       ((\\<lambda>(Cx, Mx, pc', h, cs'', pcx).\n                            (_ (C, M, pc) #\n                               cs',\\<lfloor>((Cx, Mx, pc') # h,\n       True)\\<rfloor> _)) `\n                        {(Cx, Mx, pc', h, cs'', pcx).\n                         (C, M, pc) # cs' = cs'' @ (Cx, Mx, pcx) # h \\<and>\n                         pc'\n                         < length (instrs_of P\\<^bsub>wf\\<^esub> Cx Mx)})", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Cx Mx pc' h cs'' pcx.\n       \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n                 (_ cs'' @ (Cx, Mx, pcx) # h,x _);\n        instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw;\n        finite\n         ((\\<lambda>x.\n              case x of\n              (Cxa, Mxa, pc', ha, cs''a, pcxa) \\<Rightarrow>\n                (_ cs'' @\n                   (Cx, Mx, pcx) #\n                   h,\\<lfloor>((Cxa, Mxa, pc') # ha, True)\\<rfloor> _)) `\n          {(Cxa, Mxa, pc', ha, cs''a, pcxa).\n           cs'' @ (Cx, Mx, pcx) # h = cs''a @ (Cxa, Mxa, pcxa) # ha \\<and>\n           pc' < length (instrs_of P\\<^bsub>wf\\<^esub> Cxa Mxa)});\n        (C, M, pc) # cs' = cs'' @ (Cx, Mx, pcx) # h;\n        pc' < length (instrs_of P\\<^bsub>wf\\<^esub> Cx Mx)\\<rbrakk>\n       \\<Longrightarrow> (_ cs'' @\n                            (Cx, Mx, pcx) #\n                            h,\\<lfloor>((Cx, Mx, pc') # h, True)\\<rfloor> _)\n                         \\<in> (\\<lambda>x.\n                                   case x of\n                                   (Cxa, Mxa, pc', ha, cs''a,\n                                    pcxa) \\<Rightarrow>\n                                     (_ cs'' @\n  (Cx, Mx, pcx) # h,\\<lfloor>((Cxa, Mxa, pc') # ha, True)\\<rfloor> _)) `\n                               {(Cxa, Mxa, pc', ha, cs''a, pcxa).\n                                cs'' @ (Cx, Mx, pcx) # h =\n                                cs''a @ (Cxa, Mxa, pcxa) # ha \\<and>\n                                pc'\n                                < length\n                                   (instrs_of P\\<^bsub>wf\\<^esub> Cxa Mxa)}\n 2. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw\\<rbrakk>\n    \\<Longrightarrow> finite\n                       ((\\<lambda>(Cx, Mx, pc', h, cs'', pcx).\n                            (_ (C, M, pc) #\n                               cs',\\<lfloor>((Cx, Mx, pc') # h,\n       True)\\<rfloor> _)) `\n                        {(Cx, Mx, pc', h, cs'', pcx).\n                         (C, M, pc) # cs' = cs'' @ (Cx, Mx, pcx) # h \\<and>\n                         pc'\n                         < length (instrs_of P\\<^bsub>wf\\<^esub> Cx Mx)})", "apply (rule_tac x=\"(Cx,Mx,pc',h,cs'',pcx)\" in image_eqI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>Cx Mx pc' h cs'' pcx.\n       \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n                 (_ cs'' @ (Cx, Mx, pcx) # h,x _);\n        instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw;\n        finite\n         ((\\<lambda>x.\n              case x of\n              (Cxa, Mxa, pc', ha, cs''a, pcxa) \\<Rightarrow>\n                (_ cs'' @\n                   (Cx, Mx, pcx) #\n                   h,\\<lfloor>((Cxa, Mxa, pc') # ha, True)\\<rfloor> _)) `\n          {(Cxa, Mxa, pc', ha, cs''a, pcxa).\n           cs'' @ (Cx, Mx, pcx) # h = cs''a @ (Cxa, Mxa, pcxa) # ha \\<and>\n           pc' < length (instrs_of P\\<^bsub>wf\\<^esub> Cxa Mxa)});\n        (C, M, pc) # cs' = cs'' @ (Cx, Mx, pcx) # h;\n        pc' < length (instrs_of P\\<^bsub>wf\\<^esub> Cx Mx)\\<rbrakk>\n       \\<Longrightarrow> (_ cs'' @\n                            (Cx, Mx, pcx) #\n                            h,\\<lfloor>((Cx, Mx, pc') # h,\n  True)\\<rfloor> _) =\n                         (case (Cx, Mx, pc', h, cs'', pcx) of\n                          (Cxa, Mxa, pc', ha, cs''a, pcxa) \\<Rightarrow>\n                            (_ cs'' @\n                               (Cx, Mx, pcx) #\n                               h,\\<lfloor>((Cxa, Mxa, pc') # ha,\n     True)\\<rfloor> _))\n 2. \\<And>Cx Mx pc' h cs'' pcx.\n       \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n                 (_ cs'' @ (Cx, Mx, pcx) # h,x _);\n        instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw;\n        finite\n         ((\\<lambda>x.\n              case x of\n              (Cxa, Mxa, pc', ha, cs''a, pcxa) \\<Rightarrow>\n                (_ cs'' @\n                   (Cx, Mx, pcx) #\n                   h,\\<lfloor>((Cxa, Mxa, pc') # ha, True)\\<rfloor> _)) `\n          {(Cxa, Mxa, pc', ha, cs''a, pcxa).\n           cs'' @ (Cx, Mx, pcx) # h = cs''a @ (Cxa, Mxa, pcxa) # ha \\<and>\n           pc' < length (instrs_of P\\<^bsub>wf\\<^esub> Cxa Mxa)});\n        (C, M, pc) # cs' = cs'' @ (Cx, Mx, pcx) # h;\n        pc' < length (instrs_of P\\<^bsub>wf\\<^esub> Cx Mx)\\<rbrakk>\n       \\<Longrightarrow> (Cx, Mx, pc', h, cs'', pcx)\n                         \\<in> {(Cxa, Mxa, pc', ha, cs''a, pcxa).\n                                cs'' @ (Cx, Mx, pcx) # h =\n                                cs''a @ (Cxa, Mxa, pcxa) # ha \\<and>\n                                pc'\n                                < length\n                                   (instrs_of P\\<^bsub>wf\\<^esub> Cxa Mxa)}\n 3. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw\\<rbrakk>\n    \\<Longrightarrow> finite\n                       ((\\<lambda>(Cx, Mx, pc', h, cs'', pcx).\n                            (_ (C, M, pc) #\n                               cs',\\<lfloor>((Cx, Mx, pc') # h,\n       True)\\<rfloor> _)) `\n                        {(Cx, Mx, pc', h, cs'', pcx).\n                         (C, M, pc) # cs' = cs'' @ (Cx, Mx, pcx) # h \\<and>\n                         pc'\n                         < length (instrs_of P\\<^bsub>wf\\<^esub> Cx Mx)})", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>Cx Mx pc' h cs'' pcx.\n       \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n                 (_ cs'' @ (Cx, Mx, pcx) # h,x _);\n        instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw;\n        finite\n         ((\\<lambda>x.\n              case x of\n              (Cxa, Mxa, pc', ha, cs''a, pcxa) \\<Rightarrow>\n                (_ cs'' @\n                   (Cx, Mx, pcx) #\n                   h,\\<lfloor>((Cxa, Mxa, pc') # ha, True)\\<rfloor> _)) `\n          {(Cxa, Mxa, pc', ha, cs''a, pcxa).\n           cs'' @ (Cx, Mx, pcx) # h = cs''a @ (Cxa, Mxa, pcxa) # ha \\<and>\n           pc' < length (instrs_of P\\<^bsub>wf\\<^esub> Cxa Mxa)});\n        (C, M, pc) # cs' = cs'' @ (Cx, Mx, pcx) # h;\n        pc' < length (instrs_of P\\<^bsub>wf\\<^esub> Cx Mx)\\<rbrakk>\n       \\<Longrightarrow> (Cx, Mx, pc', h, cs'', pcx)\n                         \\<in> {(Cxa, Mxa, pc', ha, cs''a, pcxa).\n                                cs'' @ (Cx, Mx, pcx) # h =\n                                cs''a @ (Cxa, Mxa, pcxa) # ha \\<and>\n                                pc'\n                                < length\n                                   (instrs_of P\\<^bsub>wf\\<^esub> Cxa Mxa)}\n 2. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw\\<rbrakk>\n    \\<Longrightarrow> finite\n                       ((\\<lambda>(Cx, Mx, pc', h, cs'', pcx).\n                            (_ (C, M, pc) #\n                               cs',\\<lfloor>((Cx, Mx, pc') # h,\n       True)\\<rfloor> _)) `\n                        {(Cx, Mx, pc', h, cs'', pcx).\n                         (C, M, pc) # cs' = cs'' @ (Cx, Mx, pcx) # h \\<and>\n                         pc'\n                         < length (instrs_of P\\<^bsub>wf\\<^esub> Cx Mx)})", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw\\<rbrakk>\n    \\<Longrightarrow> finite\n                       ((\\<lambda>(Cx, Mx, pc', h, cs'', pcx).\n                            (_ (C, M, pc) #\n                               cs',\\<lfloor>((Cx, Mx, pc') # h,\n       True)\\<rfloor> _)) `\n                        {(Cx, Mx, pc', h, cs'', pcx).\n                         (C, M, pc) # cs' = cs'' @ (Cx, Mx, pcx) # h \\<and>\n                         pc'\n                         < length (instrs_of P\\<^bsub>wf\\<^esub> Cx Mx)})", "apply (rule finite_imageI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {(Cx, Mx, pc', h, cs'', pcx).\n                        (C, M, pc) # cs' = cs'' @ (Cx, Mx, pcx) # h \\<and>\n                        pc' < length (instrs_of P\\<^bsub>wf\\<^esub> Cx Mx)}", "apply (subgoal_tac \"finite (\n            (\\<lambda>(l, pc'). (fst(((C, M, pc)#cs') ! l),\n                         fst(snd(((C, M, pc)#cs') ! l)),\n                         pc',\n                         drop l cs',\n                         take l ((C, M, pc)#cs'),\n                         snd(snd(((C, M, pc)#cs') ! l))\n                        )\n            ) ` {(l, pc'). l < length ((C,M,pc)#cs') \\<and>\n                           pc' < length (instrs_of (P\\<^bsub>wf\\<^esub>) (fst(((C, M, pc)#cs') ! l))\n                                                        (fst(snd(((C, M, pc)#cs') ! l))))})\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw;\n     finite\n      ((\\<lambda>(l, pc').\n           (fst (((C, M, pc) # cs') ! l),\n            fst (snd (((C, M, pc) # cs') ! l)), pc', drop l cs',\n            take l ((C, M, pc) # cs'),\n            snd (snd (((C, M, pc) # cs') ! l)))) `\n       {(l, pc').\n        l < length ((C, M, pc) # cs') \\<and>\n        pc'\n        < length\n           (instrs_of P\\<^bsub>wf\\<^esub> (fst (((C, M, pc) # cs') ! l))\n             (fst (snd (((C, M, pc) # cs') ! l))))})\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {(Cx, Mx, pc', h, cs'', pcx).\n                        (C, M, pc) # cs' = cs'' @ (Cx, Mx, pcx) # h \\<and>\n                        pc' < length (instrs_of P\\<^bsub>wf\\<^esub> Cx Mx)}\n 2. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw\\<rbrakk>\n    \\<Longrightarrow> finite\n                       ((\\<lambda>(l, pc').\n                            (fst (((C, M, pc) # cs') ! l),\n                             fst (snd (((C, M, pc) # cs') ! l)), pc',\n                             drop l cs', take l ((C, M, pc) # cs'),\n                             snd (snd (((C, M, pc) # cs') ! l)))) `\n                        {(l, pc').\n                         l < length ((C, M, pc) # cs') \\<and>\n                         pc'\n                         < length\n                            (instrs_of P\\<^bsub>wf\\<^esub>\n                              (fst (((C, M, pc) # cs') ! l))\n                              (fst (snd (((C, M, pc) # cs') ! l))))})", "apply (case_tac \"((\\<lambda>(l, pc').\n             (fst (((C, M, pc) # cs') ! l),\n              fst (snd (((C, M, pc) # cs') ! l)),\n              pc',\n              drop l cs',\n              take l ((C, M, pc) # cs'),\n              snd (snd (((C, M, pc) # cs') ! l))\n             )) ` {(l, pc'). l < length ((C,M,pc)#cs') \\<and>\n                             pc' < length (instrs_of (P\\<^bsub>wf\\<^esub>) (fst (((C, M, pc) # cs') ! l))\n                                                          (fst (snd (((C, M, pc) # cs') ! l))))})\n             = {(Cx, Mx, pc', h, cs'', pcx).\n                (C, M, pc) # cs' = cs'' @ (Cx, Mx, pcx) # h \\<and>\n                pc' < length (instrs_of (P\\<^bsub>wf\\<^esub>) Cx Mx)}\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw;\n     finite\n      ((\\<lambda>(l, pc').\n           (fst (((C, M, pc) # cs') ! l),\n            fst (snd (((C, M, pc) # cs') ! l)), pc', drop l cs',\n            take l ((C, M, pc) # cs'),\n            snd (snd (((C, M, pc) # cs') ! l)))) `\n       {(l, pc').\n        l < length ((C, M, pc) # cs') \\<and>\n        pc'\n        < length\n           (instrs_of P\\<^bsub>wf\\<^esub> (fst (((C, M, pc) # cs') ! l))\n             (fst (snd (((C, M, pc) # cs') ! l))))});\n     (\\<lambda>(l, pc').\n         (fst (((C, M, pc) # cs') ! l), fst (snd (((C, M, pc) # cs') ! l)),\n          pc', drop l cs', take l ((C, M, pc) # cs'),\n          snd (snd (((C, M, pc) # cs') ! l)))) `\n     {(l, pc').\n      l < length ((C, M, pc) # cs') \\<and>\n      pc'\n      < length\n         (instrs_of P\\<^bsub>wf\\<^esub> (fst (((C, M, pc) # cs') ! l))\n           (fst (snd (((C, M, pc) # cs') ! l))))} =\n     {(Cx, Mx, pc', h, cs'', pcx).\n      (C, M, pc) # cs' = cs'' @ (Cx, Mx, pcx) # h \\<and>\n      pc' < length (instrs_of P\\<^bsub>wf\\<^esub> Cx Mx)}\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {(Cx, Mx, pc', h, cs'', pcx).\n                        (C, M, pc) # cs' = cs'' @ (Cx, Mx, pcx) # h \\<and>\n                        pc' < length (instrs_of P\\<^bsub>wf\\<^esub> Cx Mx)}\n 2. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw;\n     finite\n      ((\\<lambda>(l, pc').\n           (fst (((C, M, pc) # cs') ! l),\n            fst (snd (((C, M, pc) # cs') ! l)), pc', drop l cs',\n            take l ((C, M, pc) # cs'),\n            snd (snd (((C, M, pc) # cs') ! l)))) `\n       {(l, pc').\n        l < length ((C, M, pc) # cs') \\<and>\n        pc'\n        < length\n           (instrs_of P\\<^bsub>wf\\<^esub> (fst (((C, M, pc) # cs') ! l))\n             (fst (snd (((C, M, pc) # cs') ! l))))});\n     (\\<lambda>(l, pc').\n         (fst (((C, M, pc) # cs') ! l), fst (snd (((C, M, pc) # cs') ! l)),\n          pc', drop l cs', take l ((C, M, pc) # cs'),\n          snd (snd (((C, M, pc) # cs') ! l)))) `\n     {(l, pc').\n      l < length ((C, M, pc) # cs') \\<and>\n      pc'\n      < length\n         (instrs_of P\\<^bsub>wf\\<^esub> (fst (((C, M, pc) # cs') ! l))\n           (fst (snd (((C, M, pc) # cs') ! l))))} \\<noteq>\n     {(Cx, Mx, pc', h, cs'', pcx).\n      (C, M, pc) # cs' = cs'' @ (Cx, Mx, pcx) # h \\<and>\n      pc' < length (instrs_of P\\<^bsub>wf\\<^esub> Cx Mx)}\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {(Cx, Mx, pc', h, cs'', pcx).\n                        (C, M, pc) # cs' = cs'' @ (Cx, Mx, pcx) # h \\<and>\n                        pc' < length (instrs_of P\\<^bsub>wf\\<^esub> Cx Mx)}\n 3. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw\\<rbrakk>\n    \\<Longrightarrow> finite\n                       ((\\<lambda>(l, pc').\n                            (fst (((C, M, pc) # cs') ! l),\n                             fst (snd (((C, M, pc) # cs') ! l)), pc',\n                             drop l cs', take l ((C, M, pc) # cs'),\n                             snd (snd (((C, M, pc) # cs') ! l)))) `\n                        {(l, pc').\n                         l < length ((C, M, pc) # cs') \\<and>\n                         pc'\n                         < length\n                            (instrs_of P\\<^bsub>wf\\<^esub>\n                              (fst (((C, M, pc) # cs') ! l))\n                              (fst (snd (((C, M, pc) # cs') ! l))))})", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw;\n     finite\n      ((\\<lambda>(l, pc').\n           (fst (((C, M, pc) # cs') ! l),\n            fst (snd (((C, M, pc) # cs') ! l)), pc', drop l cs',\n            take l ((C, M, pc) # cs'),\n            snd (snd (((C, M, pc) # cs') ! l)))) `\n       {(l, pc').\n        l < length ((C, M, pc) # cs') \\<and>\n        pc'\n        < length\n           (instrs_of P\\<^bsub>wf\\<^esub> (fst (((C, M, pc) # cs') ! l))\n             (fst (snd (((C, M, pc) # cs') ! l))))});\n     (\\<lambda>(l, pc').\n         (fst (((C, M, pc) # cs') ! l), fst (snd (((C, M, pc) # cs') ! l)),\n          pc', drop l cs', take l ((C, M, pc) # cs'),\n          snd (snd (((C, M, pc) # cs') ! l)))) `\n     {(l, pc').\n      l < length ((C, M, pc) # cs') \\<and>\n      pc'\n      < length\n         (instrs_of P\\<^bsub>wf\\<^esub> (fst (((C, M, pc) # cs') ! l))\n           (fst (snd (((C, M, pc) # cs') ! l))))} \\<noteq>\n     {(Cx, Mx, pc', h, cs'', pcx).\n      (C, M, pc) # cs' = cs'' @ (Cx, Mx, pcx) # h \\<and>\n      pc' < length (instrs_of P\\<^bsub>wf\\<^esub> Cx Mx)}\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {(Cx, Mx, pc', h, cs'', pcx).\n                        (C, M, pc) # cs' = cs'' @ (Cx, Mx, pcx) # h \\<and>\n                        pc' < length (instrs_of P\\<^bsub>wf\\<^esub> Cx Mx)}\n 2. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw\\<rbrakk>\n    \\<Longrightarrow> finite\n                       ((\\<lambda>(l, pc').\n                            (fst (((C, M, pc) # cs') ! l),\n                             fst (snd (((C, M, pc) # cs') ! l)), pc',\n                             drop l cs', take l ((C, M, pc) # cs'),\n                             snd (snd (((C, M, pc) # cs') ! l)))) `\n                        {(l, pc').\n                         l < length ((C, M, pc) # cs') \\<and>\n                         pc'\n                         < length\n                            (instrs_of P\\<^bsub>wf\\<^esub>\n                              (fst (((C, M, pc) # cs') ! l))\n                              (fst (snd (((C, M, pc) # cs') ! l))))})", "apply (erule notE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw;\n     finite\n      ((\\<lambda>(l, pc').\n           (fst (((C, M, pc) # cs') ! l),\n            fst (snd (((C, M, pc) # cs') ! l)), pc', drop l cs',\n            take l ((C, M, pc) # cs'),\n            snd (snd (((C, M, pc) # cs') ! l)))) `\n       {(l, pc').\n        l < length ((C, M, pc) # cs') \\<and>\n        pc'\n        < length\n           (instrs_of P\\<^bsub>wf\\<^esub> (fst (((C, M, pc) # cs') ! l))\n             (fst (snd (((C, M, pc) # cs') ! l))))})\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>(l, pc').\n                          (fst (((C, M, pc) # cs') ! l),\n                           fst (snd (((C, M, pc) # cs') ! l)), pc',\n                           drop l cs', take l ((C, M, pc) # cs'),\n                           snd (snd (((C, M, pc) # cs') ! l)))) `\n                      {(l, pc').\n                       l < length ((C, M, pc) # cs') \\<and>\n                       pc'\n                       < length\n                          (instrs_of P\\<^bsub>wf\\<^esub>\n                            (fst (((C, M, pc) # cs') ! l))\n                            (fst (snd (((C, M, pc) # cs') ! l))))} =\n                      {(Cx, Mx, pc', h, cs'', pcx).\n                       (C, M, pc) # cs' = cs'' @ (Cx, Mx, pcx) # h \\<and>\n                       pc' < length (instrs_of P\\<^bsub>wf\\<^esub> Cx Mx)}\n 2. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw\\<rbrakk>\n    \\<Longrightarrow> finite\n                       ((\\<lambda>(l, pc').\n                            (fst (((C, M, pc) # cs') ! l),\n                             fst (snd (((C, M, pc) # cs') ! l)), pc',\n                             drop l cs', take l ((C, M, pc) # cs'),\n                             snd (snd (((C, M, pc) # cs') ! l)))) `\n                        {(l, pc').\n                         l < length ((C, M, pc) # cs') \\<and>\n                         pc'\n                         < length\n                            (instrs_of P\\<^bsub>wf\\<^esub>\n                              (fst (((C, M, pc) # cs') ! l))\n                              (fst (snd (((C, M, pc) # cs') ! l))))})", "apply (rule equalityI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw;\n     finite\n      ((\\<lambda>(l, pc').\n           (fst (((C, M, pc) # cs') ! l),\n            fst (snd (((C, M, pc) # cs') ! l)), pc', drop l cs',\n            take l ((C, M, pc) # cs'),\n            snd (snd (((C, M, pc) # cs') ! l)))) `\n       {(l, pc').\n        l < length ((C, M, pc) # cs') \\<and>\n        pc'\n        < length\n           (instrs_of P\\<^bsub>wf\\<^esub> (fst (((C, M, pc) # cs') ! l))\n             (fst (snd (((C, M, pc) # cs') ! l))))})\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>(l, pc').\n                          (fst (((C, M, pc) # cs') ! l),\n                           fst (snd (((C, M, pc) # cs') ! l)), pc',\n                           drop l cs', take l ((C, M, pc) # cs'),\n                           snd (snd (((C, M, pc) # cs') ! l)))) `\n                      {(l, pc').\n                       l < length ((C, M, pc) # cs') \\<and>\n                       pc'\n                       < length\n                          (instrs_of P\\<^bsub>wf\\<^esub>\n                            (fst (((C, M, pc) # cs') ! l))\n                            (fst (snd (((C, M, pc) # cs') ! l))))}\n                      \\<subseteq> {(Cx, Mx, pc', h, cs'', pcx).\n                                   (C, M, pc) # cs' =\n                                   cs'' @ (Cx, Mx, pcx) # h \\<and>\n                                   pc'\n                                   < length\n(instrs_of P\\<^bsub>wf\\<^esub> Cx Mx)}\n 2. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw;\n     finite\n      ((\\<lambda>(l, pc').\n           (fst (((C, M, pc) # cs') ! l),\n            fst (snd (((C, M, pc) # cs') ! l)), pc', drop l cs',\n            take l ((C, M, pc) # cs'),\n            snd (snd (((C, M, pc) # cs') ! l)))) `\n       {(l, pc').\n        l < length ((C, M, pc) # cs') \\<and>\n        pc'\n        < length\n           (instrs_of P\\<^bsub>wf\\<^esub> (fst (((C, M, pc) # cs') ! l))\n             (fst (snd (((C, M, pc) # cs') ! l))))})\\<rbrakk>\n    \\<Longrightarrow> {(Cx, Mx, pc', h, cs'', pcx).\n                       (C, M, pc) # cs' = cs'' @ (Cx, Mx, pcx) # h \\<and>\n                       pc' < length (instrs_of P\\<^bsub>wf\\<^esub> Cx Mx)}\n                      \\<subseteq> (\\<lambda>(l, pc').\n(fst (((C, M, pc) # cs') ! l), fst (snd (((C, M, pc) # cs') ! l)), pc',\n drop l cs', take l ((C, M, pc) # cs'),\n snd (snd (((C, M, pc) # cs') ! l)))) `\n                                  {(l, pc').\n                                   l < length ((C, M, pc) # cs') \\<and>\n                                   pc'\n                                   < length\n(instrs_of P\\<^bsub>wf\\<^esub> (fst (((C, M, pc) # cs') ! l))\n  (fst (snd (((C, M, pc) # cs') ! l))))}\n 3. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw\\<rbrakk>\n    \\<Longrightarrow> finite\n                       ((\\<lambda>(l, pc').\n                            (fst (((C, M, pc) # cs') ! l),\n                             fst (snd (((C, M, pc) # cs') ! l)), pc',\n                             drop l cs', take l ((C, M, pc) # cs'),\n                             snd (snd (((C, M, pc) # cs') ! l)))) `\n                        {(l, pc').\n                         l < length ((C, M, pc) # cs') \\<and>\n                         pc'\n                         < length\n                            (instrs_of P\\<^bsub>wf\\<^esub>\n                              (fst (((C, M, pc) # cs') ! l))\n                              (fst (snd (((C, M, pc) # cs') ! l))))})", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ae ba.\n       \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n                 (_ (C, M, pc) # cs',x _);\n        instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw;\n        finite\n         ((\\<lambda>x.\n              case x of\n              (l, pc') \\<Rightarrow>\n                (fst (((C, M, pc) # cs') ! l),\n                 fst (snd (((C, M, pc) # cs') ! l)), pc', drop l cs',\n                 take l ((C, M, pc) # cs'),\n                 snd (snd (((C, M, pc) # cs') ! l)))) `\n          {(l, pc').\n           l < Suc (length cs') \\<and>\n           pc'\n           < length\n              (instrs_of P\\<^bsub>wf\\<^esub> (fst (((C, M, pc) # cs') ! l))\n                (fst (snd (((C, M, pc) # cs') ! l))))});\n        ae < Suc (length cs');\n        ba < length\n              (instrs_of P\\<^bsub>wf\\<^esub> (fst (((C, M, pc) # cs') ! ae))\n                (fst (snd (((C, M, pc) # cs') ! ae))))\\<rbrakk>\n       \\<Longrightarrow> (C, M, pc) # cs' =\n                         take ae ((C, M, pc) # cs') @\n                         ((C, M, pc) # cs') ! ae # drop ae cs'\n 2. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw;\n     finite\n      ((\\<lambda>(l, pc').\n           (fst (((C, M, pc) # cs') ! l),\n            fst (snd (((C, M, pc) # cs') ! l)), pc', drop l cs',\n            take l ((C, M, pc) # cs'),\n            snd (snd (((C, M, pc) # cs') ! l)))) `\n       {(l, pc').\n        l < length ((C, M, pc) # cs') \\<and>\n        pc'\n        < length\n           (instrs_of P\\<^bsub>wf\\<^esub> (fst (((C, M, pc) # cs') ! l))\n             (fst (snd (((C, M, pc) # cs') ! l))))})\\<rbrakk>\n    \\<Longrightarrow> {(Cx, Mx, pc', h, cs'', pcx).\n                       (C, M, pc) # cs' = cs'' @ (Cx, Mx, pcx) # h \\<and>\n                       pc' < length (instrs_of P\\<^bsub>wf\\<^esub> Cx Mx)}\n                      \\<subseteq> (\\<lambda>(l, pc').\n(fst (((C, M, pc) # cs') ! l), fst (snd (((C, M, pc) # cs') ! l)), pc',\n drop l cs', take l ((C, M, pc) # cs'),\n snd (snd (((C, M, pc) # cs') ! l)))) `\n                                  {(l, pc').\n                                   l < length ((C, M, pc) # cs') \\<and>\n                                   pc'\n                                   < length\n(instrs_of P\\<^bsub>wf\\<^esub> (fst (((C, M, pc) # cs') ! l))\n  (fst (snd (((C, M, pc) # cs') ! l))))}\n 3. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw\\<rbrakk>\n    \\<Longrightarrow> finite\n                       ((\\<lambda>(l, pc').\n                            (fst (((C, M, pc) # cs') ! l),\n                             fst (snd (((C, M, pc) # cs') ! l)), pc',\n                             drop l cs', take l ((C, M, pc) # cs'),\n                             snd (snd (((C, M, pc) # cs') ! l)))) `\n                        {(l, pc').\n                         l < length ((C, M, pc) # cs') \\<and>\n                         pc'\n                         < length\n                            (instrs_of P\\<^bsub>wf\\<^esub>\n                              (fst (((C, M, pc) # cs') ! l))\n                              (fst (snd (((C, M, pc) # cs') ! l))))})", "apply (rule id_take_nth_drop [of _ \"(C,M,pc)#cs'\", simplified])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ae ba.\n       \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n                 (_ (C, M, pc) # cs',x _);\n        instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw;\n        finite\n         ((\\<lambda>x.\n              case x of\n              (l, pc') \\<Rightarrow>\n                (fst (((C, M, pc) # cs') ! l),\n                 fst (snd (((C, M, pc) # cs') ! l)), pc', drop l cs',\n                 take l ((C, M, pc) # cs'),\n                 snd (snd (((C, M, pc) # cs') ! l)))) `\n          {(l, pc').\n           l < Suc (length cs') \\<and>\n           pc'\n           < length\n              (instrs_of P\\<^bsub>wf\\<^esub> (fst (((C, M, pc) # cs') ! l))\n                (fst (snd (((C, M, pc) # cs') ! l))))});\n        ae < Suc (length cs');\n        ba < length\n              (instrs_of P\\<^bsub>wf\\<^esub> (fst (((C, M, pc) # cs') ! ae))\n                (fst (snd (((C, M, pc) # cs') ! ae))))\\<rbrakk>\n       \\<Longrightarrow> ae < Suc (length cs')\n 2. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw;\n     finite\n      ((\\<lambda>(l, pc').\n           (fst (((C, M, pc) # cs') ! l),\n            fst (snd (((C, M, pc) # cs') ! l)), pc', drop l cs',\n            take l ((C, M, pc) # cs'),\n            snd (snd (((C, M, pc) # cs') ! l)))) `\n       {(l, pc').\n        l < length ((C, M, pc) # cs') \\<and>\n        pc'\n        < length\n           (instrs_of P\\<^bsub>wf\\<^esub> (fst (((C, M, pc) # cs') ! l))\n             (fst (snd (((C, M, pc) # cs') ! l))))})\\<rbrakk>\n    \\<Longrightarrow> {(Cx, Mx, pc', h, cs'', pcx).\n                       (C, M, pc) # cs' = cs'' @ (Cx, Mx, pcx) # h \\<and>\n                       pc' < length (instrs_of P\\<^bsub>wf\\<^esub> Cx Mx)}\n                      \\<subseteq> (\\<lambda>(l, pc').\n(fst (((C, M, pc) # cs') ! l), fst (snd (((C, M, pc) # cs') ! l)), pc',\n drop l cs', take l ((C, M, pc) # cs'),\n snd (snd (((C, M, pc) # cs') ! l)))) `\n                                  {(l, pc').\n                                   l < length ((C, M, pc) # cs') \\<and>\n                                   pc'\n                                   < length\n(instrs_of P\\<^bsub>wf\\<^esub> (fst (((C, M, pc) # cs') ! l))\n  (fst (snd (((C, M, pc) # cs') ! l))))}\n 3. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw\\<rbrakk>\n    \\<Longrightarrow> finite\n                       ((\\<lambda>(l, pc').\n                            (fst (((C, M, pc) # cs') ! l),\n                             fst (snd (((C, M, pc) # cs') ! l)), pc',\n                             drop l cs', take l ((C, M, pc) # cs'),\n                             snd (snd (((C, M, pc) # cs') ! l)))) `\n                        {(l, pc').\n                         l < length ((C, M, pc) # cs') \\<and>\n                         pc'\n                         < length\n                            (instrs_of P\\<^bsub>wf\\<^esub>\n                              (fst (((C, M, pc) # cs') ! l))\n                              (fst (snd (((C, M, pc) # cs') ! l))))})", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw;\n     finite\n      ((\\<lambda>(l, pc').\n           (fst (((C, M, pc) # cs') ! l),\n            fst (snd (((C, M, pc) # cs') ! l)), pc', drop l cs',\n            take l ((C, M, pc) # cs'),\n            snd (snd (((C, M, pc) # cs') ! l)))) `\n       {(l, pc').\n        l < length ((C, M, pc) # cs') \\<and>\n        pc'\n        < length\n           (instrs_of P\\<^bsub>wf\\<^esub> (fst (((C, M, pc) # cs') ! l))\n             (fst (snd (((C, M, pc) # cs') ! l))))})\\<rbrakk>\n    \\<Longrightarrow> {(Cx, Mx, pc', h, cs'', pcx).\n                       (C, M, pc) # cs' = cs'' @ (Cx, Mx, pcx) # h \\<and>\n                       pc' < length (instrs_of P\\<^bsub>wf\\<^esub> Cx Mx)}\n                      \\<subseteq> (\\<lambda>(l, pc').\n(fst (((C, M, pc) # cs') ! l), fst (snd (((C, M, pc) # cs') ! l)), pc',\n drop l cs', take l ((C, M, pc) # cs'),\n snd (snd (((C, M, pc) # cs') ! l)))) `\n                                  {(l, pc').\n                                   l < length ((C, M, pc) # cs') \\<and>\n                                   pc'\n                                   < length\n(instrs_of P\\<^bsub>wf\\<^esub> (fst (((C, M, pc) # cs') ! l))\n  (fst (snd (((C, M, pc) # cs') ! l))))}\n 2. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw\\<rbrakk>\n    \\<Longrightarrow> finite\n                       ((\\<lambda>(l, pc').\n                            (fst (((C, M, pc) # cs') ! l),\n                             fst (snd (((C, M, pc) # cs') ! l)), pc',\n                             drop l cs', take l ((C, M, pc) # cs'),\n                             snd (snd (((C, M, pc) # cs') ! l)))) `\n                        {(l, pc').\n                         l < length ((C, M, pc) # cs') \\<and>\n                         pc'\n                         < length\n                            (instrs_of P\\<^bsub>wf\\<^esub>\n                              (fst (((C, M, pc) # cs') ! l))\n                              (fst (snd (((C, M, pc) # cs') ! l))))})", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a aa ab ac ad b.\n       \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n                 (_ ad @ (a, aa, b) # ac,x _);\n        instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw;\n        finite\n         ((\\<lambda>x.\n              case x of\n              (l, pc') \\<Rightarrow>\n                (fst ((ad @ (a, aa, b) # ac) ! l),\n                 fst (snd ((ad @ (a, aa, b) # ac) ! l)), pc', drop l cs',\n                 take l ad @ take (l - length ad) ((a, aa, b) # ac),\n                 snd (snd ((ad @ (a, aa, b) # ac) ! l)))) `\n          {(l, pc').\n           l < Suc (length cs') \\<and>\n           pc'\n           < length\n              (instrs_of P\\<^bsub>wf\\<^esub>\n                (fst ((ad @ (a, aa, b) # ac) ! l))\n                (fst (snd ((ad @ (a, aa, b) # ac) ! l))))});\n        (C, M, pc) # cs' = ad @ (a, aa, b) # ac;\n        ab < length (instrs_of P\\<^bsub>wf\\<^esub> a aa)\\<rbrakk>\n       \\<Longrightarrow> (a, aa, ab, ac, ad, b)\n                         \\<in> (\\<lambda>x.\n                                   case x of\n                                   (l, pc') \\<Rightarrow>\n                                     (fst ((ad @ (a, aa, b) # ac) ! l),\nfst (snd ((ad @ (a, aa, b) # ac) ! l)), pc', drop l cs',\ntake l ad @ take (l - length ad) ((a, aa, b) # ac),\nsnd (snd ((ad @ (a, aa, b) # ac) ! l)))) `\n                               {(l, pc').\n                                l < Suc (length cs') \\<and>\n                                pc'\n                                < length\n                                   (instrs_of P\\<^bsub>wf\\<^esub>\n                                     (fst ((ad @ (a, aa, b) # ac) ! l))\n                                     (fst\n (snd ((ad @ (a, aa, b) # ac) ! l))))}\n 2. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw\\<rbrakk>\n    \\<Longrightarrow> finite\n                       ((\\<lambda>(l, pc').\n                            (fst (((C, M, pc) # cs') ! l),\n                             fst (snd (((C, M, pc) # cs') ! l)), pc',\n                             drop l cs', take l ((C, M, pc) # cs'),\n                             snd (snd (((C, M, pc) # cs') ! l)))) `\n                        {(l, pc').\n                         l < length ((C, M, pc) # cs') \\<and>\n                         pc'\n                         < length\n                            (instrs_of P\\<^bsub>wf\\<^esub>\n                              (fst (((C, M, pc) # cs') ! l))\n                              (fst (snd (((C, M, pc) # cs') ! l))))})", "apply (rule_tac x=\"(length ad,ab)\" in image_eqI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a aa ab ac ad b.\n       \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n                 (_ ad @ (a, aa, b) # ac,x _);\n        instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw;\n        finite\n         ((\\<lambda>x.\n              case x of\n              (l, pc') \\<Rightarrow>\n                (fst ((ad @ (a, aa, b) # ac) ! l),\n                 fst (snd ((ad @ (a, aa, b) # ac) ! l)), pc', drop l cs',\n                 take l ad @ take (l - length ad) ((a, aa, b) # ac),\n                 snd (snd ((ad @ (a, aa, b) # ac) ! l)))) `\n          {(l, pc').\n           l < Suc (length cs') \\<and>\n           pc'\n           < length\n              (instrs_of P\\<^bsub>wf\\<^esub>\n                (fst ((ad @ (a, aa, b) # ac) ! l))\n                (fst (snd ((ad @ (a, aa, b) # ac) ! l))))});\n        (C, M, pc) # cs' = ad @ (a, aa, b) # ac;\n        ab < length (instrs_of P\\<^bsub>wf\\<^esub> a aa)\\<rbrakk>\n       \\<Longrightarrow> (a, aa, ab, ac, ad, b) =\n                         (case (length ad, ab) of\n                          (l, pc') \\<Rightarrow>\n                            (fst ((ad @ (a, aa, b) # ac) ! l),\n                             fst (snd ((ad @ (a, aa, b) # ac) ! l)), pc',\n                             drop l cs',\n                             take l ad @\n                             take (l - length ad) ((a, aa, b) # ac),\n                             snd (snd ((ad @ (a, aa, b) # ac) ! l))))\n 2. \\<And>a aa ab ac ad b.\n       \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n                 (_ ad @ (a, aa, b) # ac,x _);\n        instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw;\n        finite\n         ((\\<lambda>x.\n              case x of\n              (l, pc') \\<Rightarrow>\n                (fst ((ad @ (a, aa, b) # ac) ! l),\n                 fst (snd ((ad @ (a, aa, b) # ac) ! l)), pc', drop l cs',\n                 take l ad @ take (l - length ad) ((a, aa, b) # ac),\n                 snd (snd ((ad @ (a, aa, b) # ac) ! l)))) `\n          {(l, pc').\n           l < Suc (length cs') \\<and>\n           pc'\n           < length\n              (instrs_of P\\<^bsub>wf\\<^esub>\n                (fst ((ad @ (a, aa, b) # ac) ! l))\n                (fst (snd ((ad @ (a, aa, b) # ac) ! l))))});\n        (C, M, pc) # cs' = ad @ (a, aa, b) # ac;\n        ab < length (instrs_of P\\<^bsub>wf\\<^esub> a aa)\\<rbrakk>\n       \\<Longrightarrow> (length ad, ab)\n                         \\<in> {(l, pc').\n                                l < Suc (length cs') \\<and>\n                                pc'\n                                < length\n                                   (instrs_of P\\<^bsub>wf\\<^esub>\n                                     (fst ((ad @ (a, aa, b) # ac) ! l))\n                                     (fst\n (snd ((ad @ (a, aa, b) # ac) ! l))))}\n 3. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw\\<rbrakk>\n    \\<Longrightarrow> finite\n                       ((\\<lambda>(l, pc').\n                            (fst (((C, M, pc) # cs') ! l),\n                             fst (snd (((C, M, pc) # cs') ! l)), pc',\n                             drop l cs', take l ((C, M, pc) # cs'),\n                             snd (snd (((C, M, pc) # cs') ! l)))) `\n                        {(l, pc').\n                         l < length ((C, M, pc) # cs') \\<and>\n                         pc'\n                         < length\n                            (instrs_of P\\<^bsub>wf\\<^esub>\n                              (fst (((C, M, pc) # cs') ! l))\n                              (fst (snd (((C, M, pc) # cs') ! l))))})", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a aa ab ac ad b.\n       \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n                 (_ ad @ (a, aa, b) # ac,x _);\n        instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw;\n        finite\n         ((\\<lambda>x.\n              case x of\n              (l, pc') \\<Rightarrow>\n                (fst ((ad @ (a, aa, b) # ac) ! l),\n                 fst (snd ((ad @ (a, aa, b) # ac) ! l)), pc', drop l cs',\n                 take l ad @ take (l - length ad) ((a, aa, b) # ac),\n                 snd (snd ((ad @ (a, aa, b) # ac) ! l)))) `\n          {(l, pc').\n           l < Suc (length cs') \\<and>\n           pc'\n           < length\n              (instrs_of P\\<^bsub>wf\\<^esub>\n                (fst ((ad @ (a, aa, b) # ac) ! l))\n                (fst (snd ((ad @ (a, aa, b) # ac) ! l))))});\n        (C, M, pc) # cs' = ad @ (a, aa, b) # ac;\n        ab < length (instrs_of P\\<^bsub>wf\\<^esub> a aa)\\<rbrakk>\n       \\<Longrightarrow> ac = drop (length ad) cs'\n 2. \\<And>a aa ab ac ad b.\n       \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n                 (_ ad @ (a, aa, b) # ac,x _);\n        instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw;\n        finite\n         ((\\<lambda>x.\n              case x of\n              (l, pc') \\<Rightarrow>\n                (fst ((ad @ (a, aa, b) # ac) ! l),\n                 fst (snd ((ad @ (a, aa, b) # ac) ! l)), pc', drop l cs',\n                 take l ad @ take (l - length ad) ((a, aa, b) # ac),\n                 snd (snd ((ad @ (a, aa, b) # ac) ! l)))) `\n          {(l, pc').\n           l < Suc (length cs') \\<and>\n           pc'\n           < length\n              (instrs_of P\\<^bsub>wf\\<^esub>\n                (fst ((ad @ (a, aa, b) # ac) ! l))\n                (fst (snd ((ad @ (a, aa, b) # ac) ! l))))});\n        (C, M, pc) # cs' = ad @ (a, aa, b) # ac;\n        ab < length (instrs_of P\\<^bsub>wf\\<^esub> a aa)\\<rbrakk>\n       \\<Longrightarrow> (length ad, ab)\n                         \\<in> {(l, pc').\n                                l < Suc (length cs') \\<and>\n                                pc'\n                                < length\n                                   (instrs_of P\\<^bsub>wf\\<^esub>\n                                     (fst ((ad @ (a, aa, b) # ac) ! l))\n                                     (fst\n (snd ((ad @ (a, aa, b) # ac) ! l))))}\n 3. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw\\<rbrakk>\n    \\<Longrightarrow> finite\n                       ((\\<lambda>(l, pc').\n                            (fst (((C, M, pc) # cs') ! l),\n                             fst (snd (((C, M, pc) # cs') ! l)), pc',\n                             drop l cs', take l ((C, M, pc) # cs'),\n                             snd (snd (((C, M, pc) # cs') ! l)))) `\n                        {(l, pc').\n                         l < length ((C, M, pc) # cs') \\<and>\n                         pc'\n                         < length\n                            (instrs_of P\\<^bsub>wf\\<^esub>\n                              (fst (((C, M, pc) # cs') ! l))\n                              (fst (snd (((C, M, pc) # cs') ! l))))})", "apply (case_tac ad, clarsimp, clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a aa ab ac ad b.\n       \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n                 (_ ad @ (a, aa, b) # ac,x _);\n        instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw;\n        finite\n         ((\\<lambda>x.\n              case x of\n              (l, pc') \\<Rightarrow>\n                (fst ((ad @ (a, aa, b) # ac) ! l),\n                 fst (snd ((ad @ (a, aa, b) # ac) ! l)), pc', drop l cs',\n                 take l ad @ take (l - length ad) ((a, aa, b) # ac),\n                 snd (snd ((ad @ (a, aa, b) # ac) ! l)))) `\n          {(l, pc').\n           l < Suc (length cs') \\<and>\n           pc'\n           < length\n              (instrs_of P\\<^bsub>wf\\<^esub>\n                (fst ((ad @ (a, aa, b) # ac) ! l))\n                (fst (snd ((ad @ (a, aa, b) # ac) ! l))))});\n        (C, M, pc) # cs' = ad @ (a, aa, b) # ac;\n        ab < length (instrs_of P\\<^bsub>wf\\<^esub> a aa)\\<rbrakk>\n       \\<Longrightarrow> (length ad, ab)\n                         \\<in> {(l, pc').\n                                l < Suc (length cs') \\<and>\n                                pc'\n                                < length\n                                   (instrs_of P\\<^bsub>wf\\<^esub>\n                                     (fst ((ad @ (a, aa, b) # ac) ! l))\n                                     (fst\n (snd ((ad @ (a, aa, b) # ac) ! l))))}\n 2. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw\\<rbrakk>\n    \\<Longrightarrow> finite\n                       ((\\<lambda>(l, pc').\n                            (fst (((C, M, pc) # cs') ! l),\n                             fst (snd (((C, M, pc) # cs') ! l)), pc',\n                             drop l cs', take l ((C, M, pc) # cs'),\n                             snd (snd (((C, M, pc) # cs') ! l)))) `\n                        {(l, pc').\n                         l < length ((C, M, pc) # cs') \\<and>\n                         pc'\n                         < length\n                            (instrs_of P\\<^bsub>wf\\<^esub>\n                              (fst (((C, M, pc) # cs') ! l))\n                              (fst (snd (((C, M, pc) # cs') ! l))))})", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a aa ab ac ad b.\n       \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n                 (_ ad @ (a, aa, b) # ac,x _);\n        instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw;\n        finite\n         ((\\<lambda>x.\n              case x of\n              (l, pc') \\<Rightarrow>\n                (fst ((ad @ (a, aa, b) # ac) ! l),\n                 fst (snd ((ad @ (a, aa, b) # ac) ! l)), pc', drop l cs',\n                 take l ad @ take (l - length ad) ((a, aa, b) # ac),\n                 snd (snd ((ad @ (a, aa, b) # ac) ! l)))) `\n          {(l, pc').\n           l < Suc (length cs') \\<and>\n           pc'\n           < length\n              (instrs_of P\\<^bsub>wf\\<^esub>\n                (fst ((ad @ (a, aa, b) # ac) ! l))\n                (fst (snd ((ad @ (a, aa, b) # ac) ! l))))});\n        (C, M, pc) # cs' = ad @ (a, aa, b) # ac;\n        ab < length (instrs_of P\\<^bsub>wf\\<^esub> a aa)\\<rbrakk>\n       \\<Longrightarrow> length ad < Suc (length cs')\n 2. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw\\<rbrakk>\n    \\<Longrightarrow> finite\n                       ((\\<lambda>(l, pc').\n                            (fst (((C, M, pc) # cs') ! l),\n                             fst (snd (((C, M, pc) # cs') ! l)), pc',\n                             drop l cs', take l ((C, M, pc) # cs'),\n                             snd (snd (((C, M, pc) # cs') ! l)))) `\n                        {(l, pc').\n                         l < length ((C, M, pc) # cs') \\<and>\n                         pc'\n                         < length\n                            (instrs_of P\\<^bsub>wf\\<^esub>\n                              (fst (((C, M, pc) # cs') ! l))\n                              (fst (snd (((C, M, pc) # cs') ! l))))})", "apply (case_tac ad, clarsimp, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw\\<rbrakk>\n    \\<Longrightarrow> finite\n                       ((\\<lambda>(l, pc').\n                            (fst (((C, M, pc) # cs') ! l),\n                             fst (snd (((C, M, pc) # cs') ! l)), pc',\n                             drop l cs', take l ((C, M, pc) # cs'),\n                             snd (snd (((C, M, pc) # cs') ! l)))) `\n                        {(l, pc').\n                         l < length ((C, M, pc) # cs') \\<and>\n                         pc'\n                         < length\n                            (instrs_of P\\<^bsub>wf\\<^esub>\n                              (fst (((C, M, pc) # cs') ! l))\n                              (fst (snd (((C, M, pc) # cs') ! l))))})", "apply (rule finite_imageI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>JVM_CFG_Interpret.valid_node (P, C0, Main)\n              (_ (C, M, pc) # cs',x _);\n     instrs_of P\\<^bsub>wf\\<^esub> C M ! pc = Throw\\<rbrakk>\n    \\<Longrightarrow> finite\n                       {(l, pc').\n                        l < length ((C, M, pc) # cs') \\<and>\n                        pc'\n                        < length\n                           (instrs_of P\\<^bsub>wf\\<^esub>\n                             (fst (((C, M, pc) # cs') ! l))\n                             (fst (snd (((C, M, pc) # cs') ! l))))}", "by (rule f_1)"], ["proof (state)\nthis:\n  finite\n   {n'.\n    \\<exists>a'.\n       valid_edge prog a' \\<and>\n       sourcenode a' = n \\<and> targetnode a' = n'}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite\n   {n'.\n    \\<exists>a'.\n       valid_edge prog a' \\<and>\n       sourcenode a' = n \\<and> targetnode a' = n'}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite\n   {n'.\n    \\<exists>a'.\n       valid_edge prog a' \\<and>\n       sourcenode a' = n \\<and> targetnode a' = n'}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite\n   {n'.\n    \\<exists>a'.\n       valid_edge prog a' \\<and>\n       sourcenode a' = n \\<and> targetnode a' = n'}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Interpretation of the locale\\<close>"], ["", "interpretation JVM_CFG_StrongPostdomination:\n  StrongPostdomination \"sourcenode\" \"targetnode\" \"kind\" \"valid_edge\\<^bsub>CFG\\<^esub> prog\" \"Entry\" \"(_Exit_)\"\n  for prog"], ["proof (prove)\ngoal (1 subgoal):\n 1. StrongPostdomination sourcenode targetnode kind\n     (valid_edge\\<^bsub>CFG\\<^esub> prog) (_Entry_) (_Exit_)", "proof(unfold_locales)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       JVM_CFG_Interpret.valid_node\\<^bsub>CFG\\<^esub> prog\n        n \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge\\<^bsub>CFG\\<^esub> prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       JVM_CFG_Interpret.valid_node\\<^bsub>CFG\\<^esub> prog\n        n \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge\\<^bsub>CFG\\<^esub> prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}", "assume vn: \"CFG.valid_node sourcenode targetnode (valid_edge\\<^bsub>CFG\\<^esub> prog) n\""], ["proof (state)\nthis:\n  JVM_CFG_Interpret.valid_node\\<^bsub>CFG\\<^esub> prog n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       JVM_CFG_Interpret.valid_node\\<^bsub>CFG\\<^esub> prog\n        n \\<Longrightarrow>\n       finite\n        {n'.\n         \\<exists>a'.\n            valid_edge\\<^bsub>CFG\\<^esub> prog a' \\<and>\n            sourcenode a' = n \\<and> targetnode a' = n'}", "thus \"finite {n'. \\<exists>a'. valid_edge\\<^bsub>CFG\\<^esub> prog a' \\<and> sourcenode a' = n \\<and> targetnode a' = n'}\""], ["proof (prove)\nusing this:\n  JVM_CFG_Interpret.valid_node\\<^bsub>CFG\\<^esub> prog n\n\ngoal (1 subgoal):\n 1. finite\n     {n'.\n      \\<exists>a'.\n         valid_edge\\<^bsub>CFG\\<^esub> prog a' \\<and>\n         sourcenode a' = n \\<and> targetnode a' = n'}", "by (rule successor_set_finite)"], ["proof (state)\nthis:\n  finite\n   {n'.\n    \\<exists>a'.\n       valid_edge\\<^bsub>CFG\\<^esub> prog a' \\<and>\n       sourcenode a' = n \\<and> targetnode a' = n'}\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}