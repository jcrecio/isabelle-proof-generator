{"file_name": "/home/qj213/afp-2021-10-22/thys/Slicing/While/Interpretation.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Slicing", "problem_names": ["lemma While_CFG_aux:\n  \"CFG sourcenode targetnode (valid_edge prog) Entry\"", "lemma While_CFGExit_aux:\n  \"CFGExit sourcenode targetnode kind (valid_edge prog) Entry Exit\""], "translations": [["", "lemma While_CFG_aux:\n  \"CFG sourcenode targetnode (valid_edge prog) Entry\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CFG sourcenode targetnode (valid_edge prog) (_Entry_)", "proof(unfold_locales)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>valid_edge prog a; targetnode a = (_Entry_)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a a'.\n       \\<lbrakk>valid_edge prog a; valid_edge prog a';\n        sourcenode a = sourcenode a'; targetnode a = targetnode a'\\<rbrakk>\n       \\<Longrightarrow> a = a'", "fix a"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>valid_edge prog a; targetnode a = (_Entry_)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a a'.\n       \\<lbrakk>valid_edge prog a; valid_edge prog a';\n        sourcenode a = sourcenode a'; targetnode a = targetnode a'\\<rbrakk>\n       \\<Longrightarrow> a = a'", "assume \"valid_edge prog a\" and \"targetnode a = (_Entry_)\""], ["proof (state)\nthis:\n  valid_edge prog a\n  targetnode a = (_Entry_)\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>valid_edge prog a; targetnode a = (_Entry_)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a a'.\n       \\<lbrakk>valid_edge prog a; valid_edge prog a';\n        sourcenode a = sourcenode a'; targetnode a = targetnode a'\\<rbrakk>\n       \\<Longrightarrow> a = a'", "obtain nx et nx' where \"a = (nx,et,nx')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>nx et nx'.\n        a = (nx, et, nx') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases a) auto"], ["proof (state)\nthis:\n  a = (nx, et, nx')\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>valid_edge prog a; targetnode a = (_Entry_)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a a'.\n       \\<lbrakk>valid_edge prog a; valid_edge prog a';\n        sourcenode a = sourcenode a'; targetnode a = targetnode a'\\<rbrakk>\n       \\<Longrightarrow> a = a'", "with \\<open>valid_edge prog a\\<close> \\<open>targetnode a = (_Entry_)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge prog a\n  targetnode a = (_Entry_)\n  a = (nx, et, nx')", "have \"prog \\<turnstile> nx -et\\<rightarrow> (_Entry_)\""], ["proof (prove)\nusing this:\n  valid_edge prog a\n  targetnode a = (_Entry_)\n  a = (nx, et, nx')\n\ngoal (1 subgoal):\n 1. prog \\<turnstile> nx -et\\<rightarrow> (_Entry_)", "by(simp add:valid_edge_def)"], ["proof (state)\nthis:\n  prog \\<turnstile> nx -et\\<rightarrow> (_Entry_)\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>valid_edge prog a; targetnode a = (_Entry_)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a a'.\n       \\<lbrakk>valid_edge prog a; valid_edge prog a';\n        sourcenode a = sourcenode a'; targetnode a = targetnode a'\\<rbrakk>\n       \\<Longrightarrow> a = a'", "thus False"], ["proof (prove)\nusing this:\n  prog \\<turnstile> nx -et\\<rightarrow> (_Entry_)\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>valid_edge prog a; valid_edge prog a';\n        sourcenode a = sourcenode a'; targetnode a = targetnode a'\\<rbrakk>\n       \\<Longrightarrow> a = a'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>valid_edge prog a; valid_edge prog a';\n        sourcenode a = sourcenode a'; targetnode a = targetnode a'\\<rbrakk>\n       \\<Longrightarrow> a = a'", "fix a a'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>valid_edge prog a; valid_edge prog a';\n        sourcenode a = sourcenode a'; targetnode a = targetnode a'\\<rbrakk>\n       \\<Longrightarrow> a = a'", "assume assms:\"valid_edge prog a\" \"valid_edge prog a'\"\n    \"sourcenode a = sourcenode a'\" \"targetnode a = targetnode a'\""], ["proof (state)\nthis:\n  valid_edge prog a\n  valid_edge prog a'\n  sourcenode a = sourcenode a'\n  targetnode a = targetnode a'\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>valid_edge prog a; valid_edge prog a';\n        sourcenode a = sourcenode a'; targetnode a = targetnode a'\\<rbrakk>\n       \\<Longrightarrow> a = a'", "obtain x et y where [simp]:\"a = (x,et,y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x et y.\n        a = (x, et, y) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases a) auto"], ["proof (state)\nthis:\n  a = (x, et, y)\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>valid_edge prog a; valid_edge prog a';\n        sourcenode a = sourcenode a'; targetnode a = targetnode a'\\<rbrakk>\n       \\<Longrightarrow> a = a'", "obtain x' et' y' where [simp]:\"a' = (x',et',y')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x' et' y'.\n        a' = (x', et', y') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases a') auto"], ["proof (state)\nthis:\n  a' = (x', et', y')\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>valid_edge prog a; valid_edge prog a';\n        sourcenode a = sourcenode a'; targetnode a = targetnode a'\\<rbrakk>\n       \\<Longrightarrow> a = a'", "from assms"], ["proof (chain)\npicking this:\n  valid_edge prog a\n  valid_edge prog a'\n  sourcenode a = sourcenode a'\n  targetnode a = targetnode a'", "have \"et = et'\""], ["proof (prove)\nusing this:\n  valid_edge prog a\n  valid_edge prog a'\n  sourcenode a = sourcenode a'\n  targetnode a = targetnode a'\n\ngoal (1 subgoal):\n 1. et = et'", "by(fastforce intro:WCFG_edge_det simp:valid_edge_def)"], ["proof (state)\nthis:\n  et = et'\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>valid_edge prog a; valid_edge prog a';\n        sourcenode a = sourcenode a'; targetnode a = targetnode a'\\<rbrakk>\n       \\<Longrightarrow> a = a'", "with \\<open>sourcenode a = sourcenode a'\\<close> \\<open>targetnode a = targetnode a'\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a = sourcenode a'\n  targetnode a = targetnode a'\n  et = et'", "show \"a = a'\""], ["proof (prove)\nusing this:\n  sourcenode a = sourcenode a'\n  targetnode a = targetnode a'\n  et = et'\n\ngoal (1 subgoal):\n 1. a = a'", "by simp"], ["proof (state)\nthis:\n  a = a'\n\ngoal:\nNo subgoals!", "qed"], ["", "interpretation While_CFG:\n  CFG sourcenode targetnode kind \"valid_edge prog\" Entry\n  for prog"], ["proof (prove)\ngoal (1 subgoal):\n 1. CFG sourcenode targetnode (valid_edge prog) (_Entry_)", "by(rule While_CFG_aux)"], ["", "lemma While_CFGExit_aux:\n  \"CFGExit sourcenode targetnode kind (valid_edge prog) Entry Exit\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CFGExit sourcenode targetnode kind (valid_edge prog) (_Entry_) (_Exit_)", "proof(unfold_locales)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>valid_edge prog a; sourcenode a = (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<exists>a.\n       valid_edge prog a \\<and>\n       sourcenode a = (_Entry_) \\<and>\n       targetnode a = (_Exit_) \\<and>\n       kind a = (\\<lambda>s. False)\\<^sub>\\<surd>", "fix a"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>valid_edge prog a; sourcenode a = (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<exists>a.\n       valid_edge prog a \\<and>\n       sourcenode a = (_Entry_) \\<and>\n       targetnode a = (_Exit_) \\<and>\n       kind a = (\\<lambda>s. False)\\<^sub>\\<surd>", "assume \"valid_edge prog a\" and \"sourcenode a = (_Exit_)\""], ["proof (state)\nthis:\n  valid_edge prog a\n  sourcenode a = (_Exit_)\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>valid_edge prog a; sourcenode a = (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<exists>a.\n       valid_edge prog a \\<and>\n       sourcenode a = (_Entry_) \\<and>\n       targetnode a = (_Exit_) \\<and>\n       kind a = (\\<lambda>s. False)\\<^sub>\\<surd>", "obtain nx et nx' where \"a = (nx,et,nx')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>nx et nx'.\n        a = (nx, et, nx') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases a) auto"], ["proof (state)\nthis:\n  a = (nx, et, nx')\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>valid_edge prog a; sourcenode a = (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<exists>a.\n       valid_edge prog a \\<and>\n       sourcenode a = (_Entry_) \\<and>\n       targetnode a = (_Exit_) \\<and>\n       kind a = (\\<lambda>s. False)\\<^sub>\\<surd>", "with \\<open>valid_edge prog a\\<close> \\<open>sourcenode a = (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge prog a\n  sourcenode a = (_Exit_)\n  a = (nx, et, nx')", "have \"prog \\<turnstile> (_Exit_) -et\\<rightarrow> nx'\""], ["proof (prove)\nusing this:\n  valid_edge prog a\n  sourcenode a = (_Exit_)\n  a = (nx, et, nx')\n\ngoal (1 subgoal):\n 1. prog \\<turnstile> (_Exit_) -et\\<rightarrow> nx'", "by(simp add:valid_edge_def)"], ["proof (state)\nthis:\n  prog \\<turnstile> (_Exit_) -et\\<rightarrow> nx'\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>valid_edge prog a; sourcenode a = (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<exists>a.\n       valid_edge prog a \\<and>\n       sourcenode a = (_Entry_) \\<and>\n       targetnode a = (_Exit_) \\<and>\n       kind a = (\\<lambda>s. False)\\<^sub>\\<surd>", "thus False"], ["proof (prove)\nusing this:\n  prog \\<turnstile> (_Exit_) -et\\<rightarrow> nx'\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>a.\n       valid_edge prog a \\<and>\n       sourcenode a = (_Entry_) \\<and>\n       targetnode a = (_Exit_) \\<and>\n       kind a = (\\<lambda>s. False)\\<^sub>\\<surd>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>a.\n       valid_edge prog a \\<and>\n       sourcenode a = (_Entry_) \\<and>\n       targetnode a = (_Exit_) \\<and>\n       kind a = (\\<lambda>s. False)\\<^sub>\\<surd>", "have \"prog \\<turnstile> (_Entry_) -(\\<lambda>s. False)\\<^sub>\\<surd>\\<rightarrow> (_Exit_)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prog \\<turnstile> (_Entry_) -(\\<lambda>s.\n                                     False)\\<^sub>\\<surd>\\<rightarrow> (_Exit_)", "by(rule WCFG_Entry_Exit)"], ["proof (state)\nthis:\n  prog \\<turnstile> (_Entry_) -(\\<lambda>s.\n                                   False)\\<^sub>\\<surd>\\<rightarrow> (_Exit_)\n\ngoal (1 subgoal):\n 1. \\<exists>a.\n       valid_edge prog a \\<and>\n       sourcenode a = (_Entry_) \\<and>\n       targetnode a = (_Exit_) \\<and>\n       kind a = (\\<lambda>s. False)\\<^sub>\\<surd>", "thus \"\\<exists>a. valid_edge prog a \\<and> sourcenode a = (_Entry_) \\<and>\n            targetnode a = (_Exit_) \\<and> kind a = (\\<lambda>s. False)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  prog \\<turnstile> (_Entry_) -(\\<lambda>s.\n                                   False)\\<^sub>\\<surd>\\<rightarrow> (_Exit_)\n\ngoal (1 subgoal):\n 1. \\<exists>a.\n       valid_edge prog a \\<and>\n       sourcenode a = (_Entry_) \\<and>\n       targetnode a = (_Exit_) \\<and>\n       kind a = (\\<lambda>s. False)\\<^sub>\\<surd>", "by(fastforce simp:valid_edge_def)"], ["proof (state)\nthis:\n  \\<exists>a.\n     valid_edge prog a \\<and>\n     sourcenode a = (_Entry_) \\<and>\n     targetnode a = (_Exit_) \\<and>\n     kind a = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["", "interpretation While_CFGExit:\n  CFGExit sourcenode targetnode kind \"valid_edge prog\" Entry Exit\n  for prog"], ["proof (prove)\ngoal (1 subgoal):\n 1. CFGExit sourcenode targetnode kind (valid_edge prog) (_Entry_) (_Exit_)", "by(rule While_CFGExit_aux)"], ["", "end"]]}