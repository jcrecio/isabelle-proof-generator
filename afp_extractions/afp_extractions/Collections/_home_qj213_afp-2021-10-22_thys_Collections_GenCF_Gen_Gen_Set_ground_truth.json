{"file_name": "/home/qj213/afp-2021-10-22/thys/Collections/GenCF/Gen/Gen_Set.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Collections", "problem_names": ["lemma foldli_union: \"det_fold_set X (\\<lambda>_. True) insert a ((\\<union>) a)\"", "lemma gen_union[autoref_rules_raw]:\n    assumes PRIO_TAG_GEN_ALGO\n    assumes INS: \"GEN_OP ins Set.insert (Rk\\<rightarrow>\\<langle>Rk\\<rangle>Rs2\\<rightarrow>\\<langle>Rk\\<rangle>Rs2)\"\n    assumes IT: \"SIDE_GEN_ALGO (is_set_to_list Rk Rs1 tsl)\"\n    shows \"(gen_union (\\<lambda>x. foldli (tsl x)) ins,(\\<union>)) \n    \\<in> (\\<langle>Rk\\<rangle>Rs1) \\<rightarrow> (\\<langle>Rk\\<rangle>Rs2) \\<rightarrow> (\\<langle>Rk\\<rangle>Rs2)\"", "lemma foldli_inter: \"det_fold_set X (\\<lambda>_. True) \n    (\\<lambda>x s. if x\\<in>a then insert x s else s) {} (\\<lambda>s. s\\<inter>a)\" \n    (is \"det_fold_set _ _ ?f _ _\")", "lemma gen_inter[autoref_rules_raw]:\n    assumes PRIO_TAG_GEN_ALGO\n    assumes IT: \"SIDE_GEN_ALGO (is_set_to_list Rk Rs1 tsl)\"\n    assumes MEMB:\n      \"GEN_OP memb2 (\\<in>) (Rk \\<rightarrow> \\<langle>Rk\\<rangle>Rs2 \\<rightarrow> Id)\"\n    assumes INS: \n      \"GEN_OP ins3 Set.insert (Rk\\<rightarrow>\\<langle>Rk\\<rangle>Rs3\\<rightarrow>\\<langle>Rk\\<rangle>Rs3)\"\n    assumes EMPTY: \n      \"GEN_OP empty3 {} (\\<langle>Rk\\<rangle>Rs3)\"\n    shows \"(gen_inter (\\<lambda>x. foldli (tsl x)) memb2 ins3 empty3,(\\<inter>)) \n    \\<in> (\\<langle>Rk\\<rangle>Rs1) \\<rightarrow> (\\<langle>Rk\\<rangle>Rs2) \\<rightarrow> (\\<langle>Rk\\<rangle>Rs3)\"", "lemma foldli_diff: \n    \"det_fold_set X (\\<lambda>_. True) (\\<lambda>x s. op_set_delete x s) s ((-) s)\"", "lemma gen_diff[autoref_rules_raw]:\n    assumes PRIO_TAG_GEN_ALGO\n    assumes DEL:\n      \"GEN_OP del1 op_set_delete (Rk \\<rightarrow> \\<langle>Rk\\<rangle>Rs1 \\<rightarrow> \\<langle>Rk\\<rangle>Rs1)\"\n    assumes IT: \"SIDE_GEN_ALGO (is_set_to_list Rk Rs2 it2)\"\n    shows \"(gen_diff del1 (\\<lambda>x. foldli (it2 x)),(-)) \n      \\<in> (\\<langle>Rk\\<rangle>Rs1) \\<rightarrow> (\\<langle>Rk\\<rangle>Rs2) \\<rightarrow> (\\<langle>Rk\\<rangle>Rs1)\"", "lemma foldli_ball_aux: \n    \"foldli l (\\<lambda>x. x) (\\<lambda>x _. P x) b \\<longleftrightarrow> b \\<and> Ball (set l) P\"", "lemma foldli_ball: \"det_fold_set X (\\<lambda>x. x) (\\<lambda>x _. P x) True (\\<lambda>s. Ball s P)\"", "lemma gen_ball[autoref_rules_raw]:\n    assumes PRIO_TAG_GEN_ALGO\n    assumes IT: \"SIDE_GEN_ALGO (is_set_to_list Rk Rs it)\"\n    shows \"(gen_ball (\\<lambda>x. foldli (it x)),Ball) \\<in> \\<langle>Rk\\<rangle>Rs \\<rightarrow> (Rk\\<rightarrow>Id) \\<rightarrow> Id\"", "lemma foldli_bex_aux: \"foldli l (\\<lambda>x. \\<not>x) (\\<lambda>x _. P x) b \\<longleftrightarrow> b \\<or> Bex (set l) P\"", "lemma foldli_bex: \"det_fold_set X (\\<lambda>x. \\<not>x) (\\<lambda>x _. P x) False (\\<lambda>s. Bex s P)\"", "lemma gen_bex[autoref_rules_raw]:\n    assumes PRIO_TAG_GEN_ALGO\n    assumes IT: \"SIDE_GEN_ALGO (is_set_to_list Rk Rs it)\"\n    shows \"(gen_bex (\\<lambda>x. foldli (it x)),Bex) \\<in> \\<langle>Rk\\<rangle>Rs \\<rightarrow> (Rk\\<rightarrow>Id) \\<rightarrow> Id\"", "lemma ball_subseteq:\n    \"(Ball s1 (\\<lambda>x. x\\<in>s2)) \\<longleftrightarrow> s1 \\<subseteq> s2\"", "lemma gen_subseteq[autoref_rules_raw]:\n    assumes PRIO_TAG_GEN_ALGO\n    assumes \"GEN_OP ball1 Ball (\\<langle>Rk\\<rangle>Rs1 \\<rightarrow> (Rk\\<rightarrow>Id) \\<rightarrow> Id)\"\n    assumes \"GEN_OP mem2 (\\<in>) (Rk \\<rightarrow> \\<langle>Rk\\<rangle>Rs2 \\<rightarrow> Id)\"\n    shows \"(gen_subseteq ball1 mem2,(\\<subseteq>)) \\<in> \\<langle>Rk\\<rangle>Rs1 \\<rightarrow> \\<langle>Rk\\<rangle>Rs2 \\<rightarrow> Id\"", "lemma gen_equal[autoref_rules_raw]:\n    assumes PRIO_TAG_GEN_ALGO\n    assumes \"GEN_OP ss1 (\\<subseteq>) (\\<langle>Rk\\<rangle>Rs1 \\<rightarrow> \\<langle>Rk\\<rangle>Rs2 \\<rightarrow> Id)\"\n    assumes \"GEN_OP ss2 (\\<subseteq>) (\\<langle>Rk\\<rangle>Rs2 \\<rightarrow> \\<langle>Rk\\<rangle>Rs1 \\<rightarrow> Id)\"\n    shows \"(gen_equal ss1 ss2, (=)) \\<in> \\<langle>Rk\\<rangle>Rs1 \\<rightarrow> \\<langle>Rk\\<rangle>Rs2 \\<rightarrow> Id\"", "lemma foldli_card_aux: \"distinct l \\<Longrightarrow> foldli l (\\<lambda>_. True) \n    (\\<lambda>_ n. Suc n) n = n + card (set l)\"", "lemma foldli_card: \"det_fold_set X (\\<lambda>_. True) (\\<lambda>_ n. Suc n) 0 card\"", "lemma gen_card[autoref_rules_raw]:\n    assumes PRIO_TAG_GEN_ALGO\n    assumes IT: \"SIDE_GEN_ALGO (is_set_to_list Rk Rs it)\"\n    shows \"(gen_card (\\<lambda>x. foldli (it x)),card) \\<in> \\<langle>Rk\\<rangle>Rs \\<rightarrow> Id\"", "lemma fold_set: \"fold Set.insert l s = s \\<union> set l\"", "lemma gen_set[autoref_rules_raw]: \n    assumes PRIO_TAG_GEN_ALGO\n    assumes EMPTY: \n      \"GEN_OP emp {} (\\<langle>Rk\\<rangle>Rs)\"\n    assumes INS: \n      \"GEN_OP ins Set.insert (Rk\\<rightarrow>\\<langle>Rk\\<rangle>Rs\\<rightarrow>\\<langle>Rk\\<rangle>Rs)\"\n    shows \"(gen_set emp ins,set)\\<in>\\<langle>Rk\\<rangle>list_rel\\<rightarrow>\\<langle>Rk\\<rangle>Rs\"", "lemma ball_isEmpty: \"op_set_isEmpty s = (\\<forall>x\\<in>s. False)\"", "lemma gen_isEmpty[autoref_rules_raw]:\n    assumes PRIO_TAG_GEN_ALGO\n    assumes \"GEN_OP ball Ball (\\<langle>Rk\\<rangle>Rs \\<rightarrow> (Rk\\<rightarrow>Id) \\<rightarrow> Id)\"\n    shows \"(gen_isEmpty ball,op_set_isEmpty) \\<in> \\<langle>Rk\\<rangle>Rs \\<rightarrow> Id\"", "lemma foldli_size_abort_aux:\n    \"\\<lbrakk>n0\\<le>m; distinct l\\<rbrakk> \\<Longrightarrow> \n      foldli l (\\<lambda>n. n<m) (\\<lambda>_ n. Suc n) n0 = min m (n0 + card (set l))\"", "lemma foldli_size_abort: \"\n    det_fold_set X (\\<lambda>n. n<m) (\\<lambda>_ n. Suc n) 0 (op_set_size_abort m)\"", "lemma gen_size_abort[autoref_rules_raw]:\n    assumes PRIO_TAG_GEN_ALGO\n    assumes IT: \"SIDE_GEN_ALGO (is_set_to_list Rk Rs it)\"\n    shows \"(gen_size_abort (\\<lambda>x. foldli (it x)),op_set_size_abort) \n    \\<in> Id \\<rightarrow> \\<langle>Rk\\<rangle>Rs \\<rightarrow> Id\"", "lemma size_abort_isSng: \"op_set_isSng s \\<longleftrightarrow> op_set_size_abort 2 s = 1\"", "lemma gen_isSng[autoref_rules_raw]:\n    assumes PRIO_TAG_GEN_ALGO\n    assumes \"GEN_OP sizea op_set_size_abort (Id \\<rightarrow> (\\<langle>Rk\\<rangle>Rs) \\<rightarrow> Id)\"\n    shows \"(gen_isSng sizea,op_set_isSng) \\<in> \\<langle>Rk\\<rangle>Rs \\<rightarrow> Id\"", "lemma foldli_disjoint_aux:\n    \"foldli l1 (\\<lambda>x. x) (\\<lambda>x _. \\<not>x\\<in>s2) b \\<longleftrightarrow> b \\<and> op_set_disjoint (set l1) s2\"", "lemma foldli_disjoint: \n    \"det_fold_set X (\\<lambda>x. x) (\\<lambda>x _. \\<not>x\\<in>s2) True (\\<lambda>s1. op_set_disjoint s1 s2)\"", "lemma gen_disjoint[autoref_rules_raw]:\n    assumes PRIO_TAG_GEN_ALGO\n    assumes IT: \"SIDE_GEN_ALGO (is_set_to_list Rk Rs1 it1)\"\n    assumes MEM: \"GEN_OP mem2 (\\<in>) (Rk \\<rightarrow> \\<langle>Rk\\<rangle>Rs2 \\<rightarrow> Id)\"\n    shows \"(gen_disjoint (\\<lambda>x. foldli (it1 x)) mem2,op_set_disjoint) \n    \\<in> \\<langle>Rk\\<rangle>Rs1 \\<rightarrow> \\<langle>Rk\\<rangle>Rs2 \\<rightarrow> Id\"", "lemma foldli_filter_aux:\n    \"foldli l (\\<lambda>_. True) (\\<lambda>x s. if P x then insert x s else s) s0 \n    = s0 \\<union> op_set_filter P (set l)\"", "lemma foldli_filter: \n    \"det_fold_set X (\\<lambda>_. True) (\\<lambda>x s. if P x then insert x s else s) {} \n      (op_set_filter P)\"", "lemma gen_filter[autoref_rules_raw]:\n    assumes PRIO_TAG_GEN_ALGO\n    assumes IT: \"SIDE_GEN_ALGO (is_set_to_list Rk Rs1 it1)\"\n    assumes INS: \n      \"GEN_OP ins2 Set.insert (Rk\\<rightarrow>\\<langle>Rk\\<rangle>Rs2\\<rightarrow>\\<langle>Rk\\<rangle>Rs2)\"\n    assumes EMPTY: \n      \"GEN_OP empty2 {} (\\<langle>Rk\\<rangle>Rs2)\"\n    shows \"(gen_filter (\\<lambda>x. foldli (it1 x)) empty2 ins2,op_set_filter) \n    \\<in> (Rk\\<rightarrow>Id) \\<rightarrow> (\\<langle>Rk\\<rangle>Rs1) \\<rightarrow> (\\<langle>Rk\\<rangle>Rs2)\"", "lemma foldli_image_aux:\n    \"foldli l (\\<lambda>_. True) (\\<lambda>x s. insert (f x) s) s0\n    = s0 \\<union> f`(set l)\"", "lemma foldli_image: \n    \"det_fold_set X (\\<lambda>_. True) (\\<lambda>x s. insert (f x) s) {} \n      ((`) f)\"", "lemma gen_image[autoref_rules_raw]:\n    assumes PRIO_TAG_GEN_ALGO\n    assumes IT: \"SIDE_GEN_ALGO (is_set_to_list Rk Rs1 it1)\"\n    assumes INS: \n      \"GEN_OP ins2 Set.insert (Rk'\\<rightarrow>\\<langle>Rk'\\<rangle>Rs2\\<rightarrow>\\<langle>Rk'\\<rangle>Rs2)\"\n    assumes EMPTY: \n      \"GEN_OP empty2 {} (\\<langle>Rk'\\<rangle>Rs2)\"\n    shows \"(gen_image (\\<lambda>x. foldli (it1 x)) empty2 ins2,(`)) \n    \\<in> (Rk\\<rightarrow>Rk') \\<rightarrow> (\\<langle>Rk\\<rangle>Rs1) \\<rightarrow> (\\<langle>Rk'\\<rangle>Rs2)\"", "lemma foldli_pick:\n    assumes \"l\\<noteq>[]\" \n    obtains x where \"x\\<in>set l\" \n    and \"(foldli l (case_option True (\\<lambda>_. False)) (\\<lambda>x _. Some x) None) = Some x\"", "lemma gen_pick[autoref_rules_raw]:\n    assumes PRIO_TAG_GEN_ALGO\n    assumes IT: \"SIDE_GEN_ALGO (is_set_to_list Rk Rs it)\"\n    assumes NE: \"SIDE_PRECOND (s'\\<noteq>{})\"\n    assumes SREF: \"(s,s')\\<in>\\<langle>Rk\\<rangle>Rs\"\n    shows \"(RETURN (gen_pick (\\<lambda>x. foldli (it x)) s), \n      (OP op_set_pick ::: \\<langle>Rk\\<rangle>Rs\\<rightarrow>\\<langle>Rk\\<rangle>nres_rel)$s')\\<in>\\<langle>Rk\\<rangle>nres_rel\"", "lemma foldli_Sigma_aux:\n    fixes s :: \"'s1_impl\" and s':: \"'k set\"\n    fixes f :: \"'k_impl \\<Rightarrow> 's2_impl\" and f':: \"'k \\<Rightarrow> 'l set\"\n    fixes s0 :: \"'kl_impl\" and s0' :: \"('k\\<times>'l) set\"\n    assumes IT1: \"is_set_to_list Rk Rs1 it1\"\n    assumes IT2: \"is_set_to_list Rl Rs2 it2\"\n    assumes INS: \n      \"(insX, Set.insert) \\<in> \n        (\\<langle>Rk,Rl\\<rangle>prod_rel\\<rightarrow>\\<langle>\\<langle>Rk,Rl\\<rangle>prod_rel\\<rangle>Rs3\\<rightarrow>\\<langle>\\<langle>Rk,Rl\\<rangle>prod_rel\\<rangle>Rs3)\"\n    assumes S0R: \"(s0, s0') \\<in> \\<langle>\\<langle>Rk,Rl\\<rangle>prod_rel\\<rangle>Rs3\" \n    assumes SR: \"(s, s') \\<in> \\<langle>Rk\\<rangle>Rs1\" \n    assumes FR: \"(f, f') \\<in> Rk \\<rightarrow> \\<langle>Rl\\<rangle>Rs2\"\n    shows \"(foldli (it1 s) (\\<lambda>_. True) (\\<lambda>x s. \n        foldli (it2 (f x)) (\\<lambda>_. True) (\\<lambda>y s. insX (x,y) s) s\n      ) s0,s0' \\<union> Sigma s' f') \n      \\<in> \\<langle>\\<langle>Rk,Rl\\<rangle>prod_rel\\<rangle>Rs3\"", "lemma gen_Sigma[autoref_rules_raw]:\n    assumes PRIO_TAG_GEN_ALGO\n    assumes IT1: \"SIDE_GEN_ALGO (is_set_to_list Rk Rs1 it1)\"\n    assumes IT2: \"SIDE_GEN_ALGO (is_set_to_list Rl Rs2 it2)\"\n    assumes EMPTY: \n      \"GEN_OP empX {} (\\<langle>\\<langle>Rk,Rl\\<rangle>prod_rel\\<rangle>Rs3)\"\n    assumes INS: \n      \"GEN_OP insX Set.insert \n         (\\<langle>Rk,Rl\\<rangle>prod_rel\\<rightarrow>\\<langle>\\<langle>Rk,Rl\\<rangle>prod_rel\\<rangle>Rs3\\<rightarrow>\\<langle>\\<langle>Rk,Rl\\<rangle>prod_rel\\<rangle>Rs3)\"\n    shows \"(gen_Sigma (\\<lambda>x. foldli (it1 x)) (\\<lambda>x. foldli (it2 x)) empX insX,Sigma) \n      \\<in> (\\<langle>Rk\\<rangle>Rs1) \\<rightarrow> (Rk \\<rightarrow> \\<langle>Rl\\<rangle>Rs2) \\<rightarrow> \\<langle>\\<langle>Rk,Rl\\<rangle>prod_rel\\<rangle>Rs3\"", "lemma gen_cart:\n  assumes PRIO_TAG_GEN_ALGO\n  assumes [param]: \"(sigma, Sigma) \\<in> (\\<langle>Rx\\<rangle>Rsx \\<rightarrow> (Rx \\<rightarrow> \\<langle>Ry\\<rangle>Rsy) \\<rightarrow> \\<langle>Rx \\<times>\\<^sub>r Ry\\<rangle>Rsp)\"\n  shows \"(\\<lambda>x y. sigma x (\\<lambda>_. y), op_set_cart) \\<in> \\<langle>Rx\\<rangle>Rsx \\<rightarrow> \\<langle>Ry\\<rangle>Rsy \\<rightarrow> \\<langle>Rx \\<times>\\<^sub>r Ry\\<rangle>Rsp\"", "lemmas [autoref_rules] = gen_cart[OF _ GEN_OP_D]", "lemma op_set_to_sorted_list_autoref[autoref_rules]:\n    assumes \"SIDE_GEN_ALGO (is_set_to_sorted_list ordR Rk Rs tsl)\"\n    shows \"(\\<lambda>si. RETURN (tsl si),  OP (op_set_to_sorted_list ordR)) \n      \\<in> \\<langle>Rk\\<rangle>Rs \\<rightarrow> \\<langle>\\<langle>Rk\\<rangle>list_rel\\<rangle>nres_rel\"", "lemma op_set_to_list_autoref[autoref_rules]:\n    assumes \"SIDE_GEN_ALGO (is_set_to_sorted_list ordR Rk Rs tsl)\"\n    shows \"(\\<lambda>si. RETURN (tsl si), op_set_to_list) \n      \\<in> \\<langle>Rk\\<rangle>Rs \\<rightarrow> \\<langle>\\<langle>Rk\\<rangle>list_rel\\<rangle>nres_rel\"", "lemma foldli_Union: \"det_fold_set X (\\<lambda>_. True) (\\<union>) {} Union\"", "lemma gen_Union[autoref_rules_raw]:\n  assumes PRIO_TAG_GEN_ALGO\n  assumes EMP: \"GEN_OP emp {} (\\<langle>Rk\\<rangle>Rs3)\"\n  assumes UN: \"GEN_OP un (\\<union>) (\\<langle>Rk\\<rangle>Rs2\\<rightarrow>\\<langle>Rk\\<rangle>Rs3\\<rightarrow>\\<langle>Rk\\<rangle>Rs3)\"\n  assumes IT: \"SIDE_GEN_ALGO (is_set_to_list (\\<langle>Rk\\<rangle>Rs2) Rs1 tsl)\"\n  shows \"(gen_Union (\\<lambda>x. foldli (tsl x)) emp un,Union) \\<in> \\<langle>\\<langle>Rk\\<rangle>Rs2\\<rangle>Rs1 \\<rightarrow> \\<langle>Rk\\<rangle>Rs3\"", "lemma atLeastLessThan_impl_correct: \n  \"atLeastLessThan_impl a b \\<le> SPEC (\\<lambda>r. r = {a..<b::nat})\"", "lemma atLeastLessThan_gen[autoref_rules]: \n  assumes \"PRIO_TAG_GEN_ALGO\"\n  assumes \"GEN_OP emp {} Rs\"\n  assumes \"GEN_OP ins insert (nat_rel \\<rightarrow> Rs \\<rightarrow> Rs)\"\n  shows \"(atLeastLessThan_tr emp ins, atLeastLessThan) \n    \\<in> nat_rel \\<rightarrow> nat_rel \\<rightarrow> Rs\""], "translations": [["", "lemma foldli_union: \"det_fold_set X (\\<lambda>_. True) insert a ((\\<union>) a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det_fold_set X (\\<lambda>_. True) insert a ((\\<union>) a)", "proof (rule, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>distinct l; sorted_wrt X l\\<rbrakk>\n       \\<Longrightarrow> foldli l (\\<lambda>_. True) insert a =\n                         a \\<union> set l", "case (1 l)"], ["proof (state)\nthis:\n  distinct l\n  sorted_wrt X l\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>distinct l; sorted_wrt X l\\<rbrakk>\n       \\<Longrightarrow> foldli l (\\<lambda>_. True) insert a =\n                         a \\<union> set l", "thus ?case"], ["proof (prove)\nusing this:\n  distinct l\n  sorted_wrt X l\n\ngoal (1 subgoal):\n 1. foldli l (\\<lambda>_. True) insert a = a \\<union> set l", "by (induct l arbitrary: a) auto"], ["proof (state)\nthis:\n  foldli l (\\<lambda>_. True) insert a = a \\<union> set l\n\ngoal:\nNo subgoals!", "qed"], ["", "definition gen_union\n    :: \"_ \\<Rightarrow> ('k \\<Rightarrow> 's2 \\<Rightarrow> 's2) \n        \\<Rightarrow> 's1 \\<Rightarrow> 's2 \\<Rightarrow> 's2\"\n    where \n    \"gen_union it ins A B \\<equiv> it A (\\<lambda>_. True) ins B\""], ["", "lemma gen_union[autoref_rules_raw]:\n    assumes PRIO_TAG_GEN_ALGO\n    assumes INS: \"GEN_OP ins Set.insert (Rk\\<rightarrow>\\<langle>Rk\\<rangle>Rs2\\<rightarrow>\\<langle>Rk\\<rangle>Rs2)\"\n    assumes IT: \"SIDE_GEN_ALGO (is_set_to_list Rk Rs1 tsl)\"\n    shows \"(gen_union (\\<lambda>x. foldli (tsl x)) ins,(\\<union>)) \n    \\<in> (\\<langle>Rk\\<rangle>Rs1) \\<rightarrow> (\\<langle>Rk\\<rangle>Rs2) \\<rightarrow> (\\<langle>Rk\\<rangle>Rs2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gen_union (\\<lambda>x. foldli (tsl x)) ins, (\\<union>))\n    \\<in> \\<langle>Rk\\<rangle>Rs1 \\<rightarrow>\n          \\<langle>Rk\\<rangle>Rs2 \\<rightarrow> \\<langle>Rk\\<rangle>Rs2", "apply (intro fun_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (gen_union (\\<lambda>x. foldli (tsl x)) ins a aa,\n                          a' \\<union> a'a)\n                         \\<in> \\<langle>Rk\\<rangle>Rs2", "apply (subst Un_commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (gen_union (\\<lambda>x. foldli (tsl x)) ins a aa,\n                          a'a \\<union> a')\n                         \\<in> \\<langle>Rk\\<rangle>Rs2", "unfolding gen_union_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (foldli (tsl a) (\\<lambda>_. True) ins aa,\n                          a'a \\<union> a')\n                         \\<in> \\<langle>Rk\\<rangle>Rs2", "apply (rule det_fold_set[OF \n      foldli_union IT[unfolded autoref_tag_defs]])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (a, a') \\<in> \\<langle>Rk\\<rangle>Rs1\n 2. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>_. True, \\<lambda>_. True)\n                         \\<in> \\<langle>Rk\\<rangle>Rs2 \\<rightarrow>\n                               bool_rel\n 3. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (ins, insert)\n                         \\<in> Rk \\<rightarrow>\n                               \\<langle>Rk\\<rangle>Rs2 \\<rightarrow>\n                               \\<langle>Rk\\<rangle>Rs2\n 4. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2", "using INS"], ["proof (prove)\nusing this:\n  GEN_OP ins insert\n   (Rk \\<rightarrow>\n    \\<langle>Rk\\<rangle>Rs2 \\<rightarrow> \\<langle>Rk\\<rangle>Rs2)\n\ngoal (4 subgoals):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (a, a') \\<in> \\<langle>Rk\\<rangle>Rs1\n 2. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>_. True, \\<lambda>_. True)\n                         \\<in> \\<langle>Rk\\<rangle>Rs2 \\<rightarrow>\n                               bool_rel\n 3. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (ins, insert)\n                         \\<in> Rk \\<rightarrow>\n                               \\<langle>Rk\\<rangle>Rs2 \\<rightarrow>\n                               \\<langle>Rk\\<rangle>Rs2\n 4. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2", "unfolding autoref_tag_defs"], ["proof (prove)\nusing this:\n  (ins, insert)\n  \\<in> Rk \\<rightarrow>\n        \\<langle>Rk\\<rangle>Rs2 \\<rightarrow> \\<langle>Rk\\<rangle>Rs2\n\ngoal (4 subgoals):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (a, a') \\<in> \\<langle>Rk\\<rangle>Rs1\n 2. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>_. True, \\<lambda>_. True)\n                         \\<in> \\<langle>Rk\\<rangle>Rs2 \\<rightarrow>\n                               bool_rel\n 3. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (ins, insert)\n                         \\<in> Rk \\<rightarrow>\n                               \\<langle>Rk\\<rangle>Rs2 \\<rightarrow>\n                               \\<langle>Rk\\<rangle>Rs2\n 4. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2", "apply (parametricity)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma foldli_inter: \"det_fold_set X (\\<lambda>_. True) \n    (\\<lambda>x s. if x\\<in>a then insert x s else s) {} (\\<lambda>s. s\\<inter>a)\" \n    (is \"det_fold_set _ _ ?f _ _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. det_fold_set X (\\<lambda>_. True)\n     (\\<lambda>x s. if x \\<in> a then insert x s else s) {}\n     (\\<lambda>s. s \\<inter> a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. det_fold_set X (\\<lambda>_. True)\n     (\\<lambda>x s. if x \\<in> a then insert x s else s) {}\n     (\\<lambda>s. s \\<inter> a)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. det_fold_set X (\\<lambda>_. True)\n     (\\<lambda>x s. if x \\<in> a then insert x s else s) {}\n     (\\<lambda>s. s \\<inter> a)", "fix l s0"], ["proof (state)\ngoal (1 subgoal):\n 1. det_fold_set X (\\<lambda>_. True)\n     (\\<lambda>x s. if x \\<in> a then insert x s else s) {}\n     (\\<lambda>s. s \\<inter> a)", "have \"foldli l (\\<lambda>_. True) \n        (\\<lambda>x s. if x\\<in>a then insert x s else s) s0 = s0 \\<union> (set l \\<inter> a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli l (\\<lambda>_. True)\n     (\\<lambda>x s. if x \\<in> a then insert x s else s) s0 =\n    s0 \\<union> set l \\<inter> a", "by (induct l arbitrary: s0) auto"], ["proof (state)\nthis:\n  foldli l (\\<lambda>_. True)\n   (\\<lambda>x s. if x \\<in> a then insert x s else s) s0 =\n  s0 \\<union> set l \\<inter> a\n\ngoal (1 subgoal):\n 1. det_fold_set X (\\<lambda>_. True)\n     (\\<lambda>x s. if x \\<in> a then insert x s else s) {}\n     (\\<lambda>s. s \\<inter> a)", "}"], ["proof (state)\nthis:\n  foldli ?l2 (\\<lambda>_. True)\n   (\\<lambda>x s. if x \\<in> a then insert x s else s) ?s0.2 =\n  ?s0.2 \\<union> set ?l2 \\<inter> a\n\ngoal (1 subgoal):\n 1. det_fold_set X (\\<lambda>_. True)\n     (\\<lambda>x s. if x \\<in> a then insert x s else s) {}\n     (\\<lambda>s. s \\<inter> a)", "from this[of _ \"{}\"]"], ["proof (chain)\npicking this:\n  foldli ?l2 (\\<lambda>_. True)\n   (\\<lambda>x s. if x \\<in> a then insert x s else s) {} =\n  {} \\<union> set ?l2 \\<inter> a", "show ?thesis"], ["proof (prove)\nusing this:\n  foldli ?l2 (\\<lambda>_. True)\n   (\\<lambda>x s. if x \\<in> a then insert x s else s) {} =\n  {} \\<union> set ?l2 \\<inter> a\n\ngoal (1 subgoal):\n 1. det_fold_set X (\\<lambda>_. True)\n     (\\<lambda>x s. if x \\<in> a then insert x s else s) {}\n     (\\<lambda>s. s \\<inter> a)", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l.\n        foldli l (\\<lambda>_. True)\n         (\\<lambda>x s. if x \\<in> a then insert x s else s) {} =\n        {} \\<union> set l \\<inter> a) \\<Longrightarrow>\n    det_fold_set X (\\<lambda>_. True)\n     (\\<lambda>x s. if x \\<in> a then insert x s else s) {}\n     (\\<lambda>s. s \\<inter> a)", "by rule simp"], ["proof (state)\nthis:\n  det_fold_set X (\\<lambda>_. True)\n   (\\<lambda>x s. if x \\<in> a then insert x s else s) {}\n   (\\<lambda>s. s \\<inter> a)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition gen_inter :: \"_ \\<Rightarrow> \n    ('k \\<Rightarrow> 's2 \\<Rightarrow> bool) \\<Rightarrow> _\"\n    where \"gen_inter it1 memb2 ins3 empty3 s1 s2 \n    \\<equiv> it1 s1 (\\<lambda>_. True) \n      (\\<lambda>x s. if memb2 x s2 then ins3 x s else s) empty3\""], ["", "lemma gen_inter[autoref_rules_raw]:\n    assumes PRIO_TAG_GEN_ALGO\n    assumes IT: \"SIDE_GEN_ALGO (is_set_to_list Rk Rs1 tsl)\"\n    assumes MEMB:\n      \"GEN_OP memb2 (\\<in>) (Rk \\<rightarrow> \\<langle>Rk\\<rangle>Rs2 \\<rightarrow> Id)\"\n    assumes INS: \n      \"GEN_OP ins3 Set.insert (Rk\\<rightarrow>\\<langle>Rk\\<rangle>Rs3\\<rightarrow>\\<langle>Rk\\<rangle>Rs3)\"\n    assumes EMPTY: \n      \"GEN_OP empty3 {} (\\<langle>Rk\\<rangle>Rs3)\"\n    shows \"(gen_inter (\\<lambda>x. foldli (tsl x)) memb2 ins3 empty3,(\\<inter>)) \n    \\<in> (\\<langle>Rk\\<rangle>Rs1) \\<rightarrow> (\\<langle>Rk\\<rangle>Rs2) \\<rightarrow> (\\<langle>Rk\\<rangle>Rs3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gen_inter (\\<lambda>x. foldli (tsl x)) memb2 ins3 empty3, (\\<inter>))\n    \\<in> \\<langle>Rk\\<rangle>Rs1 \\<rightarrow>\n          \\<langle>Rk\\<rangle>Rs2 \\<rightarrow> \\<langle>Rk\\<rangle>Rs3", "apply (intro fun_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (gen_inter (\\<lambda>x. foldli (tsl x)) memb2 ins3\n                           empty3 a aa,\n                          a' \\<inter> a'a)\n                         \\<in> \\<langle>Rk\\<rangle>Rs3", "unfolding gen_inter_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (foldli (tsl a) (\\<lambda>_. True)\n                           (\\<lambda>x s.\n                               if memb2 x aa then ins3 x s else s)\n                           empty3,\n                          a' \\<inter> a'a)\n                         \\<in> \\<langle>Rk\\<rangle>Rs3", "apply (rule det_fold_set[OF foldli_inter IT[unfolded autoref_tag_defs]])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (a, a') \\<in> \\<langle>Rk\\<rangle>Rs1\n 2. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>_. True, \\<lambda>_. True)\n                         \\<in> \\<langle>Rk\\<rangle>Rs3 \\<rightarrow>\n                               bool_rel\n 3. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x s. if memb2 x aa then ins3 x s else s,\n                          \\<lambda>x s.\n                             if x \\<in> a'a then insert x s else s)\n                         \\<in> Rk \\<rightarrow>\n                               \\<langle>Rk\\<rangle>Rs3 \\<rightarrow>\n                               \\<langle>Rk\\<rangle>Rs3\n 4. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (empty3, {}) \\<in> \\<langle>Rk\\<rangle>Rs3", "using MEMB INS EMPTY"], ["proof (prove)\nusing this:\n  GEN_OP memb2 (\\<in>)\n   (Rk \\<rightarrow> \\<langle>Rk\\<rangle>Rs2 \\<rightarrow> bool_rel)\n  GEN_OP ins3 insert\n   (Rk \\<rightarrow>\n    \\<langle>Rk\\<rangle>Rs3 \\<rightarrow> \\<langle>Rk\\<rangle>Rs3)\n  GEN_OP empty3 {} (\\<langle>Rk\\<rangle>Rs3)\n\ngoal (4 subgoals):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (a, a') \\<in> \\<langle>Rk\\<rangle>Rs1\n 2. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>_. True, \\<lambda>_. True)\n                         \\<in> \\<langle>Rk\\<rangle>Rs3 \\<rightarrow>\n                               bool_rel\n 3. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x s. if memb2 x aa then ins3 x s else s,\n                          \\<lambda>x s.\n                             if x \\<in> a'a then insert x s else s)\n                         \\<in> Rk \\<rightarrow>\n                               \\<langle>Rk\\<rangle>Rs3 \\<rightarrow>\n                               \\<langle>Rk\\<rangle>Rs3\n 4. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (empty3, {}) \\<in> \\<langle>Rk\\<rangle>Rs3", "unfolding autoref_tag_defs"], ["proof (prove)\nusing this:\n  (memb2, (\\<in>))\n  \\<in> Rk \\<rightarrow> \\<langle>Rk\\<rangle>Rs2 \\<rightarrow> bool_rel\n  (ins3, insert)\n  \\<in> Rk \\<rightarrow>\n        \\<langle>Rk\\<rangle>Rs3 \\<rightarrow> \\<langle>Rk\\<rangle>Rs3\n  (empty3, {}) \\<in> \\<langle>Rk\\<rangle>Rs3\n\ngoal (4 subgoals):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (a, a') \\<in> \\<langle>Rk\\<rangle>Rs1\n 2. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>_. True, \\<lambda>_. True)\n                         \\<in> \\<langle>Rk\\<rangle>Rs3 \\<rightarrow>\n                               bool_rel\n 3. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x s. if memb2 x aa then ins3 x s else s,\n                          \\<lambda>x s.\n                             if x \\<in> a'a then insert x s else s)\n                         \\<in> Rk \\<rightarrow>\n                               \\<langle>Rk\\<rangle>Rs3 \\<rightarrow>\n                               \\<langle>Rk\\<rangle>Rs3\n 4. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (empty3, {}) \\<in> \\<langle>Rk\\<rangle>Rs3", "apply (parametricity)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma foldli_diff: \n    \"det_fold_set X (\\<lambda>_. True) (\\<lambda>x s. op_set_delete x s) s ((-) s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det_fold_set X (\\<lambda>_. True) op_set_delete s ((-) s)", "proof (rule, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>distinct l; sorted_wrt X l\\<rbrakk>\n       \\<Longrightarrow> foldli l (\\<lambda>_. True) op_set_delete s =\n                         s - set l", "case (1 l)"], ["proof (state)\nthis:\n  distinct l\n  sorted_wrt X l\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>distinct l; sorted_wrt X l\\<rbrakk>\n       \\<Longrightarrow> foldli l (\\<lambda>_. True) op_set_delete s =\n                         s - set l", "thus ?case"], ["proof (prove)\nusing this:\n  distinct l\n  sorted_wrt X l\n\ngoal (1 subgoal):\n 1. foldli l (\\<lambda>_. True) op_set_delete s = s - set l", "by (induct l arbitrary: s) auto"], ["proof (state)\nthis:\n  foldli l (\\<lambda>_. True) op_set_delete s = s - set l\n\ngoal:\nNo subgoals!", "qed"], ["", "definition gen_diff :: \"('k\\<Rightarrow>'s1\\<Rightarrow>'s1) \\<Rightarrow> _ \\<Rightarrow> 's2 \\<Rightarrow> _ \"\n    where \"gen_diff del1 it2 s1 s2 \n    \\<equiv> it2 s2 (\\<lambda>_. True) (\\<lambda>x s. del1 x s) s1\""], ["", "lemma gen_diff[autoref_rules_raw]:\n    assumes PRIO_TAG_GEN_ALGO\n    assumes DEL:\n      \"GEN_OP del1 op_set_delete (Rk \\<rightarrow> \\<langle>Rk\\<rangle>Rs1 \\<rightarrow> \\<langle>Rk\\<rangle>Rs1)\"\n    assumes IT: \"SIDE_GEN_ALGO (is_set_to_list Rk Rs2 it2)\"\n    shows \"(gen_diff del1 (\\<lambda>x. foldli (it2 x)),(-)) \n      \\<in> (\\<langle>Rk\\<rangle>Rs1) \\<rightarrow> (\\<langle>Rk\\<rangle>Rs2) \\<rightarrow> (\\<langle>Rk\\<rangle>Rs1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gen_diff del1 (\\<lambda>x. foldli (it2 x)), (-))\n    \\<in> \\<langle>Rk\\<rangle>Rs1 \\<rightarrow>\n          \\<langle>Rk\\<rangle>Rs2 \\<rightarrow> \\<langle>Rk\\<rangle>Rs1", "apply (intro fun_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (gen_diff del1 (\\<lambda>x. foldli (it2 x)) a aa,\n                          a' - a'a)\n                         \\<in> \\<langle>Rk\\<rangle>Rs1", "unfolding gen_diff_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (foldli (it2 aa) (\\<lambda>_. True) del1 a,\n                          a' - a'a)\n                         \\<in> \\<langle>Rk\\<rangle>Rs1", "apply (rule det_fold_set[OF foldli_diff IT[unfolded autoref_tag_defs]])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2\n 2. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>_. True, \\<lambda>_. True)\n                         \\<in> \\<langle>Rk\\<rangle>Rs1 \\<rightarrow>\n                               bool_rel\n 3. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (del1, op_set_delete)\n                         \\<in> Rk \\<rightarrow>\n                               \\<langle>Rk\\<rangle>Rs1 \\<rightarrow>\n                               \\<langle>Rk\\<rangle>Rs1\n 4. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (a, a') \\<in> \\<langle>Rk\\<rangle>Rs1", "using DEL"], ["proof (prove)\nusing this:\n  GEN_OP del1 op_set_delete\n   (Rk \\<rightarrow>\n    \\<langle>Rk\\<rangle>Rs1 \\<rightarrow> \\<langle>Rk\\<rangle>Rs1)\n\ngoal (4 subgoals):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2\n 2. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>_. True, \\<lambda>_. True)\n                         \\<in> \\<langle>Rk\\<rangle>Rs1 \\<rightarrow>\n                               bool_rel\n 3. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (del1, op_set_delete)\n                         \\<in> Rk \\<rightarrow>\n                               \\<langle>Rk\\<rangle>Rs1 \\<rightarrow>\n                               \\<langle>Rk\\<rangle>Rs1\n 4. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (a, a') \\<in> \\<langle>Rk\\<rangle>Rs1", "unfolding autoref_tag_defs"], ["proof (prove)\nusing this:\n  (del1, op_set_delete)\n  \\<in> Rk \\<rightarrow>\n        \\<langle>Rk\\<rangle>Rs1 \\<rightarrow> \\<langle>Rk\\<rangle>Rs1\n\ngoal (4 subgoals):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2\n 2. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>_. True, \\<lambda>_. True)\n                         \\<in> \\<langle>Rk\\<rangle>Rs1 \\<rightarrow>\n                               bool_rel\n 3. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (del1, op_set_delete)\n                         \\<in> Rk \\<rightarrow>\n                               \\<langle>Rk\\<rangle>Rs1 \\<rightarrow>\n                               \\<langle>Rk\\<rangle>Rs1\n 4. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (a, a') \\<in> \\<langle>Rk\\<rangle>Rs1", "apply (parametricity)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma foldli_ball_aux: \n    \"foldli l (\\<lambda>x. x) (\\<lambda>x _. P x) b \\<longleftrightarrow> b \\<and> Ball (set l) P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli l (\\<lambda>x. x) (\\<lambda>x _. P x) b =\n    (b \\<and> Ball (set l) P)", "by (induct l arbitrary: b) auto"], ["", "lemma foldli_ball: \"det_fold_set X (\\<lambda>x. x) (\\<lambda>x _. P x) True (\\<lambda>s. Ball s P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det_fold_set X (\\<lambda>x. x) (\\<lambda>x _. P x) True\n     (\\<lambda>s. Ball s P)", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>distinct l; sorted_wrt X l\\<rbrakk>\n       \\<Longrightarrow> foldli l (\\<lambda>x. x) (\\<lambda>x _. P x) True =\n                         Ball (set l) P", "using foldli_ball_aux[where b=True]"], ["proof (prove)\nusing this:\n  foldli ?l (\\<lambda>x. x) (\\<lambda>x _. ?P x) True =\n  (True \\<and> Ball (set ?l) ?P)\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>distinct l; sorted_wrt X l\\<rbrakk>\n       \\<Longrightarrow> foldli l (\\<lambda>x. x) (\\<lambda>x _. P x) True =\n                         Ball (set l) P", "by simp"], ["", "definition gen_ball :: \"_ \\<Rightarrow> 's \\<Rightarrow> ('k \\<Rightarrow> bool) \\<Rightarrow> _ \"\n    where \"gen_ball it s P \\<equiv> it s (\\<lambda>x. x) (\\<lambda>x _. P x) True\""], ["", "lemma gen_ball[autoref_rules_raw]:\n    assumes PRIO_TAG_GEN_ALGO\n    assumes IT: \"SIDE_GEN_ALGO (is_set_to_list Rk Rs it)\"\n    shows \"(gen_ball (\\<lambda>x. foldli (it x)),Ball) \\<in> \\<langle>Rk\\<rangle>Rs \\<rightarrow> (Rk\\<rightarrow>Id) \\<rightarrow> Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gen_ball (\\<lambda>x. foldli (it x)), Ball)\n    \\<in> \\<langle>Rk\\<rangle>Rs \\<rightarrow>\n          (Rk \\<rightarrow> bool_rel) \\<rightarrow> bool_rel", "apply (intro fun_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs;\n        (aa, a'a) \\<in> Rk \\<rightarrow> bool_rel\\<rbrakk>\n       \\<Longrightarrow> (gen_ball (\\<lambda>x. foldli (it x)) a aa,\n                          Ball a' a'a)\n                         \\<in> bool_rel", "unfolding gen_ball_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs;\n        (aa, a'a) \\<in> Rk \\<rightarrow> bool_rel\\<rbrakk>\n       \\<Longrightarrow> (foldli (it a) (\\<lambda>x. x) (\\<lambda>x _. aa x)\n                           True,\n                          Ball a' a'a)\n                         \\<in> bool_rel", "apply (rule det_fold_set[OF foldli_ball IT[unfolded autoref_tag_defs]])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs;\n        (aa, a'a) \\<in> Rk \\<rightarrow> bool_rel\\<rbrakk>\n       \\<Longrightarrow> (a, a') \\<in> \\<langle>Rk\\<rangle>Rs\n 2. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs;\n        (aa, a'a) \\<in> Rk \\<rightarrow> bool_rel\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. x, \\<lambda>x. x)\n                         \\<in> bool_rel \\<rightarrow> bool_rel\n 3. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs;\n        (aa, a'a) \\<in> Rk \\<rightarrow> bool_rel\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x _. aa x, \\<lambda>x _. a'a x)\n                         \\<in> Rk \\<rightarrow>\n                               bool_rel \\<rightarrow> bool_rel\n 4. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs;\n        (aa, a'a) \\<in> Rk \\<rightarrow> bool_rel\\<rbrakk>\n       \\<Longrightarrow> (True, True) \\<in> bool_rel", "apply (parametricity)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma foldli_bex_aux: \"foldli l (\\<lambda>x. \\<not>x) (\\<lambda>x _. P x) b \\<longleftrightarrow> b \\<or> Bex (set l) P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli l Not (\\<lambda>x _. P x) b = (b \\<or> Bex (set l) P)", "by (induct l arbitrary: b) auto"], ["", "lemma foldli_bex: \"det_fold_set X (\\<lambda>x. \\<not>x) (\\<lambda>x _. P x) False (\\<lambda>s. Bex s P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det_fold_set X Not (\\<lambda>x _. P x) False (\\<lambda>s. Bex s P)", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>distinct l; sorted_wrt X l\\<rbrakk>\n       \\<Longrightarrow> foldli l Not (\\<lambda>x _. P x) False =\n                         Bex (set l) P", "using foldli_bex_aux[where b=False]"], ["proof (prove)\nusing this:\n  foldli ?l Not (\\<lambda>x _. ?P x) False = (False \\<or> Bex (set ?l) ?P)\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>distinct l; sorted_wrt X l\\<rbrakk>\n       \\<Longrightarrow> foldli l Not (\\<lambda>x _. P x) False =\n                         Bex (set l) P", "by simp"], ["", "definition gen_bex :: \"_ \\<Rightarrow> 's \\<Rightarrow> ('k \\<Rightarrow> bool) \\<Rightarrow> _ \"\n    where \"gen_bex it s P \\<equiv> it s (\\<lambda>x. \\<not>x) (\\<lambda>x _. P x) False\""], ["", "lemma gen_bex[autoref_rules_raw]:\n    assumes PRIO_TAG_GEN_ALGO\n    assumes IT: \"SIDE_GEN_ALGO (is_set_to_list Rk Rs it)\"\n    shows \"(gen_bex (\\<lambda>x. foldli (it x)),Bex) \\<in> \\<langle>Rk\\<rangle>Rs \\<rightarrow> (Rk\\<rightarrow>Id) \\<rightarrow> Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gen_bex (\\<lambda>x. foldli (it x)), Bex)\n    \\<in> \\<langle>Rk\\<rangle>Rs \\<rightarrow>\n          (Rk \\<rightarrow> bool_rel) \\<rightarrow> bool_rel", "apply (intro fun_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs;\n        (aa, a'a) \\<in> Rk \\<rightarrow> bool_rel\\<rbrakk>\n       \\<Longrightarrow> (gen_bex (\\<lambda>x. foldli (it x)) a aa,\n                          Bex a' a'a)\n                         \\<in> bool_rel", "unfolding gen_bex_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs;\n        (aa, a'a) \\<in> Rk \\<rightarrow> bool_rel\\<rbrakk>\n       \\<Longrightarrow> (foldli (it a) Not (\\<lambda>x _. aa x) False,\n                          Bex a' a'a)\n                         \\<in> bool_rel", "apply (rule det_fold_set[OF foldli_bex IT[unfolded autoref_tag_defs]])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs;\n        (aa, a'a) \\<in> Rk \\<rightarrow> bool_rel\\<rbrakk>\n       \\<Longrightarrow> (a, a') \\<in> \\<langle>Rk\\<rangle>Rs\n 2. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs;\n        (aa, a'a) \\<in> Rk \\<rightarrow> bool_rel\\<rbrakk>\n       \\<Longrightarrow> (Not, Not) \\<in> bool_rel \\<rightarrow> bool_rel\n 3. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs;\n        (aa, a'a) \\<in> Rk \\<rightarrow> bool_rel\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x _. aa x, \\<lambda>x _. a'a x)\n                         \\<in> Rk \\<rightarrow>\n                               bool_rel \\<rightarrow> bool_rel\n 4. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs;\n        (aa, a'a) \\<in> Rk \\<rightarrow> bool_rel\\<rbrakk>\n       \\<Longrightarrow> (False, False) \\<in> bool_rel", "apply (parametricity)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ball_subseteq:\n    \"(Ball s1 (\\<lambda>x. x\\<in>s2)) \\<longleftrightarrow> s1 \\<subseteq> s2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>s1. x \\<in> s2) = (s1 \\<subseteq> s2)", "by blast"], ["", "definition gen_subseteq \n    :: \"('s1 \\<Rightarrow> ('k \\<Rightarrow> bool) \\<Rightarrow> bool) \\<Rightarrow> ('k \\<Rightarrow> 's2 \\<Rightarrow> bool) \\<Rightarrow> _\" \n    where \"gen_subseteq ball1 mem2 s1 s2 \\<equiv> ball1 s1 (\\<lambda>x. mem2 x s2)\""], ["", "lemma gen_subseteq[autoref_rules_raw]:\n    assumes PRIO_TAG_GEN_ALGO\n    assumes \"GEN_OP ball1 Ball (\\<langle>Rk\\<rangle>Rs1 \\<rightarrow> (Rk\\<rightarrow>Id) \\<rightarrow> Id)\"\n    assumes \"GEN_OP mem2 (\\<in>) (Rk \\<rightarrow> \\<langle>Rk\\<rangle>Rs2 \\<rightarrow> Id)\"\n    shows \"(gen_subseteq ball1 mem2,(\\<subseteq>)) \\<in> \\<langle>Rk\\<rangle>Rs1 \\<rightarrow> \\<langle>Rk\\<rangle>Rs2 \\<rightarrow> Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gen_subseteq ball1 mem2, (\\<subseteq>))\n    \\<in> \\<langle>Rk\\<rangle>Rs1 \\<rightarrow>\n          \\<langle>Rk\\<rangle>Rs2 \\<rightarrow> bool_rel", "apply (intro fun_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (gen_subseteq ball1 mem2 a aa, a' \\<subseteq> a'a)\n                         \\<in> bool_rel", "unfolding gen_subseteq_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (ball1 a (\\<lambda>x. mem2 x aa),\n                          a' \\<subseteq> a'a)\n                         \\<in> bool_rel", "using assms"], ["proof (prove)\nusing this:\n  PRIO_TAG_GEN_ALGO\n  GEN_OP ball1 Ball\n   (\\<langle>Rk\\<rangle>Rs1 \\<rightarrow>\n    (Rk \\<rightarrow> bool_rel) \\<rightarrow> bool_rel)\n  GEN_OP mem2 (\\<in>)\n   (Rk \\<rightarrow> \\<langle>Rk\\<rangle>Rs2 \\<rightarrow> bool_rel)\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (ball1 a (\\<lambda>x. mem2 x aa),\n                          a' \\<subseteq> a'a)\n                         \\<in> bool_rel", "unfolding autoref_tag_defs"], ["proof (prove)\nusing this:\n  PRIO_TAG_GEN_ALGO\n  (ball1, Ball)\n  \\<in> \\<langle>Rk\\<rangle>Rs1 \\<rightarrow>\n        (Rk \\<rightarrow> bool_rel) \\<rightarrow> bool_rel\n  (mem2, (\\<in>))\n  \\<in> Rk \\<rightarrow> \\<langle>Rk\\<rangle>Rs2 \\<rightarrow> bool_rel\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (ball1 a (\\<lambda>x. mem2 x aa),\n                          a' \\<subseteq> a'a)\n                         \\<in> bool_rel", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2; PRIO_TAG_GEN_ALGO;\n        (ball1, Ball)\n        \\<in> \\<langle>Rk\\<rangle>Rs1 \\<rightarrow>\n              (Rk \\<rightarrow> bool_rel) \\<rightarrow> bool_rel;\n        (mem2, (\\<in>))\n        \\<in> Rk \\<rightarrow>\n              \\<langle>Rk\\<rangle>Rs2 \\<rightarrow> bool_rel\\<rbrakk>\n       \\<Longrightarrow> (ball1 a (\\<lambda>x. mem2 x aa),\n                          a' \\<subseteq> a'a)\n                         \\<in> bool_rel", "apply (subst ball_subseteq[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2; PRIO_TAG_GEN_ALGO;\n        (ball1, Ball)\n        \\<in> \\<langle>Rk\\<rangle>Rs1 \\<rightarrow>\n              (Rk \\<rightarrow> bool_rel) \\<rightarrow> bool_rel;\n        (mem2, (\\<in>))\n        \\<in> Rk \\<rightarrow>\n              \\<langle>Rk\\<rangle>Rs2 \\<rightarrow> bool_rel\\<rbrakk>\n       \\<Longrightarrow> (ball1 a (\\<lambda>x. mem2 x aa),\n                          \\<forall>x\\<in>a'. x \\<in> a'a)\n                         \\<in> bool_rel", "apply parametricity"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition \"gen_equal ss1 ss2 s1 s2 \\<equiv> ss1 s1 s2 \\<and> ss2 s2 s1\""], ["", "lemma gen_equal[autoref_rules_raw]:\n    assumes PRIO_TAG_GEN_ALGO\n    assumes \"GEN_OP ss1 (\\<subseteq>) (\\<langle>Rk\\<rangle>Rs1 \\<rightarrow> \\<langle>Rk\\<rangle>Rs2 \\<rightarrow> Id)\"\n    assumes \"GEN_OP ss2 (\\<subseteq>) (\\<langle>Rk\\<rangle>Rs2 \\<rightarrow> \\<langle>Rk\\<rangle>Rs1 \\<rightarrow> Id)\"\n    shows \"(gen_equal ss1 ss2, (=)) \\<in> \\<langle>Rk\\<rangle>Rs1 \\<rightarrow> \\<langle>Rk\\<rangle>Rs2 \\<rightarrow> Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gen_equal ss1 ss2, (=))\n    \\<in> \\<langle>Rk\\<rangle>Rs1 \\<rightarrow>\n          \\<langle>Rk\\<rangle>Rs2 \\<rightarrow> bool_rel", "apply (intro fun_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (gen_equal ss1 ss2 a aa, a' = a'a) \\<in> bool_rel", "unfolding gen_equal_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (ss1 a aa \\<and> ss2 aa a, a' = a'a) \\<in> bool_rel", "using assms"], ["proof (prove)\nusing this:\n  PRIO_TAG_GEN_ALGO\n  GEN_OP ss1 (\\<subseteq>)\n   (\\<langle>Rk\\<rangle>Rs1 \\<rightarrow>\n    \\<langle>Rk\\<rangle>Rs2 \\<rightarrow> bool_rel)\n  GEN_OP ss2 (\\<subseteq>)\n   (\\<langle>Rk\\<rangle>Rs2 \\<rightarrow>\n    \\<langle>Rk\\<rangle>Rs1 \\<rightarrow> bool_rel)\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (ss1 a aa \\<and> ss2 aa a, a' = a'a) \\<in> bool_rel", "unfolding autoref_tag_defs"], ["proof (prove)\nusing this:\n  PRIO_TAG_GEN_ALGO\n  (ss1, (\\<subseteq>))\n  \\<in> \\<langle>Rk\\<rangle>Rs1 \\<rightarrow>\n        \\<langle>Rk\\<rangle>Rs2 \\<rightarrow> bool_rel\n  (ss2, (\\<subseteq>))\n  \\<in> \\<langle>Rk\\<rangle>Rs2 \\<rightarrow>\n        \\<langle>Rk\\<rangle>Rs1 \\<rightarrow> bool_rel\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (ss1 a aa \\<and> ss2 aa a, a' = a'a) \\<in> bool_rel", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2; PRIO_TAG_GEN_ALGO;\n        (ss1, (\\<subseteq>))\n        \\<in> \\<langle>Rk\\<rangle>Rs1 \\<rightarrow>\n              \\<langle>Rk\\<rangle>Rs2 \\<rightarrow> bool_rel;\n        (ss2, (\\<subseteq>))\n        \\<in> \\<langle>Rk\\<rangle>Rs2 \\<rightarrow>\n              \\<langle>Rk\\<rangle>Rs1 \\<rightarrow> bool_rel\\<rbrakk>\n       \\<Longrightarrow> (ss1 a aa \\<and> ss2 aa a, a' = a'a) \\<in> bool_rel", "apply (subst set_eq_subset)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2; PRIO_TAG_GEN_ALGO;\n        (ss1, (\\<subseteq>))\n        \\<in> \\<langle>Rk\\<rangle>Rs1 \\<rightarrow>\n              \\<langle>Rk\\<rangle>Rs2 \\<rightarrow> bool_rel;\n        (ss2, (\\<subseteq>))\n        \\<in> \\<langle>Rk\\<rangle>Rs2 \\<rightarrow>\n              \\<langle>Rk\\<rangle>Rs1 \\<rightarrow> bool_rel\\<rbrakk>\n       \\<Longrightarrow> (ss1 a aa \\<and> ss2 aa a,\n                          a' \\<subseteq> a'a \\<and> a'a \\<subseteq> a')\n                         \\<in> bool_rel", "apply (parametricity)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma foldli_card_aux: \"distinct l \\<Longrightarrow> foldli l (\\<lambda>_. True) \n    (\\<lambda>_ n. Suc n) n = n + card (set l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct l \\<Longrightarrow>\n    foldli l (\\<lambda>_. True) (\\<lambda>_. Suc) n = n + card (set l)", "apply (induct l arbitrary: n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       distinct [] \\<Longrightarrow>\n       foldli [] (\\<lambda>_. True) (\\<lambda>_. Suc) n = n + card (set [])\n 2. \\<And>a l n.\n       \\<lbrakk>\\<And>n.\n                   distinct l \\<Longrightarrow>\n                   foldli l (\\<lambda>_. True) (\\<lambda>_. Suc) n =\n                   n + card (set l);\n        distinct (a # l)\\<rbrakk>\n       \\<Longrightarrow> foldli (a # l) (\\<lambda>_. True) (\\<lambda>_. Suc)\n                          n =\n                         n + card (set (a # l))", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma foldli_card: \"det_fold_set X (\\<lambda>_. True) (\\<lambda>_ n. Suc n) 0 card\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det_fold_set X (\\<lambda>_. True) (\\<lambda>_. Suc) 0 card", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>distinct l; sorted_wrt X l\\<rbrakk>\n       \\<Longrightarrow> foldli l (\\<lambda>_. True) (\\<lambda>_. Suc) 0 =\n                         card (set l)", "using foldli_card_aux[where n=0]"], ["proof (prove)\nusing this:\n  distinct ?l \\<Longrightarrow>\n  foldli ?l (\\<lambda>_. True) (\\<lambda>_. Suc) 0 = 0 + card (set ?l)\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>distinct l; sorted_wrt X l\\<rbrakk>\n       \\<Longrightarrow> foldli l (\\<lambda>_. True) (\\<lambda>_. Suc) 0 =\n                         card (set l)", "by simp"], ["", "definition gen_card where\n    \"gen_card it s \\<equiv> it s (\\<lambda>x. True) (\\<lambda>_ n. Suc n) 0\""], ["", "lemma gen_card[autoref_rules_raw]:\n    assumes PRIO_TAG_GEN_ALGO\n    assumes IT: \"SIDE_GEN_ALGO (is_set_to_list Rk Rs it)\"\n    shows \"(gen_card (\\<lambda>x. foldli (it x)),card) \\<in> \\<langle>Rk\\<rangle>Rs \\<rightarrow> Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gen_card (\\<lambda>x. foldli (it x)), card)\n    \\<in> \\<langle>Rk\\<rangle>Rs \\<rightarrow> nat_rel", "apply (intro fun_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk\\<rangle>Rs \\<Longrightarrow>\n       (gen_card (\\<lambda>x. foldli (it x)) a, card a') \\<in> nat_rel", "unfolding gen_card_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk\\<rangle>Rs \\<Longrightarrow>\n       (foldli (it a) (\\<lambda>x. True) (\\<lambda>_. Suc) 0, card a')\n       \\<in> nat_rel", "apply (rule det_fold_set[OF foldli_card IT[unfolded autoref_tag_defs]])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk\\<rangle>Rs \\<Longrightarrow>\n       (a, a') \\<in> \\<langle>Rk\\<rangle>Rs\n 2. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk\\<rangle>Rs \\<Longrightarrow>\n       (\\<lambda>x. True, \\<lambda>_. True)\n       \\<in> nat_rel \\<rightarrow> bool_rel\n 3. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk\\<rangle>Rs \\<Longrightarrow>\n       (\\<lambda>_. Suc, \\<lambda>_. Suc)\n       \\<in> Rk \\<rightarrow> nat_rel \\<rightarrow> nat_rel\n 4. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk\\<rangle>Rs \\<Longrightarrow>\n       (0, 0) \\<in> nat_rel", "apply (parametricity)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fold_set: \"fold Set.insert l s = s \\<union> set l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold insert l s = s \\<union> set l", "by (induct l arbitrary: s) auto"], ["", "definition gen_set :: \"'s \\<Rightarrow> ('k \\<Rightarrow> 's \\<Rightarrow> 's) \\<Rightarrow> _\" where\n    \"gen_set emp ins l = fold ins l emp\""], ["", "lemma gen_set[autoref_rules_raw]: \n    assumes PRIO_TAG_GEN_ALGO\n    assumes EMPTY: \n      \"GEN_OP emp {} (\\<langle>Rk\\<rangle>Rs)\"\n    assumes INS: \n      \"GEN_OP ins Set.insert (Rk\\<rightarrow>\\<langle>Rk\\<rangle>Rs\\<rightarrow>\\<langle>Rk\\<rangle>Rs)\"\n    shows \"(gen_set emp ins,set)\\<in>\\<langle>Rk\\<rangle>list_rel\\<rightarrow>\\<langle>Rk\\<rangle>Rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gen_set emp ins, set)\n    \\<in> \\<langle>Rk\\<rangle>list_rel \\<rightarrow> \\<langle>Rk\\<rangle>Rs", "apply (intro fun_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk\\<rangle>list_rel \\<Longrightarrow>\n       (gen_set emp ins a, set a') \\<in> \\<langle>Rk\\<rangle>Rs", "unfolding gen_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk\\<rangle>list_rel \\<Longrightarrow>\n       (fold ins a emp, set a') \\<in> \\<langle>Rk\\<rangle>Rs", "using assms"], ["proof (prove)\nusing this:\n  PRIO_TAG_GEN_ALGO\n  GEN_OP emp {} (\\<langle>Rk\\<rangle>Rs)\n  GEN_OP ins insert\n   (Rk \\<rightarrow>\n    \\<langle>Rk\\<rangle>Rs \\<rightarrow> \\<langle>Rk\\<rangle>Rs)\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk\\<rangle>list_rel \\<Longrightarrow>\n       (fold ins a emp, set a') \\<in> \\<langle>Rk\\<rangle>Rs", "unfolding autoref_tag_defs"], ["proof (prove)\nusing this:\n  PRIO_TAG_GEN_ALGO\n  (emp, {}) \\<in> \\<langle>Rk\\<rangle>Rs\n  (ins, insert)\n  \\<in> Rk \\<rightarrow>\n        \\<langle>Rk\\<rangle>Rs \\<rightarrow> \\<langle>Rk\\<rangle>Rs\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk\\<rangle>list_rel \\<Longrightarrow>\n       (fold ins a emp, set a') \\<in> \\<langle>Rk\\<rangle>Rs", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>list_rel;\n        PRIO_TAG_GEN_ALGO; (emp, {}) \\<in> \\<langle>Rk\\<rangle>Rs;\n        (ins, insert)\n        \\<in> Rk \\<rightarrow>\n              \\<langle>Rk\\<rangle>Rs \\<rightarrow>\n              \\<langle>Rk\\<rangle>Rs\\<rbrakk>\n       \\<Longrightarrow> (fold ins a emp, set a')\n                         \\<in> \\<langle>Rk\\<rangle>Rs", "apply (subst fold_set[where s=\"{}\",simplified,symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>list_rel;\n        PRIO_TAG_GEN_ALGO; (emp, {}) \\<in> \\<langle>Rk\\<rangle>Rs;\n        (ins, insert)\n        \\<in> Rk \\<rightarrow>\n              \\<langle>Rk\\<rangle>Rs \\<rightarrow>\n              \\<langle>Rk\\<rangle>Rs\\<rbrakk>\n       \\<Longrightarrow> (fold ins a emp, fold insert a' {})\n                         \\<in> \\<langle>Rk\\<rangle>Rs", "apply parametricity"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ball_isEmpty: \"op_set_isEmpty s = (\\<forall>x\\<in>s. False)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op_set_isEmpty s = (\\<forall>x\\<in>s. False)", "by auto"], ["", "definition gen_isEmpty :: \"('s \\<Rightarrow> ('k \\<Rightarrow> bool) \\<Rightarrow> bool) \\<Rightarrow> 's \\<Rightarrow> bool\" where\n    \"gen_isEmpty ball s \\<equiv> ball s (\\<lambda>_. False)\""], ["", "lemma gen_isEmpty[autoref_rules_raw]:\n    assumes PRIO_TAG_GEN_ALGO\n    assumes \"GEN_OP ball Ball (\\<langle>Rk\\<rangle>Rs \\<rightarrow> (Rk\\<rightarrow>Id) \\<rightarrow> Id)\"\n    shows \"(gen_isEmpty ball,op_set_isEmpty) \\<in> \\<langle>Rk\\<rangle>Rs \\<rightarrow> Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gen_isEmpty ball, op_set_isEmpty)\n    \\<in> \\<langle>Rk\\<rangle>Rs \\<rightarrow> bool_rel", "apply (intro fun_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk\\<rangle>Rs \\<Longrightarrow>\n       (gen_isEmpty ball a, op_set_isEmpty a') \\<in> bool_rel", "unfolding gen_isEmpty_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk\\<rangle>Rs \\<Longrightarrow>\n       (ball a (\\<lambda>_. False), op_set_isEmpty a') \\<in> bool_rel", "using assms"], ["proof (prove)\nusing this:\n  PRIO_TAG_GEN_ALGO\n  GEN_OP ball Ball\n   (\\<langle>Rk\\<rangle>Rs \\<rightarrow>\n    (Rk \\<rightarrow> bool_rel) \\<rightarrow> bool_rel)\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk\\<rangle>Rs \\<Longrightarrow>\n       (ball a (\\<lambda>_. False), op_set_isEmpty a') \\<in> bool_rel", "unfolding autoref_tag_defs"], ["proof (prove)\nusing this:\n  PRIO_TAG_GEN_ALGO\n  (ball, Ball)\n  \\<in> \\<langle>Rk\\<rangle>Rs \\<rightarrow>\n        (Rk \\<rightarrow> bool_rel) \\<rightarrow> bool_rel\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk\\<rangle>Rs \\<Longrightarrow>\n       (ball a (\\<lambda>_. False), op_set_isEmpty a') \\<in> bool_rel", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs; PRIO_TAG_GEN_ALGO;\n        (ball, Ball)\n        \\<in> \\<langle>Rk\\<rangle>Rs \\<rightarrow>\n              (Rk \\<rightarrow> bool_rel) \\<rightarrow> bool_rel\\<rbrakk>\n       \\<Longrightarrow> (ball a (\\<lambda>_. False), op_set_isEmpty a')\n                         \\<in> bool_rel", "apply (subst ball_isEmpty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs; PRIO_TAG_GEN_ALGO;\n        (ball, Ball)\n        \\<in> \\<langle>Rk\\<rangle>Rs \\<rightarrow>\n              (Rk \\<rightarrow> bool_rel) \\<rightarrow> bool_rel\\<rbrakk>\n       \\<Longrightarrow> (ball a (\\<lambda>_. False),\n                          \\<forall>x\\<in>a'. False)\n                         \\<in> bool_rel", "apply parametricity"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma foldli_size_abort_aux:\n    \"\\<lbrakk>n0\\<le>m; distinct l\\<rbrakk> \\<Longrightarrow> \n      foldli l (\\<lambda>n. n<m) (\\<lambda>_ n. Suc n) n0 = min m (n0 + card (set l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n0 \\<le> m; distinct l\\<rbrakk>\n    \\<Longrightarrow> foldli l (\\<lambda>n. n < m) (\\<lambda>_. Suc) n0 =\n                      min m (n0 + card (set l))", "apply (induct l arbitrary: n0)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n0.\n       \\<lbrakk>n0 \\<le> m; distinct []\\<rbrakk>\n       \\<Longrightarrow> foldli [] (\\<lambda>n. n < m) (\\<lambda>_. Suc)\n                          n0 =\n                         min m (n0 + card (set []))\n 2. \\<And>a l n0.\n       \\<lbrakk>\\<And>n0.\n                   \\<lbrakk>n0 \\<le> m; distinct l\\<rbrakk>\n                   \\<Longrightarrow> foldli l (\\<lambda>n. n < m)\n(\\<lambda>_. Suc) n0 =\n                                     min m (n0 + card (set l));\n        n0 \\<le> m; distinct (a # l)\\<rbrakk>\n       \\<Longrightarrow> foldli (a # l) (\\<lambda>n. n < m)\n                          (\\<lambda>_. Suc) n0 =\n                         min m (n0 + card (set (a # l)))", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma foldli_size_abort: \"\n    det_fold_set X (\\<lambda>n. n<m) (\\<lambda>_ n. Suc n) 0 (op_set_size_abort m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det_fold_set X (\\<lambda>n. n < m) (\\<lambda>_. Suc) 0\n     (op_set_size_abort m)", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>distinct l; sorted_wrt X l\\<rbrakk>\n       \\<Longrightarrow> foldli l (\\<lambda>n. n < m) (\\<lambda>_. Suc) 0 =\n                         op_set_size_abort m (set l)", "using foldli_size_abort_aux[where ?n0.0=0]"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> ?m; distinct ?l\\<rbrakk>\n  \\<Longrightarrow> foldli ?l (\\<lambda>n. n < ?m) (\\<lambda>_. Suc) 0 =\n                    min ?m (0 + card (set ?l))\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>distinct l; sorted_wrt X l\\<rbrakk>\n       \\<Longrightarrow> foldli l (\\<lambda>n. n < m) (\\<lambda>_. Suc) 0 =\n                         op_set_size_abort m (set l)", "by simp"], ["", "definition gen_size_abort where\n    \"gen_size_abort it m s \\<equiv> it s (\\<lambda>n. n<m) (\\<lambda>_ n. Suc n) 0\""], ["", "lemma gen_size_abort[autoref_rules_raw]:\n    assumes PRIO_TAG_GEN_ALGO\n    assumes IT: \"SIDE_GEN_ALGO (is_set_to_list Rk Rs it)\"\n    shows \"(gen_size_abort (\\<lambda>x. foldli (it x)),op_set_size_abort) \n    \\<in> Id \\<rightarrow> \\<langle>Rk\\<rangle>Rs \\<rightarrow> Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gen_size_abort (\\<lambda>x. foldli (it x)), op_set_size_abort)\n    \\<in> nat_rel \\<rightarrow> \\<langle>Rk\\<rangle>Rs \\<rightarrow> nat_rel", "apply (intro fun_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> nat_rel;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs\\<rbrakk>\n       \\<Longrightarrow> (gen_size_abort (\\<lambda>x. foldli (it x)) a aa,\n                          op_set_size_abort a' a'a)\n                         \\<in> nat_rel", "unfolding gen_size_abort_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> nat_rel;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs\\<rbrakk>\n       \\<Longrightarrow> (foldli (it aa) (\\<lambda>n. n < a)\n                           (\\<lambda>_. Suc) 0,\n                          op_set_size_abort a' a'a)\n                         \\<in> nat_rel", "apply (rule det_fold_set[OF foldli_size_abort IT[unfolded autoref_tag_defs]])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> nat_rel;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs\\<rbrakk>\n       \\<Longrightarrow> (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs\n 2. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> nat_rel;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>n. n < a, \\<lambda>n. n < a')\n                         \\<in> nat_rel \\<rightarrow> bool_rel\n 3. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> nat_rel;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>_. Suc, \\<lambda>_. Suc)\n                         \\<in> Rk \\<rightarrow>\n                               nat_rel \\<rightarrow> nat_rel\n 4. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> nat_rel;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs\\<rbrakk>\n       \\<Longrightarrow> (0, 0) \\<in> nat_rel", "apply (parametricity)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma size_abort_isSng: \"op_set_isSng s \\<longleftrightarrow> op_set_size_abort 2 s = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op_set_isSng s = (op_set_size_abort 2 s = 1)", "by auto"], ["", "definition gen_isSng :: \"(nat \\<Rightarrow> 's \\<Rightarrow> nat) \\<Rightarrow> _\" where\n    \"gen_isSng sizea s \\<equiv> sizea 2 s = 1\""], ["", "lemma gen_isSng[autoref_rules_raw]:\n    assumes PRIO_TAG_GEN_ALGO\n    assumes \"GEN_OP sizea op_set_size_abort (Id \\<rightarrow> (\\<langle>Rk\\<rangle>Rs) \\<rightarrow> Id)\"\n    shows \"(gen_isSng sizea,op_set_isSng) \\<in> \\<langle>Rk\\<rangle>Rs \\<rightarrow> Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gen_isSng sizea, op_set_isSng)\n    \\<in> \\<langle>Rk\\<rangle>Rs \\<rightarrow> bool_rel", "apply (intro fun_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk\\<rangle>Rs \\<Longrightarrow>\n       (gen_isSng sizea a, op_set_isSng a') \\<in> bool_rel", "unfolding gen_isSng_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk\\<rangle>Rs \\<Longrightarrow>\n       (sizea 2 a = 1, op_set_isSng a') \\<in> bool_rel", "using assms"], ["proof (prove)\nusing this:\n  PRIO_TAG_GEN_ALGO\n  GEN_OP sizea op_set_size_abort\n   (nat_rel \\<rightarrow> \\<langle>Rk\\<rangle>Rs \\<rightarrow> nat_rel)\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk\\<rangle>Rs \\<Longrightarrow>\n       (sizea 2 a = 1, op_set_isSng a') \\<in> bool_rel", "unfolding autoref_tag_defs"], ["proof (prove)\nusing this:\n  PRIO_TAG_GEN_ALGO\n  (sizea, op_set_size_abort)\n  \\<in> nat_rel \\<rightarrow> \\<langle>Rk\\<rangle>Rs \\<rightarrow> nat_rel\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk\\<rangle>Rs \\<Longrightarrow>\n       (sizea 2 a = 1, op_set_isSng a') \\<in> bool_rel", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs; PRIO_TAG_GEN_ALGO;\n        (sizea, op_set_size_abort)\n        \\<in> nat_rel \\<rightarrow>\n              \\<langle>Rk\\<rangle>Rs \\<rightarrow> nat_rel\\<rbrakk>\n       \\<Longrightarrow> (sizea 2 a = 1, op_set_isSng a') \\<in> bool_rel", "apply (subst size_abort_isSng)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs; PRIO_TAG_GEN_ALGO;\n        (sizea, op_set_size_abort)\n        \\<in> nat_rel \\<rightarrow>\n              \\<langle>Rk\\<rangle>Rs \\<rightarrow> nat_rel\\<rbrakk>\n       \\<Longrightarrow> (sizea 2 a = 1, op_set_size_abort 2 a' = 1)\n                         \\<in> bool_rel", "apply parametricity"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma foldli_disjoint_aux:\n    \"foldli l1 (\\<lambda>x. x) (\\<lambda>x _. \\<not>x\\<in>s2) b \\<longleftrightarrow> b \\<and> op_set_disjoint (set l1) s2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli l1 (\\<lambda>x. x) (\\<lambda>x _. x \\<notin> s2) b =\n    (b \\<and> op_set_disjoint (set l1) s2)", "by (induct l1 arbitrary: b) auto"], ["", "lemma foldli_disjoint: \n    \"det_fold_set X (\\<lambda>x. x) (\\<lambda>x _. \\<not>x\\<in>s2) True (\\<lambda>s1. op_set_disjoint s1 s2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det_fold_set X (\\<lambda>x. x) (\\<lambda>x _. x \\<notin> s2) True\n     (\\<lambda>s1. op_set_disjoint s1 s2)", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>distinct l; sorted_wrt X l\\<rbrakk>\n       \\<Longrightarrow> foldli l (\\<lambda>x. x)\n                          (\\<lambda>x _. x \\<notin> s2) True =\n                         op_set_disjoint (set l) s2", "using foldli_disjoint_aux[where b=True]"], ["proof (prove)\nusing this:\n  foldli ?l1.0 (\\<lambda>x. x) (\\<lambda>x _. x \\<notin> ?s2.0) True =\n  (True \\<and> op_set_disjoint (set ?l1.0) ?s2.0)\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>distinct l; sorted_wrt X l\\<rbrakk>\n       \\<Longrightarrow> foldli l (\\<lambda>x. x)\n                          (\\<lambda>x _. x \\<notin> s2) True =\n                         op_set_disjoint (set l) s2", "by simp"], ["", "definition gen_disjoint \n    :: \"_ \\<Rightarrow> ('k\\<Rightarrow>'s2\\<Rightarrow>bool) \\<Rightarrow> _\"\n    where \"gen_disjoint it1 mem2 s1 s2 \n    \\<equiv> it1 s1 (\\<lambda>x. x) (\\<lambda>x _. \\<not>mem2 x s2) True\""], ["", "lemma gen_disjoint[autoref_rules_raw]:\n    assumes PRIO_TAG_GEN_ALGO\n    assumes IT: \"SIDE_GEN_ALGO (is_set_to_list Rk Rs1 it1)\"\n    assumes MEM: \"GEN_OP mem2 (\\<in>) (Rk \\<rightarrow> \\<langle>Rk\\<rangle>Rs2 \\<rightarrow> Id)\"\n    shows \"(gen_disjoint (\\<lambda>x. foldli (it1 x)) mem2,op_set_disjoint) \n    \\<in> \\<langle>Rk\\<rangle>Rs1 \\<rightarrow> \\<langle>Rk\\<rangle>Rs2 \\<rightarrow> Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gen_disjoint (\\<lambda>x. foldli (it1 x)) mem2, op_set_disjoint)\n    \\<in> \\<langle>Rk\\<rangle>Rs1 \\<rightarrow>\n          \\<langle>Rk\\<rangle>Rs2 \\<rightarrow> bool_rel", "apply (intro fun_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (gen_disjoint (\\<lambda>x. foldli (it1 x)) mem2 a\n                           aa,\n                          op_set_disjoint a' a'a)\n                         \\<in> bool_rel", "unfolding gen_disjoint_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (foldli (it1 a) (\\<lambda>x. x)\n                           (\\<lambda>x _. \\<not> mem2 x aa) True,\n                          op_set_disjoint a' a'a)\n                         \\<in> bool_rel", "apply (rule det_fold_set[OF foldli_disjoint IT[unfolded autoref_tag_defs]])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (a, a') \\<in> \\<langle>Rk\\<rangle>Rs1\n 2. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. x, \\<lambda>x. x)\n                         \\<in> bool_rel \\<rightarrow> bool_rel\n 3. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x _. \\<not> mem2 x aa,\n                          \\<lambda>x _. x \\<notin> a'a)\n                         \\<in> Rk \\<rightarrow>\n                               bool_rel \\<rightarrow> bool_rel\n 4. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (True, True) \\<in> bool_rel", "using MEM"], ["proof (prove)\nusing this:\n  GEN_OP mem2 (\\<in>)\n   (Rk \\<rightarrow> \\<langle>Rk\\<rangle>Rs2 \\<rightarrow> bool_rel)\n\ngoal (4 subgoals):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (a, a') \\<in> \\<langle>Rk\\<rangle>Rs1\n 2. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. x, \\<lambda>x. x)\n                         \\<in> bool_rel \\<rightarrow> bool_rel\n 3. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x _. \\<not> mem2 x aa,\n                          \\<lambda>x _. x \\<notin> a'a)\n                         \\<in> Rk \\<rightarrow>\n                               bool_rel \\<rightarrow> bool_rel\n 4. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (True, True) \\<in> bool_rel", "unfolding autoref_tag_defs"], ["proof (prove)\nusing this:\n  (mem2, (\\<in>))\n  \\<in> Rk \\<rightarrow> \\<langle>Rk\\<rangle>Rs2 \\<rightarrow> bool_rel\n\ngoal (4 subgoals):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (a, a') \\<in> \\<langle>Rk\\<rangle>Rs1\n 2. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. x, \\<lambda>x. x)\n                         \\<in> bool_rel \\<rightarrow> bool_rel\n 3. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x _. \\<not> mem2 x aa,\n                          \\<lambda>x _. x \\<notin> a'a)\n                         \\<in> Rk \\<rightarrow>\n                               bool_rel \\<rightarrow> bool_rel\n 4. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (True, True) \\<in> bool_rel", "apply (parametricity)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma foldli_filter_aux:\n    \"foldli l (\\<lambda>_. True) (\\<lambda>x s. if P x then insert x s else s) s0 \n    = s0 \\<union> op_set_filter P (set l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli l (\\<lambda>_. True)\n     (\\<lambda>x s. if P x then insert x s else s) s0 =\n    s0 \\<union> op_set_filter P (set l)", "by (induct l arbitrary: s0) auto"], ["", "lemma foldli_filter: \n    \"det_fold_set X (\\<lambda>_. True) (\\<lambda>x s. if P x then insert x s else s) {} \n      (op_set_filter P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det_fold_set X (\\<lambda>_. True)\n     (\\<lambda>x s. if P x then insert x s else s) {} (op_set_filter P)", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>distinct l; sorted_wrt X l\\<rbrakk>\n       \\<Longrightarrow> foldli l (\\<lambda>_. True)\n                          (\\<lambda>x s. if P x then insert x s else s) {} =\n                         op_set_filter P (set l)", "using foldli_filter_aux[where ?s0.0=\"{}\"]"], ["proof (prove)\nusing this:\n  foldli ?l (\\<lambda>_. True)\n   (\\<lambda>x s. if ?P x then insert x s else s) {} =\n  {} \\<union> op_set_filter ?P (set ?l)\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>distinct l; sorted_wrt X l\\<rbrakk>\n       \\<Longrightarrow> foldli l (\\<lambda>_. True)\n                          (\\<lambda>x s. if P x then insert x s else s) {} =\n                         op_set_filter P (set l)", "by simp"], ["", "definition gen_filter\n    where \"gen_filter it1 emp2 ins2 P s1 \\<equiv> \n      it1 s1 (\\<lambda>_. True) (\\<lambda>x s. if P x then ins2 x s else s) emp2\""], ["", "lemma gen_filter[autoref_rules_raw]:\n    assumes PRIO_TAG_GEN_ALGO\n    assumes IT: \"SIDE_GEN_ALGO (is_set_to_list Rk Rs1 it1)\"\n    assumes INS: \n      \"GEN_OP ins2 Set.insert (Rk\\<rightarrow>\\<langle>Rk\\<rangle>Rs2\\<rightarrow>\\<langle>Rk\\<rangle>Rs2)\"\n    assumes EMPTY: \n      \"GEN_OP empty2 {} (\\<langle>Rk\\<rangle>Rs2)\"\n    shows \"(gen_filter (\\<lambda>x. foldli (it1 x)) empty2 ins2,op_set_filter) \n    \\<in> (Rk\\<rightarrow>Id) \\<rightarrow> (\\<langle>Rk\\<rangle>Rs1) \\<rightarrow> (\\<langle>Rk\\<rangle>Rs2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gen_filter (\\<lambda>x. foldli (it1 x)) empty2 ins2, op_set_filter)\n    \\<in> (Rk \\<rightarrow> bool_rel) \\<rightarrow>\n          \\<langle>Rk\\<rangle>Rs1 \\<rightarrow> \\<langle>Rk\\<rangle>Rs2", "apply (intro fun_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Rk \\<rightarrow> bool_rel;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs1\\<rbrakk>\n       \\<Longrightarrow> (gen_filter (\\<lambda>x. foldli (it1 x)) empty2\n                           ins2 a aa,\n                          op_set_filter a' a'a)\n                         \\<in> \\<langle>Rk\\<rangle>Rs2", "unfolding gen_filter_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Rk \\<rightarrow> bool_rel;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs1\\<rbrakk>\n       \\<Longrightarrow> (foldli (it1 aa) (\\<lambda>_. True)\n                           (\\<lambda>x s. if a x then ins2 x s else s)\n                           empty2,\n                          op_set_filter a' a'a)\n                         \\<in> \\<langle>Rk\\<rangle>Rs2", "apply (rule det_fold_set[OF foldli_filter IT[unfolded autoref_tag_defs]])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Rk \\<rightarrow> bool_rel;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs1\\<rbrakk>\n       \\<Longrightarrow> (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs1\n 2. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Rk \\<rightarrow> bool_rel;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs1\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>_. True, \\<lambda>_. True)\n                         \\<in> \\<langle>Rk\\<rangle>Rs2 \\<rightarrow>\n                               bool_rel\n 3. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Rk \\<rightarrow> bool_rel;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs1\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x s. if a x then ins2 x s else s,\n                          \\<lambda>x s. if a' x then insert x s else s)\n                         \\<in> Rk \\<rightarrow>\n                               \\<langle>Rk\\<rangle>Rs2 \\<rightarrow>\n                               \\<langle>Rk\\<rangle>Rs2\n 4. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Rk \\<rightarrow> bool_rel;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs1\\<rbrakk>\n       \\<Longrightarrow> (empty2, {}) \\<in> \\<langle>Rk\\<rangle>Rs2", "using INS EMPTY"], ["proof (prove)\nusing this:\n  GEN_OP ins2 insert\n   (Rk \\<rightarrow>\n    \\<langle>Rk\\<rangle>Rs2 \\<rightarrow> \\<langle>Rk\\<rangle>Rs2)\n  GEN_OP empty2 {} (\\<langle>Rk\\<rangle>Rs2)\n\ngoal (4 subgoals):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Rk \\<rightarrow> bool_rel;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs1\\<rbrakk>\n       \\<Longrightarrow> (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs1\n 2. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Rk \\<rightarrow> bool_rel;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs1\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>_. True, \\<lambda>_. True)\n                         \\<in> \\<langle>Rk\\<rangle>Rs2 \\<rightarrow>\n                               bool_rel\n 3. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Rk \\<rightarrow> bool_rel;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs1\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x s. if a x then ins2 x s else s,\n                          \\<lambda>x s. if a' x then insert x s else s)\n                         \\<in> Rk \\<rightarrow>\n                               \\<langle>Rk\\<rangle>Rs2 \\<rightarrow>\n                               \\<langle>Rk\\<rangle>Rs2\n 4. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Rk \\<rightarrow> bool_rel;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs1\\<rbrakk>\n       \\<Longrightarrow> (empty2, {}) \\<in> \\<langle>Rk\\<rangle>Rs2", "unfolding autoref_tag_defs"], ["proof (prove)\nusing this:\n  (ins2, insert)\n  \\<in> Rk \\<rightarrow>\n        \\<langle>Rk\\<rangle>Rs2 \\<rightarrow> \\<langle>Rk\\<rangle>Rs2\n  (empty2, {}) \\<in> \\<langle>Rk\\<rangle>Rs2\n\ngoal (4 subgoals):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Rk \\<rightarrow> bool_rel;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs1\\<rbrakk>\n       \\<Longrightarrow> (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs1\n 2. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Rk \\<rightarrow> bool_rel;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs1\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>_. True, \\<lambda>_. True)\n                         \\<in> \\<langle>Rk\\<rangle>Rs2 \\<rightarrow>\n                               bool_rel\n 3. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Rk \\<rightarrow> bool_rel;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs1\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x s. if a x then ins2 x s else s,\n                          \\<lambda>x s. if a' x then insert x s else s)\n                         \\<in> Rk \\<rightarrow>\n                               \\<langle>Rk\\<rangle>Rs2 \\<rightarrow>\n                               \\<langle>Rk\\<rangle>Rs2\n 4. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Rk \\<rightarrow> bool_rel;\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs1\\<rbrakk>\n       \\<Longrightarrow> (empty2, {}) \\<in> \\<langle>Rk\\<rangle>Rs2", "apply (parametricity)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma foldli_image_aux:\n    \"foldli l (\\<lambda>_. True) (\\<lambda>x s. insert (f x) s) s0\n    = s0 \\<union> f`(set l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli l (\\<lambda>_. True) (\\<lambda>x. insert (f x)) s0 =\n    s0 \\<union> f ` set l", "by (induct l arbitrary: s0) auto"], ["", "lemma foldli_image: \n    \"det_fold_set X (\\<lambda>_. True) (\\<lambda>x s. insert (f x) s) {} \n      ((`) f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det_fold_set X (\\<lambda>_. True) (\\<lambda>x. insert (f x)) {} ((`) f)", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>distinct l; sorted_wrt X l\\<rbrakk>\n       \\<Longrightarrow> foldli l (\\<lambda>_. True)\n                          (\\<lambda>x. insert (f x)) {} =\n                         f ` set l", "using foldli_image_aux[where ?s0.0=\"{}\"]"], ["proof (prove)\nusing this:\n  foldli ?l (\\<lambda>_. True) (\\<lambda>x. insert (?f x)) {} =\n  {} \\<union> ?f ` set ?l\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>distinct l; sorted_wrt X l\\<rbrakk>\n       \\<Longrightarrow> foldli l (\\<lambda>_. True)\n                          (\\<lambda>x. insert (f x)) {} =\n                         f ` set l", "by simp"], ["", "definition gen_image\n    where \"gen_image it1 emp2 ins2 f s1 \\<equiv> \n      it1 s1 (\\<lambda>_. True) (\\<lambda>x s. ins2 (f x) s) emp2\""], ["", "lemma gen_image[autoref_rules_raw]:\n    assumes PRIO_TAG_GEN_ALGO\n    assumes IT: \"SIDE_GEN_ALGO (is_set_to_list Rk Rs1 it1)\"\n    assumes INS: \n      \"GEN_OP ins2 Set.insert (Rk'\\<rightarrow>\\<langle>Rk'\\<rangle>Rs2\\<rightarrow>\\<langle>Rk'\\<rangle>Rs2)\"\n    assumes EMPTY: \n      \"GEN_OP empty2 {} (\\<langle>Rk'\\<rangle>Rs2)\"\n    shows \"(gen_image (\\<lambda>x. foldli (it1 x)) empty2 ins2,(`)) \n    \\<in> (Rk\\<rightarrow>Rk') \\<rightarrow> (\\<langle>Rk\\<rangle>Rs1) \\<rightarrow> (\\<langle>Rk'\\<rangle>Rs2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gen_image (\\<lambda>x. foldli (it1 x)) empty2 ins2, (`))\n    \\<in> (Rk \\<rightarrow> Rk') \\<rightarrow>\n          \\<langle>Rk\\<rangle>Rs1 \\<rightarrow> \\<langle>Rk'\\<rangle>Rs2", "apply (intro fun_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Rk \\<rightarrow> Rk';\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs1\\<rbrakk>\n       \\<Longrightarrow> (gen_image (\\<lambda>x. foldli (it1 x)) empty2 ins2\n                           a aa,\n                          a' ` a'a)\n                         \\<in> \\<langle>Rk'\\<rangle>Rs2", "unfolding gen_image_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Rk \\<rightarrow> Rk';\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs1\\<rbrakk>\n       \\<Longrightarrow> (foldli (it1 aa) (\\<lambda>_. True)\n                           (\\<lambda>x. ins2 (a x)) empty2,\n                          a' ` a'a)\n                         \\<in> \\<langle>Rk'\\<rangle>Rs2", "apply (rule det_fold_set[OF foldli_image IT[unfolded autoref_tag_defs]])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Rk \\<rightarrow> Rk';\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs1\\<rbrakk>\n       \\<Longrightarrow> (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs1\n 2. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Rk \\<rightarrow> Rk';\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs1\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>_. True, \\<lambda>_. True)\n                         \\<in> \\<langle>Rk'\\<rangle>Rs2 \\<rightarrow>\n                               bool_rel\n 3. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Rk \\<rightarrow> Rk';\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs1\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. ins2 (a x), \\<lambda>x. insert (a' x))\n                         \\<in> Rk \\<rightarrow>\n                               \\<langle>Rk'\\<rangle>Rs2 \\<rightarrow>\n                               \\<langle>Rk'\\<rangle>Rs2\n 4. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Rk \\<rightarrow> Rk';\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs1\\<rbrakk>\n       \\<Longrightarrow> (empty2, {}) \\<in> \\<langle>Rk'\\<rangle>Rs2", "using INS EMPTY"], ["proof (prove)\nusing this:\n  GEN_OP ins2 insert\n   (Rk' \\<rightarrow>\n    \\<langle>Rk'\\<rangle>Rs2 \\<rightarrow> \\<langle>Rk'\\<rangle>Rs2)\n  GEN_OP empty2 {} (\\<langle>Rk'\\<rangle>Rs2)\n\ngoal (4 subgoals):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Rk \\<rightarrow> Rk';\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs1\\<rbrakk>\n       \\<Longrightarrow> (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs1\n 2. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Rk \\<rightarrow> Rk';\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs1\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>_. True, \\<lambda>_. True)\n                         \\<in> \\<langle>Rk'\\<rangle>Rs2 \\<rightarrow>\n                               bool_rel\n 3. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Rk \\<rightarrow> Rk';\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs1\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. ins2 (a x), \\<lambda>x. insert (a' x))\n                         \\<in> Rk \\<rightarrow>\n                               \\<langle>Rk'\\<rangle>Rs2 \\<rightarrow>\n                               \\<langle>Rk'\\<rangle>Rs2\n 4. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Rk \\<rightarrow> Rk';\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs1\\<rbrakk>\n       \\<Longrightarrow> (empty2, {}) \\<in> \\<langle>Rk'\\<rangle>Rs2", "unfolding autoref_tag_defs"], ["proof (prove)\nusing this:\n  (ins2, insert)\n  \\<in> Rk' \\<rightarrow>\n        \\<langle>Rk'\\<rangle>Rs2 \\<rightarrow> \\<langle>Rk'\\<rangle>Rs2\n  (empty2, {}) \\<in> \\<langle>Rk'\\<rangle>Rs2\n\ngoal (4 subgoals):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Rk \\<rightarrow> Rk';\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs1\\<rbrakk>\n       \\<Longrightarrow> (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs1\n 2. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Rk \\<rightarrow> Rk';\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs1\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>_. True, \\<lambda>_. True)\n                         \\<in> \\<langle>Rk'\\<rangle>Rs2 \\<rightarrow>\n                               bool_rel\n 3. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Rk \\<rightarrow> Rk';\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs1\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. ins2 (a x), \\<lambda>x. insert (a' x))\n                         \\<in> Rk \\<rightarrow>\n                               \\<langle>Rk'\\<rangle>Rs2 \\<rightarrow>\n                               \\<langle>Rk'\\<rangle>Rs2\n 4. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Rk \\<rightarrow> Rk';\n        (aa, a'a) \\<in> \\<langle>Rk\\<rangle>Rs1\\<rbrakk>\n       \\<Longrightarrow> (empty2, {}) \\<in> \\<langle>Rk'\\<rangle>Rs2", "apply (parametricity)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(* TODO: Also do sel! *)"], ["", "lemma foldli_pick:\n    assumes \"l\\<noteq>[]\" \n    obtains x where \"x\\<in>set l\" \n    and \"(foldli l (case_option True (\\<lambda>_. False)) (\\<lambda>x _. Some x) None) = Some x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> set l;\n         foldli l (case_option True (\\<lambda>_. False))\n          (\\<lambda>x _. Some x) None =\n         Some x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  l \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> set l;\n         foldli l (case_option True (\\<lambda>_. False))\n          (\\<lambda>x _. Some x) None =\n         Some x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases l) auto"], ["", "definition gen_pick where\n    \"gen_pick it s \\<equiv> \n      (the (it s (case_option True (\\<lambda>_. False)) (\\<lambda>x _. Some x) None))\""], ["", "context begin"], ["", "interpretation autoref_syn"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma gen_pick[autoref_rules_raw]:\n    assumes PRIO_TAG_GEN_ALGO\n    assumes IT: \"SIDE_GEN_ALGO (is_set_to_list Rk Rs it)\"\n    assumes NE: \"SIDE_PRECOND (s'\\<noteq>{})\"\n    assumes SREF: \"(s,s')\\<in>\\<langle>Rk\\<rangle>Rs\"\n    shows \"(RETURN (gen_pick (\\<lambda>x. foldli (it x)) s), \n      (OP op_set_pick ::: \\<langle>Rk\\<rangle>Rs\\<rightarrow>\\<langle>Rk\\<rangle>nres_rel)$s')\\<in>\\<langle>Rk\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN (gen_pick (\\<lambda>x. foldli (it x)) s),\n     (OP op_set_pick :::\n      \\<langle>Rk\\<rangle>Rs \\<rightarrow> \\<langle>Rk\\<rangle>nres_rel) $\n     s')\n    \\<in> \\<langle>Rk\\<rangle>nres_rel", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (RETURN (gen_pick (\\<lambda>x. foldli (it x)) s),\n     (OP op_set_pick :::\n      \\<langle>Rk\\<rangle>Rs \\<rightarrow> \\<langle>Rk\\<rangle>nres_rel) $\n     s')\n    \\<in> \\<langle>Rk\\<rangle>nres_rel", "obtain tsl' where\n      [param]: \"(it s,tsl') \\<in> \\<langle>Rk\\<rangle>list_rel\" \n      and IT': \"RETURN tsl' \\<le> it_to_sorted_list (\\<lambda>_ _. True) s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>tsl'.\n        \\<lbrakk>(it s, tsl') \\<in> \\<langle>Rk\\<rangle>list_rel;\n         RETURN tsl'\n         \\<le> it_to_sorted_list (\\<lambda>_ _. True) s'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using IT[unfolded autoref_tag_defs is_set_to_list_def] SREF"], ["proof (prove)\nusing this:\n  is_set_to_sorted_list (\\<lambda>_ _. True) Rk Rs it\n  (s, s') \\<in> \\<langle>Rk\\<rangle>Rs\n\ngoal (1 subgoal):\n 1. (\\<And>tsl'.\n        \\<lbrakk>(it s, tsl') \\<in> \\<langle>Rk\\<rangle>list_rel;\n         RETURN tsl'\n         \\<le> it_to_sorted_list (\\<lambda>_ _. True) s'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule is_set_to_sorted_listE)"], ["proof (state)\nthis:\n  (it s, tsl') \\<in> \\<langle>Rk\\<rangle>list_rel\n  RETURN tsl' \\<le> it_to_sorted_list (\\<lambda>_ _. True) s'\n\ngoal (1 subgoal):\n 1. (RETURN (gen_pick (\\<lambda>x. foldli (it x)) s),\n     (OP op_set_pick :::\n      \\<langle>Rk\\<rangle>Rs \\<rightarrow> \\<langle>Rk\\<rangle>nres_rel) $\n     s')\n    \\<in> \\<langle>Rk\\<rangle>nres_rel", "from IT' NE"], ["proof (chain)\npicking this:\n  RETURN tsl' \\<le> it_to_sorted_list (\\<lambda>_ _. True) s'\n  SIDE_PRECOND (s' \\<noteq> {})", "have \"tsl'\\<noteq>[]\" and [simp]: \"s'=set tsl'\""], ["proof (prove)\nusing this:\n  RETURN tsl' \\<le> it_to_sorted_list (\\<lambda>_ _. True) s'\n  SIDE_PRECOND (s' \\<noteq> {})\n\ngoal (1 subgoal):\n 1. tsl' \\<noteq> [] &&& s' = set tsl'", "unfolding it_to_sorted_list_def"], ["proof (prove)\nusing this:\n  RETURN tsl'\n  \\<le> SPEC\n         (\\<lambda>l.\n             distinct l \\<and>\n             s' = set l \\<and> sorted_wrt (\\<lambda>_ _. True) l)\n  SIDE_PRECOND (s' \\<noteq> {})\n\ngoal (1 subgoal):\n 1. tsl' \\<noteq> [] &&& s' = set tsl'", "by simp_all"], ["proof (state)\nthis:\n  tsl' \\<noteq> []\n  s' = set tsl'\n\ngoal (1 subgoal):\n 1. (RETURN (gen_pick (\\<lambda>x. foldli (it x)) s),\n     (OP op_set_pick :::\n      \\<langle>Rk\\<rangle>Rs \\<rightarrow> \\<langle>Rk\\<rangle>nres_rel) $\n     s')\n    \\<in> \\<langle>Rk\\<rangle>nres_rel", "then"], ["proof (chain)\npicking this:\n  tsl' \\<noteq> []\n  s' = set tsl'", "obtain x where \"x\\<in>s'\" and\n      \"(foldli tsl' (case_option True (\\<lambda>_. False)) (\\<lambda>x _. Some x) None) = Some x\"\n      (is \"?fld = _\")"], ["proof (prove)\nusing this:\n  tsl' \\<noteq> []\n  s' = set tsl'\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> s';\n         foldli tsl' (case_option True (\\<lambda>_. False))\n          (\\<lambda>x _. Some x) None =\n         Some x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (blast elim: foldli_pick)"], ["proof (state)\nthis:\n  x \\<in> s'\n  foldli tsl' (case_option True (\\<lambda>_. False)) (\\<lambda>x _. Some x)\n   None =\n  Some x\n\ngoal (1 subgoal):\n 1. (RETURN (gen_pick (\\<lambda>x. foldli (it x)) s),\n     (OP op_set_pick :::\n      \\<langle>Rk\\<rangle>Rs \\<rightarrow> \\<langle>Rk\\<rangle>nres_rel) $\n     s')\n    \\<in> \\<langle>Rk\\<rangle>nres_rel", "moreover"], ["proof (state)\nthis:\n  x \\<in> s'\n  foldli tsl' (case_option True (\\<lambda>_. False)) (\\<lambda>x _. Some x)\n   None =\n  Some x\n\ngoal (1 subgoal):\n 1. (RETURN (gen_pick (\\<lambda>x. foldli (it x)) s),\n     (OP op_set_pick :::\n      \\<langle>Rk\\<rangle>Rs \\<rightarrow> \\<langle>Rk\\<rangle>nres_rel) $\n     s')\n    \\<in> \\<langle>Rk\\<rangle>nres_rel", "have \"(RETURN (gen_pick (\\<lambda>x. foldli (it x)) s), RETURN (the ?fld)) \n      \\<in> \\<langle>Rk\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN (gen_pick (\\<lambda>x. foldli (it x)) s),\n     RETURN\n      (the (foldli tsl' (case_option True (\\<lambda>_. False))\n             (\\<lambda>x _. Some x) None)))\n    \\<in> \\<langle>Rk\\<rangle>nres_rel", "unfolding gen_pick_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN\n      (the (foldli (it s) (case_option True (\\<lambda>_. False))\n             (\\<lambda>x _. Some x) None)),\n     RETURN\n      (the (foldli tsl' (case_option True (\\<lambda>_. False))\n             (\\<lambda>x _. Some x) None)))\n    \\<in> \\<langle>Rk\\<rangle>nres_rel", "apply (parametricity add: the_paramR)"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli tsl' (case_option True (\\<lambda>_. False))\n     (\\<lambda>x _. Some x) None \\<noteq>\n    None", "using \\<open>?fld = Some x\\<close>"], ["proof (prove)\nusing this:\n  foldli tsl' (case_option True (\\<lambda>_. False)) (\\<lambda>x _. Some x)\n   None =\n  Some x\n\ngoal (1 subgoal):\n 1. foldli tsl' (case_option True (\\<lambda>_. False))\n     (\\<lambda>x _. Some x) None \\<noteq>\n    None", "by simp"], ["proof (state)\nthis:\n  (RETURN (gen_pick (\\<lambda>x. foldli (it x)) s),\n   RETURN\n    (the (foldli tsl' (case_option True (\\<lambda>_. False))\n           (\\<lambda>x _. Some x) None)))\n  \\<in> \\<langle>Rk\\<rangle>nres_rel\n\ngoal (1 subgoal):\n 1. (RETURN (gen_pick (\\<lambda>x. foldli (it x)) s),\n     (OP op_set_pick :::\n      \\<langle>Rk\\<rangle>Rs \\<rightarrow> \\<langle>Rk\\<rangle>nres_rel) $\n     s')\n    \\<in> \\<langle>Rk\\<rangle>nres_rel", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> s'\n  foldli tsl' (case_option True (\\<lambda>_. False)) (\\<lambda>x _. Some x)\n   None =\n  Some x\n  (RETURN (gen_pick (\\<lambda>x. foldli (it x)) s),\n   RETURN\n    (the (foldli tsl' (case_option True (\\<lambda>_. False))\n           (\\<lambda>x _. Some x) None)))\n  \\<in> \\<langle>Rk\\<rangle>nres_rel", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> s'\n  foldli tsl' (case_option True (\\<lambda>_. False)) (\\<lambda>x _. Some x)\n   None =\n  Some x\n  (RETURN (gen_pick (\\<lambda>x. foldli (it x)) s),\n   RETURN\n    (the (foldli tsl' (case_option True (\\<lambda>_. False))\n           (\\<lambda>x _. Some x) None)))\n  \\<in> \\<langle>Rk\\<rangle>nres_rel\n\ngoal (1 subgoal):\n 1. (RETURN (gen_pick (\\<lambda>x. foldli (it x)) s),\n     (OP op_set_pick :::\n      \\<langle>Rk\\<rangle>Rs \\<rightarrow> \\<langle>Rk\\<rangle>nres_rel) $\n     s')\n    \\<in> \\<langle>Rk\\<rangle>nres_rel", "unfolding autoref_tag_defs"], ["proof (prove)\nusing this:\n  x \\<in> s'\n  foldli tsl' (case_option True (\\<lambda>_. False)) (\\<lambda>x _. Some x)\n   None =\n  Some x\n  (RETURN (gen_pick (\\<lambda>x. foldli (it x)) s),\n   RETURN\n    (the (foldli tsl' (case_option True (\\<lambda>_. False))\n           (\\<lambda>x _. Some x) None)))\n  \\<in> \\<langle>Rk\\<rangle>nres_rel\n\ngoal (1 subgoal):\n 1. (RETURN (gen_pick (\\<lambda>x. foldli (it x)) s), op_set_pick s')\n    \\<in> \\<langle>Rk\\<rangle>nres_rel", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> s';\n     foldli tsl' (case_option True (\\<lambda>_. False))\n      (\\<lambda>x _. Some x) None =\n     Some x;\n     (RETURN (gen_pick (\\<lambda>x. foldli (it x)) s),\n      RETURN\n       (the (foldli tsl' (case_option True (\\<lambda>_. False))\n              (\\<lambda>x _. Some x) None)))\n     \\<in> \\<langle>Rk\\<rangle>nres_rel\\<rbrakk>\n    \\<Longrightarrow> (RETURN (gen_pick (\\<lambda>x. foldli (it x)) s),\n                       op_set_pick s')\n                      \\<in> \\<langle>Rk\\<rangle>nres_rel", "apply (drule nres_relD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> s';\n     foldli tsl' (case_option True (\\<lambda>_. False))\n      (\\<lambda>x _. Some x) None =\n     Some x;\n     RETURN (gen_pick (\\<lambda>x. foldli (it x)) s)\n     \\<le> \\<Down> Rk\n            (RETURN\n              (the (foldli tsl' (case_option True (\\<lambda>_. False))\n                     (\\<lambda>x _. Some x) None)))\\<rbrakk>\n    \\<Longrightarrow> (RETURN (gen_pick (\\<lambda>x. foldli (it x)) s),\n                       op_set_pick s')\n                      \\<in> \\<langle>Rk\\<rangle>nres_rel", "apply (rule nres_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> s';\n     foldli tsl' (case_option True (\\<lambda>_. False))\n      (\\<lambda>x _. Some x) None =\n     Some x;\n     RETURN (gen_pick (\\<lambda>x. foldli (it x)) s)\n     \\<le> \\<Down> Rk\n            (RETURN\n              (the (foldli tsl' (case_option True (\\<lambda>_. False))\n                     (\\<lambda>x _. Some x) None)))\\<rbrakk>\n    \\<Longrightarrow> RETURN (gen_pick (\\<lambda>x. foldli (it x)) s)\n                      \\<le> \\<Down> Rk (op_set_pick s')", "apply (erule ref_two_step)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> s';\n     foldli tsl' (case_option True (\\<lambda>_. False))\n      (\\<lambda>x _. Some x) None =\n     Some x\\<rbrakk>\n    \\<Longrightarrow> RETURN\n                       (the (foldli tsl'\n                              (case_option True (\\<lambda>_. False))\n                              (\\<lambda>x _. Some x) None))\n                      \\<le> op_set_pick s'", "by simp"], ["proof (state)\nthis:\n  (RETURN (gen_pick (\\<lambda>x. foldli (it x)) s),\n   (OP op_set_pick :::\n    \\<langle>Rk\\<rangle>Rs \\<rightarrow> \\<langle>Rk\\<rangle>nres_rel) $\n   s')\n  \\<in> \\<langle>Rk\\<rangle>nres_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "definition gen_Sigma\n    where \"gen_Sigma it1 it2 empX insX s1 f2 \\<equiv> \n      it1 s1 (\\<lambda>_. True) (\\<lambda>x s. \n        it2 (f2 x) (\\<lambda>_. True) (\\<lambda>y s. insX (x,y) s) s\n      ) empX\n    \""], ["", "lemma foldli_Sigma_aux:\n    fixes s :: \"'s1_impl\" and s':: \"'k set\"\n    fixes f :: \"'k_impl \\<Rightarrow> 's2_impl\" and f':: \"'k \\<Rightarrow> 'l set\"\n    fixes s0 :: \"'kl_impl\" and s0' :: \"('k\\<times>'l) set\"\n    assumes IT1: \"is_set_to_list Rk Rs1 it1\"\n    assumes IT2: \"is_set_to_list Rl Rs2 it2\"\n    assumes INS: \n      \"(insX, Set.insert) \\<in> \n        (\\<langle>Rk,Rl\\<rangle>prod_rel\\<rightarrow>\\<langle>\\<langle>Rk,Rl\\<rangle>prod_rel\\<rangle>Rs3\\<rightarrow>\\<langle>\\<langle>Rk,Rl\\<rangle>prod_rel\\<rangle>Rs3)\"\n    assumes S0R: \"(s0, s0') \\<in> \\<langle>\\<langle>Rk,Rl\\<rangle>prod_rel\\<rangle>Rs3\" \n    assumes SR: \"(s, s') \\<in> \\<langle>Rk\\<rangle>Rs1\" \n    assumes FR: \"(f, f') \\<in> Rk \\<rightarrow> \\<langle>Rl\\<rangle>Rs2\"\n    shows \"(foldli (it1 s) (\\<lambda>_. True) (\\<lambda>x s. \n        foldli (it2 (f x)) (\\<lambda>_. True) (\\<lambda>y s. insX (x,y) s) s\n      ) s0,s0' \\<union> Sigma s' f') \n      \\<in> \\<langle>\\<langle>Rk,Rl\\<rangle>prod_rel\\<rangle>Rs3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (foldli (it1 s) (\\<lambda>_. True)\n      (\\<lambda>x.\n          foldli (it2 (f x)) (\\<lambda>_. True) (\\<lambda>y. insX (x, y)))\n      s0,\n     s0' \\<union> Sigma s' f')\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (foldli (it1 s) (\\<lambda>_. True)\n      (\\<lambda>x.\n          foldli (it2 (f x)) (\\<lambda>_. True) (\\<lambda>y. insX (x, y)))\n      s0,\n     s0' \\<union> Sigma s' f')\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3", "have S: \"\\<And>x s f. Sigma (insert x s) f = ({x}\\<times>f x) \\<union> Sigma s f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x s f. Sigma (insert x s) f = {x} \\<times> f x \\<union> Sigma s f", "by auto"], ["proof (state)\nthis:\n  Sigma (insert ?x ?s) ?f = {?x} \\<times> ?f ?x \\<union> Sigma ?s ?f\n\ngoal (1 subgoal):\n 1. (foldli (it1 s) (\\<lambda>_. True)\n      (\\<lambda>x.\n          foldli (it2 (f x)) (\\<lambda>_. True) (\\<lambda>y. insX (x, y)))\n      s0,\n     s0' \\<union> Sigma s' f')\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3", "obtain l' where \n      IT1L: \"(it1 s,l')\\<in>\\<langle>Rk\\<rangle>list_rel\" \n      and SL: \"s' = set l'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>(it1 s, l') \\<in> \\<langle>Rk\\<rangle>list_rel;\n         s' = set l'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (rule \n        is_set_to_sorted_listE[OF IT1[unfolded is_set_to_list_def] SR])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l'.\n       \\<lbrakk>\\<And>l'.\n                   \\<lbrakk>(it1 s, l') \\<in> \\<langle>Rk\\<rangle>list_rel;\n                    s' = set l'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        (it1 s, l') \\<in> \\<langle>Rk\\<rangle>list_rel;\n        RETURN l' \\<le> it_to_sorted_list (\\<lambda>_ _. True) s'\\<rbrakk>\n       \\<Longrightarrow> thesis", "by (auto simp: it_to_sorted_list_def)"], ["proof (state)\nthis:\n  (it1 s, l') \\<in> \\<langle>Rk\\<rangle>list_rel\n  s' = set l'\n\ngoal (1 subgoal):\n 1. (foldli (it1 s) (\\<lambda>_. True)\n      (\\<lambda>x.\n          foldli (it2 (f x)) (\\<lambda>_. True) (\\<lambda>y. insX (x, y)))\n      s0,\n     s0' \\<union> Sigma s' f')\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (foldli (it1 s) (\\<lambda>_. True)\n      (\\<lambda>x.\n          foldli (it2 (f x)) (\\<lambda>_. True) (\\<lambda>y. insX (x, y)))\n      s0,\n     s0' \\<union> Sigma s' f')\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3", "unfolding SL"], ["proof (prove)\ngoal (1 subgoal):\n 1. (foldli (it1 s) (\\<lambda>_. True)\n      (\\<lambda>x.\n          foldli (it2 (f x)) (\\<lambda>_. True) (\\<lambda>y. insX (x, y)))\n      s0,\n     s0' \\<union> Sigma (set l') f')\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3", "using IT1L S0R"], ["proof (prove)\nusing this:\n  (it1 s, l') \\<in> \\<langle>Rk\\<rangle>list_rel\n  (s0, s0') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3\n\ngoal (1 subgoal):\n 1. (foldli (it1 s) (\\<lambda>_. True)\n      (\\<lambda>x.\n          foldli (it2 (f x)) (\\<lambda>_. True) (\\<lambda>y. insX (x, y)))\n      s0,\n     s0' \\<union> Sigma (set l') f')\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3", "proof (induct arbitrary: s0 s0' rule: list_rel_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s0 s0'.\n       (s0, s0')\n       \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3 \\<Longrightarrow>\n       (foldli [] (\\<lambda>_. True)\n         (\\<lambda>x.\n             foldli (it2 (f x)) (\\<lambda>_. True)\n              (\\<lambda>y. insX (x, y)))\n         s0,\n        s0' \\<union> Sigma (set []) f')\n       \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3\n 2. \\<And>x x' l l' s0 s0'.\n       \\<lbrakk>(x, x') \\<in> Rk;\n        (l, l') \\<in> \\<langle>Rk\\<rangle>list_rel;\n        \\<And>s0 s0'.\n           (s0, s0')\n           \\<in> \\<langle>Rk \\<times>\\<^sub>r\n                          Rl\\<rangle>Rs3 \\<Longrightarrow>\n           (foldli l (\\<lambda>_. True)\n             (\\<lambda>x.\n                 foldli (it2 (f x)) (\\<lambda>_. True)\n                  (\\<lambda>y. insX (x, y)))\n             s0,\n            s0' \\<union> Sigma (set l') f')\n           \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3;\n        (s0, s0') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3\\<rbrakk>\n       \\<Longrightarrow> (foldli (x # l) (\\<lambda>_. True)\n                           (\\<lambda>x.\n                               foldli (it2 (f x)) (\\<lambda>_. True)\n                                (\\<lambda>y. insX (x, y)))\n                           s0,\n                          s0' \\<union> Sigma (set (x' # l')) f')\n                         \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3", "case Nil"], ["proof (state)\nthis:\n  (s0, s0') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3\n\ngoal (2 subgoals):\n 1. \\<And>s0 s0'.\n       (s0, s0')\n       \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3 \\<Longrightarrow>\n       (foldli [] (\\<lambda>_. True)\n         (\\<lambda>x.\n             foldli (it2 (f x)) (\\<lambda>_. True)\n              (\\<lambda>y. insX (x, y)))\n         s0,\n        s0' \\<union> Sigma (set []) f')\n       \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3\n 2. \\<And>x x' l l' s0 s0'.\n       \\<lbrakk>(x, x') \\<in> Rk;\n        (l, l') \\<in> \\<langle>Rk\\<rangle>list_rel;\n        \\<And>s0 s0'.\n           (s0, s0')\n           \\<in> \\<langle>Rk \\<times>\\<^sub>r\n                          Rl\\<rangle>Rs3 \\<Longrightarrow>\n           (foldli l (\\<lambda>_. True)\n             (\\<lambda>x.\n                 foldli (it2 (f x)) (\\<lambda>_. True)\n                  (\\<lambda>y. insX (x, y)))\n             s0,\n            s0' \\<union> Sigma (set l') f')\n           \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3;\n        (s0, s0') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3\\<rbrakk>\n       \\<Longrightarrow> (foldli (x # l) (\\<lambda>_. True)\n                           (\\<lambda>x.\n                               foldli (it2 (f x)) (\\<lambda>_. True)\n                                (\\<lambda>y. insX (x, y)))\n                           s0,\n                          s0' \\<union> Sigma (set (x' # l')) f')\n                         \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3", "thus ?case"], ["proof (prove)\nusing this:\n  (s0, s0') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3\n\ngoal (1 subgoal):\n 1. (foldli [] (\\<lambda>_. True)\n      (\\<lambda>x.\n          foldli (it2 (f x)) (\\<lambda>_. True) (\\<lambda>y. insX (x, y)))\n      s0,\n     s0' \\<union> Sigma (set []) f')\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3", "by simp"], ["proof (state)\nthis:\n  (foldli [] (\\<lambda>_. True)\n    (\\<lambda>x.\n        foldli (it2 (f x)) (\\<lambda>_. True) (\\<lambda>y. insX (x, y)))\n    s0,\n   s0' \\<union> Sigma (set []) f')\n  \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3\n\ngoal (1 subgoal):\n 1. \\<And>x x' l l' s0 s0'.\n       \\<lbrakk>(x, x') \\<in> Rk;\n        (l, l') \\<in> \\<langle>Rk\\<rangle>list_rel;\n        \\<And>s0 s0'.\n           (s0, s0')\n           \\<in> \\<langle>Rk \\<times>\\<^sub>r\n                          Rl\\<rangle>Rs3 \\<Longrightarrow>\n           (foldli l (\\<lambda>_. True)\n             (\\<lambda>x.\n                 foldli (it2 (f x)) (\\<lambda>_. True)\n                  (\\<lambda>y. insX (x, y)))\n             s0,\n            s0' \\<union> Sigma (set l') f')\n           \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3;\n        (s0, s0') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3\\<rbrakk>\n       \\<Longrightarrow> (foldli (x # l) (\\<lambda>_. True)\n                           (\\<lambda>x.\n                               foldli (it2 (f x)) (\\<lambda>_. True)\n                                (\\<lambda>y. insX (x, y)))\n                           s0,\n                          s0' \\<union> Sigma (set (x' # l')) f')\n                         \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x x' l l' s0 s0'.\n       \\<lbrakk>(x, x') \\<in> Rk;\n        (l, l') \\<in> \\<langle>Rk\\<rangle>list_rel;\n        \\<And>s0 s0'.\n           (s0, s0')\n           \\<in> \\<langle>Rk \\<times>\\<^sub>r\n                          Rl\\<rangle>Rs3 \\<Longrightarrow>\n           (foldli l (\\<lambda>_. True)\n             (\\<lambda>x.\n                 foldli (it2 (f x)) (\\<lambda>_. True)\n                  (\\<lambda>y. insX (x, y)))\n             s0,\n            s0' \\<union> Sigma (set l') f')\n           \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3;\n        (s0, s0') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3\\<rbrakk>\n       \\<Longrightarrow> (foldli (x # l) (\\<lambda>_. True)\n                           (\\<lambda>x.\n                               foldli (it2 (f x)) (\\<lambda>_. True)\n                                (\\<lambda>y. insX (x, y)))\n                           s0,\n                          s0' \\<union> Sigma (set (x' # l')) f')\n                         \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3", "case (Cons x x' l l')"], ["proof (state)\nthis:\n  (x, x') \\<in> Rk\n  (l, l') \\<in> \\<langle>Rk\\<rangle>list_rel\n  (?s0.1, ?s0'1)\n  \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3 \\<Longrightarrow>\n  (foldli l (\\<lambda>_. True)\n    (\\<lambda>x.\n        foldli (it2 (f x)) (\\<lambda>_. True) (\\<lambda>y. insX (x, y)))\n    ?s0.1,\n   ?s0'1 \\<union> Sigma (set l') f')\n  \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3\n  (s0, s0') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3\n\ngoal (1 subgoal):\n 1. \\<And>x x' l l' s0 s0'.\n       \\<lbrakk>(x, x') \\<in> Rk;\n        (l, l') \\<in> \\<langle>Rk\\<rangle>list_rel;\n        \\<And>s0 s0'.\n           (s0, s0')\n           \\<in> \\<langle>Rk \\<times>\\<^sub>r\n                          Rl\\<rangle>Rs3 \\<Longrightarrow>\n           (foldli l (\\<lambda>_. True)\n             (\\<lambda>x.\n                 foldli (it2 (f x)) (\\<lambda>_. True)\n                  (\\<lambda>y. insX (x, y)))\n             s0,\n            s0' \\<union> Sigma (set l') f')\n           \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3;\n        (s0, s0') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3\\<rbrakk>\n       \\<Longrightarrow> (foldli (x # l) (\\<lambda>_. True)\n                           (\\<lambda>x.\n                               foldli (it2 (f x)) (\\<lambda>_. True)\n                                (\\<lambda>y. insX (x, y)))\n                           s0,\n                          s0' \\<union> Sigma (set (x' # l')) f')\n                         \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3", "obtain l2' where \n        IT2L: \"(it2 (f x),l2')\\<in>\\<langle>Rl\\<rangle>list_rel\" \n        and FXL: \"f' x' = set l2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l2'.\n        \\<lbrakk>(it2 (f x), l2') \\<in> \\<langle>Rl\\<rangle>list_rel;\n         f' x' = set l2'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (rule \n          is_set_to_sorted_listE[\n            OF IT2[unfolded is_set_to_list_def], of \"f x\" \"f' x'\"\n          ])"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<And>l2'.\n        \\<lbrakk>(it2 (f x), l2') \\<in> \\<langle>Rl\\<rangle>list_rel;\n         f' x' = set l2'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    (f x, f' x') \\<in> \\<langle>Rl\\<rangle>Rs2\n 2. \\<And>l'.\n       \\<lbrakk>\\<And>l2'.\n                   \\<lbrakk>(it2 (f x), l2')\n                            \\<in> \\<langle>Rl\\<rangle>list_rel;\n                    f' x' = set l2'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        (it2 (f x), l') \\<in> \\<langle>Rl\\<rangle>list_rel;\n        RETURN l'\n        \\<le> it_to_sorted_list (\\<lambda>_ _. True) (f' x')\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (parametricity add: Cons.hyps(1) FR)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l'.\n       \\<lbrakk>\\<And>l2'.\n                   \\<lbrakk>(it2 (f x), l2')\n                            \\<in> \\<langle>Rl\\<rangle>list_rel;\n                    f' x' = set l2'\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        (it2 (f x), l') \\<in> \\<langle>Rl\\<rangle>list_rel;\n        RETURN l'\n        \\<le> it_to_sorted_list (\\<lambda>_ _. True) (f' x')\\<rbrakk>\n       \\<Longrightarrow> thesis", "by (auto simp: it_to_sorted_list_def)"], ["proof (state)\nthis:\n  (it2 (f x), l2') \\<in> \\<langle>Rl\\<rangle>list_rel\n  f' x' = set l2'\n\ngoal (1 subgoal):\n 1. \\<And>x x' l l' s0 s0'.\n       \\<lbrakk>(x, x') \\<in> Rk;\n        (l, l') \\<in> \\<langle>Rk\\<rangle>list_rel;\n        \\<And>s0 s0'.\n           (s0, s0')\n           \\<in> \\<langle>Rk \\<times>\\<^sub>r\n                          Rl\\<rangle>Rs3 \\<Longrightarrow>\n           (foldli l (\\<lambda>_. True)\n             (\\<lambda>x.\n                 foldli (it2 (f x)) (\\<lambda>_. True)\n                  (\\<lambda>y. insX (x, y)))\n             s0,\n            s0' \\<union> Sigma (set l') f')\n           \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3;\n        (s0, s0') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3\\<rbrakk>\n       \\<Longrightarrow> (foldli (x # l) (\\<lambda>_. True)\n                           (\\<lambda>x.\n                               foldli (it2 (f x)) (\\<lambda>_. True)\n                                (\\<lambda>y. insX (x, y)))\n                           s0,\n                          s0' \\<union> Sigma (set (x' # l')) f')\n                         \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3", "have \"(foldli (it2 (f x)) (\\<lambda>_. True) (\\<lambda>y. insX (x, y)) s0, \n        s0' \\<union> {x'}\\<times>f' x') \\<in> \\<langle>\\<langle>Rk,Rl\\<rangle>prod_rel\\<rangle>Rs3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (foldli (it2 (f x)) (\\<lambda>_. True) (\\<lambda>y. insX (x, y)) s0,\n     s0' \\<union> {x'} \\<times> f' x')\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3", "unfolding FXL"], ["proof (prove)\ngoal (1 subgoal):\n 1. (foldli (it2 (f x)) (\\<lambda>_. True) (\\<lambda>y. insX (x, y)) s0,\n     s0' \\<union> {x'} \\<times> set l2')\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3", "using IT2L \\<open>(s0, s0') \\<in> \\<langle>\\<langle>Rk, Rl\\<rangle>prod_rel\\<rangle>Rs3\\<close>"], ["proof (prove)\nusing this:\n  (it2 (f x), l2') \\<in> \\<langle>Rl\\<rangle>list_rel\n  (s0, s0') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3\n\ngoal (1 subgoal):\n 1. (foldli (it2 (f x)) (\\<lambda>_. True) (\\<lambda>y. insX (x, y)) s0,\n     s0' \\<union> {x'} \\<times> set l2')\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3", "apply (induct  arbitrary: s0 s0' rule: list_rel_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s0 s0'.\n       (s0, s0')\n       \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3 \\<Longrightarrow>\n       (foldli [] (\\<lambda>_. True) (\\<lambda>y. insX (x, y)) s0,\n        s0' \\<union> {x'} \\<times> set [])\n       \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3\n 2. \\<And>xa x'a l l' s0 s0'.\n       \\<lbrakk>(xa, x'a) \\<in> Rl;\n        (l, l') \\<in> \\<langle>Rl\\<rangle>list_rel;\n        \\<And>s0 s0'.\n           (s0, s0')\n           \\<in> \\<langle>Rk \\<times>\\<^sub>r\n                          Rl\\<rangle>Rs3 \\<Longrightarrow>\n           (foldli l (\\<lambda>_. True) (\\<lambda>y. insX (x, y)) s0,\n            s0' \\<union> {x'} \\<times> set l')\n           \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3;\n        (s0, s0') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3\\<rbrakk>\n       \\<Longrightarrow> (foldli (xa # l) (\\<lambda>_. True)\n                           (\\<lambda>y. insX (x, y)) s0,\n                          s0' \\<union> {x'} \\<times> set (x'a # l'))\n                         \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa x'a l l' s0 s0'.\n       \\<lbrakk>(xa, x'a) \\<in> Rl;\n        (l, l') \\<in> \\<langle>Rl\\<rangle>list_rel;\n        \\<And>s0 s0'.\n           (s0, s0')\n           \\<in> \\<langle>Rk \\<times>\\<^sub>r\n                          Rl\\<rangle>Rs3 \\<Longrightarrow>\n           (foldli l (\\<lambda>_. True) (\\<lambda>y. insX (x, y)) s0,\n            s0' \\<union> {x'} \\<times> set l')\n           \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3;\n        (s0, s0') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3\\<rbrakk>\n       \\<Longrightarrow> (foldli (xa # l) (\\<lambda>_. True)\n                           (\\<lambda>y. insX (x, y)) s0,\n                          s0' \\<union> {x'} \\<times> set (x'a # l'))\n                         \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa x'a l l' s0 s0'.\n       \\<lbrakk>(xa, x'a) \\<in> Rl;\n        (l, l') \\<in> \\<langle>Rl\\<rangle>list_rel;\n        \\<And>s0 s0'.\n           (s0, s0')\n           \\<in> \\<langle>Rk \\<times>\\<^sub>r\n                          Rl\\<rangle>Rs3 \\<Longrightarrow>\n           (foldli l (\\<lambda>_. True) (\\<lambda>y. insX (x, y)) s0,\n            s0' \\<union> {x'} \\<times> set l')\n           \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3;\n        (s0, s0') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3\\<rbrakk>\n       \\<Longrightarrow> (foldli l (\\<lambda>_. True)\n                           (\\<lambda>y. insX (x, y)) (insX (x, xa) s0),\n                          insert (x', x'a)\n                           (s0' \\<union> {x'} \\<times> set l'))\n                         \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3", "apply (subst Un_insert_left[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa x'a l l' s0 s0'.\n       \\<lbrakk>(xa, x'a) \\<in> Rl;\n        (l, l') \\<in> \\<langle>Rl\\<rangle>list_rel;\n        \\<And>s0 s0'.\n           (s0, s0')\n           \\<in> \\<langle>Rk \\<times>\\<^sub>r\n                          Rl\\<rangle>Rs3 \\<Longrightarrow>\n           (foldli l (\\<lambda>_. True) (\\<lambda>y. insX (x, y)) s0,\n            s0' \\<union> {x'} \\<times> set l')\n           \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3;\n        (s0, s0') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3\\<rbrakk>\n       \\<Longrightarrow> (foldli l (\\<lambda>_. True)\n                           (\\<lambda>y. insX (x, y)) (insX (x, xa) s0),\n                          insert (x', x'a) s0' \\<union>\n                          {x'} \\<times> set l')\n                         \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3", "apply (rprems)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa x'a l l' s0 s0'.\n       \\<lbrakk>(xa, x'a) \\<in> Rl;\n        (l, l') \\<in> \\<langle>Rl\\<rangle>list_rel;\n        (s0, s0') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3\\<rbrakk>\n       \\<Longrightarrow> (insX (x, xa) s0, insert (x', x'a) s0')\n                         \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3", "apply (parametricity add: INS \\<open>(x,x')\\<in>Rk\\<close>)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (foldli (it2 (f x)) (\\<lambda>_. True) (\\<lambda>y. insX (x, y)) s0,\n   s0' \\<union> {x'} \\<times> f' x')\n  \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3\n\ngoal (1 subgoal):\n 1. \\<And>x x' l l' s0 s0'.\n       \\<lbrakk>(x, x') \\<in> Rk;\n        (l, l') \\<in> \\<langle>Rk\\<rangle>list_rel;\n        \\<And>s0 s0'.\n           (s0, s0')\n           \\<in> \\<langle>Rk \\<times>\\<^sub>r\n                          Rl\\<rangle>Rs3 \\<Longrightarrow>\n           (foldli l (\\<lambda>_. True)\n             (\\<lambda>x.\n                 foldli (it2 (f x)) (\\<lambda>_. True)\n                  (\\<lambda>y. insX (x, y)))\n             s0,\n            s0' \\<union> Sigma (set l') f')\n           \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3;\n        (s0, s0') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3\\<rbrakk>\n       \\<Longrightarrow> (foldli (x # l) (\\<lambda>_. True)\n                           (\\<lambda>x.\n                               foldli (it2 (f x)) (\\<lambda>_. True)\n                                (\\<lambda>y. insX (x, y)))\n                           s0,\n                          s0' \\<union> Sigma (set (x' # l')) f')\n                         \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (foldli (x # l) (\\<lambda>_. True)\n      (\\<lambda>x.\n          foldli (it2 (f x)) (\\<lambda>_. True) (\\<lambda>y. insX (x, y)))\n      s0,\n     s0' \\<union> Sigma (set (x' # l')) f')\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (foldli l (\\<lambda>_. True)\n      (\\<lambda>x.\n          foldli (it2 (f x)) (\\<lambda>_. True) (\\<lambda>y. insX (x, y)))\n      (foldli (it2 (f x)) (\\<lambda>_. True) (\\<lambda>y. insX (x, y)) s0),\n     s0' \\<union> Sigma (insert x' (set l')) f')\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3", "apply (subst S)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (foldli l (\\<lambda>_. True)\n      (\\<lambda>x.\n          foldli (it2 (f x)) (\\<lambda>_. True) (\\<lambda>y. insX (x, y)))\n      (foldli (it2 (f x)) (\\<lambda>_. True) (\\<lambda>y. insX (x, y)) s0),\n     s0' \\<union> ({x'} \\<times> f' x' \\<union> Sigma (set l') f'))\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3", "apply (subst Un_assoc[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (foldli l (\\<lambda>_. True)\n      (\\<lambda>x.\n          foldli (it2 (f x)) (\\<lambda>_. True) (\\<lambda>y. insX (x, y)))\n      (foldli (it2 (f x)) (\\<lambda>_. True) (\\<lambda>y. insX (x, y)) s0),\n     s0' \\<union> {x'} \\<times> f' x' \\<union> Sigma (set l') f')\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3", "apply (rule Cons.hyps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (foldli (it2 (f x)) (\\<lambda>_. True) (\\<lambda>y. insX (x, y)) s0,\n     s0' \\<union> {x'} \\<times> f' x')\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3", "apply fact"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (foldli (x # l) (\\<lambda>_. True)\n    (\\<lambda>x.\n        foldli (it2 (f x)) (\\<lambda>_. True) (\\<lambda>y. insX (x, y)))\n    s0,\n   s0' \\<union> Sigma (set (x' # l')) f')\n  \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (foldli (it1 s) (\\<lambda>_. True)\n    (\\<lambda>x.\n        foldli (it2 (f x)) (\\<lambda>_. True) (\\<lambda>y. insX (x, y)))\n    s0,\n   s0' \\<union> Sigma s' f')\n  \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gen_Sigma[autoref_rules_raw]:\n    assumes PRIO_TAG_GEN_ALGO\n    assumes IT1: \"SIDE_GEN_ALGO (is_set_to_list Rk Rs1 it1)\"\n    assumes IT2: \"SIDE_GEN_ALGO (is_set_to_list Rl Rs2 it2)\"\n    assumes EMPTY: \n      \"GEN_OP empX {} (\\<langle>\\<langle>Rk,Rl\\<rangle>prod_rel\\<rangle>Rs3)\"\n    assumes INS: \n      \"GEN_OP insX Set.insert \n         (\\<langle>Rk,Rl\\<rangle>prod_rel\\<rightarrow>\\<langle>\\<langle>Rk,Rl\\<rangle>prod_rel\\<rangle>Rs3\\<rightarrow>\\<langle>\\<langle>Rk,Rl\\<rangle>prod_rel\\<rangle>Rs3)\"\n    shows \"(gen_Sigma (\\<lambda>x. foldli (it1 x)) (\\<lambda>x. foldli (it2 x)) empX insX,Sigma) \n      \\<in> (\\<langle>Rk\\<rangle>Rs1) \\<rightarrow> (Rk \\<rightarrow> \\<langle>Rl\\<rangle>Rs2) \\<rightarrow> \\<langle>\\<langle>Rk,Rl\\<rangle>prod_rel\\<rangle>Rs3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gen_Sigma (\\<lambda>x. foldli (it1 x)) (\\<lambda>x. foldli (it2 x))\n      empX insX,\n     Sigma)\n    \\<in> \\<langle>Rk\\<rangle>Rs1 \\<rightarrow>\n          (Rk \\<rightarrow> \\<langle>Rl\\<rangle>Rs2) \\<rightarrow>\n          \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3", "apply (intro fun_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> Rk \\<rightarrow> \\<langle>Rl\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (gen_Sigma (\\<lambda>x. foldli (it1 x))\n                           (\\<lambda>x. foldli (it2 x)) empX insX a aa,\n                          Sigma a' a'a)\n                         \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3", "unfolding gen_Sigma_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> Rk \\<rightarrow> \\<langle>Rl\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (foldli (it1 a) (\\<lambda>_. True)\n                           (\\<lambda>x.\n                               foldli (it2 (aa x)) (\\<lambda>_. True)\n                                (\\<lambda>y. insX (x, y)))\n                           empX,\n                          Sigma a' a'a)\n                         \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3", "using foldli_Sigma_aux[OF \n      IT1[unfolded autoref_tag_defs]\n      IT2[unfolded autoref_tag_defs]\n      INS[unfolded autoref_tag_defs]\n      EMPTY[unfolded autoref_tag_defs]\n    ]"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?s, ?s') \\<in> \\<langle>Rk\\<rangle>Rs1;\n   (?f, ?f') \\<in> Rk \\<rightarrow> \\<langle>Rl\\<rangle>Rs2\\<rbrakk>\n  \\<Longrightarrow> (foldli (it1 ?s) (\\<lambda>_. True)\n                      (\\<lambda>x.\n                          foldli (it2 (?f x)) (\\<lambda>_. True)\n                           (\\<lambda>y. insX (x, y)))\n                      empX,\n                     {} \\<union> Sigma ?s' ?f')\n                    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk\\<rangle>Rs1;\n        (aa, a'a) \\<in> Rk \\<rightarrow> \\<langle>Rl\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (foldli (it1 a) (\\<lambda>_. True)\n                           (\\<lambda>x.\n                               foldli (it2 (aa x)) (\\<lambda>_. True)\n                                (\\<lambda>y. insX (x, y)))\n                           empX,\n                          Sigma a' a'a)\n                         \\<in> \\<langle>Rk \\<times>\\<^sub>r Rl\\<rangle>Rs3", "by simp"], ["", "lemma gen_cart:\n  assumes PRIO_TAG_GEN_ALGO\n  assumes [param]: \"(sigma, Sigma) \\<in> (\\<langle>Rx\\<rangle>Rsx \\<rightarrow> (Rx \\<rightarrow> \\<langle>Ry\\<rangle>Rsy) \\<rightarrow> \\<langle>Rx \\<times>\\<^sub>r Ry\\<rangle>Rsp)\"\n  shows \"(\\<lambda>x y. sigma x (\\<lambda>_. y), op_set_cart) \\<in> \\<langle>Rx\\<rangle>Rsx \\<rightarrow> \\<langle>Ry\\<rangle>Rsy \\<rightarrow> \\<langle>Rx \\<times>\\<^sub>r Ry\\<rangle>Rsp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x y. sigma x (\\<lambda>_. y), op_set_cart)\n    \\<in> \\<langle>Rx\\<rangle>Rsx \\<rightarrow>\n          \\<langle>Ry\\<rangle>Rsy \\<rightarrow>\n          \\<langle>Rx \\<times>\\<^sub>r Ry\\<rangle>Rsp", "unfolding op_set_cart_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x y. sigma x (\\<lambda>_. y), (\\<times>))\n    \\<in> \\<langle>Rx\\<rangle>Rsx \\<rightarrow>\n          \\<langle>Ry\\<rangle>Rsy \\<rightarrow>\n          \\<langle>Rx \\<times>\\<^sub>r Ry\\<rangle>Rsp", "by parametricity"], ["", "lemmas [autoref_rules] = gen_cart[OF _ GEN_OP_D]"], ["", "context begin"], ["", "interpretation autoref_syn"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma op_set_to_sorted_list_autoref[autoref_rules]:\n    assumes \"SIDE_GEN_ALGO (is_set_to_sorted_list ordR Rk Rs tsl)\"\n    shows \"(\\<lambda>si. RETURN (tsl si),  OP (op_set_to_sorted_list ordR)) \n      \\<in> \\<langle>Rk\\<rangle>Rs \\<rightarrow> \\<langle>\\<langle>Rk\\<rangle>list_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>si. RETURN (tsl si), OP (op_set_to_sorted_list ordR))\n    \\<in> \\<langle>Rk\\<rangle>Rs \\<rightarrow>\n          \\<langle>\\<langle>Rk\\<rangle>list_rel\\<rangle>nres_rel", "using assms"], ["proof (prove)\nusing this:\n  SIDE_GEN_ALGO (is_set_to_sorted_list ordR Rk Rs tsl)\n\ngoal (1 subgoal):\n 1. (\\<lambda>si. RETURN (tsl si), OP (op_set_to_sorted_list ordR))\n    \\<in> \\<langle>Rk\\<rangle>Rs \\<rightarrow>\n          \\<langle>\\<langle>Rk\\<rangle>list_rel\\<rangle>nres_rel", "apply (intro fun_relI nres_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>SIDE_GEN_ALGO (is_set_to_sorted_list ordR Rk Rs tsl);\n        (a, a') \\<in> \\<langle>Rk\\<rangle>Rs\\<rbrakk>\n       \\<Longrightarrow> RETURN (tsl a)\n                         \\<le> \\<Down> (\\<langle>Rk\\<rangle>list_rel)\n                                (OP (op_set_to_sorted_list ordR) a')", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>is_set_to_sorted_list ordR Rk Rs tsl;\n        (a, a') \\<in> \\<langle>Rk\\<rangle>Rs\\<rbrakk>\n       \\<Longrightarrow> RETURN (tsl a)\n                         \\<le> \\<Down> (\\<langle>Rk\\<rangle>list_rel)\n                                (SPEC\n                                  (\\<lambda>l.\nset l = a' \\<and> distinct l \\<and> sorted_wrt ordR l))", "apply (rule RETURN_SPEC_refine)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>is_set_to_sorted_list ordR Rk Rs tsl;\n        (a, a') \\<in> \\<langle>Rk\\<rangle>Rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x'.\n                            (tsl a, x')\n                            \\<in> \\<langle>Rk\\<rangle>list_rel \\<and>\n                            set x' = a' \\<and>\n                            distinct x' \\<and> sorted_wrt ordR x'", "apply (auto simp: is_set_to_sorted_list_def it_to_sorted_list_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma op_set_to_list_autoref[autoref_rules]:\n    assumes \"SIDE_GEN_ALGO (is_set_to_sorted_list ordR Rk Rs tsl)\"\n    shows \"(\\<lambda>si. RETURN (tsl si), op_set_to_list) \n      \\<in> \\<langle>Rk\\<rangle>Rs \\<rightarrow> \\<langle>\\<langle>Rk\\<rangle>list_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>si. RETURN (tsl si), op_set_to_list)\n    \\<in> \\<langle>Rk\\<rangle>Rs \\<rightarrow>\n          \\<langle>\\<langle>Rk\\<rangle>list_rel\\<rangle>nres_rel", "using assms"], ["proof (prove)\nusing this:\n  SIDE_GEN_ALGO (is_set_to_sorted_list ordR Rk Rs tsl)\n\ngoal (1 subgoal):\n 1. (\\<lambda>si. RETURN (tsl si), op_set_to_list)\n    \\<in> \\<langle>Rk\\<rangle>Rs \\<rightarrow>\n          \\<langle>\\<langle>Rk\\<rangle>list_rel\\<rangle>nres_rel", "apply (intro fun_relI nres_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>SIDE_GEN_ALGO (is_set_to_sorted_list ordR Rk Rs tsl);\n        (a, a') \\<in> \\<langle>Rk\\<rangle>Rs\\<rbrakk>\n       \\<Longrightarrow> RETURN (tsl a)\n                         \\<le> \\<Down> (\\<langle>Rk\\<rangle>list_rel)\n                                (op_set_to_list a')", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>is_set_to_sorted_list ordR Rk Rs tsl;\n        (a, a') \\<in> \\<langle>Rk\\<rangle>Rs\\<rbrakk>\n       \\<Longrightarrow> RETURN (tsl a)\n                         \\<le> \\<Down> (\\<langle>Rk\\<rangle>list_rel)\n                                (SPEC\n                                  (\\<lambda>l.\nset l = a' \\<and> distinct l))", "apply (rule RETURN_SPEC_refine)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>is_set_to_sorted_list ordR Rk Rs tsl;\n        (a, a') \\<in> \\<langle>Rk\\<rangle>Rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x'.\n                            (tsl a, x')\n                            \\<in> \\<langle>Rk\\<rangle>list_rel \\<and>\n                            set x' = a' \\<and> distinct x'", "apply (auto simp: is_set_to_sorted_list_def it_to_sorted_list_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "lemma foldli_Union: \"det_fold_set X (\\<lambda>_. True) (\\<union>) {} Union\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det_fold_set X (\\<lambda>_. True) (\\<union>) {} \\<Union>", "proof (rule, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>distinct l; sorted_wrt X l\\<rbrakk>\n       \\<Longrightarrow> foldli l (\\<lambda>_. True) (\\<union>) {} =\n                         \\<Union> (set l)", "case (1 l)"], ["proof (state)\nthis:\n  distinct l\n  sorted_wrt X l\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>distinct l; sorted_wrt X l\\<rbrakk>\n       \\<Longrightarrow> foldli l (\\<lambda>_. True) (\\<union>) {} =\n                         \\<Union> (set l)", "have \"\\<forall>a. foldli l (\\<lambda>_. True) (\\<union>) a = a \\<union> \\<Union>(set l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a.\n       foldli l (\\<lambda>_. True) (\\<union>) a =\n       a \\<union> \\<Union> (set l)", "by (induct l) auto"], ["proof (state)\nthis:\n  \\<forall>a.\n     foldli l (\\<lambda>_. True) (\\<union>) a = a \\<union> \\<Union> (set l)\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>distinct l; sorted_wrt X l\\<rbrakk>\n       \\<Longrightarrow> foldli l (\\<lambda>_. True) (\\<union>) {} =\n                         \\<Union> (set l)", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>a.\n     foldli l (\\<lambda>_. True) (\\<union>) a = a \\<union> \\<Union> (set l)\n\ngoal (1 subgoal):\n 1. foldli l (\\<lambda>_. True) (\\<union>) {} = \\<Union> (set l)", "by auto"], ["proof (state)\nthis:\n  foldli l (\\<lambda>_. True) (\\<union>) {} = \\<Union> (set l)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition gen_Union\n  :: \"_ \\<Rightarrow> 's3 \\<Rightarrow> ('s2 \\<Rightarrow> 's3 \\<Rightarrow> 's3) \n      \\<Rightarrow> 's1 \\<Rightarrow> 's3\"\n  where \n  \"gen_Union it emp un X \\<equiv> it X (\\<lambda>_. True) un emp\""], ["", "lemma gen_Union[autoref_rules_raw]:\n  assumes PRIO_TAG_GEN_ALGO\n  assumes EMP: \"GEN_OP emp {} (\\<langle>Rk\\<rangle>Rs3)\"\n  assumes UN: \"GEN_OP un (\\<union>) (\\<langle>Rk\\<rangle>Rs2\\<rightarrow>\\<langle>Rk\\<rangle>Rs3\\<rightarrow>\\<langle>Rk\\<rangle>Rs3)\"\n  assumes IT: \"SIDE_GEN_ALGO (is_set_to_list (\\<langle>Rk\\<rangle>Rs2) Rs1 tsl)\"\n  shows \"(gen_Union (\\<lambda>x. foldli (tsl x)) emp un,Union) \\<in> \\<langle>\\<langle>Rk\\<rangle>Rs2\\<rangle>Rs1 \\<rightarrow> \\<langle>Rk\\<rangle>Rs3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gen_Union (\\<lambda>x. foldli (tsl x)) emp un, \\<Union>)\n    \\<in> \\<langle>\\<langle>Rk\\<rangle>Rs2\\<rangle>Rs1 \\<rightarrow>\n          \\<langle>Rk\\<rangle>Rs3", "apply (intro fun_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a')\n       \\<in> \\<langle>\\<langle>Rk\\<rangle>Rs2\\<rangle>Rs1 \\<Longrightarrow>\n       (gen_Union (\\<lambda>x. foldli (tsl x)) emp un a, \\<Union> a')\n       \\<in> \\<langle>Rk\\<rangle>Rs3", "unfolding gen_Union_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a')\n       \\<in> \\<langle>\\<langle>Rk\\<rangle>Rs2\\<rangle>Rs1 \\<Longrightarrow>\n       (foldli (tsl a) (\\<lambda>_. True) un emp, \\<Union> a')\n       \\<in> \\<langle>Rk\\<rangle>Rs3", "apply (rule det_fold_set[OF \n    foldli_Union IT[unfolded autoref_tag_defs]])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a a'.\n       (a, a')\n       \\<in> \\<langle>\\<langle>Rk\\<rangle>Rs2\\<rangle>Rs1 \\<Longrightarrow>\n       (a, a') \\<in> \\<langle>\\<langle>Rk\\<rangle>Rs2\\<rangle>Rs1\n 2. \\<And>a a'.\n       (a, a')\n       \\<in> \\<langle>\\<langle>Rk\\<rangle>Rs2\\<rangle>Rs1 \\<Longrightarrow>\n       (\\<lambda>_. True, \\<lambda>_. True)\n       \\<in> \\<langle>Rk\\<rangle>Rs3 \\<rightarrow> bool_rel\n 3. \\<And>a a'.\n       (a, a')\n       \\<in> \\<langle>\\<langle>Rk\\<rangle>Rs2\\<rangle>Rs1 \\<Longrightarrow>\n       (un, (\\<union>))\n       \\<in> \\<langle>Rk\\<rangle>Rs2 \\<rightarrow>\n             \\<langle>Rk\\<rangle>Rs3 \\<rightarrow> \\<langle>Rk\\<rangle>Rs3\n 4. \\<And>a a'.\n       (a, a')\n       \\<in> \\<langle>\\<langle>Rk\\<rangle>Rs2\\<rangle>Rs1 \\<Longrightarrow>\n       (emp, {}) \\<in> \\<langle>Rk\\<rangle>Rs3", "using EMP UN"], ["proof (prove)\nusing this:\n  GEN_OP emp {} (\\<langle>Rk\\<rangle>Rs3)\n  GEN_OP un (\\<union>)\n   (\\<langle>Rk\\<rangle>Rs2 \\<rightarrow>\n    \\<langle>Rk\\<rangle>Rs3 \\<rightarrow> \\<langle>Rk\\<rangle>Rs3)\n\ngoal (4 subgoals):\n 1. \\<And>a a'.\n       (a, a')\n       \\<in> \\<langle>\\<langle>Rk\\<rangle>Rs2\\<rangle>Rs1 \\<Longrightarrow>\n       (a, a') \\<in> \\<langle>\\<langle>Rk\\<rangle>Rs2\\<rangle>Rs1\n 2. \\<And>a a'.\n       (a, a')\n       \\<in> \\<langle>\\<langle>Rk\\<rangle>Rs2\\<rangle>Rs1 \\<Longrightarrow>\n       (\\<lambda>_. True, \\<lambda>_. True)\n       \\<in> \\<langle>Rk\\<rangle>Rs3 \\<rightarrow> bool_rel\n 3. \\<And>a a'.\n       (a, a')\n       \\<in> \\<langle>\\<langle>Rk\\<rangle>Rs2\\<rangle>Rs1 \\<Longrightarrow>\n       (un, (\\<union>))\n       \\<in> \\<langle>Rk\\<rangle>Rs2 \\<rightarrow>\n             \\<langle>Rk\\<rangle>Rs3 \\<rightarrow> \\<langle>Rk\\<rangle>Rs3\n 4. \\<And>a a'.\n       (a, a')\n       \\<in> \\<langle>\\<langle>Rk\\<rangle>Rs2\\<rangle>Rs1 \\<Longrightarrow>\n       (emp, {}) \\<in> \\<langle>Rk\\<rangle>Rs3", "unfolding autoref_tag_defs"], ["proof (prove)\nusing this:\n  (emp, {}) \\<in> \\<langle>Rk\\<rangle>Rs3\n  (un, (\\<union>))\n  \\<in> \\<langle>Rk\\<rangle>Rs2 \\<rightarrow>\n        \\<langle>Rk\\<rangle>Rs3 \\<rightarrow> \\<langle>Rk\\<rangle>Rs3\n\ngoal (4 subgoals):\n 1. \\<And>a a'.\n       (a, a')\n       \\<in> \\<langle>\\<langle>Rk\\<rangle>Rs2\\<rangle>Rs1 \\<Longrightarrow>\n       (a, a') \\<in> \\<langle>\\<langle>Rk\\<rangle>Rs2\\<rangle>Rs1\n 2. \\<And>a a'.\n       (a, a')\n       \\<in> \\<langle>\\<langle>Rk\\<rangle>Rs2\\<rangle>Rs1 \\<Longrightarrow>\n       (\\<lambda>_. True, \\<lambda>_. True)\n       \\<in> \\<langle>Rk\\<rangle>Rs3 \\<rightarrow> bool_rel\n 3. \\<And>a a'.\n       (a, a')\n       \\<in> \\<langle>\\<langle>Rk\\<rangle>Rs2\\<rangle>Rs1 \\<Longrightarrow>\n       (un, (\\<union>))\n       \\<in> \\<langle>Rk\\<rangle>Rs2 \\<rightarrow>\n             \\<langle>Rk\\<rangle>Rs3 \\<rightarrow> \\<langle>Rk\\<rangle>Rs3\n 4. \\<And>a a'.\n       (a, a')\n       \\<in> \\<langle>\\<langle>Rk\\<rangle>Rs2\\<rangle>Rs1 \\<Longrightarrow>\n       (emp, {}) \\<in> \\<langle>Rk\\<rangle>Rs3", "apply (parametricity)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition \"atLeastLessThan_impl a b \\<equiv> do {\n  (_,r) \\<leftarrow> WHILET (\\<lambda>(i,r). i<b) (\\<lambda>(i,r). RETURN (i+1, insert i r)) (a,{});\n  RETURN r\n}\""], ["", "lemma atLeastLessThan_impl_correct: \n  \"atLeastLessThan_impl a b \\<le> SPEC (\\<lambda>r. r = {a..<b::nat})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. atLeastLessThan_impl a b \\<le> SPEC (\\<lambda>r. r = {a..<b})", "unfolding atLeastLessThan_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILE\\<^sub>T (\\<lambda>(i, r). i < b)\n     (\\<lambda>(i, r). RETURN (i + 1, insert i r)) (a, {}) \\<bind>\n    (\\<lambda>(uu_, r). RETURN r)\n    \\<le> SPEC (\\<lambda>r. r = {a..<b})", "apply (refine_rcg refine_vcg WHILET_rule[where \n    I = \"\\<lambda>(i,r). r = {a..<i} \\<and> a\\<le>i \\<and> ((a<b \\<longrightarrow> i\\<le>b) \\<and> (\\<not>a<b \\<longrightarrow> i=a))\"\n    and R = \"measure (\\<lambda>(i,_). b - i)\"\n    ])"], ["proof (prove)\ngoal (11 subgoals):\n 1. wf (measure (\\<lambda>(i, uu_). b - i))\n 2. \\<And>x1 x2. (a, {}) = (x1, x2) \\<Longrightarrow> x2 = {a..<x1}\n 3. \\<And>x1 x2. (a, {}) = (x1, x2) \\<Longrightarrow> a \\<le> x1\n 4. \\<And>x1 x2.\n       \\<lbrakk>(a, {}) = (x1, x2); a < b\\<rbrakk>\n       \\<Longrightarrow> x1 \\<le> b\n 5. \\<And>x1 x2.\n       \\<lbrakk>(a, {}) = (x1, x2); \\<not> a < b\\<rbrakk>\n       \\<Longrightarrow> x1 = a\n 6. \\<And>s aa ba x1 x2.\n       \\<lbrakk>case s of\n                (i, r) \\<Rightarrow>\n                  r = {a..<i} \\<and>\n                  a \\<le> i \\<and>\n                  (a < b \\<longrightarrow> i \\<le> b) \\<and>\n                  (\\<not> a < b \\<longrightarrow> i = a);\n        case s of (i, r) \\<Rightarrow> i < b; s = (aa, ba);\n        (aa + 1, insert aa ba) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> x2 = {a..<x1}\n 7. \\<And>s aa ba x1 x2.\n       \\<lbrakk>case s of\n                (i, r) \\<Rightarrow>\n                  r = {a..<i} \\<and>\n                  a \\<le> i \\<and>\n                  (a < b \\<longrightarrow> i \\<le> b) \\<and>\n                  (\\<not> a < b \\<longrightarrow> i = a);\n        case s of (i, r) \\<Rightarrow> i < b; s = (aa, ba);\n        (aa + 1, insert aa ba) = (x1, x2)\\<rbrakk>\n       \\<Longrightarrow> a \\<le> x1\n 8. \\<And>s aa ba x1 x2.\n       \\<lbrakk>case s of\n                (i, r) \\<Rightarrow>\n                  r = {a..<i} \\<and>\n                  a \\<le> i \\<and>\n                  (a < b \\<longrightarrow> i \\<le> b) \\<and>\n                  (\\<not> a < b \\<longrightarrow> i = a);\n        case s of (i, r) \\<Rightarrow> i < b; s = (aa, ba);\n        (aa + 1, insert aa ba) = (x1, x2); a < b\\<rbrakk>\n       \\<Longrightarrow> x1 \\<le> b\n 9. \\<And>s aa ba x1 x2.\n       \\<lbrakk>case s of\n                (i, r) \\<Rightarrow>\n                  r = {a..<i} \\<and>\n                  a \\<le> i \\<and>\n                  (a < b \\<longrightarrow> i \\<le> b) \\<and>\n                  (\\<not> a < b \\<longrightarrow> i = a);\n        case s of (i, r) \\<Rightarrow> i < b; s = (aa, ba);\n        (aa + 1, insert aa ba) = (x1, x2); \\<not> a < b\\<rbrakk>\n       \\<Longrightarrow> x1 = a\n 10. \\<And>s aa ba.\n        \\<lbrakk>case s of\n                 (i, r) \\<Rightarrow>\n                   r = {a..<i} \\<and>\n                   a \\<le> i \\<and>\n                   (a < b \\<longrightarrow> i \\<le> b) \\<and>\n                   (\\<not> a < b \\<longrightarrow> i = a);\n         case s of (i, r) \\<Rightarrow> i < b; s = (aa, ba)\\<rbrakk>\n        \\<Longrightarrow> ((aa + 1, insert aa ba), s)\n                          \\<in> measure (\\<lambda>(i, uu_). b - i)\nA total of 11 subgoals...", "by auto"], ["", "schematic_goal atLeastLessThan_code_aux:\n  notes [autoref_rules] = IdI[of a] IdI[of b]\n  assumes [autoref_rules]: \"(emp,{})\\<in>Rs\"\n  assumes [autoref_rules]: \"(ins,insert)\\<in>nat_rel \\<rightarrow> Rs \\<rightarrow> Rs\"\n  shows \"(?c, atLeastLessThan_impl) \n  \\<in> nat_rel \\<rightarrow> nat_rel \\<rightarrow> \\<langle>Rs\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c, atLeastLessThan_impl)\n    \\<in> nat_rel \\<rightarrow>\n          nat_rel \\<rightarrow> \\<langle>Rs\\<rangle>nres_rel", "unfolding atLeastLessThan_impl_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?c,\n     \\<lambda>a b.\n        WHILE\\<^sub>T (\\<lambda>(i, r). i < b)\n         (\\<lambda>(i, r). RETURN (i + 1, insert i r)) (a, {}) \\<bind>\n        (\\<lambda>(uu_, r). RETURN r))\n    \\<in> nat_rel \\<rightarrow>\n          nat_rel \\<rightarrow> \\<langle>Rs\\<rangle>nres_rel", "apply (autoref (keep_goal))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "concrete_definition atLeastLessThan_code uses atLeastLessThan_code_aux"], ["", "schematic_goal atLeastLessThan_tr_aux:\n  \"RETURN ?c \\<le> atLeastLessThan_code emp ins a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?c \\<le> atLeastLessThan_code emp ins a b", "unfolding atLeastLessThan_code_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?c\n    \\<le> WHILE\\<^sub>T (\\<lambda>(xc, xd). xc < b)\n           (\\<lambda>(xc, xd). RETURN (xc + 1, ins xc xd)) (a, emp) \\<bind>\n          (\\<lambda>(xb, y). RETURN y)", "by (refine_transfer (post))"], ["", "concrete_definition atLeastLessThan_tr \n  for emp ins a b uses atLeastLessThan_tr_aux"], ["", "lemma atLeastLessThan_gen[autoref_rules]: \n  assumes \"PRIO_TAG_GEN_ALGO\"\n  assumes \"GEN_OP emp {} Rs\"\n  assumes \"GEN_OP ins insert (nat_rel \\<rightarrow> Rs \\<rightarrow> Rs)\"\n  shows \"(atLeastLessThan_tr emp ins, atLeastLessThan) \n    \\<in> nat_rel \\<rightarrow> nat_rel \\<rightarrow> Rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (atLeastLessThan_tr emp ins, atLeastLessThan)\n    \\<in> nat_rel \\<rightarrow> nat_rel \\<rightarrow> Rs", "proof (intro fun_relI, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>a = a'; aa = a'a\\<rbrakk>\n       \\<Longrightarrow> (atLeastLessThan_tr emp ins a' a'a, {a'..<a'a})\n                         \\<in> Rs", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>a = a'; aa = a'a\\<rbrakk>\n       \\<Longrightarrow> (atLeastLessThan_tr emp ins a' a'a, {a'..<a'a})\n                         \\<in> Rs", "from assms"], ["proof (chain)\npicking this:\n  PRIO_TAG_GEN_ALGO\n  GEN_OP emp {} Rs\n  GEN_OP ins insert (nat_rel \\<rightarrow> Rs \\<rightarrow> Rs)", "have GEN: \n    \"(emp,{})\\<in>Rs\" \"(ins,insert)\\<in>nat_rel \\<rightarrow> Rs \\<rightarrow> Rs\""], ["proof (prove)\nusing this:\n  PRIO_TAG_GEN_ALGO\n  GEN_OP emp {} Rs\n  GEN_OP ins insert (nat_rel \\<rightarrow> Rs \\<rightarrow> Rs)\n\ngoal (1 subgoal):\n 1. (emp, {}) \\<in> Rs &&&\n    (ins, insert) \\<in> nat_rel \\<rightarrow> Rs \\<rightarrow> Rs", "by auto"], ["proof (state)\nthis:\n  (emp, {}) \\<in> Rs\n  (ins, insert) \\<in> nat_rel \\<rightarrow> Rs \\<rightarrow> Rs\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>a = a'; aa = a'a\\<rbrakk>\n       \\<Longrightarrow> (atLeastLessThan_tr emp ins a' a'a, {a'..<a'a})\n                         \\<in> Rs", "note atLeastLessThan_tr.refine[of emp ins a b]"], ["proof (state)\nthis:\n  RETURN (atLeastLessThan_tr emp ins a b)\n  \\<le> atLeastLessThan_code emp ins a b\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>a = a'; aa = a'a\\<rbrakk>\n       \\<Longrightarrow> (atLeastLessThan_tr emp ins a' a'a, {a'..<a'a})\n                         \\<in> Rs", "also"], ["proof (state)\nthis:\n  RETURN (atLeastLessThan_tr emp ins a b)\n  \\<le> atLeastLessThan_code emp ins a b\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>a = a'; aa = a'a\\<rbrakk>\n       \\<Longrightarrow> (atLeastLessThan_tr emp ins a' a'a, {a'..<a'a})\n                         \\<in> Rs", "note \n    atLeastLessThan_code.refine[OF GEN,param_fo, OF IdI IdI, THEN nres_relD]"], ["proof (state)\nthis:\n  atLeastLessThan_code emp ins ?x2 ?x1\n  \\<le> \\<Down> Rs (atLeastLessThan_impl ?x2 ?x1)\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>a = a'; aa = a'a\\<rbrakk>\n       \\<Longrightarrow> (atLeastLessThan_tr emp ins a' a'a, {a'..<a'a})\n                         \\<in> Rs", "also"], ["proof (state)\nthis:\n  atLeastLessThan_code emp ins ?x2 ?x1\n  \\<le> \\<Down> Rs (atLeastLessThan_impl ?x2 ?x1)\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>a = a'; aa = a'a\\<rbrakk>\n       \\<Longrightarrow> (atLeastLessThan_tr emp ins a' a'a, {a'..<a'a})\n                         \\<in> Rs", "note atLeastLessThan_impl_correct"], ["proof (state)\nthis:\n  atLeastLessThan_impl ?a ?b \\<le> SPEC (\\<lambda>r. r = {?a..<?b})\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>a = a'; aa = a'a\\<rbrakk>\n       \\<Longrightarrow> (atLeastLessThan_tr emp ins a' a'a, {a'..<a'a})\n                         \\<in> Rs", "finally"], ["proof (chain)\npicking this:\n  RETURN (atLeastLessThan_tr emp ins a b)\n  \\<le> \\<Down> Rs (SPEC (\\<lambda>r. r = {a..<b}))", "show \"(atLeastLessThan_tr emp ins a b, {a..<b}) \\<in> Rs\""], ["proof (prove)\nusing this:\n  RETURN (atLeastLessThan_tr emp ins a b)\n  \\<le> \\<Down> Rs (SPEC (\\<lambda>r. r = {a..<b}))\n\ngoal (1 subgoal):\n 1. (atLeastLessThan_tr emp ins a b, {a..<b}) \\<in> Rs", "by (auto simp: pw_le_iff refine_pw_simps)"], ["proof (state)\nthis:\n  (atLeastLessThan_tr emp ins a b, {a..<b}) \\<in> Rs\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}