{"file_name": "/home/qj213/afp-2021-10-22/thys/Collections/Iterator/SetAbstractionIterator.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Collections", "problem_names": ["lemma remove_abs :\n    assumes f_OK: \"\\<And>xc. invar xc \\<Longrightarrow> \\<alpha> xc \\<in> S0 \\<Longrightarrow> fc xc = fa (\\<alpha> xc)\"\n        and it_OK: \"\\<And>iti. set_iterator_genord iti S0 R \\<Longrightarrow> P (iti c fa \\<sigma>0)\"\n    shows \"P (iti c fc \\<sigma>0)\"", "lemma remove_abs2 :\n    \"\\<exists>S0'. set_iterator_genord iti S0' (\\<lambda>x y. R (\\<alpha> x) (\\<alpha> y)) \\<and>\n           inj_on \\<alpha> S0' \\<and> \\<alpha> ` S0' = S0 \\<and> (\\<forall>x \\<in> S0'. invar x)\"", "lemma iteratei_abs_simple_rule_P:\n  assumes f_OK: \"\\<And>xc. invar xc \\<Longrightarrow> \\<alpha> xc \\<in> S0 \\<Longrightarrow> f xc = f' (\\<alpha> xc)\"\n  assumes pre :\n      \"I S0 \\<sigma>0\"\n      \"\\<And>S \\<sigma> x. \\<lbrakk> c \\<sigma>; x \\<in> S; I S \\<sigma>; S \\<subseteq> S0; \n                 \\<forall>y\\<in>S - {x}. R x y; \\<forall>y\\<in>S0 - S. R y x\\<rbrakk> \n                 \\<Longrightarrow> I (S - {x}) (f' x \\<sigma>)\"\n      \"\\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n      \"\\<And>\\<sigma> S. \\<lbrakk> S \\<subseteq> S0; S \\<noteq> {}; \\<not> c \\<sigma>; I S \\<sigma>;\n               \\<forall>x\\<in>S. \\<forall>y\\<in>S0-S. R y x \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n    shows \"P (iti c f \\<sigma>0)\"", "lemma iteratei_abs_simple_rule_insert_P:\n  assumes f_OK: \"\\<And>xc. invar xc \\<Longrightarrow> \\<alpha> xc \\<in> S0 \\<Longrightarrow> f xc = f' (\\<alpha> xc)\"\n  assumes pre :\n      \"I {} \\<sigma>0\"\n      \"\\<And>S \\<sigma> x. \\<lbrakk> c \\<sigma>; x \\<in> S0 - S; I S \\<sigma>; S \\<subseteq> S0; \\<forall>y\\<in>(S0 - S) - {x}. R x y;\n                 \\<forall>y\\<in>S. R y x\\<rbrakk> \n                  \\<Longrightarrow> I (insert x S) (f' x \\<sigma>)\"\n      \"\\<And>\\<sigma>. I S0 \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n      \"\\<And>\\<sigma> S. \\<lbrakk> S \\<subseteq> S0; S \\<noteq> S0; \n              \\<not> (c \\<sigma>); I S \\<sigma>; \\<forall>x\\<in>S0-S. \\<forall>y\\<in>S. R y x \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n  shows \"P (iti c f \\<sigma>0)\"", "lemma iteratei_abs_rule_P:\n  assumes pre :\n      \"I S0 \\<sigma>0\"\n      \"\\<And>S \\<sigma> x. \\<lbrakk> c \\<sigma>; invar x; \\<alpha> x \\<in> S; I S \\<sigma>; S \\<subseteq> S0; \n                 \\<forall>y\\<in>S - {\\<alpha> x}. R (\\<alpha> x) y; \\<forall>y\\<in>S0 - S. R y (\\<alpha> x)\\<rbrakk> \n                 \\<Longrightarrow> I (S - {\\<alpha> x}) (f x \\<sigma>)\"\n      \"\\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n      \"\\<And>\\<sigma> S. \\<lbrakk> S \\<subseteq> S0; S \\<noteq> {}; \\<not> c \\<sigma>; I S \\<sigma>;\n               \\<forall>x\\<in>S. \\<forall>y\\<in>S0-S. R y x \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n    shows \"P (iti c f \\<sigma>0)\"", "lemma iteratei_abs_rule_insert_P:\n  assumes pre :\n      \"I {} \\<sigma>0\"\n      \"\\<And>S \\<sigma> x. \\<lbrakk> c \\<sigma>; invar x; \\<alpha> x \\<in> S0 - S; I S \\<sigma>; S \\<subseteq> S0; \n                 \\<forall>y\\<in>(S0 - S) - {\\<alpha> x}. R (\\<alpha> x) y; \\<forall>y\\<in>S. R y (\\<alpha> x)\\<rbrakk> \n                 \\<Longrightarrow> I (insert (\\<alpha> x) S) (f x \\<sigma>)\"\n      \"\\<And>\\<sigma>. I S0 \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n      \"\\<And>\\<sigma> S. \\<lbrakk> S \\<subseteq> S0; S \\<noteq> S0; \\<not> c \\<sigma>; I S \\<sigma>;\n               \\<forall>x\\<in>S0-S. \\<forall>y\\<in>S. R y x \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n    shows \"P (iti c f \\<sigma>0)\"", "lemma set_iterator_abs_genord_trivial:\n  \"set_iterator_abs_genord id (\\<lambda>_. True) = set_iterator_genord\"", "lemma set_iterator_abs_genord_trivial_simp [simp] :\n  assumes \"\\<forall>x. invar x\"\n      and \"\\<forall>x. \\<alpha> x = x\"\nshows \"set_iterator_abs_genord \\<alpha> invar = set_iterator_genord\"", "lemma set_iterator_abs_genord_I2 :\n  assumes it_OK: \"set_iterator_genord iti S0 Rc\"\n      and R_OK: \"\\<And>xc1 xc2. \\<lbrakk>invar xc1; invar xc2; Rc xc1 xc2\\<rbrakk> \\<Longrightarrow> Ra (\\<alpha> xc1) (\\<alpha> xc2)\"\n      and dist: \"\\<And>xc1 xc2. \\<lbrakk>invar xc1; invar xc2; xc1 \\<in> S0; xc2 \\<in> S0; \\<alpha> xc1 = \\<alpha> xc2\\<rbrakk> \\<Longrightarrow> xc1 = xc2\"\n      and invar: \"\\<And>xc. xc \\<in> S0 \\<Longrightarrow> invar xc\"\n      and S0'_eq: \"S0' = \\<alpha> ` S0\"\n  shows \"set_iterator_abs_genord \\<alpha> invar iti S0' Ra\"", "lemma map_to_set_cong: \n  \"map_to_set m1 = map_to_set m2 \\<longleftrightarrow> m1 = m2\"", "lemma map_iterator_abs_genord_I2 :\n  assumes it_OK: \"map_iterator_genord iti m R'\"\n      and invar: \"\\<And>k v. m k = Some v \\<Longrightarrow> invar v\"\n      and R_OK: \"\\<And>k v k' v'. invar v \\<Longrightarrow> invar v' \\<Longrightarrow> R' (k, v) (k', v') \\<Longrightarrow> R (k, \\<alpha> v) (k', \\<alpha> v')\"\n      and m'_eq: \"m' = ((map_option \\<alpha>) o m)\"\n  shows \"map_iterator_abs_genord \\<alpha> invar iti m' R\"", "lemma map_iterator_abs_genord_remove_abs2 :\n  assumes iti: \"map_iterator_abs_genord \\<alpha> invar iti m R\"\n  obtains m' where \"map_iterator_genord iti m' (\\<lambda>(k, v) (k', v'). R (k, \\<alpha> v) (k', \\<alpha> v'))\"\n       \"(map_option \\<alpha>) o m' = m\" \"\\<And>k v. m' k = Some v \\<Longrightarrow> invar v\"", "lemma map_iterator_abs_genord_rule_P:\n  assumes iti_OK: \"map_iterator_abs_genord \\<alpha> invar iti m R\"\n      and I0: \"I (dom m) \\<sigma>0\"\n      and IP: \"!!k v it \\<sigma>. \\<lbrakk> c \\<sigma>; k \\<in> it; invar v; m k = Some (\\<alpha> v); it \\<subseteq> dom m; I it \\<sigma>; \n                             \\<forall>k' v'. k' \\<in> it-{k} \\<and> invar v' \\<and> m k' = Some (\\<alpha> v') \\<longrightarrow> R (k, \\<alpha> v) (k', \\<alpha> v');\n                             \\<forall>k' v'. k' \\<notin> it \\<and> invar v' \\<and> m k' = Some (\\<alpha> v') \\<longrightarrow> R (k', \\<alpha> v') (k, \\<alpha> v)\\<rbrakk> \\<Longrightarrow> \n                            I (it - {k}) (f (k, v) \\<sigma>)\"\n      and IF: \"!!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n      and II: \"!!\\<sigma> it. \\<lbrakk> it \\<subseteq> dom m; it \\<noteq> {}; \\<not> c \\<sigma>; I it \\<sigma>;\n                         \\<forall>k v k' v'. k \\<notin> it \\<and> invar v \\<and> m k = Some (\\<alpha> v) \\<and> \n                                     k' \\<in> it \\<and> invar v' \\<and> m k' = Some (\\<alpha> v') \\<longrightarrow> \n                                     R (k, \\<alpha> v) (k', \\<alpha> v') \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n  shows \"P (iti c f \\<sigma>0)\"", "lemma map_iterator_abs_genord_rule_insert_P:\n  assumes iti_OK: \"map_iterator_abs_genord \\<alpha> invar iti m R\"\n      and I0: \"I {} \\<sigma>0\"\n      and IP: \"!!k v it \\<sigma>. \\<lbrakk> c \\<sigma>; k \\<in> dom m - it; invar v; m k = Some (\\<alpha> v); it \\<subseteq> dom m; I it \\<sigma>; \n                             \\<forall>k' v'. k' \\<in> (dom m - it)-{k} \\<and> invar v' \\<and> m k' = Some (\\<alpha> v') \\<longrightarrow> R (k, \\<alpha> v) (k', \\<alpha> v');\n                             \\<forall>k' v'. k' \\<in> it \\<and> invar v' \\<and> m k' = Some (\\<alpha> v') \\<longrightarrow> R (k', \\<alpha> v') (k, \\<alpha> v)\\<rbrakk> \\<Longrightarrow> \n                            I (insert k it) (f (k, v) \\<sigma>)\"\n      and IF: \"!!\\<sigma>. I (dom m) \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n      and II: \"!!\\<sigma> it. \\<lbrakk> it \\<subseteq> dom m; it \\<noteq> dom m; \\<not> c \\<sigma>; I it \\<sigma>;\n                         \\<forall>k v k' v'. k \\<in> it \\<and> invar v \\<and> m k = Some (\\<alpha> v) \\<and> \n                                     k' \\<notin> it \\<and> invar v' \\<and> m k' = Some (\\<alpha> v') \\<longrightarrow> \n                                     R (k, \\<alpha> v) (k', \\<alpha> v') \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n  shows \"P (iti c f \\<sigma>0)\"", "lemma set_iterator_abs_trivial:\n  \"set_iterator_abs id (\\<lambda>_. True) = set_iterator\"", "lemma set_iterator_abs_trivial_simp [simp]:\n  assumes \"\\<forall>x. invar x\"\n      and \"\\<forall>x. \\<alpha> x = x\"\nshows \"set_iterator_abs \\<alpha> invar = set_iterator\"", "lemma set_iterator_abs_I2 :\n  assumes it_OK: \"set_iterator iti S0\"\n      and dist: \"\\<And>xc1 xc2. \\<lbrakk>invar xc1; invar xc2; xc1 \\<in> S0; xc2 \\<in> S0; \\<alpha> xc1 = \\<alpha> xc2\\<rbrakk> \\<Longrightarrow> xc1 = xc2\"\n      and invar: \"\\<And>xc. xc \\<in> S0 \\<Longrightarrow> invar xc\"\n      and S0'_OK: \"S0' = \\<alpha> ` S0\"\n  shows \"set_iterator_abs \\<alpha> invar iti S0'\"", "lemma set_iterator_abs_simple_rule_P:\n\"\\<lbrakk> set_iterator_abs \\<alpha> invar it S0;\n   (\\<And>xc. invar xc \\<Longrightarrow> f xc = f' (\\<alpha> xc));\n   I S0 \\<sigma>0;\n   !!S \\<sigma> x. \\<lbrakk> c \\<sigma>; x \\<in> S; I S \\<sigma>; S \\<subseteq> S0 \\<rbrakk> \\<Longrightarrow> I (S - {x}) (f' x \\<sigma>);\n   !!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>;\n   !!\\<sigma> S. S \\<subseteq> S0 \\<Longrightarrow> S \\<noteq> {} \\<Longrightarrow> \\<not> c \\<sigma> \\<Longrightarrow> I S \\<sigma> \\<Longrightarrow> P \\<sigma>\n \\<rbrakk> \\<Longrightarrow> P (it c f \\<sigma>0)\"", "lemma set_iterator_abs_simple_no_cond_rule_P:\n\"\\<lbrakk> set_iterator_abs \\<alpha> invar it S0;\n   (\\<And>xc. invar xc \\<Longrightarrow> f xc = f' (\\<alpha> xc));\n   I S0 \\<sigma>0;\n   !!S \\<sigma> x. \\<lbrakk> x \\<in> S; I S \\<sigma>; S \\<subseteq> S0 \\<rbrakk> \\<Longrightarrow> I (S - {x}) (f' x \\<sigma>);\n   !!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\n \\<rbrakk> \\<Longrightarrow> P (it (\\<lambda>_. True) f \\<sigma>0)\"", "lemma set_iterator_abs_simple_rule_insert_P :\n\"\\<lbrakk> set_iterator_abs \\<alpha> invar it S0;\n   (\\<And>xc. invar xc \\<Longrightarrow> f xc = f' (\\<alpha> xc));\n   I {} \\<sigma>0;\n   !!S \\<sigma> x. \\<lbrakk> c \\<sigma>; x \\<in> S0 - S; I S \\<sigma>; S \\<subseteq> S0 \\<rbrakk>  \\<Longrightarrow> I (insert x S) (f' x \\<sigma>);\n   !!\\<sigma>. I S0 \\<sigma> \\<Longrightarrow> P \\<sigma>;\n   !!\\<sigma> S. S \\<subseteq> S0 \\<Longrightarrow> S \\<noteq> S0 \\<Longrightarrow> \\<not> c \\<sigma> \\<Longrightarrow> I S \\<sigma> \\<Longrightarrow> P \\<sigma>\n \\<rbrakk> \\<Longrightarrow> P (it c f \\<sigma>0)\"", "lemma set_iterator_abs_no_cond_simple_rule_insert_P :\n\"\\<lbrakk> set_iterator_abs \\<alpha> invar it S0;\n   (\\<And>xc. invar xc \\<Longrightarrow> f xc = f' (\\<alpha> xc));\n   I {} \\<sigma>0;\n   !!S \\<sigma> x. \\<lbrakk> x \\<in> S0 - S; I S \\<sigma>; S \\<subseteq> S0 \\<rbrakk>  \\<Longrightarrow> I (insert x S) (f' x \\<sigma>);\n   !!\\<sigma>. I S0 \\<sigma> \\<Longrightarrow> P \\<sigma>\n \\<rbrakk> \\<Longrightarrow> P (it (\\<lambda>_. True) f \\<sigma>0)\"", "lemma set_iterator_abs_rule_P:\n\"\\<lbrakk> set_iterator_abs \\<alpha> invar it S0;\n   I S0 \\<sigma>0;\n   !!S \\<sigma> x. \\<lbrakk> c \\<sigma>; invar x; \\<alpha> x \\<in> S; I S \\<sigma>; S \\<subseteq> S0 \\<rbrakk> \\<Longrightarrow> I (S - {\\<alpha> x}) (f x \\<sigma>);\n   !!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>;\n   !!\\<sigma> S. S \\<subseteq> S0 \\<Longrightarrow> S \\<noteq> {} \\<Longrightarrow> \\<not> c \\<sigma> \\<Longrightarrow> I S \\<sigma> \\<Longrightarrow> P \\<sigma>\n \\<rbrakk> \\<Longrightarrow> P (it c f \\<sigma>0)\"", "lemma set_iterator_abs_no_cond_rule_P:\n\"\\<lbrakk> set_iterator_abs \\<alpha> invar it S0;\n   I S0 \\<sigma>0;\n   !!S \\<sigma> x. \\<lbrakk> invar x; \\<alpha> x \\<in> S; I S \\<sigma>; S \\<subseteq> S0 \\<rbrakk> \\<Longrightarrow> I (S - {\\<alpha> x}) (f x \\<sigma>);\n   !!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\n \\<rbrakk> \\<Longrightarrow> P (it (\\<lambda>_. True) f \\<sigma>0)\"", "lemma set_iterator_abs_rule_insert_P :\n\"\\<lbrakk> set_iterator_abs \\<alpha> invar it S0;\n   I {} \\<sigma>0;\n   !!S \\<sigma> x. \\<lbrakk> c \\<sigma>; invar x; \\<alpha> x \\<in> S0 - S; I S \\<sigma>; S \\<subseteq> S0 \\<rbrakk>  \\<Longrightarrow> I (insert (\\<alpha> x) S) (f x \\<sigma>);\n   !!\\<sigma>. I S0 \\<sigma> \\<Longrightarrow> P \\<sigma>;\n   !!\\<sigma> S. S \\<subseteq> S0 \\<Longrightarrow> S \\<noteq> S0 \\<Longrightarrow> \\<not> c \\<sigma> \\<Longrightarrow> I S \\<sigma> \\<Longrightarrow> P \\<sigma>\n \\<rbrakk> \\<Longrightarrow> P (it c f \\<sigma>0)\"", "lemma set_iterator_abs_no_cond_rule_insert_P :\n\"\\<lbrakk> set_iterator_abs \\<alpha> invar it S0;\n   I {} \\<sigma>0;\n   !!S \\<sigma> x. \\<lbrakk> invar x; \\<alpha> x \\<in> S0 - S; I S \\<sigma>; S \\<subseteq> S0 \\<rbrakk>  \\<Longrightarrow> I (insert (\\<alpha> x) S) (f x \\<sigma>);\n   !!\\<sigma>. I S0 \\<sigma> \\<Longrightarrow> P \\<sigma>\n \\<rbrakk> \\<Longrightarrow> P (it (\\<lambda>_. True) f \\<sigma>0)\"", "lemma map_iterator_abs_trivial:\n  \"map_iterator_abs id (\\<lambda>_. True) = map_iterator\"", "lemma map_iterator_abs_trivial_simp [simp] :\n  assumes \"\\<forall>x. invar x\"\n      and \"\\<forall>x. \\<alpha> x = x\"\nshows \"map_iterator_abs \\<alpha> invar = map_iterator\"", "lemma map_iterator_abs_I2 :\n  assumes it_OK: \"map_iterator iti m\"\n      and invar: \"\\<And>k v. m k = Some v \\<Longrightarrow> invar v\"\n      and m'_eq: \"m' = map_option \\<alpha> \\<circ> m\"\n  shows \"map_iterator_abs \\<alpha> invar iti m'\"", "lemma map_iterator_abs_rule_P:\n  assumes iti_OK: \"map_iterator_abs \\<alpha> invar iti m\"\n      and I0: \"I (dom m) \\<sigma>0\"\n      and IP: \"!!k v it \\<sigma>. \\<lbrakk> c \\<sigma>; k \\<in> it; invar v; m k = Some (\\<alpha> v); it \\<subseteq> dom m; I it \\<sigma> \\<rbrakk> \\<Longrightarrow> \n                            I (it - {k}) (f (k, v) \\<sigma>)\"\n      and IF: \"!!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n      and II: \"!!\\<sigma> it. \\<lbrakk> it \\<subseteq> dom m; it \\<noteq> {}; \\<not> c \\<sigma>; I it \\<sigma> \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n  shows \"P (iti c f \\<sigma>0)\"", "lemma map_iterator_abs_no_cond_rule_P:\n  assumes iti_OK: \"map_iterator_abs \\<alpha> invar iti m\"\n      and I0: \"I (dom m) \\<sigma>0\"\n      and IP: \"!!k v it \\<sigma>. \\<lbrakk> k \\<in> it; invar v; m k = Some (\\<alpha> v); it \\<subseteq> dom m; I it \\<sigma> \\<rbrakk> \\<Longrightarrow> \n                            I (it - {k}) (f (k, v) \\<sigma>)\"\n      and IF: \"!!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n  shows \"P (iti (\\<lambda>_. True) f \\<sigma>0)\"", "lemma map_iterator_abs_rule_insert_P:\n  assumes iti_OK: \"map_iterator_abs \\<alpha> invar iti m\"\n      and I0: \"I {} \\<sigma>0\"\n      and IP: \"!!k v it \\<sigma>. \\<lbrakk> c \\<sigma>; k \\<in> dom m - it; invar v; m k = Some (\\<alpha> v); it \\<subseteq> dom m; I it \\<sigma> \\<rbrakk> \\<Longrightarrow> \n                            I (insert k it) (f (k, v) \\<sigma>)\"\n      and IF: \"!!\\<sigma>. I (dom m) \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n      and II: \"!!\\<sigma> it. \\<lbrakk> it \\<subseteq> dom m; it \\<noteq> dom m; \\<not> c \\<sigma>; I it \\<sigma> \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n  shows \"P (iti c f \\<sigma>0)\"", "lemma map_iterator_abs_no_cond_rule_insert_P:\n  assumes iti_OK: \"map_iterator_abs \\<alpha> invar iti m\"\n      and I0: \"I {} \\<sigma>0\"\n      and IP: \"!!k v it \\<sigma>. \\<lbrakk> k \\<in> dom m - it; invar v; m k = Some (\\<alpha> v); it \\<subseteq> dom m; I it \\<sigma> \\<rbrakk> \\<Longrightarrow> \n                            I (insert k it) (f (k, v) \\<sigma>)\"\n      and IF: \"!!\\<sigma>. I (dom m) \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n  shows \"P (iti (\\<lambda>_. True) f \\<sigma>0)\""], "translations": [["", "lemma remove_abs :\n    assumes f_OK: \"\\<And>xc. invar xc \\<Longrightarrow> \\<alpha> xc \\<in> S0 \\<Longrightarrow> fc xc = fa (\\<alpha> xc)\"\n        and it_OK: \"\\<And>iti. set_iterator_genord iti S0 R \\<Longrightarrow> P (iti c fa \\<sigma>0)\"\n    shows \"P (iti c fc \\<sigma>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (iti c fc \\<sigma>0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P (iti c fc \\<sigma>0)", "from foldli_transform"], ["proof (chain)\npicking this:\n  \\<exists>lc.\n     (\\<forall>xc\\<in>set lc. invar xc) \\<and>\n     distinct (map \\<alpha> lc) \\<and>\n     S0 = set (map \\<alpha> lc) \\<and>\n     sorted_wrt R (map \\<alpha> lc) \\<and> iti = foldli lc", "obtain lc where \n          lc_invar: \"\\<And>xc. xc \\<in> set lc \\<Longrightarrow> invar xc\" \n      and \\<alpha>_props: \"distinct (map \\<alpha> lc)\" \"S0 = set (map \\<alpha> lc)\" \n                   \"sorted_wrt R (map \\<alpha> lc)\" \n      and iti_eq: \"iti = foldli lc\""], ["proof (prove)\nusing this:\n  \\<exists>lc.\n     (\\<forall>xc\\<in>set lc. invar xc) \\<and>\n     distinct (map \\<alpha> lc) \\<and>\n     S0 = set (map \\<alpha> lc) \\<and>\n     sorted_wrt R (map \\<alpha> lc) \\<and> iti = foldli lc\n\ngoal (1 subgoal):\n 1. (\\<And>lc.\n        \\<lbrakk>\\<And>xc. xc \\<in> set lc \\<Longrightarrow> invar xc;\n         distinct (map \\<alpha> lc); S0 = set (map \\<alpha> lc);\n         sorted_wrt R (map \\<alpha> lc); iti = foldli lc\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ?xc \\<in> set lc \\<Longrightarrow> invar ?xc\n  distinct (map \\<alpha> lc)\n  S0 = set (map \\<alpha> lc)\n  sorted_wrt R (map \\<alpha> lc)\n  iti = foldli lc\n\ngoal (1 subgoal):\n 1. P (iti c fc \\<sigma>0)", "from \\<alpha>_props"], ["proof (chain)\npicking this:\n  distinct (map \\<alpha> lc)\n  S0 = set (map \\<alpha> lc)\n  sorted_wrt R (map \\<alpha> lc)", "have \"set_iterator_genord (foldli (map \\<alpha> lc)) S0 R\""], ["proof (prove)\nusing this:\n  distinct (map \\<alpha> lc)\n  S0 = set (map \\<alpha> lc)\n  sorted_wrt R (map \\<alpha> lc)\n\ngoal (1 subgoal):\n 1. set_iterator_genord (foldli (map \\<alpha> lc)) S0 R", "by (rule_tac set_iterator_genord_I [of \"map \\<alpha> lc\"]) simp_all"], ["proof (state)\nthis:\n  set_iterator_genord (foldli (map \\<alpha> lc)) S0 R\n\ngoal (1 subgoal):\n 1. P (iti c fc \\<sigma>0)", "with it_OK"], ["proof (chain)\npicking this:\n  set_iterator_genord ?iti S0 R \\<Longrightarrow> P (?iti c fa \\<sigma>0)\n  set_iterator_genord (foldli (map \\<alpha> lc)) S0 R", "have P_OK: \"P (foldli (map \\<alpha> lc) c fa \\<sigma>0)\""], ["proof (prove)\nusing this:\n  set_iterator_genord ?iti S0 R \\<Longrightarrow> P (?iti c fa \\<sigma>0)\n  set_iterator_genord (foldli (map \\<alpha> lc)) S0 R\n\ngoal (1 subgoal):\n 1. P (foldli (map \\<alpha> lc) c fa \\<sigma>0)", "by blast"], ["proof (state)\nthis:\n  P (foldli (map \\<alpha> lc) c fa \\<sigma>0)\n\ngoal (1 subgoal):\n 1. P (iti c fc \\<sigma>0)", "from lc_invar f_OK[unfolded \\<alpha>_props(2)]"], ["proof (chain)\npicking this:\n  ?xc \\<in> set lc \\<Longrightarrow> invar ?xc\n  \\<lbrakk>invar ?xc; \\<alpha> ?xc \\<in> set (map \\<alpha> lc)\\<rbrakk>\n  \\<Longrightarrow> fc ?xc = fa (\\<alpha> ?xc)", "have \"foldli (map \\<alpha> lc) c fa \\<sigma>0 = foldli lc c fc \\<sigma>0\""], ["proof (prove)\nusing this:\n  ?xc \\<in> set lc \\<Longrightarrow> invar ?xc\n  \\<lbrakk>invar ?xc; \\<alpha> ?xc \\<in> set (map \\<alpha> lc)\\<rbrakk>\n  \\<Longrightarrow> fc ?xc = fa (\\<alpha> ?xc)\n\ngoal (1 subgoal):\n 1. foldli (map \\<alpha> lc) c fa \\<sigma>0 = foldli lc c fc \\<sigma>0", "by (induct lc arbitrary: \\<sigma>0) simp_all"], ["proof (state)\nthis:\n  foldli (map \\<alpha> lc) c fa \\<sigma>0 = foldli lc c fc \\<sigma>0\n\ngoal (1 subgoal):\n 1. P (iti c fc \\<sigma>0)", "with P_OK iti_eq"], ["proof (chain)\npicking this:\n  P (foldli (map \\<alpha> lc) c fa \\<sigma>0)\n  iti = foldli lc\n  foldli (map \\<alpha> lc) c fa \\<sigma>0 = foldli lc c fc \\<sigma>0", "show ?thesis"], ["proof (prove)\nusing this:\n  P (foldli (map \\<alpha> lc) c fa \\<sigma>0)\n  iti = foldli lc\n  foldli (map \\<alpha> lc) c fa \\<sigma>0 = foldli lc c fc \\<sigma>0\n\ngoal (1 subgoal):\n 1. P (iti c fc \\<sigma>0)", "by simp"], ["proof (state)\nthis:\n  P (iti c fc \\<sigma>0)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>In general, one needs the representation, though. Even in this case,\n    the construct can be reduced to standard iterators.\\<close>"], ["", "lemma remove_abs2 :\n    \"\\<exists>S0'. set_iterator_genord iti S0' (\\<lambda>x y. R (\\<alpha> x) (\\<alpha> y)) \\<and>\n           inj_on \\<alpha> S0' \\<and> \\<alpha> ` S0' = S0 \\<and> (\\<forall>x \\<in> S0'. invar x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>S0'.\n       set_iterator_genord iti S0'\n        (\\<lambda>x y. R (\\<alpha> x) (\\<alpha> y)) \\<and>\n       inj_on \\<alpha> S0' \\<and>\n       \\<alpha> ` S0' = S0 \\<and> (\\<forall>x\\<in>S0'. invar x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>S0'.\n       set_iterator_genord iti S0'\n        (\\<lambda>x y. R (\\<alpha> x) (\\<alpha> y)) \\<and>\n       inj_on \\<alpha> S0' \\<and>\n       \\<alpha> ` S0' = S0 \\<and> (\\<forall>x\\<in>S0'. invar x)", "from foldli_transform"], ["proof (chain)\npicking this:\n  \\<exists>lc.\n     (\\<forall>xc\\<in>set lc. invar xc) \\<and>\n     distinct (map \\<alpha> lc) \\<and>\n     S0 = set (map \\<alpha> lc) \\<and>\n     sorted_wrt R (map \\<alpha> lc) \\<and> iti = foldli lc", "obtain lc where \n          lc_invar: \"\\<And>xc. xc \\<in> set lc \\<Longrightarrow> invar xc\" \n      and \\<alpha>_props: \"distinct (map \\<alpha> lc)\" \"S0 = set (map \\<alpha> lc)\" \n                   \"sorted_wrt R (map \\<alpha> lc)\" \n      and iti_eq: \"iti = foldli lc\""], ["proof (prove)\nusing this:\n  \\<exists>lc.\n     (\\<forall>xc\\<in>set lc. invar xc) \\<and>\n     distinct (map \\<alpha> lc) \\<and>\n     S0 = set (map \\<alpha> lc) \\<and>\n     sorted_wrt R (map \\<alpha> lc) \\<and> iti = foldli lc\n\ngoal (1 subgoal):\n 1. (\\<And>lc.\n        \\<lbrakk>\\<And>xc. xc \\<in> set lc \\<Longrightarrow> invar xc;\n         distinct (map \\<alpha> lc); S0 = set (map \\<alpha> lc);\n         sorted_wrt R (map \\<alpha> lc); iti = foldli lc\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ?xc \\<in> set lc \\<Longrightarrow> invar ?xc\n  distinct (map \\<alpha> lc)\n  S0 = set (map \\<alpha> lc)\n  sorted_wrt R (map \\<alpha> lc)\n  iti = foldli lc\n\ngoal (1 subgoal):\n 1. \\<exists>S0'.\n       set_iterator_genord iti S0'\n        (\\<lambda>x y. R (\\<alpha> x) (\\<alpha> y)) \\<and>\n       inj_on \\<alpha> S0' \\<and>\n       \\<alpha> ` S0' = S0 \\<and> (\\<forall>x\\<in>S0'. invar x)", "from \\<alpha>_props"], ["proof (chain)\npicking this:\n  distinct (map \\<alpha> lc)\n  S0 = set (map \\<alpha> lc)\n  sorted_wrt R (map \\<alpha> lc)", "have it': \"set_iterator_genord iti (set lc) (\\<lambda>x y. R (\\<alpha> x) (\\<alpha> y))\""], ["proof (prove)\nusing this:\n  distinct (map \\<alpha> lc)\n  S0 = set (map \\<alpha> lc)\n  sorted_wrt R (map \\<alpha> lc)\n\ngoal (1 subgoal):\n 1. set_iterator_genord iti (set lc)\n     (\\<lambda>x y. R (\\<alpha> x) (\\<alpha> y))", "apply (rule_tac set_iterator_genord_I [of lc])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>distinct (map \\<alpha> lc); S0 = set (map \\<alpha> lc);\n     sorted_wrt R (map \\<alpha> lc)\\<rbrakk>\n    \\<Longrightarrow> distinct lc\n 2. \\<lbrakk>distinct (map \\<alpha> lc); S0 = set (map \\<alpha> lc);\n     sorted_wrt R (map \\<alpha> lc)\\<rbrakk>\n    \\<Longrightarrow> set lc = set lc\n 3. \\<lbrakk>distinct (map \\<alpha> lc); S0 = set (map \\<alpha> lc);\n     sorted_wrt R (map \\<alpha> lc)\\<rbrakk>\n    \\<Longrightarrow> sorted_wrt (\\<lambda>x y. R (\\<alpha> x) (\\<alpha> y))\n                       lc\n 4. \\<lbrakk>distinct (map \\<alpha> lc); S0 = set (map \\<alpha> lc);\n     sorted_wrt R (map \\<alpha> lc)\\<rbrakk>\n    \\<Longrightarrow> iti = foldli lc", "apply (simp_all add: distinct_map sorted_wrt_map iti_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  set_iterator_genord iti (set lc)\n   (\\<lambda>x y. R (\\<alpha> x) (\\<alpha> y))\n\ngoal (1 subgoal):\n 1. \\<exists>S0'.\n       set_iterator_genord iti S0'\n        (\\<lambda>x y. R (\\<alpha> x) (\\<alpha> y)) \\<and>\n       inj_on \\<alpha> S0' \\<and>\n       \\<alpha> ` S0' = S0 \\<and> (\\<forall>x\\<in>S0'. invar x)", "from \\<alpha>_props"], ["proof (chain)\npicking this:\n  distinct (map \\<alpha> lc)\n  S0 = set (map \\<alpha> lc)\n  sorted_wrt R (map \\<alpha> lc)", "show ?thesis"], ["proof (prove)\nusing this:\n  distinct (map \\<alpha> lc)\n  S0 = set (map \\<alpha> lc)\n  sorted_wrt R (map \\<alpha> lc)\n\ngoal (1 subgoal):\n 1. \\<exists>S0'.\n       set_iterator_genord iti S0'\n        (\\<lambda>x y. R (\\<alpha> x) (\\<alpha> y)) \\<and>\n       inj_on \\<alpha> S0' \\<and>\n       \\<alpha> ` S0' = S0 \\<and> (\\<forall>x\\<in>S0'. invar x)", "apply (rule_tac exI[where x = \"set lc\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (map \\<alpha> lc); S0 = set (map \\<alpha> lc);\n     sorted_wrt R (map \\<alpha> lc)\\<rbrakk>\n    \\<Longrightarrow> set_iterator_genord iti (set lc)\n                       (\\<lambda>x y. R (\\<alpha> x) (\\<alpha> y)) \\<and>\n                      inj_on \\<alpha> (set lc) \\<and>\n                      \\<alpha> ` set lc = S0 \\<and>\n                      (\\<forall>x\\<in>set lc. invar x)", "apply (simp add: lc_invar distinct_map it')"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>S0'.\n     set_iterator_genord iti S0'\n      (\\<lambda>x y. R (\\<alpha> x) (\\<alpha> y)) \\<and>\n     inj_on \\<alpha> S0' \\<and>\n     \\<alpha> ` S0' = S0 \\<and> (\\<forall>x\\<in>S0'. invar x)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Let's now derive the inference rules for iterators over representations.\\<close>"], ["", "lemma iteratei_abs_simple_rule_P:\n  assumes f_OK: \"\\<And>xc. invar xc \\<Longrightarrow> \\<alpha> xc \\<in> S0 \\<Longrightarrow> f xc = f' (\\<alpha> xc)\"\n  assumes pre :\n      \"I S0 \\<sigma>0\"\n      \"\\<And>S \\<sigma> x. \\<lbrakk> c \\<sigma>; x \\<in> S; I S \\<sigma>; S \\<subseteq> S0; \n                 \\<forall>y\\<in>S - {x}. R x y; \\<forall>y\\<in>S0 - S. R y x\\<rbrakk> \n                 \\<Longrightarrow> I (S - {x}) (f' x \\<sigma>)\"\n      \"\\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n      \"\\<And>\\<sigma> S. \\<lbrakk> S \\<subseteq> S0; S \\<noteq> {}; \\<not> c \\<sigma>; I S \\<sigma>;\n               \\<forall>x\\<in>S. \\<forall>y\\<in>S0-S. R y x \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n    shows \"P (iti c f \\<sigma>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (iti c f \\<sigma>0)", "apply (rule remove_abs[of f f' P c \\<sigma>0])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xc.\n       \\<lbrakk>invar xc; \\<alpha> xc \\<in> S0\\<rbrakk>\n       \\<Longrightarrow> f xc = f' (\\<alpha> xc)\n 2. \\<And>iti.\n       set_iterator_genord iti S0 R \\<Longrightarrow> P (iti c f' \\<sigma>0)", "apply (simp add: f_OK)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>iti.\n       set_iterator_genord iti S0 R \\<Longrightarrow> P (iti c f' \\<sigma>0)", "apply (erule set_iterator_genord.iteratei_rule_P [of _ S0 R I])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>iti. I S0 \\<sigma>0\n 2. \\<And>iti S \\<sigma> x.\n       \\<lbrakk>c \\<sigma>; x \\<in> S; I S \\<sigma>; S \\<subseteq> S0;\n        \\<forall>y\\<in>S - {x}. R x y; \\<forall>y\\<in>S0 - S. R y x\\<rbrakk>\n       \\<Longrightarrow> I (S - {x}) (f' x \\<sigma>)\n 3. \\<And>iti \\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\n 4. \\<And>iti \\<sigma> S.\n       \\<lbrakk>S \\<subseteq> S0; S \\<noteq> {}; \\<not> c \\<sigma>;\n        I S \\<sigma>;\n        \\<forall>x\\<in>S. \\<forall>y\\<in>S0 - S. R y x\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "apply (simp_all add: pre)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iteratei_abs_simple_rule_insert_P:\n  assumes f_OK: \"\\<And>xc. invar xc \\<Longrightarrow> \\<alpha> xc \\<in> S0 \\<Longrightarrow> f xc = f' (\\<alpha> xc)\"\n  assumes pre :\n      \"I {} \\<sigma>0\"\n      \"\\<And>S \\<sigma> x. \\<lbrakk> c \\<sigma>; x \\<in> S0 - S; I S \\<sigma>; S \\<subseteq> S0; \\<forall>y\\<in>(S0 - S) - {x}. R x y;\n                 \\<forall>y\\<in>S. R y x\\<rbrakk> \n                  \\<Longrightarrow> I (insert x S) (f' x \\<sigma>)\"\n      \"\\<And>\\<sigma>. I S0 \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n      \"\\<And>\\<sigma> S. \\<lbrakk> S \\<subseteq> S0; S \\<noteq> S0; \n              \\<not> (c \\<sigma>); I S \\<sigma>; \\<forall>x\\<in>S0-S. \\<forall>y\\<in>S. R y x \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n  shows \"P (iti c f \\<sigma>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (iti c f \\<sigma>0)", "apply (rule remove_abs[of f f' P c \\<sigma>0])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xc.\n       \\<lbrakk>invar xc; \\<alpha> xc \\<in> S0\\<rbrakk>\n       \\<Longrightarrow> f xc = f' (\\<alpha> xc)\n 2. \\<And>iti.\n       set_iterator_genord iti S0 R \\<Longrightarrow> P (iti c f' \\<sigma>0)", "apply (simp add: f_OK)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>iti.\n       set_iterator_genord iti S0 R \\<Longrightarrow> P (iti c f' \\<sigma>0)", "apply (erule set_iterator_genord.iteratei_rule_insert_P [of _ S0 R I])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>iti. I {} \\<sigma>0\n 2. \\<And>iti S \\<sigma> x.\n       \\<lbrakk>c \\<sigma>; x \\<in> S0 - S; I S \\<sigma>; S \\<subseteq> S0;\n        \\<forall>y\\<in>S0 - S - {x}. R x y; \\<forall>y\\<in>S. R y x\\<rbrakk>\n       \\<Longrightarrow> I (insert x S) (f' x \\<sigma>)\n 3. \\<And>iti \\<sigma>. I S0 \\<sigma> \\<Longrightarrow> P \\<sigma>\n 4. \\<And>iti \\<sigma> S.\n       \\<lbrakk>S \\<subseteq> S0; S \\<noteq> S0; \\<not> c \\<sigma>;\n        I S \\<sigma>;\n        \\<forall>x\\<in>S0 - S. \\<forall>y\\<in>S. R y x\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "apply (simp_all add: pre)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iteratei_abs_rule_P:\n  assumes pre :\n      \"I S0 \\<sigma>0\"\n      \"\\<And>S \\<sigma> x. \\<lbrakk> c \\<sigma>; invar x; \\<alpha> x \\<in> S; I S \\<sigma>; S \\<subseteq> S0; \n                 \\<forall>y\\<in>S - {\\<alpha> x}. R (\\<alpha> x) y; \\<forall>y\\<in>S0 - S. R y (\\<alpha> x)\\<rbrakk> \n                 \\<Longrightarrow> I (S - {\\<alpha> x}) (f x \\<sigma>)\"\n      \"\\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n      \"\\<And>\\<sigma> S. \\<lbrakk> S \\<subseteq> S0; S \\<noteq> {}; \\<not> c \\<sigma>; I S \\<sigma>;\n               \\<forall>x\\<in>S. \\<forall>y\\<in>S0-S. R y x \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n    shows \"P (iti c f \\<sigma>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (iti c f \\<sigma>0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P (iti c f \\<sigma>0)", "obtain S0' where S0'_props: \"set_iterator_genord iti S0' (\\<lambda>x y. R (\\<alpha> x) (\\<alpha> y))\"\n       \"inj_on \\<alpha> S0'\" \"S0 = \\<alpha> ` S0'\" \"\\<And>x. x \\<in> S0' \\<Longrightarrow> invar x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>S0'.\n        \\<lbrakk>set_iterator_genord iti S0'\n                  (\\<lambda>x y. R (\\<alpha> x) (\\<alpha> y));\n         inj_on \\<alpha> S0'; S0 = \\<alpha> ` S0';\n         \\<And>x. x \\<in> S0' \\<Longrightarrow> invar x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis remove_abs2)"], ["proof (state)\nthis:\n  set_iterator_genord iti S0' (\\<lambda>x y. R (\\<alpha> x) (\\<alpha> y))\n  inj_on \\<alpha> S0'\n  S0 = \\<alpha> ` S0'\n  ?x \\<in> S0' \\<Longrightarrow> invar ?x\n\ngoal (1 subgoal):\n 1. P (iti c f \\<sigma>0)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. P (iti c f \\<sigma>0)", "proof (rule set_iterator_genord.iteratei_rule_P[OF S0'_props(1), of \"\\<lambda>S \\<sigma>. I (\\<alpha> ` S) \\<sigma>\" \\<sigma>0 c], goal_cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. I (\\<alpha> ` S0') \\<sigma>0\n 2. \\<And>S \\<sigma> x.\n       \\<lbrakk>c \\<sigma>; x \\<in> S; I (\\<alpha> ` S) \\<sigma>;\n        S \\<subseteq> S0';\n        \\<forall>y\\<in>S - {x}. R (\\<alpha> x) (\\<alpha> y);\n        \\<forall>y\\<in>S0' - S. R (\\<alpha> y) (\\<alpha> x)\\<rbrakk>\n       \\<Longrightarrow> I (\\<alpha> ` (S - {x})) (f x \\<sigma>)\n 3. \\<And>\\<sigma>. I (\\<alpha> ` {}) \\<sigma> \\<Longrightarrow> P \\<sigma>\n 4. \\<And>\\<sigma> S.\n       \\<lbrakk>S \\<subseteq> S0'; S \\<noteq> {}; \\<not> c \\<sigma>;\n        I (\\<alpha> ` S) \\<sigma>;\n        \\<forall>x\\<in>S.\n           \\<forall>y\\<in>S0' - S. R (\\<alpha> y) (\\<alpha> x)\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. I (\\<alpha> ` S0') \\<sigma>0\n 2. \\<And>S \\<sigma> x.\n       \\<lbrakk>c \\<sigma>; x \\<in> S; I (\\<alpha> ` S) \\<sigma>;\n        S \\<subseteq> S0';\n        \\<forall>y\\<in>S - {x}. R (\\<alpha> x) (\\<alpha> y);\n        \\<forall>y\\<in>S0' - S. R (\\<alpha> y) (\\<alpha> x)\\<rbrakk>\n       \\<Longrightarrow> I (\\<alpha> ` (S - {x})) (f x \\<sigma>)\n 3. \\<And>\\<sigma>. I (\\<alpha> ` {}) \\<sigma> \\<Longrightarrow> P \\<sigma>\n 4. \\<And>\\<sigma> S.\n       \\<lbrakk>S \\<subseteq> S0'; S \\<noteq> {}; \\<not> c \\<sigma>;\n        I (\\<alpha> ` S) \\<sigma>;\n        \\<forall>x\\<in>S.\n           \\<forall>y\\<in>S0' - S. R (\\<alpha> y) (\\<alpha> x)\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. I (\\<alpha> ` S0') \\<sigma>0", "using S0'_props pre"], ["proof (prove)\nusing this:\n  set_iterator_genord iti S0' (\\<lambda>x y. R (\\<alpha> x) (\\<alpha> y))\n  inj_on \\<alpha> S0'\n  S0 = \\<alpha> ` S0'\n  ?x \\<in> S0' \\<Longrightarrow> invar ?x\n  I S0 \\<sigma>0\n  \\<lbrakk>c ?\\<sigma>; invar ?x; \\<alpha> ?x \\<in> ?S; I ?S ?\\<sigma>;\n   ?S \\<subseteq> S0; \\<forall>y\\<in>?S - {\\<alpha> ?x}. R (\\<alpha> ?x) y;\n   \\<forall>y\\<in>S0 - ?S. R y (\\<alpha> ?x)\\<rbrakk>\n  \\<Longrightarrow> I (?S - {\\<alpha> ?x}) (f ?x ?\\<sigma>)\n  I {} ?\\<sigma> \\<Longrightarrow> P ?\\<sigma>\n  \\<lbrakk>?S \\<subseteq> S0; ?S \\<noteq> {}; \\<not> c ?\\<sigma>;\n   I ?S ?\\<sigma>; \\<forall>x\\<in>?S. \\<forall>y\\<in>S0 - ?S. R y x\\<rbrakk>\n  \\<Longrightarrow> P ?\\<sigma>\n\ngoal (1 subgoal):\n 1. I (\\<alpha> ` S0') \\<sigma>0", "by simp"], ["proof (state)\nthis:\n  I (\\<alpha> ` S0') \\<sigma>0\n\ngoal (3 subgoals):\n 1. \\<And>S \\<sigma> x.\n       \\<lbrakk>c \\<sigma>; x \\<in> S; I (\\<alpha> ` S) \\<sigma>;\n        S \\<subseteq> S0';\n        \\<forall>y\\<in>S - {x}. R (\\<alpha> x) (\\<alpha> y);\n        \\<forall>y\\<in>S0' - S. R (\\<alpha> y) (\\<alpha> x)\\<rbrakk>\n       \\<Longrightarrow> I (\\<alpha> ` (S - {x})) (f x \\<sigma>)\n 2. \\<And>\\<sigma>. I (\\<alpha> ` {}) \\<sigma> \\<Longrightarrow> P \\<sigma>\n 3. \\<And>\\<sigma> S.\n       \\<lbrakk>S \\<subseteq> S0'; S \\<noteq> {}; \\<not> c \\<sigma>;\n        I (\\<alpha> ` S) \\<sigma>;\n        \\<forall>x\\<in>S.\n           \\<forall>y\\<in>S0' - S. R (\\<alpha> y) (\\<alpha> x)\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>S \\<sigma> x.\n       \\<lbrakk>c \\<sigma>; x \\<in> S; I (\\<alpha> ` S) \\<sigma>;\n        S \\<subseteq> S0';\n        \\<forall>y\\<in>S - {x}. R (\\<alpha> x) (\\<alpha> y);\n        \\<forall>y\\<in>S0' - S. R (\\<alpha> y) (\\<alpha> x)\\<rbrakk>\n       \\<Longrightarrow> I (\\<alpha> ` (S - {x})) (f x \\<sigma>)\n 2. \\<And>\\<sigma>. I (\\<alpha> ` {}) \\<sigma> \\<Longrightarrow> P \\<sigma>\n 3. \\<And>\\<sigma> S.\n       \\<lbrakk>S \\<subseteq> S0'; S \\<noteq> {}; \\<not> c \\<sigma>;\n        I (\\<alpha> ` S) \\<sigma>;\n        \\<forall>x\\<in>S.\n           \\<forall>y\\<in>S0' - S. R (\\<alpha> y) (\\<alpha> x)\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "case 3"], ["proof (state)\nthis:\n  I (\\<alpha> ` {}) \\<sigma>_\n\ngoal (3 subgoals):\n 1. \\<And>S \\<sigma> x.\n       \\<lbrakk>c \\<sigma>; x \\<in> S; I (\\<alpha> ` S) \\<sigma>;\n        S \\<subseteq> S0';\n        \\<forall>y\\<in>S - {x}. R (\\<alpha> x) (\\<alpha> y);\n        \\<forall>y\\<in>S0' - S. R (\\<alpha> y) (\\<alpha> x)\\<rbrakk>\n       \\<Longrightarrow> I (\\<alpha> ` (S - {x})) (f x \\<sigma>)\n 2. \\<And>\\<sigma>. I (\\<alpha> ` {}) \\<sigma> \\<Longrightarrow> P \\<sigma>\n 3. \\<And>\\<sigma> S.\n       \\<lbrakk>S \\<subseteq> S0'; S \\<noteq> {}; \\<not> c \\<sigma>;\n        I (\\<alpha> ` S) \\<sigma>;\n        \\<forall>x\\<in>S.\n           \\<forall>y\\<in>S0' - S. R (\\<alpha> y) (\\<alpha> x)\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "thus ?case"], ["proof (prove)\nusing this:\n  I (\\<alpha> ` {}) \\<sigma>_\n\ngoal (1 subgoal):\n 1. P \\<sigma>_", "using S0'_props pre"], ["proof (prove)\nusing this:\n  I (\\<alpha> ` {}) \\<sigma>_\n  set_iterator_genord iti S0' (\\<lambda>x y. R (\\<alpha> x) (\\<alpha> y))\n  inj_on \\<alpha> S0'\n  S0 = \\<alpha> ` S0'\n  ?x \\<in> S0' \\<Longrightarrow> invar ?x\n  I S0 \\<sigma>0\n  \\<lbrakk>c ?\\<sigma>; invar ?x; \\<alpha> ?x \\<in> ?S; I ?S ?\\<sigma>;\n   ?S \\<subseteq> S0; \\<forall>y\\<in>?S - {\\<alpha> ?x}. R (\\<alpha> ?x) y;\n   \\<forall>y\\<in>S0 - ?S. R y (\\<alpha> ?x)\\<rbrakk>\n  \\<Longrightarrow> I (?S - {\\<alpha> ?x}) (f ?x ?\\<sigma>)\n  I {} ?\\<sigma> \\<Longrightarrow> P ?\\<sigma>\n  \\<lbrakk>?S \\<subseteq> S0; ?S \\<noteq> {}; \\<not> c ?\\<sigma>;\n   I ?S ?\\<sigma>; \\<forall>x\\<in>?S. \\<forall>y\\<in>S0 - ?S. R y x\\<rbrakk>\n  \\<Longrightarrow> P ?\\<sigma>\n\ngoal (1 subgoal):\n 1. P \\<sigma>_", "by simp"], ["proof (state)\nthis:\n  P \\<sigma>_\n\ngoal (2 subgoals):\n 1. \\<And>S \\<sigma> x.\n       \\<lbrakk>c \\<sigma>; x \\<in> S; I (\\<alpha> ` S) \\<sigma>;\n        S \\<subseteq> S0';\n        \\<forall>y\\<in>S - {x}. R (\\<alpha> x) (\\<alpha> y);\n        \\<forall>y\\<in>S0' - S. R (\\<alpha> y) (\\<alpha> x)\\<rbrakk>\n       \\<Longrightarrow> I (\\<alpha> ` (S - {x})) (f x \\<sigma>)\n 2. \\<And>\\<sigma> S.\n       \\<lbrakk>S \\<subseteq> S0'; S \\<noteq> {}; \\<not> c \\<sigma>;\n        I (\\<alpha> ` S) \\<sigma>;\n        \\<forall>x\\<in>S.\n           \\<forall>y\\<in>S0' - S. R (\\<alpha> y) (\\<alpha> x)\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>S \\<sigma> x.\n       \\<lbrakk>c \\<sigma>; x \\<in> S; I (\\<alpha> ` S) \\<sigma>;\n        S \\<subseteq> S0';\n        \\<forall>y\\<in>S - {x}. R (\\<alpha> x) (\\<alpha> y);\n        \\<forall>y\\<in>S0' - S. R (\\<alpha> y) (\\<alpha> x)\\<rbrakk>\n       \\<Longrightarrow> I (\\<alpha> ` (S - {x})) (f x \\<sigma>)\n 2. \\<And>\\<sigma> S.\n       \\<lbrakk>S \\<subseteq> S0'; S \\<noteq> {}; \\<not> c \\<sigma>;\n        I (\\<alpha> ` S) \\<sigma>;\n        \\<forall>x\\<in>S.\n           \\<forall>y\\<in>S0' - S. R (\\<alpha> y) (\\<alpha> x)\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "case prems: (2 S \\<sigma> x)"], ["proof (state)\nthis:\n  c \\<sigma>\n  x \\<in> S\n  I (\\<alpha> ` S) \\<sigma>\n  S \\<subseteq> S0'\n  \\<forall>y\\<in>S - {x}. R (\\<alpha> x) (\\<alpha> y)\n  \\<forall>y\\<in>S0' - S. R (\\<alpha> y) (\\<alpha> x)\n\ngoal (2 subgoals):\n 1. \\<And>S \\<sigma> x.\n       \\<lbrakk>c \\<sigma>; x \\<in> S; I (\\<alpha> ` S) \\<sigma>;\n        S \\<subseteq> S0';\n        \\<forall>y\\<in>S - {x}. R (\\<alpha> x) (\\<alpha> y);\n        \\<forall>y\\<in>S0' - S. R (\\<alpha> y) (\\<alpha> x)\\<rbrakk>\n       \\<Longrightarrow> I (\\<alpha> ` (S - {x})) (f x \\<sigma>)\n 2. \\<And>\\<sigma> S.\n       \\<lbrakk>S \\<subseteq> S0'; S \\<noteq> {}; \\<not> c \\<sigma>;\n        I (\\<alpha> ` S) \\<sigma>;\n        \\<forall>x\\<in>S.\n           \\<forall>y\\<in>S0' - S. R (\\<alpha> y) (\\<alpha> x)\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "from prems S0'_props"], ["proof (chain)\npicking this:\n  c \\<sigma>\n  x \\<in> S\n  I (\\<alpha> ` S) \\<sigma>\n  S \\<subseteq> S0'\n  \\<forall>y\\<in>S - {x}. R (\\<alpha> x) (\\<alpha> y)\n  \\<forall>y\\<in>S0' - S. R (\\<alpha> y) (\\<alpha> x)\n  set_iterator_genord iti S0' (\\<lambda>x y. R (\\<alpha> x) (\\<alpha> y))\n  inj_on \\<alpha> S0'\n  S0 = \\<alpha> ` S0'\n  ?x \\<in> S0' \\<Longrightarrow> invar ?x", "have inv_x: \"invar x\""], ["proof (prove)\nusing this:\n  c \\<sigma>\n  x \\<in> S\n  I (\\<alpha> ` S) \\<sigma>\n  S \\<subseteq> S0'\n  \\<forall>y\\<in>S - {x}. R (\\<alpha> x) (\\<alpha> y)\n  \\<forall>y\\<in>S0' - S. R (\\<alpha> y) (\\<alpha> x)\n  set_iterator_genord iti S0' (\\<lambda>x y. R (\\<alpha> x) (\\<alpha> y))\n  inj_on \\<alpha> S0'\n  S0 = \\<alpha> ` S0'\n  ?x \\<in> S0' \\<Longrightarrow> invar ?x\n\ngoal (1 subgoal):\n 1. invar x", "by blast"], ["proof (state)\nthis:\n  invar x\n\ngoal (2 subgoals):\n 1. \\<And>S \\<sigma> x.\n       \\<lbrakk>c \\<sigma>; x \\<in> S; I (\\<alpha> ` S) \\<sigma>;\n        S \\<subseteq> S0';\n        \\<forall>y\\<in>S - {x}. R (\\<alpha> x) (\\<alpha> y);\n        \\<forall>y\\<in>S0' - S. R (\\<alpha> y) (\\<alpha> x)\\<rbrakk>\n       \\<Longrightarrow> I (\\<alpha> ` (S - {x})) (f x \\<sigma>)\n 2. \\<And>\\<sigma> S.\n       \\<lbrakk>S \\<subseteq> S0'; S \\<noteq> {}; \\<not> c \\<sigma>;\n        I (\\<alpha> ` S) \\<sigma>;\n        \\<forall>x\\<in>S.\n           \\<forall>y\\<in>S0' - S. R (\\<alpha> y) (\\<alpha> x)\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "from prems(4)"], ["proof (chain)\npicking this:\n  S \\<subseteq> S0'", "have subs_alpha: \"\\<alpha> ` S \\<subseteq> \\<alpha> ` S0'\""], ["proof (prove)\nusing this:\n  S \\<subseteq> S0'\n\ngoal (1 subgoal):\n 1. \\<alpha> ` S \\<subseteq> \\<alpha> ` S0'", "by auto"], ["proof (state)\nthis:\n  \\<alpha> ` S \\<subseteq> \\<alpha> ` S0'\n\ngoal (2 subgoals):\n 1. \\<And>S \\<sigma> x.\n       \\<lbrakk>c \\<sigma>; x \\<in> S; I (\\<alpha> ` S) \\<sigma>;\n        S \\<subseteq> S0';\n        \\<forall>y\\<in>S - {x}. R (\\<alpha> x) (\\<alpha> y);\n        \\<forall>y\\<in>S0' - S. R (\\<alpha> y) (\\<alpha> x)\\<rbrakk>\n       \\<Longrightarrow> I (\\<alpha> ` (S - {x})) (f x \\<sigma>)\n 2. \\<And>\\<sigma> S.\n       \\<lbrakk>S \\<subseteq> S0'; S \\<noteq> {}; \\<not> c \\<sigma>;\n        I (\\<alpha> ` S) \\<sigma>;\n        \\<forall>x\\<in>S.\n           \\<forall>y\\<in>S0' - S. R (\\<alpha> y) (\\<alpha> x)\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "from S0'_props prems(2,4)"], ["proof (chain)\npicking this:\n  set_iterator_genord iti S0' (\\<lambda>x y. R (\\<alpha> x) (\\<alpha> y))\n  inj_on \\<alpha> S0'\n  S0 = \\<alpha> ` S0'\n  ?x \\<in> S0' \\<Longrightarrow> invar ?x\n  x \\<in> S\n  S \\<subseteq> S0'", "have diff_alpha: \"\\<alpha> ` S - {\\<alpha> x} = \\<alpha> ` (S - {x})\" \"\\<alpha> ` S0' - \\<alpha> ` S = \\<alpha> ` (S0' - S)\""], ["proof (prove)\nusing this:\n  set_iterator_genord iti S0' (\\<lambda>x y. R (\\<alpha> x) (\\<alpha> y))\n  inj_on \\<alpha> S0'\n  S0 = \\<alpha> ` S0'\n  ?x \\<in> S0' \\<Longrightarrow> invar ?x\n  x \\<in> S\n  S \\<subseteq> S0'\n\ngoal (1 subgoal):\n 1. \\<alpha> ` S - {\\<alpha> x} = \\<alpha> ` (S - {x}) &&&\n    \\<alpha> ` S0' - \\<alpha> ` S = \\<alpha> ` (S0' - S)", "by (auto simp add: inj_on_def subset_iff Ball_def)"], ["proof (state)\nthis:\n  \\<alpha> ` S - {\\<alpha> x} = \\<alpha> ` (S - {x})\n  \\<alpha> ` S0' - \\<alpha> ` S = \\<alpha> ` (S0' - S)\n\ngoal (2 subgoals):\n 1. \\<And>S \\<sigma> x.\n       \\<lbrakk>c \\<sigma>; x \\<in> S; I (\\<alpha> ` S) \\<sigma>;\n        S \\<subseteq> S0';\n        \\<forall>y\\<in>S - {x}. R (\\<alpha> x) (\\<alpha> y);\n        \\<forall>y\\<in>S0' - S. R (\\<alpha> y) (\\<alpha> x)\\<rbrakk>\n       \\<Longrightarrow> I (\\<alpha> ` (S - {x})) (f x \\<sigma>)\n 2. \\<And>\\<sigma> S.\n       \\<lbrakk>S \\<subseteq> S0'; S \\<noteq> {}; \\<not> c \\<sigma>;\n        I (\\<alpha> ` S) \\<sigma>;\n        \\<forall>x\\<in>S.\n           \\<forall>y\\<in>S0' - S. R (\\<alpha> y) (\\<alpha> x)\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. I (\\<alpha> ` (S - {x})) (f x \\<sigma>)", "using pre(2)[of \\<sigma> x \"\\<alpha> ` S\"] S0'_props(3)"], ["proof (prove)\nusing this:\n  \\<lbrakk>c \\<sigma>; invar x; \\<alpha> x \\<in> \\<alpha> ` S;\n   I (\\<alpha> ` S) \\<sigma>; \\<alpha> ` S \\<subseteq> S0;\n   \\<forall>y\\<in>\\<alpha> ` S - {\\<alpha> x}. R (\\<alpha> x) y;\n   \\<forall>y\\<in>S0 - \\<alpha> ` S. R y (\\<alpha> x)\\<rbrakk>\n  \\<Longrightarrow> I (\\<alpha> ` S - {\\<alpha> x}) (f x \\<sigma>)\n  S0 = \\<alpha> ` S0'\n\ngoal (1 subgoal):\n 1. I (\\<alpha> ` (S - {x})) (f x \\<sigma>)", "by (simp add: inv_x prems subs_alpha diff_alpha)"], ["proof (state)\nthis:\n  I (\\<alpha> ` (S - {x})) (f x \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> S.\n       \\<lbrakk>S \\<subseteq> S0'; S \\<noteq> {}; \\<not> c \\<sigma>;\n        I (\\<alpha> ` S) \\<sigma>;\n        \\<forall>x\\<in>S.\n           \\<forall>y\\<in>S0' - S. R (\\<alpha> y) (\\<alpha> x)\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> S.\n       \\<lbrakk>S \\<subseteq> S0'; S \\<noteq> {}; \\<not> c \\<sigma>;\n        I (\\<alpha> ` S) \\<sigma>;\n        \\<forall>x\\<in>S.\n           \\<forall>y\\<in>S0' - S. R (\\<alpha> y) (\\<alpha> x)\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "case prems: (4 \\<sigma> S)"], ["proof (state)\nthis:\n  S \\<subseteq> S0'\n  S \\<noteq> {}\n  \\<not> c \\<sigma>\n  I (\\<alpha> ` S) \\<sigma>\n  \\<forall>x\\<in>S. \\<forall>y\\<in>S0' - S. R (\\<alpha> y) (\\<alpha> x)\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> S.\n       \\<lbrakk>S \\<subseteq> S0'; S \\<noteq> {}; \\<not> c \\<sigma>;\n        I (\\<alpha> ` S) \\<sigma>;\n        \\<forall>x\\<in>S.\n           \\<forall>y\\<in>S0' - S. R (\\<alpha> y) (\\<alpha> x)\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<sigma>", "using pre(4)[of \"\\<alpha> ` S\" \\<sigma>] prems S0'_props"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<alpha> ` S \\<subseteq> S0; \\<alpha> ` S \\<noteq> {};\n   \\<not> c \\<sigma>; I (\\<alpha> ` S) \\<sigma>;\n   \\<forall>x\\<in>\\<alpha> ` S.\n      \\<forall>y\\<in>S0 - \\<alpha> ` S. R y x\\<rbrakk>\n  \\<Longrightarrow> P \\<sigma>\n  S \\<subseteq> S0'\n  S \\<noteq> {}\n  \\<not> c \\<sigma>\n  I (\\<alpha> ` S) \\<sigma>\n  \\<forall>x\\<in>S. \\<forall>y\\<in>S0' - S. R (\\<alpha> y) (\\<alpha> x)\n  set_iterator_genord iti S0' (\\<lambda>x y. R (\\<alpha> x) (\\<alpha> y))\n  inj_on \\<alpha> S0'\n  S0 = \\<alpha> ` S0'\n  ?x \\<in> S0' \\<Longrightarrow> invar ?x\n\ngoal (1 subgoal):\n 1. P \\<sigma>", "by auto"], ["proof (state)\nthis:\n  P \\<sigma>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P (iti c f \\<sigma>0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma iteratei_abs_rule_insert_P:\n  assumes pre :\n      \"I {} \\<sigma>0\"\n      \"\\<And>S \\<sigma> x. \\<lbrakk> c \\<sigma>; invar x; \\<alpha> x \\<in> S0 - S; I S \\<sigma>; S \\<subseteq> S0; \n                 \\<forall>y\\<in>(S0 - S) - {\\<alpha> x}. R (\\<alpha> x) y; \\<forall>y\\<in>S. R y (\\<alpha> x)\\<rbrakk> \n                 \\<Longrightarrow> I (insert (\\<alpha> x) S) (f x \\<sigma>)\"\n      \"\\<And>\\<sigma>. I S0 \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n      \"\\<And>\\<sigma> S. \\<lbrakk> S \\<subseteq> S0; S \\<noteq> S0; \\<not> c \\<sigma>; I S \\<sigma>;\n               \\<forall>x\\<in>S0-S. \\<forall>y\\<in>S. R y x \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n    shows \"P (iti c f \\<sigma>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (iti c f \\<sigma>0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P (iti c f \\<sigma>0)", "obtain S0' where S0'_props: \"set_iterator_genord iti S0' (\\<lambda>x y. R (\\<alpha> x) (\\<alpha> y))\"\n       \"inj_on \\<alpha> S0'\" \"S0 = \\<alpha> ` S0'\" \"\\<And>x. x \\<in> S0' \\<Longrightarrow> invar x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>S0'.\n        \\<lbrakk>set_iterator_genord iti S0'\n                  (\\<lambda>x y. R (\\<alpha> x) (\\<alpha> y));\n         inj_on \\<alpha> S0'; S0 = \\<alpha> ` S0';\n         \\<And>x. x \\<in> S0' \\<Longrightarrow> invar x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis remove_abs2)"], ["proof (state)\nthis:\n  set_iterator_genord iti S0' (\\<lambda>x y. R (\\<alpha> x) (\\<alpha> y))\n  inj_on \\<alpha> S0'\n  S0 = \\<alpha> ` S0'\n  ?x \\<in> S0' \\<Longrightarrow> invar ?x\n\ngoal (1 subgoal):\n 1. P (iti c f \\<sigma>0)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. P (iti c f \\<sigma>0)", "proof (rule set_iterator_genord.iteratei_rule_insert_P[OF S0'_props(1), of \"\\<lambda>S \\<sigma>. I (\\<alpha> ` S) \\<sigma>\" \\<sigma>0 c], goal_cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. I (\\<alpha> ` {}) \\<sigma>0\n 2. \\<And>S \\<sigma> x.\n       \\<lbrakk>c \\<sigma>; x \\<in> S0' - S; I (\\<alpha> ` S) \\<sigma>;\n        S \\<subseteq> S0';\n        \\<forall>y\\<in>S0' - S - {x}. R (\\<alpha> x) (\\<alpha> y);\n        \\<forall>y\\<in>S. R (\\<alpha> y) (\\<alpha> x)\\<rbrakk>\n       \\<Longrightarrow> I (\\<alpha> ` insert x S) (f x \\<sigma>)\n 3. \\<And>\\<sigma>. I (\\<alpha> ` S0') \\<sigma> \\<Longrightarrow> P \\<sigma>\n 4. \\<And>\\<sigma> S.\n       \\<lbrakk>S \\<subseteq> S0'; S \\<noteq> S0'; \\<not> c \\<sigma>;\n        I (\\<alpha> ` S) \\<sigma>;\n        \\<forall>x\\<in>S0' - S.\n           \\<forall>y\\<in>S. R (\\<alpha> y) (\\<alpha> x)\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. I (\\<alpha> ` {}) \\<sigma>0\n 2. \\<And>S \\<sigma> x.\n       \\<lbrakk>c \\<sigma>; x \\<in> S0' - S; I (\\<alpha> ` S) \\<sigma>;\n        S \\<subseteq> S0';\n        \\<forall>y\\<in>S0' - S - {x}. R (\\<alpha> x) (\\<alpha> y);\n        \\<forall>y\\<in>S. R (\\<alpha> y) (\\<alpha> x)\\<rbrakk>\n       \\<Longrightarrow> I (\\<alpha> ` insert x S) (f x \\<sigma>)\n 3. \\<And>\\<sigma>. I (\\<alpha> ` S0') \\<sigma> \\<Longrightarrow> P \\<sigma>\n 4. \\<And>\\<sigma> S.\n       \\<lbrakk>S \\<subseteq> S0'; S \\<noteq> S0'; \\<not> c \\<sigma>;\n        I (\\<alpha> ` S) \\<sigma>;\n        \\<forall>x\\<in>S0' - S.\n           \\<forall>y\\<in>S. R (\\<alpha> y) (\\<alpha> x)\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. I (\\<alpha> ` {}) \\<sigma>0", "using S0'_props pre"], ["proof (prove)\nusing this:\n  set_iterator_genord iti S0' (\\<lambda>x y. R (\\<alpha> x) (\\<alpha> y))\n  inj_on \\<alpha> S0'\n  S0 = \\<alpha> ` S0'\n  ?x \\<in> S0' \\<Longrightarrow> invar ?x\n  I {} \\<sigma>0\n  \\<lbrakk>c ?\\<sigma>; invar ?x; \\<alpha> ?x \\<in> S0 - ?S; I ?S ?\\<sigma>;\n   ?S \\<subseteq> S0;\n   \\<forall>y\\<in>S0 - ?S - {\\<alpha> ?x}. R (\\<alpha> ?x) y;\n   \\<forall>y\\<in>?S. R y (\\<alpha> ?x)\\<rbrakk>\n  \\<Longrightarrow> I (insert (\\<alpha> ?x) ?S) (f ?x ?\\<sigma>)\n  I S0 ?\\<sigma> \\<Longrightarrow> P ?\\<sigma>\n  \\<lbrakk>?S \\<subseteq> S0; ?S \\<noteq> S0; \\<not> c ?\\<sigma>;\n   I ?S ?\\<sigma>; \\<forall>x\\<in>S0 - ?S. \\<forall>y\\<in>?S. R y x\\<rbrakk>\n  \\<Longrightarrow> P ?\\<sigma>\n\ngoal (1 subgoal):\n 1. I (\\<alpha> ` {}) \\<sigma>0", "by simp"], ["proof (state)\nthis:\n  I (\\<alpha> ` {}) \\<sigma>0\n\ngoal (3 subgoals):\n 1. \\<And>S \\<sigma> x.\n       \\<lbrakk>c \\<sigma>; x \\<in> S0' - S; I (\\<alpha> ` S) \\<sigma>;\n        S \\<subseteq> S0';\n        \\<forall>y\\<in>S0' - S - {x}. R (\\<alpha> x) (\\<alpha> y);\n        \\<forall>y\\<in>S. R (\\<alpha> y) (\\<alpha> x)\\<rbrakk>\n       \\<Longrightarrow> I (\\<alpha> ` insert x S) (f x \\<sigma>)\n 2. \\<And>\\<sigma>. I (\\<alpha> ` S0') \\<sigma> \\<Longrightarrow> P \\<sigma>\n 3. \\<And>\\<sigma> S.\n       \\<lbrakk>S \\<subseteq> S0'; S \\<noteq> S0'; \\<not> c \\<sigma>;\n        I (\\<alpha> ` S) \\<sigma>;\n        \\<forall>x\\<in>S0' - S.\n           \\<forall>y\\<in>S. R (\\<alpha> y) (\\<alpha> x)\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>S \\<sigma> x.\n       \\<lbrakk>c \\<sigma>; x \\<in> S0' - S; I (\\<alpha> ` S) \\<sigma>;\n        S \\<subseteq> S0';\n        \\<forall>y\\<in>S0' - S - {x}. R (\\<alpha> x) (\\<alpha> y);\n        \\<forall>y\\<in>S. R (\\<alpha> y) (\\<alpha> x)\\<rbrakk>\n       \\<Longrightarrow> I (\\<alpha> ` insert x S) (f x \\<sigma>)\n 2. \\<And>\\<sigma>. I (\\<alpha> ` S0') \\<sigma> \\<Longrightarrow> P \\<sigma>\n 3. \\<And>\\<sigma> S.\n       \\<lbrakk>S \\<subseteq> S0'; S \\<noteq> S0'; \\<not> c \\<sigma>;\n        I (\\<alpha> ` S) \\<sigma>;\n        \\<forall>x\\<in>S0' - S.\n           \\<forall>y\\<in>S. R (\\<alpha> y) (\\<alpha> x)\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "case 3"], ["proof (state)\nthis:\n  I (\\<alpha> ` S0') \\<sigma>_\n\ngoal (3 subgoals):\n 1. \\<And>S \\<sigma> x.\n       \\<lbrakk>c \\<sigma>; x \\<in> S0' - S; I (\\<alpha> ` S) \\<sigma>;\n        S \\<subseteq> S0';\n        \\<forall>y\\<in>S0' - S - {x}. R (\\<alpha> x) (\\<alpha> y);\n        \\<forall>y\\<in>S. R (\\<alpha> y) (\\<alpha> x)\\<rbrakk>\n       \\<Longrightarrow> I (\\<alpha> ` insert x S) (f x \\<sigma>)\n 2. \\<And>\\<sigma>. I (\\<alpha> ` S0') \\<sigma> \\<Longrightarrow> P \\<sigma>\n 3. \\<And>\\<sigma> S.\n       \\<lbrakk>S \\<subseteq> S0'; S \\<noteq> S0'; \\<not> c \\<sigma>;\n        I (\\<alpha> ` S) \\<sigma>;\n        \\<forall>x\\<in>S0' - S.\n           \\<forall>y\\<in>S. R (\\<alpha> y) (\\<alpha> x)\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "thus ?case"], ["proof (prove)\nusing this:\n  I (\\<alpha> ` S0') \\<sigma>_\n\ngoal (1 subgoal):\n 1. P \\<sigma>_", "using S0'_props pre"], ["proof (prove)\nusing this:\n  I (\\<alpha> ` S0') \\<sigma>_\n  set_iterator_genord iti S0' (\\<lambda>x y. R (\\<alpha> x) (\\<alpha> y))\n  inj_on \\<alpha> S0'\n  S0 = \\<alpha> ` S0'\n  ?x \\<in> S0' \\<Longrightarrow> invar ?x\n  I {} \\<sigma>0\n  \\<lbrakk>c ?\\<sigma>; invar ?x; \\<alpha> ?x \\<in> S0 - ?S; I ?S ?\\<sigma>;\n   ?S \\<subseteq> S0;\n   \\<forall>y\\<in>S0 - ?S - {\\<alpha> ?x}. R (\\<alpha> ?x) y;\n   \\<forall>y\\<in>?S. R y (\\<alpha> ?x)\\<rbrakk>\n  \\<Longrightarrow> I (insert (\\<alpha> ?x) ?S) (f ?x ?\\<sigma>)\n  I S0 ?\\<sigma> \\<Longrightarrow> P ?\\<sigma>\n  \\<lbrakk>?S \\<subseteq> S0; ?S \\<noteq> S0; \\<not> c ?\\<sigma>;\n   I ?S ?\\<sigma>; \\<forall>x\\<in>S0 - ?S. \\<forall>y\\<in>?S. R y x\\<rbrakk>\n  \\<Longrightarrow> P ?\\<sigma>\n\ngoal (1 subgoal):\n 1. P \\<sigma>_", "by simp"], ["proof (state)\nthis:\n  P \\<sigma>_\n\ngoal (2 subgoals):\n 1. \\<And>S \\<sigma> x.\n       \\<lbrakk>c \\<sigma>; x \\<in> S0' - S; I (\\<alpha> ` S) \\<sigma>;\n        S \\<subseteq> S0';\n        \\<forall>y\\<in>S0' - S - {x}. R (\\<alpha> x) (\\<alpha> y);\n        \\<forall>y\\<in>S. R (\\<alpha> y) (\\<alpha> x)\\<rbrakk>\n       \\<Longrightarrow> I (\\<alpha> ` insert x S) (f x \\<sigma>)\n 2. \\<And>\\<sigma> S.\n       \\<lbrakk>S \\<subseteq> S0'; S \\<noteq> S0'; \\<not> c \\<sigma>;\n        I (\\<alpha> ` S) \\<sigma>;\n        \\<forall>x\\<in>S0' - S.\n           \\<forall>y\\<in>S. R (\\<alpha> y) (\\<alpha> x)\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>S \\<sigma> x.\n       \\<lbrakk>c \\<sigma>; x \\<in> S0' - S; I (\\<alpha> ` S) \\<sigma>;\n        S \\<subseteq> S0';\n        \\<forall>y\\<in>S0' - S - {x}. R (\\<alpha> x) (\\<alpha> y);\n        \\<forall>y\\<in>S. R (\\<alpha> y) (\\<alpha> x)\\<rbrakk>\n       \\<Longrightarrow> I (\\<alpha> ` insert x S) (f x \\<sigma>)\n 2. \\<And>\\<sigma> S.\n       \\<lbrakk>S \\<subseteq> S0'; S \\<noteq> S0'; \\<not> c \\<sigma>;\n        I (\\<alpha> ` S) \\<sigma>;\n        \\<forall>x\\<in>S0' - S.\n           \\<forall>y\\<in>S. R (\\<alpha> y) (\\<alpha> x)\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "case prems: (2 S \\<sigma> x)"], ["proof (state)\nthis:\n  c \\<sigma>\n  x \\<in> S0' - S\n  I (\\<alpha> ` S) \\<sigma>\n  S \\<subseteq> S0'\n  \\<forall>y\\<in>S0' - S - {x}. R (\\<alpha> x) (\\<alpha> y)\n  \\<forall>y\\<in>S. R (\\<alpha> y) (\\<alpha> x)\n\ngoal (2 subgoals):\n 1. \\<And>S \\<sigma> x.\n       \\<lbrakk>c \\<sigma>; x \\<in> S0' - S; I (\\<alpha> ` S) \\<sigma>;\n        S \\<subseteq> S0';\n        \\<forall>y\\<in>S0' - S - {x}. R (\\<alpha> x) (\\<alpha> y);\n        \\<forall>y\\<in>S. R (\\<alpha> y) (\\<alpha> x)\\<rbrakk>\n       \\<Longrightarrow> I (\\<alpha> ` insert x S) (f x \\<sigma>)\n 2. \\<And>\\<sigma> S.\n       \\<lbrakk>S \\<subseteq> S0'; S \\<noteq> S0'; \\<not> c \\<sigma>;\n        I (\\<alpha> ` S) \\<sigma>;\n        \\<forall>x\\<in>S0' - S.\n           \\<forall>y\\<in>S. R (\\<alpha> y) (\\<alpha> x)\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "from prems S0'_props"], ["proof (chain)\npicking this:\n  c \\<sigma>\n  x \\<in> S0' - S\n  I (\\<alpha> ` S) \\<sigma>\n  S \\<subseteq> S0'\n  \\<forall>y\\<in>S0' - S - {x}. R (\\<alpha> x) (\\<alpha> y)\n  \\<forall>y\\<in>S. R (\\<alpha> y) (\\<alpha> x)\n  set_iterator_genord iti S0' (\\<lambda>x y. R (\\<alpha> x) (\\<alpha> y))\n  inj_on \\<alpha> S0'\n  S0 = \\<alpha> ` S0'\n  ?x \\<in> S0' \\<Longrightarrow> invar ?x", "have inv_x: \"invar x\""], ["proof (prove)\nusing this:\n  c \\<sigma>\n  x \\<in> S0' - S\n  I (\\<alpha> ` S) \\<sigma>\n  S \\<subseteq> S0'\n  \\<forall>y\\<in>S0' - S - {x}. R (\\<alpha> x) (\\<alpha> y)\n  \\<forall>y\\<in>S. R (\\<alpha> y) (\\<alpha> x)\n  set_iterator_genord iti S0' (\\<lambda>x y. R (\\<alpha> x) (\\<alpha> y))\n  inj_on \\<alpha> S0'\n  S0 = \\<alpha> ` S0'\n  ?x \\<in> S0' \\<Longrightarrow> invar ?x\n\ngoal (1 subgoal):\n 1. invar x", "by blast"], ["proof (state)\nthis:\n  invar x\n\ngoal (2 subgoals):\n 1. \\<And>S \\<sigma> x.\n       \\<lbrakk>c \\<sigma>; x \\<in> S0' - S; I (\\<alpha> ` S) \\<sigma>;\n        S \\<subseteq> S0';\n        \\<forall>y\\<in>S0' - S - {x}. R (\\<alpha> x) (\\<alpha> y);\n        \\<forall>y\\<in>S. R (\\<alpha> y) (\\<alpha> x)\\<rbrakk>\n       \\<Longrightarrow> I (\\<alpha> ` insert x S) (f x \\<sigma>)\n 2. \\<And>\\<sigma> S.\n       \\<lbrakk>S \\<subseteq> S0'; S \\<noteq> S0'; \\<not> c \\<sigma>;\n        I (\\<alpha> ` S) \\<sigma>;\n        \\<forall>x\\<in>S0' - S.\n           \\<forall>y\\<in>S. R (\\<alpha> y) (\\<alpha> x)\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "from prems(4)"], ["proof (chain)\npicking this:\n  S \\<subseteq> S0'", "have subs_alpha: \"\\<alpha> ` S \\<subseteq> \\<alpha> ` S0'\""], ["proof (prove)\nusing this:\n  S \\<subseteq> S0'\n\ngoal (1 subgoal):\n 1. \\<alpha> ` S \\<subseteq> \\<alpha> ` S0'", "by auto"], ["proof (state)\nthis:\n  \\<alpha> ` S \\<subseteq> \\<alpha> ` S0'\n\ngoal (2 subgoals):\n 1. \\<And>S \\<sigma> x.\n       \\<lbrakk>c \\<sigma>; x \\<in> S0' - S; I (\\<alpha> ` S) \\<sigma>;\n        S \\<subseteq> S0';\n        \\<forall>y\\<in>S0' - S - {x}. R (\\<alpha> x) (\\<alpha> y);\n        \\<forall>y\\<in>S. R (\\<alpha> y) (\\<alpha> x)\\<rbrakk>\n       \\<Longrightarrow> I (\\<alpha> ` insert x S) (f x \\<sigma>)\n 2. \\<And>\\<sigma> S.\n       \\<lbrakk>S \\<subseteq> S0'; S \\<noteq> S0'; \\<not> c \\<sigma>;\n        I (\\<alpha> ` S) \\<sigma>;\n        \\<forall>x\\<in>S0' - S.\n           \\<forall>y\\<in>S. R (\\<alpha> y) (\\<alpha> x)\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "from S0'_props prems(2,4)"], ["proof (chain)\npicking this:\n  set_iterator_genord iti S0' (\\<lambda>x y. R (\\<alpha> x) (\\<alpha> y))\n  inj_on \\<alpha> S0'\n  S0 = \\<alpha> ` S0'\n  ?x \\<in> S0' \\<Longrightarrow> invar ?x\n  x \\<in> S0' - S\n  S \\<subseteq> S0'", "have diff_alpha: \"\\<alpha> ` (S0' - S) - {\\<alpha> x} = \\<alpha> ` ((S0' - S) - {x})\" \"\\<alpha> ` S0' - \\<alpha> ` S = \\<alpha> ` (S0' - S)\""], ["proof (prove)\nusing this:\n  set_iterator_genord iti S0' (\\<lambda>x y. R (\\<alpha> x) (\\<alpha> y))\n  inj_on \\<alpha> S0'\n  S0 = \\<alpha> ` S0'\n  ?x \\<in> S0' \\<Longrightarrow> invar ?x\n  x \\<in> S0' - S\n  S \\<subseteq> S0'\n\ngoal (1 subgoal):\n 1. \\<alpha> ` (S0' - S) - {\\<alpha> x} = \\<alpha> ` (S0' - S - {x}) &&&\n    \\<alpha> ` S0' - \\<alpha> ` S = \\<alpha> ` (S0' - S)", "by (auto simp add: inj_on_def subset_iff Ball_def)"], ["proof (state)\nthis:\n  \\<alpha> ` (S0' - S) - {\\<alpha> x} = \\<alpha> ` (S0' - S - {x})\n  \\<alpha> ` S0' - \\<alpha> ` S = \\<alpha> ` (S0' - S)\n\ngoal (2 subgoals):\n 1. \\<And>S \\<sigma> x.\n       \\<lbrakk>c \\<sigma>; x \\<in> S0' - S; I (\\<alpha> ` S) \\<sigma>;\n        S \\<subseteq> S0';\n        \\<forall>y\\<in>S0' - S - {x}. R (\\<alpha> x) (\\<alpha> y);\n        \\<forall>y\\<in>S. R (\\<alpha> y) (\\<alpha> x)\\<rbrakk>\n       \\<Longrightarrow> I (\\<alpha> ` insert x S) (f x \\<sigma>)\n 2. \\<And>\\<sigma> S.\n       \\<lbrakk>S \\<subseteq> S0'; S \\<noteq> S0'; \\<not> c \\<sigma>;\n        I (\\<alpha> ` S) \\<sigma>;\n        \\<forall>x\\<in>S0' - S.\n           \\<forall>y\\<in>S. R (\\<alpha> y) (\\<alpha> x)\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. I (\\<alpha> ` insert x S) (f x \\<sigma>)", "using pre(2)[of \\<sigma> x \"\\<alpha> ` S\"] prems S0'_props(3)"], ["proof (prove)\nusing this:\n  \\<lbrakk>c \\<sigma>; invar x; \\<alpha> x \\<in> S0 - \\<alpha> ` S;\n   I (\\<alpha> ` S) \\<sigma>; \\<alpha> ` S \\<subseteq> S0;\n   \\<forall>y\\<in>S0 - \\<alpha> ` S - {\\<alpha> x}. R (\\<alpha> x) y;\n   \\<forall>y\\<in>\\<alpha> ` S. R y (\\<alpha> x)\\<rbrakk>\n  \\<Longrightarrow> I (insert (\\<alpha> x) (\\<alpha> ` S)) (f x \\<sigma>)\n  c \\<sigma>\n  x \\<in> S0' - S\n  I (\\<alpha> ` S) \\<sigma>\n  S \\<subseteq> S0'\n  \\<forall>y\\<in>S0' - S - {x}. R (\\<alpha> x) (\\<alpha> y)\n  \\<forall>y\\<in>S. R (\\<alpha> y) (\\<alpha> x)\n  S0 = \\<alpha> ` S0'\n\ngoal (1 subgoal):\n 1. I (\\<alpha> ` insert x S) (f x \\<sigma>)", "by (simp add: diff_alpha inv_x subs_alpha)"], ["proof (state)\nthis:\n  I (\\<alpha> ` insert x S) (f x \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> S.\n       \\<lbrakk>S \\<subseteq> S0'; S \\<noteq> S0'; \\<not> c \\<sigma>;\n        I (\\<alpha> ` S) \\<sigma>;\n        \\<forall>x\\<in>S0' - S.\n           \\<forall>y\\<in>S. R (\\<alpha> y) (\\<alpha> x)\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> S.\n       \\<lbrakk>S \\<subseteq> S0'; S \\<noteq> S0'; \\<not> c \\<sigma>;\n        I (\\<alpha> ` S) \\<sigma>;\n        \\<forall>x\\<in>S0' - S.\n           \\<forall>y\\<in>S. R (\\<alpha> y) (\\<alpha> x)\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "case prems: (4 \\<sigma> S)"], ["proof (state)\nthis:\n  S \\<subseteq> S0'\n  S \\<noteq> S0'\n  \\<not> c \\<sigma>\n  I (\\<alpha> ` S) \\<sigma>\n  \\<forall>x\\<in>S0' - S. \\<forall>y\\<in>S. R (\\<alpha> y) (\\<alpha> x)\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> S.\n       \\<lbrakk>S \\<subseteq> S0'; S \\<noteq> S0'; \\<not> c \\<sigma>;\n        I (\\<alpha> ` S) \\<sigma>;\n        \\<forall>x\\<in>S0' - S.\n           \\<forall>y\\<in>S. R (\\<alpha> y) (\\<alpha> x)\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "from prems(1)"], ["proof (chain)\npicking this:\n  S \\<subseteq> S0'", "have subs_alpha: \"\\<alpha> ` S \\<subseteq> \\<alpha> ` S0'\""], ["proof (prove)\nusing this:\n  S \\<subseteq> S0'\n\ngoal (1 subgoal):\n 1. \\<alpha> ` S \\<subseteq> \\<alpha> ` S0'", "by auto"], ["proof (state)\nthis:\n  \\<alpha> ` S \\<subseteq> \\<alpha> ` S0'\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> S.\n       \\<lbrakk>S \\<subseteq> S0'; S \\<noteq> S0'; \\<not> c \\<sigma>;\n        I (\\<alpha> ` S) \\<sigma>;\n        \\<forall>x\\<in>S0' - S.\n           \\<forall>y\\<in>S. R (\\<alpha> y) (\\<alpha> x)\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "from S0'_props prems"], ["proof (chain)\npicking this:\n  set_iterator_genord iti S0' (\\<lambda>x y. R (\\<alpha> x) (\\<alpha> y))\n  inj_on \\<alpha> S0'\n  S0 = \\<alpha> ` S0'\n  ?x \\<in> S0' \\<Longrightarrow> invar ?x\n  S \\<subseteq> S0'\n  S \\<noteq> S0'\n  \\<not> c \\<sigma>\n  I (\\<alpha> ` S) \\<sigma>\n  \\<forall>x\\<in>S0' - S. \\<forall>y\\<in>S. R (\\<alpha> y) (\\<alpha> x)", "have diff_alpha: \"\\<alpha> ` S0' - \\<alpha> ` S = \\<alpha> ` (S0' - S)\""], ["proof (prove)\nusing this:\n  set_iterator_genord iti S0' (\\<lambda>x y. R (\\<alpha> x) (\\<alpha> y))\n  inj_on \\<alpha> S0'\n  S0 = \\<alpha> ` S0'\n  ?x \\<in> S0' \\<Longrightarrow> invar ?x\n  S \\<subseteq> S0'\n  S \\<noteq> S0'\n  \\<not> c \\<sigma>\n  I (\\<alpha> ` S) \\<sigma>\n  \\<forall>x\\<in>S0' - S. \\<forall>y\\<in>S. R (\\<alpha> y) (\\<alpha> x)\n\ngoal (1 subgoal):\n 1. \\<alpha> ` S0' - \\<alpha> ` S = \\<alpha> ` (S0' - S)", "by (auto simp add: inj_on_def subset_iff Ball_def)"], ["proof (state)\nthis:\n  \\<alpha> ` S0' - \\<alpha> ` S = \\<alpha> ` (S0' - S)\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> S.\n       \\<lbrakk>S \\<subseteq> S0'; S \\<noteq> S0'; \\<not> c \\<sigma>;\n        I (\\<alpha> ` S) \\<sigma>;\n        \\<forall>x\\<in>S0' - S.\n           \\<forall>y\\<in>S. R (\\<alpha> y) (\\<alpha> x)\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "from prems(1,2) S0'_props(2,3)"], ["proof (chain)\npicking this:\n  S \\<subseteq> S0'\n  S \\<noteq> S0'\n  inj_on \\<alpha> S0'\n  S0 = \\<alpha> ` S0'", "have alpha_eq: \"\\<alpha> ` S \\<noteq> \\<alpha> ` S0'\""], ["proof (prove)\nusing this:\n  S \\<subseteq> S0'\n  S \\<noteq> S0'\n  inj_on \\<alpha> S0'\n  S0 = \\<alpha> ` S0'\n\ngoal (1 subgoal):\n 1. \\<alpha> ` S \\<noteq> \\<alpha> ` S0'", "apply (simp add: inj_on_def set_eq_iff image_iff Bex_def subset_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>t. t \\<in> S \\<longrightarrow> t \\<in> S0';\n     \\<exists>x. (x \\<in> S) = (x \\<notin> S0');\n     \\<forall>x\\<in>S0'.\n        \\<forall>y\\<in>S0'. \\<alpha> x = \\<alpha> y \\<longrightarrow> x = y;\n     \\<forall>x.\n        (x \\<in> S0) =\n        (\\<exists>xa. xa \\<in> S0' \\<and> x = \\<alpha> xa)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x.\n                         (\\<exists>xa. xa \\<in> S \\<and> x = \\<alpha> xa) =\n                         (\\<forall>xa.\n                             xa \\<in> S0' \\<longrightarrow>\n                             x \\<noteq> \\<alpha> xa)", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<alpha> ` S \\<noteq> \\<alpha> ` S0'\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> S.\n       \\<lbrakk>S \\<subseteq> S0'; S \\<noteq> S0'; \\<not> c \\<sigma>;\n        I (\\<alpha> ` S) \\<sigma>;\n        \\<forall>x\\<in>S0' - S.\n           \\<forall>y\\<in>S. R (\\<alpha> y) (\\<alpha> x)\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<sigma>", "using pre(4)[of \"\\<alpha> ` S\" \\<sigma>] S0'_props prems"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<alpha> ` S \\<subseteq> S0; \\<alpha> ` S \\<noteq> S0;\n   \\<not> c \\<sigma>; I (\\<alpha> ` S) \\<sigma>;\n   \\<forall>x\\<in>S0 - \\<alpha> ` S.\n      \\<forall>y\\<in>\\<alpha> ` S. R y x\\<rbrakk>\n  \\<Longrightarrow> P \\<sigma>\n  set_iterator_genord iti S0' (\\<lambda>x y. R (\\<alpha> x) (\\<alpha> y))\n  inj_on \\<alpha> S0'\n  S0 = \\<alpha> ` S0'\n  ?x \\<in> S0' \\<Longrightarrow> invar ?x\n  S \\<subseteq> S0'\n  S \\<noteq> S0'\n  \\<not> c \\<sigma>\n  I (\\<alpha> ` S) \\<sigma>\n  \\<forall>x\\<in>S0' - S. \\<forall>y\\<in>S. R (\\<alpha> y) (\\<alpha> x)\n\ngoal (1 subgoal):\n 1. P \\<sigma>", "by (auto simp add: subs_alpha diff_alpha alpha_eq)"], ["proof (state)\nthis:\n  P \\<sigma>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P (iti c f \\<sigma>0)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma set_iterator_abs_genord_trivial:\n  \"set_iterator_abs_genord id (\\<lambda>_. True) = set_iterator_genord\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_abs_genord id (\\<lambda>_. True) = set_iterator_genord", "by (simp add: set_iterator_genord_def set_iterator_abs_genord_def fun_eq_iff)"], ["", "lemma set_iterator_abs_genord_trivial_simp [simp] :\n  assumes \"\\<forall>x. invar x\"\n      and \"\\<forall>x. \\<alpha> x = x\"\nshows \"set_iterator_abs_genord \\<alpha> invar = set_iterator_genord\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_abs_genord \\<alpha> invar = set_iterator_genord", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set_iterator_abs_genord \\<alpha> invar = set_iterator_genord", "from assms"], ["proof (chain)\npicking this:\n  \\<forall>x. invar x\n  \\<forall>x. \\<alpha> x = x", "have \"invar = (\\<lambda>_. True)\" and \"\\<alpha> = id\""], ["proof (prove)\nusing this:\n  \\<forall>x. invar x\n  \\<forall>x. \\<alpha> x = x\n\ngoal (1 subgoal):\n 1. invar = (\\<lambda>_. True) &&& \\<alpha> = id", "by (simp_all add: fun_eq_iff)"], ["proof (state)\nthis:\n  invar = (\\<lambda>_. True)\n  \\<alpha> = id\n\ngoal (1 subgoal):\n 1. set_iterator_abs_genord \\<alpha> invar = set_iterator_genord", "thus ?thesis"], ["proof (prove)\nusing this:\n  invar = (\\<lambda>_. True)\n  \\<alpha> = id\n\ngoal (1 subgoal):\n 1. set_iterator_abs_genord \\<alpha> invar = set_iterator_genord", "by (simp add: set_iterator_abs_genord_trivial)"], ["proof (state)\nthis:\n  set_iterator_abs_genord \\<alpha> invar = set_iterator_genord\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Introduce iterators over representations\\<close>"], ["", "lemma set_iterator_abs_genord_I2 :\n  assumes it_OK: \"set_iterator_genord iti S0 Rc\"\n      and R_OK: \"\\<And>xc1 xc2. \\<lbrakk>invar xc1; invar xc2; Rc xc1 xc2\\<rbrakk> \\<Longrightarrow> Ra (\\<alpha> xc1) (\\<alpha> xc2)\"\n      and dist: \"\\<And>xc1 xc2. \\<lbrakk>invar xc1; invar xc2; xc1 \\<in> S0; xc2 \\<in> S0; \\<alpha> xc1 = \\<alpha> xc2\\<rbrakk> \\<Longrightarrow> xc1 = xc2\"\n      and invar: \"\\<And>xc. xc \\<in> S0 \\<Longrightarrow> invar xc\"\n      and S0'_eq: \"S0' = \\<alpha> ` S0\"\n  shows \"set_iterator_abs_genord \\<alpha> invar iti S0' Ra\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_abs_genord \\<alpha> invar iti S0' Ra", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set_iterator_abs_genord \\<alpha> invar iti S0' Ra", "from it_OK"], ["proof (chain)\npicking this:\n  set_iterator_genord iti S0 Rc", "obtain l0 where dist_l0: \"distinct l0\" and \n          S0_eq: \"S0 = set l0\" and \n          sort_Rc: \"sorted_wrt Rc l0\"  and iti_eq: \"iti = foldli l0\""], ["proof (prove)\nusing this:\n  set_iterator_genord iti S0 Rc\n\ngoal (1 subgoal):\n 1. (\\<And>l0.\n        \\<lbrakk>distinct l0; S0 = set l0; sorted_wrt Rc l0;\n         iti = foldli l0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding set_iterator_genord_def"], ["proof (prove)\nusing this:\n  \\<exists>l0.\n     distinct l0 \\<and>\n     S0 = set l0 \\<and> sorted_wrt Rc l0 \\<and> iti = foldli l0\n\ngoal (1 subgoal):\n 1. (\\<And>l0.\n        \\<lbrakk>distinct l0; S0 = set l0; sorted_wrt Rc l0;\n         iti = foldli l0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  distinct l0\n  S0 = set l0\n  sorted_wrt Rc l0\n  iti = foldli l0\n\ngoal (1 subgoal):\n 1. set_iterator_abs_genord \\<alpha> invar iti S0' Ra", "have \"set l0 \\<subseteq> S0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set l0 \\<subseteq> S0", "unfolding S0_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. set l0 \\<subseteq> set l0", "by simp"], ["proof (state)\nthis:\n  set l0 \\<subseteq> S0\n\ngoal (1 subgoal):\n 1. set_iterator_abs_genord \\<alpha> invar iti S0' Ra", "with dist_l0 sort_Rc"], ["proof (chain)\npicking this:\n  distinct l0\n  sorted_wrt Rc l0\n  set l0 \\<subseteq> S0", "have map_props: \"distinct (map \\<alpha> l0) \\<and> sorted_wrt Ra (map \\<alpha> l0)\""], ["proof (prove)\nusing this:\n  distinct l0\n  sorted_wrt Rc l0\n  set l0 \\<subseteq> S0\n\ngoal (1 subgoal):\n 1. distinct (map \\<alpha> l0) \\<and> sorted_wrt Ra (map \\<alpha> l0)", "proof (induct l0)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct []; sorted_wrt Rc []; set [] \\<subseteq> S0\\<rbrakk>\n    \\<Longrightarrow> distinct (map \\<alpha> []) \\<and>\n                      sorted_wrt Ra (map \\<alpha> [])\n 2. \\<And>a l0.\n       \\<lbrakk>\\<lbrakk>distinct l0; sorted_wrt Rc l0;\n                 set l0 \\<subseteq> S0\\<rbrakk>\n                \\<Longrightarrow> distinct (map \\<alpha> l0) \\<and>\n                                  sorted_wrt Ra (map \\<alpha> l0);\n        distinct (a # l0); sorted_wrt Rc (a # l0);\n        set (a # l0) \\<subseteq> S0\\<rbrakk>\n       \\<Longrightarrow> distinct (map \\<alpha> (a # l0)) \\<and>\n                         sorted_wrt Ra (map \\<alpha> (a # l0))", "case Nil"], ["proof (state)\nthis:\n  distinct []\n  sorted_wrt Rc []\n  set [] \\<subseteq> S0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct []; sorted_wrt Rc []; set [] \\<subseteq> S0\\<rbrakk>\n    \\<Longrightarrow> distinct (map \\<alpha> []) \\<and>\n                      sorted_wrt Ra (map \\<alpha> [])\n 2. \\<And>a l0.\n       \\<lbrakk>\\<lbrakk>distinct l0; sorted_wrt Rc l0;\n                 set l0 \\<subseteq> S0\\<rbrakk>\n                \\<Longrightarrow> distinct (map \\<alpha> l0) \\<and>\n                                  sorted_wrt Ra (map \\<alpha> l0);\n        distinct (a # l0); sorted_wrt Rc (a # l0);\n        set (a # l0) \\<subseteq> S0\\<rbrakk>\n       \\<Longrightarrow> distinct (map \\<alpha> (a # l0)) \\<and>\n                         sorted_wrt Ra (map \\<alpha> (a # l0))", "thus ?case"], ["proof (prove)\nusing this:\n  distinct []\n  sorted_wrt Rc []\n  set [] \\<subseteq> S0\n\ngoal (1 subgoal):\n 1. distinct (map \\<alpha> []) \\<and> sorted_wrt Ra (map \\<alpha> [])", "by simp"], ["proof (state)\nthis:\n  distinct (map \\<alpha> []) \\<and> sorted_wrt Ra (map \\<alpha> [])\n\ngoal (1 subgoal):\n 1. \\<And>a l0.\n       \\<lbrakk>\\<lbrakk>distinct l0; sorted_wrt Rc l0;\n                 set l0 \\<subseteq> S0\\<rbrakk>\n                \\<Longrightarrow> distinct (map \\<alpha> l0) \\<and>\n                                  sorted_wrt Ra (map \\<alpha> l0);\n        distinct (a # l0); sorted_wrt Rc (a # l0);\n        set (a # l0) \\<subseteq> S0\\<rbrakk>\n       \\<Longrightarrow> distinct (map \\<alpha> (a # l0)) \\<and>\n                         sorted_wrt Ra (map \\<alpha> (a # l0))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a l0.\n       \\<lbrakk>\\<lbrakk>distinct l0; sorted_wrt Rc l0;\n                 set l0 \\<subseteq> S0\\<rbrakk>\n                \\<Longrightarrow> distinct (map \\<alpha> l0) \\<and>\n                                  sorted_wrt Ra (map \\<alpha> l0);\n        distinct (a # l0); sorted_wrt Rc (a # l0);\n        set (a # l0) \\<subseteq> S0\\<rbrakk>\n       \\<Longrightarrow> distinct (map \\<alpha> (a # l0)) \\<and>\n                         sorted_wrt Ra (map \\<alpha> (a # l0))", "case (Cons x l0)"], ["proof (state)\nthis:\n  \\<lbrakk>distinct l0; sorted_wrt Rc l0; set l0 \\<subseteq> S0\\<rbrakk>\n  \\<Longrightarrow> distinct (map \\<alpha> l0) \\<and>\n                    sorted_wrt Ra (map \\<alpha> l0)\n  distinct (x # l0)\n  sorted_wrt Rc (x # l0)\n  set (x # l0) \\<subseteq> S0\n\ngoal (1 subgoal):\n 1. \\<And>a l0.\n       \\<lbrakk>\\<lbrakk>distinct l0; sorted_wrt Rc l0;\n                 set l0 \\<subseteq> S0\\<rbrakk>\n                \\<Longrightarrow> distinct (map \\<alpha> l0) \\<and>\n                                  sorted_wrt Ra (map \\<alpha> l0);\n        distinct (a # l0); sorted_wrt Rc (a # l0);\n        set (a # l0) \\<subseteq> S0\\<rbrakk>\n       \\<Longrightarrow> distinct (map \\<alpha> (a # l0)) \\<and>\n                         sorted_wrt Ra (map \\<alpha> (a # l0))", "hence \"distinct l0\" and \"x \\<notin> set l0\" and \"x \\<in> S0\" and \"set l0 \\<subseteq> S0\" and\n            \"distinct (map \\<alpha> l0)\" \"sorted_wrt Ra (map \\<alpha> l0)\" \"\\<And>x'. x' \\<in> set l0 \\<Longrightarrow> Rc x x'\""], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct l0; sorted_wrt Rc l0; set l0 \\<subseteq> S0\\<rbrakk>\n  \\<Longrightarrow> distinct (map \\<alpha> l0) \\<and>\n                    sorted_wrt Ra (map \\<alpha> l0)\n  distinct (x # l0)\n  sorted_wrt Rc (x # l0)\n  set (x # l0) \\<subseteq> S0\n\ngoal (1 subgoal):\n 1. (distinct l0 &&& x \\<notin> set l0) &&&\n    x \\<in> S0 &&&\n    set l0 \\<subseteq> S0 &&&\n    distinct (map \\<alpha> l0) &&&\n    sorted_wrt Ra (map \\<alpha> l0) &&&\n    (\\<And>x'. x' \\<in> set l0 \\<Longrightarrow> Rc x x')", "by (simp_all)"], ["proof (state)\nthis:\n  distinct l0\n  x \\<notin> set l0\n  x \\<in> S0\n  set l0 \\<subseteq> S0\n  distinct (map \\<alpha> l0)\n  sorted_wrt Ra (map \\<alpha> l0)\n  ?x' \\<in> set l0 \\<Longrightarrow> Rc x ?x'\n\ngoal (1 subgoal):\n 1. \\<And>a l0.\n       \\<lbrakk>\\<lbrakk>distinct l0; sorted_wrt Rc l0;\n                 set l0 \\<subseteq> S0\\<rbrakk>\n                \\<Longrightarrow> distinct (map \\<alpha> l0) \\<and>\n                                  sorted_wrt Ra (map \\<alpha> l0);\n        distinct (a # l0); sorted_wrt Rc (a # l0);\n        set (a # l0) \\<subseteq> S0\\<rbrakk>\n       \\<Longrightarrow> distinct (map \\<alpha> (a # l0)) \\<and>\n                         sorted_wrt Ra (map \\<alpha> (a # l0))", "thus ?case"], ["proof (prove)\nusing this:\n  distinct l0\n  x \\<notin> set l0\n  x \\<in> S0\n  set l0 \\<subseteq> S0\n  distinct (map \\<alpha> l0)\n  sorted_wrt Ra (map \\<alpha> l0)\n  ?x' \\<in> set l0 \\<Longrightarrow> Rc x ?x'\n\ngoal (1 subgoal):\n 1. distinct (map \\<alpha> (x # l0)) \\<and>\n    sorted_wrt Ra (map \\<alpha> (x # l0))", "using dist[of x] R_OK[of x] invar"], ["proof (prove)\nusing this:\n  distinct l0\n  x \\<notin> set l0\n  x \\<in> S0\n  set l0 \\<subseteq> S0\n  distinct (map \\<alpha> l0)\n  sorted_wrt Ra (map \\<alpha> l0)\n  ?x' \\<in> set l0 \\<Longrightarrow> Rc x ?x'\n  \\<lbrakk>invar x; invar ?xc2.0; x \\<in> S0; ?xc2.0 \\<in> S0;\n   \\<alpha> x = \\<alpha> ?xc2.0\\<rbrakk>\n  \\<Longrightarrow> x = ?xc2.0\n  \\<lbrakk>invar x; invar ?xc2.0; Rc x ?xc2.0\\<rbrakk>\n  \\<Longrightarrow> Ra (\\<alpha> x) (\\<alpha> ?xc2.0)\n  ?xc \\<in> S0 \\<Longrightarrow> invar ?xc\n\ngoal (1 subgoal):\n 1. distinct (map \\<alpha> (x # l0)) \\<and>\n    sorted_wrt Ra (map \\<alpha> (x # l0))", "apply (simp add: image_iff Ball_def subset_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct l0; x \\<notin> set l0; x \\<in> S0;\n     \\<forall>t. t \\<in> set l0 \\<longrightarrow> t \\<in> S0;\n     distinct (map \\<alpha> l0); sorted_wrt Ra (map \\<alpha> l0);\n     \\<And>x'. x' \\<in> set l0 \\<Longrightarrow> Rc x x';\n     \\<And>xc2.\n        \\<lbrakk>xc2 \\<in> S0; \\<alpha> x = \\<alpha> xc2\\<rbrakk>\n        \\<Longrightarrow> x = xc2;\n     \\<And>xc2.\n        \\<lbrakk>invar xc2; Rc x xc2\\<rbrakk>\n        \\<Longrightarrow> Ra (\\<alpha> x) (\\<alpha> xc2);\n     \\<And>xc. xc \\<in> S0 \\<Longrightarrow> invar xc\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>xa.\n                          xa \\<in> set l0 \\<longrightarrow>\n                          \\<alpha> x \\<noteq> \\<alpha> xa) \\<and>\n                      (\\<forall>xa.\n                          (\\<exists>x\\<in>set l0.\n                              xa = \\<alpha> x) \\<longrightarrow>\n                          Ra (\\<alpha> x) xa)", "apply metis"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  distinct (map \\<alpha> (x # l0)) \\<and>\n  sorted_wrt Ra (map \\<alpha> (x # l0))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  distinct (map \\<alpha> l0) \\<and> sorted_wrt Ra (map \\<alpha> l0)\n\ngoal (1 subgoal):\n 1. set_iterator_abs_genord \\<alpha> invar iti S0' Ra", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_abs_genord \\<alpha> invar iti S0' Ra", "unfolding S0'_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_abs_genord \\<alpha> invar iti (\\<alpha> ` S0) Ra", "apply (rule set_iterator_abs_genord.intro)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>lc.\n       (\\<forall>xc\\<in>set lc. invar xc) \\<and>\n       distinct (map \\<alpha> lc) \\<and>\n       \\<alpha> ` S0 = set (map \\<alpha> lc) \\<and>\n       sorted_wrt Ra (map \\<alpha> lc) \\<and> iti = foldli lc", "apply (rule_tac exI[where x = l0])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>xc\\<in>set l0. invar xc) \\<and>\n    distinct (map \\<alpha> l0) \\<and>\n    \\<alpha> ` S0 = set (map \\<alpha> l0) \\<and>\n    sorted_wrt Ra (map \\<alpha> l0) \\<and> iti = foldli l0", "apply (simp add: iti_eq map_props S0_eq Ball_def invar)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  set_iterator_abs_genord \\<alpha> invar iti S0' Ra\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Map-Iterators\\<close>"], ["", "lemma map_to_set_cong: \n  \"map_to_set m1 = map_to_set m2 \\<longleftrightarrow> m1 = m2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map_to_set m1 = map_to_set m2) = (m1 = m2)", "apply (simp add: set_eq_iff map_to_set_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>a b. (m1 a = Some b) = (m2 a = Some b)) = (m1 = m2)", "apply (simp add: fun_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>a b. (m1 a = Some b) = (m2 a = Some b)) =\n    (\\<forall>x. m1 x = m2 x)", "apply (metis not_Some_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition \"map_iterator_abs_genord \\<alpha> invar it m R \\<equiv> \nset_iterator_abs_genord (\\<lambda>(k,v). (k, \\<alpha> v)) (\\<lambda>(k,v). invar v) it (map_to_set m) R\""], ["", "lemma map_iterator_abs_genord_I2 :\n  assumes it_OK: \"map_iterator_genord iti m R'\"\n      and invar: \"\\<And>k v. m k = Some v \\<Longrightarrow> invar v\"\n      and R_OK: \"\\<And>k v k' v'. invar v \\<Longrightarrow> invar v' \\<Longrightarrow> R' (k, v) (k', v') \\<Longrightarrow> R (k, \\<alpha> v) (k', \\<alpha> v')\"\n      and m'_eq: \"m' = ((map_option \\<alpha>) o m)\"\n  shows \"map_iterator_abs_genord \\<alpha> invar iti m' R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_iterator_abs_genord \\<alpha> invar iti m' R", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map_iterator_abs_genord \\<alpha> invar iti m' R", "let ?\\<alpha>' = \"\\<lambda>(k,v). (k, \\<alpha> v)\""], ["proof (state)\ngoal (1 subgoal):\n 1. map_iterator_abs_genord \\<alpha> invar iti m' R", "let ?invar' = \"\\<lambda>(k,v). invar v\""], ["proof (state)\ngoal (1 subgoal):\n 1. map_iterator_abs_genord \\<alpha> invar iti m' R", "have \\<alpha>_rewr: \"?\\<alpha>' ` (map_to_set m) = map_to_set ((map_option \\<alpha>) o m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(k, v). (k, \\<alpha> v)) ` map_to_set m =\n    map_to_set (map_option \\<alpha> \\<circ> m)", "by (auto simp add: map_to_set_def)"], ["proof (state)\nthis:\n  (\\<lambda>(k, v). (k, \\<alpha> v)) ` map_to_set m =\n  map_to_set (map_option \\<alpha> \\<circ> m)\n\ngoal (1 subgoal):\n 1. map_iterator_abs_genord \\<alpha> invar iti m' R", "note rule' = set_iterator_abs_genord_I2[OF it_OK[unfolded set_iterator_def], \n    of ?invar' R ?\\<alpha>' \"map_to_set (map_option \\<alpha> \\<circ> m)\", unfolded \\<alpha>_rewr map_iterator_abs_genord_def[symmetric]]"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>xc1 xc2.\n              \\<lbrakk>case xc1 of (k, v) \\<Rightarrow> invar v;\n               case xc2 of (k, v) \\<Rightarrow> invar v; R' xc1 xc2\\<rbrakk>\n              \\<Longrightarrow> R (case xc1 of\n                                   (k, v) \\<Rightarrow> (k, \\<alpha> v))\n                                 (case xc2 of\n                                  (k, v) \\<Rightarrow> (k, \\<alpha> v));\n   \\<And>xc1 xc2.\n      \\<lbrakk>case xc1 of (k, v) \\<Rightarrow> invar v;\n       case xc2 of (k, v) \\<Rightarrow> invar v; xc1 \\<in> map_to_set m;\n       xc2 \\<in> map_to_set m;\n       (case xc1 of (k, v) \\<Rightarrow> (k, \\<alpha> v)) =\n       (case xc2 of (k, v) \\<Rightarrow> (k, \\<alpha> v))\\<rbrakk>\n      \\<Longrightarrow> xc1 = xc2;\n   \\<And>xc.\n      xc \\<in> map_to_set m \\<Longrightarrow>\n      case xc of (k, v) \\<Rightarrow> invar v;\n   map_to_set (map_option \\<alpha> \\<circ> m) =\n   map_to_set (map_option \\<alpha> \\<circ> m)\\<rbrakk>\n  \\<Longrightarrow> map_iterator_abs_genord \\<alpha> invar iti\n                     (map_option \\<alpha> \\<circ> m) R\n\ngoal (1 subgoal):\n 1. map_iterator_abs_genord \\<alpha> invar iti m' R", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_iterator_abs_genord \\<alpha> invar iti m' R", "unfolding m'_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_iterator_abs_genord \\<alpha> invar iti\n     (map_option \\<alpha> \\<circ> m) R", "apply (rule rule')"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>xc1 xc2.\n       \\<lbrakk>case xc1 of (k, v) \\<Rightarrow> invar v;\n        case xc2 of (k, v) \\<Rightarrow> invar v; R' xc1 xc2\\<rbrakk>\n       \\<Longrightarrow> R (case xc1 of\n                            (k, v) \\<Rightarrow> (k, \\<alpha> v))\n                          (case xc2 of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n 2. \\<And>xc1 xc2.\n       \\<lbrakk>case xc1 of (k, v) \\<Rightarrow> invar v;\n        case xc2 of (k, v) \\<Rightarrow> invar v; xc1 \\<in> map_to_set m;\n        xc2 \\<in> map_to_set m;\n        (case xc1 of (k, v) \\<Rightarrow> (k, \\<alpha> v)) =\n        (case xc2 of (k, v) \\<Rightarrow> (k, \\<alpha> v))\\<rbrakk>\n       \\<Longrightarrow> xc1 = xc2\n 3. \\<And>xc.\n       xc \\<in> map_to_set m \\<Longrightarrow>\n       case xc of (k, v) \\<Rightarrow> invar v\n 4. map_to_set (map_option \\<alpha> \\<circ> m) =\n    map_to_set (map_option \\<alpha> \\<circ> m)", "apply (auto simp add: map_to_set_def invar R_OK)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  map_iterator_abs_genord \\<alpha> invar iti m' R\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_iterator_abs_genord_remove_abs2 :\n  assumes iti: \"map_iterator_abs_genord \\<alpha> invar iti m R\"\n  obtains m' where \"map_iterator_genord iti m' (\\<lambda>(k, v) (k', v'). R (k, \\<alpha> v) (k', \\<alpha> v'))\"\n       \"(map_option \\<alpha>) o m' = m\" \"\\<And>k v. m' k = Some v \\<Longrightarrow> invar v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m'.\n        \\<lbrakk>map_iterator_genord iti m'\n                  (\\<lambda>(k, v) (k', v').\n                      R (k, \\<alpha> v) (k', \\<alpha> v'));\n         map_option \\<alpha> \\<circ> m' = m;\n         \\<And>k v. m' k = Some v \\<Longrightarrow> invar v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>m'.\n        \\<lbrakk>map_iterator_genord iti m'\n                  (\\<lambda>(k, v) (k', v').\n                      R (k, \\<alpha> v) (k', \\<alpha> v'));\n         map_option \\<alpha> \\<circ> m' = m;\n         \\<And>k v. m' k = Some v \\<Longrightarrow> invar v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?\\<alpha>' = \"\\<lambda>(k,v). (k, \\<alpha> v)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>m'.\n        \\<lbrakk>map_iterator_genord iti m'\n                  (\\<lambda>(k, v) (k', v').\n                      R (k, \\<alpha> v) (k', \\<alpha> v'));\n         map_option \\<alpha> \\<circ> m' = m;\n         \\<And>k v. m' k = Some v \\<Longrightarrow> invar v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?invar' = \"\\<lambda>(k,v). invar v\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>m'.\n        \\<lbrakk>map_iterator_genord iti m'\n                  (\\<lambda>(k, v) (k', v').\n                      R (k, \\<alpha> v) (k', \\<alpha> v'));\n         map_option \\<alpha> \\<circ> m' = m;\n         \\<And>k v. m' k = Some v \\<Longrightarrow> invar v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from set_iterator_abs_genord.foldli_transform [OF iti[unfolded map_iterator_abs_genord_def]]"], ["proof (chain)\npicking this:\n  \\<exists>lc.\n     (\\<forall>xc\\<in>set lc.\n         case xc of (k, v) \\<Rightarrow> invar v) \\<and>\n     distinct (map (\\<lambda>(k, v). (k, \\<alpha> v)) lc) \\<and>\n     map_to_set m = set (map (\\<lambda>(k, v). (k, \\<alpha> v)) lc) \\<and>\n     sorted_wrt R (map (\\<lambda>(k, v). (k, \\<alpha> v)) lc) \\<and>\n     iti = foldli lc", "obtain lc where lc_invar: \"\\<And>k v. (k, v) \\<in> set lc \\<Longrightarrow> invar v\" \n      and \\<alpha>_props: \"distinct (map ?\\<alpha>' lc)\" \"map_to_set m = set (map ?\\<alpha>' lc)\" \n                   \"sorted_wrt R (map ?\\<alpha>' lc)\" \n      and iti_eq: \"iti = foldli lc\""], ["proof (prove)\nusing this:\n  \\<exists>lc.\n     (\\<forall>xc\\<in>set lc.\n         case xc of (k, v) \\<Rightarrow> invar v) \\<and>\n     distinct (map (\\<lambda>(k, v). (k, \\<alpha> v)) lc) \\<and>\n     map_to_set m = set (map (\\<lambda>(k, v). (k, \\<alpha> v)) lc) \\<and>\n     sorted_wrt R (map (\\<lambda>(k, v). (k, \\<alpha> v)) lc) \\<and>\n     iti = foldli lc\n\ngoal (1 subgoal):\n 1. (\\<And>lc.\n        \\<lbrakk>\\<And>k v. (k, v) \\<in> set lc \\<Longrightarrow> invar v;\n         distinct (map (\\<lambda>(k, v). (k, \\<alpha> v)) lc);\n         map_to_set m = set (map (\\<lambda>(k, v). (k, \\<alpha> v)) lc);\n         sorted_wrt R (map (\\<lambda>(k, v). (k, \\<alpha> v)) lc);\n         iti = foldli lc\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (?k2, ?v2) \\<in> set lc \\<Longrightarrow> invar ?v2\n  distinct (map (\\<lambda>(k, v). (k, \\<alpha> v)) lc)\n  map_to_set m = set (map (\\<lambda>(k, v). (k, \\<alpha> v)) lc)\n  sorted_wrt R (map (\\<lambda>(k, v). (k, \\<alpha> v)) lc)\n  iti = foldli lc\n\ngoal (1 subgoal):\n 1. (\\<And>m'.\n        \\<lbrakk>map_iterator_genord iti m'\n                  (\\<lambda>(k, v) (k', v').\n                      R (k, \\<alpha> v) (k', \\<alpha> v'));\n         map_option \\<alpha> \\<circ> m' = m;\n         \\<And>k v. m' k = Some v \\<Longrightarrow> invar v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from \\<alpha>_props(2)[symmetric]"], ["proof (chain)\npicking this:\n  set (map (\\<lambda>(k, v). (k, \\<alpha> v)) lc) = map_to_set m", "have in_lc: \"\\<And>k v. (k, v) \\<in> set lc \\<Longrightarrow> m k = Some (\\<alpha> v)\""], ["proof (prove)\nusing this:\n  set (map (\\<lambda>(k, v). (k, \\<alpha> v)) lc) = map_to_set m\n\ngoal (1 subgoal):\n 1. \\<And>k v. (k, v) \\<in> set lc \\<Longrightarrow> m k = Some (\\<alpha> v)", "by (auto simp add: set_eq_iff image_iff map_to_set_def Ball_def Bex_def)"], ["proof (state)\nthis:\n  (?k2, ?v2) \\<in> set lc \\<Longrightarrow> m ?k2 = Some (\\<alpha> ?v2)\n\ngoal (1 subgoal):\n 1. (\\<And>m'.\n        \\<lbrakk>map_iterator_genord iti m'\n                  (\\<lambda>(k, v) (k', v').\n                      R (k, \\<alpha> v) (k', \\<alpha> v'));\n         map_option \\<alpha> \\<circ> m' = m;\n         \\<And>k v. m' k = Some v \\<Longrightarrow> invar v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from \\<alpha>_props(1)"], ["proof (chain)\npicking this:\n  distinct (map (\\<lambda>(k, v). (k, \\<alpha> v)) lc)", "have inj_on_\\<alpha>': \"inj_on ?\\<alpha>' (set lc)\""], ["proof (prove)\nusing this:\n  distinct (map (\\<lambda>(k, v). (k, \\<alpha> v)) lc)\n\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>(k, v). (k, \\<alpha> v)) (set lc)", "by (simp add: distinct_map)"], ["proof (state)\nthis:\n  inj_on (\\<lambda>(k, v). (k, \\<alpha> v)) (set lc)\n\ngoal (1 subgoal):\n 1. (\\<And>m'.\n        \\<lbrakk>map_iterator_genord iti m'\n                  (\\<lambda>(k, v) (k', v').\n                      R (k, \\<alpha> v) (k', \\<alpha> v'));\n         map_option \\<alpha> \\<circ> m' = m;\n         \\<And>k v. m' k = Some v \\<Longrightarrow> invar v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from in_lc inj_on_\\<alpha>'"], ["proof (chain)\npicking this:\n  (?k2, ?v2) \\<in> set lc \\<Longrightarrow> m ?k2 = Some (\\<alpha> ?v2)\n  inj_on (\\<lambda>(k, v). (k, \\<alpha> v)) (set lc)", "have inj_on_fst: \"inj_on fst (set lc)\""], ["proof (prove)\nusing this:\n  (?k2, ?v2) \\<in> set lc \\<Longrightarrow> m ?k2 = Some (\\<alpha> ?v2)\n  inj_on (\\<lambda>(k, v). (k, \\<alpha> v)) (set lc)\n\ngoal (1 subgoal):\n 1. inj_on fst (set lc)", "apply (simp add: inj_on_def Ball_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>k v.\n                (k, v) \\<in> set lc \\<Longrightarrow>\n                m k = Some (\\<alpha> v);\n     \\<forall>a b.\n        (a, b) \\<in> set lc \\<longrightarrow>\n        (\\<forall>ba.\n            (a, ba) \\<in> set lc \\<longrightarrow>\n            \\<alpha> b = \\<alpha> ba \\<longrightarrow> b = ba)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a b.\n                         (a, b) \\<in> set lc \\<longrightarrow>\n                         (\\<forall>ba.\n                             (a, ba) \\<in> set lc \\<longrightarrow> b = ba)", "apply (metis option.inject)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  inj_on fst (set lc)\n\ngoal (1 subgoal):\n 1. (\\<And>m'.\n        \\<lbrakk>map_iterator_genord iti m'\n                  (\\<lambda>(k, v) (k', v').\n                      R (k, \\<alpha> v) (k', \\<alpha> v'));\n         map_option \\<alpha> \\<circ> m' = m;\n         \\<And>k v. m' k = Some v \\<Longrightarrow> invar v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?m' = \"map_of lc\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>m'.\n        \\<lbrakk>map_iterator_genord iti m'\n                  (\\<lambda>(k, v) (k', v').\n                      R (k, \\<alpha> v) (k', \\<alpha> v'));\n         map_option \\<alpha> \\<circ> m' = m;\n         \\<And>k v. m' k = Some v \\<Longrightarrow> invar v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from \\<alpha>_props"], ["proof (chain)\npicking this:\n  distinct (map (\\<lambda>(k, v). (k, \\<alpha> v)) lc)\n  map_to_set m = set (map (\\<lambda>(k, v). (k, \\<alpha> v)) lc)\n  sorted_wrt R (map (\\<lambda>(k, v). (k, \\<alpha> v)) lc)", "have it': \"map_iterator_genord iti ?m' (\\<lambda>x y. R (?\\<alpha>' x) (?\\<alpha>' y))\""], ["proof (prove)\nusing this:\n  distinct (map (\\<lambda>(k, v). (k, \\<alpha> v)) lc)\n  map_to_set m = set (map (\\<lambda>(k, v). (k, \\<alpha> v)) lc)\n  sorted_wrt R (map (\\<lambda>(k, v). (k, \\<alpha> v)) lc)\n\ngoal (1 subgoal):\n 1. map_iterator_genord iti (map_of lc)\n     (\\<lambda>x y.\n         R (case x of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n          (case y of (k, v) \\<Rightarrow> (k, \\<alpha> v)))", "apply (rule_tac set_iterator_genord_I [of lc])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>distinct (map (\\<lambda>(k, v). (k, \\<alpha> v)) lc);\n     map_to_set m = set (map (\\<lambda>(k, v). (k, \\<alpha> v)) lc);\n     sorted_wrt R (map (\\<lambda>(k, v). (k, \\<alpha> v)) lc)\\<rbrakk>\n    \\<Longrightarrow> distinct lc\n 2. \\<lbrakk>distinct (map (\\<lambda>(k, v). (k, \\<alpha> v)) lc);\n     map_to_set m = set (map (\\<lambda>(k, v). (k, \\<alpha> v)) lc);\n     sorted_wrt R (map (\\<lambda>(k, v). (k, \\<alpha> v)) lc)\\<rbrakk>\n    \\<Longrightarrow> map_to_set (map_of lc) = set lc\n 3. \\<lbrakk>distinct (map (\\<lambda>(k, v). (k, \\<alpha> v)) lc);\n     map_to_set m = set (map (\\<lambda>(k, v). (k, \\<alpha> v)) lc);\n     sorted_wrt R (map (\\<lambda>(k, v). (k, \\<alpha> v)) lc)\\<rbrakk>\n    \\<Longrightarrow> sorted_wrt\n                       (\\<lambda>x y.\n                           R (case x of\n                              (k, v) \\<Rightarrow> (k, \\<alpha> v))\n                            (case y of\n                             (k, v) \\<Rightarrow> (k, \\<alpha> v)))\n                       lc\n 4. \\<lbrakk>distinct (map (\\<lambda>(k, v). (k, \\<alpha> v)) lc);\n     map_to_set m = set (map (\\<lambda>(k, v). (k, \\<alpha> v)) lc);\n     sorted_wrt R (map (\\<lambda>(k, v). (k, \\<alpha> v)) lc)\\<rbrakk>\n    \\<Longrightarrow> iti = foldli lc", "apply (simp_all add: distinct_map sorted_wrt_map iti_eq map_to_set_map_of inj_on_fst)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  map_iterator_genord iti (map_of lc)\n   (\\<lambda>x y.\n       R (case x of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n        (case y of (k, v) \\<Rightarrow> (k, \\<alpha> v)))\n\ngoal (1 subgoal):\n 1. (\\<And>m'.\n        \\<lbrakk>map_iterator_genord iti m'\n                  (\\<lambda>(k, v) (k', v').\n                      R (k, \\<alpha> v) (k', \\<alpha> v'));\n         map_option \\<alpha> \\<circ> m' = m;\n         \\<And>k v. m' k = Some v \\<Longrightarrow> invar v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from inj_on_fst \\<alpha>_props(1)"], ["proof (chain)\npicking this:\n  inj_on fst (set lc)\n  distinct (map (\\<lambda>(k, v). (k, \\<alpha> v)) lc)", "have \"distinct (map fst (map ?\\<alpha>' lc))\""], ["proof (prove)\nusing this:\n  inj_on fst (set lc)\n  distinct (map (\\<lambda>(k, v). (k, \\<alpha> v)) lc)\n\ngoal (1 subgoal):\n 1. distinct (map fst (map (\\<lambda>(k, v). (k, \\<alpha> v)) lc))", "by (auto simp add: distinct_map inj_on_def Ball_def)"], ["proof (state)\nthis:\n  distinct (map fst (map (\\<lambda>(k, v). (k, \\<alpha> v)) lc))\n\ngoal (1 subgoal):\n 1. (\\<And>m'.\n        \\<lbrakk>map_iterator_genord iti m'\n                  (\\<lambda>(k, v) (k', v').\n                      R (k, \\<alpha> v) (k', \\<alpha> v'));\n         map_option \\<alpha> \\<circ> m' = m;\n         \\<And>k v. m' k = Some v \\<Longrightarrow> invar v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"map_to_set m = map_to_set (map_of (map ?\\<alpha>' lc))\""], ["proof (prove)\nusing this:\n  distinct (map fst (map (\\<lambda>(k, v). (k, \\<alpha> v)) lc))\n\ngoal (1 subgoal):\n 1. map_to_set m =\n    map_to_set (map_of (map (\\<lambda>(k, v). (k, \\<alpha> v)) lc))", "by (simp add: \\<alpha>_props map_to_set_map_of)"], ["proof (state)\nthis:\n  map_to_set m =\n  map_to_set (map_of (map (\\<lambda>(k, v). (k, \\<alpha> v)) lc))\n\ngoal (1 subgoal):\n 1. (\\<And>m'.\n        \\<lbrakk>map_iterator_genord iti m'\n                  (\\<lambda>(k, v) (k', v').\n                      R (k, \\<alpha> v) (k', \\<alpha> v'));\n         map_option \\<alpha> \\<circ> m' = m;\n         \\<And>k v. m' k = Some v \\<Longrightarrow> invar v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence m_eq: \"map_option \\<alpha> \\<circ> map_of lc = m\""], ["proof (prove)\nusing this:\n  map_to_set m =\n  map_to_set (map_of (map (\\<lambda>(k, v). (k, \\<alpha> v)) lc))\n\ngoal (1 subgoal):\n 1. (map_option \\<alpha> \\<circ>\\<circ> map_of) lc = m", "by (simp add: map_of_map[symmetric] map_to_set_cong)"], ["proof (state)\nthis:\n  (map_option \\<alpha> \\<circ>\\<circ> map_of) lc = m\n\ngoal (1 subgoal):\n 1. (\\<And>m'.\n        \\<lbrakk>map_iterator_genord iti m'\n                  (\\<lambda>(k, v) (k', v').\n                      R (k, \\<alpha> v) (k', \\<alpha> v'));\n         map_option \\<alpha> \\<circ> m' = m;\n         \\<And>k v. m' k = Some v \\<Longrightarrow> invar v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from that[of ?m'] it' lc_invar \\<alpha>_props(1)"], ["proof (chain)\npicking this:\n  \\<lbrakk>map_iterator_genord iti (map_of lc)\n            (\\<lambda>(k, v) (k', v'). R (k, \\<alpha> v) (k', \\<alpha> v'));\n   (map_option \\<alpha> \\<circ>\\<circ> map_of) lc = m;\n   \\<And>k v. map_of lc k = Some v \\<Longrightarrow> invar v\\<rbrakk>\n  \\<Longrightarrow> thesis\n  map_iterator_genord iti (map_of lc)\n   (\\<lambda>x y.\n       R (case x of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n        (case y of (k, v) \\<Rightarrow> (k, \\<alpha> v)))\n  (?k2, ?v2) \\<in> set lc \\<Longrightarrow> invar ?v2\n  distinct (map (\\<lambda>(k, v). (k, \\<alpha> v)) lc)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>map_iterator_genord iti (map_of lc)\n            (\\<lambda>(k, v) (k', v'). R (k, \\<alpha> v) (k', \\<alpha> v'));\n   (map_option \\<alpha> \\<circ>\\<circ> map_of) lc = m;\n   \\<And>k v. map_of lc k = Some v \\<Longrightarrow> invar v\\<rbrakk>\n  \\<Longrightarrow> thesis\n  map_iterator_genord iti (map_of lc)\n   (\\<lambda>x y.\n       R (case x of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n        (case y of (k, v) \\<Rightarrow> (k, \\<alpha> v)))\n  (?k2, ?v2) \\<in> set lc \\<Longrightarrow> invar ?v2\n  distinct (map (\\<lambda>(k, v). (k, \\<alpha> v)) lc)\n\ngoal (1 subgoal):\n 1. thesis", "by (simp add: distinct_map split_def inj_on_fst ran_distinct m_eq)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_iterator_abs_genord_rule_P:\n  assumes iti_OK: \"map_iterator_abs_genord \\<alpha> invar iti m R\"\n      and I0: \"I (dom m) \\<sigma>0\"\n      and IP: \"!!k v it \\<sigma>. \\<lbrakk> c \\<sigma>; k \\<in> it; invar v; m k = Some (\\<alpha> v); it \\<subseteq> dom m; I it \\<sigma>; \n                             \\<forall>k' v'. k' \\<in> it-{k} \\<and> invar v' \\<and> m k' = Some (\\<alpha> v') \\<longrightarrow> R (k, \\<alpha> v) (k', \\<alpha> v');\n                             \\<forall>k' v'. k' \\<notin> it \\<and> invar v' \\<and> m k' = Some (\\<alpha> v') \\<longrightarrow> R (k', \\<alpha> v') (k, \\<alpha> v)\\<rbrakk> \\<Longrightarrow> \n                            I (it - {k}) (f (k, v) \\<sigma>)\"\n      and IF: \"!!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n      and II: \"!!\\<sigma> it. \\<lbrakk> it \\<subseteq> dom m; it \\<noteq> {}; \\<not> c \\<sigma>; I it \\<sigma>;\n                         \\<forall>k v k' v'. k \\<notin> it \\<and> invar v \\<and> m k = Some (\\<alpha> v) \\<and> \n                                     k' \\<in> it \\<and> invar v' \\<and> m k' = Some (\\<alpha> v') \\<longrightarrow> \n                                     R (k, \\<alpha> v) (k', \\<alpha> v') \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n  shows \"P (iti c f \\<sigma>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (iti c f \\<sigma>0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P (iti c f \\<sigma>0)", "let ?\\<alpha>' = \"\\<lambda>(k,v). (k, \\<alpha> v)\""], ["proof (state)\ngoal (1 subgoal):\n 1. P (iti c f \\<sigma>0)", "let ?invar' = \"\\<lambda>(k,v). invar v\""], ["proof (state)\ngoal (1 subgoal):\n 1. P (iti c f \\<sigma>0)", "from map_iterator_abs_genord_remove_abs2 [OF iti_OK]"], ["proof (chain)\npicking this:\n  (\\<And>m'.\n      \\<lbrakk>map_iterator_genord iti m'\n                (\\<lambda>(k, v) (k', v').\n                    R (k, \\<alpha> v) (k', \\<alpha> v'));\n       map_option \\<alpha> \\<circ> m' = m;\n       \\<And>k v. m' k = Some v \\<Longrightarrow> invar v\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain m' where m'_props: \"map_iterator_genord iti m' (\\<lambda>x y. R (?\\<alpha>' x) (?\\<alpha>' y))\"\n     \"m = map_option \\<alpha> \\<circ> m'\" \"\\<And>k v. m' k = Some v \\<Longrightarrow> invar v\""], ["proof (prove)\nusing this:\n  (\\<And>m'.\n      \\<lbrakk>map_iterator_genord iti m'\n                (\\<lambda>(k, v) (k', v').\n                    R (k, \\<alpha> v) (k', \\<alpha> v'));\n       map_option \\<alpha> \\<circ> m' = m;\n       \\<And>k v. m' k = Some v \\<Longrightarrow> invar v\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>m'.\n        \\<lbrakk>map_iterator_genord iti m'\n                  (\\<lambda>x y.\n                      R (case x of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n                       (case y of (k, v) \\<Rightarrow> (k, \\<alpha> v)));\n         m = map_option \\<alpha> \\<circ> m';\n         \\<And>k v. m' k = Some v \\<Longrightarrow> invar v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: split_def)"], ["proof (state)\nthis:\n  map_iterator_genord iti m'\n   (\\<lambda>x y.\n       R (case x of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n        (case y of (k, v) \\<Rightarrow> (k, \\<alpha> v)))\n  m = map_option \\<alpha> \\<circ> m'\n  m' ?k2 = Some ?v2 \\<Longrightarrow> invar ?v2\n\ngoal (1 subgoal):\n 1. P (iti c f \\<sigma>0)", "have dom_m'_eq: \"dom m' = dom m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom m' = dom m", "unfolding m'_props"], ["proof (prove)\ngoal (1 subgoal):\n 1. dom m' = dom (map_option \\<alpha> \\<circ> m')", "by (simp add: dom_def)"], ["proof (state)\nthis:\n  dom m' = dom m\n\ngoal (1 subgoal):\n 1. P (iti c f \\<sigma>0)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. P (iti c f \\<sigma>0)", "proof (rule map_iterator_genord_rule_P[OF m'_props(1), of I], goal_cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. I (dom m') \\<sigma>0\n 2. \\<And>k v it \\<sigma>.\n       \\<lbrakk>c \\<sigma>; k \\<in> it; m' k = Some v;\n        it \\<subseteq> dom m'; I it \\<sigma>;\n        \\<forall>k' v'.\n           k' \\<in> it - {k} \\<and> m' k' = Some v' \\<longrightarrow>\n           R (case (k, v) of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n            (case (k', v') of (k, v) \\<Rightarrow> (k, \\<alpha> v));\n        \\<forall>k' v'.\n           k' \\<notin> it \\<and> m' k' = Some v' \\<longrightarrow>\n           R (case (k', v') of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n            (case (k, v) of (k, v) \\<Rightarrow> (k, \\<alpha> v))\\<rbrakk>\n       \\<Longrightarrow> I (it - {k}) (f (k, v) \\<sigma>)\n 3. \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\n 4. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom m'; it \\<noteq> {}; \\<not> c \\<sigma>;\n        I it \\<sigma>;\n        \\<forall>k v k' v'.\n           k \\<notin> it \\<and>\n           m' k = Some v \\<and>\n           k' \\<in> it \\<and> m' k' = Some v' \\<longrightarrow>\n           R (case (k, v) of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n            (case (k', v') of (k, v) \\<Rightarrow> (k, \\<alpha> v))\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. I (dom m') \\<sigma>0\n 2. \\<And>k v it \\<sigma>.\n       \\<lbrakk>c \\<sigma>; k \\<in> it; m' k = Some v;\n        it \\<subseteq> dom m'; I it \\<sigma>;\n        \\<forall>k' v'.\n           k' \\<in> it - {k} \\<and> m' k' = Some v' \\<longrightarrow>\n           R (case (k, v) of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n            (case (k', v') of (k, v) \\<Rightarrow> (k, \\<alpha> v));\n        \\<forall>k' v'.\n           k' \\<notin> it \\<and> m' k' = Some v' \\<longrightarrow>\n           R (case (k', v') of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n            (case (k, v) of (k, v) \\<Rightarrow> (k, \\<alpha> v))\\<rbrakk>\n       \\<Longrightarrow> I (it - {k}) (f (k, v) \\<sigma>)\n 3. \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\n 4. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom m'; it \\<noteq> {}; \\<not> c \\<sigma>;\n        I it \\<sigma>;\n        \\<forall>k v k' v'.\n           k \\<notin> it \\<and>\n           m' k = Some v \\<and>\n           k' \\<in> it \\<and> m' k' = Some v' \\<longrightarrow>\n           R (case (k, v) of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n            (case (k', v') of (k, v) \\<Rightarrow> (k, \\<alpha> v))\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. I (dom m') \\<sigma>0", "using I0"], ["proof (prove)\nusing this:\n  I (dom m) \\<sigma>0\n\ngoal (1 subgoal):\n 1. I (dom m') \\<sigma>0", "by (simp add: dom_m'_eq)"], ["proof (state)\nthis:\n  I (dom m') \\<sigma>0\n\ngoal (3 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>c \\<sigma>; k \\<in> it; m' k = Some v;\n        it \\<subseteq> dom m'; I it \\<sigma>;\n        \\<forall>k' v'.\n           k' \\<in> it - {k} \\<and> m' k' = Some v' \\<longrightarrow>\n           R (case (k, v) of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n            (case (k', v') of (k, v) \\<Rightarrow> (k, \\<alpha> v));\n        \\<forall>k' v'.\n           k' \\<notin> it \\<and> m' k' = Some v' \\<longrightarrow>\n           R (case (k', v') of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n            (case (k, v) of (k, v) \\<Rightarrow> (k, \\<alpha> v))\\<rbrakk>\n       \\<Longrightarrow> I (it - {k}) (f (k, v) \\<sigma>)\n 2. \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\n 3. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom m'; it \\<noteq> {}; \\<not> c \\<sigma>;\n        I it \\<sigma>;\n        \\<forall>k v k' v'.\n           k \\<notin> it \\<and>\n           m' k = Some v \\<and>\n           k' \\<in> it \\<and> m' k' = Some v' \\<longrightarrow>\n           R (case (k, v) of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n            (case (k', v') of (k, v) \\<Rightarrow> (k, \\<alpha> v))\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>c \\<sigma>; k \\<in> it; m' k = Some v;\n        it \\<subseteq> dom m'; I it \\<sigma>;\n        \\<forall>k' v'.\n           k' \\<in> it - {k} \\<and> m' k' = Some v' \\<longrightarrow>\n           R (case (k, v) of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n            (case (k', v') of (k, v) \\<Rightarrow> (k, \\<alpha> v));\n        \\<forall>k' v'.\n           k' \\<notin> it \\<and> m' k' = Some v' \\<longrightarrow>\n           R (case (k', v') of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n            (case (k, v) of (k, v) \\<Rightarrow> (k, \\<alpha> v))\\<rbrakk>\n       \\<Longrightarrow> I (it - {k}) (f (k, v) \\<sigma>)\n 2. \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\n 3. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom m'; it \\<noteq> {}; \\<not> c \\<sigma>;\n        I it \\<sigma>;\n        \\<forall>k v k' v'.\n           k \\<notin> it \\<and>\n           m' k = Some v \\<and>\n           k' \\<in> it \\<and> m' k' = Some v' \\<longrightarrow>\n           R (case (k, v) of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n            (case (k', v') of (k, v) \\<Rightarrow> (k, \\<alpha> v))\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "case 3"], ["proof (state)\nthis:\n  I {} \\<sigma>_\n\ngoal (3 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>c \\<sigma>; k \\<in> it; m' k = Some v;\n        it \\<subseteq> dom m'; I it \\<sigma>;\n        \\<forall>k' v'.\n           k' \\<in> it - {k} \\<and> m' k' = Some v' \\<longrightarrow>\n           R (case (k, v) of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n            (case (k', v') of (k, v) \\<Rightarrow> (k, \\<alpha> v));\n        \\<forall>k' v'.\n           k' \\<notin> it \\<and> m' k' = Some v' \\<longrightarrow>\n           R (case (k', v') of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n            (case (k, v) of (k, v) \\<Rightarrow> (k, \\<alpha> v))\\<rbrakk>\n       \\<Longrightarrow> I (it - {k}) (f (k, v) \\<sigma>)\n 2. \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\n 3. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom m'; it \\<noteq> {}; \\<not> c \\<sigma>;\n        I it \\<sigma>;\n        \\<forall>k v k' v'.\n           k \\<notin> it \\<and>\n           m' k = Some v \\<and>\n           k' \\<in> it \\<and> m' k' = Some v' \\<longrightarrow>\n           R (case (k, v) of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n            (case (k', v') of (k, v) \\<Rightarrow> (k, \\<alpha> v))\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "thus ?case"], ["proof (prove)\nusing this:\n  I {} \\<sigma>_\n\ngoal (1 subgoal):\n 1. P \\<sigma>_", "using IF"], ["proof (prove)\nusing this:\n  I {} \\<sigma>_\n  I {} ?\\<sigma> \\<Longrightarrow> P ?\\<sigma>\n\ngoal (1 subgoal):\n 1. P \\<sigma>_", "by simp"], ["proof (state)\nthis:\n  P \\<sigma>_\n\ngoal (2 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>c \\<sigma>; k \\<in> it; m' k = Some v;\n        it \\<subseteq> dom m'; I it \\<sigma>;\n        \\<forall>k' v'.\n           k' \\<in> it - {k} \\<and> m' k' = Some v' \\<longrightarrow>\n           R (case (k, v) of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n            (case (k', v') of (k, v) \\<Rightarrow> (k, \\<alpha> v));\n        \\<forall>k' v'.\n           k' \\<notin> it \\<and> m' k' = Some v' \\<longrightarrow>\n           R (case (k', v') of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n            (case (k, v) of (k, v) \\<Rightarrow> (k, \\<alpha> v))\\<rbrakk>\n       \\<Longrightarrow> I (it - {k}) (f (k, v) \\<sigma>)\n 2. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom m'; it \\<noteq> {}; \\<not> c \\<sigma>;\n        I it \\<sigma>;\n        \\<forall>k v k' v'.\n           k \\<notin> it \\<and>\n           m' k = Some v \\<and>\n           k' \\<in> it \\<and> m' k' = Some v' \\<longrightarrow>\n           R (case (k, v) of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n            (case (k', v') of (k, v) \\<Rightarrow> (k, \\<alpha> v))\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>c \\<sigma>; k \\<in> it; m' k = Some v;\n        it \\<subseteq> dom m'; I it \\<sigma>;\n        \\<forall>k' v'.\n           k' \\<in> it - {k} \\<and> m' k' = Some v' \\<longrightarrow>\n           R (case (k, v) of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n            (case (k', v') of (k, v) \\<Rightarrow> (k, \\<alpha> v));\n        \\<forall>k' v'.\n           k' \\<notin> it \\<and> m' k' = Some v' \\<longrightarrow>\n           R (case (k', v') of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n            (case (k, v) of (k, v) \\<Rightarrow> (k, \\<alpha> v))\\<rbrakk>\n       \\<Longrightarrow> I (it - {k}) (f (k, v) \\<sigma>)\n 2. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom m'; it \\<noteq> {}; \\<not> c \\<sigma>;\n        I it \\<sigma>;\n        \\<forall>k v k' v'.\n           k \\<notin> it \\<and>\n           m' k = Some v \\<and>\n           k' \\<in> it \\<and> m' k' = Some v' \\<longrightarrow>\n           R (case (k, v) of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n            (case (k', v') of (k, v) \\<Rightarrow> (k, \\<alpha> v))\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "case prems: (2 k v S \\<sigma>)"], ["proof (state)\nthis:\n  c \\<sigma>\n  k \\<in> S\n  m' k = Some v\n  S \\<subseteq> dom m'\n  I S \\<sigma>\n  \\<forall>k' v'.\n     k' \\<in> S - {k} \\<and> m' k' = Some v' \\<longrightarrow>\n     R (case (k, v) of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n      (case (k', v') of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n  \\<forall>k' v'.\n     k' \\<notin> S \\<and> m' k' = Some v' \\<longrightarrow>\n     R (case (k', v') of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n      (case (k, v) of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n\ngoal (2 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>c \\<sigma>; k \\<in> it; m' k = Some v;\n        it \\<subseteq> dom m'; I it \\<sigma>;\n        \\<forall>k' v'.\n           k' \\<in> it - {k} \\<and> m' k' = Some v' \\<longrightarrow>\n           R (case (k, v) of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n            (case (k', v') of (k, v) \\<Rightarrow> (k, \\<alpha> v));\n        \\<forall>k' v'.\n           k' \\<notin> it \\<and> m' k' = Some v' \\<longrightarrow>\n           R (case (k', v') of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n            (case (k, v) of (k, v) \\<Rightarrow> (k, \\<alpha> v))\\<rbrakk>\n       \\<Longrightarrow> I (it - {k}) (f (k, v) \\<sigma>)\n 2. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom m'; it \\<noteq> {}; \\<not> c \\<sigma>;\n        I it \\<sigma>;\n        \\<forall>k v k' v'.\n           k \\<notin> it \\<and>\n           m' k = Some v \\<and>\n           k' \\<in> it \\<and> m' k' = Some v' \\<longrightarrow>\n           R (case (k, v) of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n            (case (k', v') of (k, v) \\<Rightarrow> (k, \\<alpha> v))\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "from IP [of \\<sigma> k S v] prems"], ["proof (chain)\npicking this:\n  \\<lbrakk>c \\<sigma>; k \\<in> S; invar v; m k = Some (\\<alpha> v);\n   S \\<subseteq> dom m; I S \\<sigma>;\n   \\<forall>k' v'.\n      k' \\<in> S - {k} \\<and>\n      invar v' \\<and> m k' = Some (\\<alpha> v') \\<longrightarrow>\n      R (k, \\<alpha> v) (k', \\<alpha> v');\n   \\<forall>k' v'.\n      k' \\<notin> S \\<and>\n      invar v' \\<and> m k' = Some (\\<alpha> v') \\<longrightarrow>\n      R (k', \\<alpha> v') (k, \\<alpha> v)\\<rbrakk>\n  \\<Longrightarrow> I (S - {k}) (f (k, v) \\<sigma>)\n  c \\<sigma>\n  k \\<in> S\n  m' k = Some v\n  S \\<subseteq> dom m'\n  I S \\<sigma>\n  \\<forall>k' v'.\n     k' \\<in> S - {k} \\<and> m' k' = Some v' \\<longrightarrow>\n     R (case (k, v) of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n      (case (k', v') of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n  \\<forall>k' v'.\n     k' \\<notin> S \\<and> m' k' = Some v' \\<longrightarrow>\n     R (case (k', v') of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n      (case (k, v) of (k, v) \\<Rightarrow> (k, \\<alpha> v))", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>c \\<sigma>; k \\<in> S; invar v; m k = Some (\\<alpha> v);\n   S \\<subseteq> dom m; I S \\<sigma>;\n   \\<forall>k' v'.\n      k' \\<in> S - {k} \\<and>\n      invar v' \\<and> m k' = Some (\\<alpha> v') \\<longrightarrow>\n      R (k, \\<alpha> v) (k', \\<alpha> v');\n   \\<forall>k' v'.\n      k' \\<notin> S \\<and>\n      invar v' \\<and> m k' = Some (\\<alpha> v') \\<longrightarrow>\n      R (k', \\<alpha> v') (k, \\<alpha> v)\\<rbrakk>\n  \\<Longrightarrow> I (S - {k}) (f (k, v) \\<sigma>)\n  c \\<sigma>\n  k \\<in> S\n  m' k = Some v\n  S \\<subseteq> dom m'\n  I S \\<sigma>\n  \\<forall>k' v'.\n     k' \\<in> S - {k} \\<and> m' k' = Some v' \\<longrightarrow>\n     R (case (k, v) of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n      (case (k', v') of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n  \\<forall>k' v'.\n     k' \\<notin> S \\<and> m' k' = Some v' \\<longrightarrow>\n     R (case (k', v') of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n      (case (k, v) of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n\ngoal (1 subgoal):\n 1. I (S - {k}) (f (k, v) \\<sigma>)", "by (simp add: m'_props) metis"], ["proof (state)\nthis:\n  I (S - {k}) (f (k, v) \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom m'; it \\<noteq> {}; \\<not> c \\<sigma>;\n        I it \\<sigma>;\n        \\<forall>k v k' v'.\n           k \\<notin> it \\<and>\n           m' k = Some v \\<and>\n           k' \\<in> it \\<and> m' k' = Some v' \\<longrightarrow>\n           R (case (k, v) of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n            (case (k', v') of (k, v) \\<Rightarrow> (k, \\<alpha> v))\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom m'; it \\<noteq> {}; \\<not> c \\<sigma>;\n        I it \\<sigma>;\n        \\<forall>k v k' v'.\n           k \\<notin> it \\<and>\n           m' k = Some v \\<and>\n           k' \\<in> it \\<and> m' k' = Some v' \\<longrightarrow>\n           R (case (k, v) of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n            (case (k', v') of (k, v) \\<Rightarrow> (k, \\<alpha> v))\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "case prems: (4 \\<sigma> S)"], ["proof (state)\nthis:\n  S \\<subseteq> dom m'\n  S \\<noteq> {}\n  \\<not> c \\<sigma>\n  I S \\<sigma>\n  \\<forall>k v k' v'.\n     k \\<notin> S \\<and>\n     m' k = Some v \\<and>\n     k' \\<in> S \\<and> m' k' = Some v' \\<longrightarrow>\n     R (case (k, v) of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n      (case (k', v') of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom m'; it \\<noteq> {}; \\<not> c \\<sigma>;\n        I it \\<sigma>;\n        \\<forall>k v k' v'.\n           k \\<notin> it \\<and>\n           m' k = Some v \\<and>\n           k' \\<in> it \\<and> m' k' = Some v' \\<longrightarrow>\n           R (case (k, v) of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n            (case (k', v') of (k, v) \\<Rightarrow> (k, \\<alpha> v))\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<sigma>", "using II[of S \\<sigma>] prems"], ["proof (prove)\nusing this:\n  \\<lbrakk>S \\<subseteq> dom m; S \\<noteq> {}; \\<not> c \\<sigma>;\n   I S \\<sigma>;\n   \\<forall>k v k' v'.\n      k \\<notin> S \\<and>\n      invar v \\<and>\n      m k = Some (\\<alpha> v) \\<and>\n      k' \\<in> S \\<and>\n      invar v' \\<and> m k' = Some (\\<alpha> v') \\<longrightarrow>\n      R (k, \\<alpha> v) (k', \\<alpha> v')\\<rbrakk>\n  \\<Longrightarrow> P \\<sigma>\n  S \\<subseteq> dom m'\n  S \\<noteq> {}\n  \\<not> c \\<sigma>\n  I S \\<sigma>\n  \\<forall>k v k' v'.\n     k \\<notin> S \\<and>\n     m' k = Some v \\<and>\n     k' \\<in> S \\<and> m' k' = Some v' \\<longrightarrow>\n     R (case (k, v) of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n      (case (k', v') of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n\ngoal (1 subgoal):\n 1. P \\<sigma>", "by (simp add: m'_props) metis"], ["proof (state)\nthis:\n  P \\<sigma>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P (iti c f \\<sigma>0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_iterator_abs_genord_rule_insert_P:\n  assumes iti_OK: \"map_iterator_abs_genord \\<alpha> invar iti m R\"\n      and I0: \"I {} \\<sigma>0\"\n      and IP: \"!!k v it \\<sigma>. \\<lbrakk> c \\<sigma>; k \\<in> dom m - it; invar v; m k = Some (\\<alpha> v); it \\<subseteq> dom m; I it \\<sigma>; \n                             \\<forall>k' v'. k' \\<in> (dom m - it)-{k} \\<and> invar v' \\<and> m k' = Some (\\<alpha> v') \\<longrightarrow> R (k, \\<alpha> v) (k', \\<alpha> v');\n                             \\<forall>k' v'. k' \\<in> it \\<and> invar v' \\<and> m k' = Some (\\<alpha> v') \\<longrightarrow> R (k', \\<alpha> v') (k, \\<alpha> v)\\<rbrakk> \\<Longrightarrow> \n                            I (insert k it) (f (k, v) \\<sigma>)\"\n      and IF: \"!!\\<sigma>. I (dom m) \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n      and II: \"!!\\<sigma> it. \\<lbrakk> it \\<subseteq> dom m; it \\<noteq> dom m; \\<not> c \\<sigma>; I it \\<sigma>;\n                         \\<forall>k v k' v'. k \\<in> it \\<and> invar v \\<and> m k = Some (\\<alpha> v) \\<and> \n                                     k' \\<notin> it \\<and> invar v' \\<and> m k' = Some (\\<alpha> v') \\<longrightarrow> \n                                     R (k, \\<alpha> v) (k', \\<alpha> v') \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n  shows \"P (iti c f \\<sigma>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (iti c f \\<sigma>0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P (iti c f \\<sigma>0)", "let ?\\<alpha>' = \"\\<lambda>(k,v). (k, \\<alpha> v)\""], ["proof (state)\ngoal (1 subgoal):\n 1. P (iti c f \\<sigma>0)", "let ?invar' = \"\\<lambda>(k,v). invar v\""], ["proof (state)\ngoal (1 subgoal):\n 1. P (iti c f \\<sigma>0)", "from map_iterator_abs_genord_remove_abs2 [OF iti_OK]"], ["proof (chain)\npicking this:\n  (\\<And>m'.\n      \\<lbrakk>map_iterator_genord iti m'\n                (\\<lambda>(k, v) (k', v').\n                    R (k, \\<alpha> v) (k', \\<alpha> v'));\n       map_option \\<alpha> \\<circ> m' = m;\n       \\<And>k v. m' k = Some v \\<Longrightarrow> invar v\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain m' where m'_props: \"map_iterator_genord iti m' (\\<lambda>x y. R (?\\<alpha>' x) (?\\<alpha>' y))\"\n     \"m = map_option \\<alpha> \\<circ> m'\" \"\\<And>k v. m' k = Some v \\<Longrightarrow> invar v\""], ["proof (prove)\nusing this:\n  (\\<And>m'.\n      \\<lbrakk>map_iterator_genord iti m'\n                (\\<lambda>(k, v) (k', v').\n                    R (k, \\<alpha> v) (k', \\<alpha> v'));\n       map_option \\<alpha> \\<circ> m' = m;\n       \\<And>k v. m' k = Some v \\<Longrightarrow> invar v\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>m'.\n        \\<lbrakk>map_iterator_genord iti m'\n                  (\\<lambda>x y.\n                      R (case x of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n                       (case y of (k, v) \\<Rightarrow> (k, \\<alpha> v)));\n         m = map_option \\<alpha> \\<circ> m';\n         \\<And>k v. m' k = Some v \\<Longrightarrow> invar v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: split_def)"], ["proof (state)\nthis:\n  map_iterator_genord iti m'\n   (\\<lambda>x y.\n       R (case x of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n        (case y of (k, v) \\<Rightarrow> (k, \\<alpha> v)))\n  m = map_option \\<alpha> \\<circ> m'\n  m' ?k2 = Some ?v2 \\<Longrightarrow> invar ?v2\n\ngoal (1 subgoal):\n 1. P (iti c f \\<sigma>0)", "have dom_m'_eq: \"dom m' = dom m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom m' = dom m", "unfolding m'_props"], ["proof (prove)\ngoal (1 subgoal):\n 1. dom m' = dom (map_option \\<alpha> \\<circ> m')", "by (simp add: dom_def)"], ["proof (state)\nthis:\n  dom m' = dom m\n\ngoal (1 subgoal):\n 1. P (iti c f \\<sigma>0)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. P (iti c f \\<sigma>0)", "proof (rule map_iterator_genord_rule_insert_P[OF m'_props(1), of I], goal_cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. I {} \\<sigma>0\n 2. \\<And>k v it \\<sigma>.\n       \\<lbrakk>c \\<sigma>; k \\<in> dom m' - it; m' k = Some v;\n        it \\<subseteq> dom m'; I it \\<sigma>;\n        \\<forall>k' v'.\n           k' \\<in> dom m' - it - {k} \\<and>\n           m' k' = Some v' \\<longrightarrow>\n           R (case (k, v) of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n            (case (k', v') of (k, v) \\<Rightarrow> (k, \\<alpha> v));\n        \\<forall>k' v'.\n           k' \\<in> it \\<and> m' k' = Some v' \\<longrightarrow>\n           R (case (k', v') of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n            (case (k, v) of (k, v) \\<Rightarrow> (k, \\<alpha> v))\\<rbrakk>\n       \\<Longrightarrow> I (insert k it) (f (k, v) \\<sigma>)\n 3. \\<And>\\<sigma>. I (dom m') \\<sigma> \\<Longrightarrow> P \\<sigma>\n 4. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom m'; it \\<noteq> dom m';\n        \\<not> c \\<sigma>; I it \\<sigma>;\n        \\<forall>k v k' v'.\n           k \\<in> it \\<and>\n           m' k = Some v \\<and>\n           k' \\<notin> it \\<and> m' k' = Some v' \\<longrightarrow>\n           R (case (k, v) of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n            (case (k', v') of (k, v) \\<Rightarrow> (k, \\<alpha> v))\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. I {} \\<sigma>0\n 2. \\<And>k v it \\<sigma>.\n       \\<lbrakk>c \\<sigma>; k \\<in> dom m' - it; m' k = Some v;\n        it \\<subseteq> dom m'; I it \\<sigma>;\n        \\<forall>k' v'.\n           k' \\<in> dom m' - it - {k} \\<and>\n           m' k' = Some v' \\<longrightarrow>\n           R (case (k, v) of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n            (case (k', v') of (k, v) \\<Rightarrow> (k, \\<alpha> v));\n        \\<forall>k' v'.\n           k' \\<in> it \\<and> m' k' = Some v' \\<longrightarrow>\n           R (case (k', v') of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n            (case (k, v) of (k, v) \\<Rightarrow> (k, \\<alpha> v))\\<rbrakk>\n       \\<Longrightarrow> I (insert k it) (f (k, v) \\<sigma>)\n 3. \\<And>\\<sigma>. I (dom m') \\<sigma> \\<Longrightarrow> P \\<sigma>\n 4. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom m'; it \\<noteq> dom m';\n        \\<not> c \\<sigma>; I it \\<sigma>;\n        \\<forall>k v k' v'.\n           k \\<in> it \\<and>\n           m' k = Some v \\<and>\n           k' \\<notin> it \\<and> m' k' = Some v' \\<longrightarrow>\n           R (case (k, v) of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n            (case (k', v') of (k, v) \\<Rightarrow> (k, \\<alpha> v))\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. I {} \\<sigma>0", "using I0"], ["proof (prove)\nusing this:\n  I {} \\<sigma>0\n\ngoal (1 subgoal):\n 1. I {} \\<sigma>0", "by simp"], ["proof (state)\nthis:\n  I {} \\<sigma>0\n\ngoal (3 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>c \\<sigma>; k \\<in> dom m' - it; m' k = Some v;\n        it \\<subseteq> dom m'; I it \\<sigma>;\n        \\<forall>k' v'.\n           k' \\<in> dom m' - it - {k} \\<and>\n           m' k' = Some v' \\<longrightarrow>\n           R (case (k, v) of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n            (case (k', v') of (k, v) \\<Rightarrow> (k, \\<alpha> v));\n        \\<forall>k' v'.\n           k' \\<in> it \\<and> m' k' = Some v' \\<longrightarrow>\n           R (case (k', v') of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n            (case (k, v) of (k, v) \\<Rightarrow> (k, \\<alpha> v))\\<rbrakk>\n       \\<Longrightarrow> I (insert k it) (f (k, v) \\<sigma>)\n 2. \\<And>\\<sigma>. I (dom m') \\<sigma> \\<Longrightarrow> P \\<sigma>\n 3. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom m'; it \\<noteq> dom m';\n        \\<not> c \\<sigma>; I it \\<sigma>;\n        \\<forall>k v k' v'.\n           k \\<in> it \\<and>\n           m' k = Some v \\<and>\n           k' \\<notin> it \\<and> m' k' = Some v' \\<longrightarrow>\n           R (case (k, v) of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n            (case (k', v') of (k, v) \\<Rightarrow> (k, \\<alpha> v))\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>c \\<sigma>; k \\<in> dom m' - it; m' k = Some v;\n        it \\<subseteq> dom m'; I it \\<sigma>;\n        \\<forall>k' v'.\n           k' \\<in> dom m' - it - {k} \\<and>\n           m' k' = Some v' \\<longrightarrow>\n           R (case (k, v) of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n            (case (k', v') of (k, v) \\<Rightarrow> (k, \\<alpha> v));\n        \\<forall>k' v'.\n           k' \\<in> it \\<and> m' k' = Some v' \\<longrightarrow>\n           R (case (k', v') of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n            (case (k, v) of (k, v) \\<Rightarrow> (k, \\<alpha> v))\\<rbrakk>\n       \\<Longrightarrow> I (insert k it) (f (k, v) \\<sigma>)\n 2. \\<And>\\<sigma>. I (dom m') \\<sigma> \\<Longrightarrow> P \\<sigma>\n 3. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom m'; it \\<noteq> dom m';\n        \\<not> c \\<sigma>; I it \\<sigma>;\n        \\<forall>k v k' v'.\n           k \\<in> it \\<and>\n           m' k = Some v \\<and>\n           k' \\<notin> it \\<and> m' k' = Some v' \\<longrightarrow>\n           R (case (k, v) of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n            (case (k', v') of (k, v) \\<Rightarrow> (k, \\<alpha> v))\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "case 3"], ["proof (state)\nthis:\n  I (dom m') \\<sigma>_\n\ngoal (3 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>c \\<sigma>; k \\<in> dom m' - it; m' k = Some v;\n        it \\<subseteq> dom m'; I it \\<sigma>;\n        \\<forall>k' v'.\n           k' \\<in> dom m' - it - {k} \\<and>\n           m' k' = Some v' \\<longrightarrow>\n           R (case (k, v) of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n            (case (k', v') of (k, v) \\<Rightarrow> (k, \\<alpha> v));\n        \\<forall>k' v'.\n           k' \\<in> it \\<and> m' k' = Some v' \\<longrightarrow>\n           R (case (k', v') of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n            (case (k, v) of (k, v) \\<Rightarrow> (k, \\<alpha> v))\\<rbrakk>\n       \\<Longrightarrow> I (insert k it) (f (k, v) \\<sigma>)\n 2. \\<And>\\<sigma>. I (dom m') \\<sigma> \\<Longrightarrow> P \\<sigma>\n 3. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom m'; it \\<noteq> dom m';\n        \\<not> c \\<sigma>; I it \\<sigma>;\n        \\<forall>k v k' v'.\n           k \\<in> it \\<and>\n           m' k = Some v \\<and>\n           k' \\<notin> it \\<and> m' k' = Some v' \\<longrightarrow>\n           R (case (k, v) of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n            (case (k', v') of (k, v) \\<Rightarrow> (k, \\<alpha> v))\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "thus ?case"], ["proof (prove)\nusing this:\n  I (dom m') \\<sigma>_\n\ngoal (1 subgoal):\n 1. P \\<sigma>_", "using IF"], ["proof (prove)\nusing this:\n  I (dom m') \\<sigma>_\n  I (dom m) ?\\<sigma> \\<Longrightarrow> P ?\\<sigma>\n\ngoal (1 subgoal):\n 1. P \\<sigma>_", "by (simp add: dom_m'_eq)"], ["proof (state)\nthis:\n  P \\<sigma>_\n\ngoal (2 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>c \\<sigma>; k \\<in> dom m' - it; m' k = Some v;\n        it \\<subseteq> dom m'; I it \\<sigma>;\n        \\<forall>k' v'.\n           k' \\<in> dom m' - it - {k} \\<and>\n           m' k' = Some v' \\<longrightarrow>\n           R (case (k, v) of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n            (case (k', v') of (k, v) \\<Rightarrow> (k, \\<alpha> v));\n        \\<forall>k' v'.\n           k' \\<in> it \\<and> m' k' = Some v' \\<longrightarrow>\n           R (case (k', v') of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n            (case (k, v) of (k, v) \\<Rightarrow> (k, \\<alpha> v))\\<rbrakk>\n       \\<Longrightarrow> I (insert k it) (f (k, v) \\<sigma>)\n 2. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom m'; it \\<noteq> dom m';\n        \\<not> c \\<sigma>; I it \\<sigma>;\n        \\<forall>k v k' v'.\n           k \\<in> it \\<and>\n           m' k = Some v \\<and>\n           k' \\<notin> it \\<and> m' k' = Some v' \\<longrightarrow>\n           R (case (k, v) of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n            (case (k', v') of (k, v) \\<Rightarrow> (k, \\<alpha> v))\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>c \\<sigma>; k \\<in> dom m' - it; m' k = Some v;\n        it \\<subseteq> dom m'; I it \\<sigma>;\n        \\<forall>k' v'.\n           k' \\<in> dom m' - it - {k} \\<and>\n           m' k' = Some v' \\<longrightarrow>\n           R (case (k, v) of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n            (case (k', v') of (k, v) \\<Rightarrow> (k, \\<alpha> v));\n        \\<forall>k' v'.\n           k' \\<in> it \\<and> m' k' = Some v' \\<longrightarrow>\n           R (case (k', v') of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n            (case (k, v) of (k, v) \\<Rightarrow> (k, \\<alpha> v))\\<rbrakk>\n       \\<Longrightarrow> I (insert k it) (f (k, v) \\<sigma>)\n 2. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom m'; it \\<noteq> dom m';\n        \\<not> c \\<sigma>; I it \\<sigma>;\n        \\<forall>k v k' v'.\n           k \\<in> it \\<and>\n           m' k = Some v \\<and>\n           k' \\<notin> it \\<and> m' k' = Some v' \\<longrightarrow>\n           R (case (k, v) of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n            (case (k', v') of (k, v) \\<Rightarrow> (k, \\<alpha> v))\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "case prems: (2 k v S \\<sigma>)"], ["proof (state)\nthis:\n  c \\<sigma>\n  k \\<in> dom m' - S\n  m' k = Some v\n  S \\<subseteq> dom m'\n  I S \\<sigma>\n  \\<forall>k' v'.\n     k' \\<in> dom m' - S - {k} \\<and> m' k' = Some v' \\<longrightarrow>\n     R (case (k, v) of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n      (case (k', v') of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n  \\<forall>k' v'.\n     k' \\<in> S \\<and> m' k' = Some v' \\<longrightarrow>\n     R (case (k', v') of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n      (case (k, v) of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n\ngoal (2 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>c \\<sigma>; k \\<in> dom m' - it; m' k = Some v;\n        it \\<subseteq> dom m'; I it \\<sigma>;\n        \\<forall>k' v'.\n           k' \\<in> dom m' - it - {k} \\<and>\n           m' k' = Some v' \\<longrightarrow>\n           R (case (k, v) of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n            (case (k', v') of (k, v) \\<Rightarrow> (k, \\<alpha> v));\n        \\<forall>k' v'.\n           k' \\<in> it \\<and> m' k' = Some v' \\<longrightarrow>\n           R (case (k', v') of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n            (case (k, v) of (k, v) \\<Rightarrow> (k, \\<alpha> v))\\<rbrakk>\n       \\<Longrightarrow> I (insert k it) (f (k, v) \\<sigma>)\n 2. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom m'; it \\<noteq> dom m';\n        \\<not> c \\<sigma>; I it \\<sigma>;\n        \\<forall>k v k' v'.\n           k \\<in> it \\<and>\n           m' k = Some v \\<and>\n           k' \\<notin> it \\<and> m' k' = Some v' \\<longrightarrow>\n           R (case (k, v) of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n            (case (k', v') of (k, v) \\<Rightarrow> (k, \\<alpha> v))\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "from IP [of \\<sigma> k S v] prems"], ["proof (chain)\npicking this:\n  \\<lbrakk>c \\<sigma>; k \\<in> dom m - S; invar v; m k = Some (\\<alpha> v);\n   S \\<subseteq> dom m; I S \\<sigma>;\n   \\<forall>k' v'.\n      k' \\<in> dom m - S - {k} \\<and>\n      invar v' \\<and> m k' = Some (\\<alpha> v') \\<longrightarrow>\n      R (k, \\<alpha> v) (k', \\<alpha> v');\n   \\<forall>k' v'.\n      k' \\<in> S \\<and>\n      invar v' \\<and> m k' = Some (\\<alpha> v') \\<longrightarrow>\n      R (k', \\<alpha> v') (k, \\<alpha> v)\\<rbrakk>\n  \\<Longrightarrow> I (insert k S) (f (k, v) \\<sigma>)\n  c \\<sigma>\n  k \\<in> dom m' - S\n  m' k = Some v\n  S \\<subseteq> dom m'\n  I S \\<sigma>\n  \\<forall>k' v'.\n     k' \\<in> dom m' - S - {k} \\<and> m' k' = Some v' \\<longrightarrow>\n     R (case (k, v) of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n      (case (k', v') of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n  \\<forall>k' v'.\n     k' \\<in> S \\<and> m' k' = Some v' \\<longrightarrow>\n     R (case (k', v') of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n      (case (k, v) of (k, v) \\<Rightarrow> (k, \\<alpha> v))", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>c \\<sigma>; k \\<in> dom m - S; invar v; m k = Some (\\<alpha> v);\n   S \\<subseteq> dom m; I S \\<sigma>;\n   \\<forall>k' v'.\n      k' \\<in> dom m - S - {k} \\<and>\n      invar v' \\<and> m k' = Some (\\<alpha> v') \\<longrightarrow>\n      R (k, \\<alpha> v) (k', \\<alpha> v');\n   \\<forall>k' v'.\n      k' \\<in> S \\<and>\n      invar v' \\<and> m k' = Some (\\<alpha> v') \\<longrightarrow>\n      R (k', \\<alpha> v') (k, \\<alpha> v)\\<rbrakk>\n  \\<Longrightarrow> I (insert k S) (f (k, v) \\<sigma>)\n  c \\<sigma>\n  k \\<in> dom m' - S\n  m' k = Some v\n  S \\<subseteq> dom m'\n  I S \\<sigma>\n  \\<forall>k' v'.\n     k' \\<in> dom m' - S - {k} \\<and> m' k' = Some v' \\<longrightarrow>\n     R (case (k, v) of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n      (case (k', v') of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n  \\<forall>k' v'.\n     k' \\<in> S \\<and> m' k' = Some v' \\<longrightarrow>\n     R (case (k', v') of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n      (case (k, v) of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n\ngoal (1 subgoal):\n 1. I (insert k S) (f (k, v) \\<sigma>)", "by (simp add: m'_props) metis"], ["proof (state)\nthis:\n  I (insert k S) (f (k, v) \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom m'; it \\<noteq> dom m';\n        \\<not> c \\<sigma>; I it \\<sigma>;\n        \\<forall>k v k' v'.\n           k \\<in> it \\<and>\n           m' k = Some v \\<and>\n           k' \\<notin> it \\<and> m' k' = Some v' \\<longrightarrow>\n           R (case (k, v) of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n            (case (k', v') of (k, v) \\<Rightarrow> (k, \\<alpha> v))\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom m'; it \\<noteq> dom m';\n        \\<not> c \\<sigma>; I it \\<sigma>;\n        \\<forall>k v k' v'.\n           k \\<in> it \\<and>\n           m' k = Some v \\<and>\n           k' \\<notin> it \\<and> m' k' = Some v' \\<longrightarrow>\n           R (case (k, v) of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n            (case (k', v') of (k, v) \\<Rightarrow> (k, \\<alpha> v))\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "case prems: (4 \\<sigma> S)"], ["proof (state)\nthis:\n  S \\<subseteq> dom m'\n  S \\<noteq> dom m'\n  \\<not> c \\<sigma>\n  I S \\<sigma>\n  \\<forall>k v k' v'.\n     k \\<in> S \\<and>\n     m' k = Some v \\<and>\n     k' \\<notin> S \\<and> m' k' = Some v' \\<longrightarrow>\n     R (case (k, v) of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n      (case (k', v') of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom m'; it \\<noteq> dom m';\n        \\<not> c \\<sigma>; I it \\<sigma>;\n        \\<forall>k v k' v'.\n           k \\<in> it \\<and>\n           m' k = Some v \\<and>\n           k' \\<notin> it \\<and> m' k' = Some v' \\<longrightarrow>\n           R (case (k, v) of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n            (case (k', v') of (k, v) \\<Rightarrow> (k, \\<alpha> v))\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<sigma>", "using II[of S \\<sigma>] prems"], ["proof (prove)\nusing this:\n  \\<lbrakk>S \\<subseteq> dom m; S \\<noteq> dom m; \\<not> c \\<sigma>;\n   I S \\<sigma>;\n   \\<forall>k v k' v'.\n      k \\<in> S \\<and>\n      invar v \\<and>\n      m k = Some (\\<alpha> v) \\<and>\n      k' \\<notin> S \\<and>\n      invar v' \\<and> m k' = Some (\\<alpha> v') \\<longrightarrow>\n      R (k, \\<alpha> v) (k', \\<alpha> v')\\<rbrakk>\n  \\<Longrightarrow> P \\<sigma>\n  S \\<subseteq> dom m'\n  S \\<noteq> dom m'\n  \\<not> c \\<sigma>\n  I S \\<sigma>\n  \\<forall>k v k' v'.\n     k \\<in> S \\<and>\n     m' k = Some v \\<and>\n     k' \\<notin> S \\<and> m' k' = Some v' \\<longrightarrow>\n     R (case (k, v) of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n      (case (k', v') of (k, v) \\<Rightarrow> (k, \\<alpha> v))\n\ngoal (1 subgoal):\n 1. P \\<sigma>", "by (simp add: m'_props) metis"], ["proof (state)\nthis:\n  P \\<sigma>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P (iti c f \\<sigma>0)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Unsorted Iterators\\<close>"], ["", "definition \"set_iterator_abs \\<alpha> invar it S0 \\<equiv> set_iterator_abs_genord \\<alpha> invar it S0 (\\<lambda>_ _. True)\""], ["", "lemma set_iterator_abs_trivial:\n  \"set_iterator_abs id (\\<lambda>_. True) = set_iterator\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_abs id (\\<lambda>_. True) = set_iterator", "by (simp add: set_iterator_def set_iterator_abs_def fun_eq_iff)"], ["", "lemma set_iterator_abs_trivial_simp [simp]:\n  assumes \"\\<forall>x. invar x\"\n      and \"\\<forall>x. \\<alpha> x = x\"\nshows \"set_iterator_abs \\<alpha> invar = set_iterator\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_abs \\<alpha> invar = set_iterator", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set_iterator_abs \\<alpha> invar = set_iterator", "from assms"], ["proof (chain)\npicking this:\n  \\<forall>x. invar x\n  \\<forall>x. \\<alpha> x = x", "have \"invar = (\\<lambda>_. True)\" and \"\\<alpha> = id\""], ["proof (prove)\nusing this:\n  \\<forall>x. invar x\n  \\<forall>x. \\<alpha> x = x\n\ngoal (1 subgoal):\n 1. invar = (\\<lambda>_. True) &&& \\<alpha> = id", "by (simp_all add: fun_eq_iff)"], ["proof (state)\nthis:\n  invar = (\\<lambda>_. True)\n  \\<alpha> = id\n\ngoal (1 subgoal):\n 1. set_iterator_abs \\<alpha> invar = set_iterator", "thus ?thesis"], ["proof (prove)\nusing this:\n  invar = (\\<lambda>_. True)\n  \\<alpha> = id\n\ngoal (1 subgoal):\n 1. set_iterator_abs \\<alpha> invar = set_iterator", "by (simp add: set_iterator_abs_trivial)"], ["proof (state)\nthis:\n  set_iterator_abs \\<alpha> invar = set_iterator\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_iterator_abs_I2 :\n  assumes it_OK: \"set_iterator iti S0\"\n      and dist: \"\\<And>xc1 xc2. \\<lbrakk>invar xc1; invar xc2; xc1 \\<in> S0; xc2 \\<in> S0; \\<alpha> xc1 = \\<alpha> xc2\\<rbrakk> \\<Longrightarrow> xc1 = xc2\"\n      and invar: \"\\<And>xc. xc \\<in> S0 \\<Longrightarrow> invar xc\"\n      and S0'_OK: \"S0' = \\<alpha> ` S0\"\n  shows \"set_iterator_abs \\<alpha> invar iti S0'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_abs \\<alpha> invar iti S0'", "unfolding set_iterator_abs_def S0'_OK"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_abs_genord \\<alpha> invar iti (\\<alpha> ` S0)\n     (\\<lambda>_ _. True)", "apply (rule set_iterator_abs_genord_I2[OF it_OK[unfolded set_iterator_def], of invar _ \\<alpha>])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>xc1 xc2.\n       \\<lbrakk>invar xc1; invar xc2; True\\<rbrakk> \\<Longrightarrow> True\n 2. \\<And>xc1 xc2.\n       \\<lbrakk>invar xc1; invar xc2; xc1 \\<in> S0; xc2 \\<in> S0;\n        \\<alpha> xc1 = \\<alpha> xc2\\<rbrakk>\n       \\<Longrightarrow> xc1 = xc2\n 3. \\<And>xc. xc \\<in> S0 \\<Longrightarrow> invar xc\n 4. \\<alpha> ` S0 = \\<alpha> ` S0", "apply (simp_all add: dist invar)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma set_iterator_abs_simple_rule_P:\n\"\\<lbrakk> set_iterator_abs \\<alpha> invar it S0;\n   (\\<And>xc. invar xc \\<Longrightarrow> f xc = f' (\\<alpha> xc));\n   I S0 \\<sigma>0;\n   !!S \\<sigma> x. \\<lbrakk> c \\<sigma>; x \\<in> S; I S \\<sigma>; S \\<subseteq> S0 \\<rbrakk> \\<Longrightarrow> I (S - {x}) (f' x \\<sigma>);\n   !!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>;\n   !!\\<sigma> S. S \\<subseteq> S0 \\<Longrightarrow> S \\<noteq> {} \\<Longrightarrow> \\<not> c \\<sigma> \\<Longrightarrow> I S \\<sigma> \\<Longrightarrow> P \\<sigma>\n \\<rbrakk> \\<Longrightarrow> P (it c f \\<sigma>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set_iterator_abs \\<alpha> invar it S0;\n     \\<And>xc. invar xc \\<Longrightarrow> f xc = f' (\\<alpha> xc);\n     I S0 \\<sigma>0;\n     \\<And>S \\<sigma> x.\n        \\<lbrakk>c \\<sigma>; x \\<in> S; I S \\<sigma>;\n         S \\<subseteq> S0\\<rbrakk>\n        \\<Longrightarrow> I (S - {x}) (f' x \\<sigma>);\n     \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>;\n     \\<And>\\<sigma> S.\n        \\<lbrakk>S \\<subseteq> S0; S \\<noteq> {}; \\<not> c \\<sigma>;\n         I S \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> P (it c f \\<sigma>0)", "unfolding set_iterator_abs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set_iterator_abs_genord \\<alpha> invar it S0\n              (\\<lambda>_ _. True);\n     \\<And>xc. invar xc \\<Longrightarrow> f xc = f' (\\<alpha> xc);\n     I S0 \\<sigma>0;\n     \\<And>S \\<sigma> x.\n        \\<lbrakk>c \\<sigma>; x \\<in> S; I S \\<sigma>;\n         S \\<subseteq> S0\\<rbrakk>\n        \\<Longrightarrow> I (S - {x}) (f' x \\<sigma>);\n     \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>;\n     \\<And>\\<sigma> S.\n        \\<lbrakk>S \\<subseteq> S0; S \\<noteq> {}; \\<not> c \\<sigma>;\n         I S \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> P (it c f \\<sigma>0)", "using set_iterator_abs_genord.iteratei_abs_simple_rule_P [of \\<alpha> invar it S0 \"\\<lambda>_ _. True\" f f' I \\<sigma>0 c P]"], ["proof (prove)\nusing this:\n  \\<lbrakk>set_iterator_abs_genord \\<alpha> invar it S0\n            (\\<lambda>_ _. True);\n   \\<And>xc.\n      \\<lbrakk>invar xc; \\<alpha> xc \\<in> S0\\<rbrakk>\n      \\<Longrightarrow> f xc = f' (\\<alpha> xc);\n   I S0 \\<sigma>0;\n   \\<And>S \\<sigma> x.\n      \\<lbrakk>c \\<sigma>; x \\<in> S; I S \\<sigma>; S \\<subseteq> S0;\n       \\<forall>y\\<in>S - {x}. True; \\<forall>y\\<in>S0 - S. True\\<rbrakk>\n      \\<Longrightarrow> I (S - {x}) (f' x \\<sigma>);\n   \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>;\n   \\<And>\\<sigma> S.\n      \\<lbrakk>S \\<subseteq> S0; S \\<noteq> {}; \\<not> c \\<sigma>;\n       I S \\<sigma>; \\<forall>x\\<in>S. \\<forall>y\\<in>S0 - S. True\\<rbrakk>\n      \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n  \\<Longrightarrow> P (it c f \\<sigma>0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>set_iterator_abs_genord \\<alpha> invar it S0\n              (\\<lambda>_ _. True);\n     \\<And>xc. invar xc \\<Longrightarrow> f xc = f' (\\<alpha> xc);\n     I S0 \\<sigma>0;\n     \\<And>S \\<sigma> x.\n        \\<lbrakk>c \\<sigma>; x \\<in> S; I S \\<sigma>;\n         S \\<subseteq> S0\\<rbrakk>\n        \\<Longrightarrow> I (S - {x}) (f' x \\<sigma>);\n     \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>;\n     \\<And>\\<sigma> S.\n        \\<lbrakk>S \\<subseteq> S0; S \\<noteq> {}; \\<not> c \\<sigma>;\n         I S \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> P (it c f \\<sigma>0)", "by simp"], ["", "lemma set_iterator_abs_simple_no_cond_rule_P:\n\"\\<lbrakk> set_iterator_abs \\<alpha> invar it S0;\n   (\\<And>xc. invar xc \\<Longrightarrow> f xc = f' (\\<alpha> xc));\n   I S0 \\<sigma>0;\n   !!S \\<sigma> x. \\<lbrakk> x \\<in> S; I S \\<sigma>; S \\<subseteq> S0 \\<rbrakk> \\<Longrightarrow> I (S - {x}) (f' x \\<sigma>);\n   !!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\n \\<rbrakk> \\<Longrightarrow> P (it (\\<lambda>_. True) f \\<sigma>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set_iterator_abs \\<alpha> invar it S0;\n     \\<And>xc. invar xc \\<Longrightarrow> f xc = f' (\\<alpha> xc);\n     I S0 \\<sigma>0;\n     \\<And>S \\<sigma> x.\n        \\<lbrakk>x \\<in> S; I S \\<sigma>; S \\<subseteq> S0\\<rbrakk>\n        \\<Longrightarrow> I (S - {x}) (f' x \\<sigma>);\n     \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> P (it (\\<lambda>_. True) f \\<sigma>0)", "using set_iterator_abs_simple_rule_P[of \\<alpha> invar it S0 f f' I \\<sigma>0 \"\\<lambda>_. True\" P]"], ["proof (prove)\nusing this:\n  \\<lbrakk>set_iterator_abs \\<alpha> invar it S0;\n   \\<And>xc. invar xc \\<Longrightarrow> f xc = f' (\\<alpha> xc);\n   I S0 \\<sigma>0;\n   \\<And>S \\<sigma> x.\n      \\<lbrakk>True; x \\<in> S; I S \\<sigma>; S \\<subseteq> S0\\<rbrakk>\n      \\<Longrightarrow> I (S - {x}) (f' x \\<sigma>);\n   \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>;\n   \\<And>\\<sigma> S.\n      \\<lbrakk>S \\<subseteq> S0; S \\<noteq> {}; \\<not> True;\n       I S \\<sigma>\\<rbrakk>\n      \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n  \\<Longrightarrow> P (it (\\<lambda>_. True) f \\<sigma>0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>set_iterator_abs \\<alpha> invar it S0;\n     \\<And>xc. invar xc \\<Longrightarrow> f xc = f' (\\<alpha> xc);\n     I S0 \\<sigma>0;\n     \\<And>S \\<sigma> x.\n        \\<lbrakk>x \\<in> S; I S \\<sigma>; S \\<subseteq> S0\\<rbrakk>\n        \\<Longrightarrow> I (S - {x}) (f' x \\<sigma>);\n     \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> P (it (\\<lambda>_. True) f \\<sigma>0)", "by simp"], ["", "lemma set_iterator_abs_simple_rule_insert_P :\n\"\\<lbrakk> set_iterator_abs \\<alpha> invar it S0;\n   (\\<And>xc. invar xc \\<Longrightarrow> f xc = f' (\\<alpha> xc));\n   I {} \\<sigma>0;\n   !!S \\<sigma> x. \\<lbrakk> c \\<sigma>; x \\<in> S0 - S; I S \\<sigma>; S \\<subseteq> S0 \\<rbrakk>  \\<Longrightarrow> I (insert x S) (f' x \\<sigma>);\n   !!\\<sigma>. I S0 \\<sigma> \\<Longrightarrow> P \\<sigma>;\n   !!\\<sigma> S. S \\<subseteq> S0 \\<Longrightarrow> S \\<noteq> S0 \\<Longrightarrow> \\<not> c \\<sigma> \\<Longrightarrow> I S \\<sigma> \\<Longrightarrow> P \\<sigma>\n \\<rbrakk> \\<Longrightarrow> P (it c f \\<sigma>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set_iterator_abs \\<alpha> invar it S0;\n     \\<And>xc. invar xc \\<Longrightarrow> f xc = f' (\\<alpha> xc);\n     I {} \\<sigma>0;\n     \\<And>S \\<sigma> x.\n        \\<lbrakk>c \\<sigma>; x \\<in> S0 - S; I S \\<sigma>;\n         S \\<subseteq> S0\\<rbrakk>\n        \\<Longrightarrow> I (insert x S) (f' x \\<sigma>);\n     \\<And>\\<sigma>. I S0 \\<sigma> \\<Longrightarrow> P \\<sigma>;\n     \\<And>\\<sigma> S.\n        \\<lbrakk>S \\<subseteq> S0; S \\<noteq> S0; \\<not> c \\<sigma>;\n         I S \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> P (it c f \\<sigma>0)", "unfolding set_iterator_abs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set_iterator_abs_genord \\<alpha> invar it S0\n              (\\<lambda>_ _. True);\n     \\<And>xc. invar xc \\<Longrightarrow> f xc = f' (\\<alpha> xc);\n     I {} \\<sigma>0;\n     \\<And>S \\<sigma> x.\n        \\<lbrakk>c \\<sigma>; x \\<in> S0 - S; I S \\<sigma>;\n         S \\<subseteq> S0\\<rbrakk>\n        \\<Longrightarrow> I (insert x S) (f' x \\<sigma>);\n     \\<And>\\<sigma>. I S0 \\<sigma> \\<Longrightarrow> P \\<sigma>;\n     \\<And>\\<sigma> S.\n        \\<lbrakk>S \\<subseteq> S0; S \\<noteq> S0; \\<not> c \\<sigma>;\n         I S \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> P (it c f \\<sigma>0)", "using set_iterator_abs_genord.iteratei_abs_simple_rule_insert_P [of \\<alpha> invar it S0 \"\\<lambda>_ _. True\" f f' I \\<sigma>0 c P]"], ["proof (prove)\nusing this:\n  \\<lbrakk>set_iterator_abs_genord \\<alpha> invar it S0\n            (\\<lambda>_ _. True);\n   \\<And>xc.\n      \\<lbrakk>invar xc; \\<alpha> xc \\<in> S0\\<rbrakk>\n      \\<Longrightarrow> f xc = f' (\\<alpha> xc);\n   I {} \\<sigma>0;\n   \\<And>S \\<sigma> x.\n      \\<lbrakk>c \\<sigma>; x \\<in> S0 - S; I S \\<sigma>; S \\<subseteq> S0;\n       \\<forall>y\\<in>S0 - S - {x}. True; \\<forall>y\\<in>S. True\\<rbrakk>\n      \\<Longrightarrow> I (insert x S) (f' x \\<sigma>);\n   \\<And>\\<sigma>. I S0 \\<sigma> \\<Longrightarrow> P \\<sigma>;\n   \\<And>\\<sigma> S.\n      \\<lbrakk>S \\<subseteq> S0; S \\<noteq> S0; \\<not> c \\<sigma>;\n       I S \\<sigma>; \\<forall>x\\<in>S0 - S. \\<forall>y\\<in>S. True\\<rbrakk>\n      \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n  \\<Longrightarrow> P (it c f \\<sigma>0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>set_iterator_abs_genord \\<alpha> invar it S0\n              (\\<lambda>_ _. True);\n     \\<And>xc. invar xc \\<Longrightarrow> f xc = f' (\\<alpha> xc);\n     I {} \\<sigma>0;\n     \\<And>S \\<sigma> x.\n        \\<lbrakk>c \\<sigma>; x \\<in> S0 - S; I S \\<sigma>;\n         S \\<subseteq> S0\\<rbrakk>\n        \\<Longrightarrow> I (insert x S) (f' x \\<sigma>);\n     \\<And>\\<sigma>. I S0 \\<sigma> \\<Longrightarrow> P \\<sigma>;\n     \\<And>\\<sigma> S.\n        \\<lbrakk>S \\<subseteq> S0; S \\<noteq> S0; \\<not> c \\<sigma>;\n         I S \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> P (it c f \\<sigma>0)", "by simp"], ["", "lemma set_iterator_abs_no_cond_simple_rule_insert_P :\n\"\\<lbrakk> set_iterator_abs \\<alpha> invar it S0;\n   (\\<And>xc. invar xc \\<Longrightarrow> f xc = f' (\\<alpha> xc));\n   I {} \\<sigma>0;\n   !!S \\<sigma> x. \\<lbrakk> x \\<in> S0 - S; I S \\<sigma>; S \\<subseteq> S0 \\<rbrakk>  \\<Longrightarrow> I (insert x S) (f' x \\<sigma>);\n   !!\\<sigma>. I S0 \\<sigma> \\<Longrightarrow> P \\<sigma>\n \\<rbrakk> \\<Longrightarrow> P (it (\\<lambda>_. True) f \\<sigma>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set_iterator_abs \\<alpha> invar it S0;\n     \\<And>xc. invar xc \\<Longrightarrow> f xc = f' (\\<alpha> xc);\n     I {} \\<sigma>0;\n     \\<And>S \\<sigma> x.\n        \\<lbrakk>x \\<in> S0 - S; I S \\<sigma>; S \\<subseteq> S0\\<rbrakk>\n        \\<Longrightarrow> I (insert x S) (f' x \\<sigma>);\n     \\<And>\\<sigma>. I S0 \\<sigma> \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> P (it (\\<lambda>_. True) f \\<sigma>0)", "using set_iterator_abs_simple_rule_insert_P[of \\<alpha> invar it S0 f f' I \\<sigma>0 \"\\<lambda>_. True\" P]"], ["proof (prove)\nusing this:\n  \\<lbrakk>set_iterator_abs \\<alpha> invar it S0;\n   \\<And>xc. invar xc \\<Longrightarrow> f xc = f' (\\<alpha> xc);\n   I {} \\<sigma>0;\n   \\<And>S \\<sigma> x.\n      \\<lbrakk>True; x \\<in> S0 - S; I S \\<sigma>; S \\<subseteq> S0\\<rbrakk>\n      \\<Longrightarrow> I (insert x S) (f' x \\<sigma>);\n   \\<And>\\<sigma>. I S0 \\<sigma> \\<Longrightarrow> P \\<sigma>;\n   \\<And>\\<sigma> S.\n      \\<lbrakk>S \\<subseteq> S0; S \\<noteq> S0; \\<not> True;\n       I S \\<sigma>\\<rbrakk>\n      \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n  \\<Longrightarrow> P (it (\\<lambda>_. True) f \\<sigma>0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>set_iterator_abs \\<alpha> invar it S0;\n     \\<And>xc. invar xc \\<Longrightarrow> f xc = f' (\\<alpha> xc);\n     I {} \\<sigma>0;\n     \\<And>S \\<sigma> x.\n        \\<lbrakk>x \\<in> S0 - S; I S \\<sigma>; S \\<subseteq> S0\\<rbrakk>\n        \\<Longrightarrow> I (insert x S) (f' x \\<sigma>);\n     \\<And>\\<sigma>. I S0 \\<sigma> \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> P (it (\\<lambda>_. True) f \\<sigma>0)", "by simp"], ["", "lemma set_iterator_abs_rule_P:\n\"\\<lbrakk> set_iterator_abs \\<alpha> invar it S0;\n   I S0 \\<sigma>0;\n   !!S \\<sigma> x. \\<lbrakk> c \\<sigma>; invar x; \\<alpha> x \\<in> S; I S \\<sigma>; S \\<subseteq> S0 \\<rbrakk> \\<Longrightarrow> I (S - {\\<alpha> x}) (f x \\<sigma>);\n   !!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>;\n   !!\\<sigma> S. S \\<subseteq> S0 \\<Longrightarrow> S \\<noteq> {} \\<Longrightarrow> \\<not> c \\<sigma> \\<Longrightarrow> I S \\<sigma> \\<Longrightarrow> P \\<sigma>\n \\<rbrakk> \\<Longrightarrow> P (it c f \\<sigma>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set_iterator_abs \\<alpha> invar it S0; I S0 \\<sigma>0;\n     \\<And>S \\<sigma> x.\n        \\<lbrakk>c \\<sigma>; invar x; \\<alpha> x \\<in> S; I S \\<sigma>;\n         S \\<subseteq> S0\\<rbrakk>\n        \\<Longrightarrow> I (S - {\\<alpha> x}) (f x \\<sigma>);\n     \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>;\n     \\<And>\\<sigma> S.\n        \\<lbrakk>S \\<subseteq> S0; S \\<noteq> {}; \\<not> c \\<sigma>;\n         I S \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> P (it c f \\<sigma>0)", "unfolding set_iterator_abs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set_iterator_abs_genord \\<alpha> invar it S0\n              (\\<lambda>_ _. True);\n     I S0 \\<sigma>0;\n     \\<And>S \\<sigma> x.\n        \\<lbrakk>c \\<sigma>; invar x; \\<alpha> x \\<in> S; I S \\<sigma>;\n         S \\<subseteq> S0\\<rbrakk>\n        \\<Longrightarrow> I (S - {\\<alpha> x}) (f x \\<sigma>);\n     \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>;\n     \\<And>\\<sigma> S.\n        \\<lbrakk>S \\<subseteq> S0; S \\<noteq> {}; \\<not> c \\<sigma>;\n         I S \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> P (it c f \\<sigma>0)", "using set_iterator_abs_genord.iteratei_abs_rule_P [of \\<alpha> invar it S0 \"\\<lambda>_ _. True\" I \\<sigma>0 c f P]"], ["proof (prove)\nusing this:\n  \\<lbrakk>set_iterator_abs_genord \\<alpha> invar it S0\n            (\\<lambda>_ _. True);\n   I S0 \\<sigma>0;\n   \\<And>S \\<sigma> x.\n      \\<lbrakk>c \\<sigma>; invar x; \\<alpha> x \\<in> S; I S \\<sigma>;\n       S \\<subseteq> S0; \\<forall>y\\<in>S - {\\<alpha> x}. True;\n       \\<forall>y\\<in>S0 - S. True\\<rbrakk>\n      \\<Longrightarrow> I (S - {\\<alpha> x}) (f x \\<sigma>);\n   \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>;\n   \\<And>\\<sigma> S.\n      \\<lbrakk>S \\<subseteq> S0; S \\<noteq> {}; \\<not> c \\<sigma>;\n       I S \\<sigma>; \\<forall>x\\<in>S. \\<forall>y\\<in>S0 - S. True\\<rbrakk>\n      \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n  \\<Longrightarrow> P (it c f \\<sigma>0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>set_iterator_abs_genord \\<alpha> invar it S0\n              (\\<lambda>_ _. True);\n     I S0 \\<sigma>0;\n     \\<And>S \\<sigma> x.\n        \\<lbrakk>c \\<sigma>; invar x; \\<alpha> x \\<in> S; I S \\<sigma>;\n         S \\<subseteq> S0\\<rbrakk>\n        \\<Longrightarrow> I (S - {\\<alpha> x}) (f x \\<sigma>);\n     \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>;\n     \\<And>\\<sigma> S.\n        \\<lbrakk>S \\<subseteq> S0; S \\<noteq> {}; \\<not> c \\<sigma>;\n         I S \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> P (it c f \\<sigma>0)", "by simp"], ["", "lemma set_iterator_abs_no_cond_rule_P:\n\"\\<lbrakk> set_iterator_abs \\<alpha> invar it S0;\n   I S0 \\<sigma>0;\n   !!S \\<sigma> x. \\<lbrakk> invar x; \\<alpha> x \\<in> S; I S \\<sigma>; S \\<subseteq> S0 \\<rbrakk> \\<Longrightarrow> I (S - {\\<alpha> x}) (f x \\<sigma>);\n   !!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\n \\<rbrakk> \\<Longrightarrow> P (it (\\<lambda>_. True) f \\<sigma>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set_iterator_abs \\<alpha> invar it S0; I S0 \\<sigma>0;\n     \\<And>S \\<sigma> x.\n        \\<lbrakk>invar x; \\<alpha> x \\<in> S; I S \\<sigma>;\n         S \\<subseteq> S0\\<rbrakk>\n        \\<Longrightarrow> I (S - {\\<alpha> x}) (f x \\<sigma>);\n     \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> P (it (\\<lambda>_. True) f \\<sigma>0)", "using set_iterator_abs_rule_P[of \\<alpha> invar it S0 I \\<sigma>0 \"\\<lambda>_. True\" f P]"], ["proof (prove)\nusing this:\n  \\<lbrakk>set_iterator_abs \\<alpha> invar it S0; I S0 \\<sigma>0;\n   \\<And>S \\<sigma> x.\n      \\<lbrakk>True; invar x; \\<alpha> x \\<in> S; I S \\<sigma>;\n       S \\<subseteq> S0\\<rbrakk>\n      \\<Longrightarrow> I (S - {\\<alpha> x}) (f x \\<sigma>);\n   \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>;\n   \\<And>\\<sigma> S.\n      \\<lbrakk>S \\<subseteq> S0; S \\<noteq> {}; \\<not> True;\n       I S \\<sigma>\\<rbrakk>\n      \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n  \\<Longrightarrow> P (it (\\<lambda>_. True) f \\<sigma>0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>set_iterator_abs \\<alpha> invar it S0; I S0 \\<sigma>0;\n     \\<And>S \\<sigma> x.\n        \\<lbrakk>invar x; \\<alpha> x \\<in> S; I S \\<sigma>;\n         S \\<subseteq> S0\\<rbrakk>\n        \\<Longrightarrow> I (S - {\\<alpha> x}) (f x \\<sigma>);\n     \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> P (it (\\<lambda>_. True) f \\<sigma>0)", "by simp"], ["", "lemma set_iterator_abs_rule_insert_P :\n\"\\<lbrakk> set_iterator_abs \\<alpha> invar it S0;\n   I {} \\<sigma>0;\n   !!S \\<sigma> x. \\<lbrakk> c \\<sigma>; invar x; \\<alpha> x \\<in> S0 - S; I S \\<sigma>; S \\<subseteq> S0 \\<rbrakk>  \\<Longrightarrow> I (insert (\\<alpha> x) S) (f x \\<sigma>);\n   !!\\<sigma>. I S0 \\<sigma> \\<Longrightarrow> P \\<sigma>;\n   !!\\<sigma> S. S \\<subseteq> S0 \\<Longrightarrow> S \\<noteq> S0 \\<Longrightarrow> \\<not> c \\<sigma> \\<Longrightarrow> I S \\<sigma> \\<Longrightarrow> P \\<sigma>\n \\<rbrakk> \\<Longrightarrow> P (it c f \\<sigma>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set_iterator_abs \\<alpha> invar it S0; I {} \\<sigma>0;\n     \\<And>S \\<sigma> x.\n        \\<lbrakk>c \\<sigma>; invar x; \\<alpha> x \\<in> S0 - S; I S \\<sigma>;\n         S \\<subseteq> S0\\<rbrakk>\n        \\<Longrightarrow> I (insert (\\<alpha> x) S) (f x \\<sigma>);\n     \\<And>\\<sigma>. I S0 \\<sigma> \\<Longrightarrow> P \\<sigma>;\n     \\<And>\\<sigma> S.\n        \\<lbrakk>S \\<subseteq> S0; S \\<noteq> S0; \\<not> c \\<sigma>;\n         I S \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> P (it c f \\<sigma>0)", "unfolding set_iterator_abs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set_iterator_abs_genord \\<alpha> invar it S0\n              (\\<lambda>_ _. True);\n     I {} \\<sigma>0;\n     \\<And>S \\<sigma> x.\n        \\<lbrakk>c \\<sigma>; invar x; \\<alpha> x \\<in> S0 - S; I S \\<sigma>;\n         S \\<subseteq> S0\\<rbrakk>\n        \\<Longrightarrow> I (insert (\\<alpha> x) S) (f x \\<sigma>);\n     \\<And>\\<sigma>. I S0 \\<sigma> \\<Longrightarrow> P \\<sigma>;\n     \\<And>\\<sigma> S.\n        \\<lbrakk>S \\<subseteq> S0; S \\<noteq> S0; \\<not> c \\<sigma>;\n         I S \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> P (it c f \\<sigma>0)", "using set_iterator_abs_genord.iteratei_abs_rule_insert_P [of \\<alpha> invar it S0 \"\\<lambda>_ _. True\" I \\<sigma>0 c f P]"], ["proof (prove)\nusing this:\n  \\<lbrakk>set_iterator_abs_genord \\<alpha> invar it S0\n            (\\<lambda>_ _. True);\n   I {} \\<sigma>0;\n   \\<And>S \\<sigma> x.\n      \\<lbrakk>c \\<sigma>; invar x; \\<alpha> x \\<in> S0 - S; I S \\<sigma>;\n       S \\<subseteq> S0; \\<forall>y\\<in>S0 - S - {\\<alpha> x}. True;\n       \\<forall>y\\<in>S. True\\<rbrakk>\n      \\<Longrightarrow> I (insert (\\<alpha> x) S) (f x \\<sigma>);\n   \\<And>\\<sigma>. I S0 \\<sigma> \\<Longrightarrow> P \\<sigma>;\n   \\<And>\\<sigma> S.\n      \\<lbrakk>S \\<subseteq> S0; S \\<noteq> S0; \\<not> c \\<sigma>;\n       I S \\<sigma>; \\<forall>x\\<in>S0 - S. \\<forall>y\\<in>S. True\\<rbrakk>\n      \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n  \\<Longrightarrow> P (it c f \\<sigma>0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>set_iterator_abs_genord \\<alpha> invar it S0\n              (\\<lambda>_ _. True);\n     I {} \\<sigma>0;\n     \\<And>S \\<sigma> x.\n        \\<lbrakk>c \\<sigma>; invar x; \\<alpha> x \\<in> S0 - S; I S \\<sigma>;\n         S \\<subseteq> S0\\<rbrakk>\n        \\<Longrightarrow> I (insert (\\<alpha> x) S) (f x \\<sigma>);\n     \\<And>\\<sigma>. I S0 \\<sigma> \\<Longrightarrow> P \\<sigma>;\n     \\<And>\\<sigma> S.\n        \\<lbrakk>S \\<subseteq> S0; S \\<noteq> S0; \\<not> c \\<sigma>;\n         I S \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> P (it c f \\<sigma>0)", "by simp"], ["", "lemma set_iterator_abs_no_cond_rule_insert_P :\n\"\\<lbrakk> set_iterator_abs \\<alpha> invar it S0;\n   I {} \\<sigma>0;\n   !!S \\<sigma> x. \\<lbrakk> invar x; \\<alpha> x \\<in> S0 - S; I S \\<sigma>; S \\<subseteq> S0 \\<rbrakk>  \\<Longrightarrow> I (insert (\\<alpha> x) S) (f x \\<sigma>);\n   !!\\<sigma>. I S0 \\<sigma> \\<Longrightarrow> P \\<sigma>\n \\<rbrakk> \\<Longrightarrow> P (it (\\<lambda>_. True) f \\<sigma>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set_iterator_abs \\<alpha> invar it S0; I {} \\<sigma>0;\n     \\<And>S \\<sigma> x.\n        \\<lbrakk>invar x; \\<alpha> x \\<in> S0 - S; I S \\<sigma>;\n         S \\<subseteq> S0\\<rbrakk>\n        \\<Longrightarrow> I (insert (\\<alpha> x) S) (f x \\<sigma>);\n     \\<And>\\<sigma>. I S0 \\<sigma> \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> P (it (\\<lambda>_. True) f \\<sigma>0)", "using set_iterator_abs_rule_insert_P[of \\<alpha> invar it S0 I \\<sigma>0 \"\\<lambda>_. True\" f P]"], ["proof (prove)\nusing this:\n  \\<lbrakk>set_iterator_abs \\<alpha> invar it S0; I {} \\<sigma>0;\n   \\<And>S \\<sigma> x.\n      \\<lbrakk>True; invar x; \\<alpha> x \\<in> S0 - S; I S \\<sigma>;\n       S \\<subseteq> S0\\<rbrakk>\n      \\<Longrightarrow> I (insert (\\<alpha> x) S) (f x \\<sigma>);\n   \\<And>\\<sigma>. I S0 \\<sigma> \\<Longrightarrow> P \\<sigma>;\n   \\<And>\\<sigma> S.\n      \\<lbrakk>S \\<subseteq> S0; S \\<noteq> S0; \\<not> True;\n       I S \\<sigma>\\<rbrakk>\n      \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n  \\<Longrightarrow> P (it (\\<lambda>_. True) f \\<sigma>0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>set_iterator_abs \\<alpha> invar it S0; I {} \\<sigma>0;\n     \\<And>S \\<sigma> x.\n        \\<lbrakk>invar x; \\<alpha> x \\<in> S0 - S; I S \\<sigma>;\n         S \\<subseteq> S0\\<rbrakk>\n        \\<Longrightarrow> I (insert (\\<alpha> x) S) (f x \\<sigma>);\n     \\<And>\\<sigma>. I S0 \\<sigma> \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> P (it (\\<lambda>_. True) f \\<sigma>0)", "by simp"], ["", "subsection \\<open>Unsorted Map-Iterators\\<close>"], ["", "definition \"map_iterator_abs \\<alpha> invar it m \\<equiv> map_iterator_abs_genord \\<alpha> invar it m (\\<lambda>_ _. True)\""], ["", "lemma map_iterator_abs_trivial:\n  \"map_iterator_abs id (\\<lambda>_. True) = map_iterator\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_iterator_abs id (\\<lambda>_. True) = map_iterator", "by (simp add: set_iterator_def map_iterator_abs_def map_iterator_abs_genord_def \n              set_iterator_abs_genord_def set_iterator_genord_def fun_eq_iff)"], ["", "lemma map_iterator_abs_trivial_simp [simp] :\n  assumes \"\\<forall>x. invar x\"\n      and \"\\<forall>x. \\<alpha> x = x\"\nshows \"map_iterator_abs \\<alpha> invar = map_iterator\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_iterator_abs \\<alpha> invar = map_iterator", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map_iterator_abs \\<alpha> invar = map_iterator", "from assms"], ["proof (chain)\npicking this:\n  \\<forall>x. invar x\n  \\<forall>x. \\<alpha> x = x", "have \"invar = (\\<lambda>_. True)\" and \"\\<alpha> = id\""], ["proof (prove)\nusing this:\n  \\<forall>x. invar x\n  \\<forall>x. \\<alpha> x = x\n\ngoal (1 subgoal):\n 1. invar = (\\<lambda>_. True) &&& \\<alpha> = id", "by (simp_all add: fun_eq_iff)"], ["proof (state)\nthis:\n  invar = (\\<lambda>_. True)\n  \\<alpha> = id\n\ngoal (1 subgoal):\n 1. map_iterator_abs \\<alpha> invar = map_iterator", "thus ?thesis"], ["proof (prove)\nusing this:\n  invar = (\\<lambda>_. True)\n  \\<alpha> = id\n\ngoal (1 subgoal):\n 1. map_iterator_abs \\<alpha> invar = map_iterator", "by (simp add: map_iterator_abs_trivial)"], ["proof (state)\nthis:\n  map_iterator_abs \\<alpha> invar = map_iterator\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_iterator_abs_I2 :\n  assumes it_OK: \"map_iterator iti m\"\n      and invar: \"\\<And>k v. m k = Some v \\<Longrightarrow> invar v\"\n      and m'_eq: \"m' = map_option \\<alpha> \\<circ> m\"\n  shows \"map_iterator_abs \\<alpha> invar iti m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_iterator_abs \\<alpha> invar iti m'", "using assms"], ["proof (prove)\nusing this:\n  map_iterator iti m\n  m ?k = Some ?v \\<Longrightarrow> invar ?v\n  m' = map_option \\<alpha> \\<circ> m\n\ngoal (1 subgoal):\n 1. map_iterator_abs \\<alpha> invar iti m'", "unfolding map_iterator_abs_def set_iterator_def"], ["proof (prove)\nusing this:\n  map_iterator_genord iti m (\\<lambda>_ _. True)\n  m ?k = Some ?v \\<Longrightarrow> invar ?v\n  m' = map_option \\<alpha> \\<circ> m\n\ngoal (1 subgoal):\n 1. map_iterator_abs_genord \\<alpha> invar iti m' (\\<lambda>_ _. True)", "by (rule_tac map_iterator_abs_genord_I2 [OF it_OK[unfolded set_iterator_def]]) simp_all"], ["", "lemma map_iterator_abs_rule_P:\n  assumes iti_OK: \"map_iterator_abs \\<alpha> invar iti m\"\n      and I0: \"I (dom m) \\<sigma>0\"\n      and IP: \"!!k v it \\<sigma>. \\<lbrakk> c \\<sigma>; k \\<in> it; invar v; m k = Some (\\<alpha> v); it \\<subseteq> dom m; I it \\<sigma> \\<rbrakk> \\<Longrightarrow> \n                            I (it - {k}) (f (k, v) \\<sigma>)\"\n      and IF: \"!!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n      and II: \"!!\\<sigma> it. \\<lbrakk> it \\<subseteq> dom m; it \\<noteq> {}; \\<not> c \\<sigma>; I it \\<sigma> \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n  shows \"P (iti c f \\<sigma>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (iti c f \\<sigma>0)", "apply (rule map_iterator_abs_genord_rule_P [OF iti_OK[unfolded map_iterator_abs_def], of I])"], ["proof (prove)\ngoal (4 subgoals):\n 1. I (dom m) \\<sigma>0\n 2. \\<And>k v it \\<sigma>.\n       \\<lbrakk>c \\<sigma>; k \\<in> it; invar v; m k = Some (\\<alpha> v);\n        it \\<subseteq> dom m; I it \\<sigma>;\n        \\<forall>k' v'.\n           k' \\<in> it - {k} \\<and>\n           invar v' \\<and> m k' = Some (\\<alpha> v') \\<longrightarrow>\n           True;\n        \\<forall>k' v'.\n           k' \\<notin> it \\<and>\n           invar v' \\<and> m k' = Some (\\<alpha> v') \\<longrightarrow>\n           True\\<rbrakk>\n       \\<Longrightarrow> I (it - {k}) (f (k, v) \\<sigma>)\n 3. \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\n 4. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom m; it \\<noteq> {}; \\<not> c \\<sigma>;\n        I it \\<sigma>;\n        \\<forall>k v k' v'.\n           k \\<notin> it \\<and>\n           invar v \\<and>\n           m k = Some (\\<alpha> v) \\<and>\n           k' \\<in> it \\<and>\n           invar v' \\<and> m k' = Some (\\<alpha> v') \\<longrightarrow>\n           True\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "apply (simp_all add: I0 IP IF II)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma map_iterator_abs_no_cond_rule_P:\n  assumes iti_OK: \"map_iterator_abs \\<alpha> invar iti m\"\n      and I0: \"I (dom m) \\<sigma>0\"\n      and IP: \"!!k v it \\<sigma>. \\<lbrakk> k \\<in> it; invar v; m k = Some (\\<alpha> v); it \\<subseteq> dom m; I it \\<sigma> \\<rbrakk> \\<Longrightarrow> \n                            I (it - {k}) (f (k, v) \\<sigma>)\"\n      and IF: \"!!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n  shows \"P (iti (\\<lambda>_. True) f \\<sigma>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (iti (\\<lambda>_. True) f \\<sigma>0)", "apply (rule map_iterator_abs_rule_P [OF iti_OK, of I])"], ["proof (prove)\ngoal (4 subgoals):\n 1. I (dom m) \\<sigma>0\n 2. \\<And>k v it \\<sigma>.\n       \\<lbrakk>True; k \\<in> it; invar v; m k = Some (\\<alpha> v);\n        it \\<subseteq> dom m; I it \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I (it - {k}) (f (k, v) \\<sigma>)\n 3. \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\n 4. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom m; it \\<noteq> {}; \\<not> True;\n        I it \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "apply (simp_all add: I0 IP IF)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma map_iterator_abs_rule_insert_P:\n  assumes iti_OK: \"map_iterator_abs \\<alpha> invar iti m\"\n      and I0: \"I {} \\<sigma>0\"\n      and IP: \"!!k v it \\<sigma>. \\<lbrakk> c \\<sigma>; k \\<in> dom m - it; invar v; m k = Some (\\<alpha> v); it \\<subseteq> dom m; I it \\<sigma> \\<rbrakk> \\<Longrightarrow> \n                            I (insert k it) (f (k, v) \\<sigma>)\"\n      and IF: \"!!\\<sigma>. I (dom m) \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n      and II: \"!!\\<sigma> it. \\<lbrakk> it \\<subseteq> dom m; it \\<noteq> dom m; \\<not> c \\<sigma>; I it \\<sigma> \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n  shows \"P (iti c f \\<sigma>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (iti c f \\<sigma>0)", "apply (rule map_iterator_abs_genord_rule_insert_P [OF iti_OK[unfolded map_iterator_abs_def], of I])"], ["proof (prove)\ngoal (4 subgoals):\n 1. I {} \\<sigma>0\n 2. \\<And>k v it \\<sigma>.\n       \\<lbrakk>c \\<sigma>; k \\<in> dom m - it; invar v;\n        m k = Some (\\<alpha> v); it \\<subseteq> dom m; I it \\<sigma>;\n        \\<forall>k' v'.\n           k' \\<in> dom m - it - {k} \\<and>\n           invar v' \\<and> m k' = Some (\\<alpha> v') \\<longrightarrow>\n           True;\n        \\<forall>k' v'.\n           k' \\<in> it \\<and>\n           invar v' \\<and> m k' = Some (\\<alpha> v') \\<longrightarrow>\n           True\\<rbrakk>\n       \\<Longrightarrow> I (insert k it) (f (k, v) \\<sigma>)\n 3. \\<And>\\<sigma>. I (dom m) \\<sigma> \\<Longrightarrow> P \\<sigma>\n 4. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom m; it \\<noteq> dom m; \\<not> c \\<sigma>;\n        I it \\<sigma>;\n        \\<forall>k v k' v'.\n           k \\<in> it \\<and>\n           invar v \\<and>\n           m k = Some (\\<alpha> v) \\<and>\n           k' \\<notin> it \\<and>\n           invar v' \\<and> m k' = Some (\\<alpha> v') \\<longrightarrow>\n           True\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "apply (simp_all add: I0 IP IF II)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma map_iterator_abs_no_cond_rule_insert_P:\n  assumes iti_OK: \"map_iterator_abs \\<alpha> invar iti m\"\n      and I0: \"I {} \\<sigma>0\"\n      and IP: \"!!k v it \\<sigma>. \\<lbrakk> k \\<in> dom m - it; invar v; m k = Some (\\<alpha> v); it \\<subseteq> dom m; I it \\<sigma> \\<rbrakk> \\<Longrightarrow> \n                            I (insert k it) (f (k, v) \\<sigma>)\"\n      and IF: \"!!\\<sigma>. I (dom m) \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n  shows \"P (iti (\\<lambda>_. True) f \\<sigma>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (iti (\\<lambda>_. True) f \\<sigma>0)", "apply (rule map_iterator_abs_genord_rule_insert_P [OF iti_OK[unfolded map_iterator_abs_def], of I])"], ["proof (prove)\ngoal (4 subgoals):\n 1. I {} \\<sigma>0\n 2. \\<And>k v it \\<sigma>.\n       \\<lbrakk>True; k \\<in> dom m - it; invar v; m k = Some (\\<alpha> v);\n        it \\<subseteq> dom m; I it \\<sigma>;\n        \\<forall>k' v'.\n           k' \\<in> dom m - it - {k} \\<and>\n           invar v' \\<and> m k' = Some (\\<alpha> v') \\<longrightarrow>\n           True;\n        \\<forall>k' v'.\n           k' \\<in> it \\<and>\n           invar v' \\<and> m k' = Some (\\<alpha> v') \\<longrightarrow>\n           True\\<rbrakk>\n       \\<Longrightarrow> I (insert k it) (f (k, v) \\<sigma>)\n 3. \\<And>\\<sigma>. I (dom m) \\<sigma> \\<Longrightarrow> P \\<sigma>\n 4. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom m; it \\<noteq> dom m; \\<not> True;\n        I it \\<sigma>;\n        \\<forall>k v k' v'.\n           k \\<in> it \\<and>\n           invar v \\<and>\n           m k = Some (\\<alpha> v) \\<and>\n           k' \\<notin> it \\<and>\n           invar v' \\<and> m k' = Some (\\<alpha> v') \\<longrightarrow>\n           True\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "apply (simp_all add: I0 IP IF)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}