{"file_name": "/home/qj213/afp-2021-10-22/thys/Collections/GenCF/Impl/Impl_Array_Hash_Map.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Collections", "problem_names": ["lemma ahm_map_rel_def: \"\\<langle>Rk,Rv\\<rangle> ahm_map_rel \\<equiv> \n{(HashMap a n, HashMap a' n)| a a' n n'.\n         (a,a') \\<in> \\<langle>\\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel\\<rangle>array_rel \\<and> (n,n') \\<in> Id}\"", "lemma ahm_rel_def: \"\\<langle>Rk, Rv\\<rangle> ahm_rel bhc \\<equiv>\n     \\<langle>Rk,Rv\\<rangle> ahm_map_rel O ahm_map_rel' (abstract_bounded_hashcode Rk bhc)\"", "lemmas [autoref_rel_intf] = REL_INTFI[of \"ahm_rel bhc\" i_map] for bhc", "lemma hm_grow_gt_1 [iff]:\n  \"Suc 0 < hm_grow hm\"", "lemma bucket_ok_Nil [simp]: \"bucket_ok bhc len h [] = True\"", "lemma bucket_okD:\n  \"\\<lbrakk> bucket_ok bhc len h xs; (k, v) \\<in> set xs \\<rbrakk>\n  \\<Longrightarrow> bhc len k = h\"", "lemma bucket_okI:\n  \"(\\<And>k. k \\<in> fst ` set kvs \\<Longrightarrow> bhc len k = h) \\<Longrightarrow> bucket_ok bhc len h kvs\"", "lemma param_HashMap[param]: \"(HashMap, HashMap) \\<in> \n    \\<langle>\\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel\\<rangle>array_rel \\<rightarrow> nat_rel \\<rightarrow> \\<langle>Rk,Rv\\<rangle>ahm_map_rel\"", "lemma param_case_hashmap[param]: \"(case_hashmap, case_hashmap) \\<in>\n    (\\<langle>\\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel\\<rangle>array_rel \\<rightarrow> nat_rel \\<rightarrow> R) \\<rightarrow> \n     \\<langle>Rk,Rv\\<rangle>ahm_map_rel \\<rightarrow> R\"", "lemma rec_hashmap_is_case[simp]: \"rec_hashmap = case_hashmap\"", "lemma ahm_invar_auxD:\n  assumes \"ahm_invar_aux bhc n a\"\n  shows \"\\<And>h. h < array_length a \\<Longrightarrow> \n            bucket_ok bhc (array_length a) h (array_get a h)\" and\n        \"\\<And>h. h < array_length a \\<Longrightarrow> \n            list_map_invar (array_get a h)\" and\n        \"n = array_foldl (\\<lambda>_ n kvs. n + length kvs) 0 a\" and \n        \"array_length a > 1\"", "lemma ahm_invar_auxE:\n  assumes \"ahm_invar_aux bhc n a\"\n  obtains \"\\<forall>h. h < array_length a \\<longrightarrow> \n      bucket_ok bhc (array_length a) h (array_get a h) \\<and> \n      list_map_invar (array_get a h)\" and\n  \"n = array_foldl (\\<lambda>_ n kvs. n + length kvs) 0 a\" and \n  \"array_length a > 1\"", "lemma ahm_invar_auxI:\n  \"\\<lbrakk> \\<And>h. h < array_length a \\<Longrightarrow> \n         bucket_ok bhc (array_length a) h (array_get a h);\n     \\<And>h. h < array_length a \\<Longrightarrow> list_map_invar (array_get a h);\n     n = array_foldl (\\<lambda>_ n kvs. n + length kvs) 0 a; array_length a > 1 \\<rbrakk>\n  \\<Longrightarrow> ahm_invar_aux bhc n a\"", "lemma ahm_invar_distinct_fst_concatD:\n  assumes inv: \"ahm_invar_aux bhc n (Array xs)\"\n  shows \"distinct (map fst (concat xs))\"", "lemma list_map_lookup_is_map_of:\n     \"list_map_lookup (=) k l = map_of l k\"", "lemma ahm_\\<alpha>_aux_def2: \"ahm_\\<alpha>_aux bhc a = (\\<lambda>k. map_of (array_get a \n    (bhc (array_length a) k)) k)\"", "lemma ahm_\\<alpha>_def2: \"ahm_\\<alpha> bhc (HashMap a n) = ahm_\\<alpha>_aux bhc a\"", "lemma finite_dom_ahm_\\<alpha>_aux:\n  assumes \"is_bounded_hashcode Id (=) bhc\" \"ahm_invar_aux bhc n a\"\n  shows \"finite (dom (ahm_\\<alpha>_aux bhc a))\"", "lemma ahm_\\<alpha>_aux_new_array[simp]:\n  assumes bhc: \"is_bounded_hashcode Id (=) bhc\" \"1 < sz\"\n  shows \"ahm_\\<alpha>_aux bhc (new_array [] sz) k = None\"", "lemma ahm_\\<alpha>_aux_conv_map_of_concat:\n  assumes bhc: \"is_bounded_hashcode Id (=) bhc\"\n  assumes inv: \"ahm_invar_aux bhc n (Array xs)\"\n  shows \"ahm_\\<alpha>_aux bhc (Array xs) = map_of (concat xs)\"", "lemma ahm_invar_aux_card_dom_ahm_\\<alpha>_auxD:\n  assumes bhc: \"is_bounded_hashcode Id (=) bhc\"\n  assumes inv: \"ahm_invar_aux bhc n a\"\n  shows \"card (dom (ahm_\\<alpha>_aux bhc a)) = n\"", "lemma finite_dom_ahm_\\<alpha>:\n  assumes \"is_bounded_hashcode Id (=) bhc\" \"ahm_invar bhc hm\"\n  shows \"finite (dom (ahm_\\<alpha> bhc hm))\"", "lemma ahm_invar_aux_new_array:\n  assumes \"n > 1\"\n  shows \"ahm_invar_aux bhc 0 (new_array [] n)\"", "lemma ahm_invar_new_hashmap_with:\n  \"n > 1 \\<Longrightarrow> ahm_invar bhc (new_hashmap_with n)\"", "lemma ahm_\\<alpha>_new_hashmap_with:\n  assumes \"is_bounded_hashcode Id (=) bhc\" and \"n > 1\"\n  shows \"Map.empty = ahm_\\<alpha> bhc (new_hashmap_with n)\"", "lemma ahm_empty_impl:\n  assumes bhc: \"is_bounded_hashcode Id (=) bhc\"\n  assumes def_size: \"def_size > 1\"\n  shows \"(ahm_empty def_size, Map.empty) \\<in> ahm_map_rel' bhc\"", "lemma param_ahm_empty[param]: \n  assumes def_size: \"(def_size, def_size') \\<in> nat_rel\"\n  shows \"(ahm_empty def_size ,ahm_empty def_size') \\<in> \n      \\<langle>Rk,Rv\\<rangle>ahm_map_rel\"", "lemma autoref_ahm_empty[autoref_rules]:\n  fixes Rk :: \"('kc\\<times>'ka) set\"\n  assumes bhc: \"SIDE_GEN_ALGO (is_bounded_hashcode Rk eq bhc)\"\n  assumes def_size: \"SIDE_GEN_ALGO (is_valid_def_hm_size TYPE('kc) def_size)\"\n  shows \"(ahm_empty def_size, op_map_empty) \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc\"", "lemma param_ahm_lookup[param]:\n  assumes bhc: \"is_bounded_hashcode Rk eq bhc\"\n  defines bhc'_def: \"bhc' \\<equiv> abstract_bounded_hashcode Rk bhc\"\n  assumes inv: \"ahm_invar bhc' m'\"\n  assumes K: \"(k,k') \\<in> Rk\"\n  assumes M: \"(m,m') \\<in> \\<langle>Rk,Rv\\<rangle>ahm_map_rel\"\n  shows \"(ahm_lookup eq bhc k m, ahm_lookup (=) bhc' k' m') \\<in> \n             \\<langle>Rv\\<rangle>option_rel\"", "lemma ahm_lookup_impl:\n  assumes bhc: \"is_bounded_hashcode Id (=) bhc\"\n  shows \"(ahm_lookup (=) bhc, op_map_lookup) \\<in> Id \\<rightarrow> ahm_map_rel' bhc \\<rightarrow> Id\"", "lemma autoref_ahm_lookup[autoref_rules]:\n  assumes \n    bhc[unfolded autoref_tag_defs]: \"SIDE_GEN_ALGO (is_bounded_hashcode Rk eq bhc)\"\n  shows \"(ahm_lookup eq bhc, op_map_lookup) \n    \\<in> Rk \\<rightarrow> \\<langle>Rk,Rv\\<rangle>ahm_rel bhc \\<rightarrow> \\<langle>Rv\\<rangle>option_rel\"", "lemma param_ahm_iteratei_aux[param]:\n  \"(ahm_iteratei_aux,ahm_iteratei_aux) \\<in> \\<langle>\\<langle>Ra\\<rangle>list_rel\\<rangle>array_rel \\<rightarrow>\n       (Rb \\<rightarrow> bool_rel) \\<rightarrow> (Ra \\<rightarrow> Rb \\<rightarrow> Rb) \\<rightarrow> Rb \\<rightarrow> Rb\"", "lemma param_ahm_iteratei[param]:\n  \"(ahm_iteratei,ahm_iteratei) \\<in> \\<langle>Rk,Rv\\<rangle>ahm_map_rel \\<rightarrow>\n       (Rb \\<rightarrow> bool_rel) \\<rightarrow> (\\<langle>Rk,Rv\\<rangle>prod_rel \\<rightarrow> Rb \\<rightarrow> Rb) \\<rightarrow> Rb \\<rightarrow> Rb\"", "lemma param_ahm_to_list[param]:\n  \"(ahm_to_list,ahm_to_list) \\<in> \n       \\<langle>Rk, Rv\\<rangle>ahm_map_rel \\<rightarrow> \\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel\"", "lemma ahm_to_list_distinct[simp,intro]:\n  assumes bhc: \"is_bounded_hashcode Id (=) bhc\"\n  assumes inv: \"ahm_invar bhc m\"\n  shows \"distinct (ahm_to_list m)\"", "lemma set_ahm_to_list:\n  assumes bhc: \"is_bounded_hashcode Id (=) bhc\"\n  assumes ref: \"(m,m') \\<in> ahm_map_rel' bhc\"\n  shows \"map_to_set m' = set (ahm_to_list m)\"", "lemma ahm_iteratei_aux_impl:\n  assumes inv: \"ahm_invar_aux bhc n a\"\n  and bhc: \"is_bounded_hashcode Id (=) bhc\"\n  shows \"map_iterator (ahm_iteratei_aux a) (ahm_\\<alpha>_aux bhc a)\"", "lemma ahm_iteratei_impl:\n  assumes inv: \"ahm_invar bhc m\"\n  and bhc: \"is_bounded_hashcode Id (=) bhc\"\n  shows \"map_iterator (ahm_iteratei m) (ahm_\\<alpha> bhc m)\"", "lemma autoref_ahm_is_iterator[autoref_ga_rules]:\n  (*assumes eq: \"GEN_OP_tag ((eq,OP (=) ::: (Rk \\<rightarrow> Rk \\<rightarrow> bool_rel)) \\<in> (Rk \\<rightarrow> Rk \\<rightarrow> bool_rel))\"*)\n  assumes bhc: \"GEN_ALGO_tag (is_bounded_hashcode Rk eq bhc)\"\n  shows \"is_map_to_list Rk Rv (ahm_rel bhc) ahm_to_list\"", "lemma ahm_iteratei_aux_code[code]:\n  \"ahm_iteratei_aux a c f \\<sigma> = idx_iteratei array_get array_length a c \n       (\\<lambda>x. foldli x c f) \\<sigma>\"", "lemma array_length_ahm_rehash_aux':\n  \"array_length (ahm_rehash_aux' bhc n kv a) = array_length a\"", "lemma ahm_rehash_aux'_preserves_ahm_invar_aux:\n  assumes inv: \"ahm_invar_aux bhc n a\"\n  and bhc: \"is_bounded_hashcode Id (=) bhc\"\n  and fresh: \"k \\<notin> fst ` set (array_get a (bhc (array_length a) k))\"\n  shows \"ahm_invar_aux bhc (Suc n) (ahm_rehash_aux' bhc (array_length a) (k, v) a)\"\n  (is \"ahm_invar_aux bhc _ ?a\")", "lemma ahm_rehash_aux_correct:\n  fixes a :: \"('k\\<times>'v) list array\"\n  assumes bhc: \"is_bounded_hashcode Id (=) bhc\"\n  and inv: \"ahm_invar_aux bhc n a\"\n  and \"sz > 1\"\n  shows \"ahm_invar_aux bhc n (ahm_rehash_aux bhc a sz)\" (is \"?thesis1\")\n  and \"ahm_\\<alpha>_aux bhc (ahm_rehash_aux bhc a sz) = ahm_\\<alpha>_aux bhc a\" (is \"?thesis2\")", "lemma ahm_rehash_correct:\n  fixes hm :: \"('k, 'v) hashmap\"\n  assumes bhc: \"is_bounded_hashcode Id (=) bhc\"\n  and inv: \"ahm_invar bhc hm\"\n  and \"sz > 1\"\n  shows \"ahm_invar bhc (ahm_rehash bhc hm sz)\" \n        \"ahm_\\<alpha> bhc (ahm_rehash bhc hm sz) = ahm_\\<alpha> bhc hm\"", "lemma param_hm_grow[param]:\n  \"(hm_grow, hm_grow) \\<in> \\<langle>Rk,Rv\\<rangle>ahm_map_rel \\<rightarrow> nat_rel\"", "lemma param_ahm_rehash_aux'[param]:\n  assumes \"is_bounded_hashcode Rk eq bhc\"\n  assumes \"1 < n\"\n  assumes \"(bhc,bhc') \\<in> nat_rel \\<rightarrow> Rk \\<rightarrow> nat_rel\"\n  assumes \"(n,n') \\<in> nat_rel\" and \"n = array_length a\"\n  assumes \"(kv,kv') \\<in> \\<langle>Rk,Rv\\<rangle>prod_rel\"\n  assumes \"(a,a') \\<in> \\<langle>\\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel\\<rangle>array_rel\"\n  shows \"(ahm_rehash_aux' bhc n kv a, ahm_rehash_aux' bhc' n' kv' a') \\<in>\n             \\<langle>\\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel\\<rangle>array_rel\"", "lemma param_new_array[param]: \n    \"(new_array, new_array) \\<in> R \\<rightarrow> nat_rel \\<rightarrow> \\<langle>R\\<rangle>array_rel\"", "lemma param_foldli_induct:\n  assumes l: \"(l,l') \\<in> \\<langle>Ra\\<rangle>list_rel\"\n  assumes c: \"(c,c') \\<in> Rb \\<rightarrow> bool_rel\"\n  assumes \\<sigma>: \"(\\<sigma>,\\<sigma>') \\<in> Rb\"\n  assumes P\\<sigma>: \"P \\<sigma> \\<sigma>'\"\n  assumes f: \"\\<And>a a' b b'. (a,a')\\<in>Ra \\<Longrightarrow> (b,b')\\<in>Rb \\<Longrightarrow> c b \\<Longrightarrow> c' b' \\<Longrightarrow> \n                           P b b' \\<Longrightarrow> (f a b, f' a' b') \\<in> Rb \\<and> \n                          P (f a b) (f' a' b')\"\n  shows \"(foldli l c f \\<sigma>, foldli l' c' f' \\<sigma>') \\<in> Rb\"", "lemma param_foldli_induct_nocond:\n  assumes l: \"(l,l') \\<in> \\<langle>Ra\\<rangle>list_rel\"\n  assumes \\<sigma>: \"(\\<sigma>,\\<sigma>') \\<in> Rb\"\n  assumes P\\<sigma>: \"P \\<sigma> \\<sigma>'\"\n  assumes f: \"\\<And>a a' b b'. (a,a')\\<in>Ra \\<Longrightarrow> (b,b')\\<in>Rb \\<Longrightarrow> P b b' \\<Longrightarrow> \n                  (f a b, f' a' b') \\<in> Rb \\<and> P (f a b) (f' a' b')\"\n  shows \"(foldli l (\\<lambda>_. True) f \\<sigma>, foldli l' (\\<lambda>_. True) f' \\<sigma>') \\<in> Rb\"", "lemma param_ahm_rehash_aux[param]:\n  assumes bhc: \"is_bounded_hashcode Rk eq bhc\"\n  assumes bhc_rel: \"(bhc,bhc') \\<in> nat_rel \\<rightarrow> Rk \\<rightarrow> nat_rel\"\n  assumes A: \"(a,a') \\<in> \\<langle>\\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel\\<rangle>array_rel\"\n  assumes N: \"(n,n') \\<in> nat_rel\" \"1 < n\"\n  shows \"(ahm_rehash_aux bhc a n, ahm_rehash_aux bhc' a' n') \\<in> \n        \\<langle>\\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel\\<rangle>array_rel\"", "lemma param_ahm_rehash[param]:\n  assumes bhc: \"is_bounded_hashcode Rk eq bhc\"\n  assumes bhc_rel: \"(bhc,bhc') \\<in> nat_rel \\<rightarrow> Rk \\<rightarrow> nat_rel\"\n  assumes M: \"(m,m') \\<in> \\<langle>Rk,Rv\\<rangle>ahm_map_rel\"\n  assumes N: \"(n,n') \\<in> nat_rel\" \"1 < n\"\n  shows \"(ahm_rehash bhc m n, ahm_rehash bhc' m' n') \\<in>\n             \\<langle>Rk,Rv\\<rangle>ahm_map_rel\"", "lemma param_load_factor[param]:\n  \"(load_factor, load_factor) \\<in> nat_rel\"", "lemma param_ahm_filled[param]: \n    \"(ahm_filled, ahm_filled) \\<in> \\<langle>Rk,Rv\\<rangle>ahm_map_rel \\<rightarrow> bool_rel\"", "lemma param_ahm_update_aux[param]:\n  assumes bhc: \"is_bounded_hashcode Rk eq bhc\"\n  assumes bhc_rel: \"(bhc,bhc') \\<in> nat_rel \\<rightarrow> Rk \\<rightarrow> nat_rel\"\n  assumes inv: \"ahm_invar bhc' m'\"\n  assumes K: \"(k,k') \\<in> Rk\"\n  assumes V: \"(v,v') \\<in> Rv\"\n  assumes M: \"(m,m') \\<in> \\<langle>Rk,Rv\\<rangle>ahm_map_rel\"\n  shows \"(ahm_update_aux eq bhc m k v, \n          ahm_update_aux (=) bhc' m' k' v' ) \\<in> \\<langle>Rk,Rv\\<rangle>ahm_map_rel\"", "lemma param_ahm_update[param]:\n  assumes bhc: \"is_bounded_hashcode Rk eq bhc\"\n  assumes bhc_rel: \"(bhc,bhc') \\<in> nat_rel \\<rightarrow> Rk \\<rightarrow> nat_rel\"\n  assumes inv: \"ahm_invar bhc' m'\"\n  assumes K: \"(k,k') \\<in> Rk\"\n  assumes V: \"(v,v') \\<in> Rv\"\n  assumes M: \"(m,m') \\<in> \\<langle>Rk,Rv\\<rangle>ahm_map_rel\"\n  shows \"(ahm_update eq bhc k v m, ahm_update (=) bhc' k' v' m') \\<in> \n             \\<langle>Rk,Rv\\<rangle>ahm_map_rel\"", "lemma length_list_map_update:\n  \"length (list_map_update (=) k v xs) =\n    (if list_map_lookup (=) k xs = None then Suc (length xs) else length xs)\"\n        (is \"?l_new = _\")", "lemma length_list_map_delete:\n  \"length (list_map_delete (=) k xs) =\n    (if list_map_lookup (=) k xs = None then length xs else length xs - 1)\"\n        (is \"?l_new = _\")", "lemma ahm_update_impl:\n  assumes bhc: \"is_bounded_hashcode Id (=) bhc\"\n  shows \"(ahm_update (=) bhc, op_map_update) \\<in> (Id::('k\\<times>'k) set) \\<rightarrow> \n              (Id::('v\\<times>'v) set) \\<rightarrow> ahm_map_rel' bhc \\<rightarrow> ahm_map_rel' bhc\"", "lemma autoref_ahm_update[autoref_rules]:\n  assumes bhc[unfolded autoref_tag_defs]: \n    \"SIDE_GEN_ALGO (is_bounded_hashcode Rk eq bhc)\"\n  shows \"(ahm_update eq bhc, op_map_update) \\<in> \n              Rk \\<rightarrow> Rv \\<rightarrow> \\<langle>Rk,Rv\\<rangle>ahm_rel bhc \\<rightarrow> \\<langle>Rk,Rv\\<rangle>ahm_rel bhc\"", "lemma param_ahm_delete[param]:\n  (*assumes eq: \"(eq,(=)) \\<in> Rk \\<rightarrow> Rk \\<rightarrow> bool_rel\"*)\n  assumes isbhc: \"is_bounded_hashcode Rk eq bhc\"\n  assumes bhc: \"(bhc,bhc') \\<in> nat_rel \\<rightarrow> Rk \\<rightarrow> nat_rel\"\n  assumes inv: \"ahm_invar bhc' m'\"\n  assumes K: \"(k,k') \\<in> Rk\"\n  assumes M: \"(m,m') \\<in> \\<langle>Rk,Rv\\<rangle>ahm_map_rel\"\n  shows\n  \"(ahm_delete eq bhc k m, ahm_delete (=) bhc' k' m') \\<in> \n       \\<langle>Rk,Rv\\<rangle>ahm_map_rel\"", "lemma ahm_delete_impl:\n  assumes bhc: \"is_bounded_hashcode Id (=) bhc\"\n  shows \"(ahm_delete (=) bhc, op_map_delete) \\<in> (Id::('k\\<times>'k) set) \\<rightarrow> \n              ahm_map_rel' bhc \\<rightarrow> ahm_map_rel' bhc\"", "lemma autoref_ahm_delete[autoref_rules]:\n  assumes bhc[unfolded autoref_tag_defs]: \n    \"SIDE_GEN_ALGO (is_bounded_hashcode Rk eq bhc)\"\n  shows \"(ahm_delete eq bhc, op_map_delete) \\<in> \n              Rk \\<rightarrow> \\<langle>Rk,Rv\\<rangle>ahm_rel bhc \\<rightarrow> \\<langle>Rk,Rv\\<rangle>ahm_rel bhc\"", "lemma param_ahm_isEmpty[param]: \n    \"(ahm_isEmpty, ahm_isEmpty) \\<in> \\<langle>Rk,Rv\\<rangle>ahm_map_rel \\<rightarrow> bool_rel\"", "lemma param_ahm_isSng[param]: \n    \"(ahm_isSng, ahm_isSng) \\<in> \\<langle>Rk,Rv\\<rangle>ahm_map_rel \\<rightarrow> bool_rel\"", "lemma param_ahm_size[param]: \n    \"(ahm_size, ahm_size) \\<in> \\<langle>Rk,Rv\\<rangle>ahm_map_rel \\<rightarrow> nat_rel\"", "lemma ahm_isEmpty_impl:\n  assumes \"is_bounded_hashcode Id (=) bhc\"\n  shows \"(ahm_isEmpty, op_map_isEmpty) \\<in> ahm_map_rel' bhc \\<rightarrow> bool_rel\"", "lemma ahm_isSng_impl:\n  assumes \"is_bounded_hashcode Id (=) bhc\"\n  shows \"(ahm_isSng, op_map_isSng) \\<in> ahm_map_rel' bhc \\<rightarrow> bool_rel\"", "lemma ahm_size_impl:\n  assumes \"is_bounded_hashcode Id (=) bhc\"\n  shows \"(ahm_size, op_map_size) \\<in> ahm_map_rel' bhc \\<rightarrow> nat_rel\"", "lemma autoref_ahm_isEmpty[autoref_rules]:\n  (*assumes eq: \"GEN_OP eq (=) (Rk \\<rightarrow> Rk \\<rightarrow> bool_rel)\"*)\n  assumes bhc[unfolded autoref_tag_defs]: \n      \"SIDE_GEN_ALGO (is_bounded_hashcode Rk eq bhc)\"\n  shows \"(ahm_isEmpty, op_map_isEmpty) \\<in> \\<langle>Rk,Rv\\<rangle>ahm_rel bhc \\<rightarrow> bool_rel\"", "lemma autoref_ahm_isSng[autoref_rules]:\n  assumes bhc[unfolded autoref_tag_defs]: \n      \"SIDE_GEN_ALGO (is_bounded_hashcode Rk eq bhc)\"\n  shows \"(ahm_isSng, op_map_isSng) \\<in> \\<langle>Rk,Rv\\<rangle>ahm_rel bhc \\<rightarrow> bool_rel\"", "lemma autoref_ahm_size[autoref_rules]:\n  assumes bhc[unfolded autoref_tag_defs]: \n      \"SIDE_GEN_ALGO (is_bounded_hashcode Rk eq bhc)\"\n  shows \"(ahm_size, op_map_size) \\<in> \\<langle>Rk,Rv\\<rangle>ahm_rel bhc \\<rightarrow> nat_rel\"", "lemma ahm_map_rel_sv[relator_props]:\n  assumes SK: \"single_valued Rk\" \n  assumes SV: \"single_valued Rv\"\n  shows \"single_valued (\\<langle>Rk, Rv\\<rangle>ahm_map_rel)\"", "lemma ahm_rel_sv[relator_props]:\n  \"\\<lbrakk>single_valued Rk; single_valued Rv\\<rbrakk> \n  \\<Longrightarrow> single_valued (\\<langle>Rk,Rv\\<rangle>ahm_rel bhc)\"", "lemma rbt_map_rel_finite[relator_props]: \n  assumes A[simplified]: \"GEN_ALGO_tag (is_bounded_hashcode Rk eq bhc)\"\n  shows \"finite_map_rel (\\<langle>Rk,Rv\\<rangle>ahm_rel bhc)\"", "lemma pi_ahm[icf_proper_iteratorI]: \n  \"proper_it (ahm_iteratei m) (ahm_iteratei m)\"", "lemma pi'_ahm[icf_proper_iteratorI]: \n  \"proper_it' ahm_iteratei ahm_iteratei\"", "lemmas autoref_ahm_rules = \n  autoref_ahm_empty \n  autoref_ahm_lookup \n  autoref_ahm_update\n  autoref_ahm_delete\n  autoref_ahm_isEmpty\n  autoref_ahm_isSng\n  autoref_ahm_size", "lemmas autoref_ahm_rules_hashable[autoref_rules_raw]\n  = autoref_ahm_rules[where Rk=\"Rk\"] for Rk :: \"(_\\<times>_::hashable) set\""], "translations": [["", "lemma ahm_map_rel_def: \"\\<langle>Rk,Rv\\<rangle> ahm_map_rel \\<equiv> \n{(HashMap a n, HashMap a' n)| a a' n n'.\n         (a,a') \\<in> \\<langle>\\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel\\<rangle>array_rel \\<and> (n,n') \\<in> Id}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>Rk, Rv\\<rangle>ahm_map_rel \\<equiv>\n    {uu_.\n     \\<exists>a a' n n'.\n        uu_ = (HashMap a n, HashMap a' n) \\<and>\n        (a, a')\n        \\<in> \\<langle>\\<langle>Rk \\<times>\\<^sub>r\n                                Rv\\<rangle>list_rel\\<rangle>array_rel \\<and>\n        (n, n') \\<in> nat_rel}", "unfolding relAPP_def ahm_map_rel_def_internal"], ["proof (prove)\ngoal (1 subgoal):\n 1. {uu_.\n     \\<exists>a a' n n'.\n        uu_ = (HashMap a n, HashMap a' n) \\<and>\n        (a, a') \\<in> array_rel (list_rel (prod_rel Rk Rv)) \\<and>\n        (n, n') \\<in> nat_rel} \\<equiv>\n    {uu_.\n     \\<exists>a a' n n'.\n        uu_ = (HashMap a n, HashMap a' n) \\<and>\n        (a, a') \\<in> array_rel (list_rel (prod_rel Rk Rv)) \\<and>\n        (n, n') \\<in> nat_rel}", "."], ["", "definition ahm_map_rel'_def: \n  \"ahm_map_rel' bhc \\<equiv> br (ahm_\\<alpha> bhc) (ahm_invar bhc)\""], ["", "definition ahm_rel_def_internal: \"ahm_rel bhc Rk Rv = \n    \\<langle>Rk,Rv\\<rangle> ahm_map_rel O ahm_map_rel' (abstract_bounded_hashcode Rk bhc)\""], ["", "lemma ahm_rel_def: \"\\<langle>Rk, Rv\\<rangle> ahm_rel bhc \\<equiv>\n     \\<langle>Rk,Rv\\<rangle> ahm_map_rel O ahm_map_rel' (abstract_bounded_hashcode Rk bhc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>Rk, Rv\\<rangle>ahm_rel bhc \\<equiv>\n    \\<langle>Rk, Rv\\<rangle>ahm_map_rel O\n    ahm_map_rel' (abstract_bounded_hashcode Rk bhc)", "unfolding relAPP_def ahm_rel_def_internal"], ["proof (prove)\ngoal (1 subgoal):\n 1. ahm_map_rel Rk Rv O\n    ahm_map_rel' (abstract_bounded_hashcode Rk bhc) \\<equiv>\n    ahm_map_rel Rk Rv O ahm_map_rel' (abstract_bounded_hashcode Rk bhc)", "."], ["", "lemmas [autoref_rel_intf] = REL_INTFI[of \"ahm_rel bhc\" i_map] for bhc"], ["", "abbreviation \"dflt_ahm_rel \\<equiv> ahm_rel bounded_hashcode_nat\""], ["", "primrec ahm_iteratei_aux :: \"(('k\\<times>'v) list array) \\<Rightarrow> ('k\\<times>'v, '\\<sigma>) set_iterator\"\nwhere \"ahm_iteratei_aux (Array xs) c f = foldli (concat xs) c f\""], ["", "primrec ahm_iteratei :: \"(('k, 'v) hashmap) \\<Rightarrow> (('k\\<times>'v), '\\<sigma>) set_iterator\"\nwhere\n  \"ahm_iteratei (HashMap a n) = ahm_iteratei_aux a\""], ["", "definition ahm_rehash_aux' :: \"'k bhc \\<Rightarrow> nat \\<Rightarrow> 'k\\<times>'v \\<Rightarrow> \n    ('k\\<times>'v) list array \\<Rightarrow> ('k\\<times>'v) list array\"\nwhere\n  \"ahm_rehash_aux' bhc n kv a =\n   (let h = bhc n (fst kv)\n    in array_set a h (kv # array_get a h))\""], ["", "definition ahm_rehash_aux :: \"'k bhc \\<Rightarrow> ('k\\<times>'v) list array \\<Rightarrow> nat \\<Rightarrow> \n    ('k\\<times>'v) list array\"\nwhere\n  \"ahm_rehash_aux bhc a sz = ahm_iteratei_aux a (\\<lambda>x. True) \n       (ahm_rehash_aux' bhc sz) (new_array [] sz)\""], ["", "primrec ahm_rehash :: \"'k bhc \\<Rightarrow> ('k,'v) hashmap \\<Rightarrow> nat \\<Rightarrow> ('k,'v) hashmap\"\nwhere \"ahm_rehash bhc (HashMap a n) sz = HashMap (ahm_rehash_aux bhc a sz) n\""], ["", "primrec hm_grow :: \"('k,'v) hashmap \\<Rightarrow> nat\"\nwhere \"hm_grow (HashMap a n) = 2 * array_length a + 3\""], ["", "primrec ahm_filled :: \"('k,'v) hashmap \\<Rightarrow> bool\"\nwhere \"ahm_filled (HashMap a n) = (array_length a * load_factor \\<le> n * 100)\""], ["", "primrec ahm_update_aux :: \"'k eq \\<Rightarrow> 'k bhc \\<Rightarrow> ('k,'v) hashmap \\<Rightarrow> \n    'k \\<Rightarrow> 'v \\<Rightarrow> ('k, 'v) hashmap\"\nwhere\n  \"ahm_update_aux eq bhc (HashMap a n) k v = \n  (let h = bhc (array_length a) k;\n       m = array_get a h;\n       insert = list_map_lookup eq k m = None\n   in HashMap (array_set a h (list_map_update eq k v m)) \n       (if insert then n + 1 else n))\""], ["", "definition ahm_update :: \"'k eq \\<Rightarrow> 'k bhc \\<Rightarrow> 'k \\<Rightarrow> 'v \\<Rightarrow> \n    ('k, 'v) hashmap \\<Rightarrow> ('k, 'v) hashmap\"\nwhere\n  \"ahm_update eq bhc k v hm = \n   (let hm' = ahm_update_aux eq bhc hm k v\n    in (if ahm_filled hm' then ahm_rehash bhc hm' (hm_grow hm') else hm'))\""], ["", "primrec ahm_delete :: \"'k eq \\<Rightarrow> 'k bhc \\<Rightarrow> 'k \\<Rightarrow> \n    ('k,'v) hashmap \\<Rightarrow> ('k,'v) hashmap\"\nwhere\n  \"ahm_delete eq bhc k (HashMap a n) =\n  (let h = bhc (array_length a) k;\n       m = array_get a h;\n       deleted = (list_map_lookup eq k m \\<noteq> None)\n   in HashMap (array_set a h (list_map_delete eq k m)) (if deleted then n - 1 else n))\""], ["", "primrec ahm_isEmpty :: \"('k,'v) hashmap \\<Rightarrow> bool\" where\n  \"ahm_isEmpty (HashMap _ n) = (n = 0)\""], ["", "primrec ahm_isSng :: \"('k,'v) hashmap \\<Rightarrow> bool\" where\n  \"ahm_isSng (HashMap _ n) = (n = 1)\""], ["", "primrec ahm_size :: \"('k,'v) hashmap \\<Rightarrow> nat\" where\n  \"ahm_size (HashMap _ n) = n\""], ["", "lemma hm_grow_gt_1 [iff]:\n  \"Suc 0 < hm_grow hm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc 0 < hm_grow hm", "by(cases hm)(simp)"], ["", "lemma bucket_ok_Nil [simp]: \"bucket_ok bhc len h [] = True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bucket_ok bhc len h [] = True", "by(simp add: bucket_ok_def)"], ["", "lemma bucket_okD:\n  \"\\<lbrakk> bucket_ok bhc len h xs; (k, v) \\<in> set xs \\<rbrakk>\n  \\<Longrightarrow> bhc len k = h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bucket_ok bhc len h xs; (k, v) \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> bhc len k = h", "by(auto simp add: bucket_ok_def)"], ["", "lemma bucket_okI:\n  \"(\\<And>k. k \\<in> fst ` set kvs \\<Longrightarrow> bhc len k = h) \\<Longrightarrow> bucket_ok bhc len h kvs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k.\n        k \\<in> fst ` set kvs \\<Longrightarrow>\n        bhc len k = h) \\<Longrightarrow>\n    bucket_ok bhc len h kvs", "by(simp add: bucket_ok_def)"], ["", "subsection \\<open>Parametricity\\<close>"], ["", "lemma param_HashMap[param]: \"(HashMap, HashMap) \\<in> \n    \\<langle>\\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel\\<rangle>array_rel \\<rightarrow> nat_rel \\<rightarrow> \\<langle>Rk,Rv\\<rangle>ahm_map_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (HashMap, HashMap)\n    \\<in> \\<langle>\\<langle>Rk \\<times>\\<^sub>r\n                            Rv\\<rangle>list_rel\\<rangle>array_rel \\<rightarrow>\n          nat_rel \\<rightarrow> \\<langle>Rk, Rv\\<rangle>ahm_map_rel", "unfolding ahm_map_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (HashMap, HashMap)\n    \\<in> \\<langle>\\<langle>Rk \\<times>\\<^sub>r\n                            Rv\\<rangle>list_rel\\<rangle>array_rel \\<rightarrow>\n          nat_rel \\<rightarrow>\n          {uu_.\n           \\<exists>a a' n n'.\n              uu_ = (HashMap a n, HashMap a' n) \\<and>\n              (a, a')\n              \\<in> \\<langle>\\<langle>Rk \\<times>\\<^sub>r\nRv\\<rangle>list_rel\\<rangle>array_rel \\<and>\n              (n, n') \\<in> nat_rel}", "by force"], ["", "lemma param_case_hashmap[param]: \"(case_hashmap, case_hashmap) \\<in>\n    (\\<langle>\\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel\\<rangle>array_rel \\<rightarrow> nat_rel \\<rightarrow> R) \\<rightarrow> \n     \\<langle>Rk,Rv\\<rangle>ahm_map_rel \\<rightarrow> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case_hashmap, case_hashmap)\n    \\<in> (\\<langle>\\<langle>Rk \\<times>\\<^sub>r\n                             Rv\\<rangle>list_rel\\<rangle>array_rel \\<rightarrow>\n           nat_rel \\<rightarrow> R) \\<rightarrow>\n          \\<langle>Rk, Rv\\<rangle>ahm_map_rel \\<rightarrow> R", "unfolding ahm_map_rel_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case_hashmap, case_hashmap)\n    \\<in> (\\<langle>\\<langle>Rk \\<times>\\<^sub>r\n                             Rv\\<rangle>list_rel\\<rangle>array_rel \\<rightarrow>\n           nat_rel \\<rightarrow> R) \\<rightarrow>\n          {uu_.\n           \\<exists>a a' n n'.\n              uu_ = (HashMap a n, HashMap a' n) \\<and>\n              (a, a')\n              \\<in> \\<langle>\\<langle>Rk \\<times>\\<^sub>r\nRv\\<rangle>list_rel\\<rangle>array_rel \\<and>\n              (n, n') \\<in> nat_rel} \\<rightarrow>\n          R", "by (force split: hashmap.split dest: fun_relD)"], ["", "lemma rec_hashmap_is_case[simp]: \"rec_hashmap = case_hashmap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_hashmap = case_hashmap", "by (intro ext, simp split: hashmap.split)"], ["", "subsection \\<open>@{term ahm_invar}\\<close>"], ["", "lemma ahm_invar_auxD:\n  assumes \"ahm_invar_aux bhc n a\"\n  shows \"\\<And>h. h < array_length a \\<Longrightarrow> \n            bucket_ok bhc (array_length a) h (array_get a h)\" and\n        \"\\<And>h. h < array_length a \\<Longrightarrow> \n            list_map_invar (array_get a h)\" and\n        \"n = array_foldl (\\<lambda>_ n kvs. n + length kvs) 0 a\" and \n        \"array_length a > 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<And>h.\n         h < array_length a \\<Longrightarrow>\n         bucket_ok bhc (array_length a) h (array_get a h)) &&&\n     (\\<And>h.\n         h < array_length a \\<Longrightarrow>\n         list_map_invar (array_get a h))) &&&\n    n = array_foldl (\\<lambda>_ n kvs. n + length kvs) 0 a &&&\n    1 < array_length a", "using assms"], ["proof (prove)\nusing this:\n  ahm_invar_aux bhc n a\n\ngoal (1 subgoal):\n 1. ((\\<And>h.\n         h < array_length a \\<Longrightarrow>\n         bucket_ok bhc (array_length a) h (array_get a h)) &&&\n     (\\<And>h.\n         h < array_length a \\<Longrightarrow>\n         list_map_invar (array_get a h))) &&&\n    n = array_foldl (\\<lambda>_ n kvs. n + length kvs) 0 a &&&\n    1 < array_length a", "unfolding ahm_invar_aux_def"], ["proof (prove)\nusing this:\n  (\\<forall>h<array_length a.\n      bucket_ok bhc (array_length a) h (array_get a h) \\<and>\n      list_map_invar (array_get a h)) \\<and>\n  array_foldl (\\<lambda>_ n kvs. n + length kvs) 0 a = n \\<and>\n  1 < array_length a\n\ngoal (1 subgoal):\n 1. ((\\<And>h.\n         h < array_length a \\<Longrightarrow>\n         bucket_ok bhc (array_length a) h (array_get a h)) &&&\n     (\\<And>h.\n         h < array_length a \\<Longrightarrow>\n         list_map_invar (array_get a h))) &&&\n    n = array_foldl (\\<lambda>_ n kvs. n + length kvs) 0 a &&&\n    1 < array_length a", "by auto"], ["", "lemma ahm_invar_auxE:\n  assumes \"ahm_invar_aux bhc n a\"\n  obtains \"\\<forall>h. h < array_length a \\<longrightarrow> \n      bucket_ok bhc (array_length a) h (array_get a h) \\<and> \n      list_map_invar (array_get a h)\" and\n  \"n = array_foldl (\\<lambda>_ n kvs. n + length kvs) 0 a\" and \n  \"array_length a > 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>\\<forall>h<array_length a.\n                 bucket_ok bhc (array_length a) h (array_get a h) \\<and>\n                 list_map_invar (array_get a h);\n      n = array_foldl (\\<lambda>_ n kvs. n + length kvs) 0 a;\n      1 < array_length a\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  ahm_invar_aux bhc n a\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>\\<forall>h<array_length a.\n                 bucket_ok bhc (array_length a) h (array_get a h) \\<and>\n                 list_map_invar (array_get a h);\n      n = array_foldl (\\<lambda>_ n kvs. n + length kvs) 0 a;\n      1 < array_length a\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding ahm_invar_aux_def"], ["proof (prove)\nusing this:\n  (\\<forall>h<array_length a.\n      bucket_ok bhc (array_length a) h (array_get a h) \\<and>\n      list_map_invar (array_get a h)) \\<and>\n  array_foldl (\\<lambda>_ n kvs. n + length kvs) 0 a = n \\<and>\n  1 < array_length a\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>\\<forall>h<array_length a.\n                 bucket_ok bhc (array_length a) h (array_get a h) \\<and>\n                 list_map_invar (array_get a h);\n      n = array_foldl (\\<lambda>_ n kvs. n + length kvs) 0 a;\n      1 < array_length a\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["", "lemma ahm_invar_auxI:\n  \"\\<lbrakk> \\<And>h. h < array_length a \\<Longrightarrow> \n         bucket_ok bhc (array_length a) h (array_get a h);\n     \\<And>h. h < array_length a \\<Longrightarrow> list_map_invar (array_get a h);\n     n = array_foldl (\\<lambda>_ n kvs. n + length kvs) 0 a; array_length a > 1 \\<rbrakk>\n  \\<Longrightarrow> ahm_invar_aux bhc n a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>h.\n                h < array_length a \\<Longrightarrow>\n                bucket_ok bhc (array_length a) h (array_get a h);\n     \\<And>h.\n        h < array_length a \\<Longrightarrow> list_map_invar (array_get a h);\n     n = array_foldl (\\<lambda>_ n kvs. n + length kvs) 0 a;\n     1 < array_length a\\<rbrakk>\n    \\<Longrightarrow> ahm_invar_aux bhc n a", "unfolding ahm_invar_aux_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>h.\n                h < array_length a \\<Longrightarrow>\n                bucket_ok bhc (array_length a) h (array_get a h);\n     \\<And>h.\n        h < array_length a \\<Longrightarrow> list_map_invar (array_get a h);\n     n = array_foldl (\\<lambda>_ n kvs. n + length kvs) 0 a;\n     1 < array_length a\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>h<array_length a.\n                          bucket_ok bhc (array_length a) h\n                           (array_get a h) \\<and>\n                          list_map_invar (array_get a h)) \\<and>\n                      array_foldl (\\<lambda>_ n kvs. n + length kvs) 0 a =\n                      n \\<and>\n                      1 < array_length a", "by blast"], ["", "lemma ahm_invar_distinct_fst_concatD:\n  assumes inv: \"ahm_invar_aux bhc n (Array xs)\"\n  shows \"distinct (map fst (concat xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst (concat xs))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. distinct (map fst (concat xs))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. distinct (map fst (concat xs))", "fix h"], ["proof (state)\ngoal (1 subgoal):\n 1. distinct (map fst (concat xs))", "assume \"h < length xs\""], ["proof (state)\nthis:\n  h < length xs\n\ngoal (1 subgoal):\n 1. distinct (map fst (concat xs))", "with inv"], ["proof (chain)\npicking this:\n  ahm_invar_aux bhc n (Array xs)\n  h < length xs", "have \"bucket_ok bhc (length xs) h (xs ! h)\" and \n                  \"list_map_invar (xs ! h)\""], ["proof (prove)\nusing this:\n  ahm_invar_aux bhc n (Array xs)\n  h < length xs\n\ngoal (1 subgoal):\n 1. bucket_ok bhc (length xs) h (xs ! h) &&& list_map_invar (xs ! h)", "by(simp_all add: ahm_invar_aux_def)"], ["proof (state)\nthis:\n  bucket_ok bhc (length xs) h (xs ! h)\n  list_map_invar (xs ! h)\n\ngoal (1 subgoal):\n 1. distinct (map fst (concat xs))", "}"], ["proof (state)\nthis:\n  ?h2 < length xs \\<Longrightarrow> bucket_ok bhc (length xs) ?h2 (xs ! ?h2)\n  ?h2 < length xs \\<Longrightarrow> list_map_invar (xs ! ?h2)\n\ngoal (1 subgoal):\n 1. distinct (map fst (concat xs))", "note no_junk = this"], ["proof (state)\nthis:\n  ?h2 < length xs \\<Longrightarrow> bucket_ok bhc (length xs) ?h2 (xs ! ?h2)\n  ?h2 < length xs \\<Longrightarrow> list_map_invar (xs ! ?h2)\n\ngoal (1 subgoal):\n 1. distinct (map fst (concat xs))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst (concat xs))", "unfolding map_concat"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (concat (map (map fst) xs))", "proof(rule distinct_concat')"], ["proof (state)\ngoal (3 subgoals):\n 1. distinct (filter (\\<lambda>ys. ys \\<noteq> []) (map (map fst) xs))\n 2. \\<And>ys. ys \\<in> set (map (map fst) xs) \\<Longrightarrow> distinct ys\n 3. \\<And>ys zs.\n       \\<lbrakk>ys \\<in> set (map (map fst) xs);\n        zs \\<in> set (map (map fst) xs); ys \\<noteq> zs\\<rbrakk>\n       \\<Longrightarrow> set ys \\<inter> set zs = {}", "have \"distinct [x\\<leftarrow>xs . x \\<noteq> []]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (filter (\\<lambda>x. x \\<noteq> []) xs)", "unfolding distinct_conv_nth"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length (filter (\\<lambda>x. x \\<noteq> []) xs).\n       \\<forall>j<length (filter (\\<lambda>x. x \\<noteq> []) xs).\n          i \\<noteq> j \\<longrightarrow>\n          filter (\\<lambda>x. x \\<noteq> []) xs ! i \\<noteq>\n          filter (\\<lambda>x. x \\<noteq> []) xs ! j", "proof(intro allI ballI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length (filter (\\<lambda>x. x \\<noteq> []) xs);\n        j < length (filter (\\<lambda>x. x \\<noteq> []) xs);\n        i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> filter (\\<lambda>x. x \\<noteq> []) xs ! i \\<noteq>\n                         filter (\\<lambda>x. x \\<noteq> []) xs ! j", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length (filter (\\<lambda>x. x \\<noteq> []) xs);\n        j < length (filter (\\<lambda>x. x \\<noteq> []) xs);\n        i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> filter (\\<lambda>x. x \\<noteq> []) xs ! i \\<noteq>\n                         filter (\\<lambda>x. x \\<noteq> []) xs ! j", "assume \"i < length [x\\<leftarrow>xs . x \\<noteq> []]\" \"j < length [x\\<leftarrow>xs . x \\<noteq> []]\" \"i \\<noteq> j\""], ["proof (state)\nthis:\n  i < length (filter (\\<lambda>x. x \\<noteq> []) xs)\n  j < length (filter (\\<lambda>x. x \\<noteq> []) xs)\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length (filter (\\<lambda>x. x \\<noteq> []) xs);\n        j < length (filter (\\<lambda>x. x \\<noteq> []) xs);\n        i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> filter (\\<lambda>x. x \\<noteq> []) xs ! i \\<noteq>\n                         filter (\\<lambda>x. x \\<noteq> []) xs ! j", "from filter_nth_ex_nth[OF \\<open>i < length [x\\<leftarrow>xs . x \\<noteq> []]\\<close>]"], ["proof (chain)\npicking this:\n  \\<exists>m\\<ge>i.\n     m < length xs \\<and>\n     filter (\\<lambda>x. x \\<noteq> []) xs ! i = xs ! m \\<and>\n     filter (\\<lambda>x. x \\<noteq> []) (take m xs) =\n     take i (filter (\\<lambda>x. x \\<noteq> []) xs)", "obtain i' where \"i' \\<ge> i\" \"i' < length xs\" and ith: \"[x\\<leftarrow>xs . x \\<noteq> []] ! i = xs ! i'\" \n        and eqi: \"[x\\<leftarrow>take i' xs . x \\<noteq> []] = take i [x\\<leftarrow>xs . x \\<noteq> []]\""], ["proof (prove)\nusing this:\n  \\<exists>m\\<ge>i.\n     m < length xs \\<and>\n     filter (\\<lambda>x. x \\<noteq> []) xs ! i = xs ! m \\<and>\n     filter (\\<lambda>x. x \\<noteq> []) (take m xs) =\n     take i (filter (\\<lambda>x. x \\<noteq> []) xs)\n\ngoal (1 subgoal):\n 1. (\\<And>i'.\n        \\<lbrakk>i \\<le> i'; i' < length xs;\n         filter (\\<lambda>x. x \\<noteq> []) xs ! i = xs ! i';\n         filter (\\<lambda>x. x \\<noteq> []) (take i' xs) =\n         take i (filter (\\<lambda>x. x \\<noteq> []) xs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  i \\<le> i'\n  i' < length xs\n  filter (\\<lambda>x. x \\<noteq> []) xs ! i = xs ! i'\n  filter (\\<lambda>x. x \\<noteq> []) (take i' xs) =\n  take i (filter (\\<lambda>x. x \\<noteq> []) xs)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length (filter (\\<lambda>x. x \\<noteq> []) xs);\n        j < length (filter (\\<lambda>x. x \\<noteq> []) xs);\n        i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> filter (\\<lambda>x. x \\<noteq> []) xs ! i \\<noteq>\n                         filter (\\<lambda>x. x \\<noteq> []) xs ! j", "from filter_nth_ex_nth[OF \\<open>j < length [x\\<leftarrow>xs . x \\<noteq> []]\\<close>]"], ["proof (chain)\npicking this:\n  \\<exists>m\\<ge>j.\n     m < length xs \\<and>\n     filter (\\<lambda>x. x \\<noteq> []) xs ! j = xs ! m \\<and>\n     filter (\\<lambda>x. x \\<noteq> []) (take m xs) =\n     take j (filter (\\<lambda>x. x \\<noteq> []) xs)", "obtain j' where \"j' \\<ge> j\" \"j' < length xs\" and jth: \"[x\\<leftarrow>xs . x \\<noteq> []] ! j = xs ! j'\"\n        and eqj: \"[x\\<leftarrow>take j' xs . x \\<noteq> []] = take j [x\\<leftarrow>xs . x \\<noteq> []]\""], ["proof (prove)\nusing this:\n  \\<exists>m\\<ge>j.\n     m < length xs \\<and>\n     filter (\\<lambda>x. x \\<noteq> []) xs ! j = xs ! m \\<and>\n     filter (\\<lambda>x. x \\<noteq> []) (take m xs) =\n     take j (filter (\\<lambda>x. x \\<noteq> []) xs)\n\ngoal (1 subgoal):\n 1. (\\<And>j'.\n        \\<lbrakk>j \\<le> j'; j' < length xs;\n         filter (\\<lambda>x. x \\<noteq> []) xs ! j = xs ! j';\n         filter (\\<lambda>x. x \\<noteq> []) (take j' xs) =\n         take j (filter (\\<lambda>x. x \\<noteq> []) xs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  j \\<le> j'\n  j' < length xs\n  filter (\\<lambda>x. x \\<noteq> []) xs ! j = xs ! j'\n  filter (\\<lambda>x. x \\<noteq> []) (take j' xs) =\n  take j (filter (\\<lambda>x. x \\<noteq> []) xs)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length (filter (\\<lambda>x. x \\<noteq> []) xs);\n        j < length (filter (\\<lambda>x. x \\<noteq> []) xs);\n        i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> filter (\\<lambda>x. x \\<noteq> []) xs ! i \\<noteq>\n                         filter (\\<lambda>x. x \\<noteq> []) xs ! j", "show \"[x\\<leftarrow>xs . x \\<noteq> []] ! i \\<noteq> [x\\<leftarrow>xs . x \\<noteq> []] ! j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. x \\<noteq> []) xs ! i \\<noteq>\n    filter (\\<lambda>x. x \\<noteq> []) xs ! j", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. x \\<noteq> []) xs ! i =\n    filter (\\<lambda>x. x \\<noteq> []) xs ! j \\<Longrightarrow>\n    False", "assume \"[x\\<leftarrow>xs . x \\<noteq> []] ! i = [x\\<leftarrow>xs . x \\<noteq> []] ! j\""], ["proof (state)\nthis:\n  filter (\\<lambda>x. x \\<noteq> []) xs ! i =\n  filter (\\<lambda>x. x \\<noteq> []) xs ! j\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. x \\<noteq> []) xs ! i =\n    filter (\\<lambda>x. x \\<noteq> []) xs ! j \\<Longrightarrow>\n    False", "hence eq: \"xs ! i' = xs ! j'\""], ["proof (prove)\nusing this:\n  filter (\\<lambda>x. x \\<noteq> []) xs ! i =\n  filter (\\<lambda>x. x \\<noteq> []) xs ! j\n\ngoal (1 subgoal):\n 1. xs ! i' = xs ! j'", "using ith jth"], ["proof (prove)\nusing this:\n  filter (\\<lambda>x. x \\<noteq> []) xs ! i =\n  filter (\\<lambda>x. x \\<noteq> []) xs ! j\n  filter (\\<lambda>x. x \\<noteq> []) xs ! i = xs ! i'\n  filter (\\<lambda>x. x \\<noteq> []) xs ! j = xs ! j'\n\ngoal (1 subgoal):\n 1. xs ! i' = xs ! j'", "by simp"], ["proof (state)\nthis:\n  xs ! i' = xs ! j'\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. x \\<noteq> []) xs ! i =\n    filter (\\<lambda>x. x \\<noteq> []) xs ! j \\<Longrightarrow>\n    False", "from \\<open>i < length [x\\<leftarrow>xs . x \\<noteq> []]\\<close>"], ["proof (chain)\npicking this:\n  i < length (filter (\\<lambda>x. x \\<noteq> []) xs)", "have \"[x\\<leftarrow>xs . x \\<noteq> []] ! i \\<in> set [x\\<leftarrow>xs . x \\<noteq> []]\""], ["proof (prove)\nusing this:\n  i < length (filter (\\<lambda>x. x \\<noteq> []) xs)\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. x \\<noteq> []) xs ! i\n    \\<in> set (filter (\\<lambda>x. x \\<noteq> []) xs)", "by(rule nth_mem)"], ["proof (state)\nthis:\n  filter (\\<lambda>x. x \\<noteq> []) xs ! i\n  \\<in> set (filter (\\<lambda>x. x \\<noteq> []) xs)\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. x \\<noteq> []) xs ! i =\n    filter (\\<lambda>x. x \\<noteq> []) xs ! j \\<Longrightarrow>\n    False", "with ith"], ["proof (chain)\npicking this:\n  filter (\\<lambda>x. x \\<noteq> []) xs ! i = xs ! i'\n  filter (\\<lambda>x. x \\<noteq> []) xs ! i\n  \\<in> set (filter (\\<lambda>x. x \\<noteq> []) xs)", "have \"xs ! i' \\<noteq> []\""], ["proof (prove)\nusing this:\n  filter (\\<lambda>x. x \\<noteq> []) xs ! i = xs ! i'\n  filter (\\<lambda>x. x \\<noteq> []) xs ! i\n  \\<in> set (filter (\\<lambda>x. x \\<noteq> []) xs)\n\ngoal (1 subgoal):\n 1. xs ! i' \\<noteq> []", "by simp"], ["proof (state)\nthis:\n  xs ! i' \\<noteq> []\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. x \\<noteq> []) xs ! i =\n    filter (\\<lambda>x. x \\<noteq> []) xs ! j \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  xs ! i' \\<noteq> []", "obtain kv where \"kv \\<in> set (xs ! i')\""], ["proof (prove)\nusing this:\n  xs ! i' \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>kv.\n        kv \\<in> set (xs ! i') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce simp add: neq_Nil_conv)"], ["proof (state)\nthis:\n  kv \\<in> set (xs ! i')\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. x \\<noteq> []) xs ! i =\n    filter (\\<lambda>x. x \\<noteq> []) xs ! j \\<Longrightarrow>\n    False", "with no_junk[OF \\<open>i' < length xs\\<close>]"], ["proof (chain)\npicking this:\n  bucket_ok bhc (length xs) i' (xs ! i')\n  list_map_invar (xs ! i')\n  kv \\<in> set (xs ! i')", "have \"bhc (length xs) (fst kv) = i'\""], ["proof (prove)\nusing this:\n  bucket_ok bhc (length xs) i' (xs ! i')\n  list_map_invar (xs ! i')\n  kv \\<in> set (xs ! i')\n\ngoal (1 subgoal):\n 1. bhc (length xs) (fst kv) = i'", "by(simp add: bucket_ok_def)"], ["proof (state)\nthis:\n  bhc (length xs) (fst kv) = i'\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. x \\<noteq> []) xs ! i =\n    filter (\\<lambda>x. x \\<noteq> []) xs ! j \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  bhc (length xs) (fst kv) = i'\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. x \\<noteq> []) xs ! i =\n    filter (\\<lambda>x. x \\<noteq> []) xs ! j \\<Longrightarrow>\n    False", "from eq \\<open>kv \\<in> set (xs ! i')\\<close>"], ["proof (chain)\npicking this:\n  xs ! i' = xs ! j'\n  kv \\<in> set (xs ! i')", "have \"kv \\<in> set (xs ! j')\""], ["proof (prove)\nusing this:\n  xs ! i' = xs ! j'\n  kv \\<in> set (xs ! i')\n\ngoal (1 subgoal):\n 1. kv \\<in> set (xs ! j')", "by simp"], ["proof (state)\nthis:\n  kv \\<in> set (xs ! j')\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. x \\<noteq> []) xs ! i =\n    filter (\\<lambda>x. x \\<noteq> []) xs ! j \\<Longrightarrow>\n    False", "with no_junk[OF \\<open>j' < length xs\\<close>]"], ["proof (chain)\npicking this:\n  bucket_ok bhc (length xs) j' (xs ! j')\n  list_map_invar (xs ! j')\n  kv \\<in> set (xs ! j')", "have \"bhc (length xs) (fst kv) = j'\""], ["proof (prove)\nusing this:\n  bucket_ok bhc (length xs) j' (xs ! j')\n  list_map_invar (xs ! j')\n  kv \\<in> set (xs ! j')\n\ngoal (1 subgoal):\n 1. bhc (length xs) (fst kv) = j'", "by(simp add: bucket_ok_def)"], ["proof (state)\nthis:\n  bhc (length xs) (fst kv) = j'\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. x \\<noteq> []) xs ! i =\n    filter (\\<lambda>x. x \\<noteq> []) xs ! j \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  bhc (length xs) (fst kv) = i'\n  bhc (length xs) (fst kv) = j'", "have [simp]: \"i' = j'\""], ["proof (prove)\nusing this:\n  bhc (length xs) (fst kv) = i'\n  bhc (length xs) (fst kv) = j'\n\ngoal (1 subgoal):\n 1. i' = j'", "by simp"], ["proof (state)\nthis:\n  i' = j'\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. x \\<noteq> []) xs ! i =\n    filter (\\<lambda>x. x \\<noteq> []) xs ! j \\<Longrightarrow>\n    False", "from \\<open>i < length [x\\<leftarrow>xs . x \\<noteq> []]\\<close>"], ["proof (chain)\npicking this:\n  i < length (filter (\\<lambda>x. x \\<noteq> []) xs)", "have \"i = length (take i [x\\<leftarrow>xs . x \\<noteq> []])\""], ["proof (prove)\nusing this:\n  i < length (filter (\\<lambda>x. x \\<noteq> []) xs)\n\ngoal (1 subgoal):\n 1. i = length (take i (filter (\\<lambda>x. x \\<noteq> []) xs))", "by simp"], ["proof (state)\nthis:\n  i = length (take i (filter (\\<lambda>x. x \\<noteq> []) xs))\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. x \\<noteq> []) xs ! i =\n    filter (\\<lambda>x. x \\<noteq> []) xs ! j \\<Longrightarrow>\n    False", "also"], ["proof (state)\nthis:\n  i = length (take i (filter (\\<lambda>x. x \\<noteq> []) xs))\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. x \\<noteq> []) xs ! i =\n    filter (\\<lambda>x. x \\<noteq> []) xs ! j \\<Longrightarrow>\n    False", "from eqi eqj"], ["proof (chain)\npicking this:\n  filter (\\<lambda>x. x \\<noteq> []) (take i' xs) =\n  take i (filter (\\<lambda>x. x \\<noteq> []) xs)\n  filter (\\<lambda>x. x \\<noteq> []) (take j' xs) =\n  take j (filter (\\<lambda>x. x \\<noteq> []) xs)", "have \"take i [x\\<leftarrow>xs . x \\<noteq> []] = take j [x\\<leftarrow>xs . x \\<noteq> []]\""], ["proof (prove)\nusing this:\n  filter (\\<lambda>x. x \\<noteq> []) (take i' xs) =\n  take i (filter (\\<lambda>x. x \\<noteq> []) xs)\n  filter (\\<lambda>x. x \\<noteq> []) (take j' xs) =\n  take j (filter (\\<lambda>x. x \\<noteq> []) xs)\n\ngoal (1 subgoal):\n 1. take i (filter (\\<lambda>x. x \\<noteq> []) xs) =\n    take j (filter (\\<lambda>x. x \\<noteq> []) xs)", "by simp"], ["proof (state)\nthis:\n  take i (filter (\\<lambda>x. x \\<noteq> []) xs) =\n  take j (filter (\\<lambda>x. x \\<noteq> []) xs)\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. x \\<noteq> []) xs ! i =\n    filter (\\<lambda>x. x \\<noteq> []) xs ! j \\<Longrightarrow>\n    False", "finally"], ["proof (chain)\npicking this:\n  i = length (take j (filter (\\<lambda>x. x \\<noteq> []) xs))", "show False"], ["proof (prove)\nusing this:\n  i = length (take j (filter (\\<lambda>x. x \\<noteq> []) xs))\n\ngoal (1 subgoal):\n 1. False", "using \\<open>i \\<noteq> j\\<close> \\<open>j < length [x\\<leftarrow>xs . x \\<noteq> []]\\<close>"], ["proof (prove)\nusing this:\n  i = length (take j (filter (\\<lambda>x. x \\<noteq> []) xs))\n  i \\<noteq> j\n  j < length (filter (\\<lambda>x. x \\<noteq> []) xs)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  filter (\\<lambda>x. x \\<noteq> []) xs ! i \\<noteq>\n  filter (\\<lambda>x. x \\<noteq> []) xs ! j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  distinct (filter (\\<lambda>x. x \\<noteq> []) xs)\n\ngoal (3 subgoals):\n 1. distinct (filter (\\<lambda>ys. ys \\<noteq> []) (map (map fst) xs))\n 2. \\<And>ys. ys \\<in> set (map (map fst) xs) \\<Longrightarrow> distinct ys\n 3. \\<And>ys zs.\n       \\<lbrakk>ys \\<in> set (map (map fst) xs);\n        zs \\<in> set (map (map fst) xs); ys \\<noteq> zs\\<rbrakk>\n       \\<Longrightarrow> set ys \\<inter> set zs = {}", "moreover"], ["proof (state)\nthis:\n  distinct (filter (\\<lambda>x. x \\<noteq> []) xs)\n\ngoal (3 subgoals):\n 1. distinct (filter (\\<lambda>ys. ys \\<noteq> []) (map (map fst) xs))\n 2. \\<And>ys. ys \\<in> set (map (map fst) xs) \\<Longrightarrow> distinct ys\n 3. \\<And>ys zs.\n       \\<lbrakk>ys \\<in> set (map (map fst) xs);\n        zs \\<in> set (map (map fst) xs); ys \\<noteq> zs\\<rbrakk>\n       \\<Longrightarrow> set ys \\<inter> set zs = {}", "have \"inj_on (map fst) {x \\<in> set xs. x \\<noteq> []}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (map fst) {x \\<in> set xs. x \\<noteq> []}", "proof(rule inj_onI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {x \\<in> set xs. x \\<noteq> []};\n        y \\<in> {x \\<in> set xs. x \\<noteq> []};\n        map fst x = map fst y\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {x \\<in> set xs. x \\<noteq> []};\n        y \\<in> {x \\<in> set xs. x \\<noteq> []};\n        map fst x = map fst y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume \"x \\<in> {x \\<in> set xs. x \\<noteq> []}\" \"y \\<in> {x \\<in> set xs. x \\<noteq> []}\" \"map fst x = map fst y\""], ["proof (state)\nthis:\n  x \\<in> {x \\<in> set xs. x \\<noteq> []}\n  y \\<in> {x \\<in> set xs. x \\<noteq> []}\n  map fst x = map fst y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {x \\<in> set xs. x \\<noteq> []};\n        y \\<in> {x \\<in> set xs. x \\<noteq> []};\n        map fst x = map fst y\\<rbrakk>\n       \\<Longrightarrow> x = y", "hence \"x \\<in> set xs\" \"y \\<in> set xs\" \"x \\<noteq> []\" \"y \\<noteq> []\""], ["proof (prove)\nusing this:\n  x \\<in> {x \\<in> set xs. x \\<noteq> []}\n  y \\<in> {x \\<in> set xs. x \\<noteq> []}\n  map fst x = map fst y\n\ngoal (1 subgoal):\n 1. (x \\<in> set xs &&& y \\<in> set xs) &&& x \\<noteq> [] &&& y \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  x \\<in> set xs\n  y \\<in> set xs\n  x \\<noteq> []\n  y \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {x \\<in> set xs. x \\<noteq> []};\n        y \\<in> {x \\<in> set xs. x \\<noteq> []};\n        map fst x = map fst y\\<rbrakk>\n       \\<Longrightarrow> x = y", "from \\<open>x \\<in> set xs\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> set xs", "obtain i where \"xs ! i = x\" \"i < length xs\""], ["proof (prove)\nusing this:\n  x \\<in> set xs\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>xs ! i = x; i < length xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding set_conv_nth"], ["proof (prove)\nusing this:\n  x \\<in> {xs ! i |i. i < length xs}\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>xs ! i = x; i < length xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  xs ! i = x\n  i < length xs\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {x \\<in> set xs. x \\<noteq> []};\n        y \\<in> {x \\<in> set xs. x \\<noteq> []};\n        map fst x = map fst y\\<rbrakk>\n       \\<Longrightarrow> x = y", "from \\<open>y \\<in> set xs\\<close>"], ["proof (chain)\npicking this:\n  y \\<in> set xs", "obtain j where \"xs ! j = y\" \"j < length xs\""], ["proof (prove)\nusing this:\n  y \\<in> set xs\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>xs ! j = y; j < length xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding set_conv_nth"], ["proof (prove)\nusing this:\n  y \\<in> {xs ! i |i. i < length xs}\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>xs ! j = y; j < length xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  xs ! j = y\n  j < length xs\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {x \\<in> set xs. x \\<noteq> []};\n        y \\<in> {x \\<in> set xs. x \\<noteq> []};\n        map fst x = map fst y\\<rbrakk>\n       \\<Longrightarrow> x = y", "from \\<open>x \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  x \\<noteq> []", "obtain k v x' where \"x = (k, v) # x'\""], ["proof (prove)\nusing this:\n  x \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>k v x'.\n        x = (k, v) # x' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases x) auto"], ["proof (state)\nthis:\n  x = (k, v) # x'\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {x \\<in> set xs. x \\<noteq> []};\n        y \\<in> {x \\<in> set xs. x \\<noteq> []};\n        map fst x = map fst y\\<rbrakk>\n       \\<Longrightarrow> x = y", "with no_junk[OF \\<open>i < length xs\\<close>] \\<open>xs ! i = x\\<close>"], ["proof (chain)\npicking this:\n  bucket_ok bhc (length xs) i (xs ! i)\n  list_map_invar (xs ! i)\n  xs ! i = x\n  x = (k, v) # x'", "have \"bhc (length xs) k = i\""], ["proof (prove)\nusing this:\n  bucket_ok bhc (length xs) i (xs ! i)\n  list_map_invar (xs ! i)\n  xs ! i = x\n  x = (k, v) # x'\n\ngoal (1 subgoal):\n 1. bhc (length xs) k = i", "by(auto simp add: bucket_ok_def)"], ["proof (state)\nthis:\n  bhc (length xs) k = i\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {x \\<in> set xs. x \\<noteq> []};\n        y \\<in> {x \\<in> set xs. x \\<noteq> []};\n        map fst x = map fst y\\<rbrakk>\n       \\<Longrightarrow> x = y", "moreover"], ["proof (state)\nthis:\n  bhc (length xs) k = i\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {x \\<in> set xs. x \\<noteq> []};\n        y \\<in> {x \\<in> set xs. x \\<noteq> []};\n        map fst x = map fst y\\<rbrakk>\n       \\<Longrightarrow> x = y", "from \\<open>map fst x = map fst y\\<close> \\<open>x = (k, v) # x'\\<close>"], ["proof (chain)\npicking this:\n  map fst x = map fst y\n  x = (k, v) # x'", "obtain v' where \"(k, v') \\<in> set y\""], ["proof (prove)\nusing this:\n  map fst x = map fst y\n  x = (k, v) # x'\n\ngoal (1 subgoal):\n 1. (\\<And>v'.\n        (k, v') \\<in> set y \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  (k, v') \\<in> set y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {x \\<in> set xs. x \\<noteq> []};\n        y \\<in> {x \\<in> set xs. x \\<noteq> []};\n        map fst x = map fst y\\<rbrakk>\n       \\<Longrightarrow> x = y", "with no_junk[OF \\<open>j < length xs\\<close>] \\<open>xs ! j = y\\<close>"], ["proof (chain)\npicking this:\n  bucket_ok bhc (length xs) j (xs ! j)\n  list_map_invar (xs ! j)\n  xs ! j = y\n  (k, v') \\<in> set y", "have \"bhc (length xs) k = j\""], ["proof (prove)\nusing this:\n  bucket_ok bhc (length xs) j (xs ! j)\n  list_map_invar (xs ! j)\n  xs ! j = y\n  (k, v') \\<in> set y\n\ngoal (1 subgoal):\n 1. bhc (length xs) k = j", "by(auto simp add: bucket_ok_def)"], ["proof (state)\nthis:\n  bhc (length xs) k = j\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {x \\<in> set xs. x \\<noteq> []};\n        y \\<in> {x \\<in> set xs. x \\<noteq> []};\n        map fst x = map fst y\\<rbrakk>\n       \\<Longrightarrow> x = y", "ultimately"], ["proof (chain)\npicking this:\n  bhc (length xs) k = i\n  bhc (length xs) k = j", "have \"i = j\""], ["proof (prove)\nusing this:\n  bhc (length xs) k = i\n  bhc (length xs) k = j\n\ngoal (1 subgoal):\n 1. i = j", "by simp"], ["proof (state)\nthis:\n  i = j\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {x \\<in> set xs. x \\<noteq> []};\n        y \\<in> {x \\<in> set xs. x \\<noteq> []};\n        map fst x = map fst y\\<rbrakk>\n       \\<Longrightarrow> x = y", "with \\<open>xs ! i = x\\<close> \\<open>xs ! j = y\\<close>"], ["proof (chain)\npicking this:\n  xs ! i = x\n  xs ! j = y\n  i = j", "show \"x = y\""], ["proof (prove)\nusing this:\n  xs ! i = x\n  xs ! j = y\n  i = j\n\ngoal (1 subgoal):\n 1. x = y", "by simp"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inj_on (map fst) {x \\<in> set xs. x \\<noteq> []}\n\ngoal (3 subgoals):\n 1. distinct (filter (\\<lambda>ys. ys \\<noteq> []) (map (map fst) xs))\n 2. \\<And>ys. ys \\<in> set (map (map fst) xs) \\<Longrightarrow> distinct ys\n 3. \\<And>ys zs.\n       \\<lbrakk>ys \\<in> set (map (map fst) xs);\n        zs \\<in> set (map (map fst) xs); ys \\<noteq> zs\\<rbrakk>\n       \\<Longrightarrow> set ys \\<inter> set zs = {}", "ultimately"], ["proof (chain)\npicking this:\n  distinct (filter (\\<lambda>x. x \\<noteq> []) xs)\n  inj_on (map fst) {x \\<in> set xs. x \\<noteq> []}", "show \"distinct [ys\\<leftarrow>map (map fst) xs . ys \\<noteq> []]\""], ["proof (prove)\nusing this:\n  distinct (filter (\\<lambda>x. x \\<noteq> []) xs)\n  inj_on (map fst) {x \\<in> set xs. x \\<noteq> []}\n\ngoal (1 subgoal):\n 1. distinct (filter (\\<lambda>ys. ys \\<noteq> []) (map (map fst) xs))", "by(simp add: filter_map o_def distinct_map)"], ["proof (state)\nthis:\n  distinct (filter (\\<lambda>ys. ys \\<noteq> []) (map (map fst) xs))\n\ngoal (2 subgoals):\n 1. \\<And>ys. ys \\<in> set (map (map fst) xs) \\<Longrightarrow> distinct ys\n 2. \\<And>ys zs.\n       \\<lbrakk>ys \\<in> set (map (map fst) xs);\n        zs \\<in> set (map (map fst) xs); ys \\<noteq> zs\\<rbrakk>\n       \\<Longrightarrow> set ys \\<inter> set zs = {}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys. ys \\<in> set (map (map fst) xs) \\<Longrightarrow> distinct ys\n 2. \\<And>ys zs.\n       \\<lbrakk>ys \\<in> set (map (map fst) xs);\n        zs \\<in> set (map (map fst) xs); ys \\<noteq> zs\\<rbrakk>\n       \\<Longrightarrow> set ys \\<inter> set zs = {}", "fix ys"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys. ys \\<in> set (map (map fst) xs) \\<Longrightarrow> distinct ys\n 2. \\<And>ys zs.\n       \\<lbrakk>ys \\<in> set (map (map fst) xs);\n        zs \\<in> set (map (map fst) xs); ys \\<noteq> zs\\<rbrakk>\n       \\<Longrightarrow> set ys \\<inter> set zs = {}", "have A: \"\\<And>xs. distinct (map fst xs) = list_map_invar xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs. distinct (map fst xs) = list_map_invar xs", "by (simp add: list_map_invar_def)"], ["proof (state)\nthis:\n  distinct (map fst ?xs) = list_map_invar ?xs\n\ngoal (2 subgoals):\n 1. \\<And>ys. ys \\<in> set (map (map fst) xs) \\<Longrightarrow> distinct ys\n 2. \\<And>ys zs.\n       \\<lbrakk>ys \\<in> set (map (map fst) xs);\n        zs \\<in> set (map (map fst) xs); ys \\<noteq> zs\\<rbrakk>\n       \\<Longrightarrow> set ys \\<inter> set zs = {}", "assume \"ys \\<in> set (map (map fst) xs)\""], ["proof (state)\nthis:\n  ys \\<in> set (map (map fst) xs)\n\ngoal (2 subgoals):\n 1. \\<And>ys. ys \\<in> set (map (map fst) xs) \\<Longrightarrow> distinct ys\n 2. \\<And>ys zs.\n       \\<lbrakk>ys \\<in> set (map (map fst) xs);\n        zs \\<in> set (map (map fst) xs); ys \\<noteq> zs\\<rbrakk>\n       \\<Longrightarrow> set ys \\<inter> set zs = {}", "thus \"distinct ys\""], ["proof (prove)\nusing this:\n  ys \\<in> set (map (map fst) xs)\n\ngoal (1 subgoal):\n 1. distinct ys", "by(clarsimp simp add: set_conv_nth A) (erule no_junk(2))"], ["proof (state)\nthis:\n  distinct ys\n\ngoal (1 subgoal):\n 1. \\<And>ys zs.\n       \\<lbrakk>ys \\<in> set (map (map fst) xs);\n        zs \\<in> set (map (map fst) xs); ys \\<noteq> zs\\<rbrakk>\n       \\<Longrightarrow> set ys \\<inter> set zs = {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys zs.\n       \\<lbrakk>ys \\<in> set (map (map fst) xs);\n        zs \\<in> set (map (map fst) xs); ys \\<noteq> zs\\<rbrakk>\n       \\<Longrightarrow> set ys \\<inter> set zs = {}", "fix ys zs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys zs.\n       \\<lbrakk>ys \\<in> set (map (map fst) xs);\n        zs \\<in> set (map (map fst) xs); ys \\<noteq> zs\\<rbrakk>\n       \\<Longrightarrow> set ys \\<inter> set zs = {}", "assume \"ys \\<in> set (map (map fst) xs)\" \"zs \\<in> set (map (map fst) xs)\" \"ys \\<noteq> zs\""], ["proof (state)\nthis:\n  ys \\<in> set (map (map fst) xs)\n  zs \\<in> set (map (map fst) xs)\n  ys \\<noteq> zs\n\ngoal (1 subgoal):\n 1. \\<And>ys zs.\n       \\<lbrakk>ys \\<in> set (map (map fst) xs);\n        zs \\<in> set (map (map fst) xs); ys \\<noteq> zs\\<rbrakk>\n       \\<Longrightarrow> set ys \\<inter> set zs = {}", "then"], ["proof (chain)\npicking this:\n  ys \\<in> set (map (map fst) xs)\n  zs \\<in> set (map (map fst) xs)\n  ys \\<noteq> zs", "obtain ys' zs' where [simp]: \"ys = map fst ys'\" \"zs = map fst zs'\" \n      and \"ys' \\<in> set xs\" \"zs' \\<in> set xs\""], ["proof (prove)\nusing this:\n  ys \\<in> set (map (map fst) xs)\n  zs \\<in> set (map (map fst) xs)\n  ys \\<noteq> zs\n\ngoal (1 subgoal):\n 1. (\\<And>ys' zs'.\n        \\<lbrakk>ys = map fst ys'; zs = map fst zs'; ys' \\<in> set xs;\n         zs' \\<in> set xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ys = map fst ys'\n  zs = map fst zs'\n  ys' \\<in> set xs\n  zs' \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<And>ys zs.\n       \\<lbrakk>ys \\<in> set (map (map fst) xs);\n        zs \\<in> set (map (map fst) xs); ys \\<noteq> zs\\<rbrakk>\n       \\<Longrightarrow> set ys \\<inter> set zs = {}", "have \"fst ` set ys' \\<inter> fst ` set zs' = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` set ys' \\<inter> fst ` set zs' = {}", "proof(rule equals0I)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> fst ` set ys' \\<inter> fst ` set zs' \\<Longrightarrow> False", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> fst ` set ys' \\<inter> fst ` set zs' \\<Longrightarrow> False", "assume \"k \\<in> fst ` set ys' \\<inter> fst ` set zs'\""], ["proof (state)\nthis:\n  k \\<in> fst ` set ys' \\<inter> fst ` set zs'\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> fst ` set ys' \\<inter> fst ` set zs' \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  k \\<in> fst ` set ys' \\<inter> fst ` set zs'", "obtain v v' where \"(k, v) \\<in> set ys'\" \"(k, v') \\<in> set zs'\""], ["proof (prove)\nusing this:\n  k \\<in> fst ` set ys' \\<inter> fst ` set zs'\n\ngoal (1 subgoal):\n 1. (\\<And>v v'.\n        \\<lbrakk>(k, v) \\<in> set ys'; (k, v') \\<in> set zs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto)"], ["proof (state)\nthis:\n  (k, v) \\<in> set ys'\n  (k, v') \\<in> set zs'\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> fst ` set ys' \\<inter> fst ` set zs' \\<Longrightarrow> False", "from \\<open>ys' \\<in> set xs\\<close>"], ["proof (chain)\npicking this:\n  ys' \\<in> set xs", "obtain i where \"xs ! i = ys'\" \"i < length xs\""], ["proof (prove)\nusing this:\n  ys' \\<in> set xs\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>xs ! i = ys'; i < length xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding set_conv_nth"], ["proof (prove)\nusing this:\n  ys' \\<in> {xs ! i |i. i < length xs}\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>xs ! i = ys'; i < length xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  xs ! i = ys'\n  i < length xs\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> fst ` set ys' \\<inter> fst ` set zs' \\<Longrightarrow> False", "with \\<open>(k, v) \\<in> set ys'\\<close>"], ["proof (chain)\npicking this:\n  (k, v) \\<in> set ys'\n  xs ! i = ys'\n  i < length xs", "have \"bhc (length xs) k = i\""], ["proof (prove)\nusing this:\n  (k, v) \\<in> set ys'\n  xs ! i = ys'\n  i < length xs\n\ngoal (1 subgoal):\n 1. bhc (length xs) k = i", "by(auto dest: no_junk bucket_okD)"], ["proof (state)\nthis:\n  bhc (length xs) k = i\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> fst ` set ys' \\<inter> fst ` set zs' \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  bhc (length xs) k = i\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> fst ` set ys' \\<inter> fst ` set zs' \\<Longrightarrow> False", "from \\<open>zs' \\<in> set xs\\<close>"], ["proof (chain)\npicking this:\n  zs' \\<in> set xs", "obtain j where \"xs ! j = zs'\" \"j < length xs\""], ["proof (prove)\nusing this:\n  zs' \\<in> set xs\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>xs ! j = zs'; j < length xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding set_conv_nth"], ["proof (prove)\nusing this:\n  zs' \\<in> {xs ! i |i. i < length xs}\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>xs ! j = zs'; j < length xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  xs ! j = zs'\n  j < length xs\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> fst ` set ys' \\<inter> fst ` set zs' \\<Longrightarrow> False", "with \\<open>(k, v') \\<in> set zs'\\<close>"], ["proof (chain)\npicking this:\n  (k, v') \\<in> set zs'\n  xs ! j = zs'\n  j < length xs", "have \"bhc (length xs) k = j\""], ["proof (prove)\nusing this:\n  (k, v') \\<in> set zs'\n  xs ! j = zs'\n  j < length xs\n\ngoal (1 subgoal):\n 1. bhc (length xs) k = j", "by(auto dest: no_junk bucket_okD)"], ["proof (state)\nthis:\n  bhc (length xs) k = j\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> fst ` set ys' \\<inter> fst ` set zs' \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  bhc (length xs) k = i\n  bhc (length xs) k = j", "have \"i = j\""], ["proof (prove)\nusing this:\n  bhc (length xs) k = i\n  bhc (length xs) k = j\n\ngoal (1 subgoal):\n 1. i = j", "by simp"], ["proof (state)\nthis:\n  i = j\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> fst ` set ys' \\<inter> fst ` set zs' \\<Longrightarrow> False", "with \\<open>xs ! i = ys'\\<close> \\<open>xs ! j = zs'\\<close>"], ["proof (chain)\npicking this:\n  xs ! i = ys'\n  xs ! j = zs'\n  i = j", "have \"ys' = zs'\""], ["proof (prove)\nusing this:\n  xs ! i = ys'\n  xs ! j = zs'\n  i = j\n\ngoal (1 subgoal):\n 1. ys' = zs'", "by simp"], ["proof (state)\nthis:\n  ys' = zs'\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> fst ` set ys' \\<inter> fst ` set zs' \\<Longrightarrow> False", "with \\<open>ys \\<noteq> zs\\<close>"], ["proof (chain)\npicking this:\n  ys \\<noteq> zs\n  ys' = zs'", "show False"], ["proof (prove)\nusing this:\n  ys \\<noteq> zs\n  ys' = zs'\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fst ` set ys' \\<inter> fst ` set zs' = {}\n\ngoal (1 subgoal):\n 1. \\<And>ys zs.\n       \\<lbrakk>ys \\<in> set (map (map fst) xs);\n        zs \\<in> set (map (map fst) xs); ys \\<noteq> zs\\<rbrakk>\n       \\<Longrightarrow> set ys \\<inter> set zs = {}", "thus \"set ys \\<inter> set zs = {}\""], ["proof (prove)\nusing this:\n  fst ` set ys' \\<inter> fst ` set zs' = {}\n\ngoal (1 subgoal):\n 1. set ys \\<inter> set zs = {}", "by simp"], ["proof (state)\nthis:\n  set ys \\<inter> set zs = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  distinct (map fst (concat xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>@{term \"ahm_\\<alpha>\"}\\<close>"], ["", "(* TODO: Move this *)"], ["", "lemma list_map_lookup_is_map_of:\n     \"list_map_lookup (=) k l = map_of l k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_map_lookup (=) k l = map_of l k", "using list_map_autoref_lookup_aux[where eq=\"(=)\" and\n           Rk=Id and Rv=Id]"], ["proof (prove)\nusing this:\n  \\<lbrakk>GEN_OP (=) (=) (Id \\<rightarrow> Id \\<rightarrow> bool_rel);\n   (?k, ?k') \\<in> Id;\n   (?m, ?m') \\<in> \\<langle>Id \\<times>\\<^sub>r Id\\<rangle>list_rel\\<rbrakk>\n  \\<Longrightarrow> (list_map_lookup (=) ?k ?m,\n                     op_map_lookup ?k' (map_of ?m'))\n                    \\<in> \\<langle>Id\\<rangle>option_rel\n\ngoal (1 subgoal):\n 1. list_map_lookup (=) k l = map_of l k", "by force"], ["", "definition \"ahm_\\<alpha>_aux bhc a \\<equiv> \n    (\\<lambda>k. ahm_lookup_aux (=) bhc k a)\""], ["", "lemma ahm_\\<alpha>_aux_def2: \"ahm_\\<alpha>_aux bhc a = (\\<lambda>k. map_of (array_get a \n    (bhc (array_length a) k)) k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ahm_\\<alpha>_aux bhc a =\n    (\\<lambda>k. map_of (array_get a (bhc (array_length a) k)) k)", "unfolding ahm_\\<alpha>_aux_def ahm_lookup_aux_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>k.\n        list_map_lookup (=) k (array_get a (bhc (array_length a) k))) =\n    (\\<lambda>k. map_of (array_get a (bhc (array_length a) k)) k)", "by (simp add: list_map_lookup_is_map_of)"], ["", "lemma ahm_\\<alpha>_def2: \"ahm_\\<alpha> bhc (HashMap a n) = ahm_\\<alpha>_aux bhc a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ahm_\\<alpha> bhc (HashMap a n) = ahm_\\<alpha>_aux bhc a", "unfolding ahm_\\<alpha>_def ahm_\\<alpha>_aux_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>k. ahm_lookup (=) bhc k (HashMap a n)) =\n    (\\<lambda>k. ahm_lookup_aux (=) bhc k a)", "by simp"], ["", "lemma finite_dom_ahm_\\<alpha>_aux:\n  assumes \"is_bounded_hashcode Id (=) bhc\" \"ahm_invar_aux bhc n a\"\n  shows \"finite (dom (ahm_\\<alpha>_aux bhc a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (dom (ahm_\\<alpha>_aux bhc a))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (dom (ahm_\\<alpha>_aux bhc a))", "have \"dom (ahm_\\<alpha>_aux bhc a) \\<subseteq> (\\<Union>h \\<in> range (bhc (array_length a) :: 'a \\<Rightarrow> nat). dom (map_of (array_get a h)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (ahm_\\<alpha>_aux bhc a)\n    \\<subseteq> (\\<Union>h\\<in>range (bhc (array_length a)).\n                    dom (map_of (array_get a h)))", "unfolding ahm_\\<alpha>_aux_def2"], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (\\<lambda>k. map_of (array_get a (bhc (array_length a) k)) k)\n    \\<subseteq> (\\<Union>h\\<in>range (bhc (array_length a)).\n                    dom (map_of (array_get a h)))", "by(force simp add: dom_map_of_conv_image_fst dest: map_of_SomeD)"], ["proof (state)\nthis:\n  dom (ahm_\\<alpha>_aux bhc a)\n  \\<subseteq> (\\<Union>h\\<in>range (bhc (array_length a)).\n                  dom (map_of (array_get a h)))\n\ngoal (1 subgoal):\n 1. finite (dom (ahm_\\<alpha>_aux bhc a))", "moreover"], ["proof (state)\nthis:\n  dom (ahm_\\<alpha>_aux bhc a)\n  \\<subseteq> (\\<Union>h\\<in>range (bhc (array_length a)).\n                  dom (map_of (array_get a h)))\n\ngoal (1 subgoal):\n 1. finite (dom (ahm_\\<alpha>_aux bhc a))", "have \"finite \\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (\\<Union>h\\<in>range (bhc (array_length a)).\n         dom (map_of (array_get a h)))", "proof(rule finite_UN_I)"], ["proof (state)\ngoal (2 subgoals):\n 1. finite (range (bhc (array_length a)))\n 2. \\<And>h.\n       h \\<in> range (bhc (array_length a)) \\<Longrightarrow>\n       finite (dom (map_of (array_get a h)))", "from \\<open>ahm_invar_aux bhc n a\\<close>"], ["proof (chain)\npicking this:\n  ahm_invar_aux bhc n a", "have \"array_length a > 1\""], ["proof (prove)\nusing this:\n  ahm_invar_aux bhc n a\n\ngoal (1 subgoal):\n 1. 1 < array_length a", "by(simp add: ahm_invar_aux_def)"], ["proof (state)\nthis:\n  1 < array_length a\n\ngoal (2 subgoals):\n 1. finite (range (bhc (array_length a)))\n 2. \\<And>h.\n       h \\<in> range (bhc (array_length a)) \\<Longrightarrow>\n       finite (dom (map_of (array_get a h)))", "hence \"range (bhc (array_length a) :: 'a \\<Rightarrow> nat) \\<subseteq> {0..<array_length a}\""], ["proof (prove)\nusing this:\n  1 < array_length a\n\ngoal (1 subgoal):\n 1. range (bhc (array_length a)) \\<subseteq> {0..<array_length a}", "using assms"], ["proof (prove)\nusing this:\n  1 < array_length a\n  is_bounded_hashcode Id (=) bhc\n  ahm_invar_aux bhc n a\n\ngoal (1 subgoal):\n 1. range (bhc (array_length a)) \\<subseteq> {0..<array_length a}", "by force"], ["proof (state)\nthis:\n  range (bhc (array_length a)) \\<subseteq> {0..<array_length a}\n\ngoal (2 subgoals):\n 1. finite (range (bhc (array_length a)))\n 2. \\<And>h.\n       h \\<in> range (bhc (array_length a)) \\<Longrightarrow>\n       finite (dom (map_of (array_get a h)))", "thus \"finite (range (bhc (array_length a) :: 'a \\<Rightarrow> nat))\""], ["proof (prove)\nusing this:\n  range (bhc (array_length a)) \\<subseteq> {0..<array_length a}\n\ngoal (1 subgoal):\n 1. finite (range (bhc (array_length a)))", "by(rule finite_subset) simp"], ["proof (state)\nthis:\n  finite (range (bhc (array_length a)))\n\ngoal (1 subgoal):\n 1. \\<And>h.\n       h \\<in> range (bhc (array_length a)) \\<Longrightarrow>\n       finite (dom (map_of (array_get a h)))", "qed(rule finite_dom_map_of)"], ["proof (state)\nthis:\n  finite\n   (\\<Union>h\\<in>range (bhc (array_length a)).\n       dom (map_of (array_get a h)))\n\ngoal (1 subgoal):\n 1. finite (dom (ahm_\\<alpha>_aux bhc a))", "ultimately"], ["proof (chain)\npicking this:\n  dom (ahm_\\<alpha>_aux bhc a)\n  \\<subseteq> (\\<Union>h\\<in>range (bhc (array_length a)).\n                  dom (map_of (array_get a h)))\n  finite\n   (\\<Union>h\\<in>range (bhc (array_length a)).\n       dom (map_of (array_get a h)))", "show ?thesis"], ["proof (prove)\nusing this:\n  dom (ahm_\\<alpha>_aux bhc a)\n  \\<subseteq> (\\<Union>h\\<in>range (bhc (array_length a)).\n                  dom (map_of (array_get a h)))\n  finite\n   (\\<Union>h\\<in>range (bhc (array_length a)).\n       dom (map_of (array_get a h)))\n\ngoal (1 subgoal):\n 1. finite (dom (ahm_\\<alpha>_aux bhc a))", "by(rule finite_subset)"], ["proof (state)\nthis:\n  finite (dom (ahm_\\<alpha>_aux bhc a))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ahm_\\<alpha>_aux_new_array[simp]:\n  assumes bhc: \"is_bounded_hashcode Id (=) bhc\" \"1 < sz\"\n  shows \"ahm_\\<alpha>_aux bhc (new_array [] sz) k = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ahm_\\<alpha>_aux bhc (new_array [] sz) k = None", "using is_bounded_hashcodeD(3)[OF assms]"], ["proof (prove)\nusing this:\n  bhc sz ?x < sz\n\ngoal (1 subgoal):\n 1. ahm_\\<alpha>_aux bhc (new_array [] sz) k = None", "unfolding ahm_\\<alpha>_aux_def ahm_lookup_aux_def"], ["proof (prove)\nusing this:\n  bhc sz ?x < sz\n\ngoal (1 subgoal):\n 1. list_map_lookup (=) k\n     (array_get (new_array [] sz)\n       (bhc (array_length (new_array [] sz)) k)) =\n    None", "by simp"], ["", "lemma ahm_\\<alpha>_aux_conv_map_of_concat:\n  assumes bhc: \"is_bounded_hashcode Id (=) bhc\"\n  assumes inv: \"ahm_invar_aux bhc n (Array xs)\"\n  shows \"ahm_\\<alpha>_aux bhc (Array xs) = map_of (concat xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ahm_\\<alpha>_aux bhc (Array xs) = map_of (concat xs)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. ahm_\\<alpha>_aux bhc (Array xs) x = map_of (concat xs) x", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. ahm_\\<alpha>_aux bhc (Array xs) x = map_of (concat xs) x", "show \"ahm_\\<alpha>_aux bhc (Array xs) k = map_of (concat xs) k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ahm_\\<alpha>_aux bhc (Array xs) k = map_of (concat xs) k", "proof(cases \"map_of (concat xs) k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. map_of (concat xs) k = None \\<Longrightarrow>\n    ahm_\\<alpha>_aux bhc (Array xs) k = map_of (concat xs) k\n 2. \\<And>a.\n       map_of (concat xs) k = Some a \\<Longrightarrow>\n       ahm_\\<alpha>_aux bhc (Array xs) k = map_of (concat xs) k", "case None"], ["proof (state)\nthis:\n  map_of (concat xs) k = None\n\ngoal (2 subgoals):\n 1. map_of (concat xs) k = None \\<Longrightarrow>\n    ahm_\\<alpha>_aux bhc (Array xs) k = map_of (concat xs) k\n 2. \\<And>a.\n       map_of (concat xs) k = Some a \\<Longrightarrow>\n       ahm_\\<alpha>_aux bhc (Array xs) k = map_of (concat xs) k", "hence \"k \\<notin> fst ` set (concat xs)\""], ["proof (prove)\nusing this:\n  map_of (concat xs) k = None\n\ngoal (1 subgoal):\n 1. k \\<notin> fst ` set (concat xs)", "by(simp add: map_of_eq_None_iff)"], ["proof (state)\nthis:\n  k \\<notin> fst ` set (concat xs)\n\ngoal (2 subgoals):\n 1. map_of (concat xs) k = None \\<Longrightarrow>\n    ahm_\\<alpha>_aux bhc (Array xs) k = map_of (concat xs) k\n 2. \\<And>a.\n       map_of (concat xs) k = Some a \\<Longrightarrow>\n       ahm_\\<alpha>_aux bhc (Array xs) k = map_of (concat xs) k", "hence \"k \\<notin> fst ` set (xs ! bhc (length xs) k)\""], ["proof (prove)\nusing this:\n  k \\<notin> fst ` set (concat xs)\n\ngoal (1 subgoal):\n 1. k \\<notin> fst ` set (xs ! bhc (length xs) k)", "proof(rule contrapos_nn)"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<in> fst ` set (xs ! bhc (length xs) k) \\<Longrightarrow>\n    k \\<in> fst ` set (concat xs)", "assume \"k \\<in> fst ` set (xs ! bhc (length xs) k)\""], ["proof (state)\nthis:\n  k \\<in> fst ` set (xs ! bhc (length xs) k)\n\ngoal (1 subgoal):\n 1. k \\<in> fst ` set (xs ! bhc (length xs) k) \\<Longrightarrow>\n    k \\<in> fst ` set (concat xs)", "then"], ["proof (chain)\npicking this:\n  k \\<in> fst ` set (xs ! bhc (length xs) k)", "obtain v where \"(k, v) \\<in> set (xs ! bhc (length xs) k)\""], ["proof (prove)\nusing this:\n  k \\<in> fst ` set (xs ! bhc (length xs) k)\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        (k, v) \\<in> set (xs ! bhc (length xs) k) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (k, v) \\<in> set (xs ! bhc (length xs) k)\n\ngoal (1 subgoal):\n 1. k \\<in> fst ` set (xs ! bhc (length xs) k) \\<Longrightarrow>\n    k \\<in> fst ` set (concat xs)", "moreover"], ["proof (state)\nthis:\n  (k, v) \\<in> set (xs ! bhc (length xs) k)\n\ngoal (1 subgoal):\n 1. k \\<in> fst ` set (xs ! bhc (length xs) k) \\<Longrightarrow>\n    k \\<in> fst ` set (concat xs)", "from inv"], ["proof (chain)\npicking this:\n  ahm_invar_aux bhc n (Array xs)", "have \"bhc (length xs) k < length xs\""], ["proof (prove)\nusing this:\n  ahm_invar_aux bhc n (Array xs)\n\ngoal (1 subgoal):\n 1. bhc (length xs) k < length xs", "using bhc"], ["proof (prove)\nusing this:\n  ahm_invar_aux bhc n (Array xs)\n  is_bounded_hashcode Id (=) bhc\n\ngoal (1 subgoal):\n 1. bhc (length xs) k < length xs", "by (force simp: ahm_invar_aux_def)"], ["proof (state)\nthis:\n  bhc (length xs) k < length xs\n\ngoal (1 subgoal):\n 1. k \\<in> fst ` set (xs ! bhc (length xs) k) \\<Longrightarrow>\n    k \\<in> fst ` set (concat xs)", "ultimately"], ["proof (chain)\npicking this:\n  (k, v) \\<in> set (xs ! bhc (length xs) k)\n  bhc (length xs) k < length xs", "show \"k \\<in> fst ` set (concat xs)\""], ["proof (prove)\nusing this:\n  (k, v) \\<in> set (xs ! bhc (length xs) k)\n  bhc (length xs) k < length xs\n\ngoal (1 subgoal):\n 1. k \\<in> fst ` set (concat xs)", "by (force intro: rev_image_eqI)"], ["proof (state)\nthis:\n  k \\<in> fst ` set (concat xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  k \\<notin> fst ` set (xs ! bhc (length xs) k)\n\ngoal (2 subgoals):\n 1. map_of (concat xs) k = None \\<Longrightarrow>\n    ahm_\\<alpha>_aux bhc (Array xs) k = map_of (concat xs) k\n 2. \\<And>a.\n       map_of (concat xs) k = Some a \\<Longrightarrow>\n       ahm_\\<alpha>_aux bhc (Array xs) k = map_of (concat xs) k", "thus ?thesis"], ["proof (prove)\nusing this:\n  k \\<notin> fst ` set (xs ! bhc (length xs) k)\n\ngoal (1 subgoal):\n 1. ahm_\\<alpha>_aux bhc (Array xs) k = map_of (concat xs) k", "unfolding None ahm_\\<alpha>_aux_def2"], ["proof (prove)\nusing this:\n  k \\<notin> fst ` set (xs ! bhc (length xs) k)\n\ngoal (1 subgoal):\n 1. map_of (array_get (Array xs) (bhc (array_length (Array xs)) k)) k = None", "by (simp add: map_of_eq_None_iff)"], ["proof (state)\nthis:\n  ahm_\\<alpha>_aux bhc (Array xs) k = map_of (concat xs) k\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       map_of (concat xs) k = Some a \\<Longrightarrow>\n       ahm_\\<alpha>_aux bhc (Array xs) k = map_of (concat xs) k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       map_of (concat xs) k = Some a \\<Longrightarrow>\n       ahm_\\<alpha>_aux bhc (Array xs) k = map_of (concat xs) k", "case (Some v)"], ["proof (state)\nthis:\n  map_of (concat xs) k = Some v\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       map_of (concat xs) k = Some a \\<Longrightarrow>\n       ahm_\\<alpha>_aux bhc (Array xs) k = map_of (concat xs) k", "hence \"(k, v) \\<in> set (concat xs)\""], ["proof (prove)\nusing this:\n  map_of (concat xs) k = Some v\n\ngoal (1 subgoal):\n 1. (k, v) \\<in> set (concat xs)", "by(rule map_of_SomeD)"], ["proof (state)\nthis:\n  (k, v) \\<in> set (concat xs)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       map_of (concat xs) k = Some a \\<Longrightarrow>\n       ahm_\\<alpha>_aux bhc (Array xs) k = map_of (concat xs) k", "then"], ["proof (chain)\npicking this:\n  (k, v) \\<in> set (concat xs)", "obtain ys where \"ys \\<in> set xs\" \"(k, v) \\<in> set ys\""], ["proof (prove)\nusing this:\n  (k, v) \\<in> set (concat xs)\n\ngoal (1 subgoal):\n 1. (\\<And>ys.\n        \\<lbrakk>ys \\<in> set xs; (k, v) \\<in> set ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding set_concat"], ["proof (prove)\nusing this:\n  (k, v) \\<in> \\<Union> (set ` set xs)\n\ngoal (1 subgoal):\n 1. (\\<And>ys.\n        \\<lbrakk>ys \\<in> set xs; (k, v) \\<in> set ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ys \\<in> set xs\n  (k, v) \\<in> set ys\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       map_of (concat xs) k = Some a \\<Longrightarrow>\n       ahm_\\<alpha>_aux bhc (Array xs) k = map_of (concat xs) k", "from \\<open>ys \\<in> set xs\\<close>"], ["proof (chain)\npicking this:\n  ys \\<in> set xs", "obtain i j where \"i < length xs\" \"xs ! i = ys\""], ["proof (prove)\nusing this:\n  ys \\<in> set xs\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length xs; xs ! i = ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding set_conv_nth"], ["proof (prove)\nusing this:\n  ys \\<in> {xs ! i |i. i < length xs}\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length xs; xs ! i = ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i < length xs\n  xs ! i = ys\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       map_of (concat xs) k = Some a \\<Longrightarrow>\n       ahm_\\<alpha>_aux bhc (Array xs) k = map_of (concat xs) k", "with inv \\<open>(k, v) \\<in> set ys\\<close>"], ["proof (chain)\npicking this:\n  ahm_invar_aux bhc n (Array xs)\n  (k, v) \\<in> set ys\n  i < length xs\n  xs ! i = ys", "show ?thesis"], ["proof (prove)\nusing this:\n  ahm_invar_aux bhc n (Array xs)\n  (k, v) \\<in> set ys\n  i < length xs\n  xs ! i = ys\n\ngoal (1 subgoal):\n 1. ahm_\\<alpha>_aux bhc (Array xs) k = map_of (concat xs) k", "unfolding Some"], ["proof (prove)\nusing this:\n  ahm_invar_aux bhc n (Array xs)\n  (k, v) \\<in> set ys\n  i < length xs\n  xs ! i = ys\n\ngoal (1 subgoal):\n 1. ahm_\\<alpha>_aux bhc (Array xs) k = Some v", "unfolding ahm_\\<alpha>_aux_def2"], ["proof (prove)\nusing this:\n  ahm_invar_aux bhc n (Array xs)\n  (k, v) \\<in> set ys\n  i < length xs\n  xs ! i = ys\n\ngoal (1 subgoal):\n 1. map_of (array_get (Array xs) (bhc (array_length (Array xs)) k)) k =\n    Some v", "by(force dest: bucket_okD simp add: ahm_invar_aux_def list_map_invar_def)"], ["proof (state)\nthis:\n  ahm_\\<alpha>_aux bhc (Array xs) k = map_of (concat xs) k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ahm_\\<alpha>_aux bhc (Array xs) k = map_of (concat xs) k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ahm_invar_aux_card_dom_ahm_\\<alpha>_auxD:\n  assumes bhc: \"is_bounded_hashcode Id (=) bhc\"\n  assumes inv: \"ahm_invar_aux bhc n a\"\n  shows \"card (dom (ahm_\\<alpha>_aux bhc a)) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (dom (ahm_\\<alpha>_aux bhc a)) = n", "proof(cases a)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       a = Array x \\<Longrightarrow> card (dom (ahm_\\<alpha>_aux bhc a)) = n", "case [simp]: (Array xs)"], ["proof (state)\nthis:\n  a = Array xs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       a = Array x \\<Longrightarrow> card (dom (ahm_\\<alpha>_aux bhc a)) = n", "from inv"], ["proof (chain)\npicking this:\n  ahm_invar_aux bhc n a", "have \"card (dom (ahm_\\<alpha>_aux bhc (Array xs))) = card (dom (map_of (concat xs)))\""], ["proof (prove)\nusing this:\n  ahm_invar_aux bhc n a\n\ngoal (1 subgoal):\n 1. card (dom (ahm_\\<alpha>_aux bhc (Array xs))) =\n    card (dom (map_of (concat xs)))", "by(simp add: ahm_\\<alpha>_aux_conv_map_of_concat[OF bhc])"], ["proof (state)\nthis:\n  card (dom (ahm_\\<alpha>_aux bhc (Array xs))) =\n  card (dom (map_of (concat xs)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       a = Array x \\<Longrightarrow> card (dom (ahm_\\<alpha>_aux bhc a)) = n", "also"], ["proof (state)\nthis:\n  card (dom (ahm_\\<alpha>_aux bhc (Array xs))) =\n  card (dom (map_of (concat xs)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       a = Array x \\<Longrightarrow> card (dom (ahm_\\<alpha>_aux bhc a)) = n", "from inv"], ["proof (chain)\npicking this:\n  ahm_invar_aux bhc n a", "have \"distinct (map fst (concat xs))\""], ["proof (prove)\nusing this:\n  ahm_invar_aux bhc n a\n\ngoal (1 subgoal):\n 1. distinct (map fst (concat xs))", "by(simp add: ahm_invar_distinct_fst_concatD)"], ["proof (state)\nthis:\n  distinct (map fst (concat xs))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       a = Array x \\<Longrightarrow> card (dom (ahm_\\<alpha>_aux bhc a)) = n", "hence \"card (dom (map_of (concat xs))) = length (concat xs)\""], ["proof (prove)\nusing this:\n  distinct (map fst (concat xs))\n\ngoal (1 subgoal):\n 1. card (dom (map_of (concat xs))) = length (concat xs)", "by(rule card_dom_map_of)"], ["proof (state)\nthis:\n  card (dom (map_of (concat xs))) = length (concat xs)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       a = Array x \\<Longrightarrow> card (dom (ahm_\\<alpha>_aux bhc a)) = n", "also"], ["proof (state)\nthis:\n  card (dom (map_of (concat xs))) = length (concat xs)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       a = Array x \\<Longrightarrow> card (dom (ahm_\\<alpha>_aux bhc a)) = n", "have \"length (concat xs) = foldl (+) 0 (map length xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (concat xs) = foldl (+) 0 (map length xs)", "by (simp add: length_concat foldl_conv_fold add.commute fold_plus_sum_list_rev)"], ["proof (state)\nthis:\n  length (concat xs) = foldl (+) 0 (map length xs)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       a = Array x \\<Longrightarrow> card (dom (ahm_\\<alpha>_aux bhc a)) = n", "also"], ["proof (state)\nthis:\n  length (concat xs) = foldl (+) 0 (map length xs)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       a = Array x \\<Longrightarrow> card (dom (ahm_\\<alpha>_aux bhc a)) = n", "from inv"], ["proof (chain)\npicking this:\n  ahm_invar_aux bhc n a", "have \"\\<dots> = n\""], ["proof (prove)\nusing this:\n  ahm_invar_aux bhc n a\n\ngoal (1 subgoal):\n 1. foldl (+) 0 (map length xs) = n", "unfolding foldl_map"], ["proof (prove)\nusing this:\n  ahm_invar_aux bhc n a\n\ngoal (1 subgoal):\n 1. foldl (\\<lambda>a x. a + length x) 0 xs = n", "by(simp add: ahm_invar_aux_def array_foldl_foldl)"], ["proof (state)\nthis:\n  foldl (+) 0 (map length xs) = n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       a = Array x \\<Longrightarrow> card (dom (ahm_\\<alpha>_aux bhc a)) = n", "finally"], ["proof (chain)\npicking this:\n  card (dom (ahm_\\<alpha>_aux bhc (Array xs))) = n", "show ?thesis"], ["proof (prove)\nusing this:\n  card (dom (ahm_\\<alpha>_aux bhc (Array xs))) = n\n\ngoal (1 subgoal):\n 1. card (dom (ahm_\\<alpha>_aux bhc a)) = n", "by(simp)"], ["proof (state)\nthis:\n  card (dom (ahm_\\<alpha>_aux bhc a)) = n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_dom_ahm_\\<alpha>:\n  assumes \"is_bounded_hashcode Id (=) bhc\" \"ahm_invar bhc hm\"\n  shows \"finite (dom (ahm_\\<alpha> bhc hm))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (dom (ahm_\\<alpha> bhc hm))", "using assms"], ["proof (prove)\nusing this:\n  is_bounded_hashcode Id (=) bhc\n  ahm_invar bhc hm\n\ngoal (1 subgoal):\n 1. finite (dom (ahm_\\<alpha> bhc hm))", "by (cases hm, force intro: finite_dom_ahm_\\<alpha>_aux \n      simp: ahm_\\<alpha>_def2)"], ["", "subsection \\<open>@{term ahm_empty}\\<close>"], ["", "lemma ahm_invar_aux_new_array:\n  assumes \"n > 1\"\n  shows \"ahm_invar_aux bhc 0 (new_array [] n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ahm_invar_aux bhc 0 (new_array [] n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ahm_invar_aux bhc 0 (new_array [] n)", "have \"foldl (\\<lambda>b (k, v). b + length v) 0 (zip [0..<n] (replicate n [])) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (\\<lambda>b (k, v). b + length v) 0\n     (zip [0..<n] (replicate n [])) =\n    0", "by(induct n)(simp_all add: replicate_Suc_conv_snoc del: replicate_Suc)"], ["proof (state)\nthis:\n  foldl (\\<lambda>b (k, v). b + length v) 0 (zip [0..<n] (replicate n [])) =\n  0\n\ngoal (1 subgoal):\n 1. ahm_invar_aux bhc 0 (new_array [] n)", "with assms"], ["proof (chain)\npicking this:\n  1 < n\n  foldl (\\<lambda>b (k, v). b + length v) 0 (zip [0..<n] (replicate n [])) =\n  0", "show ?thesis"], ["proof (prove)\nusing this:\n  1 < n\n  foldl (\\<lambda>b (k, v). b + length v) 0 (zip [0..<n] (replicate n [])) =\n  0\n\ngoal (1 subgoal):\n 1. ahm_invar_aux bhc 0 (new_array [] n)", "by(simp add: ahm_invar_aux_def array_foldl_new_array list_map_invar_def)"], ["proof (state)\nthis:\n  ahm_invar_aux bhc 0 (new_array [] n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ahm_invar_new_hashmap_with:\n  \"n > 1 \\<Longrightarrow> ahm_invar bhc (new_hashmap_with n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < n \\<Longrightarrow> ahm_invar bhc (new_hashmap_with n)", "by(auto simp add: ahm_invar_def new_hashmap_with_def intro: ahm_invar_aux_new_array)"], ["", "lemma ahm_\\<alpha>_new_hashmap_with:\n  assumes \"is_bounded_hashcode Id (=) bhc\" and \"n > 1\"\n  shows \"Map.empty = ahm_\\<alpha> bhc (new_hashmap_with n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Map.empty = ahm_\\<alpha> bhc (new_hashmap_with n)", "unfolding new_hashmap_with_def ahm_\\<alpha>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Map.empty =\n    (\\<lambda>k. ahm_lookup (=) bhc k (HashMap (new_array [] n) 0))", "using is_bounded_hashcodeD(3)[OF assms]"], ["proof (prove)\nusing this:\n  bhc n ?x < n\n\ngoal (1 subgoal):\n 1. Map.empty =\n    (\\<lambda>k. ahm_lookup (=) bhc k (HashMap (new_array [] n) 0))", "by force"], ["", "lemma ahm_empty_impl:\n  assumes bhc: \"is_bounded_hashcode Id (=) bhc\"\n  assumes def_size: \"def_size > 1\"\n  shows \"(ahm_empty def_size, Map.empty) \\<in> ahm_map_rel' bhc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ahm_empty def_size, Map.empty) \\<in> ahm_map_rel' bhc", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (ahm_empty def_size, Map.empty) \\<in> ahm_map_rel' bhc", "from def_size and ahm_\\<alpha>_new_hashmap_with[OF bhc def_size] and\n       ahm_invar_new_hashmap_with[OF def_size]"], ["proof (chain)\npicking this:\n  1 < def_size\n  Map.empty = ahm_\\<alpha> bhc (new_hashmap_with def_size)\n  ahm_invar ?bhc (new_hashmap_with def_size)", "show ?thesis"], ["proof (prove)\nusing this:\n  1 < def_size\n  Map.empty = ahm_\\<alpha> bhc (new_hashmap_with def_size)\n  ahm_invar ?bhc (new_hashmap_with def_size)\n\ngoal (1 subgoal):\n 1. (ahm_empty def_size, Map.empty) \\<in> ahm_map_rel' bhc", "unfolding ahm_empty_def ahm_map_rel'_def br_def"], ["proof (prove)\nusing this:\n  1 < def_size\n  Map.empty = ahm_\\<alpha> bhc (new_hashmap_with def_size)\n  ahm_invar ?bhc (new_hashmap_with def_size)\n\ngoal (1 subgoal):\n 1. (new_hashmap_with def_size, Map.empty)\n    \\<in> {(c, a). a = ahm_\\<alpha> bhc c \\<and> ahm_invar bhc c}", "by force"], ["proof (state)\nthis:\n  (ahm_empty def_size, Map.empty) \\<in> ahm_map_rel' bhc\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma param_ahm_empty[param]: \n  assumes def_size: \"(def_size, def_size') \\<in> nat_rel\"\n  shows \"(ahm_empty def_size ,ahm_empty def_size') \\<in> \n      \\<langle>Rk,Rv\\<rangle>ahm_map_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ahm_empty def_size, ahm_empty def_size') \\<in> \\<langle>Rk,\n    Rv\\<rangle>ahm_map_rel", "unfolding ahm_empty_def[abs_def] new_hashmap_with_def[abs_def]\n    new_array_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (HashMap (Array (replicate def_size [])) 0,\n     HashMap (Array (replicate def_size' [])) 0)\n    \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel", "using assms"], ["proof (prove)\nusing this:\n  (def_size, def_size') \\<in> nat_rel\n\ngoal (1 subgoal):\n 1. (HashMap (Array (replicate def_size [])) 0,\n     HashMap (Array (replicate def_size' [])) 0)\n    \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel", "by parametricity"], ["", "lemma autoref_ahm_empty[autoref_rules]:\n  fixes Rk :: \"('kc\\<times>'ka) set\"\n  assumes bhc: \"SIDE_GEN_ALGO (is_bounded_hashcode Rk eq bhc)\"\n  assumes def_size: \"SIDE_GEN_ALGO (is_valid_def_hm_size TYPE('kc) def_size)\"\n  shows \"(ahm_empty def_size, op_map_empty) \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ahm_empty def_size, op_map_empty) \\<in> \\<langle>Rk,\n    Rv\\<rangle>ahm_rel bhc", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (ahm_empty def_size, op_map_empty) \\<in> \\<langle>Rk,\n    Rv\\<rangle>ahm_rel bhc", "from bhc"], ["proof (chain)\npicking this:\n  SIDE_GEN_ALGO (is_bounded_hashcode Rk eq bhc)", "have eq': \"(eq,(=)) \\<in> Rk \\<rightarrow> Rk \\<rightarrow> bool_rel\""], ["proof (prove)\nusing this:\n  SIDE_GEN_ALGO (is_bounded_hashcode Rk eq bhc)\n\ngoal (1 subgoal):\n 1. (eq, (=)) \\<in> Rk \\<rightarrow> Rk \\<rightarrow> bool_rel", "by (simp add: is_bounded_hashcodeD)"], ["proof (state)\nthis:\n  (eq, (=)) \\<in> Rk \\<rightarrow> Rk \\<rightarrow> bool_rel\n\ngoal (1 subgoal):\n 1. (ahm_empty def_size, op_map_empty) \\<in> \\<langle>Rk,\n    Rv\\<rangle>ahm_rel bhc", "with bhc"], ["proof (chain)\npicking this:\n  SIDE_GEN_ALGO (is_bounded_hashcode Rk eq bhc)\n  (eq, (=)) \\<in> Rk \\<rightarrow> Rk \\<rightarrow> bool_rel", "have \"is_bounded_hashcode Id (=) \n      (abstract_bounded_hashcode Rk bhc)\""], ["proof (prove)\nusing this:\n  SIDE_GEN_ALGO (is_bounded_hashcode Rk eq bhc)\n  (eq, (=)) \\<in> Rk \\<rightarrow> Rk \\<rightarrow> bool_rel\n\ngoal (1 subgoal):\n 1. is_bounded_hashcode Id (=) (abstract_bounded_hashcode Rk bhc)", "unfolding autoref_tag_defs"], ["proof (prove)\nusing this:\n  is_bounded_hashcode Rk eq bhc\n  (eq, (=)) \\<in> Rk \\<rightarrow> Rk \\<rightarrow> bool_rel\n\ngoal (1 subgoal):\n 1. is_bounded_hashcode Id (=) (abstract_bounded_hashcode Rk bhc)", "by blast"], ["proof (state)\nthis:\n  is_bounded_hashcode Id (=) (abstract_bounded_hashcode Rk bhc)\n\ngoal (1 subgoal):\n 1. (ahm_empty def_size, op_map_empty) \\<in> \\<langle>Rk,\n    Rv\\<rangle>ahm_rel bhc", "thus ?thesis"], ["proof (prove)\nusing this:\n  is_bounded_hashcode Id (=) (abstract_bounded_hashcode Rk bhc)\n\ngoal (1 subgoal):\n 1. (ahm_empty def_size, op_map_empty) \\<in> \\<langle>Rk,\n    Rv\\<rangle>ahm_rel bhc", "using assms"], ["proof (prove)\nusing this:\n  is_bounded_hashcode Id (=) (abstract_bounded_hashcode Rk bhc)\n  SIDE_GEN_ALGO (is_bounded_hashcode Rk eq bhc)\n  SIDE_GEN_ALGO (is_valid_def_hm_size TYPE('kc) def_size)\n\ngoal (1 subgoal):\n 1. (ahm_empty def_size, op_map_empty) \\<in> \\<langle>Rk,\n    Rv\\<rangle>ahm_rel bhc", "unfolding op_map_empty_def"], ["proof (prove)\nusing this:\n  is_bounded_hashcode Id (=) (abstract_bounded_hashcode Rk bhc)\n  SIDE_GEN_ALGO (is_bounded_hashcode Rk eq bhc)\n  SIDE_GEN_ALGO (is_valid_def_hm_size TYPE('kc) def_size)\n\ngoal (1 subgoal):\n 1. (ahm_empty def_size, Map.empty) \\<in> \\<langle>Rk,\n    Rv\\<rangle>ahm_rel bhc", "unfolding ahm_rel_def is_valid_def_hm_size_def autoref_tag_defs"], ["proof (prove)\nusing this:\n  is_bounded_hashcode Id (=) (abstract_bounded_hashcode Rk bhc)\n  is_bounded_hashcode Rk eq bhc\n  1 < def_size\n\ngoal (1 subgoal):\n 1. (ahm_empty def_size, Map.empty)\n    \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel O\n          ahm_map_rel' (abstract_bounded_hashcode Rk bhc)", "apply (intro relcompI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>is_bounded_hashcode Id (=) (abstract_bounded_hashcode Rk bhc);\n     is_bounded_hashcode Rk eq bhc; 1 < def_size\\<rbrakk>\n    \\<Longrightarrow> (ahm_empty def_size, ?b3) \\<in> \\<langle>Rk,\n                      Rv\\<rangle>ahm_map_rel\n 2. \\<lbrakk>is_bounded_hashcode Id (=) (abstract_bounded_hashcode Rk bhc);\n     is_bounded_hashcode Rk eq bhc; 1 < def_size\\<rbrakk>\n    \\<Longrightarrow> (?b3, Map.empty)\n                      \\<in> ahm_map_rel' (abstract_bounded_hashcode Rk bhc)", "apply (rule param_ahm_empty[of def_size def_size], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_bounded_hashcode Id (=) (abstract_bounded_hashcode Rk bhc);\n     is_bounded_hashcode Rk eq bhc; 1 < def_size\\<rbrakk>\n    \\<Longrightarrow> (ahm_empty def_size, Map.empty)\n                      \\<in> ahm_map_rel' (abstract_bounded_hashcode Rk bhc)", "apply (blast intro: ahm_empty_impl)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (ahm_empty def_size, op_map_empty) \\<in> \\<langle>Rk,\n  Rv\\<rangle>ahm_rel bhc\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>@{term \"ahm_lookup\"}\\<close>"], ["", "lemma param_ahm_lookup[param]:\n  assumes bhc: \"is_bounded_hashcode Rk eq bhc\"\n  defines bhc'_def: \"bhc' \\<equiv> abstract_bounded_hashcode Rk bhc\"\n  assumes inv: \"ahm_invar bhc' m'\"\n  assumes K: \"(k,k') \\<in> Rk\"\n  assumes M: \"(m,m') \\<in> \\<langle>Rk,Rv\\<rangle>ahm_map_rel\"\n  shows \"(ahm_lookup eq bhc k m, ahm_lookup (=) bhc' k' m') \\<in> \n             \\<langle>Rv\\<rangle>option_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ahm_lookup eq bhc k m, ahm_lookup (=) bhc' k' m')\n    \\<in> \\<langle>Rv\\<rangle>option_rel", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (ahm_lookup eq bhc k m, ahm_lookup (=) bhc' k' m')\n    \\<in> \\<langle>Rv\\<rangle>option_rel", "from bhc"], ["proof (chain)\npicking this:\n  is_bounded_hashcode Rk eq bhc", "have eq': \"(eq,(=)) \\<in> Rk \\<rightarrow> Rk \\<rightarrow> bool_rel\""], ["proof (prove)\nusing this:\n  is_bounded_hashcode Rk eq bhc\n\ngoal (1 subgoal):\n 1. (eq, (=)) \\<in> Rk \\<rightarrow> Rk \\<rightarrow> bool_rel", "by (simp add: is_bounded_hashcodeD)"], ["proof (state)\nthis:\n  (eq, (=)) \\<in> Rk \\<rightarrow> Rk \\<rightarrow> bool_rel\n\ngoal (1 subgoal):\n 1. (ahm_lookup eq bhc k m, ahm_lookup (=) bhc' k' m')\n    \\<in> \\<langle>Rv\\<rangle>option_rel", "moreover"], ["proof (state)\nthis:\n  (eq, (=)) \\<in> Rk \\<rightarrow> Rk \\<rightarrow> bool_rel\n\ngoal (1 subgoal):\n 1. (ahm_lookup eq bhc k m, ahm_lookup (=) bhc' k' m')\n    \\<in> \\<langle>Rv\\<rangle>option_rel", "from abstract_bhc_correct[OF bhc]"], ["proof (chain)\npicking this:\n  (bhc, abstract_bounded_hashcode Rk bhc)\n  \\<in> nat_rel \\<rightarrow> Rk \\<rightarrow> nat_rel", "have bhc': \"(bhc,bhc') \\<in> nat_rel \\<rightarrow> Rk \\<rightarrow> nat_rel\""], ["proof (prove)\nusing this:\n  (bhc, abstract_bounded_hashcode Rk bhc)\n  \\<in> nat_rel \\<rightarrow> Rk \\<rightarrow> nat_rel\n\ngoal (1 subgoal):\n 1. (bhc, bhc') \\<in> nat_rel \\<rightarrow> Rk \\<rightarrow> nat_rel", "unfolding bhc'_def"], ["proof (prove)\nusing this:\n  (bhc, abstract_bounded_hashcode Rk bhc)\n  \\<in> nat_rel \\<rightarrow> Rk \\<rightarrow> nat_rel\n\ngoal (1 subgoal):\n 1. (bhc, abstract_bounded_hashcode Rk bhc)\n    \\<in> nat_rel \\<rightarrow> Rk \\<rightarrow> nat_rel", "."], ["proof (state)\nthis:\n  (bhc, bhc') \\<in> nat_rel \\<rightarrow> Rk \\<rightarrow> nat_rel\n\ngoal (1 subgoal):\n 1. (ahm_lookup eq bhc k m, ahm_lookup (=) bhc' k' m')\n    \\<in> \\<langle>Rv\\<rangle>option_rel", "moreover"], ["proof (state)\nthis:\n  (bhc, bhc') \\<in> nat_rel \\<rightarrow> Rk \\<rightarrow> nat_rel\n\ngoal (1 subgoal):\n 1. (ahm_lookup eq bhc k m, ahm_lookup (=) bhc' k' m')\n    \\<in> \\<langle>Rv\\<rangle>option_rel", "from M"], ["proof (chain)\npicking this:\n  (m, m') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel", "obtain a a' n n' where \n      [simp]: \"m = HashMap a n\" and [simp]: \"m' = HashMap a' n'\" and\n      A: \"(a,a') \\<in> \\<langle>\\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel\\<rangle>array_rel\" and N: \"(n,n') \\<in> Id\""], ["proof (prove)\nusing this:\n  (m, m') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel\n\ngoal (1 subgoal):\n 1. (\\<And>a n a' n'.\n        \\<lbrakk>m = HashMap a n; m' = HashMap a' n';\n         (a, a')\n         \\<in> \\<langle>\\<langle>Rk \\<times>\\<^sub>r\n                                 Rv\\<rangle>list_rel\\<rangle>array_rel;\n         (n, n') \\<in> nat_rel\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases m, cases m', unfold ahm_map_rel_def, auto)"], ["proof (state)\nthis:\n  m = HashMap a n\n  m' = HashMap a' n'\n  (a, a')\n  \\<in> \\<langle>\\<langle>Rk \\<times>\\<^sub>r\n                          Rv\\<rangle>list_rel\\<rangle>array_rel\n  (n, n') \\<in> nat_rel\n\ngoal (1 subgoal):\n 1. (ahm_lookup eq bhc k m, ahm_lookup (=) bhc' k' m')\n    \\<in> \\<langle>Rv\\<rangle>option_rel", "moreover"], ["proof (state)\nthis:\n  m = HashMap a n\n  m' = HashMap a' n'\n  (a, a')\n  \\<in> \\<langle>\\<langle>Rk \\<times>\\<^sub>r\n                          Rv\\<rangle>list_rel\\<rangle>array_rel\n  (n, n') \\<in> nat_rel\n\ngoal (1 subgoal):\n 1. (ahm_lookup eq bhc k m, ahm_lookup (=) bhc' k' m')\n    \\<in> \\<langle>Rv\\<rangle>option_rel", "from inv and array_rel_imp_same_length[OF A]"], ["proof (chain)\npicking this:\n  ahm_invar bhc' m'\n  array_length a = array_length a'", "have \"array_length a > 1\""], ["proof (prove)\nusing this:\n  ahm_invar bhc' m'\n  array_length a = array_length a'\n\ngoal (1 subgoal):\n 1. 1 < array_length a", "by (simp add: ahm_invar_aux_def)"], ["proof (state)\nthis:\n  1 < array_length a\n\ngoal (1 subgoal):\n 1. (ahm_lookup eq bhc k m, ahm_lookup (=) bhc' k' m')\n    \\<in> \\<langle>Rv\\<rangle>option_rel", "with abstract_bhc_is_bhc[OF bhc]"], ["proof (chain)\npicking this:\n  is_bounded_hashcode Id (=) (abstract_bounded_hashcode Rk bhc)\n  1 < array_length a", "have \"bhc' (array_length a) k' < array_length a\""], ["proof (prove)\nusing this:\n  is_bounded_hashcode Id (=) (abstract_bounded_hashcode Rk bhc)\n  1 < array_length a\n\ngoal (1 subgoal):\n 1. bhc' (array_length a) k' < array_length a", "unfolding bhc'_def"], ["proof (prove)\nusing this:\n  is_bounded_hashcode Id (=) (abstract_bounded_hashcode Rk bhc)\n  1 < array_length a\n\ngoal (1 subgoal):\n 1. abstract_bounded_hashcode Rk bhc (array_length a) k' < array_length a", "by blast"], ["proof (state)\nthis:\n  bhc' (array_length a) k' < array_length a\n\ngoal (1 subgoal):\n 1. (ahm_lookup eq bhc k m, ahm_lookup (=) bhc' k' m')\n    \\<in> \\<langle>Rv\\<rangle>option_rel", "with bhc'[param_fo, OF _ K]"], ["proof (chain)\npicking this:\n  (?x1, ?x'1) \\<in> nat_rel \\<Longrightarrow>\n  (bhc ?x1 k, bhc' ?x'1 k') \\<in> nat_rel\n  bhc' (array_length a) k' < array_length a", "have \"bhc (array_length a) k < array_length a\""], ["proof (prove)\nusing this:\n  (?x1, ?x'1) \\<in> nat_rel \\<Longrightarrow>\n  (bhc ?x1 k, bhc' ?x'1 k') \\<in> nat_rel\n  bhc' (array_length a) k' < array_length a\n\ngoal (1 subgoal):\n 1. bhc (array_length a) k < array_length a", "by simp"], ["proof (state)\nthis:\n  bhc (array_length a) k < array_length a\n\ngoal (1 subgoal):\n 1. (ahm_lookup eq bhc k m, ahm_lookup (=) bhc' k' m')\n    \\<in> \\<langle>Rv\\<rangle>option_rel", "ultimately"], ["proof (chain)\npicking this:\n  (eq, (=)) \\<in> Rk \\<rightarrow> Rk \\<rightarrow> bool_rel\n  (bhc, bhc') \\<in> nat_rel \\<rightarrow> Rk \\<rightarrow> nat_rel\n  m = HashMap a n\n  m' = HashMap a' n'\n  (a, a')\n  \\<in> \\<langle>\\<langle>Rk \\<times>\\<^sub>r\n                          Rv\\<rangle>list_rel\\<rangle>array_rel\n  (n, n') \\<in> nat_rel\n  bhc (array_length a) k < array_length a", "show ?thesis"], ["proof (prove)\nusing this:\n  (eq, (=)) \\<in> Rk \\<rightarrow> Rk \\<rightarrow> bool_rel\n  (bhc, bhc') \\<in> nat_rel \\<rightarrow> Rk \\<rightarrow> nat_rel\n  m = HashMap a n\n  m' = HashMap a' n'\n  (a, a')\n  \\<in> \\<langle>\\<langle>Rk \\<times>\\<^sub>r\n                          Rv\\<rangle>list_rel\\<rangle>array_rel\n  (n, n') \\<in> nat_rel\n  bhc (array_length a) k < array_length a\n\ngoal (1 subgoal):\n 1. (ahm_lookup eq bhc k m, ahm_lookup (=) bhc' k' m')\n    \\<in> \\<langle>Rv\\<rangle>option_rel", "using K"], ["proof (prove)\nusing this:\n  (eq, (=)) \\<in> Rk \\<rightarrow> Rk \\<rightarrow> bool_rel\n  (bhc, bhc') \\<in> nat_rel \\<rightarrow> Rk \\<rightarrow> nat_rel\n  m = HashMap a n\n  m' = HashMap a' n'\n  (a, a')\n  \\<in> \\<langle>\\<langle>Rk \\<times>\\<^sub>r\n                          Rv\\<rangle>list_rel\\<rangle>array_rel\n  (n, n') \\<in> nat_rel\n  bhc (array_length a) k < array_length a\n  (k, k') \\<in> Rk\n\ngoal (1 subgoal):\n 1. (ahm_lookup eq bhc k m, ahm_lookup (=) bhc' k' m')\n    \\<in> \\<langle>Rv\\<rangle>option_rel", "unfolding ahm_lookup_def[abs_def] rec_hashmap_is_case"], ["proof (prove)\nusing this:\n  (eq, (=)) \\<in> Rk \\<rightarrow> Rk \\<rightarrow> bool_rel\n  (bhc, bhc') \\<in> nat_rel \\<rightarrow> Rk \\<rightarrow> nat_rel\n  m = HashMap a n\n  m' = HashMap a' n'\n  (a, a')\n  \\<in> \\<langle>\\<langle>Rk \\<times>\\<^sub>r\n                          Rv\\<rangle>list_rel\\<rangle>array_rel\n  (n, n') \\<in> nat_rel\n  bhc (array_length a) k < array_length a\n  (k, k') \\<in> Rk\n\ngoal (1 subgoal):\n 1. ((case m of\n      HashMap a uu_ \\<Rightarrow>\n        \\<lambda>eq bhc k. ahm_lookup_aux eq bhc k a)\n      eq bhc k,\n     (case m' of\n      HashMap a uu_ \\<Rightarrow>\n        \\<lambda>eq bhc k. ahm_lookup_aux eq bhc k a)\n      (=) bhc' k')\n    \\<in> \\<langle>Rv\\<rangle>option_rel", "by (simp, parametricity)"], ["proof (state)\nthis:\n  (ahm_lookup eq bhc k m, ahm_lookup (=) bhc' k' m')\n  \\<in> \\<langle>Rv\\<rangle>option_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ahm_lookup_impl:\n  assumes bhc: \"is_bounded_hashcode Id (=) bhc\"\n  shows \"(ahm_lookup (=) bhc, op_map_lookup) \\<in> Id \\<rightarrow> ahm_map_rel' bhc \\<rightarrow> Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ahm_lookup (=) bhc, op_map_lookup)\n    \\<in> Id \\<rightarrow> ahm_map_rel' bhc \\<rightarrow> Id", "unfolding ahm_map_rel'_def br_def ahm_\\<alpha>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ahm_lookup (=) bhc, op_map_lookup)\n    \\<in> Id \\<rightarrow>\n          {(c, a).\n           a = (\\<lambda>k. ahm_lookup (=) bhc k c) \\<and>\n           ahm_invar bhc c} \\<rightarrow>\n          Id", "by force"], ["", "lemma autoref_ahm_lookup[autoref_rules]:\n  assumes \n    bhc[unfolded autoref_tag_defs]: \"SIDE_GEN_ALGO (is_bounded_hashcode Rk eq bhc)\"\n  shows \"(ahm_lookup eq bhc, op_map_lookup) \n    \\<in> Rk \\<rightarrow> \\<langle>Rk,Rv\\<rangle>ahm_rel bhc \\<rightarrow> \\<langle>Rv\\<rangle>option_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ahm_lookup eq bhc, op_map_lookup)\n    \\<in> Rk \\<rightarrow>\n          \\<langle>Rk, Rv\\<rangle>ahm_rel bhc \\<rightarrow>\n          \\<langle>Rv\\<rangle>option_rel", "proof (intro fun_relI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Rk;\n        (aa, a'a) \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc\\<rbrakk>\n       \\<Longrightarrow> (ahm_lookup eq bhc a aa, op_map_lookup a' a'a)\n                         \\<in> \\<langle>Rv\\<rangle>option_rel", "let ?bhc' = \"abstract_bounded_hashcode Rk bhc\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Rk;\n        (aa, a'a) \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc\\<rbrakk>\n       \\<Longrightarrow> (ahm_lookup eq bhc a aa, op_map_lookup a' a'a)\n                         \\<in> \\<langle>Rv\\<rangle>option_rel", "fix k k' a m'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Rk;\n        (aa, a'a) \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc\\<rbrakk>\n       \\<Longrightarrow> (ahm_lookup eq bhc a aa, op_map_lookup a' a'a)\n                         \\<in> \\<langle>Rv\\<rangle>option_rel", "assume K: \"(k,k') \\<in> Rk\""], ["proof (state)\nthis:\n  (k, k') \\<in> Rk\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Rk;\n        (aa, a'a) \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc\\<rbrakk>\n       \\<Longrightarrow> (ahm_lookup eq bhc a aa, op_map_lookup a' a'a)\n                         \\<in> \\<langle>Rv\\<rangle>option_rel", "assume M: \"(a,m') \\<in> \\<langle>Rk,Rv\\<rangle>ahm_rel bhc\""], ["proof (state)\nthis:\n  (a, m') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Rk;\n        (aa, a'a) \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc\\<rbrakk>\n       \\<Longrightarrow> (ahm_lookup eq bhc a aa, op_map_lookup a' a'a)\n                         \\<in> \\<langle>Rv\\<rangle>option_rel", "from bhc"], ["proof (chain)\npicking this:\n  is_bounded_hashcode Rk eq bhc", "have bhc': \"is_bounded_hashcode Id (=) ?bhc'\""], ["proof (prove)\nusing this:\n  is_bounded_hashcode Rk eq bhc\n\ngoal (1 subgoal):\n 1. is_bounded_hashcode Id (=) (abstract_bounded_hashcode Rk bhc)", "by blast"], ["proof (state)\nthis:\n  is_bounded_hashcode Id (=) (abstract_bounded_hashcode Rk bhc)\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Rk;\n        (aa, a'a) \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc\\<rbrakk>\n       \\<Longrightarrow> (ahm_lookup eq bhc a aa, op_map_lookup a' a'a)\n                         \\<in> \\<langle>Rv\\<rangle>option_rel", "from M"], ["proof (chain)\npicking this:\n  (a, m') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc", "obtain a' where M1: \"(a,a') \\<in> \\<langle>Rk,Rv\\<rangle>ahm_map_rel\" and\n      M2: \"(a',m') \\<in> ahm_map_rel' ?bhc'\""], ["proof (prove)\nusing this:\n  (a, m') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>(a, a') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel;\n         (a', m')\n         \\<in> ahm_map_rel' (abstract_bounded_hashcode Rk bhc)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding ahm_rel_def"], ["proof (prove)\nusing this:\n  (a, m')\n  \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel O\n        ahm_map_rel' (abstract_bounded_hashcode Rk bhc)\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>(a, a') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel;\n         (a', m')\n         \\<in> ahm_map_rel' (abstract_bounded_hashcode Rk bhc)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (a, a') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel\n  (a', m') \\<in> ahm_map_rel' (abstract_bounded_hashcode Rk bhc)\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Rk;\n        (aa, a'a) \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc\\<rbrakk>\n       \\<Longrightarrow> (ahm_lookup eq bhc a aa, op_map_lookup a' a'a)\n                         \\<in> \\<langle>Rv\\<rangle>option_rel", "hence inv: \"ahm_invar ?bhc' a'\""], ["proof (prove)\nusing this:\n  (a, a') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel\n  (a', m') \\<in> ahm_map_rel' (abstract_bounded_hashcode Rk bhc)\n\ngoal (1 subgoal):\n 1. ahm_invar (abstract_bounded_hashcode Rk bhc) a'", "unfolding ahm_map_rel'_def br_def"], ["proof (prove)\nusing this:\n  (a, a') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel\n  (a', m')\n  \\<in> {(c, a).\n         a = ahm_\\<alpha> (abstract_bounded_hashcode Rk bhc) c \\<and>\n         ahm_invar (abstract_bounded_hashcode Rk bhc) c}\n\ngoal (1 subgoal):\n 1. ahm_invar (abstract_bounded_hashcode Rk bhc) a'", "by simp"], ["proof (state)\nthis:\n  ahm_invar (abstract_bounded_hashcode Rk bhc) a'\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Rk;\n        (aa, a'a) \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc\\<rbrakk>\n       \\<Longrightarrow> (ahm_lookup eq bhc a aa, op_map_lookup a' a'a)\n                         \\<in> \\<langle>Rv\\<rangle>option_rel", "from relcompI[OF param_ahm_lookup[OF bhc inv K M1]\n                   ahm_lookup_impl[param_fo, OF bhc' _ M2]]"], ["proof (chain)\npicking this:\n  (k', ?x'2) \\<in> Id \\<Longrightarrow>\n  (ahm_lookup eq bhc k a, op_map_lookup ?x'2 m')\n  \\<in> \\<langle>Rv\\<rangle>option_rel O Id", "show \"(ahm_lookup eq bhc k a, op_map_lookup k' m') \\<in> \\<langle>Rv\\<rangle>option_rel\""], ["proof (prove)\nusing this:\n  (k', ?x'2) \\<in> Id \\<Longrightarrow>\n  (ahm_lookup eq bhc k a, op_map_lookup ?x'2 m')\n  \\<in> \\<langle>Rv\\<rangle>option_rel O Id\n\ngoal (1 subgoal):\n 1. (ahm_lookup eq bhc k a, op_map_lookup k' m')\n    \\<in> \\<langle>Rv\\<rangle>option_rel", "by simp"], ["proof (state)\nthis:\n  (ahm_lookup eq bhc k a, op_map_lookup k' m')\n  \\<in> \\<langle>Rv\\<rangle>option_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>@{term \"ahm_iteratei\"}\\<close>"], ["", "abbreviation \"ahm_to_list \\<equiv> it_to_list ahm_iteratei\""], ["", "lemma param_ahm_iteratei_aux[param]:\n  \"(ahm_iteratei_aux,ahm_iteratei_aux) \\<in> \\<langle>\\<langle>Ra\\<rangle>list_rel\\<rangle>array_rel \\<rightarrow>\n       (Rb \\<rightarrow> bool_rel) \\<rightarrow> (Ra \\<rightarrow> Rb \\<rightarrow> Rb) \\<rightarrow> Rb \\<rightarrow> Rb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ahm_iteratei_aux, ahm_iteratei_aux)\n    \\<in> \\<langle>\\<langle>Ra\\<rangle>list_rel\\<rangle>array_rel \\<rightarrow>\n          (Rb \\<rightarrow> bool_rel) \\<rightarrow>\n          (Ra \\<rightarrow> Rb \\<rightarrow> Rb) \\<rightarrow>\n          Rb \\<rightarrow> Rb", "unfolding ahm_iteratei_aux_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rec_array (\\<lambda>xs. foldli (concat xs)),\n     rec_array (\\<lambda>xs. foldli (concat xs)))\n    \\<in> \\<langle>\\<langle>Ra\\<rangle>list_rel\\<rangle>array_rel \\<rightarrow>\n          (Rb \\<rightarrow> bool_rel) \\<rightarrow>\n          (Ra \\<rightarrow> Rb \\<rightarrow> Rb) \\<rightarrow>\n          Rb \\<rightarrow> Rb", "by parametricity"], ["", "lemma param_ahm_iteratei[param]:\n  \"(ahm_iteratei,ahm_iteratei) \\<in> \\<langle>Rk,Rv\\<rangle>ahm_map_rel \\<rightarrow>\n       (Rb \\<rightarrow> bool_rel) \\<rightarrow> (\\<langle>Rk,Rv\\<rangle>prod_rel \\<rightarrow> Rb \\<rightarrow> Rb) \\<rightarrow> Rb \\<rightarrow> Rb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ahm_iteratei, ahm_iteratei)\n    \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel \\<rightarrow>\n          (Rb \\<rightarrow> bool_rel) \\<rightarrow>\n          (Rk \\<times>\\<^sub>r Rv \\<rightarrow>\n           Rb \\<rightarrow> Rb) \\<rightarrow>\n          Rb \\<rightarrow> Rb", "unfolding ahm_iteratei_def[abs_def] rec_hashmap_is_case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>uu. case uu of HashMap a n \\<Rightarrow> ahm_iteratei_aux a,\n     \\<lambda>uu. case uu of HashMap a n \\<Rightarrow> ahm_iteratei_aux a)\n    \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel \\<rightarrow>\n          (Rb \\<rightarrow> bool_rel) \\<rightarrow>\n          (Rk \\<times>\\<^sub>r Rv \\<rightarrow>\n           Rb \\<rightarrow> Rb) \\<rightarrow>\n          Rb \\<rightarrow> Rb", "by parametricity"], ["", "lemma param_ahm_to_list[param]:\n  \"(ahm_to_list,ahm_to_list) \\<in> \n       \\<langle>Rk, Rv\\<rangle>ahm_map_rel \\<rightarrow> \\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ahm_to_list, ahm_to_list)\n    \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel \\<rightarrow>\n          \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel", "unfolding it_to_list_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>s.\n        ahm_iteratei s (\\<lambda>_. True) (\\<lambda>x l. l @ [x]) [],\n     \\<lambda>s.\n        ahm_iteratei s (\\<lambda>_. True) (\\<lambda>x l. l @ [x]) [])\n    \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel \\<rightarrow>\n          \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel", "by parametricity"], ["", "lemma ahm_to_list_distinct[simp,intro]:\n  assumes bhc: \"is_bounded_hashcode Id (=) bhc\"\n  assumes inv: \"ahm_invar bhc m\"\n  shows \"distinct (ahm_to_list m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (ahm_to_list m)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. distinct (ahm_to_list m)", "obtain n a where [simp]: \"m = HashMap a n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a n. m = HashMap a n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases m)"], ["proof (state)\nthis:\n  m = HashMap a n\n\ngoal (1 subgoal):\n 1. distinct (ahm_to_list m)", "obtain l where [simp]: \"a = Array l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l. a = Array l \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (cases a)"], ["proof (state)\nthis:\n  a = Array l\n\ngoal (1 subgoal):\n 1. distinct (ahm_to_list m)", "from inv"], ["proof (chain)\npicking this:\n  ahm_invar bhc m", "show \"distinct (ahm_to_list m)\""], ["proof (prove)\nusing this:\n  ahm_invar bhc m\n\ngoal (1 subgoal):\n 1. distinct (ahm_to_list m)", "unfolding it_to_list_def"], ["proof (prove)\nusing this:\n  ahm_invar bhc m\n\ngoal (1 subgoal):\n 1. distinct (ahm_iteratei m (\\<lambda>_. True) (\\<lambda>x l. l @ [x]) [])", "by (force intro: distinct_mapI dest: ahm_invar_distinct_fst_concatD)"], ["proof (state)\nthis:\n  distinct (ahm_to_list m)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_ahm_to_list:\n  assumes bhc: \"is_bounded_hashcode Id (=) bhc\"\n  assumes ref: \"(m,m') \\<in> ahm_map_rel' bhc\"\n  shows \"map_to_set m' = set (ahm_to_list m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_to_set m' = set (ahm_to_list m)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. map_to_set m' = set (ahm_to_list m)", "obtain n a where [simp]: \"m = HashMap a n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a n. m = HashMap a n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases m)"], ["proof (state)\nthis:\n  m = HashMap a n\n\ngoal (1 subgoal):\n 1. map_to_set m' = set (ahm_to_list m)", "obtain l where [simp]: \"a = Array l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l. a = Array l \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (cases a)"], ["proof (state)\nthis:\n  a = Array l\n\ngoal (1 subgoal):\n 1. map_to_set m' = set (ahm_to_list m)", "from ref"], ["proof (chain)\npicking this:\n  (m, m') \\<in> ahm_map_rel' bhc", "have \\<alpha>[simp]: \"m' = ahm_\\<alpha> bhc m\" and \n      inv: \"ahm_invar bhc m\""], ["proof (prove)\nusing this:\n  (m, m') \\<in> ahm_map_rel' bhc\n\ngoal (1 subgoal):\n 1. m' = ahm_\\<alpha> bhc m &&& ahm_invar bhc m", "unfolding ahm_map_rel'_def br_def"], ["proof (prove)\nusing this:\n  (m, m') \\<in> {(c, a). a = ahm_\\<alpha> bhc c \\<and> ahm_invar bhc c}\n\ngoal (1 subgoal):\n 1. m' = ahm_\\<alpha> bhc m &&& ahm_invar bhc m", "by auto"], ["proof (state)\nthis:\n  m' = ahm_\\<alpha> bhc m\n  ahm_invar bhc m\n\ngoal (1 subgoal):\n 1. map_to_set m' = set (ahm_to_list m)", "from inv"], ["proof (chain)\npicking this:\n  ahm_invar bhc m", "have length: \"length l > 1\""], ["proof (prove)\nusing this:\n  ahm_invar bhc m\n\ngoal (1 subgoal):\n 1. 1 < length l", "unfolding ahm_invar_def ahm_invar_aux_def"], ["proof (prove)\nusing this:\n  rec_hashmap\n   (\\<lambda>a n bhc.\n       (\\<forall>h<array_length a.\n           bucket_ok bhc (array_length a) h (array_get a h) \\<and>\n           list_map_invar (array_get a h)) \\<and>\n       array_foldl (\\<lambda>_ n kvs. n + length kvs) 0 a = n \\<and>\n       1 < array_length a)\n   m bhc\n\ngoal (1 subgoal):\n 1. 1 < length l", "by force"], ["proof (state)\nthis:\n  1 < length l\n\ngoal (1 subgoal):\n 1. map_to_set m' = set (ahm_to_list m)", "from inv"], ["proof (chain)\npicking this:\n  ahm_invar bhc m", "have buckets_ok: \"\\<And>h x. h < length l \\<Longrightarrow> x \\<in> set (l!h) \\<Longrightarrow>\n      bhc (length l) (fst x) = h\"\n      \"\\<And>h. h < length l \\<Longrightarrow>  distinct (map fst (l!h))\""], ["proof (prove)\nusing this:\n  ahm_invar bhc m\n\ngoal (1 subgoal):\n 1. (\\<And>h x.\n        \\<lbrakk>h < length l; x \\<in> set (l ! h)\\<rbrakk>\n        \\<Longrightarrow> bhc (length l) (fst x) = h) &&&\n    (\\<And>h. h < length l \\<Longrightarrow> distinct (map fst (l ! h)))", "by (simp_all add: ahm_invar_def ahm_invar_aux_def \n                        bucket_ok_def list_map_invar_def)"], ["proof (state)\nthis:\n  \\<lbrakk>?h < length l; ?x \\<in> set (l ! ?h)\\<rbrakk>\n  \\<Longrightarrow> bhc (length l) (fst ?x) = ?h\n  ?h < length l \\<Longrightarrow> distinct (map fst (l ! ?h))\n\ngoal (1 subgoal):\n 1. map_to_set m' = set (ahm_to_list m)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_to_set m' = set (ahm_to_list m)", "unfolding it_to_list_def \\<alpha> ahm_\\<alpha>_def ahm_iteratei_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_to_set (\\<lambda>k. ahm_lookup (=) bhc k m) =\n    set (rec_hashmap (\\<lambda>a n. ahm_iteratei_aux a) m (\\<lambda>_. True)\n          (\\<lambda>x l. l @ [x]) [])", "apply (simp add: list_map_lookup_is_map_of)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_to_set (\\<lambda>k. map_of (l ! bhc (length l) k) k) =\n    \\<Union> (set ` set l)", "proof (intro equalityI subsetI, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> map_to_set\n                (\\<lambda>k.\n                    map_of (l ! bhc (length l) k) k) \\<Longrightarrow>\n       x \\<in> \\<Union> (set ` set l)\n 2. \\<And>x.\n       x \\<in> \\<Union> (set ` set l) \\<Longrightarrow>\n       x \\<in> map_to_set (\\<lambda>k. map_of (l ! bhc (length l) k) k)", "case prems: (1 x)"], ["proof (state)\nthis:\n  x \\<in> map_to_set (\\<lambda>k. map_of (l ! bhc (length l) k) k)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> map_to_set\n                (\\<lambda>k.\n                    map_of (l ! bhc (length l) k) k) \\<Longrightarrow>\n       x \\<in> \\<Union> (set ` set l)\n 2. \\<And>x.\n       x \\<in> \\<Union> (set ` set l) \\<Longrightarrow>\n       x \\<in> map_to_set (\\<lambda>k. map_of (l ! bhc (length l) k) k)", "let ?m = \"\\<lambda>k. map_of (l ! bhc (length l) k) k\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> map_to_set\n                (\\<lambda>k.\n                    map_of (l ! bhc (length l) k) k) \\<Longrightarrow>\n       x \\<in> \\<Union> (set ` set l)\n 2. \\<And>x.\n       x \\<in> \\<Union> (set ` set l) \\<Longrightarrow>\n       x \\<in> map_to_set (\\<lambda>k. map_of (l ! bhc (length l) k) k)", "obtain k v where [simp]: \"x = (k, v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k v. x = (k, v) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases x)"], ["proof (state)\nthis:\n  x = (k, v)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> map_to_set\n                (\\<lambda>k.\n                    map_of (l ! bhc (length l) k) k) \\<Longrightarrow>\n       x \\<in> \\<Union> (set ` set l)\n 2. \\<And>x.\n       x \\<in> \\<Union> (set ` set l) \\<Longrightarrow>\n       x \\<in> map_to_set (\\<lambda>k. map_of (l ! bhc (length l) k) k)", "from prems"], ["proof (chain)\npicking this:\n  x \\<in> map_to_set (\\<lambda>k. map_of (l ! bhc (length l) k) k)", "have \"set_to_map (map_to_set ?m) k = Some v\""], ["proof (prove)\nusing this:\n  x \\<in> map_to_set (\\<lambda>k. map_of (l ! bhc (length l) k) k)\n\ngoal (1 subgoal):\n 1. set_to_map (map_to_set (\\<lambda>k. map_of (l ! bhc (length l) k) k))\n     k =\n    Some v", "by (simp add: set_to_map_simp inj_on_fst_map_to_set)"], ["proof (state)\nthis:\n  set_to_map (map_to_set (\\<lambda>k. map_of (l ! bhc (length l) k) k)) k =\n  Some v\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> map_to_set\n                (\\<lambda>k.\n                    map_of (l ! bhc (length l) k) k) \\<Longrightarrow>\n       x \\<in> \\<Union> (set ` set l)\n 2. \\<And>x.\n       x \\<in> \\<Union> (set ` set l) \\<Longrightarrow>\n       x \\<in> map_to_set (\\<lambda>k. map_of (l ! bhc (length l) k) k)", "also"], ["proof (state)\nthis:\n  set_to_map (map_to_set (\\<lambda>k. map_of (l ! bhc (length l) k) k)) k =\n  Some v\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> map_to_set\n                (\\<lambda>k.\n                    map_of (l ! bhc (length l) k) k) \\<Longrightarrow>\n       x \\<in> \\<Union> (set ` set l)\n 2. \\<And>x.\n       x \\<in> \\<Union> (set ` set l) \\<Longrightarrow>\n       x \\<in> map_to_set (\\<lambda>k. map_of (l ! bhc (length l) k) k)", "note map_to_set_inverse"], ["proof (state)\nthis:\n  set_to_map (map_to_set ?m) = ?m\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> map_to_set\n                (\\<lambda>k.\n                    map_of (l ! bhc (length l) k) k) \\<Longrightarrow>\n       x \\<in> \\<Union> (set ` set l)\n 2. \\<And>x.\n       x \\<in> \\<Union> (set ` set l) \\<Longrightarrow>\n       x \\<in> map_to_set (\\<lambda>k. map_of (l ! bhc (length l) k) k)", "finally"], ["proof (chain)\npicking this:\n  map_of (l ! bhc (length l) k) k = Some v", "have \"map_of (l ! bhc (length l) k) k = Some v\""], ["proof (prove)\nusing this:\n  map_of (l ! bhc (length l) k) k = Some v\n\ngoal (1 subgoal):\n 1. map_of (l ! bhc (length l) k) k = Some v", "."], ["proof (state)\nthis:\n  map_of (l ! bhc (length l) k) k = Some v\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> map_to_set\n                (\\<lambda>k.\n                    map_of (l ! bhc (length l) k) k) \\<Longrightarrow>\n       x \\<in> \\<Union> (set ` set l)\n 2. \\<And>x.\n       x \\<in> \\<Union> (set ` set l) \\<Longrightarrow>\n       x \\<in> map_to_set (\\<lambda>k. map_of (l ! bhc (length l) k) k)", "hence \"(k,v) \\<in> set (l ! bhc (length l) k)\""], ["proof (prove)\nusing this:\n  map_of (l ! bhc (length l) k) k = Some v\n\ngoal (1 subgoal):\n 1. (k, v) \\<in> set (l ! bhc (length l) k)", "by (simp add: map_of_SomeD)"], ["proof (state)\nthis:\n  (k, v) \\<in> set (l ! bhc (length l) k)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> map_to_set\n                (\\<lambda>k.\n                    map_of (l ! bhc (length l) k) k) \\<Longrightarrow>\n       x \\<in> \\<Union> (set ` set l)\n 2. \\<And>x.\n       x \\<in> \\<Union> (set ` set l) \\<Longrightarrow>\n       x \\<in> map_to_set (\\<lambda>k. map_of (l ! bhc (length l) k) k)", "moreover"], ["proof (state)\nthis:\n  (k, v) \\<in> set (l ! bhc (length l) k)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> map_to_set\n                (\\<lambda>k.\n                    map_of (l ! bhc (length l) k) k) \\<Longrightarrow>\n       x \\<in> \\<Union> (set ` set l)\n 2. \\<And>x.\n       x \\<in> \\<Union> (set ` set l) \\<Longrightarrow>\n       x \\<in> map_to_set (\\<lambda>k. map_of (l ! bhc (length l) k) k)", "have \"bhc (length l) k < length l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bhc (length l) k < length l", "using bhc length"], ["proof (prove)\nusing this:\n  is_bounded_hashcode Id (=) bhc\n  1 < length l\n\ngoal (1 subgoal):\n 1. bhc (length l) k < length l", ".."], ["proof (state)\nthis:\n  bhc (length l) k < length l\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> map_to_set\n                (\\<lambda>k.\n                    map_of (l ! bhc (length l) k) k) \\<Longrightarrow>\n       x \\<in> \\<Union> (set ` set l)\n 2. \\<And>x.\n       x \\<in> \\<Union> (set ` set l) \\<Longrightarrow>\n       x \\<in> map_to_set (\\<lambda>k. map_of (l ! bhc (length l) k) k)", "ultimately"], ["proof (chain)\npicking this:\n  (k, v) \\<in> set (l ! bhc (length l) k)\n  bhc (length l) k < length l", "show ?case"], ["proof (prove)\nusing this:\n  (k, v) \\<in> set (l ! bhc (length l) k)\n  bhc (length l) k < length l\n\ngoal (1 subgoal):\n 1. x \\<in> \\<Union> (set ` set l)", "by force"], ["proof (state)\nthis:\n  x \\<in> \\<Union> (set ` set l)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union> (set ` set l) \\<Longrightarrow>\n       x \\<in> map_to_set (\\<lambda>k. map_of (l ! bhc (length l) k) k)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union> (set ` set l) \\<Longrightarrow>\n       x \\<in> map_to_set (\\<lambda>k. map_of (l ! bhc (length l) k) k)", "case prems: (2 x)"], ["proof (state)\nthis:\n  x \\<in> \\<Union> (set ` set l)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union> (set ` set l) \\<Longrightarrow>\n       x \\<in> map_to_set (\\<lambda>k. map_of (l ! bhc (length l) k) k)", "obtain k v where [simp]: \"x = (k, v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k v. x = (k, v) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases x)"], ["proof (state)\nthis:\n  x = (k, v)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union> (set ` set l) \\<Longrightarrow>\n       x \\<in> map_to_set (\\<lambda>k. map_of (l ! bhc (length l) k) k)", "from prems"], ["proof (chain)\npicking this:\n  x \\<in> \\<Union> (set ` set l)", "obtain h where h_props: \"(k,v) \\<in> set (l!h)\" \"h < length l\""], ["proof (prove)\nusing this:\n  x \\<in> \\<Union> (set ` set l)\n\ngoal (1 subgoal):\n 1. (\\<And>h.\n        \\<lbrakk>(k, v) \\<in> set (l ! h); h < length l\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (force simp: set_conv_nth)"], ["proof (state)\nthis:\n  (k, v) \\<in> set (l ! h)\n  h < length l\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union> (set ` set l) \\<Longrightarrow>\n       x \\<in> map_to_set (\\<lambda>k. map_of (l ! bhc (length l) k) k)", "moreover"], ["proof (state)\nthis:\n  (k, v) \\<in> set (l ! h)\n  h < length l\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union> (set ` set l) \\<Longrightarrow>\n       x \\<in> map_to_set (\\<lambda>k. map_of (l ! bhc (length l) k) k)", "from h_props and buckets_ok"], ["proof (chain)\npicking this:\n  (k, v) \\<in> set (l ! h)\n  h < length l\n  \\<lbrakk>?h < length l; ?x \\<in> set (l ! ?h)\\<rbrakk>\n  \\<Longrightarrow> bhc (length l) (fst ?x) = ?h\n  ?h < length l \\<Longrightarrow> distinct (map fst (l ! ?h))", "have \"bhc (length l) k = h\" \"distinct (map fst (l!h))\""], ["proof (prove)\nusing this:\n  (k, v) \\<in> set (l ! h)\n  h < length l\n  \\<lbrakk>?h < length l; ?x \\<in> set (l ! ?h)\\<rbrakk>\n  \\<Longrightarrow> bhc (length l) (fst ?x) = ?h\n  ?h < length l \\<Longrightarrow> distinct (map fst (l ! ?h))\n\ngoal (1 subgoal):\n 1. bhc (length l) k = h &&& distinct (map fst (l ! h))", "by auto"], ["proof (state)\nthis:\n  bhc (length l) k = h\n  distinct (map fst (l ! h))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union> (set ` set l) \\<Longrightarrow>\n       x \\<in> map_to_set (\\<lambda>k. map_of (l ! bhc (length l) k) k)", "ultimately"], ["proof (chain)\npicking this:\n  (k, v) \\<in> set (l ! h)\n  h < length l\n  bhc (length l) k = h\n  distinct (map fst (l ! h))", "have \"map_of (l ! bhc (length l) k) k = Some v\""], ["proof (prove)\nusing this:\n  (k, v) \\<in> set (l ! h)\n  h < length l\n  bhc (length l) k = h\n  distinct (map fst (l ! h))\n\ngoal (1 subgoal):\n 1. map_of (l ! bhc (length l) k) k = Some v", "by (force intro: map_of_is_SomeI)"], ["proof (state)\nthis:\n  map_of (l ! bhc (length l) k) k = Some v\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<Union> (set ` set l) \\<Longrightarrow>\n       x \\<in> map_to_set (\\<lambda>k. map_of (l ! bhc (length l) k) k)", "thus ?case"], ["proof (prove)\nusing this:\n  map_of (l ! bhc (length l) k) k = Some v\n\ngoal (1 subgoal):\n 1. x \\<in> map_to_set (\\<lambda>k. map_of (l ! bhc (length l) k) k)", "by simp"], ["proof (state)\nthis:\n  x \\<in> map_to_set (\\<lambda>k. map_of (l ! bhc (length l) k) k)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map_to_set m' = set (ahm_to_list m)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO: find out what the problem is here *)"], ["", "lemma ahm_iteratei_aux_impl:\n  assumes inv: \"ahm_invar_aux bhc n a\"\n  and bhc: \"is_bounded_hashcode Id (=) bhc\"\n  shows \"map_iterator (ahm_iteratei_aux a) (ahm_\\<alpha>_aux bhc a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_iterator (ahm_iteratei_aux a) (ahm_\\<alpha>_aux bhc a)", "proof (cases a, rule)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x. a = Array x \\<Longrightarrow> distinct (map fst (?l0.1 x))\n 2. \\<And>x.\n       a = Array x \\<Longrightarrow>\n       ahm_\\<alpha>_aux bhc a = map_of (?l0.1 x)\n 3. \\<And>x.\n       a = Array x \\<Longrightarrow> ahm_iteratei_aux a = foldli (?l0.1 x)", "fix xs"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x. a = Array x \\<Longrightarrow> distinct (map fst (?l0.1 x))\n 2. \\<And>x.\n       a = Array x \\<Longrightarrow>\n       ahm_\\<alpha>_aux bhc a = map_of (?l0.1 x)\n 3. \\<And>x.\n       a = Array x \\<Longrightarrow> ahm_iteratei_aux a = foldli (?l0.1 x)", "assume [simp]: \"a = Array xs\""], ["proof (state)\nthis:\n  a = Array xs\n\ngoal (3 subgoals):\n 1. \\<And>x. a = Array x \\<Longrightarrow> distinct (map fst (?l0.1 x))\n 2. \\<And>x.\n       a = Array x \\<Longrightarrow>\n       ahm_\\<alpha>_aux bhc a = map_of (?l0.1 x)\n 3. \\<And>x.\n       a = Array x \\<Longrightarrow> ahm_iteratei_aux a = foldli (?l0.1 x)", "show \"ahm_iteratei_aux a = foldli (concat xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ahm_iteratei_aux a = foldli (concat xs)", "by (intro ext, simp)"], ["proof (state)\nthis:\n  ahm_iteratei_aux a = foldli (concat xs)\n\ngoal (2 subgoals):\n 1. \\<And>x. a = Array x \\<Longrightarrow> distinct (map fst (concat x))\n 2. \\<And>x.\n       a = Array x \\<Longrightarrow>\n       ahm_\\<alpha>_aux bhc a = map_of (concat x)", "from ahm_invar_distinct_fst_concatD and inv"], ["proof (chain)\npicking this:\n  ahm_invar_aux ?bhc ?n (Array ?xs) \\<Longrightarrow>\n  distinct (map fst (concat ?xs))\n  ahm_invar_aux bhc n a", "show \"distinct (map fst (concat xs))\""], ["proof (prove)\nusing this:\n  ahm_invar_aux ?bhc ?n (Array ?xs) \\<Longrightarrow>\n  distinct (map fst (concat ?xs))\n  ahm_invar_aux bhc n a\n\ngoal (1 subgoal):\n 1. distinct (map fst (concat xs))", "by simp"], ["proof (state)\nthis:\n  distinct (map fst (concat xs))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       a = Array x \\<Longrightarrow>\n       ahm_\\<alpha>_aux bhc a = map_of (concat x)", "from ahm_\\<alpha>_aux_conv_map_of_concat and assms"], ["proof (chain)\npicking this:\n  \\<lbrakk>is_bounded_hashcode Id (=) ?bhc;\n   ahm_invar_aux ?bhc ?n (Array ?xs)\\<rbrakk>\n  \\<Longrightarrow> ahm_\\<alpha>_aux ?bhc (Array ?xs) = map_of (concat ?xs)\n  ahm_invar_aux bhc n a\n  is_bounded_hashcode Id (=) bhc", "show \"ahm_\\<alpha>_aux bhc a = map_of (concat xs)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>is_bounded_hashcode Id (=) ?bhc;\n   ahm_invar_aux ?bhc ?n (Array ?xs)\\<rbrakk>\n  \\<Longrightarrow> ahm_\\<alpha>_aux ?bhc (Array ?xs) = map_of (concat ?xs)\n  ahm_invar_aux bhc n a\n  is_bounded_hashcode Id (=) bhc\n\ngoal (1 subgoal):\n 1. ahm_\\<alpha>_aux bhc a = map_of (concat xs)", "by simp"], ["proof (state)\nthis:\n  ahm_\\<alpha>_aux bhc a = map_of (concat xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ahm_iteratei_impl:\n  assumes inv: \"ahm_invar bhc m\"\n  and bhc: \"is_bounded_hashcode Id (=) bhc\"\n  shows \"map_iterator (ahm_iteratei m) (ahm_\\<alpha> bhc m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_iterator (ahm_iteratei m) (ahm_\\<alpha> bhc m)", "by (insert assms, cases m, simp add: ahm_\\<alpha>_def2,\n          erule (1) ahm_iteratei_aux_impl)"], ["", "lemma autoref_ahm_is_iterator[autoref_ga_rules]:\n  (*assumes eq: \"GEN_OP_tag ((eq,OP (=) ::: (Rk \\<rightarrow> Rk \\<rightarrow> bool_rel)) \\<in> (Rk \\<rightarrow> Rk \\<rightarrow> bool_rel))\"*)\n  assumes bhc: \"GEN_ALGO_tag (is_bounded_hashcode Rk eq bhc)\"\n  shows \"is_map_to_list Rk Rv (ahm_rel bhc) ahm_to_list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_map_to_list Rk Rv (ahm_rel bhc) ahm_to_list", "unfolding is_map_to_list_def is_map_to_sorted_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>m m'.\n       (m, m') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc \\<longrightarrow>\n       (\\<exists>l'.\n           (ahm_to_list m, l')\n           \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel \\<and>\n           RETURN l'\n           \\<le> it_to_sorted_list (key_rel (\\<lambda>_ _. True))\n                  (map_to_set m'))", "proof (intro allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m m'.\n       (m, m') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc \\<Longrightarrow>\n       \\<exists>l'.\n          (ahm_to_list m, l')\n          \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel \\<and>\n          RETURN l'\n          \\<le> it_to_sorted_list (key_rel (\\<lambda>_ _. True))\n                 (map_to_set m')", "let ?bhc' = \"abstract_bounded_hashcode Rk bhc\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m m'.\n       (m, m') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc \\<Longrightarrow>\n       \\<exists>l'.\n          (ahm_to_list m, l')\n          \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel \\<and>\n          RETURN l'\n          \\<le> it_to_sorted_list (key_rel (\\<lambda>_ _. True))\n                 (map_to_set m')", "fix a m'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m m'.\n       (m, m') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc \\<Longrightarrow>\n       \\<exists>l'.\n          (ahm_to_list m, l')\n          \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel \\<and>\n          RETURN l'\n          \\<le> it_to_sorted_list (key_rel (\\<lambda>_ _. True))\n                 (map_to_set m')", "assume M: \"(a,m') \\<in> \\<langle>Rk,Rv\\<rangle>ahm_rel bhc\""], ["proof (state)\nthis:\n  (a, m') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc\n\ngoal (1 subgoal):\n 1. \\<And>m m'.\n       (m, m') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc \\<Longrightarrow>\n       \\<exists>l'.\n          (ahm_to_list m, l')\n          \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel \\<and>\n          RETURN l'\n          \\<le> it_to_sorted_list (key_rel (\\<lambda>_ _. True))\n                 (map_to_set m')", "from bhc"], ["proof (chain)\npicking this:\n  GEN_ALGO_tag (is_bounded_hashcode Rk eq bhc)", "have bhc': \"is_bounded_hashcode Id (=) ?bhc'\""], ["proof (prove)\nusing this:\n  GEN_ALGO_tag (is_bounded_hashcode Rk eq bhc)\n\ngoal (1 subgoal):\n 1. is_bounded_hashcode Id (=) (abstract_bounded_hashcode Rk bhc)", "unfolding autoref_tag_defs"], ["proof (prove)\nusing this:\n  is_bounded_hashcode Rk eq bhc\n\ngoal (1 subgoal):\n 1. is_bounded_hashcode Id (=) (abstract_bounded_hashcode Rk bhc)", "apply (rule_tac abstract_bhc_is_bhc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_bounded_hashcode Rk eq bhc \\<Longrightarrow>\n    is_bounded_hashcode Rk ?eq1 bhc", "by simp_all"], ["proof (state)\nthis:\n  is_bounded_hashcode Id (=) (abstract_bounded_hashcode Rk bhc)\n\ngoal (1 subgoal):\n 1. \\<And>m m'.\n       (m, m') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc \\<Longrightarrow>\n       \\<exists>l'.\n          (ahm_to_list m, l')\n          \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel \\<and>\n          RETURN l'\n          \\<le> it_to_sorted_list (key_rel (\\<lambda>_ _. True))\n                 (map_to_set m')", "from M"], ["proof (chain)\npicking this:\n  (a, m') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc", "obtain a' where M1: \"(a,a') \\<in> \\<langle>Rk,Rv\\<rangle>ahm_map_rel\" and\n      M2: \"(a',m') \\<in> ahm_map_rel' ?bhc'\""], ["proof (prove)\nusing this:\n  (a, m') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>(a, a') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel;\n         (a', m')\n         \\<in> ahm_map_rel' (abstract_bounded_hashcode Rk bhc)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding ahm_rel_def"], ["proof (prove)\nusing this:\n  (a, m')\n  \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel O\n        ahm_map_rel' (abstract_bounded_hashcode Rk bhc)\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>(a, a') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel;\n         (a', m')\n         \\<in> ahm_map_rel' (abstract_bounded_hashcode Rk bhc)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (a, a') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel\n  (a', m') \\<in> ahm_map_rel' (abstract_bounded_hashcode Rk bhc)\n\ngoal (1 subgoal):\n 1. \\<And>m m'.\n       (m, m') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc \\<Longrightarrow>\n       \\<exists>l'.\n          (ahm_to_list m, l')\n          \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel \\<and>\n          RETURN l'\n          \\<le> it_to_sorted_list (key_rel (\\<lambda>_ _. True))\n                 (map_to_set m')", "hence inv: \"ahm_invar ?bhc' a'\""], ["proof (prove)\nusing this:\n  (a, a') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel\n  (a', m') \\<in> ahm_map_rel' (abstract_bounded_hashcode Rk bhc)\n\ngoal (1 subgoal):\n 1. ahm_invar (abstract_bounded_hashcode Rk bhc) a'", "unfolding ahm_map_rel'_def br_def"], ["proof (prove)\nusing this:\n  (a, a') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel\n  (a', m')\n  \\<in> {(c, a).\n         a = ahm_\\<alpha> (abstract_bounded_hashcode Rk bhc) c \\<and>\n         ahm_invar (abstract_bounded_hashcode Rk bhc) c}\n\ngoal (1 subgoal):\n 1. ahm_invar (abstract_bounded_hashcode Rk bhc) a'", "by simp"], ["proof (state)\nthis:\n  ahm_invar (abstract_bounded_hashcode Rk bhc) a'\n\ngoal (1 subgoal):\n 1. \\<And>m m'.\n       (m, m') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc \\<Longrightarrow>\n       \\<exists>l'.\n          (ahm_to_list m, l')\n          \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel \\<and>\n          RETURN l'\n          \\<le> it_to_sorted_list (key_rel (\\<lambda>_ _. True))\n                 (map_to_set m')", "let ?l' = \"ahm_to_list a'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m m'.\n       (m, m') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc \\<Longrightarrow>\n       \\<exists>l'.\n          (ahm_to_list m, l')\n          \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel \\<and>\n          RETURN l'\n          \\<le> it_to_sorted_list (key_rel (\\<lambda>_ _. True))\n                 (map_to_set m')", "from param_ahm_to_list[param_fo, OF M1]"], ["proof (chain)\npicking this:\n  (ahm_to_list a, ahm_to_list a')\n  \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel", "have \"(ahm_to_list a, ?l') \\<in> \\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel\""], ["proof (prove)\nusing this:\n  (ahm_to_list a, ahm_to_list a')\n  \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. (ahm_to_list a, ahm_to_list a')\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel", "."], ["proof (state)\nthis:\n  (ahm_to_list a, ahm_to_list a')\n  \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. \\<And>m m'.\n       (m, m') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc \\<Longrightarrow>\n       \\<exists>l'.\n          (ahm_to_list m, l')\n          \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel \\<and>\n          RETURN l'\n          \\<le> it_to_sorted_list (key_rel (\\<lambda>_ _. True))\n                 (map_to_set m')", "moreover"], ["proof (state)\nthis:\n  (ahm_to_list a, ahm_to_list a')\n  \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. \\<And>m m'.\n       (m, m') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc \\<Longrightarrow>\n       \\<exists>l'.\n          (ahm_to_list m, l')\n          \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel \\<and>\n          RETURN l'\n          \\<le> it_to_sorted_list (key_rel (\\<lambda>_ _. True))\n                 (map_to_set m')", "from ahm_to_list_distinct[OF bhc' inv]"], ["proof (chain)\npicking this:\n  distinct (ahm_to_list a')", "have \"distinct (ahm_to_list a')\""], ["proof (prove)\nusing this:\n  distinct (ahm_to_list a')\n\ngoal (1 subgoal):\n 1. distinct (ahm_to_list a')", "."], ["proof (state)\nthis:\n  distinct (ahm_to_list a')\n\ngoal (1 subgoal):\n 1. \\<And>m m'.\n       (m, m') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc \\<Longrightarrow>\n       \\<exists>l'.\n          (ahm_to_list m, l')\n          \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel \\<and>\n          RETURN l'\n          \\<le> it_to_sorted_list (key_rel (\\<lambda>_ _. True))\n                 (map_to_set m')", "moreover"], ["proof (state)\nthis:\n  distinct (ahm_to_list a')\n\ngoal (1 subgoal):\n 1. \\<And>m m'.\n       (m, m') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc \\<Longrightarrow>\n       \\<exists>l'.\n          (ahm_to_list m, l')\n          \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel \\<and>\n          RETURN l'\n          \\<le> it_to_sorted_list (key_rel (\\<lambda>_ _. True))\n                 (map_to_set m')", "from set_ahm_to_list[OF bhc' M2]"], ["proof (chain)\npicking this:\n  map_to_set m' = set (ahm_to_list a')", "have \"map_to_set m' = set (ahm_to_list a')\""], ["proof (prove)\nusing this:\n  map_to_set m' = set (ahm_to_list a')\n\ngoal (1 subgoal):\n 1. map_to_set m' = set (ahm_to_list a')", "."], ["proof (state)\nthis:\n  map_to_set m' = set (ahm_to_list a')\n\ngoal (1 subgoal):\n 1. \\<And>m m'.\n       (m, m') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc \\<Longrightarrow>\n       \\<exists>l'.\n          (ahm_to_list m, l')\n          \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel \\<and>\n          RETURN l'\n          \\<le> it_to_sorted_list (key_rel (\\<lambda>_ _. True))\n                 (map_to_set m')", "ultimately"], ["proof (chain)\npicking this:\n  (ahm_to_list a, ahm_to_list a')\n  \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n  distinct (ahm_to_list a')\n  map_to_set m' = set (ahm_to_list a')", "show \"\\<exists>l'. (ahm_to_list a, l') \\<in> \\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel \\<and>\n                        RETURN l' \\<le> it_to_sorted_list \n                            (key_rel (\\<lambda>_ _. True)) (map_to_set m')\""], ["proof (prove)\nusing this:\n  (ahm_to_list a, ahm_to_list a')\n  \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n  distinct (ahm_to_list a')\n  map_to_set m' = set (ahm_to_list a')\n\ngoal (1 subgoal):\n 1. \\<exists>l'.\n       (ahm_to_list a, l')\n       \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel \\<and>\n       RETURN l'\n       \\<le> it_to_sorted_list (key_rel (\\<lambda>_ _. True))\n              (map_to_set m')", "by (force simp: it_to_sorted_list_def key_rel_def[abs_def])"], ["proof (state)\nthis:\n  \\<exists>l'.\n     (ahm_to_list a, l')\n     \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel \\<and>\n     RETURN l'\n     \\<le> it_to_sorted_list (key_rel (\\<lambda>_ _. True)) (map_to_set m')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ahm_iteratei_aux_code[code]:\n  \"ahm_iteratei_aux a c f \\<sigma> = idx_iteratei array_get array_length a c \n       (\\<lambda>x. foldli x c f) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ahm_iteratei_aux a c f \\<sigma> =\n    idx_iteratei array_get array_length a c (\\<lambda>x. foldli x c f)\n     \\<sigma>", "proof(cases a)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       a = Array x \\<Longrightarrow>\n       ahm_iteratei_aux a c f \\<sigma> =\n       idx_iteratei array_get array_length a c (\\<lambda>x. foldli x c f)\n        \\<sigma>", "case [simp]: (Array xs)"], ["proof (state)\nthis:\n  a = Array xs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       a = Array x \\<Longrightarrow>\n       ahm_iteratei_aux a c f \\<sigma> =\n       idx_iteratei array_get array_length a c (\\<lambda>x. foldli x c f)\n        \\<sigma>", "have \"ahm_iteratei_aux a c f \\<sigma> = foldli (concat xs) c f \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ahm_iteratei_aux a c f \\<sigma> = foldli (concat xs) c f \\<sigma>", "by simp"], ["proof (state)\nthis:\n  ahm_iteratei_aux a c f \\<sigma> = foldli (concat xs) c f \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       a = Array x \\<Longrightarrow>\n       ahm_iteratei_aux a c f \\<sigma> =\n       idx_iteratei array_get array_length a c (\\<lambda>x. foldli x c f)\n        \\<sigma>", "also"], ["proof (state)\nthis:\n  ahm_iteratei_aux a c f \\<sigma> = foldli (concat xs) c f \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       a = Array x \\<Longrightarrow>\n       ahm_iteratei_aux a c f \\<sigma> =\n       idx_iteratei array_get array_length a c (\\<lambda>x. foldli x c f)\n        \\<sigma>", "have \"\\<dots> = foldli xs c (\\<lambda>x. foldli x c f) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli (concat xs) c f \\<sigma> =\n    foldli xs c (\\<lambda>x. foldli x c f) \\<sigma>", "by (simp add: foldli_concat)"], ["proof (state)\nthis:\n  foldli (concat xs) c f \\<sigma> =\n  foldli xs c (\\<lambda>x. foldli x c f) \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       a = Array x \\<Longrightarrow>\n       ahm_iteratei_aux a c f \\<sigma> =\n       idx_iteratei array_get array_length a c (\\<lambda>x. foldli x c f)\n        \\<sigma>", "also"], ["proof (state)\nthis:\n  foldli (concat xs) c f \\<sigma> =\n  foldli xs c (\\<lambda>x. foldli x c f) \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       a = Array x \\<Longrightarrow>\n       ahm_iteratei_aux a c f \\<sigma> =\n       idx_iteratei array_get array_length a c (\\<lambda>x. foldli x c f)\n        \\<sigma>", "have \"\\<dots> = idx_iteratei (!) length xs c (\\<lambda>x. foldli x c f) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli xs c (\\<lambda>x. foldli x c f) \\<sigma> =\n    idx_iteratei (!) length xs c (\\<lambda>x. foldli x c f) \\<sigma>", "by (simp add: idx_iteratei_nth_length_conv_foldli)"], ["proof (state)\nthis:\n  foldli xs c (\\<lambda>x. foldli x c f) \\<sigma> =\n  idx_iteratei (!) length xs c (\\<lambda>x. foldli x c f) \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       a = Array x \\<Longrightarrow>\n       ahm_iteratei_aux a c f \\<sigma> =\n       idx_iteratei array_get array_length a c (\\<lambda>x. foldli x c f)\n        \\<sigma>", "also"], ["proof (state)\nthis:\n  foldli xs c (\\<lambda>x. foldli x c f) \\<sigma> =\n  idx_iteratei (!) length xs c (\\<lambda>x. foldli x c f) \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       a = Array x \\<Longrightarrow>\n       ahm_iteratei_aux a c f \\<sigma> =\n       idx_iteratei array_get array_length a c (\\<lambda>x. foldli x c f)\n        \\<sigma>", "have \"\\<dots> = idx_iteratei array_get array_length a c (\\<lambda>x. foldli x c f) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. idx_iteratei (!) length xs c (\\<lambda>x. foldli x c f) \\<sigma> =\n    idx_iteratei array_get array_length a c (\\<lambda>x. foldli x c f)\n     \\<sigma>", "by(simp add: idx_iteratei_array_get_Array_conv_nth)"], ["proof (state)\nthis:\n  idx_iteratei (!) length xs c (\\<lambda>x. foldli x c f) \\<sigma> =\n  idx_iteratei array_get array_length a c (\\<lambda>x. foldli x c f)\n   \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       a = Array x \\<Longrightarrow>\n       ahm_iteratei_aux a c f \\<sigma> =\n       idx_iteratei array_get array_length a c (\\<lambda>x. foldli x c f)\n        \\<sigma>", "finally"], ["proof (chain)\npicking this:\n  ahm_iteratei_aux a c f \\<sigma> =\n  idx_iteratei array_get array_length a c (\\<lambda>x. foldli x c f)\n   \\<sigma>", "show ?thesis"], ["proof (prove)\nusing this:\n  ahm_iteratei_aux a c f \\<sigma> =\n  idx_iteratei array_get array_length a c (\\<lambda>x. foldli x c f)\n   \\<sigma>\n\ngoal (1 subgoal):\n 1. ahm_iteratei_aux a c f \\<sigma> =\n    idx_iteratei array_get array_length a c (\\<lambda>x. foldli x c f)\n     \\<sigma>", "."], ["proof (state)\nthis:\n  ahm_iteratei_aux a c f \\<sigma> =\n  idx_iteratei array_get array_length a c (\\<lambda>x. foldli x c f)\n   \\<sigma>\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>@{term \"ahm_rehash\"}\\<close>"], ["", "lemma array_length_ahm_rehash_aux':\n  \"array_length (ahm_rehash_aux' bhc n kv a) = array_length a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. array_length (ahm_rehash_aux' bhc n kv a) = array_length a", "by(simp add: ahm_rehash_aux'_def Let_def)"], ["", "lemma ahm_rehash_aux'_preserves_ahm_invar_aux:\n  assumes inv: \"ahm_invar_aux bhc n a\"\n  and bhc: \"is_bounded_hashcode Id (=) bhc\"\n  and fresh: \"k \\<notin> fst ` set (array_get a (bhc (array_length a) k))\"\n  shows \"ahm_invar_aux bhc (Suc n) (ahm_rehash_aux' bhc (array_length a) (k, v) a)\"\n  (is \"ahm_invar_aux bhc _ ?a\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. ahm_invar_aux bhc (Suc n)\n     (ahm_rehash_aux' bhc (array_length a) (k, v) a)", "proof(rule ahm_invar_auxI)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>h.\n       h < array_length\n            (ahm_rehash_aux' bhc (array_length a) (k, v)\n              a) \\<Longrightarrow>\n       bucket_ok bhc\n        (array_length (ahm_rehash_aux' bhc (array_length a) (k, v) a)) h\n        (array_get (ahm_rehash_aux' bhc (array_length a) (k, v) a) h)\n 2. \\<And>h.\n       h < array_length\n            (ahm_rehash_aux' bhc (array_length a) (k, v)\n              a) \\<Longrightarrow>\n       list_map_invar\n        (array_get (ahm_rehash_aux' bhc (array_length a) (k, v) a) h)\n 3. Suc n =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (ahm_rehash_aux' bhc (array_length a) (k, v) a)\n 4. 1 < array_length (ahm_rehash_aux' bhc (array_length a) (k, v) a)", "note invD = ahm_invar_auxD[OF inv]"], ["proof (state)\nthis:\n  ?h < array_length a \\<Longrightarrow>\n  bucket_ok bhc (array_length a) ?h (array_get a ?h)\n  ?h < array_length a \\<Longrightarrow> list_map_invar (array_get a ?h)\n  n = array_foldl (\\<lambda>_ n kvs. n + length kvs) 0 a\n  1 < array_length a\n\ngoal (4 subgoals):\n 1. \\<And>h.\n       h < array_length\n            (ahm_rehash_aux' bhc (array_length a) (k, v)\n              a) \\<Longrightarrow>\n       bucket_ok bhc\n        (array_length (ahm_rehash_aux' bhc (array_length a) (k, v) a)) h\n        (array_get (ahm_rehash_aux' bhc (array_length a) (k, v) a) h)\n 2. \\<And>h.\n       h < array_length\n            (ahm_rehash_aux' bhc (array_length a) (k, v)\n              a) \\<Longrightarrow>\n       list_map_invar\n        (array_get (ahm_rehash_aux' bhc (array_length a) (k, v) a) h)\n 3. Suc n =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (ahm_rehash_aux' bhc (array_length a) (k, v) a)\n 4. 1 < array_length (ahm_rehash_aux' bhc (array_length a) (k, v) a)", "let ?l = \"array_length a\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>h.\n       h < array_length\n            (ahm_rehash_aux' bhc (array_length a) (k, v)\n              a) \\<Longrightarrow>\n       bucket_ok bhc\n        (array_length (ahm_rehash_aux' bhc (array_length a) (k, v) a)) h\n        (array_get (ahm_rehash_aux' bhc (array_length a) (k, v) a) h)\n 2. \\<And>h.\n       h < array_length\n            (ahm_rehash_aux' bhc (array_length a) (k, v)\n              a) \\<Longrightarrow>\n       list_map_invar\n        (array_get (ahm_rehash_aux' bhc (array_length a) (k, v) a) h)\n 3. Suc n =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (ahm_rehash_aux' bhc (array_length a) (k, v) a)\n 4. 1 < array_length (ahm_rehash_aux' bhc (array_length a) (k, v) a)", "fix h"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>h.\n       h < array_length\n            (ahm_rehash_aux' bhc (array_length a) (k, v)\n              a) \\<Longrightarrow>\n       bucket_ok bhc\n        (array_length (ahm_rehash_aux' bhc (array_length a) (k, v) a)) h\n        (array_get (ahm_rehash_aux' bhc (array_length a) (k, v) a) h)\n 2. \\<And>h.\n       h < array_length\n            (ahm_rehash_aux' bhc (array_length a) (k, v)\n              a) \\<Longrightarrow>\n       list_map_invar\n        (array_get (ahm_rehash_aux' bhc (array_length a) (k, v) a) h)\n 3. Suc n =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (ahm_rehash_aux' bhc (array_length a) (k, v) a)\n 4. 1 < array_length (ahm_rehash_aux' bhc (array_length a) (k, v) a)", "assume \"h < array_length ?a\""], ["proof (state)\nthis:\n  h < array_length (ahm_rehash_aux' bhc (array_length a) (k, v) a)\n\ngoal (4 subgoals):\n 1. \\<And>h.\n       h < array_length\n            (ahm_rehash_aux' bhc (array_length a) (k, v)\n              a) \\<Longrightarrow>\n       bucket_ok bhc\n        (array_length (ahm_rehash_aux' bhc (array_length a) (k, v) a)) h\n        (array_get (ahm_rehash_aux' bhc (array_length a) (k, v) a) h)\n 2. \\<And>h.\n       h < array_length\n            (ahm_rehash_aux' bhc (array_length a) (k, v)\n              a) \\<Longrightarrow>\n       list_map_invar\n        (array_get (ahm_rehash_aux' bhc (array_length a) (k, v) a) h)\n 3. Suc n =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (ahm_rehash_aux' bhc (array_length a) (k, v) a)\n 4. 1 < array_length (ahm_rehash_aux' bhc (array_length a) (k, v) a)", "hence hlen: \"h < ?l\""], ["proof (prove)\nusing this:\n  h < array_length (ahm_rehash_aux' bhc (array_length a) (k, v) a)\n\ngoal (1 subgoal):\n 1. h < array_length a", "by(simp add: array_length_ahm_rehash_aux')"], ["proof (state)\nthis:\n  h < array_length a\n\ngoal (4 subgoals):\n 1. \\<And>h.\n       h < array_length\n            (ahm_rehash_aux' bhc (array_length a) (k, v)\n              a) \\<Longrightarrow>\n       bucket_ok bhc\n        (array_length (ahm_rehash_aux' bhc (array_length a) (k, v) a)) h\n        (array_get (ahm_rehash_aux' bhc (array_length a) (k, v) a) h)\n 2. \\<And>h.\n       h < array_length\n            (ahm_rehash_aux' bhc (array_length a) (k, v)\n              a) \\<Longrightarrow>\n       list_map_invar\n        (array_get (ahm_rehash_aux' bhc (array_length a) (k, v) a) h)\n 3. Suc n =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (ahm_rehash_aux' bhc (array_length a) (k, v) a)\n 4. 1 < array_length (ahm_rehash_aux' bhc (array_length a) (k, v) a)", "from invD(1,2)[OF this]"], ["proof (chain)\npicking this:\n  bucket_ok bhc (array_length a) h (array_get a h)\n  list_map_invar (array_get a h)", "have bucket: \"bucket_ok bhc ?l h (array_get a h)\"\n    and dist: \"distinct (map fst (array_get a h))\""], ["proof (prove)\nusing this:\n  bucket_ok bhc (array_length a) h (array_get a h)\n  list_map_invar (array_get a h)\n\ngoal (1 subgoal):\n 1. bucket_ok bhc (array_length a) h (array_get a h) &&&\n    distinct (map fst (array_get a h))", "by (simp_all add: list_map_invar_def)"], ["proof (state)\nthis:\n  bucket_ok bhc (array_length a) h (array_get a h)\n  distinct (map fst (array_get a h))\n\ngoal (4 subgoals):\n 1. \\<And>h.\n       h < array_length\n            (ahm_rehash_aux' bhc (array_length a) (k, v)\n              a) \\<Longrightarrow>\n       bucket_ok bhc\n        (array_length (ahm_rehash_aux' bhc (array_length a) (k, v) a)) h\n        (array_get (ahm_rehash_aux' bhc (array_length a) (k, v) a) h)\n 2. \\<And>h.\n       h < array_length\n            (ahm_rehash_aux' bhc (array_length a) (k, v)\n              a) \\<Longrightarrow>\n       list_map_invar\n        (array_get (ahm_rehash_aux' bhc (array_length a) (k, v) a) h)\n 3. Suc n =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (ahm_rehash_aux' bhc (array_length a) (k, v) a)\n 4. 1 < array_length (ahm_rehash_aux' bhc (array_length a) (k, v) a)", "let ?h = \"bhc (array_length a) k\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>h.\n       h < array_length\n            (ahm_rehash_aux' bhc (array_length a) (k, v)\n              a) \\<Longrightarrow>\n       bucket_ok bhc\n        (array_length (ahm_rehash_aux' bhc (array_length a) (k, v) a)) h\n        (array_get (ahm_rehash_aux' bhc (array_length a) (k, v) a) h)\n 2. \\<And>h.\n       h < array_length\n            (ahm_rehash_aux' bhc (array_length a) (k, v)\n              a) \\<Longrightarrow>\n       list_map_invar\n        (array_get (ahm_rehash_aux' bhc (array_length a) (k, v) a) h)\n 3. Suc n =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (ahm_rehash_aux' bhc (array_length a) (k, v) a)\n 4. 1 < array_length (ahm_rehash_aux' bhc (array_length a) (k, v) a)", "from hlen bucket"], ["proof (chain)\npicking this:\n  h < array_length a\n  bucket_ok bhc (array_length a) h (array_get a h)", "show \"bucket_ok bhc (array_length ?a) h (array_get ?a h)\""], ["proof (prove)\nusing this:\n  h < array_length a\n  bucket_ok bhc (array_length a) h (array_get a h)\n\ngoal (1 subgoal):\n 1. bucket_ok bhc\n     (array_length (ahm_rehash_aux' bhc (array_length a) (k, v) a)) h\n     (array_get (ahm_rehash_aux' bhc (array_length a) (k, v) a) h)", "by(cases \"h = ?h\")(auto simp add: ahm_rehash_aux'_def Let_def array_length_ahm_rehash_aux' array_get_array_set_other dest: bucket_okD intro!: bucket_okI)"], ["proof (state)\nthis:\n  bucket_ok bhc\n   (array_length (ahm_rehash_aux' bhc (array_length a) (k, v) a)) h\n   (array_get (ahm_rehash_aux' bhc (array_length a) (k, v) a) h)\n\ngoal (3 subgoals):\n 1. \\<And>h.\n       h < array_length\n            (ahm_rehash_aux' bhc (array_length a) (k, v)\n              a) \\<Longrightarrow>\n       list_map_invar\n        (array_get (ahm_rehash_aux' bhc (array_length a) (k, v) a) h)\n 2. Suc n =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (ahm_rehash_aux' bhc (array_length a) (k, v) a)\n 3. 1 < array_length (ahm_rehash_aux' bhc (array_length a) (k, v) a)", "from dist hlen fresh"], ["proof (chain)\npicking this:\n  distinct (map fst (array_get a h))\n  h < array_length a\n  k \\<notin> fst ` set (array_get a (bhc (array_length a) k))", "show \"list_map_invar (array_get ?a h)\""], ["proof (prove)\nusing this:\n  distinct (map fst (array_get a h))\n  h < array_length a\n  k \\<notin> fst ` set (array_get a (bhc (array_length a) k))\n\ngoal (1 subgoal):\n 1. list_map_invar\n     (array_get (ahm_rehash_aux' bhc (array_length a) (k, v) a) h)", "unfolding list_map_invar_def"], ["proof (prove)\nusing this:\n  distinct (map fst (array_get a h))\n  h < array_length a\n  k \\<notin> fst ` set (array_get a (bhc (array_length a) k))\n\ngoal (1 subgoal):\n 1. (distinct \\<circ>\\<circ> map) fst\n     (array_get (ahm_rehash_aux' bhc (array_length a) (k, v) a) h)", "by(cases \"h = ?h\")(auto simp add: ahm_rehash_aux'_def Let_def array_get_array_set_other)"], ["proof (state)\nthis:\n  list_map_invar\n   (array_get (ahm_rehash_aux' bhc (array_length a) (k, v) a) h)\n\ngoal (2 subgoals):\n 1. Suc n =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (ahm_rehash_aux' bhc (array_length a) (k, v) a)\n 2. 1 < array_length (ahm_rehash_aux' bhc (array_length a) (k, v) a)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. Suc n =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (ahm_rehash_aux' bhc (array_length a) (k, v) a)\n 2. 1 < array_length (ahm_rehash_aux' bhc (array_length a) (k, v) a)", "let ?f = \"\\<lambda>n kvs. n + length kvs\""], ["proof (state)\ngoal (2 subgoals):\n 1. Suc n =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (ahm_rehash_aux' bhc (array_length a) (k, v) a)\n 2. 1 < array_length (ahm_rehash_aux' bhc (array_length a) (k, v) a)", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. Suc n =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (ahm_rehash_aux' bhc (array_length a) (k, v) a)\n 2. 1 < array_length (ahm_rehash_aux' bhc (array_length a) (k, v) a)", "fix n :: nat and xs :: \"('a \\<times> 'b) list list\""], ["proof (state)\ngoal (2 subgoals):\n 1. Suc n =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (ahm_rehash_aux' bhc (array_length a) (k, v) a)\n 2. 1 < array_length (ahm_rehash_aux' bhc (array_length a) (k, v) a)", "have \"foldl ?f n xs = n + foldl ?f 0 xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (\\<lambda>n kvs. n + length kvs) n xs =\n    n + foldl (\\<lambda>n kvs. n + length kvs) 0 xs", "by(induct xs arbitrary:  rule: rev_induct) simp_all"], ["proof (state)\nthis:\n  foldl (\\<lambda>n kvs. n + length kvs) n xs =\n  n + foldl (\\<lambda>n kvs. n + length kvs) 0 xs\n\ngoal (2 subgoals):\n 1. Suc n =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (ahm_rehash_aux' bhc (array_length a) (k, v) a)\n 2. 1 < array_length (ahm_rehash_aux' bhc (array_length a) (k, v) a)", "}"], ["proof (state)\nthis:\n  foldl (\\<lambda>n kvs. n + length kvs) ?na3 ?xs3 =\n  ?na3 + foldl (\\<lambda>n kvs. n + length kvs) 0 ?xs3\n\ngoal (2 subgoals):\n 1. Suc n =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (ahm_rehash_aux' bhc (array_length a) (k, v) a)\n 2. 1 < array_length (ahm_rehash_aux' bhc (array_length a) (k, v) a)", "note fold = this"], ["proof (state)\nthis:\n  foldl (\\<lambda>n kvs. n + length kvs) ?na3 ?xs3 =\n  ?na3 + foldl (\\<lambda>n kvs. n + length kvs) 0 ?xs3\n\ngoal (2 subgoals):\n 1. Suc n =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (ahm_rehash_aux' bhc (array_length a) (k, v) a)\n 2. 1 < array_length (ahm_rehash_aux' bhc (array_length a) (k, v) a)", "let ?h = \"bhc (array_length a) k\""], ["proof (state)\ngoal (2 subgoals):\n 1. Suc n =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (ahm_rehash_aux' bhc (array_length a) (k, v) a)\n 2. 1 < array_length (ahm_rehash_aux' bhc (array_length a) (k, v) a)", "obtain xs where a [simp]: \"a = Array xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs. a = Array xs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases a)"], ["proof (state)\nthis:\n  a = Array xs\n\ngoal (2 subgoals):\n 1. Suc n =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (ahm_rehash_aux' bhc (array_length a) (k, v) a)\n 2. 1 < array_length (ahm_rehash_aux' bhc (array_length a) (k, v) a)", "from inv and bhc"], ["proof (chain)\npicking this:\n  ahm_invar_aux bhc n a\n  is_bounded_hashcode Id (=) bhc", "have [simp]: \"bhc (length xs) k < length xs\""], ["proof (prove)\nusing this:\n  ahm_invar_aux bhc n a\n  is_bounded_hashcode Id (=) bhc\n\ngoal (1 subgoal):\n 1. bhc (length xs) k < length xs", "by (force simp add: ahm_invar_aux_def)"], ["proof (state)\nthis:\n  bhc (length xs) k < length xs\n\ngoal (2 subgoals):\n 1. Suc n =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (ahm_rehash_aux' bhc (array_length a) (k, v) a)\n 2. 1 < array_length (ahm_rehash_aux' bhc (array_length a) (k, v) a)", "have xs: \"xs = take ?h xs @ (xs ! ?h) # drop (Suc ?h) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs =\n    take (bhc (array_length a) k) xs @\n    xs ! bhc (array_length a) k # drop (Suc (bhc (array_length a) k)) xs", "by(simp add: Cons_nth_drop_Suc)"], ["proof (state)\nthis:\n  xs =\n  take (bhc (array_length a) k) xs @\n  xs ! bhc (array_length a) k # drop (Suc (bhc (array_length a) k)) xs\n\ngoal (2 subgoals):\n 1. Suc n =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (ahm_rehash_aux' bhc (array_length a) (k, v) a)\n 2. 1 < array_length (ahm_rehash_aux' bhc (array_length a) (k, v) a)", "from inv"], ["proof (chain)\npicking this:\n  ahm_invar_aux bhc n a", "have \"n = array_foldl (\\<lambda>_ n kvs. n + length kvs) 0 a\""], ["proof (prove)\nusing this:\n  ahm_invar_aux bhc n a\n\ngoal (1 subgoal):\n 1. n = array_foldl (\\<lambda>_ n kvs. n + length kvs) 0 a", "by(auto elim: ahm_invar_auxE)"], ["proof (state)\nthis:\n  n = array_foldl (\\<lambda>_ n kvs. n + length kvs) 0 a\n\ngoal (2 subgoals):\n 1. Suc n =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (ahm_rehash_aux' bhc (array_length a) (k, v) a)\n 2. 1 < array_length (ahm_rehash_aux' bhc (array_length a) (k, v) a)", "hence \"n = foldl ?f 0 (take ?h xs) + length (xs ! ?h) + foldl ?f 0 (drop (Suc ?h) xs)\""], ["proof (prove)\nusing this:\n  n = array_foldl (\\<lambda>_ n kvs. n + length kvs) 0 a\n\ngoal (1 subgoal):\n 1. n =\n    foldl (\\<lambda>n kvs. n + length kvs) 0\n     (take (bhc (array_length a) k) xs) +\n    length (xs ! bhc (array_length a) k) +\n    foldl (\\<lambda>n kvs. n + length kvs) 0\n     (drop (Suc (bhc (array_length a) k)) xs)", "by(simp add: array_foldl_foldl)(subst xs, simp, subst (1 2 3 4) fold, simp)"], ["proof (state)\nthis:\n  n =\n  foldl (\\<lambda>n kvs. n + length kvs) 0\n   (take (bhc (array_length a) k) xs) +\n  length (xs ! bhc (array_length a) k) +\n  foldl (\\<lambda>n kvs. n + length kvs) 0\n   (drop (Suc (bhc (array_length a) k)) xs)\n\ngoal (2 subgoals):\n 1. Suc n =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (ahm_rehash_aux' bhc (array_length a) (k, v) a)\n 2. 1 < array_length (ahm_rehash_aux' bhc (array_length a) (k, v) a)", "thus \"Suc n = array_foldl (\\<lambda>_ n kvs. n + length kvs) 0 ?a\""], ["proof (prove)\nusing this:\n  n =\n  foldl (\\<lambda>n kvs. n + length kvs) 0\n   (take (bhc (array_length a) k) xs) +\n  length (xs ! bhc (array_length a) k) +\n  foldl (\\<lambda>n kvs. n + length kvs) 0\n   (drop (Suc (bhc (array_length a) k)) xs)\n\ngoal (1 subgoal):\n 1. Suc n =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (ahm_rehash_aux' bhc (array_length a) (k, v) a)", "by(simp add: ahm_rehash_aux'_def Let_def array_foldl_foldl foldl_list_update)(subst (1 2 3 4) fold, simp)"], ["proof (state)\nthis:\n  Suc n =\n  array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n   (ahm_rehash_aux' bhc (array_length a) (k, v) a)\n\ngoal (1 subgoal):\n 1. 1 < array_length (ahm_rehash_aux' bhc (array_length a) (k, v) a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 1 < array_length (ahm_rehash_aux' bhc (array_length a) (k, v) a)", "from inv"], ["proof (chain)\npicking this:\n  ahm_invar_aux bhc n a", "have \"1 < array_length a\""], ["proof (prove)\nusing this:\n  ahm_invar_aux bhc n a\n\ngoal (1 subgoal):\n 1. 1 < array_length a", "by(auto elim: ahm_invar_auxE)"], ["proof (state)\nthis:\n  1 < array_length a\n\ngoal (1 subgoal):\n 1. 1 < array_length (ahm_rehash_aux' bhc (array_length a) (k, v) a)", "thus \"1 < array_length ?a\""], ["proof (prove)\nusing this:\n  1 < array_length a\n\ngoal (1 subgoal):\n 1. 1 < array_length (ahm_rehash_aux' bhc (array_length a) (k, v) a)", "by(simp add: array_length_ahm_rehash_aux')"], ["proof (state)\nthis:\n  1 < array_length (ahm_rehash_aux' bhc (array_length a) (k, v) a)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO: Here be dragons *)"], ["", "lemma ahm_rehash_aux_correct:\n  fixes a :: \"('k\\<times>'v) list array\"\n  assumes bhc: \"is_bounded_hashcode Id (=) bhc\"\n  and inv: \"ahm_invar_aux bhc n a\"\n  and \"sz > 1\"\n  shows \"ahm_invar_aux bhc n (ahm_rehash_aux bhc a sz)\" (is \"?thesis1\")\n  and \"ahm_\\<alpha>_aux bhc (ahm_rehash_aux bhc a sz) = ahm_\\<alpha>_aux bhc a\" (is \"?thesis2\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. ahm_invar_aux bhc n (ahm_rehash_aux bhc a sz) &&&\n    ahm_\\<alpha>_aux bhc (ahm_rehash_aux bhc a sz) = ahm_\\<alpha>_aux bhc a", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. ahm_invar_aux bhc n (ahm_rehash_aux bhc a sz)\n 2. ahm_\\<alpha>_aux bhc (ahm_rehash_aux bhc a sz) = ahm_\\<alpha>_aux bhc a", "let ?a = \"ahm_rehash_aux bhc a sz\""], ["proof (state)\ngoal (2 subgoals):\n 1. ahm_invar_aux bhc n (ahm_rehash_aux bhc a sz)\n 2. ahm_\\<alpha>_aux bhc (ahm_rehash_aux bhc a sz) = ahm_\\<alpha>_aux bhc a", "define I where \"I it a' \\<longleftrightarrow>\n   ahm_invar_aux bhc (n - card it) a' \n \\<and> array_length a' = sz \n \\<and> (\\<forall>k. if k \\<in> it then \n      ahm_\\<alpha>_aux bhc a' k = None \n      else ahm_\\<alpha>_aux bhc a' k = ahm_\\<alpha>_aux bhc a k)\" for it a'"], ["proof (state)\nthis:\n  I ?it ?a' =\n  (ahm_invar_aux bhc (n - card ?it) ?a' \\<and>\n   array_length ?a' = sz \\<and>\n   (\\<forall>k.\n       if k \\<in> ?it then ahm_\\<alpha>_aux bhc ?a' k = None\n       else ahm_\\<alpha>_aux bhc ?a' k = ahm_\\<alpha>_aux bhc a k))\n\ngoal (2 subgoals):\n 1. ahm_invar_aux bhc n (ahm_rehash_aux bhc a sz)\n 2. ahm_\\<alpha>_aux bhc (ahm_rehash_aux bhc a sz) = ahm_\\<alpha>_aux bhc a", "note iterator_rule = map_iterator_no_cond_rule_P[\n        OF ahm_iteratei_aux_impl[OF inv bhc], \n        of I \"new_array [] sz\" \"ahm_rehash_aux' bhc sz\" \"I {}\"]"], ["proof (state)\nthis:\n  \\<lbrakk>I (dom (ahm_\\<alpha>_aux bhc a)) (new_array [] sz);\n   \\<And>k v it \\<sigma>.\n      \\<lbrakk>k \\<in> it; ahm_\\<alpha>_aux bhc a k = Some v;\n       it \\<subseteq> dom (ahm_\\<alpha>_aux bhc a); I it \\<sigma>\\<rbrakk>\n      \\<Longrightarrow> I (it - {k})\n                         (ahm_rehash_aux' bhc sz (k, v) \\<sigma>);\n   \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> I {} \\<sigma>\\<rbrakk>\n  \\<Longrightarrow> I {}\n                     (ahm_iteratei_aux a (\\<lambda>_. True)\n                       (ahm_rehash_aux' bhc sz) (new_array [] sz))\n\ngoal (2 subgoals):\n 1. ahm_invar_aux bhc n (ahm_rehash_aux bhc a sz)\n 2. ahm_\\<alpha>_aux bhc (ahm_rehash_aux bhc a sz) = ahm_\\<alpha>_aux bhc a", "from inv"], ["proof (chain)\npicking this:\n  ahm_invar_aux bhc n a", "have \"I {} ?a\""], ["proof (prove)\nusing this:\n  ahm_invar_aux bhc n a\n\ngoal (1 subgoal):\n 1. I {} (ahm_rehash_aux bhc a sz)", "unfolding ahm_rehash_aux_def"], ["proof (prove)\nusing this:\n  ahm_invar_aux bhc n a\n\ngoal (1 subgoal):\n 1. I {}\n     (ahm_iteratei_aux a (\\<lambda>x. True) (ahm_rehash_aux' bhc sz)\n       (new_array [] sz))", "proof(intro iterator_rule)"], ["proof (state)\ngoal (3 subgoals):\n 1. ahm_invar_aux bhc n a \\<Longrightarrow>\n    I (dom (ahm_\\<alpha>_aux bhc a)) (new_array [] sz)\n 2. \\<And>k v it \\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; k \\<in> it;\n        ahm_\\<alpha>_aux bhc a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux bhc a); I it \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I (it - {k})\n                          (ahm_rehash_aux' bhc sz (k, v) \\<sigma>)\n 3. \\<And>\\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; I {} \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I {} \\<sigma>", "from ahm_invar_aux_card_dom_ahm_\\<alpha>_auxD[OF bhc inv]"], ["proof (chain)\npicking this:\n  card (dom (ahm_\\<alpha>_aux bhc a)) = n", "have \"card (dom (ahm_\\<alpha>_aux bhc a)) = n\""], ["proof (prove)\nusing this:\n  card (dom (ahm_\\<alpha>_aux bhc a)) = n\n\ngoal (1 subgoal):\n 1. card (dom (ahm_\\<alpha>_aux bhc a)) = n", "."], ["proof (state)\nthis:\n  card (dom (ahm_\\<alpha>_aux bhc a)) = n\n\ngoal (3 subgoals):\n 1. ahm_invar_aux bhc n a \\<Longrightarrow>\n    I (dom (ahm_\\<alpha>_aux bhc a)) (new_array [] sz)\n 2. \\<And>k v it \\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; k \\<in> it;\n        ahm_\\<alpha>_aux bhc a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux bhc a); I it \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I (it - {k})\n                          (ahm_rehash_aux' bhc sz (k, v) \\<sigma>)\n 3. \\<And>\\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; I {} \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I {} \\<sigma>", "moreover"], ["proof (state)\nthis:\n  card (dom (ahm_\\<alpha>_aux bhc a)) = n\n\ngoal (3 subgoals):\n 1. ahm_invar_aux bhc n a \\<Longrightarrow>\n    I (dom (ahm_\\<alpha>_aux bhc a)) (new_array [] sz)\n 2. \\<And>k v it \\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; k \\<in> it;\n        ahm_\\<alpha>_aux bhc a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux bhc a); I it \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I (it - {k})\n                          (ahm_rehash_aux' bhc sz (k, v) \\<sigma>)\n 3. \\<And>\\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; I {} \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I {} \\<sigma>", "from ahm_invar_aux_new_array[OF \\<open>1 < sz\\<close>]"], ["proof (chain)\npicking this:\n  ahm_invar_aux ?bhc 0 (new_array [] sz)", "have \"ahm_invar_aux bhc 0 (new_array ([]::('k\\<times>'v) list) sz)\""], ["proof (prove)\nusing this:\n  ahm_invar_aux ?bhc 0 (new_array [] sz)\n\ngoal (1 subgoal):\n 1. ahm_invar_aux bhc 0 (new_array [] sz)", "."], ["proof (state)\nthis:\n  ahm_invar_aux bhc 0 (new_array [] sz)\n\ngoal (3 subgoals):\n 1. ahm_invar_aux bhc n a \\<Longrightarrow>\n    I (dom (ahm_\\<alpha>_aux bhc a)) (new_array [] sz)\n 2. \\<And>k v it \\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; k \\<in> it;\n        ahm_\\<alpha>_aux bhc a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux bhc a); I it \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I (it - {k})\n                          (ahm_rehash_aux' bhc sz (k, v) \\<sigma>)\n 3. \\<And>\\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; I {} \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I {} \\<sigma>", "moreover"], ["proof (state)\nthis:\n  ahm_invar_aux bhc 0 (new_array [] sz)\n\ngoal (3 subgoals):\n 1. ahm_invar_aux bhc n a \\<Longrightarrow>\n    I (dom (ahm_\\<alpha>_aux bhc a)) (new_array [] sz)\n 2. \\<And>k v it \\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; k \\<in> it;\n        ahm_\\<alpha>_aux bhc a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux bhc a); I it \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I (it - {k})\n                          (ahm_rehash_aux' bhc sz (k, v) \\<sigma>)\n 3. \\<And>\\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; I {} \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I {} \\<sigma>", "{"], ["proof (state)\nthis:\n  ahm_invar_aux bhc 0 (new_array [] sz)\n\ngoal (3 subgoals):\n 1. ahm_invar_aux bhc n a \\<Longrightarrow>\n    I (dom (ahm_\\<alpha>_aux bhc a)) (new_array [] sz)\n 2. \\<And>k v it \\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; k \\<in> it;\n        ahm_\\<alpha>_aux bhc a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux bhc a); I it \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I (it - {k})\n                          (ahm_rehash_aux' bhc sz (k, v) \\<sigma>)\n 3. \\<And>\\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; I {} \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I {} \\<sigma>", "fix k"], ["proof (state)\ngoal (3 subgoals):\n 1. ahm_invar_aux bhc n a \\<Longrightarrow>\n    I (dom (ahm_\\<alpha>_aux bhc a)) (new_array [] sz)\n 2. \\<And>k v it \\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; k \\<in> it;\n        ahm_\\<alpha>_aux bhc a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux bhc a); I it \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I (it - {k})\n                          (ahm_rehash_aux' bhc sz (k, v) \\<sigma>)\n 3. \\<And>\\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; I {} \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I {} \\<sigma>", "assume \"k \\<notin> dom (ahm_\\<alpha>_aux bhc a)\""], ["proof (state)\nthis:\n  k \\<notin> dom (ahm_\\<alpha>_aux bhc a)\n\ngoal (3 subgoals):\n 1. ahm_invar_aux bhc n a \\<Longrightarrow>\n    I (dom (ahm_\\<alpha>_aux bhc a)) (new_array [] sz)\n 2. \\<And>k v it \\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; k \\<in> it;\n        ahm_\\<alpha>_aux bhc a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux bhc a); I it \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I (it - {k})\n                          (ahm_rehash_aux' bhc sz (k, v) \\<sigma>)\n 3. \\<And>\\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; I {} \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I {} \\<sigma>", "hence \"ahm_\\<alpha>_aux bhc a k = None\""], ["proof (prove)\nusing this:\n  k \\<notin> dom (ahm_\\<alpha>_aux bhc a)\n\ngoal (1 subgoal):\n 1. ahm_\\<alpha>_aux bhc a k = None", "by auto"], ["proof (state)\nthis:\n  ahm_\\<alpha>_aux bhc a k = None\n\ngoal (3 subgoals):\n 1. ahm_invar_aux bhc n a \\<Longrightarrow>\n    I (dom (ahm_\\<alpha>_aux bhc a)) (new_array [] sz)\n 2. \\<And>k v it \\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; k \\<in> it;\n        ahm_\\<alpha>_aux bhc a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux bhc a); I it \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I (it - {k})\n                          (ahm_rehash_aux' bhc sz (k, v) \\<sigma>)\n 3. \\<And>\\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; I {} \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I {} \\<sigma>", "hence \"ahm_\\<alpha>_aux bhc (new_array [] sz) k = ahm_\\<alpha>_aux bhc a k\""], ["proof (prove)\nusing this:\n  ahm_\\<alpha>_aux bhc a k = None\n\ngoal (1 subgoal):\n 1. ahm_\\<alpha>_aux bhc (new_array [] sz) k = ahm_\\<alpha>_aux bhc a k", "using assms"], ["proof (prove)\nusing this:\n  ahm_\\<alpha>_aux bhc a k = None\n  is_bounded_hashcode Id (=) bhc\n  ahm_invar_aux bhc n a\n  1 < sz\n\ngoal (1 subgoal):\n 1. ahm_\\<alpha>_aux bhc (new_array [] sz) k = ahm_\\<alpha>_aux bhc a k", "by simp"], ["proof (state)\nthis:\n  ahm_\\<alpha>_aux bhc (new_array [] sz) k = ahm_\\<alpha>_aux bhc a k\n\ngoal (3 subgoals):\n 1. ahm_invar_aux bhc n a \\<Longrightarrow>\n    I (dom (ahm_\\<alpha>_aux bhc a)) (new_array [] sz)\n 2. \\<And>k v it \\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; k \\<in> it;\n        ahm_\\<alpha>_aux bhc a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux bhc a); I it \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I (it - {k})\n                          (ahm_rehash_aux' bhc sz (k, v) \\<sigma>)\n 3. \\<And>\\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; I {} \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I {} \\<sigma>", "}"], ["proof (state)\nthis:\n  ?k2 \\<notin> dom (ahm_\\<alpha>_aux bhc a) \\<Longrightarrow>\n  ahm_\\<alpha>_aux bhc (new_array [] sz) ?k2 = ahm_\\<alpha>_aux bhc a ?k2\n\ngoal (3 subgoals):\n 1. ahm_invar_aux bhc n a \\<Longrightarrow>\n    I (dom (ahm_\\<alpha>_aux bhc a)) (new_array [] sz)\n 2. \\<And>k v it \\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; k \\<in> it;\n        ahm_\\<alpha>_aux bhc a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux bhc a); I it \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I (it - {k})\n                          (ahm_rehash_aux' bhc sz (k, v) \\<sigma>)\n 3. \\<And>\\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; I {} \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I {} \\<sigma>", "ultimately"], ["proof (chain)\npicking this:\n  card (dom (ahm_\\<alpha>_aux bhc a)) = n\n  ahm_invar_aux bhc 0 (new_array [] sz)\n  ?k2 \\<notin> dom (ahm_\\<alpha>_aux bhc a) \\<Longrightarrow>\n  ahm_\\<alpha>_aux bhc (new_array [] sz) ?k2 = ahm_\\<alpha>_aux bhc a ?k2", "show \"I (dom (ahm_\\<alpha>_aux bhc a)) (new_array [] sz)\""], ["proof (prove)\nusing this:\n  card (dom (ahm_\\<alpha>_aux bhc a)) = n\n  ahm_invar_aux bhc 0 (new_array [] sz)\n  ?k2 \\<notin> dom (ahm_\\<alpha>_aux bhc a) \\<Longrightarrow>\n  ahm_\\<alpha>_aux bhc (new_array [] sz) ?k2 = ahm_\\<alpha>_aux bhc a ?k2\n\ngoal (1 subgoal):\n 1. I (dom (ahm_\\<alpha>_aux bhc a)) (new_array [] sz)", "using assms"], ["proof (prove)\nusing this:\n  card (dom (ahm_\\<alpha>_aux bhc a)) = n\n  ahm_invar_aux bhc 0 (new_array [] sz)\n  ?k2 \\<notin> dom (ahm_\\<alpha>_aux bhc a) \\<Longrightarrow>\n  ahm_\\<alpha>_aux bhc (new_array [] sz) ?k2 = ahm_\\<alpha>_aux bhc a ?k2\n  is_bounded_hashcode Id (=) bhc\n  ahm_invar_aux bhc n a\n  1 < sz\n\ngoal (1 subgoal):\n 1. I (dom (ahm_\\<alpha>_aux bhc a)) (new_array [] sz)", "by (simp add: I_def)"], ["proof (state)\nthis:\n  I (dom (ahm_\\<alpha>_aux bhc a)) (new_array [] sz)\n\ngoal (2 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; k \\<in> it;\n        ahm_\\<alpha>_aux bhc a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux bhc a); I it \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I (it - {k})\n                          (ahm_rehash_aux' bhc sz (k, v) \\<sigma>)\n 2. \\<And>\\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; I {} \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I {} \\<sigma>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; k \\<in> it;\n        ahm_\\<alpha>_aux bhc a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux bhc a); I it \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I (it - {k})\n                          (ahm_rehash_aux' bhc sz (k, v) \\<sigma>)\n 2. \\<And>\\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; I {} \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I {} \\<sigma>", "fix k :: 'k\n      and v :: 'v\n      and it a'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; k \\<in> it;\n        ahm_\\<alpha>_aux bhc a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux bhc a); I it \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I (it - {k})\n                          (ahm_rehash_aux' bhc sz (k, v) \\<sigma>)\n 2. \\<And>\\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; I {} \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I {} \\<sigma>", "assume \"k \\<in> it\" \"ahm_\\<alpha>_aux bhc a k = Some v\" \n      and it_sub: \"it \\<subseteq> dom (ahm_\\<alpha>_aux bhc a)\"\n      and I: \"I it a'\""], ["proof (state)\nthis:\n  k \\<in> it\n  ahm_\\<alpha>_aux bhc a k = Some v\n  it \\<subseteq> dom (ahm_\\<alpha>_aux bhc a)\n  I it a'\n\ngoal (2 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; k \\<in> it;\n        ahm_\\<alpha>_aux bhc a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux bhc a); I it \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I (it - {k})\n                          (ahm_rehash_aux' bhc sz (k, v) \\<sigma>)\n 2. \\<And>\\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; I {} \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I {} \\<sigma>", "from I"], ["proof (chain)\npicking this:\n  I it a'", "have inv': \"ahm_invar_aux bhc (n - card it) a'\" \n      and a'_eq_a: \"\\<And>k. k \\<notin> it \\<Longrightarrow> ahm_\\<alpha>_aux bhc a' k = ahm_\\<alpha>_aux bhc a k\" \n      and a'_None: \"\\<And>k. k \\<in> it \\<Longrightarrow> ahm_\\<alpha>_aux bhc a' k = None\"\n      and [simp]: \"sz = array_length a'\""], ["proof (prove)\nusing this:\n  I it a'\n\ngoal (1 subgoal):\n 1. (ahm_invar_aux bhc (n - card it) a' &&&\n     (\\<And>k.\n         k \\<notin> it \\<Longrightarrow>\n         ahm_\\<alpha>_aux bhc a' k = ahm_\\<alpha>_aux bhc a k)) &&&\n    (\\<And>k.\n        k \\<in> it \\<Longrightarrow> ahm_\\<alpha>_aux bhc a' k = None) &&&\n    sz = array_length a'", "by (auto split: if_split_asm simp: I_def)"], ["proof (state)\nthis:\n  ahm_invar_aux bhc (n - card it) a'\n  ?k \\<notin> it \\<Longrightarrow>\n  ahm_\\<alpha>_aux bhc a' ?k = ahm_\\<alpha>_aux bhc a ?k\n  ?k \\<in> it \\<Longrightarrow> ahm_\\<alpha>_aux bhc a' ?k = None\n  sz = array_length a'\n\ngoal (2 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; k \\<in> it;\n        ahm_\\<alpha>_aux bhc a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux bhc a); I it \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I (it - {k})\n                          (ahm_rehash_aux' bhc sz (k, v) \\<sigma>)\n 2. \\<And>\\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; I {} \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I {} \\<sigma>", "from it_sub finite_dom_ahm_\\<alpha>_aux[OF bhc inv]"], ["proof (chain)\npicking this:\n  it \\<subseteq> dom (ahm_\\<alpha>_aux bhc a)\n  finite (dom (ahm_\\<alpha>_aux bhc a))", "have \"finite it\""], ["proof (prove)\nusing this:\n  it \\<subseteq> dom (ahm_\\<alpha>_aux bhc a)\n  finite (dom (ahm_\\<alpha>_aux bhc a))\n\ngoal (1 subgoal):\n 1. finite it", "by(rule finite_subset)"], ["proof (state)\nthis:\n  finite it\n\ngoal (2 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; k \\<in> it;\n        ahm_\\<alpha>_aux bhc a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux bhc a); I it \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I (it - {k})\n                          (ahm_rehash_aux' bhc sz (k, v) \\<sigma>)\n 2. \\<And>\\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; I {} \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I {} \\<sigma>", "moreover"], ["proof (state)\nthis:\n  finite it\n\ngoal (2 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; k \\<in> it;\n        ahm_\\<alpha>_aux bhc a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux bhc a); I it \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I (it - {k})\n                          (ahm_rehash_aux' bhc sz (k, v) \\<sigma>)\n 2. \\<And>\\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; I {} \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I {} \\<sigma>", "with \\<open>k \\<in> it\\<close>"], ["proof (chain)\npicking this:\n  k \\<in> it\n  finite it", "have \"card it > 0\""], ["proof (prove)\nusing this:\n  k \\<in> it\n  finite it\n\ngoal (1 subgoal):\n 1. 0 < card it", "by (auto simp add: card_gt_0_iff)"], ["proof (state)\nthis:\n  0 < card it\n\ngoal (2 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; k \\<in> it;\n        ahm_\\<alpha>_aux bhc a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux bhc a); I it \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I (it - {k})\n                          (ahm_rehash_aux' bhc sz (k, v) \\<sigma>)\n 2. \\<And>\\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; I {} \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I {} \\<sigma>", "moreover"], ["proof (state)\nthis:\n  0 < card it\n\ngoal (2 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; k \\<in> it;\n        ahm_\\<alpha>_aux bhc a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux bhc a); I it \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I (it - {k})\n                          (ahm_rehash_aux' bhc sz (k, v) \\<sigma>)\n 2. \\<And>\\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; I {} \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I {} \\<sigma>", "from finite_dom_ahm_\\<alpha>_aux[OF bhc inv] it_sub"], ["proof (chain)\npicking this:\n  finite (dom (ahm_\\<alpha>_aux bhc a))\n  it \\<subseteq> dom (ahm_\\<alpha>_aux bhc a)", "have \"card it \\<le> card (dom (ahm_\\<alpha>_aux bhc a))\""], ["proof (prove)\nusing this:\n  finite (dom (ahm_\\<alpha>_aux bhc a))\n  it \\<subseteq> dom (ahm_\\<alpha>_aux bhc a)\n\ngoal (1 subgoal):\n 1. card it \\<le> card (dom (ahm_\\<alpha>_aux bhc a))", "by (rule card_mono)"], ["proof (state)\nthis:\n  card it \\<le> card (dom (ahm_\\<alpha>_aux bhc a))\n\ngoal (2 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; k \\<in> it;\n        ahm_\\<alpha>_aux bhc a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux bhc a); I it \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I (it - {k})\n                          (ahm_rehash_aux' bhc sz (k, v) \\<sigma>)\n 2. \\<And>\\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; I {} \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I {} \\<sigma>", "moreover"], ["proof (state)\nthis:\n  card it \\<le> card (dom (ahm_\\<alpha>_aux bhc a))\n\ngoal (2 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; k \\<in> it;\n        ahm_\\<alpha>_aux bhc a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux bhc a); I it \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I (it - {k})\n                          (ahm_rehash_aux' bhc sz (k, v) \\<sigma>)\n 2. \\<And>\\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; I {} \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I {} \\<sigma>", "have \"\\<dots> = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (dom (ahm_\\<alpha>_aux bhc a)) = n", "using inv"], ["proof (prove)\nusing this:\n  ahm_invar_aux bhc n a\n\ngoal (1 subgoal):\n 1. card (dom (ahm_\\<alpha>_aux bhc a)) = n", "by(simp add: ahm_invar_aux_card_dom_ahm_\\<alpha>_auxD[OF bhc])"], ["proof (state)\nthis:\n  card (dom (ahm_\\<alpha>_aux bhc a)) = n\n\ngoal (2 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; k \\<in> it;\n        ahm_\\<alpha>_aux bhc a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux bhc a); I it \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I (it - {k})\n                          (ahm_rehash_aux' bhc sz (k, v) \\<sigma>)\n 2. \\<And>\\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; I {} \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I {} \\<sigma>", "ultimately"], ["proof (chain)\npicking this:\n  finite it\n  0 < card it\n  card it \\<le> card (dom (ahm_\\<alpha>_aux bhc a))\n  card (dom (ahm_\\<alpha>_aux bhc a)) = n", "have \"n - card (it - {k}) = (n - card it) + 1\""], ["proof (prove)\nusing this:\n  finite it\n  0 < card it\n  card it \\<le> card (dom (ahm_\\<alpha>_aux bhc a))\n  card (dom (ahm_\\<alpha>_aux bhc a)) = n\n\ngoal (1 subgoal):\n 1. n - card (it - {k}) = n - card it + 1", "using \\<open>k \\<in> it\\<close>"], ["proof (prove)\nusing this:\n  finite it\n  0 < card it\n  card it \\<le> card (dom (ahm_\\<alpha>_aux bhc a))\n  card (dom (ahm_\\<alpha>_aux bhc a)) = n\n  k \\<in> it\n\ngoal (1 subgoal):\n 1. n - card (it - {k}) = n - card it + 1", "by auto"], ["proof (state)\nthis:\n  n - card (it - {k}) = n - card it + 1\n\ngoal (2 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; k \\<in> it;\n        ahm_\\<alpha>_aux bhc a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux bhc a); I it \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I (it - {k})\n                          (ahm_rehash_aux' bhc sz (k, v) \\<sigma>)\n 2. \\<And>\\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; I {} \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I {} \\<sigma>", "moreover"], ["proof (state)\nthis:\n  n - card (it - {k}) = n - card it + 1\n\ngoal (2 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; k \\<in> it;\n        ahm_\\<alpha>_aux bhc a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux bhc a); I it \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I (it - {k})\n                          (ahm_rehash_aux' bhc sz (k, v) \\<sigma>)\n 2. \\<And>\\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; I {} \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I {} \\<sigma>", "from \\<open>k \\<in> it\\<close>"], ["proof (chain)\npicking this:\n  k \\<in> it", "have \"ahm_\\<alpha>_aux bhc a' k = None\""], ["proof (prove)\nusing this:\n  k \\<in> it\n\ngoal (1 subgoal):\n 1. ahm_\\<alpha>_aux bhc a' k = None", "by (rule a'_None)"], ["proof (state)\nthis:\n  ahm_\\<alpha>_aux bhc a' k = None\n\ngoal (2 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; k \\<in> it;\n        ahm_\\<alpha>_aux bhc a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux bhc a); I it \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I (it - {k})\n                          (ahm_rehash_aux' bhc sz (k, v) \\<sigma>)\n 2. \\<And>\\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; I {} \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I {} \\<sigma>", "hence \"k \\<notin> fst ` set (array_get a' (bhc (array_length a') k))\""], ["proof (prove)\nusing this:\n  ahm_\\<alpha>_aux bhc a' k = None\n\ngoal (1 subgoal):\n 1. k \\<notin> fst ` set (array_get a' (bhc (array_length a') k))", "by (simp add: ahm_\\<alpha>_aux_def2 map_of_eq_None_iff)"], ["proof (state)\nthis:\n  k \\<notin> fst ` set (array_get a' (bhc (array_length a') k))\n\ngoal (2 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; k \\<in> it;\n        ahm_\\<alpha>_aux bhc a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux bhc a); I it \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I (it - {k})\n                          (ahm_rehash_aux' bhc sz (k, v) \\<sigma>)\n 2. \\<And>\\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; I {} \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I {} \\<sigma>", "ultimately"], ["proof (chain)\npicking this:\n  n - card (it - {k}) = n - card it + 1\n  k \\<notin> fst ` set (array_get a' (bhc (array_length a') k))", "have \"ahm_invar_aux bhc (n - card (it - {k})) \n        (ahm_rehash_aux' bhc sz (k, v) a')\""], ["proof (prove)\nusing this:\n  n - card (it - {k}) = n - card it + 1\n  k \\<notin> fst ` set (array_get a' (bhc (array_length a') k))\n\ngoal (1 subgoal):\n 1. ahm_invar_aux bhc (n - card (it - {k}))\n     (ahm_rehash_aux' bhc sz (k, v) a')", "using ahm_rehash_aux'_preserves_ahm_invar_aux[OF inv' bhc]"], ["proof (prove)\nusing this:\n  n - card (it - {k}) = n - card it + 1\n  k \\<notin> fst ` set (array_get a' (bhc (array_length a') k))\n  ?k \\<notin> fst `\n              set (array_get a'\n                    (bhc (array_length a') ?k)) \\<Longrightarrow>\n  ahm_invar_aux bhc (Suc (n - card it))\n   (ahm_rehash_aux' bhc (array_length a') (?k, ?v) a')\n\ngoal (1 subgoal):\n 1. ahm_invar_aux bhc (n - card (it - {k}))\n     (ahm_rehash_aux' bhc sz (k, v) a')", "by simp"], ["proof (state)\nthis:\n  ahm_invar_aux bhc (n - card (it - {k})) (ahm_rehash_aux' bhc sz (k, v) a')\n\ngoal (2 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; k \\<in> it;\n        ahm_\\<alpha>_aux bhc a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux bhc a); I it \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I (it - {k})\n                          (ahm_rehash_aux' bhc sz (k, v) \\<sigma>)\n 2. \\<And>\\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; I {} \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I {} \\<sigma>", "moreover"], ["proof (state)\nthis:\n  ahm_invar_aux bhc (n - card (it - {k})) (ahm_rehash_aux' bhc sz (k, v) a')\n\ngoal (2 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; k \\<in> it;\n        ahm_\\<alpha>_aux bhc a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux bhc a); I it \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I (it - {k})\n                          (ahm_rehash_aux' bhc sz (k, v) \\<sigma>)\n 2. \\<And>\\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; I {} \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I {} \\<sigma>", "have \"array_length (ahm_rehash_aux' bhc sz (k, v) a') = sz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. array_length (ahm_rehash_aux' bhc sz (k, v) a') = sz", "by (simp add: array_length_ahm_rehash_aux')"], ["proof (state)\nthis:\n  array_length (ahm_rehash_aux' bhc sz (k, v) a') = sz\n\ngoal (2 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; k \\<in> it;\n        ahm_\\<alpha>_aux bhc a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux bhc a); I it \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I (it - {k})\n                          (ahm_rehash_aux' bhc sz (k, v) \\<sigma>)\n 2. \\<And>\\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; I {} \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I {} \\<sigma>", "moreover"], ["proof (state)\nthis:\n  array_length (ahm_rehash_aux' bhc sz (k, v) a') = sz\n\ngoal (2 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; k \\<in> it;\n        ahm_\\<alpha>_aux bhc a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux bhc a); I it \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I (it - {k})\n                          (ahm_rehash_aux' bhc sz (k, v) \\<sigma>)\n 2. \\<And>\\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; I {} \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I {} \\<sigma>", "{"], ["proof (state)\nthis:\n  array_length (ahm_rehash_aux' bhc sz (k, v) a') = sz\n\ngoal (2 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; k \\<in> it;\n        ahm_\\<alpha>_aux bhc a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux bhc a); I it \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I (it - {k})\n                          (ahm_rehash_aux' bhc sz (k, v) \\<sigma>)\n 2. \\<And>\\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; I {} \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I {} \\<sigma>", "fix k'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; k \\<in> it;\n        ahm_\\<alpha>_aux bhc a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux bhc a); I it \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I (it - {k})\n                          (ahm_rehash_aux' bhc sz (k, v) \\<sigma>)\n 2. \\<And>\\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; I {} \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I {} \\<sigma>", "assume \"k' \\<in> it - {k}\""], ["proof (state)\nthis:\n  k' \\<in> it - {k}\n\ngoal (2 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; k \\<in> it;\n        ahm_\\<alpha>_aux bhc a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux bhc a); I it \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I (it - {k})\n                          (ahm_rehash_aux' bhc sz (k, v) \\<sigma>)\n 2. \\<And>\\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; I {} \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I {} \\<sigma>", "with is_bounded_hashcodeD(3)[OF bhc \\<open>1 < sz\\<close>, of k'] a'_None[of k']"], ["proof (chain)\npicking this:\n  bhc sz k' < sz\n  k' \\<in> it \\<Longrightarrow> ahm_\\<alpha>_aux bhc a' k' = None\n  k' \\<in> it - {k}", "have \"ahm_\\<alpha>_aux bhc (ahm_rehash_aux' bhc sz (k, v) a') k' = None\""], ["proof (prove)\nusing this:\n  bhc sz k' < sz\n  k' \\<in> it \\<Longrightarrow> ahm_\\<alpha>_aux bhc a' k' = None\n  k' \\<in> it - {k}\n\ngoal (1 subgoal):\n 1. ahm_\\<alpha>_aux bhc (ahm_rehash_aux' bhc sz (k, v) a') k' = None", "unfolding ahm_\\<alpha>_aux_def2"], ["proof (prove)\nusing this:\n  bhc sz k' < sz\n  k' \\<in> it \\<Longrightarrow>\n  map_of (array_get a' (bhc (array_length a') k')) k' = None\n  k' \\<in> it - {k}\n\ngoal (1 subgoal):\n 1. map_of\n     (array_get (ahm_rehash_aux' bhc sz (k, v) a')\n       (bhc (array_length (ahm_rehash_aux' bhc sz (k, v) a')) k'))\n     k' =\n    None", "by (cases \"bhc sz k = bhc sz k'\") (simp_all add: \n                  array_get_array_set_other ahm_rehash_aux'_def Let_def)"], ["proof (state)\nthis:\n  ahm_\\<alpha>_aux bhc (ahm_rehash_aux' bhc sz (k, v) a') k' = None\n\ngoal (2 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; k \\<in> it;\n        ahm_\\<alpha>_aux bhc a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux bhc a); I it \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I (it - {k})\n                          (ahm_rehash_aux' bhc sz (k, v) \\<sigma>)\n 2. \\<And>\\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; I {} \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I {} \\<sigma>", "}"], ["proof (state)\nthis:\n  ?k'2 \\<in> it - {k} \\<Longrightarrow>\n  ahm_\\<alpha>_aux bhc (ahm_rehash_aux' bhc sz (k, v) a') ?k'2 = None\n\ngoal (2 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; k \\<in> it;\n        ahm_\\<alpha>_aux bhc a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux bhc a); I it \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I (it - {k})\n                          (ahm_rehash_aux' bhc sz (k, v) \\<sigma>)\n 2. \\<And>\\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; I {} \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I {} \\<sigma>", "moreover"], ["proof (state)\nthis:\n  ?k'2 \\<in> it - {k} \\<Longrightarrow>\n  ahm_\\<alpha>_aux bhc (ahm_rehash_aux' bhc sz (k, v) a') ?k'2 = None\n\ngoal (2 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; k \\<in> it;\n        ahm_\\<alpha>_aux bhc a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux bhc a); I it \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I (it - {k})\n                          (ahm_rehash_aux' bhc sz (k, v) \\<sigma>)\n 2. \\<And>\\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; I {} \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I {} \\<sigma>", "{"], ["proof (state)\nthis:\n  ?k'2 \\<in> it - {k} \\<Longrightarrow>\n  ahm_\\<alpha>_aux bhc (ahm_rehash_aux' bhc sz (k, v) a') ?k'2 = None\n\ngoal (2 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; k \\<in> it;\n        ahm_\\<alpha>_aux bhc a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux bhc a); I it \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I (it - {k})\n                          (ahm_rehash_aux' bhc sz (k, v) \\<sigma>)\n 2. \\<And>\\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; I {} \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I {} \\<sigma>", "fix k'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; k \\<in> it;\n        ahm_\\<alpha>_aux bhc a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux bhc a); I it \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I (it - {k})\n                          (ahm_rehash_aux' bhc sz (k, v) \\<sigma>)\n 2. \\<And>\\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; I {} \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I {} \\<sigma>", "assume \"k' \\<notin> it - {k}\""], ["proof (state)\nthis:\n  k' \\<notin> it - {k}\n\ngoal (2 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; k \\<in> it;\n        ahm_\\<alpha>_aux bhc a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux bhc a); I it \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I (it - {k})\n                          (ahm_rehash_aux' bhc sz (k, v) \\<sigma>)\n 2. \\<And>\\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; I {} \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I {} \\<sigma>", "with is_bounded_hashcodeD(3)[OF bhc \\<open>1 < sz\\<close>, of k]\n           is_bounded_hashcodeD(3)[OF bhc \\<open>1 < sz\\<close>, of k'] \n           a'_eq_a[of k'] \\<open>k \\<in> it\\<close>"], ["proof (chain)\npicking this:\n  bhc sz k < sz\n  bhc sz k' < sz\n  k' \\<notin> it \\<Longrightarrow>\n  ahm_\\<alpha>_aux bhc a' k' = ahm_\\<alpha>_aux bhc a k'\n  k \\<in> it\n  k' \\<notin> it - {k}", "have \"ahm_\\<alpha>_aux bhc (ahm_rehash_aux' bhc sz (k, v) a') k' = \n                ahm_\\<alpha>_aux bhc a k'\""], ["proof (prove)\nusing this:\n  bhc sz k < sz\n  bhc sz k' < sz\n  k' \\<notin> it \\<Longrightarrow>\n  ahm_\\<alpha>_aux bhc a' k' = ahm_\\<alpha>_aux bhc a k'\n  k \\<in> it\n  k' \\<notin> it - {k}\n\ngoal (1 subgoal):\n 1. ahm_\\<alpha>_aux bhc (ahm_rehash_aux' bhc sz (k, v) a') k' =\n    ahm_\\<alpha>_aux bhc a k'", "unfolding ahm_rehash_aux'_def Let_def"], ["proof (prove)\nusing this:\n  bhc sz k < sz\n  bhc sz k' < sz\n  k' \\<notin> it \\<Longrightarrow>\n  ahm_\\<alpha>_aux bhc a' k' = ahm_\\<alpha>_aux bhc a k'\n  k \\<in> it\n  k' \\<notin> it - {k}\n\ngoal (1 subgoal):\n 1. ahm_\\<alpha>_aux bhc\n     (array_set a' (bhc sz (fst (k, v)))\n       ((k, v) # array_get a' (bhc sz (fst (k, v)))))\n     k' =\n    ahm_\\<alpha>_aux bhc a k'", "using \\<open>ahm_\\<alpha>_aux bhc a k = Some v\\<close>"], ["proof (prove)\nusing this:\n  bhc sz k < sz\n  bhc sz k' < sz\n  k' \\<notin> it \\<Longrightarrow>\n  ahm_\\<alpha>_aux bhc a' k' = ahm_\\<alpha>_aux bhc a k'\n  k \\<in> it\n  k' \\<notin> it - {k}\n  ahm_\\<alpha>_aux bhc a k = Some v\n\ngoal (1 subgoal):\n 1. ahm_\\<alpha>_aux bhc\n     (array_set a' (bhc sz (fst (k, v)))\n       ((k, v) # array_get a' (bhc sz (fst (k, v)))))\n     k' =\n    ahm_\\<alpha>_aux bhc a k'", "unfolding ahm_\\<alpha>_aux_def2"], ["proof (prove)\nusing this:\n  bhc sz k < sz\n  bhc sz k' < sz\n  k' \\<notin> it \\<Longrightarrow>\n  map_of (array_get a' (bhc (array_length a') k')) k' =\n  map_of (array_get a (bhc (array_length a) k')) k'\n  k \\<in> it\n  k' \\<notin> it - {k}\n  map_of (array_get a (bhc (array_length a) k)) k = Some v\n\ngoal (1 subgoal):\n 1. map_of\n     (array_get\n       (array_set a' (bhc sz (fst (k, v)))\n         ((k, v) # array_get a' (bhc sz (fst (k, v)))))\n       (bhc (array_length\n              (array_set a' (bhc sz (fst (k, v)))\n                ((k, v) # array_get a' (bhc sz (fst (k, v))))))\n         k'))\n     k' =\n    map_of (array_get a (bhc (array_length a) k')) k'", "by(cases \"bhc sz k = bhc sz k'\") (case_tac [!] \"k' = k\", \n            simp_all add: array_get_array_set_other)"], ["proof (state)\nthis:\n  ahm_\\<alpha>_aux bhc (ahm_rehash_aux' bhc sz (k, v) a') k' =\n  ahm_\\<alpha>_aux bhc a k'\n\ngoal (2 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; k \\<in> it;\n        ahm_\\<alpha>_aux bhc a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux bhc a); I it \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I (it - {k})\n                          (ahm_rehash_aux' bhc sz (k, v) \\<sigma>)\n 2. \\<And>\\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; I {} \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I {} \\<sigma>", "}"], ["proof (state)\nthis:\n  ?k'2 \\<notin> it - {k} \\<Longrightarrow>\n  ahm_\\<alpha>_aux bhc (ahm_rehash_aux' bhc sz (k, v) a') ?k'2 =\n  ahm_\\<alpha>_aux bhc a ?k'2\n\ngoal (2 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; k \\<in> it;\n        ahm_\\<alpha>_aux bhc a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux bhc a); I it \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I (it - {k})\n                          (ahm_rehash_aux' bhc sz (k, v) \\<sigma>)\n 2. \\<And>\\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; I {} \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I {} \\<sigma>", "ultimately"], ["proof (chain)\npicking this:\n  ahm_invar_aux bhc (n - card (it - {k})) (ahm_rehash_aux' bhc sz (k, v) a')\n  array_length (ahm_rehash_aux' bhc sz (k, v) a') = sz\n  ?k'2 \\<in> it - {k} \\<Longrightarrow>\n  ahm_\\<alpha>_aux bhc (ahm_rehash_aux' bhc sz (k, v) a') ?k'2 = None\n  ?k'2 \\<notin> it - {k} \\<Longrightarrow>\n  ahm_\\<alpha>_aux bhc (ahm_rehash_aux' bhc sz (k, v) a') ?k'2 =\n  ahm_\\<alpha>_aux bhc a ?k'2", "show \"I (it - {k}) (ahm_rehash_aux' bhc sz (k, v) a')\""], ["proof (prove)\nusing this:\n  ahm_invar_aux bhc (n - card (it - {k})) (ahm_rehash_aux' bhc sz (k, v) a')\n  array_length (ahm_rehash_aux' bhc sz (k, v) a') = sz\n  ?k'2 \\<in> it - {k} \\<Longrightarrow>\n  ahm_\\<alpha>_aux bhc (ahm_rehash_aux' bhc sz (k, v) a') ?k'2 = None\n  ?k'2 \\<notin> it - {k} \\<Longrightarrow>\n  ahm_\\<alpha>_aux bhc (ahm_rehash_aux' bhc sz (k, v) a') ?k'2 =\n  ahm_\\<alpha>_aux bhc a ?k'2\n\ngoal (1 subgoal):\n 1. I (it - {k}) (ahm_rehash_aux' bhc sz (k, v) a')", "unfolding I_def"], ["proof (prove)\nusing this:\n  ahm_invar_aux bhc (n - card (it - {k})) (ahm_rehash_aux' bhc sz (k, v) a')\n  array_length (ahm_rehash_aux' bhc sz (k, v) a') = sz\n  ?k'2 \\<in> it - {k} \\<Longrightarrow>\n  ahm_\\<alpha>_aux bhc (ahm_rehash_aux' bhc sz (k, v) a') ?k'2 = None\n  ?k'2 \\<notin> it - {k} \\<Longrightarrow>\n  ahm_\\<alpha>_aux bhc (ahm_rehash_aux' bhc sz (k, v) a') ?k'2 =\n  ahm_\\<alpha>_aux bhc a ?k'2\n\ngoal (1 subgoal):\n 1. ahm_invar_aux bhc (n - card (it - {k}))\n     (ahm_rehash_aux' bhc sz (k, v) a') \\<and>\n    array_length (ahm_rehash_aux' bhc sz (k, v) a') = sz \\<and>\n    (\\<forall>ka.\n        if ka \\<in> it - {k}\n        then ahm_\\<alpha>_aux bhc (ahm_rehash_aux' bhc sz (k, v) a') ka =\n             None\n        else ahm_\\<alpha>_aux bhc (ahm_rehash_aux' bhc sz (k, v) a') ka =\n             ahm_\\<alpha>_aux bhc a ka)", "by simp"], ["proof (state)\nthis:\n  I (it - {k}) (ahm_rehash_aux' bhc sz (k, v) a')\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<lbrakk>ahm_invar_aux bhc n a; I {} \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I {} \\<sigma>", "qed simp_all"], ["proof (state)\nthis:\n  I {} (ahm_rehash_aux bhc a sz)\n\ngoal (2 subgoals):\n 1. ahm_invar_aux bhc n (ahm_rehash_aux bhc a sz)\n 2. ahm_\\<alpha>_aux bhc (ahm_rehash_aux bhc a sz) = ahm_\\<alpha>_aux bhc a", "thus ?thesis1 ?thesis2"], ["proof (prove)\nusing this:\n  I {} (ahm_rehash_aux bhc a sz)\n\ngoal (1 subgoal):\n 1. ahm_invar_aux bhc n (ahm_rehash_aux bhc a sz) &&&\n    ahm_\\<alpha>_aux bhc (ahm_rehash_aux bhc a sz) = ahm_\\<alpha>_aux bhc a", "unfolding ahm_rehash_aux_def I_def"], ["proof (prove)\nusing this:\n  ahm_invar_aux bhc (n - card {})\n   (ahm_iteratei_aux a (\\<lambda>x. True) (ahm_rehash_aux' bhc sz)\n     (new_array [] sz)) \\<and>\n  array_length\n   (ahm_iteratei_aux a (\\<lambda>x. True) (ahm_rehash_aux' bhc sz)\n     (new_array [] sz)) =\n  sz \\<and>\n  (\\<forall>k.\n      if k \\<in> {}\n      then ahm_\\<alpha>_aux bhc\n            (ahm_iteratei_aux a (\\<lambda>x. True) (ahm_rehash_aux' bhc sz)\n              (new_array [] sz))\n            k =\n           None\n      else ahm_\\<alpha>_aux bhc\n            (ahm_iteratei_aux a (\\<lambda>x. True) (ahm_rehash_aux' bhc sz)\n              (new_array [] sz))\n            k =\n           ahm_\\<alpha>_aux bhc a k)\n\ngoal (1 subgoal):\n 1. ahm_invar_aux bhc n\n     (ahm_iteratei_aux a (\\<lambda>x. True) (ahm_rehash_aux' bhc sz)\n       (new_array [] sz)) &&&\n    ahm_\\<alpha>_aux bhc\n     (ahm_iteratei_aux a (\\<lambda>x. True) (ahm_rehash_aux' bhc sz)\n       (new_array [] sz)) =\n    ahm_\\<alpha>_aux bhc a", "by auto"], ["proof (state)\nthis:\n  ahm_invar_aux bhc n (ahm_rehash_aux bhc a sz)\n  ahm_\\<alpha>_aux bhc (ahm_rehash_aux bhc a sz) = ahm_\\<alpha>_aux bhc a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ahm_rehash_correct:\n  fixes hm :: \"('k, 'v) hashmap\"\n  assumes bhc: \"is_bounded_hashcode Id (=) bhc\"\n  and inv: \"ahm_invar bhc hm\"\n  and \"sz > 1\"\n  shows \"ahm_invar bhc (ahm_rehash bhc hm sz)\" \n        \"ahm_\\<alpha> bhc (ahm_rehash bhc hm sz) = ahm_\\<alpha> bhc hm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ahm_invar bhc (ahm_rehash bhc hm sz) &&&\n    ahm_\\<alpha> bhc (ahm_rehash bhc hm sz) = ahm_\\<alpha> bhc hm", "proof-"], ["proof (state)\ngoal (2 subgoals):\n 1. ahm_invar bhc (ahm_rehash bhc hm sz)\n 2. ahm_\\<alpha> bhc (ahm_rehash bhc hm sz) = ahm_\\<alpha> bhc hm", "obtain a n where [simp]: \"hm = HashMap a n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a n. hm = HashMap a n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases hm)"], ["proof (state)\nthis:\n  hm = HashMap a n\n\ngoal (2 subgoals):\n 1. ahm_invar bhc (ahm_rehash bhc hm sz)\n 2. ahm_\\<alpha> bhc (ahm_rehash bhc hm sz) = ahm_\\<alpha> bhc hm", "from inv"], ["proof (chain)\npicking this:\n  ahm_invar bhc hm", "have \"ahm_invar_aux bhc n a\""], ["proof (prove)\nusing this:\n  ahm_invar bhc hm\n\ngoal (1 subgoal):\n 1. ahm_invar_aux bhc n a", "by simp"], ["proof (state)\nthis:\n  ahm_invar_aux bhc n a\n\ngoal (2 subgoals):\n 1. ahm_invar bhc (ahm_rehash bhc hm sz)\n 2. ahm_\\<alpha> bhc (ahm_rehash bhc hm sz) = ahm_\\<alpha> bhc hm", "from ahm_rehash_aux_correct[OF bhc this \\<open>sz > 1\\<close>]"], ["proof (chain)\npicking this:\n  ahm_invar_aux bhc n (ahm_rehash_aux bhc a sz)\n  ahm_\\<alpha>_aux bhc (ahm_rehash_aux bhc a sz) = ahm_\\<alpha>_aux bhc a", "show \"ahm_invar bhc (ahm_rehash bhc hm sz)\" and\n           \"ahm_\\<alpha> bhc (ahm_rehash bhc hm sz) = ahm_\\<alpha> bhc hm\""], ["proof (prove)\nusing this:\n  ahm_invar_aux bhc n (ahm_rehash_aux bhc a sz)\n  ahm_\\<alpha>_aux bhc (ahm_rehash_aux bhc a sz) = ahm_\\<alpha>_aux bhc a\n\ngoal (1 subgoal):\n 1. ahm_invar bhc (ahm_rehash bhc hm sz) &&&\n    ahm_\\<alpha> bhc (ahm_rehash bhc hm sz) = ahm_\\<alpha> bhc hm", "by (simp_all add: ahm_\\<alpha>_def2)"], ["proof (state)\nthis:\n  ahm_invar bhc (ahm_rehash bhc hm sz)\n  ahm_\\<alpha> bhc (ahm_rehash bhc hm sz) = ahm_\\<alpha> bhc hm\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>@{term ahm_update}\\<close>"], ["", "lemma param_hm_grow[param]:\n  \"(hm_grow, hm_grow) \\<in> \\<langle>Rk,Rv\\<rangle>ahm_map_rel \\<rightarrow> nat_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (hm_grow, hm_grow)\n    \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel \\<rightarrow> nat_rel", "unfolding hm_grow_def[abs_def] rec_hashmap_is_case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>uu.\n        case uu of HashMap a n \\<Rightarrow> 2 * array_length a + 3,\n     \\<lambda>uu.\n        case uu of HashMap a n \\<Rightarrow> 2 * array_length a + 3)\n    \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel \\<rightarrow> nat_rel", "by parametricity"], ["", "lemma param_ahm_rehash_aux'[param]:\n  assumes \"is_bounded_hashcode Rk eq bhc\"\n  assumes \"1 < n\"\n  assumes \"(bhc,bhc') \\<in> nat_rel \\<rightarrow> Rk \\<rightarrow> nat_rel\"\n  assumes \"(n,n') \\<in> nat_rel\" and \"n = array_length a\"\n  assumes \"(kv,kv') \\<in> \\<langle>Rk,Rv\\<rangle>prod_rel\"\n  assumes \"(a,a') \\<in> \\<langle>\\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel\\<rangle>array_rel\"\n  shows \"(ahm_rehash_aux' bhc n kv a, ahm_rehash_aux' bhc' n' kv' a') \\<in>\n             \\<langle>\\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel\\<rangle>array_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ahm_rehash_aux' bhc n kv a, ahm_rehash_aux' bhc' n' kv' a')\n    \\<in> \\<langle>\\<langle>Rk \\<times>\\<^sub>r\n                            Rv\\<rangle>list_rel\\<rangle>array_rel", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (ahm_rehash_aux' bhc n kv a, ahm_rehash_aux' bhc' n' kv' a')\n    \\<in> \\<langle>\\<langle>Rk \\<times>\\<^sub>r\n                            Rv\\<rangle>list_rel\\<rangle>array_rel", "from assms"], ["proof (chain)\npicking this:\n  is_bounded_hashcode Rk eq bhc\n  1 < n\n  (bhc, bhc') \\<in> nat_rel \\<rightarrow> Rk \\<rightarrow> nat_rel\n  (n, n') \\<in> nat_rel\n  n = array_length a\n  (kv, kv') \\<in> Rk \\<times>\\<^sub>r Rv\n  (a, a')\n  \\<in> \\<langle>\\<langle>Rk \\<times>\\<^sub>r\n                          Rv\\<rangle>list_rel\\<rangle>array_rel", "have \"bhc n (fst kv) < array_length a\""], ["proof (prove)\nusing this:\n  is_bounded_hashcode Rk eq bhc\n  1 < n\n  (bhc, bhc') \\<in> nat_rel \\<rightarrow> Rk \\<rightarrow> nat_rel\n  (n, n') \\<in> nat_rel\n  n = array_length a\n  (kv, kv') \\<in> Rk \\<times>\\<^sub>r Rv\n  (a, a')\n  \\<in> \\<langle>\\<langle>Rk \\<times>\\<^sub>r\n                          Rv\\<rangle>list_rel\\<rangle>array_rel\n\ngoal (1 subgoal):\n 1. bhc n (fst kv) < array_length a", "by force"], ["proof (state)\nthis:\n  bhc n (fst kv) < array_length a\n\ngoal (1 subgoal):\n 1. (ahm_rehash_aux' bhc n kv a, ahm_rehash_aux' bhc' n' kv' a')\n    \\<in> \\<langle>\\<langle>Rk \\<times>\\<^sub>r\n                            Rv\\<rangle>list_rel\\<rangle>array_rel", "thus ?thesis"], ["proof (prove)\nusing this:\n  bhc n (fst kv) < array_length a\n\ngoal (1 subgoal):\n 1. (ahm_rehash_aux' bhc n kv a, ahm_rehash_aux' bhc' n' kv' a')\n    \\<in> \\<langle>\\<langle>Rk \\<times>\\<^sub>r\n                            Rv\\<rangle>list_rel\\<rangle>array_rel", "unfolding ahm_rehash_aux'_def[abs_def] \n      rec_hashmap_is_case Let_def"], ["proof (prove)\nusing this:\n  bhc n (fst kv) < array_length a\n\ngoal (1 subgoal):\n 1. (array_set a (bhc n (fst kv)) (kv # array_get a (bhc n (fst kv))),\n     array_set a' (bhc' n' (fst kv'))\n      (kv' # array_get a' (bhc' n' (fst kv'))))\n    \\<in> \\<langle>\\<langle>Rk \\<times>\\<^sub>r\n                            Rv\\<rangle>list_rel\\<rangle>array_rel", "using assms"], ["proof (prove)\nusing this:\n  bhc n (fst kv) < array_length a\n  is_bounded_hashcode Rk eq bhc\n  1 < n\n  (bhc, bhc') \\<in> nat_rel \\<rightarrow> Rk \\<rightarrow> nat_rel\n  (n, n') \\<in> nat_rel\n  n = array_length a\n  (kv, kv') \\<in> Rk \\<times>\\<^sub>r Rv\n  (a, a')\n  \\<in> \\<langle>\\<langle>Rk \\<times>\\<^sub>r\n                          Rv\\<rangle>list_rel\\<rangle>array_rel\n\ngoal (1 subgoal):\n 1. (array_set a (bhc n (fst kv)) (kv # array_get a (bhc n (fst kv))),\n     array_set a' (bhc' n' (fst kv'))\n      (kv' # array_get a' (bhc' n' (fst kv'))))\n    \\<in> \\<langle>\\<langle>Rk \\<times>\\<^sub>r\n                            Rv\\<rangle>list_rel\\<rangle>array_rel", "by parametricity"], ["proof (state)\nthis:\n  (ahm_rehash_aux' bhc n kv a, ahm_rehash_aux' bhc' n' kv' a')\n  \\<in> \\<langle>\\<langle>Rk \\<times>\\<^sub>r\n                          Rv\\<rangle>list_rel\\<rangle>array_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO: Move this *)"], ["", "lemma param_new_array[param]: \n    \"(new_array, new_array) \\<in> R \\<rightarrow> nat_rel \\<rightarrow> \\<langle>R\\<rangle>array_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (new_array, new_array)\n    \\<in> R \\<rightarrow> nat_rel \\<rightarrow> \\<langle>R\\<rangle>array_rel", "unfolding new_array_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>a n. Array (replicate n a),\n     \\<lambda>a n. Array (replicate n a))\n    \\<in> R \\<rightarrow> nat_rel \\<rightarrow> \\<langle>R\\<rangle>array_rel", "by parametricity"], ["", "(* TODO: move *)"], ["", "lemma param_foldli_induct:\n  assumes l: \"(l,l') \\<in> \\<langle>Ra\\<rangle>list_rel\"\n  assumes c: \"(c,c') \\<in> Rb \\<rightarrow> bool_rel\"\n  assumes \\<sigma>: \"(\\<sigma>,\\<sigma>') \\<in> Rb\"\n  assumes P\\<sigma>: \"P \\<sigma> \\<sigma>'\"\n  assumes f: \"\\<And>a a' b b'. (a,a')\\<in>Ra \\<Longrightarrow> (b,b')\\<in>Rb \\<Longrightarrow> c b \\<Longrightarrow> c' b' \\<Longrightarrow> \n                           P b b' \\<Longrightarrow> (f a b, f' a' b') \\<in> Rb \\<and> \n                          P (f a b) (f' a' b')\"\n  shows \"(foldli l c f \\<sigma>, foldli l' c' f' \\<sigma>') \\<in> Rb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (foldli l c f \\<sigma>, foldli l' c' f' \\<sigma>') \\<in> Rb", "using c \\<sigma> P\\<sigma> f"], ["proof (prove)\nusing this:\n  (c, c') \\<in> Rb \\<rightarrow> bool_rel\n  (\\<sigma>, \\<sigma>') \\<in> Rb\n  P \\<sigma> \\<sigma>'\n  \\<lbrakk>(?a, ?a') \\<in> Ra; (?b, ?b') \\<in> Rb; c ?b; c' ?b';\n   P ?b ?b'\\<rbrakk>\n  \\<Longrightarrow> (f ?a ?b, f' ?a' ?b') \\<in> Rb \\<and>\n                    P (f ?a ?b) (f' ?a' ?b')\n\ngoal (1 subgoal):\n 1. (foldli l c f \\<sigma>, foldli l' c' f' \\<sigma>') \\<in> Rb", "by (induction arbitrary: \\<sigma> \\<sigma>' rule: list_rel_induct[OF l],\n                   auto dest!: fun_relD)"], ["", "lemma param_foldli_induct_nocond:\n  assumes l: \"(l,l') \\<in> \\<langle>Ra\\<rangle>list_rel\"\n  assumes \\<sigma>: \"(\\<sigma>,\\<sigma>') \\<in> Rb\"\n  assumes P\\<sigma>: \"P \\<sigma> \\<sigma>'\"\n  assumes f: \"\\<And>a a' b b'. (a,a')\\<in>Ra \\<Longrightarrow> (b,b')\\<in>Rb \\<Longrightarrow> P b b' \\<Longrightarrow> \n                  (f a b, f' a' b') \\<in> Rb \\<and> P (f a b) (f' a' b')\"\n  shows \"(foldli l (\\<lambda>_. True) f \\<sigma>, foldli l' (\\<lambda>_. True) f' \\<sigma>') \\<in> Rb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (foldli l (\\<lambda>_. True) f \\<sigma>,\n     foldli l' (\\<lambda>_. True) f' \\<sigma>')\n    \\<in> Rb", "using assms"], ["proof (prove)\nusing this:\n  (l, l') \\<in> \\<langle>Ra\\<rangle>list_rel\n  (\\<sigma>, \\<sigma>') \\<in> Rb\n  P \\<sigma> \\<sigma>'\n  \\<lbrakk>(?a, ?a') \\<in> Ra; (?b, ?b') \\<in> Rb; P ?b ?b'\\<rbrakk>\n  \\<Longrightarrow> (f ?a ?b, f' ?a' ?b') \\<in> Rb \\<and>\n                    P (f ?a ?b) (f' ?a' ?b')\n\ngoal (1 subgoal):\n 1. (foldli l (\\<lambda>_. True) f \\<sigma>,\n     foldli l' (\\<lambda>_. True) f' \\<sigma>')\n    \\<in> Rb", "by (blast intro: param_foldli_induct)"], ["", "lemma param_ahm_rehash_aux[param]:\n  assumes bhc: \"is_bounded_hashcode Rk eq bhc\"\n  assumes bhc_rel: \"(bhc,bhc') \\<in> nat_rel \\<rightarrow> Rk \\<rightarrow> nat_rel\"\n  assumes A: \"(a,a') \\<in> \\<langle>\\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel\\<rangle>array_rel\"\n  assumes N: \"(n,n') \\<in> nat_rel\" \"1 < n\"\n  shows \"(ahm_rehash_aux bhc a n, ahm_rehash_aux bhc' a' n') \\<in> \n        \\<langle>\\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel\\<rangle>array_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ahm_rehash_aux bhc a n, ahm_rehash_aux bhc' a' n')\n    \\<in> \\<langle>\\<langle>Rk \\<times>\\<^sub>r\n                            Rv\\<rangle>list_rel\\<rangle>array_rel", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (ahm_rehash_aux bhc a n, ahm_rehash_aux bhc' a' n')\n    \\<in> \\<langle>\\<langle>Rk \\<times>\\<^sub>r\n                            Rv\\<rangle>list_rel\\<rangle>array_rel", "obtain l l' where [simp]: \"a = Array l\" \"a' = Array l'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l l'.\n        \\<lbrakk>a = Array l; a' = Array l'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases a, cases a')"], ["proof (state)\nthis:\n  a = Array l\n  a' = Array l'\n\ngoal (1 subgoal):\n 1. (ahm_rehash_aux bhc a n, ahm_rehash_aux bhc' a' n')\n    \\<in> \\<langle>\\<langle>Rk \\<times>\\<^sub>r\n                            Rv\\<rangle>list_rel\\<rangle>array_rel", "from A"], ["proof (chain)\npicking this:\n  (a, a')\n  \\<in> \\<langle>\\<langle>Rk \\<times>\\<^sub>r\n                          Rv\\<rangle>list_rel\\<rangle>array_rel", "have L: \"(l,l') \\<in> \\<langle>\\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel\\<rangle>list_rel\""], ["proof (prove)\nusing this:\n  (a, a')\n  \\<in> \\<langle>\\<langle>Rk \\<times>\\<^sub>r\n                          Rv\\<rangle>list_rel\\<rangle>array_rel\n\ngoal (1 subgoal):\n 1. (l, l')\n    \\<in> \\<langle>\\<langle>Rk \\<times>\\<^sub>r\n                            Rv\\<rangle>list_rel\\<rangle>list_rel", "unfolding array_rel_def"], ["proof (prove)\nusing this:\n  (a, a')\n  \\<in> {(Array xs, Array ys) |xs ys.\n         (xs, ys)\n         \\<in> \\<langle>\\<langle>Rk \\<times>\\<^sub>r\n                                 Rv\\<rangle>list_rel\\<rangle>list_rel}\n\ngoal (1 subgoal):\n 1. (l, l')\n    \\<in> \\<langle>\\<langle>Rk \\<times>\\<^sub>r\n                            Rv\\<rangle>list_rel\\<rangle>list_rel", "by simp"], ["proof (state)\nthis:\n  (l, l')\n  \\<in> \\<langle>\\<langle>Rk \\<times>\\<^sub>r\n                          Rv\\<rangle>list_rel\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. (ahm_rehash_aux bhc a n, ahm_rehash_aux bhc' a' n')\n    \\<in> \\<langle>\\<langle>Rk \\<times>\\<^sub>r\n                            Rv\\<rangle>list_rel\\<rangle>array_rel", "hence L': \"(concat l, concat l') \\<in> \\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel\""], ["proof (prove)\nusing this:\n  (l, l')\n  \\<in> \\<langle>\\<langle>Rk \\<times>\\<^sub>r\n                          Rv\\<rangle>list_rel\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. (concat l, concat l')\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel", "by parametricity"], ["proof (state)\nthis:\n  (concat l, concat l')\n  \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. (ahm_rehash_aux bhc a n, ahm_rehash_aux bhc' a' n')\n    \\<in> \\<langle>\\<langle>Rk \\<times>\\<^sub>r\n                            Rv\\<rangle>list_rel\\<rangle>array_rel", "let ?P = \"\\<lambda>a a'. n = array_length a\""], ["proof (state)\ngoal (1 subgoal):\n 1. (ahm_rehash_aux bhc a n, ahm_rehash_aux bhc' a' n')\n    \\<in> \\<langle>\\<langle>Rk \\<times>\\<^sub>r\n                            Rv\\<rangle>list_rel\\<rangle>array_rel", "note induct_rule = param_foldli_induct_nocond[OF L', where P=\"?P\"]"], ["proof (state)\nthis:\n  \\<lbrakk>(?\\<sigma>, ?\\<sigma>') \\<in> ?Rb; n = array_length ?\\<sigma>;\n   \\<And>a a' b b'.\n      \\<lbrakk>(a, a') \\<in> Rk \\<times>\\<^sub>r Rv; (b, b') \\<in> ?Rb;\n       n = array_length b\\<rbrakk>\n      \\<Longrightarrow> (?f a b, ?f' a' b') \\<in> ?Rb \\<and>\n                        n = array_length (?f a b)\\<rbrakk>\n  \\<Longrightarrow> (foldli (concat l) (\\<lambda>_. True) ?f ?\\<sigma>,\n                     foldli (concat l') (\\<lambda>_. True) ?f' ?\\<sigma>')\n                    \\<in> ?Rb\n\ngoal (1 subgoal):\n 1. (ahm_rehash_aux bhc a n, ahm_rehash_aux bhc' a' n')\n    \\<in> \\<langle>\\<langle>Rk \\<times>\\<^sub>r\n                            Rv\\<rangle>list_rel\\<rangle>array_rel", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ahm_rehash_aux bhc a n, ahm_rehash_aux bhc' a' n')\n    \\<in> \\<langle>\\<langle>Rk \\<times>\\<^sub>r\n                            Rv\\<rangle>list_rel\\<rangle>array_rel", "unfolding ahm_rehash_aux_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ahm_iteratei_aux a (\\<lambda>x. True) (ahm_rehash_aux' bhc n)\n      (new_array [] n),\n     ahm_iteratei_aux a' (\\<lambda>x. True) (ahm_rehash_aux' bhc' n')\n      (new_array [] n'))\n    \\<in> \\<langle>\\<langle>Rk \\<times>\\<^sub>r\n                            Rv\\<rangle>list_rel\\<rangle>array_rel", "by (simp, induction rule: induct_rule, insert N bhc bhc_rel,\n          auto intro: param_new_array[param_fo] \n                      param_ahm_rehash_aux'[param_fo] \n          simp: array_length_ahm_rehash_aux')"], ["proof (state)\nthis:\n  (ahm_rehash_aux bhc a n, ahm_rehash_aux bhc' a' n')\n  \\<in> \\<langle>\\<langle>Rk \\<times>\\<^sub>r\n                          Rv\\<rangle>list_rel\\<rangle>array_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO: Parametricity fails to prove this. Why? *)"], ["", "lemma param_ahm_rehash[param]:\n  assumes bhc: \"is_bounded_hashcode Rk eq bhc\"\n  assumes bhc_rel: \"(bhc,bhc') \\<in> nat_rel \\<rightarrow> Rk \\<rightarrow> nat_rel\"\n  assumes M: \"(m,m') \\<in> \\<langle>Rk,Rv\\<rangle>ahm_map_rel\"\n  assumes N: \"(n,n') \\<in> nat_rel\" \"1 < n\"\n  shows \"(ahm_rehash bhc m n, ahm_rehash bhc' m' n') \\<in>\n             \\<langle>Rk,Rv\\<rangle>ahm_map_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ahm_rehash bhc m n, ahm_rehash bhc' m' n') \\<in> \\<langle>Rk,\n    Rv\\<rangle>ahm_map_rel", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (ahm_rehash bhc m n, ahm_rehash bhc' m' n') \\<in> \\<langle>Rk,\n    Rv\\<rangle>ahm_map_rel", "obtain a a' k k' where [simp]: \"m = HashMap a k\" \"m' = HashMap a' k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a k a' k'.\n        \\<lbrakk>m = HashMap a k; m' = HashMap a' k'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases m, cases m')"], ["proof (state)\nthis:\n  m = HashMap a k\n  m' = HashMap a' k'\n\ngoal (1 subgoal):\n 1. (ahm_rehash bhc m n, ahm_rehash bhc' m' n') \\<in> \\<langle>Rk,\n    Rv\\<rangle>ahm_map_rel", "hence K: \"(k,k') \\<in> nat_rel\" and\n        A: \"(a,a') \\<in> \\<langle>\\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel\\<rangle>array_rel\""], ["proof (prove)\nusing this:\n  m = HashMap a k\n  m' = HashMap a' k'\n\ngoal (1 subgoal):\n 1. (k, k') \\<in> nat_rel &&&\n    (a, a')\n    \\<in> \\<langle>\\<langle>Rk \\<times>\\<^sub>r\n                            Rv\\<rangle>list_rel\\<rangle>array_rel", "using M"], ["proof (prove)\nusing this:\n  m = HashMap a k\n  m' = HashMap a' k'\n  (m, m') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel\n\ngoal (1 subgoal):\n 1. (k, k') \\<in> nat_rel &&&\n    (a, a')\n    \\<in> \\<langle>\\<langle>Rk \\<times>\\<^sub>r\n                            Rv\\<rangle>list_rel\\<rangle>array_rel", "unfolding ahm_map_rel_def"], ["proof (prove)\nusing this:\n  m = HashMap a k\n  m' = HashMap a' k'\n  (m, m')\n  \\<in> {uu_.\n         \\<exists>a a' n n'.\n            uu_ = (HashMap a n, HashMap a' n) \\<and>\n            (a, a')\n            \\<in> \\<langle>\\<langle>Rk \\<times>\\<^sub>r\n                                    Rv\\<rangle>list_rel\\<rangle>array_rel \\<and>\n            (n, n') \\<in> nat_rel}\n\ngoal (1 subgoal):\n 1. (k, k') \\<in> nat_rel &&&\n    (a, a')\n    \\<in> \\<langle>\\<langle>Rk \\<times>\\<^sub>r\n                            Rv\\<rangle>list_rel\\<rangle>array_rel", "by simp_all"], ["proof (state)\nthis:\n  (k, k') \\<in> nat_rel\n  (a, a')\n  \\<in> \\<langle>\\<langle>Rk \\<times>\\<^sub>r\n                          Rv\\<rangle>list_rel\\<rangle>array_rel\n\ngoal (1 subgoal):\n 1. (ahm_rehash bhc m n, ahm_rehash bhc' m' n') \\<in> \\<langle>Rk,\n    Rv\\<rangle>ahm_map_rel", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ahm_rehash bhc m n, ahm_rehash bhc' m' n') \\<in> \\<langle>Rk,\n    Rv\\<rangle>ahm_map_rel", "unfolding ahm_rehash_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rec_hashmap (\\<lambda>a n bhc sz. HashMap (ahm_rehash_aux bhc a sz) n)\n      m bhc n,\n     rec_hashmap (\\<lambda>a n bhc sz. HashMap (ahm_rehash_aux bhc a sz) n)\n      m' bhc' n')\n    \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel", "by (simp, insert K A assms, parametricity)"], ["proof (state)\nthis:\n  (ahm_rehash bhc m n, ahm_rehash bhc' m' n') \\<in> \\<langle>Rk,\n  Rv\\<rangle>ahm_map_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma param_load_factor[param]:\n  \"(load_factor, load_factor) \\<in> nat_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (load_factor, load_factor) \\<in> nat_rel", "unfolding load_factor_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (75, 75) \\<in> nat_rel", "by simp"], ["", "lemma param_ahm_filled[param]: \n    \"(ahm_filled, ahm_filled) \\<in> \\<langle>Rk,Rv\\<rangle>ahm_map_rel \\<rightarrow> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ahm_filled, ahm_filled)\n    \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel \\<rightarrow> bool_rel", "unfolding ahm_filled_def[abs_def] rec_hashmap_is_case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>uu.\n        case uu of\n        HashMap a n \\<Rightarrow>\n          array_length a * load_factor \\<le> n * 100,\n     \\<lambda>uu.\n        case uu of\n        HashMap a n \\<Rightarrow>\n          array_length a * load_factor \\<le> n * 100)\n    \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel \\<rightarrow> bool_rel", "by parametricity"], ["", "lemma param_ahm_update_aux[param]:\n  assumes bhc: \"is_bounded_hashcode Rk eq bhc\"\n  assumes bhc_rel: \"(bhc,bhc') \\<in> nat_rel \\<rightarrow> Rk \\<rightarrow> nat_rel\"\n  assumes inv: \"ahm_invar bhc' m'\"\n  assumes K: \"(k,k') \\<in> Rk\"\n  assumes V: \"(v,v') \\<in> Rv\"\n  assumes M: \"(m,m') \\<in> \\<langle>Rk,Rv\\<rangle>ahm_map_rel\"\n  shows \"(ahm_update_aux eq bhc m k v, \n          ahm_update_aux (=) bhc' m' k' v' ) \\<in> \\<langle>Rk,Rv\\<rangle>ahm_map_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ahm_update_aux eq bhc m k v, ahm_update_aux (=) bhc' m' k' v')\n    \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (ahm_update_aux eq bhc m k v, ahm_update_aux (=) bhc' m' k' v')\n    \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel", "from bhc"], ["proof (chain)\npicking this:\n  is_bounded_hashcode Rk eq bhc", "have eq[param]: \"(eq, (=))\\<in>Rk \\<rightarrow> Rk \\<rightarrow> bool_rel\""], ["proof (prove)\nusing this:\n  is_bounded_hashcode Rk eq bhc\n\ngoal (1 subgoal):\n 1. (eq, (=)) \\<in> Rk \\<rightarrow> Rk \\<rightarrow> bool_rel", "by (simp add: is_bounded_hashcodeD)"], ["proof (state)\nthis:\n  (eq, (=)) \\<in> Rk \\<rightarrow> Rk \\<rightarrow> bool_rel\n\ngoal (1 subgoal):\n 1. (ahm_update_aux eq bhc m k v, ahm_update_aux (=) bhc' m' k' v')\n    \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel", "obtain a a' n n' where \n      [simp]: \"m = HashMap a n\" and [simp]: \"m' = HashMap a' n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a n a' n'.\n        \\<lbrakk>m = HashMap a n; m' = HashMap a' n'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases m, cases m')"], ["proof (state)\nthis:\n  m = HashMap a n\n  m' = HashMap a' n'\n\ngoal (1 subgoal):\n 1. (ahm_update_aux eq bhc m k v, ahm_update_aux (=) bhc' m' k' v')\n    \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel", "from M"], ["proof (chain)\npicking this:\n  (m, m') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel", "have A: \"(a,a') \\<in> \\<langle>\\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel\\<rangle>array_rel\" and \n              N: \"(n,n') \\<in> nat_rel\""], ["proof (prove)\nusing this:\n  (m, m') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel\n\ngoal (1 subgoal):\n 1. (a, a')\n    \\<in> \\<langle>\\<langle>Rk \\<times>\\<^sub>r\n                            Rv\\<rangle>list_rel\\<rangle>array_rel &&&\n    (n, n') \\<in> nat_rel", "unfolding ahm_map_rel_def"], ["proof (prove)\nusing this:\n  (m, m')\n  \\<in> {uu_.\n         \\<exists>a a' n n'.\n            uu_ = (HashMap a n, HashMap a' n) \\<and>\n            (a, a')\n            \\<in> \\<langle>\\<langle>Rk \\<times>\\<^sub>r\n                                    Rv\\<rangle>list_rel\\<rangle>array_rel \\<and>\n            (n, n') \\<in> nat_rel}\n\ngoal (1 subgoal):\n 1. (a, a')\n    \\<in> \\<langle>\\<langle>Rk \\<times>\\<^sub>r\n                            Rv\\<rangle>list_rel\\<rangle>array_rel &&&\n    (n, n') \\<in> nat_rel", "by simp_all"], ["proof (state)\nthis:\n  (a, a')\n  \\<in> \\<langle>\\<langle>Rk \\<times>\\<^sub>r\n                          Rv\\<rangle>list_rel\\<rangle>array_rel\n  (n, n') \\<in> nat_rel\n\ngoal (1 subgoal):\n 1. (ahm_update_aux eq bhc m k v, ahm_update_aux (=) bhc' m' k' v')\n    \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel", "from inv"], ["proof (chain)\npicking this:\n  ahm_invar bhc' m'", "have \"1 < array_length a'\""], ["proof (prove)\nusing this:\n  ahm_invar bhc' m'\n\ngoal (1 subgoal):\n 1. 1 < array_length a'", "unfolding ahm_invar_def ahm_invar_aux_def"], ["proof (prove)\nusing this:\n  rec_hashmap\n   (\\<lambda>a n bhc.\n       (\\<forall>h<array_length a.\n           bucket_ok bhc (array_length a) h (array_get a h) \\<and>\n           list_map_invar (array_get a h)) \\<and>\n       array_foldl (\\<lambda>_ n kvs. n + length kvs) 0 a = n \\<and>\n       1 < array_length a)\n   m' bhc'\n\ngoal (1 subgoal):\n 1. 1 < array_length a'", "by force"], ["proof (state)\nthis:\n  1 < array_length a'\n\ngoal (1 subgoal):\n 1. (ahm_update_aux eq bhc m k v, ahm_update_aux (=) bhc' m' k' v')\n    \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel", "hence \"1 < array_length a\""], ["proof (prove)\nusing this:\n  1 < array_length a'\n\ngoal (1 subgoal):\n 1. 1 < array_length a", "by (simp add: array_rel_imp_same_length[OF A])"], ["proof (state)\nthis:\n  1 < array_length a\n\ngoal (1 subgoal):\n 1. (ahm_update_aux eq bhc m k v, ahm_update_aux (=) bhc' m' k' v')\n    \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel", "with bhc"], ["proof (chain)\npicking this:\n  is_bounded_hashcode Rk eq bhc\n  1 < array_length a", "have bhc_range: \"bhc (array_length a) k < array_length a\""], ["proof (prove)\nusing this:\n  is_bounded_hashcode Rk eq bhc\n  1 < array_length a\n\ngoal (1 subgoal):\n 1. bhc (array_length a) k < array_length a", "by blast"], ["proof (state)\nthis:\n  bhc (array_length a) k < array_length a\n\ngoal (1 subgoal):\n 1. (ahm_update_aux eq bhc m k v, ahm_update_aux (=) bhc' m' k' v')\n    \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel", "have option_compare: \"\\<And>a a'. (a,a') \\<in> \\<langle>Rv\\<rangle>option_rel \\<Longrightarrow>\n                            (a = None,a' = None) \\<in> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rv\\<rangle>option_rel \\<Longrightarrow>\n       (a = None, a' = None) \\<in> bool_rel", "by force"], ["proof (state)\nthis:\n  (?a, ?a') \\<in> \\<langle>Rv\\<rangle>option_rel \\<Longrightarrow>\n  (?a = None, ?a' = None) \\<in> bool_rel\n\ngoal (1 subgoal):\n 1. (ahm_update_aux eq bhc m k v, ahm_update_aux (=) bhc' m' k' v')\n    \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel", "have \"(array_get a (bhc (array_length a) k),  \n         array_get a' (bhc' (array_length a') k')) \\<in> \n         \\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (array_get a (bhc (array_length a) k),\n     array_get a' (bhc' (array_length a') k'))\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel", "using A K bhc_rel bhc_range"], ["proof (prove)\nusing this:\n  (a, a')\n  \\<in> \\<langle>\\<langle>Rk \\<times>\\<^sub>r\n                          Rv\\<rangle>list_rel\\<rangle>array_rel\n  (k, k') \\<in> Rk\n  (bhc, bhc') \\<in> nat_rel \\<rightarrow> Rk \\<rightarrow> nat_rel\n  bhc (array_length a) k < array_length a\n\ngoal (1 subgoal):\n 1. (array_get a (bhc (array_length a) k),\n     array_get a' (bhc' (array_length a') k'))\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel", "by parametricity"], ["proof (state)\nthis:\n  (array_get a (bhc (array_length a) k),\n   array_get a' (bhc' (array_length a') k'))\n  \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. (ahm_update_aux eq bhc m k v, ahm_update_aux (=) bhc' m' k' v')\n    \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel", "note cmp = option_compare[OF param_list_map_lookup[param_fo, OF eq K this]]"], ["proof (state)\nthis:\n  (list_map_lookup eq k (array_get a (bhc (array_length a) k)) = None,\n   list_map_lookup (=) k' (array_get a' (bhc' (array_length a') k')) = None)\n  \\<in> bool_rel\n\ngoal (1 subgoal):\n 1. (ahm_update_aux eq bhc m k v, ahm_update_aux (=) bhc' m' k' v')\n    \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ahm_update_aux eq bhc m k v, ahm_update_aux (=) bhc' m' k' v')\n    \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let h = bhc (array_length a) k; m = array_get a h\n     in HashMap (array_set a h (list_map_update eq k v m))\n         (if list_map_lookup eq k m = None then n + 1 else n),\n     let h = bhc' (array_length a') k'; m = array_get a' h\n     in HashMap (array_set a' h (list_map_update (=) k' v' m))\n         (if list_map_lookup (=) k' m = None then n' + 1 else n'))\n    \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel", "unfolding ahm_update_aux_def Let_def rec_hashmap_is_case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (HashMap\n      (array_set a (bhc (array_length a) k)\n        (list_map_update eq k v (array_get a (bhc (array_length a) k))))\n      (if list_map_lookup eq k (array_get a (bhc (array_length a) k)) = None\n       then n + 1 else n),\n     HashMap\n      (array_set a' (bhc' (array_length a') k')\n        (list_map_update (=) k' v'\n          (array_get a' (bhc' (array_length a') k'))))\n      (if list_map_lookup (=) k'\n           (array_get a' (bhc' (array_length a') k')) =\n          None\n       then n' + 1 else n'))\n    \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel", "using assms A N bhc_range cmp"], ["proof (prove)\nusing this:\n  is_bounded_hashcode Rk eq bhc\n  (bhc, bhc') \\<in> nat_rel \\<rightarrow> Rk \\<rightarrow> nat_rel\n  ahm_invar bhc' m'\n  (k, k') \\<in> Rk\n  (v, v') \\<in> Rv\n  (m, m') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel\n  (a, a')\n  \\<in> \\<langle>\\<langle>Rk \\<times>\\<^sub>r\n                          Rv\\<rangle>list_rel\\<rangle>array_rel\n  (n, n') \\<in> nat_rel\n  bhc (array_length a) k < array_length a\n  (list_map_lookup eq k (array_get a (bhc (array_length a) k)) = None,\n   list_map_lookup (=) k' (array_get a' (bhc' (array_length a') k')) = None)\n  \\<in> bool_rel\n\ngoal (1 subgoal):\n 1. (HashMap\n      (array_set a (bhc (array_length a) k)\n        (list_map_update eq k v (array_get a (bhc (array_length a) k))))\n      (if list_map_lookup eq k (array_get a (bhc (array_length a) k)) = None\n       then n + 1 else n),\n     HashMap\n      (array_set a' (bhc' (array_length a') k')\n        (list_map_update (=) k' v'\n          (array_get a' (bhc' (array_length a') k'))))\n      (if list_map_lookup (=) k'\n           (array_get a' (bhc' (array_length a') k')) =\n          None\n       then n' + 1 else n'))\n    \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel", "by parametricity"], ["proof (state)\nthis:\n  (ahm_update_aux eq bhc m k v, ahm_update_aux (=) bhc' m' k' v')\n  \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma param_ahm_update[param]:\n  assumes bhc: \"is_bounded_hashcode Rk eq bhc\"\n  assumes bhc_rel: \"(bhc,bhc') \\<in> nat_rel \\<rightarrow> Rk \\<rightarrow> nat_rel\"\n  assumes inv: \"ahm_invar bhc' m'\"\n  assumes K: \"(k,k') \\<in> Rk\"\n  assumes V: \"(v,v') \\<in> Rv\"\n  assumes M: \"(m,m') \\<in> \\<langle>Rk,Rv\\<rangle>ahm_map_rel\"\n  shows \"(ahm_update eq bhc k v m, ahm_update (=) bhc' k' v' m') \\<in> \n             \\<langle>Rk,Rv\\<rangle>ahm_map_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ahm_update eq bhc k v m, ahm_update (=) bhc' k' v' m')\n    \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (ahm_update eq bhc k v m, ahm_update (=) bhc' k' v' m')\n    \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel", "have \"1 < hm_grow (ahm_update_aux eq bhc m k v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < hm_grow (ahm_update_aux eq bhc m k v)", "by simp"], ["proof (state)\nthis:\n  1 < hm_grow (ahm_update_aux eq bhc m k v)\n\ngoal (1 subgoal):\n 1. (ahm_update eq bhc k v m, ahm_update (=) bhc' k' v' m')\n    \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel", "with assms"], ["proof (chain)\npicking this:\n  is_bounded_hashcode Rk eq bhc\n  (bhc, bhc') \\<in> nat_rel \\<rightarrow> Rk \\<rightarrow> nat_rel\n  ahm_invar bhc' m'\n  (k, k') \\<in> Rk\n  (v, v') \\<in> Rv\n  (m, m') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel\n  1 < hm_grow (ahm_update_aux eq bhc m k v)", "show ?thesis"], ["proof (prove)\nusing this:\n  is_bounded_hashcode Rk eq bhc\n  (bhc, bhc') \\<in> nat_rel \\<rightarrow> Rk \\<rightarrow> nat_rel\n  ahm_invar bhc' m'\n  (k, k') \\<in> Rk\n  (v, v') \\<in> Rv\n  (m, m') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel\n  1 < hm_grow (ahm_update_aux eq bhc m k v)\n\ngoal (1 subgoal):\n 1. (ahm_update eq bhc k v m, ahm_update (=) bhc' k' v' m')\n    \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel", "unfolding ahm_update_def[abs_def] Let_def"], ["proof (prove)\nusing this:\n  is_bounded_hashcode Rk eq bhc\n  (bhc, bhc') \\<in> nat_rel \\<rightarrow> Rk \\<rightarrow> nat_rel\n  ahm_invar bhc' m'\n  (k, k') \\<in> Rk\n  (v, v') \\<in> Rv\n  (m, m') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel\n  1 < hm_grow (ahm_update_aux eq bhc m k v)\n\ngoal (1 subgoal):\n 1. (if ahm_filled (ahm_update_aux eq bhc m k v)\n     then ahm_rehash bhc (ahm_update_aux eq bhc m k v)\n           (hm_grow (ahm_update_aux eq bhc m k v))\n     else ahm_update_aux eq bhc m k v,\n     if ahm_filled (ahm_update_aux (=) bhc' m' k' v')\n     then ahm_rehash bhc' (ahm_update_aux (=) bhc' m' k' v')\n           (hm_grow (ahm_update_aux (=) bhc' m' k' v'))\n     else ahm_update_aux (=) bhc' m' k' v')\n    \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel", "by parametricity"], ["proof (state)\nthis:\n  (ahm_update eq bhc k v m, ahm_update (=) bhc' k' v' m') \\<in> \\<langle>Rk,\n  Rv\\<rangle>ahm_map_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO: Move *)"], ["", "lemma length_list_map_update:\n  \"length (list_map_update (=) k v xs) =\n    (if list_map_lookup (=) k xs = None then Suc (length xs) else length xs)\"\n        (is \"?l_new = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (list_map_update (=) k v xs) =\n    (if list_map_lookup (=) k xs = None then Suc (length xs) else length xs)", "proof (cases \"list_map_lookup (=) k xs\", simp_all)"], ["proof (state)\ngoal (2 subgoals):\n 1. list_map_lookup (=) k xs = None \\<Longrightarrow>\n    length (list_map_update (=) k v xs) = Suc (length xs)\n 2. \\<And>a.\n       list_map_lookup (=) k xs = Some a \\<Longrightarrow>\n       length (list_map_update (=) k v xs) = length xs", "case None"], ["proof (state)\nthis:\n  list_map_lookup (=) k xs = None\n\ngoal (2 subgoals):\n 1. list_map_lookup (=) k xs = None \\<Longrightarrow>\n    length (list_map_update (=) k v xs) = Suc (length xs)\n 2. \\<And>a.\n       list_map_lookup (=) k xs = Some a \\<Longrightarrow>\n       length (list_map_update (=) k v xs) = length xs", "hence \"k \\<notin> dom (map_of xs)\""], ["proof (prove)\nusing this:\n  list_map_lookup (=) k xs = None\n\ngoal (1 subgoal):\n 1. k \\<notin> dom (map_of xs)", "by (force simp: list_map_lookup_is_map_of)"], ["proof (state)\nthis:\n  k \\<notin> dom (map_of xs)\n\ngoal (2 subgoals):\n 1. list_map_lookup (=) k xs = None \\<Longrightarrow>\n    length (list_map_update (=) k v xs) = Suc (length xs)\n 2. \\<And>a.\n       list_map_lookup (=) k xs = Some a \\<Longrightarrow>\n       length (list_map_update (=) k v xs) = length xs", "hence \"\\<And>a. list_map_update_aux (=) k v xs a = (k,v) # rev xs @ a\""], ["proof (prove)\nusing this:\n  k \\<notin> dom (map_of xs)\n\ngoal (1 subgoal):\n 1. \\<And>a. list_map_update_aux (=) k v xs a = (k, v) # rev xs @ a", "by (induction xs, auto)"], ["proof (state)\nthis:\n  list_map_update_aux (=) k v xs ?a = (k, v) # rev xs @ ?a\n\ngoal (2 subgoals):\n 1. list_map_lookup (=) k xs = None \\<Longrightarrow>\n    length (list_map_update (=) k v xs) = Suc (length xs)\n 2. \\<And>a.\n       list_map_lookup (=) k xs = Some a \\<Longrightarrow>\n       length (list_map_update (=) k v xs) = length xs", "thus \"?l_new = Suc (length xs)\""], ["proof (prove)\nusing this:\n  list_map_update_aux (=) k v xs ?a = (k, v) # rev xs @ ?a\n\ngoal (1 subgoal):\n 1. length (list_map_update (=) k v xs) = Suc (length xs)", "unfolding list_map_update_def"], ["proof (prove)\nusing this:\n  list_map_update_aux (=) k v xs ?a = (k, v) # rev xs @ ?a\n\ngoal (1 subgoal):\n 1. length (list_map_update_aux (=) k v xs []) = Suc (length xs)", "by simp"], ["proof (state)\nthis:\n  length (list_map_update (=) k v xs) = Suc (length xs)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       list_map_lookup (=) k xs = Some a \\<Longrightarrow>\n       length (list_map_update (=) k v xs) = length xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       list_map_lookup (=) k xs = Some a \\<Longrightarrow>\n       length (list_map_update (=) k v xs) = length xs", "case (Some v')"], ["proof (state)\nthis:\n  list_map_lookup (=) k xs = Some v'\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       list_map_lookup (=) k xs = Some a \\<Longrightarrow>\n       length (list_map_update (=) k v xs) = length xs", "hence \"(k,v') \\<in> set xs\""], ["proof (prove)\nusing this:\n  list_map_lookup (=) k xs = Some v'\n\ngoal (1 subgoal):\n 1. (k, v') \\<in> set xs", "unfolding list_map_lookup_is_map_of"], ["proof (prove)\nusing this:\n  map_of xs k = Some v'\n\ngoal (1 subgoal):\n 1. (k, v') \\<in> set xs", "by (rule map_of_SomeD)"], ["proof (state)\nthis:\n  (k, v') \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       list_map_lookup (=) k xs = Some a \\<Longrightarrow>\n       length (list_map_update (=) k v xs) = length xs", "hence \"\\<And>a. length (list_map_update_aux (=) k v xs a) = \n        length xs + length a\""], ["proof (prove)\nusing this:\n  (k, v') \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       length (list_map_update_aux (=) k v xs a) = length xs + length a", "by (induction xs, auto)"], ["proof (state)\nthis:\n  length (list_map_update_aux (=) k v xs ?a) = length xs + length ?a\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       list_map_lookup (=) k xs = Some a \\<Longrightarrow>\n       length (list_map_update (=) k v xs) = length xs", "thus \"?l_new = length xs\""], ["proof (prove)\nusing this:\n  length (list_map_update_aux (=) k v xs ?a) = length xs + length ?a\n\ngoal (1 subgoal):\n 1. length (list_map_update (=) k v xs) = length xs", "unfolding list_map_update_def"], ["proof (prove)\nusing this:\n  length (list_map_update_aux (=) k v xs ?a) = length xs + length ?a\n\ngoal (1 subgoal):\n 1. length (list_map_update_aux (=) k v xs []) = length xs", "by simp"], ["proof (state)\nthis:\n  length (list_map_update (=) k v xs) = length xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma length_list_map_delete:\n  \"length (list_map_delete (=) k xs) =\n    (if list_map_lookup (=) k xs = None then length xs else length xs - 1)\"\n        (is \"?l_new = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (list_map_delete (=) k xs) =\n    (if list_map_lookup (=) k xs = None then length xs else length xs - 1)", "proof (cases \"list_map_lookup (=) k xs\", simp_all)"], ["proof (state)\ngoal (2 subgoals):\n 1. list_map_lookup (=) k xs = None \\<Longrightarrow>\n    length (list_map_delete (=) k xs) = length xs\n 2. \\<And>a.\n       list_map_lookup (=) k xs = Some a \\<Longrightarrow>\n       length (list_map_delete (=) k xs) = length xs - Suc 0", "case None"], ["proof (state)\nthis:\n  list_map_lookup (=) k xs = None\n\ngoal (2 subgoals):\n 1. list_map_lookup (=) k xs = None \\<Longrightarrow>\n    length (list_map_delete (=) k xs) = length xs\n 2. \\<And>a.\n       list_map_lookup (=) k xs = Some a \\<Longrightarrow>\n       length (list_map_delete (=) k xs) = length xs - Suc 0", "hence \"k \\<notin> dom (map_of xs)\""], ["proof (prove)\nusing this:\n  list_map_lookup (=) k xs = None\n\ngoal (1 subgoal):\n 1. k \\<notin> dom (map_of xs)", "by (force simp: list_map_lookup_is_map_of)"], ["proof (state)\nthis:\n  k \\<notin> dom (map_of xs)\n\ngoal (2 subgoals):\n 1. list_map_lookup (=) k xs = None \\<Longrightarrow>\n    length (list_map_delete (=) k xs) = length xs\n 2. \\<And>a.\n       list_map_lookup (=) k xs = Some a \\<Longrightarrow>\n       length (list_map_delete (=) k xs) = length xs - Suc 0", "hence \"\\<And>a. list_map_delete_aux (=) k xs a = rev xs @ a\""], ["proof (prove)\nusing this:\n  k \\<notin> dom (map_of xs)\n\ngoal (1 subgoal):\n 1. \\<And>a. list_map_delete_aux (=) k xs a = rev xs @ a", "by (induction xs, auto)"], ["proof (state)\nthis:\n  list_map_delete_aux (=) k xs ?a = rev xs @ ?a\n\ngoal (2 subgoals):\n 1. list_map_lookup (=) k xs = None \\<Longrightarrow>\n    length (list_map_delete (=) k xs) = length xs\n 2. \\<And>a.\n       list_map_lookup (=) k xs = Some a \\<Longrightarrow>\n       length (list_map_delete (=) k xs) = length xs - Suc 0", "thus \"?l_new = length xs\""], ["proof (prove)\nusing this:\n  list_map_delete_aux (=) k xs ?a = rev xs @ ?a\n\ngoal (1 subgoal):\n 1. length (list_map_delete (=) k xs) = length xs", "unfolding list_map_delete_def"], ["proof (prove)\nusing this:\n  list_map_delete_aux (=) k xs ?a = rev xs @ ?a\n\ngoal (1 subgoal):\n 1. length (list_map_delete_aux (=) k xs []) = length xs", "by simp"], ["proof (state)\nthis:\n  length (list_map_delete (=) k xs) = length xs\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       list_map_lookup (=) k xs = Some a \\<Longrightarrow>\n       length (list_map_delete (=) k xs) = length xs - Suc 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       list_map_lookup (=) k xs = Some a \\<Longrightarrow>\n       length (list_map_delete (=) k xs) = length xs - Suc 0", "case (Some v')"], ["proof (state)\nthis:\n  list_map_lookup (=) k xs = Some v'\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       list_map_lookup (=) k xs = Some a \\<Longrightarrow>\n       length (list_map_delete (=) k xs) = length xs - Suc 0", "hence \"(k,v') \\<in> set xs\""], ["proof (prove)\nusing this:\n  list_map_lookup (=) k xs = Some v'\n\ngoal (1 subgoal):\n 1. (k, v') \\<in> set xs", "unfolding list_map_lookup_is_map_of"], ["proof (prove)\nusing this:\n  map_of xs k = Some v'\n\ngoal (1 subgoal):\n 1. (k, v') \\<in> set xs", "by (rule map_of_SomeD)"], ["proof (state)\nthis:\n  (k, v') \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       list_map_lookup (=) k xs = Some a \\<Longrightarrow>\n       length (list_map_delete (=) k xs) = length xs - Suc 0", "hence \"\\<And>a. k \\<notin> fst`set a \\<Longrightarrow> length (list_map_delete_aux (=) k xs a) = \n        length xs + length a - 1\""], ["proof (prove)\nusing this:\n  (k, v') \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       k \\<notin> fst ` set a \\<Longrightarrow>\n       length (list_map_delete_aux (=) k xs a) = length xs + length a - 1", "by (induction xs, auto)"], ["proof (state)\nthis:\n  k \\<notin> fst ` set ?a \\<Longrightarrow>\n  length (list_map_delete_aux (=) k xs ?a) = length xs + length ?a - 1\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       list_map_lookup (=) k xs = Some a \\<Longrightarrow>\n       length (list_map_delete (=) k xs) = length xs - Suc 0", "thus \"?l_new = length xs - Suc 0\""], ["proof (prove)\nusing this:\n  k \\<notin> fst ` set ?a \\<Longrightarrow>\n  length (list_map_delete_aux (=) k xs ?a) = length xs + length ?a - 1\n\ngoal (1 subgoal):\n 1. length (list_map_delete (=) k xs) = length xs - Suc 0", "unfolding list_map_delete_def"], ["proof (prove)\nusing this:\n  k \\<notin> fst ` set ?a \\<Longrightarrow>\n  length (list_map_delete_aux (=) k xs ?a) = length xs + length ?a - 1\n\ngoal (1 subgoal):\n 1. length (list_map_delete_aux (=) k xs []) = length xs - Suc 0", "by simp"], ["proof (state)\nthis:\n  length (list_map_delete (=) k xs) = length xs - Suc 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ahm_update_impl:\n  assumes bhc: \"is_bounded_hashcode Id (=) bhc\"\n  shows \"(ahm_update (=) bhc, op_map_update) \\<in> (Id::('k\\<times>'k) set) \\<rightarrow> \n              (Id::('v\\<times>'v) set) \\<rightarrow> ahm_map_rel' bhc \\<rightarrow> ahm_map_rel' bhc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ahm_update (=) bhc, op_map_update)\n    \\<in> Id \\<rightarrow>\n          Id \\<rightarrow> ahm_map_rel' bhc \\<rightarrow> ahm_map_rel' bhc", "proof (intro fun_relI, clarsimp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a' a'a ab a'b.\n       (ab, a'b) \\<in> ahm_map_rel' bhc \\<Longrightarrow>\n       (ahm_update (=) bhc a' a'a ab, a'b(a' \\<mapsto> a'a))\n       \\<in> ahm_map_rel' bhc", "fix k::'k and v::'v and hm::\"('k,'v) hashmap\" and  m::\"'k\\<rightharpoonup>'v\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a' a'a ab a'b.\n       (ab, a'b) \\<in> ahm_map_rel' bhc \\<Longrightarrow>\n       (ahm_update (=) bhc a' a'a ab, a'b(a' \\<mapsto> a'a))\n       \\<in> ahm_map_rel' bhc", "assume \"(hm,m) \\<in> ahm_map_rel' bhc\""], ["proof (state)\nthis:\n  (hm, m) \\<in> ahm_map_rel' bhc\n\ngoal (1 subgoal):\n 1. \\<And>a' a'a ab a'b.\n       (ab, a'b) \\<in> ahm_map_rel' bhc \\<Longrightarrow>\n       (ahm_update (=) bhc a' a'a ab, a'b(a' \\<mapsto> a'a))\n       \\<in> ahm_map_rel' bhc", "hence \\<alpha>: \"m = ahm_\\<alpha> bhc hm\" and inv: \"ahm_invar bhc hm\""], ["proof (prove)\nusing this:\n  (hm, m) \\<in> ahm_map_rel' bhc\n\ngoal (1 subgoal):\n 1. m = ahm_\\<alpha> bhc hm &&& ahm_invar bhc hm", "unfolding ahm_map_rel'_def br_def"], ["proof (prove)\nusing this:\n  (hm, m) \\<in> {(c, a). a = ahm_\\<alpha> bhc c \\<and> ahm_invar bhc c}\n\ngoal (1 subgoal):\n 1. m = ahm_\\<alpha> bhc hm &&& ahm_invar bhc hm", "by simp_all"], ["proof (state)\nthis:\n  m = ahm_\\<alpha> bhc hm\n  ahm_invar bhc hm\n\ngoal (1 subgoal):\n 1. \\<And>a' a'a ab a'b.\n       (ab, a'b) \\<in> ahm_map_rel' bhc \\<Longrightarrow>\n       (ahm_update (=) bhc a' a'a ab, a'b(a' \\<mapsto> a'a))\n       \\<in> ahm_map_rel' bhc", "obtain a n where [simp]: \"hm = HashMap a n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a n. hm = HashMap a n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases hm)"], ["proof (state)\nthis:\n  hm = HashMap a n\n\ngoal (1 subgoal):\n 1. \\<And>a' a'a ab a'b.\n       (ab, a'b) \\<in> ahm_map_rel' bhc \\<Longrightarrow>\n       (ahm_update (=) bhc a' a'a ab, a'b(a' \\<mapsto> a'a))\n       \\<in> ahm_map_rel' bhc", "have K: \"(k,k) \\<in> Id\" and V: \"(v,v) \\<in> Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (k, k) \\<in> Id &&& (v, v) \\<in> Id", "by simp_all"], ["proof (state)\nthis:\n  (k, k) \\<in> Id\n  (v, v) \\<in> Id\n\ngoal (1 subgoal):\n 1. \\<And>a' a'a ab a'b.\n       (ab, a'b) \\<in> ahm_map_rel' bhc \\<Longrightarrow>\n       (ahm_update (=) bhc a' a'a ab, a'b(a' \\<mapsto> a'a))\n       \\<in> ahm_map_rel' bhc", "from inv"], ["proof (chain)\npicking this:\n  ahm_invar bhc hm", "have [simp]: \"1 < array_length a\""], ["proof (prove)\nusing this:\n  ahm_invar bhc hm\n\ngoal (1 subgoal):\n 1. 1 < array_length a", "unfolding ahm_invar_def ahm_invar_aux_def"], ["proof (prove)\nusing this:\n  rec_hashmap\n   (\\<lambda>a n bhc.\n       (\\<forall>h<array_length a.\n           bucket_ok bhc (array_length a) h (array_get a h) \\<and>\n           list_map_invar (array_get a h)) \\<and>\n       array_foldl (\\<lambda>_ n kvs. n + length kvs) 0 a = n \\<and>\n       1 < array_length a)\n   hm bhc\n\ngoal (1 subgoal):\n 1. 1 < array_length a", "by simp"], ["proof (state)\nthis:\n  1 < array_length a\n\ngoal (1 subgoal):\n 1. \\<And>a' a'a ab a'b.\n       (ab, a'b) \\<in> ahm_map_rel' bhc \\<Longrightarrow>\n       (ahm_update (=) bhc a' a'a ab, a'b(a' \\<mapsto> a'a))\n       \\<in> ahm_map_rel' bhc", "hence bhc_range[simp]: \"\\<And>k. bhc (array_length a) k < array_length a\""], ["proof (prove)\nusing this:\n  1 < array_length a\n\ngoal (1 subgoal):\n 1. \\<And>k. bhc (array_length a) k < array_length a", "using bhc"], ["proof (prove)\nusing this:\n  1 < array_length a\n  is_bounded_hashcode Id (=) bhc\n\ngoal (1 subgoal):\n 1. \\<And>k. bhc (array_length a) k < array_length a", "by blast"], ["proof (state)\nthis:\n  bhc (array_length a) ?k < array_length a\n\ngoal (1 subgoal):\n 1. \\<And>a' a'a ab a'b.\n       (ab, a'b) \\<in> ahm_map_rel' bhc \\<Longrightarrow>\n       (ahm_update (=) bhc a' a'a ab, a'b(a' \\<mapsto> a'a))\n       \\<in> ahm_map_rel' bhc", "let ?l = \"array_length a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a' a'a ab a'b.\n       (ab, a'b) \\<in> ahm_map_rel' bhc \\<Longrightarrow>\n       (ahm_update (=) bhc a' a'a ab, a'b(a' \\<mapsto> a'a))\n       \\<in> ahm_map_rel' bhc", "let ?h = \"bhc (array_length a) k\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a' a'a ab a'b.\n       (ab, a'b) \\<in> ahm_map_rel' bhc \\<Longrightarrow>\n       (ahm_update (=) bhc a' a'a ab, a'b(a' \\<mapsto> a'a))\n       \\<in> ahm_map_rel' bhc", "let ?a' = \"array_set a ?h (list_map_update (=) k v (array_get a ?h))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a' a'a ab a'b.\n       (ab, a'b) \\<in> ahm_map_rel' bhc \\<Longrightarrow>\n       (ahm_update (=) bhc a' a'a ab, a'b(a' \\<mapsto> a'a))\n       \\<in> ahm_map_rel' bhc", "let ?n' = \"if list_map_lookup (=) k (array_get a ?h) = None \n                 then n + 1 else n\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a' a'a ab a'b.\n       (ab, a'b) \\<in> ahm_map_rel' bhc \\<Longrightarrow>\n       (ahm_update (=) bhc a' a'a ab, a'b(a' \\<mapsto> a'a))\n       \\<in> ahm_map_rel' bhc", "let ?list = \"array_get a (bhc ?l k)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a' a'a ab a'b.\n       (ab, a'b) \\<in> ahm_map_rel' bhc \\<Longrightarrow>\n       (ahm_update (=) bhc a' a'a ab, a'b(a' \\<mapsto> a'a))\n       \\<in> ahm_map_rel' bhc", "let ?list' = \"map_of ?list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a' a'a ab a'b.\n       (ab, a'b) \\<in> ahm_map_rel' bhc \\<Longrightarrow>\n       (ahm_update (=) bhc a' a'a ab, a'b(a' \\<mapsto> a'a))\n       \\<in> ahm_map_rel' bhc", "have L: \"(?list, ?list') \\<in> br map_of list_map_invar\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (array_get a (bhc (array_length a) k),\n     map_of (array_get a (bhc (array_length a) k)))\n    \\<in> br map_of list_map_invar", "using inv"], ["proof (prove)\nusing this:\n  ahm_invar bhc hm\n\ngoal (1 subgoal):\n 1. (array_get a (bhc (array_length a) k),\n     map_of (array_get a (bhc (array_length a) k)))\n    \\<in> br map_of list_map_invar", "unfolding ahm_invar_def ahm_invar_aux_def br_def"], ["proof (prove)\nusing this:\n  rec_hashmap\n   (\\<lambda>a n bhc.\n       (\\<forall>h<array_length a.\n           bucket_ok bhc (array_length a) h (array_get a h) \\<and>\n           list_map_invar (array_get a h)) \\<and>\n       array_foldl (\\<lambda>_ n kvs. n + length kvs) 0 a = n \\<and>\n       1 < array_length a)\n   hm bhc\n\ngoal (1 subgoal):\n 1. (array_get a (bhc (array_length a) k),\n     map_of (array_get a (bhc (array_length a) k)))\n    \\<in> {(c, a). a = map_of c \\<and> list_map_invar c}", "by simp"], ["proof (state)\nthis:\n  (array_get a (bhc (array_length a) k),\n   map_of (array_get a (bhc (array_length a) k)))\n  \\<in> br map_of list_map_invar\n\ngoal (1 subgoal):\n 1. \\<And>a' a'a ab a'b.\n       (ab, a'b) \\<in> ahm_map_rel' bhc \\<Longrightarrow>\n       (ahm_update (=) bhc a' a'a ab, a'b(a' \\<mapsto> a'a))\n       \\<in> ahm_map_rel' bhc", "hence list: \"list_map_invar ?list\""], ["proof (prove)\nusing this:\n  (array_get a (bhc (array_length a) k),\n   map_of (array_get a (bhc (array_length a) k)))\n  \\<in> br map_of list_map_invar\n\ngoal (1 subgoal):\n 1. list_map_invar (array_get a (bhc (array_length a) k))", "by (simp_all add: br_def)"], ["proof (state)\nthis:\n  list_map_invar (array_get a (bhc (array_length a) k))\n\ngoal (1 subgoal):\n 1. \\<And>a' a'a ab a'b.\n       (ab, a'b) \\<in> ahm_map_rel' bhc \\<Longrightarrow>\n       (ahm_update (=) bhc a' a'a ab, a'b(a' \\<mapsto> a'a))\n       \\<in> ahm_map_rel' bhc", "let ?list_new = \"list_map_update (=) k v ?list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a' a'a ab a'b.\n       (ab, a'b) \\<in> ahm_map_rel' bhc \\<Longrightarrow>\n       (ahm_update (=) bhc a' a'a ab, a'b(a' \\<mapsto> a'a))\n       \\<in> ahm_map_rel' bhc", "let ?list_new' = \"op_map_update k v (map_of (?list))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a' a'a ab a'b.\n       (ab, a'b) \\<in> ahm_map_rel' bhc \\<Longrightarrow>\n       (ahm_update (=) bhc a' a'a ab, a'b(a' \\<mapsto> a'a))\n       \\<in> ahm_map_rel' bhc", "from list_map_autoref_update2[param_fo, OF K V L]"], ["proof (chain)\npicking this:\n  (list_map_update (=) k v (array_get a (bhc (array_length a) k)),\n   op_map_update k v (map_of (array_get a (bhc (array_length a) k))))\n  \\<in> br map_of list_map_invar", "have list_updated: \"map_of ?list_new = ?list_new'\" \n           \"list_map_invar ?list_new\""], ["proof (prove)\nusing this:\n  (list_map_update (=) k v (array_get a (bhc (array_length a) k)),\n   op_map_update k v (map_of (array_get a (bhc (array_length a) k))))\n  \\<in> br map_of list_map_invar\n\ngoal (1 subgoal):\n 1. map_of\n     (list_map_update (=) k v (array_get a (bhc (array_length a) k))) =\n    op_map_update k v (map_of (array_get a (bhc (array_length a) k))) &&&\n    list_map_invar\n     (list_map_update (=) k v (array_get a (bhc (array_length a) k)))", "unfolding br_def"], ["proof (prove)\nusing this:\n  (list_map_update (=) k v (array_get a (bhc (array_length a) k)),\n   op_map_update k v (map_of (array_get a (bhc (array_length a) k))))\n  \\<in> {(c, a). a = map_of c \\<and> list_map_invar c}\n\ngoal (1 subgoal):\n 1. map_of\n     (list_map_update (=) k v (array_get a (bhc (array_length a) k))) =\n    op_map_update k v (map_of (array_get a (bhc (array_length a) k))) &&&\n    list_map_invar\n     (list_map_update (=) k v (array_get a (bhc (array_length a) k)))", "by simp_all"], ["proof (state)\nthis:\n  map_of (list_map_update (=) k v (array_get a (bhc (array_length a) k))) =\n  op_map_update k v (map_of (array_get a (bhc (array_length a) k)))\n  list_map_invar\n   (list_map_update (=) k v (array_get a (bhc (array_length a) k)))\n\ngoal (1 subgoal):\n 1. \\<And>a' a'a ab a'b.\n       (ab, a'b) \\<in> ahm_map_rel' bhc \\<Longrightarrow>\n       (ahm_update (=) bhc a' a'a ab, a'b(a' \\<mapsto> a'a))\n       \\<in> ahm_map_rel' bhc", "have \"ahm_invar bhc (HashMap ?a' ?n')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ahm_invar bhc\n     (HashMap\n       (array_set a (bhc (array_length a) k)\n         (list_map_update (=) k v (array_get a (bhc (array_length a) k))))\n       (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) =\n           None\n        then n + 1 else n))", "unfolding ahm_invar.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. ahm_invar_aux bhc\n     (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) = None\n      then n + 1 else n)\n     (array_set a (bhc (array_length a) k)\n       (list_map_update (=) k v (array_get a (bhc (array_length a) k))))", "proof(rule ahm_invar_auxI)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>h.\n       h < array_length\n            (array_set a (bhc (array_length a) k)\n              (list_map_update (=) k v\n                (array_get a (bhc (array_length a) k)))) \\<Longrightarrow>\n       bucket_ok bhc\n        (array_length\n          (array_set a (bhc (array_length a) k)\n            (list_map_update (=) k v\n              (array_get a (bhc (array_length a) k)))))\n        h (array_get\n            (array_set a (bhc (array_length a) k)\n              (list_map_update (=) k v\n                (array_get a (bhc (array_length a) k))))\n            h)\n 2. \\<And>h.\n       h < array_length\n            (array_set a (bhc (array_length a) k)\n              (list_map_update (=) k v\n                (array_get a (bhc (array_length a) k)))) \\<Longrightarrow>\n       list_map_invar\n        (array_get\n          (array_set a (bhc (array_length a) k)\n            (list_map_update (=) k v\n              (array_get a (bhc (array_length a) k))))\n          h)\n 3. (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) = None\n     then n + 1 else n) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bhc (array_length a) k)\n       (list_map_update (=) k v (array_get a (bhc (array_length a) k))))\n 4. 1 < array_length\n         (array_set a (bhc (array_length a) k)\n           (list_map_update (=) k v (array_get a (bhc (array_length a) k))))", "fix h"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>h.\n       h < array_length\n            (array_set a (bhc (array_length a) k)\n              (list_map_update (=) k v\n                (array_get a (bhc (array_length a) k)))) \\<Longrightarrow>\n       bucket_ok bhc\n        (array_length\n          (array_set a (bhc (array_length a) k)\n            (list_map_update (=) k v\n              (array_get a (bhc (array_length a) k)))))\n        h (array_get\n            (array_set a (bhc (array_length a) k)\n              (list_map_update (=) k v\n                (array_get a (bhc (array_length a) k))))\n            h)\n 2. \\<And>h.\n       h < array_length\n            (array_set a (bhc (array_length a) k)\n              (list_map_update (=) k v\n                (array_get a (bhc (array_length a) k)))) \\<Longrightarrow>\n       list_map_invar\n        (array_get\n          (array_set a (bhc (array_length a) k)\n            (list_map_update (=) k v\n              (array_get a (bhc (array_length a) k))))\n          h)\n 3. (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) = None\n     then n + 1 else n) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bhc (array_length a) k)\n       (list_map_update (=) k v (array_get a (bhc (array_length a) k))))\n 4. 1 < array_length\n         (array_set a (bhc (array_length a) k)\n           (list_map_update (=) k v (array_get a (bhc (array_length a) k))))", "assume \"h < array_length ?a'\""], ["proof (state)\nthis:\n  h < array_length\n       (array_set a (bhc (array_length a) k)\n         (list_map_update (=) k v (array_get a (bhc (array_length a) k))))\n\ngoal (4 subgoals):\n 1. \\<And>h.\n       h < array_length\n            (array_set a (bhc (array_length a) k)\n              (list_map_update (=) k v\n                (array_get a (bhc (array_length a) k)))) \\<Longrightarrow>\n       bucket_ok bhc\n        (array_length\n          (array_set a (bhc (array_length a) k)\n            (list_map_update (=) k v\n              (array_get a (bhc (array_length a) k)))))\n        h (array_get\n            (array_set a (bhc (array_length a) k)\n              (list_map_update (=) k v\n                (array_get a (bhc (array_length a) k))))\n            h)\n 2. \\<And>h.\n       h < array_length\n            (array_set a (bhc (array_length a) k)\n              (list_map_update (=) k v\n                (array_get a (bhc (array_length a) k)))) \\<Longrightarrow>\n       list_map_invar\n        (array_get\n          (array_set a (bhc (array_length a) k)\n            (list_map_update (=) k v\n              (array_get a (bhc (array_length a) k))))\n          h)\n 3. (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) = None\n     then n + 1 else n) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bhc (array_length a) k)\n       (list_map_update (=) k v (array_get a (bhc (array_length a) k))))\n 4. 1 < array_length\n         (array_set a (bhc (array_length a) k)\n           (list_map_update (=) k v (array_get a (bhc (array_length a) k))))", "hence h_in_range: \"h < array_length a\""], ["proof (prove)\nusing this:\n  h < array_length\n       (array_set a (bhc (array_length a) k)\n         (list_map_update (=) k v (array_get a (bhc (array_length a) k))))\n\ngoal (1 subgoal):\n 1. h < array_length a", "by simp"], ["proof (state)\nthis:\n  h < array_length a\n\ngoal (4 subgoals):\n 1. \\<And>h.\n       h < array_length\n            (array_set a (bhc (array_length a) k)\n              (list_map_update (=) k v\n                (array_get a (bhc (array_length a) k)))) \\<Longrightarrow>\n       bucket_ok bhc\n        (array_length\n          (array_set a (bhc (array_length a) k)\n            (list_map_update (=) k v\n              (array_get a (bhc (array_length a) k)))))\n        h (array_get\n            (array_set a (bhc (array_length a) k)\n              (list_map_update (=) k v\n                (array_get a (bhc (array_length a) k))))\n            h)\n 2. \\<And>h.\n       h < array_length\n            (array_set a (bhc (array_length a) k)\n              (list_map_update (=) k v\n                (array_get a (bhc (array_length a) k)))) \\<Longrightarrow>\n       list_map_invar\n        (array_get\n          (array_set a (bhc (array_length a) k)\n            (list_map_update (=) k v\n              (array_get a (bhc (array_length a) k))))\n          h)\n 3. (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) = None\n     then n + 1 else n) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bhc (array_length a) k)\n       (list_map_update (=) k v (array_get a (bhc (array_length a) k))))\n 4. 1 < array_length\n         (array_set a (bhc (array_length a) k)\n           (list_map_update (=) k v (array_get a (bhc (array_length a) k))))", "with inv"], ["proof (chain)\npicking this:\n  ahm_invar bhc hm\n  h < array_length a", "have bucket_ok: \"bucket_ok bhc ?l h (array_get a h)\""], ["proof (prove)\nusing this:\n  ahm_invar bhc hm\n  h < array_length a\n\ngoal (1 subgoal):\n 1. bucket_ok bhc (array_length a) h (array_get a h)", "by(auto elim: ahm_invar_auxD)"], ["proof (state)\nthis:\n  bucket_ok bhc (array_length a) h (array_get a h)\n\ngoal (4 subgoals):\n 1. \\<And>h.\n       h < array_length\n            (array_set a (bhc (array_length a) k)\n              (list_map_update (=) k v\n                (array_get a (bhc (array_length a) k)))) \\<Longrightarrow>\n       bucket_ok bhc\n        (array_length\n          (array_set a (bhc (array_length a) k)\n            (list_map_update (=) k v\n              (array_get a (bhc (array_length a) k)))))\n        h (array_get\n            (array_set a (bhc (array_length a) k)\n              (list_map_update (=) k v\n                (array_get a (bhc (array_length a) k))))\n            h)\n 2. \\<And>h.\n       h < array_length\n            (array_set a (bhc (array_length a) k)\n              (list_map_update (=) k v\n                (array_get a (bhc (array_length a) k)))) \\<Longrightarrow>\n       list_map_invar\n        (array_get\n          (array_set a (bhc (array_length a) k)\n            (list_map_update (=) k v\n              (array_get a (bhc (array_length a) k))))\n          h)\n 3. (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) = None\n     then n + 1 else n) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bhc (array_length a) k)\n       (list_map_update (=) k v (array_get a (bhc (array_length a) k))))\n 4. 1 < array_length\n         (array_set a (bhc (array_length a) k)\n           (list_map_update (=) k v (array_get a (bhc (array_length a) k))))", "thus \"bucket_ok bhc (array_length ?a') h (array_get ?a' h)\""], ["proof (prove)\nusing this:\n  bucket_ok bhc (array_length a) h (array_get a h)\n\ngoal (1 subgoal):\n 1. bucket_ok bhc\n     (array_length\n       (array_set a (bhc (array_length a) k)\n         (list_map_update (=) k v (array_get a (bhc (array_length a) k)))))\n     h (array_get\n         (array_set a (bhc (array_length a) k)\n           (list_map_update (=) k v (array_get a (bhc (array_length a) k))))\n         h)", "proof (cases \"h = bhc (array_length a) k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>bucket_ok bhc (array_length a) h (array_get a h);\n     h = bhc (array_length a) k\\<rbrakk>\n    \\<Longrightarrow> bucket_ok bhc\n                       (array_length\n                         (array_set a (bhc (array_length a) k)\n                           (list_map_update (=) k v\n                             (array_get a (bhc (array_length a) k)))))\n                       h (array_get\n                           (array_set a (bhc (array_length a) k)\n                             (list_map_update (=) k v\n                               (array_get a (bhc (array_length a) k))))\n                           h)\n 2. \\<lbrakk>bucket_ok bhc (array_length a) h (array_get a h);\n     h \\<noteq> bhc (array_length a) k\\<rbrakk>\n    \\<Longrightarrow> bucket_ok bhc\n                       (array_length\n                         (array_set a (bhc (array_length a) k)\n                           (list_map_update (=) k v\n                             (array_get a (bhc (array_length a) k)))))\n                       h (array_get\n                           (array_set a (bhc (array_length a) k)\n                             (list_map_update (=) k v\n                               (array_get a (bhc (array_length a) k))))\n                           h)", "case False"], ["proof (state)\nthis:\n  h \\<noteq> bhc (array_length a) k\n\ngoal (2 subgoals):\n 1. \\<lbrakk>bucket_ok bhc (array_length a) h (array_get a h);\n     h = bhc (array_length a) k\\<rbrakk>\n    \\<Longrightarrow> bucket_ok bhc\n                       (array_length\n                         (array_set a (bhc (array_length a) k)\n                           (list_map_update (=) k v\n                             (array_get a (bhc (array_length a) k)))))\n                       h (array_get\n                           (array_set a (bhc (array_length a) k)\n                             (list_map_update (=) k v\n                               (array_get a (bhc (array_length a) k))))\n                           h)\n 2. \\<lbrakk>bucket_ok bhc (array_length a) h (array_get a h);\n     h \\<noteq> bhc (array_length a) k\\<rbrakk>\n    \\<Longrightarrow> bucket_ok bhc\n                       (array_length\n                         (array_set a (bhc (array_length a) k)\n                           (list_map_update (=) k v\n                             (array_get a (bhc (array_length a) k)))))\n                       h (array_get\n                           (array_set a (bhc (array_length a) k)\n                             (list_map_update (=) k v\n                               (array_get a (bhc (array_length a) k))))\n                           h)", "with bucket_ok"], ["proof (chain)\npicking this:\n  bucket_ok bhc (array_length a) h (array_get a h)\n  h \\<noteq> bhc (array_length a) k", "show ?thesis"], ["proof (prove)\nusing this:\n  bucket_ok bhc (array_length a) h (array_get a h)\n  h \\<noteq> bhc (array_length a) k\n\ngoal (1 subgoal):\n 1. bucket_ok bhc\n     (array_length\n       (array_set a (bhc (array_length a) k)\n         (list_map_update (=) k v (array_get a (bhc (array_length a) k)))))\n     h (array_get\n         (array_set a (bhc (array_length a) k)\n           (list_map_update (=) k v (array_get a (bhc (array_length a) k))))\n         h)", "by (intro bucket_okI, force simp add: \n                  array_get_array_set_other dest: bucket_okD)"], ["proof (state)\nthis:\n  bucket_ok bhc\n   (array_length\n     (array_set a (bhc (array_length a) k)\n       (list_map_update (=) k v (array_get a (bhc (array_length a) k)))))\n   h (array_get\n       (array_set a (bhc (array_length a) k)\n         (list_map_update (=) k v (array_get a (bhc (array_length a) k))))\n       h)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>bucket_ok bhc (array_length a) h (array_get a h);\n     h = bhc (array_length a) k\\<rbrakk>\n    \\<Longrightarrow> bucket_ok bhc\n                       (array_length\n                         (array_set a (bhc (array_length a) k)\n                           (list_map_update (=) k v\n                             (array_get a (bhc (array_length a) k)))))\n                       h (array_get\n                           (array_set a (bhc (array_length a) k)\n                             (list_map_update (=) k v\n                               (array_get a (bhc (array_length a) k))))\n                           h)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>bucket_ok bhc (array_length a) h (array_get a h);\n     h = bhc (array_length a) k\\<rbrakk>\n    \\<Longrightarrow> bucket_ok bhc\n                       (array_length\n                         (array_set a (bhc (array_length a) k)\n                           (list_map_update (=) k v\n                             (array_get a (bhc (array_length a) k)))))\n                       h (array_get\n                           (array_set a (bhc (array_length a) k)\n                             (list_map_update (=) k v\n                               (array_get a (bhc (array_length a) k))))\n                           h)", "case True"], ["proof (state)\nthis:\n  h = bhc (array_length a) k\n\ngoal (1 subgoal):\n 1. \\<lbrakk>bucket_ok bhc (array_length a) h (array_get a h);\n     h = bhc (array_length a) k\\<rbrakk>\n    \\<Longrightarrow> bucket_ok bhc\n                       (array_length\n                         (array_set a (bhc (array_length a) k)\n                           (list_map_update (=) k v\n                             (array_get a (bhc (array_length a) k)))))\n                       h (array_get\n                           (array_set a (bhc (array_length a) k)\n                             (list_map_update (=) k v\n                               (array_get a (bhc (array_length a) k))))\n                           h)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. bucket_ok bhc\n     (array_length\n       (array_set a (bhc (array_length a) k)\n         (list_map_update (=) k v (array_get a (bhc (array_length a) k)))))\n     h (array_get\n         (array_set a (bhc (array_length a) k)\n           (list_map_update (=) k v (array_get a (bhc (array_length a) k))))\n         h)", "proof (insert True, simp, intro bucket_okI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ka.\n       \\<lbrakk>h = bhc (array_length a) k;\n        ka \\<in> fst `\n                 set (list_map_update (=) k v\n                       (array_get a (bhc (array_length a) k)))\\<rbrakk>\n       \\<Longrightarrow> bhc (array_length a) ka = bhc (array_length a) k", "case prems: (1 k')"], ["proof (state)\nthis:\n  h = bhc (array_length a) k\n  k' \\<in> fst `\n           set (list_map_update (=) k v\n                 (array_get a (bhc (array_length a) k)))\n\ngoal (1 subgoal):\n 1. \\<And>ka.\n       \\<lbrakk>h = bhc (array_length a) k;\n        ka \\<in> fst `\n                 set (list_map_update (=) k v\n                       (array_get a (bhc (array_length a) k)))\\<rbrakk>\n       \\<Longrightarrow> bhc (array_length a) ka = bhc (array_length a) k", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. bhc (array_length a) k' = bhc (array_length a) k", "proof (cases \"k = k'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k = k' \\<Longrightarrow>\n    bhc (array_length a) k' = bhc (array_length a) k\n 2. k \\<noteq> k' \\<Longrightarrow>\n    bhc (array_length a) k' = bhc (array_length a) k", "case False"], ["proof (state)\nthis:\n  k \\<noteq> k'\n\ngoal (2 subgoals):\n 1. k = k' \\<Longrightarrow>\n    bhc (array_length a) k' = bhc (array_length a) k\n 2. k \\<noteq> k' \\<Longrightarrow>\n    bhc (array_length a) k' = bhc (array_length a) k", "from prems"], ["proof (chain)\npicking this:\n  h = bhc (array_length a) k\n  k' \\<in> fst `\n           set (list_map_update (=) k v\n                 (array_get a (bhc (array_length a) k)))", "have \"k' \\<in> dom ?list_new'\""], ["proof (prove)\nusing this:\n  h = bhc (array_length a) k\n  k' \\<in> fst `\n           set (list_map_update (=) k v\n                 (array_get a (bhc (array_length a) k)))\n\ngoal (1 subgoal):\n 1. k' \\<in> dom (op_map_update k v\n                   (map_of (array_get a (bhc (array_length a) k))))", "by (simp only: dom_map_of_conv_image_fst \n                          list_updated(1)[symmetric])"], ["proof (state)\nthis:\n  k' \\<in> dom (op_map_update k v\n                 (map_of (array_get a (bhc (array_length a) k))))\n\ngoal (2 subgoals):\n 1. k = k' \\<Longrightarrow>\n    bhc (array_length a) k' = bhc (array_length a) k\n 2. k \\<noteq> k' \\<Longrightarrow>\n    bhc (array_length a) k' = bhc (array_length a) k", "hence \"k' \\<in> fst`set ?list\""], ["proof (prove)\nusing this:\n  k' \\<in> dom (op_map_update k v\n                 (map_of (array_get a (bhc (array_length a) k))))\n\ngoal (1 subgoal):\n 1. k' \\<in> fst ` set (array_get a (bhc (array_length a) k))", "using False"], ["proof (prove)\nusing this:\n  k' \\<in> dom (op_map_update k v\n                 (map_of (array_get a (bhc (array_length a) k))))\n  k \\<noteq> k'\n\ngoal (1 subgoal):\n 1. k' \\<in> fst ` set (array_get a (bhc (array_length a) k))", "by (simp add: dom_map_of_conv_image_fst)"], ["proof (state)\nthis:\n  k' \\<in> fst ` set (array_get a (bhc (array_length a) k))\n\ngoal (2 subgoals):\n 1. k = k' \\<Longrightarrow>\n    bhc (array_length a) k' = bhc (array_length a) k\n 2. k \\<noteq> k' \\<Longrightarrow>\n    bhc (array_length a) k' = bhc (array_length a) k", "from imageE[OF this]"], ["proof (chain)\npicking this:\n  (\\<And>x.\n      \\<lbrakk>k' = fst x;\n       x \\<in> set (array_get a (bhc (array_length a) k))\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain x where \n                      \"fst x = k'\" and \"x \\<in> set ?list\""], ["proof (prove)\nusing this:\n  (\\<And>x.\n      \\<lbrakk>k' = fst x;\n       x \\<in> set (array_get a (bhc (array_length a) k))\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>fst x = k';\n         x \\<in> set (array_get a (bhc (array_length a) k))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  fst x = k'\n  x \\<in> set (array_get a (bhc (array_length a) k))\n\ngoal (2 subgoals):\n 1. k = k' \\<Longrightarrow>\n    bhc (array_length a) k' = bhc (array_length a) k\n 2. k \\<noteq> k' \\<Longrightarrow>\n    bhc (array_length a) k' = bhc (array_length a) k", "then"], ["proof (chain)\npicking this:\n  fst x = k'\n  x \\<in> set (array_get a (bhc (array_length a) k))", "obtain v' where \"(k',v') \\<in> set ?list\""], ["proof (prove)\nusing this:\n  fst x = k'\n  x \\<in> set (array_get a (bhc (array_length a) k))\n\ngoal (1 subgoal):\n 1. (\\<And>v'.\n        (k', v')\n        \\<in> set (array_get a (bhc (array_length a) k)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases x, simp)"], ["proof (state)\nthis:\n  (k', v') \\<in> set (array_get a (bhc (array_length a) k))\n\ngoal (2 subgoals):\n 1. k = k' \\<Longrightarrow>\n    bhc (array_length a) k' = bhc (array_length a) k\n 2. k \\<noteq> k' \\<Longrightarrow>\n    bhc (array_length a) k' = bhc (array_length a) k", "with bucket_okD[OF bucket_ok] and \n                      \\<open>h = bhc (array_length a) k\\<close>"], ["proof (chain)\npicking this:\n  (?k, ?v) \\<in> set (array_get a h) \\<Longrightarrow>\n  bhc (array_length a) ?k = h\n  h = bhc (array_length a) k\n  (k', v') \\<in> set (array_get a (bhc (array_length a) k))", "show ?thesis"], ["proof (prove)\nusing this:\n  (?k, ?v) \\<in> set (array_get a h) \\<Longrightarrow>\n  bhc (array_length a) ?k = h\n  h = bhc (array_length a) k\n  (k', v') \\<in> set (array_get a (bhc (array_length a) k))\n\ngoal (1 subgoal):\n 1. bhc (array_length a) k' = bhc (array_length a) k", "by simp"], ["proof (state)\nthis:\n  bhc (array_length a) k' = bhc (array_length a) k\n\ngoal (1 subgoal):\n 1. k = k' \\<Longrightarrow>\n    bhc (array_length a) k' = bhc (array_length a) k", "qed simp"], ["proof (state)\nthis:\n  bhc (array_length a) k' = bhc (array_length a) k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bucket_ok bhc\n   (array_length\n     (array_set a (bhc (array_length a) k)\n       (list_map_update (=) k v (array_get a (bhc (array_length a) k)))))\n   h (array_get\n       (array_set a (bhc (array_length a) k)\n         (list_map_update (=) k v (array_get a (bhc (array_length a) k))))\n       h)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bucket_ok bhc\n   (array_length\n     (array_set a (bhc (array_length a) k)\n       (list_map_update (=) k v (array_get a (bhc (array_length a) k)))))\n   h (array_get\n       (array_set a (bhc (array_length a) k)\n         (list_map_update (=) k v (array_get a (bhc (array_length a) k))))\n       h)\n\ngoal (3 subgoals):\n 1. \\<And>h.\n       h < array_length\n            (array_set a (bhc (array_length a) k)\n              (list_map_update (=) k v\n                (array_get a (bhc (array_length a) k)))) \\<Longrightarrow>\n       list_map_invar\n        (array_get\n          (array_set a (bhc (array_length a) k)\n            (list_map_update (=) k v\n              (array_get a (bhc (array_length a) k))))\n          h)\n 2. (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) = None\n     then n + 1 else n) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bhc (array_length a) k)\n       (list_map_update (=) k v (array_get a (bhc (array_length a) k))))\n 3. 1 < array_length\n         (array_set a (bhc (array_length a) k)\n           (list_map_update (=) k v (array_get a (bhc (array_length a) k))))", "from \\<open>h < array_length a\\<close> inv"], ["proof (chain)\npicking this:\n  h < array_length a\n  ahm_invar bhc hm", "have \"list_map_invar (array_get a h)\""], ["proof (prove)\nusing this:\n  h < array_length a\n  ahm_invar bhc hm\n\ngoal (1 subgoal):\n 1. list_map_invar (array_get a h)", "by(auto dest: ahm_invar_auxD)"], ["proof (state)\nthis:\n  list_map_invar (array_get a h)\n\ngoal (3 subgoals):\n 1. \\<And>h.\n       h < array_length\n            (array_set a (bhc (array_length a) k)\n              (list_map_update (=) k v\n                (array_get a (bhc (array_length a) k)))) \\<Longrightarrow>\n       list_map_invar\n        (array_get\n          (array_set a (bhc (array_length a) k)\n            (list_map_update (=) k v\n              (array_get a (bhc (array_length a) k))))\n          h)\n 2. (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) = None\n     then n + 1 else n) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bhc (array_length a) k)\n       (list_map_update (=) k v (array_get a (bhc (array_length a) k))))\n 3. 1 < array_length\n         (array_set a (bhc (array_length a) k)\n           (list_map_update (=) k v (array_get a (bhc (array_length a) k))))", "with \\<open>h < array_length a\\<close>"], ["proof (chain)\npicking this:\n  h < array_length a\n  list_map_invar (array_get a h)", "show \"list_map_invar (array_get ?a' h)\""], ["proof (prove)\nusing this:\n  h < array_length a\n  list_map_invar (array_get a h)\n\ngoal (1 subgoal):\n 1. list_map_invar\n     (array_get\n       (array_set a (bhc (array_length a) k)\n         (list_map_update (=) k v (array_get a (bhc (array_length a) k))))\n       h)", "by (cases \"h = ?h\", simp_all add: \n            list_updated array_get_array_set_other)"], ["proof (state)\nthis:\n  list_map_invar\n   (array_get\n     (array_set a (bhc (array_length a) k)\n       (list_map_update (=) k v (array_get a (bhc (array_length a) k))))\n     h)\n\ngoal (2 subgoals):\n 1. (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) = None\n     then n + 1 else n) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bhc (array_length a) k)\n       (list_map_update (=) k v (array_get a (bhc (array_length a) k))))\n 2. 1 < array_length\n         (array_set a (bhc (array_length a) k)\n           (list_map_update (=) k v (array_get a (bhc (array_length a) k))))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) = None\n     then n + 1 else n) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bhc (array_length a) k)\n       (list_map_update (=) k v (array_get a (bhc (array_length a) k))))\n 2. 1 < array_length\n         (array_set a (bhc (array_length a) k)\n           (list_map_update (=) k v (array_get a (bhc (array_length a) k))))", "obtain xs where a [simp]: \"a = Array xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs. a = Array xs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases a)"], ["proof (state)\nthis:\n  a = Array xs\n\ngoal (2 subgoals):\n 1. (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) = None\n     then n + 1 else n) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bhc (array_length a) k)\n       (list_map_update (=) k v (array_get a (bhc (array_length a) k))))\n 2. 1 < array_length\n         (array_set a (bhc (array_length a) k)\n           (list_map_update (=) k v (array_get a (bhc (array_length a) k))))", "let ?f = \"\\<lambda>n kvs. n + length kvs\""], ["proof (state)\ngoal (2 subgoals):\n 1. (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) = None\n     then n + 1 else n) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bhc (array_length a) k)\n       (list_map_update (=) k v (array_get a (bhc (array_length a) k))))\n 2. 1 < array_length\n         (array_set a (bhc (array_length a) k)\n           (list_map_update (=) k v (array_get a (bhc (array_length a) k))))", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) = None\n     then n + 1 else n) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bhc (array_length a) k)\n       (list_map_update (=) k v (array_get a (bhc (array_length a) k))))\n 2. 1 < array_length\n         (array_set a (bhc (array_length a) k)\n           (list_map_update (=) k v (array_get a (bhc (array_length a) k))))", "fix n :: nat and xs :: \"('k \\<times> 'v) list list\""], ["proof (state)\ngoal (2 subgoals):\n 1. (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) = None\n     then n__ + 1 else n__) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bhc (array_length a) k)\n       (list_map_update (=) k v (array_get a (bhc (array_length a) k))))\n 2. 1 < array_length\n         (array_set a (bhc (array_length a) k)\n           (list_map_update (=) k v (array_get a (bhc (array_length a) k))))", "have \"foldl ?f n xs = n + foldl ?f 0 xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (\\<lambda>n kvs. n + length kvs) n xs =\n    n + foldl (\\<lambda>n kvs. n + length kvs) 0 xs", "by(induct xs arbitrary:  rule: rev_induct) simp_all"], ["proof (state)\nthis:\n  foldl (\\<lambda>n kvs. n + length kvs) n xs =\n  n + foldl (\\<lambda>n kvs. n + length kvs) 0 xs\n\ngoal (2 subgoals):\n 1. (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) = None\n     then n__ + 1 else n__) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bhc (array_length a) k)\n       (list_map_update (=) k v (array_get a (bhc (array_length a) k))))\n 2. 1 < array_length\n         (array_set a (bhc (array_length a) k)\n           (list_map_update (=) k v (array_get a (bhc (array_length a) k))))", "}"], ["proof (state)\nthis:\n  foldl (\\<lambda>n kvs. n + length kvs) ?na3 ?xsa3 =\n  ?na3 + foldl (\\<lambda>n kvs. n + length kvs) 0 ?xsa3\n\ngoal (2 subgoals):\n 1. (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) = None\n     then n + 1 else n) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bhc (array_length a) k)\n       (list_map_update (=) k v (array_get a (bhc (array_length a) k))))\n 2. 1 < array_length\n         (array_set a (bhc (array_length a) k)\n           (list_map_update (=) k v (array_get a (bhc (array_length a) k))))", "note fold = this"], ["proof (state)\nthis:\n  foldl (\\<lambda>n kvs. n + length kvs) ?na3 ?xsa3 =\n  ?na3 + foldl (\\<lambda>n kvs. n + length kvs) 0 ?xsa3\n\ngoal (2 subgoals):\n 1. (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) = None\n     then n + 1 else n) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bhc (array_length a) k)\n       (list_map_update (=) k v (array_get a (bhc (array_length a) k))))\n 2. 1 < array_length\n         (array_set a (bhc (array_length a) k)\n           (list_map_update (=) k v (array_get a (bhc (array_length a) k))))", "from inv"], ["proof (chain)\npicking this:\n  ahm_invar bhc hm", "have [simp]: \"bhc (length xs) k < length xs\""], ["proof (prove)\nusing this:\n  ahm_invar bhc hm\n\ngoal (1 subgoal):\n 1. bhc (length xs) k < length xs", "using bhc_range"], ["proof (prove)\nusing this:\n  ahm_invar bhc hm\n  bhc (array_length a) ?k < array_length a\n\ngoal (1 subgoal):\n 1. bhc (length xs) k < length xs", "by simp"], ["proof (state)\nthis:\n  bhc (length xs) k < length xs\n\ngoal (2 subgoals):\n 1. (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) = None\n     then n + 1 else n) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bhc (array_length a) k)\n       (list_map_update (=) k v (array_get a (bhc (array_length a) k))))\n 2. 1 < array_length\n         (array_set a (bhc (array_length a) k)\n           (list_map_update (=) k v (array_get a (bhc (array_length a) k))))", "have xs: \"xs = take ?h xs @ (xs ! ?h) # drop (Suc ?h) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs =\n    take (bhc (array_length a) k) xs @\n    xs ! bhc (array_length a) k # drop (Suc (bhc (array_length a) k)) xs", "by(simp add: Cons_nth_drop_Suc)"], ["proof (state)\nthis:\n  xs =\n  take (bhc (array_length a) k) xs @\n  xs ! bhc (array_length a) k # drop (Suc (bhc (array_length a) k)) xs\n\ngoal (2 subgoals):\n 1. (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) = None\n     then n + 1 else n) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bhc (array_length a) k)\n       (list_map_update (=) k v (array_get a (bhc (array_length a) k))))\n 2. 1 < array_length\n         (array_set a (bhc (array_length a) k)\n           (list_map_update (=) k v (array_get a (bhc (array_length a) k))))", "from inv"], ["proof (chain)\npicking this:\n  ahm_invar bhc hm", "have \"n = array_foldl (\\<lambda>_ n kvs. n + length kvs) 0 a\""], ["proof (prove)\nusing this:\n  ahm_invar bhc hm\n\ngoal (1 subgoal):\n 1. n = array_foldl (\\<lambda>_ n kvs. n + length kvs) 0 a", "by (force dest: ahm_invar_auxD)"], ["proof (state)\nthis:\n  n = array_foldl (\\<lambda>_ n kvs. n + length kvs) 0 a\n\ngoal (2 subgoals):\n 1. (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) = None\n     then n + 1 else n) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bhc (array_length a) k)\n       (list_map_update (=) k v (array_get a (bhc (array_length a) k))))\n 2. 1 < array_length\n         (array_set a (bhc (array_length a) k)\n           (list_map_update (=) k v (array_get a (bhc (array_length a) k))))", "hence \"n = foldl ?f 0 (take ?h xs) + length (xs ! ?h) + foldl ?f 0 (drop (Suc ?h) xs)\""], ["proof (prove)\nusing this:\n  n = array_foldl (\\<lambda>_ n kvs. n + length kvs) 0 a\n\ngoal (1 subgoal):\n 1. n =\n    foldl (\\<lambda>n kvs. n + length kvs) 0\n     (take (bhc (array_length a) k) xs) +\n    length (xs ! bhc (array_length a) k) +\n    foldl (\\<lambda>n kvs. n + length kvs) 0\n     (drop (Suc (bhc (array_length a) k)) xs)", "apply (simp add: array_foldl_foldl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. n = foldl (\\<lambda>n kvs. n + length kvs) 0 xs \\<Longrightarrow>\n    foldl (\\<lambda>n kvs. n + length kvs) 0 xs =\n    foldl (\\<lambda>n kvs. n + length kvs) 0 (take (bhc (length xs) k) xs) +\n    length (xs ! bhc (length xs) k) +\n    foldl (\\<lambda>n kvs. n + length kvs) 0\n     (drop (Suc (bhc (length xs) k)) xs)", "apply (subst xs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. n = foldl (\\<lambda>n kvs. n + length kvs) 0 xs \\<Longrightarrow>\n    foldl (\\<lambda>n kvs. n + length kvs) 0\n     (take (bhc (array_length a) k) xs @\n      xs ! bhc (array_length a) k #\n      drop (Suc (bhc (array_length a) k)) xs) =\n    foldl (\\<lambda>n kvs. n + length kvs) 0 (take (bhc (length xs) k) xs) +\n    length (xs ! bhc (length xs) k) +\n    foldl (\\<lambda>n kvs. n + length kvs) 0\n     (drop (Suc (bhc (length xs) k)) xs)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. n = foldl (\\<lambda>n kvs. n + length kvs) 0 xs \\<Longrightarrow>\n    foldl (\\<lambda>n kvs. n + length kvs)\n     (foldl (\\<lambda>n kvs. n + length kvs) 0\n       (take (bhc (length xs) k) xs) +\n      length (xs ! bhc (length xs) k))\n     (drop (Suc (bhc (length xs) k)) xs) =\n    foldl (\\<lambda>n kvs. n + length kvs) 0 (take (bhc (length xs) k) xs) +\n    length (xs ! bhc (length xs) k) +\n    foldl (\\<lambda>n kvs. n + length kvs) 0\n     (drop (Suc (bhc (length xs) k)) xs)", "apply (metis fold)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  n =\n  foldl (\\<lambda>n kvs. n + length kvs) 0\n   (take (bhc (array_length a) k) xs) +\n  length (xs ! bhc (array_length a) k) +\n  foldl (\\<lambda>n kvs. n + length kvs) 0\n   (drop (Suc (bhc (array_length a) k)) xs)\n\ngoal (2 subgoals):\n 1. (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) = None\n     then n + 1 else n) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bhc (array_length a) k)\n       (list_map_update (=) k v (array_get a (bhc (array_length a) k))))\n 2. 1 < array_length\n         (array_set a (bhc (array_length a) k)\n           (list_map_update (=) k v (array_get a (bhc (array_length a) k))))", "thus \"?n' = array_foldl (\\<lambda>_ n kvs. n + length kvs) 0 ?a'\""], ["proof (prove)\nusing this:\n  n =\n  foldl (\\<lambda>n kvs. n + length kvs) 0\n   (take (bhc (array_length a) k) xs) +\n  length (xs ! bhc (array_length a) k) +\n  foldl (\\<lambda>n kvs. n + length kvs) 0\n   (drop (Suc (bhc (array_length a) k)) xs)\n\ngoal (1 subgoal):\n 1. (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) = None\n     then n + 1 else n) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bhc (array_length a) k)\n       (list_map_update (=) k v (array_get a (bhc (array_length a) k))))", "apply(simp add: ahm_rehash_aux'_def Let_def array_foldl_foldl foldl_list_update map_of_eq_None_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. n =\n    foldl (\\<lambda>n kvs. n + length kvs) 0 (take (bhc (length xs) k) xs) +\n    length (xs ! bhc (length xs) k) +\n    foldl (\\<lambda>n kvs. n + length kvs) 0\n     (drop (Suc (bhc (length xs) k)) xs) \\<Longrightarrow>\n    (list_map_lookup (=) k (xs ! bhc (length xs) k) = None \\<longrightarrow>\n     Suc (foldl (\\<lambda>n kvs. n + length kvs) 0\n           (take (bhc (length xs) k) xs) +\n          length (xs ! bhc (length xs) k) +\n          foldl (\\<lambda>n kvs. n + length kvs) 0\n           (drop (Suc (bhc (length xs) k)) xs)) =\n     foldl (\\<lambda>n kvs. n + length kvs)\n      (foldl (\\<lambda>n kvs. n + length kvs) 0\n        (take (bhc (length xs) k) xs) +\n       length (list_map_update (=) k v (xs ! bhc (length xs) k)))\n      (drop (Suc (bhc (length xs) k)) xs)) \\<and>\n    ((\\<exists>y.\n         list_map_lookup (=) k (xs ! bhc (length xs) k) =\n         Some y) \\<longrightarrow>\n     foldl (\\<lambda>n kvs. n + length kvs) 0\n      (take (bhc (length xs) k) xs) +\n     length (xs ! bhc (length xs) k) +\n     foldl (\\<lambda>n kvs. n + length kvs) 0\n      (drop (Suc (bhc (length xs) k)) xs) =\n     foldl (\\<lambda>n kvs. n + length kvs)\n      (foldl (\\<lambda>n kvs. n + length kvs) 0\n        (take (bhc (length xs) k) xs) +\n       length (list_map_update (=) k v (xs ! bhc (length xs) k)))\n      (drop (Suc (bhc (length xs) k)) xs))", "apply(subst (1 2 3 4 5 6 7 8) fold)"], ["proof (prove)\ngoal (1 subgoal):\n 1. n =\n    foldl (\\<lambda>n kvs. n + length kvs) 0 (take (bhc (length xs) k) xs) +\n    length (xs ! bhc (length xs) k) +\n    foldl (\\<lambda>n kvs. n + length kvs) 0\n     (drop (Suc (bhc (length xs) k)) xs) \\<Longrightarrow>\n    (list_map_lookup (=) k (xs ! bhc (length xs) k) = None \\<longrightarrow>\n     Suc (0 +\n          foldl (\\<lambda>n kvs. n + length kvs) 0\n           (take (bhc (length xs) k) xs) +\n          length (xs ! bhc (length xs) k) +\n          (0 +\n           foldl (\\<lambda>n kvs. n + length kvs) 0\n            (drop (Suc (bhc (length xs) k)) xs))) =\n     0 +\n     foldl (\\<lambda>n kvs. n + length kvs) 0\n      (take (bhc (length xs) k) xs) +\n     length (list_map_update (=) k v (xs ! bhc (length xs) k)) +\n     foldl (\\<lambda>n kvs. n + length kvs) 0\n      (drop (Suc (bhc (length xs) k)) xs)) \\<and>\n    ((\\<exists>y.\n         list_map_lookup (=) k (xs ! bhc (length xs) k) =\n         Some y) \\<longrightarrow>\n     0 +\n     foldl (\\<lambda>n kvs. n + length kvs) 0\n      (take (bhc (length xs) k) xs) +\n     length (xs ! bhc (length xs) k) +\n     (0 +\n      foldl (\\<lambda>n kvs. n + length kvs) 0\n       (drop (Suc (bhc (length xs) k)) xs)) =\n     0 +\n     foldl (\\<lambda>n kvs. n + length kvs) 0\n      (take (bhc (length xs) k) xs) +\n     length (list_map_update (=) k v (xs ! bhc (length xs) k)) +\n     foldl (\\<lambda>n kvs. n + length kvs) 0\n      (drop (Suc (bhc (length xs) k)) xs))", "apply(simp add: length_list_map_update)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) = None\n   then n + 1 else n) =\n  array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n   (array_set a (bhc (array_length a) k)\n     (list_map_update (=) k v (array_get a (bhc (array_length a) k))))\n\ngoal (1 subgoal):\n 1. 1 < array_length\n         (array_set a (bhc (array_length a) k)\n           (list_map_update (=) k v (array_get a (bhc (array_length a) k))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 1 < array_length\n         (array_set a (bhc (array_length a) k)\n           (list_map_update (=) k v (array_get a (bhc (array_length a) k))))", "from inv"], ["proof (chain)\npicking this:\n  ahm_invar bhc hm", "have \"1 < array_length a\""], ["proof (prove)\nusing this:\n  ahm_invar bhc hm\n\ngoal (1 subgoal):\n 1. 1 < array_length a", "by(auto elim: ahm_invar_auxE)"], ["proof (state)\nthis:\n  1 < array_length a\n\ngoal (1 subgoal):\n 1. 1 < array_length\n         (array_set a (bhc (array_length a) k)\n           (list_map_update (=) k v (array_get a (bhc (array_length a) k))))", "thus \"1 < array_length ?a'\""], ["proof (prove)\nusing this:\n  1 < array_length a\n\ngoal (1 subgoal):\n 1. 1 < array_length\n         (array_set a (bhc (array_length a) k)\n           (list_map_update (=) k v (array_get a (bhc (array_length a) k))))", "by simp"], ["proof (state)\nthis:\n  1 < array_length\n       (array_set a (bhc (array_length a) k)\n         (list_map_update (=) k v (array_get a (bhc (array_length a) k))))\n\ngoal:\nNo subgoals!", "next"], ["proof (state)\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ahm_invar bhc\n   (HashMap\n     (array_set a (bhc (array_length a) k)\n       (list_map_update (=) k v (array_get a (bhc (array_length a) k))))\n     (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) = None\n      then n + 1 else n))\n\ngoal (1 subgoal):\n 1. \\<And>a' a'a ab a'b.\n       (ab, a'b) \\<in> ahm_map_rel' bhc \\<Longrightarrow>\n       (ahm_update (=) bhc a' a'a ab, a'b(a' \\<mapsto> a'a))\n       \\<in> ahm_map_rel' bhc", "moreover"], ["proof (state)\nthis:\n  ahm_invar bhc\n   (HashMap\n     (array_set a (bhc (array_length a) k)\n       (list_map_update (=) k v (array_get a (bhc (array_length a) k))))\n     (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) = None\n      then n + 1 else n))\n\ngoal (1 subgoal):\n 1. \\<And>a' a'a ab a'b.\n       (ab, a'b) \\<in> ahm_map_rel' bhc \\<Longrightarrow>\n       (ahm_update (=) bhc a' a'a ab, a'b(a' \\<mapsto> a'a))\n       \\<in> ahm_map_rel' bhc", "have \"ahm_\\<alpha> bhc (ahm_update_aux (=) bhc hm k v) = \n                     ahm_\\<alpha> bhc hm(k \\<mapsto> v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ahm_\\<alpha> bhc (ahm_update_aux (=) bhc hm k v) = ahm_\\<alpha> bhc hm\n    (k \\<mapsto> v)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       ahm_\\<alpha> bhc (ahm_update_aux (=) bhc hm k v) x =\n       (ahm_\\<alpha> bhc hm(k \\<mapsto> v)) x", "fix k'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       ahm_\\<alpha> bhc (ahm_update_aux (=) bhc hm k v) x =\n       (ahm_\\<alpha> bhc hm(k \\<mapsto> v)) x", "show \"ahm_\\<alpha> bhc (ahm_update_aux (=) bhc hm k v) k' = (ahm_\\<alpha> bhc hm(k \\<mapsto> v)) k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ahm_\\<alpha> bhc (ahm_update_aux (=) bhc hm k v) k' =\n    (ahm_\\<alpha> bhc hm(k \\<mapsto> v)) k'", "proof (cases \"bhc ?l k = bhc ?l k'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. bhc (array_length a) k = bhc (array_length a) k' \\<Longrightarrow>\n    ahm_\\<alpha> bhc (ahm_update_aux (=) bhc hm k v) k' =\n    (ahm_\\<alpha> bhc hm(k \\<mapsto> v)) k'\n 2. bhc (array_length a) k \\<noteq>\n    bhc (array_length a) k' \\<Longrightarrow>\n    ahm_\\<alpha> bhc (ahm_update_aux (=) bhc hm k v) k' =\n    (ahm_\\<alpha> bhc hm(k \\<mapsto> v)) k'", "case False"], ["proof (state)\nthis:\n  bhc (array_length a) k \\<noteq> bhc (array_length a) k'\n\ngoal (2 subgoals):\n 1. bhc (array_length a) k = bhc (array_length a) k' \\<Longrightarrow>\n    ahm_\\<alpha> bhc (ahm_update_aux (=) bhc hm k v) k' =\n    (ahm_\\<alpha> bhc hm(k \\<mapsto> v)) k'\n 2. bhc (array_length a) k \\<noteq>\n    bhc (array_length a) k' \\<Longrightarrow>\n    ahm_\\<alpha> bhc (ahm_update_aux (=) bhc hm k v) k' =\n    (ahm_\\<alpha> bhc hm(k \\<mapsto> v)) k'", "thus ?thesis"], ["proof (prove)\nusing this:\n  bhc (array_length a) k \\<noteq> bhc (array_length a) k'\n\ngoal (1 subgoal):\n 1. ahm_\\<alpha> bhc (ahm_update_aux (=) bhc hm k v) k' =\n    (ahm_\\<alpha> bhc hm(k \\<mapsto> v)) k'", "by (force simp add: Let_def \n            ahm_\\<alpha>_def array_get_array_set_other)"], ["proof (state)\nthis:\n  ahm_\\<alpha> bhc (ahm_update_aux (=) bhc hm k v) k' =\n  (ahm_\\<alpha> bhc hm(k \\<mapsto> v)) k'\n\ngoal (1 subgoal):\n 1. bhc (array_length a) k = bhc (array_length a) k' \\<Longrightarrow>\n    ahm_\\<alpha> bhc (ahm_update_aux (=) bhc hm k v) k' =\n    (ahm_\\<alpha> bhc hm(k \\<mapsto> v)) k'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. bhc (array_length a) k = bhc (array_length a) k' \\<Longrightarrow>\n    ahm_\\<alpha> bhc (ahm_update_aux (=) bhc hm k v) k' =\n    (ahm_\\<alpha> bhc hm(k \\<mapsto> v)) k'", "case True"], ["proof (state)\nthis:\n  bhc (array_length a) k = bhc (array_length a) k'\n\ngoal (1 subgoal):\n 1. bhc (array_length a) k = bhc (array_length a) k' \\<Longrightarrow>\n    ahm_\\<alpha> bhc (ahm_update_aux (=) bhc hm k v) k' =\n    (ahm_\\<alpha> bhc hm(k \\<mapsto> v)) k'", "hence \"bhc ?l k' = bhc ?l k\""], ["proof (prove)\nusing this:\n  bhc (array_length a) k = bhc (array_length a) k'\n\ngoal (1 subgoal):\n 1. bhc (array_length a) k' = bhc (array_length a) k", "by simp"], ["proof (state)\nthis:\n  bhc (array_length a) k' = bhc (array_length a) k\n\ngoal (1 subgoal):\n 1. bhc (array_length a) k = bhc (array_length a) k' \\<Longrightarrow>\n    ahm_\\<alpha> bhc (ahm_update_aux (=) bhc hm k v) k' =\n    (ahm_\\<alpha> bhc hm(k \\<mapsto> v)) k'", "thus ?thesis"], ["proof (prove)\nusing this:\n  bhc (array_length a) k' = bhc (array_length a) k\n\ngoal (1 subgoal):\n 1. ahm_\\<alpha> bhc (ahm_update_aux (=) bhc hm k v) k' =\n    (ahm_\\<alpha> bhc hm(k \\<mapsto> v)) k'", "by (auto simp add: Let_def ahm_\\<alpha>_def \n            list_map_lookup_is_map_of list_updated)"], ["proof (state)\nthis:\n  ahm_\\<alpha> bhc (ahm_update_aux (=) bhc hm k v) k' =\n  (ahm_\\<alpha> bhc hm(k \\<mapsto> v)) k'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ahm_\\<alpha> bhc (ahm_update_aux (=) bhc hm k v) k' =\n  (ahm_\\<alpha> bhc hm(k \\<mapsto> v)) k'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ahm_\\<alpha> bhc (ahm_update_aux (=) bhc hm k v) = ahm_\\<alpha> bhc hm(k \n  \\<mapsto> v)\n\ngoal (1 subgoal):\n 1. \\<And>a' a'a ab a'b.\n       (ab, a'b) \\<in> ahm_map_rel' bhc \\<Longrightarrow>\n       (ahm_update (=) bhc a' a'a ab, a'b(a' \\<mapsto> a'a))\n       \\<in> ahm_map_rel' bhc", "ultimately"], ["proof (chain)\npicking this:\n  ahm_invar bhc\n   (HashMap\n     (array_set a (bhc (array_length a) k)\n       (list_map_update (=) k v (array_get a (bhc (array_length a) k))))\n     (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) = None\n      then n + 1 else n))\n  ahm_\\<alpha> bhc (ahm_update_aux (=) bhc hm k v) = ahm_\\<alpha> bhc hm(k \n  \\<mapsto> v)", "have ref: \"(ahm_update_aux (=) bhc hm k v, \n                    m(k \\<mapsto> v)) \\<in> ahm_map_rel' bhc\" (is \"(?hm',_)\\<in>_\")"], ["proof (prove)\nusing this:\n  ahm_invar bhc\n   (HashMap\n     (array_set a (bhc (array_length a) k)\n       (list_map_update (=) k v (array_get a (bhc (array_length a) k))))\n     (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) = None\n      then n + 1 else n))\n  ahm_\\<alpha> bhc (ahm_update_aux (=) bhc hm k v) = ahm_\\<alpha> bhc hm(k \n  \\<mapsto> v)\n\ngoal (1 subgoal):\n 1. (ahm_update_aux (=) bhc hm k v, m(k \\<mapsto> v)) \\<in> ahm_map_rel' bhc", "unfolding ahm_map_rel'_def br_def"], ["proof (prove)\nusing this:\n  ahm_invar bhc\n   (HashMap\n     (array_set a (bhc (array_length a) k)\n       (list_map_update (=) k v (array_get a (bhc (array_length a) k))))\n     (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) = None\n      then n + 1 else n))\n  ahm_\\<alpha> bhc (ahm_update_aux (=) bhc hm k v) = ahm_\\<alpha> bhc hm(k \n  \\<mapsto> v)\n\ngoal (1 subgoal):\n 1. (ahm_update_aux (=) bhc hm k v, m(k \\<mapsto> v))\n    \\<in> {(c, a). a = ahm_\\<alpha> bhc c \\<and> ahm_invar bhc c}", "using \\<alpha>"], ["proof (prove)\nusing this:\n  ahm_invar bhc\n   (HashMap\n     (array_set a (bhc (array_length a) k)\n       (list_map_update (=) k v (array_get a (bhc (array_length a) k))))\n     (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) = None\n      then n + 1 else n))\n  ahm_\\<alpha> bhc (ahm_update_aux (=) bhc hm k v) = ahm_\\<alpha> bhc hm(k \n  \\<mapsto> v)\n  m = ahm_\\<alpha> bhc hm\n\ngoal (1 subgoal):\n 1. (ahm_update_aux (=) bhc hm k v, m(k \\<mapsto> v))\n    \\<in> {(c, a). a = ahm_\\<alpha> bhc c \\<and> ahm_invar bhc c}", "by (auto simp: Let_def)"], ["proof (state)\nthis:\n  (ahm_update_aux (=) bhc hm k v, m(k \\<mapsto> v)) \\<in> ahm_map_rel' bhc\n\ngoal (1 subgoal):\n 1. \\<And>a' a'a ab a'b.\n       (ab, a'b) \\<in> ahm_map_rel' bhc \\<Longrightarrow>\n       (ahm_update (=) bhc a' a'a ab, a'b(a' \\<mapsto> a'a))\n       \\<in> ahm_map_rel' bhc", "show \"(ahm_update (=) bhc k v hm, m(k \\<mapsto> v))\n            \\<in> ahm_map_rel' bhc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ahm_update (=) bhc k v hm, m(k \\<mapsto> v)) \\<in> ahm_map_rel' bhc", "proof (cases \"ahm_filled ?hm'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. ahm_filled (ahm_update_aux (=) bhc hm k v) \\<Longrightarrow>\n    (ahm_update (=) bhc k v hm, m(k \\<mapsto> v)) \\<in> ahm_map_rel' bhc\n 2. \\<not> ahm_filled (ahm_update_aux (=) bhc hm k v) \\<Longrightarrow>\n    (ahm_update (=) bhc k v hm, m(k \\<mapsto> v)) \\<in> ahm_map_rel' bhc", "case False"], ["proof (state)\nthis:\n  \\<not> ahm_filled (ahm_update_aux (=) bhc hm k v)\n\ngoal (2 subgoals):\n 1. ahm_filled (ahm_update_aux (=) bhc hm k v) \\<Longrightarrow>\n    (ahm_update (=) bhc k v hm, m(k \\<mapsto> v)) \\<in> ahm_map_rel' bhc\n 2. \\<not> ahm_filled (ahm_update_aux (=) bhc hm k v) \\<Longrightarrow>\n    (ahm_update (=) bhc k v hm, m(k \\<mapsto> v)) \\<in> ahm_map_rel' bhc", "with ref"], ["proof (chain)\npicking this:\n  (ahm_update_aux (=) bhc hm k v, m(k \\<mapsto> v)) \\<in> ahm_map_rel' bhc\n  \\<not> ahm_filled (ahm_update_aux (=) bhc hm k v)", "show ?thesis"], ["proof (prove)\nusing this:\n  (ahm_update_aux (=) bhc hm k v, m(k \\<mapsto> v)) \\<in> ahm_map_rel' bhc\n  \\<not> ahm_filled (ahm_update_aux (=) bhc hm k v)\n\ngoal (1 subgoal):\n 1. (ahm_update (=) bhc k v hm, m(k \\<mapsto> v)) \\<in> ahm_map_rel' bhc", "unfolding ahm_update_def"], ["proof (prove)\nusing this:\n  (ahm_update_aux (=) bhc hm k v, m(k \\<mapsto> v)) \\<in> ahm_map_rel' bhc\n  \\<not> ahm_filled (ahm_update_aux (=) bhc hm k v)\n\ngoal (1 subgoal):\n 1. (let hm' = ahm_update_aux (=) bhc hm k v\n     in if ahm_filled hm' then ahm_rehash bhc hm' (hm_grow hm') else hm',\n     m(k \\<mapsto> v))\n    \\<in> ahm_map_rel' bhc", "by (simp del: ahm_update_aux.simps)"], ["proof (state)\nthis:\n  (ahm_update (=) bhc k v hm, m(k \\<mapsto> v)) \\<in> ahm_map_rel' bhc\n\ngoal (1 subgoal):\n 1. ahm_filled (ahm_update_aux (=) bhc hm k v) \\<Longrightarrow>\n    (ahm_update (=) bhc k v hm, m(k \\<mapsto> v)) \\<in> ahm_map_rel' bhc", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ahm_filled (ahm_update_aux (=) bhc hm k v) \\<Longrightarrow>\n    (ahm_update (=) bhc k v hm, m(k \\<mapsto> v)) \\<in> ahm_map_rel' bhc", "case True"], ["proof (state)\nthis:\n  ahm_filled (ahm_update_aux (=) bhc hm k v)\n\ngoal (1 subgoal):\n 1. ahm_filled (ahm_update_aux (=) bhc hm k v) \\<Longrightarrow>\n    (ahm_update (=) bhc k v hm, m(k \\<mapsto> v)) \\<in> ahm_map_rel' bhc", "from ref"], ["proof (chain)\npicking this:\n  (ahm_update_aux (=) bhc hm k v, m(k \\<mapsto> v)) \\<in> ahm_map_rel' bhc", "have \"(ahm_rehash bhc ?hm' (hm_grow ?hm'), m(k \\<mapsto> v)) \\<in> \n          ahm_map_rel' bhc\""], ["proof (prove)\nusing this:\n  (ahm_update_aux (=) bhc hm k v, m(k \\<mapsto> v)) \\<in> ahm_map_rel' bhc\n\ngoal (1 subgoal):\n 1. (ahm_rehash bhc (ahm_update_aux (=) bhc hm k v)\n      (hm_grow (ahm_update_aux (=) bhc hm k v)),\n     m(k \\<mapsto> v))\n    \\<in> ahm_map_rel' bhc", "unfolding ahm_map_rel'_def br_def"], ["proof (prove)\nusing this:\n  (ahm_update_aux (=) bhc hm k v, m(k \\<mapsto> v))\n  \\<in> {(c, a). a = ahm_\\<alpha> bhc c \\<and> ahm_invar bhc c}\n\ngoal (1 subgoal):\n 1. (ahm_rehash bhc (ahm_update_aux (=) bhc hm k v)\n      (hm_grow (ahm_update_aux (=) bhc hm k v)),\n     m(k \\<mapsto> v))\n    \\<in> {(c, a). a = ahm_\\<alpha> bhc c \\<and> ahm_invar bhc c}", "by (simp del: ahm_update_aux.simps \n                   add: ahm_rehash_correct[OF bhc])"], ["proof (state)\nthis:\n  (ahm_rehash bhc (ahm_update_aux (=) bhc hm k v)\n    (hm_grow (ahm_update_aux (=) bhc hm k v)),\n   m(k \\<mapsto> v))\n  \\<in> ahm_map_rel' bhc\n\ngoal (1 subgoal):\n 1. ahm_filled (ahm_update_aux (=) bhc hm k v) \\<Longrightarrow>\n    (ahm_update (=) bhc k v hm, m(k \\<mapsto> v)) \\<in> ahm_map_rel' bhc", "thus ?thesis"], ["proof (prove)\nusing this:\n  (ahm_rehash bhc (ahm_update_aux (=) bhc hm k v)\n    (hm_grow (ahm_update_aux (=) bhc hm k v)),\n   m(k \\<mapsto> v))\n  \\<in> ahm_map_rel' bhc\n\ngoal (1 subgoal):\n 1. (ahm_update (=) bhc k v hm, m(k \\<mapsto> v)) \\<in> ahm_map_rel' bhc", "unfolding ahm_update_def"], ["proof (prove)\nusing this:\n  (ahm_rehash bhc (ahm_update_aux (=) bhc hm k v)\n    (hm_grow (ahm_update_aux (=) bhc hm k v)),\n   m(k \\<mapsto> v))\n  \\<in> ahm_map_rel' bhc\n\ngoal (1 subgoal):\n 1. (let hm' = ahm_update_aux (=) bhc hm k v\n     in if ahm_filled hm' then ahm_rehash bhc hm' (hm_grow hm') else hm',\n     m(k \\<mapsto> v))\n    \\<in> ahm_map_rel' bhc", "using True"], ["proof (prove)\nusing this:\n  (ahm_rehash bhc (ahm_update_aux (=) bhc hm k v)\n    (hm_grow (ahm_update_aux (=) bhc hm k v)),\n   m(k \\<mapsto> v))\n  \\<in> ahm_map_rel' bhc\n  ahm_filled (ahm_update_aux (=) bhc hm k v)\n\ngoal (1 subgoal):\n 1. (let hm' = ahm_update_aux (=) bhc hm k v\n     in if ahm_filled hm' then ahm_rehash bhc hm' (hm_grow hm') else hm',\n     m(k \\<mapsto> v))\n    \\<in> ahm_map_rel' bhc", "by (simp del: ahm_update_aux.simps add: Let_def)"], ["proof (state)\nthis:\n  (ahm_update (=) bhc k v hm, m(k \\<mapsto> v)) \\<in> ahm_map_rel' bhc\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (ahm_update (=) bhc k v hm, m(k \\<mapsto> v)) \\<in> ahm_map_rel' bhc\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma autoref_ahm_update[autoref_rules]:\n  assumes bhc[unfolded autoref_tag_defs]: \n    \"SIDE_GEN_ALGO (is_bounded_hashcode Rk eq bhc)\"\n  shows \"(ahm_update eq bhc, op_map_update) \\<in> \n              Rk \\<rightarrow> Rv \\<rightarrow> \\<langle>Rk,Rv\\<rangle>ahm_rel bhc \\<rightarrow> \\<langle>Rk,Rv\\<rangle>ahm_rel bhc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ahm_update eq bhc, op_map_update)\n    \\<in> Rk \\<rightarrow>\n          Rv \\<rightarrow>\n          \\<langle>Rk, Rv\\<rangle>ahm_rel bhc \\<rightarrow> \\<langle>Rk,\n          Rv\\<rangle>ahm_rel bhc", "proof (intro fun_relI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> Rk; (aa, a'a) \\<in> Rv;\n        (ab, a'b) \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc\\<rbrakk>\n       \\<Longrightarrow> (ahm_update eq bhc a aa ab,\n                          op_map_update a' a'a a'b)\n                         \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc", "let ?bhc' = \"abstract_bounded_hashcode Rk bhc\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> Rk; (aa, a'a) \\<in> Rv;\n        (ab, a'b) \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc\\<rbrakk>\n       \\<Longrightarrow> (ahm_update eq bhc a aa ab,\n                          op_map_update a' a'a a'b)\n                         \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc", "fix k k' v v' a m'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> Rk; (aa, a'a) \\<in> Rv;\n        (ab, a'b) \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc\\<rbrakk>\n       \\<Longrightarrow> (ahm_update eq bhc a aa ab,\n                          op_map_update a' a'a a'b)\n                         \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc", "assume K: \"(k,k') \\<in> Rk\" and V: \"(v,v') \\<in> Rv\""], ["proof (state)\nthis:\n  (k, k') \\<in> Rk\n  (v, v') \\<in> Rv\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> Rk; (aa, a'a) \\<in> Rv;\n        (ab, a'b) \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc\\<rbrakk>\n       \\<Longrightarrow> (ahm_update eq bhc a aa ab,\n                          op_map_update a' a'a a'b)\n                         \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc", "assume M: \"(a,m') \\<in> \\<langle>Rk,Rv\\<rangle>ahm_rel bhc\""], ["proof (state)\nthis:\n  (a, m') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> Rk; (aa, a'a) \\<in> Rv;\n        (ab, a'b) \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc\\<rbrakk>\n       \\<Longrightarrow> (ahm_update eq bhc a aa ab,\n                          op_map_update a' a'a a'b)\n                         \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc", "(*from eq have eq': \"(eq,(=)) \\<in> Rk \\<rightarrow> Rk \\<rightarrow> bool_rel\" by simp*)"], ["proof (state)\nthis:\n  (a, m') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> Rk; (aa, a'a) \\<in> Rv;\n        (ab, a'b) \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc\\<rbrakk>\n       \\<Longrightarrow> (ahm_update eq bhc a aa ab,\n                          op_map_update a' a'a a'b)\n                         \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc", "with bhc"], ["proof (chain)\npicking this:\n  is_bounded_hashcode Rk eq bhc\n  (a, m') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc", "have bhc': \"is_bounded_hashcode Id (=) ?bhc'\""], ["proof (prove)\nusing this:\n  is_bounded_hashcode Rk eq bhc\n  (a, m') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc\n\ngoal (1 subgoal):\n 1. is_bounded_hashcode Id (=) (abstract_bounded_hashcode Rk bhc)", "by blast"], ["proof (state)\nthis:\n  is_bounded_hashcode Id (=) (abstract_bounded_hashcode Rk bhc)\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> Rk; (aa, a'a) \\<in> Rv;\n        (ab, a'b) \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc\\<rbrakk>\n       \\<Longrightarrow> (ahm_update eq bhc a aa ab,\n                          op_map_update a' a'a a'b)\n                         \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc", "from abstract_bhc_correct[OF bhc]"], ["proof (chain)\npicking this:\n  (bhc, abstract_bounded_hashcode Rk bhc)\n  \\<in> nat_rel \\<rightarrow> Rk \\<rightarrow> nat_rel", "have bhc_rel: \"(bhc,?bhc') \\<in> nat_rel \\<rightarrow> Rk \\<rightarrow> nat_rel\""], ["proof (prove)\nusing this:\n  (bhc, abstract_bounded_hashcode Rk bhc)\n  \\<in> nat_rel \\<rightarrow> Rk \\<rightarrow> nat_rel\n\ngoal (1 subgoal):\n 1. (bhc, abstract_bounded_hashcode Rk bhc)\n    \\<in> nat_rel \\<rightarrow> Rk \\<rightarrow> nat_rel", "."], ["proof (state)\nthis:\n  (bhc, abstract_bounded_hashcode Rk bhc)\n  \\<in> nat_rel \\<rightarrow> Rk \\<rightarrow> nat_rel\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> Rk; (aa, a'a) \\<in> Rv;\n        (ab, a'b) \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc\\<rbrakk>\n       \\<Longrightarrow> (ahm_update eq bhc a aa ab,\n                          op_map_update a' a'a a'b)\n                         \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc", "from M"], ["proof (chain)\npicking this:\n  (a, m') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc", "obtain a' where M1: \"(a,a') \\<in> \\<langle>Rk,Rv\\<rangle>ahm_map_rel\" and\n      M2: \"(a',m') \\<in> ahm_map_rel' ?bhc'\""], ["proof (prove)\nusing this:\n  (a, m') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>(a, a') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel;\n         (a', m')\n         \\<in> ahm_map_rel' (abstract_bounded_hashcode Rk bhc)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding ahm_rel_def"], ["proof (prove)\nusing this:\n  (a, m')\n  \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel O\n        ahm_map_rel' (abstract_bounded_hashcode Rk bhc)\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>(a, a') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel;\n         (a', m')\n         \\<in> ahm_map_rel' (abstract_bounded_hashcode Rk bhc)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (a, a') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel\n  (a', m') \\<in> ahm_map_rel' (abstract_bounded_hashcode Rk bhc)\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> Rk; (aa, a'a) \\<in> Rv;\n        (ab, a'b) \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc\\<rbrakk>\n       \\<Longrightarrow> (ahm_update eq bhc a aa ab,\n                          op_map_update a' a'a a'b)\n                         \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc", "hence inv: \"ahm_invar ?bhc' a'\""], ["proof (prove)\nusing this:\n  (a, a') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel\n  (a', m') \\<in> ahm_map_rel' (abstract_bounded_hashcode Rk bhc)\n\ngoal (1 subgoal):\n 1. ahm_invar (abstract_bounded_hashcode Rk bhc) a'", "unfolding ahm_map_rel'_def br_def"], ["proof (prove)\nusing this:\n  (a, a') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel\n  (a', m')\n  \\<in> {(c, a).\n         a = ahm_\\<alpha> (abstract_bounded_hashcode Rk bhc) c \\<and>\n         ahm_invar (abstract_bounded_hashcode Rk bhc) c}\n\ngoal (1 subgoal):\n 1. ahm_invar (abstract_bounded_hashcode Rk bhc) a'", "by simp"], ["proof (state)\nthis:\n  ahm_invar (abstract_bounded_hashcode Rk bhc) a'\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> Rk; (aa, a'a) \\<in> Rv;\n        (ab, a'b) \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc\\<rbrakk>\n       \\<Longrightarrow> (ahm_update eq bhc a aa ab,\n                          op_map_update a' a'a a'b)\n                         \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc", "from relcompI[OF param_ahm_update[OF bhc bhc_rel inv K V M1]\n                   ahm_update_impl[param_fo, OF bhc' _ _ M2]]"], ["proof (chain)\npicking this:\n  \\<lbrakk>(k', ?x'3) \\<in> Id; (v', ?x'2) \\<in> Id\\<rbrakk>\n  \\<Longrightarrow> (ahm_update eq bhc k v a, op_map_update ?x'3 ?x'2 m')\n                    \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel O\n                          ahm_map_rel' (abstract_bounded_hashcode Rk bhc)", "show \"(ahm_update eq bhc k v a, op_map_update k' v' m') \\<in> \n            \\<langle>Rk,Rv\\<rangle>ahm_rel bhc\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(k', ?x'3) \\<in> Id; (v', ?x'2) \\<in> Id\\<rbrakk>\n  \\<Longrightarrow> (ahm_update eq bhc k v a, op_map_update ?x'3 ?x'2 m')\n                    \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel O\n                          ahm_map_rel' (abstract_bounded_hashcode Rk bhc)\n\ngoal (1 subgoal):\n 1. (ahm_update eq bhc k v a, op_map_update k' v' m') \\<in> \\<langle>Rk,\n    Rv\\<rangle>ahm_rel bhc", "unfolding ahm_rel_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>(k', ?x'3) \\<in> Id; (v', ?x'2) \\<in> Id\\<rbrakk>\n  \\<Longrightarrow> (ahm_update eq bhc k v a, op_map_update ?x'3 ?x'2 m')\n                    \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel O\n                          ahm_map_rel' (abstract_bounded_hashcode Rk bhc)\n\ngoal (1 subgoal):\n 1. (ahm_update eq bhc k v a, op_map_update k' v' m')\n    \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel O\n          ahm_map_rel' (abstract_bounded_hashcode Rk bhc)", "by simp"], ["proof (state)\nthis:\n  (ahm_update eq bhc k v a, op_map_update k' v' m') \\<in> \\<langle>Rk,\n  Rv\\<rangle>ahm_rel bhc\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>@{term \"ahm_delete\"}\\<close>"], ["", "lemma param_ahm_delete[param]:\n  (*assumes eq: \"(eq,(=)) \\<in> Rk \\<rightarrow> Rk \\<rightarrow> bool_rel\"*)\n  assumes isbhc: \"is_bounded_hashcode Rk eq bhc\"\n  assumes bhc: \"(bhc,bhc') \\<in> nat_rel \\<rightarrow> Rk \\<rightarrow> nat_rel\"\n  assumes inv: \"ahm_invar bhc' m'\"\n  assumes K: \"(k,k') \\<in> Rk\"\n  assumes M: \"(m,m') \\<in> \\<langle>Rk,Rv\\<rangle>ahm_map_rel\"\n  shows\n  \"(ahm_delete eq bhc k m, ahm_delete (=) bhc' k' m') \\<in> \n       \\<langle>Rk,Rv\\<rangle>ahm_map_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ahm_delete eq bhc k m, ahm_delete (=) bhc' k' m') \\<in> \\<langle>Rk,\n    Rv\\<rangle>ahm_map_rel", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (ahm_delete eq bhc k m, ahm_delete (=) bhc' k' m') \\<in> \\<langle>Rk,\n    Rv\\<rangle>ahm_map_rel", "from isbhc"], ["proof (chain)\npicking this:\n  is_bounded_hashcode Rk eq bhc", "have eq: \"(eq,(=))\\<in>Rk\\<rightarrow>Rk\\<rightarrow>bool_rel\""], ["proof (prove)\nusing this:\n  is_bounded_hashcode Rk eq bhc\n\ngoal (1 subgoal):\n 1. (eq, (=)) \\<in> Rk \\<rightarrow> Rk \\<rightarrow> bool_rel", "by (simp add: is_bounded_hashcodeD)"], ["proof (state)\nthis:\n  (eq, (=)) \\<in> Rk \\<rightarrow> Rk \\<rightarrow> bool_rel\n\ngoal (1 subgoal):\n 1. (ahm_delete eq bhc k m, ahm_delete (=) bhc' k' m') \\<in> \\<langle>Rk,\n    Rv\\<rangle>ahm_map_rel", "obtain a a' n n' where \n      [simp]: \"m = HashMap a n\" and [simp]: \"m' = HashMap a' n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a n a' n'.\n        \\<lbrakk>m = HashMap a n; m' = HashMap a' n'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases m, cases m')"], ["proof (state)\nthis:\n  m = HashMap a n\n  m' = HashMap a' n'\n\ngoal (1 subgoal):\n 1. (ahm_delete eq bhc k m, ahm_delete (=) bhc' k' m') \\<in> \\<langle>Rk,\n    Rv\\<rangle>ahm_map_rel", "from M"], ["proof (chain)\npicking this:\n  (m, m') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel", "have A: \"(a,a') \\<in> \\<langle>\\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel\\<rangle>array_rel\" and \n              N: \"(n,n') \\<in> nat_rel\""], ["proof (prove)\nusing this:\n  (m, m') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel\n\ngoal (1 subgoal):\n 1. (a, a')\n    \\<in> \\<langle>\\<langle>Rk \\<times>\\<^sub>r\n                            Rv\\<rangle>list_rel\\<rangle>array_rel &&&\n    (n, n') \\<in> nat_rel", "unfolding ahm_map_rel_def"], ["proof (prove)\nusing this:\n  (m, m')\n  \\<in> {uu_.\n         \\<exists>a a' n n'.\n            uu_ = (HashMap a n, HashMap a' n) \\<and>\n            (a, a')\n            \\<in> \\<langle>\\<langle>Rk \\<times>\\<^sub>r\n                                    Rv\\<rangle>list_rel\\<rangle>array_rel \\<and>\n            (n, n') \\<in> nat_rel}\n\ngoal (1 subgoal):\n 1. (a, a')\n    \\<in> \\<langle>\\<langle>Rk \\<times>\\<^sub>r\n                            Rv\\<rangle>list_rel\\<rangle>array_rel &&&\n    (n, n') \\<in> nat_rel", "by simp_all"], ["proof (state)\nthis:\n  (a, a')\n  \\<in> \\<langle>\\<langle>Rk \\<times>\\<^sub>r\n                          Rv\\<rangle>list_rel\\<rangle>array_rel\n  (n, n') \\<in> nat_rel\n\ngoal (1 subgoal):\n 1. (ahm_delete eq bhc k m, ahm_delete (=) bhc' k' m') \\<in> \\<langle>Rk,\n    Rv\\<rangle>ahm_map_rel", "from inv"], ["proof (chain)\npicking this:\n  ahm_invar bhc' m'", "have \"1 < array_length a'\""], ["proof (prove)\nusing this:\n  ahm_invar bhc' m'\n\ngoal (1 subgoal):\n 1. 1 < array_length a'", "unfolding ahm_invar_def ahm_invar_aux_def"], ["proof (prove)\nusing this:\n  rec_hashmap\n   (\\<lambda>a n bhc.\n       (\\<forall>h<array_length a.\n           bucket_ok bhc (array_length a) h (array_get a h) \\<and>\n           list_map_invar (array_get a h)) \\<and>\n       array_foldl (\\<lambda>_ n kvs. n + length kvs) 0 a = n \\<and>\n       1 < array_length a)\n   m' bhc'\n\ngoal (1 subgoal):\n 1. 1 < array_length a'", "by force"], ["proof (state)\nthis:\n  1 < array_length a'\n\ngoal (1 subgoal):\n 1. (ahm_delete eq bhc k m, ahm_delete (=) bhc' k' m') \\<in> \\<langle>Rk,\n    Rv\\<rangle>ahm_map_rel", "hence \"1 < array_length a\""], ["proof (prove)\nusing this:\n  1 < array_length a'\n\ngoal (1 subgoal):\n 1. 1 < array_length a", "by (simp add: array_rel_imp_same_length[OF A])"], ["proof (state)\nthis:\n  1 < array_length a\n\ngoal (1 subgoal):\n 1. (ahm_delete eq bhc k m, ahm_delete (=) bhc' k' m') \\<in> \\<langle>Rk,\n    Rv\\<rangle>ahm_map_rel", "with isbhc"], ["proof (chain)\npicking this:\n  is_bounded_hashcode Rk eq bhc\n  1 < array_length a", "have bhc_range: \"bhc (array_length a) k < array_length a\""], ["proof (prove)\nusing this:\n  is_bounded_hashcode Rk eq bhc\n  1 < array_length a\n\ngoal (1 subgoal):\n 1. bhc (array_length a) k < array_length a", "by blast"], ["proof (state)\nthis:\n  bhc (array_length a) k < array_length a\n\ngoal (1 subgoal):\n 1. (ahm_delete eq bhc k m, ahm_delete (=) bhc' k' m') \\<in> \\<langle>Rk,\n    Rv\\<rangle>ahm_map_rel", "have option_compare: \"\\<And>a a'. (a,a') \\<in> \\<langle>Rv\\<rangle>option_rel \\<Longrightarrow>\n                            (a = None,a' = None) \\<in> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rv\\<rangle>option_rel \\<Longrightarrow>\n       (a = None, a' = None) \\<in> bool_rel", "by force"], ["proof (state)\nthis:\n  (?a, ?a') \\<in> \\<langle>Rv\\<rangle>option_rel \\<Longrightarrow>\n  (?a = None, ?a' = None) \\<in> bool_rel\n\ngoal (1 subgoal):\n 1. (ahm_delete eq bhc k m, ahm_delete (=) bhc' k' m') \\<in> \\<langle>Rk,\n    Rv\\<rangle>ahm_map_rel", "have \"(array_get a (bhc (array_length a) k),  \n         array_get a' (bhc' (array_length a') k')) \\<in> \n         \\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (array_get a (bhc (array_length a) k),\n     array_get a' (bhc' (array_length a') k'))\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel", "using A K bhc bhc_range"], ["proof (prove)\nusing this:\n  (a, a')\n  \\<in> \\<langle>\\<langle>Rk \\<times>\\<^sub>r\n                          Rv\\<rangle>list_rel\\<rangle>array_rel\n  (k, k') \\<in> Rk\n  (bhc, bhc') \\<in> nat_rel \\<rightarrow> Rk \\<rightarrow> nat_rel\n  bhc (array_length a) k < array_length a\n\ngoal (1 subgoal):\n 1. (array_get a (bhc (array_length a) k),\n     array_get a' (bhc' (array_length a') k'))\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel", "by parametricity"], ["proof (state)\nthis:\n  (array_get a (bhc (array_length a) k),\n   array_get a' (bhc' (array_length a') k'))\n  \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. (ahm_delete eq bhc k m, ahm_delete (=) bhc' k' m') \\<in> \\<langle>Rk,\n    Rv\\<rangle>ahm_map_rel", "note cmp = option_compare[OF param_list_map_lookup[param_fo, OF eq K this]]"], ["proof (state)\nthis:\n  (list_map_lookup eq k (array_get a (bhc (array_length a) k)) = None,\n   list_map_lookup (=) k' (array_get a' (bhc' (array_length a') k')) = None)\n  \\<in> bool_rel\n\ngoal (1 subgoal):\n 1. (ahm_delete eq bhc k m, ahm_delete (=) bhc' k' m') \\<in> \\<langle>Rk,\n    Rv\\<rangle>ahm_map_rel", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ahm_delete eq bhc k m, ahm_delete (=) bhc' k' m') \\<in> \\<langle>Rk,\n    Rv\\<rangle>ahm_map_rel", "unfolding \\<open>m = HashMap a n\\<close> \\<open>m' = HashMap a' n'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ahm_delete eq bhc k (HashMap a n),\n     ahm_delete (=) bhc' k' (HashMap a' n'))\n    \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel", "by (simp only: ahm_delete.simps Let_def,\n             insert eq isbhc bhc K A N bhc_range cmp, parametricity)"], ["proof (state)\nthis:\n  (ahm_delete eq bhc k m, ahm_delete (=) bhc' k' m') \\<in> \\<langle>Rk,\n  Rv\\<rangle>ahm_map_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ahm_delete_impl:\n  assumes bhc: \"is_bounded_hashcode Id (=) bhc\"\n  shows \"(ahm_delete (=) bhc, op_map_delete) \\<in> (Id::('k\\<times>'k) set) \\<rightarrow> \n              ahm_map_rel' bhc \\<rightarrow> ahm_map_rel' bhc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ahm_delete (=) bhc, op_map_delete)\n    \\<in> Id \\<rightarrow> ahm_map_rel' bhc \\<rightarrow> ahm_map_rel' bhc", "proof (intro fun_relI, clarsimp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a' aa a'a.\n       (aa, a'a) \\<in> ahm_map_rel' bhc \\<Longrightarrow>\n       (ahm_delete (=) bhc a' aa, a'a |` (- {a'})) \\<in> ahm_map_rel' bhc", "fix k::'k and hm::\"('k,'v) hashmap\" and  m::\"'k\\<rightharpoonup>'v\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a' aa a'a.\n       (aa, a'a) \\<in> ahm_map_rel' bhc \\<Longrightarrow>\n       (ahm_delete (=) bhc a' aa, a'a |` (- {a'})) \\<in> ahm_map_rel' bhc", "assume \"(hm,m) \\<in> ahm_map_rel' bhc\""], ["proof (state)\nthis:\n  (hm, m) \\<in> ahm_map_rel' bhc\n\ngoal (1 subgoal):\n 1. \\<And>a' aa a'a.\n       (aa, a'a) \\<in> ahm_map_rel' bhc \\<Longrightarrow>\n       (ahm_delete (=) bhc a' aa, a'a |` (- {a'})) \\<in> ahm_map_rel' bhc", "hence \\<alpha>: \"m = ahm_\\<alpha> bhc hm\" and inv: \"ahm_invar bhc hm\""], ["proof (prove)\nusing this:\n  (hm, m) \\<in> ahm_map_rel' bhc\n\ngoal (1 subgoal):\n 1. m = ahm_\\<alpha> bhc hm &&& ahm_invar bhc hm", "unfolding ahm_map_rel'_def br_def"], ["proof (prove)\nusing this:\n  (hm, m) \\<in> {(c, a). a = ahm_\\<alpha> bhc c \\<and> ahm_invar bhc c}\n\ngoal (1 subgoal):\n 1. m = ahm_\\<alpha> bhc hm &&& ahm_invar bhc hm", "by simp_all"], ["proof (state)\nthis:\n  m = ahm_\\<alpha> bhc hm\n  ahm_invar bhc hm\n\ngoal (1 subgoal):\n 1. \\<And>a' aa a'a.\n       (aa, a'a) \\<in> ahm_map_rel' bhc \\<Longrightarrow>\n       (ahm_delete (=) bhc a' aa, a'a |` (- {a'})) \\<in> ahm_map_rel' bhc", "obtain a n where [simp]: \"hm = HashMap a n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a n. hm = HashMap a n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases hm)"], ["proof (state)\nthis:\n  hm = HashMap a n\n\ngoal (1 subgoal):\n 1. \\<And>a' aa a'a.\n       (aa, a'a) \\<in> ahm_map_rel' bhc \\<Longrightarrow>\n       (ahm_delete (=) bhc a' aa, a'a |` (- {a'})) \\<in> ahm_map_rel' bhc", "have K: \"(k,k) \\<in> Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (k, k) \\<in> Id", "by simp"], ["proof (state)\nthis:\n  (k, k) \\<in> Id\n\ngoal (1 subgoal):\n 1. \\<And>a' aa a'a.\n       (aa, a'a) \\<in> ahm_map_rel' bhc \\<Longrightarrow>\n       (ahm_delete (=) bhc a' aa, a'a |` (- {a'})) \\<in> ahm_map_rel' bhc", "from inv"], ["proof (chain)\npicking this:\n  ahm_invar bhc hm", "have [simp]: \"1 < array_length a\""], ["proof (prove)\nusing this:\n  ahm_invar bhc hm\n\ngoal (1 subgoal):\n 1. 1 < array_length a", "unfolding ahm_invar_def ahm_invar_aux_def"], ["proof (prove)\nusing this:\n  rec_hashmap\n   (\\<lambda>a n bhc.\n       (\\<forall>h<array_length a.\n           bucket_ok bhc (array_length a) h (array_get a h) \\<and>\n           list_map_invar (array_get a h)) \\<and>\n       array_foldl (\\<lambda>_ n kvs. n + length kvs) 0 a = n \\<and>\n       1 < array_length a)\n   hm bhc\n\ngoal (1 subgoal):\n 1. 1 < array_length a", "by simp"], ["proof (state)\nthis:\n  1 < array_length a\n\ngoal (1 subgoal):\n 1. \\<And>a' aa a'a.\n       (aa, a'a) \\<in> ahm_map_rel' bhc \\<Longrightarrow>\n       (ahm_delete (=) bhc a' aa, a'a |` (- {a'})) \\<in> ahm_map_rel' bhc", "hence bhc_range[simp]: \"\\<And>k. bhc (array_length a) k < array_length a\""], ["proof (prove)\nusing this:\n  1 < array_length a\n\ngoal (1 subgoal):\n 1. \\<And>k. bhc (array_length a) k < array_length a", "using bhc"], ["proof (prove)\nusing this:\n  1 < array_length a\n  is_bounded_hashcode Id (=) bhc\n\ngoal (1 subgoal):\n 1. \\<And>k. bhc (array_length a) k < array_length a", "by blast"], ["proof (state)\nthis:\n  bhc (array_length a) ?k < array_length a\n\ngoal (1 subgoal):\n 1. \\<And>a' aa a'a.\n       (aa, a'a) \\<in> ahm_map_rel' bhc \\<Longrightarrow>\n       (ahm_delete (=) bhc a' aa, a'a |` (- {a'})) \\<in> ahm_map_rel' bhc", "let ?l = \"array_length a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a' aa a'a.\n       (aa, a'a) \\<in> ahm_map_rel' bhc \\<Longrightarrow>\n       (ahm_delete (=) bhc a' aa, a'a |` (- {a'})) \\<in> ahm_map_rel' bhc", "let ?h = \"bhc ?l k\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a' aa a'a.\n       (aa, a'a) \\<in> ahm_map_rel' bhc \\<Longrightarrow>\n       (ahm_delete (=) bhc a' aa, a'a |` (- {a'})) \\<in> ahm_map_rel' bhc", "let ?a' = \"array_set a ?h (list_map_delete (=) k (array_get a ?h))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a' aa a'a.\n       (aa, a'a) \\<in> ahm_map_rel' bhc \\<Longrightarrow>\n       (ahm_delete (=) bhc a' aa, a'a |` (- {a'})) \\<in> ahm_map_rel' bhc", "let ?n' = \"if list_map_lookup (=) k (array_get a ?h) = None then n else n - 1\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a' aa a'a.\n       (aa, a'a) \\<in> ahm_map_rel' bhc \\<Longrightarrow>\n       (ahm_delete (=) bhc a' aa, a'a |` (- {a'})) \\<in> ahm_map_rel' bhc", "let ?list = \"array_get a ?h\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a' aa a'a.\n       (aa, a'a) \\<in> ahm_map_rel' bhc \\<Longrightarrow>\n       (ahm_delete (=) bhc a' aa, a'a |` (- {a'})) \\<in> ahm_map_rel' bhc", "let ?list' = \"map_of ?list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a' aa a'a.\n       (aa, a'a) \\<in> ahm_map_rel' bhc \\<Longrightarrow>\n       (ahm_delete (=) bhc a' aa, a'a |` (- {a'})) \\<in> ahm_map_rel' bhc", "let ?list_new = \"list_map_delete (=) k ?list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a' aa a'a.\n       (aa, a'a) \\<in> ahm_map_rel' bhc \\<Longrightarrow>\n       (ahm_delete (=) bhc a' aa, a'a |` (- {a'})) \\<in> ahm_map_rel' bhc", "let ?list_new' = \"?list' |` (-{k})\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a' aa a'a.\n       (aa, a'a) \\<in> ahm_map_rel' bhc \\<Longrightarrow>\n       (ahm_delete (=) bhc a' aa, a'a |` (- {a'})) \\<in> ahm_map_rel' bhc", "from inv"], ["proof (chain)\npicking this:\n  ahm_invar bhc hm", "have \"(?list, ?list') \\<in> br map_of list_map_invar\""], ["proof (prove)\nusing this:\n  ahm_invar bhc hm\n\ngoal (1 subgoal):\n 1. (array_get a (bhc (array_length a) k),\n     map_of (array_get a (bhc (array_length a) k)))\n    \\<in> br map_of list_map_invar", "unfolding br_def ahm_invar_def ahm_invar_aux_def"], ["proof (prove)\nusing this:\n  rec_hashmap\n   (\\<lambda>a n bhc.\n       (\\<forall>h<array_length a.\n           bucket_ok bhc (array_length a) h (array_get a h) \\<and>\n           list_map_invar (array_get a h)) \\<and>\n       array_foldl (\\<lambda>_ n kvs. n + length kvs) 0 a = n \\<and>\n       1 < array_length a)\n   hm bhc\n\ngoal (1 subgoal):\n 1. (array_get a (bhc (array_length a) k),\n     map_of (array_get a (bhc (array_length a) k)))\n    \\<in> {(c, a). a = map_of c \\<and> list_map_invar c}", "by simp"], ["proof (state)\nthis:\n  (array_get a (bhc (array_length a) k),\n   map_of (array_get a (bhc (array_length a) k)))\n  \\<in> br map_of list_map_invar\n\ngoal (1 subgoal):\n 1. \\<And>a' aa a'a.\n       (aa, a'a) \\<in> ahm_map_rel' bhc \\<Longrightarrow>\n       (ahm_delete (=) bhc a' aa, a'a |` (- {a'})) \\<in> ahm_map_rel' bhc", "from list_map_autoref_delete2[param_fo, OF K this]"], ["proof (chain)\npicking this:\n  (list_map_delete (=) k (array_get a (bhc (array_length a) k)),\n   op_map_delete k (map_of (array_get a (bhc (array_length a) k))))\n  \\<in> br map_of list_map_invar", "have list_updated: \"map_of ?list_new = ?list_new'\"\n           \"list_map_invar ?list_new\""], ["proof (prove)\nusing this:\n  (list_map_delete (=) k (array_get a (bhc (array_length a) k)),\n   op_map_delete k (map_of (array_get a (bhc (array_length a) k))))\n  \\<in> br map_of list_map_invar\n\ngoal (1 subgoal):\n 1. map_of (list_map_delete (=) k (array_get a (bhc (array_length a) k))) =\n    map_of (array_get a (bhc (array_length a) k)) |` (- {k}) &&&\n    list_map_invar\n     (list_map_delete (=) k (array_get a (bhc (array_length a) k)))", "by (simp_all add: br_def)"], ["proof (state)\nthis:\n  map_of (list_map_delete (=) k (array_get a (bhc (array_length a) k))) =\n  map_of (array_get a (bhc (array_length a) k)) |` (- {k})\n  list_map_invar\n   (list_map_delete (=) k (array_get a (bhc (array_length a) k)))\n\ngoal (1 subgoal):\n 1. \\<And>a' aa a'a.\n       (aa, a'a) \\<in> ahm_map_rel' bhc \\<Longrightarrow>\n       (ahm_delete (=) bhc a' aa, a'a |` (- {a'})) \\<in> ahm_map_rel' bhc", "have [simp]: \"array_length ?a' = ?l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. array_length\n     (array_set a (bhc (array_length a) k)\n       (list_map_delete (=) k (array_get a (bhc (array_length a) k)))) =\n    array_length a", "by simp"], ["proof (state)\nthis:\n  array_length\n   (array_set a (bhc (array_length a) k)\n     (list_map_delete (=) k (array_get a (bhc (array_length a) k)))) =\n  array_length a\n\ngoal (1 subgoal):\n 1. \\<And>a' aa a'a.\n       (aa, a'a) \\<in> ahm_map_rel' bhc \\<Longrightarrow>\n       (ahm_delete (=) bhc a' aa, a'a |` (- {a'})) \\<in> ahm_map_rel' bhc", "have \"ahm_invar_aux bhc ?n' ?a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ahm_invar_aux bhc\n     (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) = None\n      then n else n - 1)\n     (array_set a (bhc (array_length a) k)\n       (list_map_delete (=) k (array_get a (bhc (array_length a) k))))", "proof(rule ahm_invar_auxI)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>h.\n       h < array_length\n            (array_set a (bhc (array_length a) k)\n              (list_map_delete (=) k\n                (array_get a (bhc (array_length a) k)))) \\<Longrightarrow>\n       bucket_ok bhc\n        (array_length\n          (array_set a (bhc (array_length a) k)\n            (list_map_delete (=) k (array_get a (bhc (array_length a) k)))))\n        h (array_get\n            (array_set a (bhc (array_length a) k)\n              (list_map_delete (=) k\n                (array_get a (bhc (array_length a) k))))\n            h)\n 2. \\<And>h.\n       h < array_length\n            (array_set a (bhc (array_length a) k)\n              (list_map_delete (=) k\n                (array_get a (bhc (array_length a) k)))) \\<Longrightarrow>\n       list_map_invar\n        (array_get\n          (array_set a (bhc (array_length a) k)\n            (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n          h)\n 3. (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) = None\n     then n else n - 1) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bhc (array_length a) k)\n       (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n 4. 1 < array_length\n         (array_set a (bhc (array_length a) k)\n           (list_map_delete (=) k (array_get a (bhc (array_length a) k))))", "fix h"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>h.\n       h < array_length\n            (array_set a (bhc (array_length a) k)\n              (list_map_delete (=) k\n                (array_get a (bhc (array_length a) k)))) \\<Longrightarrow>\n       bucket_ok bhc\n        (array_length\n          (array_set a (bhc (array_length a) k)\n            (list_map_delete (=) k (array_get a (bhc (array_length a) k)))))\n        h (array_get\n            (array_set a (bhc (array_length a) k)\n              (list_map_delete (=) k\n                (array_get a (bhc (array_length a) k))))\n            h)\n 2. \\<And>h.\n       h < array_length\n            (array_set a (bhc (array_length a) k)\n              (list_map_delete (=) k\n                (array_get a (bhc (array_length a) k)))) \\<Longrightarrow>\n       list_map_invar\n        (array_get\n          (array_set a (bhc (array_length a) k)\n            (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n          h)\n 3. (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) = None\n     then n else n - 1) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bhc (array_length a) k)\n       (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n 4. 1 < array_length\n         (array_set a (bhc (array_length a) k)\n           (list_map_delete (=) k (array_get a (bhc (array_length a) k))))", "assume \"h < array_length ?a'\""], ["proof (state)\nthis:\n  h < array_length\n       (array_set a (bhc (array_length a) k)\n         (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n\ngoal (4 subgoals):\n 1. \\<And>h.\n       h < array_length\n            (array_set a (bhc (array_length a) k)\n              (list_map_delete (=) k\n                (array_get a (bhc (array_length a) k)))) \\<Longrightarrow>\n       bucket_ok bhc\n        (array_length\n          (array_set a (bhc (array_length a) k)\n            (list_map_delete (=) k (array_get a (bhc (array_length a) k)))))\n        h (array_get\n            (array_set a (bhc (array_length a) k)\n              (list_map_delete (=) k\n                (array_get a (bhc (array_length a) k))))\n            h)\n 2. \\<And>h.\n       h < array_length\n            (array_set a (bhc (array_length a) k)\n              (list_map_delete (=) k\n                (array_get a (bhc (array_length a) k)))) \\<Longrightarrow>\n       list_map_invar\n        (array_get\n          (array_set a (bhc (array_length a) k)\n            (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n          h)\n 3. (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) = None\n     then n else n - 1) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bhc (array_length a) k)\n       (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n 4. 1 < array_length\n         (array_set a (bhc (array_length a) k)\n           (list_map_delete (=) k (array_get a (bhc (array_length a) k))))", "hence h_in_range[simp]: \"h < array_length a\""], ["proof (prove)\nusing this:\n  h < array_length\n       (array_set a (bhc (array_length a) k)\n         (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n\ngoal (1 subgoal):\n 1. h < array_length a", "by simp"], ["proof (state)\nthis:\n  h < array_length a\n\ngoal (4 subgoals):\n 1. \\<And>h.\n       h < array_length\n            (array_set a (bhc (array_length a) k)\n              (list_map_delete (=) k\n                (array_get a (bhc (array_length a) k)))) \\<Longrightarrow>\n       bucket_ok bhc\n        (array_length\n          (array_set a (bhc (array_length a) k)\n            (list_map_delete (=) k (array_get a (bhc (array_length a) k)))))\n        h (array_get\n            (array_set a (bhc (array_length a) k)\n              (list_map_delete (=) k\n                (array_get a (bhc (array_length a) k))))\n            h)\n 2. \\<And>h.\n       h < array_length\n            (array_set a (bhc (array_length a) k)\n              (list_map_delete (=) k\n                (array_get a (bhc (array_length a) k)))) \\<Longrightarrow>\n       list_map_invar\n        (array_get\n          (array_set a (bhc (array_length a) k)\n            (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n          h)\n 3. (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) = None\n     then n else n - 1) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bhc (array_length a) k)\n       (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n 4. 1 < array_length\n         (array_set a (bhc (array_length a) k)\n           (list_map_delete (=) k (array_get a (bhc (array_length a) k))))", "with inv"], ["proof (chain)\npicking this:\n  ahm_invar bhc hm\n  h < array_length a", "have inv': \"bucket_ok bhc ?l h (array_get a h)\" \"1 < ?l\" \n        \"list_map_invar (array_get a h)\""], ["proof (prove)\nusing this:\n  ahm_invar bhc hm\n  h < array_length a\n\ngoal (1 subgoal):\n 1. bucket_ok bhc (array_length a) h (array_get a h) &&&\n    1 < array_length a &&& list_map_invar (array_get a h)", "by (auto elim: ahm_invar_auxE)"], ["proof (state)\nthis:\n  bucket_ok bhc (array_length a) h (array_get a h)\n  1 < array_length a\n  list_map_invar (array_get a h)\n\ngoal (4 subgoals):\n 1. \\<And>h.\n       h < array_length\n            (array_set a (bhc (array_length a) k)\n              (list_map_delete (=) k\n                (array_get a (bhc (array_length a) k)))) \\<Longrightarrow>\n       bucket_ok bhc\n        (array_length\n          (array_set a (bhc (array_length a) k)\n            (list_map_delete (=) k (array_get a (bhc (array_length a) k)))))\n        h (array_get\n            (array_set a (bhc (array_length a) k)\n              (list_map_delete (=) k\n                (array_get a (bhc (array_length a) k))))\n            h)\n 2. \\<And>h.\n       h < array_length\n            (array_set a (bhc (array_length a) k)\n              (list_map_delete (=) k\n                (array_get a (bhc (array_length a) k)))) \\<Longrightarrow>\n       list_map_invar\n        (array_get\n          (array_set a (bhc (array_length a) k)\n            (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n          h)\n 3. (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) = None\n     then n else n - 1) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bhc (array_length a) k)\n       (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n 4. 1 < array_length\n         (array_set a (bhc (array_length a) k)\n           (list_map_delete (=) k (array_get a (bhc (array_length a) k))))", "show \"bucket_ok bhc (array_length ?a') h (array_get ?a' h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bucket_ok bhc\n     (array_length\n       (array_set a (bhc (array_length a) k)\n         (list_map_delete (=) k (array_get a (bhc (array_length a) k)))))\n     h (array_get\n         (array_set a (bhc (array_length a) k)\n           (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n         h)", "proof (cases \"h = bhc ?l k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. h = bhc (array_length a) k \\<Longrightarrow>\n    bucket_ok bhc\n     (array_length\n       (array_set a (bhc (array_length a) k)\n         (list_map_delete (=) k (array_get a (bhc (array_length a) k)))))\n     h (array_get\n         (array_set a (bhc (array_length a) k)\n           (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n         h)\n 2. h \\<noteq> bhc (array_length a) k \\<Longrightarrow>\n    bucket_ok bhc\n     (array_length\n       (array_set a (bhc (array_length a) k)\n         (list_map_delete (=) k (array_get a (bhc (array_length a) k)))))\n     h (array_get\n         (array_set a (bhc (array_length a) k)\n           (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n         h)", "case False"], ["proof (state)\nthis:\n  h \\<noteq> bhc (array_length a) k\n\ngoal (2 subgoals):\n 1. h = bhc (array_length a) k \\<Longrightarrow>\n    bucket_ok bhc\n     (array_length\n       (array_set a (bhc (array_length a) k)\n         (list_map_delete (=) k (array_get a (bhc (array_length a) k)))))\n     h (array_get\n         (array_set a (bhc (array_length a) k)\n           (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n         h)\n 2. h \\<noteq> bhc (array_length a) k \\<Longrightarrow>\n    bucket_ok bhc\n     (array_length\n       (array_set a (bhc (array_length a) k)\n         (list_map_delete (=) k (array_get a (bhc (array_length a) k)))))\n     h (array_get\n         (array_set a (bhc (array_length a) k)\n           (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n         h)", "thus ?thesis"], ["proof (prove)\nusing this:\n  h \\<noteq> bhc (array_length a) k\n\ngoal (1 subgoal):\n 1. bucket_ok bhc\n     (array_length\n       (array_set a (bhc (array_length a) k)\n         (list_map_delete (=) k (array_get a (bhc (array_length a) k)))))\n     h (array_get\n         (array_set a (bhc (array_length a) k)\n           (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n         h)", "using inv'"], ["proof (prove)\nusing this:\n  h \\<noteq> bhc (array_length a) k\n  bucket_ok bhc (array_length a) h (array_get a h)\n  1 < array_length a\n  list_map_invar (array_get a h)\n\ngoal (1 subgoal):\n 1. bucket_ok bhc\n     (array_length\n       (array_set a (bhc (array_length a) k)\n         (list_map_delete (=) k (array_get a (bhc (array_length a) k)))))\n     h (array_get\n         (array_set a (bhc (array_length a) k)\n           (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n         h)", "by (simp add: array_get_array_set_other)"], ["proof (state)\nthis:\n  bucket_ok bhc\n   (array_length\n     (array_set a (bhc (array_length a) k)\n       (list_map_delete (=) k (array_get a (bhc (array_length a) k)))))\n   h (array_get\n       (array_set a (bhc (array_length a) k)\n         (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n       h)\n\ngoal (1 subgoal):\n 1. h = bhc (array_length a) k \\<Longrightarrow>\n    bucket_ok bhc\n     (array_length\n       (array_set a (bhc (array_length a) k)\n         (list_map_delete (=) k (array_get a (bhc (array_length a) k)))))\n     h (array_get\n         (array_set a (bhc (array_length a) k)\n           (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n         h)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. h = bhc (array_length a) k \\<Longrightarrow>\n    bucket_ok bhc\n     (array_length\n       (array_set a (bhc (array_length a) k)\n         (list_map_delete (=) k (array_get a (bhc (array_length a) k)))))\n     h (array_get\n         (array_set a (bhc (array_length a) k)\n           (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n         h)", "case True"], ["proof (state)\nthis:\n  h = bhc (array_length a) k\n\ngoal (1 subgoal):\n 1. h = bhc (array_length a) k \\<Longrightarrow>\n    bucket_ok bhc\n     (array_length\n       (array_set a (bhc (array_length a) k)\n         (list_map_delete (=) k (array_get a (bhc (array_length a) k)))))\n     h (array_get\n         (array_set a (bhc (array_length a) k)\n           (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n         h)", "thus ?thesis"], ["proof (prove)\nusing this:\n  h = bhc (array_length a) k\n\ngoal (1 subgoal):\n 1. bucket_ok bhc\n     (array_length\n       (array_set a (bhc (array_length a) k)\n         (list_map_delete (=) k (array_get a (bhc (array_length a) k)))))\n     h (array_get\n         (array_set a (bhc (array_length a) k)\n           (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n         h)", "proof (simp, intro bucket_okI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ka.\n       \\<lbrakk>h = bhc (array_length a) k; h = bhc (array_length a) k;\n        ka \\<in> fst `\n                 set (list_map_delete (=) k\n                       (array_get a (bhc (array_length a) k)))\\<rbrakk>\n       \\<Longrightarrow> bhc (array_length a) ka = bhc (array_length a) k", "case prems: (1 k')"], ["proof (state)\nthis:\n  h = bhc (array_length a) k\n  h = bhc (array_length a) k\n  k' \\<in> fst `\n           set (list_map_delete (=) k\n                 (array_get a (bhc (array_length a) k)))\n\ngoal (1 subgoal):\n 1. \\<And>ka.\n       \\<lbrakk>h = bhc (array_length a) k; h = bhc (array_length a) k;\n        ka \\<in> fst `\n                 set (list_map_delete (=) k\n                       (array_get a (bhc (array_length a) k)))\\<rbrakk>\n       \\<Longrightarrow> bhc (array_length a) ka = bhc (array_length a) k", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. bhc (array_length a) k' = bhc (array_length a) k", "proof (cases \"k = k'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k = k' \\<Longrightarrow>\n    bhc (array_length a) k' = bhc (array_length a) k\n 2. k \\<noteq> k' \\<Longrightarrow>\n    bhc (array_length a) k' = bhc (array_length a) k", "case False"], ["proof (state)\nthis:\n  k \\<noteq> k'\n\ngoal (2 subgoals):\n 1. k = k' \\<Longrightarrow>\n    bhc (array_length a) k' = bhc (array_length a) k\n 2. k \\<noteq> k' \\<Longrightarrow>\n    bhc (array_length a) k' = bhc (array_length a) k", "from prems"], ["proof (chain)\npicking this:\n  h = bhc (array_length a) k\n  h = bhc (array_length a) k\n  k' \\<in> fst `\n           set (list_map_delete (=) k\n                 (array_get a (bhc (array_length a) k)))", "have \"k' \\<in> dom ?list_new'\""], ["proof (prove)\nusing this:\n  h = bhc (array_length a) k\n  h = bhc (array_length a) k\n  k' \\<in> fst `\n           set (list_map_delete (=) k\n                 (array_get a (bhc (array_length a) k)))\n\ngoal (1 subgoal):\n 1. k' \\<in> dom (map_of (array_get a (bhc (array_length a) k)) |` (- {k}))", "by (simp only: dom_map_of_conv_image_fst \n                          list_updated(1)[symmetric])"], ["proof (state)\nthis:\n  k' \\<in> dom (map_of (array_get a (bhc (array_length a) k)) |` (- {k}))\n\ngoal (2 subgoals):\n 1. k = k' \\<Longrightarrow>\n    bhc (array_length a) k' = bhc (array_length a) k\n 2. k \\<noteq> k' \\<Longrightarrow>\n    bhc (array_length a) k' = bhc (array_length a) k", "hence \"k' \\<in> fst`set ?list\""], ["proof (prove)\nusing this:\n  k' \\<in> dom (map_of (array_get a (bhc (array_length a) k)) |` (- {k}))\n\ngoal (1 subgoal):\n 1. k' \\<in> fst ` set (array_get a (bhc (array_length a) k))", "using False"], ["proof (prove)\nusing this:\n  k' \\<in> dom (map_of (array_get a (bhc (array_length a) k)) |` (- {k}))\n  k \\<noteq> k'\n\ngoal (1 subgoal):\n 1. k' \\<in> fst ` set (array_get a (bhc (array_length a) k))", "by (simp add: dom_map_of_conv_image_fst)"], ["proof (state)\nthis:\n  k' \\<in> fst ` set (array_get a (bhc (array_length a) k))\n\ngoal (2 subgoals):\n 1. k = k' \\<Longrightarrow>\n    bhc (array_length a) k' = bhc (array_length a) k\n 2. k \\<noteq> k' \\<Longrightarrow>\n    bhc (array_length a) k' = bhc (array_length a) k", "from imageE[OF this]"], ["proof (chain)\npicking this:\n  (\\<And>x.\n      \\<lbrakk>k' = fst x;\n       x \\<in> set (array_get a (bhc (array_length a) k))\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain x where \n                      \"fst x = k'\" and \"x \\<in> set ?list\""], ["proof (prove)\nusing this:\n  (\\<And>x.\n      \\<lbrakk>k' = fst x;\n       x \\<in> set (array_get a (bhc (array_length a) k))\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>fst x = k';\n         x \\<in> set (array_get a (bhc (array_length a) k))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  fst x = k'\n  x \\<in> set (array_get a (bhc (array_length a) k))\n\ngoal (2 subgoals):\n 1. k = k' \\<Longrightarrow>\n    bhc (array_length a) k' = bhc (array_length a) k\n 2. k \\<noteq> k' \\<Longrightarrow>\n    bhc (array_length a) k' = bhc (array_length a) k", "then"], ["proof (chain)\npicking this:\n  fst x = k'\n  x \\<in> set (array_get a (bhc (array_length a) k))", "obtain v' where \"(k',v') \\<in> set ?list\""], ["proof (prove)\nusing this:\n  fst x = k'\n  x \\<in> set (array_get a (bhc (array_length a) k))\n\ngoal (1 subgoal):\n 1. (\\<And>v'.\n        (k', v')\n        \\<in> set (array_get a (bhc (array_length a) k)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases x, simp)"], ["proof (state)\nthis:\n  (k', v') \\<in> set (array_get a (bhc (array_length a) k))\n\ngoal (2 subgoals):\n 1. k = k' \\<Longrightarrow>\n    bhc (array_length a) k' = bhc (array_length a) k\n 2. k \\<noteq> k' \\<Longrightarrow>\n    bhc (array_length a) k' = bhc (array_length a) k", "with bucket_okD[OF inv'(1)] and \n                      \\<open>h = bhc (array_length a) k\\<close>"], ["proof (chain)\npicking this:\n  (?k, ?v) \\<in> set (array_get a h) \\<Longrightarrow>\n  bhc (array_length a) ?k = h\n  h = bhc (array_length a) k\n  (k', v') \\<in> set (array_get a (bhc (array_length a) k))", "show ?thesis"], ["proof (prove)\nusing this:\n  (?k, ?v) \\<in> set (array_get a h) \\<Longrightarrow>\n  bhc (array_length a) ?k = h\n  h = bhc (array_length a) k\n  (k', v') \\<in> set (array_get a (bhc (array_length a) k))\n\ngoal (1 subgoal):\n 1. bhc (array_length a) k' = bhc (array_length a) k", "by blast"], ["proof (state)\nthis:\n  bhc (array_length a) k' = bhc (array_length a) k\n\ngoal (1 subgoal):\n 1. k = k' \\<Longrightarrow>\n    bhc (array_length a) k' = bhc (array_length a) k", "qed simp"], ["proof (state)\nthis:\n  bhc (array_length a) k' = bhc (array_length a) k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bucket_ok bhc\n   (array_length\n     (array_set a (bhc (array_length a) k)\n       (list_map_delete (=) k (array_get a (bhc (array_length a) k)))))\n   h (array_get\n       (array_set a (bhc (array_length a) k)\n         (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n       h)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bucket_ok bhc\n   (array_length\n     (array_set a (bhc (array_length a) k)\n       (list_map_delete (=) k (array_get a (bhc (array_length a) k)))))\n   h (array_get\n       (array_set a (bhc (array_length a) k)\n         (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n       h)\n\ngoal (3 subgoals):\n 1. \\<And>h.\n       h < array_length\n            (array_set a (bhc (array_length a) k)\n              (list_map_delete (=) k\n                (array_get a (bhc (array_length a) k)))) \\<Longrightarrow>\n       list_map_invar\n        (array_get\n          (array_set a (bhc (array_length a) k)\n            (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n          h)\n 2. (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) = None\n     then n else n - 1) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bhc (array_length a) k)\n       (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n 3. 1 < array_length\n         (array_set a (bhc (array_length a) k)\n           (list_map_delete (=) k (array_get a (bhc (array_length a) k))))", "from inv'(3) \\<open>h < array_length a\\<close>"], ["proof (chain)\npicking this:\n  list_map_invar (array_get a h)\n  h < array_length a", "show \"list_map_invar (array_get ?a' h)\""], ["proof (prove)\nusing this:\n  list_map_invar (array_get a h)\n  h < array_length a\n\ngoal (1 subgoal):\n 1. list_map_invar\n     (array_get\n       (array_set a (bhc (array_length a) k)\n         (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n       h)", "by (cases \"h = ?h\", simp_all add: \n            list_updated array_get_array_set_other)"], ["proof (state)\nthis:\n  list_map_invar\n   (array_get\n     (array_set a (bhc (array_length a) k)\n       (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n     h)\n\ngoal (2 subgoals):\n 1. (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) = None\n     then n else n - 1) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bhc (array_length a) k)\n       (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n 2. 1 < array_length\n         (array_set a (bhc (array_length a) k)\n           (list_map_delete (=) k (array_get a (bhc (array_length a) k))))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) = None\n     then n else n - 1) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bhc (array_length a) k)\n       (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n 2. 1 < array_length\n         (array_set a (bhc (array_length a) k)\n           (list_map_delete (=) k (array_get a (bhc (array_length a) k))))", "obtain xs where a [simp]: \"a = Array xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs. a = Array xs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases a)"], ["proof (state)\nthis:\n  a = Array xs\n\ngoal (2 subgoals):\n 1. (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) = None\n     then n else n - 1) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bhc (array_length a) k)\n       (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n 2. 1 < array_length\n         (array_set a (bhc (array_length a) k)\n           (list_map_delete (=) k (array_get a (bhc (array_length a) k))))", "let ?f = \"\\<lambda>n kvs. n + length (kvs::('k\\<times>'v) list)\""], ["proof (state)\ngoal (2 subgoals):\n 1. (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) = None\n     then n else n - 1) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bhc (array_length a) k)\n       (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n 2. 1 < array_length\n         (array_set a (bhc (array_length a) k)\n           (list_map_delete (=) k (array_get a (bhc (array_length a) k))))", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) = None\n     then n else n - 1) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bhc (array_length a) k)\n       (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n 2. 1 < array_length\n         (array_set a (bhc (array_length a) k)\n           (list_map_delete (=) k (array_get a (bhc (array_length a) k))))", "fix n :: nat and xs :: \"('k\\<times>'v) list list\""], ["proof (state)\ngoal (2 subgoals):\n 1. (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) = None\n     then n__ else n__ - 1) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bhc (array_length a) k)\n       (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n 2. 1 < array_length\n         (array_set a (bhc (array_length a) k)\n           (list_map_delete (=) k (array_get a (bhc (array_length a) k))))", "have \"foldl ?f n xs = n + foldl ?f 0 xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (\\<lambda>n kvs. n + length kvs) n xs =\n    n + foldl (\\<lambda>n kvs. n + length kvs) 0 xs", "by(induct xs arbitrary:  rule: rev_induct) simp_all"], ["proof (state)\nthis:\n  foldl (\\<lambda>n kvs. n + length kvs) n xs =\n  n + foldl (\\<lambda>n kvs. n + length kvs) 0 xs\n\ngoal (2 subgoals):\n 1. (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) = None\n     then n__ else n__ - 1) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bhc (array_length a) k)\n       (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n 2. 1 < array_length\n         (array_set a (bhc (array_length a) k)\n           (list_map_delete (=) k (array_get a (bhc (array_length a) k))))", "}"], ["proof (state)\nthis:\n  foldl (\\<lambda>n kvs. n + length kvs) ?na2 ?xsa2 =\n  ?na2 + foldl (\\<lambda>n kvs. n + length kvs) 0 ?xsa2\n\ngoal (2 subgoals):\n 1. (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) = None\n     then n else n - 1) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bhc (array_length a) k)\n       (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n 2. 1 < array_length\n         (array_set a (bhc (array_length a) k)\n           (list_map_delete (=) k (array_get a (bhc (array_length a) k))))", "note fold = this"], ["proof (state)\nthis:\n  foldl (\\<lambda>n kvs. n + length kvs) ?na2 ?xsa2 =\n  ?na2 + foldl (\\<lambda>n kvs. n + length kvs) 0 ?xsa2\n\ngoal (2 subgoals):\n 1. (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) = None\n     then n else n - 1) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bhc (array_length a) k)\n       (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n 2. 1 < array_length\n         (array_set a (bhc (array_length a) k)\n           (list_map_delete (=) k (array_get a (bhc (array_length a) k))))", "from bhc_range"], ["proof (chain)\npicking this:\n  bhc (array_length a) ?k < array_length a", "have [simp]: \"bhc (length xs) k < length xs\""], ["proof (prove)\nusing this:\n  bhc (array_length a) ?k < array_length a\n\ngoal (1 subgoal):\n 1. bhc (length xs) k < length xs", "by simp"], ["proof (state)\nthis:\n  bhc (length xs) k < length xs\n\ngoal (2 subgoals):\n 1. (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) = None\n     then n else n - 1) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bhc (array_length a) k)\n       (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n 2. 1 < array_length\n         (array_set a (bhc (array_length a) k)\n           (list_map_delete (=) k (array_get a (bhc (array_length a) k))))", "moreover"], ["proof (state)\nthis:\n  bhc (length xs) k < length xs\n\ngoal (2 subgoals):\n 1. (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) = None\n     then n else n - 1) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bhc (array_length a) k)\n       (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n 2. 1 < array_length\n         (array_set a (bhc (array_length a) k)\n           (list_map_delete (=) k (array_get a (bhc (array_length a) k))))", "have xs: \"xs = take ?h xs @ (xs ! ?h) # drop (Suc ?h) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs =\n    take (bhc (array_length a) k) xs @\n    xs ! bhc (array_length a) k # drop (Suc (bhc (array_length a) k)) xs", "by(simp add: Cons_nth_drop_Suc)"], ["proof (state)\nthis:\n  xs =\n  take (bhc (array_length a) k) xs @\n  xs ! bhc (array_length a) k # drop (Suc (bhc (array_length a) k)) xs\n\ngoal (2 subgoals):\n 1. (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) = None\n     then n else n - 1) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bhc (array_length a) k)\n       (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n 2. 1 < array_length\n         (array_set a (bhc (array_length a) k)\n           (list_map_delete (=) k (array_get a (bhc (array_length a) k))))", "from inv"], ["proof (chain)\npicking this:\n  ahm_invar bhc hm", "have \"n = array_foldl (\\<lambda>_ n kvs. n + length kvs) 0 a\""], ["proof (prove)\nusing this:\n  ahm_invar bhc hm\n\ngoal (1 subgoal):\n 1. n = array_foldl (\\<lambda>_ n kvs. n + length kvs) 0 a", "by(auto elim: ahm_invar_auxE)"], ["proof (state)\nthis:\n  n = array_foldl (\\<lambda>_ n kvs. n + length kvs) 0 a\n\ngoal (2 subgoals):\n 1. (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) = None\n     then n else n - 1) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bhc (array_length a) k)\n       (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n 2. 1 < array_length\n         (array_set a (bhc (array_length a) k)\n           (list_map_delete (=) k (array_get a (bhc (array_length a) k))))", "hence \"n = foldl ?f 0 (take ?h xs) + length (xs ! ?h) + foldl ?f 0 (drop (Suc ?h) xs)\""], ["proof (prove)\nusing this:\n  n = array_foldl (\\<lambda>_ n kvs. n + length kvs) 0 a\n\ngoal (1 subgoal):\n 1. n =\n    foldl (\\<lambda>n kvs. n + length kvs) 0\n     (take (bhc (array_length a) k) xs) +\n    length (xs ! bhc (array_length a) k) +\n    foldl (\\<lambda>n kvs. n + length kvs) 0\n     (drop (Suc (bhc (array_length a) k)) xs)", "by(simp add: array_foldl_foldl)(subst xs, simp, subst (1 2 3 4) fold, simp)"], ["proof (state)\nthis:\n  n =\n  foldl (\\<lambda>n kvs. n + length kvs) 0\n   (take (bhc (array_length a) k) xs) +\n  length (xs ! bhc (array_length a) k) +\n  foldl (\\<lambda>n kvs. n + length kvs) 0\n   (drop (Suc (bhc (array_length a) k)) xs)\n\ngoal (2 subgoals):\n 1. (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) = None\n     then n else n - 1) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bhc (array_length a) k)\n       (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n 2. 1 < array_length\n         (array_set a (bhc (array_length a) k)\n           (list_map_delete (=) k (array_get a (bhc (array_length a) k))))", "moreover"], ["proof (state)\nthis:\n  n =\n  foldl (\\<lambda>n kvs. n + length kvs) 0\n   (take (bhc (array_length a) k) xs) +\n  length (xs ! bhc (array_length a) k) +\n  foldl (\\<lambda>n kvs. n + length kvs) 0\n   (drop (Suc (bhc (array_length a) k)) xs)\n\ngoal (2 subgoals):\n 1. (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) = None\n     then n else n - 1) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bhc (array_length a) k)\n       (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n 2. 1 < array_length\n         (array_set a (bhc (array_length a) k)\n           (list_map_delete (=) k (array_get a (bhc (array_length a) k))))", "have \"\\<And>v a b. list_map_lookup (=) k (xs ! ?h) = Some v\n        \\<Longrightarrow> a + (length (xs ! ?h) - 1) + b = a + length (xs ! ?h) + b - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v aa b.\n       list_map_lookup (=) k (xs ! bhc (array_length a) k) =\n       Some v \\<Longrightarrow>\n       aa + (length (xs ! bhc (array_length a) k) - 1) + b =\n       aa + length (xs ! bhc (array_length a) k) + b - 1", "by (cases \"xs ! ?h\", simp_all)"], ["proof (state)\nthis:\n  list_map_lookup (=) k (xs ! bhc (array_length a) k) =\n  Some ?v \\<Longrightarrow>\n  ?a + (length (xs ! bhc (array_length a) k) - 1) + ?b =\n  ?a + length (xs ! bhc (array_length a) k) + ?b - 1\n\ngoal (2 subgoals):\n 1. (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) = None\n     then n else n - 1) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bhc (array_length a) k)\n       (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n 2. 1 < array_length\n         (array_set a (bhc (array_length a) k)\n           (list_map_delete (=) k (array_get a (bhc (array_length a) k))))", "ultimately"], ["proof (chain)\npicking this:\n  bhc (length xs) k < length xs\n  n =\n  foldl (\\<lambda>n kvs. n + length kvs) 0\n   (take (bhc (array_length a) k) xs) +\n  length (xs ! bhc (array_length a) k) +\n  foldl (\\<lambda>n kvs. n + length kvs) 0\n   (drop (Suc (bhc (array_length a) k)) xs)\n  list_map_lookup (=) k (xs ! bhc (array_length a) k) =\n  Some ?v \\<Longrightarrow>\n  ?a + (length (xs ! bhc (array_length a) k) - 1) + ?b =\n  ?a + length (xs ! bhc (array_length a) k) + ?b - 1", "show \"?n' = array_foldl (\\<lambda>_ n kvs. n + length kvs) 0 ?a'\""], ["proof (prove)\nusing this:\n  bhc (length xs) k < length xs\n  n =\n  foldl (\\<lambda>n kvs. n + length kvs) 0\n   (take (bhc (array_length a) k) xs) +\n  length (xs ! bhc (array_length a) k) +\n  foldl (\\<lambda>n kvs. n + length kvs) 0\n   (drop (Suc (bhc (array_length a) k)) xs)\n  list_map_lookup (=) k (xs ! bhc (array_length a) k) =\n  Some ?v \\<Longrightarrow>\n  ?a + (length (xs ! bhc (array_length a) k) - 1) + ?b =\n  ?a + length (xs ! bhc (array_length a) k) + ?b - 1\n\ngoal (1 subgoal):\n 1. (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) = None\n     then n else n - 1) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bhc (array_length a) k)\n       (list_map_delete (=) k (array_get a (bhc (array_length a) k))))", "apply(simp add: array_foldl_foldl foldl_list_update map_of_eq_None_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n =\n             foldl (\\<lambda>n kvs. n + length kvs) 0\n              (take (bhc (length xs) k) xs) +\n             length (xs ! bhc (length xs) k) +\n             foldl (\\<lambda>n kvs. n + length kvs) 0\n              (drop (Suc (bhc (length xs) k)) xs);\n     \\<And>v a b.\n        list_map_lookup (=) k (xs ! bhc (length xs) k) =\n        Some v \\<Longrightarrow>\n        a + (length (xs ! bhc (length xs) k) - Suc 0) + b =\n        a + length (xs ! bhc (length xs) k) + b - Suc 0\\<rbrakk>\n    \\<Longrightarrow> (list_map_lookup (=) k (xs ! bhc (length xs) k) =\n                       None \\<longrightarrow>\n                       foldl (\\<lambda>n kvs. n + length kvs) 0\n                        (take (bhc (length xs) k) xs) +\n                       length (xs ! bhc (length xs) k) +\n                       foldl (\\<lambda>n kvs. n + length kvs) 0\n                        (drop (Suc (bhc (length xs) k)) xs) =\n                       foldl (\\<lambda>n kvs. n + length kvs)\n                        (foldl (\\<lambda>n kvs. n + length kvs) 0\n                          (take (bhc (length xs) k) xs) +\n                         length\n                          (list_map_delete (=) k (xs ! bhc (length xs) k)))\n                        (drop (Suc (bhc (length xs) k)) xs)) \\<and>\n                      ((\\<exists>y.\n                           list_map_lookup (=) k (xs ! bhc (length xs) k) =\n                           Some y) \\<longrightarrow>\n                       foldl (\\<lambda>n kvs. n + length kvs) 0\n                        (take (bhc (length xs) k) xs) +\n                       length (xs ! bhc (length xs) k) +\n                       foldl (\\<lambda>n kvs. n + length kvs) 0\n                        (drop (Suc (bhc (length xs) k)) xs) -\n                       Suc 0 =\n                       foldl (\\<lambda>n kvs. n + length kvs)\n                        (foldl (\\<lambda>n kvs. n + length kvs) 0\n                          (take (bhc (length xs) k) xs) +\n                         length\n                          (list_map_delete (=) k (xs ! bhc (length xs) k)))\n                        (drop (Suc (bhc (length xs) k)) xs))", "apply(subst (1 2 3 4 5 6 7 8) fold)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n =\n             foldl (\\<lambda>n kvs. n + length kvs) 0\n              (take (bhc (length xs) k) xs) +\n             length (xs ! bhc (length xs) k) +\n             foldl (\\<lambda>n kvs. n + length kvs) 0\n              (drop (Suc (bhc (length xs) k)) xs);\n     \\<And>v a b.\n        list_map_lookup (=) k (xs ! bhc (length xs) k) =\n        Some v \\<Longrightarrow>\n        a + (length (xs ! bhc (length xs) k) - Suc 0) + b =\n        a + length (xs ! bhc (length xs) k) + b - Suc 0\\<rbrakk>\n    \\<Longrightarrow> (list_map_lookup (=) k (xs ! bhc (length xs) k) =\n                       None \\<longrightarrow>\n                       0 +\n                       foldl (\\<lambda>n kvs. n + length kvs) 0\n                        (take (bhc (length xs) k) xs) +\n                       length (xs ! bhc (length xs) k) +\n                       (0 +\n                        foldl (\\<lambda>n kvs. n + length kvs) 0\n                         (drop (Suc (bhc (length xs) k)) xs)) =\n                       0 +\n                       foldl (\\<lambda>n kvs. n + length kvs) 0\n                        (take (bhc (length xs) k) xs) +\n                       length\n                        (list_map_delete (=) k (xs ! bhc (length xs) k)) +\n                       foldl (\\<lambda>n kvs. n + length kvs) 0\n                        (drop (Suc (bhc (length xs) k)) xs)) \\<and>\n                      ((\\<exists>y.\n                           list_map_lookup (=) k (xs ! bhc (length xs) k) =\n                           Some y) \\<longrightarrow>\n                       0 +\n                       foldl (\\<lambda>n kvs. n + length kvs) 0\n                        (take (bhc (length xs) k) xs) +\n                       length (xs ! bhc (length xs) k) +\n                       (0 +\n                        foldl (\\<lambda>n kvs. n + length kvs) 0\n                         (drop (Suc (bhc (length xs) k)) xs)) -\n                       Suc 0 =\n                       0 +\n                       foldl (\\<lambda>n kvs. n + length kvs) 0\n                        (take (bhc (length xs) k) xs) +\n                       length\n                        (list_map_delete (=) k (xs ! bhc (length xs) k)) +\n                       foldl (\\<lambda>n kvs. n + length kvs) 0\n                        (drop (Suc (bhc (length xs) k)) xs))", "apply (intro conjI impI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>n =\n             foldl (\\<lambda>n kvs. n + length kvs) 0\n              (take (bhc (length xs) k) xs) +\n             length (xs ! bhc (length xs) k) +\n             foldl (\\<lambda>n kvs. n + length kvs) 0\n              (drop (Suc (bhc (length xs) k)) xs);\n     \\<And>v a b.\n        list_map_lookup (=) k (xs ! bhc (length xs) k) =\n        Some v \\<Longrightarrow>\n        a + (length (xs ! bhc (length xs) k) - Suc 0) + b =\n        a + length (xs ! bhc (length xs) k) + b - Suc 0;\n     list_map_lookup (=) k (xs ! bhc (length xs) k) = None\\<rbrakk>\n    \\<Longrightarrow> 0 +\n                      foldl (\\<lambda>n kvs. n + length kvs) 0\n                       (take (bhc (length xs) k) xs) +\n                      length (xs ! bhc (length xs) k) +\n                      (0 +\n                       foldl (\\<lambda>n kvs. n + length kvs) 0\n                        (drop (Suc (bhc (length xs) k)) xs)) =\n                      0 +\n                      foldl (\\<lambda>n kvs. n + length kvs) 0\n                       (take (bhc (length xs) k) xs) +\n                      length\n                       (list_map_delete (=) k (xs ! bhc (length xs) k)) +\n                      foldl (\\<lambda>n kvs. n + length kvs) 0\n                       (drop (Suc (bhc (length xs) k)) xs)\n 2. \\<lbrakk>n =\n             foldl (\\<lambda>n kvs. n + length kvs) 0\n              (take (bhc (length xs) k) xs) +\n             length (xs ! bhc (length xs) k) +\n             foldl (\\<lambda>n kvs. n + length kvs) 0\n              (drop (Suc (bhc (length xs) k)) xs);\n     \\<And>v a b.\n        list_map_lookup (=) k (xs ! bhc (length xs) k) =\n        Some v \\<Longrightarrow>\n        a + (length (xs ! bhc (length xs) k) - Suc 0) + b =\n        a + length (xs ! bhc (length xs) k) + b - Suc 0;\n     \\<exists>y.\n        list_map_lookup (=) k (xs ! bhc (length xs) k) = Some y\\<rbrakk>\n    \\<Longrightarrow> 0 +\n                      foldl (\\<lambda>n kvs. n + length kvs) 0\n                       (take (bhc (length xs) k) xs) +\n                      length (xs ! bhc (length xs) k) +\n                      (0 +\n                       foldl (\\<lambda>n kvs. n + length kvs) 0\n                        (drop (Suc (bhc (length xs) k)) xs)) -\n                      Suc 0 =\n                      0 +\n                      foldl (\\<lambda>n kvs. n + length kvs) 0\n                       (take (bhc (length xs) k) xs) +\n                      length\n                       (list_map_delete (=) k (xs ! bhc (length xs) k)) +\n                      foldl (\\<lambda>n kvs. n + length kvs) 0\n                       (drop (Suc (bhc (length xs) k)) xs)", "apply(auto simp add: length_list_map_delete)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) = None\n   then n else n - 1) =\n  array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n   (array_set a (bhc (array_length a) k)\n     (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n\ngoal (1 subgoal):\n 1. 1 < array_length\n         (array_set a (bhc (array_length a) k)\n           (list_map_delete (=) k (array_get a (bhc (array_length a) k))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 1 < array_length\n         (array_set a (bhc (array_length a) k)\n           (list_map_delete (=) k (array_get a (bhc (array_length a) k))))", "from inv"], ["proof (chain)\npicking this:\n  ahm_invar bhc hm", "show \"1 < array_length ?a'\""], ["proof (prove)\nusing this:\n  ahm_invar bhc hm\n\ngoal (1 subgoal):\n 1. 1 < array_length\n         (array_set a (bhc (array_length a) k)\n           (list_map_delete (=) k (array_get a (bhc (array_length a) k))))", "by(auto elim: ahm_invar_auxE)"], ["proof (state)\nthis:\n  1 < array_length\n       (array_set a (bhc (array_length a) k)\n         (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ahm_invar_aux bhc\n   (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) = None\n    then n else n - 1)\n   (array_set a (bhc (array_length a) k)\n     (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n\ngoal (1 subgoal):\n 1. \\<And>a' aa a'a.\n       (aa, a'a) \\<in> ahm_map_rel' bhc \\<Longrightarrow>\n       (ahm_delete (=) bhc a' aa, a'a |` (- {a'})) \\<in> ahm_map_rel' bhc", "hence \"ahm_invar bhc (HashMap ?a' ?n')\""], ["proof (prove)\nusing this:\n  ahm_invar_aux bhc\n   (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) = None\n    then n else n - 1)\n   (array_set a (bhc (array_length a) k)\n     (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n\ngoal (1 subgoal):\n 1. ahm_invar bhc\n     (HashMap\n       (array_set a (bhc (array_length a) k)\n         (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n       (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) =\n           None\n        then n else n - 1))", "by simp"], ["proof (state)\nthis:\n  ahm_invar bhc\n   (HashMap\n     (array_set a (bhc (array_length a) k)\n       (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n     (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) = None\n      then n else n - 1))\n\ngoal (1 subgoal):\n 1. \\<And>a' aa a'a.\n       (aa, a'a) \\<in> ahm_map_rel' bhc \\<Longrightarrow>\n       (ahm_delete (=) bhc a' aa, a'a |` (- {a'})) \\<in> ahm_map_rel' bhc", "moreover"], ["proof (state)\nthis:\n  ahm_invar bhc\n   (HashMap\n     (array_set a (bhc (array_length a) k)\n       (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n     (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) = None\n      then n else n - 1))\n\ngoal (1 subgoal):\n 1. \\<And>a' aa a'a.\n       (aa, a'a) \\<in> ahm_map_rel' bhc \\<Longrightarrow>\n       (ahm_delete (=) bhc a' aa, a'a |` (- {a'})) \\<in> ahm_map_rel' bhc", "have \"ahm_\\<alpha>_aux bhc ?a' = ahm_\\<alpha>_aux bhc a |` (- {k})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ahm_\\<alpha>_aux bhc\n     (array_set a (bhc (array_length a) k)\n       (list_map_delete (=) k (array_get a (bhc (array_length a) k)))) =\n    ahm_\\<alpha>_aux bhc a |` (- {k})", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       ahm_\\<alpha>_aux bhc\n        (array_set a (bhc (array_length a) k)\n          (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n        x =\n       (ahm_\\<alpha>_aux bhc a |` (- {k})) x", "fix k' :: 'k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       ahm_\\<alpha>_aux bhc\n        (array_set a (bhc (array_length a) k)\n          (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n        x =\n       (ahm_\\<alpha>_aux bhc a |` (- {k})) x", "show \"ahm_\\<alpha>_aux bhc ?a' k' = (ahm_\\<alpha>_aux bhc a |` (- {k})) k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ahm_\\<alpha>_aux bhc\n     (array_set a (bhc (array_length a) k)\n       (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n     k' =\n    (ahm_\\<alpha>_aux bhc a |` (- {k})) k'", "proof (cases \"bhc ?l k' = ?h\")"], ["proof (state)\ngoal (2 subgoals):\n 1. bhc (array_length a) k' = bhc (array_length a) k \\<Longrightarrow>\n    ahm_\\<alpha>_aux bhc\n     (array_set a (bhc (array_length a) k)\n       (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n     k' =\n    (ahm_\\<alpha>_aux bhc a |` (- {k})) k'\n 2. bhc (array_length a) k' \\<noteq>\n    bhc (array_length a) k \\<Longrightarrow>\n    ahm_\\<alpha>_aux bhc\n     (array_set a (bhc (array_length a) k)\n       (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n     k' =\n    (ahm_\\<alpha>_aux bhc a |` (- {k})) k'", "case False"], ["proof (state)\nthis:\n  bhc (array_length a) k' \\<noteq> bhc (array_length a) k\n\ngoal (2 subgoals):\n 1. bhc (array_length a) k' = bhc (array_length a) k \\<Longrightarrow>\n    ahm_\\<alpha>_aux bhc\n     (array_set a (bhc (array_length a) k)\n       (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n     k' =\n    (ahm_\\<alpha>_aux bhc a |` (- {k})) k'\n 2. bhc (array_length a) k' \\<noteq>\n    bhc (array_length a) k \\<Longrightarrow>\n    ahm_\\<alpha>_aux bhc\n     (array_set a (bhc (array_length a) k)\n       (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n     k' =\n    (ahm_\\<alpha>_aux bhc a |` (- {k})) k'", "hence \"k \\<noteq> k'\""], ["proof (prove)\nusing this:\n  bhc (array_length a) k' \\<noteq> bhc (array_length a) k\n\ngoal (1 subgoal):\n 1. k \\<noteq> k'", "by force"], ["proof (state)\nthis:\n  k \\<noteq> k'\n\ngoal (2 subgoals):\n 1. bhc (array_length a) k' = bhc (array_length a) k \\<Longrightarrow>\n    ahm_\\<alpha>_aux bhc\n     (array_set a (bhc (array_length a) k)\n       (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n     k' =\n    (ahm_\\<alpha>_aux bhc a |` (- {k})) k'\n 2. bhc (array_length a) k' \\<noteq>\n    bhc (array_length a) k \\<Longrightarrow>\n    ahm_\\<alpha>_aux bhc\n     (array_set a (bhc (array_length a) k)\n       (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n     k' =\n    (ahm_\\<alpha>_aux bhc a |` (- {k})) k'", "thus ?thesis"], ["proof (prove)\nusing this:\n  k \\<noteq> k'\n\ngoal (1 subgoal):\n 1. ahm_\\<alpha>_aux bhc\n     (array_set a (bhc (array_length a) k)\n       (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n     k' =\n    (ahm_\\<alpha>_aux bhc a |` (- {k})) k'", "using False"], ["proof (prove)\nusing this:\n  k \\<noteq> k'\n  bhc (array_length a) k' \\<noteq> bhc (array_length a) k\n\ngoal (1 subgoal):\n 1. ahm_\\<alpha>_aux bhc\n     (array_set a (bhc (array_length a) k)\n       (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n     k' =\n    (ahm_\\<alpha>_aux bhc a |` (- {k})) k'", "unfolding ahm_\\<alpha>_aux_def"], ["proof (prove)\nusing this:\n  k \\<noteq> k'\n  bhc (array_length a) k' \\<noteq> bhc (array_length a) k\n\ngoal (1 subgoal):\n 1. ahm_lookup_aux (=) bhc k'\n     (array_set a (bhc (array_length a) k)\n       (list_map_delete (=) k (array_get a (bhc (array_length a) k)))) =\n    ((\\<lambda>k. ahm_lookup_aux (=) bhc k a) |` (- {k})) k'", "by (simp add: array_get_array_set_other \n                          list_map_lookup_is_map_of)"], ["proof (state)\nthis:\n  ahm_\\<alpha>_aux bhc\n   (array_set a (bhc (array_length a) k)\n     (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n   k' =\n  (ahm_\\<alpha>_aux bhc a |` (- {k})) k'\n\ngoal (1 subgoal):\n 1. bhc (array_length a) k' = bhc (array_length a) k \\<Longrightarrow>\n    ahm_\\<alpha>_aux bhc\n     (array_set a (bhc (array_length a) k)\n       (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n     k' =\n    (ahm_\\<alpha>_aux bhc a |` (- {k})) k'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. bhc (array_length a) k' = bhc (array_length a) k \\<Longrightarrow>\n    ahm_\\<alpha>_aux bhc\n     (array_set a (bhc (array_length a) k)\n       (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n     k' =\n    (ahm_\\<alpha>_aux bhc a |` (- {k})) k'", "case True"], ["proof (state)\nthis:\n  bhc (array_length a) k' = bhc (array_length a) k\n\ngoal (1 subgoal):\n 1. bhc (array_length a) k' = bhc (array_length a) k \\<Longrightarrow>\n    ahm_\\<alpha>_aux bhc\n     (array_set a (bhc (array_length a) k)\n       (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n     k' =\n    (ahm_\\<alpha>_aux bhc a |` (- {k})) k'", "thus ?thesis"], ["proof (prove)\nusing this:\n  bhc (array_length a) k' = bhc (array_length a) k\n\ngoal (1 subgoal):\n 1. ahm_\\<alpha>_aux bhc\n     (array_set a (bhc (array_length a) k)\n       (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n     k' =\n    (ahm_\\<alpha>_aux bhc a |` (- {k})) k'", "unfolding ahm_\\<alpha>_aux_def"], ["proof (prove)\nusing this:\n  bhc (array_length a) k' = bhc (array_length a) k\n\ngoal (1 subgoal):\n 1. ahm_lookup_aux (=) bhc k'\n     (array_set a (bhc (array_length a) k)\n       (list_map_delete (=) k (array_get a (bhc (array_length a) k)))) =\n    ((\\<lambda>k. ahm_lookup_aux (=) bhc k a) |` (- {k})) k'", "by (simp add: list_map_lookup_is_map_of \n                       list_updated(1) restrict_map_def)"], ["proof (state)\nthis:\n  ahm_\\<alpha>_aux bhc\n   (array_set a (bhc (array_length a) k)\n     (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n   k' =\n  (ahm_\\<alpha>_aux bhc a |` (- {k})) k'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ahm_\\<alpha>_aux bhc\n   (array_set a (bhc (array_length a) k)\n     (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n   k' =\n  (ahm_\\<alpha>_aux bhc a |` (- {k})) k'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ahm_\\<alpha>_aux bhc\n   (array_set a (bhc (array_length a) k)\n     (list_map_delete (=) k (array_get a (bhc (array_length a) k)))) =\n  ahm_\\<alpha>_aux bhc a |` (- {k})\n\ngoal (1 subgoal):\n 1. \\<And>a' aa a'a.\n       (aa, a'a) \\<in> ahm_map_rel' bhc \\<Longrightarrow>\n       (ahm_delete (=) bhc a' aa, a'a |` (- {a'})) \\<in> ahm_map_rel' bhc", "hence \"ahm_\\<alpha> bhc (HashMap ?a' ?n') = op_map_delete k m\""], ["proof (prove)\nusing this:\n  ahm_\\<alpha>_aux bhc\n   (array_set a (bhc (array_length a) k)\n     (list_map_delete (=) k (array_get a (bhc (array_length a) k)))) =\n  ahm_\\<alpha>_aux bhc a |` (- {k})\n\ngoal (1 subgoal):\n 1. ahm_\\<alpha> bhc\n     (HashMap\n       (array_set a (bhc (array_length a) k)\n         (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n       (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) =\n           None\n        then n else n - 1)) =\n    op_map_delete k m", "unfolding op_map_delete_def"], ["proof (prove)\nusing this:\n  ahm_\\<alpha>_aux bhc\n   (array_set a (bhc (array_length a) k)\n     (list_map_delete (=) k (array_get a (bhc (array_length a) k)))) =\n  ahm_\\<alpha>_aux bhc a |` (- {k})\n\ngoal (1 subgoal):\n 1. ahm_\\<alpha> bhc\n     (HashMap\n       (array_set a (bhc (array_length a) k)\n         (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n       (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) =\n           None\n        then n else n - 1)) =\n    m |` (- {k})", "by (simp add: ahm_\\<alpha>_def2 \\<alpha>)"], ["proof (state)\nthis:\n  ahm_\\<alpha> bhc\n   (HashMap\n     (array_set a (bhc (array_length a) k)\n       (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n     (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) = None\n      then n else n - 1)) =\n  op_map_delete k m\n\ngoal (1 subgoal):\n 1. \\<And>a' aa a'a.\n       (aa, a'a) \\<in> ahm_map_rel' bhc \\<Longrightarrow>\n       (ahm_delete (=) bhc a' aa, a'a |` (- {a'})) \\<in> ahm_map_rel' bhc", "ultimately"], ["proof (chain)\npicking this:\n  ahm_invar bhc\n   (HashMap\n     (array_set a (bhc (array_length a) k)\n       (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n     (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) = None\n      then n else n - 1))\n  ahm_\\<alpha> bhc\n   (HashMap\n     (array_set a (bhc (array_length a) k)\n       (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n     (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) = None\n      then n else n - 1)) =\n  op_map_delete k m", "have \"(HashMap ?a' ?n', op_map_delete k m) \\<in> ahm_map_rel' bhc\""], ["proof (prove)\nusing this:\n  ahm_invar bhc\n   (HashMap\n     (array_set a (bhc (array_length a) k)\n       (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n     (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) = None\n      then n else n - 1))\n  ahm_\\<alpha> bhc\n   (HashMap\n     (array_set a (bhc (array_length a) k)\n       (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n     (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) = None\n      then n else n - 1)) =\n  op_map_delete k m\n\ngoal (1 subgoal):\n 1. (HashMap\n      (array_set a (bhc (array_length a) k)\n        (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n      (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) =\n          None\n       then n else n - 1),\n     op_map_delete k m)\n    \\<in> ahm_map_rel' bhc", "unfolding ahm_map_rel'_def br_def"], ["proof (prove)\nusing this:\n  ahm_invar bhc\n   (HashMap\n     (array_set a (bhc (array_length a) k)\n       (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n     (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) = None\n      then n else n - 1))\n  ahm_\\<alpha> bhc\n   (HashMap\n     (array_set a (bhc (array_length a) k)\n       (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n     (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) = None\n      then n else n - 1)) =\n  op_map_delete k m\n\ngoal (1 subgoal):\n 1. (HashMap\n      (array_set a (bhc (array_length a) k)\n        (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n      (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) =\n          None\n       then n else n - 1),\n     op_map_delete k m)\n    \\<in> {(c, a). a = ahm_\\<alpha> bhc c \\<and> ahm_invar bhc c}", "by simp"], ["proof (state)\nthis:\n  (HashMap\n    (array_set a (bhc (array_length a) k)\n      (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n    (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) = None\n     then n else n - 1),\n   op_map_delete k m)\n  \\<in> ahm_map_rel' bhc\n\ngoal (1 subgoal):\n 1. \\<And>a' aa a'a.\n       (aa, a'a) \\<in> ahm_map_rel' bhc \\<Longrightarrow>\n       (ahm_delete (=) bhc a' aa, a'a |` (- {a'})) \\<in> ahm_map_rel' bhc", "thus \"(ahm_delete (=) bhc k hm, m |` (-{k})) \\<in> ahm_map_rel' bhc\""], ["proof (prove)\nusing this:\n  (HashMap\n    (array_set a (bhc (array_length a) k)\n      (list_map_delete (=) k (array_get a (bhc (array_length a) k))))\n    (if list_map_lookup (=) k (array_get a (bhc (array_length a) k)) = None\n     then n else n - 1),\n   op_map_delete k m)\n  \\<in> ahm_map_rel' bhc\n\ngoal (1 subgoal):\n 1. (ahm_delete (=) bhc k hm, m |` (- {k})) \\<in> ahm_map_rel' bhc", "by (simp only: \\<open>hm = HashMap a n\\<close> ahm_delete.simps Let_def \n                 op_map_delete_def, force)"], ["proof (state)\nthis:\n  (ahm_delete (=) bhc k hm, m |` (- {k})) \\<in> ahm_map_rel' bhc\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma autoref_ahm_delete[autoref_rules]:\n  assumes bhc[unfolded autoref_tag_defs]: \n    \"SIDE_GEN_ALGO (is_bounded_hashcode Rk eq bhc)\"\n  shows \"(ahm_delete eq bhc, op_map_delete) \\<in> \n              Rk \\<rightarrow> \\<langle>Rk,Rv\\<rangle>ahm_rel bhc \\<rightarrow> \\<langle>Rk,Rv\\<rangle>ahm_rel bhc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ahm_delete eq bhc, op_map_delete)\n    \\<in> Rk \\<rightarrow>\n          \\<langle>Rk, Rv\\<rangle>ahm_rel bhc \\<rightarrow> \\<langle>Rk,\n          Rv\\<rangle>ahm_rel bhc", "proof (intro fun_relI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Rk;\n        (aa, a'a) \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc\\<rbrakk>\n       \\<Longrightarrow> (ahm_delete eq bhc a aa, op_map_delete a' a'a)\n                         \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc", "let ?bhc' = \"abstract_bounded_hashcode Rk bhc\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Rk;\n        (aa, a'a) \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc\\<rbrakk>\n       \\<Longrightarrow> (ahm_delete eq bhc a aa, op_map_delete a' a'a)\n                         \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc", "fix k k' a m'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Rk;\n        (aa, a'a) \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc\\<rbrakk>\n       \\<Longrightarrow> (ahm_delete eq bhc a aa, op_map_delete a' a'a)\n                         \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc", "assume K: \"(k,k') \\<in> Rk\""], ["proof (state)\nthis:\n  (k, k') \\<in> Rk\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Rk;\n        (aa, a'a) \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc\\<rbrakk>\n       \\<Longrightarrow> (ahm_delete eq bhc a aa, op_map_delete a' a'a)\n                         \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc", "assume M: \"(a,m') \\<in> \\<langle>Rk,Rv\\<rangle>ahm_rel bhc\""], ["proof (state)\nthis:\n  (a, m') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Rk;\n        (aa, a'a) \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc\\<rbrakk>\n       \\<Longrightarrow> (ahm_delete eq bhc a aa, op_map_delete a' a'a)\n                         \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc", "(*from bhc have eq': \"(eq,(=)) \\<in> Rk \\<rightarrow> Rk \\<rightarrow> bool_rel\" by (simp add: is_bounded_hashcodeD)*)"], ["proof (state)\nthis:\n  (a, m') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Rk;\n        (aa, a'a) \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc\\<rbrakk>\n       \\<Longrightarrow> (ahm_delete eq bhc a aa, op_map_delete a' a'a)\n                         \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc", "with bhc"], ["proof (chain)\npicking this:\n  is_bounded_hashcode Rk eq bhc\n  (a, m') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc", "have bhc': \"is_bounded_hashcode Id (=) ?bhc'\""], ["proof (prove)\nusing this:\n  is_bounded_hashcode Rk eq bhc\n  (a, m') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc\n\ngoal (1 subgoal):\n 1. is_bounded_hashcode Id (=) (abstract_bounded_hashcode Rk bhc)", "by blast"], ["proof (state)\nthis:\n  is_bounded_hashcode Id (=) (abstract_bounded_hashcode Rk bhc)\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Rk;\n        (aa, a'a) \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc\\<rbrakk>\n       \\<Longrightarrow> (ahm_delete eq bhc a aa, op_map_delete a' a'a)\n                         \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc", "from abstract_bhc_correct[OF bhc]"], ["proof (chain)\npicking this:\n  (bhc, abstract_bounded_hashcode Rk bhc)\n  \\<in> nat_rel \\<rightarrow> Rk \\<rightarrow> nat_rel", "have bhc_rel: \"(bhc,?bhc') \\<in> nat_rel \\<rightarrow> Rk \\<rightarrow> nat_rel\""], ["proof (prove)\nusing this:\n  (bhc, abstract_bounded_hashcode Rk bhc)\n  \\<in> nat_rel \\<rightarrow> Rk \\<rightarrow> nat_rel\n\ngoal (1 subgoal):\n 1. (bhc, abstract_bounded_hashcode Rk bhc)\n    \\<in> nat_rel \\<rightarrow> Rk \\<rightarrow> nat_rel", "."], ["proof (state)\nthis:\n  (bhc, abstract_bounded_hashcode Rk bhc)\n  \\<in> nat_rel \\<rightarrow> Rk \\<rightarrow> nat_rel\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Rk;\n        (aa, a'a) \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc\\<rbrakk>\n       \\<Longrightarrow> (ahm_delete eq bhc a aa, op_map_delete a' a'a)\n                         \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc", "from M"], ["proof (chain)\npicking this:\n  (a, m') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc", "obtain a' where M1: \"(a,a') \\<in> \\<langle>Rk,Rv\\<rangle>ahm_map_rel\" and\n      M2: \"(a',m') \\<in> ahm_map_rel' ?bhc'\""], ["proof (prove)\nusing this:\n  (a, m') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>(a, a') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel;\n         (a', m')\n         \\<in> ahm_map_rel' (abstract_bounded_hashcode Rk bhc)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding ahm_rel_def"], ["proof (prove)\nusing this:\n  (a, m')\n  \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel O\n        ahm_map_rel' (abstract_bounded_hashcode Rk bhc)\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>(a, a') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel;\n         (a', m')\n         \\<in> ahm_map_rel' (abstract_bounded_hashcode Rk bhc)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (a, a') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel\n  (a', m') \\<in> ahm_map_rel' (abstract_bounded_hashcode Rk bhc)\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Rk;\n        (aa, a'a) \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc\\<rbrakk>\n       \\<Longrightarrow> (ahm_delete eq bhc a aa, op_map_delete a' a'a)\n                         \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc", "hence inv: \"ahm_invar ?bhc' a'\""], ["proof (prove)\nusing this:\n  (a, a') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel\n  (a', m') \\<in> ahm_map_rel' (abstract_bounded_hashcode Rk bhc)\n\ngoal (1 subgoal):\n 1. ahm_invar (abstract_bounded_hashcode Rk bhc) a'", "unfolding ahm_map_rel'_def br_def"], ["proof (prove)\nusing this:\n  (a, a') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel\n  (a', m')\n  \\<in> {(c, a).\n         a = ahm_\\<alpha> (abstract_bounded_hashcode Rk bhc) c \\<and>\n         ahm_invar (abstract_bounded_hashcode Rk bhc) c}\n\ngoal (1 subgoal):\n 1. ahm_invar (abstract_bounded_hashcode Rk bhc) a'", "by simp"], ["proof (state)\nthis:\n  ahm_invar (abstract_bounded_hashcode Rk bhc) a'\n\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Rk;\n        (aa, a'a) \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc\\<rbrakk>\n       \\<Longrightarrow> (ahm_delete eq bhc a aa, op_map_delete a' a'a)\n                         \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc", "from relcompI[OF param_ahm_delete[OF bhc bhc_rel inv K M1]\n                   ahm_delete_impl[param_fo, OF bhc' _ M2]]"], ["proof (chain)\npicking this:\n  (k', ?x'2) \\<in> Id \\<Longrightarrow>\n  (ahm_delete eq bhc k a, op_map_delete ?x'2 m')\n  \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel O\n        ahm_map_rel' (abstract_bounded_hashcode Rk bhc)", "show \"(ahm_delete eq bhc k a, op_map_delete k' m') \\<in> \n            \\<langle>Rk,Rv\\<rangle>ahm_rel bhc\""], ["proof (prove)\nusing this:\n  (k', ?x'2) \\<in> Id \\<Longrightarrow>\n  (ahm_delete eq bhc k a, op_map_delete ?x'2 m')\n  \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel O\n        ahm_map_rel' (abstract_bounded_hashcode Rk bhc)\n\ngoal (1 subgoal):\n 1. (ahm_delete eq bhc k a, op_map_delete k' m') \\<in> \\<langle>Rk,\n    Rv\\<rangle>ahm_rel bhc", "unfolding ahm_rel_def"], ["proof (prove)\nusing this:\n  (k', ?x'2) \\<in> Id \\<Longrightarrow>\n  (ahm_delete eq bhc k a, op_map_delete ?x'2 m')\n  \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel O\n        ahm_map_rel' (abstract_bounded_hashcode Rk bhc)\n\ngoal (1 subgoal):\n 1. (ahm_delete eq bhc k a, op_map_delete k' m')\n    \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel O\n          ahm_map_rel' (abstract_bounded_hashcode Rk bhc)", "by simp"], ["proof (state)\nthis:\n  (ahm_delete eq bhc k a, op_map_delete k' m') \\<in> \\<langle>Rk,\n  Rv\\<rangle>ahm_rel bhc\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Various simple operations\\<close>"], ["", "lemma param_ahm_isEmpty[param]: \n    \"(ahm_isEmpty, ahm_isEmpty) \\<in> \\<langle>Rk,Rv\\<rangle>ahm_map_rel \\<rightarrow> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ahm_isEmpty, ahm_isEmpty)\n    \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel \\<rightarrow> bool_rel", "unfolding ahm_isEmpty_def[abs_def] rec_hashmap_is_case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>uu. case uu of HashMap uu_ n \\<Rightarrow> n = 0,\n     \\<lambda>uu. case uu of HashMap uu_ n \\<Rightarrow> n = 0)\n    \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel \\<rightarrow> bool_rel", "by parametricity"], ["", "lemma param_ahm_isSng[param]: \n    \"(ahm_isSng, ahm_isSng) \\<in> \\<langle>Rk,Rv\\<rangle>ahm_map_rel \\<rightarrow> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ahm_isSng, ahm_isSng)\n    \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel \\<rightarrow> bool_rel", "unfolding ahm_isSng_def[abs_def] rec_hashmap_is_case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>uu. case uu of HashMap uu_ n \\<Rightarrow> n = 1,\n     \\<lambda>uu. case uu of HashMap uu_ n \\<Rightarrow> n = 1)\n    \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel \\<rightarrow> bool_rel", "by parametricity"], ["", "lemma param_ahm_size[param]: \n    \"(ahm_size, ahm_size) \\<in> \\<langle>Rk,Rv\\<rangle>ahm_map_rel \\<rightarrow> nat_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ahm_size, ahm_size)\n    \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel \\<rightarrow> nat_rel", "unfolding ahm_size_def[abs_def] rec_hashmap_is_case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>uu. case uu of HashMap uu_ n \\<Rightarrow> n,\n     \\<lambda>uu. case uu of HashMap uu_ n \\<Rightarrow> n)\n    \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel \\<rightarrow> nat_rel", "by parametricity"], ["", "lemma ahm_isEmpty_impl:\n  assumes \"is_bounded_hashcode Id (=) bhc\"\n  shows \"(ahm_isEmpty, op_map_isEmpty) \\<in> ahm_map_rel' bhc \\<rightarrow> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ahm_isEmpty, op_map_isEmpty)\n    \\<in> ahm_map_rel' bhc \\<rightarrow> bool_rel", "proof (intro fun_relI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> ahm_map_rel' bhc \\<Longrightarrow>\n       (ahm_isEmpty a, op_map_isEmpty a') \\<in> bool_rel", "fix hm m"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> ahm_map_rel' bhc \\<Longrightarrow>\n       (ahm_isEmpty a, op_map_isEmpty a') \\<in> bool_rel", "assume rel: \"(hm,m) \\<in> ahm_map_rel' bhc\""], ["proof (state)\nthis:\n  (hm, m) \\<in> ahm_map_rel' bhc\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> ahm_map_rel' bhc \\<Longrightarrow>\n       (ahm_isEmpty a, op_map_isEmpty a') \\<in> bool_rel", "obtain a n where [simp]: \"hm = HashMap a n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a n. hm = HashMap a n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases hm)"], ["proof (state)\nthis:\n  hm = HashMap a n\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> ahm_map_rel' bhc \\<Longrightarrow>\n       (ahm_isEmpty a, op_map_isEmpty a') \\<in> bool_rel", "from rel"], ["proof (chain)\npicking this:\n  (hm, m) \\<in> ahm_map_rel' bhc", "have \\<alpha>: \"m = ahm_\\<alpha>_aux bhc a\" and inv: \"ahm_invar_aux bhc n a\""], ["proof (prove)\nusing this:\n  (hm, m) \\<in> ahm_map_rel' bhc\n\ngoal (1 subgoal):\n 1. m = ahm_\\<alpha>_aux bhc a &&& ahm_invar_aux bhc n a", "unfolding ahm_map_rel'_def br_def"], ["proof (prove)\nusing this:\n  (hm, m) \\<in> {(c, a). a = ahm_\\<alpha> bhc c \\<and> ahm_invar bhc c}\n\ngoal (1 subgoal):\n 1. m = ahm_\\<alpha>_aux bhc a &&& ahm_invar_aux bhc n a", "by (simp_all add: ahm_\\<alpha>_def2)"], ["proof (state)\nthis:\n  m = ahm_\\<alpha>_aux bhc a\n  ahm_invar_aux bhc n a\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> ahm_map_rel' bhc \\<Longrightarrow>\n       (ahm_isEmpty a, op_map_isEmpty a') \\<in> bool_rel", "from ahm_invar_aux_card_dom_ahm_\\<alpha>_auxD[OF assms inv,symmetric] and\n       finite_dom_ahm_\\<alpha>_aux[OF assms inv]"], ["proof (chain)\npicking this:\n  n = card (dom (ahm_\\<alpha>_aux bhc a))\n  finite (dom (ahm_\\<alpha>_aux bhc a))", "show \"(ahm_isEmpty hm, op_map_isEmpty m) \\<in> bool_rel\""], ["proof (prove)\nusing this:\n  n = card (dom (ahm_\\<alpha>_aux bhc a))\n  finite (dom (ahm_\\<alpha>_aux bhc a))\n\ngoal (1 subgoal):\n 1. (ahm_isEmpty hm, op_map_isEmpty m) \\<in> bool_rel", "unfolding ahm_isEmpty_def op_map_isEmpty_def"], ["proof (prove)\nusing this:\n  n = card (dom (ahm_\\<alpha>_aux bhc a))\n  finite (dom (ahm_\\<alpha>_aux bhc a))\n\ngoal (1 subgoal):\n 1. (rec_hashmap (\\<lambda>_ n. n = 0) hm, m = Map.empty) \\<in> bool_rel", "by (simp add: \\<alpha> card_eq_0_iff)"], ["proof (state)\nthis:\n  (ahm_isEmpty hm, op_map_isEmpty m) \\<in> bool_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ahm_isSng_impl:\n  assumes \"is_bounded_hashcode Id (=) bhc\"\n  shows \"(ahm_isSng, op_map_isSng) \\<in> ahm_map_rel' bhc \\<rightarrow> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ahm_isSng, op_map_isSng) \\<in> ahm_map_rel' bhc \\<rightarrow> bool_rel", "proof (intro fun_relI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> ahm_map_rel' bhc \\<Longrightarrow>\n       (ahm_isSng a, op_map_isSng a') \\<in> bool_rel", "fix hm m"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> ahm_map_rel' bhc \\<Longrightarrow>\n       (ahm_isSng a, op_map_isSng a') \\<in> bool_rel", "assume rel: \"(hm,m) \\<in> ahm_map_rel' bhc\""], ["proof (state)\nthis:\n  (hm, m) \\<in> ahm_map_rel' bhc\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> ahm_map_rel' bhc \\<Longrightarrow>\n       (ahm_isSng a, op_map_isSng a') \\<in> bool_rel", "obtain a n where [simp]: \"hm = HashMap a n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a n. hm = HashMap a n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases hm)"], ["proof (state)\nthis:\n  hm = HashMap a n\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> ahm_map_rel' bhc \\<Longrightarrow>\n       (ahm_isSng a, op_map_isSng a') \\<in> bool_rel", "from rel"], ["proof (chain)\npicking this:\n  (hm, m) \\<in> ahm_map_rel' bhc", "have \\<alpha>: \"m = ahm_\\<alpha>_aux bhc a\" and inv: \"ahm_invar_aux bhc n a\""], ["proof (prove)\nusing this:\n  (hm, m) \\<in> ahm_map_rel' bhc\n\ngoal (1 subgoal):\n 1. m = ahm_\\<alpha>_aux bhc a &&& ahm_invar_aux bhc n a", "unfolding ahm_map_rel'_def br_def"], ["proof (prove)\nusing this:\n  (hm, m) \\<in> {(c, a). a = ahm_\\<alpha> bhc c \\<and> ahm_invar bhc c}\n\ngoal (1 subgoal):\n 1. m = ahm_\\<alpha>_aux bhc a &&& ahm_invar_aux bhc n a", "by (simp_all add: ahm_\\<alpha>_def2)"], ["proof (state)\nthis:\n  m = ahm_\\<alpha>_aux bhc a\n  ahm_invar_aux bhc n a\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> ahm_map_rel' bhc \\<Longrightarrow>\n       (ahm_isSng a, op_map_isSng a') \\<in> bool_rel", "note n_props[simp] = ahm_invar_aux_card_dom_ahm_\\<alpha>_auxD[OF assms inv,symmetric]"], ["proof (state)\nthis:\n  n = card (dom (ahm_\\<alpha>_aux bhc a))\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> ahm_map_rel' bhc \\<Longrightarrow>\n       (ahm_isSng a, op_map_isSng a') \\<in> bool_rel", "note finite_dom[simp] =  finite_dom_ahm_\\<alpha>_aux[OF assms inv]"], ["proof (state)\nthis:\n  finite (dom (ahm_\\<alpha>_aux bhc a))\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> ahm_map_rel' bhc \\<Longrightarrow>\n       (ahm_isSng a, op_map_isSng a') \\<in> bool_rel", "show \"(ahm_isSng hm, op_map_isSng m) \\<in> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ahm_isSng hm, op_map_isSng m) \\<in> bool_rel", "by (force simp add: \\<alpha>[symmetric] dom_eq_singleton_conv \n                dest!: card_eq_SucD)"], ["proof (state)\nthis:\n  (ahm_isSng hm, op_map_isSng m) \\<in> bool_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ahm_size_impl:\n  assumes \"is_bounded_hashcode Id (=) bhc\"\n  shows \"(ahm_size, op_map_size) \\<in> ahm_map_rel' bhc \\<rightarrow> nat_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ahm_size, op_map_size) \\<in> ahm_map_rel' bhc \\<rightarrow> nat_rel", "proof (intro fun_relI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> ahm_map_rel' bhc \\<Longrightarrow>\n       (ahm_size a, op_map_size a') \\<in> nat_rel", "fix hm m"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> ahm_map_rel' bhc \\<Longrightarrow>\n       (ahm_size a, op_map_size a') \\<in> nat_rel", "assume rel: \"(hm,m) \\<in> ahm_map_rel' bhc\""], ["proof (state)\nthis:\n  (hm, m) \\<in> ahm_map_rel' bhc\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> ahm_map_rel' bhc \\<Longrightarrow>\n       (ahm_size a, op_map_size a') \\<in> nat_rel", "obtain a n where [simp]: \"hm = HashMap a n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a n. hm = HashMap a n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases hm)"], ["proof (state)\nthis:\n  hm = HashMap a n\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> ahm_map_rel' bhc \\<Longrightarrow>\n       (ahm_size a, op_map_size a') \\<in> nat_rel", "from rel"], ["proof (chain)\npicking this:\n  (hm, m) \\<in> ahm_map_rel' bhc", "have \\<alpha>: \"m = ahm_\\<alpha>_aux bhc a\" and inv: \"ahm_invar_aux bhc n a\""], ["proof (prove)\nusing this:\n  (hm, m) \\<in> ahm_map_rel' bhc\n\ngoal (1 subgoal):\n 1. m = ahm_\\<alpha>_aux bhc a &&& ahm_invar_aux bhc n a", "unfolding ahm_map_rel'_def br_def"], ["proof (prove)\nusing this:\n  (hm, m) \\<in> {(c, a). a = ahm_\\<alpha> bhc c \\<and> ahm_invar bhc c}\n\ngoal (1 subgoal):\n 1. m = ahm_\\<alpha>_aux bhc a &&& ahm_invar_aux bhc n a", "by (simp_all add: ahm_\\<alpha>_def2)"], ["proof (state)\nthis:\n  m = ahm_\\<alpha>_aux bhc a\n  ahm_invar_aux bhc n a\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> ahm_map_rel' bhc \\<Longrightarrow>\n       (ahm_size a, op_map_size a') \\<in> nat_rel", "from ahm_invar_aux_card_dom_ahm_\\<alpha>_auxD[OF assms inv,symmetric]"], ["proof (chain)\npicking this:\n  n = card (dom (ahm_\\<alpha>_aux bhc a))", "show \"(ahm_size hm, op_map_size m) \\<in> nat_rel\""], ["proof (prove)\nusing this:\n  n = card (dom (ahm_\\<alpha>_aux bhc a))\n\ngoal (1 subgoal):\n 1. (ahm_size hm, op_map_size m) \\<in> nat_rel", "unfolding ahm_isEmpty_def op_map_isEmpty_def"], ["proof (prove)\nusing this:\n  n = card (dom (ahm_\\<alpha>_aux bhc a))\n\ngoal (1 subgoal):\n 1. (ahm_size hm, op_map_size m) \\<in> nat_rel", "by (simp add: \\<alpha> card_eq_0_iff)"], ["proof (state)\nthis:\n  (ahm_size hm, op_map_size m) \\<in> nat_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma autoref_ahm_isEmpty[autoref_rules]:\n  (*assumes eq: \"GEN_OP eq (=) (Rk \\<rightarrow> Rk \\<rightarrow> bool_rel)\"*)\n  assumes bhc[unfolded autoref_tag_defs]: \n      \"SIDE_GEN_ALGO (is_bounded_hashcode Rk eq bhc)\"\n  shows \"(ahm_isEmpty, op_map_isEmpty) \\<in> \\<langle>Rk,Rv\\<rangle>ahm_rel bhc \\<rightarrow> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ahm_isEmpty, op_map_isEmpty)\n    \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc \\<rightarrow> bool_rel", "proof (intro fun_relI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc \\<Longrightarrow>\n       (ahm_isEmpty a, op_map_isEmpty a') \\<in> bool_rel", "let ?bhc' = \"abstract_bounded_hashcode Rk bhc\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc \\<Longrightarrow>\n       (ahm_isEmpty a, op_map_isEmpty a') \\<in> bool_rel", "fix k k' a m'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc \\<Longrightarrow>\n       (ahm_isEmpty a, op_map_isEmpty a') \\<in> bool_rel", "assume M: \"(a,m') \\<in> \\<langle>Rk,Rv\\<rangle>ahm_rel bhc\""], ["proof (state)\nthis:\n  (a, m') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc \\<Longrightarrow>\n       (ahm_isEmpty a, op_map_isEmpty a') \\<in> bool_rel", "(*from eq have \"(eq,(=)) \\<in> Rk \\<rightarrow> Rk \\<rightarrow> bool_rel\" by simp*)"], ["proof (state)\nthis:\n  (a, m') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc \\<Longrightarrow>\n       (ahm_isEmpty a, op_map_isEmpty a') \\<in> bool_rel", "from bhc"], ["proof (chain)\npicking this:\n  is_bounded_hashcode Rk eq bhc", "have bhc': \"is_bounded_hashcode Id (=) ?bhc'\""], ["proof (prove)\nusing this:\n  is_bounded_hashcode Rk eq bhc\n\ngoal (1 subgoal):\n 1. is_bounded_hashcode Id (=) (abstract_bounded_hashcode Rk bhc)", "by blast"], ["proof (state)\nthis:\n  is_bounded_hashcode Id (=) (abstract_bounded_hashcode Rk bhc)\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc \\<Longrightarrow>\n       (ahm_isEmpty a, op_map_isEmpty a') \\<in> bool_rel", "from M"], ["proof (chain)\npicking this:\n  (a, m') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc", "obtain a' where M1: \"(a,a') \\<in> \\<langle>Rk,Rv\\<rangle>ahm_map_rel\" and\n      M2: \"(a',m') \\<in> ahm_map_rel' ?bhc'\""], ["proof (prove)\nusing this:\n  (a, m') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>(a, a') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel;\n         (a', m')\n         \\<in> ahm_map_rel' (abstract_bounded_hashcode Rk bhc)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding ahm_rel_def"], ["proof (prove)\nusing this:\n  (a, m')\n  \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel O\n        ahm_map_rel' (abstract_bounded_hashcode Rk bhc)\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>(a, a') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel;\n         (a', m')\n         \\<in> ahm_map_rel' (abstract_bounded_hashcode Rk bhc)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (a, a') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel\n  (a', m') \\<in> ahm_map_rel' (abstract_bounded_hashcode Rk bhc)\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc \\<Longrightarrow>\n       (ahm_isEmpty a, op_map_isEmpty a') \\<in> bool_rel", "from relcompI[OF param_ahm_isEmpty[param_fo, OF M1]\n                   ahm_isEmpty_impl[param_fo, OF bhc' M2]]"], ["proof (chain)\npicking this:\n  (ahm_isEmpty a, op_map_isEmpty m') \\<in> bool_rel O bool_rel", "show \"(ahm_isEmpty a, op_map_isEmpty m') \\<in> bool_rel\""], ["proof (prove)\nusing this:\n  (ahm_isEmpty a, op_map_isEmpty m') \\<in> bool_rel O bool_rel\n\ngoal (1 subgoal):\n 1. (ahm_isEmpty a, op_map_isEmpty m') \\<in> bool_rel", "by simp"], ["proof (state)\nthis:\n  (ahm_isEmpty a, op_map_isEmpty m') \\<in> bool_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma autoref_ahm_isSng[autoref_rules]:\n  assumes bhc[unfolded autoref_tag_defs]: \n      \"SIDE_GEN_ALGO (is_bounded_hashcode Rk eq bhc)\"\n  shows \"(ahm_isSng, op_map_isSng) \\<in> \\<langle>Rk,Rv\\<rangle>ahm_rel bhc \\<rightarrow> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ahm_isSng, op_map_isSng)\n    \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc \\<rightarrow> bool_rel", "proof (intro fun_relI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc \\<Longrightarrow>\n       (ahm_isSng a, op_map_isSng a') \\<in> bool_rel", "let ?bhc' = \"abstract_bounded_hashcode Rk bhc\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc \\<Longrightarrow>\n       (ahm_isSng a, op_map_isSng a') \\<in> bool_rel", "fix k k' a m'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc \\<Longrightarrow>\n       (ahm_isSng a, op_map_isSng a') \\<in> bool_rel", "assume M: \"(a,m') \\<in> \\<langle>Rk,Rv\\<rangle>ahm_rel bhc\""], ["proof (state)\nthis:\n  (a, m') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc \\<Longrightarrow>\n       (ahm_isSng a, op_map_isSng a') \\<in> bool_rel", "from bhc"], ["proof (chain)\npicking this:\n  is_bounded_hashcode Rk eq bhc", "have bhc': \"is_bounded_hashcode Id (=) ?bhc'\""], ["proof (prove)\nusing this:\n  is_bounded_hashcode Rk eq bhc\n\ngoal (1 subgoal):\n 1. is_bounded_hashcode Id (=) (abstract_bounded_hashcode Rk bhc)", "by blast"], ["proof (state)\nthis:\n  is_bounded_hashcode Id (=) (abstract_bounded_hashcode Rk bhc)\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc \\<Longrightarrow>\n       (ahm_isSng a, op_map_isSng a') \\<in> bool_rel", "from M"], ["proof (chain)\npicking this:\n  (a, m') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc", "obtain a' where M1: \"(a,a') \\<in> \\<langle>Rk,Rv\\<rangle>ahm_map_rel\" and\n      M2: \"(a',m') \\<in> ahm_map_rel' ?bhc'\""], ["proof (prove)\nusing this:\n  (a, m') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>(a, a') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel;\n         (a', m')\n         \\<in> ahm_map_rel' (abstract_bounded_hashcode Rk bhc)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding ahm_rel_def"], ["proof (prove)\nusing this:\n  (a, m')\n  \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel O\n        ahm_map_rel' (abstract_bounded_hashcode Rk bhc)\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>(a, a') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel;\n         (a', m')\n         \\<in> ahm_map_rel' (abstract_bounded_hashcode Rk bhc)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (a, a') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel\n  (a', m') \\<in> ahm_map_rel' (abstract_bounded_hashcode Rk bhc)\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc \\<Longrightarrow>\n       (ahm_isSng a, op_map_isSng a') \\<in> bool_rel", "from relcompI[OF param_ahm_isSng[param_fo, OF M1]\n                   ahm_isSng_impl[param_fo, OF bhc' M2]]"], ["proof (chain)\npicking this:\n  (ahm_isSng a, op_map_isSng m') \\<in> bool_rel O bool_rel", "show \"(ahm_isSng a, op_map_isSng m') \\<in> bool_rel\""], ["proof (prove)\nusing this:\n  (ahm_isSng a, op_map_isSng m') \\<in> bool_rel O bool_rel\n\ngoal (1 subgoal):\n 1. (ahm_isSng a, op_map_isSng m') \\<in> bool_rel", "by simp"], ["proof (state)\nthis:\n  (ahm_isSng a, op_map_isSng m') \\<in> bool_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma autoref_ahm_size[autoref_rules]:\n  assumes bhc[unfolded autoref_tag_defs]: \n      \"SIDE_GEN_ALGO (is_bounded_hashcode Rk eq bhc)\"\n  shows \"(ahm_size, op_map_size) \\<in> \\<langle>Rk,Rv\\<rangle>ahm_rel bhc \\<rightarrow> nat_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ahm_size, op_map_size)\n    \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc \\<rightarrow> nat_rel", "proof (intro fun_relI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc \\<Longrightarrow>\n       (ahm_size a, op_map_size a') \\<in> nat_rel", "let ?bhc' = \"abstract_bounded_hashcode Rk bhc\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc \\<Longrightarrow>\n       (ahm_size a, op_map_size a') \\<in> nat_rel", "fix k k' a m'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc \\<Longrightarrow>\n       (ahm_size a, op_map_size a') \\<in> nat_rel", "assume M: \"(a,m') \\<in> \\<langle>Rk,Rv\\<rangle>ahm_rel bhc\""], ["proof (state)\nthis:\n  (a, m') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc \\<Longrightarrow>\n       (ahm_size a, op_map_size a') \\<in> nat_rel", "from bhc"], ["proof (chain)\npicking this:\n  is_bounded_hashcode Rk eq bhc", "have bhc': \"is_bounded_hashcode Id (=) ?bhc'\""], ["proof (prove)\nusing this:\n  is_bounded_hashcode Rk eq bhc\n\ngoal (1 subgoal):\n 1. is_bounded_hashcode Id (=) (abstract_bounded_hashcode Rk bhc)", "by blast"], ["proof (state)\nthis:\n  is_bounded_hashcode Id (=) (abstract_bounded_hashcode Rk bhc)\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc \\<Longrightarrow>\n       (ahm_size a, op_map_size a') \\<in> nat_rel", "from M"], ["proof (chain)\npicking this:\n  (a, m') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc", "obtain a' where M1: \"(a,a') \\<in> \\<langle>Rk,Rv\\<rangle>ahm_map_rel\" and\n      M2: \"(a',m') \\<in> ahm_map_rel' ?bhc'\""], ["proof (prove)\nusing this:\n  (a, m') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>(a, a') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel;\n         (a', m')\n         \\<in> ahm_map_rel' (abstract_bounded_hashcode Rk bhc)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding ahm_rel_def"], ["proof (prove)\nusing this:\n  (a, m')\n  \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel O\n        ahm_map_rel' (abstract_bounded_hashcode Rk bhc)\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>(a, a') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel;\n         (a', m')\n         \\<in> ahm_map_rel' (abstract_bounded_hashcode Rk bhc)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (a, a') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel\n  (a', m') \\<in> ahm_map_rel' (abstract_bounded_hashcode Rk bhc)\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk, Rv\\<rangle>ahm_rel bhc \\<Longrightarrow>\n       (ahm_size a, op_map_size a') \\<in> nat_rel", "from relcompI[OF param_ahm_size[param_fo, OF M1]\n                   ahm_size_impl[param_fo, OF bhc' M2]]"], ["proof (chain)\npicking this:\n  (ahm_size a, op_map_size m') \\<in> nat_rel O nat_rel", "show \"(ahm_size a, op_map_size m') \\<in> nat_rel\""], ["proof (prove)\nusing this:\n  (ahm_size a, op_map_size m') \\<in> nat_rel O nat_rel\n\ngoal (1 subgoal):\n 1. (ahm_size a, op_map_size m') \\<in> nat_rel", "by simp"], ["proof (state)\nthis:\n  (ahm_size a, op_map_size m') \\<in> nat_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ahm_map_rel_sv[relator_props]:\n  assumes SK: \"single_valued Rk\" \n  assumes SV: \"single_valued Rv\"\n  shows \"single_valued (\\<langle>Rk, Rv\\<rangle>ahm_map_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued (\\<langle>Rk, Rv\\<rangle>ahm_map_rel)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. single_valued (\\<langle>Rk, Rv\\<rangle>ahm_map_rel)", "from SK SV"], ["proof (chain)\npicking this:\n  single_valued Rk\n  single_valued Rv", "have 1: \"single_valued (\\<langle>\\<langle>\\<langle>Rk, Rv\\<rangle>prod_rel\\<rangle>list_rel\\<rangle>array_rel)\""], ["proof (prove)\nusing this:\n  single_valued Rk\n  single_valued Rv\n\ngoal (1 subgoal):\n 1. single_valued\n     (\\<langle>\\<langle>Rk \\<times>\\<^sub>r\n                        Rv\\<rangle>list_rel\\<rangle>array_rel)", "by (tagged_solver)"], ["proof (state)\nthis:\n  single_valued\n   (\\<langle>\\<langle>Rk \\<times>\\<^sub>r\n                      Rv\\<rangle>list_rel\\<rangle>array_rel)\n\ngoal (1 subgoal):\n 1. single_valued (\\<langle>Rk, Rv\\<rangle>ahm_map_rel)", "thus ?thesis"], ["proof (prove)\nusing this:\n  single_valued\n   (\\<langle>\\<langle>Rk \\<times>\\<^sub>r\n                      Rv\\<rangle>list_rel\\<rangle>array_rel)\n\ngoal (1 subgoal):\n 1. single_valued (\\<langle>Rk, Rv\\<rangle>ahm_map_rel)", "unfolding ahm_map_rel_def"], ["proof (prove)\nusing this:\n  single_valued\n   (\\<langle>\\<langle>Rk \\<times>\\<^sub>r\n                      Rv\\<rangle>list_rel\\<rangle>array_rel)\n\ngoal (1 subgoal):\n 1. single_valued\n     {uu_.\n      \\<exists>a a' n n'.\n         uu_ = (HashMap a n, HashMap a' n) \\<and>\n         (a, a')\n         \\<in> \\<langle>\\<langle>Rk \\<times>\\<^sub>r\n                                 Rv\\<rangle>list_rel\\<rangle>array_rel \\<and>\n         (n, n') \\<in> nat_rel}", "by (auto intro: single_valuedI dest: single_valuedD[OF 1])"], ["proof (state)\nthis:\n  single_valued (\\<langle>Rk, Rv\\<rangle>ahm_map_rel)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ahm_rel_sv[relator_props]:\n  \"\\<lbrakk>single_valued Rk; single_valued Rv\\<rbrakk> \n  \\<Longrightarrow> single_valued (\\<langle>Rk,Rv\\<rangle>ahm_rel bhc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>single_valued Rk; single_valued Rv\\<rbrakk>\n    \\<Longrightarrow> single_valued (\\<langle>Rk, Rv\\<rangle>ahm_rel bhc)", "unfolding ahm_rel_def ahm_map_rel'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>single_valued Rk; single_valued Rv\\<rbrakk>\n    \\<Longrightarrow> single_valued\n                       (\\<langle>Rk, Rv\\<rangle>ahm_map_rel O\n                        br (ahm_\\<alpha> (abstract_bounded_hashcode Rk bhc))\n                         (ahm_invar (abstract_bounded_hashcode Rk bhc)))", "by (tagged_solver (keep))"], ["", "lemma rbt_map_rel_finite[relator_props]: \n  assumes A[simplified]: \"GEN_ALGO_tag (is_bounded_hashcode Rk eq bhc)\"\n  shows \"finite_map_rel (\\<langle>Rk,Rv\\<rangle>ahm_rel bhc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_map_rel (\\<langle>Rk, Rv\\<rangle>ahm_rel bhc)", "unfolding ahm_rel_def finite_map_rel_def ahm_map_rel'_def br_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Range\n     (\\<langle>Rk, Rv\\<rangle>ahm_map_rel O\n      {(c, a).\n       a = ahm_\\<alpha> (abstract_bounded_hashcode Rk bhc) c \\<and>\n       ahm_invar (abstract_bounded_hashcode Rk bhc) c})\n    \\<subseteq> Collect (finite \\<circ> dom)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       \\<lbrakk>(xa, y) \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel;\n        ahm_invar (abstract_bounded_hashcode Rk bhc) y\\<rbrakk>\n       \\<Longrightarrow> finite\n                          (dom (ahm_\\<alpha>\n                                 (abstract_bounded_hashcode Rk bhc) y))", "apply (case_tac y)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa y x1 x2.\n       \\<lbrakk>(xa, y) \\<in> \\<langle>Rk, Rv\\<rangle>ahm_map_rel;\n        ahm_invar (abstract_bounded_hashcode Rk bhc) y;\n        y = HashMap x1 x2\\<rbrakk>\n       \\<Longrightarrow> finite\n                          (dom (ahm_\\<alpha>\n                                 (abstract_bounded_hashcode Rk bhc) y))", "apply (auto simp: ahm_\\<alpha>_def2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa x1 x2.\n       \\<lbrakk>(xa, HashMap x1 x2) \\<in> \\<langle>Rk,\n                Rv\\<rangle>ahm_map_rel;\n        ahm_invar_aux (abstract_bounded_hashcode Rk bhc) x2 x1\\<rbrakk>\n       \\<Longrightarrow> finite\n                          (dom (ahm_\\<alpha>_aux\n                                 (abstract_bounded_hashcode Rk bhc) x1))", "thm finite_dom_ahm_\\<alpha>_aux"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa x1 x2.\n       \\<lbrakk>(xa, HashMap x1 x2) \\<in> \\<langle>Rk,\n                Rv\\<rangle>ahm_map_rel;\n        ahm_invar_aux (abstract_bounded_hashcode Rk bhc) x2 x1\\<rbrakk>\n       \\<Longrightarrow> finite\n                          (dom (ahm_\\<alpha>_aux\n                                 (abstract_bounded_hashcode Rk bhc) x1))", "apply (rule finite_dom_ahm_\\<alpha>_aux)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa x1 x2.\n       \\<lbrakk>(xa, HashMap x1 x2) \\<in> \\<langle>Rk,\n                Rv\\<rangle>ahm_map_rel;\n        ahm_invar_aux (abstract_bounded_hashcode Rk bhc) x2 x1\\<rbrakk>\n       \\<Longrightarrow> is_bounded_hashcode Id (=)\n                          (abstract_bounded_hashcode Rk bhc)\n 2. \\<And>xa x1 x2.\n       \\<lbrakk>(xa, HashMap x1 x2) \\<in> \\<langle>Rk,\n                Rv\\<rangle>ahm_map_rel;\n        ahm_invar_aux (abstract_bounded_hashcode Rk bhc) x2 x1\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (abstract_bounded_hashcode Rk bhc)\n                          (?n13 xa x1 x2) x1", "apply (rule abstract_bhc_is_bhc)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa x1 x2.\n       \\<lbrakk>(xa, HashMap x1 x2) \\<in> \\<langle>Rk,\n                Rv\\<rangle>ahm_map_rel;\n        ahm_invar_aux (abstract_bounded_hashcode Rk bhc) x2 x1\\<rbrakk>\n       \\<Longrightarrow> is_bounded_hashcode Rk (?eq16 xa x1 x2) bhc\n 2. \\<And>xa x1 x2.\n       \\<lbrakk>(xa, HashMap x1 x2) \\<in> \\<langle>Rk,\n                Rv\\<rangle>ahm_map_rel;\n        ahm_invar_aux (abstract_bounded_hashcode Rk bhc) x2 x1\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (abstract_bounded_hashcode Rk bhc)\n                          (?n13 xa x1 x2) x1", "apply (rule A)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa x1 x2.\n       \\<lbrakk>(xa, HashMap x1 x2) \\<in> \\<langle>Rk,\n                Rv\\<rangle>ahm_map_rel;\n        ahm_invar_aux (abstract_bounded_hashcode Rk bhc) x2 x1\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (abstract_bounded_hashcode Rk bhc)\n                          (?n13 xa x1 x2) x1", "apply assumption"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Proper iterator proofs\\<close>"], ["", "lemma pi_ahm[icf_proper_iteratorI]: \n  \"proper_it (ahm_iteratei m) (ahm_iteratei m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it (ahm_iteratei m) (ahm_iteratei m)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. proper_it (ahm_iteratei m) (ahm_iteratei m)", "obtain a n where [simp]: \"m = HashMap a n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a n. m = HashMap a n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases m)"], ["proof (state)\nthis:\n  m = HashMap a n\n\ngoal (1 subgoal):\n 1. proper_it (ahm_iteratei m) (ahm_iteratei m)", "then"], ["proof (chain)\npicking this:\n  m = HashMap a n", "obtain l where [simp]: \"a = Array l\""], ["proof (prove)\nusing this:\n  m = HashMap a n\n\ngoal (1 subgoal):\n 1. (\\<And>l. a = Array l \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (cases a)"], ["proof (state)\nthis:\n  a = Array l\n\ngoal (1 subgoal):\n 1. proper_it (ahm_iteratei m) (ahm_iteratei m)", "thus ?thesis"], ["proof (prove)\nusing this:\n  a = Array l\n\ngoal (1 subgoal):\n 1. proper_it (ahm_iteratei m) (ahm_iteratei m)", "unfolding proper_it_def list_map_iteratei_def"], ["proof (prove)\nusing this:\n  a = Array l\n\ngoal (1 subgoal):\n 1. \\<exists>l. ahm_iteratei m = foldli l \\<and> ahm_iteratei m = foldli l", "by (simp add: ahm_iteratei_aux_def, blast)"], ["proof (state)\nthis:\n  proper_it (ahm_iteratei m) (ahm_iteratei m)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pi'_ahm[icf_proper_iteratorI]: \n  \"proper_it' ahm_iteratei ahm_iteratei\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it' ahm_iteratei ahm_iteratei", "by (rule proper_it'I, rule pi_ahm)"], ["", "(*\nhide_const (open) HashMap bucket_ok ahm_invar ahm_\\<alpha>\n  ahm_rehash hm_grow ahm_filled\nhide_type (open) hashmap\n*)"], ["", "lemmas autoref_ahm_rules = \n  autoref_ahm_empty \n  autoref_ahm_lookup \n  autoref_ahm_update\n  autoref_ahm_delete\n  autoref_ahm_isEmpty\n  autoref_ahm_isSng\n  autoref_ahm_size"], ["", "lemmas autoref_ahm_rules_hashable[autoref_rules_raw]\n  = autoref_ahm_rules[where Rk=\"Rk\"] for Rk :: \"(_\\<times>_::hashable) set\""], ["", "end"]]}