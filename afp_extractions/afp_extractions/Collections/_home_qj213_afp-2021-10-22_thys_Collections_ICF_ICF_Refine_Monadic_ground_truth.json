{"file_name": "/home/qj213/afp-2021-10-22/thys/Collections/ICF/ICF_Refine_Monadic.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Collections", "problem_names": ["lemma (in set) drh[refine_dref_RELATES]: \n  \"RELATES (build_rel \\<alpha> invar)\"", "lemma (in map) drh[refine_dref_RELATES]: \n  \"RELATES (build_rel \\<alpha> invar)\"", "lemma (in uprio) drh[refine_dref_RELATES]: \"RELATES (build_rel \\<alpha> invar)\"", "lemma (in prio) drh[refine_dref_RELATES]: \"RELATES (build_rel \\<alpha> invar)\"", "lemmas (in StdSet) [refine_hsimp] = correct", "lemmas (in StdMap) [refine_hsimp] = correct", "lemma (in set_sel') pick_ref[refine_hsimp]:\n  \"\\<lbrakk> invar s; \\<alpha> s \\<noteq> {}\\<rbrakk> \\<Longrightarrow> the (sel' s (\\<lambda>_. True)) \\<in> \\<alpha> s\"", "lemma (in uprio_pop) prio_pop_min_refine[refine]:\n  \"(q,q')\\<in>build_rel \\<alpha> invar \\<Longrightarrow> RETURN (pop q) \n    \\<le> \\<Down> (\\<langle>Id,\\<langle>Id,br \\<alpha> invar\\<rangle>prod_rel\\<rangle>prod_rel) (prio_pop_min q')\"", "lemmas (in poly_map_iteratei) [refine_transfer] = iteratei_correct", "lemmas (in poly_map_iterateoi) [refine_transfer] = iterateoi_correct", "lemmas (in map_no_invar) [refine_transfer] = invar", "lemmas (in poly_set_iteratei) [refine_transfer] = iteratei_correct", "lemmas (in poly_set_iterateoi) [refine_transfer] = iterateoi_correct", "lemmas (in set_no_invar) [refine_transfer] = invar", "lemma (in poly_set_iteratei) dres_ne_bot_iterate[refine_transfer]:\n  assumes A: \"\\<And>x s. f x s \\<noteq> dSUCCEED\"\n  shows \"iteratei r c (\\<lambda>x s. dbind s (f x)) (dRETURN s) \\<noteq> dSUCCEED\"", "lemma (in poly_set_iterateoi) dres_ne_bot_iterateo[refine_transfer]:\n  assumes A: \"\\<And>x s. f x s \\<noteq> dSUCCEED\"\n  shows \"iterateoi r c (\\<lambda>x s. dbind s (f x)) (dRETURN s) \\<noteq> dSUCCEED\"", "lemma (in poly_map_iteratei) dres_ne_bot_map_iterate[refine_transfer]:\n  assumes A: \"\\<And>x s. f x s \\<noteq> dSUCCEED\"\n  shows \"iteratei r c (\\<lambda>x s. dbind s (f x)) (dRETURN s) \\<noteq> dSUCCEED\"", "lemma (in poly_set_iterateoi) dres_ne_bot_map_iterateo[refine_transfer]:\n  assumes A: \"\\<And>x s. f x s \\<noteq> dSUCCEED\"\n  shows \"iterateoi r c (\\<lambda>x s. dbind s (f x)) (dRETURN s) \\<noteq> dSUCCEED\"", "lemma transfer_FOREACHoci_plain[refine_transfer]:\n  assumes A: \"set_iterator_genord iterate s ordR\"\n  assumes R: \"\\<And>x \\<sigma>. RETURN (fi x \\<sigma>) \\<le> f x \\<sigma>\"\n  shows \"RETURN (iterate c fi \\<sigma>) \\<le> FOREACHoci ordR I s c f \\<sigma>\"", "lemma transfer_FOREACHoi_plain[refine_transfer]:\n  assumes A: \"set_iterator_genord iterate s ordR\"\n  assumes R: \"\\<And>x \\<sigma>. RETURN (fi x \\<sigma>) \\<le> f x \\<sigma>\"\n  shows \"RETURN (iterate (\\<lambda>_. True) fi \\<sigma>) \\<le> FOREACHoi ordR I s f \\<sigma>\"", "lemma transfer_FOREACHci_plain[refine_transfer]:\n  assumes A: \"set_iterator iterate s\"\n  assumes R: \"\\<And>x \\<sigma>. RETURN (fi x \\<sigma>) \\<le> f x \\<sigma>\"\n  shows \"RETURN (iterate c fi \\<sigma>) \\<le> FOREACHci I s c f \\<sigma>\"", "lemma transfer_FOREACHi_plain[refine_transfer]:\n  assumes A: \"set_iterator iterate s\"\n  assumes R: \"\\<And>x \\<sigma>. RETURN (fi x \\<sigma>) \\<le> f x \\<sigma>\"\n  shows \"RETURN (iterate (\\<lambda>_. True) fi \\<sigma>) \\<le> FOREACHi I s f \\<sigma>\"", "lemma transfer_FOREACHc_plain[refine_transfer]:\n  assumes A: \"set_iterator iterate s\"\n  assumes R: \"\\<And>x \\<sigma>. RETURN (fi x \\<sigma>) \\<le> f x \\<sigma>\"\n  shows \"RETURN (iterate c fi \\<sigma>) \\<le> FOREACHc s c f \\<sigma>\"", "lemma transfer_FOREACH_plain[refine_transfer]:\n  assumes A: \"set_iterator iterate s\"\n  assumes R: \"\\<And>x \\<sigma>. RETURN (fi x \\<sigma>) \\<le> f x \\<sigma>\"\n  shows \"RETURN (iterate (\\<lambda>_. True) fi \\<sigma>) \\<le> FOREACH s f \\<sigma>\"", "lemma transfer_FOREACHoci_nres[refine_transfer]:\n  assumes A: \"set_iterator_genord iterate s ordR\"\n  assumes R: \"\\<And>x \\<sigma>. nres_of (fi x \\<sigma>) \\<le> f x \\<sigma>\"\n  shows \"nres_of (dres_it iterate c fi \\<sigma>) \\<le> FOREACHoci ordR I s c f \\<sigma>\"", "lemma transfer_FOREACHoi_nres[refine_transfer]:\n  assumes A: \"set_iterator_genord iterate s ordR\"\n  assumes R: \"\\<And>x \\<sigma>. nres_of (fi x \\<sigma>) \\<le> f x \\<sigma>\"\n  shows \"nres_of (dres_it iterate (\\<lambda>_. True) fi \\<sigma>) \\<le> FOREACHoi ordR I s f \\<sigma>\"", "lemma transfer_FOREACHci_nres[refine_transfer]:\n  assumes A: \"set_iterator iterate s\"\n  assumes R: \"\\<And>x \\<sigma>. nres_of (fi x \\<sigma>) \\<le> f x \\<sigma>\"\n  shows \"nres_of (dres_it iterate c fi \\<sigma>) \\<le> FOREACHci I s c f \\<sigma>\"", "lemma transfer_FOREACHi_nres[refine_transfer]:\n  assumes A: \"set_iterator iterate s\"\n  assumes R: \"\\<And>x \\<sigma>. nres_of (fi x \\<sigma>) \\<le> f x \\<sigma>\"\n  shows \"nres_of (dres_it iterate (\\<lambda>_. True) fi \\<sigma>) \\<le> FOREACHi I s f \\<sigma>\"", "lemma transfer_FOREACHc_nres[refine_transfer]:\n  assumes A: \"set_iterator iterate s\"\n  assumes R: \"\\<And>x \\<sigma>. nres_of (fi x \\<sigma>) \\<le> f x \\<sigma>\"\n  shows \"nres_of (dres_it iterate c fi \\<sigma>) \\<le> FOREACHc s c f \\<sigma>\"", "lemma transfer_FOREACH_nres[refine_transfer]:\n  assumes A: \"set_iterator iterate s\"\n  assumes R: \"\\<And>x \\<sigma>. nres_of (fi x \\<sigma>) \\<le> f x \\<sigma>\"\n  shows \"nres_of (dres_it iterate (\\<lambda>_. True) fi \\<sigma>) \\<le> FOREACH s f \\<sigma>\""], "translations": [["", "lemma (in set) drh[refine_dref_RELATES]: \n  \"RELATES (build_rel \\<alpha> invar)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RELATES (br \\<alpha> invar)", "by (simp add: RELATES_def)"], ["", "lemma (in map) drh[refine_dref_RELATES]: \n  \"RELATES (build_rel \\<alpha> invar)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RELATES (br \\<alpha> invar)", "by (simp add: RELATES_def)"], ["", "lemma (in uprio) drh[refine_dref_RELATES]: \"RELATES (build_rel \\<alpha> invar)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RELATES (br \\<alpha> invar)", "by (simp add: RELATES_def)"], ["", "lemma (in prio) drh[refine_dref_RELATES]: \"RELATES (build_rel \\<alpha> invar)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RELATES (br \\<alpha> invar)", "by (simp add: RELATES_def)"], ["", "lemmas (in StdSet) [refine_hsimp] = correct"], ["", "lemmas (in StdMap) [refine_hsimp] = correct"], ["", "lemma (in set_sel') pick_ref[refine_hsimp]:\n  \"\\<lbrakk> invar s; \\<alpha> s \\<noteq> {}\\<rbrakk> \\<Longrightarrow> the (sel' s (\\<lambda>_. True)) \\<in> \\<alpha> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar s; \\<alpha> s \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> the (sel' s (\\<lambda>_. True)) \\<in> \\<alpha> s", "by (auto elim!: sel'E)"], ["", "(*text {* Wrapper to prevent higher-order unification problems *}\ndefinition [simp, code_unfold]: \"IT_tag x \\<equiv> x\"\n\nlemma (in set_iteratei) it_is_iterator[refine_transfer]:\n  \"invar s \\<Longrightarrow> set_iterator (IT_tag iteratei s) (\\<alpha> s)\"\n  unfolding IT_tag_def by (rule iteratei_rule)\n\nlemma (in map_iteratei) it_is_iterator[refine_transfer]:\n  \"invar m \\<Longrightarrow> set_iterator (IT_tag iteratei m) (map_to_set (\\<alpha> m))\"\n  unfolding IT_tag_def by (rule iteratei_rule)\n*)"], ["", "text \\<open>\n  This definition is handy to be used on the abstract level.\n\\<close>"], ["", "definition \"prio_pop_min q \\<equiv> do {\n    ASSERT (dom q \\<noteq> {});\n    SPEC (\\<lambda>(e,w,q'). \n      q'=q(e:=None) \\<and> \n      q e = Some w \\<and> \n      (\\<forall> e' w'. q e' = Some w' \\<longrightarrow> w\\<le>w')\n    )\n  }\""], ["", "lemma (in uprio_pop) prio_pop_min_refine[refine]:\n  \"(q,q')\\<in>build_rel \\<alpha> invar \\<Longrightarrow> RETURN (pop q) \n    \\<le> \\<Down> (\\<langle>Id,\\<langle>Id,br \\<alpha> invar\\<rangle>prod_rel\\<rangle>prod_rel) (prio_pop_min q')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (q, q') \\<in> br \\<alpha> invar \\<Longrightarrow>\n    RETURN (pop q)\n    \\<le> \\<Down>\n           (Id \\<times>\\<^sub>r Id \\<times>\\<^sub>r br \\<alpha> invar)\n           (prio_pop_min q')", "unfolding prio_pop_min_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (q, q') \\<in> br \\<alpha> invar \\<Longrightarrow>\n    RETURN (pop q)\n    \\<le> \\<Down>\n           (Id \\<times>\\<^sub>r Id \\<times>\\<^sub>r br \\<alpha> invar)\n           (ASSERT (dom q' \\<noteq> {}) \\<bind>\n            (\\<lambda>_.\n                SPEC\n                 (\\<lambda>(e, w, q'a).\n                     q'a = q'(e := None) \\<and>\n                     q' e = Some w \\<and>\n                     (\\<forall>e' w'.\n                         q' e' = Some w' \\<longrightarrow> w \\<le> w'))))", "apply refine_rcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(q, q') \\<in> br \\<alpha> invar; dom q' \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> RETURN (pop q)\n                      \\<le> \\<Down>\n                             (Id \\<times>\\<^sub>r\n                              Id \\<times>\\<^sub>r br \\<alpha> invar)\n                             (SPEC\n                               (\\<lambda>(e, w, q'a).\n                                   q'a = q'(e := None) \\<and>\n                                   q' e = Some w \\<and>\n                                   (\\<forall>e' w'.\n q' e' = Some w' \\<longrightarrow> w \\<le> w')))", "apply (clarsimp simp: prod_rel_def br_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<alpha> q \\<noteq> Map.empty; q' = \\<alpha> q;\n     invar q\\<rbrakk>\n    \\<Longrightarrow> RETURN (pop q)\n                      \\<le> \\<Down>\n                             {((a, b), a', b').\n                              a = a' \\<and>\n                              (case b of\n                               (a, b) \\<Rightarrow>\n                                 \\<lambda>(a', b').\n                                    a = a' \\<and>\n                                    b' = \\<alpha> b \\<and> invar b)\n                               b'}\n                             (SPEC\n                               (\\<lambda>(e, w, q').\n                                   q' = (\\<alpha> q)(e := None) \\<and>\n                                   \\<alpha> q e = Some w \\<and>\n                                   (\\<forall>e' w'.\n \\<alpha> q e' = Some w' \\<longrightarrow> w \\<le> w')))", "apply (erule (1) popE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>e a s'.\n       \\<lbrakk>\\<alpha> q \\<noteq> Map.empty; q' = \\<alpha> q;\n        pop q = (e, a, s'); invar s'; \\<alpha> s' = (\\<alpha> q)(e := None);\n        \\<alpha> q e = Some a;\n        \\<forall>y\\<in>ran (\\<alpha> q). a \\<le> y\\<rbrakk>\n       \\<Longrightarrow> RETURN (pop q)\n                         \\<le> \\<Down>\n                                {((a, b), a', b').\n                                 a = a' \\<and>\n                                 (case b of\n                                  (a, b) \\<Rightarrow>\n                                    \\<lambda>(a', b').\n a = a' \\<and> b' = \\<alpha> b \\<and> invar b)\n                                  b'}\n                                (SPEC\n                                  (\\<lambda>(e, w, q').\nq' = (\\<alpha> q)(e := None) \\<and>\n\\<alpha> q e = Some w \\<and>\n(\\<forall>e' w'. \\<alpha> q e' = Some w' \\<longrightarrow> w \\<le> w')))", "apply (rule pw_leI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>e a s'.\n       \\<lbrakk>\\<alpha> q \\<noteq> Map.empty; q' = \\<alpha> q;\n        pop q = (e, a, s'); invar s'; \\<alpha> s' = (\\<alpha> q)(e := None);\n        \\<alpha> q e = Some a;\n        \\<forall>y\\<in>ran (\\<alpha> q). a \\<le> y\\<rbrakk>\n       \\<Longrightarrow> nofail\n                          (\\<Down>\n                            {((a, b), a', b').\n                             a = a' \\<and>\n                             (case b of\n                              (a, b) \\<Rightarrow>\n                                \\<lambda>(a', b').\n                                   a = a' \\<and>\n                                   b' = \\<alpha> b \\<and> invar b)\n                              b'}\n                            (SPEC\n                              (\\<lambda>(e, w, q').\n                                  q' = (\\<alpha> q)(e := None) \\<and>\n                                  \\<alpha> q e = Some w \\<and>\n                                  (\\<forall>e' w'.\n\\<alpha> q e' = Some w' \\<longrightarrow> w \\<le> w')))) \\<longrightarrow>\n                         nofail (RETURN (pop q)) \\<and>\n                         (\\<forall>x.\n                             inres (RETURN (pop q)) x \\<longrightarrow>\n                             inres\n                              (\\<Down>\n                                {((a, b), a', b').\n                                 a = a' \\<and>\n                                 (case b of\n                                  (a, b) \\<Rightarrow>\n                                    \\<lambda>(a', b').\n a = a' \\<and> b' = \\<alpha> b \\<and> invar b)\n                                  b'}\n                                (SPEC\n                                  (\\<lambda>(e, w, q').\nq' = (\\<alpha> q)(e := None) \\<and>\n\\<alpha> q e = Some w \\<and>\n(\\<forall>e' w'. \\<alpha> q e' = Some w' \\<longrightarrow> w \\<le> w'))))\n                              x)", "apply (auto simp: refine_pw_simps intro: ranI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \"Iterators\""], ["", "lemmas (in poly_map_iteratei) [refine_transfer] = iteratei_correct"], ["", "lemmas (in poly_map_iterateoi) [refine_transfer] = iterateoi_correct"], ["", "lemmas (in map_no_invar) [refine_transfer] = invar"], ["", "lemmas (in poly_set_iteratei) [refine_transfer] = iteratei_correct"], ["", "lemmas (in poly_set_iterateoi) [refine_transfer] = iterateoi_correct"], ["", "lemmas (in set_no_invar) [refine_transfer] = invar"], ["", "lemma (in poly_set_iteratei) dres_ne_bot_iterate[refine_transfer]:\n  assumes A: \"\\<And>x s. f x s \\<noteq> dSUCCEED\"\n  shows \"iteratei r c (\\<lambda>x s. dbind s (f x)) (dRETURN s) \\<noteq> dSUCCEED\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iteratei r c (\\<lambda>x s. s \\<bind> f x) (dRETURN s) \\<noteq> dSUCCEED", "unfolding iteratei_def it_to_list_def it_to_it_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli (list_it r (\\<lambda>_. True) (\\<lambda>x l. l @ [x]) []) c\n     (\\<lambda>x s. s \\<bind> f x) (dRETURN s) \\<noteq>\n    dSUCCEED", "apply (rule dres_foldli_ne_bot)"], ["proof (prove)\ngoal (2 subgoals):\n 1. dRETURN s \\<noteq> dSUCCEED\n 2. \\<And>x \\<sigma>. f x \\<sigma> \\<noteq> dSUCCEED", "by (simp_all add: A)"], ["", "lemma (in poly_set_iterateoi) dres_ne_bot_iterateo[refine_transfer]:\n  assumes A: \"\\<And>x s. f x s \\<noteq> dSUCCEED\"\n  shows \"iterateoi r c (\\<lambda>x s. dbind s (f x)) (dRETURN s) \\<noteq> dSUCCEED\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iterateoi r c (\\<lambda>x s. s \\<bind> f x) (dRETURN s) \\<noteq>\n    dSUCCEED", "unfolding iterateoi_def it_to_list_def it_to_it_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli (list_ordered_it r (\\<lambda>_. True) (\\<lambda>x l. l @ [x]) [])\n     c (\\<lambda>x s. s \\<bind> f x) (dRETURN s) \\<noteq>\n    dSUCCEED", "apply (rule dres_foldli_ne_bot)"], ["proof (prove)\ngoal (2 subgoals):\n 1. dRETURN s \\<noteq> dSUCCEED\n 2. \\<And>x \\<sigma>. f x \\<sigma> \\<noteq> dSUCCEED", "by (simp_all add: A)"], ["", "lemma (in poly_map_iteratei) dres_ne_bot_map_iterate[refine_transfer]:\n  assumes A: \"\\<And>x s. f x s \\<noteq> dSUCCEED\"\n  shows \"iteratei r c (\\<lambda>x s. dbind s (f x)) (dRETURN s) \\<noteq> dSUCCEED\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iteratei r c (\\<lambda>x s. s \\<bind> f x) (dRETURN s) \\<noteq> dSUCCEED", "unfolding iteratei_def it_to_list_def it_to_it_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli (list_it r (\\<lambda>_. True) (\\<lambda>x l. l @ [x]) []) c\n     (\\<lambda>x s. s \\<bind> f x) (dRETURN s) \\<noteq>\n    dSUCCEED", "apply (rule dres_foldli_ne_bot)"], ["proof (prove)\ngoal (2 subgoals):\n 1. dRETURN s \\<noteq> dSUCCEED\n 2. \\<And>x \\<sigma>. f x \\<sigma> \\<noteq> dSUCCEED", "by (simp_all add: A)"], ["", "lemma (in poly_set_iterateoi) dres_ne_bot_map_iterateo[refine_transfer]:\n  assumes A: \"\\<And>x s. f x s \\<noteq> dSUCCEED\"\n  shows \"iterateoi r c (\\<lambda>x s. dbind s (f x)) (dRETURN s) \\<noteq> dSUCCEED\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iterateoi r c (\\<lambda>x s. s \\<bind> f x) (dRETURN s) \\<noteq>\n    dSUCCEED", "unfolding iterateoi_def it_to_list_def it_to_it_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli (list_ordered_it r (\\<lambda>_. True) (\\<lambda>x l. l @ [x]) [])\n     c (\\<lambda>x s. s \\<bind> f x) (dRETURN s) \\<noteq>\n    dSUCCEED", "apply (rule dres_foldli_ne_bot)"], ["proof (prove)\ngoal (2 subgoals):\n 1. dRETURN s \\<noteq> dSUCCEED\n 2. \\<And>x \\<sigma>. f x \\<sigma> \\<noteq> dSUCCEED", "by (simp_all add: A)"], ["", "subsection \"Alternative FOREACH-transfer\""], ["", "text \\<open>Required for manual refinements\\<close>"], ["", "lemma transfer_FOREACHoci_plain[refine_transfer]:\n  assumes A: \"set_iterator_genord iterate s ordR\"\n  assumes R: \"\\<And>x \\<sigma>. RETURN (fi x \\<sigma>) \\<le> f x \\<sigma>\"\n  shows \"RETURN (iterate c fi \\<sigma>) \\<le> FOREACHoci ordR I s c f \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN (iterate c fi \\<sigma>)\n    \\<le> FOREACH\\<^sub>O\\<^sub>C\\<^bsup>ordR,I\\<^esup> s c f \\<sigma>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. RETURN (iterate c fi \\<sigma>)\n    \\<le> FOREACH\\<^sub>O\\<^sub>C\\<^bsup>ordR,I\\<^esup> s c f \\<sigma>", "from A"], ["proof (chain)\npicking this:\n  set_iterator_genord iterate s ordR", "obtain l where [simp]:\n    \"distinct l\" \n    \"s = set l\" \n    \"sorted_wrt ordR l\"\n    \"iterate = foldli l\""], ["proof (prove)\nusing this:\n  set_iterator_genord iterate s ordR\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>distinct l; s = set l; sorted_wrt ordR l;\n         iterate = foldli l\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding set_iterator_genord_def"], ["proof (prove)\nusing this:\n  \\<exists>l0.\n     distinct l0 \\<and>\n     s = set l0 \\<and> sorted_wrt ordR l0 \\<and> iterate = foldli l0\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>distinct l; s = set l; sorted_wrt ordR l;\n         iterate = foldli l\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  distinct l\n  s = set l\n  sorted_wrt ordR l\n  iterate = foldli l\n\ngoal (1 subgoal):\n 1. RETURN (iterate c fi \\<sigma>)\n    \\<le> FOREACH\\<^sub>O\\<^sub>C\\<^bsup>ordR,I\\<^esup> s c f \\<sigma>", "have \"RETURN (foldli l c fi \\<sigma>) \\<le> nfoldli l c f \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN (foldli l c fi \\<sigma>) \\<le> nfoldli l c f \\<sigma>", "by (rule nfoldli_transfer_plain[OF R])"], ["proof (state)\nthis:\n  RETURN (foldli l c fi \\<sigma>) \\<le> nfoldli l c f \\<sigma>\n\ngoal (1 subgoal):\n 1. RETURN (iterate c fi \\<sigma>)\n    \\<le> FOREACH\\<^sub>O\\<^sub>C\\<^bsup>ordR,I\\<^esup> s c f \\<sigma>", "also"], ["proof (state)\nthis:\n  RETURN (foldli l c fi \\<sigma>) \\<le> nfoldli l c f \\<sigma>\n\ngoal (1 subgoal):\n 1. RETURN (iterate c fi \\<sigma>)\n    \\<le> FOREACH\\<^sub>O\\<^sub>C\\<^bsup>ordR,I\\<^esup> s c f \\<sigma>", "have \"\\<dots> = do { l \\<leftarrow> RETURN l; nfoldli l c f \\<sigma> }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nfoldli l c f \\<sigma> =\n    RETURN l \\<bind> (\\<lambda>l. nfoldli l c f \\<sigma>)", "by simp"], ["proof (state)\nthis:\n  nfoldli l c f \\<sigma> =\n  RETURN l \\<bind> (\\<lambda>l. nfoldli l c f \\<sigma>)\n\ngoal (1 subgoal):\n 1. RETURN (iterate c fi \\<sigma>)\n    \\<le> FOREACH\\<^sub>O\\<^sub>C\\<^bsup>ordR,I\\<^esup> s c f \\<sigma>", "also"], ["proof (state)\nthis:\n  nfoldli l c f \\<sigma> =\n  RETURN l \\<bind> (\\<lambda>l. nfoldli l c f \\<sigma>)\n\ngoal (1 subgoal):\n 1. RETURN (iterate c fi \\<sigma>)\n    \\<le> FOREACH\\<^sub>O\\<^sub>C\\<^bsup>ordR,I\\<^esup> s c f \\<sigma>", "have \"\\<dots> \\<le> FOREACHoci ordR I s c f \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN l \\<bind> (\\<lambda>l. nfoldli l c f \\<sigma>)\n    \\<le> FOREACH\\<^sub>O\\<^sub>C\\<^bsup>ordR,I\\<^esup> s c f \\<sigma>", "apply (rule refine_IdD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN l \\<bind> (\\<lambda>l. nfoldli l c f \\<sigma>)\n    \\<le> \\<Down> Id\n           (FOREACH\\<^sub>O\\<^sub>C\\<^bsup>ordR,I\\<^esup> s c f \\<sigma>)", "unfolding FOREACHoci_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN l \\<bind> (\\<lambda>l. nfoldli l c f \\<sigma>)\n    \\<le> \\<Down> Id\n           (ASSERT (finite s) \\<bind>\n            (\\<lambda>_.\n                SPEC\n                 (\\<lambda>xs.\n                     distinct xs \\<and>\n                     s = set xs \\<and> sorted_wrt ordR xs) \\<bind>\n                (\\<lambda>xs.\n                    WHILE\\<^sub>T\\<^bsup>\\<lambda>(it, \\<sigma>).\n      \\<exists>xs'. xs = xs' @ it \\<and> I (set it) \\<sigma>\\<^esup>\n                     (FOREACH_cond c) (FOREACH_body f)\n                     (xs, \\<sigma>) \\<bind>\n                    (\\<lambda>(uu_, \\<sigma>). RETURN \\<sigma>))))", "apply refine_rcg"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite s \\<Longrightarrow>\n    RETURN l\n    \\<le> SPEC\n           (\\<lambda>xs.\n               distinct xs \\<and> s = set xs \\<and> sorted_wrt ordR xs)\n 2. \\<And>l xs.\n       \\<lbrakk>finite s; (l, xs) \\<in> Id;\n        xs \\<in> {xs.\n                  distinct xs \\<and>\n                  s = set xs \\<and> sorted_wrt ordR xs}\\<rbrakk>\n       \\<Longrightarrow> nfoldli l c f \\<sigma>\n                         \\<le> \\<Down> Id\n                                (WHILE\\<^sub>T\\<^bsup>\\<lambda>(it,\n                   \\<sigma>).\n                   \\<exists>xs'.\n                      xs = xs' @ it \\<and> I (set it) \\<sigma>\\<^esup>\n                                  (FOREACH_cond c) (FOREACH_body f)\n                                  (xs, \\<sigma>) \\<bind>\n                                 (\\<lambda>(uu_, \\<sigma>).\n                                     RETURN \\<sigma>))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l xs.\n       \\<lbrakk>finite s; (l, xs) \\<in> Id;\n        xs \\<in> {xs.\n                  distinct xs \\<and>\n                  s = set xs \\<and> sorted_wrt ordR xs}\\<rbrakk>\n       \\<Longrightarrow> nfoldli l c f \\<sigma>\n                         \\<le> \\<Down> Id\n                                (WHILE\\<^sub>T\\<^bsup>\\<lambda>(it,\n                   \\<sigma>).\n                   \\<exists>xs'.\n                      xs = xs' @ it \\<and> I (set it) \\<sigma>\\<^esup>\n                                  (FOREACH_cond c) (FOREACH_body f)\n                                  (xs, \\<sigma>) \\<bind>\n                                 (\\<lambda>(uu_, \\<sigma>).\n                                     RETURN \\<sigma>))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>la.\n       distinct la \\<and>\n       set l = set la \\<and> sorted_wrt ordR la \\<Longrightarrow>\n       nfoldli la c f \\<sigma>\n       \\<le> WHILE\\<^sub>T\\<^bsup>\\<lambda>(it, \\<sigma>).\n                                     (\\<exists>xs'. la = xs' @ it) \\<and>\n                                     I (set it) \\<sigma>\\<^esup>\n              (FOREACH_cond c) (FOREACH_body f) (la, \\<sigma>) \\<bind>\n             (\\<lambda>(uu_, y). RETURN y)", "apply (rule nfoldli_while)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  RETURN l \\<bind> (\\<lambda>l. nfoldli l c f \\<sigma>)\n  \\<le> FOREACH\\<^sub>O\\<^sub>C\\<^bsup>ordR,I\\<^esup> s c f \\<sigma>\n\ngoal (1 subgoal):\n 1. RETURN (iterate c fi \\<sigma>)\n    \\<le> FOREACH\\<^sub>O\\<^sub>C\\<^bsup>ordR,I\\<^esup> s c f \\<sigma>", "finally"], ["proof (chain)\npicking this:\n  RETURN (foldli l c fi \\<sigma>)\n  \\<le> FOREACH\\<^sub>O\\<^sub>C\\<^bsup>ordR,I\\<^esup> s c f \\<sigma>", "show ?thesis"], ["proof (prove)\nusing this:\n  RETURN (foldli l c fi \\<sigma>)\n  \\<le> FOREACH\\<^sub>O\\<^sub>C\\<^bsup>ordR,I\\<^esup> s c f \\<sigma>\n\ngoal (1 subgoal):\n 1. RETURN (iterate c fi \\<sigma>)\n    \\<le> FOREACH\\<^sub>O\\<^sub>C\\<^bsup>ordR,I\\<^esup> s c f \\<sigma>", "by simp"], ["proof (state)\nthis:\n  RETURN (iterate c fi \\<sigma>)\n  \\<le> FOREACH\\<^sub>O\\<^sub>C\\<^bsup>ordR,I\\<^esup> s c f \\<sigma>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma transfer_FOREACHoi_plain[refine_transfer]:\n  assumes A: \"set_iterator_genord iterate s ordR\"\n  assumes R: \"\\<And>x \\<sigma>. RETURN (fi x \\<sigma>) \\<le> f x \\<sigma>\"\n  shows \"RETURN (iterate (\\<lambda>_. True) fi \\<sigma>) \\<le> FOREACHoi ordR I s f \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN (iterate (\\<lambda>_. True) fi \\<sigma>)\n    \\<le> FOREACH\\<^sub>O\\<^bsup>ordR,I\\<^esup> s f \\<sigma>", "using assms"], ["proof (prove)\nusing this:\n  set_iterator_genord iterate s ordR\n  RETURN (fi ?x ?\\<sigma>) \\<le> f ?x ?\\<sigma>\n\ngoal (1 subgoal):\n 1. RETURN (iterate (\\<lambda>_. True) fi \\<sigma>)\n    \\<le> FOREACH\\<^sub>O\\<^bsup>ordR,I\\<^esup> s f \\<sigma>", "unfolding FOREACHoi_def"], ["proof (prove)\nusing this:\n  set_iterator_genord iterate s ordR\n  RETURN (fi ?x ?\\<sigma>) \\<le> f ?x ?\\<sigma>\n\ngoal (1 subgoal):\n 1. RETURN (iterate (\\<lambda>_. True) fi \\<sigma>)\n    \\<le> FOREACH\\<^sub>O\\<^sub>C\\<^bsup>ordR,I\\<^esup> s (\\<lambda>_. True)\n           f \\<sigma>", "by (rule transfer_FOREACHoci_plain)"], ["", "lemma transfer_FOREACHci_plain[refine_transfer]:\n  assumes A: \"set_iterator iterate s\"\n  assumes R: \"\\<And>x \\<sigma>. RETURN (fi x \\<sigma>) \\<le> f x \\<sigma>\"\n  shows \"RETURN (iterate c fi \\<sigma>) \\<le> FOREACHci I s c f \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN (iterate c fi \\<sigma>)\n    \\<le> FOREACH\\<^sub>C\\<^bsup>I\\<^esup> s c f \\<sigma>", "using assms"], ["proof (prove)\nusing this:\n  set_iterator iterate s\n  RETURN (fi ?x ?\\<sigma>) \\<le> f ?x ?\\<sigma>\n\ngoal (1 subgoal):\n 1. RETURN (iterate c fi \\<sigma>)\n    \\<le> FOREACH\\<^sub>C\\<^bsup>I\\<^esup> s c f \\<sigma>", "unfolding FOREACHci_def set_iterator_def"], ["proof (prove)\nusing this:\n  set_iterator_genord iterate s (\\<lambda>_ _. True)\n  RETURN (fi ?x ?\\<sigma>) \\<le> f ?x ?\\<sigma>\n\ngoal (1 subgoal):\n 1. RETURN (iterate c fi \\<sigma>)\n    \\<le> FOREACH\\<^sub>O\\<^sub>C\\<^bsup>\\<lambda>_ _. True,I\\<^esup> s c f\n           \\<sigma>", "by (rule transfer_FOREACHoci_plain)"], ["", "lemma transfer_FOREACHi_plain[refine_transfer]:\n  assumes A: \"set_iterator iterate s\"\n  assumes R: \"\\<And>x \\<sigma>. RETURN (fi x \\<sigma>) \\<le> f x \\<sigma>\"\n  shows \"RETURN (iterate (\\<lambda>_. True) fi \\<sigma>) \\<le> FOREACHi I s f \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN (iterate (\\<lambda>_. True) fi \\<sigma>)\n    \\<le> FOREACH\\<^bsup>I\\<^esup> s f \\<sigma>", "using assms"], ["proof (prove)\nusing this:\n  set_iterator iterate s\n  RETURN (fi ?x ?\\<sigma>) \\<le> f ?x ?\\<sigma>\n\ngoal (1 subgoal):\n 1. RETURN (iterate (\\<lambda>_. True) fi \\<sigma>)\n    \\<le> FOREACH\\<^bsup>I\\<^esup> s f \\<sigma>", "unfolding FOREACHi_def"], ["proof (prove)\nusing this:\n  set_iterator iterate s\n  RETURN (fi ?x ?\\<sigma>) \\<le> f ?x ?\\<sigma>\n\ngoal (1 subgoal):\n 1. RETURN (iterate (\\<lambda>_. True) fi \\<sigma>)\n    \\<le> FOREACH\\<^sub>C\\<^bsup>I\\<^esup> s (\\<lambda>_. True) f \\<sigma>", "by (rule transfer_FOREACHci_plain)"], ["", "lemma transfer_FOREACHc_plain[refine_transfer]:\n  assumes A: \"set_iterator iterate s\"\n  assumes R: \"\\<And>x \\<sigma>. RETURN (fi x \\<sigma>) \\<le> f x \\<sigma>\"\n  shows \"RETURN (iterate c fi \\<sigma>) \\<le> FOREACHc s c f \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN (iterate c fi \\<sigma>) \\<le> FOREACH\\<^sub>C s c f \\<sigma>", "using assms"], ["proof (prove)\nusing this:\n  set_iterator iterate s\n  RETURN (fi ?x ?\\<sigma>) \\<le> f ?x ?\\<sigma>\n\ngoal (1 subgoal):\n 1. RETURN (iterate c fi \\<sigma>) \\<le> FOREACH\\<^sub>C s c f \\<sigma>", "unfolding FOREACHc_def"], ["proof (prove)\nusing this:\n  set_iterator iterate s\n  RETURN (fi ?x ?\\<sigma>) \\<le> f ?x ?\\<sigma>\n\ngoal (1 subgoal):\n 1. RETURN (iterate c fi \\<sigma>)\n    \\<le> FOREACH\\<^sub>C\\<^bsup>\\<lambda>_ _. True\\<^esup> s c f \\<sigma>", "by (rule transfer_FOREACHci_plain)"], ["", "lemma transfer_FOREACH_plain[refine_transfer]:\n  assumes A: \"set_iterator iterate s\"\n  assumes R: \"\\<And>x \\<sigma>. RETURN (fi x \\<sigma>) \\<le> f x \\<sigma>\"\n  shows \"RETURN (iterate (\\<lambda>_. True) fi \\<sigma>) \\<le> FOREACH s f \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN (iterate (\\<lambda>_. True) fi \\<sigma>)\n    \\<le> FOREACH s f \\<sigma>", "using assms"], ["proof (prove)\nusing this:\n  set_iterator iterate s\n  RETURN (fi ?x ?\\<sigma>) \\<le> f ?x ?\\<sigma>\n\ngoal (1 subgoal):\n 1. RETURN (iterate (\\<lambda>_. True) fi \\<sigma>)\n    \\<le> FOREACH s f \\<sigma>", "unfolding FOREACH_def"], ["proof (prove)\nusing this:\n  set_iterator iterate s\n  RETURN (fi ?x ?\\<sigma>) \\<le> f ?x ?\\<sigma>\n\ngoal (1 subgoal):\n 1. RETURN (iterate (\\<lambda>_. True) fi \\<sigma>)\n    \\<le> FOREACH\\<^sub>C s (\\<lambda>_. True) f \\<sigma>", "by (rule transfer_FOREACHc_plain)"], ["", "abbreviation \"dres_it iterate c (fi::'a \\<Rightarrow> 'b \\<Rightarrow> 'b dres) \\<sigma> \\<equiv> \n  iterate (case_dres False False c) (\\<lambda>x s. s\\<bind>fi x) (dRETURN \\<sigma>)\""], ["", "lemma transfer_FOREACHoci_nres[refine_transfer]:\n  assumes A: \"set_iterator_genord iterate s ordR\"\n  assumes R: \"\\<And>x \\<sigma>. nres_of (fi x \\<sigma>) \\<le> f x \\<sigma>\"\n  shows \"nres_of (dres_it iterate c fi \\<sigma>) \\<le> FOREACHoci ordR I s c f \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nres_of\n     (iterate (case_dres False False c) (\\<lambda>x s. s \\<bind> fi x)\n       (dRETURN \\<sigma>))\n    \\<le> FOREACH\\<^sub>O\\<^sub>C\\<^bsup>ordR,I\\<^esup> s c f \\<sigma>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. nres_of\n     (iterate (case_dres False False c) (\\<lambda>x s. s \\<bind> fi x)\n       (dRETURN \\<sigma>))\n    \\<le> FOREACH\\<^sub>O\\<^sub>C\\<^bsup>ordR,I\\<^esup> s c f \\<sigma>", "from A"], ["proof (chain)\npicking this:\n  set_iterator_genord iterate s ordR", "obtain l where [simp]:\n    \"distinct l\" \n    \"s = set l\" \n    \"sorted_wrt ordR l\"\n    \"iterate = foldli l\""], ["proof (prove)\nusing this:\n  set_iterator_genord iterate s ordR\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>distinct l; s = set l; sorted_wrt ordR l;\n         iterate = foldli l\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding set_iterator_genord_def"], ["proof (prove)\nusing this:\n  \\<exists>l0.\n     distinct l0 \\<and>\n     s = set l0 \\<and> sorted_wrt ordR l0 \\<and> iterate = foldli l0\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>distinct l; s = set l; sorted_wrt ordR l;\n         iterate = foldli l\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  distinct l\n  s = set l\n  sorted_wrt ordR l\n  iterate = foldli l\n\ngoal (1 subgoal):\n 1. nres_of\n     (iterate (case_dres False False c) (\\<lambda>x s. s \\<bind> fi x)\n       (dRETURN \\<sigma>))\n    \\<le> FOREACH\\<^sub>O\\<^sub>C\\<^bsup>ordR,I\\<^esup> s c f \\<sigma>", "have \"nres_of (dres_it (foldli l) c fi \\<sigma>) \\<le> nfoldli l c f \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nres_of\n     (foldli l (case_dres False False c) (\\<lambda>x s. s \\<bind> fi x)\n       (dRETURN \\<sigma>))\n    \\<le> nfoldli l c f \\<sigma>", "by (rule nfoldli_transfer_dres[OF R])"], ["proof (state)\nthis:\n  nres_of\n   (foldli l (case_dres False False c) (\\<lambda>x s. s \\<bind> fi x)\n     (dRETURN \\<sigma>))\n  \\<le> nfoldli l c f \\<sigma>\n\ngoal (1 subgoal):\n 1. nres_of\n     (iterate (case_dres False False c) (\\<lambda>x s. s \\<bind> fi x)\n       (dRETURN \\<sigma>))\n    \\<le> FOREACH\\<^sub>O\\<^sub>C\\<^bsup>ordR,I\\<^esup> s c f \\<sigma>", "also"], ["proof (state)\nthis:\n  nres_of\n   (foldli l (case_dres False False c) (\\<lambda>x s. s \\<bind> fi x)\n     (dRETURN \\<sigma>))\n  \\<le> nfoldli l c f \\<sigma>\n\ngoal (1 subgoal):\n 1. nres_of\n     (iterate (case_dres False False c) (\\<lambda>x s. s \\<bind> fi x)\n       (dRETURN \\<sigma>))\n    \\<le> FOREACH\\<^sub>O\\<^sub>C\\<^bsup>ordR,I\\<^esup> s c f \\<sigma>", "have \"\\<dots> = do { l \\<leftarrow> RETURN l; nfoldli l c f \\<sigma> }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nfoldli l c f \\<sigma> =\n    RETURN l \\<bind> (\\<lambda>l. nfoldli l c f \\<sigma>)", "by simp"], ["proof (state)\nthis:\n  nfoldli l c f \\<sigma> =\n  RETURN l \\<bind> (\\<lambda>l. nfoldli l c f \\<sigma>)\n\ngoal (1 subgoal):\n 1. nres_of\n     (iterate (case_dres False False c) (\\<lambda>x s. s \\<bind> fi x)\n       (dRETURN \\<sigma>))\n    \\<le> FOREACH\\<^sub>O\\<^sub>C\\<^bsup>ordR,I\\<^esup> s c f \\<sigma>", "also"], ["proof (state)\nthis:\n  nfoldli l c f \\<sigma> =\n  RETURN l \\<bind> (\\<lambda>l. nfoldli l c f \\<sigma>)\n\ngoal (1 subgoal):\n 1. nres_of\n     (iterate (case_dres False False c) (\\<lambda>x s. s \\<bind> fi x)\n       (dRETURN \\<sigma>))\n    \\<le> FOREACH\\<^sub>O\\<^sub>C\\<^bsup>ordR,I\\<^esup> s c f \\<sigma>", "have \"\\<dots> \\<le> FOREACHoci ordR I s c f \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN l \\<bind> (\\<lambda>l. nfoldli l c f \\<sigma>)\n    \\<le> FOREACH\\<^sub>O\\<^sub>C\\<^bsup>ordR,I\\<^esup> s c f \\<sigma>", "apply (rule refine_IdD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN l \\<bind> (\\<lambda>l. nfoldli l c f \\<sigma>)\n    \\<le> \\<Down> Id\n           (FOREACH\\<^sub>O\\<^sub>C\\<^bsup>ordR,I\\<^esup> s c f \\<sigma>)", "unfolding FOREACHoci_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN l \\<bind> (\\<lambda>l. nfoldli l c f \\<sigma>)\n    \\<le> \\<Down> Id\n           (ASSERT (finite s) \\<bind>\n            (\\<lambda>_.\n                SPEC\n                 (\\<lambda>xs.\n                     distinct xs \\<and>\n                     s = set xs \\<and> sorted_wrt ordR xs) \\<bind>\n                (\\<lambda>xs.\n                    WHILE\\<^sub>T\\<^bsup>\\<lambda>(it, \\<sigma>).\n      \\<exists>xs'. xs = xs' @ it \\<and> I (set it) \\<sigma>\\<^esup>\n                     (FOREACH_cond c) (FOREACH_body f)\n                     (xs, \\<sigma>) \\<bind>\n                    (\\<lambda>(uu_, \\<sigma>). RETURN \\<sigma>))))", "apply refine_rcg"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite s \\<Longrightarrow>\n    RETURN l\n    \\<le> SPEC\n           (\\<lambda>xs.\n               distinct xs \\<and> s = set xs \\<and> sorted_wrt ordR xs)\n 2. \\<And>l xs.\n       \\<lbrakk>finite s; (l, xs) \\<in> Id;\n        xs \\<in> {xs.\n                  distinct xs \\<and>\n                  s = set xs \\<and> sorted_wrt ordR xs}\\<rbrakk>\n       \\<Longrightarrow> nfoldli l c f \\<sigma>\n                         \\<le> \\<Down> Id\n                                (WHILE\\<^sub>T\\<^bsup>\\<lambda>(it,\n                   \\<sigma>).\n                   \\<exists>xs'.\n                      xs = xs' @ it \\<and> I (set it) \\<sigma>\\<^esup>\n                                  (FOREACH_cond c) (FOREACH_body f)\n                                  (xs, \\<sigma>) \\<bind>\n                                 (\\<lambda>(uu_, \\<sigma>).\n                                     RETURN \\<sigma>))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l xs.\n       \\<lbrakk>finite s; (l, xs) \\<in> Id;\n        xs \\<in> {xs.\n                  distinct xs \\<and>\n                  s = set xs \\<and> sorted_wrt ordR xs}\\<rbrakk>\n       \\<Longrightarrow> nfoldli l c f \\<sigma>\n                         \\<le> \\<Down> Id\n                                (WHILE\\<^sub>T\\<^bsup>\\<lambda>(it,\n                   \\<sigma>).\n                   \\<exists>xs'.\n                      xs = xs' @ it \\<and> I (set it) \\<sigma>\\<^esup>\n                                  (FOREACH_cond c) (FOREACH_body f)\n                                  (xs, \\<sigma>) \\<bind>\n                                 (\\<lambda>(uu_, \\<sigma>).\n                                     RETURN \\<sigma>))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>la.\n       distinct la \\<and>\n       set l = set la \\<and> sorted_wrt ordR la \\<Longrightarrow>\n       nfoldli la c f \\<sigma>\n       \\<le> WHILE\\<^sub>T\\<^bsup>\\<lambda>(it, \\<sigma>).\n                                     (\\<exists>xs'. la = xs' @ it) \\<and>\n                                     I (set it) \\<sigma>\\<^esup>\n              (FOREACH_cond c) (FOREACH_body f) (la, \\<sigma>) \\<bind>\n             (\\<lambda>(uu_, y). RETURN y)", "apply (rule nfoldli_while)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  RETURN l \\<bind> (\\<lambda>l. nfoldli l c f \\<sigma>)\n  \\<le> FOREACH\\<^sub>O\\<^sub>C\\<^bsup>ordR,I\\<^esup> s c f \\<sigma>\n\ngoal (1 subgoal):\n 1. nres_of\n     (iterate (case_dres False False c) (\\<lambda>x s. s \\<bind> fi x)\n       (dRETURN \\<sigma>))\n    \\<le> FOREACH\\<^sub>O\\<^sub>C\\<^bsup>ordR,I\\<^esup> s c f \\<sigma>", "finally"], ["proof (chain)\npicking this:\n  nres_of\n   (foldli l (case_dres False False c) (\\<lambda>x s. s \\<bind> fi x)\n     (dRETURN \\<sigma>))\n  \\<le> FOREACH\\<^sub>O\\<^sub>C\\<^bsup>ordR,I\\<^esup> s c f \\<sigma>", "show ?thesis"], ["proof (prove)\nusing this:\n  nres_of\n   (foldli l (case_dres False False c) (\\<lambda>x s. s \\<bind> fi x)\n     (dRETURN \\<sigma>))\n  \\<le> FOREACH\\<^sub>O\\<^sub>C\\<^bsup>ordR,I\\<^esup> s c f \\<sigma>\n\ngoal (1 subgoal):\n 1. nres_of\n     (iterate (case_dres False False c) (\\<lambda>x s. s \\<bind> fi x)\n       (dRETURN \\<sigma>))\n    \\<le> FOREACH\\<^sub>O\\<^sub>C\\<^bsup>ordR,I\\<^esup> s c f \\<sigma>", "by simp"], ["proof (state)\nthis:\n  nres_of\n   (iterate (case_dres False False c) (\\<lambda>x s. s \\<bind> fi x)\n     (dRETURN \\<sigma>))\n  \\<le> FOREACH\\<^sub>O\\<^sub>C\\<^bsup>ordR,I\\<^esup> s c f \\<sigma>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma transfer_FOREACHoi_nres[refine_transfer]:\n  assumes A: \"set_iterator_genord iterate s ordR\"\n  assumes R: \"\\<And>x \\<sigma>. nres_of (fi x \\<sigma>) \\<le> f x \\<sigma>\"\n  shows \"nres_of (dres_it iterate (\\<lambda>_. True) fi \\<sigma>) \\<le> FOREACHoi ordR I s f \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nres_of\n     (iterate (case_dres False False (\\<lambda>_. True))\n       (\\<lambda>x s. s \\<bind> fi x) (dRETURN \\<sigma>))\n    \\<le> FOREACH\\<^sub>O\\<^bsup>ordR,I\\<^esup> s f \\<sigma>", "using assms"], ["proof (prove)\nusing this:\n  set_iterator_genord iterate s ordR\n  nres_of (fi ?x ?\\<sigma>) \\<le> f ?x ?\\<sigma>\n\ngoal (1 subgoal):\n 1. nres_of\n     (iterate (case_dres False False (\\<lambda>_. True))\n       (\\<lambda>x s. s \\<bind> fi x) (dRETURN \\<sigma>))\n    \\<le> FOREACH\\<^sub>O\\<^bsup>ordR,I\\<^esup> s f \\<sigma>", "unfolding FOREACHoi_def"], ["proof (prove)\nusing this:\n  set_iterator_genord iterate s ordR\n  nres_of (fi ?x ?\\<sigma>) \\<le> f ?x ?\\<sigma>\n\ngoal (1 subgoal):\n 1. nres_of\n     (iterate (case_dres False False (\\<lambda>_. True))\n       (\\<lambda>x s. s \\<bind> fi x) (dRETURN \\<sigma>))\n    \\<le> FOREACH\\<^sub>O\\<^sub>C\\<^bsup>ordR,I\\<^esup> s (\\<lambda>_. True)\n           f \\<sigma>", "by (rule transfer_FOREACHoci_nres)"], ["", "lemma transfer_FOREACHci_nres[refine_transfer]:\n  assumes A: \"set_iterator iterate s\"\n  assumes R: \"\\<And>x \\<sigma>. nres_of (fi x \\<sigma>) \\<le> f x \\<sigma>\"\n  shows \"nres_of (dres_it iterate c fi \\<sigma>) \\<le> FOREACHci I s c f \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nres_of\n     (iterate (case_dres False False c) (\\<lambda>x s. s \\<bind> fi x)\n       (dRETURN \\<sigma>))\n    \\<le> FOREACH\\<^sub>C\\<^bsup>I\\<^esup> s c f \\<sigma>", "using assms"], ["proof (prove)\nusing this:\n  set_iterator iterate s\n  nres_of (fi ?x ?\\<sigma>) \\<le> f ?x ?\\<sigma>\n\ngoal (1 subgoal):\n 1. nres_of\n     (iterate (case_dres False False c) (\\<lambda>x s. s \\<bind> fi x)\n       (dRETURN \\<sigma>))\n    \\<le> FOREACH\\<^sub>C\\<^bsup>I\\<^esup> s c f \\<sigma>", "unfolding FOREACHci_def set_iterator_def"], ["proof (prove)\nusing this:\n  set_iterator_genord iterate s (\\<lambda>_ _. True)\n  nres_of (fi ?x ?\\<sigma>) \\<le> f ?x ?\\<sigma>\n\ngoal (1 subgoal):\n 1. nres_of\n     (iterate (case_dres False False c) (\\<lambda>x s. s \\<bind> fi x)\n       (dRETURN \\<sigma>))\n    \\<le> FOREACH\\<^sub>O\\<^sub>C\\<^bsup>\\<lambda>_ _. True,I\\<^esup> s c f\n           \\<sigma>", "by (rule transfer_FOREACHoci_nres)"], ["", "lemma transfer_FOREACHi_nres[refine_transfer]:\n  assumes A: \"set_iterator iterate s\"\n  assumes R: \"\\<And>x \\<sigma>. nres_of (fi x \\<sigma>) \\<le> f x \\<sigma>\"\n  shows \"nres_of (dres_it iterate (\\<lambda>_. True) fi \\<sigma>) \\<le> FOREACHi I s f \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nres_of\n     (iterate (case_dres False False (\\<lambda>_. True))\n       (\\<lambda>x s. s \\<bind> fi x) (dRETURN \\<sigma>))\n    \\<le> FOREACH\\<^bsup>I\\<^esup> s f \\<sigma>", "using assms"], ["proof (prove)\nusing this:\n  set_iterator iterate s\n  nres_of (fi ?x ?\\<sigma>) \\<le> f ?x ?\\<sigma>\n\ngoal (1 subgoal):\n 1. nres_of\n     (iterate (case_dres False False (\\<lambda>_. True))\n       (\\<lambda>x s. s \\<bind> fi x) (dRETURN \\<sigma>))\n    \\<le> FOREACH\\<^bsup>I\\<^esup> s f \\<sigma>", "unfolding FOREACHi_def"], ["proof (prove)\nusing this:\n  set_iterator iterate s\n  nres_of (fi ?x ?\\<sigma>) \\<le> f ?x ?\\<sigma>\n\ngoal (1 subgoal):\n 1. nres_of\n     (iterate (case_dres False False (\\<lambda>_. True))\n       (\\<lambda>x s. s \\<bind> fi x) (dRETURN \\<sigma>))\n    \\<le> FOREACH\\<^sub>C\\<^bsup>I\\<^esup> s (\\<lambda>_. True) f \\<sigma>", "by (rule transfer_FOREACHci_nres)"], ["", "lemma transfer_FOREACHc_nres[refine_transfer]:\n  assumes A: \"set_iterator iterate s\"\n  assumes R: \"\\<And>x \\<sigma>. nres_of (fi x \\<sigma>) \\<le> f x \\<sigma>\"\n  shows \"nres_of (dres_it iterate c fi \\<sigma>) \\<le> FOREACHc s c f \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nres_of\n     (iterate (case_dres False False c) (\\<lambda>x s. s \\<bind> fi x)\n       (dRETURN \\<sigma>))\n    \\<le> FOREACH\\<^sub>C s c f \\<sigma>", "using assms"], ["proof (prove)\nusing this:\n  set_iterator iterate s\n  nres_of (fi ?x ?\\<sigma>) \\<le> f ?x ?\\<sigma>\n\ngoal (1 subgoal):\n 1. nres_of\n     (iterate (case_dres False False c) (\\<lambda>x s. s \\<bind> fi x)\n       (dRETURN \\<sigma>))\n    \\<le> FOREACH\\<^sub>C s c f \\<sigma>", "unfolding FOREACHc_def"], ["proof (prove)\nusing this:\n  set_iterator iterate s\n  nres_of (fi ?x ?\\<sigma>) \\<le> f ?x ?\\<sigma>\n\ngoal (1 subgoal):\n 1. nres_of\n     (iterate (case_dres False False c) (\\<lambda>x s. s \\<bind> fi x)\n       (dRETURN \\<sigma>))\n    \\<le> FOREACH\\<^sub>C\\<^bsup>\\<lambda>_ _. True\\<^esup> s c f \\<sigma>", "by (rule transfer_FOREACHci_nres)"], ["", "lemma transfer_FOREACH_nres[refine_transfer]:\n  assumes A: \"set_iterator iterate s\"\n  assumes R: \"\\<And>x \\<sigma>. nres_of (fi x \\<sigma>) \\<le> f x \\<sigma>\"\n  shows \"nres_of (dres_it iterate (\\<lambda>_. True) fi \\<sigma>) \\<le> FOREACH s f \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nres_of\n     (iterate (case_dres False False (\\<lambda>_. True))\n       (\\<lambda>x s. s \\<bind> fi x) (dRETURN \\<sigma>))\n    \\<le> FOREACH s f \\<sigma>", "using assms"], ["proof (prove)\nusing this:\n  set_iterator iterate s\n  nres_of (fi ?x ?\\<sigma>) \\<le> f ?x ?\\<sigma>\n\ngoal (1 subgoal):\n 1. nres_of\n     (iterate (case_dres False False (\\<lambda>_. True))\n       (\\<lambda>x s. s \\<bind> fi x) (dRETURN \\<sigma>))\n    \\<le> FOREACH s f \\<sigma>", "unfolding FOREACH_def"], ["proof (prove)\nusing this:\n  set_iterator iterate s\n  nres_of (fi ?x ?\\<sigma>) \\<le> f ?x ?\\<sigma>\n\ngoal (1 subgoal):\n 1. nres_of\n     (iterate (case_dres False False (\\<lambda>_. True))\n       (\\<lambda>x s. s \\<bind> fi x) (dRETURN \\<sigma>))\n    \\<le> FOREACH\\<^sub>C s (\\<lambda>_. True) f \\<sigma>", "by (rule transfer_FOREACHc_nres)"], ["", "(*\nlemma dres_ne_bot_iterate[refine_transfer]:\n  assumes B: \"set_iterator (IT_tag it r) S\"\n  assumes A: \"\\<And>x s. f x s \\<noteq> dSUCCEED\"\n  shows \"IT_tag it r c (\\<lambda>x s. dbind s (f x)) (dRETURN s) \\<noteq> dSUCCEED\"\n  apply (rule_tac I=\"\\<lambda>_ s. s\\<noteq>dSUCCEED\" in set_iterator_rule_P[OF B])\n  apply (rule dres_ne_bot_basic A | assumption)+\n  done\n*)\n\n(*\nsubsubsection {* Monotonicity for Iterators *}\n\nlemma it_mono_aux:\n  assumes COND: \"\\<And>\\<sigma> \\<sigma>'. \\<sigma>\\<le>\\<sigma>' \\<Longrightarrow> c \\<sigma> \\<noteq> c \\<sigma>' \\<Longrightarrow> \\<sigma>=bot \\<or> \\<sigma>'=top \"\n  assumes STRICT: \"\\<And>x. f x bot = bot\" \"\\<And>x. f' x top = top\"\n  assumes B: \"\\<sigma>\\<le>\\<sigma>'\"\n  assumes A: \"\\<And>a x x'. x\\<le>x' \\<Longrightarrow> f a x \\<le> f' a x'\"\n  shows \"foldli l c f \\<sigma> \\<le> foldli l c f' \\<sigma>'\"\nproof -\n  { fix l \n    have \"foldli l c f bot = bot\" by (induct l) (auto simp: STRICT)\n  } note [simp] = this\n  { fix l \n    have \"foldli l c f' top = top\" by (induct l) (auto simp: STRICT)\n  } note [simp] = this\n\n  show ?thesis\n    using B\n    apply (induct l arbitrary: \\<sigma> \\<sigma>')\n    apply simp_all\n    apply (metis assms foldli_not_cond)\n    done\nqed\n\n\nlemma it_mono_aux_dres':\n  assumes STRICT: \"\\<And>x. f x bot = bot\" \"\\<And>x. f' x top = top\"\n  assumes A: \"\\<And>a x x'. x\\<le>x' \\<Longrightarrow> f a x \\<le> f' a x'\"\n  shows \"foldli l (case_dres True True c) f \\<sigma> \n    \\<le> foldli l (case_dres True True c) f' \\<sigma>\"\n  apply (rule it_mono_aux)\n  apply (simp_all split: dres.split_asm add: STRICT A)\n  done\n\nlemma it_mono_aux_dres:\n  assumes A: \"\\<And>a x. f a x \\<le> f' a x\"\n  shows \"foldli l (case_dres True True c) (\\<lambda>x s. dbind s (f x)) \\<sigma> \n    \\<le> foldli l (case_dres True True c) (\\<lambda>x s. dbind s (f' x)) \\<sigma>\"\n  apply (rule it_mono_aux_dres')\n  apply (simp_all)\n  apply (rule dbind_mono)\n  apply (simp_all add: A)\n  done\n  \nlemma iteratei_mono':\n  assumes L: \"set_iteratei \\<alpha> invar it\"\n  assumes STRICT: \"\\<And>x. f x bot = bot\" \"\\<And>x. f' x top = top\"\n  assumes A: \"\\<And>a x x'. x\\<le>x' \\<Longrightarrow> f a x \\<le> f' a x'\"\n  assumes I: \"invar s\"\n  shows \"IT_tag it s (case_dres True True c) f \\<sigma> \n    \\<le> IT_tag it s (case_dres True True c) f' \\<sigma>\"\n  proof -\n    from set_iteratei.iteratei_rule[OF L, OF I, unfolded set_iterator_foldli_conv]\n    obtain l0 where l0_props: \"distinct l0\" \"\\<alpha> s = set l0\" \"it s = foldli l0\" by blast\n \n    from it_mono_aux_dres' [of f f' l0 c \\<sigma>]\n    show ?thesis\n      unfolding IT_tag_def l0_props(3)\n      by (simp add: STRICT A)\n  qed\n\nlemma iteratei_mono:\n  assumes L: \"set_iteratei \\<alpha> invar it\"\n  assumes A: \"\\<And>a x. f a x \\<le> f' a x\"\n  assumes I: \"invar s\"\n  shows \"IT_tag it s (case_dres True True c) (\\<lambda>x s. dbind s (f x)) \\<sigma> \n    \\<le> IT_tag it s (case_dres True True c) (\\<lambda>x s. dbind s (f' x)) \\<sigma>\"\n proof -\n    from set_iteratei.iteratei_rule[OF L, OF I, unfolded set_iterator_foldli_conv]\n    obtain l0 where l0_props: \"distinct l0\" \"\\<alpha> s = set l0\" \"it s = foldli l0\" by blast\n \n    from it_mono_aux_dres [of f f' l0 c \\<sigma>]\n    show ?thesis\n      unfolding IT_tag_def l0_props(3)\n      by (simp add: A)\n  qed\n\nlemmas [refine_mono] = iteratei_mono[OF ls_iteratei_impl]\nlemmas [refine_mono] = iteratei_mono[OF lsi_iteratei_impl]\nlemmas [refine_mono] = iteratei_mono[OF rs_iteratei_impl]\nlemmas [refine_mono] = iteratei_mono[OF ahs_iteratei_impl]\nlemmas [refine_mono] = iteratei_mono[OF ias_iteratei_impl]\nlemmas [refine_mono] = iteratei_mono[OF ts_iteratei_impl]\n*)\n(* Do not require the invariant for lsi_iteratei. \n\nThis is kind of a hack -- the real fix comes with the new Collection/Refinement-Framework. *)\n(*\nlemma dres_ne_bot_iterate_lsi[refine_transfer]:\n  fixes s :: \"'a\"\n  assumes A: \"\\<And>x s. f x s \\<noteq> dSUCCEED\"\n  shows \"IT_tag lsi_iteratei r c (\\<lambda>x s. dbind s (f x)) (dRETURN s) \\<noteq> dSUCCEED\"\nproof -\n  {\n    fix l and s :: \"'a dres\"\n    assume \"s\\<noteq>dSUCCEED\" \n    hence \"foldli l c (\\<lambda>x s. s\\<bind>f x) s \\<noteq> dSUCCEED\"\n      apply (induct l arbitrary: s)\n      using A\n      apply simp_all\n      apply (intro impI)\n      apply (metis dres_ne_bot_basic)\n      done\n  } note R=this\n  with A show ?thesis\n    unfolding lsi_iteratei_def\n    by simp\nqed\n\n\nlemma iteratei_mono_lsi[refine_mono]:\n  assumes A: \"\\<And>a x. f a x \\<le> f' a x\"\n  shows \"IT_tag lsi_iteratei s (case_dres True True c) (\\<lambda>x s. dbind s (f x)) \\<sigma> \n    \\<le> IT_tag lsi_iteratei s (case_dres True True c) (\\<lambda>x s. dbind s (f' x)) \\<sigma>\"\n proof -\n    from it_mono_aux_dres [of f f' s c \\<sigma>]\n    show ?thesis\n      unfolding IT_tag_def lsi_iteratei_def\n      by (simp add: A)\n qed\n*)"], ["", "end"]]}