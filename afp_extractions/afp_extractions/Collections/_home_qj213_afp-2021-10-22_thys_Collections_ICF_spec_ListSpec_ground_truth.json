{"file_name": "/home/qj213/afp-2021-10-22/thys/Collections/ICF/spec/ListSpec.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Collections", "problem_names": ["lemmas push_correct = appendl_correct", "lemma removelE: \n    assumes I: \"invar s\" \"\\<alpha> s \\<noteq> []\" \n    obtains s' where \"removel s = (hd (\\<alpha> s), s')\" \"invar s'\" \"\\<alpha> s' = tl (\\<alpha> s)\"", "lemmas pop_correct = removel_correct", "lemmas dequeue_correct = removel_correct", "lemmas top_correct = leftmost_correct", "lemmas enqueue_correct = appendr_correct", "lemmas bot_correct = rightmost_correct", "lemmas correct = \n    empty_correct\n    isEmpty_correct\n    size_correct\n    appendl_correct\n    removel_correct\n    leftmost_correct\n    appendr_correct\n    remover_correct\n    rightmost_correct\n    get_correct\n    set_correct"], "translations": [["", "lemmas push_correct = appendl_correct"], ["", "end"], ["", "locale list_removel = list +\n  constrains \\<alpha> :: \"'s \\<Rightarrow> 'x list\"\n  fixes removel :: \"'s \\<Rightarrow> ('x \\<times> 's)\"\n  assumes removel_correct:\n    \"\\<lbrakk>invar s; \\<alpha> s \\<noteq> []\\<rbrakk> \\<Longrightarrow> fst (removel s) = hd (\\<alpha> s)\"\n    \"\\<lbrakk>invar s; \\<alpha> s \\<noteq> []\\<rbrakk> \\<Longrightarrow> \\<alpha> (snd (removel s)) = tl (\\<alpha> s)\"\n    \"\\<lbrakk>invar s; \\<alpha> s \\<noteq> []\\<rbrakk> \\<Longrightarrow> invar (snd (removel s))\"\nbegin"], ["", "lemma removelE: \n    assumes I: \"invar s\" \"\\<alpha> s \\<noteq> []\" \n    obtains s' where \"removel s = (hd (\\<alpha> s), s')\" \"invar s'\" \"\\<alpha> s' = tl (\\<alpha> s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s'.\n        \\<lbrakk>removel s = (hd (\\<alpha> s), s'); invar s';\n         \\<alpha> s' = tl (\\<alpha> s)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>s'.\n        \\<lbrakk>removel s = (hd (\\<alpha> s), s'); invar s';\n         \\<alpha> s' = tl (\\<alpha> s)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from removel_correct(1,2,3)[OF I]"], ["proof (chain)\npicking this:\n  fst (removel s) = hd (\\<alpha> s)\n  \\<alpha> (snd (removel s)) = tl (\\<alpha> s)\n  invar (snd (removel s))", "have \n      C: \"fst (removel s) = hd (\\<alpha> s)\"\n         \"\\<alpha> (snd (removel s)) = tl (\\<alpha> s)\"\n         \"invar (snd (removel s))\""], ["proof (prove)\nusing this:\n  fst (removel s) = hd (\\<alpha> s)\n  \\<alpha> (snd (removel s)) = tl (\\<alpha> s)\n  invar (snd (removel s))\n\ngoal (1 subgoal):\n 1. fst (removel s) = hd (\\<alpha> s) &&&\n    \\<alpha> (snd (removel s)) = tl (\\<alpha> s) &&& invar (snd (removel s))", "."], ["proof (state)\nthis:\n  fst (removel s) = hd (\\<alpha> s)\n  \\<alpha> (snd (removel s)) = tl (\\<alpha> s)\n  invar (snd (removel s))\n\ngoal (1 subgoal):\n 1. (\\<And>s'.\n        \\<lbrakk>removel s = (hd (\\<alpha> s), s'); invar s';\n         \\<alpha> s' = tl (\\<alpha> s)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from that[of \"snd (removel s)\", OF _ C(3,2), folded C(1)]"], ["proof (chain)\npicking this:\n  removel s = (fst (removel s), snd (removel s)) \\<Longrightarrow> thesis", "show thesis"], ["proof (prove)\nusing this:\n  removel s = (fst (removel s), snd (removel s)) \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by simp"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The following shortcut notations are not meant for generating efficient code,\n    but solely to simplify reasoning\\<close>"], ["", "(* TODO: Is this actually used somewhere ? *)\n  (*\n  definition \"head s == fst (removef s)\"\n  definition \"tail s == snd (removef s)\"\n\n  lemma tail_correct: \"\\<lbrakk>invar F; \\<alpha> F \\<noteq> []\\<rbrakk> \\<Longrightarrow> \\<alpha> (tail F) = tl (\\<alpha> F)\"\n    by (simp add: tail_def removef_correct)\n\n  lemma head_correct: \"\\<lbrakk>invar F; \\<alpha> F \\<noteq> []\\<rbrakk> \\<Longrightarrow> (head F) = hd (\\<alpha> F)\"\n    by (simp add: head_def removef_correct)\n\n  lemma removef_split: \"removef F = (head F, tail F)\"\n    apply (cases \"removef F\")\n    apply (simp add: head_def tail_def)\n    done\n    *)"], ["", "abbreviation (input) \"pop \\<equiv> removel\""], ["", "lemmas pop_correct = removel_correct"], ["", "abbreviation (input) \"dequeue \\<equiv> removel\""], ["", "lemmas dequeue_correct = removel_correct"], ["", "end"], ["", "locale list_leftmost = list +\n  constrains \\<alpha> :: \"'s \\<Rightarrow> 'x list\"\n  fixes leftmost :: \"'s \\<Rightarrow> 'x\"\n  assumes leftmost_correct:\n    \"\\<lbrakk>invar s; \\<alpha> s \\<noteq> []\\<rbrakk> \\<Longrightarrow> leftmost s = hd (\\<alpha> s)\"\nbegin"], ["", "abbreviation (input) top where \"top \\<equiv> leftmost\""], ["", "lemmas top_correct = leftmost_correct"], ["", "end"], ["", "locale list_appendr = list +\n  constrains \\<alpha> :: \"'s \\<Rightarrow> 'x list\"\n  fixes appendr :: \"'x \\<Rightarrow> 's \\<Rightarrow> 's\"\n  assumes appendr_correct: \n    \"invar s \\<Longrightarrow> \\<alpha> (appendr x s) = \\<alpha> s @ [x]\"\n    \"invar s \\<Longrightarrow> invar (appendr x s)\"\nbegin"], ["", "abbreviation (input) \"enqueue \\<equiv> appendr\""], ["", "lemmas enqueue_correct = appendr_correct"], ["", "end"], ["", "locale list_remover = list +\n  constrains \\<alpha> :: \"'s \\<Rightarrow> 'x list\"\n  fixes remover :: \"'s \\<Rightarrow> 's \\<times> 'x\"\n  assumes remover_correct: \n    \"\\<lbrakk>invar s; \\<alpha> s \\<noteq> []\\<rbrakk> \\<Longrightarrow> \\<alpha> (fst (remover s)) = butlast (\\<alpha> s)\"\n    \"\\<lbrakk>invar s; \\<alpha> s \\<noteq> []\\<rbrakk> \\<Longrightarrow> snd (remover s) = last (\\<alpha> s)\"\n    \"\\<lbrakk>invar s; \\<alpha> s \\<noteq> []\\<rbrakk> \\<Longrightarrow> invar (fst (remover s))\""], ["", "locale list_rightmost = list +\n  constrains \\<alpha> :: \"'s \\<Rightarrow> 'x list\"\n  fixes rightmost :: \"'s \\<Rightarrow> 'x\"\n  assumes rightmost_correct:\n    \"\\<lbrakk>invar s; \\<alpha> s \\<noteq> []\\<rbrakk> \\<Longrightarrow> rightmost s = List.last (\\<alpha> s)\"\nbegin"], ["", "abbreviation (input) bot where \"bot \\<equiv> rightmost\""], ["", "lemmas bot_correct = rightmost_correct"], ["", "end"], ["", "subsubsection \"Indexing\""], ["", "locale list_get = list +\n  constrains \\<alpha> :: \"'s \\<Rightarrow> 'x list\"\n  fixes get :: \"'s \\<Rightarrow> nat \\<Rightarrow> 'x\"\n  assumes get_correct:\n    \"\\<lbrakk>invar s; i<length (\\<alpha> s)\\<rbrakk> \\<Longrightarrow> get s i = \\<alpha> s ! i\""], ["", "locale list_set = list +\n  constrains \\<alpha> :: \"'s \\<Rightarrow> 'x list\"\n  fixes set :: \"'s \\<Rightarrow> nat \\<Rightarrow> 'x \\<Rightarrow> 's\"\n  assumes set_correct:\n    \"\\<lbrakk>invar s; i<length (\\<alpha> s)\\<rbrakk> \\<Longrightarrow> \\<alpha> (set s i x) = (\\<alpha> s) [i := x]\"\n    \"\\<lbrakk>invar s; i<length (\\<alpha> s)\\<rbrakk> \\<Longrightarrow> invar (set s i x)\""], ["", "record ('a,'s) list_ops = \n  list_op_\\<alpha> :: \"'s \\<Rightarrow> 'a list\"\n  list_op_invar :: \"'s \\<Rightarrow> bool\"\n  list_op_empty :: \"unit \\<Rightarrow> 's\"\n  list_op_isEmpty :: \"'s \\<Rightarrow> bool\"\n  list_op_size :: \"'s \\<Rightarrow> nat\"\n  list_op_appendl :: \"'a \\<Rightarrow> 's \\<Rightarrow> 's\"\n  list_op_removel :: \"'s \\<Rightarrow> 'a \\<times> 's\"\n  list_op_leftmost :: \"'s \\<Rightarrow> 'a\"\n  list_op_appendr :: \"'a \\<Rightarrow> 's \\<Rightarrow> 's\"\n  list_op_remover :: \"'s \\<Rightarrow> 's \\<times> 'a\"\n  list_op_rightmost :: \"'s \\<Rightarrow> 'a\"\n  list_op_get :: \"'s \\<Rightarrow> nat \\<Rightarrow> 'a\"\n  list_op_set :: \"'s \\<Rightarrow> nat \\<Rightarrow> 'a \\<Rightarrow> 's\""], ["", "locale StdListDefs = \n  poly_list_iteratei \"list_op_\\<alpha> ops\" \"list_op_invar ops\"\n  + poly_list_rev_iteratei \"list_op_\\<alpha> ops\" \"list_op_invar ops\"\n  for ops :: \"('a,'s,'more) list_ops_scheme\"\nbegin"], ["", "abbreviation \\<alpha> where \"\\<alpha> \\<equiv> list_op_\\<alpha> ops\""], ["", "abbreviation invar where \"invar \\<equiv> list_op_invar ops\""], ["", "abbreviation empty where \"empty \\<equiv> list_op_empty ops\""], ["", "abbreviation isEmpty where \"isEmpty \\<equiv> list_op_isEmpty ops\""], ["", "abbreviation size where \"size \\<equiv> list_op_size ops\""], ["", "abbreviation appendl where \"appendl \\<equiv> list_op_appendl ops\""], ["", "abbreviation removel where \"removel \\<equiv> list_op_removel ops\""], ["", "abbreviation leftmost where \"leftmost \\<equiv> list_op_leftmost ops\""], ["", "abbreviation appendr where \"appendr \\<equiv> list_op_appendr ops\""], ["", "abbreviation remover where \"remover \\<equiv> list_op_remover ops\""], ["", "abbreviation rightmost where \"rightmost \\<equiv> list_op_rightmost ops\""], ["", "abbreviation get where \"get \\<equiv> list_op_get ops\""], ["", "abbreviation set where \"set \\<equiv> list_op_set ops\""], ["", "end"], ["", "locale StdList = StdListDefs ops\n  + list \\<alpha> invar\n  + list_empty \\<alpha> invar empty \n  + list_isEmpty \\<alpha> invar isEmpty \n  + list_size \\<alpha> invar size \n  + list_appendl \\<alpha> invar appendl \n  + list_removel \\<alpha> invar removel \n  + list_leftmost \\<alpha> invar leftmost \n  + list_appendr \\<alpha> invar appendr \n  + list_remover \\<alpha> invar remover \n  + list_rightmost \\<alpha> invar rightmost \n  + list_get \\<alpha> invar get \n  + list_set \\<alpha> invar set \n  for ops :: \"('a,'s,'more) list_ops_scheme\"\nbegin"], ["", "lemmas correct = \n    empty_correct\n    isEmpty_correct\n    size_correct\n    appendl_correct\n    removel_correct\n    leftmost_correct\n    appendr_correct\n    remover_correct\n    rightmost_correct\n    get_correct\n    set_correct"], ["", "end"], ["", "locale StdList_no_invar = StdList + list_no_invar \\<alpha> invar"], ["", "end"]]}