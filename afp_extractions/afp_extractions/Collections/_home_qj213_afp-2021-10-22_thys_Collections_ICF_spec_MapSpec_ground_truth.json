{"file_name": "/home/qj213/afp-2021-10-22/thys/Collections/ICF/spec/MapSpec.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Collections", "problem_names": ["lemma isSng_correct_exists1 :\n    \"invar s \\<Longrightarrow> (isSng s \\<longleftrightarrow> (\\<exists>!k. \\<exists>v. (\\<alpha> s k = Some v)))\"", "lemma isSng_correct_card :\n    \"invar s \\<Longrightarrow> (isSng s \\<longleftrightarrow> (card (dom (\\<alpha> s)) = 1))\"", "lemma iteratei_correct: \"invar S \\<Longrightarrow> map_iterator (iteratei S) (\\<alpha> S)\"", "lemma pi_iteratei[icf_proper_iteratorI]: \n    \"proper_it (iteratei S) (iteratei S)\"", "lemma iteratei_rule_P:\n    assumes \"invar m\"\n    and I0: \"I (map_to_set (\\<alpha> m)) \\<sigma>0\"\n    and IP: \"!!k v it \\<sigma>. \\<lbrakk> c \\<sigma>; (k,v) \\<in> it; it \\<subseteq> map_to_set (\\<alpha> m); I it \\<sigma> \\<rbrakk> \n      \\<Longrightarrow> I (it - {(k,v)}) (f (k, v) \\<sigma>)\"\n    and IF: \"!!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n    and II: \"!!\\<sigma> it. \\<lbrakk> it \\<subseteq> map_to_set (\\<alpha> m); it \\<noteq> {}; \\<not> c \\<sigma>; I it \\<sigma> \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n    shows \"P (iteratei m c f \\<sigma>0)\"", "lemma iteratei_rule_insert_P:\n    assumes \"invar m\" \n    and \"I {} \\<sigma>0\"\n    and \"!!k v it \\<sigma>. \\<lbrakk> c \\<sigma>; (k,v) \\<in> (map_to_set (\\<alpha> m) - it); \n                       it \\<subseteq> map_to_set (\\<alpha> m); I it \\<sigma> \\<rbrakk> \n      \\<Longrightarrow> I (insert (k,v) it) (f (k, v) \\<sigma>)\"\n    and \"!!\\<sigma>. I (map_to_set (\\<alpha> m)) \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n    and \"!!\\<sigma> it. \\<lbrakk> it \\<subseteq> map_to_set (\\<alpha> m); it \\<noteq> map_to_set (\\<alpha> m); \n                  \\<not> (c \\<sigma>); \n                  I it \\<sigma> \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n    shows \"P (iteratei m c f \\<sigma>0)\"", "lemma iterate_rule_P:\n    assumes \"invar m\"\n    and I0: \"I (map_to_set (\\<alpha> m)) \\<sigma>0\"\n    and IP: \"!!k v it \\<sigma>. \\<lbrakk> (k,v) \\<in> it; it \\<subseteq> map_to_set (\\<alpha> m); I it \\<sigma> \\<rbrakk> \n      \\<Longrightarrow> I (it - {(k,v)}) (f (k, v) \\<sigma>)\"\n    and IF: \"!!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n    shows \"P (iterate m f \\<sigma>0)\"", "lemma iterate_rule_insert_P:\n    assumes \"invar m\" \n    and I0: \"I {} \\<sigma>0\"\n    and \"!!k v it \\<sigma>. \\<lbrakk> (k,v) \\<in> (map_to_set (\\<alpha> m) - it); \n                       it \\<subseteq> map_to_set (\\<alpha> m); I it \\<sigma> \\<rbrakk> \n      \\<Longrightarrow> I (insert (k,v) it) (f (k, v) \\<sigma>)\"\n    and \"!!\\<sigma>. I (map_to_set (\\<alpha> m)) \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n    shows \"P (iterate m f \\<sigma>0)\"", "lemma old_iteratei_rule_P:\n    assumes \"invar m\"\n    and I0: \"I (dom (\\<alpha> m)) \\<sigma>0\"\n    and IP: \"!!k v it \\<sigma>. \\<lbrakk> c \\<sigma>; k \\<in> it; \\<alpha> m k = Some v; it \\<subseteq> dom (\\<alpha> m); I it \\<sigma> \\<rbrakk> \n      \\<Longrightarrow> I (it - {k}) (f (k, v) \\<sigma>)\"\n    and IF: \"!!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n    and II: \"!!\\<sigma> it. \\<lbrakk> it \\<subseteq> dom (\\<alpha> m); it \\<noteq> {}; \\<not> c \\<sigma>; I it \\<sigma> \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n    shows \"P (iteratei m c f \\<sigma>0)\"", "lemma old_iteratei_rule_insert_P:\n    assumes \"invar m\" \n    and \"I {} \\<sigma>0\"\n    and \"!!k v it \\<sigma>. \\<lbrakk> c \\<sigma>; k \\<in> (dom (\\<alpha> m) - it); \\<alpha> m k = Some v; \n                       it \\<subseteq> dom (\\<alpha> m); I it \\<sigma> \\<rbrakk> \n      \\<Longrightarrow> I (insert k it) (f (k, v) \\<sigma>)\"\n    and \"!!\\<sigma>. I (dom (\\<alpha> m)) \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n    and \"!!\\<sigma> it. \\<lbrakk> it \\<subseteq> dom (\\<alpha> m); it \\<noteq> dom (\\<alpha> m); \n                  \\<not> (c \\<sigma>); \n                  I it \\<sigma> \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n    shows \"P (iteratei m c f \\<sigma>0)\"", "lemma old_iterate_rule_P:\n    \"\\<lbrakk>\n      invar m;\n      I (dom (\\<alpha> m)) \\<sigma>0;\n      !!k v it \\<sigma>. \\<lbrakk> k \\<in> it; \\<alpha> m k = Some v; it \\<subseteq> dom (\\<alpha> m); I it \\<sigma> \\<rbrakk> \n                  \\<Longrightarrow> I (it - {k}) (f (k, v) \\<sigma>);\n      !!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\n    \\<rbrakk> \\<Longrightarrow> P (iterate m f \\<sigma>0)\"", "lemma old_iterate_rule_insert_P:\n    \"\\<lbrakk>\n      invar m;\n      I {} \\<sigma>0;\n      !!k v it \\<sigma>. \\<lbrakk> k \\<in> (dom (\\<alpha> m) - it); \\<alpha> m k = Some v; \n                    it \\<subseteq> dom (\\<alpha> m); I it \\<sigma> \\<rbrakk> \n                  \\<Longrightarrow> I (insert k it) (f (k, v) \\<sigma>);\n      !!\\<sigma>. I (dom (\\<alpha> m)) \\<sigma> \\<Longrightarrow> P \\<sigma>\n    \\<rbrakk> \\<Longrightarrow> P (iteratei m (\\<lambda>_. True) f \\<sigma>0)\"", "lemma sel_someE: \n    \"\\<lbrakk> invar m; sel m f = Some r; \n       !!u v. \\<lbrakk> \\<alpha> m u = Some v; f (u, v) = Some r \\<rbrakk> \\<Longrightarrow> P\n     \\<rbrakk> \\<Longrightarrow> P\"", "lemma sel_noneD: \"\\<lbrakk>invar m; sel m f = None; \\<alpha> m u = Some v\\<rbrakk> \\<Longrightarrow> f (u, v) = None\"", "lemma map_sel_altI:\n  assumes S1: \n    \"!!s f r P. \\<lbrakk> invar s; sel s f = Some r; \n                  !!u v. \\<lbrakk>\\<alpha> s u = Some v; f (u, v) = Some r\\<rbrakk> \\<Longrightarrow> P\n                \\<rbrakk> \\<Longrightarrow> P\"\n  assumes S2: \n    \"!!s f u v. \\<lbrakk>invar s; sel s f = None; \\<alpha> s u = Some v\\<rbrakk> \\<Longrightarrow> f (u, v) = None\"\n  shows \"map_sel \\<alpha> invar sel\"", "lemma sel'_someE: \n    \"\\<lbrakk> invar m; sel' m P = Some (u,v); \n       !!u v. \\<lbrakk> \\<alpha> m u = Some v; P (u, v) \\<rbrakk> \\<Longrightarrow> thesis\n     \\<rbrakk> \\<Longrightarrow> thesis\"", "lemma sel'_noneD: \"\\<lbrakk>invar m; sel' m P = None; \\<alpha> m u = Some v\\<rbrakk> \\<Longrightarrow> \\<not> P (u, v)\"", "lemma sel'_SomeD:\n    \"\\<lbrakk> sel' m P = Some (u, v); invar m \\<rbrakk> \\<Longrightarrow> \\<alpha> m u = Some v \\<and> P (u, v)\"", "lemma map_image_filter_correct_aux2 :\n    assumes \"invar1 m\" \n      and \"transforms_to_unique_keys (\\<alpha>1 m) f\"\n    shows \"(\\<alpha>2 (map_image_filter f m) k' = None) \\<longleftrightarrow>\n      (\\<forall>k v v'. \\<alpha>1 m k = Some v \\<longrightarrow> f (k, v) \\<noteq> Some (k', v'))\"", "lemmas map_image_filter_correct = \n     conjunct1 [OF map_image_filter_correct_aux1] \n     conjunct2 [OF map_image_filter_correct_aux1] \n     map_image_filter_correct_aux2", "lemmas map_value_image_filter_correct =\n    conjunct1[OF map_value_image_filter_correct_aux]\n    conjunct2[OF map_value_image_filter_correct_aux]", "lemma map_value_image_filter_correct_alt :\n    \"invar1 m \\<Longrightarrow> \n     invar2 (map_value_image_filter f m)\"\n    \"invar1 m \\<Longrightarrow>\n     (\\<alpha>2 (map_value_image_filter f m) k = Some v') \\<longleftrightarrow>\n     (\\<exists>v. (\\<alpha>1 m k = Some v) \\<and> f k v = Some v')\"\n    \"invar1 m \\<Longrightarrow>\n     (\\<alpha>2 (map_value_image_filter f m) k = None) \\<longleftrightarrow>\n     (\\<forall>v. (\\<alpha>1 m k = Some v) --> f k v = None)\"", "lemma restrict_correct_aux2 :\n    \"invar1 m \\<Longrightarrow> \\<alpha>2 (restrict (\\<lambda>(k,_). P k) m) = \\<alpha>1 m |` {k. P k}\"", "lemmas restrict_correct = \n     restrict_correct_aux1\n     restrict_correct_aux2", "lemma iterateoi_correct: \"invar S \\<Longrightarrow> map_iterator_linord (iterateoi S) (\\<alpha> S)\"", "lemma pi_iterateoi[icf_proper_iteratorI]: \n    \"proper_it (iterateoi S) (iterateoi S)\"", "lemma iterateoi_rule_P[case_names minv inv0 inv_pres i_complete i_inter]:\n    assumes MINV: \"invar m\"\n    assumes I0: \"I (dom (\\<alpha> m)) \\<sigma>0\"\n    assumes IP: \"!!k v it \\<sigma>. \\<lbrakk> \n      c \\<sigma>; \n      k \\<in> it; \n      \\<alpha> m k = Some v; \n      it \\<subseteq> dom (\\<alpha> m); \n      I it \\<sigma>;\n      \\<And>j. j\\<in>it \\<Longrightarrow> k\\<le>j; \n      \\<And>j. j\\<in>dom (\\<alpha> m) - it \\<Longrightarrow> j\\<le>k\n    \\<rbrakk> \\<Longrightarrow> I (it - {k}) (f (k, v) \\<sigma>)\"\n    assumes IF: \"!!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n    assumes II: \"!!\\<sigma> it. \\<lbrakk> \n      it \\<subseteq> dom (\\<alpha> m); \n      it \\<noteq> {}; \n      \\<not> c \\<sigma>; \n      I it \\<sigma>; \n      \\<And>k j. \\<lbrakk>k\\<in>it; j\\<in>dom (\\<alpha> m) - it\\<rbrakk> \\<Longrightarrow> j\\<le>k \n    \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n    shows \"P (iterateoi m c f \\<sigma>0)\"", "lemma iterateo_rule_P[case_names minv inv0 inv_pres i_complete]: \n    assumes MINV: \"invar m\"\n    assumes I0: \"I (dom (\\<alpha> m)) \\<sigma>0\"\n    assumes IP: \"!!k v it \\<sigma>. \\<lbrakk> \n      k \\<in> it; \n      \\<alpha> m k = Some v; \n      it \\<subseteq> dom (\\<alpha> m); \n      I it \\<sigma>;\n      \\<And>j. j\\<in>it \\<Longrightarrow> k\\<le>j; \n      \\<And>j. j\\<in>dom (\\<alpha> m) - it \\<Longrightarrow> j\\<le>k\n    \\<rbrakk> \\<Longrightarrow> I (it - {k}) (f (k, v) \\<sigma>)\"\n    assumes IF: \"!!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n    shows \"P (iterateo m f \\<sigma>0)\"", "lemma rev_iterateoi_correct: \n    \"invar S \\<Longrightarrow> map_iterator_rev_linord (rev_iterateoi S) (\\<alpha> S)\"", "lemma pi_rev_iterateoi[icf_proper_iteratorI]: \n    \"proper_it (rev_iterateoi S) (rev_iterateoi S)\"", "lemma rev_iterateoi_rule_P[case_names minv inv0 inv_pres i_complete i_inter]:\n    assumes MINV: \"invar m\"\n    assumes I0: \"I (dom (\\<alpha> m)) \\<sigma>0\"\n    assumes IP: \"!!k v it \\<sigma>. \\<lbrakk> \n      c \\<sigma>; \n      k \\<in> it; \n      \\<alpha> m k = Some v; \n      it \\<subseteq> dom (\\<alpha> m); \n      I it \\<sigma>;\n      \\<And>j. j\\<in>it \\<Longrightarrow> k\\<ge>j; \n      \\<And>j. j\\<in>dom (\\<alpha> m) - it \\<Longrightarrow> j\\<ge>k\n    \\<rbrakk> \\<Longrightarrow> I (it - {k}) (f (k, v) \\<sigma>)\"\n    assumes IF: \"!!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n    assumes II: \"!!\\<sigma> it. \\<lbrakk> \n      it \\<subseteq> dom (\\<alpha> m); \n      it \\<noteq> {}; \n      \\<not> c \\<sigma>; \n      I it \\<sigma>; \n      \\<And>k j. \\<lbrakk>k\\<in>it; j\\<in>dom (\\<alpha> m) - it\\<rbrakk> \\<Longrightarrow> j\\<ge>k \n    \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n    shows \"P (rev_iterateoi m c f \\<sigma>0)\"", "lemma rev_iterateo_rule_P[case_names minv inv0 inv_pres i_complete]: \n    assumes MINV: \"invar m\"\n    assumes I0: \"I (dom (\\<alpha> m)) \\<sigma>0\"\n    assumes IP: \"!!k v it \\<sigma>. \\<lbrakk> \n      k \\<in> it; \n      \\<alpha> m k = Some v; \n      it \\<subseteq> dom (\\<alpha> m); \n      I it \\<sigma>;\n      \\<And>j. j\\<in>it \\<Longrightarrow> k\\<ge>j; \n      \\<And>j. j\\<in>dom (\\<alpha> m) - it \\<Longrightarrow> j\\<ge>k\n    \\<rbrakk> \\<Longrightarrow> I (it - {k}) (f (k, v) \\<sigma>)\"\n    assumes IF: \"!!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n    shows \"P (rev_iterateo m f \\<sigma>0)\"", "lemma minE: \n     assumes A: \"invar s\" \"rel_of (\\<alpha> s) P \\<noteq> {}\"\n     obtains k v where\n     \"min s P = Some (k,v)\" \"(k,v)\\<in>rel_of (\\<alpha> s) P\" \"\\<forall>(k',v')\\<in>rel_of (\\<alpha> s) P. k \\<le> k'\"", "lemmas minI = min_correct(3)", "lemma min_Some:\n     \"\\<lbrakk> invar s; min s P = Some (k,v) \\<rbrakk> \\<Longrightarrow> (k,v)\\<in>rel_of (\\<alpha> s) P\"\n     \"\\<lbrakk> invar s; min s P = Some (k,v); (k',v')\\<in>rel_of (\\<alpha> s) P \\<rbrakk> \\<Longrightarrow> k\\<le>k'\"", "lemma min_None:\n     \"\\<lbrakk> invar s; min s P = None \\<rbrakk> \\<Longrightarrow> rel_of (\\<alpha> s) P = {}\"", "lemma maxE: \n     assumes A: \"invar s\" \"rel_of (\\<alpha> s) P \\<noteq> {}\"\n     obtains k v where\n     \"max s P = Some (k,v)\" \"(k,v)\\<in>rel_of (\\<alpha> s) P\" \"\\<forall>(k',v')\\<in>rel_of (\\<alpha> s) P. k \\<ge> k'\"", "lemmas maxI = max_correct(3)", "lemma max_Some:\n     \"\\<lbrakk> invar s; max s P = Some (k,v) \\<rbrakk> \\<Longrightarrow> (k,v)\\<in>rel_of (\\<alpha> s) P\"\n     \"\\<lbrakk> invar s; max s P = Some (k,v); (k',v')\\<in>rel_of (\\<alpha> s) P \\<rbrakk> \\<Longrightarrow> k\\<ge>k'\"", "lemma max_None:\n     \"\\<lbrakk> invar s; max s P = None \\<rbrakk> \\<Longrightarrow> rel_of (\\<alpha> s) P = {}\"", "lemmas correct =\n      empty_correct\n      sng_correct\n      lookup_correct\n      update_correct\n      update_dj_correct\n      delete_correct\n      restrict_correct\n      add_correct\n      add_dj_correct\n      isEmpty_correct\n      isSng_correct\n      ball_correct\n      bex_correct\n      size_correct\n      size_abort_correct\n      to_list_correct\n      to_map_correct", "lemmas StdMap_intro = StdMap.intro[rem_dup_prems]", "lemmas StdOMap_intro = \n    StdOMap.intro[OF StdMap_intro, rem_dup_prems]"], "translations": [["", "lemma isSng_correct_exists1 :\n    \"invar s \\<Longrightarrow> (isSng s \\<longleftrightarrow> (\\<exists>!k. \\<exists>v. (\\<alpha> s k = Some v)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar s \\<Longrightarrow>\n    isSng s = (\\<exists>!k. \\<exists>v. \\<alpha> s k = Some v)", "apply (auto simp add: isSng_correct split: if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k v.\n       \\<lbrakk>invar s;\n        \\<forall>y y'.\n           (\\<exists>v. \\<alpha> s y = Some v) \\<and>\n           (\\<exists>v. \\<alpha> s y' = Some v) \\<longrightarrow>\n           y = y';\n        \\<alpha> s k = Some v\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k v. \\<alpha> s = [k \\<mapsto> v]", "apply (rule_tac x=k in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k v.\n       \\<lbrakk>invar s;\n        \\<forall>y y'.\n           (\\<exists>v. \\<alpha> s y = Some v) \\<and>\n           (\\<exists>v. \\<alpha> s y' = Some v) \\<longrightarrow>\n           y = y';\n        \\<alpha> s k = Some v\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v. \\<alpha> s = [k \\<mapsto> v]", "apply (rule_tac x=v in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k v.\n       \\<lbrakk>invar s;\n        \\<forall>y y'.\n           (\\<exists>v. \\<alpha> s y = Some v) \\<and>\n           (\\<exists>v. \\<alpha> s y' = Some v) \\<longrightarrow>\n           y = y';\n        \\<alpha> s k = Some v\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> s = [k \\<mapsto> v]", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k v x.\n       \\<lbrakk>invar s;\n        \\<forall>y y'.\n           (\\<exists>v. \\<alpha> s y = Some v) \\<and>\n           (\\<exists>v. \\<alpha> s y' = Some v) \\<longrightarrow>\n           y = y';\n        \\<alpha> s k = Some v\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> s x = [k \\<mapsto> v] x", "apply (case_tac \"\\<alpha> s x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>k v x.\n       \\<lbrakk>invar s;\n        \\<forall>y y'.\n           (\\<exists>v. \\<alpha> s y = Some v) \\<and>\n           (\\<exists>v. \\<alpha> s y' = Some v) \\<longrightarrow>\n           y = y';\n        \\<alpha> s k = Some v; \\<alpha> s x = None\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> s x = [k \\<mapsto> v] x\n 2. \\<And>k v x a.\n       \\<lbrakk>invar s;\n        \\<forall>y y'.\n           (\\<exists>v. \\<alpha> s y = Some v) \\<and>\n           (\\<exists>v. \\<alpha> s y' = Some v) \\<longrightarrow>\n           y = y';\n        \\<alpha> s k = Some v; \\<alpha> s x = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> s x = [k \\<mapsto> v] x", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k v x a.\n       \\<lbrakk>invar s;\n        \\<forall>y y'.\n           (\\<exists>v. \\<alpha> s y = Some v) \\<and>\n           (\\<exists>v. \\<alpha> s y' = Some v) \\<longrightarrow>\n           y = y';\n        \\<alpha> s k = Some v; \\<alpha> s x = Some a\\<rbrakk>\n       \\<Longrightarrow> a = v", "apply force"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma isSng_correct_card :\n    \"invar s \\<Longrightarrow> (isSng s \\<longleftrightarrow> (card (dom (\\<alpha> s)) = 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar s \\<Longrightarrow> isSng s = (card (dom (\\<alpha> s)) = 1)", "by (auto simp add: isSng_correct card_Suc_eq dom_eq_singleton_conv)"], ["", "end"], ["", "subsubsection \"Finite Maps\""], ["", "locale finite_map = map +\n  assumes finite[simp, intro!]: \"invar m \\<Longrightarrow> finite (dom (\\<alpha> m))\""], ["", "subsubsection \"Size\""], ["", "type_synonym ('k,'v,'s) map_size = \"'s \\<Rightarrow> nat\""], ["", "locale map_size = finite_map +\n  constrains \\<alpha> :: \"'s \\<Rightarrow> 'u \\<rightharpoonup> 'v\"\n  fixes size :: \"'s \\<Rightarrow> nat\"\n  assumes size_correct: \"invar s \\<Longrightarrow> size s = card (dom (\\<alpha> s))\""], ["", "type_synonym ('k,'v,'s) map_size_abort = \"nat \\<Rightarrow> 's \\<Rightarrow> nat\""], ["", "locale map_size_abort = finite_map +\n  constrains \\<alpha> :: \"'s \\<Rightarrow> 'u \\<rightharpoonup> 'v\"\n  fixes size_abort :: \"nat \\<Rightarrow> 's \\<Rightarrow> nat\"\n  assumes size_abort_correct: \"invar s \\<Longrightarrow> size_abort m s = min m (card (dom (\\<alpha> s)))\""], ["", "subsubsection \"Iterators\""], ["", "text \\<open>\n  An iteration combinator over a map applies a function to a state for each \n  map entry, in arbitrary order.\n  Proving of properties is done by invariant reasoning.\n  An iterator can also contain a continuation condition. Iteration is\n  interrupted if the condition becomes false.\n\\<close>"], ["", "(* Deprecated *)\n(*locale map_iteratei = finite_map +\n  constrains \\<alpha> :: \"'s \\<Rightarrow> 'u \\<rightharpoonup> 'v\"\n  fixes iteratei :: \"'s \\<Rightarrow> ('u \\<times> 'v,'\\<sigma>) set_iterator\"\n\n  assumes iteratei_rule: \"invar m \\<Longrightarrow> map_iterator (iteratei m) (\\<alpha> m)\"\nbegin\n  lemma iteratei_rule_P:\n    assumes \"invar m\"\n        and I0: \"I (dom (\\<alpha> m)) \\<sigma>0\"\n        and IP: \"!!k v it \\<sigma>. \\<lbrakk> c \\<sigma>; k \\<in> it; \\<alpha> m k = Some v; it \\<subseteq> dom (\\<alpha> m); I it \\<sigma> \\<rbrakk> \n                    \\<Longrightarrow> I (it - {k}) (f (k, v) \\<sigma>)\"\n        and IF: \"!!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n        and II: \"!!\\<sigma> it. \\<lbrakk> it \\<subseteq> dom (\\<alpha> m); it \\<noteq> {}; \\<not> c \\<sigma>; I it \\<sigma> \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n    shows \"P (iteratei m c f \\<sigma>0)\"\n    using map_iterator_rule_P [OF iteratei_rule, of m I \\<sigma>0 c f P]\n    by (simp_all add: assms)\n\n  lemma iteratei_rule_insert_P:\n    assumes  \n      \"invar m\" \n      \"I {} \\<sigma>0\"\n      \"!!k v it \\<sigma>. \\<lbrakk> c \\<sigma>; k \\<in> (dom (\\<alpha> m) - it); \\<alpha> m k = Some v; it \\<subseteq> dom (\\<alpha> m); I it \\<sigma> \\<rbrakk> \n          \\<Longrightarrow> I (insert k it) (f (k, v) \\<sigma>)\"\n      \"!!\\<sigma>. I (dom (\\<alpha> m)) \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n      \"!!\\<sigma> it. \\<lbrakk> it \\<subseteq> dom (\\<alpha> m); it \\<noteq> dom (\\<alpha> m); \n               \\<not> (c \\<sigma>); \n               I it \\<sigma> \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n    shows \"P (iteratei m c f \\<sigma>0)\"\n    using map_iterator_rule_insert_P [OF iteratei_rule, of m I \\<sigma>0 c f P]\n    by (simp_all add: assms)\n\n  lemma iterate_rule_P:\n    \"\\<lbrakk>\n      invar m;\n      I (dom (\\<alpha> m)) \\<sigma>0;\n      !!k v it \\<sigma>. \\<lbrakk> k \\<in> it; \\<alpha> m k = Some v; it \\<subseteq> dom (\\<alpha> m); I it \\<sigma> \\<rbrakk> \n                  \\<Longrightarrow> I (it - {k}) (f (k, v) \\<sigma>);\n      !!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\n    \\<rbrakk> \\<Longrightarrow> P (iteratei m (\\<lambda>_. True) f \\<sigma>0)\"\n    using iteratei_rule_P [of m I \\<sigma>0 \"\\<lambda>_. True\" f P]\n    by fast\n\n  lemma iterate_rule_insert_P:\n    \"\\<lbrakk>\n      invar m;\n      I {} \\<sigma>0;\n      !!k v it \\<sigma>. \\<lbrakk> k \\<in> (dom (\\<alpha> m) - it); \\<alpha> m k = Some v; it \\<subseteq> dom (\\<alpha> m); I it \\<sigma> \\<rbrakk> \n                  \\<Longrightarrow> I (insert k it) (f (k, v) \\<sigma>);\n      !!\\<sigma>. I (dom (\\<alpha> m)) \\<sigma> \\<Longrightarrow> P \\<sigma>\n    \\<rbrakk> \\<Longrightarrow> P (iteratei m (\\<lambda>_. True) f \\<sigma>0)\"\n    using iteratei_rule_insert_P [of m I \\<sigma>0 \"\\<lambda>_. True\" f P]\n    by fast\nend\n\nlemma map_iteratei_I :\n  assumes \"\\<And>m. invar m \\<Longrightarrow> map_iterator (iti m) (\\<alpha> m)\"\n  shows \"map_iteratei \\<alpha> invar iti\"\nproof\n  fix m \n  assume invar_m: \"invar m\"\n  from assms(1)[OF invar_m] show it_OK: \"map_iterator (iti m) (\\<alpha> m)\" .\n  \n  from set_iterator_genord.finite_S0 [OF it_OK[unfolded set_iterator_def]]\n  show \"finite (dom (\\<alpha> m))\" by (simp add: finite_map_to_set) \nqed\n*)"], ["", "type_synonym ('k,'v,'s) map_list_it\n  = \"'s \\<Rightarrow> ('k\\<times>'v,('k\\<times>'v) list) set_iterator\""], ["", "locale poly_map_iteratei_defs =\n  fixes list_it :: \"'s \\<Rightarrow> ('u\\<times>'v,('u\\<times>'v) list) set_iterator\"\nbegin"], ["", "definition iteratei :: \"'s \\<Rightarrow> ('u\\<times>'v,'\\<sigma>) set_iterator\"\n    where \"iteratei S \\<equiv> it_to_it (list_it S)\""], ["", "abbreviation \"iterate m \\<equiv> iteratei m (\\<lambda>_. True)\""], ["", "end"], ["", "locale poly_map_iteratei =\n  finite_map + poly_map_iteratei_defs list_it\n  for list_it :: \"'s \\<Rightarrow> ('u\\<times>'v,('u\\<times>'v) list) set_iterator\" +\n  constrains \\<alpha> :: \"'s \\<Rightarrow> 'u \\<rightharpoonup> 'v\"\n  assumes list_it_correct: \"invar m \\<Longrightarrow> map_iterator (list_it m) (\\<alpha> m)\"\nbegin"], ["", "lemma iteratei_correct: \"invar S \\<Longrightarrow> map_iterator (iteratei S) (\\<alpha> S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar S \\<Longrightarrow> map_iterator (iteratei S) (\\<alpha> S)", "unfolding iteratei_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. invar S \\<Longrightarrow>\n    map_iterator (it_to_it (list_it S)) (\\<alpha> S)", "apply (rule it_to_it_correct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. invar S \\<Longrightarrow> map_iterator (list_it S) (\\<alpha> S)", "by (rule list_it_correct)"], ["", "lemma pi_iteratei[icf_proper_iteratorI]: \n    \"proper_it (iteratei S) (iteratei S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it (iteratei S) (iteratei S)", "unfolding iteratei_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it (it_to_it (list_it S)) (it_to_it (list_it S))", "by (intro icf_proper_iteratorI)"], ["", "lemma iteratei_rule_P:\n    assumes \"invar m\"\n    and I0: \"I (map_to_set (\\<alpha> m)) \\<sigma>0\"\n    and IP: \"!!k v it \\<sigma>. \\<lbrakk> c \\<sigma>; (k,v) \\<in> it; it \\<subseteq> map_to_set (\\<alpha> m); I it \\<sigma> \\<rbrakk> \n      \\<Longrightarrow> I (it - {(k,v)}) (f (k, v) \\<sigma>)\"\n    and IF: \"!!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n    and II: \"!!\\<sigma> it. \\<lbrakk> it \\<subseteq> map_to_set (\\<alpha> m); it \\<noteq> {}; \\<not> c \\<sigma>; I it \\<sigma> \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n    shows \"P (iteratei m c f \\<sigma>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (iteratei m c f \\<sigma>0)", "apply (rule set_iterator_rule_P[OF iteratei_correct])"], ["proof (prove)\ngoal (5 subgoals):\n 1. invar m\n 2. ?I (map_to_set (\\<alpha> m)) \\<sigma>0\n 3. \\<And>S \\<sigma> x.\n       \\<lbrakk>c \\<sigma>; x \\<in> S; ?I S \\<sigma>;\n        S \\<subseteq> map_to_set (\\<alpha> m)\\<rbrakk>\n       \\<Longrightarrow> ?I (S - {x}) (f x \\<sigma>)\n 4. \\<And>\\<sigma>. ?I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\n 5. \\<And>\\<sigma> S.\n       \\<lbrakk>S \\<subseteq> map_to_set (\\<alpha> m); S \\<noteq> {};\n        \\<not> c \\<sigma>; ?I S \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "apply fact"], ["proof (prove)\ngoal (4 subgoals):\n 1. ?I (map_to_set (\\<alpha> m)) \\<sigma>0\n 2. \\<And>S \\<sigma> x.\n       \\<lbrakk>c \\<sigma>; x \\<in> S; ?I S \\<sigma>;\n        S \\<subseteq> map_to_set (\\<alpha> m)\\<rbrakk>\n       \\<Longrightarrow> ?I (S - {x}) (f x \\<sigma>)\n 3. \\<And>\\<sigma>. ?I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\n 4. \\<And>\\<sigma> S.\n       \\<lbrakk>S \\<subseteq> map_to_set (\\<alpha> m); S \\<noteq> {};\n        \\<not> c \\<sigma>; ?I S \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "apply fact"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>S \\<sigma> x.\n       \\<lbrakk>c \\<sigma>; x \\<in> S; I S \\<sigma>;\n        S \\<subseteq> map_to_set (\\<alpha> m)\\<rbrakk>\n       \\<Longrightarrow> I (S - {x}) (f x \\<sigma>)\n 2. \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\n 3. \\<And>\\<sigma> S.\n       \\<lbrakk>S \\<subseteq> map_to_set (\\<alpha> m); S \\<noteq> {};\n        \\<not> c \\<sigma>; I S \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "apply (case_tac x, simp add: IP)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\n 2. \\<And>\\<sigma> S.\n       \\<lbrakk>S \\<subseteq> map_to_set (\\<alpha> m); S \\<noteq> {};\n        \\<not> c \\<sigma>; I S \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> S.\n       \\<lbrakk>S \\<subseteq> map_to_set (\\<alpha> m); S \\<noteq> {};\n        \\<not> c \\<sigma>; I S \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "apply fact"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iteratei_rule_insert_P:\n    assumes \"invar m\" \n    and \"I {} \\<sigma>0\"\n    and \"!!k v it \\<sigma>. \\<lbrakk> c \\<sigma>; (k,v) \\<in> (map_to_set (\\<alpha> m) - it); \n                       it \\<subseteq> map_to_set (\\<alpha> m); I it \\<sigma> \\<rbrakk> \n      \\<Longrightarrow> I (insert (k,v) it) (f (k, v) \\<sigma>)\"\n    and \"!!\\<sigma>. I (map_to_set (\\<alpha> m)) \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n    and \"!!\\<sigma> it. \\<lbrakk> it \\<subseteq> map_to_set (\\<alpha> m); it \\<noteq> map_to_set (\\<alpha> m); \n                  \\<not> (c \\<sigma>); \n                  I it \\<sigma> \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n    shows \"P (iteratei m c f \\<sigma>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (iteratei m c f \\<sigma>0)", "apply (rule set_iterator_rule_insert_P[OF iteratei_correct])"], ["proof (prove)\ngoal (5 subgoals):\n 1. invar m\n 2. ?I {} \\<sigma>0\n 3. \\<And>S \\<sigma> x.\n       \\<lbrakk>c \\<sigma>; x \\<in> map_to_set (\\<alpha> m) - S;\n        ?I S \\<sigma>; S \\<subseteq> map_to_set (\\<alpha> m)\\<rbrakk>\n       \\<Longrightarrow> ?I (insert x S) (f x \\<sigma>)\n 4. \\<And>\\<sigma>.\n       ?I (map_to_set (\\<alpha> m)) \\<sigma> \\<Longrightarrow> P \\<sigma>\n 5. \\<And>\\<sigma> S.\n       \\<lbrakk>S \\<subseteq> map_to_set (\\<alpha> m);\n        S \\<noteq> map_to_set (\\<alpha> m); \\<not> c \\<sigma>;\n        ?I S \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "apply fact"], ["proof (prove)\ngoal (4 subgoals):\n 1. ?I {} \\<sigma>0\n 2. \\<And>S \\<sigma> x.\n       \\<lbrakk>c \\<sigma>; x \\<in> map_to_set (\\<alpha> m) - S;\n        ?I S \\<sigma>; S \\<subseteq> map_to_set (\\<alpha> m)\\<rbrakk>\n       \\<Longrightarrow> ?I (insert x S) (f x \\<sigma>)\n 3. \\<And>\\<sigma>.\n       ?I (map_to_set (\\<alpha> m)) \\<sigma> \\<Longrightarrow> P \\<sigma>\n 4. \\<And>\\<sigma> S.\n       \\<lbrakk>S \\<subseteq> map_to_set (\\<alpha> m);\n        S \\<noteq> map_to_set (\\<alpha> m); \\<not> c \\<sigma>;\n        ?I S \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "apply fact"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>S \\<sigma> x.\n       \\<lbrakk>c \\<sigma>; x \\<in> map_to_set (\\<alpha> m) - S;\n        I S \\<sigma>; S \\<subseteq> map_to_set (\\<alpha> m)\\<rbrakk>\n       \\<Longrightarrow> I (insert x S) (f x \\<sigma>)\n 2. \\<And>\\<sigma>.\n       I (map_to_set (\\<alpha> m)) \\<sigma> \\<Longrightarrow> P \\<sigma>\n 3. \\<And>\\<sigma> S.\n       \\<lbrakk>S \\<subseteq> map_to_set (\\<alpha> m);\n        S \\<noteq> map_to_set (\\<alpha> m); \\<not> c \\<sigma>;\n        I S \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "apply (case_tac x, simp add: assms)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma>.\n       I (map_to_set (\\<alpha> m)) \\<sigma> \\<Longrightarrow> P \\<sigma>\n 2. \\<And>\\<sigma> S.\n       \\<lbrakk>S \\<subseteq> map_to_set (\\<alpha> m);\n        S \\<noteq> map_to_set (\\<alpha> m); \\<not> c \\<sigma>;\n        I S \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> S.\n       \\<lbrakk>S \\<subseteq> map_to_set (\\<alpha> m);\n        S \\<noteq> map_to_set (\\<alpha> m); \\<not> c \\<sigma>;\n        I S \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "apply fact"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iterate_rule_P:\n    assumes \"invar m\"\n    and I0: \"I (map_to_set (\\<alpha> m)) \\<sigma>0\"\n    and IP: \"!!k v it \\<sigma>. \\<lbrakk> (k,v) \\<in> it; it \\<subseteq> map_to_set (\\<alpha> m); I it \\<sigma> \\<rbrakk> \n      \\<Longrightarrow> I (it - {(k,v)}) (f (k, v) \\<sigma>)\"\n    and IF: \"!!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n    shows \"P (iterate m f \\<sigma>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (iterate m f \\<sigma>0)", "apply (rule iteratei_rule_P)"], ["proof (prove)\ngoal (5 subgoals):\n 1. invar m\n 2. ?I (map_to_set (\\<alpha> m)) \\<sigma>0\n 3. \\<And>k v it \\<sigma>.\n       \\<lbrakk>True; (k, v) \\<in> it;\n        it \\<subseteq> map_to_set (\\<alpha> m); ?I it \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> ?I (it - {(k, v)}) (f (k, v) \\<sigma>)\n 4. \\<And>\\<sigma>. ?I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\n 5. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> map_to_set (\\<alpha> m); it \\<noteq> {};\n        \\<not> True; ?I it \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "apply fact"], ["proof (prove)\ngoal (4 subgoals):\n 1. ?I (map_to_set (\\<alpha> m)) \\<sigma>0\n 2. \\<And>k v it \\<sigma>.\n       \\<lbrakk>True; (k, v) \\<in> it;\n        it \\<subseteq> map_to_set (\\<alpha> m); ?I it \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> ?I (it - {(k, v)}) (f (k, v) \\<sigma>)\n 3. \\<And>\\<sigma>. ?I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\n 4. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> map_to_set (\\<alpha> m); it \\<noteq> {};\n        \\<not> True; ?I it \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "apply (rule I0)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>True; (k, v) \\<in> it;\n        it \\<subseteq> map_to_set (\\<alpha> m); I it \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I (it - {(k, v)}) (f (k, v) \\<sigma>)\n 2. \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\n 3. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> map_to_set (\\<alpha> m); it \\<noteq> {};\n        \\<not> True; I it \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "apply (rule IP, assumption+) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\n 2. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> map_to_set (\\<alpha> m); it \\<noteq> {};\n        \\<not> True; I it \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "apply (rule IF, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> map_to_set (\\<alpha> m); it \\<noteq> {};\n        \\<not> True; I it \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iterate_rule_insert_P:\n    assumes \"invar m\" \n    and I0: \"I {} \\<sigma>0\"\n    and \"!!k v it \\<sigma>. \\<lbrakk> (k,v) \\<in> (map_to_set (\\<alpha> m) - it); \n                       it \\<subseteq> map_to_set (\\<alpha> m); I it \\<sigma> \\<rbrakk> \n      \\<Longrightarrow> I (insert (k,v) it) (f (k, v) \\<sigma>)\"\n    and \"!!\\<sigma>. I (map_to_set (\\<alpha> m)) \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n    shows \"P (iterate m f \\<sigma>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (iterate m f \\<sigma>0)", "apply (rule iteratei_rule_insert_P)"], ["proof (prove)\ngoal (5 subgoals):\n 1. invar m\n 2. ?I {} \\<sigma>0\n 3. \\<And>k v it \\<sigma>.\n       \\<lbrakk>True; (k, v) \\<in> map_to_set (\\<alpha> m) - it;\n        it \\<subseteq> map_to_set (\\<alpha> m); ?I it \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> ?I (insert (k, v) it) (f (k, v) \\<sigma>)\n 4. \\<And>\\<sigma>.\n       ?I (map_to_set (\\<alpha> m)) \\<sigma> \\<Longrightarrow> P \\<sigma>\n 5. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> map_to_set (\\<alpha> m);\n        it \\<noteq> map_to_set (\\<alpha> m); \\<not> True;\n        ?I it \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "apply fact"], ["proof (prove)\ngoal (4 subgoals):\n 1. ?I {} \\<sigma>0\n 2. \\<And>k v it \\<sigma>.\n       \\<lbrakk>True; (k, v) \\<in> map_to_set (\\<alpha> m) - it;\n        it \\<subseteq> map_to_set (\\<alpha> m); ?I it \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> ?I (insert (k, v) it) (f (k, v) \\<sigma>)\n 3. \\<And>\\<sigma>.\n       ?I (map_to_set (\\<alpha> m)) \\<sigma> \\<Longrightarrow> P \\<sigma>\n 4. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> map_to_set (\\<alpha> m);\n        it \\<noteq> map_to_set (\\<alpha> m); \\<not> True;\n        ?I it \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "apply (rule I0)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>True; (k, v) \\<in> map_to_set (\\<alpha> m) - it;\n        it \\<subseteq> map_to_set (\\<alpha> m); I it \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I (insert (k, v) it) (f (k, v) \\<sigma>)\n 2. \\<And>\\<sigma>.\n       I (map_to_set (\\<alpha> m)) \\<sigma> \\<Longrightarrow> P \\<sigma>\n 3. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> map_to_set (\\<alpha> m);\n        it \\<noteq> map_to_set (\\<alpha> m); \\<not> True;\n        I it \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "apply (rule assms, assumption+) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma>.\n       I (map_to_set (\\<alpha> m)) \\<sigma> \\<Longrightarrow> P \\<sigma>\n 2. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> map_to_set (\\<alpha> m);\n        it \\<noteq> map_to_set (\\<alpha> m); \\<not> True;\n        I it \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "apply (rule assms, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> map_to_set (\\<alpha> m);\n        it \\<noteq> map_to_set (\\<alpha> m); \\<not> True;\n        I it \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma old_iteratei_rule_P:\n    assumes \"invar m\"\n    and I0: \"I (dom (\\<alpha> m)) \\<sigma>0\"\n    and IP: \"!!k v it \\<sigma>. \\<lbrakk> c \\<sigma>; k \\<in> it; \\<alpha> m k = Some v; it \\<subseteq> dom (\\<alpha> m); I it \\<sigma> \\<rbrakk> \n      \\<Longrightarrow> I (it - {k}) (f (k, v) \\<sigma>)\"\n    and IF: \"!!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n    and II: \"!!\\<sigma> it. \\<lbrakk> it \\<subseteq> dom (\\<alpha> m); it \\<noteq> {}; \\<not> c \\<sigma>; I it \\<sigma> \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n    shows \"P (iteratei m c f \\<sigma>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (iteratei m c f \\<sigma>0)", "using assms"], ["proof (prove)\nusing this:\n  invar m\n  I (dom (\\<alpha> m)) \\<sigma>0\n  \\<lbrakk>c ?\\<sigma>2; ?k2 \\<in> ?it2; \\<alpha> m ?k2 = Some ?v2;\n   ?it2 \\<subseteq> dom (\\<alpha> m); I ?it2 ?\\<sigma>2\\<rbrakk>\n  \\<Longrightarrow> I (?it2 - {?k2}) (f (?k2, ?v2) ?\\<sigma>2)\n  I {} ?\\<sigma>2 \\<Longrightarrow> P ?\\<sigma>2\n  \\<lbrakk>?it2 \\<subseteq> dom (\\<alpha> m); ?it2 \\<noteq> {};\n   \\<not> c ?\\<sigma>2; I ?it2 ?\\<sigma>2\\<rbrakk>\n  \\<Longrightarrow> P ?\\<sigma>2\n\ngoal (1 subgoal):\n 1. P (iteratei m c f \\<sigma>0)", "by (rule map_iterator_rule_P[OF iteratei_correct])"], ["", "lemma old_iteratei_rule_insert_P:\n    assumes \"invar m\" \n    and \"I {} \\<sigma>0\"\n    and \"!!k v it \\<sigma>. \\<lbrakk> c \\<sigma>; k \\<in> (dom (\\<alpha> m) - it); \\<alpha> m k = Some v; \n                       it \\<subseteq> dom (\\<alpha> m); I it \\<sigma> \\<rbrakk> \n      \\<Longrightarrow> I (insert k it) (f (k, v) \\<sigma>)\"\n    and \"!!\\<sigma>. I (dom (\\<alpha> m)) \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n    and \"!!\\<sigma> it. \\<lbrakk> it \\<subseteq> dom (\\<alpha> m); it \\<noteq> dom (\\<alpha> m); \n                  \\<not> (c \\<sigma>); \n                  I it \\<sigma> \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n    shows \"P (iteratei m c f \\<sigma>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (iteratei m c f \\<sigma>0)", "using assms"], ["proof (prove)\nusing this:\n  invar m\n  I {} \\<sigma>0\n  \\<lbrakk>c ?\\<sigma>2; ?k2 \\<in> dom (\\<alpha> m) - ?it2;\n   \\<alpha> m ?k2 = Some ?v2; ?it2 \\<subseteq> dom (\\<alpha> m);\n   I ?it2 ?\\<sigma>2\\<rbrakk>\n  \\<Longrightarrow> I (insert ?k2 ?it2) (f (?k2, ?v2) ?\\<sigma>2)\n  I (dom (\\<alpha> m)) ?\\<sigma>2 \\<Longrightarrow> P ?\\<sigma>2\n  \\<lbrakk>?it2 \\<subseteq> dom (\\<alpha> m);\n   ?it2 \\<noteq> dom (\\<alpha> m); \\<not> c ?\\<sigma>2;\n   I ?it2 ?\\<sigma>2\\<rbrakk>\n  \\<Longrightarrow> P ?\\<sigma>2\n\ngoal (1 subgoal):\n 1. P (iteratei m c f \\<sigma>0)", "by (rule map_iterator_rule_insert_P[OF iteratei_correct])"], ["", "lemma old_iterate_rule_P:\n    \"\\<lbrakk>\n      invar m;\n      I (dom (\\<alpha> m)) \\<sigma>0;\n      !!k v it \\<sigma>. \\<lbrakk> k \\<in> it; \\<alpha> m k = Some v; it \\<subseteq> dom (\\<alpha> m); I it \\<sigma> \\<rbrakk> \n                  \\<Longrightarrow> I (it - {k}) (f (k, v) \\<sigma>);\n      !!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\n    \\<rbrakk> \\<Longrightarrow> P (iterate m f \\<sigma>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar m; I (dom (\\<alpha> m)) \\<sigma>0;\n     \\<And>k v it \\<sigma>.\n        \\<lbrakk>k \\<in> it; \\<alpha> m k = Some v;\n         it \\<subseteq> dom (\\<alpha> m); I it \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> I (it - {k}) (f (k, v) \\<sigma>);\n     \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> P (iterate m f \\<sigma>0)", "using old_iteratei_rule_P [of m I \\<sigma>0 \"\\<lambda>_. True\" f P]"], ["proof (prove)\nusing this:\n  \\<lbrakk>invar m; I (dom (\\<alpha> m)) \\<sigma>0;\n   \\<And>k v it \\<sigma>.\n      \\<lbrakk>True; k \\<in> it; \\<alpha> m k = Some v;\n       it \\<subseteq> dom (\\<alpha> m); I it \\<sigma>\\<rbrakk>\n      \\<Longrightarrow> I (it - {k}) (f (k, v) \\<sigma>);\n   \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>;\n   \\<And>\\<sigma> it.\n      \\<lbrakk>it \\<subseteq> dom (\\<alpha> m); it \\<noteq> {}; \\<not> True;\n       I it \\<sigma>\\<rbrakk>\n      \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n  \\<Longrightarrow> P (iterate m f \\<sigma>0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>invar m; I (dom (\\<alpha> m)) \\<sigma>0;\n     \\<And>k v it \\<sigma>.\n        \\<lbrakk>k \\<in> it; \\<alpha> m k = Some v;\n         it \\<subseteq> dom (\\<alpha> m); I it \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> I (it - {k}) (f (k, v) \\<sigma>);\n     \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> P (iterate m f \\<sigma>0)", "by blast"], ["", "lemma old_iterate_rule_insert_P:\n    \"\\<lbrakk>\n      invar m;\n      I {} \\<sigma>0;\n      !!k v it \\<sigma>. \\<lbrakk> k \\<in> (dom (\\<alpha> m) - it); \\<alpha> m k = Some v; \n                    it \\<subseteq> dom (\\<alpha> m); I it \\<sigma> \\<rbrakk> \n                  \\<Longrightarrow> I (insert k it) (f (k, v) \\<sigma>);\n      !!\\<sigma>. I (dom (\\<alpha> m)) \\<sigma> \\<Longrightarrow> P \\<sigma>\n    \\<rbrakk> \\<Longrightarrow> P (iteratei m (\\<lambda>_. True) f \\<sigma>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar m; I {} \\<sigma>0;\n     \\<And>k v it \\<sigma>.\n        \\<lbrakk>k \\<in> dom (\\<alpha> m) - it; \\<alpha> m k = Some v;\n         it \\<subseteq> dom (\\<alpha> m); I it \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> I (insert k it) (f (k, v) \\<sigma>);\n     \\<And>\\<sigma>.\n        I (dom (\\<alpha> m)) \\<sigma> \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> P (iterate m f \\<sigma>0)", "using old_iteratei_rule_insert_P [of m I \\<sigma>0 \"\\<lambda>_. True\" f P]"], ["proof (prove)\nusing this:\n  \\<lbrakk>invar m; I {} \\<sigma>0;\n   \\<And>k v it \\<sigma>.\n      \\<lbrakk>True; k \\<in> dom (\\<alpha> m) - it; \\<alpha> m k = Some v;\n       it \\<subseteq> dom (\\<alpha> m); I it \\<sigma>\\<rbrakk>\n      \\<Longrightarrow> I (insert k it) (f (k, v) \\<sigma>);\n   \\<And>\\<sigma>.\n      I (dom (\\<alpha> m)) \\<sigma> \\<Longrightarrow> P \\<sigma>;\n   \\<And>\\<sigma> it.\n      \\<lbrakk>it \\<subseteq> dom (\\<alpha> m);\n       it \\<noteq> dom (\\<alpha> m); \\<not> True; I it \\<sigma>\\<rbrakk>\n      \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n  \\<Longrightarrow> P (iterate m f \\<sigma>0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>invar m; I {} \\<sigma>0;\n     \\<And>k v it \\<sigma>.\n        \\<lbrakk>k \\<in> dom (\\<alpha> m) - it; \\<alpha> m k = Some v;\n         it \\<subseteq> dom (\\<alpha> m); I it \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> I (insert k it) (f (k, v) \\<sigma>);\n     \\<And>\\<sigma>.\n        I (dom (\\<alpha> m)) \\<sigma> \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> P (iterate m f \\<sigma>0)", "by blast"], ["", "end"], ["", "subsubsection \"Bounded Quantification\""], ["", "type_synonym ('k,'v,'s) map_ball = \"'s \\<Rightarrow> ('k \\<times> 'v \\<Rightarrow> bool) \\<Rightarrow> bool\""], ["", "locale map_ball = map +\n  constrains \\<alpha> :: \"'s \\<Rightarrow> 'u \\<rightharpoonup> 'v\"\n  fixes ball :: \"'s \\<Rightarrow> ('u \\<times> 'v \\<Rightarrow> bool) \\<Rightarrow> bool\"\n  assumes ball_correct: \"invar m \\<Longrightarrow> ball m P \\<longleftrightarrow> (\\<forall>u v. \\<alpha> m u = Some v \\<longrightarrow> P (u, v))\""], ["", "type_synonym ('k,'v,'s) map_bex = \"'s \\<Rightarrow> ('k \\<times> 'v \\<Rightarrow> bool) \\<Rightarrow> bool\""], ["", "locale map_bex = map +\n  constrains \\<alpha> :: \"'s \\<Rightarrow> 'u \\<rightharpoonup> 'v\"\n  fixes bex :: \"'s \\<Rightarrow> ('u \\<times> 'v \\<Rightarrow> bool) \\<Rightarrow> bool\"\n  assumes bex_correct: \n    \"invar m \\<Longrightarrow> bex m P \\<longleftrightarrow> (\\<exists>u v. \\<alpha> m u = Some v \\<and> P (u, v))\""], ["", "subsubsection \"Selection of Entry\""], ["", "type_synonym ('k,'v,'s,'r) map_sel = \"'s \\<Rightarrow> ('k \\<times> 'v \\<Rightarrow> 'r option) \\<Rightarrow> 'r option\""], ["", "locale map_sel = map +\n  constrains \\<alpha> :: \"'s \\<Rightarrow> 'u \\<rightharpoonup> 'v\"\n  fixes sel :: \"'s \\<Rightarrow> ('u \\<times> 'v \\<Rightarrow> 'r option) \\<Rightarrow> 'r option\"\n  assumes selE: \n  \"\\<lbrakk> invar m; \\<alpha> m u = Some v; f (u, v) = Some r; \n     !!u v r. \\<lbrakk> sel m f = Some r; \\<alpha> m u = Some v; f (u, v) = Some r \\<rbrakk> \\<Longrightarrow> Q \n   \\<rbrakk> \\<Longrightarrow> Q\"\n  assumes selI: \n    \"\\<lbrakk> invar m; \\<forall>u v. \\<alpha> m u = Some v \\<longrightarrow> f (u, v) = None \\<rbrakk> \\<Longrightarrow> sel m f = None\"\n\nbegin"], ["", "lemma sel_someE: \n    \"\\<lbrakk> invar m; sel m f = Some r; \n       !!u v. \\<lbrakk> \\<alpha> m u = Some v; f (u, v) = Some r \\<rbrakk> \\<Longrightarrow> P\n     \\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar m; sel m f = Some r;\n     \\<And>u v.\n        \\<lbrakk>\\<alpha> m u = Some v; f (u, v) = Some r\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "apply (cases \"\\<exists>u v r. \\<alpha> m u = Some v \\<and> f (u, v) = Some r\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>invar m; sel m f = Some r;\n     \\<And>u v.\n        \\<lbrakk>\\<alpha> m u = Some v; f (u, v) = Some r\\<rbrakk>\n        \\<Longrightarrow> P;\n     \\<exists>u v r. \\<alpha> m u = Some v \\<and> f (u, v) = Some r\\<rbrakk>\n    \\<Longrightarrow> P\n 2. \\<lbrakk>invar m; sel m f = Some r;\n     \\<And>u v.\n        \\<lbrakk>\\<alpha> m u = Some v; f (u, v) = Some r\\<rbrakk>\n        \\<Longrightarrow> P;\n     \\<nexists>u v r.\n        \\<alpha> m u = Some v \\<and> f (u, v) = Some r\\<rbrakk>\n    \\<Longrightarrow> P", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>u v ra.\n       \\<lbrakk>invar m; sel m f = Some r;\n        \\<And>u v.\n           \\<lbrakk>\\<alpha> m u = Some v; f (u, v) = Some r\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<alpha> m u = Some v; f (u, v) = Some ra\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<lbrakk>invar m; sel m f = Some r;\n     \\<And>u v.\n        \\<lbrakk>\\<alpha> m u = Some v; f (u, v) = Some r\\<rbrakk>\n        \\<Longrightarrow> P;\n     \\<nexists>u v r.\n        \\<alpha> m u = Some v \\<and> f (u, v) = Some r\\<rbrakk>\n    \\<Longrightarrow> P", "apply (erule_tac u=u and v=v and r=ra in selE)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>u v ra.\n       \\<lbrakk>sel m f = Some r;\n        \\<And>u v.\n           \\<lbrakk>\\<alpha> m u = Some v; f (u, v) = Some r\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<alpha> m u = Some v; f (u, v) = Some ra\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> m u = Some v\n 2. \\<And>u v ra.\n       \\<lbrakk>sel m f = Some r;\n        \\<And>u v.\n           \\<lbrakk>\\<alpha> m u = Some v; f (u, v) = Some r\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<alpha> m u = Some v; f (u, v) = Some ra\\<rbrakk>\n       \\<Longrightarrow> ?f5 u v ra (u, v) = Some ra\n 3. \\<And>u v ra ua va raa.\n       \\<lbrakk>sel m f = Some r;\n        \\<And>u v.\n           \\<lbrakk>\\<alpha> m u = Some v; f (u, v) = Some r\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<alpha> m u = Some v; f (u, v) = Some ra;\n        sel m (?f5 u v ra) = Some raa; \\<alpha> m ua = Some va;\n        ?f5 u v ra (ua, va) = Some raa\\<rbrakk>\n       \\<Longrightarrow> P\n 4. \\<lbrakk>invar m; sel m f = Some r;\n     \\<And>u v.\n        \\<lbrakk>\\<alpha> m u = Some v; f (u, v) = Some r\\<rbrakk>\n        \\<Longrightarrow> P;\n     \\<nexists>u v r.\n        \\<alpha> m u = Some v \\<and> f (u, v) = Some r\\<rbrakk>\n    \\<Longrightarrow> P", "apply assumption"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>u v ra.\n       \\<lbrakk>sel m f = Some r;\n        \\<And>u v.\n           \\<lbrakk>\\<alpha> m u = Some v; f (u, v) = Some r\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<alpha> m u = Some v; f (u, v) = Some ra\\<rbrakk>\n       \\<Longrightarrow> ?f5 u v ra (u, v) = Some ra\n 2. \\<And>u v ra ua va raa.\n       \\<lbrakk>sel m f = Some r;\n        \\<And>u v.\n           \\<lbrakk>\\<alpha> m u = Some v; f (u, v) = Some r\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<alpha> m u = Some v; f (u, v) = Some ra;\n        sel m (?f5 u v ra) = Some raa; \\<alpha> m ua = Some va;\n        ?f5 u v ra (ua, va) = Some raa\\<rbrakk>\n       \\<Longrightarrow> P\n 3. \\<lbrakk>invar m; sel m f = Some r;\n     \\<And>u v.\n        \\<lbrakk>\\<alpha> m u = Some v; f (u, v) = Some r\\<rbrakk>\n        \\<Longrightarrow> P;\n     \\<nexists>u v r.\n        \\<alpha> m u = Some v \\<and> f (u, v) = Some r\\<rbrakk>\n    \\<Longrightarrow> P", "apply assumption"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>u v ra ua va raa.\n       \\<lbrakk>sel m f = Some r;\n        \\<And>u v.\n           \\<lbrakk>\\<alpha> m u = Some v; f (u, v) = Some r\\<rbrakk>\n           \\<Longrightarrow> P;\n        \\<alpha> m u = Some v; f (u, v) = Some ra; sel m f = Some raa;\n        \\<alpha> m ua = Some va; f (ua, va) = Some raa\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<lbrakk>invar m; sel m f = Some r;\n     \\<And>u v.\n        \\<lbrakk>\\<alpha> m u = Some v; f (u, v) = Some r\\<rbrakk>\n        \\<Longrightarrow> P;\n     \\<nexists>u v r.\n        \\<alpha> m u = Some v \\<and> f (u, v) = Some r\\<rbrakk>\n    \\<Longrightarrow> P", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar m; sel m f = Some r;\n     \\<And>u v.\n        \\<lbrakk>\\<alpha> m u = Some v; f (u, v) = Some r\\<rbrakk>\n        \\<Longrightarrow> P;\n     \\<nexists>u v r.\n        \\<alpha> m u = Some v \\<and> f (u, v) = Some r\\<rbrakk>\n    \\<Longrightarrow> P", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar m; sel m f = Some r;\n     \\<forall>u v.\n        \\<alpha> m u = Some v \\<longrightarrow> f (u, v) = None\\<rbrakk>\n    \\<Longrightarrow> P", "apply (drule (1) selI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sel m f = Some r;\n     \\<forall>u v. \\<alpha> m u = Some v \\<longrightarrow> f (u, v) = None;\n     sel m f = None\\<rbrakk>\n    \\<Longrightarrow> P", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sel_noneD: \"\\<lbrakk>invar m; sel m f = None; \\<alpha> m u = Some v\\<rbrakk> \\<Longrightarrow> f (u, v) = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar m; sel m f = None; \\<alpha> m u = Some v\\<rbrakk>\n    \\<Longrightarrow> f (u, v) = None", "apply (rule ccontr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar m; sel m f = None; \\<alpha> m u = Some v;\n     f (u, v) \\<noteq> None\\<rbrakk>\n    \\<Longrightarrow> False", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar m; sel m f = None; \\<alpha> m u = Some v;\n     \\<exists>y. f (u, v) = Some y\\<rbrakk>\n    \\<Longrightarrow> False", "apply (erule exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>invar m; sel m f = None; \\<alpha> m u = Some v;\n        f (u, v) = Some y\\<rbrakk>\n       \\<Longrightarrow> False", "apply (erule_tac f=f and u=u and v=v and r=y in selE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>sel m f = None; \\<alpha> m u = Some v;\n        f (u, v) = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> m u = Some v\n 2. \\<And>y.\n       \\<lbrakk>sel m f = None; \\<alpha> m u = Some v;\n        f (u, v) = Some y\\<rbrakk>\n       \\<Longrightarrow> f (u, v) = Some y\n 3. \\<And>y ua va r.\n       \\<lbrakk>sel m f = None; \\<alpha> m u = Some v; f (u, v) = Some y;\n        sel m f = Some r; \\<alpha> m ua = Some va;\n        f (ua, va) = Some r\\<rbrakk>\n       \\<Longrightarrow> False", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end\n\n  \\<comment> \\<open>Equivalent description of sel-map properties\\<close>"], ["", "lemma map_sel_altI:\n  assumes S1: \n    \"!!s f r P. \\<lbrakk> invar s; sel s f = Some r; \n                  !!u v. \\<lbrakk>\\<alpha> s u = Some v; f (u, v) = Some r\\<rbrakk> \\<Longrightarrow> P\n                \\<rbrakk> \\<Longrightarrow> P\"\n  assumes S2: \n    \"!!s f u v. \\<lbrakk>invar s; sel s f = None; \\<alpha> s u = Some v\\<rbrakk> \\<Longrightarrow> f (u, v) = None\"\n  shows \"map_sel \\<alpha> invar sel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_sel \\<alpha> invar sel", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map_sel \\<alpha> invar sel", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_sel \\<alpha> invar sel", "apply (unfold_locales)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m u v f r Q.\n       \\<lbrakk>invar m; \\<alpha> m u = Some v; f (u, v) = Some r;\n        \\<And>u v r.\n           \\<lbrakk>sel m f = Some r; \\<alpha> m u = Some v;\n            f (u, v) = Some r\\<rbrakk>\n           \\<Longrightarrow> Q\\<rbrakk>\n       \\<Longrightarrow> Q\n 2. \\<And>m f.\n       \\<lbrakk>invar m;\n        \\<forall>u v.\n           \\<alpha> m u = Some v \\<longrightarrow> f (u, v) = None\\<rbrakk>\n       \\<Longrightarrow> sel m f = None", "apply (case_tac \"sel m f\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>m u v f r Q.\n       \\<lbrakk>invar m; \\<alpha> m u = Some v; f (u, v) = Some r;\n        \\<And>u v r.\n           \\<lbrakk>sel m f = Some r; \\<alpha> m u = Some v;\n            f (u, v) = Some r\\<rbrakk>\n           \\<Longrightarrow> Q;\n        sel m f = None\\<rbrakk>\n       \\<Longrightarrow> Q\n 2. \\<And>m u v f r Q a.\n       \\<lbrakk>invar m; \\<alpha> m u = Some v; f (u, v) = Some r;\n        \\<And>u v r.\n           \\<lbrakk>sel m f = Some r; \\<alpha> m u = Some v;\n            f (u, v) = Some r\\<rbrakk>\n           \\<Longrightarrow> Q;\n        sel m f = Some a\\<rbrakk>\n       \\<Longrightarrow> Q\n 3. \\<And>m f.\n       \\<lbrakk>invar m;\n        \\<forall>u v.\n           \\<alpha> m u = Some v \\<longrightarrow> f (u, v) = None\\<rbrakk>\n       \\<Longrightarrow> sel m f = None", "apply (force dest: S2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m u v f r Q a.\n       \\<lbrakk>invar m; \\<alpha> m u = Some v; f (u, v) = Some r;\n        \\<And>u v r.\n           \\<lbrakk>sel m f = Some r; \\<alpha> m u = Some v;\n            f (u, v) = Some r\\<rbrakk>\n           \\<Longrightarrow> Q;\n        sel m f = Some a\\<rbrakk>\n       \\<Longrightarrow> Q\n 2. \\<And>m f.\n       \\<lbrakk>invar m;\n        \\<forall>u v.\n           \\<alpha> m u = Some v \\<longrightarrow> f (u, v) = None\\<rbrakk>\n       \\<Longrightarrow> sel m f = None", "apply (force elim: S1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m f.\n       \\<lbrakk>invar m;\n        \\<forall>u v.\n           \\<alpha> m u = Some v \\<longrightarrow> f (u, v) = None\\<rbrakk>\n       \\<Longrightarrow> sel m f = None", "apply (case_tac \"sel m f\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m f.\n       \\<lbrakk>invar m;\n        \\<forall>u v.\n           \\<alpha> m u = Some v \\<longrightarrow> f (u, v) = None;\n        sel m f = None\\<rbrakk>\n       \\<Longrightarrow> sel m f = None\n 2. \\<And>m f a.\n       \\<lbrakk>invar m;\n        \\<forall>u v.\n           \\<alpha> m u = Some v \\<longrightarrow> f (u, v) = None;\n        sel m f = Some a\\<rbrakk>\n       \\<Longrightarrow> sel m f = None", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m f a.\n       \\<lbrakk>invar m;\n        \\<forall>u v.\n           \\<alpha> m u = Some v \\<longrightarrow> f (u, v) = None;\n        sel m f = Some a\\<rbrakk>\n       \\<Longrightarrow> sel m f = None", "apply (force elim: S1)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  map_sel \\<alpha> invar sel\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \"Selection of Entry (without mapping)\""], ["", "type_synonym ('k,'v,'s) map_sel' = \"'s \\<Rightarrow> ('k \\<times> 'v \\<Rightarrow> bool) \\<Rightarrow> ('k\\<times>'v) option\""], ["", "locale map_sel' = map +\n  constrains \\<alpha> :: \"'s \\<Rightarrow> 'u \\<rightharpoonup> 'v\"\n  fixes sel' :: \"'s \\<Rightarrow> ('u \\<times> 'v \\<Rightarrow> bool) \\<Rightarrow> ('u\\<times>'v) option\"\n  assumes sel'E: \n  \"\\<lbrakk> invar m; \\<alpha> m u = Some v; P (u, v); \n     !!u v. \\<lbrakk> sel' m P = Some (u,v); \\<alpha> m u = Some v; P (u, v)\\<rbrakk> \\<Longrightarrow> Q \n   \\<rbrakk> \\<Longrightarrow> Q\"\n  assumes sel'I: \n    \"\\<lbrakk> invar m; \\<forall>u v. \\<alpha> m u = Some v \\<longrightarrow> \\<not> P (u, v) \\<rbrakk> \\<Longrightarrow> sel' m P = None\"\n\nbegin"], ["", "lemma sel'_someE: \n    \"\\<lbrakk> invar m; sel' m P = Some (u,v); \n       !!u v. \\<lbrakk> \\<alpha> m u = Some v; P (u, v) \\<rbrakk> \\<Longrightarrow> thesis\n     \\<rbrakk> \\<Longrightarrow> thesis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar m; sel' m P = Some (u, v);\n     \\<And>u v.\n        \\<lbrakk>\\<alpha> m u = Some v; P (u, v)\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply (cases \"\\<exists>u v. \\<alpha> m u = Some v \\<and> P (u, v)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>invar m; sel' m P = Some (u, v);\n     \\<And>u v.\n        \\<lbrakk>\\<alpha> m u = Some v; P (u, v)\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<exists>u v. \\<alpha> m u = Some v \\<and> P (u, v)\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>invar m; sel' m P = Some (u, v);\n     \\<And>u v.\n        \\<lbrakk>\\<alpha> m u = Some v; P (u, v)\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<nexists>u v. \\<alpha> m u = Some v \\<and> P (u, v)\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply safe"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ua va.\n       \\<lbrakk>invar m; sel' m P = Some (u, v);\n        \\<And>u v.\n           \\<lbrakk>\\<alpha> m u = Some v; P (u, v)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<alpha> m ua = Some va; P (ua, va)\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<lbrakk>invar m; sel' m P = Some (u, v);\n     \\<And>u v.\n        \\<lbrakk>\\<alpha> m u = Some v; P (u, v)\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<nexists>u v. \\<alpha> m u = Some v \\<and> P (u, v)\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply (erule_tac u=ua and v=va in sel'E)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>ua va.\n       \\<lbrakk>sel' m P = Some (u, v);\n        \\<And>u v.\n           \\<lbrakk>\\<alpha> m u = Some v; P (u, v)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<alpha> m ua = Some va; P (ua, va)\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> m ua = Some va\n 2. \\<And>ua va.\n       \\<lbrakk>sel' m P = Some (u, v);\n        \\<And>u v.\n           \\<lbrakk>\\<alpha> m u = Some v; P (u, v)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<alpha> m ua = Some va; P (ua, va)\\<rbrakk>\n       \\<Longrightarrow> ?P4 ua va (ua, va)\n 3. \\<And>ua va uaa vaa.\n       \\<lbrakk>sel' m P = Some (u, v);\n        \\<And>u v.\n           \\<lbrakk>\\<alpha> m u = Some v; P (u, v)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<alpha> m ua = Some va; P (ua, va);\n        sel' m (?P4 ua va) = Some (uaa, vaa); \\<alpha> m uaa = Some vaa;\n        ?P4 ua va (uaa, vaa)\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<lbrakk>invar m; sel' m P = Some (u, v);\n     \\<And>u v.\n        \\<lbrakk>\\<alpha> m u = Some v; P (u, v)\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<nexists>u v. \\<alpha> m u = Some v \\<and> P (u, v)\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply assumption"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ua va.\n       \\<lbrakk>sel' m P = Some (u, v);\n        \\<And>u v.\n           \\<lbrakk>\\<alpha> m u = Some v; P (u, v)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<alpha> m ua = Some va; P (ua, va)\\<rbrakk>\n       \\<Longrightarrow> ?P4 ua va (ua, va)\n 2. \\<And>ua va uaa vaa.\n       \\<lbrakk>sel' m P = Some (u, v);\n        \\<And>u v.\n           \\<lbrakk>\\<alpha> m u = Some v; P (u, v)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<alpha> m ua = Some va; P (ua, va);\n        sel' m (?P4 ua va) = Some (uaa, vaa); \\<alpha> m uaa = Some vaa;\n        ?P4 ua va (uaa, vaa)\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<lbrakk>invar m; sel' m P = Some (u, v);\n     \\<And>u v.\n        \\<lbrakk>\\<alpha> m u = Some v; P (u, v)\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<nexists>u v. \\<alpha> m u = Some v \\<and> P (u, v)\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply assumption"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ua va uaa vaa.\n       \\<lbrakk>sel' m P = Some (u, v);\n        \\<And>u v.\n           \\<lbrakk>\\<alpha> m u = Some v; P (u, v)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<alpha> m ua = Some va; P (ua, va);\n        sel' m (\\<lambda>a. sel' m P = Some (u, v)) = Some (uaa, vaa);\n        \\<alpha> m uaa = Some vaa; sel' m P = Some (u, v)\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<lbrakk>invar m; sel' m P = Some (u, v);\n     \\<And>u v.\n        \\<lbrakk>\\<alpha> m u = Some v; P (u, v)\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<nexists>u v. \\<alpha> m u = Some v \\<and> P (u, v)\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar m; sel' m P = Some (u, v);\n     \\<And>u v.\n        \\<lbrakk>\\<alpha> m u = Some v; P (u, v)\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<nexists>u v. \\<alpha> m u = Some v \\<and> P (u, v)\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar m; sel' m P = Some (u, v);\n     \\<forall>u v.\n        \\<alpha> m u = Some v \\<longrightarrow> \\<not> P (u, v)\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply (drule (1) sel'I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sel' m P = Some (u, v);\n     \\<forall>u v. \\<alpha> m u = Some v \\<longrightarrow> \\<not> P (u, v);\n     sel' m P = None\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sel'_noneD: \"\\<lbrakk>invar m; sel' m P = None; \\<alpha> m u = Some v\\<rbrakk> \\<Longrightarrow> \\<not> P (u, v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar m; sel' m P = None; \\<alpha> m u = Some v\\<rbrakk>\n    \\<Longrightarrow> \\<not> P (u, v)", "apply (rule ccontr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar m; sel' m P = None; \\<alpha> m u = Some v;\n     \\<not> \\<not> P (u, v)\\<rbrakk>\n    \\<Longrightarrow> False", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar m; sel' m P = None; \\<alpha> m u = Some v;\n     P (u, v)\\<rbrakk>\n    \\<Longrightarrow> False", "apply (erule (2) sel'E[where P=P])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ua va.\n       \\<lbrakk>sel' m P = None; \\<alpha> m u = Some v; P (u, v);\n        sel' m P = Some (ua, va); \\<alpha> m ua = Some va;\n        P (ua, va)\\<rbrakk>\n       \\<Longrightarrow> False", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sel'_SomeD:\n    \"\\<lbrakk> sel' m P = Some (u, v); invar m \\<rbrakk> \\<Longrightarrow> \\<alpha> m u = Some v \\<and> P (u, v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sel' m P = Some (u, v); invar m\\<rbrakk>\n    \\<Longrightarrow> \\<alpha> m u = Some v \\<and> P (u, v)", "apply(cases \"\\<exists>u' v'. \\<alpha> m u' = Some v' \\<and> P (u', v')\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>sel' m P = Some (u, v); invar m;\n     \\<exists>u' v'. \\<alpha> m u' = Some v' \\<and> P (u', v')\\<rbrakk>\n    \\<Longrightarrow> \\<alpha> m u = Some v \\<and> P (u, v)\n 2. \\<lbrakk>sel' m P = Some (u, v); invar m;\n     \\<nexists>u' v'. \\<alpha> m u' = Some v' \\<and> P (u', v')\\<rbrakk>\n    \\<Longrightarrow> \\<alpha> m u = Some v \\<and> P (u, v)", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>u' v'.\n       \\<lbrakk>sel' m P = Some (u, v); invar m; \\<alpha> m u' = Some v';\n        P (u', v')\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> m u = Some v \\<and> P (u, v)\n 2. \\<lbrakk>sel' m P = Some (u, v); invar m;\n     \\<nexists>u' v'. \\<alpha> m u' = Some v' \\<and> P (u', v')\\<rbrakk>\n    \\<Longrightarrow> \\<alpha> m u = Some v \\<and> P (u, v)", "apply(erule (2) sel'E[where P=P])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>u' v' ua va.\n       \\<lbrakk>sel' m P = Some (u, v); \\<alpha> m u' = Some v'; P (u', v');\n        sel' m P = Some (ua, va); \\<alpha> m ua = Some va;\n        P (ua, va)\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> m u = Some v \\<and> P (u, v)\n 2. \\<lbrakk>sel' m P = Some (u, v); invar m;\n     \\<nexists>u' v'. \\<alpha> m u' = Some v' \\<and> P (u', v')\\<rbrakk>\n    \\<Longrightarrow> \\<alpha> m u = Some v \\<and> P (u, v)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sel' m P = Some (u, v); invar m;\n     \\<nexists>u' v'. \\<alpha> m u' = Some v' \\<and> P (u', v')\\<rbrakk>\n    \\<Longrightarrow> \\<alpha> m u = Some v \\<and> P (u, v)", "apply(clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sel' m P = Some (u, v); invar m;\n     \\<forall>u' v'.\n        \\<alpha> m u' = Some v' \\<longrightarrow> \\<not> P (u', v')\\<rbrakk>\n    \\<Longrightarrow> \\<alpha> m u = Some v \\<and> P (u, v)", "apply(drule (1) sel'I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sel' m P = Some (u, v);\n     \\<forall>u' v'.\n        \\<alpha> m u' = Some v' \\<longrightarrow> \\<not> P (u', v');\n     sel' m P = None\\<rbrakk>\n    \\<Longrightarrow> \\<alpha> m u = Some v \\<and> P (u, v)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "subsubsection \"Map to List Conversion\""], ["", "type_synonym ('k,'v,'s) map_to_list = \"'s \\<Rightarrow> ('k\\<times>'v) list\""], ["", "locale map_to_list = map +\n  constrains \\<alpha> :: \"'s \\<Rightarrow> 'u \\<rightharpoonup> 'v\"\n  fixes to_list :: \"'s \\<Rightarrow> ('u\\<times>'v) list\"\n  assumes to_list_correct: \n    \"invar m \\<Longrightarrow> map_of (to_list m) = \\<alpha> m\"\n    \"invar m \\<Longrightarrow> distinct (map fst (to_list m))\""], ["", "subsubsection \"List to Map Conversion\""], ["", "type_synonym ('k,'v,'s) list_to_map = \"('k\\<times>'v) list \\<Rightarrow> 's\""], ["", "locale list_to_map = map +\n  constrains \\<alpha> :: \"'s \\<Rightarrow> 'u \\<rightharpoonup> 'v\"\n  fixes to_map :: \"('u\\<times>'v) list \\<Rightarrow> 's\"\n  assumes to_map_correct:\n    \"\\<alpha> (to_map l) = map_of l\"\n    \"invar (to_map l)\""], ["", "subsubsection \"Image of a Map\""], ["", "text \\<open>This locale allows to apply a function to both the keys and\n the values of a map while at the same time filtering entries.\\<close>"], ["", "definition transforms_to_unique_keys ::\n  \"('u1 \\<rightharpoonup> 'v1) \\<Rightarrow> ('u1 \\<times> 'v1 \\<rightharpoonup> ('u2 \\<times> 'v2)) \\<Rightarrow> bool\"\n  where\n  \"transforms_to_unique_keys m f \\<equiv> (\\<forall>k1 k2 v1 v2 k' v1' v2'. ( \n         m k1 = Some v1 \\<and>\n         m k2 = Some v2 \\<and>\n         f (k1, v1) = Some (k', v1') \\<and>\n         f (k2, v2) = Some (k', v2')) -->\n       (k1 = k2))\""], ["", "type_synonym ('k1,'v1,'m1,'k2,'v2,'m2) map_image_filter  \n  = \"('k1 \\<times> 'v1 \\<Rightarrow> ('k2 \\<times> 'v2) option) \\<Rightarrow> 'm1 \\<Rightarrow> 'm2\""], ["", "locale map_image_filter = m1: map \\<alpha>1 invar1 + m2: map \\<alpha>2 invar2\n  for \\<alpha>1 :: \"'m1 \\<Rightarrow> 'u1 \\<rightharpoonup> 'v1\" and invar1\n  and \\<alpha>2 :: \"'m2 \\<Rightarrow> 'u2 \\<rightharpoonup> 'v2\" and invar2\n  +\n  fixes map_image_filter :: \"('u1 \\<times> 'v1 \\<Rightarrow> ('u2 \\<times> 'v2) option) \\<Rightarrow> 'm1 \\<Rightarrow> 'm2\"\n  assumes map_image_filter_correct_aux1:\n    \"\\<And>k' v'. \n     \\<lbrakk>invar1 m; transforms_to_unique_keys (\\<alpha>1 m) f\\<rbrakk> \\<Longrightarrow> \n     (invar2 (map_image_filter f m) \\<and>\n      ((\\<alpha>2 (map_image_filter f m) k' = Some v') \\<longleftrightarrow>\n       (\\<exists>k v. (\\<alpha>1 m k = Some v) \\<and> f (k, v) = Some (k', v'))))\"\nbegin"], ["", "(*Let's use a definition for the precondition *)"], ["", "lemma map_image_filter_correct_aux2 :\n    assumes \"invar1 m\" \n      and \"transforms_to_unique_keys (\\<alpha>1 m) f\"\n    shows \"(\\<alpha>2 (map_image_filter f m) k' = None) \\<longleftrightarrow>\n      (\\<forall>k v v'. \\<alpha>1 m k = Some v \\<longrightarrow> f (k, v) \\<noteq> Some (k', v'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<alpha>2 (map_image_filter f m) k' = None) =\n    (\\<forall>k v v'.\n        \\<alpha>1 m k = Some v \\<longrightarrow>\n        f (k, v) \\<noteq> Some (k', v'))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<alpha>2 (map_image_filter f m) k' = None) =\n    (\\<forall>k v v'.\n        \\<alpha>1 m k = Some v \\<longrightarrow>\n        f (k, v) \\<noteq> Some (k', v'))", "note map_image_filter_correct_aux1 [OF assms]"], ["proof (state)\nthis:\n  invar2 (map_image_filter f m) \\<and>\n  (\\<alpha>2 (map_image_filter f m) ?k' = Some ?v') =\n  (\\<exists>k v. \\<alpha>1 m k = Some v \\<and> f (k, v) = Some (?k', ?v'))\n\ngoal (1 subgoal):\n 1. (\\<alpha>2 (map_image_filter f m) k' = None) =\n    (\\<forall>k v v'.\n        \\<alpha>1 m k = Some v \\<longrightarrow>\n        f (k, v) \\<noteq> Some (k', v'))", "have Some_eq: \"\\<And>v'. (\\<alpha>2 (map_image_filter f m) k' = Some v') =\n          (\\<exists>k v. \\<alpha>1 m k = Some v \\<and> f (k, v) = Some (k', v'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v'.\n       (\\<alpha>2 (map_image_filter f m) k' = Some v') =\n       (\\<exists>k v.\n           \\<alpha>1 m k = Some v \\<and> f (k, v) = Some (k', v'))", "by (simp add: map_image_filter_correct_aux1 [OF assms])"], ["proof (state)\nthis:\n  (\\<alpha>2 (map_image_filter f m) k' = Some ?v') =\n  (\\<exists>k v. \\<alpha>1 m k = Some v \\<and> f (k, v) = Some (k', ?v'))\n\ngoal (1 subgoal):\n 1. (\\<alpha>2 (map_image_filter f m) k' = None) =\n    (\\<forall>k v v'.\n        \\<alpha>1 m k = Some v \\<longrightarrow>\n        f (k, v) \\<noteq> Some (k', v'))", "have intro_some: \"(\\<alpha>2 (map_image_filter f m) k' = None) \\<longleftrightarrow>\n                      (\\<forall>v'. \\<alpha>2 (map_image_filter f m) k' \\<noteq> Some v')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<alpha>2 (map_image_filter f m) k' = None) =\n    (\\<forall>v'. \\<alpha>2 (map_image_filter f m) k' \\<noteq> Some v')", "by auto"], ["proof (state)\nthis:\n  (\\<alpha>2 (map_image_filter f m) k' = None) =\n  (\\<forall>v'. \\<alpha>2 (map_image_filter f m) k' \\<noteq> Some v')\n\ngoal (1 subgoal):\n 1. (\\<alpha>2 (map_image_filter f m) k' = None) =\n    (\\<forall>k v v'.\n        \\<alpha>1 m k = Some v \\<longrightarrow>\n        f (k, v) \\<noteq> Some (k', v'))", "from intro_some Some_eq"], ["proof (chain)\npicking this:\n  (\\<alpha>2 (map_image_filter f m) k' = None) =\n  (\\<forall>v'. \\<alpha>2 (map_image_filter f m) k' \\<noteq> Some v')\n  (\\<alpha>2 (map_image_filter f m) k' = Some ?v') =\n  (\\<exists>k v. \\<alpha>1 m k = Some v \\<and> f (k, v) = Some (k', ?v'))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<alpha>2 (map_image_filter f m) k' = None) =\n  (\\<forall>v'. \\<alpha>2 (map_image_filter f m) k' \\<noteq> Some v')\n  (\\<alpha>2 (map_image_filter f m) k' = Some ?v') =\n  (\\<exists>k v. \\<alpha>1 m k = Some v \\<and> f (k, v) = Some (k', ?v'))\n\ngoal (1 subgoal):\n 1. (\\<alpha>2 (map_image_filter f m) k' = None) =\n    (\\<forall>k v v'.\n        \\<alpha>1 m k = Some v \\<longrightarrow>\n        f (k, v) \\<noteq> Some (k', v'))", "by auto"], ["proof (state)\nthis:\n  (\\<alpha>2 (map_image_filter f m) k' = None) =\n  (\\<forall>k v v'.\n      \\<alpha>1 m k = Some v \\<longrightarrow>\n      f (k, v) \\<noteq> Some (k', v'))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas map_image_filter_correct = \n     conjunct1 [OF map_image_filter_correct_aux1] \n     conjunct2 [OF map_image_filter_correct_aux1] \n     map_image_filter_correct_aux2"], ["", "end"], ["", "text \\<open>Most of the time the mapping function is only applied to values. Then,\n  the precondition disapears.\\<close>"], ["", "type_synonym ('k,'v1,'m1,'k2,'v2,'m2) map_value_image_filter  \n  = \"('k \\<Rightarrow> 'v1 \\<Rightarrow> 'v2 option) \\<Rightarrow> 'm1 \\<Rightarrow> 'm2\""], ["", "locale map_value_image_filter = m1: map \\<alpha>1 invar1 + m2: map \\<alpha>2 invar2\n  for \\<alpha>1 :: \"'m1 \\<Rightarrow> 'u \\<rightharpoonup> 'v1\" and invar1\n  and \\<alpha>2 :: \"'m2 \\<Rightarrow> 'u \\<rightharpoonup> 'v2\" and invar2\n  +\n  fixes map_value_image_filter :: \"('u \\<Rightarrow> 'v1 \\<Rightarrow> 'v2 option) \\<Rightarrow> 'm1 \\<Rightarrow> 'm2\"\n  assumes map_value_image_filter_correct_aux:\n    \"invar1 m \\<Longrightarrow> \n     invar2 (map_value_image_filter f m) \\<and>\n     (\\<alpha>2 (map_value_image_filter f m) = \n      (\\<lambda>k. Option.bind (\\<alpha>1 m k) (f k)))\"\nbegin"], ["", "lemmas map_value_image_filter_correct =\n    conjunct1[OF map_value_image_filter_correct_aux]\n    conjunct2[OF map_value_image_filter_correct_aux]"], ["", "lemma map_value_image_filter_correct_alt :\n    \"invar1 m \\<Longrightarrow> \n     invar2 (map_value_image_filter f m)\"\n    \"invar1 m \\<Longrightarrow>\n     (\\<alpha>2 (map_value_image_filter f m) k = Some v') \\<longleftrightarrow>\n     (\\<exists>v. (\\<alpha>1 m k = Some v) \\<and> f k v = Some v')\"\n    \"invar1 m \\<Longrightarrow>\n     (\\<alpha>2 (map_value_image_filter f m) k = None) \\<longleftrightarrow>\n     (\\<forall>v. (\\<alpha>1 m k = Some v) --> f k v = None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (invar1 m \\<Longrightarrow> invar2 (map_value_image_filter f m)) &&&\n    (invar1 m \\<Longrightarrow>\n     (\\<alpha>2 (map_value_image_filter f m) k = Some v') =\n     (\\<exists>v. \\<alpha>1 m k = Some v \\<and> f k v = Some v')) &&&\n    (invar1 m \\<Longrightarrow>\n     (\\<alpha>2 (map_value_image_filter f m) k = None) =\n     (\\<forall>v. \\<alpha>1 m k = Some v \\<longrightarrow> f k v = None))", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. invar1 m \\<Longrightarrow> invar2 (map_value_image_filter f m)\n 2. invar1 m \\<Longrightarrow>\n    (\\<alpha>2 (map_value_image_filter f m) k = Some v') =\n    (\\<exists>v. \\<alpha>1 m k = Some v \\<and> f k v = Some v')\n 3. invar1 m \\<Longrightarrow>\n    (\\<alpha>2 (map_value_image_filter f m) k = None) =\n    (\\<forall>v. \\<alpha>1 m k = Some v \\<longrightarrow> f k v = None)", "assume invar_m : \"invar1 m\""], ["proof (state)\nthis:\n  invar1 m\n\ngoal (3 subgoals):\n 1. invar1 m \\<Longrightarrow> invar2 (map_value_image_filter f m)\n 2. invar1 m \\<Longrightarrow>\n    (\\<alpha>2 (map_value_image_filter f m) k = Some v') =\n    (\\<exists>v. \\<alpha>1 m k = Some v \\<and> f k v = Some v')\n 3. invar1 m \\<Longrightarrow>\n    (\\<alpha>2 (map_value_image_filter f m) k = None) =\n    (\\<forall>v. \\<alpha>1 m k = Some v \\<longrightarrow> f k v = None)", "note aux = map_value_image_filter_correct_aux [OF invar_m]"], ["proof (state)\nthis:\n  invar2 (map_value_image_filter ?f m) \\<and>\n  \\<alpha>2 (map_value_image_filter ?f m) =\n  (\\<lambda>k. \\<alpha>1 m k \\<bind> ?f k)\n\ngoal (3 subgoals):\n 1. invar1 m \\<Longrightarrow> invar2 (map_value_image_filter f m)\n 2. invar1 m \\<Longrightarrow>\n    (\\<alpha>2 (map_value_image_filter f m) k = Some v') =\n    (\\<exists>v. \\<alpha>1 m k = Some v \\<and> f k v = Some v')\n 3. invar1 m \\<Longrightarrow>\n    (\\<alpha>2 (map_value_image_filter f m) k = None) =\n    (\\<forall>v. \\<alpha>1 m k = Some v \\<longrightarrow> f k v = None)", "from aux"], ["proof (chain)\npicking this:\n  invar2 (map_value_image_filter ?f m) \\<and>\n  \\<alpha>2 (map_value_image_filter ?f m) =\n  (\\<lambda>k. \\<alpha>1 m k \\<bind> ?f k)", "show \"invar2 (map_value_image_filter f m)\""], ["proof (prove)\nusing this:\n  invar2 (map_value_image_filter ?f m) \\<and>\n  \\<alpha>2 (map_value_image_filter ?f m) =\n  (\\<lambda>k. \\<alpha>1 m k \\<bind> ?f k)\n\ngoal (1 subgoal):\n 1. invar2 (map_value_image_filter f m)", "by simp"], ["proof (state)\nthis:\n  invar2 (map_value_image_filter f m)\n\ngoal (2 subgoals):\n 1. invar1 m \\<Longrightarrow>\n    (\\<alpha>2 (map_value_image_filter f m) k = Some v') =\n    (\\<exists>v. \\<alpha>1 m k = Some v \\<and> f k v = Some v')\n 2. invar1 m \\<Longrightarrow>\n    (\\<alpha>2 (map_value_image_filter f m) k = None) =\n    (\\<forall>v. \\<alpha>1 m k = Some v \\<longrightarrow> f k v = None)", "from aux"], ["proof (chain)\npicking this:\n  invar2 (map_value_image_filter ?f m) \\<and>\n  \\<alpha>2 (map_value_image_filter ?f m) =\n  (\\<lambda>k. \\<alpha>1 m k \\<bind> ?f k)", "show \"(\\<alpha>2 (map_value_image_filter f m) k = Some v') \\<longleftrightarrow>\n     (\\<exists>v. (\\<alpha>1 m k = Some v) \\<and> f k v = Some v')\""], ["proof (prove)\nusing this:\n  invar2 (map_value_image_filter ?f m) \\<and>\n  \\<alpha>2 (map_value_image_filter ?f m) =\n  (\\<lambda>k. \\<alpha>1 m k \\<bind> ?f k)\n\ngoal (1 subgoal):\n 1. (\\<alpha>2 (map_value_image_filter f m) k = Some v') =\n    (\\<exists>v. \\<alpha>1 m k = Some v \\<and> f k v = Some v')", "by (cases \"\\<alpha>1 m k\", simp_all)"], ["proof (state)\nthis:\n  (\\<alpha>2 (map_value_image_filter f m) k = Some v') =\n  (\\<exists>v. \\<alpha>1 m k = Some v \\<and> f k v = Some v')\n\ngoal (1 subgoal):\n 1. invar1 m \\<Longrightarrow>\n    (\\<alpha>2 (map_value_image_filter f m) k = None) =\n    (\\<forall>v. \\<alpha>1 m k = Some v \\<longrightarrow> f k v = None)", "from aux"], ["proof (chain)\npicking this:\n  invar2 (map_value_image_filter ?f m) \\<and>\n  \\<alpha>2 (map_value_image_filter ?f m) =\n  (\\<lambda>k. \\<alpha>1 m k \\<bind> ?f k)", "show \"(\\<alpha>2 (map_value_image_filter f m) k = None) \\<longleftrightarrow>\n     (\\<forall>v. (\\<alpha>1 m k = Some v) --> f k v = None)\""], ["proof (prove)\nusing this:\n  invar2 (map_value_image_filter ?f m) \\<and>\n  \\<alpha>2 (map_value_image_filter ?f m) =\n  (\\<lambda>k. \\<alpha>1 m k \\<bind> ?f k)\n\ngoal (1 subgoal):\n 1. (\\<alpha>2 (map_value_image_filter f m) k = None) =\n    (\\<forall>v. \\<alpha>1 m k = Some v \\<longrightarrow> f k v = None)", "by (cases \"\\<alpha>1 m k\", simp_all)"], ["proof (state)\nthis:\n  (\\<alpha>2 (map_value_image_filter f m) k = None) =\n  (\\<forall>v. \\<alpha>1 m k = Some v \\<longrightarrow> f k v = None)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "type_synonym ('k,'v,'m1,'m2) map_restrict = \"('k \\<times> 'v \\<Rightarrow> bool) \\<Rightarrow> 'm1 \\<Rightarrow> 'm2\""], ["", "locale map_restrict = m1: map \\<alpha>1 invar1 + m2: map \\<alpha>2 invar2 \n  for \\<alpha>1 :: \"'m1 \\<Rightarrow> 'u \\<rightharpoonup> 'v\" and invar1\n  and \\<alpha>2 :: \"'m2 \\<Rightarrow> 'u \\<rightharpoonup> 'v\" and invar2\n  +\n  fixes restrict :: \"('u \\<times> 'v \\<Rightarrow> bool) \\<Rightarrow> 'm1 \\<Rightarrow> 'm2\"\n  assumes restrict_correct_aux1 :\n    \"invar1 m \\<Longrightarrow> \\<alpha>2 (restrict P m) = \\<alpha>1 m |` {k. \\<exists>v. \\<alpha>1 m k = Some v \\<and> P (k, v)}\"\n    \"invar1 m \\<Longrightarrow> invar2 (restrict P m)\"\nbegin"], ["", "lemma restrict_correct_aux2 :\n    \"invar1 m \\<Longrightarrow> \\<alpha>2 (restrict (\\<lambda>(k,_). P k) m) = \\<alpha>1 m |` {k. P k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar1 m \\<Longrightarrow>\n    \\<alpha>2 (restrict (\\<lambda>(k, uu_). P k) m) =\n    \\<alpha>1 m |` {k. P k}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. invar1 m \\<Longrightarrow>\n    \\<alpha>2 (restrict (\\<lambda>(k, uu_). P k) m) =\n    \\<alpha>1 m |` {k. P k}", "assume invar_m : \"invar1 m\""], ["proof (state)\nthis:\n  invar1 m\n\ngoal (1 subgoal):\n 1. invar1 m \\<Longrightarrow>\n    \\<alpha>2 (restrict (\\<lambda>(k, uu_). P k) m) =\n    \\<alpha>1 m |` {k. P k}", "have \"\\<alpha>1 m |` {k. (\\<exists>v. \\<alpha>1 m k = Some v) \\<and> P k} = \\<alpha>1 m |` {k. P k}\"\n      (is \"\\<alpha>1 m |` ?A1 = \\<alpha>1 m |` ?A2\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha>1 m |` {k. (\\<exists>v. \\<alpha>1 m k = Some v) \\<and> P k} =\n    \\<alpha>1 m |` {k. P k}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<alpha>1 m |` {k. (\\<exists>v. \\<alpha>1 m k = Some v) \\<and> P k})\n        x =\n       (\\<alpha>1 m |` {k. P k}) x", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<alpha>1 m |` {k. (\\<exists>v. \\<alpha>1 m k = Some v) \\<and> P k})\n        x =\n       (\\<alpha>1 m |` {k. P k}) x", "show \"(\\<alpha>1 m |` ?A1) k = (\\<alpha>1 m |` ?A2) k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<alpha>1 m |` {k. (\\<exists>v. \\<alpha>1 m k = Some v) \\<and> P k})\n     k =\n    (\\<alpha>1 m |` {k. P k}) k", "proof (cases \"k \\<in> ?A2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k \\<in> {k. P k} \\<Longrightarrow>\n    (\\<alpha>1 m |` {k. (\\<exists>v. \\<alpha>1 m k = Some v) \\<and> P k})\n     k =\n    (\\<alpha>1 m |` {k. P k}) k\n 2. k \\<notin> {k. P k} \\<Longrightarrow>\n    (\\<alpha>1 m |` {k. (\\<exists>v. \\<alpha>1 m k = Some v) \\<and> P k})\n     k =\n    (\\<alpha>1 m |` {k. P k}) k", "case False"], ["proof (state)\nthis:\n  k \\<notin> {k. P k}\n\ngoal (2 subgoals):\n 1. k \\<in> {k. P k} \\<Longrightarrow>\n    (\\<alpha>1 m |` {k. (\\<exists>v. \\<alpha>1 m k = Some v) \\<and> P k})\n     k =\n    (\\<alpha>1 m |` {k. P k}) k\n 2. k \\<notin> {k. P k} \\<Longrightarrow>\n    (\\<alpha>1 m |` {k. (\\<exists>v. \\<alpha>1 m k = Some v) \\<and> P k})\n     k =\n    (\\<alpha>1 m |` {k. P k}) k", "thus ?thesis"], ["proof (prove)\nusing this:\n  k \\<notin> {k. P k}\n\ngoal (1 subgoal):\n 1. (\\<alpha>1 m |` {k. (\\<exists>v. \\<alpha>1 m k = Some v) \\<and> P k})\n     k =\n    (\\<alpha>1 m |` {k. P k}) k", "by simp"], ["proof (state)\nthis:\n  (\\<alpha>1 m |` {k. (\\<exists>v. \\<alpha>1 m k = Some v) \\<and> P k}) k =\n  (\\<alpha>1 m |` {k. P k}) k\n\ngoal (1 subgoal):\n 1. k \\<in> {k. P k} \\<Longrightarrow>\n    (\\<alpha>1 m |` {k. (\\<exists>v. \\<alpha>1 m k = Some v) \\<and> P k})\n     k =\n    (\\<alpha>1 m |` {k. P k}) k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<in> {k. P k} \\<Longrightarrow>\n    (\\<alpha>1 m |` {k. (\\<exists>v. \\<alpha>1 m k = Some v) \\<and> P k})\n     k =\n    (\\<alpha>1 m |` {k. P k}) k", "case True"], ["proof (state)\nthis:\n  k \\<in> {k. P k}\n\ngoal (1 subgoal):\n 1. k \\<in> {k. P k} \\<Longrightarrow>\n    (\\<alpha>1 m |` {k. (\\<exists>v. \\<alpha>1 m k = Some v) \\<and> P k})\n     k =\n    (\\<alpha>1 m |` {k. P k}) k", "hence P_k : \"P k\""], ["proof (prove)\nusing this:\n  k \\<in> {k. P k}\n\ngoal (1 subgoal):\n 1. P k", "by simp"], ["proof (state)\nthis:\n  P k\n\ngoal (1 subgoal):\n 1. k \\<in> {k. P k} \\<Longrightarrow>\n    (\\<alpha>1 m |` {k. (\\<exists>v. \\<alpha>1 m k = Some v) \\<and> P k})\n     k =\n    (\\<alpha>1 m |` {k. P k}) k", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<alpha>1 m |` {k. (\\<exists>v. \\<alpha>1 m k = Some v) \\<and> P k})\n     k =\n    (\\<alpha>1 m |` {k. P k}) k", "by (cases \"\\<alpha>1 m k\", simp_all add: P_k)"], ["proof (state)\nthis:\n  (\\<alpha>1 m |` {k. (\\<exists>v. \\<alpha>1 m k = Some v) \\<and> P k}) k =\n  (\\<alpha>1 m |` {k. P k}) k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<alpha>1 m |` {k. (\\<exists>v. \\<alpha>1 m k = Some v) \\<and> P k}) k =\n  (\\<alpha>1 m |` {k. P k}) k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<alpha>1 m |` {k. (\\<exists>v. \\<alpha>1 m k = Some v) \\<and> P k} =\n  \\<alpha>1 m |` {k. P k}\n\ngoal (1 subgoal):\n 1. invar1 m \\<Longrightarrow>\n    \\<alpha>2 (restrict (\\<lambda>(k, uu_). P k) m) =\n    \\<alpha>1 m |` {k. P k}", "with invar_m"], ["proof (chain)\npicking this:\n  invar1 m\n  \\<alpha>1 m |` {k. (\\<exists>v. \\<alpha>1 m k = Some v) \\<and> P k} =\n  \\<alpha>1 m |` {k. P k}", "show \"\\<alpha>2 (restrict (\\<lambda>(k, _). P k) m) = \\<alpha>1 m |` {k. P k}\""], ["proof (prove)\nusing this:\n  invar1 m\n  \\<alpha>1 m |` {k. (\\<exists>v. \\<alpha>1 m k = Some v) \\<and> P k} =\n  \\<alpha>1 m |` {k. P k}\n\ngoal (1 subgoal):\n 1. \\<alpha>2 (restrict (\\<lambda>(k, uu_). P k) m) =\n    \\<alpha>1 m |` {k. P k}", "by (simp add: restrict_correct_aux1)"], ["proof (state)\nthis:\n  \\<alpha>2 (restrict (\\<lambda>(k, uu_). P k) m) = \\<alpha>1 m |` {k. P k}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas restrict_correct = \n     restrict_correct_aux1\n     restrict_correct_aux2"], ["", "end"], ["", "subsection \"Ordered Maps\""], ["", "locale ordered_map = map \\<alpha> invar \n    for \\<alpha> :: \"'s \\<Rightarrow> ('u::linorder) \\<rightharpoonup> 'v\" and invar"], ["", "locale ordered_finite_map = finite_map \\<alpha> invar + ordered_map \\<alpha> invar\n    for \\<alpha> :: \"'s \\<Rightarrow> ('u::linorder) \\<rightharpoonup> 'v\" and invar"], ["", "subsubsection \\<open>Ordered Iteration\\<close>"], ["", "(* Deprecated *)\n(*\n  locale map_iterateoi = ordered_finite_map \\<alpha> invar\n    for \\<alpha> :: \"'s \\<Rightarrow> ('u::linorder) \\<rightharpoonup> 'v\" and invar\n    +\n    fixes iterateoi :: \"'s \\<Rightarrow> ('u \\<times> 'v,'\\<sigma>) set_iterator\"\n    assumes iterateoi_rule: \"\n      invar m \\<Longrightarrow> map_iterator_linord (iterateoi m) (\\<alpha> m)\"\n  begin\n    lemma iterateoi_rule_P[case_names minv inv0 inv_pres i_complete i_inter]:\n      assumes MINV: \"invar m\"\n      assumes I0: \"I (dom (\\<alpha> m)) \\<sigma>0\"\n      assumes IP: \"!!k v it \\<sigma>. \\<lbrakk> \n        c \\<sigma>; \n        k \\<in> it; \n        \\<forall>j\\<in>it. k\\<le>j; \n        \\<forall>j\\<in>dom (\\<alpha> m) - it. j\\<le>k; \n        \\<alpha> m k = Some v; \n        it \\<subseteq> dom (\\<alpha> m); \n        I it \\<sigma> \n      \\<rbrakk> \\<Longrightarrow> I (it - {k}) (f (k, v) \\<sigma>)\"\n      assumes IF: \"!!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n      assumes II: \"!!\\<sigma> it. \\<lbrakk> \n        it \\<subseteq> dom (\\<alpha> m); \n        it \\<noteq> {}; \n        \\<not> c \\<sigma>; \n        I it \\<sigma>; \n        \\<forall>k\\<in>it. \\<forall>j\\<in>dom (\\<alpha> m) - it. j\\<le>k \n      \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n      shows \"P (iterateoi m c f \\<sigma>0)\"\n    using map_iterator_linord_rule_P [OF iterateoi_rule, of m I \\<sigma>0 c f P] assms\n    by simp\n\n    lemma iterateo_rule_P[case_names minv inv0 inv_pres i_complete]: \n      assumes MINV: \"invar m\"\n      assumes I0: \"I (dom (\\<alpha> m)) \\<sigma>0\"\n      assumes IP: \"!!k v it \\<sigma>. \\<lbrakk> k \\<in> it; \\<forall>j\\<in>it. k\\<le>j; \\<forall>j\\<in>dom (\\<alpha> m) - it. j\\<le>k; \\<alpha> m k = Some v; it \\<subseteq> dom (\\<alpha> m); I it \\<sigma> \\<rbrakk> \n                  \\<Longrightarrow> I (it - {k}) (f (k, v) \\<sigma>)\"\n      assumes IF: \"!!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n      shows \"P (iterateoi m (\\<lambda>_. True) f \\<sigma>0)\"\n    using map_iterator_linord_rule_P [OF iterateoi_rule, of m I \\<sigma>0 \"\\<lambda>_. True\" f P] assms\n    by simp\n  end\n\n  lemma map_iterateoi_I :\n  assumes \"\\<And>m. invar m \\<Longrightarrow> map_iterator_linord (itoi m) (\\<alpha> m)\"\n  shows \"map_iterateoi \\<alpha> invar itoi\"\n  proof\n    fix m \n    assume invar_m: \"invar m\"\n    from assms(1)[OF invar_m] show it_OK: \"map_iterator_linord (itoi m) (\\<alpha> m)\" .\n  \n    from set_iterator_genord.finite_S0 [OF it_OK[unfolded set_iterator_map_linord_def]]\n    show \"finite (dom (\\<alpha> m))\" by (simp add: finite_map_to_set) \n  qed\n\n  locale map_reverse_iterateoi = ordered_finite_map \\<alpha> invar \n    for \\<alpha> :: \"'s \\<Rightarrow> ('u::linorder) \\<rightharpoonup> 'v\" and invar\n    +\n    fixes reverse_iterateoi :: \"'s \\<Rightarrow> ('u \\<times> 'v,'\\<sigma>) set_iterator\"\n    assumes reverse_iterateoi_rule: \"\n      invar m \\<Longrightarrow> map_iterator_rev_linord (reverse_iterateoi m) (\\<alpha> m)\"\n  begin\n    lemma reverse_iterateoi_rule_P[case_names minv inv0 inv_pres i_complete i_inter]:\n      assumes MINV: \"invar m\"\n      assumes I0: \"I (dom (\\<alpha> m)) \\<sigma>0\"\n      assumes IP: \"!!k v it \\<sigma>. \\<lbrakk> \n        c \\<sigma>; \n        k \\<in> it; \n        \\<forall>j\\<in>it. k\\<ge>j; \n        \\<forall>j\\<in>dom (\\<alpha> m) - it. j\\<ge>k; \n        \\<alpha> m k = Some v; \n        it \\<subseteq> dom (\\<alpha> m); \n        I it \\<sigma> \n      \\<rbrakk> \\<Longrightarrow> I (it - {k}) (f (k, v) \\<sigma>)\"\n      assumes IF: \"!!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n      assumes II: \"!!\\<sigma> it. \\<lbrakk> \n        it \\<subseteq> dom (\\<alpha> m); \n        it \\<noteq> {}; \n        \\<not> c \\<sigma>; \n        I it \\<sigma>; \n        \\<forall>k\\<in>it. \\<forall>j\\<in>dom (\\<alpha> m) - it. j\\<ge>k \n      \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n      shows \"P (reverse_iterateoi m c f \\<sigma>0)\"\n    using map_iterator_rev_linord_rule_P [OF reverse_iterateoi_rule, of m I \\<sigma>0 c f P] assms\n    by simp\n\n    lemma reverse_iterateo_rule_P[case_names minv inv0 inv_pres i_complete]:\n      assumes MINV: \"invar m\"\n      assumes I0: \"I (dom (\\<alpha> m)) \\<sigma>0\"\n      assumes IP: \"!!k v it \\<sigma>. \\<lbrakk> \n        k \\<in> it; \n        \\<forall>j\\<in>it. k\\<ge>j; \n        \\<forall>j\\<in>dom (\\<alpha> m) - it. j\\<ge>k; \n        \\<alpha> m k = Some v; \n        it \\<subseteq> dom (\\<alpha> m); \n        I it \\<sigma> \n      \\<rbrakk> \\<Longrightarrow> I (it - {k}) (f (k, v) \\<sigma>)\"\n      assumes IF: \"!!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n      shows \"P (reverse_iterateoi m (\\<lambda>_. True) f \\<sigma>0)\"\n    using map_iterator_rev_linord_rule_P[OF reverse_iterateoi_rule, of m I \\<sigma>0 \"\\<lambda>_. True\" f P] assms\n    by simp\n  end\n\n  lemma map_reverse_iterateoi_I :\n  assumes \"\\<And>m. invar m \\<Longrightarrow> map_iterator_rev_linord (ritoi m) (\\<alpha> m)\"\n  shows \"map_reverse_iterateoi \\<alpha> invar ritoi\"\n  proof\n    fix m \n    assume invar_m: \"invar m\"\n    from assms(1)[OF invar_m] show it_OK: \"map_iterator_rev_linord (ritoi m) (\\<alpha> m)\" .\n  \n    from set_iterator_genord.finite_S0 [OF it_OK[unfolded set_iterator_map_rev_linord_def]]\n    show \"finite (dom (\\<alpha> m))\" by (simp add: finite_map_to_set) \n  qed\n*)"], ["", "locale poly_map_iterateoi_defs =\n  fixes olist_it :: \"'s \\<Rightarrow> ('u\\<times>'v,('u\\<times>'v) list) set_iterator\"\nbegin"], ["", "definition iterateoi :: \"'s \\<Rightarrow> ('u\\<times>'v,'\\<sigma>) set_iterator\"\n    where \"iterateoi S \\<equiv> it_to_it (olist_it S)\""], ["", "abbreviation \"iterateo m \\<equiv> iterateoi m (\\<lambda>_. True)\""], ["", "end"], ["", "locale poly_map_iterateoi =\n  finite_map \\<alpha> invar + poly_map_iterateoi_defs list_ordered_it\n  for \\<alpha> :: \"'s \\<Rightarrow> ('u::linorder) \\<rightharpoonup> 'v\" \n  and invar \n  and list_ordered_it :: \"'s \\<Rightarrow> ('u\\<times>'v,('u\\<times>'v) list) set_iterator\" +\n  assumes list_ordered_it_correct: \"invar m \n    \\<Longrightarrow> map_iterator_linord (list_ordered_it m) (\\<alpha> m)\"\nbegin"], ["", "lemma iterateoi_correct: \"invar S \\<Longrightarrow> map_iterator_linord (iterateoi S) (\\<alpha> S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar S \\<Longrightarrow> map_iterator_linord (iterateoi S) (\\<alpha> S)", "unfolding iterateoi_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. invar S \\<Longrightarrow>\n    map_iterator_linord (it_to_it (list_ordered_it S)) (\\<alpha> S)", "apply (rule it_to_it_map_linord_correct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. invar S \\<Longrightarrow>\n    map_iterator_linord (list_ordered_it S) (\\<alpha> S)", "by (rule list_ordered_it_correct)"], ["", "lemma pi_iterateoi[icf_proper_iteratorI]: \n    \"proper_it (iterateoi S) (iterateoi S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it (iterateoi S) (iterateoi S)", "unfolding iterateoi_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it (it_to_it (list_ordered_it S)) (it_to_it (list_ordered_it S))", "by (intro icf_proper_iteratorI)"], ["", "lemma iterateoi_rule_P[case_names minv inv0 inv_pres i_complete i_inter]:\n    assumes MINV: \"invar m\"\n    assumes I0: \"I (dom (\\<alpha> m)) \\<sigma>0\"\n    assumes IP: \"!!k v it \\<sigma>. \\<lbrakk> \n      c \\<sigma>; \n      k \\<in> it; \n      \\<alpha> m k = Some v; \n      it \\<subseteq> dom (\\<alpha> m); \n      I it \\<sigma>;\n      \\<And>j. j\\<in>it \\<Longrightarrow> k\\<le>j; \n      \\<And>j. j\\<in>dom (\\<alpha> m) - it \\<Longrightarrow> j\\<le>k\n    \\<rbrakk> \\<Longrightarrow> I (it - {k}) (f (k, v) \\<sigma>)\"\n    assumes IF: \"!!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n    assumes II: \"!!\\<sigma> it. \\<lbrakk> \n      it \\<subseteq> dom (\\<alpha> m); \n      it \\<noteq> {}; \n      \\<not> c \\<sigma>; \n      I it \\<sigma>; \n      \\<And>k j. \\<lbrakk>k\\<in>it; j\\<in>dom (\\<alpha> m) - it\\<rbrakk> \\<Longrightarrow> j\\<le>k \n    \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n    shows \"P (iterateoi m c f \\<sigma>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (iterateoi m c f \\<sigma>0)", "using assms"], ["proof (prove)\nusing this:\n  invar m\n  I (dom (\\<alpha> m)) \\<sigma>0\n  \\<lbrakk>c ?\\<sigma>2; ?k2 \\<in> ?it2; \\<alpha> m ?k2 = Some ?v2;\n   ?it2 \\<subseteq> dom (\\<alpha> m); I ?it2 ?\\<sigma>2;\n   \\<And>j. j \\<in> ?it2 \\<Longrightarrow> ?k2 \\<le> j;\n   \\<And>j.\n      j \\<in> dom (\\<alpha> m) - ?it2 \\<Longrightarrow> j \\<le> ?k2\\<rbrakk>\n  \\<Longrightarrow> I (?it2 - {?k2}) (f (?k2, ?v2) ?\\<sigma>2)\n  I {} ?\\<sigma>2 \\<Longrightarrow> P ?\\<sigma>2\n  \\<lbrakk>?it2 \\<subseteq> dom (\\<alpha> m); ?it2 \\<noteq> {};\n   \\<not> c ?\\<sigma>2; I ?it2 ?\\<sigma>2;\n   \\<And>k j.\n      \\<lbrakk>k \\<in> ?it2; j \\<in> dom (\\<alpha> m) - ?it2\\<rbrakk>\n      \\<Longrightarrow> j \\<le> k\\<rbrakk>\n  \\<Longrightarrow> P ?\\<sigma>2\n\ngoal (1 subgoal):\n 1. P (iterateoi m c f \\<sigma>0)", "by (rule map_iterator_linord_rule_P[OF iterateoi_correct])"], ["", "lemma iterateo_rule_P[case_names minv inv0 inv_pres i_complete]: \n    assumes MINV: \"invar m\"\n    assumes I0: \"I (dom (\\<alpha> m)) \\<sigma>0\"\n    assumes IP: \"!!k v it \\<sigma>. \\<lbrakk> \n      k \\<in> it; \n      \\<alpha> m k = Some v; \n      it \\<subseteq> dom (\\<alpha> m); \n      I it \\<sigma>;\n      \\<And>j. j\\<in>it \\<Longrightarrow> k\\<le>j; \n      \\<And>j. j\\<in>dom (\\<alpha> m) - it \\<Longrightarrow> j\\<le>k\n    \\<rbrakk> \\<Longrightarrow> I (it - {k}) (f (k, v) \\<sigma>)\"\n    assumes IF: \"!!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n    shows \"P (iterateo m f \\<sigma>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (iterateo m f \\<sigma>0)", "using assms \n      map_iterator_linord_rule_P[OF iterateoi_correct, of m I \\<sigma>0 \"\\<lambda>_. True\" f P]"], ["proof (prove)\nusing this:\n  invar m\n  I (dom (\\<alpha> m)) \\<sigma>0\n  \\<lbrakk>?k2 \\<in> ?it2; \\<alpha> m ?k2 = Some ?v2;\n   ?it2 \\<subseteq> dom (\\<alpha> m); I ?it2 ?\\<sigma>2;\n   \\<And>j. j \\<in> ?it2 \\<Longrightarrow> ?k2 \\<le> j;\n   \\<And>j.\n      j \\<in> dom (\\<alpha> m) - ?it2 \\<Longrightarrow> j \\<le> ?k2\\<rbrakk>\n  \\<Longrightarrow> I (?it2 - {?k2}) (f (?k2, ?v2) ?\\<sigma>2)\n  I {} ?\\<sigma>2 \\<Longrightarrow> P ?\\<sigma>2\n  \\<lbrakk>invar m; I (dom (\\<alpha> m)) \\<sigma>0;\n   \\<And>k v it \\<sigma>.\n      \\<lbrakk>True; k \\<in> it; \\<alpha> m k = Some v;\n       it \\<subseteq> dom (\\<alpha> m); I it \\<sigma>;\n       \\<And>k'. k' \\<in> it \\<Longrightarrow> k \\<le> k';\n       \\<And>k'.\n          k' \\<in> dom (\\<alpha> m) - it \\<Longrightarrow>\n          k' \\<le> k\\<rbrakk>\n      \\<Longrightarrow> I (it - {k}) (f (k, v) \\<sigma>);\n   \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>;\n   \\<And>\\<sigma> it.\n      \\<lbrakk>it \\<subseteq> dom (\\<alpha> m); it \\<noteq> {}; \\<not> True;\n       I it \\<sigma>;\n       \\<And>k k'.\n          \\<lbrakk>k \\<in> dom (\\<alpha> m) - it; k' \\<in> it\\<rbrakk>\n          \\<Longrightarrow> k \\<le> k'\\<rbrakk>\n      \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n  \\<Longrightarrow> P (iterateo m f \\<sigma>0)\n\ngoal (1 subgoal):\n 1. P (iterateo m f \\<sigma>0)", "by blast"], ["", "end"], ["", "type_synonym ('k,'v,'s) map_list_rev_it\n  = \"'s \\<Rightarrow> ('k\\<times>'v,('k\\<times>'v) list) set_iterator\""], ["", "locale poly_map_rev_iterateoi_defs =\n  fixes list_rev_it :: \"'s \\<Rightarrow> ('u\\<times>'v,('u\\<times>'v) list) set_iterator\"\nbegin"], ["", "definition rev_iterateoi :: \"'s \\<Rightarrow> ('u\\<times>'v,'\\<sigma>) set_iterator\"\n    where \"rev_iterateoi S \\<equiv> it_to_it (list_rev_it S)\""], ["", "abbreviation \"rev_iterateo m \\<equiv> rev_iterateoi m (\\<lambda>_. True)\""], ["", "abbreviation \"reverse_iterateoi \\<equiv> rev_iterateoi\""], ["", "abbreviation \"reverse_iterateo \\<equiv> rev_iterateo\""], ["", "end"], ["", "locale poly_map_rev_iterateoi =\n  finite_map \\<alpha> invar + poly_map_rev_iterateoi_defs list_rev_it\n  for \\<alpha> :: \"'s \\<Rightarrow> ('u::linorder) \\<rightharpoonup> 'v\" \n  and invar\n  and list_rev_it :: \"'s \\<Rightarrow> ('u\\<times>'v,('u\\<times>'v) list) set_iterator\" +\n  assumes list_rev_it_correct: \n    \"invar m \\<Longrightarrow> map_iterator_rev_linord (list_rev_it m) (\\<alpha> m)\"\nbegin"], ["", "lemma rev_iterateoi_correct: \n    \"invar S \\<Longrightarrow> map_iterator_rev_linord (rev_iterateoi S) (\\<alpha> S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar S \\<Longrightarrow>\n    map_iterator_rev_linord (reverse_iterateoi S) (\\<alpha> S)", "unfolding rev_iterateoi_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. invar S \\<Longrightarrow>\n    map_iterator_rev_linord (it_to_it (list_rev_it S)) (\\<alpha> S)", "apply (rule it_to_it_map_rev_linord_correct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. invar S \\<Longrightarrow>\n    map_iterator_rev_linord (list_rev_it S) (\\<alpha> S)", "by (rule list_rev_it_correct)"], ["", "lemma pi_rev_iterateoi[icf_proper_iteratorI]: \n    \"proper_it (rev_iterateoi S) (rev_iterateoi S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it (reverse_iterateoi S) (reverse_iterateoi S)", "unfolding rev_iterateoi_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it (it_to_it (list_rev_it S)) (it_to_it (list_rev_it S))", "by (intro icf_proper_iteratorI)"], ["", "lemma rev_iterateoi_rule_P[case_names minv inv0 inv_pres i_complete i_inter]:\n    assumes MINV: \"invar m\"\n    assumes I0: \"I (dom (\\<alpha> m)) \\<sigma>0\"\n    assumes IP: \"!!k v it \\<sigma>. \\<lbrakk> \n      c \\<sigma>; \n      k \\<in> it; \n      \\<alpha> m k = Some v; \n      it \\<subseteq> dom (\\<alpha> m); \n      I it \\<sigma>;\n      \\<And>j. j\\<in>it \\<Longrightarrow> k\\<ge>j; \n      \\<And>j. j\\<in>dom (\\<alpha> m) - it \\<Longrightarrow> j\\<ge>k\n    \\<rbrakk> \\<Longrightarrow> I (it - {k}) (f (k, v) \\<sigma>)\"\n    assumes IF: \"!!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n    assumes II: \"!!\\<sigma> it. \\<lbrakk> \n      it \\<subseteq> dom (\\<alpha> m); \n      it \\<noteq> {}; \n      \\<not> c \\<sigma>; \n      I it \\<sigma>; \n      \\<And>k j. \\<lbrakk>k\\<in>it; j\\<in>dom (\\<alpha> m) - it\\<rbrakk> \\<Longrightarrow> j\\<ge>k \n    \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n    shows \"P (rev_iterateoi m c f \\<sigma>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (reverse_iterateoi m c f \\<sigma>0)", "using assms"], ["proof (prove)\nusing this:\n  invar m\n  I (dom (\\<alpha> m)) \\<sigma>0\n  \\<lbrakk>c ?\\<sigma>4; ?k4 \\<in> ?it4; \\<alpha> m ?k4 = Some ?v4;\n   ?it4 \\<subseteq> dom (\\<alpha> m); I ?it4 ?\\<sigma>4;\n   \\<And>j. j \\<in> ?it4 \\<Longrightarrow> j \\<le> ?k4;\n   \\<And>j.\n      j \\<in> dom (\\<alpha> m) - ?it4 \\<Longrightarrow> ?k4 \\<le> j\\<rbrakk>\n  \\<Longrightarrow> I (?it4 - {?k4}) (f (?k4, ?v4) ?\\<sigma>4)\n  I {} ?\\<sigma>4 \\<Longrightarrow> P ?\\<sigma>4\n  \\<lbrakk>?it4 \\<subseteq> dom (\\<alpha> m); ?it4 \\<noteq> {};\n   \\<not> c ?\\<sigma>4; I ?it4 ?\\<sigma>4;\n   \\<And>k j.\n      \\<lbrakk>k \\<in> ?it4; j \\<in> dom (\\<alpha> m) - ?it4\\<rbrakk>\n      \\<Longrightarrow> k \\<le> j\\<rbrakk>\n  \\<Longrightarrow> P ?\\<sigma>4\n\ngoal (1 subgoal):\n 1. P (reverse_iterateoi m c f \\<sigma>0)", "by (rule map_iterator_rev_linord_rule_P[OF rev_iterateoi_correct])"], ["", "lemma rev_iterateo_rule_P[case_names minv inv0 inv_pres i_complete]: \n    assumes MINV: \"invar m\"\n    assumes I0: \"I (dom (\\<alpha> m)) \\<sigma>0\"\n    assumes IP: \"!!k v it \\<sigma>. \\<lbrakk> \n      k \\<in> it; \n      \\<alpha> m k = Some v; \n      it \\<subseteq> dom (\\<alpha> m); \n      I it \\<sigma>;\n      \\<And>j. j\\<in>it \\<Longrightarrow> k\\<ge>j; \n      \\<And>j. j\\<in>dom (\\<alpha> m) - it \\<Longrightarrow> j\\<ge>k\n    \\<rbrakk> \\<Longrightarrow> I (it - {k}) (f (k, v) \\<sigma>)\"\n    assumes IF: \"!!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n    shows \"P (rev_iterateo m f \\<sigma>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (reverse_iterateo m f \\<sigma>0)", "using assms \n      map_iterator_rev_linord_rule_P[OF rev_iterateoi_correct, \n        of m I \\<sigma>0 \"\\<lambda>_. True\" f P]"], ["proof (prove)\nusing this:\n  invar m\n  I (dom (\\<alpha> m)) \\<sigma>0\n  \\<lbrakk>?k4 \\<in> ?it4; \\<alpha> m ?k4 = Some ?v4;\n   ?it4 \\<subseteq> dom (\\<alpha> m); I ?it4 ?\\<sigma>4;\n   \\<And>j. j \\<in> ?it4 \\<Longrightarrow> j \\<le> ?k4;\n   \\<And>j.\n      j \\<in> dom (\\<alpha> m) - ?it4 \\<Longrightarrow> ?k4 \\<le> j\\<rbrakk>\n  \\<Longrightarrow> I (?it4 - {?k4}) (f (?k4, ?v4) ?\\<sigma>4)\n  I {} ?\\<sigma>4 \\<Longrightarrow> P ?\\<sigma>4\n  \\<lbrakk>invar m; I (dom (\\<alpha> m)) \\<sigma>0;\n   \\<And>k v it \\<sigma>.\n      \\<lbrakk>True; k \\<in> it; \\<alpha> m k = Some v;\n       it \\<subseteq> dom (\\<alpha> m); I it \\<sigma>;\n       \\<And>k'. k' \\<in> it \\<Longrightarrow> k' \\<le> k;\n       \\<And>k'.\n          k' \\<in> dom (\\<alpha> m) - it \\<Longrightarrow>\n          k \\<le> k'\\<rbrakk>\n      \\<Longrightarrow> I (it - {k}) (f (k, v) \\<sigma>);\n   \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>;\n   \\<And>\\<sigma> it.\n      \\<lbrakk>it \\<subseteq> dom (\\<alpha> m); it \\<noteq> {}; \\<not> True;\n       I it \\<sigma>;\n       \\<And>k k'.\n          \\<lbrakk>k \\<in> dom (\\<alpha> m) - it; k' \\<in> it\\<rbrakk>\n          \\<Longrightarrow> k' \\<le> k\\<rbrakk>\n      \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n  \\<Longrightarrow> P (reverse_iterateo m f \\<sigma>0)\n\ngoal (1 subgoal):\n 1. P (reverse_iterateo m f \\<sigma>0)", "by blast"], ["", "end"], ["", "subsubsection \\<open>Minimal and Maximal Elements\\<close>"], ["", "type_synonym ('k,'v,'s) map_min \n    = \"'s \\<Rightarrow> ('k \\<times> 'v \\<Rightarrow> bool) \\<Rightarrow> ('k \\<times> 'v) option\""], ["", "locale map_min = ordered_map +\n    constrains \\<alpha> :: \"'s \\<Rightarrow> 'u::linorder \\<rightharpoonup> 'v\"\n    fixes min :: \"'s \\<Rightarrow> ('u \\<times> 'v \\<Rightarrow> bool) \\<Rightarrow> ('u \\<times> 'v) option\"\n    assumes min_correct:\n      \"\\<lbrakk> invar s; rel_of (\\<alpha> s) P \\<noteq> {} \\<rbrakk> \\<Longrightarrow> min s P \\<in> Some ` rel_of (\\<alpha> s) P\"\n      \"\\<lbrakk> invar s; (k,v) \\<in> rel_of (\\<alpha> s) P \\<rbrakk> \\<Longrightarrow> fst (the (min s P)) \\<le> k\"\n      \"\\<lbrakk> invar s; rel_of (\\<alpha> s) P = {} \\<rbrakk> \\<Longrightarrow> min s P = None\"\n  begin"], ["", "lemma minE: \n     assumes A: \"invar s\" \"rel_of (\\<alpha> s) P \\<noteq> {}\"\n     obtains k v where\n     \"min s P = Some (k,v)\" \"(k,v)\\<in>rel_of (\\<alpha> s) P\" \"\\<forall>(k',v')\\<in>rel_of (\\<alpha> s) P. k \\<le> k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k v.\n        \\<lbrakk>min s P = Some (k, v); (k, v) \\<in> rel_of (\\<alpha> s) P;\n         \\<forall>(k', v')\\<in>rel_of (\\<alpha> s) P. k \\<le> k'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>k v.\n        \\<lbrakk>min s P = Some (k, v); (k, v) \\<in> rel_of (\\<alpha> s) P;\n         \\<forall>(k', v')\\<in>rel_of (\\<alpha> s) P. k \\<le> k'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from min_correct(1)[OF A]"], ["proof (chain)\npicking this:\n  min s P \\<in> Some ` rel_of (\\<alpha> s) P", "have MIS: \"min s P \\<in> Some ` rel_of (\\<alpha> s) P\""], ["proof (prove)\nusing this:\n  min s P \\<in> Some ` rel_of (\\<alpha> s) P\n\ngoal (1 subgoal):\n 1. min s P \\<in> Some ` rel_of (\\<alpha> s) P", "."], ["proof (state)\nthis:\n  min s P \\<in> Some ` rel_of (\\<alpha> s) P\n\ngoal (1 subgoal):\n 1. (\\<And>k v.\n        \\<lbrakk>min s P = Some (k, v); (k, v) \\<in> rel_of (\\<alpha> s) P;\n         \\<forall>(k', v')\\<in>rel_of (\\<alpha> s) P. k \\<le> k'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  min s P \\<in> Some ` rel_of (\\<alpha> s) P", "obtain k v where KV: \"min s P = Some (k,v)\" \"(k,v)\\<in>rel_of (\\<alpha> s) P\""], ["proof (prove)\nusing this:\n  min s P \\<in> Some ` rel_of (\\<alpha> s) P\n\ngoal (1 subgoal):\n 1. (\\<And>k v.\n        \\<lbrakk>min s P = Some (k, v);\n         (k, v) \\<in> rel_of (\\<alpha> s) P\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  min s P = Some (k, v)\n  (k, v) \\<in> rel_of (\\<alpha> s) P\n\ngoal (1 subgoal):\n 1. (\\<And>k v.\n        \\<lbrakk>min s P = Some (k, v); (k, v) \\<in> rel_of (\\<alpha> s) P;\n         \\<forall>(k', v')\\<in>rel_of (\\<alpha> s) P. k \\<le> k'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "show thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "apply (rule that[OF KV])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(k', v')\\<in>rel_of (\\<alpha> s) P. k \\<le> k'", "apply (clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> rel_of (\\<alpha> s) P \\<Longrightarrow> k \\<le> a", "apply (drule min_correct(2)[OF \\<open>invar s\\<close>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b. fst (the (min s P)) \\<le> a \\<Longrightarrow> k \\<le> a", "apply (simp add: KV(1))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas minI = min_correct(3)"], ["", "lemma min_Some:\n     \"\\<lbrakk> invar s; min s P = Some (k,v) \\<rbrakk> \\<Longrightarrow> (k,v)\\<in>rel_of (\\<alpha> s) P\"\n     \"\\<lbrakk> invar s; min s P = Some (k,v); (k',v')\\<in>rel_of (\\<alpha> s) P \\<rbrakk> \\<Longrightarrow> k\\<le>k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>invar s; min s P = Some (k, v)\\<rbrakk>\n     \\<Longrightarrow> (k, v) \\<in> rel_of (\\<alpha> s) P) &&&\n    (\\<lbrakk>invar s; min s P = Some (k, v);\n      (k', v') \\<in> rel_of (\\<alpha> s) P\\<rbrakk>\n     \\<Longrightarrow> k \\<le> k')", "apply -"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>invar s; min s P = Some (k, v)\\<rbrakk>\n    \\<Longrightarrow> (k, v) \\<in> rel_of (\\<alpha> s) P\n 2. \\<lbrakk>invar s; min s P = Some (k, v);\n     (k', v') \\<in> rel_of (\\<alpha> s) P\\<rbrakk>\n    \\<Longrightarrow> k \\<le> k'", "apply (cases \"rel_of (\\<alpha> s) P = {}\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>invar s; min s P = Some (k, v);\n     rel_of (\\<alpha> s) P = {}\\<rbrakk>\n    \\<Longrightarrow> (k, v) \\<in> rel_of (\\<alpha> s) P\n 2. \\<lbrakk>invar s; min s P = Some (k, v);\n     rel_of (\\<alpha> s) P \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> (k, v) \\<in> rel_of (\\<alpha> s) P\n 3. \\<lbrakk>invar s; min s P = Some (k, v);\n     (k', v') \\<in> rel_of (\\<alpha> s) P\\<rbrakk>\n    \\<Longrightarrow> k \\<le> k'", "apply (drule (1) min_correct(3))"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>min s P = Some (k, v); rel_of (\\<alpha> s) P = {};\n     min s P = None\\<rbrakk>\n    \\<Longrightarrow> (k, v) \\<in> rel_of (\\<alpha> s) P\n 2. \\<lbrakk>invar s; min s P = Some (k, v);\n     rel_of (\\<alpha> s) P \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> (k, v) \\<in> rel_of (\\<alpha> s) P\n 3. \\<lbrakk>invar s; min s P = Some (k, v);\n     (k', v') \\<in> rel_of (\\<alpha> s) P\\<rbrakk>\n    \\<Longrightarrow> k \\<le> k'", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>invar s; min s P = Some (k, v);\n     rel_of (\\<alpha> s) P \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> (k, v) \\<in> rel_of (\\<alpha> s) P\n 2. \\<lbrakk>invar s; min s P = Some (k, v);\n     (k', v') \\<in> rel_of (\\<alpha> s) P\\<rbrakk>\n    \\<Longrightarrow> k \\<le> k'", "apply (erule (1) minE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ka va.\n       \\<lbrakk>min s P = Some (k, v); rel_of (\\<alpha> s) P \\<noteq> {};\n        min s P = Some (ka, va); (ka, va) \\<in> rel_of (\\<alpha> s) P;\n        \\<forall>(k', v')\\<in>rel_of (\\<alpha> s) P. ka \\<le> k'\\<rbrakk>\n       \\<Longrightarrow> (k, v) \\<in> rel_of (\\<alpha> s) P\n 2. \\<lbrakk>invar s; min s P = Some (k, v);\n     (k', v') \\<in> rel_of (\\<alpha> s) P\\<rbrakk>\n    \\<Longrightarrow> k \\<le> k'", "apply auto [1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar s; min s P = Some (k, v);\n     (k', v') \\<in> rel_of (\\<alpha> s) P\\<rbrakk>\n    \\<Longrightarrow> k \\<le> k'", "apply (drule (1) min_correct(2))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>min s P = Some (k, v); (k', v') \\<in> rel_of (\\<alpha> s) P;\n     fst (the (min s P)) \\<le> k'\\<rbrakk>\n    \\<Longrightarrow> k \\<le> k'", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma min_None:\n     \"\\<lbrakk> invar s; min s P = None \\<rbrakk> \\<Longrightarrow> rel_of (\\<alpha> s) P = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar s; min s P = None\\<rbrakk>\n    \\<Longrightarrow> rel_of (\\<alpha> s) P = {}", "apply (cases \"rel_of (\\<alpha> s) P = {}\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>invar s; min s P = None; rel_of (\\<alpha> s) P = {}\\<rbrakk>\n    \\<Longrightarrow> rel_of (\\<alpha> s) P = {}\n 2. \\<lbrakk>invar s; min s P = None;\n     rel_of (\\<alpha> s) P \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> rel_of (\\<alpha> s) P = {}", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar s; min s P = None;\n     rel_of (\\<alpha> s) P \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> rel_of (\\<alpha> s) P = {}", "apply (drule (1) min_correct(1))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>min s P = None; rel_of (\\<alpha> s) P \\<noteq> {};\n     min s P \\<in> Some ` rel_of (\\<alpha> s) P\\<rbrakk>\n    \\<Longrightarrow> rel_of (\\<alpha> s) P = {}", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "type_synonym ('k,'v,'s) map_max\n    = \"'s \\<Rightarrow> ('k \\<times> 'v \\<Rightarrow> bool) \\<Rightarrow> ('k \\<times> 'v) option\""], ["", "locale map_max = ordered_map +\n    constrains \\<alpha> :: \"'s \\<Rightarrow> 'u::linorder \\<rightharpoonup> 'v\"\n    fixes max :: \"'s \\<Rightarrow> ('u \\<times> 'v \\<Rightarrow> bool) \\<Rightarrow> ('u \\<times> 'v) option\"\n    assumes max_correct:\n      \"\\<lbrakk> invar s; rel_of (\\<alpha> s) P \\<noteq> {} \\<rbrakk> \\<Longrightarrow> max s P \\<in> Some ` rel_of (\\<alpha> s) P\"\n      \"\\<lbrakk> invar s; (k,v) \\<in> rel_of (\\<alpha> s) P \\<rbrakk> \\<Longrightarrow> fst (the (max s P)) \\<ge> k\"\n      \"\\<lbrakk> invar s; rel_of (\\<alpha> s) P = {} \\<rbrakk> \\<Longrightarrow> max s P = None\"\n  begin"], ["", "lemma maxE: \n     assumes A: \"invar s\" \"rel_of (\\<alpha> s) P \\<noteq> {}\"\n     obtains k v where\n     \"max s P = Some (k,v)\" \"(k,v)\\<in>rel_of (\\<alpha> s) P\" \"\\<forall>(k',v')\\<in>rel_of (\\<alpha> s) P. k \\<ge> k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k v.\n        \\<lbrakk>max s P = Some (k, v); (k, v) \\<in> rel_of (\\<alpha> s) P;\n         \\<forall>(k', v')\\<in>rel_of (\\<alpha> s) P. k' \\<le> k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>k v.\n        \\<lbrakk>max s P = Some (k, v); (k, v) \\<in> rel_of (\\<alpha> s) P;\n         \\<forall>(k', v')\\<in>rel_of (\\<alpha> s) P. k' \\<le> k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from max_correct(1)[OF A]"], ["proof (chain)\npicking this:\n  max s P \\<in> Some ` rel_of (\\<alpha> s) P", "have MIS: \"max s P \\<in> Some ` rel_of (\\<alpha> s) P\""], ["proof (prove)\nusing this:\n  max s P \\<in> Some ` rel_of (\\<alpha> s) P\n\ngoal (1 subgoal):\n 1. max s P \\<in> Some ` rel_of (\\<alpha> s) P", "."], ["proof (state)\nthis:\n  max s P \\<in> Some ` rel_of (\\<alpha> s) P\n\ngoal (1 subgoal):\n 1. (\\<And>k v.\n        \\<lbrakk>max s P = Some (k, v); (k, v) \\<in> rel_of (\\<alpha> s) P;\n         \\<forall>(k', v')\\<in>rel_of (\\<alpha> s) P. k' \\<le> k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  max s P \\<in> Some ` rel_of (\\<alpha> s) P", "obtain k v where KV: \"max s P = Some (k,v)\" \"(k,v)\\<in>rel_of (\\<alpha> s) P\""], ["proof (prove)\nusing this:\n  max s P \\<in> Some ` rel_of (\\<alpha> s) P\n\ngoal (1 subgoal):\n 1. (\\<And>k v.\n        \\<lbrakk>max s P = Some (k, v);\n         (k, v) \\<in> rel_of (\\<alpha> s) P\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  max s P = Some (k, v)\n  (k, v) \\<in> rel_of (\\<alpha> s) P\n\ngoal (1 subgoal):\n 1. (\\<And>k v.\n        \\<lbrakk>max s P = Some (k, v); (k, v) \\<in> rel_of (\\<alpha> s) P;\n         \\<forall>(k', v')\\<in>rel_of (\\<alpha> s) P. k' \\<le> k\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "show thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "apply (rule that[OF KV])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(k', v')\\<in>rel_of (\\<alpha> s) P. k' \\<le> k", "apply (clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> rel_of (\\<alpha> s) P \\<Longrightarrow> a \\<le> k", "apply (drule max_correct(2)[OF \\<open>invar s\\<close>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b. a \\<le> fst (the (max s P)) \\<Longrightarrow> a \\<le> k", "apply (simp add: KV(1))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas maxI = max_correct(3)"], ["", "lemma max_Some:\n     \"\\<lbrakk> invar s; max s P = Some (k,v) \\<rbrakk> \\<Longrightarrow> (k,v)\\<in>rel_of (\\<alpha> s) P\"\n     \"\\<lbrakk> invar s; max s P = Some (k,v); (k',v')\\<in>rel_of (\\<alpha> s) P \\<rbrakk> \\<Longrightarrow> k\\<ge>k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>invar s; max s P = Some (k, v)\\<rbrakk>\n     \\<Longrightarrow> (k, v) \\<in> rel_of (\\<alpha> s) P) &&&\n    (\\<lbrakk>invar s; max s P = Some (k, v);\n      (k', v') \\<in> rel_of (\\<alpha> s) P\\<rbrakk>\n     \\<Longrightarrow> k' \\<le> k)", "apply -"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>invar s; max s P = Some (k, v)\\<rbrakk>\n    \\<Longrightarrow> (k, v) \\<in> rel_of (\\<alpha> s) P\n 2. \\<lbrakk>invar s; max s P = Some (k, v);\n     (k', v') \\<in> rel_of (\\<alpha> s) P\\<rbrakk>\n    \\<Longrightarrow> k' \\<le> k", "apply (cases \"rel_of (\\<alpha> s) P = {}\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>invar s; max s P = Some (k, v);\n     rel_of (\\<alpha> s) P = {}\\<rbrakk>\n    \\<Longrightarrow> (k, v) \\<in> rel_of (\\<alpha> s) P\n 2. \\<lbrakk>invar s; max s P = Some (k, v);\n     rel_of (\\<alpha> s) P \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> (k, v) \\<in> rel_of (\\<alpha> s) P\n 3. \\<lbrakk>invar s; max s P = Some (k, v);\n     (k', v') \\<in> rel_of (\\<alpha> s) P\\<rbrakk>\n    \\<Longrightarrow> k' \\<le> k", "apply (drule (1) max_correct(3))"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>max s P = Some (k, v); rel_of (\\<alpha> s) P = {};\n     max s P = None\\<rbrakk>\n    \\<Longrightarrow> (k, v) \\<in> rel_of (\\<alpha> s) P\n 2. \\<lbrakk>invar s; max s P = Some (k, v);\n     rel_of (\\<alpha> s) P \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> (k, v) \\<in> rel_of (\\<alpha> s) P\n 3. \\<lbrakk>invar s; max s P = Some (k, v);\n     (k', v') \\<in> rel_of (\\<alpha> s) P\\<rbrakk>\n    \\<Longrightarrow> k' \\<le> k", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>invar s; max s P = Some (k, v);\n     rel_of (\\<alpha> s) P \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> (k, v) \\<in> rel_of (\\<alpha> s) P\n 2. \\<lbrakk>invar s; max s P = Some (k, v);\n     (k', v') \\<in> rel_of (\\<alpha> s) P\\<rbrakk>\n    \\<Longrightarrow> k' \\<le> k", "apply (erule (1) maxE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ka va.\n       \\<lbrakk>max s P = Some (k, v); rel_of (\\<alpha> s) P \\<noteq> {};\n        max s P = Some (ka, va); (ka, va) \\<in> rel_of (\\<alpha> s) P;\n        \\<forall>(k', v')\\<in>rel_of (\\<alpha> s) P. k' \\<le> ka\\<rbrakk>\n       \\<Longrightarrow> (k, v) \\<in> rel_of (\\<alpha> s) P\n 2. \\<lbrakk>invar s; max s P = Some (k, v);\n     (k', v') \\<in> rel_of (\\<alpha> s) P\\<rbrakk>\n    \\<Longrightarrow> k' \\<le> k", "apply auto [1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar s; max s P = Some (k, v);\n     (k', v') \\<in> rel_of (\\<alpha> s) P\\<rbrakk>\n    \\<Longrightarrow> k' \\<le> k", "apply (drule (1) max_correct(2))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>max s P = Some (k, v); (k', v') \\<in> rel_of (\\<alpha> s) P;\n     k' \\<le> fst (the (max s P))\\<rbrakk>\n    \\<Longrightarrow> k' \\<le> k", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma max_None:\n     \"\\<lbrakk> invar s; max s P = None \\<rbrakk> \\<Longrightarrow> rel_of (\\<alpha> s) P = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar s; max s P = None\\<rbrakk>\n    \\<Longrightarrow> rel_of (\\<alpha> s) P = {}", "apply (cases \"rel_of (\\<alpha> s) P = {}\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>invar s; max s P = None; rel_of (\\<alpha> s) P = {}\\<rbrakk>\n    \\<Longrightarrow> rel_of (\\<alpha> s) P = {}\n 2. \\<lbrakk>invar s; max s P = None;\n     rel_of (\\<alpha> s) P \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> rel_of (\\<alpha> s) P = {}", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar s; max s P = None;\n     rel_of (\\<alpha> s) P \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> rel_of (\\<alpha> s) P = {}", "apply (drule (1) max_correct(1))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>max s P = None; rel_of (\\<alpha> s) P \\<noteq> {};\n     max s P \\<in> Some ` rel_of (\\<alpha> s) P\\<rbrakk>\n    \\<Longrightarrow> rel_of (\\<alpha> s) P = {}", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "subsubsection \"Conversion to List\""], ["", "type_synonym ('k,'v,'s) map_to_sorted_list \n    = \"'s \\<Rightarrow> ('k \\<times> 'v) list\""], ["", "locale map_to_sorted_list = ordered_map +\n    constrains \\<alpha> :: \"'s \\<Rightarrow> 'u::linorder \\<rightharpoonup> 'v\"\n    fixes to_sorted_list :: \"'s \\<Rightarrow> ('u\\<times>'v) list\"\n    assumes to_sorted_list_correct: \n    \"invar m \\<Longrightarrow> map_of (to_sorted_list m) = \\<alpha> m\"\n    \"invar m \\<Longrightarrow> distinct (map fst (to_sorted_list m))\"\n    \"invar m \\<Longrightarrow> sorted (map fst (to_sorted_list m))\""], ["", "type_synonym ('k,'v,'s) map_to_rev_list \n    = \"'s \\<Rightarrow> ('k \\<times> 'v) list\""], ["", "locale map_to_rev_list = ordered_map +\n    constrains \\<alpha> :: \"'s \\<Rightarrow> 'u::linorder \\<rightharpoonup> 'v\"\n    fixes to_rev_list :: \"'s \\<Rightarrow> ('u\\<times>'v) list\"\n    assumes to_rev_list_correct: \n    \"invar m \\<Longrightarrow> map_of (to_rev_list m) = \\<alpha> m\"\n    \"invar m \\<Longrightarrow> distinct (map fst (to_rev_list m))\"\n    \"invar m \\<Longrightarrow> sorted (rev (map fst (to_rev_list m)))\""], ["", "subsection \"Record Based Interface\""], ["", "record ('k,'v,'s) map_ops = \n    map_op_\\<alpha> :: \"('k,'v,'s) map_\\<alpha>\"\n    map_op_invar :: \"('k,'v,'s) map_invar\"\n    map_op_empty :: \"('k,'v,'s) map_empty\"\n    map_op_lookup :: \"('k,'v,'s) map_lookup\"\n    map_op_update :: \"('k,'v,'s) map_update\"\n    map_op_update_dj :: \"('k,'v,'s) map_update_dj\"\n    map_op_delete :: \"('k,'v,'s) map_delete\"\n    map_op_list_it :: \"('k,'v,'s) map_list_it\"\n    map_op_sng :: \"('k,'v,'s) map_sng\"\n    map_op_restrict :: \"('k,'v,'s,'s) map_restrict\"\n    map_op_add :: \"('k,'v,'s) map_add\"\n    map_op_add_dj :: \"('k,'v,'s) map_add_dj\"\n    map_op_isEmpty :: \"('k,'v,'s) map_isEmpty\"\n    map_op_isSng :: \"('k,'v,'s) map_isSng\"\n    map_op_ball :: \"('k,'v,'s) map_ball\"\n    map_op_bex :: \"('k,'v,'s) map_bex\"\n    map_op_size :: \"('k,'v,'s) map_size\"\n    map_op_size_abort :: \"('k,'v,'s) map_size_abort\"\n    map_op_sel :: \"('k,'v,'s) map_sel'\"\n    map_op_to_list :: \"('k,'v,'s) map_to_list\"\n    map_op_to_map :: \"('k,'v,'s) list_to_map\""], ["", "locale StdMapDefs = poly_map_iteratei_defs \"map_op_list_it ops\" \n    for ops :: \"('k,'v,'s,'more) map_ops_scheme\"\n  begin"], ["", "abbreviation \\<alpha> where \"\\<alpha> == map_op_\\<alpha> ops\""], ["", "abbreviation invar where \"invar == map_op_invar ops\""], ["", "abbreviation empty where \"empty == map_op_empty ops\""], ["", "abbreviation lookup where \"lookup == map_op_lookup ops\""], ["", "abbreviation update where \"update == map_op_update ops\""], ["", "abbreviation update_dj where \"update_dj == map_op_update_dj ops\""], ["", "abbreviation delete where \"delete == map_op_delete ops\""], ["", "abbreviation list_it where \"list_it == map_op_list_it ops\""], ["", "abbreviation sng where \"sng == map_op_sng ops\""], ["", "abbreviation restrict where \"restrict == map_op_restrict ops\""], ["", "abbreviation add where \"add == map_op_add ops\""], ["", "abbreviation add_dj where \"add_dj == map_op_add_dj ops\""], ["", "abbreviation isEmpty where \"isEmpty == map_op_isEmpty ops\""], ["", "abbreviation isSng where \"isSng == map_op_isSng ops\""], ["", "abbreviation ball where \"ball == map_op_ball ops\""], ["", "abbreviation bex where \"bex == map_op_bex ops\""], ["", "abbreviation size where \"size == map_op_size ops\""], ["", "abbreviation size_abort where \"size_abort == map_op_size_abort ops\""], ["", "abbreviation sel where \"sel == map_op_sel ops\""], ["", "abbreviation to_list where \"to_list == map_op_to_list ops\""], ["", "abbreviation to_map where \"to_map == map_op_to_map ops\""], ["", "end"], ["", "locale StdMap = StdMapDefs ops +\n    map \\<alpha> invar +\n    map_empty \\<alpha> invar empty +\n    map_lookup \\<alpha> invar lookup  +\n    map_update \\<alpha> invar update  +\n    map_update_dj \\<alpha> invar update_dj +\n    map_delete \\<alpha> invar delete  +\n    poly_map_iteratei \\<alpha> invar list_it +\n    map_sng \\<alpha> invar sng  +\n    map_restrict \\<alpha> invar \\<alpha> invar restrict +\n    map_add \\<alpha> invar add  +\n    map_add_dj \\<alpha> invar add_dj +\n    map_isEmpty \\<alpha> invar isEmpty  +\n    map_isSng \\<alpha> invar isSng  +\n    map_ball \\<alpha> invar ball  +\n    map_bex \\<alpha> invar bex  +\n    map_size \\<alpha> invar size +\n    map_size_abort \\<alpha> invar size_abort +\n    map_sel' \\<alpha> invar sel  +\n    map_to_list \\<alpha> invar to_list  +\n    list_to_map \\<alpha> invar to_map \n    for ops :: \"('k,'v,'s,'more) map_ops_scheme\"\n  begin"], ["", "lemmas correct =\n      empty_correct\n      sng_correct\n      lookup_correct\n      update_correct\n      update_dj_correct\n      delete_correct\n      restrict_correct\n      add_correct\n      add_dj_correct\n      isEmpty_correct\n      isSng_correct\n      ball_correct\n      bex_correct\n      size_correct\n      size_abort_correct\n      to_list_correct\n      to_map_correct"], ["", "end"], ["", "lemmas StdMap_intro = StdMap.intro[rem_dup_prems]"], ["", "locale StdMap_no_invar = StdMap + map_no_invar \\<alpha> invar"], ["", "record ('k,'v,'s) omap_ops = \"('k,'v,'s) map_ops\" + \n    map_op_ordered_list_it :: \"'s \\<Rightarrow> ('k,'v,('k\\<times>'v) list) map_iterator\"\n    map_op_rev_list_it :: \"'s \\<Rightarrow> ('k,'v,('k\\<times>'v) list) map_iterator\"\n    map_op_min :: \"'s \\<Rightarrow> ('k \\<times> 'v \\<Rightarrow> bool) \\<Rightarrow> ('k \\<times> 'v) option\"\n    map_op_max :: \"'s \\<Rightarrow> ('k \\<times> 'v \\<Rightarrow> bool) \\<Rightarrow> ('k \\<times> 'v) option\"\n    map_op_to_sorted_list :: \"'s \\<Rightarrow> ('k \\<times> 'v) list\"\n    map_op_to_rev_list :: \"'s \\<Rightarrow> ('k \\<times> 'v) list\""], ["", "locale StdOMapDefs = StdMapDefs ops\n    + poly_map_iterateoi_defs \"map_op_ordered_list_it ops\"\n    + poly_map_rev_iterateoi_defs \"map_op_rev_list_it ops\"\n    for ops :: \"('k::linorder,'v,'s,'more) omap_ops_scheme\"\n  begin"], ["", "abbreviation ordered_list_it where \"ordered_list_it \n      \\<equiv> map_op_ordered_list_it ops\""], ["", "abbreviation rev_list_it where \"rev_list_it \n      \\<equiv> map_op_rev_list_it ops\""], ["", "abbreviation min where \"min == map_op_min ops\""], ["", "abbreviation max where \"max == map_op_max ops\""], ["", "abbreviation to_sorted_list where \n      \"to_sorted_list \\<equiv> map_op_to_sorted_list ops\""], ["", "abbreviation to_rev_list where \"to_rev_list \\<equiv> map_op_to_rev_list ops\""], ["", "end"], ["", "locale StdOMap = \n    StdOMapDefs ops +\n    StdMap ops +\n    poly_map_iterateoi \\<alpha> invar ordered_list_it +\n    poly_map_rev_iterateoi \\<alpha> invar rev_list_it +\n    map_min \\<alpha> invar min +\n    map_max \\<alpha> invar max +\n    map_to_sorted_list \\<alpha> invar to_sorted_list +\n    map_to_rev_list \\<alpha> invar to_rev_list\n    for ops :: \"('k::linorder,'v,'s,'more) omap_ops_scheme\"\n  begin"], ["", "end"], ["", "lemmas StdOMap_intro = \n    StdOMap.intro[OF StdMap_intro, rem_dup_prems]"], ["", "end"]]}