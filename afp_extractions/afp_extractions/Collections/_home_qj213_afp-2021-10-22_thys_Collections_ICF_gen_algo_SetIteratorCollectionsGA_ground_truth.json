{"file_name": "/home/qj213/afp-2021-10-22/thys/Collections/ICF/gen_algo/SetIteratorCollectionsGA.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Collections", "problem_names": ["lemma iterate_add_to_set_correct :\nassumes ins_OK: \"set_ins \\<alpha> invar ins\"\nassumes s_OK: \"invar s\"\nassumes it: \"set_iterator it S0\"\nshows \"\\<alpha> (iterate_add_to_set s ins it) = S0 \\<union> \\<alpha> s \\<and> invar (iterate_add_to_set s ins it)\"", "lemma iterate_add_to_set_dj_correct :\nassumes ins_dj_OK: \"set_ins_dj \\<alpha> invar ins_dj\"\nassumes s_OK: \"invar s\"\nassumes it: \"set_iterator it S0\"\nassumes dj: \"S0 \\<inter> \\<alpha> s = {}\"\nshows \"\\<alpha> (iterate_add_to_set s ins_dj it) = S0 \\<union> \\<alpha> s \\<and> invar (iterate_add_to_set s ins_dj it)\"", "lemma iterate_to_set_alt_def[code] :\n    \"iterate_to_set emp ins_dj (it::('x,'x_set) set_iterator) = \n     it (\\<lambda>_. True) (\\<lambda>x \\<sigma>. ins_dj x \\<sigma>) (emp ())\"", "lemma iterate_to_set_correct :\nassumes ins_dj_OK: \"set_ins_dj \\<alpha> invar ins_dj\"\nassumes emp_OK: \"set_empty \\<alpha> invar emp\"\nassumes it: \"set_iterator it S0\"\nshows \"\\<alpha> (iterate_to_set emp ins_dj it) = S0 \\<and> invar (iterate_to_set emp ins_dj it)\"", "lemma iterate_image_filter_add_to_set_correct :\nassumes ins_OK: \"set_ins \\<alpha> invar ins\"\nassumes s_OK: \"invar s\"\nassumes it: \"set_iterator it S0\"\nshows \"\\<alpha> (iterate_add_to_set s ins (set_iterator_image_filter f it)) = \n          {b . \\<exists>a. a \\<in> S0 \\<and> f a = Some b} \\<union> \\<alpha> s \\<and> \n       invar (iterate_add_to_set s ins  (set_iterator_image_filter f it))\"", "lemma iterate_image_filter_to_set_correct :\nassumes ins_OK: \"set_ins \\<alpha> invar ins\"\nassumes emp_OK: \"set_empty \\<alpha> invar emp\"\nassumes it: \"set_iterator it S0\"\nshows \"\\<alpha> (iterate_to_set emp ins (set_iterator_image_filter f it)) = \n          {b . \\<exists>a. a \\<in> S0 \\<and> f a = Some b} \\<and> \n       invar (iterate_to_set emp ins  (set_iterator_image_filter f it))\"", "lemma iterate_inj_image_filter_add_to_set_correct :\nassumes ins_dj_OK: \"set_ins_dj \\<alpha> invar ins\"\nassumes s_OK: \"invar s\"\nassumes it: \"set_iterator it S0\"\nassumes dj: \"{y. \\<exists>x. x \\<in> S0 \\<and> f x = Some y} \\<inter> \\<alpha> s = {}\"\nassumes f_inj_on: \"inj_on f (S0 \\<inter> dom f)\"\nshows \"\\<alpha> (iterate_add_to_set s ins (set_iterator_image_filter f it)) = \n          {b . \\<exists>a. a \\<in> S0 \\<and> f a = Some b} \\<union> \\<alpha> s \\<and> \n       invar (iterate_add_to_set s ins  (set_iterator_image_filter f it))\"", "lemma iterate_inj_image_filter_to_set_correct :\nassumes ins_OK: \"set_ins_dj \\<alpha> invar ins\"\nassumes emp_OK: \"set_empty \\<alpha> invar emp\"\nassumes it: \"set_iterator it S0\"\nassumes f_inj_on: \"inj_on f (S0 \\<inter> dom f)\"\nshows \"\\<alpha> (iterate_to_set emp ins (set_iterator_image_filter f it)) = \n          {b . \\<exists>a. a \\<in> S0 \\<and> f a = Some b} \\<and> \n       invar (iterate_to_set emp ins  (set_iterator_image_filter f it))\"", "lemma iterate_diff_correct :\nassumes del_OK: \"set_delete \\<alpha> invar del\"\nassumes s_OK: \"invar s\"\nassumes it: \"set_iterator it S0\"\nshows \"\\<alpha> (iterate_diff_set s del it) = \\<alpha> s - S0 \\<and> invar (iterate_diff_set s del it)\"", "lemma iterate_add_to_map_correct :\nassumes upd_OK: \"map_update \\<alpha> invar upd\"\nassumes m_OK: \"invar m\"\nassumes it: \"map_iterator it M\"\nshows \"\\<alpha> (iterate_add_to_map m upd it) = \\<alpha> m ++ M  \\<and> invar (iterate_add_to_map m upd it)\"", "lemma iterate_add_to_map_dj_correct :\nassumes upd_OK: \"map_update_dj \\<alpha> invar upd\"\nassumes m_OK: \"invar m\"\nassumes it: \"map_iterator it M\"\nassumes dj: \"dom M \\<inter> dom (\\<alpha> m) = {}\"\nshows \"\\<alpha> (iterate_add_to_map m upd it) = \\<alpha> m ++ M  \\<and> invar (iterate_add_to_map m upd it)\"", "lemma iterate_to_map_alt_def[code] :\n    \"iterate_to_map emp upd_dj it = \n     it (\\<lambda>_. True) (\\<lambda>(k, v) \\<sigma>. upd_dj k v \\<sigma>) (emp ())\"", "lemma iterate_to_map_correct :\nassumes upd_dj_OK: \"map_update_dj \\<alpha> invar upd_dj\"\nassumes emp_OK: \"map_empty \\<alpha> invar emp\"\nassumes it: \"map_iterator it M\"\nshows \"\\<alpha> (iterate_to_map emp upd_dj it) = M \\<and> invar (iterate_to_map emp upd_dj it)\""], "translations": [["", "lemma iterate_add_to_set_correct :\nassumes ins_OK: \"set_ins \\<alpha> invar ins\"\nassumes s_OK: \"invar s\"\nassumes it: \"set_iterator it S0\"\nshows \"\\<alpha> (iterate_add_to_set s ins it) = S0 \\<union> \\<alpha> s \\<and> invar (iterate_add_to_set s ins it)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (iterate_add_to_set s ins it) = S0 \\<union> \\<alpha> s \\<and>\n    invar (iterate_add_to_set s ins it)", "unfolding iterate_add_to_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (it (\\<lambda>_. True) ins s) = S0 \\<union> \\<alpha> s \\<and>\n    invar (it (\\<lambda>_. True) ins s)", "apply (rule set_iterator_no_cond_rule_insert_P [OF it,\n         where ?I=\"\\<lambda>S \\<sigma>. \\<alpha> \\<sigma> = S \\<union> \\<alpha> s \\<and> invar \\<sigma>\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<alpha> s = {} \\<union> \\<alpha> s \\<and> invar s\n 2. \\<And>S \\<sigma> x.\n       \\<lbrakk>x \\<in> S0 - S;\n        \\<alpha> \\<sigma> = S \\<union> \\<alpha> s \\<and> invar \\<sigma>;\n        S \\<subseteq> S0\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> (ins x \\<sigma>) =\n                         insert x S \\<union> \\<alpha> s \\<and>\n                         invar (ins x \\<sigma>)\n 3. \\<And>\\<sigma>.\n       \\<alpha> \\<sigma> = S0 \\<union> \\<alpha> s \\<and>\n       invar \\<sigma> \\<Longrightarrow>\n       \\<alpha> \\<sigma> = S0 \\<union> \\<alpha> s \\<and> invar \\<sigma>", "apply (insert ins_OK s_OK)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>set_ins \\<alpha> invar ins; invar s\\<rbrakk>\n    \\<Longrightarrow> \\<alpha> s = {} \\<union> \\<alpha> s \\<and> invar s\n 2. \\<And>S \\<sigma> x.\n       \\<lbrakk>x \\<in> S0 - S;\n        \\<alpha> \\<sigma> = S \\<union> \\<alpha> s \\<and> invar \\<sigma>;\n        S \\<subseteq> S0; set_ins \\<alpha> invar ins; invar s\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> (ins x \\<sigma>) =\n                         insert x S \\<union> \\<alpha> s \\<and>\n                         invar (ins x \\<sigma>)\n 3. \\<And>\\<sigma>.\n       \\<lbrakk>\\<alpha> \\<sigma> = S0 \\<union> \\<alpha> s \\<and>\n                invar \\<sigma>;\n        set_ins \\<alpha> invar ins; invar s\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> \\<sigma> = S0 \\<union> \\<alpha> s \\<and>\n                         invar \\<sigma>", "apply (simp_all add: set_ins_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iterate_add_to_set_dj_correct :\nassumes ins_dj_OK: \"set_ins_dj \\<alpha> invar ins_dj\"\nassumes s_OK: \"invar s\"\nassumes it: \"set_iterator it S0\"\nassumes dj: \"S0 \\<inter> \\<alpha> s = {}\"\nshows \"\\<alpha> (iterate_add_to_set s ins_dj it) = S0 \\<union> \\<alpha> s \\<and> invar (iterate_add_to_set s ins_dj it)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (iterate_add_to_set s ins_dj it) =\n    S0 \\<union> \\<alpha> s \\<and>\n    invar (iterate_add_to_set s ins_dj it)", "unfolding iterate_add_to_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (it (\\<lambda>_. True) ins_dj s) =\n    S0 \\<union> \\<alpha> s \\<and>\n    invar (it (\\<lambda>_. True) ins_dj s)", "apply (rule set_iterator_no_cond_rule_insert_P [OF it,\n         where ?I=\"\\<lambda>S \\<sigma>. \\<alpha> \\<sigma> = S \\<union> \\<alpha> s \\<and> invar \\<sigma>\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<alpha> s = {} \\<union> \\<alpha> s \\<and> invar s\n 2. \\<And>S \\<sigma> x.\n       \\<lbrakk>x \\<in> S0 - S;\n        \\<alpha> \\<sigma> = S \\<union> \\<alpha> s \\<and> invar \\<sigma>;\n        S \\<subseteq> S0\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> (ins_dj x \\<sigma>) =\n                         insert x S \\<union> \\<alpha> s \\<and>\n                         invar (ins_dj x \\<sigma>)\n 3. \\<And>\\<sigma>.\n       \\<alpha> \\<sigma> = S0 \\<union> \\<alpha> s \\<and>\n       invar \\<sigma> \\<Longrightarrow>\n       \\<alpha> \\<sigma> = S0 \\<union> \\<alpha> s \\<and> invar \\<sigma>", "apply (insert ins_dj_OK s_OK dj)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>set_ins_dj \\<alpha> invar ins_dj; invar s;\n     S0 \\<inter> \\<alpha> s = {}\\<rbrakk>\n    \\<Longrightarrow> \\<alpha> s = {} \\<union> \\<alpha> s \\<and> invar s\n 2. \\<And>S \\<sigma> x.\n       \\<lbrakk>x \\<in> S0 - S;\n        \\<alpha> \\<sigma> = S \\<union> \\<alpha> s \\<and> invar \\<sigma>;\n        S \\<subseteq> S0; set_ins_dj \\<alpha> invar ins_dj; invar s;\n        S0 \\<inter> \\<alpha> s = {}\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> (ins_dj x \\<sigma>) =\n                         insert x S \\<union> \\<alpha> s \\<and>\n                         invar (ins_dj x \\<sigma>)\n 3. \\<And>\\<sigma>.\n       \\<lbrakk>\\<alpha> \\<sigma> = S0 \\<union> \\<alpha> s \\<and>\n                invar \\<sigma>;\n        set_ins_dj \\<alpha> invar ins_dj; invar s;\n        S0 \\<inter> \\<alpha> s = {}\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> \\<sigma> = S0 \\<union> \\<alpha> s \\<and>\n                         invar \\<sigma>", "apply (simp_all add: set_ins_dj_def set_eq_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Iterator to Set\\<close>"], ["", "definition iterate_to_set where\n    \"iterate_to_set emp ins_dj (it::('x,'x_set) set_iterator) = \n     iterate_add_to_set (emp ()) ins_dj it\""], ["", "lemma iterate_to_set_alt_def[code] :\n    \"iterate_to_set emp ins_dj (it::('x,'x_set) set_iterator) = \n     it (\\<lambda>_. True) (\\<lambda>x \\<sigma>. ins_dj x \\<sigma>) (emp ())\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iterate_to_set emp ins_dj it = it (\\<lambda>_. True) ins_dj (emp ())", "unfolding iterate_to_set_def iterate_add_to_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. it (\\<lambda>_. True) ins_dj (emp ()) =\n    it (\\<lambda>_. True) ins_dj (emp ())", "by simp"], ["", "lemma iterate_to_set_correct :\nassumes ins_dj_OK: \"set_ins_dj \\<alpha> invar ins_dj\"\nassumes emp_OK: \"set_empty \\<alpha> invar emp\"\nassumes it: \"set_iterator it S0\"\nshows \"\\<alpha> (iterate_to_set emp ins_dj it) = S0 \\<and> invar (iterate_to_set emp ins_dj it)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (iterate_to_set emp ins_dj it) = S0 \\<and>\n    invar (iterate_to_set emp ins_dj it)", "unfolding iterate_to_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (iterate_add_to_set (emp ()) ins_dj it) = S0 \\<and>\n    invar (iterate_add_to_set (emp ()) ins_dj it)", "using iterate_add_to_set_dj_correct [OF ins_dj_OK _ it, of \"emp ()\"] emp_OK"], ["proof (prove)\nusing this:\n  \\<lbrakk>invar (emp ()); S0 \\<inter> \\<alpha> (emp ()) = {}\\<rbrakk>\n  \\<Longrightarrow> \\<alpha> (iterate_add_to_set (emp ()) ins_dj it) =\n                    S0 \\<union> \\<alpha> (emp ()) \\<and>\n                    invar (iterate_add_to_set (emp ()) ins_dj it)\n  set_empty \\<alpha> invar emp\n\ngoal (1 subgoal):\n 1. \\<alpha> (iterate_add_to_set (emp ()) ins_dj it) = S0 \\<and>\n    invar (iterate_add_to_set (emp ()) ins_dj it)", "by (simp add: set_empty_def)"], ["", "subsection \\<open>Iterate image/filter add to Set\\<close>"], ["", "text \\<open>Iterators only visit element once. Therefore the image operations makes sense for\nfilters only if an injective function is used. However, when adding to a set using\nnon-injective functions is fine.\\<close>"], ["", "lemma iterate_image_filter_add_to_set_correct :\nassumes ins_OK: \"set_ins \\<alpha> invar ins\"\nassumes s_OK: \"invar s\"\nassumes it: \"set_iterator it S0\"\nshows \"\\<alpha> (iterate_add_to_set s ins (set_iterator_image_filter f it)) = \n          {b . \\<exists>a. a \\<in> S0 \\<and> f a = Some b} \\<union> \\<alpha> s \\<and> \n       invar (iterate_add_to_set s ins  (set_iterator_image_filter f it))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (iterate_add_to_set s ins (set_iterator_image_filter f it)) =\n    {b. \\<exists>a. a \\<in> S0 \\<and> f a = Some b} \\<union>\n    \\<alpha> s \\<and>\n    invar (iterate_add_to_set s ins (set_iterator_image_filter f it))", "unfolding iterate_add_to_set_def set_iterator_image_filter_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha>\n     (it (\\<lambda>_. True)\n       (\\<lambda>x \\<sigma>.\n           case f x of None \\<Rightarrow> \\<sigma>\n           | Some x' \\<Rightarrow> ins x' \\<sigma>)\n       s) =\n    {b. \\<exists>a. a \\<in> S0 \\<and> f a = Some b} \\<union>\n    \\<alpha> s \\<and>\n    invar\n     (it (\\<lambda>_. True)\n       (\\<lambda>x \\<sigma>.\n           case f x of None \\<Rightarrow> \\<sigma>\n           | Some x' \\<Rightarrow> ins x' \\<sigma>)\n       s)", "apply (rule set_iterator_no_cond_rule_insert_P [OF it,\n         where ?I=\"\\<lambda>S \\<sigma>. \\<alpha> \\<sigma> = {b . \\<exists>a. a \\<in> S \\<and> f a = Some b} \\<union> \\<alpha> s \\<and> invar \\<sigma>\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<alpha> s =\n    {b. \\<exists>a. a \\<in> {} \\<and> f a = Some b} \\<union>\n    \\<alpha> s \\<and>\n    invar s\n 2. \\<And>S \\<sigma> x.\n       \\<lbrakk>x \\<in> S0 - S;\n        \\<alpha> \\<sigma> =\n        {b. \\<exists>a. a \\<in> S \\<and> f a = Some b} \\<union>\n        \\<alpha> s \\<and>\n        invar \\<sigma>;\n        S \\<subseteq> S0\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>\n                          (case f x of None \\<Rightarrow> \\<sigma>\n                           | Some x' \\<Rightarrow> ins x' \\<sigma>) =\n                         {b. \\<exists>a.\n                                a \\<in> insert x S \\<and>\n                                f a = Some b} \\<union>\n                         \\<alpha> s \\<and>\n                         invar\n                          (case f x of None \\<Rightarrow> \\<sigma>\n                           | Some x' \\<Rightarrow> ins x' \\<sigma>)\n 3. \\<And>\\<sigma>.\n       \\<alpha> \\<sigma> =\n       {b. \\<exists>a. a \\<in> S0 \\<and> f a = Some b} \\<union>\n       \\<alpha> s \\<and>\n       invar \\<sigma> \\<Longrightarrow>\n       \\<alpha> \\<sigma> =\n       {b. \\<exists>a. a \\<in> S0 \\<and> f a = Some b} \\<union>\n       \\<alpha> s \\<and>\n       invar \\<sigma>", "apply (insert ins_OK s_OK)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>set_ins \\<alpha> invar ins; invar s\\<rbrakk>\n    \\<Longrightarrow> \\<alpha> s =\n                      {b. \\<exists>a.\n                             a \\<in> {} \\<and> f a = Some b} \\<union>\n                      \\<alpha> s \\<and>\n                      invar s\n 2. \\<And>S \\<sigma> x.\n       \\<lbrakk>x \\<in> S0 - S;\n        \\<alpha> \\<sigma> =\n        {b. \\<exists>a. a \\<in> S \\<and> f a = Some b} \\<union>\n        \\<alpha> s \\<and>\n        invar \\<sigma>;\n        S \\<subseteq> S0; set_ins \\<alpha> invar ins; invar s\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>\n                          (case f x of None \\<Rightarrow> \\<sigma>\n                           | Some x' \\<Rightarrow> ins x' \\<sigma>) =\n                         {b. \\<exists>a.\n                                a \\<in> insert x S \\<and>\n                                f a = Some b} \\<union>\n                         \\<alpha> s \\<and>\n                         invar\n                          (case f x of None \\<Rightarrow> \\<sigma>\n                           | Some x' \\<Rightarrow> ins x' \\<sigma>)\n 3. \\<And>\\<sigma>.\n       \\<lbrakk>\\<alpha> \\<sigma> =\n                {b. \\<exists>a. a \\<in> S0 \\<and> f a = Some b} \\<union>\n                \\<alpha> s \\<and>\n                invar \\<sigma>;\n        set_ins \\<alpha> invar ins; invar s\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> \\<sigma> =\n                         {b. \\<exists>a.\n                                a \\<in> S0 \\<and> f a = Some b} \\<union>\n                         \\<alpha> s \\<and>\n                         invar \\<sigma>", "apply (simp_all add: set_ins_def split: option.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>S \\<sigma> x.\n       \\<lbrakk>x \\<in> S0 \\<and> x \\<notin> S;\n        \\<alpha> \\<sigma> =\n        {b. \\<exists>a. a \\<in> S \\<and> f a = Some b} \\<union>\n        \\<alpha> s \\<and>\n        invar \\<sigma>;\n        S \\<subseteq> S0;\n        (\\<forall>s.\n            invar s \\<longrightarrow>\n            (\\<forall>x. \\<alpha> (ins x s) = insert x (\\<alpha> s))) \\<and>\n        (\\<forall>s.\n            invar s \\<longrightarrow> (\\<forall>x. invar (ins x s)));\n        invar s\\<rbrakk>\n       \\<Longrightarrow> (f x = None \\<longrightarrow>\n                          {b. \\<exists>a.\n                                 a \\<in> S \\<and> f a = Some b} \\<union>\n                          \\<alpha> s =\n                          {b. \\<exists>a.\n                                 (a = x \\<or> a \\<in> S) \\<and>\n                                 f a = Some b} \\<union>\n                          \\<alpha> s) \\<and>\n                         (\\<forall>x2.\n                             f x = Some x2 \\<longrightarrow>\n                             insert x2\n                              ({b. \\<exists>a.\na \\<in> S \\<and> f a = Some b} \\<union>\n                               \\<alpha> s) =\n                             {b. \\<exists>a.\n                                    (a = x \\<or> a \\<in> S) \\<and>\n                                    f a = Some b} \\<union>\n                             \\<alpha> s)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iterate_image_filter_to_set_correct :\nassumes ins_OK: \"set_ins \\<alpha> invar ins\"\nassumes emp_OK: \"set_empty \\<alpha> invar emp\"\nassumes it: \"set_iterator it S0\"\nshows \"\\<alpha> (iterate_to_set emp ins (set_iterator_image_filter f it)) = \n          {b . \\<exists>a. a \\<in> S0 \\<and> f a = Some b} \\<and> \n       invar (iterate_to_set emp ins  (set_iterator_image_filter f it))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (iterate_to_set emp ins (set_iterator_image_filter f it)) =\n    {b. \\<exists>a. a \\<in> S0 \\<and> f a = Some b} \\<and>\n    invar (iterate_to_set emp ins (set_iterator_image_filter f it))", "unfolding iterate_to_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha>\n     (iterate_add_to_set (emp ()) ins (set_iterator_image_filter f it)) =\n    {b. \\<exists>a. a \\<in> S0 \\<and> f a = Some b} \\<and>\n    invar (iterate_add_to_set (emp ()) ins (set_iterator_image_filter f it))", "using iterate_image_filter_add_to_set_correct [OF ins_OK _ it, of \"emp ()\" f] emp_OK"], ["proof (prove)\nusing this:\n  invar (emp ()) \\<Longrightarrow>\n  \\<alpha>\n   (iterate_add_to_set (emp ()) ins (set_iterator_image_filter f it)) =\n  {b. \\<exists>a. a \\<in> S0 \\<and> f a = Some b} \\<union>\n  \\<alpha> (emp ()) \\<and>\n  invar (iterate_add_to_set (emp ()) ins (set_iterator_image_filter f it))\n  set_empty \\<alpha> invar emp\n\ngoal (1 subgoal):\n 1. \\<alpha>\n     (iterate_add_to_set (emp ()) ins (set_iterator_image_filter f it)) =\n    {b. \\<exists>a. a \\<in> S0 \\<and> f a = Some b} \\<and>\n    invar (iterate_add_to_set (emp ()) ins (set_iterator_image_filter f it))", "by (simp add: set_empty_def)"], ["", "text\\<open>For completeness lets also consider injective versions.\\<close>"], ["", "lemma iterate_inj_image_filter_add_to_set_correct :\nassumes ins_dj_OK: \"set_ins_dj \\<alpha> invar ins\"\nassumes s_OK: \"invar s\"\nassumes it: \"set_iterator it S0\"\nassumes dj: \"{y. \\<exists>x. x \\<in> S0 \\<and> f x = Some y} \\<inter> \\<alpha> s = {}\"\nassumes f_inj_on: \"inj_on f (S0 \\<inter> dom f)\"\nshows \"\\<alpha> (iterate_add_to_set s ins (set_iterator_image_filter f it)) = \n          {b . \\<exists>a. a \\<in> S0 \\<and> f a = Some b} \\<union> \\<alpha> s \\<and> \n       invar (iterate_add_to_set s ins  (set_iterator_image_filter f it))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (iterate_add_to_set s ins (set_iterator_image_filter f it)) =\n    {b. \\<exists>a. a \\<in> S0 \\<and> f a = Some b} \\<union>\n    \\<alpha> s \\<and>\n    invar (iterate_add_to_set s ins (set_iterator_image_filter f it))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<alpha> (iterate_add_to_set s ins (set_iterator_image_filter f it)) =\n    {b. \\<exists>a. a \\<in> S0 \\<and> f a = Some b} \\<union>\n    \\<alpha> s \\<and>\n    invar (iterate_add_to_set s ins (set_iterator_image_filter f it))", "from set_iterator_image_filter_correct [OF it f_inj_on]"], ["proof (chain)\npicking this:\n  set_iterator (set_iterator_image_filter f it)\n   {y. \\<exists>x. x \\<in> S0 \\<and> f x = Some y}", "have it_f: \"set_iterator (set_iterator_image_filter f it)\n        {y. \\<exists>x. x \\<in> S0 \\<and> f x = Some y}\""], ["proof (prove)\nusing this:\n  set_iterator (set_iterator_image_filter f it)\n   {y. \\<exists>x. x \\<in> S0 \\<and> f x = Some y}\n\ngoal (1 subgoal):\n 1. set_iterator (set_iterator_image_filter f it)\n     {y. \\<exists>x. x \\<in> S0 \\<and> f x = Some y}", "by simp"], ["proof (state)\nthis:\n  set_iterator (set_iterator_image_filter f it)\n   {y. \\<exists>x. x \\<in> S0 \\<and> f x = Some y}\n\ngoal (1 subgoal):\n 1. \\<alpha> (iterate_add_to_set s ins (set_iterator_image_filter f it)) =\n    {b. \\<exists>a. a \\<in> S0 \\<and> f a = Some b} \\<union>\n    \\<alpha> s \\<and>\n    invar (iterate_add_to_set s ins (set_iterator_image_filter f it))", "from iterate_add_to_set_dj_correct [OF ins_dj_OK, OF s_OK it_f dj]"], ["proof (chain)\npicking this:\n  \\<alpha> (iterate_add_to_set s ins (set_iterator_image_filter f it)) =\n  {y. \\<exists>x. x \\<in> S0 \\<and> f x = Some y} \\<union> \\<alpha> s \\<and>\n  invar (iterate_add_to_set s ins (set_iterator_image_filter f it))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<alpha> (iterate_add_to_set s ins (set_iterator_image_filter f it)) =\n  {y. \\<exists>x. x \\<in> S0 \\<and> f x = Some y} \\<union> \\<alpha> s \\<and>\n  invar (iterate_add_to_set s ins (set_iterator_image_filter f it))\n\ngoal (1 subgoal):\n 1. \\<alpha> (iterate_add_to_set s ins (set_iterator_image_filter f it)) =\n    {b. \\<exists>a. a \\<in> S0 \\<and> f a = Some b} \\<union>\n    \\<alpha> s \\<and>\n    invar (iterate_add_to_set s ins (set_iterator_image_filter f it))", "by auto"], ["proof (state)\nthis:\n  \\<alpha> (iterate_add_to_set s ins (set_iterator_image_filter f it)) =\n  {b. \\<exists>a. a \\<in> S0 \\<and> f a = Some b} \\<union> \\<alpha> s \\<and>\n  invar (iterate_add_to_set s ins (set_iterator_image_filter f it))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma iterate_inj_image_filter_to_set_correct :\nassumes ins_OK: \"set_ins_dj \\<alpha> invar ins\"\nassumes emp_OK: \"set_empty \\<alpha> invar emp\"\nassumes it: \"set_iterator it S0\"\nassumes f_inj_on: \"inj_on f (S0 \\<inter> dom f)\"\nshows \"\\<alpha> (iterate_to_set emp ins (set_iterator_image_filter f it)) = \n          {b . \\<exists>a. a \\<in> S0 \\<and> f a = Some b} \\<and> \n       invar (iterate_to_set emp ins  (set_iterator_image_filter f it))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (iterate_to_set emp ins (set_iterator_image_filter f it)) =\n    {b. \\<exists>a. a \\<in> S0 \\<and> f a = Some b} \\<and>\n    invar (iterate_to_set emp ins (set_iterator_image_filter f it))", "unfolding iterate_to_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha>\n     (iterate_add_to_set (emp ()) ins (set_iterator_image_filter f it)) =\n    {b. \\<exists>a. a \\<in> S0 \\<and> f a = Some b} \\<and>\n    invar (iterate_add_to_set (emp ()) ins (set_iterator_image_filter f it))", "using iterate_inj_image_filter_add_to_set_correct [OF ins_OK _ it _ f_inj_on, of \"emp ()\"] emp_OK"], ["proof (prove)\nusing this:\n  \\<lbrakk>invar (emp ());\n   {y. \\<exists>x. x \\<in> S0 \\<and> f x = Some y} \\<inter>\n   \\<alpha> (emp ()) =\n   {}\\<rbrakk>\n  \\<Longrightarrow> \\<alpha>\n                     (iterate_add_to_set (emp ()) ins\n                       (set_iterator_image_filter f it)) =\n                    {b. \\<exists>a. a \\<in> S0 \\<and> f a = Some b} \\<union>\n                    \\<alpha> (emp ()) \\<and>\n                    invar\n                     (iterate_add_to_set (emp ()) ins\n                       (set_iterator_image_filter f it))\n  set_empty \\<alpha> invar emp\n\ngoal (1 subgoal):\n 1. \\<alpha>\n     (iterate_add_to_set (emp ()) ins (set_iterator_image_filter f it)) =\n    {b. \\<exists>a. a \\<in> S0 \\<and> f a = Some b} \\<and>\n    invar (iterate_add_to_set (emp ()) ins (set_iterator_image_filter f it))", "by (simp add: set_empty_def)"], ["", "subsection \\<open>Iterate diff Set\\<close>"], ["", "definition iterate_diff_set where\n    \"iterate_diff_set s del (it::('x,'x_set) set_iterator) = \n     it (\\<lambda>_. True) (\\<lambda>x \\<sigma>. del x \\<sigma>) s\""], ["", "lemma iterate_diff_correct :\nassumes del_OK: \"set_delete \\<alpha> invar del\"\nassumes s_OK: \"invar s\"\nassumes it: \"set_iterator it S0\"\nshows \"\\<alpha> (iterate_diff_set s del it) = \\<alpha> s - S0 \\<and> invar (iterate_diff_set s del it)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (iterate_diff_set s del it) = \\<alpha> s - S0 \\<and>\n    invar (iterate_diff_set s del it)", "unfolding iterate_diff_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (it (\\<lambda>_. True) del s) = \\<alpha> s - S0 \\<and>\n    invar (it (\\<lambda>_. True) del s)", "apply (rule set_iterator_no_cond_rule_insert_P [OF it,\n         where ?I=\"\\<lambda>S \\<sigma>. \\<alpha> \\<sigma> = \\<alpha> s - S \\<and> invar \\<sigma>\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<alpha> s = \\<alpha> s - {} \\<and> invar s\n 2. \\<And>S \\<sigma> x.\n       \\<lbrakk>x \\<in> S0 - S;\n        \\<alpha> \\<sigma> = \\<alpha> s - S \\<and> invar \\<sigma>;\n        S \\<subseteq> S0\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> (del x \\<sigma>) =\n                         \\<alpha> s - insert x S \\<and>\n                         invar (del x \\<sigma>)\n 3. \\<And>\\<sigma>.\n       \\<alpha> \\<sigma> = \\<alpha> s - S0 \\<and>\n       invar \\<sigma> \\<Longrightarrow>\n       \\<alpha> \\<sigma> = \\<alpha> s - S0 \\<and> invar \\<sigma>", "apply (insert del_OK s_OK)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>set_delete \\<alpha> invar del; invar s\\<rbrakk>\n    \\<Longrightarrow> \\<alpha> s = \\<alpha> s - {} \\<and> invar s\n 2. \\<And>S \\<sigma> x.\n       \\<lbrakk>x \\<in> S0 - S;\n        \\<alpha> \\<sigma> = \\<alpha> s - S \\<and> invar \\<sigma>;\n        S \\<subseteq> S0; set_delete \\<alpha> invar del; invar s\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> (del x \\<sigma>) =\n                         \\<alpha> s - insert x S \\<and>\n                         invar (del x \\<sigma>)\n 3. \\<And>\\<sigma>.\n       \\<lbrakk>\\<alpha> \\<sigma> = \\<alpha> s - S0 \\<and> invar \\<sigma>;\n        set_delete \\<alpha> invar del; invar s\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> \\<sigma> = \\<alpha> s - S0 \\<and>\n                         invar \\<sigma>", "apply (auto simp add: set_delete_def set_eq_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Iterate add to Map\\<close>"], ["", "definition iterate_add_to_map where\n    \"iterate_add_to_map m update (it::('k \\<times> 'v,'kv_map) set_iterator) = \n     it (\\<lambda>_. True) (\\<lambda>(k,v) \\<sigma>. update k v \\<sigma>) m\""], ["", "lemma iterate_add_to_map_correct :\nassumes upd_OK: \"map_update \\<alpha> invar upd\"\nassumes m_OK: \"invar m\"\nassumes it: \"map_iterator it M\"\nshows \"\\<alpha> (iterate_add_to_map m upd it) = \\<alpha> m ++ M  \\<and> invar (iterate_add_to_map m upd it)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (iterate_add_to_map m upd it) = \\<alpha> m ++ M \\<and>\n    invar (iterate_add_to_map m upd it)", "using assms"], ["proof (prove)\nusing this:\n  map_update \\<alpha> invar upd\n  invar m\n  map_iterator it M\n\ngoal (1 subgoal):\n 1. \\<alpha> (iterate_add_to_map m upd it) = \\<alpha> m ++ M \\<and>\n    invar (iterate_add_to_map m upd it)", "unfolding iterate_add_to_map_def"], ["proof (prove)\nusing this:\n  map_update \\<alpha> invar upd\n  invar m\n  map_iterator it M\n\ngoal (1 subgoal):\n 1. \\<alpha> (it (\\<lambda>_. True) (\\<lambda>(x, y). upd x y) m) =\n    \\<alpha> m ++ M \\<and>\n    invar (it (\\<lambda>_. True) (\\<lambda>(x, y). upd x y) m)", "apply (rule_tac map_iterator_no_cond_rule_insert_P [OF it,\n         where ?I=\"\\<lambda>d \\<sigma>. (\\<alpha> \\<sigma> = \\<alpha> m ++ M |` d) \\<and> invar \\<sigma>\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>map_update \\<alpha> invar upd; invar m;\n     map_iterator it M\\<rbrakk>\n    \\<Longrightarrow> \\<alpha> m = \\<alpha> m ++ M |` {} \\<and> invar m\n 2. \\<And>k v ita \\<sigma>.\n       \\<lbrakk>map_update \\<alpha> invar upd; invar m; map_iterator it M;\n        k \\<in> dom M - ita; M k = Some v; ita \\<subseteq> dom M;\n        \\<alpha> \\<sigma> = \\<alpha> m ++ M |` ita \\<and>\n        invar \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>\n                          ((case (k, v) of (x, xa) \\<Rightarrow> upd x xa)\n                            \\<sigma>) =\n                         \\<alpha> m ++ M |` insert k ita \\<and>\n                         invar\n                          ((case (k, v) of (x, xa) \\<Rightarrow> upd x xa)\n                            \\<sigma>)\n 3. \\<And>\\<sigma>.\n       \\<lbrakk>map_update \\<alpha> invar upd; invar m; map_iterator it M;\n        \\<alpha> \\<sigma> = \\<alpha> m ++ M |` dom M \\<and>\n        invar \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> \\<sigma> = \\<alpha> m ++ M \\<and>\n                         invar \\<sigma>", "apply (simp_all add: map_update_def restrict_map_insert)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iterate_add_to_map_dj_correct :\nassumes upd_OK: \"map_update_dj \\<alpha> invar upd\"\nassumes m_OK: \"invar m\"\nassumes it: \"map_iterator it M\"\nassumes dj: \"dom M \\<inter> dom (\\<alpha> m) = {}\"\nshows \"\\<alpha> (iterate_add_to_map m upd it) = \\<alpha> m ++ M  \\<and> invar (iterate_add_to_map m upd it)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (iterate_add_to_map m upd it) = \\<alpha> m ++ M \\<and>\n    invar (iterate_add_to_map m upd it)", "using assms"], ["proof (prove)\nusing this:\n  map_update_dj \\<alpha> invar upd\n  invar m\n  map_iterator it M\n  dom M \\<inter> dom (\\<alpha> m) = {}\n\ngoal (1 subgoal):\n 1. \\<alpha> (iterate_add_to_map m upd it) = \\<alpha> m ++ M \\<and>\n    invar (iterate_add_to_map m upd it)", "unfolding iterate_add_to_map_def"], ["proof (prove)\nusing this:\n  map_update_dj \\<alpha> invar upd\n  invar m\n  map_iterator it M\n  dom M \\<inter> dom (\\<alpha> m) = {}\n\ngoal (1 subgoal):\n 1. \\<alpha> (it (\\<lambda>_. True) (\\<lambda>(x, y). upd x y) m) =\n    \\<alpha> m ++ M \\<and>\n    invar (it (\\<lambda>_. True) (\\<lambda>(x, y). upd x y) m)", "apply (rule_tac map_iterator_no_cond_rule_insert_P [OF it,\n         where ?I=\"\\<lambda>d \\<sigma>. (\\<alpha> \\<sigma> = \\<alpha> m ++ M |` d) \\<and> invar \\<sigma>\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>map_update_dj \\<alpha> invar upd; invar m; map_iterator it M;\n     dom M \\<inter> dom (\\<alpha> m) = {}\\<rbrakk>\n    \\<Longrightarrow> \\<alpha> m = \\<alpha> m ++ M |` {} \\<and> invar m\n 2. \\<And>k v ita \\<sigma>.\n       \\<lbrakk>map_update_dj \\<alpha> invar upd; invar m;\n        map_iterator it M; dom M \\<inter> dom (\\<alpha> m) = {};\n        k \\<in> dom M - ita; M k = Some v; ita \\<subseteq> dom M;\n        \\<alpha> \\<sigma> = \\<alpha> m ++ M |` ita \\<and>\n        invar \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>\n                          ((case (k, v) of (x, xa) \\<Rightarrow> upd x xa)\n                            \\<sigma>) =\n                         \\<alpha> m ++ M |` insert k ita \\<and>\n                         invar\n                          ((case (k, v) of (x, xa) \\<Rightarrow> upd x xa)\n                            \\<sigma>)\n 3. \\<And>\\<sigma>.\n       \\<lbrakk>map_update_dj \\<alpha> invar upd; invar m;\n        map_iterator it M; dom M \\<inter> dom (\\<alpha> m) = {};\n        \\<alpha> \\<sigma> = \\<alpha> m ++ M |` dom M \\<and>\n        invar \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> \\<sigma> = \\<alpha> m ++ M \\<and>\n                         invar \\<sigma>", "apply (simp_all add: map_update_dj_def restrict_map_insert set_eq_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Iterator to Map\\<close>"], ["", "definition iterate_to_map where\n    \"iterate_to_map emp upd_dj (it::('k \\<times> 'v,'kv_map) set_iterator) = \n     iterate_add_to_map (emp ()) upd_dj it\""], ["", "lemma iterate_to_map_alt_def[code] :\n    \"iterate_to_map emp upd_dj it = \n     it (\\<lambda>_. True) (\\<lambda>(k, v) \\<sigma>. upd_dj k v \\<sigma>) (emp ())\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iterate_to_map emp upd_dj it =\n    it (\\<lambda>_. True) (\\<lambda>(k, v). upd_dj k v) (emp ())", "unfolding iterate_to_map_def iterate_add_to_map_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. it (\\<lambda>_. True) (\\<lambda>(x, y). upd_dj x y) (emp ()) =\n    it (\\<lambda>_. True) (\\<lambda>(k, v). upd_dj k v) (emp ())", "by simp"], ["", "lemma iterate_to_map_correct :\nassumes upd_dj_OK: \"map_update_dj \\<alpha> invar upd_dj\"\nassumes emp_OK: \"map_empty \\<alpha> invar emp\"\nassumes it: \"map_iterator it M\"\nshows \"\\<alpha> (iterate_to_map emp upd_dj it) = M \\<and> invar (iterate_to_map emp upd_dj it)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (iterate_to_map emp upd_dj it) = M \\<and>\n    invar (iterate_to_map emp upd_dj it)", "unfolding iterate_to_map_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (iterate_add_to_map (emp ()) upd_dj it) = M \\<and>\n    invar (iterate_add_to_map (emp ()) upd_dj it)", "using iterate_add_to_map_dj_correct [OF upd_dj_OK _ it, of \"emp ()\"] emp_OK"], ["proof (prove)\nusing this:\n  \\<lbrakk>invar (emp ());\n   dom M \\<inter> dom (\\<alpha> (emp ())) = {}\\<rbrakk>\n  \\<Longrightarrow> \\<alpha> (iterate_add_to_map (emp ()) upd_dj it) =\n                    \\<alpha> (emp ()) ++ M \\<and>\n                    invar (iterate_add_to_map (emp ()) upd_dj it)\n  map_empty \\<alpha> invar emp\n\ngoal (1 subgoal):\n 1. \\<alpha> (iterate_add_to_map (emp ()) upd_dj it) = M \\<and>\n    invar (iterate_add_to_map (emp ()) upd_dj it)", "by (simp add: map_empty_def)"], ["", "end"]]}