{"file_name": "/home/qj213/afp-2021-10-22/thys/Collections/GenCF/Intf/Intf_Set.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Collections", "problem_names": ["lemmas [autoref_rel_intf] = REL_INTFI[of set_rel i_set]", "lemma [autoref_op_pat]:\n  fixes s a b :: \"'a set\" and x::'a and P :: \"'a \\<Rightarrow> bool\"\n  shows\n  \"s - {x} \\<equiv> op_set_delete$x$s\"\n\n  \"s = {} \\<equiv> op_set_isEmpty$s\"\n  \"{}=s \\<equiv> op_set_isEmpty$s\"\n\n  \"card s = 1 \\<equiv> op_set_isSng$s\"\n  \"\\<exists>x. s={x} \\<equiv> op_set_isSng$s\"\n  \"\\<exists>x. {x}=s \\<equiv> op_set_isSng$s\"\n\n  \"min m (card s) \\<equiv> op_set_size_abort$m$s\"\n  \"min (card s) m \\<equiv> op_set_size_abort$m$s\"\n\n  \"a\\<inter>b={} \\<equiv> op_set_disjoint$a$b\"\n\n  \"{x\\<in>s. P x} \\<equiv> op_set_filter$P$s\"\n\n  \"SPEC (\\<lambda>x. x\\<in>s \\<and> P x) \\<equiv> op_set_sel$P$s\"\n  \"SPEC (\\<lambda>x. P x \\<and> x\\<in>s) \\<equiv> op_set_sel$P$s\"\n\n  \"SPEC (\\<lambda>x. x\\<in>s) \\<equiv> op_set_pick$s\"", "lemma [autoref_op_pat]:\n  \"a \\<times> b \\<equiv> op_set_cart a b\"", "lemma [autoref_op_pat]:\n  \"SPEC (\\<lambda>(u,v). (u,v)\\<in>s) \\<equiv> op_set_pick$s\"\n  \"SPEC (\\<lambda>(u,v). P u v \\<and> (u,v)\\<in>s) \\<equiv> op_set_sel$(case_prod P)$s\"\n  \"SPEC (\\<lambda>(u,v). (u,v)\\<in>s \\<and> P u v) \\<equiv> op_set_sel$(case_prod P)$s\"", "lemma [autoref_op_pat]:\n    \"SPEC (\\<lambda>l. set l = s \\<and> distinct l \\<and> sorted_wrt ordR l) \n    \\<equiv> OP (op_set_to_sorted_list ordR)$s\"\n    \"SPEC (\\<lambda>l. set l = s \\<and> sorted_wrt ordR l \\<and> distinct l) \n    \\<equiv> OP (op_set_to_sorted_list ordR)$s\"\n    \"SPEC (\\<lambda>l. distinct l \\<and> set l = s \\<and> sorted_wrt ordR l) \n    \\<equiv> OP (op_set_to_sorted_list ordR)$s\"\n    \"SPEC (\\<lambda>l. distinct l \\<and> sorted_wrt ordR l \\<and> set l = s) \n    \\<equiv> OP (op_set_to_sorted_list ordR)$s\"\n    \"SPEC (\\<lambda>l. sorted_wrt ordR l \\<and> distinct l \\<and> set l = s) \n    \\<equiv> OP (op_set_to_sorted_list ordR)$s\"\n    \"SPEC (\\<lambda>l. sorted_wrt ordR l \\<and> set l = s \\<and> distinct l) \n    \\<equiv> OP (op_set_to_sorted_list ordR)$s\"\n\n    \"SPEC (\\<lambda>l. s = set l \\<and> distinct l \\<and> sorted_wrt ordR l) \n    \\<equiv> OP (op_set_to_sorted_list ordR)$s\"\n    \"SPEC (\\<lambda>l. s = set l \\<and> sorted_wrt ordR l \\<and> distinct l) \n    \\<equiv> OP (op_set_to_sorted_list ordR)$s\"\n    \"SPEC (\\<lambda>l. distinct l \\<and> s = set l \\<and> sorted_wrt ordR l) \n    \\<equiv> OP (op_set_to_sorted_list ordR)$s\"\n    \"SPEC (\\<lambda>l. distinct l \\<and> sorted_wrt ordR l \\<and> s = set l) \n    \\<equiv> OP (op_set_to_sorted_list ordR)$s\"\n    \"SPEC (\\<lambda>l. sorted_wrt ordR l \\<and> distinct l \\<and> s = set l) \n    \\<equiv> OP (op_set_to_sorted_list ordR)$s\"\n    \"SPEC (\\<lambda>l. sorted_wrt ordR l \\<and> s = set l \\<and> distinct l) \n    \\<equiv> OP (op_set_to_sorted_list ordR)$s\"\n\n    \"SPEC (\\<lambda>l. set l = s \\<and> distinct l) \\<equiv> op_set_to_list$s\"\n    \"SPEC (\\<lambda>l. distinct l \\<and> set l = s) \\<equiv> op_set_to_list$s\"\n\n    \"SPEC (\\<lambda>l. s = set l \\<and> distinct l) \\<equiv> op_set_to_list$s\"\n    \"SPEC (\\<lambda>l. distinct l \\<and> s = set l) \\<equiv> op_set_to_list$s\"", "lemma [autoref_itype]:\n  \"{} ::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set\"\n  \"insert ::\\<^sub>i I \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set\"\n  \"op_set_delete ::\\<^sub>i I \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set\"\n  \"(\\<in>) ::\\<^sub>i I \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i i_bool\"\n  \"op_set_isEmpty ::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i i_bool\"\n  \"op_set_isSng ::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i i_bool\"\n  \"(\\<union>) ::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set\"\n  \"(\\<inter>) ::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set\"\n  \"((-) :: 'a set \\<Rightarrow> 'a set \\<Rightarrow> 'a set) ::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set\"\n  \"((=) :: 'a set \\<Rightarrow> 'a set \\<Rightarrow> bool) ::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i i_bool\"\n  \"(\\<subseteq>) ::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i i_bool\"\n  \"op_set_disjoint ::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i i_bool\"\n  \"Ball ::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i (I \\<rightarrow>\\<^sub>i i_bool) \\<rightarrow>\\<^sub>i i_bool\"\n  \"Bex ::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i (I \\<rightarrow>\\<^sub>i i_bool) \\<rightarrow>\\<^sub>i i_bool\"\n  \"op_set_filter ::\\<^sub>i (I \\<rightarrow>\\<^sub>i i_bool) \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set\"\n  \"card ::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i i_nat\"\n  \"op_set_size_abort ::\\<^sub>i i_nat \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i i_nat\"\n  \"set ::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_list \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set\"\n  \"op_set_sel ::\\<^sub>i (I \\<rightarrow>\\<^sub>i i_bool) \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_nres\"\n  \"op_set_pick ::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_nres\"\n  \"Sigma ::\\<^sub>i \\<langle>Ia\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i (Ia \\<rightarrow>\\<^sub>i \\<langle>Ib\\<rangle>\\<^sub>ii_set) \\<rightarrow>\\<^sub>i \\<langle>\\<langle>Ia,Ib\\<rangle>\\<^sub>ii_prod\\<rangle>\\<^sub>ii_set\"\n  \"(`) ::\\<^sub>i (Ia\\<rightarrow>\\<^sub>iIb) \\<rightarrow>\\<^sub>i \\<langle>Ia\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i \\<langle>Ib\\<rangle>\\<^sub>ii_set\"\n  \"op_set_cart ::\\<^sub>i \\<langle>Ix\\<rangle>\\<^sub>iIsx \\<rightarrow>\\<^sub>i \\<langle>Iy\\<rangle>\\<^sub>iIsy \\<rightarrow>\\<^sub>i \\<langle>\\<langle>Ix, Iy\\<rangle>\\<^sub>ii_prod\\<rangle>\\<^sub>iIsp\"\n  \"Union ::\\<^sub>i \\<langle>\\<langle>I\\<rangle>\\<^sub>ii_set\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set\"\n  \"atLeastLessThan ::\\<^sub>i i_nat \\<rightarrow>\\<^sub>i i_nat \\<rightarrow>\\<^sub>i \\<langle>i_nat\\<rangle>\\<^sub>ii_set\"", "lemma hom_set1[autoref_hom]:\n  \"CONSTRAINT {} (\\<langle>R\\<rangle>Rs)\"\n  \"CONSTRAINT insert (R\\<rightarrow>\\<langle>R\\<rangle>Rs\\<rightarrow>\\<langle>R\\<rangle>Rs)\"\n  \"CONSTRAINT (\\<in>) (R\\<rightarrow>\\<langle>R\\<rangle>Rs\\<rightarrow>Id)\"\n  \"CONSTRAINT (\\<union>) (\\<langle>R\\<rangle>Rs\\<rightarrow>\\<langle>R\\<rangle>Rs\\<rightarrow>\\<langle>R\\<rangle>Rs)\"\n  \"CONSTRAINT (\\<inter>) (\\<langle>R\\<rangle>Rs\\<rightarrow>\\<langle>R\\<rangle>Rs\\<rightarrow>\\<langle>R\\<rangle>Rs)\"\n  \"CONSTRAINT (-) (\\<langle>R\\<rangle>Rs\\<rightarrow>\\<langle>R\\<rangle>Rs\\<rightarrow>\\<langle>R\\<rangle>Rs)\"\n  \"CONSTRAINT (=) (\\<langle>R\\<rangle>Rs\\<rightarrow>\\<langle>R\\<rangle>Rs\\<rightarrow>Id)\"\n  \"CONSTRAINT (\\<subseteq>) (\\<langle>R\\<rangle>Rs\\<rightarrow>\\<langle>R\\<rangle>Rs\\<rightarrow>Id)\"\n  \"CONSTRAINT Ball (\\<langle>R\\<rangle>Rs\\<rightarrow>(R\\<rightarrow>Id)\\<rightarrow>Id)\"\n  \"CONSTRAINT Bex (\\<langle>R\\<rangle>Rs\\<rightarrow>(R\\<rightarrow>Id)\\<rightarrow>Id)\"\n  \"CONSTRAINT card (\\<langle>R\\<rangle>Rs\\<rightarrow>Id)\"\n  \"CONSTRAINT set (\\<langle>R\\<rangle>Rl\\<rightarrow>\\<langle>R\\<rangle>Rs)\"\n  \"CONSTRAINT (`) ((Ra\\<rightarrow>Rb) \\<rightarrow> \\<langle>Ra\\<rangle>Rs\\<rightarrow>\\<langle>Rb\\<rangle>Rs)\"\n  \"CONSTRAINT Union (\\<langle>\\<langle>R\\<rangle>Ri\\<rangle>Ro \\<rightarrow> \\<langle>R\\<rangle>Ri)\"", "lemma hom_set2[autoref_hom]:\n  \"CONSTRAINT op_set_delete (R\\<rightarrow>\\<langle>R\\<rangle>Rs\\<rightarrow>\\<langle>R\\<rangle>Rs)\"\n  \"CONSTRAINT op_set_isEmpty (\\<langle>R\\<rangle>Rs\\<rightarrow>Id)\"\n  \"CONSTRAINT op_set_isSng (\\<langle>R\\<rangle>Rs\\<rightarrow>Id)\"\n  \"CONSTRAINT op_set_size_abort (Id\\<rightarrow>\\<langle>R\\<rangle>Rs\\<rightarrow>Id)\"\n  \"CONSTRAINT op_set_disjoint (\\<langle>R\\<rangle>Rs\\<rightarrow>\\<langle>R\\<rangle>Rs\\<rightarrow>Id)\"\n  \"CONSTRAINT op_set_filter ((R\\<rightarrow>Id)\\<rightarrow>\\<langle>R\\<rangle>Rs\\<rightarrow>\\<langle>R\\<rangle>Rs)\"\n  \"CONSTRAINT op_set_sel ((R \\<rightarrow> Id)\\<rightarrow>\\<langle>R\\<rangle>Rs\\<rightarrow>\\<langle>R\\<rangle>Rn)\"\n  \"CONSTRAINT op_set_pick (\\<langle>R\\<rangle>Rs\\<rightarrow>\\<langle>R\\<rangle>Rn)\"", "lemma hom_set_Sigma[autoref_hom]:\n  \"CONSTRAINT Sigma (\\<langle>Ra\\<rangle>Rs \\<rightarrow> (Ra \\<rightarrow> \\<langle>Rb\\<rangle>Rs) \\<rightarrow> \\<langle>\\<langle>Ra,Rb\\<rangle>prod_rel\\<rangle>Rs2)\"", "lemma finite_set_rel_trigger: \"finite_set_rel R \\<Longrightarrow> finite_set_rel R\""], "translations": [["", "lemmas [autoref_rel_intf] = REL_INTFI[of set_rel i_set]"], ["", "definition [simp]: \"op_set_delete x s \\<equiv> s - {x}\""], ["", "definition [simp]: \"op_set_isEmpty s \\<equiv> s = {}\""], ["", "definition [simp]: \"op_set_isSng s \\<equiv> card s = 1\""], ["", "definition [simp]: \"op_set_size_abort m s \\<equiv> min m (card s)\""], ["", "definition [simp]: \"op_set_disjoint a b \\<equiv> a\\<inter>b={}\""], ["", "definition [simp]: \"op_set_filter P s \\<equiv> {x\\<in>s. P x}\""], ["", "definition [simp]: \"op_set_sel P s \\<equiv> SPEC (\\<lambda>x. x\\<in>s \\<and> P x)\""], ["", "definition [simp]: \"op_set_pick s \\<equiv> SPEC (\\<lambda>x. x\\<in>s)\""], ["", "definition [simp]: \"op_set_to_sorted_list ordR s \n  \\<equiv> SPEC (\\<lambda>l. set l = s \\<and> distinct l \\<and> sorted_wrt ordR l)\""], ["", "definition [simp]: \"op_set_to_list s \\<equiv> SPEC (\\<lambda>l. set l = s \\<and> distinct l)\""], ["", "definition [simp]: \"op_set_cart x y \\<equiv> x \\<times> y\""], ["", "(* TODO: Do op_set_pick_remove (like op_map_pick_remove) *)"], ["", "context begin"], ["", "interpretation autoref_syn"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma [autoref_op_pat]:\n  fixes s a b :: \"'a set\" and x::'a and P :: \"'a \\<Rightarrow> bool\"\n  shows\n  \"s - {x} \\<equiv> op_set_delete$x$s\"\n\n  \"s = {} \\<equiv> op_set_isEmpty$s\"\n  \"{}=s \\<equiv> op_set_isEmpty$s\"\n\n  \"card s = 1 \\<equiv> op_set_isSng$s\"\n  \"\\<exists>x. s={x} \\<equiv> op_set_isSng$s\"\n  \"\\<exists>x. {x}=s \\<equiv> op_set_isSng$s\"\n\n  \"min m (card s) \\<equiv> op_set_size_abort$m$s\"\n  \"min (card s) m \\<equiv> op_set_size_abort$m$s\"\n\n  \"a\\<inter>b={} \\<equiv> op_set_disjoint$a$b\"\n\n  \"{x\\<in>s. P x} \\<equiv> op_set_filter$P$s\"\n\n  \"SPEC (\\<lambda>x. x\\<in>s \\<and> P x) \\<equiv> op_set_sel$P$s\"\n  \"SPEC (\\<lambda>x. P x \\<and> x\\<in>s) \\<equiv> op_set_sel$P$s\"\n\n  \"SPEC (\\<lambda>x. x\\<in>s) \\<equiv> op_set_pick$s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((s - {x} \\<equiv> op_set_delete $ x $ s) &&&\n      (s = {} \\<equiv> op_set_isEmpty $ s) &&&\n      {} = s \\<equiv> op_set_isEmpty $ s) &&&\n     (card s = 1 \\<equiv> op_set_isSng $ s) &&&\n     (\\<exists>x. s = {x} \\<equiv> op_set_isSng $ s) &&&\n     \\<exists>x. {x} = s \\<equiv> op_set_isSng $ s) &&&\n    ((min m (card s) \\<equiv> op_set_size_abort $ m $ s) &&&\n     (min (card s) m \\<equiv> op_set_size_abort $ m $ s) &&&\n     a \\<inter> b = {} \\<equiv> op_set_disjoint $ a $ b) &&&\n    (({x \\<in> s. P x} \\<equiv> op_set_filter $ P $ s) &&&\n     SPEC (\\<lambda>x. x \\<in> s \\<and> P x) \\<equiv>\n     op_set_sel $ P $ s) &&&\n    (SPEC (\\<lambda>x. P x \\<and> x \\<in> s) \\<equiv>\n     op_set_sel $ P $ s) &&&\n    SPEC (\\<lambda>x. x \\<in> s) \\<equiv> op_set_pick $ s", "by (auto intro!: eq_reflection simp: card_Suc_eq)"], ["", "lemma [autoref_op_pat]:\n  \"a \\<times> b \\<equiv> op_set_cart a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<times> b \\<equiv> op_set_cart a b", "by (auto intro!: eq_reflection simp: card_Suc_eq)"], ["", "lemma [autoref_op_pat]:\n  \"SPEC (\\<lambda>(u,v). (u,v)\\<in>s) \\<equiv> op_set_pick$s\"\n  \"SPEC (\\<lambda>(u,v). P u v \\<and> (u,v)\\<in>s) \\<equiv> op_set_sel$(case_prod P)$s\"\n  \"SPEC (\\<lambda>(u,v). (u,v)\\<in>s \\<and> P u v) \\<equiv> op_set_sel$(case_prod P)$s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SPEC (\\<lambda>(u, v). (u, v) \\<in> s) \\<equiv> op_set_pick $ s) &&&\n    (SPEC (\\<lambda>(u, v). P u v \\<and> (u, v) \\<in> s) \\<equiv>\n     op_set_sel $ (\\<lambda>(x, y). P x y) $ s) &&&\n    SPEC (\\<lambda>(u, v). (u, v) \\<in> s \\<and> P u v) \\<equiv>\n    op_set_sel $ (\\<lambda>(x, y). P x y) $ s", "by (auto intro!: eq_reflection)"], ["", "lemma [autoref_op_pat]:\n    \"SPEC (\\<lambda>l. set l = s \\<and> distinct l \\<and> sorted_wrt ordR l) \n    \\<equiv> OP (op_set_to_sorted_list ordR)$s\"\n    \"SPEC (\\<lambda>l. set l = s \\<and> sorted_wrt ordR l \\<and> distinct l) \n    \\<equiv> OP (op_set_to_sorted_list ordR)$s\"\n    \"SPEC (\\<lambda>l. distinct l \\<and> set l = s \\<and> sorted_wrt ordR l) \n    \\<equiv> OP (op_set_to_sorted_list ordR)$s\"\n    \"SPEC (\\<lambda>l. distinct l \\<and> sorted_wrt ordR l \\<and> set l = s) \n    \\<equiv> OP (op_set_to_sorted_list ordR)$s\"\n    \"SPEC (\\<lambda>l. sorted_wrt ordR l \\<and> distinct l \\<and> set l = s) \n    \\<equiv> OP (op_set_to_sorted_list ordR)$s\"\n    \"SPEC (\\<lambda>l. sorted_wrt ordR l \\<and> set l = s \\<and> distinct l) \n    \\<equiv> OP (op_set_to_sorted_list ordR)$s\"\n\n    \"SPEC (\\<lambda>l. s = set l \\<and> distinct l \\<and> sorted_wrt ordR l) \n    \\<equiv> OP (op_set_to_sorted_list ordR)$s\"\n    \"SPEC (\\<lambda>l. s = set l \\<and> sorted_wrt ordR l \\<and> distinct l) \n    \\<equiv> OP (op_set_to_sorted_list ordR)$s\"\n    \"SPEC (\\<lambda>l. distinct l \\<and> s = set l \\<and> sorted_wrt ordR l) \n    \\<equiv> OP (op_set_to_sorted_list ordR)$s\"\n    \"SPEC (\\<lambda>l. distinct l \\<and> sorted_wrt ordR l \\<and> s = set l) \n    \\<equiv> OP (op_set_to_sorted_list ordR)$s\"\n    \"SPEC (\\<lambda>l. sorted_wrt ordR l \\<and> distinct l \\<and> s = set l) \n    \\<equiv> OP (op_set_to_sorted_list ordR)$s\"\n    \"SPEC (\\<lambda>l. sorted_wrt ordR l \\<and> s = set l \\<and> distinct l) \n    \\<equiv> OP (op_set_to_sorted_list ordR)$s\"\n\n    \"SPEC (\\<lambda>l. set l = s \\<and> distinct l) \\<equiv> op_set_to_list$s\"\n    \"SPEC (\\<lambda>l. distinct l \\<and> set l = s) \\<equiv> op_set_to_list$s\"\n\n    \"SPEC (\\<lambda>l. s = set l \\<and> distinct l) \\<equiv> op_set_to_list$s\"\n    \"SPEC (\\<lambda>l. distinct l \\<and> s = set l) \\<equiv> op_set_to_list$s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((((SPEC\n         (\\<lambda>l.\n             set l = s \\<and> distinct l \\<and> sorted_wrt ordR l) \\<equiv>\n        OP (op_set_to_sorted_list ordR) $ s) &&&\n       SPEC\n        (\\<lambda>l.\n            set l = s \\<and> sorted_wrt ordR l \\<and> distinct l) \\<equiv>\n       OP (op_set_to_sorted_list ordR) $ s) &&&\n      (SPEC\n        (\\<lambda>l.\n            distinct l \\<and> set l = s \\<and> sorted_wrt ordR l) \\<equiv>\n       OP (op_set_to_sorted_list ordR) $ s) &&&\n      SPEC\n       (\\<lambda>l.\n           distinct l \\<and> sorted_wrt ordR l \\<and> set l = s) \\<equiv>\n      OP (op_set_to_sorted_list ordR) $ s) &&&\n     ((SPEC\n        (\\<lambda>l.\n            sorted_wrt ordR l \\<and> distinct l \\<and> set l = s) \\<equiv>\n       OP (op_set_to_sorted_list ordR) $ s) &&&\n      SPEC\n       (\\<lambda>l.\n           sorted_wrt ordR l \\<and> set l = s \\<and> distinct l) \\<equiv>\n      OP (op_set_to_sorted_list ordR) $ s) &&&\n     (SPEC\n       (\\<lambda>l.\n           s = set l \\<and> distinct l \\<and> sorted_wrt ordR l) \\<equiv>\n      OP (op_set_to_sorted_list ordR) $ s) &&&\n     SPEC\n      (\\<lambda>l.\n          s = set l \\<and> sorted_wrt ordR l \\<and> distinct l) \\<equiv>\n     OP (op_set_to_sorted_list ordR) $ s) &&&\n    (((SPEC\n        (\\<lambda>l.\n            distinct l \\<and> s = set l \\<and> sorted_wrt ordR l) \\<equiv>\n       OP (op_set_to_sorted_list ordR) $ s) &&&\n      SPEC\n       (\\<lambda>l.\n           distinct l \\<and> sorted_wrt ordR l \\<and> s = set l) \\<equiv>\n      OP (op_set_to_sorted_list ordR) $ s) &&&\n     (SPEC\n       (\\<lambda>l.\n           sorted_wrt ordR l \\<and> distinct l \\<and> s = set l) \\<equiv>\n      OP (op_set_to_sorted_list ordR) $ s) &&&\n     SPEC\n      (\\<lambda>l.\n          sorted_wrt ordR l \\<and> s = set l \\<and> distinct l) \\<equiv>\n     OP (op_set_to_sorted_list ordR) $ s) &&&\n    ((SPEC (\\<lambda>l. set l = s \\<and> distinct l) \\<equiv>\n      op_set_to_list $ s) &&&\n     SPEC (\\<lambda>l. distinct l \\<and> set l = s) \\<equiv>\n     op_set_to_list $ s) &&&\n    (SPEC (\\<lambda>l. s = set l \\<and> distinct l) \\<equiv>\n     op_set_to_list $ s) &&&\n    SPEC (\\<lambda>l. distinct l \\<and> s = set l) \\<equiv>\n    op_set_to_list $ s", "by (auto intro!: eq_reflection)"], ["", "end"], ["", "lemma [autoref_itype]:\n  \"{} ::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set\"\n  \"insert ::\\<^sub>i I \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set\"\n  \"op_set_delete ::\\<^sub>i I \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set\"\n  \"(\\<in>) ::\\<^sub>i I \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i i_bool\"\n  \"op_set_isEmpty ::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i i_bool\"\n  \"op_set_isSng ::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i i_bool\"\n  \"(\\<union>) ::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set\"\n  \"(\\<inter>) ::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set\"\n  \"((-) :: 'a set \\<Rightarrow> 'a set \\<Rightarrow> 'a set) ::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set\"\n  \"((=) :: 'a set \\<Rightarrow> 'a set \\<Rightarrow> bool) ::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i i_bool\"\n  \"(\\<subseteq>) ::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i i_bool\"\n  \"op_set_disjoint ::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i i_bool\"\n  \"Ball ::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i (I \\<rightarrow>\\<^sub>i i_bool) \\<rightarrow>\\<^sub>i i_bool\"\n  \"Bex ::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i (I \\<rightarrow>\\<^sub>i i_bool) \\<rightarrow>\\<^sub>i i_bool\"\n  \"op_set_filter ::\\<^sub>i (I \\<rightarrow>\\<^sub>i i_bool) \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set\"\n  \"card ::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i i_nat\"\n  \"op_set_size_abort ::\\<^sub>i i_nat \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i i_nat\"\n  \"set ::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_list \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set\"\n  \"op_set_sel ::\\<^sub>i (I \\<rightarrow>\\<^sub>i i_bool) \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_nres\"\n  \"op_set_pick ::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_nres\"\n  \"Sigma ::\\<^sub>i \\<langle>Ia\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i (Ia \\<rightarrow>\\<^sub>i \\<langle>Ib\\<rangle>\\<^sub>ii_set) \\<rightarrow>\\<^sub>i \\<langle>\\<langle>Ia,Ib\\<rangle>\\<^sub>ii_prod\\<rangle>\\<^sub>ii_set\"\n  \"(`) ::\\<^sub>i (Ia\\<rightarrow>\\<^sub>iIb) \\<rightarrow>\\<^sub>i \\<langle>Ia\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i \\<langle>Ib\\<rangle>\\<^sub>ii_set\"\n  \"op_set_cart ::\\<^sub>i \\<langle>Ix\\<rangle>\\<^sub>iIsx \\<rightarrow>\\<^sub>i \\<langle>Iy\\<rangle>\\<^sub>iIsy \\<rightarrow>\\<^sub>i \\<langle>\\<langle>Ix, Iy\\<rangle>\\<^sub>ii_prod\\<rangle>\\<^sub>iIsp\"\n  \"Union ::\\<^sub>i \\<langle>\\<langle>I\\<rangle>\\<^sub>ii_set\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set\"\n  \"atLeastLessThan ::\\<^sub>i i_nat \\<rightarrow>\\<^sub>i i_nat \\<rightarrow>\\<^sub>i \\<langle>i_nat\\<rangle>\\<^sub>ii_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((({} ::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set &&&\n       insert ::\\<^sub>i\n       I \\<rightarrow>\\<^sub>i\n       \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i\n       \\<langle>I\\<rangle>\\<^sub>ii_set &&&\n       op_set_delete ::\\<^sub>i\n       I \\<rightarrow>\\<^sub>i\n       \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i\n       \\<langle>I\\<rangle>\\<^sub>ii_set) &&&\n      (\\<in>) ::\\<^sub>i\n      I \\<rightarrow>\\<^sub>i\n      \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i i_bool &&&\n      op_set_isEmpty ::\\<^sub>i\n      \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i i_bool &&&\n      op_set_isSng ::\\<^sub>i\n      \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i i_bool) &&&\n     ((\\<union>) ::\\<^sub>i\n      \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i\n      \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i\n      \\<langle>I\\<rangle>\\<^sub>ii_set &&&\n      (\\<inter>) ::\\<^sub>i\n      \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i\n      \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i\n      \\<langle>I\\<rangle>\\<^sub>ii_set &&&\n      (-) ::\\<^sub>i\n      \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i\n      \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i\n      \\<langle>I\\<rangle>\\<^sub>ii_set) &&&\n     (=) ::\\<^sub>i\n     \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i\n     \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i i_bool &&&\n     (\\<subseteq>) ::\\<^sub>i\n     \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i\n     \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i i_bool &&&\n     op_set_disjoint ::\\<^sub>i\n     \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i\n     \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i i_bool) &&&\n    ((Ball ::\\<^sub>i\n      \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i\n      (I \\<rightarrow>\\<^sub>i i_bool) \\<rightarrow>\\<^sub>i i_bool &&&\n      Bex ::\\<^sub>i\n      \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i\n      (I \\<rightarrow>\\<^sub>i i_bool) \\<rightarrow>\\<^sub>i i_bool &&&\n      op_set_filter ::\\<^sub>i\n      (I \\<rightarrow>\\<^sub>i i_bool) \\<rightarrow>\\<^sub>i\n      \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i\n      \\<langle>I\\<rangle>\\<^sub>ii_set) &&&\n     card ::\\<^sub>i\n     \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i i_nat &&&\n     op_set_size_abort ::\\<^sub>i\n     i_nat \\<rightarrow>\\<^sub>i\n     \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i i_nat &&&\n     set ::\\<^sub>i\n     \\<langle>I\\<rangle>\\<^sub>ii_list \\<rightarrow>\\<^sub>i\n     \\<langle>I\\<rangle>\\<^sub>ii_set) &&&\n    (op_set_sel ::\\<^sub>i\n     (I \\<rightarrow>\\<^sub>i i_bool) \\<rightarrow>\\<^sub>i\n     \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i\n     \\<langle>I\\<rangle>\\<^sub>ii_nres &&&\n     op_set_pick ::\\<^sub>i\n     \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i\n     \\<langle>I\\<rangle>\\<^sub>ii_nres &&&\n     Sigma ::\\<^sub>i\n     \\<langle>Ia\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i\n     (Ia \\<rightarrow>\\<^sub>i\n      \\<langle>Ib\\<rangle>\\<^sub>ii_set) \\<rightarrow>\\<^sub>i\n     \\<langle>\\<langle>Ia,\n     Ib\\<rangle>\\<^sub>ii_prod\\<rangle>\\<^sub>ii_set) &&&\n    ((`) ::\\<^sub>i\n     (Ia \\<rightarrow>\\<^sub>i Ib) \\<rightarrow>\\<^sub>i\n     \\<langle>Ia\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i\n     \\<langle>Ib\\<rangle>\\<^sub>ii_set &&&\n     op_set_cart ::\\<^sub>i\n     \\<langle>Ix\\<rangle>\\<^sub>iIsx \\<rightarrow>\\<^sub>i\n     \\<langle>Iy\\<rangle>\\<^sub>iIsy \\<rightarrow>\\<^sub>i\n     \\<langle>\\<langle>Ix,\n     Iy\\<rangle>\\<^sub>ii_prod\\<rangle>\\<^sub>iIsp) &&&\n    \\<Union> ::\\<^sub>i\n    \\<langle>\\<langle>I\\<rangle>\\<^sub>ii_set\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i\n    \\<langle>I\\<rangle>\\<^sub>ii_set &&&\n    atLeastLessThan ::\\<^sub>i\n    i_nat \\<rightarrow>\\<^sub>i\n    i_nat \\<rightarrow>\\<^sub>i \\<langle>i_nat\\<rangle>\\<^sub>ii_set", "by simp_all"], ["", "lemma hom_set1[autoref_hom]:\n  \"CONSTRAINT {} (\\<langle>R\\<rangle>Rs)\"\n  \"CONSTRAINT insert (R\\<rightarrow>\\<langle>R\\<rangle>Rs\\<rightarrow>\\<langle>R\\<rangle>Rs)\"\n  \"CONSTRAINT (\\<in>) (R\\<rightarrow>\\<langle>R\\<rangle>Rs\\<rightarrow>Id)\"\n  \"CONSTRAINT (\\<union>) (\\<langle>R\\<rangle>Rs\\<rightarrow>\\<langle>R\\<rangle>Rs\\<rightarrow>\\<langle>R\\<rangle>Rs)\"\n  \"CONSTRAINT (\\<inter>) (\\<langle>R\\<rangle>Rs\\<rightarrow>\\<langle>R\\<rangle>Rs\\<rightarrow>\\<langle>R\\<rangle>Rs)\"\n  \"CONSTRAINT (-) (\\<langle>R\\<rangle>Rs\\<rightarrow>\\<langle>R\\<rangle>Rs\\<rightarrow>\\<langle>R\\<rangle>Rs)\"\n  \"CONSTRAINT (=) (\\<langle>R\\<rangle>Rs\\<rightarrow>\\<langle>R\\<rangle>Rs\\<rightarrow>Id)\"\n  \"CONSTRAINT (\\<subseteq>) (\\<langle>R\\<rangle>Rs\\<rightarrow>\\<langle>R\\<rangle>Rs\\<rightarrow>Id)\"\n  \"CONSTRAINT Ball (\\<langle>R\\<rangle>Rs\\<rightarrow>(R\\<rightarrow>Id)\\<rightarrow>Id)\"\n  \"CONSTRAINT Bex (\\<langle>R\\<rangle>Rs\\<rightarrow>(R\\<rightarrow>Id)\\<rightarrow>Id)\"\n  \"CONSTRAINT card (\\<langle>R\\<rangle>Rs\\<rightarrow>Id)\"\n  \"CONSTRAINT set (\\<langle>R\\<rangle>Rl\\<rightarrow>\\<langle>R\\<rangle>Rs)\"\n  \"CONSTRAINT (`) ((Ra\\<rightarrow>Rb) \\<rightarrow> \\<langle>Ra\\<rangle>Rs\\<rightarrow>\\<langle>Rb\\<rangle>Rs)\"\n  \"CONSTRAINT Union (\\<langle>\\<langle>R\\<rangle>Ri\\<rangle>Ro \\<rightarrow> \\<langle>R\\<rangle>Ri)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((CONSTRAINT {} (\\<langle>R\\<rangle>Rs) &&&\n      CONSTRAINT insert\n       (R \\<rightarrow>\n        \\<langle>R\\<rangle>Rs \\<rightarrow> \\<langle>R\\<rangle>Rs) &&&\n      CONSTRAINT (\\<in>)\n       (R \\<rightarrow> \\<langle>R\\<rangle>Rs \\<rightarrow> bool_rel)) &&&\n     (CONSTRAINT (\\<union>)\n       (\\<langle>R\\<rangle>Rs \\<rightarrow>\n        \\<langle>R\\<rangle>Rs \\<rightarrow> \\<langle>R\\<rangle>Rs) &&&\n      CONSTRAINT (\\<inter>)\n       (\\<langle>R\\<rangle>Rs \\<rightarrow>\n        \\<langle>R\\<rangle>Rs \\<rightarrow> \\<langle>R\\<rangle>Rs)) &&&\n     CONSTRAINT (-)\n      (\\<langle>R\\<rangle>Rs \\<rightarrow>\n       \\<langle>R\\<rangle>Rs \\<rightarrow> \\<langle>R\\<rangle>Rs) &&&\n     CONSTRAINT (=)\n      (\\<langle>R\\<rangle>Rs \\<rightarrow>\n       \\<langle>R\\<rangle>Rs \\<rightarrow> bool_rel)) &&&\n    (CONSTRAINT (\\<subseteq>)\n      (\\<langle>R\\<rangle>Rs \\<rightarrow>\n       \\<langle>R\\<rangle>Rs \\<rightarrow> bool_rel) &&&\n     CONSTRAINT Ball\n      (\\<langle>R\\<rangle>Rs \\<rightarrow>\n       (R \\<rightarrow> bool_rel) \\<rightarrow> bool_rel) &&&\n     CONSTRAINT Bex\n      (\\<langle>R\\<rangle>Rs \\<rightarrow>\n       (R \\<rightarrow> bool_rel) \\<rightarrow> bool_rel)) &&&\n    (CONSTRAINT card (\\<langle>R\\<rangle>Rs \\<rightarrow> nat_rel) &&&\n     CONSTRAINT set\n      (\\<langle>R\\<rangle>Rl \\<rightarrow> \\<langle>R\\<rangle>Rs)) &&&\n    CONSTRAINT (`)\n     ((Ra \\<rightarrow> Rb) \\<rightarrow>\n      \\<langle>Ra\\<rangle>Rs \\<rightarrow> \\<langle>Rb\\<rangle>Rs) &&&\n    CONSTRAINT \\<Union>\n     (\\<langle>\\<langle>R\\<rangle>Ri\\<rangle>Ro \\<rightarrow>\n      \\<langle>R\\<rangle>Ri)", "by simp_all"], ["", "lemma hom_set2[autoref_hom]:\n  \"CONSTRAINT op_set_delete (R\\<rightarrow>\\<langle>R\\<rangle>Rs\\<rightarrow>\\<langle>R\\<rangle>Rs)\"\n  \"CONSTRAINT op_set_isEmpty (\\<langle>R\\<rangle>Rs\\<rightarrow>Id)\"\n  \"CONSTRAINT op_set_isSng (\\<langle>R\\<rangle>Rs\\<rightarrow>Id)\"\n  \"CONSTRAINT op_set_size_abort (Id\\<rightarrow>\\<langle>R\\<rangle>Rs\\<rightarrow>Id)\"\n  \"CONSTRAINT op_set_disjoint (\\<langle>R\\<rangle>Rs\\<rightarrow>\\<langle>R\\<rangle>Rs\\<rightarrow>Id)\"\n  \"CONSTRAINT op_set_filter ((R\\<rightarrow>Id)\\<rightarrow>\\<langle>R\\<rangle>Rs\\<rightarrow>\\<langle>R\\<rangle>Rs)\"\n  \"CONSTRAINT op_set_sel ((R \\<rightarrow> Id)\\<rightarrow>\\<langle>R\\<rangle>Rs\\<rightarrow>\\<langle>R\\<rangle>Rn)\"\n  \"CONSTRAINT op_set_pick (\\<langle>R\\<rangle>Rs\\<rightarrow>\\<langle>R\\<rangle>Rn)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((CONSTRAINT op_set_delete\n       (R \\<rightarrow>\n        \\<langle>R\\<rangle>Rs \\<rightarrow> \\<langle>R\\<rangle>Rs) &&&\n      CONSTRAINT op_set_isEmpty\n       (\\<langle>R\\<rangle>Rs \\<rightarrow> bool_rel)) &&&\n     CONSTRAINT op_set_isSng\n      (\\<langle>R\\<rangle>Rs \\<rightarrow> bool_rel) &&&\n     CONSTRAINT op_set_size_abort\n      (nat_rel \\<rightarrow>\n       \\<langle>R\\<rangle>Rs \\<rightarrow> nat_rel)) &&&\n    (CONSTRAINT op_set_disjoint\n      (\\<langle>R\\<rangle>Rs \\<rightarrow>\n       \\<langle>R\\<rangle>Rs \\<rightarrow> bool_rel) &&&\n     CONSTRAINT op_set_filter\n      ((R \\<rightarrow> bool_rel) \\<rightarrow>\n       \\<langle>R\\<rangle>Rs \\<rightarrow> \\<langle>R\\<rangle>Rs)) &&&\n    CONSTRAINT op_set_sel\n     ((R \\<rightarrow> bool_rel) \\<rightarrow>\n      \\<langle>R\\<rangle>Rs \\<rightarrow> \\<langle>R\\<rangle>Rn) &&&\n    CONSTRAINT op_set_pick\n     (\\<langle>R\\<rangle>Rs \\<rightarrow> \\<langle>R\\<rangle>Rn)", "by simp_all"], ["", "lemma hom_set_Sigma[autoref_hom]:\n  \"CONSTRAINT Sigma (\\<langle>Ra\\<rangle>Rs \\<rightarrow> (Ra \\<rightarrow> \\<langle>Rb\\<rangle>Rs) \\<rightarrow> \\<langle>\\<langle>Ra,Rb\\<rangle>prod_rel\\<rangle>Rs2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CONSTRAINT Sigma\n     (\\<langle>Ra\\<rangle>Rs \\<rightarrow>\n      (Ra \\<rightarrow> \\<langle>Rb\\<rangle>Rs) \\<rightarrow>\n      \\<langle>Ra \\<times>\\<^sub>r Rb\\<rangle>Rs2)", "by simp_all"], ["", "definition \"finite_set_rel R \\<equiv> Range R \\<subseteq> Collect (finite)\""], ["", "lemma finite_set_rel_trigger: \"finite_set_rel R \\<Longrightarrow> finite_set_rel R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_set_rel R \\<Longrightarrow> finite_set_rel R", "."], ["", "declaration \\<open>Tagged_Solver.add_triggers \n  \"Relators.relator_props_solver\" @{thms finite_set_rel_trigger}\\<close>"], ["", "end"]]}