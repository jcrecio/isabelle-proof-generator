{"file_name": "/home/qj213/afp-2021-10-22/thys/Collections/GenCF/Gen/Gen_Map.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Collections", "problem_names": ["lemma map_to_set_distinct_conv:\n    assumes \"distinct tsl'\" and \"map_to_set m' = set tsl'\"\n    shows \"distinct (map fst tsl')\"", "lemma foldli_add: \"det_fold_map X \n    (\\<lambda>_. True) (\\<lambda>(k,v) m. op_map_update k v m) m ((++) m)\"", "lemma gen_add[autoref_rules_raw]:\n    assumes PRIO_TAG_GEN_ALGO\n    assumes UPD: \"GEN_OP ins op_map_update (Rk\\<rightarrow>Rv\\<rightarrow>\\<langle>Rk,Rv\\<rangle>Rs1\\<rightarrow>\\<langle>Rk,Rv\\<rangle>Rs1)\"\n    assumes IT: \"SIDE_GEN_ALGO (is_map_to_list Rk Rv Rs2 tsl)\"\n    shows \"(gen_add (foldli o tsl) ins,(++)) \n      \\<in> (\\<langle>Rk,Rv\\<rangle>Rs1) \\<rightarrow> (\\<langle>Rk,Rv\\<rangle>Rs2) \\<rightarrow> (\\<langle>Rk,Rv\\<rangle>Rs1)\"", "lemma foldli_restrict: \"det_fold_map X (\\<lambda>_. True) \n    (\\<lambda>(k,v) m. if P (k,v) then op_map_update k v m else m) Map.empty\n      (op_map_restrict P )\" (is \"det_fold_map _ _ ?f _ _\")", "lemma gen_restrict[autoref_rules_raw]:\n    assumes PRIO_TAG_GEN_ALGO\n    assumes IT: \"SIDE_GEN_ALGO (is_map_to_list Rk Rv Rs1 tsl)\"\n    assumes INS: \n      \"GEN_OP upd op_map_update (Rk\\<rightarrow>Rv\\<rightarrow>\\<langle>Rk,Rv\\<rangle>Rs2\\<rightarrow>\\<langle>Rk,Rv\\<rangle>Rs2)\"\n    assumes EMPTY: \n      \"GEN_OP emp Map.empty (\\<langle>Rk,Rv\\<rangle>Rs2)\"\n    shows \"(gen_restrict (foldli o tsl) upd emp,op_map_restrict) \n    \\<in> (\\<langle>Rk,Rv\\<rangle>prod_rel \\<rightarrow> Id) \\<rightarrow> (\\<langle>Rk,Rv\\<rangle>Rs1) \\<rightarrow> (\\<langle>Rk,Rv\\<rangle>Rs2)\"", "lemma fold_map_of: \n    \"fold (\\<lambda>(k,v) s. op_map_update k v s) (rev l) Map.empty = map_of l\"", "lemma gen_map_of[autoref_rules_raw]:\n    assumes PRIO_TAG_GEN_ALGO\n    assumes UPD: \"GEN_OP upd op_map_update (Rk\\<rightarrow>Rv\\<rightarrow>\\<langle>Rk,Rv\\<rangle>Rm\\<rightarrow>\\<langle>Rk,Rv\\<rangle>Rm)\"\n    assumes EMPTY: \"GEN_OP emp Map.empty (\\<langle>Rk,Rv\\<rangle>Rm)\"\n    shows \"(gen_map_of emp upd,map_of) \\<in> \\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel \\<rightarrow> \\<langle>Rk,Rv\\<rangle>Rm\"", "lemma foldli_ball_aux: \n    \"distinct (map fst l) \\<Longrightarrow> foldli l (\\<lambda>x. x) (\\<lambda>x _. P x) b \n    \\<longleftrightarrow> b \\<and> op_map_ball (map_of l) P\"", "lemma foldli_ball: \n    \"det_fold_map X (\\<lambda>x. x) (\\<lambda>x _. P x) True (\\<lambda>m. op_map_ball m P)\"", "lemma gen_ball[autoref_rules_raw]:\n    assumes PRIO_TAG_GEN_ALGO\n    assumes IT: \"SIDE_GEN_ALGO (is_map_to_list Rk Rv Rm tsl)\"\n    shows \"(gen_ball (foldli o tsl),op_map_ball) \n    \\<in> \\<langle>Rk,Rv\\<rangle>Rm \\<rightarrow> (\\<langle>Rk,Rv\\<rangle>prod_rel \\<rightarrow> Id) \\<rightarrow> Id\"", "lemma foldli_bex_aux: \n    \"distinct (map fst l) \\<Longrightarrow> foldli l (\\<lambda>x. \\<not>x) (\\<lambda>x _. P x) b \n    \\<longleftrightarrow> b \\<or> op_map_bex (map_of l) P\"", "lemma foldli_bex: \n    \"det_fold_map X (\\<lambda>x. \\<not>x) (\\<lambda>x _. P x) False (\\<lambda>m. op_map_bex m P)\"", "lemma gen_bex[autoref_rules_raw]:\n    assumes PRIO_TAG_GEN_ALGO\n    assumes IT: \"SIDE_GEN_ALGO (is_map_to_list Rk Rv Rm tsl)\"\n    shows \"(gen_bex (foldli o tsl),op_map_bex) \n    \\<in> \\<langle>Rk,Rv\\<rangle>Rm \\<rightarrow> (\\<langle>Rk,Rv\\<rangle>prod_rel \\<rightarrow> Id) \\<rightarrow> Id\"", "lemma ball_isEmpty: \"op_map_isEmpty m = op_map_ball m (\\<lambda>_. False)\"", "lemma gen_isEmpty[autoref_rules_raw]:\n    assumes PRIO_TAG_GEN_ALGO\n    assumes BALL: \n      \"GEN_OP ball op_map_ball (\\<langle>Rk,Rv\\<rangle>Rm\\<rightarrow>(\\<langle>Rk,Rv\\<rangle>prod_rel\\<rightarrow>Id) \\<rightarrow> Id)\"\n    shows \"(gen_isEmpty ball,op_map_isEmpty) \n    \\<in> \\<langle>Rk,Rv\\<rangle>Rm \\<rightarrow> Id\"", "lemma foldli_size_aux: \"distinct (map fst l) \n    \\<Longrightarrow> foldli l (\\<lambda>_. True) (\\<lambda>_ n. Suc n) n = n + op_map_size (map_of l)\"", "lemma foldli_size: \"det_fold_map X (\\<lambda>_. True) (\\<lambda>_ n. Suc n) 0 op_map_size\"", "lemma gen_size[autoref_rules_raw]:\n    assumes PRIO_TAG_GEN_ALGO\n    assumes IT: \"SIDE_GEN_ALGO (is_map_to_list Rk Rv Rm tsl)\"\n    shows \"(gen_size (foldli o tsl),op_map_size) \\<in> \\<langle>Rk,Rv\\<rangle>Rm \\<rightarrow> Id\"", "lemma foldli_size_abort_aux:\n    \"\\<lbrakk>n0\\<le>m; distinct (map fst l)\\<rbrakk> \\<Longrightarrow> \n      foldli l (\\<lambda>n. n<m) (\\<lambda>_ n. Suc n) n0 = min m (n0 + card (dom (map_of l)))\"", "lemma foldli_size_abort: \n    \"det_fold_map X (\\<lambda>n. n<m) (\\<lambda>_ n. Suc n) 0 (op_map_size_abort m)\"", "lemma gen_size_abort[autoref_rules_raw]:\n    assumes PRIO_TAG_GEN_ALGO\n    assumes IT: \"SIDE_GEN_ALGO (is_map_to_list Rk Rv Rm tsl)\"\n    shows \"(gen_size_abort (foldli o tsl),op_map_size_abort) \n      \\<in> Id \\<rightarrow> \\<langle>Rk,Rv\\<rangle>Rm \\<rightarrow> Id\"", "lemma size_abort_isSng: \"op_map_isSng s \\<longleftrightarrow> op_map_size_abort 2 s = 1\"", "lemma gen_isSng[autoref_rules_raw]:\n    assumes PRIO_TAG_GEN_ALGO\n    assumes \"GEN_OP sizea op_map_size_abort (Id \\<rightarrow> (\\<langle>Rk,Rv\\<rangle>Rm) \\<rightarrow> Id)\"\n    shows \"(gen_isSng sizea,op_map_isSng) \n    \\<in> \\<langle>Rk,Rv\\<rangle>Rm \\<rightarrow> Id\"", "lemma foldli_pick:\n    assumes \"l\\<noteq>[]\" \n    obtains k v where \"(k,v)\\<in>set l\" \n    and \"(foldli l (case_option True (\\<lambda>_. False)) (\\<lambda>x _. Some x) None) \n      = Some (k,v)\"", "lemma gen_pick[autoref_rules_raw]:\n    assumes PRIO_TAG_GEN_ALGO\n    assumes IT: \"SIDE_GEN_ALGO (is_map_to_list Rk Rv Rm it)\"\n    assumes NE: \"SIDE_PRECOND (m'\\<noteq>Map.empty)\"\n    assumes SREF: \"(m,m')\\<in>\\<langle>Rk,Rv\\<rangle>Rm\"\n    shows \"(RETURN (gen_pick (\\<lambda>x. foldli (it x)) m), \n      (OP op_map_pick ::: \\<langle>Rk,Rv\\<rangle>Rm\\<rightarrow>\\<langle>Rk\\<times>\\<^sub>rRv\\<rangle>nres_rel)$m')\\<in>\\<langle>Rk\\<times>\\<^sub>rRv\\<rangle>nres_rel\"", "lemma gen_map_pick_remove\n    [unfolded gen_map_pick_remove_def, autoref_rules_raw]:\n    assumes PRIO_TAG_GEN_ALGO\n    assumes PICK: \"SIDE_GEN_OP (\n      (pick m, \n      (OP op_map_pick ::: \\<langle>Rk,Rv\\<rangle>Rm \\<rightarrow> \\<langle>Rk\\<times>\\<^sub>rRv\\<rangle>nres_rel)$m') \\<in>\n      \\<langle>Rk\\<times>\\<^sub>rRv\\<rangle>nres_rel)\"\n    assumes DEL: \"GEN_OP del op_map_delete (Rk \\<rightarrow> \\<langle>Rk,Rv\\<rangle>Rm \\<rightarrow> \\<langle>Rk,Rv\\<rangle>Rm)\"\n    assumes [param]: \"(m,m')\\<in>\\<langle>Rk,Rv\\<rangle>Rm\"\n    shows \"(gen_map_pick_remove pick del m, \n      (OP op_map_pick_remove \n        ::: \\<langle>Rk,Rv\\<rangle>Rm \\<rightarrow> \\<langle>(Rk\\<times>\\<^sub>rRv) \\<times>\\<^sub>r \\<langle>Rk,Rv\\<rangle>Rm\\<rangle>nres_rel)$m')\n      \\<in> \\<langle>(Rk\\<times>\\<^sub>rRv) \\<times>\\<^sub>r \\<langle>Rk,Rv\\<rangle>Rm\\<rangle>nres_rel\""], "translations": [["", "lemma map_to_set_distinct_conv:\n    assumes \"distinct tsl'\" and \"map_to_set m' = set tsl'\"\n    shows \"distinct (map fst tsl')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst tsl')", "apply (rule ccontr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> distinct (map fst tsl') \\<Longrightarrow> False", "apply (drule not_distinct_decomp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs ys zs y.\n       map fst tsl' = xs @ [y] @ ys @ [y] @ zs \\<Longrightarrow>\n    False", "using assms"], ["proof (prove)\nusing this:\n  distinct tsl'\n  map_to_set m' = set tsl'\n\ngoal (1 subgoal):\n 1. \\<exists>xs ys zs y.\n       map fst tsl' = xs @ [y] @ ys @ [y] @ zs \\<Longrightarrow>\n    False", "apply (clarsimp elim!: map_eq_appendE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l a b la ba zsb.\n       \\<lbrakk>map_to_set m' =\n                insert (a, b)\n                 (insert (a, ba)\n                   (set l \\<union> (set la \\<union> set zsb)));\n        tsl' = l @ (a, b) # la @ (a, ba) # zsb; distinct l; b \\<noteq> ba;\n        (a, b) \\<notin> set la; (a, b) \\<notin> set zsb; distinct la;\n        (a, ba) \\<notin> set zsb; distinct zsb; (a, ba) \\<notin> set la;\n        set la \\<inter> set zsb = {}; (a, b) \\<notin> set l;\n        (a, ba) \\<notin> set l;\n        set l \\<inter> (set la \\<union> set zsb) = {}\\<rbrakk>\n       \\<Longrightarrow> False", "by (metis (hide_lams, no_types) insert_iff map_to_set_inj)"], ["", "(* TODO: Make foldli explicit, such that it is seen by \n  iterator-optimizations! cf Gen_Set for how to do this! *)"], ["", "lemma foldli_add: \"det_fold_map X \n    (\\<lambda>_. True) (\\<lambda>(k,v) m. op_map_update k v m) m ((++) m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det_fold_map X (\\<lambda>_. True) (\\<lambda>(k, v). op_map_update k v) m\n     ((++) m)", "proof (rule, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>distinct (map fst l); sorted_wrt (key_rel X) l\\<rbrakk>\n       \\<Longrightarrow> foldli l (\\<lambda>_. True)\n                          (\\<lambda>(k, v). op_map_update k v) m =\n                         m ++ map_of l", "case (1 l)"], ["proof (state)\nthis:\n  distinct (map fst l)\n  sorted_wrt (key_rel X) l\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>distinct (map fst l); sorted_wrt (key_rel X) l\\<rbrakk>\n       \\<Longrightarrow> foldli l (\\<lambda>_. True)\n                          (\\<lambda>(k, v). op_map_update k v) m =\n                         m ++ map_of l", "thus ?case"], ["proof (prove)\nusing this:\n  distinct (map fst l)\n  sorted_wrt (key_rel X) l\n\ngoal (1 subgoal):\n 1. foldli l (\\<lambda>_. True) (\\<lambda>(k, v). op_map_update k v) m =\n    m ++ map_of l", "apply (induct l arbitrary: m)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>distinct (map fst []); sorted_wrt (key_rel X) []\\<rbrakk>\n       \\<Longrightarrow> foldli [] (\\<lambda>_. True)\n                          (\\<lambda>(x, y). op_map_update x y) m =\n                         m ++ map_of []\n 2. \\<And>a l m.\n       \\<lbrakk>\\<And>m.\n                   \\<lbrakk>distinct (map fst l);\n                    sorted_wrt (key_rel X) l\\<rbrakk>\n                   \\<Longrightarrow> foldli l (\\<lambda>_. True)\n(\\<lambda>(x, y). op_map_update x y) m =\n                                     m ++ map_of l;\n        distinct (map fst (a # l)); sorted_wrt (key_rel X) (a # l)\\<rbrakk>\n       \\<Longrightarrow> foldli (a # l) (\\<lambda>_. True)\n                          (\\<lambda>(x, y). op_map_update x y) m =\n                         m ++ map_of (a # l)", "apply (auto simp: map_of_distinct_upd[symmetric])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  foldli l (\\<lambda>_. True) (\\<lambda>(k, v). op_map_update k v) m =\n  m ++ map_of l\n\ngoal:\nNo subgoals!", "qed"], ["", "definition gen_add\n    :: \"('s2 \\<Rightarrow> _) \\<Rightarrow> ('k \\<Rightarrow> 'v \\<Rightarrow> 's1 \\<Rightarrow> 's1) \\<Rightarrow> 's1 \\<Rightarrow> 's2 \\<Rightarrow> 's1\"\n    where \n    \"gen_add it upd A B \\<equiv> it B (\\<lambda>_. True) (\\<lambda>(k,v) m. upd k v m) A\""], ["", "lemma gen_add[autoref_rules_raw]:\n    assumes PRIO_TAG_GEN_ALGO\n    assumes UPD: \"GEN_OP ins op_map_update (Rk\\<rightarrow>Rv\\<rightarrow>\\<langle>Rk,Rv\\<rangle>Rs1\\<rightarrow>\\<langle>Rk,Rv\\<rangle>Rs1)\"\n    assumes IT: \"SIDE_GEN_ALGO (is_map_to_list Rk Rv Rs2 tsl)\"\n    shows \"(gen_add (foldli o tsl) ins,(++)) \n      \\<in> (\\<langle>Rk,Rv\\<rangle>Rs1) \\<rightarrow> (\\<langle>Rk,Rv\\<rangle>Rs2) \\<rightarrow> (\\<langle>Rk,Rv\\<rangle>Rs1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gen_add (foldli \\<circ> tsl) ins, (++))\n    \\<in> \\<langle>Rk, Rv\\<rangle>Rs1 \\<rightarrow>\n          \\<langle>Rk, Rv\\<rangle>Rs2 \\<rightarrow> \\<langle>Rk,\n          Rv\\<rangle>Rs1", "apply (intro fun_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk, Rv\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk, Rv\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (gen_add (foldli \\<circ> tsl) ins a aa, a' ++ a'a)\n                         \\<in> \\<langle>Rk, Rv\\<rangle>Rs1", "unfolding gen_add_def comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk, Rv\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk, Rv\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (foldli (tsl aa) (\\<lambda>_. True)\n                           (\\<lambda>(k, v). ins k v) a,\n                          a' ++ a'a)\n                         \\<in> \\<langle>Rk, Rv\\<rangle>Rs1", "apply (rule det_fold_map[OF foldli_add IT[unfolded autoref_tag_defs]])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk, Rv\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk, Rv\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (aa, a'a) \\<in> \\<langle>Rk, Rv\\<rangle>Rs2\n 2. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk, Rv\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk, Rv\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>_. True, \\<lambda>_. True)\n                         \\<in> \\<langle>Rk, Rv\\<rangle>Rs1 \\<rightarrow>\n                               bool_rel\n 3. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk, Rv\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk, Rv\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>(k, v). ins k v,\n                          \\<lambda>(k, v). op_map_update k v)\n                         \\<in> Rk \\<times>\\<^sub>r Rv \\<rightarrow>\n                               \\<langle>Rk, Rv\\<rangle>Rs1 \\<rightarrow>\n                               \\<langle>Rk, Rv\\<rangle>Rs1\n 4. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk, Rv\\<rangle>Rs1;\n        (aa, a'a) \\<in> \\<langle>Rk, Rv\\<rangle>Rs2\\<rbrakk>\n       \\<Longrightarrow> (a, a') \\<in> \\<langle>Rk, Rv\\<rangle>Rs1", "apply (parametricity add: UPD[unfolded autoref_tag_defs])+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma foldli_restrict: \"det_fold_map X (\\<lambda>_. True) \n    (\\<lambda>(k,v) m. if P (k,v) then op_map_update k v m else m) Map.empty\n      (op_map_restrict P )\" (is \"det_fold_map _ _ ?f _ _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. det_fold_map X (\\<lambda>_. True)\n     (\\<lambda>(k, v) m. if P (k, v) then op_map_update k v m else m)\n     Map.empty (op_map_restrict P)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. det_fold_map X (\\<lambda>_. True)\n     (\\<lambda>(k, v) m. if P (k, v) then op_map_update k v m else m)\n     Map.empty (op_map_restrict P)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. det_fold_map X (\\<lambda>_. True)\n     (\\<lambda>(k, v) m. if P (k, v) then op_map_update k v m else m)\n     Map.empty (op_map_restrict P)", "fix l m"], ["proof (state)\ngoal (1 subgoal):\n 1. det_fold_map X (\\<lambda>_. True)\n     (\\<lambda>(k, v) m. if P (k, v) then op_map_update k v m else m)\n     Map.empty (op_map_restrict P)", "have \"distinct (map fst l) \\<Longrightarrow>\n        foldli l (\\<lambda>_. True) ?f m = m ++ op_map_restrict P (map_of l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst l) \\<Longrightarrow>\n    foldli l (\\<lambda>_. True)\n     (\\<lambda>(k, v) m. if P (k, v) then op_map_update k v m else m) m =\n    m ++ op_map_restrict P (map_of l)", "proof (induction l arbitrary: m)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m.\n       distinct (map fst []) \\<Longrightarrow>\n       foldli [] (\\<lambda>_. True)\n        (\\<lambda>(k, v) m. if P (k, v) then op_map_update k v m else m) m =\n       m ++ op_map_restrict P (map_of [])\n 2. \\<And>a l m.\n       \\<lbrakk>\\<And>m.\n                   distinct (map fst l) \\<Longrightarrow>\n                   foldli l (\\<lambda>_. True)\n                    (\\<lambda>(k, v) m.\n                        if P (k, v) then op_map_update k v m else m)\n                    m =\n                   m ++ op_map_restrict P (map_of l);\n        distinct (map fst (a # l))\\<rbrakk>\n       \\<Longrightarrow> foldli (a # l) (\\<lambda>_. True)\n                          (\\<lambda>(k, v) m.\n                              if P (k, v) then op_map_update k v m else m)\n                          m =\n                         m ++ op_map_restrict P (map_of (a # l))", "case Nil"], ["proof (state)\nthis:\n  distinct (map fst [])\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       distinct (map fst []) \\<Longrightarrow>\n       foldli [] (\\<lambda>_. True)\n        (\\<lambda>(k, v) m. if P (k, v) then op_map_update k v m else m) m =\n       m ++ op_map_restrict P (map_of [])\n 2. \\<And>a l m.\n       \\<lbrakk>\\<And>m.\n                   distinct (map fst l) \\<Longrightarrow>\n                   foldli l (\\<lambda>_. True)\n                    (\\<lambda>(k, v) m.\n                        if P (k, v) then op_map_update k v m else m)\n                    m =\n                   m ++ op_map_restrict P (map_of l);\n        distinct (map fst (a # l))\\<rbrakk>\n       \\<Longrightarrow> foldli (a # l) (\\<lambda>_. True)\n                          (\\<lambda>(k, v) m.\n                              if P (k, v) then op_map_update k v m else m)\n                          m =\n                         m ++ op_map_restrict P (map_of (a # l))", "thus ?case"], ["proof (prove)\nusing this:\n  distinct (map fst [])\n\ngoal (1 subgoal):\n 1. foldli [] (\\<lambda>_. True)\n     (\\<lambda>a.\n         case a of\n         (k, v) \\<Rightarrow>\n           \\<lambda>m. if P (k, v) then op_map_update k v m else m)\n     m =\n    m ++ op_map_restrict P (map_of [])", "by simp"], ["proof (state)\nthis:\n  foldli [] (\\<lambda>_. True)\n   (\\<lambda>a.\n       case a of\n       (k, v) \\<Rightarrow>\n         \\<lambda>m. if P (k, v) then op_map_update k v m else m)\n   m =\n  m ++ op_map_restrict P (map_of [])\n\ngoal (1 subgoal):\n 1. \\<And>a l m.\n       \\<lbrakk>\\<And>m.\n                   distinct (map fst l) \\<Longrightarrow>\n                   foldli l (\\<lambda>_. True)\n                    (\\<lambda>(k, v) m.\n                        if P (k, v) then op_map_update k v m else m)\n                    m =\n                   m ++ op_map_restrict P (map_of l);\n        distinct (map fst (a # l))\\<rbrakk>\n       \\<Longrightarrow> foldli (a # l) (\\<lambda>_. True)\n                          (\\<lambda>(k, v) m.\n                              if P (k, v) then op_map_update k v m else m)\n                          m =\n                         m ++ op_map_restrict P (map_of (a # l))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a l m.\n       \\<lbrakk>\\<And>m.\n                   distinct (map fst l) \\<Longrightarrow>\n                   foldli l (\\<lambda>_. True)\n                    (\\<lambda>(k, v) m.\n                        if P (k, v) then op_map_update k v m else m)\n                    m =\n                   m ++ op_map_restrict P (map_of l);\n        distinct (map fst (a # l))\\<rbrakk>\n       \\<Longrightarrow> foldli (a # l) (\\<lambda>_. True)\n                          (\\<lambda>(k, v) m.\n                              if P (k, v) then op_map_update k v m else m)\n                          m =\n                         m ++ op_map_restrict P (map_of (a # l))", "case (Cons kv l)"], ["proof (state)\nthis:\n  distinct (map fst l) \\<Longrightarrow>\n  foldli l (\\<lambda>_. True)\n   (\\<lambda>a.\n       case a of\n       (k, v) \\<Rightarrow>\n         \\<lambda>m. if P (k, v) then op_map_update k v m else m)\n   ?m =\n  ?m ++ op_map_restrict P (map_of l)\n  distinct (map fst (kv # l))\n\ngoal (1 subgoal):\n 1. \\<And>a l m.\n       \\<lbrakk>\\<And>m.\n                   distinct (map fst l) \\<Longrightarrow>\n                   foldli l (\\<lambda>_. True)\n                    (\\<lambda>(k, v) m.\n                        if P (k, v) then op_map_update k v m else m)\n                    m =\n                   m ++ op_map_restrict P (map_of l);\n        distinct (map fst (a # l))\\<rbrakk>\n       \\<Longrightarrow> foldli (a # l) (\\<lambda>_. True)\n                          (\\<lambda>(k, v) m.\n                              if P (k, v) then op_map_update k v m else m)\n                          m =\n                         m ++ op_map_restrict P (map_of (a # l))", "obtain k v where [simp]: \"kv = (k,v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k v. kv = (k, v) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  kv = (k, v)\n\ngoal (1 subgoal):\n 1. \\<And>a l m.\n       \\<lbrakk>\\<And>m.\n                   distinct (map fst l) \\<Longrightarrow>\n                   foldli l (\\<lambda>_. True)\n                    (\\<lambda>(k, v) m.\n                        if P (k, v) then op_map_update k v m else m)\n                    m =\n                   m ++ op_map_restrict P (map_of l);\n        distinct (map fst (a # l))\\<rbrakk>\n       \\<Longrightarrow> foldli (a # l) (\\<lambda>_. True)\n                          (\\<lambda>(k, v) m.\n                              if P (k, v) then op_map_update k v m else m)\n                          m =\n                         m ++ op_map_restrict P (map_of (a # l))", "from Cons.prems"], ["proof (chain)\npicking this:\n  distinct (map fst (kv # l))", "have \n          DL: \"distinct (map fst l)\" and KNI: \"k \\<notin> set (map fst l)\""], ["proof (prove)\nusing this:\n  distinct (map fst (kv # l))\n\ngoal (1 subgoal):\n 1. distinct (map fst l) &&& k \\<notin> set (map fst l)", "by auto"], ["proof (state)\nthis:\n  distinct (map fst l)\n  k \\<notin> set (map fst l)\n\ngoal (1 subgoal):\n 1. \\<And>a l m.\n       \\<lbrakk>\\<And>m.\n                   distinct (map fst l) \\<Longrightarrow>\n                   foldli l (\\<lambda>_. True)\n                    (\\<lambda>(k, v) m.\n                        if P (k, v) then op_map_update k v m else m)\n                    m =\n                   m ++ op_map_restrict P (map_of l);\n        distinct (map fst (a # l))\\<rbrakk>\n       \\<Longrightarrow> foldli (a # l) (\\<lambda>_. True)\n                          (\\<lambda>(k, v) m.\n                              if P (k, v) then op_map_update k v m else m)\n                          m =\n                         m ++ op_map_restrict P (map_of (a # l))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli (kv # l) (\\<lambda>_. True)\n     (\\<lambda>a.\n         case a of\n         (k, v) \\<Rightarrow>\n           \\<lambda>m. if P (k, v) then op_map_update k v m else m)\n     m =\n    m ++ op_map_restrict P (map_of (kv # l))", "proof (cases \"P (k,v)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. P (k, v) \\<Longrightarrow>\n    foldli (kv # l) (\\<lambda>_. True)\n     (\\<lambda>a.\n         case a of\n         (k, v) \\<Rightarrow>\n           \\<lambda>m. if P (k, v) then op_map_update k v m else m)\n     m =\n    m ++ op_map_restrict P (map_of (kv # l))\n 2. \\<not> P (k, v) \\<Longrightarrow>\n    foldli (kv # l) (\\<lambda>_. True)\n     (\\<lambda>a.\n         case a of\n         (k, v) \\<Rightarrow>\n           \\<lambda>m. if P (k, v) then op_map_update k v m else m)\n     m =\n    m ++ op_map_restrict P (map_of (kv # l))", "case [simp]: True"], ["proof (state)\nthis:\n  P (k, v)\n\ngoal (2 subgoals):\n 1. P (k, v) \\<Longrightarrow>\n    foldli (kv # l) (\\<lambda>_. True)\n     (\\<lambda>a.\n         case a of\n         (k, v) \\<Rightarrow>\n           \\<lambda>m. if P (k, v) then op_map_update k v m else m)\n     m =\n    m ++ op_map_restrict P (map_of (kv # l))\n 2. \\<not> P (k, v) \\<Longrightarrow>\n    foldli (kv # l) (\\<lambda>_. True)\n     (\\<lambda>a.\n         case a of\n         (k, v) \\<Rightarrow>\n           \\<lambda>m. if P (k, v) then op_map_update k v m else m)\n     m =\n    m ++ op_map_restrict P (map_of (kv # l))", "have \"foldli (kv#l) (\\<lambda>_. True) ?f m = foldli l (\\<lambda>_. True) ?f (m(k\\<mapsto>v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli (kv # l) (\\<lambda>_. True)\n     (\\<lambda>(k, v) m. if P (k, v) then op_map_update k v m else m) m =\n    foldli l (\\<lambda>_. True)\n     (\\<lambda>(k, v) m. if P (k, v) then op_map_update k v m else m)\n     (m(k \\<mapsto> v))", "by simp"], ["proof (state)\nthis:\n  foldli (kv # l) (\\<lambda>_. True)\n   (\\<lambda>(k, v) m. if P (k, v) then op_map_update k v m else m) m =\n  foldli l (\\<lambda>_. True)\n   (\\<lambda>(k, v) m. if P (k, v) then op_map_update k v m else m)\n   (m(k \\<mapsto> v))\n\ngoal (2 subgoals):\n 1. P (k, v) \\<Longrightarrow>\n    foldli (kv # l) (\\<lambda>_. True)\n     (\\<lambda>a.\n         case a of\n         (k, v) \\<Rightarrow>\n           \\<lambda>m. if P (k, v) then op_map_update k v m else m)\n     m =\n    m ++ op_map_restrict P (map_of (kv # l))\n 2. \\<not> P (k, v) \\<Longrightarrow>\n    foldli (kv # l) (\\<lambda>_. True)\n     (\\<lambda>a.\n         case a of\n         (k, v) \\<Rightarrow>\n           \\<lambda>m. if P (k, v) then op_map_update k v m else m)\n     m =\n    m ++ op_map_restrict P (map_of (kv # l))", "also"], ["proof (state)\nthis:\n  foldli (kv # l) (\\<lambda>_. True)\n   (\\<lambda>(k, v) m. if P (k, v) then op_map_update k v m else m) m =\n  foldli l (\\<lambda>_. True)\n   (\\<lambda>(k, v) m. if P (k, v) then op_map_update k v m else m)\n   (m(k \\<mapsto> v))\n\ngoal (2 subgoals):\n 1. P (k, v) \\<Longrightarrow>\n    foldli (kv # l) (\\<lambda>_. True)\n     (\\<lambda>a.\n         case a of\n         (k, v) \\<Rightarrow>\n           \\<lambda>m. if P (k, v) then op_map_update k v m else m)\n     m =\n    m ++ op_map_restrict P (map_of (kv # l))\n 2. \\<not> P (k, v) \\<Longrightarrow>\n    foldli (kv # l) (\\<lambda>_. True)\n     (\\<lambda>a.\n         case a of\n         (k, v) \\<Rightarrow>\n           \\<lambda>m. if P (k, v) then op_map_update k v m else m)\n     m =\n    m ++ op_map_restrict P (map_of (kv # l))", "from Cons.IH[OF DL]"], ["proof (chain)\npicking this:\n  foldli l (\\<lambda>_. True)\n   (\\<lambda>a.\n       case a of\n       (k, v) \\<Rightarrow>\n         \\<lambda>m. if P (k, v) then op_map_update k v m else m)\n   ?m =\n  ?m ++ op_map_restrict P (map_of l)", "have \n            \"\\<dots> = m(k\\<mapsto>v) ++ op_map_restrict P (map_of l)\""], ["proof (prove)\nusing this:\n  foldli l (\\<lambda>_. True)\n   (\\<lambda>a.\n       case a of\n       (k, v) \\<Rightarrow>\n         \\<lambda>m. if P (k, v) then op_map_update k v m else m)\n   ?m =\n  ?m ++ op_map_restrict P (map_of l)\n\ngoal (1 subgoal):\n 1. foldli l (\\<lambda>_. True)\n     (\\<lambda>(k, v) m. if P (k, v) then op_map_update k v m else m)\n     (m(k \\<mapsto> v)) =\n    m(k \\<mapsto> v) ++ op_map_restrict P (map_of l)", "."], ["proof (state)\nthis:\n  foldli l (\\<lambda>_. True)\n   (\\<lambda>(k, v) m. if P (k, v) then op_map_update k v m else m)\n   (m(k \\<mapsto> v)) =\n  m(k \\<mapsto> v) ++ op_map_restrict P (map_of l)\n\ngoal (2 subgoals):\n 1. P (k, v) \\<Longrightarrow>\n    foldli (kv # l) (\\<lambda>_. True)\n     (\\<lambda>a.\n         case a of\n         (k, v) \\<Rightarrow>\n           \\<lambda>m. if P (k, v) then op_map_update k v m else m)\n     m =\n    m ++ op_map_restrict P (map_of (kv # l))\n 2. \\<not> P (k, v) \\<Longrightarrow>\n    foldli (kv # l) (\\<lambda>_. True)\n     (\\<lambda>a.\n         case a of\n         (k, v) \\<Rightarrow>\n           \\<lambda>m. if P (k, v) then op_map_update k v m else m)\n     m =\n    m ++ op_map_restrict P (map_of (kv # l))", "also"], ["proof (state)\nthis:\n  foldli l (\\<lambda>_. True)\n   (\\<lambda>(k, v) m. if P (k, v) then op_map_update k v m else m)\n   (m(k \\<mapsto> v)) =\n  m(k \\<mapsto> v) ++ op_map_restrict P (map_of l)\n\ngoal (2 subgoals):\n 1. P (k, v) \\<Longrightarrow>\n    foldli (kv # l) (\\<lambda>_. True)\n     (\\<lambda>a.\n         case a of\n         (k, v) \\<Rightarrow>\n           \\<lambda>m. if P (k, v) then op_map_update k v m else m)\n     m =\n    m ++ op_map_restrict P (map_of (kv # l))\n 2. \\<not> P (k, v) \\<Longrightarrow>\n    foldli (kv # l) (\\<lambda>_. True)\n     (\\<lambda>a.\n         case a of\n         (k, v) \\<Rightarrow>\n           \\<lambda>m. if P (k, v) then op_map_update k v m else m)\n     m =\n    m ++ op_map_restrict P (map_of (kv # l))", "have \"\\<dots> = m ++ op_map_restrict P (map_of (kv#l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m(k \\<mapsto> v) ++ op_map_restrict P (map_of l) =\n    m ++ op_map_restrict P (map_of (kv # l))", "using KNI"], ["proof (prove)\nusing this:\n  k \\<notin> set (map fst l)\n\ngoal (1 subgoal):\n 1. m(k \\<mapsto> v) ++ op_map_restrict P (map_of l) =\n    m ++ op_map_restrict P (map_of (kv # l))", "by (auto\n              split: option.splits\n              intro!: ext \n              simp: Map.restrict_map_def Map.map_add_def\n              simp: map_of_eq_None_iff[symmetric])"], ["proof (state)\nthis:\n  m(k \\<mapsto> v) ++ op_map_restrict P (map_of l) =\n  m ++ op_map_restrict P (map_of (kv # l))\n\ngoal (2 subgoals):\n 1. P (k, v) \\<Longrightarrow>\n    foldli (kv # l) (\\<lambda>_. True)\n     (\\<lambda>a.\n         case a of\n         (k, v) \\<Rightarrow>\n           \\<lambda>m. if P (k, v) then op_map_update k v m else m)\n     m =\n    m ++ op_map_restrict P (map_of (kv # l))\n 2. \\<not> P (k, v) \\<Longrightarrow>\n    foldli (kv # l) (\\<lambda>_. True)\n     (\\<lambda>a.\n         case a of\n         (k, v) \\<Rightarrow>\n           \\<lambda>m. if P (k, v) then op_map_update k v m else m)\n     m =\n    m ++ op_map_restrict P (map_of (kv # l))", "finally"], ["proof (chain)\npicking this:\n  foldli (kv # l) (\\<lambda>_. True)\n   (\\<lambda>(k, v) m. if P (k, v) then op_map_update k v m else m) m =\n  m ++ op_map_restrict P (map_of (kv # l))", "show ?thesis"], ["proof (prove)\nusing this:\n  foldli (kv # l) (\\<lambda>_. True)\n   (\\<lambda>(k, v) m. if P (k, v) then op_map_update k v m else m) m =\n  m ++ op_map_restrict P (map_of (kv # l))\n\ngoal (1 subgoal):\n 1. foldli (kv # l) (\\<lambda>_. True)\n     (\\<lambda>a.\n         case a of\n         (k, v) \\<Rightarrow>\n           \\<lambda>m. if P (k, v) then op_map_update k v m else m)\n     m =\n    m ++ op_map_restrict P (map_of (kv # l))", "."], ["proof (state)\nthis:\n  foldli (kv # l) (\\<lambda>_. True)\n   (\\<lambda>a.\n       case a of\n       (k, v) \\<Rightarrow>\n         \\<lambda>m. if P (k, v) then op_map_update k v m else m)\n   m =\n  m ++ op_map_restrict P (map_of (kv # l))\n\ngoal (1 subgoal):\n 1. \\<not> P (k, v) \\<Longrightarrow>\n    foldli (kv # l) (\\<lambda>_. True)\n     (\\<lambda>a.\n         case a of\n         (k, v) \\<Rightarrow>\n           \\<lambda>m. if P (k, v) then op_map_update k v m else m)\n     m =\n    m ++ op_map_restrict P (map_of (kv # l))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> P (k, v) \\<Longrightarrow>\n    foldli (kv # l) (\\<lambda>_. True)\n     (\\<lambda>a.\n         case a of\n         (k, v) \\<Rightarrow>\n           \\<lambda>m. if P (k, v) then op_map_update k v m else m)\n     m =\n    m ++ op_map_restrict P (map_of (kv # l))", "case [simp]: False"], ["proof (state)\nthis:\n  \\<not> P (k, v)\n\ngoal (1 subgoal):\n 1. \\<not> P (k, v) \\<Longrightarrow>\n    foldli (kv # l) (\\<lambda>_. True)\n     (\\<lambda>a.\n         case a of\n         (k, v) \\<Rightarrow>\n           \\<lambda>m. if P (k, v) then op_map_update k v m else m)\n     m =\n    m ++ op_map_restrict P (map_of (kv # l))", "have \"foldli (kv#l) (\\<lambda>_. True) ?f m = foldli l (\\<lambda>_. True) ?f m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli (kv # l) (\\<lambda>_. True)\n     (\\<lambda>(k, v) m. if P (k, v) then op_map_update k v m else m) m =\n    foldli l (\\<lambda>_. True)\n     (\\<lambda>(k, v) m. if P (k, v) then op_map_update k v m else m) m", "by simp"], ["proof (state)\nthis:\n  foldli (kv # l) (\\<lambda>_. True)\n   (\\<lambda>(k, v) m. if P (k, v) then op_map_update k v m else m) m =\n  foldli l (\\<lambda>_. True)\n   (\\<lambda>(k, v) m. if P (k, v) then op_map_update k v m else m) m\n\ngoal (1 subgoal):\n 1. \\<not> P (k, v) \\<Longrightarrow>\n    foldli (kv # l) (\\<lambda>_. True)\n     (\\<lambda>a.\n         case a of\n         (k, v) \\<Rightarrow>\n           \\<lambda>m. if P (k, v) then op_map_update k v m else m)\n     m =\n    m ++ op_map_restrict P (map_of (kv # l))", "also"], ["proof (state)\nthis:\n  foldli (kv # l) (\\<lambda>_. True)\n   (\\<lambda>(k, v) m. if P (k, v) then op_map_update k v m else m) m =\n  foldli l (\\<lambda>_. True)\n   (\\<lambda>(k, v) m. if P (k, v) then op_map_update k v m else m) m\n\ngoal (1 subgoal):\n 1. \\<not> P (k, v) \\<Longrightarrow>\n    foldli (kv # l) (\\<lambda>_. True)\n     (\\<lambda>a.\n         case a of\n         (k, v) \\<Rightarrow>\n           \\<lambda>m. if P (k, v) then op_map_update k v m else m)\n     m =\n    m ++ op_map_restrict P (map_of (kv # l))", "from Cons.IH[OF DL]"], ["proof (chain)\npicking this:\n  foldli l (\\<lambda>_. True)\n   (\\<lambda>a.\n       case a of\n       (k, v) \\<Rightarrow>\n         \\<lambda>m. if P (k, v) then op_map_update k v m else m)\n   ?m =\n  ?m ++ op_map_restrict P (map_of l)", "have \n            \"\\<dots> = m ++ op_map_restrict P (map_of l)\""], ["proof (prove)\nusing this:\n  foldli l (\\<lambda>_. True)\n   (\\<lambda>a.\n       case a of\n       (k, v) \\<Rightarrow>\n         \\<lambda>m. if P (k, v) then op_map_update k v m else m)\n   ?m =\n  ?m ++ op_map_restrict P (map_of l)\n\ngoal (1 subgoal):\n 1. foldli l (\\<lambda>_. True)\n     (\\<lambda>(k, v) m. if P (k, v) then op_map_update k v m else m) m =\n    m ++ op_map_restrict P (map_of l)", "."], ["proof (state)\nthis:\n  foldli l (\\<lambda>_. True)\n   (\\<lambda>(k, v) m. if P (k, v) then op_map_update k v m else m) m =\n  m ++ op_map_restrict P (map_of l)\n\ngoal (1 subgoal):\n 1. \\<not> P (k, v) \\<Longrightarrow>\n    foldli (kv # l) (\\<lambda>_. True)\n     (\\<lambda>a.\n         case a of\n         (k, v) \\<Rightarrow>\n           \\<lambda>m. if P (k, v) then op_map_update k v m else m)\n     m =\n    m ++ op_map_restrict P (map_of (kv # l))", "also"], ["proof (state)\nthis:\n  foldli l (\\<lambda>_. True)\n   (\\<lambda>(k, v) m. if P (k, v) then op_map_update k v m else m) m =\n  m ++ op_map_restrict P (map_of l)\n\ngoal (1 subgoal):\n 1. \\<not> P (k, v) \\<Longrightarrow>\n    foldli (kv # l) (\\<lambda>_. True)\n     (\\<lambda>a.\n         case a of\n         (k, v) \\<Rightarrow>\n           \\<lambda>m. if P (k, v) then op_map_update k v m else m)\n     m =\n    m ++ op_map_restrict P (map_of (kv # l))", "have \"\\<dots> = m ++ op_map_restrict P (map_of (kv#l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m ++ op_map_restrict P (map_of l) =\n    m ++ op_map_restrict P (map_of (kv # l))", "using KNI"], ["proof (prove)\nusing this:\n  k \\<notin> set (map fst l)\n\ngoal (1 subgoal):\n 1. m ++ op_map_restrict P (map_of l) =\n    m ++ op_map_restrict P (map_of (kv # l))", "by (auto \n              intro!: ext\n              simp: Map.restrict_map_def Map.map_add_def\n              simp: map_of_eq_None_iff[symmetric]\n            )"], ["proof (state)\nthis:\n  m ++ op_map_restrict P (map_of l) =\n  m ++ op_map_restrict P (map_of (kv # l))\n\ngoal (1 subgoal):\n 1. \\<not> P (k, v) \\<Longrightarrow>\n    foldli (kv # l) (\\<lambda>_. True)\n     (\\<lambda>a.\n         case a of\n         (k, v) \\<Rightarrow>\n           \\<lambda>m. if P (k, v) then op_map_update k v m else m)\n     m =\n    m ++ op_map_restrict P (map_of (kv # l))", "finally"], ["proof (chain)\npicking this:\n  foldli (kv # l) (\\<lambda>_. True)\n   (\\<lambda>(k, v) m. if P (k, v) then op_map_update k v m else m) m =\n  m ++ op_map_restrict P (map_of (kv # l))", "show ?thesis"], ["proof (prove)\nusing this:\n  foldli (kv # l) (\\<lambda>_. True)\n   (\\<lambda>(k, v) m. if P (k, v) then op_map_update k v m else m) m =\n  m ++ op_map_restrict P (map_of (kv # l))\n\ngoal (1 subgoal):\n 1. foldli (kv # l) (\\<lambda>_. True)\n     (\\<lambda>a.\n         case a of\n         (k, v) \\<Rightarrow>\n           \\<lambda>m. if P (k, v) then op_map_update k v m else m)\n     m =\n    m ++ op_map_restrict P (map_of (kv # l))", "."], ["proof (state)\nthis:\n  foldli (kv # l) (\\<lambda>_. True)\n   (\\<lambda>a.\n       case a of\n       (k, v) \\<Rightarrow>\n         \\<lambda>m. if P (k, v) then op_map_update k v m else m)\n   m =\n  m ++ op_map_restrict P (map_of (kv # l))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  foldli (kv # l) (\\<lambda>_. True)\n   (\\<lambda>a.\n       case a of\n       (k, v) \\<Rightarrow>\n         \\<lambda>m. if P (k, v) then op_map_update k v m else m)\n   m =\n  m ++ op_map_restrict P (map_of (kv # l))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  distinct (map fst l) \\<Longrightarrow>\n  foldli l (\\<lambda>_. True)\n   (\\<lambda>(k, v) m. if P (k, v) then op_map_update k v m else m) m =\n  m ++ op_map_restrict P (map_of l)\n\ngoal (1 subgoal):\n 1. det_fold_map X (\\<lambda>_. True)\n     (\\<lambda>(k, v) m. if P (k, v) then op_map_update k v m else m)\n     Map.empty (op_map_restrict P)", "}"], ["proof (state)\nthis:\n  distinct (map fst ?l2) \\<Longrightarrow>\n  foldli ?l2 (\\<lambda>_. True)\n   (\\<lambda>(k, v) m. if P (k, v) then op_map_update k v m else m) ?m2 =\n  ?m2 ++ op_map_restrict P (map_of ?l2)\n\ngoal (1 subgoal):\n 1. det_fold_map X (\\<lambda>_. True)\n     (\\<lambda>(k, v) m. if P (k, v) then op_map_update k v m else m)\n     Map.empty (op_map_restrict P)", "from this[of _ Map.empty]"], ["proof (chain)\npicking this:\n  distinct (map fst ?l2) \\<Longrightarrow>\n  foldli ?l2 (\\<lambda>_. True)\n   (\\<lambda>(k, v) m. if P (k, v) then op_map_update k v m else m)\n   Map.empty =\n  Map.empty ++ op_map_restrict P (map_of ?l2)", "show ?thesis"], ["proof (prove)\nusing this:\n  distinct (map fst ?l2) \\<Longrightarrow>\n  foldli ?l2 (\\<lambda>_. True)\n   (\\<lambda>(k, v) m. if P (k, v) then op_map_update k v m else m)\n   Map.empty =\n  Map.empty ++ op_map_restrict P (map_of ?l2)\n\ngoal (1 subgoal):\n 1. det_fold_map X (\\<lambda>_. True)\n     (\\<lambda>(k, v) m. if P (k, v) then op_map_update k v m else m)\n     Map.empty (op_map_restrict P)", "by (auto intro!: det_fold_mapI)"], ["proof (state)\nthis:\n  det_fold_map X (\\<lambda>_. True)\n   (\\<lambda>(k, v) m. if P (k, v) then op_map_update k v m else m)\n   Map.empty (op_map_restrict P)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition gen_restrict :: \"('s1 \\<Rightarrow> _) \\<Rightarrow> _\"\n    where \"gen_restrict it upd emp P m \n    \\<equiv> it m (\\<lambda>_. True) (\\<lambda>(k,v) m. if P (k,v) then upd k v m else m) emp\""], ["", "lemma gen_restrict[autoref_rules_raw]:\n    assumes PRIO_TAG_GEN_ALGO\n    assumes IT: \"SIDE_GEN_ALGO (is_map_to_list Rk Rv Rs1 tsl)\"\n    assumes INS: \n      \"GEN_OP upd op_map_update (Rk\\<rightarrow>Rv\\<rightarrow>\\<langle>Rk,Rv\\<rangle>Rs2\\<rightarrow>\\<langle>Rk,Rv\\<rangle>Rs2)\"\n    assumes EMPTY: \n      \"GEN_OP emp Map.empty (\\<langle>Rk,Rv\\<rangle>Rs2)\"\n    shows \"(gen_restrict (foldli o tsl) upd emp,op_map_restrict) \n    \\<in> (\\<langle>Rk,Rv\\<rangle>prod_rel \\<rightarrow> Id) \\<rightarrow> (\\<langle>Rk,Rv\\<rangle>Rs1) \\<rightarrow> (\\<langle>Rk,Rv\\<rangle>Rs2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gen_restrict (foldli \\<circ> tsl) upd emp, op_map_restrict)\n    \\<in> (Rk \\<times>\\<^sub>r Rv \\<rightarrow> bool_rel) \\<rightarrow>\n          \\<langle>Rk, Rv\\<rangle>Rs1 \\<rightarrow> \\<langle>Rk,\n          Rv\\<rangle>Rs2", "apply (intro fun_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Rk \\<times>\\<^sub>r Rv \\<rightarrow> bool_rel;\n        (aa, a'a) \\<in> \\<langle>Rk, Rv\\<rangle>Rs1\\<rbrakk>\n       \\<Longrightarrow> (gen_restrict (foldli \\<circ> tsl) upd emp a aa,\n                          op_map_restrict a' a'a)\n                         \\<in> \\<langle>Rk, Rv\\<rangle>Rs2", "unfolding gen_restrict_def comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Rk \\<times>\\<^sub>r Rv \\<rightarrow> bool_rel;\n        (aa, a'a) \\<in> \\<langle>Rk, Rv\\<rangle>Rs1\\<rbrakk>\n       \\<Longrightarrow> (foldli (tsl aa) (\\<lambda>_. True)\n                           (\\<lambda>(k, v) m.\n                               if a (k, v) then upd k v m else m)\n                           emp,\n                          op_map_restrict a' a'a)\n                         \\<in> \\<langle>Rk, Rv\\<rangle>Rs2", "apply (rule det_fold_map[OF foldli_restrict IT[unfolded autoref_tag_defs]])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Rk \\<times>\\<^sub>r Rv \\<rightarrow> bool_rel;\n        (aa, a'a) \\<in> \\<langle>Rk, Rv\\<rangle>Rs1\\<rbrakk>\n       \\<Longrightarrow> (aa, a'a) \\<in> \\<langle>Rk, Rv\\<rangle>Rs1\n 2. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Rk \\<times>\\<^sub>r Rv \\<rightarrow> bool_rel;\n        (aa, a'a) \\<in> \\<langle>Rk, Rv\\<rangle>Rs1\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>_. True, \\<lambda>_. True)\n                         \\<in> \\<langle>Rk, Rv\\<rangle>Rs2 \\<rightarrow>\n                               bool_rel\n 3. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Rk \\<times>\\<^sub>r Rv \\<rightarrow> bool_rel;\n        (aa, a'a) \\<in> \\<langle>Rk, Rv\\<rangle>Rs1\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>(k, v) m.\n                             if a (k, v) then upd k v m else m,\n                          \\<lambda>(k, v) m.\n                             if a' (k, v) then op_map_update k v m else m)\n                         \\<in> Rk \\<times>\\<^sub>r Rv \\<rightarrow>\n                               \\<langle>Rk, Rv\\<rangle>Rs2 \\<rightarrow>\n                               \\<langle>Rk, Rv\\<rangle>Rs2\n 4. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Rk \\<times>\\<^sub>r Rv \\<rightarrow> bool_rel;\n        (aa, a'a) \\<in> \\<langle>Rk, Rv\\<rangle>Rs1\\<rbrakk>\n       \\<Longrightarrow> (emp, Map.empty) \\<in> \\<langle>Rk, Rv\\<rangle>Rs2", "using INS EMPTY"], ["proof (prove)\nusing this:\n  GEN_OP upd op_map_update\n   (Rk \\<rightarrow>\n    Rv \\<rightarrow>\n    \\<langle>Rk, Rv\\<rangle>Rs2 \\<rightarrow> \\<langle>Rk, Rv\\<rangle>Rs2)\n  GEN_OP emp Map.empty (\\<langle>Rk, Rv\\<rangle>Rs2)\n\ngoal (4 subgoals):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Rk \\<times>\\<^sub>r Rv \\<rightarrow> bool_rel;\n        (aa, a'a) \\<in> \\<langle>Rk, Rv\\<rangle>Rs1\\<rbrakk>\n       \\<Longrightarrow> (aa, a'a) \\<in> \\<langle>Rk, Rv\\<rangle>Rs1\n 2. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Rk \\<times>\\<^sub>r Rv \\<rightarrow> bool_rel;\n        (aa, a'a) \\<in> \\<langle>Rk, Rv\\<rangle>Rs1\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>_. True, \\<lambda>_. True)\n                         \\<in> \\<langle>Rk, Rv\\<rangle>Rs2 \\<rightarrow>\n                               bool_rel\n 3. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Rk \\<times>\\<^sub>r Rv \\<rightarrow> bool_rel;\n        (aa, a'a) \\<in> \\<langle>Rk, Rv\\<rangle>Rs1\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>(k, v) m.\n                             if a (k, v) then upd k v m else m,\n                          \\<lambda>(k, v) m.\n                             if a' (k, v) then op_map_update k v m else m)\n                         \\<in> Rk \\<times>\\<^sub>r Rv \\<rightarrow>\n                               \\<langle>Rk, Rv\\<rangle>Rs2 \\<rightarrow>\n                               \\<langle>Rk, Rv\\<rangle>Rs2\n 4. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Rk \\<times>\\<^sub>r Rv \\<rightarrow> bool_rel;\n        (aa, a'a) \\<in> \\<langle>Rk, Rv\\<rangle>Rs1\\<rbrakk>\n       \\<Longrightarrow> (emp, Map.empty) \\<in> \\<langle>Rk, Rv\\<rangle>Rs2", "unfolding autoref_tag_defs"], ["proof (prove)\nusing this:\n  (upd, op_map_update)\n  \\<in> Rk \\<rightarrow>\n        Rv \\<rightarrow>\n        \\<langle>Rk, Rv\\<rangle>Rs2 \\<rightarrow> \\<langle>Rk,\n        Rv\\<rangle>Rs2\n  (emp, Map.empty) \\<in> \\<langle>Rk, Rv\\<rangle>Rs2\n\ngoal (4 subgoals):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Rk \\<times>\\<^sub>r Rv \\<rightarrow> bool_rel;\n        (aa, a'a) \\<in> \\<langle>Rk, Rv\\<rangle>Rs1\\<rbrakk>\n       \\<Longrightarrow> (aa, a'a) \\<in> \\<langle>Rk, Rv\\<rangle>Rs1\n 2. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Rk \\<times>\\<^sub>r Rv \\<rightarrow> bool_rel;\n        (aa, a'a) \\<in> \\<langle>Rk, Rv\\<rangle>Rs1\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>_. True, \\<lambda>_. True)\n                         \\<in> \\<langle>Rk, Rv\\<rangle>Rs2 \\<rightarrow>\n                               bool_rel\n 3. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Rk \\<times>\\<^sub>r Rv \\<rightarrow> bool_rel;\n        (aa, a'a) \\<in> \\<langle>Rk, Rv\\<rangle>Rs1\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>(k, v) m.\n                             if a (k, v) then upd k v m else m,\n                          \\<lambda>(k, v) m.\n                             if a' (k, v) then op_map_update k v m else m)\n                         \\<in> Rk \\<times>\\<^sub>r Rv \\<rightarrow>\n                               \\<langle>Rk, Rv\\<rangle>Rs2 \\<rightarrow>\n                               \\<langle>Rk, Rv\\<rangle>Rs2\n 4. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Rk \\<times>\\<^sub>r Rv \\<rightarrow> bool_rel;\n        (aa, a'a) \\<in> \\<langle>Rk, Rv\\<rangle>Rs1\\<rbrakk>\n       \\<Longrightarrow> (emp, Map.empty) \\<in> \\<langle>Rk, Rv\\<rangle>Rs2", "apply (parametricity)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fold_map_of: \n    \"fold (\\<lambda>(k,v) s. op_map_update k v s) (rev l) Map.empty = map_of l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (\\<lambda>(k, v). op_map_update k v) (rev l) Map.empty = map_of l", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fold (\\<lambda>(k, v). op_map_update k v) (rev l) Map.empty = map_of l", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. fold (\\<lambda>(k, v). op_map_update k v) (rev l) Map.empty = map_of l", "fix m"], ["proof (state)\ngoal (1 subgoal):\n 1. fold (\\<lambda>(k, v). op_map_update k v) (rev l) Map.empty = map_of l", "have \"fold (\\<lambda>(k,v) s. s(k\\<mapsto>v)) (rev l) m = m ++ map_of l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (\\<lambda>(k, v) s. s(k \\<mapsto> v)) (rev l) m = m ++ map_of l", "apply (induct l arbitrary: m)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m.\n       fold (\\<lambda>(k, v) s. s(k \\<mapsto> v)) (rev []) m =\n       m ++ map_of []\n 2. \\<And>a l m.\n       (\\<And>m.\n           fold (\\<lambda>(k, v) s. s(k \\<mapsto> v)) (rev l) m =\n           m ++ map_of l) \\<Longrightarrow>\n       fold (\\<lambda>(k, v) s. s(k \\<mapsto> v)) (rev (a # l)) m =\n       m ++ map_of (a # l)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  fold (\\<lambda>(k, v) s. s(k \\<mapsto> v)) (rev l) m = m ++ map_of l\n\ngoal (1 subgoal):\n 1. fold (\\<lambda>(k, v). op_map_update k v) (rev l) Map.empty = map_of l", "}"], ["proof (state)\nthis:\n  fold (\\<lambda>(k, v) s. s(k \\<mapsto> v)) (rev l) ?m2 = ?m2 ++ map_of l\n\ngoal (1 subgoal):\n 1. fold (\\<lambda>(k, v). op_map_update k v) (rev l) Map.empty = map_of l", "thus ?thesis"], ["proof (prove)\nusing this:\n  fold (\\<lambda>(k, v) s. s(k \\<mapsto> v)) (rev l) ?m2 = ?m2 ++ map_of l\n\ngoal (1 subgoal):\n 1. fold (\\<lambda>(k, v). op_map_update k v) (rev l) Map.empty = map_of l", "by simp"], ["proof (state)\nthis:\n  fold (\\<lambda>(k, v). op_map_update k v) (rev l) Map.empty = map_of l\n\ngoal:\nNo subgoals!", "qed"], ["", "definition gen_map_of :: \"'m \\<Rightarrow> ('k\\<Rightarrow>'v\\<Rightarrow>'m\\<Rightarrow>'m) \\<Rightarrow> _\" where \n    \"gen_map_of emp upd l \\<equiv> fold (\\<lambda>(k,v) s. upd k v s) (rev l) emp\""], ["", "lemma gen_map_of[autoref_rules_raw]:\n    assumes PRIO_TAG_GEN_ALGO\n    assumes UPD: \"GEN_OP upd op_map_update (Rk\\<rightarrow>Rv\\<rightarrow>\\<langle>Rk,Rv\\<rangle>Rm\\<rightarrow>\\<langle>Rk,Rv\\<rangle>Rm)\"\n    assumes EMPTY: \"GEN_OP emp Map.empty (\\<langle>Rk,Rv\\<rangle>Rm)\"\n    shows \"(gen_map_of emp upd,map_of) \\<in> \\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel \\<rightarrow> \\<langle>Rk,Rv\\<rangle>Rm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gen_map_of emp upd, map_of)\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel \\<rightarrow>\n          \\<langle>Rk, Rv\\<rangle>Rm", "using assms"], ["proof (prove)\nusing this:\n  PRIO_TAG_GEN_ALGO\n  GEN_OP upd op_map_update\n   (Rk \\<rightarrow>\n    Rv \\<rightarrow>\n    \\<langle>Rk, Rv\\<rangle>Rm \\<rightarrow> \\<langle>Rk, Rv\\<rangle>Rm)\n  GEN_OP emp Map.empty (\\<langle>Rk, Rv\\<rangle>Rm)\n\ngoal (1 subgoal):\n 1. (gen_map_of emp upd, map_of)\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel \\<rightarrow>\n          \\<langle>Rk, Rv\\<rangle>Rm", "apply (intro fun_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>PRIO_TAG_GEN_ALGO;\n        GEN_OP upd op_map_update\n         (Rk \\<rightarrow>\n          Rv \\<rightarrow>\n          \\<langle>Rk, Rv\\<rangle>Rm \\<rightarrow> \\<langle>Rk,\n          Rv\\<rangle>Rm);\n        GEN_OP emp Map.empty (\\<langle>Rk, Rv\\<rangle>Rm);\n        (a, a')\n        \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (gen_map_of emp upd a, map_of a')\n                         \\<in> \\<langle>Rk, Rv\\<rangle>Rm", "unfolding gen_map_of_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>PRIO_TAG_GEN_ALGO;\n        GEN_OP upd op_map_update\n         (Rk \\<rightarrow>\n          Rv \\<rightarrow>\n          \\<langle>Rk, Rv\\<rangle>Rm \\<rightarrow> \\<langle>Rk,\n          Rv\\<rangle>Rm);\n        GEN_OP emp Map.empty (\\<langle>Rk, Rv\\<rangle>Rm);\n        (a, a')\n        \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (fold (\\<lambda>(x, y). upd x y) (rev a) emp,\n                          map_of a')\n                         \\<in> \\<langle>Rk, Rv\\<rangle>Rm", "unfolding autoref_tag_defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>PRIO_TAG_GEN_ALGO;\n        (upd, op_map_update)\n        \\<in> Rk \\<rightarrow>\n              Rv \\<rightarrow>\n              \\<langle>Rk, Rv\\<rangle>Rm \\<rightarrow> \\<langle>Rk,\n              Rv\\<rangle>Rm;\n        (emp, Map.empty) \\<in> \\<langle>Rk, Rv\\<rangle>Rm;\n        (a, a')\n        \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (fold (\\<lambda>(x, y). upd x y) (rev a) emp,\n                          map_of a')\n                         \\<in> \\<langle>Rk, Rv\\<rangle>Rm", "apply (subst fold_map_of[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>PRIO_TAG_GEN_ALGO;\n        (upd, op_map_update)\n        \\<in> Rk \\<rightarrow>\n              Rv \\<rightarrow>\n              \\<langle>Rk, Rv\\<rangle>Rm \\<rightarrow> \\<langle>Rk,\n              Rv\\<rangle>Rm;\n        (emp, Map.empty) \\<in> \\<langle>Rk, Rv\\<rangle>Rm;\n        (a, a')\n        \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (fold (\\<lambda>(x, y). upd x y) (rev a) emp,\n                          fold (\\<lambda>(x, y). op_map_update x y) (rev a')\n                           Map.empty)\n                         \\<in> \\<langle>Rk, Rv\\<rangle>Rm", "apply parametricity"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma foldli_ball_aux: \n    \"distinct (map fst l) \\<Longrightarrow> foldli l (\\<lambda>x. x) (\\<lambda>x _. P x) b \n    \\<longleftrightarrow> b \\<and> op_map_ball (map_of l) P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst l) \\<Longrightarrow>\n    foldli l (\\<lambda>x. x) (\\<lambda>x _. P x) b =\n    (b \\<and> op_map_ball (map_of l) P)", "apply (induct l arbitrary: b)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b.\n       distinct (map fst []) \\<Longrightarrow>\n       foldli [] (\\<lambda>x. x) (\\<lambda>x _. P x) b =\n       (b \\<and> op_map_ball (map_of []) P)\n 2. \\<And>a l b.\n       \\<lbrakk>\\<And>b.\n                   distinct (map fst l) \\<Longrightarrow>\n                   foldli l (\\<lambda>x. x) (\\<lambda>x _. P x) b =\n                   (b \\<and> op_map_ball (map_of l) P);\n        distinct (map fst (a # l))\\<rbrakk>\n       \\<Longrightarrow> foldli (a # l) (\\<lambda>x. x) (\\<lambda>x _. P x)\n                          b =\n                         (b \\<and> op_map_ball (map_of (a # l)) P)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a l b.\n       \\<lbrakk>\\<And>b.\n                   distinct (map fst l) \\<Longrightarrow>\n                   foldli l (\\<lambda>x. x) (\\<lambda>x _. P x) b =\n                   (b \\<and> op_map_ball (map_of l) P);\n        distinct (map fst (a # l))\\<rbrakk>\n       \\<Longrightarrow> foldli (a # l) (\\<lambda>x. x) (\\<lambda>x _. P x)\n                          b =\n                         (b \\<and> op_map_ball (map_of (a # l)) P)", "apply (force simp: map_to_set_map_of image_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma foldli_ball: \n    \"det_fold_map X (\\<lambda>x. x) (\\<lambda>x _. P x) True (\\<lambda>m. op_map_ball m P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det_fold_map X (\\<lambda>x. x) (\\<lambda>x _. P x) True\n     (\\<lambda>m. op_map_ball m P)", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>distinct (map fst l); sorted_wrt (key_rel X) l\\<rbrakk>\n       \\<Longrightarrow> foldli l (\\<lambda>x. x) (\\<lambda>x _. P x) True =\n                         op_map_ball (map_of l) P", "using foldli_ball_aux[where b=True]"], ["proof (prove)\nusing this:\n  distinct (map fst ?l) \\<Longrightarrow>\n  foldli ?l (\\<lambda>x. x) (\\<lambda>x _. ?P x) True =\n  (True \\<and> op_map_ball (map_of ?l) ?P)\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>distinct (map fst l); sorted_wrt (key_rel X) l\\<rbrakk>\n       \\<Longrightarrow> foldli l (\\<lambda>x. x) (\\<lambda>x _. P x) True =\n                         op_map_ball (map_of l) P", "by auto"], ["", "definition gen_ball :: \"('m \\<Rightarrow> _) \\<Rightarrow> _\" where\n    \"gen_ball it m P \\<equiv> it m (\\<lambda>x. x) (\\<lambda>x _. P x) True\""], ["", "lemma gen_ball[autoref_rules_raw]:\n    assumes PRIO_TAG_GEN_ALGO\n    assumes IT: \"SIDE_GEN_ALGO (is_map_to_list Rk Rv Rm tsl)\"\n    shows \"(gen_ball (foldli o tsl),op_map_ball) \n    \\<in> \\<langle>Rk,Rv\\<rangle>Rm \\<rightarrow> (\\<langle>Rk,Rv\\<rangle>prod_rel \\<rightarrow> Id) \\<rightarrow> Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gen_ball (foldli \\<circ> tsl), op_map_ball)\n    \\<in> \\<langle>Rk, Rv\\<rangle>Rm \\<rightarrow>\n          (Rk \\<times>\\<^sub>r Rv \\<rightarrow> bool_rel) \\<rightarrow>\n          bool_rel", "apply (intro fun_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk, Rv\\<rangle>Rm;\n        (aa, a'a)\n        \\<in> Rk \\<times>\\<^sub>r Rv \\<rightarrow> bool_rel\\<rbrakk>\n       \\<Longrightarrow> (gen_ball (foldli \\<circ> tsl) a aa,\n                          op_map_ball a' a'a)\n                         \\<in> bool_rel", "unfolding gen_ball_def comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk, Rv\\<rangle>Rm;\n        (aa, a'a)\n        \\<in> Rk \\<times>\\<^sub>r Rv \\<rightarrow> bool_rel\\<rbrakk>\n       \\<Longrightarrow> (foldli (tsl a) (\\<lambda>x. x)\n                           (\\<lambda>x _. aa x) True,\n                          op_map_ball a' a'a)\n                         \\<in> bool_rel", "apply (rule det_fold_map[OF foldli_ball IT[unfolded autoref_tag_defs]])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk, Rv\\<rangle>Rm;\n        (aa, a'a)\n        \\<in> Rk \\<times>\\<^sub>r Rv \\<rightarrow> bool_rel\\<rbrakk>\n       \\<Longrightarrow> (a, a') \\<in> \\<langle>Rk, Rv\\<rangle>Rm\n 2. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk, Rv\\<rangle>Rm;\n        (aa, a'a)\n        \\<in> Rk \\<times>\\<^sub>r Rv \\<rightarrow> bool_rel\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x. x, \\<lambda>x. x)\n                         \\<in> bool_rel \\<rightarrow> bool_rel\n 3. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk, Rv\\<rangle>Rm;\n        (aa, a'a)\n        \\<in> Rk \\<times>\\<^sub>r Rv \\<rightarrow> bool_rel\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x _. aa x, \\<lambda>x _. a'a x)\n                         \\<in> Rk \\<times>\\<^sub>r Rv \\<rightarrow>\n                               bool_rel \\<rightarrow> bool_rel\n 4. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk, Rv\\<rangle>Rm;\n        (aa, a'a)\n        \\<in> Rk \\<times>\\<^sub>r Rv \\<rightarrow> bool_rel\\<rbrakk>\n       \\<Longrightarrow> (True, True) \\<in> bool_rel", "apply (parametricity)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma foldli_bex_aux: \n    \"distinct (map fst l) \\<Longrightarrow> foldli l (\\<lambda>x. \\<not>x) (\\<lambda>x _. P x) b \n    \\<longleftrightarrow> b \\<or> op_map_bex (map_of l) P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst l) \\<Longrightarrow>\n    foldli l Not (\\<lambda>x _. P x) b = (b \\<or> op_map_bex (map_of l) P)", "apply (induct l arbitrary: b)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b.\n       distinct (map fst []) \\<Longrightarrow>\n       foldli [] Not (\\<lambda>x _. P x) b =\n       (b \\<or> op_map_bex (map_of []) P)\n 2. \\<And>a l b.\n       \\<lbrakk>\\<And>b.\n                   distinct (map fst l) \\<Longrightarrow>\n                   foldli l Not (\\<lambda>x _. P x) b =\n                   (b \\<or> op_map_bex (map_of l) P);\n        distinct (map fst (a # l))\\<rbrakk>\n       \\<Longrightarrow> foldli (a # l) Not (\\<lambda>x _. P x) b =\n                         (b \\<or> op_map_bex (map_of (a # l)) P)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a l b.\n       \\<lbrakk>\\<And>b.\n                   distinct (map fst l) \\<Longrightarrow>\n                   foldli l Not (\\<lambda>x _. P x) b =\n                   (b \\<or> op_map_bex (map_of l) P);\n        distinct (map fst (a # l))\\<rbrakk>\n       \\<Longrightarrow> foldli (a # l) Not (\\<lambda>x _. P x) b =\n                         (b \\<or> op_map_bex (map_of (a # l)) P)", "apply (force simp: map_to_set_map_of image_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma foldli_bex: \n    \"det_fold_map X (\\<lambda>x. \\<not>x) (\\<lambda>x _. P x) False (\\<lambda>m. op_map_bex m P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det_fold_map X Not (\\<lambda>x _. P x) False\n     (\\<lambda>m. op_map_bex m P)", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>distinct (map fst l); sorted_wrt (key_rel X) l\\<rbrakk>\n       \\<Longrightarrow> foldli l Not (\\<lambda>x _. P x) False =\n                         op_map_bex (map_of l) P", "using foldli_bex_aux[where b=False]"], ["proof (prove)\nusing this:\n  distinct (map fst ?l) \\<Longrightarrow>\n  foldli ?l Not (\\<lambda>x _. ?P x) False =\n  (False \\<or> op_map_bex (map_of ?l) ?P)\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>distinct (map fst l); sorted_wrt (key_rel X) l\\<rbrakk>\n       \\<Longrightarrow> foldli l Not (\\<lambda>x _. P x) False =\n                         op_map_bex (map_of l) P", "by auto"], ["", "definition gen_bex :: \"('m \\<Rightarrow> _) \\<Rightarrow> _\" where\n    \"gen_bex it m P \\<equiv> it m (\\<lambda>x. \\<not>x) (\\<lambda>x _. P x) False\""], ["", "lemma gen_bex[autoref_rules_raw]:\n    assumes PRIO_TAG_GEN_ALGO\n    assumes IT: \"SIDE_GEN_ALGO (is_map_to_list Rk Rv Rm tsl)\"\n    shows \"(gen_bex (foldli o tsl),op_map_bex) \n    \\<in> \\<langle>Rk,Rv\\<rangle>Rm \\<rightarrow> (\\<langle>Rk,Rv\\<rangle>prod_rel \\<rightarrow> Id) \\<rightarrow> Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gen_bex (foldli \\<circ> tsl), op_map_bex)\n    \\<in> \\<langle>Rk, Rv\\<rangle>Rm \\<rightarrow>\n          (Rk \\<times>\\<^sub>r Rv \\<rightarrow> bool_rel) \\<rightarrow>\n          bool_rel", "apply (intro fun_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk, Rv\\<rangle>Rm;\n        (aa, a'a)\n        \\<in> Rk \\<times>\\<^sub>r Rv \\<rightarrow> bool_rel\\<rbrakk>\n       \\<Longrightarrow> (gen_bex (foldli \\<circ> tsl) a aa,\n                          op_map_bex a' a'a)\n                         \\<in> bool_rel", "unfolding gen_bex_def comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk, Rv\\<rangle>Rm;\n        (aa, a'a)\n        \\<in> Rk \\<times>\\<^sub>r Rv \\<rightarrow> bool_rel\\<rbrakk>\n       \\<Longrightarrow> (foldli (tsl a) Not (\\<lambda>x _. aa x) False,\n                          op_map_bex a' a'a)\n                         \\<in> bool_rel", "apply (rule det_fold_map[OF foldli_bex IT[unfolded autoref_tag_defs]])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk, Rv\\<rangle>Rm;\n        (aa, a'a)\n        \\<in> Rk \\<times>\\<^sub>r Rv \\<rightarrow> bool_rel\\<rbrakk>\n       \\<Longrightarrow> (a, a') \\<in> \\<langle>Rk, Rv\\<rangle>Rm\n 2. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk, Rv\\<rangle>Rm;\n        (aa, a'a)\n        \\<in> Rk \\<times>\\<^sub>r Rv \\<rightarrow> bool_rel\\<rbrakk>\n       \\<Longrightarrow> (Not, Not) \\<in> bool_rel \\<rightarrow> bool_rel\n 3. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk, Rv\\<rangle>Rm;\n        (aa, a'a)\n        \\<in> Rk \\<times>\\<^sub>r Rv \\<rightarrow> bool_rel\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x _. aa x, \\<lambda>x _. a'a x)\n                         \\<in> Rk \\<times>\\<^sub>r Rv \\<rightarrow>\n                               bool_rel \\<rightarrow> bool_rel\n 4. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk, Rv\\<rangle>Rm;\n        (aa, a'a)\n        \\<in> Rk \\<times>\\<^sub>r Rv \\<rightarrow> bool_rel\\<rbrakk>\n       \\<Longrightarrow> (False, False) \\<in> bool_rel", "apply (parametricity)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ball_isEmpty: \"op_map_isEmpty m = op_map_ball m (\\<lambda>_. False)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op_map_isEmpty m = op_map_ball m (\\<lambda>_. False)", "apply (auto intro!: ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>a b. (a, b) \\<notin> map_to_set m \\<Longrightarrow>\n       m x = None", "by (metis map_to_set_simps(7) option.exhaust)"], ["", "definition \"gen_isEmpty ball m \\<equiv> ball m (\\<lambda>_. False)\""], ["", "lemma gen_isEmpty[autoref_rules_raw]:\n    assumes PRIO_TAG_GEN_ALGO\n    assumes BALL: \n      \"GEN_OP ball op_map_ball (\\<langle>Rk,Rv\\<rangle>Rm\\<rightarrow>(\\<langle>Rk,Rv\\<rangle>prod_rel\\<rightarrow>Id) \\<rightarrow> Id)\"\n    shows \"(gen_isEmpty ball,op_map_isEmpty) \n    \\<in> \\<langle>Rk,Rv\\<rangle>Rm \\<rightarrow> Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gen_isEmpty ball, op_map_isEmpty)\n    \\<in> \\<langle>Rk, Rv\\<rangle>Rm \\<rightarrow> bool_rel", "apply (intro fun_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk, Rv\\<rangle>Rm \\<Longrightarrow>\n       (gen_isEmpty ball a, op_map_isEmpty a') \\<in> bool_rel", "unfolding gen_isEmpty_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk, Rv\\<rangle>Rm \\<Longrightarrow>\n       (ball a (\\<lambda>_. False), op_map_isEmpty a') \\<in> bool_rel", "using assms"], ["proof (prove)\nusing this:\n  PRIO_TAG_GEN_ALGO\n  GEN_OP ball op_map_ball\n   (\\<langle>Rk, Rv\\<rangle>Rm \\<rightarrow>\n    (Rk \\<times>\\<^sub>r Rv \\<rightarrow> bool_rel) \\<rightarrow> bool_rel)\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk, Rv\\<rangle>Rm \\<Longrightarrow>\n       (ball a (\\<lambda>_. False), op_map_isEmpty a') \\<in> bool_rel", "unfolding autoref_tag_defs"], ["proof (prove)\nusing this:\n  PRIO_TAG_GEN_ALGO\n  (ball, op_map_ball)\n  \\<in> \\<langle>Rk, Rv\\<rangle>Rm \\<rightarrow>\n        (Rk \\<times>\\<^sub>r Rv \\<rightarrow> bool_rel) \\<rightarrow>\n        bool_rel\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk, Rv\\<rangle>Rm \\<Longrightarrow>\n       (ball a (\\<lambda>_. False), op_map_isEmpty a') \\<in> bool_rel", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk, Rv\\<rangle>Rm; PRIO_TAG_GEN_ALGO;\n        (ball, op_map_ball)\n        \\<in> \\<langle>Rk, Rv\\<rangle>Rm \\<rightarrow>\n              (Rk \\<times>\\<^sub>r Rv \\<rightarrow> bool_rel) \\<rightarrow>\n              bool_rel\\<rbrakk>\n       \\<Longrightarrow> (ball a (\\<lambda>_. False), op_map_isEmpty a')\n                         \\<in> bool_rel", "apply (subst ball_isEmpty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk, Rv\\<rangle>Rm; PRIO_TAG_GEN_ALGO;\n        (ball, op_map_ball)\n        \\<in> \\<langle>Rk, Rv\\<rangle>Rm \\<rightarrow>\n              (Rk \\<times>\\<^sub>r Rv \\<rightarrow> bool_rel) \\<rightarrow>\n              bool_rel\\<rbrakk>\n       \\<Longrightarrow> (ball a (\\<lambda>_. False),\n                          op_map_ball a' (\\<lambda>_. False))\n                         \\<in> bool_rel", "apply parametricity+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma foldli_size_aux: \"distinct (map fst l) \n    \\<Longrightarrow> foldli l (\\<lambda>_. True) (\\<lambda>_ n. Suc n) n = n + op_map_size (map_of l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst l) \\<Longrightarrow>\n    foldli l (\\<lambda>_. True) (\\<lambda>_. Suc) n =\n    n + op_map_size (map_of l)", "apply (induct l arbitrary: n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       distinct (map fst []) \\<Longrightarrow>\n       foldli [] (\\<lambda>_. True) (\\<lambda>_. Suc) n =\n       n + op_map_size (map_of [])\n 2. \\<And>a l n.\n       \\<lbrakk>\\<And>n.\n                   distinct (map fst l) \\<Longrightarrow>\n                   foldli l (\\<lambda>_. True) (\\<lambda>_. Suc) n =\n                   n + op_map_size (map_of l);\n        distinct (map fst (a # l))\\<rbrakk>\n       \\<Longrightarrow> foldli (a # l) (\\<lambda>_. True) (\\<lambda>_. Suc)\n                          n =\n                         n + op_map_size (map_of (a # l))", "apply (auto simp: dom_map_of_conv_image_fst)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma foldli_size: \"det_fold_map X (\\<lambda>_. True) (\\<lambda>_ n. Suc n) 0 op_map_size\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det_fold_map X (\\<lambda>_. True) (\\<lambda>_. Suc) 0 op_map_size", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>distinct (map fst l); sorted_wrt (key_rel X) l\\<rbrakk>\n       \\<Longrightarrow> foldli l (\\<lambda>_. True) (\\<lambda>_. Suc) 0 =\n                         op_map_size (map_of l)", "using foldli_size_aux[where n=0]"], ["proof (prove)\nusing this:\n  distinct (map fst ?l) \\<Longrightarrow>\n  foldli ?l (\\<lambda>_. True) (\\<lambda>_. Suc) 0 =\n  0 + op_map_size (map_of ?l)\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>distinct (map fst l); sorted_wrt (key_rel X) l\\<rbrakk>\n       \\<Longrightarrow> foldli l (\\<lambda>_. True) (\\<lambda>_. Suc) 0 =\n                         op_map_size (map_of l)", "by simp"], ["", "definition gen_size :: \"('m \\<Rightarrow> _) \\<Rightarrow> _\"\n    where \"gen_size it m \\<equiv> it m (\\<lambda>_. True) (\\<lambda>_ n. Suc n) 0\""], ["", "lemma gen_size[autoref_rules_raw]:\n    assumes PRIO_TAG_GEN_ALGO\n    assumes IT: \"SIDE_GEN_ALGO (is_map_to_list Rk Rv Rm tsl)\"\n    shows \"(gen_size (foldli o tsl),op_map_size) \\<in> \\<langle>Rk,Rv\\<rangle>Rm \\<rightarrow> Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gen_size (foldli \\<circ> tsl), op_map_size)\n    \\<in> \\<langle>Rk, Rv\\<rangle>Rm \\<rightarrow> nat_rel", "apply (intro fun_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk, Rv\\<rangle>Rm \\<Longrightarrow>\n       (gen_size (foldli \\<circ> tsl) a, op_map_size a') \\<in> nat_rel", "unfolding gen_size_def comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk, Rv\\<rangle>Rm \\<Longrightarrow>\n       (foldli (tsl a) (\\<lambda>_. True) (\\<lambda>_. Suc) 0,\n        op_map_size a')\n       \\<in> nat_rel", "apply (rule det_fold_map[OF foldli_size IT[unfolded autoref_tag_defs]])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk, Rv\\<rangle>Rm \\<Longrightarrow>\n       (a, a') \\<in> \\<langle>Rk, Rv\\<rangle>Rm\n 2. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk, Rv\\<rangle>Rm \\<Longrightarrow>\n       (\\<lambda>_. True, \\<lambda>_. True)\n       \\<in> nat_rel \\<rightarrow> bool_rel\n 3. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk, Rv\\<rangle>Rm \\<Longrightarrow>\n       (\\<lambda>_. Suc, \\<lambda>_. Suc)\n       \\<in> Rk \\<times>\\<^sub>r Rv \\<rightarrow>\n             nat_rel \\<rightarrow> nat_rel\n 4. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk, Rv\\<rangle>Rm \\<Longrightarrow>\n       (0, 0) \\<in> nat_rel", "apply (parametricity)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma foldli_size_abort_aux:\n    \"\\<lbrakk>n0\\<le>m; distinct (map fst l)\\<rbrakk> \\<Longrightarrow> \n      foldli l (\\<lambda>n. n<m) (\\<lambda>_ n. Suc n) n0 = min m (n0 + card (dom (map_of l)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n0 \\<le> m; distinct (map fst l)\\<rbrakk>\n    \\<Longrightarrow> foldli l (\\<lambda>n. n < m) (\\<lambda>_. Suc) n0 =\n                      min m (n0 + card (dom (map_of l)))", "apply (induct l arbitrary: n0)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n0.\n       \\<lbrakk>n0 \\<le> m; distinct (map fst [])\\<rbrakk>\n       \\<Longrightarrow> foldli [] (\\<lambda>n. n < m) (\\<lambda>_. Suc)\n                          n0 =\n                         min m (n0 + card (dom (map_of [])))\n 2. \\<And>a l n0.\n       \\<lbrakk>\\<And>n0.\n                   \\<lbrakk>n0 \\<le> m; distinct (map fst l)\\<rbrakk>\n                   \\<Longrightarrow> foldli l (\\<lambda>n. n < m)\n(\\<lambda>_. Suc) n0 =\n                                     min m (n0 + card (dom (map_of l)));\n        n0 \\<le> m; distinct (map fst (a # l))\\<rbrakk>\n       \\<Longrightarrow> foldli (a # l) (\\<lambda>n. n < m)\n                          (\\<lambda>_. Suc) n0 =\n                         min m (n0 + card (dom (map_of (a # l))))", "apply (auto simp: dom_map_of_conv_image_fst)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma foldli_size_abort: \n    \"det_fold_map X (\\<lambda>n. n<m) (\\<lambda>_ n. Suc n) 0 (op_map_size_abort m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det_fold_map X (\\<lambda>n. n < m) (\\<lambda>_. Suc) 0\n     (op_map_size_abort m)", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>distinct (map fst l); sorted_wrt (key_rel X) l\\<rbrakk>\n       \\<Longrightarrow> foldli l (\\<lambda>n. n < m) (\\<lambda>_. Suc) 0 =\n                         op_map_size_abort m (map_of l)", "using foldli_size_abort_aux[where ?n0.0=0]"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> ?m; distinct (map fst ?l)\\<rbrakk>\n  \\<Longrightarrow> foldli ?l (\\<lambda>n. n < ?m) (\\<lambda>_. Suc) 0 =\n                    min ?m (0 + card (dom (map_of ?l)))\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>distinct (map fst l); sorted_wrt (key_rel X) l\\<rbrakk>\n       \\<Longrightarrow> foldli l (\\<lambda>n. n < m) (\\<lambda>_. Suc) 0 =\n                         op_map_size_abort m (map_of l)", "by simp"], ["", "definition gen_size_abort :: \"('s \\<Rightarrow> _) \\<Rightarrow> _\" where\n    \"gen_size_abort it m s \\<equiv> it s (\\<lambda>n. n<m) (\\<lambda>_ n. Suc n) 0\""], ["", "lemma gen_size_abort[autoref_rules_raw]:\n    assumes PRIO_TAG_GEN_ALGO\n    assumes IT: \"SIDE_GEN_ALGO (is_map_to_list Rk Rv Rm tsl)\"\n    shows \"(gen_size_abort (foldli o tsl),op_map_size_abort) \n      \\<in> Id \\<rightarrow> \\<langle>Rk,Rv\\<rangle>Rm \\<rightarrow> Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gen_size_abort (foldli \\<circ> tsl), op_map_size_abort)\n    \\<in> nat_rel \\<rightarrow>\n          \\<langle>Rk, Rv\\<rangle>Rm \\<rightarrow> nat_rel", "apply (intro fun_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> nat_rel;\n        (aa, a'a) \\<in> \\<langle>Rk, Rv\\<rangle>Rm\\<rbrakk>\n       \\<Longrightarrow> (gen_size_abort (foldli \\<circ> tsl) a aa,\n                          op_map_size_abort a' a'a)\n                         \\<in> nat_rel", "unfolding gen_size_abort_def comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> nat_rel;\n        (aa, a'a) \\<in> \\<langle>Rk, Rv\\<rangle>Rm\\<rbrakk>\n       \\<Longrightarrow> (foldli (tsl aa) (\\<lambda>n. n < a)\n                           (\\<lambda>_. Suc) 0,\n                          op_map_size_abort a' a'a)\n                         \\<in> nat_rel", "apply (rule det_fold_map[OF foldli_size_abort \n      IT[unfolded autoref_tag_defs]])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> nat_rel;\n        (aa, a'a) \\<in> \\<langle>Rk, Rv\\<rangle>Rm\\<rbrakk>\n       \\<Longrightarrow> (aa, a'a) \\<in> \\<langle>Rk, Rv\\<rangle>Rm\n 2. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> nat_rel;\n        (aa, a'a) \\<in> \\<langle>Rk, Rv\\<rangle>Rm\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>n. n < a, \\<lambda>n. n < a')\n                         \\<in> nat_rel \\<rightarrow> bool_rel\n 3. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> nat_rel;\n        (aa, a'a) \\<in> \\<langle>Rk, Rv\\<rangle>Rm\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>_. Suc, \\<lambda>_. Suc)\n                         \\<in> Rk \\<times>\\<^sub>r Rv \\<rightarrow>\n                               nat_rel \\<rightarrow> nat_rel\n 4. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> nat_rel;\n        (aa, a'a) \\<in> \\<langle>Rk, Rv\\<rangle>Rm\\<rbrakk>\n       \\<Longrightarrow> (0, 0) \\<in> nat_rel", "apply (parametricity)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma size_abort_isSng: \"op_map_isSng s \\<longleftrightarrow> op_map_size_abort 2 s = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op_map_isSng s = (op_map_size_abort 2 s = 1)", "by (auto simp: dom_eq_singleton_conv min_def dest!: card_eq_SucD)"], ["", "definition gen_isSng :: \"(nat \\<Rightarrow> 's \\<Rightarrow> nat) \\<Rightarrow> _\" where\n    \"gen_isSng sizea s \\<equiv> sizea 2 s = 1\""], ["", "lemma gen_isSng[autoref_rules_raw]:\n    assumes PRIO_TAG_GEN_ALGO\n    assumes \"GEN_OP sizea op_map_size_abort (Id \\<rightarrow> (\\<langle>Rk,Rv\\<rangle>Rm) \\<rightarrow> Id)\"\n    shows \"(gen_isSng sizea,op_map_isSng) \n    \\<in> \\<langle>Rk,Rv\\<rangle>Rm \\<rightarrow> Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gen_isSng sizea, op_map_isSng)\n    \\<in> \\<langle>Rk, Rv\\<rangle>Rm \\<rightarrow> bool_rel", "apply (intro fun_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk, Rv\\<rangle>Rm \\<Longrightarrow>\n       (gen_isSng sizea a, op_map_isSng a') \\<in> bool_rel", "unfolding gen_isSng_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk, Rv\\<rangle>Rm \\<Longrightarrow>\n       (sizea 2 a = 1, op_map_isSng a') \\<in> bool_rel", "using assms"], ["proof (prove)\nusing this:\n  PRIO_TAG_GEN_ALGO\n  GEN_OP sizea op_map_size_abort\n   (nat_rel \\<rightarrow> \\<langle>Rk, Rv\\<rangle>Rm \\<rightarrow> nat_rel)\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk, Rv\\<rangle>Rm \\<Longrightarrow>\n       (sizea 2 a = 1, op_map_isSng a') \\<in> bool_rel", "unfolding autoref_tag_defs"], ["proof (prove)\nusing this:\n  PRIO_TAG_GEN_ALGO\n  (sizea, op_map_size_abort)\n  \\<in> nat_rel \\<rightarrow>\n        \\<langle>Rk, Rv\\<rangle>Rm \\<rightarrow> nat_rel\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk, Rv\\<rangle>Rm \\<Longrightarrow>\n       (sizea 2 a = 1, op_map_isSng a') \\<in> bool_rel", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk, Rv\\<rangle>Rm; PRIO_TAG_GEN_ALGO;\n        (sizea, op_map_size_abort)\n        \\<in> nat_rel \\<rightarrow>\n              \\<langle>Rk, Rv\\<rangle>Rm \\<rightarrow> nat_rel\\<rbrakk>\n       \\<Longrightarrow> (sizea 2 a = 1, op_map_isSng a') \\<in> bool_rel", "apply (subst size_abort_isSng)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Rk, Rv\\<rangle>Rm; PRIO_TAG_GEN_ALGO;\n        (sizea, op_map_size_abort)\n        \\<in> nat_rel \\<rightarrow>\n              \\<langle>Rk, Rv\\<rangle>Rm \\<rightarrow> nat_rel\\<rbrakk>\n       \\<Longrightarrow> (sizea 2 a = 1, op_map_size_abort 2 a' = 1)\n                         \\<in> bool_rel", "apply parametricity"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(* TODO: Also do sel! *)"], ["", "lemma foldli_pick:\n    assumes \"l\\<noteq>[]\" \n    obtains k v where \"(k,v)\\<in>set l\" \n    and \"(foldli l (case_option True (\\<lambda>_. False)) (\\<lambda>x _. Some x) None) \n      = Some (k,v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k v.\n        \\<lbrakk>(k, v) \\<in> set l;\n         foldli l (case_option True (\\<lambda>_. False))\n          (\\<lambda>x _. Some x) None =\n         Some (k, v)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  l \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>k v.\n        \\<lbrakk>(k, v) \\<in> set l;\n         foldli l (case_option True (\\<lambda>_. False))\n          (\\<lambda>x _. Some x) None =\n         Some (k, v)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases l) auto"], ["", "definition gen_pick where\n    \"gen_pick it s \\<equiv> \n      (the (it s (case_option True (\\<lambda>_. False)) (\\<lambda>x _. Some x) None))\""], ["", "context begin"], ["", "interpretation autoref_syn"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma gen_pick[autoref_rules_raw]:\n    assumes PRIO_TAG_GEN_ALGO\n    assumes IT: \"SIDE_GEN_ALGO (is_map_to_list Rk Rv Rm it)\"\n    assumes NE: \"SIDE_PRECOND (m'\\<noteq>Map.empty)\"\n    assumes SREF: \"(m,m')\\<in>\\<langle>Rk,Rv\\<rangle>Rm\"\n    shows \"(RETURN (gen_pick (\\<lambda>x. foldli (it x)) m), \n      (OP op_map_pick ::: \\<langle>Rk,Rv\\<rangle>Rm\\<rightarrow>\\<langle>Rk\\<times>\\<^sub>rRv\\<rangle>nres_rel)$m')\\<in>\\<langle>Rk\\<times>\\<^sub>rRv\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN (gen_pick (\\<lambda>x. foldli (it x)) m),\n     (OP op_map_pick :::\n      \\<langle>Rk, Rv\\<rangle>Rm \\<rightarrow>\n      \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>nres_rel) $\n     m')\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>nres_rel", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (RETURN (gen_pick (\\<lambda>x. foldli (it x)) m),\n     (OP op_map_pick :::\n      \\<langle>Rk, Rv\\<rangle>Rm \\<rightarrow>\n      \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>nres_rel) $\n     m')\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>nres_rel", "thm is_map_to_list_def is_map_to_sorted_listE"], ["proof (state)\ngoal (1 subgoal):\n 1. (RETURN (gen_pick (\\<lambda>x. foldli (it x)) m),\n     (OP op_map_pick :::\n      \\<langle>Rk, Rv\\<rangle>Rm \\<rightarrow>\n      \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>nres_rel) $\n     m')\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>nres_rel", "obtain tsl' where\n      [param]: \"(it m,tsl') \\<in> \\<langle>Rk\\<times>\\<^sub>rRv\\<rangle>list_rel\" \n      and IT': \"RETURN tsl' \\<le> it_to_sorted_list (\\<lambda>_ _. True) (map_to_set m')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>tsl'.\n        \\<lbrakk>(it m, tsl')\n                 \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel;\n         RETURN tsl'\n         \\<le> it_to_sorted_list (\\<lambda>_ _. True)\n                (map_to_set m')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using IT[unfolded autoref_tag_defs is_map_to_list_def] SREF"], ["proof (prove)\nusing this:\n  is_map_to_sorted_list (\\<lambda>_ _. True) Rk Rv Rm it\n  (m, m') \\<in> \\<langle>Rk, Rv\\<rangle>Rm\n\ngoal (1 subgoal):\n 1. (\\<And>tsl'.\n        \\<lbrakk>(it m, tsl')\n                 \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel;\n         RETURN tsl'\n         \\<le> it_to_sorted_list (\\<lambda>_ _. True)\n                (map_to_set m')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto intro: is_map_to_sorted_listE)"], ["proof (state)\nthis:\n  (it m, tsl') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n  RETURN tsl' \\<le> it_to_sorted_list (\\<lambda>_ _. True) (map_to_set m')\n\ngoal (1 subgoal):\n 1. (RETURN (gen_pick (\\<lambda>x. foldli (it x)) m),\n     (OP op_map_pick :::\n      \\<langle>Rk, Rv\\<rangle>Rm \\<rightarrow>\n      \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>nres_rel) $\n     m')\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>nres_rel", "from IT' NE"], ["proof (chain)\npicking this:\n  RETURN tsl' \\<le> it_to_sorted_list (\\<lambda>_ _. True) (map_to_set m')\n  SIDE_PRECOND (m' \\<noteq> Map.empty)", "have \"tsl'\\<noteq>[]\" and [simp]: \"m'=map_of tsl'\" \n      and DIS': \"distinct (map fst tsl')\""], ["proof (prove)\nusing this:\n  RETURN tsl' \\<le> it_to_sorted_list (\\<lambda>_ _. True) (map_to_set m')\n  SIDE_PRECOND (m' \\<noteq> Map.empty)\n\ngoal (1 subgoal):\n 1. tsl' \\<noteq> [] &&& m' = map_of tsl' &&& distinct (map fst tsl')", "unfolding it_to_sorted_list_def"], ["proof (prove)\nusing this:\n  RETURN tsl'\n  \\<le> SPEC\n         (\\<lambda>l.\n             distinct l \\<and>\n             map_to_set m' = set l \\<and> sorted_wrt (\\<lambda>_ _. True) l)\n  SIDE_PRECOND (m' \\<noteq> Map.empty)\n\ngoal (1 subgoal):\n 1. tsl' \\<noteq> [] &&& m' = map_of tsl' &&& distinct (map fst tsl')", "apply simp_all"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>distinct tsl' \\<and> map_to_set m' = set tsl';\n     m' \\<noteq> Map.empty\\<rbrakk>\n    \\<Longrightarrow> tsl' \\<noteq> []\n 2. \\<lbrakk>distinct tsl' \\<and> map_to_set m' = set tsl';\n     m' \\<noteq> Map.empty\\<rbrakk>\n    \\<Longrightarrow> m' = map_of tsl'\n 3. \\<lbrakk>distinct tsl' \\<and> map_to_set m' = set tsl';\n     m' \\<noteq> Map.empty\\<rbrakk>\n    \\<Longrightarrow> distinct (map fst tsl')", "apply (metis empty_set map_to_set_empty_iff(1))"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct tsl' \\<and> map_to_set m' = set tsl';\n     m' \\<noteq> Map.empty\\<rbrakk>\n    \\<Longrightarrow> m' = map_of tsl'\n 2. \\<lbrakk>distinct tsl' \\<and> map_to_set m' = set tsl';\n     m' \\<noteq> Map.empty\\<rbrakk>\n    \\<Longrightarrow> distinct (map fst tsl')", "apply (metis map_of_map_to_set map_to_set_distinct_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct tsl' \\<and> map_to_set m' = set tsl';\n     m' \\<noteq> Map.empty\\<rbrakk>\n    \\<Longrightarrow> distinct (map fst tsl')", "apply (metis map_to_set_distinct_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  tsl' \\<noteq> []\n  m' = map_of tsl'\n  distinct (map fst tsl')\n\ngoal (1 subgoal):\n 1. (RETURN (gen_pick (\\<lambda>x. foldli (it x)) m),\n     (OP op_map_pick :::\n      \\<langle>Rk, Rv\\<rangle>Rm \\<rightarrow>\n      \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>nres_rel) $\n     m')\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>nres_rel", "then"], ["proof (chain)\npicking this:\n  tsl' \\<noteq> []\n  m' = map_of tsl'\n  distinct (map fst tsl')", "obtain k v where \"m' k = Some v\" and\n      \"(foldli tsl' (case_option True (\\<lambda>_. False)) (\\<lambda>x _. Some x) None) \n        = Some (k,v)\"\n      (is \"?fld = _\")"], ["proof (prove)\nusing this:\n  tsl' \\<noteq> []\n  m' = map_of tsl'\n  distinct (map fst tsl')\n\ngoal (1 subgoal):\n 1. (\\<And>k v.\n        \\<lbrakk>m' k = Some v;\n         foldli tsl' (case_option True (\\<lambda>_. False))\n          (\\<lambda>x _. Some x) None =\n         Some (k, v)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases rule: foldli_pick) auto"], ["proof (state)\nthis:\n  m' k = Some v\n  foldli tsl' (case_option True (\\<lambda>_. False)) (\\<lambda>x _. Some x)\n   None =\n  Some (k, v)\n\ngoal (1 subgoal):\n 1. (RETURN (gen_pick (\\<lambda>x. foldli (it x)) m),\n     (OP op_map_pick :::\n      \\<langle>Rk, Rv\\<rangle>Rm \\<rightarrow>\n      \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>nres_rel) $\n     m')\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>nres_rel", "moreover"], ["proof (state)\nthis:\n  m' k = Some v\n  foldli tsl' (case_option True (\\<lambda>_. False)) (\\<lambda>x _. Some x)\n   None =\n  Some (k, v)\n\ngoal (1 subgoal):\n 1. (RETURN (gen_pick (\\<lambda>x. foldli (it x)) m),\n     (OP op_map_pick :::\n      \\<langle>Rk, Rv\\<rangle>Rm \\<rightarrow>\n      \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>nres_rel) $\n     m')\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>nres_rel", "have \"(RETURN (gen_pick (\\<lambda>x. foldli (it x)) m), RETURN (the ?fld)) \n      \\<in> \\<langle>Rk\\<times>\\<^sub>rRv\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN (gen_pick (\\<lambda>x. foldli (it x)) m),\n     RETURN\n      (the (foldli tsl' (case_option True (\\<lambda>_. False))\n             (\\<lambda>x _. Some x) None)))\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>nres_rel", "unfolding gen_pick_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN\n      (the (foldli (it m) (case_option True (\\<lambda>_. False))\n             (\\<lambda>x _. Some x) None)),\n     RETURN\n      (the (foldli tsl' (case_option True (\\<lambda>_. False))\n             (\\<lambda>x _. Some x) None)))\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>nres_rel", "apply (parametricity add: the_paramR)"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli tsl' (case_option True (\\<lambda>_. False))\n     (\\<lambda>x _. Some x) None \\<noteq>\n    None", "using \\<open>?fld = Some (k,v)\\<close>"], ["proof (prove)\nusing this:\n  foldli tsl' (case_option True (\\<lambda>_. False)) (\\<lambda>x _. Some x)\n   None =\n  Some (k, v)\n\ngoal (1 subgoal):\n 1. foldli tsl' (case_option True (\\<lambda>_. False))\n     (\\<lambda>x _. Some x) None \\<noteq>\n    None", "by simp"], ["proof (state)\nthis:\n  (RETURN (gen_pick (\\<lambda>x. foldli (it x)) m),\n   RETURN\n    (the (foldli tsl' (case_option True (\\<lambda>_. False))\n           (\\<lambda>x _. Some x) None)))\n  \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>nres_rel\n\ngoal (1 subgoal):\n 1. (RETURN (gen_pick (\\<lambda>x. foldli (it x)) m),\n     (OP op_map_pick :::\n      \\<langle>Rk, Rv\\<rangle>Rm \\<rightarrow>\n      \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>nres_rel) $\n     m')\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>nres_rel", "ultimately"], ["proof (chain)\npicking this:\n  m' k = Some v\n  foldli tsl' (case_option True (\\<lambda>_. False)) (\\<lambda>x _. Some x)\n   None =\n  Some (k, v)\n  (RETURN (gen_pick (\\<lambda>x. foldli (it x)) m),\n   RETURN\n    (the (foldli tsl' (case_option True (\\<lambda>_. False))\n           (\\<lambda>x _. Some x) None)))\n  \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>nres_rel", "show ?thesis"], ["proof (prove)\nusing this:\n  m' k = Some v\n  foldli tsl' (case_option True (\\<lambda>_. False)) (\\<lambda>x _. Some x)\n   None =\n  Some (k, v)\n  (RETURN (gen_pick (\\<lambda>x. foldli (it x)) m),\n   RETURN\n    (the (foldli tsl' (case_option True (\\<lambda>_. False))\n           (\\<lambda>x _. Some x) None)))\n  \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>nres_rel\n\ngoal (1 subgoal):\n 1. (RETURN (gen_pick (\\<lambda>x. foldli (it x)) m),\n     (OP op_map_pick :::\n      \\<langle>Rk, Rv\\<rangle>Rm \\<rightarrow>\n      \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>nres_rel) $\n     m')\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>nres_rel", "unfolding autoref_tag_defs"], ["proof (prove)\nusing this:\n  m' k = Some v\n  foldli tsl' (case_option True (\\<lambda>_. False)) (\\<lambda>x _. Some x)\n   None =\n  Some (k, v)\n  (RETURN (gen_pick (\\<lambda>x. foldli (it x)) m),\n   RETURN\n    (the (foldli tsl' (case_option True (\\<lambda>_. False))\n           (\\<lambda>x _. Some x) None)))\n  \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>nres_rel\n\ngoal (1 subgoal):\n 1. (RETURN (gen_pick (\\<lambda>x. foldli (it x)) m), op_map_pick m')\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>nres_rel", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m' k = Some v;\n     foldli tsl' (case_option True (\\<lambda>_. False))\n      (\\<lambda>x _. Some x) None =\n     Some (k, v);\n     (RETURN (gen_pick (\\<lambda>x. foldli (it x)) m),\n      RETURN\n       (the (foldli tsl' (case_option True (\\<lambda>_. False))\n              (\\<lambda>x _. Some x) None)))\n     \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>nres_rel\\<rbrakk>\n    \\<Longrightarrow> (RETURN (gen_pick (\\<lambda>x. foldli (it x)) m),\n                       op_map_pick m')\n                      \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>nres_rel", "apply (drule nres_relD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m' k = Some v;\n     foldli tsl' (case_option True (\\<lambda>_. False))\n      (\\<lambda>x _. Some x) None =\n     Some (k, v);\n     RETURN (gen_pick (\\<lambda>x. foldli (it x)) m)\n     \\<le> \\<Down> (Rk \\<times>\\<^sub>r Rv)\n            (RETURN\n              (the (foldli tsl' (case_option True (\\<lambda>_. False))\n                     (\\<lambda>x _. Some x) None)))\\<rbrakk>\n    \\<Longrightarrow> (RETURN (gen_pick (\\<lambda>x. foldli (it x)) m),\n                       op_map_pick m')\n                      \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>nres_rel", "apply (rule nres_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m' k = Some v;\n     foldli tsl' (case_option True (\\<lambda>_. False))\n      (\\<lambda>x _. Some x) None =\n     Some (k, v);\n     RETURN (gen_pick (\\<lambda>x. foldli (it x)) m)\n     \\<le> \\<Down> (Rk \\<times>\\<^sub>r Rv)\n            (RETURN\n              (the (foldli tsl' (case_option True (\\<lambda>_. False))\n                     (\\<lambda>x _. Some x) None)))\\<rbrakk>\n    \\<Longrightarrow> RETURN (gen_pick (\\<lambda>x. foldli (it x)) m)\n                      \\<le> \\<Down> (Rk \\<times>\\<^sub>r Rv)\n                             (op_map_pick m')", "apply (erule ref_two_step)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m' k = Some v;\n     foldli tsl' (case_option True (\\<lambda>_. False))\n      (\\<lambda>x _. Some x) None =\n     Some (k, v)\\<rbrakk>\n    \\<Longrightarrow> RETURN\n                       (the (foldli tsl'\n                              (case_option True (\\<lambda>_. False))\n                              (\\<lambda>x _. Some x) None))\n                      \\<le> op_map_pick m'", "by simp"], ["proof (state)\nthis:\n  (RETURN (gen_pick (\\<lambda>x. foldli (it x)) m),\n   (OP op_map_pick :::\n    \\<langle>Rk, Rv\\<rangle>Rm \\<rightarrow>\n    \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>nres_rel) $\n   m')\n  \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>nres_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "definition \"gen_map_pick_remove pick del m \\<equiv> do {\n    (k,v)\\<leftarrow>pick m;\n    let m = del k m;\n    RETURN ((k,v),m)\n    }\""], ["", "context begin"], ["", "interpretation autoref_syn"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma gen_map_pick_remove\n    [unfolded gen_map_pick_remove_def, autoref_rules_raw]:\n    assumes PRIO_TAG_GEN_ALGO\n    assumes PICK: \"SIDE_GEN_OP (\n      (pick m, \n      (OP op_map_pick ::: \\<langle>Rk,Rv\\<rangle>Rm \\<rightarrow> \\<langle>Rk\\<times>\\<^sub>rRv\\<rangle>nres_rel)$m') \\<in>\n      \\<langle>Rk\\<times>\\<^sub>rRv\\<rangle>nres_rel)\"\n    assumes DEL: \"GEN_OP del op_map_delete (Rk \\<rightarrow> \\<langle>Rk,Rv\\<rangle>Rm \\<rightarrow> \\<langle>Rk,Rv\\<rangle>Rm)\"\n    assumes [param]: \"(m,m')\\<in>\\<langle>Rk,Rv\\<rangle>Rm\"\n    shows \"(gen_map_pick_remove pick del m, \n      (OP op_map_pick_remove \n        ::: \\<langle>Rk,Rv\\<rangle>Rm \\<rightarrow> \\<langle>(Rk\\<times>\\<^sub>rRv) \\<times>\\<^sub>r \\<langle>Rk,Rv\\<rangle>Rm\\<rangle>nres_rel)$m')\n      \\<in> \\<langle>(Rk\\<times>\\<^sub>rRv) \\<times>\\<^sub>r \\<langle>Rk,Rv\\<rangle>Rm\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (gen_map_pick_remove pick del m,\n     (OP op_map_pick_remove :::\n      \\<langle>Rk, Rv\\<rangle>Rm \\<rightarrow>\n      \\<langle>(Rk \\<times>\\<^sub>r Rv) \\<times>\\<^sub>r \\<langle>Rk,\n               Rv\\<rangle>Rm\\<rangle>nres_rel) $\n     m')\n    \\<in> \\<langle>(Rk \\<times>\\<^sub>r Rv) \\<times>\\<^sub>r \\<langle>Rk,\n                   Rv\\<rangle>Rm\\<rangle>nres_rel", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (gen_map_pick_remove pick del m,\n     (OP op_map_pick_remove :::\n      \\<langle>Rk, Rv\\<rangle>Rm \\<rightarrow>\n      \\<langle>(Rk \\<times>\\<^sub>r Rv) \\<times>\\<^sub>r \\<langle>Rk,\n               Rv\\<rangle>Rm\\<rangle>nres_rel) $\n     m')\n    \\<in> \\<langle>(Rk \\<times>\\<^sub>r Rv) \\<times>\\<^sub>r \\<langle>Rk,\n                   Rv\\<rangle>Rm\\<rangle>nres_rel", "note [param] = \n      PICK[unfolded autoref_tag_defs] \n      DEL[unfolded autoref_tag_defs]"], ["proof (state)\nthis:\n  (pick m, op_map_pick m')\n  \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>nres_rel\n  (del, op_map_delete)\n  \\<in> Rk \\<rightarrow>\n        \\<langle>Rk, Rv\\<rangle>Rm \\<rightarrow> \\<langle>Rk, Rv\\<rangle>Rm\n\ngoal (1 subgoal):\n 1. (gen_map_pick_remove pick del m,\n     (OP op_map_pick_remove :::\n      \\<langle>Rk, Rv\\<rangle>Rm \\<rightarrow>\n      \\<langle>(Rk \\<times>\\<^sub>r Rv) \\<times>\\<^sub>r \\<langle>Rk,\n               Rv\\<rangle>Rm\\<rangle>nres_rel) $\n     m')\n    \\<in> \\<langle>(Rk \\<times>\\<^sub>r Rv) \\<times>\\<^sub>r \\<langle>Rk,\n                   Rv\\<rangle>Rm\\<rangle>nres_rel", "have \"(gen_map_pick_remove pick del m, \n      do {    \n        (k,v)\\<leftarrow>op_map_pick m';\n        let m' = op_map_delete k m';\n        RETURN ((k,v),m')\n      }) \\<in> \\<langle>(Rk\\<times>\\<^sub>rRv) \\<times>\\<^sub>r \\<langle>Rk,Rv\\<rangle>Rm\\<rangle>nres_rel\" (is \"(_,?h):_\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (gen_map_pick_remove pick del m,\n     op_map_pick m' \\<bind>\n     (\\<lambda>(k, v). let m' = op_map_delete k m' in RETURN ((k, v), m')))\n    \\<in> \\<langle>(Rk \\<times>\\<^sub>r Rv) \\<times>\\<^sub>r \\<langle>Rk,\n                   Rv\\<rangle>Rm\\<rangle>nres_rel", "unfolding gen_map_pick_remove_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (pick m \\<bind>\n     (\\<lambda>(k, v). let m = del k m in RETURN ((k, v), m)),\n     op_map_pick m' \\<bind>\n     (\\<lambda>(k, v). let m' = op_map_delete k m' in RETURN ((k, v), m')))\n    \\<in> \\<langle>(Rk \\<times>\\<^sub>r Rv) \\<times>\\<^sub>r \\<langle>Rk,\n                   Rv\\<rangle>Rm\\<rangle>nres_rel", "apply parametricity"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (gen_map_pick_remove pick del m,\n   op_map_pick m' \\<bind>\n   (\\<lambda>(k, v). let m' = op_map_delete k m' in RETURN ((k, v), m')))\n  \\<in> \\<langle>(Rk \\<times>\\<^sub>r Rv) \\<times>\\<^sub>r \\<langle>Rk,\n                 Rv\\<rangle>Rm\\<rangle>nres_rel\n\ngoal (1 subgoal):\n 1. (gen_map_pick_remove pick del m,\n     (OP op_map_pick_remove :::\n      \\<langle>Rk, Rv\\<rangle>Rm \\<rightarrow>\n      \\<langle>(Rk \\<times>\\<^sub>r Rv) \\<times>\\<^sub>r \\<langle>Rk,\n               Rv\\<rangle>Rm\\<rangle>nres_rel) $\n     m')\n    \\<in> \\<langle>(Rk \\<times>\\<^sub>r Rv) \\<times>\\<^sub>r \\<langle>Rk,\n                   Rv\\<rangle>Rm\\<rangle>nres_rel", "also"], ["proof (state)\nthis:\n  (gen_map_pick_remove pick del m,\n   op_map_pick m' \\<bind>\n   (\\<lambda>(k, v). let m' = op_map_delete k m' in RETURN ((k, v), m')))\n  \\<in> \\<langle>(Rk \\<times>\\<^sub>r Rv) \\<times>\\<^sub>r \\<langle>Rk,\n                 Rv\\<rangle>Rm\\<rangle>nres_rel\n\ngoal (1 subgoal):\n 1. (gen_map_pick_remove pick del m,\n     (OP op_map_pick_remove :::\n      \\<langle>Rk, Rv\\<rangle>Rm \\<rightarrow>\n      \\<langle>(Rk \\<times>\\<^sub>r Rv) \\<times>\\<^sub>r \\<langle>Rk,\n               Rv\\<rangle>Rm\\<rangle>nres_rel) $\n     m')\n    \\<in> \\<langle>(Rk \\<times>\\<^sub>r Rv) \\<times>\\<^sub>r \\<langle>Rk,\n                   Rv\\<rangle>Rm\\<rangle>nres_rel", "have \"?h = op_map_pick_remove m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op_map_pick m' \\<bind>\n    (\\<lambda>(k, v). let m' = op_map_delete k m' in RETURN ((k, v), m')) =\n    op_map_pick_remove m'", "by (auto simp add: pw_eq_iff refine_pw_simps)"], ["proof (state)\nthis:\n  op_map_pick m' \\<bind>\n  (\\<lambda>(k, v). let m' = op_map_delete k m' in RETURN ((k, v), m')) =\n  op_map_pick_remove m'\n\ngoal (1 subgoal):\n 1. (gen_map_pick_remove pick del m,\n     (OP op_map_pick_remove :::\n      \\<langle>Rk, Rv\\<rangle>Rm \\<rightarrow>\n      \\<langle>(Rk \\<times>\\<^sub>r Rv) \\<times>\\<^sub>r \\<langle>Rk,\n               Rv\\<rangle>Rm\\<rangle>nres_rel) $\n     m')\n    \\<in> \\<langle>(Rk \\<times>\\<^sub>r Rv) \\<times>\\<^sub>r \\<langle>Rk,\n                   Rv\\<rangle>Rm\\<rangle>nres_rel", "finally"], ["proof (chain)\npicking this:\n  (gen_map_pick_remove pick del m, op_map_pick_remove m')\n  \\<in> \\<langle>(Rk \\<times>\\<^sub>r Rv) \\<times>\\<^sub>r \\<langle>Rk,\n                 Rv\\<rangle>Rm\\<rangle>nres_rel", "show ?thesis"], ["proof (prove)\nusing this:\n  (gen_map_pick_remove pick del m, op_map_pick_remove m')\n  \\<in> \\<langle>(Rk \\<times>\\<^sub>r Rv) \\<times>\\<^sub>r \\<langle>Rk,\n                 Rv\\<rangle>Rm\\<rangle>nres_rel\n\ngoal (1 subgoal):\n 1. (gen_map_pick_remove pick del m,\n     (OP op_map_pick_remove :::\n      \\<langle>Rk, Rv\\<rangle>Rm \\<rightarrow>\n      \\<langle>(Rk \\<times>\\<^sub>r Rv) \\<times>\\<^sub>r \\<langle>Rk,\n               Rv\\<rangle>Rm\\<rangle>nres_rel) $\n     m')\n    \\<in> \\<langle>(Rk \\<times>\\<^sub>r Rv) \\<times>\\<^sub>r \\<langle>Rk,\n                   Rv\\<rangle>Rm\\<rangle>nres_rel", "by simp"], ["proof (state)\nthis:\n  (gen_map_pick_remove pick del m,\n   (OP op_map_pick_remove :::\n    \\<langle>Rk, Rv\\<rangle>Rm \\<rightarrow>\n    \\<langle>(Rk \\<times>\\<^sub>r Rv) \\<times>\\<^sub>r \\<langle>Rk,\n             Rv\\<rangle>Rm\\<rangle>nres_rel) $\n   m')\n  \\<in> \\<langle>(Rk \\<times>\\<^sub>r Rv) \\<times>\\<^sub>r \\<langle>Rk,\n                 Rv\\<rangle>Rm\\<rangle>nres_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}