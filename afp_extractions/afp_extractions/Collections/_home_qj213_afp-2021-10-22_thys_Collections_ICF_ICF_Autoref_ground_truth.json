{"file_name": "/home/qj213/afp-2021-10-22/thys/Collections/ICF/ICF_Autoref.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Collections", "problem_names": ["lemma uprio_pats:\n  fixes s :: \"'e\\<rightharpoonup>'a\"\n  shows\n  \"Map.empty::'e\\<rightharpoonup>'a \\<equiv> op_uprio_empty\"\n  \"s e \\<equiv> op_uprio_prio$s$e\"\n  \"s(e\\<mapsto>a) \\<equiv> op_uprio_insert$s$e$a\"\n\n  \"dom s = {} \\<equiv> op_uprio_is_empty$s\"\n  \"{} = dom s \\<equiv> op_uprio_is_empty$s\"\n  \"s=Map.empty \\<equiv> op_uprio_is_empty$s\"\n  \"Map.empty=s \\<equiv> op_uprio_is_empty$s\"", "lemma [autoref_itype]:\n  \"op_uprio_empty ::\\<^sub>i \\<langle>Ie,Ia\\<rangle>\\<^sub>ii_prio\"\n  \"op_uprio_prio ::\\<^sub>i \\<langle>Ie,Ia\\<rangle>\\<^sub>ii_prio \\<rightarrow>\\<^sub>i Ie \\<rightarrow>\\<^sub>i \\<langle>Ia\\<rangle>\\<^sub>ii_option\"\n  \"op_uprio_is_empty ::\\<^sub>i \\<langle>Ie,Ia\\<rangle>\\<^sub>ii_prio \\<rightarrow>\\<^sub>i i_bool\"\n  \"op_uprio_insert ::\\<^sub>i \\<langle>Ie,Ia\\<rangle>\\<^sub>ii_prio \\<rightarrow>\\<^sub>i Ie \\<rightarrow>\\<^sub>i Ia \\<rightarrow>\\<^sub>i \\<langle>Ie,Ia\\<rangle>\\<^sub>ii_prio\"\n  \"prio_pop_min ::\\<^sub>i \\<langle>Ie,Ia\\<rangle>\\<^sub>ii_prio \\<rightarrow>\\<^sub>i \\<langle>\\<langle>Ie,\\<langle>Ia,\\<langle>Ie,Ia\\<rangle>\\<^sub>ii_prio\\<rangle>\\<^sub>ii_prod\\<rangle>\\<^sub>ii_prod\\<rangle>\\<^sub>ii_nres\"", "lemma rel_def:\n    \"\\<And>Re Ra. \\<langle>Re,Ra\\<rangle>rel \\<equiv> br \\<alpha> invar O (Re \\<rightarrow> \\<langle>Ra\\<rangle> option_rel)\"", "lemma rel_id[simp]: \"\\<langle>Id,Id\\<rangle>rel = br \\<alpha> invar\"", "lemma rel_sv[relator_props]: \n    \"\\<And>Re Ra. \\<lbrakk>Range Re = UNIV; single_valued Ra\\<rbrakk> \\<Longrightarrow> single_valued (\\<langle>Re,Ra\\<rangle>rel)\"", "lemmas [autoref_rel_intf] = REL_INTFI[of rel i_prio]", "lemma (in uprio) rel_alt: \"\\<langle>Id,Rv\\<rangle>rel = \n  { (c,a). \\<forall>x. (\\<alpha> c x,a x)\\<in>\\<langle>Rv\\<rangle>option_rel \\<and> invar c }\"", "lemma (in uprio_empty) autoref_empty[autoref_rules]:\n  \"\\<And>Re Ra. PREFER_id Re \\<Longrightarrow> (empty (),op_uprio_empty)\\<in>\\<langle>Re,Ra\\<rangle>rel\"", "lemma (in uprio_isEmpty) autoref_is_empty[autoref_rules]:\n  \"\\<And>Re Ra. PREFER_id Re \\<Longrightarrow> (isEmpty,op_uprio_is_empty)\\<in>\\<langle>Re,Ra\\<rangle>rel\\<rightarrow>bool_rel\"", "lemma (in uprio_prio) autoref_prio[autoref_rules]:\n  \"\\<And>Re Ra. PREFER_id Re \\<Longrightarrow> (prio,op_uprio_prio)\\<in>\\<langle>Re,Ra\\<rangle>rel\\<rightarrow>Re\\<rightarrow>\\<langle>Ra\\<rangle>option_rel\"", "lemma (in uprio_insert) autoref_insert[autoref_rules]:\n  \"\\<And>Re Ra. PREFER_id Re \\<Longrightarrow> (insert,op_uprio_insert)\\<in>\\<langle>Re,Ra\\<rangle>rel\\<rightarrow>Re\\<rightarrow>Ra\\<rightarrow>\\<langle>Re,Ra\\<rangle>rel\"", "lemma (in uprio_pop) autoref_prio_pop_min[autoref_rules]:\n  \"\\<And>Re Ra. \\<lbrakk>PREFER_id Re; PREFER_id Ra \\<rbrakk> \n  \\<Longrightarrow> (\\<lambda>s. RETURN (pop s),prio_pop_min)\\<in>\\<langle>Re,Ra\\<rangle>rel\\<rightarrow>\\<langle>\\<langle>Re,\\<langle>Ra,\\<langle>Re,Ra\\<rangle>rel\\<rangle>prod_rel\\<rangle>prod_rel\\<rangle>nres_rel\"", "lemma rel_def: \"\\<langle>R\\<rangle>rel \\<equiv> br \\<alpha> invar O \\<langle>R\\<rangle>set_rel\"", "lemma rel_id[simp]: \"\\<langle>Id\\<rangle>rel = br \\<alpha> invar\"", "lemma rel_sv[relator_props]: \"single_valued R \\<Longrightarrow> single_valued (\\<langle>R\\<rangle>rel)\"", "lemmas [autoref_rel_intf] = REL_INTFI[of rel i_set]", "lemma rel_def: \n    \"\\<langle>Rk,Rv\\<rangle>rel \\<equiv> br \\<alpha> invar O (Rk \\<rightarrow> \\<langle>Rv\\<rangle> option_rel)\"", "lemma rel_id[simp]: \"\\<langle>Id,Id\\<rangle>rel = br \\<alpha> invar\"", "lemma rel_sv[relator_props]: \n    \"\\<lbrakk>Range Rk = UNIV; single_valued Rv\\<rbrakk> \\<Longrightarrow> single_valued (\\<langle>Rk,Rv\\<rangle>rel)\"", "lemmas [autoref_rel_intf] = REL_INTFI[of rel i_map]", "lemma Collect_x_x_pairs_rel_image[simp]: \"{p. \\<exists>x. p = (x, x)}``x = x\"", "lemma (in set_empty) empty_autoref[autoref_rules]: \n  \"PREFER_id Rk \\<Longrightarrow> (empty (), {}) \\<in> \\<langle>Rk\\<rangle>rel\"", "lemma (in set_memb) memb_autoref[autoref_rules]: \n  \"PREFER_id Rk \\<Longrightarrow> (memb,(\\<in>))\\<in>Rk\\<rightarrow>\\<langle>Rk\\<rangle>rel\\<rightarrow>Id\"", "lemma (in set_ins) ins_autoref[autoref_rules]: \n  \"PREFER_id Rk \\<Longrightarrow> (ins,Set.insert)\\<in>Rk\\<rightarrow>\\<langle>Rk\\<rangle>rel\\<rightarrow>\\<langle>Rk\\<rangle>rel\"", "lemma ins_dj_autoref[autoref_rules]: \n  assumes \"SIDE_PRECOND_OPT (x'\\<notin>s')\"\n  assumes \"PREFER_id Rk\"\n  assumes \"(x,x')\\<in>Rk\"\n  assumes \"(s,s')\\<in>\\<langle>Rk\\<rangle>rel\"\n  shows \"(ins_dj x s,(OP Set.insert ::: Rk \\<rightarrow> \\<langle>Rk\\<rangle>rel \\<rightarrow> \\<langle>Rk\\<rangle>rel)$x'$s')\\<in>\\<langle>Rk\\<rangle>rel\"", "lemma (in set_delete) delete_autoref[autoref_rules]: \n  \"PREFER_id Rk \\<Longrightarrow> (delete,op_set_delete)\\<in>Rk\\<rightarrow>\\<langle>Rk\\<rangle>rel\\<rightarrow>\\<langle>Rk\\<rangle>rel\"", "lemma (in set_isEmpty) isEmpty_autoref[autoref_rules]: \n  \"PREFER_id Rk \\<Longrightarrow> (isEmpty,op_set_isEmpty) \\<in> \\<langle>Rk\\<rangle>rel\\<rightarrow>Id\"", "lemma (in set_isSng) isSng_autoref[autoref_rules]: \n  \"PREFER_id Rk \\<Longrightarrow> (isSng,op_set_isSng) \\<in> \\<langle>Rk\\<rangle>rel\\<rightarrow>Id\"", "lemma (in set_ball) ball_autoref[autoref_rules]: \n  \"PREFER_id Rk \\<Longrightarrow> (ball,Set.Ball) \\<in> \\<langle>Rk\\<rangle>rel\\<rightarrow>(Rk\\<rightarrow>Id)\\<rightarrow>Id\"", "lemma (in set_bex) bex_autoref[autoref_rules]: \n  \"PREFER_id Rk \\<Longrightarrow> (bex,Set.Bex) \\<in> \\<langle>Rk\\<rangle>rel\\<rightarrow>(Rk\\<rightarrow>Id)\\<rightarrow>Id\"", "lemma (in set_size) size_autoref[autoref_rules]: \n  \"PREFER_id Rk \\<Longrightarrow> (size,card) \\<in> \\<langle>Rk\\<rangle>rel \\<rightarrow> Id\"", "lemma (in set_size_abort) size_abort_autoref[autoref_rules]: \n  \"PREFER_id Rk \\<Longrightarrow> (size_abort,op_set_size_abort) \\<in> Id \\<rightarrow> \\<langle>Rk\\<rangle>rel \\<rightarrow> Id\"", "lemma (in set_union) union_autoref[autoref_rules]: \n  \"PREFER_id Rk \\<Longrightarrow> (union,(\\<union>))\\<in>\\<langle>Rk\\<rangle>s1.rel\\<rightarrow>\\<langle>Rk\\<rangle>s2.rel\\<rightarrow>\\<langle>Rk\\<rangle>s3.rel\"", "lemma union_dj_autoref[autoref_rules]:\n  assumes \"PREFER_id Rk\"\n  assumes \"SIDE_PRECOND_OPT (a'\\<inter>b'={})\"\n  assumes \"(a,a')\\<in>\\<langle>Rk\\<rangle>s1.rel\"\n  assumes \"(b,b')\\<in>\\<langle>Rk\\<rangle>s2.rel\"\n  shows \"(union_dj a b,(OP (\\<union>) ::: \\<langle>Rk\\<rangle>s1.rel \\<rightarrow> \\<langle>Rk\\<rangle>s2.rel \\<rightarrow> \\<langle>Rk\\<rangle>s3.rel)$a'$b')\n    \\<in>\\<langle>Rk\\<rangle>s3.rel\"", "lemma (in set_diff) diff_autoref[autoref_rules]: \n  \"PREFER_id Rk \\<Longrightarrow> (diff,(-))\\<in>\\<langle>Rk\\<rangle>s1.rel\\<rightarrow>\\<langle>Rk\\<rangle>s2.rel\\<rightarrow>\\<langle>Rk\\<rangle>s1.rel\"", "lemma (in set_filter) filter_autoref[autoref_rules]: \n  \"PREFER_id Rk \\<Longrightarrow> (filter,op_set_filter)\\<in>(Rk \\<rightarrow> Id) \\<rightarrow> \\<langle>Rk\\<rangle>s1.rel\\<rightarrow>\\<langle>Rk\\<rangle>s2.rel\"", "lemma (in set_inter) inter_autoref[autoref_rules]: \n  \"PREFER_id Rk \\<Longrightarrow> (inter,(\\<inter>))\\<in>\\<langle>Rk\\<rangle>s1.rel\\<rightarrow>\\<langle>Rk\\<rangle>s2.rel\\<rightarrow>\\<langle>Rk\\<rangle>s3.rel\"", "lemma (in set_subset) subset_autoref[autoref_rules]: \n  \"PREFER_id Rk \\<Longrightarrow> (subset,(\\<subseteq>))\\<in>\\<langle>Rk\\<rangle>s1.rel\\<rightarrow>\\<langle>Rk\\<rangle>s2.rel\\<rightarrow>Id\"", "lemma (in set_equal) equal_autoref[autoref_rules]: \n  \"PREFER_id Rk \\<Longrightarrow> (equal,(=))\\<in>\\<langle>Rk\\<rangle>s1.rel\\<rightarrow>\\<langle>Rk\\<rangle>s2.rel\\<rightarrow>Id\"", "lemma (in set_disjoint) disjoint_autoref[autoref_rules]: \n  \"PREFER_id Rk \\<Longrightarrow> (disjoint,op_set_disjoint)\\<in>\\<langle>Rk\\<rangle>s1.rel\\<rightarrow>\\<langle>Rk\\<rangle>s2.rel\\<rightarrow>Id\"", "lemma (in list_to_set) to_set_autoref[autoref_rules]: \n  \"PREFER_id Rk \\<Longrightarrow> (to_set,set)\\<in>\\<langle>Rk\\<rangle>list_rel \\<rightarrow> \\<langle>Rk\\<rangle>rel\"", "lemma autoref_op_set_pick[autoref_rules]: \n  assumes \"SIDE_PRECOND (s'\\<noteq>{})\"\n  assumes \"PREFER_id Rk\"\n  assumes \"(s,s')\\<in>\\<langle>Rk\\<rangle>rel\"\n  shows \"(RETURN (the (sel' s (\\<lambda>_. True))), \n          (OP op_set_pick ::: \\<langle>Rk\\<rangle>rel \\<rightarrow> \\<langle>Rk\\<rangle>nres_rel) $ s')\n    \\<in> \\<langle>Rk\\<rangle>nres_rel\"", "lemma (in poly_set_iteratei) proper[proper_it]:\n  \"proper_it' iteratei iteratei\"", "lemma (in poly_set_iteratei) autoref_iteratei[autoref_ga_rules]: \n  \"REL_IS_ID Rk \\<Longrightarrow> is_set_to_list Rk rel (it_to_list iteratei)\"", "lemma (in poly_set_iterateoi) proper_o[proper_it]:\n  \"proper_it' iterateoi iterateoi\"", "lemma (in poly_set_iterateoi) autoref_iterateoi[autoref_ga_rules]: \n  \"REL_IS_ID Rk \\<Longrightarrow> \n    is_set_to_sorted_list (\\<le>) Rk rel (it_to_list iterateoi)\"", "lemma (in poly_set_rev_iterateoi) autoref_rev_iterateoi[autoref_ga_rules]: \n  \"REL_IS_ID Rk \\<Longrightarrow> \n    is_set_to_sorted_list (\\<ge>) Rk rel (it_to_list rev_iterateoi)\"", "lemma (in poly_set_rev_iterateoi) proper_ro[proper_it]:\n  \"proper_it' rev_iterateoi rev_iterateoi\"", "lemma (in map) rel_alt: \"\\<langle>Id,Rv\\<rangle>rel = \n  { (c,a). \\<forall>x. (\\<alpha> c x,a x)\\<in>\\<langle>Rv\\<rangle>option_rel \\<and> invar c }\"", "lemma (in map_empty) empty_autoref[autoref_rules]: \n  \"PREFER_id Rk \\<Longrightarrow> (empty (),op_map_empty)\\<in>\\<langle>Rk,Rv\\<rangle>rel\"", "lemma (in map_lookup) lookup_autoref[autoref_rules]: \n  \"PREFER_id Rk \\<Longrightarrow> (lookup,op_map_lookup)\\<in>Rk\\<rightarrow>\\<langle>Rk,Rv\\<rangle>rel\\<rightarrow>\\<langle>Rv\\<rangle>option_rel\"", "lemma (in map_update) update_autoref[autoref_rules]: \n  \"PREFER_id Rk \\<Longrightarrow> (update,op_map_update)\\<in>Rk\\<rightarrow>Rv\\<rightarrow>\\<langle>Rk,Rv\\<rangle>rel\\<rightarrow>\\<langle>Rk,Rv\\<rangle>rel\"", "lemma update_dj_autoref[autoref_rules]: \n  assumes \"SIDE_PRECOND_OPT (k'\\<notin>dom m')\"\n  assumes \"PREFER_id Rk\"\n  assumes \"(k,k')\\<in>Rk\"\n  assumes \"(v,v')\\<in>Rv\"\n  assumes \"(m,m')\\<in>\\<langle>Rk,Rv\\<rangle>rel\"\n  shows \"(update_dj k v m,\n    (OP op_map_update ::: Rk \\<rightarrow> Rv \\<rightarrow> \\<langle>Rk,Rv\\<rangle>rel \\<rightarrow> \\<langle>Rk,Rv\\<rangle>rel)$k'$v'$m'\n  )\\<in>\\<langle>Rk,Rv\\<rangle>rel\"", "lemma (in map_delete) delete_autoref[autoref_rules]: \n  \"PREFER_id Rk \\<Longrightarrow> (delete,op_map_delete)\\<in>Rk\\<rightarrow>\\<langle>Rk,Rv\\<rangle>rel\\<rightarrow>\\<langle>Rk,Rv\\<rangle>rel\"", "lemma (in map_restrict) restrict_autoref[autoref_rules]: \n  \"PREFER_id Rk \\<Longrightarrow> \n    (restrict,op_map_restrict) \n    \\<in> (\\<langle>Rk,Rv\\<rangle>prod_rel \\<rightarrow> Id) \\<rightarrow> \\<langle>Rk,Rv\\<rangle>m1.rel \\<rightarrow> \\<langle>Rk,Rv\\<rangle>m2.rel\"", "lemma (in map_add) add_autoref[autoref_rules]: \n  \"PREFER_id Rk \\<Longrightarrow> (add,(++))\\<in>\\<langle>Rk,Rv\\<rangle>rel\\<rightarrow>\\<langle>Rk,Rv\\<rangle>rel\\<rightarrow>\\<langle>Rk,Rv\\<rangle>rel\"", "lemma add_dj_autoref[autoref_rules]: \n  assumes \"PREFER_id Rk\"\n  assumes \"SIDE_PRECOND_OPT (dom a' \\<inter> dom b' = {})\"\n  assumes \"(a,a')\\<in>\\<langle>Rk,Rv\\<rangle>rel\"\n  assumes \"(b,b')\\<in>\\<langle>Rk,Rv\\<rangle>rel\"\n  shows \"(add_dj a b, (OP (++) ::: \\<langle>Rk,Rv\\<rangle>rel \\<rightarrow> \\<langle>Rk,Rv\\<rangle>rel \\<rightarrow> \\<langle>Rk,Rv\\<rangle>rel) $ a' $ b')\\<in>\\<langle>Rk,Rv\\<rangle>rel\"", "lemma (in map_isEmpty) isEmpty_autoref[autoref_rules]: \n  \"PREFER_id Rk \\<Longrightarrow> (isEmpty,op_map_isEmpty)\\<in>\\<langle>Rk,Rv\\<rangle>rel\\<rightarrow>Id\"", "lemma sngI: \n  assumes \"m k = Some v\"\n  assumes \"\\<forall>k'. k'\\<noteq>k \\<longrightarrow> m k' = None\"\n  shows \"m = [k\\<mapsto>v]\"", "lemma (in map_isSng) isSng_autoref[autoref_rules]: \n  \"PREFER_id Rk \\<Longrightarrow> (isSng,op_map_isSng)\\<in>\\<langle>Rk,Rv\\<rangle>rel\\<rightarrow>Id\"", "lemma (in map_ball) ball_autoref[autoref_rules]:\n  \"PREFER_id Rk \\<Longrightarrow> (ball,op_map_ball)\\<in>\\<langle>Rk,Rv\\<rangle>rel\\<rightarrow>(\\<langle>Rk,Rv\\<rangle>prod_rel\\<rightarrow>Id)\\<rightarrow>Id\"", "lemma (in map_bex) bex_autoref[autoref_rules]:\n  \"PREFER_id Rk \\<Longrightarrow> (bex,op_map_bex)\\<in>\\<langle>Rk,Rv\\<rangle>rel\\<rightarrow>(\\<langle>Rk,Rv\\<rangle>prod_rel\\<rightarrow>Id)\\<rightarrow>Id\"", "lemma (in map_size) size_autoref[autoref_rules]:\n  \"PREFER_id Rk \\<Longrightarrow> (size,op_map_size)\\<in>\\<langle>Rk,Rv\\<rangle>rel\\<rightarrow>Id\"", "lemma (in map_size_abort) size_abort_autoref[autoref_rules]:\n  \"PREFER_id Rk \\<Longrightarrow> (size_abort,op_map_size_abort)\\<in>Id\\<rightarrow>\\<langle>Rk,Rv\\<rangle>rel\\<rightarrow>Id\"", "lemma (in list_to_map) to_map_autoref[autoref_rules]:\n  \"PREFER_id Rk \\<Longrightarrow> (to_map,map_of)\\<in> \\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel \\<rightarrow> \\<langle>Rk,Rv\\<rangle>rel\"", "lemma key_rel_true[simp]: \"key_rel (\\<lambda>_ _. True) = (\\<lambda>_ _. True)\"", "lemma (in poly_map_iteratei) proper[proper_it]:\n  \"proper_it' iteratei iteratei\"", "lemma (in poly_map_iteratei) autoref_iteratei[autoref_ga_rules]: \n  assumes ID: \"REL_IS_ID Rk\"\n    \"REL_IS_ID Rv\" (* TODO: Unnecessary*)\n  shows \"is_map_to_list Rk Rv rel (it_to_list iteratei)\"", "lemma (in poly_map_iterateoi) proper_o[proper_it]:\n  \"proper_it' iterateoi iterateoi\"", "lemma (in poly_map_iterateoi) autoref_iterateoi[autoref_ga_rules]: \n  assumes ID: \"REL_IS_ID Rk\"\n    \"REL_IS_ID Rv\" (* TODO: Unnecessary*)\n  shows \"is_map_to_sorted_list (\\<le>) Rk Rv rel (it_to_list iterateoi)\"", "lemma (in poly_map_rev_iterateoi) proper_ro[proper_it]:\n  \"proper_it' rev_iterateoi rev_iterateoi\"", "lemma (in poly_map_rev_iterateoi) autoref_rev_iterateoi[autoref_ga_rules]: \n  assumes ID: \"REL_IS_ID Rk\"\n    \"REL_IS_ID Rv\" (* TODO: Unnecessary*)\n  shows \"is_map_to_sorted_list (\\<ge>) Rk Rv rel (it_to_list rev_iterateoi)\""], "translations": [["", "lemma uprio_pats:\n  fixes s :: \"'e\\<rightharpoonup>'a\"\n  shows\n  \"Map.empty::'e\\<rightharpoonup>'a \\<equiv> op_uprio_empty\"\n  \"s e \\<equiv> op_uprio_prio$s$e\"\n  \"s(e\\<mapsto>a) \\<equiv> op_uprio_insert$s$e$a\"\n\n  \"dom s = {} \\<equiv> op_uprio_is_empty$s\"\n  \"{} = dom s \\<equiv> op_uprio_is_empty$s\"\n  \"s=Map.empty \\<equiv> op_uprio_is_empty$s\"\n  \"Map.empty=s \\<equiv> op_uprio_is_empty$s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((Map.empty \\<equiv> op_uprio_empty) &&&\n     (s e \\<equiv> op_uprio_prio $ s $ e) &&&\n     s(e \\<mapsto> a) \\<equiv> op_uprio_insert $ s $ e $ a) &&&\n    ((dom s = {} \\<equiv> op_uprio_is_empty $ s) &&&\n     {} = dom s \\<equiv> op_uprio_is_empty $ s) &&&\n    (s = Map.empty \\<equiv> op_uprio_is_empty $ s) &&&\n    Map.empty = s \\<equiv> op_uprio_is_empty $ s", "by (auto intro!: eq_reflection)"], ["", "end"], ["", "term prio_pop_min"], ["", "lemma [autoref_itype]:\n  \"op_uprio_empty ::\\<^sub>i \\<langle>Ie,Ia\\<rangle>\\<^sub>ii_prio\"\n  \"op_uprio_prio ::\\<^sub>i \\<langle>Ie,Ia\\<rangle>\\<^sub>ii_prio \\<rightarrow>\\<^sub>i Ie \\<rightarrow>\\<^sub>i \\<langle>Ia\\<rangle>\\<^sub>ii_option\"\n  \"op_uprio_is_empty ::\\<^sub>i \\<langle>Ie,Ia\\<rangle>\\<^sub>ii_prio \\<rightarrow>\\<^sub>i i_bool\"\n  \"op_uprio_insert ::\\<^sub>i \\<langle>Ie,Ia\\<rangle>\\<^sub>ii_prio \\<rightarrow>\\<^sub>i Ie \\<rightarrow>\\<^sub>i Ia \\<rightarrow>\\<^sub>i \\<langle>Ie,Ia\\<rangle>\\<^sub>ii_prio\"\n  \"prio_pop_min ::\\<^sub>i \\<langle>Ie,Ia\\<rangle>\\<^sub>ii_prio \\<rightarrow>\\<^sub>i \\<langle>\\<langle>Ie,\\<langle>Ia,\\<langle>Ie,Ia\\<rangle>\\<^sub>ii_prio\\<rangle>\\<^sub>ii_prod\\<rangle>\\<^sub>ii_prod\\<rangle>\\<^sub>ii_nres\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (op_uprio_empty ::\\<^sub>i \\<langle>Ie, Ia\\<rangle>\\<^sub>ii_prio &&&\n     op_uprio_prio ::\\<^sub>i\n     \\<langle>Ie, Ia\\<rangle>\\<^sub>ii_prio \\<rightarrow>\\<^sub>i\n     Ie \\<rightarrow>\\<^sub>i \\<langle>Ia\\<rangle>\\<^sub>ii_option) &&&\n    op_uprio_is_empty ::\\<^sub>i\n    \\<langle>Ie, Ia\\<rangle>\\<^sub>ii_prio \\<rightarrow>\\<^sub>i i_bool &&&\n    op_uprio_insert ::\\<^sub>i\n    \\<langle>Ie, Ia\\<rangle>\\<^sub>ii_prio \\<rightarrow>\\<^sub>i\n    Ie \\<rightarrow>\\<^sub>i\n    Ia \\<rightarrow>\\<^sub>i \\<langle>Ie, Ia\\<rangle>\\<^sub>ii_prio &&&\n    prio_pop_min ::\\<^sub>i\n    \\<langle>Ie, Ia\\<rangle>\\<^sub>ii_prio \\<rightarrow>\\<^sub>i\n    \\<langle>\\<langle>Ie, \\<langle>Ia, \\<langle>Ie,\n    Ia\\<rangle>\\<^sub>ii_prio\\<rangle>\\<^sub>ii_prod\\<rangle>\\<^sub>ii_prod\\<rangle>\\<^sub>ii_nres", "by simp_all"], ["", "context uprio begin"], ["", "definition rel_def_internal: \n    \"\\<And>Re Ra. rel Re Ra \\<equiv> br \\<alpha> invar O (Re \\<rightarrow> \\<langle>Ra\\<rangle> option_rel)\""], ["", "lemma rel_def:\n    \"\\<And>Re Ra. \\<langle>Re,Ra\\<rangle>rel \\<equiv> br \\<alpha> invar O (Re \\<rightarrow> \\<langle>Ra\\<rangle> option_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Re Ra.\n       \\<langle>Re, Ra\\<rangle>rel \\<equiv>\n       br \\<alpha> invar O (Re \\<rightarrow> \\<langle>Ra\\<rangle>option_rel)", "by (simp add: rel_def_internal relAPP_def)"], ["", "lemma rel_id[simp]: \"\\<langle>Id,Id\\<rangle>rel = br \\<alpha> invar\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>Id, Id\\<rangle>rel = br \\<alpha> invar", "by (simp add: rel_def)"], ["", "lemma rel_sv[relator_props]: \n    \"\\<And>Re Ra. \\<lbrakk>Range Re = UNIV; single_valued Ra\\<rbrakk> \\<Longrightarrow> single_valued (\\<langle>Re,Ra\\<rangle>rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Re Ra.\n       \\<lbrakk>Range Re = UNIV; single_valued Ra\\<rbrakk>\n       \\<Longrightarrow> single_valued (\\<langle>Re, Ra\\<rangle>rel)", "unfolding rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Re Ra.\n       \\<lbrakk>Range Re = UNIV; single_valued Ra\\<rbrakk>\n       \\<Longrightarrow> single_valued\n                          (br \\<alpha> invar O\n                           (Re \\<rightarrow>\n                            \\<langle>Ra\\<rangle>option_rel))", "by tagged_solver"], ["", "lemmas [autoref_rel_intf] = REL_INTFI[of rel i_prio]"], ["", "end"], ["", "lemma (in uprio) rel_alt: \"\\<langle>Id,Rv\\<rangle>rel = \n  { (c,a). \\<forall>x. (\\<alpha> c x,a x)\\<in>\\<langle>Rv\\<rangle>option_rel \\<and> invar c }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>Id, Rv\\<rangle>rel =\n    {(c, a).\n     \\<forall>x.\n        (\\<alpha> c x, a x) \\<in> \\<langle>Rv\\<rangle>option_rel \\<and>\n        invar c}", "by (auto simp: rel_def br_def dest: fun_relD)"], ["", "lemma (in uprio_empty) autoref_empty[autoref_rules]:\n  \"\\<And>Re Ra. PREFER_id Re \\<Longrightarrow> (empty (),op_uprio_empty)\\<in>\\<langle>Re,Ra\\<rangle>rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Re Ra.\n       PREFER_id Re \\<Longrightarrow>\n       (empty (), op_uprio_empty) \\<in> \\<langle>Re, Ra\\<rangle>rel", "by (auto simp: empty_correct rel_alt)"], ["", "lemma (in uprio_isEmpty) autoref_is_empty[autoref_rules]:\n  \"\\<And>Re Ra. PREFER_id Re \\<Longrightarrow> (isEmpty,op_uprio_is_empty)\\<in>\\<langle>Re,Ra\\<rangle>rel\\<rightarrow>bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Re Ra.\n       PREFER_id Re \\<Longrightarrow>\n       (isEmpty, op_uprio_is_empty)\n       \\<in> \\<langle>Re, Ra\\<rangle>rel \\<rightarrow> bool_rel", "by (auto simp: isEmpty_correct rel_alt intro!: ext)"], ["", "lemma (in uprio_prio) autoref_prio[autoref_rules]:\n  \"\\<And>Re Ra. PREFER_id Re \\<Longrightarrow> (prio,op_uprio_prio)\\<in>\\<langle>Re,Ra\\<rangle>rel\\<rightarrow>Re\\<rightarrow>\\<langle>Ra\\<rangle>option_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Re Ra.\n       PREFER_id Re \\<Longrightarrow>\n       (prio, op_uprio_prio)\n       \\<in> \\<langle>Re, Ra\\<rangle>rel \\<rightarrow>\n             Re \\<rightarrow> \\<langle>Ra\\<rangle>option_rel", "by (auto simp: prio_correct rel_alt intro!: ext)"], ["", "lemma (in uprio_insert) autoref_insert[autoref_rules]:\n  \"\\<And>Re Ra. PREFER_id Re \\<Longrightarrow> (insert,op_uprio_insert)\\<in>\\<langle>Re,Ra\\<rangle>rel\\<rightarrow>Re\\<rightarrow>Ra\\<rightarrow>\\<langle>Re,Ra\\<rangle>rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Re Ra.\n       PREFER_id Re \\<Longrightarrow>\n       (insert, op_uprio_insert)\n       \\<in> \\<langle>Re, Ra\\<rangle>rel \\<rightarrow>\n             Re \\<rightarrow> Ra \\<rightarrow> \\<langle>Re, Ra\\<rangle>rel", "by (auto simp: insert_correct rel_alt intro!: ext)"], ["", "lemma (in uprio_pop) autoref_prio_pop_min[autoref_rules]:\n  \"\\<And>Re Ra. \\<lbrakk>PREFER_id Re; PREFER_id Ra \\<rbrakk> \n  \\<Longrightarrow> (\\<lambda>s. RETURN (pop s),prio_pop_min)\\<in>\\<langle>Re,Ra\\<rangle>rel\\<rightarrow>\\<langle>\\<langle>Re,\\<langle>Ra,\\<langle>Re,Ra\\<rangle>rel\\<rangle>prod_rel\\<rangle>prod_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Re Ra.\n       \\<lbrakk>PREFER_id Re; PREFER_id Ra\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>s. RETURN (pop s), prio_pop_min)\n                         \\<in> \\<langle>Re, Ra\\<rangle>rel \\<rightarrow>\n                               \\<langle>Re \\<times>\\<^sub>r\n  Ra \\<times>\\<^sub>r \\<langle>Re, Ra\\<rangle>rel\\<rangle>nres_rel", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Re Ra.\n       \\<lbrakk>Re = Id; Ra = Id\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>s. RETURN (pop s), prio_pop_min)\n                         \\<in> br \\<alpha> invar \\<rightarrow>\n                               \\<langle>Id \\<times>\\<^sub>r\n  Id \\<times>\\<^sub>r br \\<alpha> invar\\<rangle>nres_rel", "apply (intro fun_relI nres_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Re Ra a a'.\n       \\<lbrakk>Re = Id; Ra = Id; (a, a') \\<in> br \\<alpha> invar\\<rbrakk>\n       \\<Longrightarrow> RETURN (pop a)\n                         \\<le> \\<Down>\n                                (Id \\<times>\\<^sub>r\n                                 Id \\<times>\\<^sub>r br \\<alpha> invar)\n                                (prio_pop_min a')", "by (rule prio_pop_min_refine)"], ["", "context set begin"], ["", "definition rel_def_internal: \"rel R \\<equiv> br \\<alpha> invar O \\<langle>R\\<rangle>set_rel\""], ["", "lemma rel_def: \"\\<langle>R\\<rangle>rel \\<equiv> br \\<alpha> invar O \\<langle>R\\<rangle>set_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>R\\<rangle>rel \\<equiv>\n    br \\<alpha> invar O \\<langle>R\\<rangle>set_rel", "by (simp add: rel_def_internal relAPP_def)"], ["", "lemma rel_id[simp]: \"\\<langle>Id\\<rangle>rel = br \\<alpha> invar\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>Id\\<rangle>rel = br \\<alpha> invar", "by (simp add: rel_def)"], ["", "lemma rel_sv[relator_props]: \"single_valued R \\<Longrightarrow> single_valued (\\<langle>R\\<rangle>rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued R \\<Longrightarrow> single_valued (\\<langle>R\\<rangle>rel)", "unfolding rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued R \\<Longrightarrow>\n    single_valued (br \\<alpha> invar O \\<langle>R\\<rangle>set_rel)", "by tagged_solver"], ["", "lemmas [autoref_rel_intf] = REL_INTFI[of rel i_set]"], ["", "end"], ["", "context map begin"], ["", "definition rel_def_internal: \n    \"rel Rk Rv \\<equiv> br \\<alpha> invar O (Rk \\<rightarrow> \\<langle>Rv\\<rangle> option_rel)\""], ["", "lemma rel_def: \n    \"\\<langle>Rk,Rv\\<rangle>rel \\<equiv> br \\<alpha> invar O (Rk \\<rightarrow> \\<langle>Rv\\<rangle> option_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>Rk, Rv\\<rangle>rel \\<equiv>\n    br \\<alpha> invar O (Rk \\<rightarrow> \\<langle>Rv\\<rangle>option_rel)", "by (simp add: rel_def_internal relAPP_def)"], ["", "lemma rel_id[simp]: \"\\<langle>Id,Id\\<rangle>rel = br \\<alpha> invar\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>Id, Id\\<rangle>rel = br \\<alpha> invar", "by (simp add: rel_def)"], ["", "lemma rel_sv[relator_props]: \n    \"\\<lbrakk>Range Rk = UNIV; single_valued Rv\\<rbrakk> \\<Longrightarrow> single_valued (\\<langle>Rk,Rv\\<rangle>rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Range Rk = UNIV; single_valued Rv\\<rbrakk>\n    \\<Longrightarrow> single_valued (\\<langle>Rk, Rv\\<rangle>rel)", "unfolding rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Range Rk = UNIV; single_valued Rv\\<rbrakk>\n    \\<Longrightarrow> single_valued\n                       (br \\<alpha> invar O\n                        (Rk \\<rightarrow> \\<langle>Rv\\<rangle>option_rel))", "by (tagged_solver (trace))"], ["", "lemmas [autoref_rel_intf] = REL_INTFI[of rel i_map]"], ["", "end"], ["", "(*\ncontext list begin\n  definition rel_def_internal: \n    \"rel R \\<equiv> br \\<alpha> invar O R\"\n  lemma rel_def: \"\\<langle>R\\<rangle>rel \\<equiv> br \\<alpha> invar O R\" \n    by (simp add: rel_def_internal relAPP_def)\n    \n  lemma rel_id[simp]: \"\\<langle>Id\\<rangle>rel = br \\<alpha> invar\" \n    by (simp add: rel_def)\n\n  lemma rel_sv[relator_props]: \"single_valued R \\<Longrightarrow> single_valued (\\<langle>R\\<rangle>rel)\"\n    unfolding rel_def by refine_post\nend\n\ncontext al begin\n  definition rel_def_internal: \n    \"rel Re Ra \\<equiv> br \\<alpha> invar O \\<langle>\\<langle>Re,Ra\\<rangle> prod_rel\\<rangle>list_rel\"\n  lemma rel_def: \n    \"\\<langle>Re,Ra\\<rangle>rel \\<equiv> br \\<alpha> invar O \\<langle>\\<langle>Re,Ra\\<rangle> prod_rel\\<rangle>list_rel\" \n    by (simp add: rel_def_internal relAPP_def)\n    \n  lemma rel_id[simp]: \"\\<langle>Id,Id\\<rangle>rel = br \\<alpha> invar\" \n    by (simp add: rel_def)\n\n  lemma rel_sv[relator_props]: \n    \"\\<lbrakk>single_valued Re; single_valued Ra\\<rbrakk> \\<Longrightarrow> single_valued (\\<langle>Re,Ra\\<rangle>rel)\"\n    unfolding rel_def by refine_post\n\nend\n\ncontext prio begin\n  (* TODO: Fix that to use multiset_rel! *)\n  definition rel_def[simp]: \"rel \\<equiv> br \\<alpha> invar\"\n  lemma rel_sv: \"single_valued rel\" unfolding rel_def by refine_post\nend\n\ncontext uprio begin\n  definition rel_def_internal: \n    \"rel Re Ra \\<equiv> br \\<alpha> invar O (Re \\<rightarrow> \\<langle>Ra\\<rangle> option_rel)\"\n  lemma rel_def:\n    \"\\<langle>Re,Ra\\<rangle>rel \\<equiv> br \\<alpha> invar O (Re \\<rightarrow> \\<langle>Ra\\<rangle> option_rel)\" \n    by (simp add: rel_def_internal relAPP_def)\n    \n  lemma rel_id[simp]: \"\\<langle>Id,Id\\<rangle>rel = br \\<alpha> invar\" \n    by (simp add: rel_def)\n\n  lemma rel_sv[relator_props]: \n    \"\\<lbrakk>Range Re = UNIV; single_valued Ra\\<rbrakk> \\<Longrightarrow> single_valued (\\<langle>Re,Ra\\<rangle>rel)\"\n    unfolding rel_def by refine_post\n\nend\n*)"], ["", "setup \\<open>Revert_Abbrev.revert_abbrev \"Autoref_Binding_ICF.*.rel\"\\<close>"], ["", "(* TODO: Move *)"], ["", "lemma Collect_x_x_pairs_rel_image[simp]: \"{p. \\<exists>x. p = (x, x)}``x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {p. \\<exists>x. p = (x, x)} `` x = x", "by auto"], ["", "subsection \"Set\""], ["", "lemma (in set_empty) empty_autoref[autoref_rules]: \n  \"PREFER_id Rk \\<Longrightarrow> (empty (), {}) \\<in> \\<langle>Rk\\<rangle>rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PREFER_id Rk \\<Longrightarrow>\n    (empty (), {}) \\<in> \\<langle>Rk\\<rangle>rel", "by (simp add: br_def empty_correct)"], ["", "lemma (in set_memb) memb_autoref[autoref_rules]: \n  \"PREFER_id Rk \\<Longrightarrow> (memb,(\\<in>))\\<in>Rk\\<rightarrow>\\<langle>Rk\\<rangle>rel\\<rightarrow>Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PREFER_id Rk \\<Longrightarrow>\n    (memb, (\\<in>))\n    \\<in> Rk \\<rightarrow> \\<langle>Rk\\<rangle>rel \\<rightarrow> bool_rel", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rk = Id \\<Longrightarrow>\n    (memb, (\\<in>))\n    \\<in> Id \\<rightarrow> br \\<alpha> invar \\<rightarrow> bool_rel", "by (auto simp add: memb_correct br_def)"], ["", "lemma (in set_ins) ins_autoref[autoref_rules]: \n  \"PREFER_id Rk \\<Longrightarrow> (ins,Set.insert)\\<in>Rk\\<rightarrow>\\<langle>Rk\\<rangle>rel\\<rightarrow>\\<langle>Rk\\<rangle>rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PREFER_id Rk \\<Longrightarrow>\n    (ins, insert)\n    \\<in> Rk \\<rightarrow>\n          \\<langle>Rk\\<rangle>rel \\<rightarrow> \\<langle>Rk\\<rangle>rel", "by simp (auto simp add: ins_correct br_def)"], ["", "context set_ins_dj begin"], ["", "context begin"], ["", "interpretation autoref_syn"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma ins_dj_autoref[autoref_rules]: \n  assumes \"SIDE_PRECOND_OPT (x'\\<notin>s')\"\n  assumes \"PREFER_id Rk\"\n  assumes \"(x,x')\\<in>Rk\"\n  assumes \"(s,s')\\<in>\\<langle>Rk\\<rangle>rel\"\n  shows \"(ins_dj x s,(OP Set.insert ::: Rk \\<rightarrow> \\<langle>Rk\\<rangle>rel \\<rightarrow> \\<langle>Rk\\<rangle>rel)$x'$s')\\<in>\\<langle>Rk\\<rangle>rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ins_dj x s,\n     (OP insert :::\n      Rk \\<rightarrow>\n      \\<langle>Rk\\<rangle>rel \\<rightarrow> \\<langle>Rk\\<rangle>rel) $\n     x' $\n     s')\n    \\<in> \\<langle>Rk\\<rangle>rel", "using assms"], ["proof (prove)\nusing this:\n  SIDE_PRECOND_OPT (x' \\<notin> s')\n  PREFER_id Rk\n  (x, x') \\<in> Rk\n  (s, s') \\<in> \\<langle>Rk\\<rangle>rel\n\ngoal (1 subgoal):\n 1. (ins_dj x s,\n     (OP insert :::\n      Rk \\<rightarrow>\n      \\<langle>Rk\\<rangle>rel \\<rightarrow> \\<langle>Rk\\<rangle>rel) $\n     x' $\n     s')\n    \\<in> \\<langle>Rk\\<rangle>rel", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x' \\<notin> s'; Rk = Id; x = x';\n     (s, s') \\<in> br \\<alpha> invar\\<rbrakk>\n    \\<Longrightarrow> (ins_dj x' s, insert x' s') \\<in> br \\<alpha> invar", "apply (auto simp add: ins_dj_correct br_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "end"], ["", "lemma (in set_delete) delete_autoref[autoref_rules]: \n  \"PREFER_id Rk \\<Longrightarrow> (delete,op_set_delete)\\<in>Rk\\<rightarrow>\\<langle>Rk\\<rangle>rel\\<rightarrow>\\<langle>Rk\\<rangle>rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PREFER_id Rk \\<Longrightarrow>\n    (delete, op_set_delete)\n    \\<in> Rk \\<rightarrow>\n          \\<langle>Rk\\<rangle>rel \\<rightarrow> \\<langle>Rk\\<rangle>rel", "by simp (auto simp add: delete_correct op_set_delete_def br_def)"], ["", "lemma (in set_isEmpty) isEmpty_autoref[autoref_rules]: \n  \"PREFER_id Rk \\<Longrightarrow> (isEmpty,op_set_isEmpty) \\<in> \\<langle>Rk\\<rangle>rel\\<rightarrow>Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PREFER_id Rk \\<Longrightarrow>\n    (isEmpty, op_set_isEmpty)\n    \\<in> \\<langle>Rk\\<rangle>rel \\<rightarrow> bool_rel", "apply (simp add: br_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rk = Id \\<Longrightarrow>\n    (isEmpty, op_set_isEmpty)\n    \\<in> {(c, a). a = \\<alpha> c \\<and> invar c} \\<rightarrow> bool_rel", "apply (fastforce simp: isEmpty_correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in set_isSng) isSng_autoref[autoref_rules]: \n  \"PREFER_id Rk \\<Longrightarrow> (isSng,op_set_isSng) \\<in> \\<langle>Rk\\<rangle>rel\\<rightarrow>Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PREFER_id Rk \\<Longrightarrow>\n    (isSng, op_set_isSng)\n    \\<in> \\<langle>Rk\\<rangle>rel \\<rightarrow> bool_rel", "by simp\n    (auto simp add: isSng_correct op_set_isSng_def br_def card_Suc_eq)"], ["", "lemma (in set_ball) ball_autoref[autoref_rules]: \n  \"PREFER_id Rk \\<Longrightarrow> (ball,Set.Ball) \\<in> \\<langle>Rk\\<rangle>rel\\<rightarrow>(Rk\\<rightarrow>Id)\\<rightarrow>Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PREFER_id Rk \\<Longrightarrow>\n    (ball, Ball)\n    \\<in> \\<langle>Rk\\<rangle>rel \\<rightarrow>\n          (Rk \\<rightarrow> bool_rel) \\<rightarrow> bool_rel", "by simp (auto simp add: ball_correct fun_rel_def br_def)"], ["", "lemma (in set_bex) bex_autoref[autoref_rules]: \n  \"PREFER_id Rk \\<Longrightarrow> (bex,Set.Bex) \\<in> \\<langle>Rk\\<rangle>rel\\<rightarrow>(Rk\\<rightarrow>Id)\\<rightarrow>Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PREFER_id Rk \\<Longrightarrow>\n    (bex, Bex)\n    \\<in> \\<langle>Rk\\<rangle>rel \\<rightarrow>\n          (Rk \\<rightarrow> bool_rel) \\<rightarrow> bool_rel", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rk = Id \\<Longrightarrow>\n    (bex, Bex) \\<in> br \\<alpha> invar \\<rightarrow> Id", "apply (auto simp: bex_correct fun_rel_def br_def intro!: ext)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in set_size) size_autoref[autoref_rules]: \n  \"PREFER_id Rk \\<Longrightarrow> (size,card) \\<in> \\<langle>Rk\\<rangle>rel \\<rightarrow> Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PREFER_id Rk \\<Longrightarrow>\n    (size, card) \\<in> \\<langle>Rk\\<rangle>rel \\<rightarrow> nat_rel", "by simp (auto simp add: size_correct br_def)"], ["", "lemma (in set_size_abort) size_abort_autoref[autoref_rules]: \n  \"PREFER_id Rk \\<Longrightarrow> (size_abort,op_set_size_abort) \\<in> Id \\<rightarrow> \\<langle>Rk\\<rangle>rel \\<rightarrow> Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PREFER_id Rk \\<Longrightarrow>\n    (size_abort, op_set_size_abort)\n    \\<in> nat_rel \\<rightarrow>\n          \\<langle>Rk\\<rangle>rel \\<rightarrow> nat_rel", "by simp\n    (auto simp add: size_abort_correct op_set_size_abort_def br_def)"], ["", "lemma (in set_union) union_autoref[autoref_rules]: \n  \"PREFER_id Rk \\<Longrightarrow> (union,(\\<union>))\\<in>\\<langle>Rk\\<rangle>s1.rel\\<rightarrow>\\<langle>Rk\\<rangle>s2.rel\\<rightarrow>\\<langle>Rk\\<rangle>s3.rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PREFER_id Rk \\<Longrightarrow>\n    (union, (\\<union>))\n    \\<in> \\<langle>Rk\\<rangle>s1.rel \\<rightarrow>\n          \\<langle>Rk\\<rangle>s2.rel \\<rightarrow>\n          \\<langle>Rk\\<rangle>s3.rel", "by simp (auto simp add: union_correct br_def)"], ["", "context set_union_dj begin"], ["", "context begin"], ["", "interpretation autoref_syn"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma union_dj_autoref[autoref_rules]:\n  assumes \"PREFER_id Rk\"\n  assumes \"SIDE_PRECOND_OPT (a'\\<inter>b'={})\"\n  assumes \"(a,a')\\<in>\\<langle>Rk\\<rangle>s1.rel\"\n  assumes \"(b,b')\\<in>\\<langle>Rk\\<rangle>s2.rel\"\n  shows \"(union_dj a b,(OP (\\<union>) ::: \\<langle>Rk\\<rangle>s1.rel \\<rightarrow> \\<langle>Rk\\<rangle>s2.rel \\<rightarrow> \\<langle>Rk\\<rangle>s3.rel)$a'$b')\n    \\<in>\\<langle>Rk\\<rangle>s3.rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (union_dj a b,\n     (OP (\\<union>) :::\n      \\<langle>Rk\\<rangle>s1.rel \\<rightarrow>\n      \\<langle>Rk\\<rangle>s2.rel \\<rightarrow> \\<langle>Rk\\<rangle>s3.rel) $\n     a' $\n     b')\n    \\<in> \\<langle>Rk\\<rangle>s3.rel", "using assms"], ["proof (prove)\nusing this:\n  PREFER_id Rk\n  SIDE_PRECOND_OPT (a' \\<inter> b' = {})\n  (a, a') \\<in> \\<langle>Rk\\<rangle>s1.rel\n  (b, b') \\<in> \\<langle>Rk\\<rangle>s2.rel\n\ngoal (1 subgoal):\n 1. (union_dj a b,\n     (OP (\\<union>) :::\n      \\<langle>Rk\\<rangle>s1.rel \\<rightarrow>\n      \\<langle>Rk\\<rangle>s2.rel \\<rightarrow> \\<langle>Rk\\<rangle>s3.rel) $\n     a' $\n     b')\n    \\<in> \\<langle>Rk\\<rangle>s3.rel", "by simp (auto simp: union_dj_correct br_def)"], ["", "end"], ["", "end"], ["", "lemma (in set_diff) diff_autoref[autoref_rules]: \n  \"PREFER_id Rk \\<Longrightarrow> (diff,(-))\\<in>\\<langle>Rk\\<rangle>s1.rel\\<rightarrow>\\<langle>Rk\\<rangle>s2.rel\\<rightarrow>\\<langle>Rk\\<rangle>s1.rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PREFER_id Rk \\<Longrightarrow>\n    (diff, (-))\n    \\<in> \\<langle>Rk\\<rangle>s1.rel \\<rightarrow>\n          \\<langle>Rk\\<rangle>s2.rel \\<rightarrow>\n          \\<langle>Rk\\<rangle>s1.rel", "by simp (auto simp add: diff_correct br_def)"], ["", "lemma (in set_filter) filter_autoref[autoref_rules]: \n  \"PREFER_id Rk \\<Longrightarrow> (filter,op_set_filter)\\<in>(Rk \\<rightarrow> Id) \\<rightarrow> \\<langle>Rk\\<rangle>s1.rel\\<rightarrow>\\<langle>Rk\\<rangle>s2.rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PREFER_id Rk \\<Longrightarrow>\n    (filter, op_set_filter)\n    \\<in> (Rk \\<rightarrow> bool_rel) \\<rightarrow>\n          \\<langle>Rk\\<rangle>s1.rel \\<rightarrow>\n          \\<langle>Rk\\<rangle>s2.rel", "by simp (auto simp add: filter_correct op_set_filter_def fun_rel_def \n    br_def)"], ["", "lemma (in set_inter) inter_autoref[autoref_rules]: \n  \"PREFER_id Rk \\<Longrightarrow> (inter,(\\<inter>))\\<in>\\<langle>Rk\\<rangle>s1.rel\\<rightarrow>\\<langle>Rk\\<rangle>s2.rel\\<rightarrow>\\<langle>Rk\\<rangle>s3.rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PREFER_id Rk \\<Longrightarrow>\n    (inter, (\\<inter>))\n    \\<in> \\<langle>Rk\\<rangle>s1.rel \\<rightarrow>\n          \\<langle>Rk\\<rangle>s2.rel \\<rightarrow>\n          \\<langle>Rk\\<rangle>s3.rel", "by simp (auto simp add: inter_correct br_def)"], ["", "lemma (in set_subset) subset_autoref[autoref_rules]: \n  \"PREFER_id Rk \\<Longrightarrow> (subset,(\\<subseteq>))\\<in>\\<langle>Rk\\<rangle>s1.rel\\<rightarrow>\\<langle>Rk\\<rangle>s2.rel\\<rightarrow>Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PREFER_id Rk \\<Longrightarrow>\n    (subset, (\\<subseteq>))\n    \\<in> \\<langle>Rk\\<rangle>s1.rel \\<rightarrow>\n          \\<langle>Rk\\<rangle>s2.rel \\<rightarrow> bool_rel", "by simp (auto simp add: subset_correct br_def)"], ["", "lemma (in set_equal) equal_autoref[autoref_rules]: \n  \"PREFER_id Rk \\<Longrightarrow> (equal,(=))\\<in>\\<langle>Rk\\<rangle>s1.rel\\<rightarrow>\\<langle>Rk\\<rangle>s2.rel\\<rightarrow>Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PREFER_id Rk \\<Longrightarrow>\n    (equal, (=))\n    \\<in> \\<langle>Rk\\<rangle>s1.rel \\<rightarrow>\n          \\<langle>Rk\\<rangle>s2.rel \\<rightarrow> bool_rel", "by simp (auto simp add: equal_correct br_def)"], ["", "lemma (in set_disjoint) disjoint_autoref[autoref_rules]: \n  \"PREFER_id Rk \\<Longrightarrow> (disjoint,op_set_disjoint)\\<in>\\<langle>Rk\\<rangle>s1.rel\\<rightarrow>\\<langle>Rk\\<rangle>s2.rel\\<rightarrow>Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PREFER_id Rk \\<Longrightarrow>\n    (disjoint, op_set_disjoint)\n    \\<in> \\<langle>Rk\\<rangle>s1.rel \\<rightarrow>\n          \\<langle>Rk\\<rangle>s2.rel \\<rightarrow> bool_rel", "by simp (auto simp add: disjoint_correct op_set_disjoint_def br_def)"], ["", "lemma (in list_to_set) to_set_autoref[autoref_rules]: \n  \"PREFER_id Rk \\<Longrightarrow> (to_set,set)\\<in>\\<langle>Rk\\<rangle>list_rel \\<rightarrow> \\<langle>Rk\\<rangle>rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PREFER_id Rk \\<Longrightarrow>\n    (to_set, set)\n    \\<in> \\<langle>Rk\\<rangle>list_rel \\<rightarrow> \\<langle>Rk\\<rangle>rel", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rk = Id \\<Longrightarrow>\n    (to_set, set) \\<in> Id \\<rightarrow> br \\<alpha> invar", "apply (auto simp add: to_set_correct br_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "context set_sel' begin"], ["", "context begin"], ["", "interpretation autoref_syn"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma autoref_op_set_pick[autoref_rules]: \n  assumes \"SIDE_PRECOND (s'\\<noteq>{})\"\n  assumes \"PREFER_id Rk\"\n  assumes \"(s,s')\\<in>\\<langle>Rk\\<rangle>rel\"\n  shows \"(RETURN (the (sel' s (\\<lambda>_. True))), \n          (OP op_set_pick ::: \\<langle>Rk\\<rangle>rel \\<rightarrow> \\<langle>Rk\\<rangle>nres_rel) $ s')\n    \\<in> \\<langle>Rk\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN (the (sel' s (\\<lambda>_. True))),\n     (OP op_set_pick :::\n      \\<langle>Rk\\<rangle>rel \\<rightarrow> \\<langle>Rk\\<rangle>nres_rel) $\n     s')\n    \\<in> \\<langle>Rk\\<rangle>nres_rel", "using assms"], ["proof (prove)\nusing this:\n  SIDE_PRECOND (s' \\<noteq> {})\n  PREFER_id Rk\n  (s, s') \\<in> \\<langle>Rk\\<rangle>rel\n\ngoal (1 subgoal):\n 1. (RETURN (the (sel' s (\\<lambda>_. True))),\n     (OP op_set_pick :::\n      \\<langle>Rk\\<rangle>rel \\<rightarrow> \\<langle>Rk\\<rangle>nres_rel) $\n     s')\n    \\<in> \\<langle>Rk\\<rangle>nres_rel", "apply (clarsimp simp add: br_def nres_rel_def ex_in_conv[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>Rk = Id; x \\<in> \\<alpha> s; s' = \\<alpha> s;\n        invar s\\<rbrakk>\n       \\<Longrightarrow> the (sel' s (\\<lambda>_. True)) \\<in> \\<alpha> s", "apply (erule (1) sel'E[OF _ _ TrueI])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>Rk = Id; x \\<in> \\<alpha> s; s' = \\<alpha> s;\n        sel' s (\\<lambda>a. True) = Some xa; xa \\<in> \\<alpha> s;\n        True\\<rbrakk>\n       \\<Longrightarrow> the (sel' s (\\<lambda>_. True)) \\<in> \\<alpha> s", "apply (auto intro: RES_refine)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "end"], ["", "lemma (in poly_set_iteratei) proper[proper_it]:\n  \"proper_it' iteratei iteratei\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it' iteratei iteratei", "apply (rule proper_it'I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s. proper_it (iteratei s) (iteratei s)", "by (rule pi_iteratei)"], ["", "lemma (in poly_set_iteratei) autoref_iteratei[autoref_ga_rules]: \n  \"REL_IS_ID Rk \\<Longrightarrow> is_set_to_list Rk rel (it_to_list iteratei)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. REL_IS_ID Rk \\<Longrightarrow>\n    is_set_to_list Rk rel (it_to_list iteratei)", "unfolding is_set_to_list_def is_set_to_sorted_list_def it_to_list_def \n    it_to_sorted_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. REL_IS_ID Rk \\<Longrightarrow>\n    \\<forall>s s'.\n       (s, s') \\<in> \\<langle>Rk\\<rangle>rel \\<longrightarrow>\n       (\\<exists>l'.\n           (iterate s (\\<lambda>x l. l @ [x]) [], l')\n           \\<in> \\<langle>Rk\\<rangle>list_rel \\<and>\n           RETURN l'\n           \\<le> SPEC\n                  (\\<lambda>l.\n                      distinct l \\<and>\n                      s' = set l \\<and> sorted_wrt (\\<lambda>_ _. True) l))", "apply (simp add: br_def, intro allI impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>Rk = Id; invar s\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (iterate s (\\<lambda>x l. l @ [x]) []) \\<and>\n                         \\<alpha> s =\n                         set (iterate s (\\<lambda>x l. l @ [x]) [])", "apply (drule iteratei_correct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>Rk = Id; set_iterator (iteratei s) (\\<alpha> s)\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (iterate s (\\<lambda>x l. l @ [x]) []) \\<and>\n                         \\<alpha> s =\n                         set (iterate s (\\<lambda>x l. l @ [x]) [])", "unfolding set_iterator_def set_iterator_genord_foldli_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>Rk = Id;\n        \\<exists>l0.\n           distinct l0 \\<and>\n           \\<alpha> s = set l0 \\<and>\n           sorted_wrt (\\<lambda>_ _. True) l0 \\<and>\n           iteratei s = foldli l0\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (iterate s (\\<lambda>x l. l @ [x]) []) \\<and>\n                         \\<alpha> s =\n                         set (iterate s (\\<lambda>x l. l @ [x]) [])", "apply (elim exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s l0.\n       \\<lbrakk>Rk = Id;\n        distinct l0 \\<and>\n        \\<alpha> s = set l0 \\<and>\n        sorted_wrt (\\<lambda>_ _. True) l0 \\<and>\n        iteratei s = foldli l0\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (iterate s (\\<lambda>x l. l @ [x]) []) \\<and>\n                         \\<alpha> s =\n                         set (iterate s (\\<lambda>x l. l @ [x]) [])", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s l0.\n       \\<lbrakk>Rk = Id; distinct l0; \\<alpha> s = set l0;\n        iteratei s = foldli l0\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (iterate s (\\<lambda>x l. l @ [x]) []) \\<and>\n                         set l0 = set (iterate s (\\<lambda>x l. l @ [x]) [])", "apply (drule fun_cong[where x=\"\\<lambda>_::'x list. True\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s l0.\n       \\<lbrakk>Rk = Id; distinct l0; \\<alpha> s = set l0;\n        iterate s = foldli l0 (\\<lambda>_. True)\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (iterate s (\\<lambda>x l. l @ [x]) []) \\<and>\n                         set l0 = set (iterate s (\\<lambda>x l. l @ [x]) [])", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in poly_set_iterateoi) proper_o[proper_it]:\n  \"proper_it' iterateoi iterateoi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it' iterateoi iterateoi", "apply (rule proper_it'I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s. proper_it (iterateoi s) (iterateoi s)", "by (rule pi_iterateoi)"], ["", "lemma (in poly_set_iterateoi) autoref_iterateoi[autoref_ga_rules]: \n  \"REL_IS_ID Rk \\<Longrightarrow> \n    is_set_to_sorted_list (\\<le>) Rk rel (it_to_list iterateoi)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. REL_IS_ID Rk \\<Longrightarrow>\n    is_set_to_sorted_list (\\<le>) Rk rel (it_to_list iterateoi)", "unfolding is_set_to_sorted_list_def it_to_list_def it_to_sorted_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. REL_IS_ID Rk \\<Longrightarrow>\n    \\<forall>s s'.\n       (s, s') \\<in> \\<langle>Rk\\<rangle>rel \\<longrightarrow>\n       (\\<exists>l'.\n           (iterateo s (\\<lambda>x l. l @ [x]) [], l')\n           \\<in> \\<langle>Rk\\<rangle>list_rel \\<and>\n           RETURN l'\n           \\<le> SPEC\n                  (\\<lambda>l.\n                      distinct l \\<and>\n                      s' = set l \\<and> sorted_wrt (\\<le>) l))", "apply (simp add: br_def, intro allI impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>Rk = Id; invar s\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (iterateo s (\\<lambda>x l. l @ [x]) []) \\<and>\n                         \\<alpha> s =\n                         set (iterateo s (\\<lambda>x l. l @ [x]) []) \\<and>\n                         sorted_wrt (\\<le>)\n                          (iterateo s (\\<lambda>x l. l @ [x]) [])", "apply (drule iterateoi_correct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>Rk = Id;\n        set_iterator_linord (iterateoi s) (\\<alpha> s)\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (iterateo s (\\<lambda>x l. l @ [x]) []) \\<and>\n                         \\<alpha> s =\n                         set (iterateo s (\\<lambda>x l. l @ [x]) []) \\<and>\n                         sorted_wrt (\\<le>)\n                          (iterateo s (\\<lambda>x l. l @ [x]) [])", "unfolding set_iterator_linord_def set_iterator_genord_foldli_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>Rk = Id;\n        \\<exists>l0.\n           distinct l0 \\<and>\n           \\<alpha> s = set l0 \\<and>\n           sorted_wrt (\\<le>) l0 \\<and> iterateoi s = foldli l0\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (iterateo s (\\<lambda>x l. l @ [x]) []) \\<and>\n                         \\<alpha> s =\n                         set (iterateo s (\\<lambda>x l. l @ [x]) []) \\<and>\n                         sorted_wrt (\\<le>)\n                          (iterateo s (\\<lambda>x l. l @ [x]) [])", "apply (elim exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s l0.\n       \\<lbrakk>Rk = Id;\n        distinct l0 \\<and>\n        \\<alpha> s = set l0 \\<and>\n        sorted_wrt (\\<le>) l0 \\<and> iterateoi s = foldli l0\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (iterateo s (\\<lambda>x l. l @ [x]) []) \\<and>\n                         \\<alpha> s =\n                         set (iterateo s (\\<lambda>x l. l @ [x]) []) \\<and>\n                         sorted_wrt (\\<le>)\n                          (iterateo s (\\<lambda>x l. l @ [x]) [])", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s l0.\n       \\<lbrakk>Rk = Id; distinct l0; \\<alpha> s = set l0;\n        sorted_wrt (\\<le>) l0; iterateoi s = foldli l0\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (iterateo s (\\<lambda>x l. l @ [x]) []) \\<and>\n                         set l0 =\n                         set (iterateo s (\\<lambda>x l. l @ [x]) []) \\<and>\n                         sorted_wrt (\\<le>)\n                          (iterateo s (\\<lambda>x l. l @ [x]) [])", "apply (drule fun_cong[where x=\"\\<lambda>_::'x list. True\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s l0.\n       \\<lbrakk>Rk = Id; distinct l0; \\<alpha> s = set l0;\n        sorted_wrt (\\<le>) l0;\n        iterateo s = foldli l0 (\\<lambda>_. True)\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (iterateo s (\\<lambda>x l. l @ [x]) []) \\<and>\n                         set l0 =\n                         set (iterateo s (\\<lambda>x l. l @ [x]) []) \\<and>\n                         sorted_wrt (\\<le>)\n                          (iterateo s (\\<lambda>x l. l @ [x]) [])", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in poly_set_rev_iterateoi) autoref_rev_iterateoi[autoref_ga_rules]: \n  \"REL_IS_ID Rk \\<Longrightarrow> \n    is_set_to_sorted_list (\\<ge>) Rk rel (it_to_list rev_iterateoi)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. REL_IS_ID Rk \\<Longrightarrow>\n    is_set_to_sorted_list (\\<lambda>x y. y \\<le> x) Rk rel\n     (it_to_list reverse_iterateoi)", "unfolding is_set_to_sorted_list_def it_to_list_def it_to_sorted_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. REL_IS_ID Rk \\<Longrightarrow>\n    \\<forall>s s'.\n       (s, s') \\<in> \\<langle>Rk\\<rangle>rel \\<longrightarrow>\n       (\\<exists>l'.\n           (reverse_iterateo s (\\<lambda>x l. l @ [x]) [], l')\n           \\<in> \\<langle>Rk\\<rangle>list_rel \\<and>\n           RETURN l'\n           \\<le> SPEC\n                  (\\<lambda>l.\n                      distinct l \\<and>\n                      s' = set l \\<and>\n                      sorted_wrt (\\<lambda>x y. y \\<le> x) l))", "apply (simp add: br_def, intro allI impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>Rk = Id; invar s\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (reverse_iterateo s (\\<lambda>x l. l @ [x])\n                            []) \\<and>\n                         \\<alpha> s =\n                         set (reverse_iterateo s (\\<lambda>x l. l @ [x])\n                               []) \\<and>\n                         sorted\n                          (rev (reverse_iterateo s (\\<lambda>x l. l @ [x])\n                                 []))", "apply (drule rev_iterateoi_correct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>Rk = Id;\n        set_iterator_rev_linord (reverse_iterateoi s) (\\<alpha> s)\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (reverse_iterateo s (\\<lambda>x l. l @ [x])\n                            []) \\<and>\n                         \\<alpha> s =\n                         set (reverse_iterateo s (\\<lambda>x l. l @ [x])\n                               []) \\<and>\n                         sorted\n                          (rev (reverse_iterateo s (\\<lambda>x l. l @ [x])\n                                 []))", "unfolding set_iterator_rev_linord_def set_iterator_genord_foldli_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>Rk = Id;\n        \\<exists>l0.\n           distinct l0 \\<and>\n           \\<alpha> s = set l0 \\<and>\n           sorted_wrt (\\<lambda>x y. y \\<le> x) l0 \\<and>\n           reverse_iterateoi s = foldli l0\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (reverse_iterateo s (\\<lambda>x l. l @ [x])\n                            []) \\<and>\n                         \\<alpha> s =\n                         set (reverse_iterateo s (\\<lambda>x l. l @ [x])\n                               []) \\<and>\n                         sorted\n                          (rev (reverse_iterateo s (\\<lambda>x l. l @ [x])\n                                 []))", "apply (elim exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s l0.\n       \\<lbrakk>Rk = Id;\n        distinct l0 \\<and>\n        \\<alpha> s = set l0 \\<and>\n        sorted_wrt (\\<lambda>x y. y \\<le> x) l0 \\<and>\n        reverse_iterateoi s = foldli l0\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (reverse_iterateo s (\\<lambda>x l. l @ [x])\n                            []) \\<and>\n                         \\<alpha> s =\n                         set (reverse_iterateo s (\\<lambda>x l. l @ [x])\n                               []) \\<and>\n                         sorted\n                          (rev (reverse_iterateo s (\\<lambda>x l. l @ [x])\n                                 []))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s l0.\n       \\<lbrakk>Rk = Id; distinct l0; \\<alpha> s = set l0; sorted (rev l0);\n        reverse_iterateoi s = foldli l0\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (reverse_iterateo s (\\<lambda>x l. l @ [x])\n                            []) \\<and>\n                         set l0 =\n                         set (reverse_iterateo s (\\<lambda>x l. l @ [x])\n                               []) \\<and>\n                         sorted\n                          (rev (reverse_iterateo s (\\<lambda>x l. l @ [x])\n                                 []))", "apply (drule fun_cong[where x=\"\\<lambda>_::'x list. True\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s l0.\n       \\<lbrakk>Rk = Id; distinct l0; \\<alpha> s = set l0; sorted (rev l0);\n        reverse_iterateo s = foldli l0 (\\<lambda>_. True)\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (reverse_iterateo s (\\<lambda>x l. l @ [x])\n                            []) \\<and>\n                         set l0 =\n                         set (reverse_iterateo s (\\<lambda>x l. l @ [x])\n                               []) \\<and>\n                         sorted\n                          (rev (reverse_iterateo s (\\<lambda>x l. l @ [x])\n                                 []))", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in poly_set_rev_iterateoi) proper_ro[proper_it]:\n  \"proper_it' rev_iterateoi rev_iterateoi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it' reverse_iterateoi reverse_iterateoi", "apply (rule proper_it'I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s. proper_it (reverse_iterateoi s) (reverse_iterateoi s)", "by (rule pi_rev_iterateoi)"], ["", "subsection \"Map\""], ["", "lemma (in map) rel_alt: \"\\<langle>Id,Rv\\<rangle>rel = \n  { (c,a). \\<forall>x. (\\<alpha> c x,a x)\\<in>\\<langle>Rv\\<rangle>option_rel \\<and> invar c }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>Id, Rv\\<rangle>rel =\n    {(c, a).\n     \\<forall>x.\n        (\\<alpha> c x, a x) \\<in> \\<langle>Rv\\<rangle>option_rel \\<and>\n        invar c}", "by (auto simp: rel_def br_def dest: fun_relD)"], ["", "lemma (in map_empty) empty_autoref[autoref_rules]: \n  \"PREFER_id Rk \\<Longrightarrow> (empty (),op_map_empty)\\<in>\\<langle>Rk,Rv\\<rangle>rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PREFER_id Rk \\<Longrightarrow>\n    (empty (), op_map_empty) \\<in> \\<langle>Rk, Rv\\<rangle>rel", "by (auto simp: empty_correct rel_alt)"], ["", "lemma (in map_lookup) lookup_autoref[autoref_rules]: \n  \"PREFER_id Rk \\<Longrightarrow> (lookup,op_map_lookup)\\<in>Rk\\<rightarrow>\\<langle>Rk,Rv\\<rangle>rel\\<rightarrow>\\<langle>Rv\\<rangle>option_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PREFER_id Rk \\<Longrightarrow>\n    (lookup, op_map_lookup)\n    \\<in> Rk \\<rightarrow>\n          \\<langle>Rk, Rv\\<rangle>rel \\<rightarrow>\n          \\<langle>Rv\\<rangle>option_rel", "apply (intro fun_relI option_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>PREFER_id Rk; (a, a') \\<in> Rk;\n        (aa, a'a) \\<in> \\<langle>Rk, Rv\\<rangle>rel\\<rbrakk>\n       \\<Longrightarrow> (lookup a aa, op_map_lookup a' a'a)\n                         \\<in> \\<langle>Rv\\<rangle>option_rel", "apply (auto simp: lookup_correct rel_alt\n    dest: fun_relD2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in map_update) update_autoref[autoref_rules]: \n  \"PREFER_id Rk \\<Longrightarrow> (update,op_map_update)\\<in>Rk\\<rightarrow>Rv\\<rightarrow>\\<langle>Rk,Rv\\<rangle>rel\\<rightarrow>\\<langle>Rk,Rv\\<rangle>rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PREFER_id Rk \\<Longrightarrow>\n    (update, op_map_update)\n    \\<in> Rk \\<rightarrow>\n          Rv \\<rightarrow>\n          \\<langle>Rk, Rv\\<rangle>rel \\<rightarrow> \\<langle>Rk,\n          Rv\\<rangle>rel", "apply (intro fun_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>PREFER_id Rk; (a, a') \\<in> Rk; (aa, a'a) \\<in> Rv;\n        (ab, a'b) \\<in> \\<langle>Rk, Rv\\<rangle>rel\\<rbrakk>\n       \\<Longrightarrow> (update a aa ab, op_map_update a' a'a a'b)\n                         \\<in> \\<langle>Rk, Rv\\<rangle>rel", "apply (simp add: update_correct rel_alt)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "context map_update_dj begin"], ["", "context begin"], ["", "interpretation autoref_syn"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma update_dj_autoref[autoref_rules]: \n  assumes \"SIDE_PRECOND_OPT (k'\\<notin>dom m')\"\n  assumes \"PREFER_id Rk\"\n  assumes \"(k,k')\\<in>Rk\"\n  assumes \"(v,v')\\<in>Rv\"\n  assumes \"(m,m')\\<in>\\<langle>Rk,Rv\\<rangle>rel\"\n  shows \"(update_dj k v m,\n    (OP op_map_update ::: Rk \\<rightarrow> Rv \\<rightarrow> \\<langle>Rk,Rv\\<rangle>rel \\<rightarrow> \\<langle>Rk,Rv\\<rangle>rel)$k'$v'$m'\n  )\\<in>\\<langle>Rk,Rv\\<rangle>rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (update_dj k v m,\n     (OP op_map_update :::\n      Rk \\<rightarrow>\n      Rv \\<rightarrow>\n      \\<langle>Rk, Rv\\<rangle>rel \\<rightarrow> \\<langle>Rk,\n      Rv\\<rangle>rel) $\n     k' $\n     v' $\n     m')\n    \\<in> \\<langle>Rk, Rv\\<rangle>rel", "using assms"], ["proof (prove)\nusing this:\n  SIDE_PRECOND_OPT (k' \\<notin> dom m')\n  PREFER_id Rk\n  (k, k') \\<in> Rk\n  (v, v') \\<in> Rv\n  (m, m') \\<in> \\<langle>Rk, Rv\\<rangle>rel\n\ngoal (1 subgoal):\n 1. (update_dj k v m,\n     (OP op_map_update :::\n      Rk \\<rightarrow>\n      Rv \\<rightarrow>\n      \\<langle>Rk, Rv\\<rangle>rel \\<rightarrow> \\<langle>Rk,\n      Rv\\<rangle>rel) $\n     k' $\n     v' $\n     m')\n    \\<in> \\<langle>Rk, Rv\\<rangle>rel", "apply (subgoal_tac \"k\\<notin>dom (\\<alpha> m)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>SIDE_PRECOND_OPT (k' \\<notin> dom m'); PREFER_id Rk;\n     (k, k') \\<in> Rk; (v, v') \\<in> Rv;\n     (m, m') \\<in> \\<langle>Rk, Rv\\<rangle>rel;\n     k \\<notin> dom (\\<alpha> m)\\<rbrakk>\n    \\<Longrightarrow> (update_dj k v m,\n                       (OP op_map_update :::\n                        Rk \\<rightarrow>\n                        Rv \\<rightarrow>\n                        \\<langle>Rk, Rv\\<rangle>rel \\<rightarrow>\n                        \\<langle>Rk, Rv\\<rangle>rel) $\n                       k' $\n                       v' $\n                       m')\n                      \\<in> \\<langle>Rk, Rv\\<rangle>rel\n 2. \\<lbrakk>SIDE_PRECOND_OPT (k' \\<notin> dom m'); PREFER_id Rk;\n     (k, k') \\<in> Rk; (v, v') \\<in> Rv;\n     (m, m') \\<in> \\<langle>Rk, Rv\\<rangle>rel\\<rbrakk>\n    \\<Longrightarrow> k \\<notin> dom (\\<alpha> m)", "apply (simp add: update_dj_correct rel_alt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>SIDE_PRECOND_OPT (k' \\<notin> dom m'); PREFER_id Rk;\n     (k, k') \\<in> Rk; (v, v') \\<in> Rv;\n     (m, m') \\<in> \\<langle>Rk, Rv\\<rangle>rel\\<rbrakk>\n    \\<Longrightarrow> k \\<notin> dom (\\<alpha> m)", "apply (auto simp add: rel_alt option_rel_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>Rk = Id; k = k'; (v, v') \\<in> Rv;\n        \\<forall>x.\n           \\<alpha> m x = None \\<and> m' x = None \\<or>\n           (\\<exists>a.\n               \\<alpha> m x = Some a \\<and>\n               (\\<exists>a'. m' x = Some a' \\<and> (a, a') \\<in> Rv));\n        invar m; m' k' = None; \\<alpha> m k' = Some y\\<rbrakk>\n       \\<Longrightarrow> False", "apply (metis option.simps(3))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "end"], ["", "lemma (in map_delete) delete_autoref[autoref_rules]: \n  \"PREFER_id Rk \\<Longrightarrow> (delete,op_map_delete)\\<in>Rk\\<rightarrow>\\<langle>Rk,Rv\\<rangle>rel\\<rightarrow>\\<langle>Rk,Rv\\<rangle>rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PREFER_id Rk \\<Longrightarrow>\n    (delete, op_map_delete)\n    \\<in> Rk \\<rightarrow>\n          \\<langle>Rk, Rv\\<rangle>rel \\<rightarrow> \\<langle>Rk,\n          Rv\\<rangle>rel", "apply (intro fun_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>PREFER_id Rk; (a, a') \\<in> Rk;\n        (aa, a'a) \\<in> \\<langle>Rk, Rv\\<rangle>rel\\<rbrakk>\n       \\<Longrightarrow> (delete a aa, op_map_delete a' a'a)\n                         \\<in> \\<langle>Rk, Rv\\<rangle>rel", "apply (simp add: delete_correct restrict_map_def rel_alt)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in map_restrict) restrict_autoref[autoref_rules]: \n  \"PREFER_id Rk \\<Longrightarrow> \n    (restrict,op_map_restrict) \n    \\<in> (\\<langle>Rk,Rv\\<rangle>prod_rel \\<rightarrow> Id) \\<rightarrow> \\<langle>Rk,Rv\\<rangle>m1.rel \\<rightarrow> \\<langle>Rk,Rv\\<rangle>m2.rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PREFER_id Rk \\<Longrightarrow>\n    (restrict, op_map_restrict)\n    \\<in> (Rk \\<times>\\<^sub>r Rv \\<rightarrow> bool_rel) \\<rightarrow>\n          \\<langle>Rk, Rv\\<rangle>m1.rel \\<rightarrow> \\<langle>Rk,\n          Rv\\<rangle>m2.rel", "apply (intro fun_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>PREFER_id Rk;\n        (a, a') \\<in> Rk \\<times>\\<^sub>r Rv \\<rightarrow> bool_rel;\n        (aa, a'a) \\<in> \\<langle>Rk, Rv\\<rangle>m1.rel\\<rbrakk>\n       \\<Longrightarrow> (restrict a aa, op_map_restrict a' a'a)\n                         \\<in> \\<langle>Rk, Rv\\<rangle>m2.rel", "apply (simp add: restrict_correct br_comp_alt m1.rel_def m2.rel_def )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>Rk = Id;\n        (a, a') \\<in> Id \\<times>\\<^sub>r Rv \\<rightarrow> bool_rel;\n        invar1 aa \\<and>\n        (\\<alpha>1 aa, a'a)\n        \\<in> Id \\<rightarrow> \\<langle>Rv\\<rangle>option_rel\\<rbrakk>\n       \\<Longrightarrow> (\\<alpha>1 aa |`\n                          {k. \\<exists>v.\n                                 \\<alpha>1 aa k = Some v \\<and> a (k, v)},\n                          a'a |` {k \\<in> dom a'a. a' (k, the (a'a k))})\n                         \\<in> Id \\<rightarrow>\n                               \\<langle>Rv\\<rangle>option_rel", "apply (intro fun_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>Rk = Id;\n        (a, a') \\<in> Id \\<times>\\<^sub>r Rv \\<rightarrow> bool_rel;\n        invar1 aa \\<and>\n        (\\<alpha>1 aa, a'a)\n        \\<in> Id \\<rightarrow> \\<langle>Rv\\<rangle>option_rel;\n        (ab, a'b) \\<in> Id\\<rbrakk>\n       \\<Longrightarrow> ((\\<alpha>1 aa |`\n                           {k. \\<exists>v.\n                                  \\<alpha>1 aa k = Some v \\<and> a (k, v)})\n                           ab,\n                          (a'a |` {k \\<in> dom a'a. a' (k, the (a'a k))})\n                           a'b)\n                         \\<in> \\<langle>Rv\\<rangle>option_rel", "apply (auto simp: restrict_map_def split: if_split_asm)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a a' aa a'a a'b v y.\n       \\<lbrakk>Rk = Id;\n        (a, a') \\<in> Id \\<times>\\<^sub>r Rv \\<rightarrow> bool_rel;\n        invar1 aa;\n        (\\<alpha>1 aa, a'a)\n        \\<in> Id \\<rightarrow> \\<langle>Rv\\<rangle>option_rel;\n        \\<alpha>1 aa a'b = Some v; a (a'b, v); a' (a'b, y);\n        a'a a'b = Some y\\<rbrakk>\n       \\<Longrightarrow> (v, y) \\<in> Rv\n 2. \\<And>a a' aa a'a a'b v.\n       \\<lbrakk>Rk = Id;\n        (a, a') \\<in> Id \\<times>\\<^sub>r Rv \\<rightarrow> bool_rel;\n        invar1 aa;\n        (\\<alpha>1 aa, a'a)\n        \\<in> Id \\<rightarrow> \\<langle>Rv\\<rangle>option_rel;\n        a (a'b, v); \\<alpha>1 aa a'b = Some v\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. a'a a'b = Some y\n 3. \\<And>a a' aa a'a a'b v.\n       \\<lbrakk>Rk = Id;\n        (a, a') \\<in> Id \\<times>\\<^sub>r Rv \\<rightarrow> bool_rel;\n        invar1 aa;\n        (\\<alpha>1 aa, a'a)\n        \\<in> Id \\<rightarrow> \\<langle>Rv\\<rangle>option_rel;\n        \\<alpha>1 aa a'b = Some v; a (a'b, v);\n        \\<not> a' (a'b, the (a'a a'b))\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a a' aa a'a a'b y.\n       \\<lbrakk>Rk = Id;\n        (a, a') \\<in> Id \\<times>\\<^sub>r Rv \\<rightarrow> bool_rel;\n        invar1 aa;\n        (\\<alpha>1 aa, a'a)\n        \\<in> Id \\<rightarrow> \\<langle>Rv\\<rangle>option_rel;\n        \\<forall>v.\n           \\<alpha>1 aa a'b = Some v \\<longrightarrow> \\<not> a (a'b, v);\n        a' (a'b, y); a'a a'b = Some y\\<rbrakk>\n       \\<Longrightarrow> False", "apply (drule (1) fun_relD1)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a a' aa a'a a'b v y.\n       \\<lbrakk>Rk = Id;\n        (a, a') \\<in> Id \\<times>\\<^sub>r Rv \\<rightarrow> bool_rel;\n        invar1 aa; \\<alpha>1 aa a'b = Some v; a (a'b, v); a' (a'b, y);\n        a'a a'b = Some y;\n        \\<forall>x'.\n           (a'b, x') \\<in> Id \\<longrightarrow>\n           (Some v, a'a x') \\<in> \\<langle>Rv\\<rangle>option_rel\\<rbrakk>\n       \\<Longrightarrow> (v, y) \\<in> Rv\n 2. \\<And>a a' aa a'a a'b v.\n       \\<lbrakk>Rk = Id;\n        (a, a') \\<in> Id \\<times>\\<^sub>r Rv \\<rightarrow> bool_rel;\n        invar1 aa;\n        (\\<alpha>1 aa, a'a)\n        \\<in> Id \\<rightarrow> \\<langle>Rv\\<rangle>option_rel;\n        a (a'b, v); \\<alpha>1 aa a'b = Some v\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. a'a a'b = Some y\n 3. \\<And>a a' aa a'a a'b v.\n       \\<lbrakk>Rk = Id;\n        (a, a') \\<in> Id \\<times>\\<^sub>r Rv \\<rightarrow> bool_rel;\n        invar1 aa;\n        (\\<alpha>1 aa, a'a)\n        \\<in> Id \\<rightarrow> \\<langle>Rv\\<rangle>option_rel;\n        \\<alpha>1 aa a'b = Some v; a (a'b, v);\n        \\<not> a' (a'b, the (a'a a'b))\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a a' aa a'a a'b y.\n       \\<lbrakk>Rk = Id;\n        (a, a') \\<in> Id \\<times>\\<^sub>r Rv \\<rightarrow> bool_rel;\n        invar1 aa;\n        (\\<alpha>1 aa, a'a)\n        \\<in> Id \\<rightarrow> \\<langle>Rv\\<rangle>option_rel;\n        \\<forall>v.\n           \\<alpha>1 aa a'b = Some v \\<longrightarrow> \\<not> a (a'b, v);\n        a' (a'b, y); a'a a'b = Some y\\<rbrakk>\n       \\<Longrightarrow> False", "apply (auto simp: option_rel_def) []"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a a' aa a'a a'b v.\n       \\<lbrakk>Rk = Id;\n        (a, a') \\<in> Id \\<times>\\<^sub>r Rv \\<rightarrow> bool_rel;\n        invar1 aa;\n        (\\<alpha>1 aa, a'a)\n        \\<in> Id \\<rightarrow> \\<langle>Rv\\<rangle>option_rel;\n        a (a'b, v); \\<alpha>1 aa a'b = Some v\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. a'a a'b = Some y\n 2. \\<And>a a' aa a'a a'b v.\n       \\<lbrakk>Rk = Id;\n        (a, a') \\<in> Id \\<times>\\<^sub>r Rv \\<rightarrow> bool_rel;\n        invar1 aa;\n        (\\<alpha>1 aa, a'a)\n        \\<in> Id \\<rightarrow> \\<langle>Rv\\<rangle>option_rel;\n        \\<alpha>1 aa a'b = Some v; a (a'b, v);\n        \\<not> a' (a'b, the (a'a a'b))\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a a' aa a'a a'b y.\n       \\<lbrakk>Rk = Id;\n        (a, a') \\<in> Id \\<times>\\<^sub>r Rv \\<rightarrow> bool_rel;\n        invar1 aa;\n        (\\<alpha>1 aa, a'a)\n        \\<in> Id \\<rightarrow> \\<langle>Rv\\<rangle>option_rel;\n        \\<forall>v.\n           \\<alpha>1 aa a'b = Some v \\<longrightarrow> \\<not> a (a'b, v);\n        a' (a'b, y); a'a a'b = Some y\\<rbrakk>\n       \\<Longrightarrow> False", "apply (drule (1) fun_relD1)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a a' aa a'a a'b v.\n       \\<lbrakk>Rk = Id;\n        (a, a') \\<in> Id \\<times>\\<^sub>r Rv \\<rightarrow> bool_rel;\n        invar1 aa; a (a'b, v); \\<alpha>1 aa a'b = Some v;\n        \\<forall>x'.\n           (a'b, x') \\<in> Id \\<longrightarrow>\n           (Some v, a'a x') \\<in> \\<langle>Rv\\<rangle>option_rel\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. a'a a'b = Some y\n 2. \\<And>a a' aa a'a a'b v.\n       \\<lbrakk>Rk = Id;\n        (a, a') \\<in> Id \\<times>\\<^sub>r Rv \\<rightarrow> bool_rel;\n        invar1 aa;\n        (\\<alpha>1 aa, a'a)\n        \\<in> Id \\<rightarrow> \\<langle>Rv\\<rangle>option_rel;\n        \\<alpha>1 aa a'b = Some v; a (a'b, v);\n        \\<not> a' (a'b, the (a'a a'b))\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a a' aa a'a a'b y.\n       \\<lbrakk>Rk = Id;\n        (a, a') \\<in> Id \\<times>\\<^sub>r Rv \\<rightarrow> bool_rel;\n        invar1 aa;\n        (\\<alpha>1 aa, a'a)\n        \\<in> Id \\<rightarrow> \\<langle>Rv\\<rangle>option_rel;\n        \\<forall>v.\n           \\<alpha>1 aa a'b = Some v \\<longrightarrow> \\<not> a (a'b, v);\n        a' (a'b, y); a'a a'b = Some y\\<rbrakk>\n       \\<Longrightarrow> False", "apply (auto simp: option_rel_def) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a a' aa a'a a'b v.\n       \\<lbrakk>Rk = Id;\n        (a, a') \\<in> Id \\<times>\\<^sub>r Rv \\<rightarrow> bool_rel;\n        invar1 aa;\n        (\\<alpha>1 aa, a'a)\n        \\<in> Id \\<rightarrow> \\<langle>Rv\\<rangle>option_rel;\n        \\<alpha>1 aa a'b = Some v; a (a'b, v);\n        \\<not> a' (a'b, the (a'a a'b))\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a a' aa a'a a'b y.\n       \\<lbrakk>Rk = Id;\n        (a, a') \\<in> Id \\<times>\\<^sub>r Rv \\<rightarrow> bool_rel;\n        invar1 aa;\n        (\\<alpha>1 aa, a'a)\n        \\<in> Id \\<rightarrow> \\<langle>Rv\\<rangle>option_rel;\n        \\<forall>v.\n           \\<alpha>1 aa a'b = Some v \\<longrightarrow> \\<not> a (a'b, v);\n        a' (a'b, y); a'a a'b = Some y\\<rbrakk>\n       \\<Longrightarrow> False", "apply (drule (1) fun_relD1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a a' aa a'a a'b v.\n       \\<lbrakk>Rk = Id;\n        (a, a') \\<in> Id \\<times>\\<^sub>r Rv \\<rightarrow> bool_rel;\n        invar1 aa; \\<alpha>1 aa a'b = Some v; a (a'b, v);\n        \\<not> a' (a'b, the (a'a a'b));\n        \\<forall>x'.\n           (a'b, x') \\<in> Id \\<longrightarrow>\n           (Some v, a'a x') \\<in> \\<langle>Rv\\<rangle>option_rel\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a a' aa a'a a'b y.\n       \\<lbrakk>Rk = Id;\n        (a, a') \\<in> Id \\<times>\\<^sub>r Rv \\<rightarrow> bool_rel;\n        invar1 aa;\n        (\\<alpha>1 aa, a'a)\n        \\<in> Id \\<rightarrow> \\<langle>Rv\\<rangle>option_rel;\n        \\<forall>v.\n           \\<alpha>1 aa a'b = Some v \\<longrightarrow> \\<not> a (a'b, v);\n        a' (a'b, y); a'a a'b = Some y\\<rbrakk>\n       \\<Longrightarrow> False", "apply (auto simp: option_rel_def prod_rel_def fun_rel_def) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a a'b y.\n       \\<lbrakk>Rk = Id;\n        (a, a') \\<in> Id \\<times>\\<^sub>r Rv \\<rightarrow> bool_rel;\n        invar1 aa;\n        (\\<alpha>1 aa, a'a)\n        \\<in> Id \\<rightarrow> \\<langle>Rv\\<rangle>option_rel;\n        \\<forall>v.\n           \\<alpha>1 aa a'b = Some v \\<longrightarrow> \\<not> a (a'b, v);\n        a' (a'b, y); a'a a'b = Some y\\<rbrakk>\n       \\<Longrightarrow> False", "apply (drule (1) fun_relD2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a a'b y.\n       \\<lbrakk>Rk = Id;\n        (a, a') \\<in> Id \\<times>\\<^sub>r Rv \\<rightarrow> bool_rel;\n        invar1 aa;\n        \\<forall>v.\n           \\<alpha>1 aa a'b = Some v \\<longrightarrow> \\<not> a (a'b, v);\n        a' (a'b, y); a'a a'b = Some y;\n        \\<forall>x.\n           (x, a'b) \\<in> Id \\<longrightarrow>\n           (\\<alpha>1 aa x, Some y)\n           \\<in> \\<langle>Rv\\<rangle>option_rel\\<rbrakk>\n       \\<Longrightarrow> False", "apply (auto simp: option_rel_def prod_rel_def fun_rel_def) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in map_add) add_autoref[autoref_rules]: \n  \"PREFER_id Rk \\<Longrightarrow> (add,(++))\\<in>\\<langle>Rk,Rv\\<rangle>rel\\<rightarrow>\\<langle>Rk,Rv\\<rangle>rel\\<rightarrow>\\<langle>Rk,Rv\\<rangle>rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PREFER_id Rk \\<Longrightarrow>\n    (add, (++))\n    \\<in> \\<langle>Rk, Rv\\<rangle>rel \\<rightarrow>\n          \\<langle>Rk, Rv\\<rangle>rel \\<rightarrow> \\<langle>Rk,\n          Rv\\<rangle>rel", "apply (auto simp add: add_correct rel_alt Map.map_add_def\n    split: option.split)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a a' aa a'a x x2.\n       \\<lbrakk>Rk = Id;\n        \\<forall>x.\n           (\\<alpha> a x, a' x) \\<in> \\<langle>Rv\\<rangle>option_rel;\n        invar a;\n        \\<forall>x.\n           (\\<alpha> aa x, a'a x) \\<in> \\<langle>Rv\\<rangle>option_rel;\n        invar aa; \\<alpha> aa x = None; a'a x = Some x2\\<rbrakk>\n       \\<Longrightarrow> (\\<alpha> a x, Some x2)\n                         \\<in> \\<langle>Rv\\<rangle>option_rel\n 2. \\<And>a a' aa a'a x x2.\n       \\<lbrakk>Rk = Id;\n        \\<forall>x.\n           (\\<alpha> a x, a' x) \\<in> \\<langle>Rv\\<rangle>option_rel;\n        invar a;\n        \\<forall>x.\n           (\\<alpha> aa x, a'a x) \\<in> \\<langle>Rv\\<rangle>option_rel;\n        invar aa; \\<alpha> aa x = Some x2; a'a x = None\\<rbrakk>\n       \\<Longrightarrow> (Some x2, a' x)\n                         \\<in> \\<langle>Rv\\<rangle>option_rel\n 3. \\<And>a a' aa a'a x x2 x2a.\n       \\<lbrakk>Rk = Id;\n        \\<forall>x.\n           (\\<alpha> a x, a' x) \\<in> \\<langle>Rv\\<rangle>option_rel;\n        invar a;\n        \\<forall>x.\n           (\\<alpha> aa x, a'a x) \\<in> \\<langle>Rv\\<rangle>option_rel;\n        invar aa; \\<alpha> aa x = Some x2; a'a x = Some x2a\\<rbrakk>\n       \\<Longrightarrow> (x2, x2a) \\<in> Rv", "apply (drule_tac x=x in spec)+"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a a' aa a'a x x2.\n       \\<lbrakk>Rk = Id; invar a; invar aa; \\<alpha> aa x = None;\n        a'a x = Some x2;\n        (\\<alpha> a x, a' x) \\<in> \\<langle>Rv\\<rangle>option_rel;\n        (\\<alpha> aa x, a'a x) \\<in> \\<langle>Rv\\<rangle>option_rel\\<rbrakk>\n       \\<Longrightarrow> (\\<alpha> a x, Some x2)\n                         \\<in> \\<langle>Rv\\<rangle>option_rel\n 2. \\<And>a a' aa a'a x x2.\n       \\<lbrakk>Rk = Id;\n        \\<forall>x.\n           (\\<alpha> a x, a' x) \\<in> \\<langle>Rv\\<rangle>option_rel;\n        invar a;\n        \\<forall>x.\n           (\\<alpha> aa x, a'a x) \\<in> \\<langle>Rv\\<rangle>option_rel;\n        invar aa; \\<alpha> aa x = Some x2; a'a x = None\\<rbrakk>\n       \\<Longrightarrow> (Some x2, a' x)\n                         \\<in> \\<langle>Rv\\<rangle>option_rel\n 3. \\<And>a a' aa a'a x x2 x2a.\n       \\<lbrakk>Rk = Id;\n        \\<forall>x.\n           (\\<alpha> a x, a' x) \\<in> \\<langle>Rv\\<rangle>option_rel;\n        invar a;\n        \\<forall>x.\n           (\\<alpha> aa x, a'a x) \\<in> \\<langle>Rv\\<rangle>option_rel;\n        invar aa; \\<alpha> aa x = Some x2; a'a x = Some x2a\\<rbrakk>\n       \\<Longrightarrow> (x2, x2a) \\<in> Rv", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a a' aa a'a x x2.\n       \\<lbrakk>Rk = Id;\n        \\<forall>x.\n           (\\<alpha> a x, a' x) \\<in> \\<langle>Rv\\<rangle>option_rel;\n        invar a;\n        \\<forall>x.\n           (\\<alpha> aa x, a'a x) \\<in> \\<langle>Rv\\<rangle>option_rel;\n        invar aa; \\<alpha> aa x = Some x2; a'a x = None\\<rbrakk>\n       \\<Longrightarrow> (Some x2, a' x)\n                         \\<in> \\<langle>Rv\\<rangle>option_rel\n 2. \\<And>a a' aa a'a x x2 x2a.\n       \\<lbrakk>Rk = Id;\n        \\<forall>x.\n           (\\<alpha> a x, a' x) \\<in> \\<langle>Rv\\<rangle>option_rel;\n        invar a;\n        \\<forall>x.\n           (\\<alpha> aa x, a'a x) \\<in> \\<langle>Rv\\<rangle>option_rel;\n        invar aa; \\<alpha> aa x = Some x2; a'a x = Some x2a\\<rbrakk>\n       \\<Longrightarrow> (x2, x2a) \\<in> Rv", "apply (metis option.simps(3) option_rel_simp(2))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a x x2 x2a.\n       \\<lbrakk>Rk = Id;\n        \\<forall>x.\n           (\\<alpha> a x, a' x) \\<in> \\<langle>Rv\\<rangle>option_rel;\n        invar a;\n        \\<forall>x.\n           (\\<alpha> aa x, a'a x) \\<in> \\<langle>Rv\\<rangle>option_rel;\n        invar aa; \\<alpha> aa x = Some x2; a'a x = Some x2a\\<rbrakk>\n       \\<Longrightarrow> (x2, x2a) \\<in> Rv", "by (metis (lifting) option_rel_simp(3))"], ["", "context map_add_dj begin"], ["", "context begin"], ["", "interpretation autoref_syn"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma add_dj_autoref[autoref_rules]: \n  assumes \"PREFER_id Rk\"\n  assumes \"SIDE_PRECOND_OPT (dom a' \\<inter> dom b' = {})\"\n  assumes \"(a,a')\\<in>\\<langle>Rk,Rv\\<rangle>rel\"\n  assumes \"(b,b')\\<in>\\<langle>Rk,Rv\\<rangle>rel\"\n  shows \"(add_dj a b, (OP (++) ::: \\<langle>Rk,Rv\\<rangle>rel \\<rightarrow> \\<langle>Rk,Rv\\<rangle>rel \\<rightarrow> \\<langle>Rk,Rv\\<rangle>rel) $ a' $ b')\\<in>\\<langle>Rk,Rv\\<rangle>rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (add_dj a b,\n     (OP (++) :::\n      \\<langle>Rk, Rv\\<rangle>rel \\<rightarrow>\n      \\<langle>Rk, Rv\\<rangle>rel \\<rightarrow> \\<langle>Rk,\n      Rv\\<rangle>rel) $\n     a' $\n     b')\n    \\<in> \\<langle>Rk, Rv\\<rangle>rel", "using assms"], ["proof (prove)\nusing this:\n  PREFER_id Rk\n  SIDE_PRECOND_OPT (dom a' \\<inter> dom b' = {})\n  (a, a') \\<in> \\<langle>Rk, Rv\\<rangle>rel\n  (b, b') \\<in> \\<langle>Rk, Rv\\<rangle>rel\n\ngoal (1 subgoal):\n 1. (add_dj a b,\n     (OP (++) :::\n      \\<langle>Rk, Rv\\<rangle>rel \\<rightarrow>\n      \\<langle>Rk, Rv\\<rangle>rel \\<rightarrow> \\<langle>Rk,\n      Rv\\<rangle>rel) $\n     a' $\n     b')\n    \\<in> \\<langle>Rk, Rv\\<rangle>rel", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Rk = Id; dom a' \\<inter> dom b' = {};\n     (a, a') \\<in> \\<langle>Id, Rv\\<rangle>rel;\n     (b, b') \\<in> \\<langle>Id, Rv\\<rangle>rel\\<rbrakk>\n    \\<Longrightarrow> (add_dj a b, a' ++ b') \\<in> \\<langle>Id,\n                      Rv\\<rangle>rel", "apply (subgoal_tac \"dom (\\<alpha> a) \\<inter> dom (\\<alpha> b) = {}\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Rk = Id; dom a' \\<inter> dom b' = {};\n     (a, a') \\<in> \\<langle>Id, Rv\\<rangle>rel;\n     (b, b') \\<in> \\<langle>Id, Rv\\<rangle>rel;\n     dom (\\<alpha> a) \\<inter> dom (\\<alpha> b) = {}\\<rbrakk>\n    \\<Longrightarrow> (add_dj a b, a' ++ b') \\<in> \\<langle>Id,\n                      Rv\\<rangle>rel\n 2. \\<lbrakk>Rk = Id; dom a' \\<inter> dom b' = {};\n     (a, a') \\<in> \\<langle>Id, Rv\\<rangle>rel;\n     (b, b') \\<in> \\<langle>Id, Rv\\<rangle>rel\\<rbrakk>\n    \\<Longrightarrow> dom (\\<alpha> a) \\<inter> dom (\\<alpha> b) = {}", "apply (clarsimp simp add: add_dj_correct rel_def br_comp_alt)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a'a.\n       \\<lbrakk>Rk = Id; dom a' \\<inter> dom b' = {};\n        dom (\\<alpha> a) \\<inter> dom (\\<alpha> b) = {}; invar a;\n        (\\<alpha> a, a')\n        \\<in> Id \\<rightarrow> \\<langle>Rv\\<rangle>option_rel;\n        invar b;\n        (\\<alpha> b, b')\n        \\<in> Id \\<rightarrow> \\<langle>Rv\\<rangle>option_rel\\<rbrakk>\n       \\<Longrightarrow> ((\\<alpha> a ++ \\<alpha> b) a'a, (a' ++ b') a'a)\n                         \\<in> \\<langle>Rv\\<rangle>option_rel\n 2. \\<lbrakk>Rk = Id; dom a' \\<inter> dom b' = {};\n     (a, a') \\<in> \\<langle>Id, Rv\\<rangle>rel;\n     (b, b') \\<in> \\<langle>Id, Rv\\<rangle>rel\\<rbrakk>\n    \\<Longrightarrow> dom (\\<alpha> a) \\<inter> dom (\\<alpha> b) = {}", "apply (auto \n    simp add: rel_def br_comp_alt Map.map_add_def\n    split: option.split\n    elim: fun_relE1 dest: fun_relD1 intro: option_relI\n  ) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Rk = Id; dom a' \\<inter> dom b' = {};\n     (a, a') \\<in> \\<langle>Id, Rv\\<rangle>rel;\n     (b, b') \\<in> \\<langle>Id, Rv\\<rangle>rel\\<rbrakk>\n    \\<Longrightarrow> dom (\\<alpha> a) \\<inter> dom (\\<alpha> b) = {}", "apply (clarsimp simp add: rel_def br_comp_alt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Rk = Id; dom a' \\<inter> dom b' = {}; invar a;\n     (\\<alpha> a, a') \\<in> Id \\<rightarrow> \\<langle>Rv\\<rangle>option_rel;\n     invar b;\n     (\\<alpha> b, b')\n     \\<in> Id \\<rightarrow> \\<langle>Rv\\<rangle>option_rel\\<rbrakk>\n    \\<Longrightarrow> dom (\\<alpha> a) \\<inter> dom (\\<alpha> b) = {}", "apply (auto simp: dom_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y ya.\n       \\<lbrakk>Rk = Id;\n        {a. \\<exists>y. a' a = Some y} \\<inter>\n        {a. \\<exists>y. b' a = Some y} =\n        {};\n        invar a;\n        (\\<alpha> a, a')\n        \\<in> Id \\<rightarrow> \\<langle>Rv\\<rangle>option_rel;\n        invar b;\n        (\\<alpha> b, b')\n        \\<in> Id \\<rightarrow> \\<langle>Rv\\<rangle>option_rel;\n        \\<alpha> a x = Some y; \\<alpha> b x = Some ya\\<rbrakk>\n       \\<Longrightarrow> False", "apply (drule (1) fun_relD1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y ya.\n       \\<lbrakk>Rk = Id;\n        {a. \\<exists>y. a' a = Some y} \\<inter>\n        {a. \\<exists>y. b' a = Some y} =\n        {};\n        invar a; invar b;\n        (\\<alpha> b, b')\n        \\<in> Id \\<rightarrow> \\<langle>Rv\\<rangle>option_rel;\n        \\<alpha> a x = Some y; \\<alpha> b x = Some ya;\n        \\<forall>x'.\n           (x, x') \\<in> Id \\<longrightarrow>\n           (Some y, a' x') \\<in> \\<langle>Rv\\<rangle>option_rel\\<rbrakk>\n       \\<Longrightarrow> False", "apply (drule (1) fun_relD1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y ya.\n       \\<lbrakk>Rk = Id;\n        {a. \\<exists>y. a' a = Some y} \\<inter>\n        {a. \\<exists>y. b' a = Some y} =\n        {};\n        invar a; invar b; \\<alpha> a x = Some y; \\<alpha> b x = Some ya;\n        \\<forall>x'.\n           (x, x') \\<in> Id \\<longrightarrow>\n           (Some y, a' x') \\<in> \\<langle>Rv\\<rangle>option_rel;\n        \\<forall>x'.\n           (x, x') \\<in> Id \\<longrightarrow>\n           (Some ya, b' x') \\<in> \\<langle>Rv\\<rangle>option_rel\\<rbrakk>\n       \\<Longrightarrow> False", "apply (auto simp: option_rel_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "end"], ["", "lemma (in map_isEmpty) isEmpty_autoref[autoref_rules]: \n  \"PREFER_id Rk \\<Longrightarrow> (isEmpty,op_map_isEmpty)\\<in>\\<langle>Rk,Rv\\<rangle>rel\\<rightarrow>Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PREFER_id Rk \\<Longrightarrow>\n    (isEmpty, op_map_isEmpty)\n    \\<in> \\<langle>Rk, Rv\\<rangle>rel \\<rightarrow> bool_rel", "by (auto simp: isEmpty_correct rel_alt\n    intro!: ext)"], ["", "lemma sngI: \n  assumes \"m k = Some v\"\n  assumes \"\\<forall>k'. k'\\<noteq>k \\<longrightarrow> m k' = None\"\n  shows \"m = [k\\<mapsto>v]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m = [k \\<mapsto> v]", "using assms"], ["proof (prove)\nusing this:\n  m k = Some v\n  \\<forall>k'. k' \\<noteq> k \\<longrightarrow> m k' = None\n\ngoal (1 subgoal):\n 1. m = [k \\<mapsto> v]", "by (auto intro!: ext)"], ["", "lemma (in map_isSng) isSng_autoref[autoref_rules]: \n  \"PREFER_id Rk \\<Longrightarrow> (isSng,op_map_isSng)\\<in>\\<langle>Rk,Rv\\<rangle>rel\\<rightarrow>Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PREFER_id Rk \\<Longrightarrow>\n    (isSng, op_map_isSng)\n    \\<in> \\<langle>Rk, Rv\\<rangle>rel \\<rightarrow> bool_rel", "(* TODO: Clean up this mess *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. PREFER_id Rk \\<Longrightarrow>\n    (isSng, op_map_isSng)\n    \\<in> \\<langle>Rk, Rv\\<rangle>rel \\<rightarrow> bool_rel", "apply (auto simp add: isSng_correct rel_alt)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a a' k v.\n       \\<lbrakk>Rk = Id;\n        \\<forall>x.\n           (if x = k then Some v else None, a' x)\n           \\<in> \\<langle>Rv\\<rangle>option_rel;\n        invar a; \\<alpha> a = [k \\<mapsto> v]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k v. a' = [k \\<mapsto> v]\n 2. \\<And>a k v.\n       \\<lbrakk>Rk = Id;\n        \\<forall>x.\n           (\\<alpha> a x, if x = k then Some v else None)\n           \\<in> \\<langle>Rv\\<rangle>option_rel;\n        invar a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k v. \\<alpha> a = [k \\<mapsto> v]", "apply (rule_tac x=k in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a a' k v.\n       \\<lbrakk>Rk = Id;\n        \\<forall>x.\n           (if x = k then Some v else None, a' x)\n           \\<in> \\<langle>Rv\\<rangle>option_rel;\n        invar a; \\<alpha> a = [k \\<mapsto> v]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v. a' = [k \\<mapsto> v]\n 2. \\<And>a k v.\n       \\<lbrakk>Rk = Id;\n        \\<forall>x.\n           (\\<alpha> a x, if x = k then Some v else None)\n           \\<in> \\<langle>Rv\\<rangle>option_rel;\n        invar a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k v. \\<alpha> a = [k \\<mapsto> v]", "apply (rule_tac x=\"the (a' k)\" in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a a' k v.\n       \\<lbrakk>Rk = Id;\n        \\<forall>x.\n           (if x = k then Some v else None, a' x)\n           \\<in> \\<langle>Rv\\<rangle>option_rel;\n        invar a; \\<alpha> a = [k \\<mapsto> v]\\<rbrakk>\n       \\<Longrightarrow> a' = [k \\<mapsto> the (a' k)]\n 2. \\<And>a k v.\n       \\<lbrakk>Rk = Id;\n        \\<forall>x.\n           (\\<alpha> a x, if x = k then Some v else None)\n           \\<in> \\<langle>Rv\\<rangle>option_rel;\n        invar a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k v. \\<alpha> a = [k \\<mapsto> v]", "apply (rule sngI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a a' k v.\n       \\<lbrakk>Rk = Id;\n        \\<forall>x.\n           (if x = k then Some v else None, a' x)\n           \\<in> \\<langle>Rv\\<rangle>option_rel;\n        invar a; \\<alpha> a = [k \\<mapsto> v]\\<rbrakk>\n       \\<Longrightarrow> a' k = Some (the (a' k))\n 2. \\<And>a a' k v.\n       \\<lbrakk>Rk = Id;\n        \\<forall>x.\n           (if x = k then Some v else None, a' x)\n           \\<in> \\<langle>Rv\\<rangle>option_rel;\n        invar a; \\<alpha> a = [k \\<mapsto> v]\\<rbrakk>\n       \\<Longrightarrow> \\<forall>k'.\n                            k' \\<noteq> k \\<longrightarrow> a' k' = None\n 3. \\<And>a k v.\n       \\<lbrakk>Rk = Id;\n        \\<forall>x.\n           (\\<alpha> a x, if x = k then Some v else None)\n           \\<in> \\<langle>Rv\\<rangle>option_rel;\n        invar a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k v. \\<alpha> a = [k \\<mapsto> v]", "apply (drule_tac x=k in spec)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a a' k v.\n       \\<lbrakk>Rk = Id; invar a; \\<alpha> a = [k \\<mapsto> v];\n        (if k = k then Some v else None, a' k)\n        \\<in> \\<langle>Rv\\<rangle>option_rel\\<rbrakk>\n       \\<Longrightarrow> a' k = Some (the (a' k))\n 2. \\<And>a a' k v.\n       \\<lbrakk>Rk = Id;\n        \\<forall>x.\n           (if x = k then Some v else None, a' x)\n           \\<in> \\<langle>Rv\\<rangle>option_rel;\n        invar a; \\<alpha> a = [k \\<mapsto> v]\\<rbrakk>\n       \\<Longrightarrow> \\<forall>k'.\n                            k' \\<noteq> k \\<longrightarrow> a' k' = None\n 3. \\<And>a k v.\n       \\<lbrakk>Rk = Id;\n        \\<forall>x.\n           (\\<alpha> a x, if x = k then Some v else None)\n           \\<in> \\<langle>Rv\\<rangle>option_rel;\n        invar a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k v. \\<alpha> a = [k \\<mapsto> v]", "apply (auto elim: option_relE) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a a' k v.\n       \\<lbrakk>Rk = Id;\n        \\<forall>x.\n           (if x = k then Some v else None, a' x)\n           \\<in> \\<langle>Rv\\<rangle>option_rel;\n        invar a; \\<alpha> a = [k \\<mapsto> v]\\<rbrakk>\n       \\<Longrightarrow> \\<forall>k'.\n                            k' \\<noteq> k \\<longrightarrow> a' k' = None\n 2. \\<And>a k v.\n       \\<lbrakk>Rk = Id;\n        \\<forall>x.\n           (\\<alpha> a x, if x = k then Some v else None)\n           \\<in> \\<langle>Rv\\<rangle>option_rel;\n        invar a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k v. \\<alpha> a = [k \\<mapsto> v]", "apply (force elim: option_relE) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a k v.\n       \\<lbrakk>Rk = Id;\n        \\<forall>x.\n           (\\<alpha> a x, if x = k then Some v else None)\n           \\<in> \\<langle>Rv\\<rangle>option_rel;\n        invar a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k v. \\<alpha> a = [k \\<mapsto> v]", "apply (rule_tac x=k in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a k v.\n       \\<lbrakk>Rk = Id;\n        \\<forall>x.\n           (\\<alpha> a x, if x = k then Some v else None)\n           \\<in> \\<langle>Rv\\<rangle>option_rel;\n        invar a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v. \\<alpha> a = [k \\<mapsto> v]", "apply (rule_tac x=\"the (\\<alpha> a k)\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a k v.\n       \\<lbrakk>Rk = Id;\n        \\<forall>x.\n           (\\<alpha> a x, if x = k then Some v else None)\n           \\<in> \\<langle>Rv\\<rangle>option_rel;\n        invar a\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> a = [k \\<mapsto> the (\\<alpha> a k)]", "apply (rule sngI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a k v.\n       \\<lbrakk>Rk = Id;\n        \\<forall>x.\n           (\\<alpha> a x, if x = k then Some v else None)\n           \\<in> \\<langle>Rv\\<rangle>option_rel;\n        invar a\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> a k = Some (the (\\<alpha> a k))\n 2. \\<And>a k v.\n       \\<lbrakk>Rk = Id;\n        \\<forall>x.\n           (\\<alpha> a x, if x = k then Some v else None)\n           \\<in> \\<langle>Rv\\<rangle>option_rel;\n        invar a\\<rbrakk>\n       \\<Longrightarrow> \\<forall>k'.\n                            k' \\<noteq> k \\<longrightarrow>\n                            \\<alpha> a k' = None", "apply (drule_tac x=k in spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a k v.\n       \\<lbrakk>Rk = Id; invar a;\n        (\\<alpha> a k, if k = k then Some v else None)\n        \\<in> \\<langle>Rv\\<rangle>option_rel\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> a k = Some (the (\\<alpha> a k))\n 2. \\<And>a k v.\n       \\<lbrakk>Rk = Id;\n        \\<forall>x.\n           (\\<alpha> a x, if x = k then Some v else None)\n           \\<in> \\<langle>Rv\\<rangle>option_rel;\n        invar a\\<rbrakk>\n       \\<Longrightarrow> \\<forall>k'.\n                            k' \\<noteq> k \\<longrightarrow>\n                            \\<alpha> a k' = None", "apply (auto elim: option_relE) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a k v.\n       \\<lbrakk>Rk = Id;\n        \\<forall>x.\n           (\\<alpha> a x, if x = k then Some v else None)\n           \\<in> \\<langle>Rv\\<rangle>option_rel;\n        invar a\\<rbrakk>\n       \\<Longrightarrow> \\<forall>k'.\n                            k' \\<noteq> k \\<longrightarrow>\n                            \\<alpha> a k' = None", "apply (force elim: option_relE) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in map_ball) ball_autoref[autoref_rules]:\n  \"PREFER_id Rk \\<Longrightarrow> (ball,op_map_ball)\\<in>\\<langle>Rk,Rv\\<rangle>rel\\<rightarrow>(\\<langle>Rk,Rv\\<rangle>prod_rel\\<rightarrow>Id)\\<rightarrow>Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PREFER_id Rk \\<Longrightarrow>\n    (ball, op_map_ball)\n    \\<in> \\<langle>Rk, Rv\\<rangle>rel \\<rightarrow>\n          (Rk \\<times>\\<^sub>r Rv \\<rightarrow> bool_rel) \\<rightarrow>\n          bool_rel", "apply (auto simp: ball_correct rel_alt map_to_set_def\n    option_rel_def prod_rel_def fun_rel_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba ab bb.\n       \\<lbrakk>Rk = Id;\n        \\<forall>x.\n           \\<alpha> a x = None \\<and> b x = None \\<or>\n           (\\<exists>aa.\n               \\<alpha> a x = Some aa \\<and>\n               (\\<exists>a'. b x = Some a' \\<and> (aa, a') \\<in> Rv));\n        invar a;\n        \\<forall>a b bb.\n           (b, bb) \\<in> Rv \\<longrightarrow> aa (a, b) = ba (a, bb);\n        \\<forall>u v. \\<alpha> a u = Some v \\<longrightarrow> aa (u, v);\n        b ab = Some bb\\<rbrakk>\n       \\<Longrightarrow> ba (ab, bb)\n 2. \\<And>a b aa ba u v.\n       \\<lbrakk>Rk = Id;\n        \\<forall>x.\n           \\<alpha> a x = None \\<and> b x = None \\<or>\n           (\\<exists>aa.\n               \\<alpha> a x = Some aa \\<and>\n               (\\<exists>a'. b x = Some a' \\<and> (aa, a') \\<in> Rv));\n        invar a;\n        \\<forall>a b bb.\n           (b, bb) \\<in> Rv \\<longrightarrow> aa (a, b) = ba (a, bb);\n        \\<forall>a bb. b a = Some bb \\<longrightarrow> ba (a, bb);\n        \\<alpha> a u = Some v\\<rbrakk>\n       \\<Longrightarrow> aa (u, v)", "apply (metis option.inject option.simps(3))+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in map_bex) bex_autoref[autoref_rules]:\n  \"PREFER_id Rk \\<Longrightarrow> (bex,op_map_bex)\\<in>\\<langle>Rk,Rv\\<rangle>rel\\<rightarrow>(\\<langle>Rk,Rv\\<rangle>prod_rel\\<rightarrow>Id)\\<rightarrow>Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PREFER_id Rk \\<Longrightarrow>\n    (bex, op_map_bex)\n    \\<in> \\<langle>Rk, Rv\\<rangle>rel \\<rightarrow>\n          (Rk \\<times>\\<^sub>r Rv \\<rightarrow> bool_rel) \\<rightarrow>\n          bool_rel", "apply (auto simp: bex_correct map_to_set_def rel_alt \n    option_rel_def prod_rel_def fun_rel_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba u v.\n       \\<lbrakk>Rk = Id;\n        \\<forall>x.\n           \\<alpha> a x = None \\<and> b x = None \\<or>\n           (\\<exists>aa.\n               \\<alpha> a x = Some aa \\<and>\n               (\\<exists>a'. b x = Some a' \\<and> (aa, a') \\<in> Rv));\n        invar a;\n        \\<forall>a b bb.\n           (b, bb) \\<in> Rv \\<longrightarrow> aa (a, b) = ba (a, bb);\n        \\<alpha> a u = Some v; aa (u, v)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a bb. b a = Some bb \\<and> ba (a, bb)\n 2. \\<And>a b aa ba ab bb.\n       \\<lbrakk>Rk = Id;\n        \\<forall>x.\n           \\<alpha> a x = None \\<and> b x = None \\<or>\n           (\\<exists>aa.\n               \\<alpha> a x = Some aa \\<and>\n               (\\<exists>a'. b x = Some a' \\<and> (aa, a') \\<in> Rv));\n        invar a;\n        \\<forall>a b bb.\n           (b, bb) \\<in> Rv \\<longrightarrow> aa (a, b) = ba (a, bb);\n        b ab = Some bb; ba (ab, bb)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u v.\n                            \\<alpha> a u = Some v \\<and> aa (u, v)", "apply (metis option.inject option.simps(3))+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in map_size) size_autoref[autoref_rules]:\n  \"PREFER_id Rk \\<Longrightarrow> (size,op_map_size)\\<in>\\<langle>Rk,Rv\\<rangle>rel\\<rightarrow>Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PREFER_id Rk \\<Longrightarrow>\n    (size, op_map_size)\n    \\<in> \\<langle>Rk, Rv\\<rangle>rel \\<rightarrow> nat_rel", "apply (auto simp: size_correct rel_alt option_rel_def dom_def \n    intro!: arg_cong[where f=card])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a a' x y.\n       \\<lbrakk>Rk = Id;\n        \\<forall>x.\n           \\<alpha> a x = None \\<and> a' x = None \\<or>\n           (\\<exists>aa.\n               \\<alpha> a x = Some aa \\<and>\n               (\\<exists>a'a. a' x = Some a'a \\<and> (aa, a'a) \\<in> Rv));\n        invar a; \\<alpha> a x = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. a' x = Some y\n 2. \\<And>a a' x y.\n       \\<lbrakk>Rk = Id;\n        \\<forall>x.\n           \\<alpha> a x = None \\<and> a' x = None \\<or>\n           (\\<exists>aa.\n               \\<alpha> a x = Some aa \\<and>\n               (\\<exists>a'a. a' x = Some a'a \\<and> (aa, a'a) \\<in> Rv));\n        invar a; a' x = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. \\<alpha> a x = Some y", "apply (metis option.simps(3))+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in map_size_abort) size_abort_autoref[autoref_rules]:\n  \"PREFER_id Rk \\<Longrightarrow> (size_abort,op_map_size_abort)\\<in>Id\\<rightarrow>\\<langle>Rk,Rv\\<rangle>rel\\<rightarrow>Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PREFER_id Rk \\<Longrightarrow>\n    (size_abort, op_map_size_abort)\n    \\<in> nat_rel \\<rightarrow>\n          \\<langle>Rk, Rv\\<rangle>rel \\<rightarrow> nat_rel", "apply (auto simp: size_abort_correct  \n    rel_alt option_rel_def\n    dom_def intro!: arg_cong[where f=card] cong[OF arg_cong[where f=min]])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa a'a x y.\n       \\<lbrakk>Rk = Id;\n        \\<forall>x.\n           \\<alpha> aa x = None \\<and> a'a x = None \\<or>\n           (\\<exists>a.\n               \\<alpha> aa x = Some a \\<and>\n               (\\<exists>a'. a'a x = Some a' \\<and> (a, a') \\<in> Rv));\n        invar aa; \\<alpha> aa x = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. a'a x = Some y\n 2. \\<And>aa a'a x y.\n       \\<lbrakk>Rk = Id;\n        \\<forall>x.\n           \\<alpha> aa x = None \\<and> a'a x = None \\<or>\n           (\\<exists>a.\n               \\<alpha> aa x = Some a \\<and>\n               (\\<exists>a'. a'a x = Some a' \\<and> (a, a') \\<in> Rv));\n        invar aa; a'a x = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. \\<alpha> aa x = Some y", "apply (metis option.simps(3))+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in list_to_map) to_map_autoref[autoref_rules]:\n  \"PREFER_id Rk \\<Longrightarrow> (to_map,map_of)\\<in> \\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel \\<rightarrow> \\<langle>Rk,Rv\\<rangle>rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PREFER_id Rk \\<Longrightarrow>\n    (to_map, map_of)\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel \\<rightarrow>\n          \\<langle>Rk, Rv\\<rangle>rel", "proof (intro fun_relI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>PREFER_id Rk;\n        (a, a')\n        \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (to_map a, map_of a') \\<in> \\<langle>Rk,\n                         Rv\\<rangle>rel", "fix l :: \"('u\\<times>'v) list\" and l' :: \"('u\\<times>'a) list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>PREFER_id Rk;\n        (a, a')\n        \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (to_map a, map_of a') \\<in> \\<langle>Rk,\n                         Rv\\<rangle>rel", "assume \"PREFER_id Rk\""], ["proof (state)\nthis:\n  PREFER_id Rk\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>PREFER_id Rk;\n        (a, a')\n        \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (to_map a, map_of a') \\<in> \\<langle>Rk,\n                         Rv\\<rangle>rel", "hence [simp]: \"Rk=Id\""], ["proof (prove)\nusing this:\n  PREFER_id Rk\n\ngoal (1 subgoal):\n 1. Rk = Id", "by simp"], ["proof (state)\nthis:\n  Rk = Id\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>PREFER_id Rk;\n        (a, a')\n        \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (to_map a, map_of a') \\<in> \\<langle>Rk,\n                         Rv\\<rangle>rel", "assume \"(l,l')\\<in>\\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel\""], ["proof (state)\nthis:\n  (l, l') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>PREFER_id Rk;\n        (a, a')\n        \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (to_map a, map_of a') \\<in> \\<langle>Rk,\n                         Rv\\<rangle>rel", "thus \"(to_map l, map_of l') \\<in> \\<langle>Rk,Rv\\<rangle>rel\""], ["proof (prove)\nusing this:\n  (l, l') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. (to_map l, map_of l') \\<in> \\<langle>Rk, Rv\\<rangle>rel", "apply (simp add: list_rel_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 (\\<lambda>x x'. (x, x') \\<in> Id \\<times>\\<^sub>r Rv) l\n     l' \\<Longrightarrow>\n    (to_map l, map_of l') \\<in> \\<langle>Id, Rv\\<rangle>rel", "proof (induct rule: list_all2_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. (to_map [], map_of []) \\<in> \\<langle>Id, Rv\\<rangle>rel\n 2. \\<And>x x' ls ls'.\n       \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r Rv;\n        list_all2 (\\<lambda>x x'. (x, x') \\<in> Id \\<times>\\<^sub>r Rv) ls\n         ls';\n        (to_map ls, map_of ls') \\<in> \\<langle>Id, Rv\\<rangle>rel\\<rbrakk>\n       \\<Longrightarrow> (to_map (x # ls), map_of (x' # ls'))\n                         \\<in> \\<langle>Id, Rv\\<rangle>rel", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. (to_map [], map_of []) \\<in> \\<langle>Id, Rv\\<rangle>rel\n 2. \\<And>x x' ls ls'.\n       \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r Rv;\n        list_all2 (\\<lambda>x x'. (x, x') \\<in> Id \\<times>\\<^sub>r Rv) ls\n         ls';\n        (to_map ls, map_of ls') \\<in> \\<langle>Id, Rv\\<rangle>rel\\<rbrakk>\n       \\<Longrightarrow> (to_map (x # ls), map_of (x' # ls'))\n                         \\<in> \\<langle>Id, Rv\\<rangle>rel", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (to_map [], map_of []) \\<in> \\<langle>Id, Rv\\<rangle>rel", "by (auto simp add: to_map_correct rel_alt)"], ["proof (state)\nthis:\n  (to_map [], map_of []) \\<in> \\<langle>Id, Rv\\<rangle>rel\n\ngoal (1 subgoal):\n 1. \\<And>x x' ls ls'.\n       \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r Rv;\n        list_all2 (\\<lambda>x x'. (x, x') \\<in> Id \\<times>\\<^sub>r Rv) ls\n         ls';\n        (to_map ls, map_of ls') \\<in> \\<langle>Id, Rv\\<rangle>rel\\<rbrakk>\n       \\<Longrightarrow> (to_map (x # ls), map_of (x' # ls'))\n                         \\<in> \\<langle>Id, Rv\\<rangle>rel", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x x' ls ls'.\n       \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r Rv;\n        list_all2 (\\<lambda>x x'. (x, x') \\<in> Id \\<times>\\<^sub>r Rv) ls\n         ls';\n        (to_map ls, map_of ls') \\<in> \\<langle>Id, Rv\\<rangle>rel\\<rbrakk>\n       \\<Longrightarrow> (to_map (x # ls), map_of (x' # ls'))\n                         \\<in> \\<langle>Id, Rv\\<rangle>rel", "case (Cons x x' l l')"], ["proof (state)\nthis:\n  (x, x') \\<in> Id \\<times>\\<^sub>r Rv\n  list_all2 (\\<lambda>x x'. (x, x') \\<in> Id \\<times>\\<^sub>r Rv) l l'\n  (to_map l, map_of l') \\<in> \\<langle>Id, Rv\\<rangle>rel\n\ngoal (1 subgoal):\n 1. \\<And>x x' ls ls'.\n       \\<lbrakk>(x, x') \\<in> Id \\<times>\\<^sub>r Rv;\n        list_all2 (\\<lambda>x x'. (x, x') \\<in> Id \\<times>\\<^sub>r Rv) ls\n         ls';\n        (to_map ls, map_of ls') \\<in> \\<langle>Id, Rv\\<rangle>rel\\<rbrakk>\n       \\<Longrightarrow> (to_map (x # ls), map_of (x' # ls'))\n                         \\<in> \\<langle>Id, Rv\\<rangle>rel", "thus ?case"], ["proof (prove)\nusing this:\n  (x, x') \\<in> Id \\<times>\\<^sub>r Rv\n  list_all2 (\\<lambda>x x'. (x, x') \\<in> Id \\<times>\\<^sub>r Rv) l l'\n  (to_map l, map_of l') \\<in> \\<langle>Id, Rv\\<rangle>rel\n\ngoal (1 subgoal):\n 1. (to_map (x # l), map_of (x' # l')) \\<in> \\<langle>Id, Rv\\<rangle>rel", "by (auto simp add: to_map_correct \n        rel_alt prod_rel_def)"], ["proof (state)\nthis:\n  (to_map (x # l), map_of (x' # l')) \\<in> \\<langle>Id, Rv\\<rangle>rel\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (to_map l, map_of l') \\<in> \\<langle>Rk, Rv\\<rangle>rel\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO: Move *)"], ["", "lemma key_rel_true[simp]: \"key_rel (\\<lambda>_ _. True) = (\\<lambda>_ _. True)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. key_rel (\\<lambda>_ _. True) = (\\<lambda>_ _. True)", "by (auto intro!: ext simp: key_rel_def)"], ["", "lemma (in poly_map_iteratei) proper[proper_it]:\n  \"proper_it' iteratei iteratei\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it' iteratei iteratei", "apply (rule proper_it'I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s. proper_it (iteratei s) (iteratei s)", "by (rule pi_iteratei)"], ["", "lemma (in poly_map_iteratei) autoref_iteratei[autoref_ga_rules]: \n  assumes ID: \"REL_IS_ID Rk\"\n    \"REL_IS_ID Rv\" (* TODO: Unnecessary*)\n  shows \"is_map_to_list Rk Rv rel (it_to_list iteratei)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_map_to_list Rk Rv rel (it_to_list iteratei)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_map_to_list Rk Rv rel (it_to_list iteratei)", "from ID"], ["proof (chain)\npicking this:\n  REL_IS_ID Rk\n  REL_IS_ID Rv", "have [simp]: \"Rk=Id\" \"Rv = Id\""], ["proof (prove)\nusing this:\n  REL_IS_ID Rk\n  REL_IS_ID Rv\n\ngoal (1 subgoal):\n 1. Rk = Id &&& Rv = Id", "by simp_all"], ["proof (state)\nthis:\n  Rk = Id\n  Rv = Id\n\ngoal (1 subgoal):\n 1. is_map_to_list Rk Rv rel (it_to_list iteratei)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_map_to_list Rk Rv rel (it_to_list iteratei)", "unfolding is_map_to_sorted_list_def is_map_to_list_def\n      it_to_sorted_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>m m'.\n       (m, m') \\<in> \\<langle>Rk, Rv\\<rangle>rel \\<longrightarrow>\n       (\\<exists>l'.\n           (it_to_list iteratei m, l')\n           \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel \\<and>\n           RETURN l'\n           \\<le> SPEC\n                  (\\<lambda>l.\n                      distinct l \\<and>\n                      map_to_set m' = set l \\<and>\n                      sorted_wrt (key_rel (\\<lambda>_ _. True)) l))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>m m'.\n       (m, m') \\<in> br \\<alpha> invar \\<longrightarrow>\n       distinct (it_to_list iteratei m) \\<and>\n       map_to_set m' = set (it_to_list iteratei m)", "apply (intro allI impI conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m m'.\n       (m, m') \\<in> br \\<alpha> invar \\<Longrightarrow>\n       distinct (it_to_list iteratei m)\n 2. \\<And>m m'.\n       (m, m') \\<in> br \\<alpha> invar \\<Longrightarrow>\n       map_to_set m' = set (it_to_list iteratei m)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m m'.\n       (m, m') \\<in> br \\<alpha> invar \\<Longrightarrow>\n       distinct (it_to_list iteratei m)\n 2. \\<And>m m'.\n       (m, m') \\<in> br \\<alpha> invar \\<Longrightarrow>\n       map_to_set m' = set (it_to_list iteratei m)", "fix m m'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m m'.\n       (m, m') \\<in> br \\<alpha> invar \\<Longrightarrow>\n       distinct (it_to_list iteratei m)\n 2. \\<And>m m'.\n       (m, m') \\<in> br \\<alpha> invar \\<Longrightarrow>\n       map_to_set m' = set (it_to_list iteratei m)", "assume \"(m, m') \\<in> br \\<alpha> invar\""], ["proof (state)\nthis:\n  (m, m') \\<in> br \\<alpha> invar\n\ngoal (2 subgoals):\n 1. \\<And>m m'.\n       (m, m') \\<in> br \\<alpha> invar \\<Longrightarrow>\n       distinct (it_to_list iteratei m)\n 2. \\<And>m m'.\n       (m, m') \\<in> br \\<alpha> invar \\<Longrightarrow>\n       map_to_set m' = set (it_to_list iteratei m)", "hence I: \"invar m\" and M': \"m' = \\<alpha> m\""], ["proof (prove)\nusing this:\n  (m, m') \\<in> br \\<alpha> invar\n\ngoal (1 subgoal):\n 1. invar m &&& m' = \\<alpha> m", "by (simp_all add: br_def)"], ["proof (state)\nthis:\n  invar m\n  m' = \\<alpha> m\n\ngoal (2 subgoals):\n 1. \\<And>m m'.\n       (m, m') \\<in> br \\<alpha> invar \\<Longrightarrow>\n       distinct (it_to_list iteratei m)\n 2. \\<And>m m'.\n       (m, m') \\<in> br \\<alpha> invar \\<Longrightarrow>\n       map_to_set m' = set (it_to_list iteratei m)", "have [simp]: \"\\<And>c. (\\<lambda>(_,_). c) = (\\<lambda>_. c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c. (\\<lambda>(uu_, uu_). c) = (\\<lambda>_. c)", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>(uu_, uu_). ?c2) = (\\<lambda>_. ?c2)\n\ngoal (2 subgoals):\n 1. \\<And>m m'.\n       (m, m') \\<in> br \\<alpha> invar \\<Longrightarrow>\n       distinct (it_to_list iteratei m)\n 2. \\<And>m m'.\n       (m, m') \\<in> br \\<alpha> invar \\<Longrightarrow>\n       map_to_set m' = set (it_to_list iteratei m)", "from map_it_to_list_genord_correct[where it = iteratei, \n      where R=\"\\<lambda>_ _. True\", simplified, OF \n      iteratei_correct[OF I, unfolded set_iterator_def]\n    ]"], ["proof (chain)\npicking this:\n  map_of (it_to_list iteratei m) = \\<alpha> m \\<and>\n  distinct (map fst (it_to_list iteratei m))", "have \n        M: \"Map.map_of (it_to_list iteratei m) = \\<alpha> m\"\n        and D: \"distinct (List.map fst (it_to_list iteratei m))\""], ["proof (prove)\nusing this:\n  map_of (it_to_list iteratei m) = \\<alpha> m \\<and>\n  distinct (map fst (it_to_list iteratei m))\n\ngoal (1 subgoal):\n 1. map_of (it_to_list iteratei m) = \\<alpha> m &&&\n    distinct (map fst (it_to_list iteratei m))", "by (simp_all)"], ["proof (state)\nthis:\n  map_of (it_to_list iteratei m) = \\<alpha> m\n  distinct (map fst (it_to_list iteratei m))\n\ngoal (2 subgoals):\n 1. \\<And>m m'.\n       (m, m') \\<in> br \\<alpha> invar \\<Longrightarrow>\n       distinct (it_to_list iteratei m)\n 2. \\<And>m m'.\n       (m, m') \\<in> br \\<alpha> invar \\<Longrightarrow>\n       map_to_set m' = set (it_to_list iteratei m)", "from D"], ["proof (chain)\npicking this:\n  distinct (map fst (it_to_list iteratei m))", "show \"distinct (it_to_list iteratei m)\""], ["proof (prove)\nusing this:\n  distinct (map fst (it_to_list iteratei m))\n\ngoal (1 subgoal):\n 1. distinct (it_to_list iteratei m)", "by (rule distinct_mapI)"], ["proof (state)\nthis:\n  distinct (it_to_list iteratei m)\n\ngoal (1 subgoal):\n 1. \\<And>m m'.\n       (m, m') \\<in> br \\<alpha> invar \\<Longrightarrow>\n       map_to_set m' = set (it_to_list iteratei m)", "from M"], ["proof (chain)\npicking this:\n  map_of (it_to_list iteratei m) = \\<alpha> m", "show \"map_to_set m' = set (it_to_list iteratei m)\""], ["proof (prove)\nusing this:\n  map_of (it_to_list iteratei m) = \\<alpha> m\n\ngoal (1 subgoal):\n 1. map_to_set m' = set (it_to_list iteratei m)", "by (simp add: M' map_of_map_to_set[OF D])"], ["proof (state)\nthis:\n  map_to_set m' = set (it_to_list iteratei m)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_map_to_list Rk Rv rel (it_to_list iteratei)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in poly_map_iterateoi) proper_o[proper_it]:\n  \"proper_it' iterateoi iterateoi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it' iterateoi iterateoi", "apply (rule proper_it'I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s. proper_it (iterateoi s) (iterateoi s)", "by (rule pi_iterateoi)"], ["", "lemma (in poly_map_iterateoi) autoref_iterateoi[autoref_ga_rules]: \n  assumes ID: \"REL_IS_ID Rk\"\n    \"REL_IS_ID Rv\" (* TODO: Unnecessary*)\n  shows \"is_map_to_sorted_list (\\<le>) Rk Rv rel (it_to_list iterateoi)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_map_to_sorted_list (\\<le>) Rk Rv rel (it_to_list iterateoi)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_map_to_sorted_list (\\<le>) Rk Rv rel (it_to_list iterateoi)", "from ID"], ["proof (chain)\npicking this:\n  REL_IS_ID Rk\n  REL_IS_ID Rv", "have [simp]: \"Rk=Id\" \"Rv = Id\""], ["proof (prove)\nusing this:\n  REL_IS_ID Rk\n  REL_IS_ID Rv\n\ngoal (1 subgoal):\n 1. Rk = Id &&& Rv = Id", "by simp_all"], ["proof (state)\nthis:\n  Rk = Id\n  Rv = Id\n\ngoal (1 subgoal):\n 1. is_map_to_sorted_list (\\<le>) Rk Rv rel (it_to_list iterateoi)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_map_to_sorted_list (\\<le>) Rk Rv rel (it_to_list iterateoi)", "unfolding is_map_to_sorted_list_def\n      it_to_sorted_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>m m'.\n       (m, m') \\<in> \\<langle>Rk, Rv\\<rangle>rel \\<longrightarrow>\n       (\\<exists>l'.\n           (it_to_list iterateoi m, l')\n           \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel \\<and>\n           RETURN l'\n           \\<le> SPEC\n                  (\\<lambda>l.\n                      distinct l \\<and>\n                      map_to_set m' = set l \\<and>\n                      sorted_wrt (key_rel (\\<le>)) l))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>m m'.\n       (m, m') \\<in> br \\<alpha> invar \\<longrightarrow>\n       distinct (it_to_list iterateoi m) \\<and>\n       map_to_set m' = set (it_to_list iterateoi m) \\<and>\n       sorted_wrt (key_rel (\\<le>)) (it_to_list iterateoi m)", "apply (intro allI impI conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>m m'.\n       (m, m') \\<in> br \\<alpha> invar \\<Longrightarrow>\n       distinct (it_to_list iterateoi m)\n 2. \\<And>m m'.\n       (m, m') \\<in> br \\<alpha> invar \\<Longrightarrow>\n       map_to_set m' = set (it_to_list iterateoi m)\n 3. \\<And>m m'.\n       (m, m') \\<in> br \\<alpha> invar \\<Longrightarrow>\n       sorted_wrt (key_rel (\\<le>)) (it_to_list iterateoi m)", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>m m'.\n       (m, m') \\<in> br \\<alpha> invar \\<Longrightarrow>\n       distinct (it_to_list iterateoi m)\n 2. \\<And>m m'.\n       (m, m') \\<in> br \\<alpha> invar \\<Longrightarrow>\n       map_to_set m' = set (it_to_list iterateoi m)\n 3. \\<And>m m'.\n       (m, m') \\<in> br \\<alpha> invar \\<Longrightarrow>\n       sorted_wrt (key_rel (\\<le>)) (it_to_list iterateoi m)", "fix m m'"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>m m'.\n       (m, m') \\<in> br \\<alpha> invar \\<Longrightarrow>\n       distinct (it_to_list iterateoi m)\n 2. \\<And>m m'.\n       (m, m') \\<in> br \\<alpha> invar \\<Longrightarrow>\n       map_to_set m' = set (it_to_list iterateoi m)\n 3. \\<And>m m'.\n       (m, m') \\<in> br \\<alpha> invar \\<Longrightarrow>\n       sorted_wrt (key_rel (\\<le>)) (it_to_list iterateoi m)", "assume \"(m, m') \\<in> br \\<alpha> invar\""], ["proof (state)\nthis:\n  (m, m') \\<in> br \\<alpha> invar\n\ngoal (3 subgoals):\n 1. \\<And>m m'.\n       (m, m') \\<in> br \\<alpha> invar \\<Longrightarrow>\n       distinct (it_to_list iterateoi m)\n 2. \\<And>m m'.\n       (m, m') \\<in> br \\<alpha> invar \\<Longrightarrow>\n       map_to_set m' = set (it_to_list iterateoi m)\n 3. \\<And>m m'.\n       (m, m') \\<in> br \\<alpha> invar \\<Longrightarrow>\n       sorted_wrt (key_rel (\\<le>)) (it_to_list iterateoi m)", "hence I: \"invar m\" and M': \"m' = \\<alpha> m\""], ["proof (prove)\nusing this:\n  (m, m') \\<in> br \\<alpha> invar\n\ngoal (1 subgoal):\n 1. invar m &&& m' = \\<alpha> m", "by (simp_all add: br_def)"], ["proof (state)\nthis:\n  invar m\n  m' = \\<alpha> m\n\ngoal (3 subgoals):\n 1. \\<And>m m'.\n       (m, m') \\<in> br \\<alpha> invar \\<Longrightarrow>\n       distinct (it_to_list iterateoi m)\n 2. \\<And>m m'.\n       (m, m') \\<in> br \\<alpha> invar \\<Longrightarrow>\n       map_to_set m' = set (it_to_list iterateoi m)\n 3. \\<And>m m'.\n       (m, m') \\<in> br \\<alpha> invar \\<Longrightarrow>\n       sorted_wrt (key_rel (\\<le>)) (it_to_list iterateoi m)", "have [simp]: \"\\<And>c. (\\<lambda>(_,_). c) = (\\<lambda>_. c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c. (\\<lambda>(uu_, uu_). c) = (\\<lambda>_. c)", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>(uu_, uu_). ?c2) = (\\<lambda>_. ?c2)\n\ngoal (3 subgoals):\n 1. \\<And>m m'.\n       (m, m') \\<in> br \\<alpha> invar \\<Longrightarrow>\n       distinct (it_to_list iterateoi m)\n 2. \\<And>m m'.\n       (m, m') \\<in> br \\<alpha> invar \\<Longrightarrow>\n       map_to_set m' = set (it_to_list iterateoi m)\n 3. \\<And>m m'.\n       (m, m') \\<in> br \\<alpha> invar \\<Longrightarrow>\n       sorted_wrt (key_rel (\\<le>)) (it_to_list iterateoi m)", "from map_it_to_list_linord_correct[where it = iterateoi, \n      OF iterateoi_correct[OF I]\n    ]"], ["proof (chain)\npicking this:\n  map_of (it_to_list iterateoi m) = \\<alpha> m \\<and>\n  distinct (map fst (it_to_list iterateoi m)) \\<and>\n  sorted (map fst (it_to_list iterateoi m))", "have \n        M: \"map_of (it_to_list iterateoi m) = \\<alpha> m\"\n        and D: \"distinct (map fst (it_to_list iterateoi m))\"\n        and S: \"sorted (map fst (it_to_list iterateoi m))\""], ["proof (prove)\nusing this:\n  map_of (it_to_list iterateoi m) = \\<alpha> m \\<and>\n  distinct (map fst (it_to_list iterateoi m)) \\<and>\n  sorted (map fst (it_to_list iterateoi m))\n\ngoal (1 subgoal):\n 1. map_of (it_to_list iterateoi m) = \\<alpha> m &&&\n    distinct (map fst (it_to_list iterateoi m)) &&&\n    sorted (map fst (it_to_list iterateoi m))", "by (simp_all)"], ["proof (state)\nthis:\n  map_of (it_to_list iterateoi m) = \\<alpha> m\n  distinct (map fst (it_to_list iterateoi m))\n  sorted (map fst (it_to_list iterateoi m))\n\ngoal (3 subgoals):\n 1. \\<And>m m'.\n       (m, m') \\<in> br \\<alpha> invar \\<Longrightarrow>\n       distinct (it_to_list iterateoi m)\n 2. \\<And>m m'.\n       (m, m') \\<in> br \\<alpha> invar \\<Longrightarrow>\n       map_to_set m' = set (it_to_list iterateoi m)\n 3. \\<And>m m'.\n       (m, m') \\<in> br \\<alpha> invar \\<Longrightarrow>\n       sorted_wrt (key_rel (\\<le>)) (it_to_list iterateoi m)", "from D"], ["proof (chain)\npicking this:\n  distinct (map fst (it_to_list iterateoi m))", "show \"distinct (it_to_list iterateoi m)\""], ["proof (prove)\nusing this:\n  distinct (map fst (it_to_list iterateoi m))\n\ngoal (1 subgoal):\n 1. distinct (it_to_list iterateoi m)", "by (rule distinct_mapI)"], ["proof (state)\nthis:\n  distinct (it_to_list iterateoi m)\n\ngoal (2 subgoals):\n 1. \\<And>m m'.\n       (m, m') \\<in> br \\<alpha> invar \\<Longrightarrow>\n       map_to_set m' = set (it_to_list iterateoi m)\n 2. \\<And>m m'.\n       (m, m') \\<in> br \\<alpha> invar \\<Longrightarrow>\n       sorted_wrt (key_rel (\\<le>)) (it_to_list iterateoi m)", "from M"], ["proof (chain)\npicking this:\n  map_of (it_to_list iterateoi m) = \\<alpha> m", "show \"map_to_set m' = set (it_to_list iterateoi m)\""], ["proof (prove)\nusing this:\n  map_of (it_to_list iterateoi m) = \\<alpha> m\n\ngoal (1 subgoal):\n 1. map_to_set m' = set (it_to_list iterateoi m)", "by (simp add: M' map_of_map_to_set[OF D])"], ["proof (state)\nthis:\n  map_to_set m' = set (it_to_list iterateoi m)\n\ngoal (1 subgoal):\n 1. \\<And>m m'.\n       (m, m') \\<in> br \\<alpha> invar \\<Longrightarrow>\n       sorted_wrt (key_rel (\\<le>)) (it_to_list iterateoi m)", "from S"], ["proof (chain)\npicking this:\n  sorted (map fst (it_to_list iterateoi m))", "show \"sorted_wrt (key_rel (\\<le>)) (it_to_list iterateoi m)\""], ["proof (prove)\nusing this:\n  sorted (map fst (it_to_list iterateoi m))\n\ngoal (1 subgoal):\n 1. sorted_wrt (key_rel (\\<le>)) (it_to_list iterateoi m)", "by (simp add: key_rel_def[abs_def])"], ["proof (state)\nthis:\n  sorted_wrt (key_rel (\\<le>)) (it_to_list iterateoi m)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_map_to_sorted_list (\\<le>) Rk Rv rel (it_to_list iterateoi)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in poly_map_rev_iterateoi) proper_ro[proper_it]:\n  \"proper_it' rev_iterateoi rev_iterateoi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it' reverse_iterateoi reverse_iterateoi", "apply (rule proper_it'I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s. proper_it (reverse_iterateoi s) (reverse_iterateoi s)", "by (rule pi_rev_iterateoi)"], ["", "lemma (in poly_map_rev_iterateoi) autoref_rev_iterateoi[autoref_ga_rules]: \n  assumes ID: \"REL_IS_ID Rk\"\n    \"REL_IS_ID Rv\" (* TODO: Unnecessary*)\n  shows \"is_map_to_sorted_list (\\<ge>) Rk Rv rel (it_to_list rev_iterateoi)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_map_to_sorted_list (\\<lambda>x y. y \\<le> x) Rk Rv rel\n     (it_to_list reverse_iterateoi)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_map_to_sorted_list (\\<lambda>x y. y \\<le> x) Rk Rv rel\n     (it_to_list reverse_iterateoi)", "from ID"], ["proof (chain)\npicking this:\n  REL_IS_ID Rk\n  REL_IS_ID Rv", "have [simp]: \"Rk=Id\" \"Rv = Id\""], ["proof (prove)\nusing this:\n  REL_IS_ID Rk\n  REL_IS_ID Rv\n\ngoal (1 subgoal):\n 1. Rk = Id &&& Rv = Id", "by simp_all"], ["proof (state)\nthis:\n  Rk = Id\n  Rv = Id\n\ngoal (1 subgoal):\n 1. is_map_to_sorted_list (\\<lambda>x y. y \\<le> x) Rk Rv rel\n     (it_to_list reverse_iterateoi)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_map_to_sorted_list (\\<lambda>x y. y \\<le> x) Rk Rv rel\n     (it_to_list reverse_iterateoi)", "unfolding is_map_to_sorted_list_def\n      it_to_sorted_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>m m'.\n       (m, m') \\<in> \\<langle>Rk, Rv\\<rangle>rel \\<longrightarrow>\n       (\\<exists>l'.\n           (it_to_list reverse_iterateoi m, l')\n           \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel \\<and>\n           RETURN l'\n           \\<le> SPEC\n                  (\\<lambda>l.\n                      distinct l \\<and>\n                      map_to_set m' = set l \\<and>\n                      sorted_wrt (key_rel (\\<lambda>x y. y \\<le> x)) l))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>m m'.\n       (m, m') \\<in> br \\<alpha> invar \\<longrightarrow>\n       distinct (it_to_list reverse_iterateoi m) \\<and>\n       map_to_set m' = set (it_to_list reverse_iterateoi m) \\<and>\n       sorted_wrt (key_rel (\\<lambda>x y. y \\<le> x))\n        (it_to_list reverse_iterateoi m)", "apply (intro allI impI conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>m m'.\n       (m, m') \\<in> br \\<alpha> invar \\<Longrightarrow>\n       distinct (it_to_list reverse_iterateoi m)\n 2. \\<And>m m'.\n       (m, m') \\<in> br \\<alpha> invar \\<Longrightarrow>\n       map_to_set m' = set (it_to_list reverse_iterateoi m)\n 3. \\<And>m m'.\n       (m, m') \\<in> br \\<alpha> invar \\<Longrightarrow>\n       sorted_wrt (key_rel (\\<lambda>x y. y \\<le> x))\n        (it_to_list reverse_iterateoi m)", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>m m'.\n       (m, m') \\<in> br \\<alpha> invar \\<Longrightarrow>\n       distinct (it_to_list reverse_iterateoi m)\n 2. \\<And>m m'.\n       (m, m') \\<in> br \\<alpha> invar \\<Longrightarrow>\n       map_to_set m' = set (it_to_list reverse_iterateoi m)\n 3. \\<And>m m'.\n       (m, m') \\<in> br \\<alpha> invar \\<Longrightarrow>\n       sorted_wrt (key_rel (\\<lambda>x y. y \\<le> x))\n        (it_to_list reverse_iterateoi m)", "fix m m'"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>m m'.\n       (m, m') \\<in> br \\<alpha> invar \\<Longrightarrow>\n       distinct (it_to_list reverse_iterateoi m)\n 2. \\<And>m m'.\n       (m, m') \\<in> br \\<alpha> invar \\<Longrightarrow>\n       map_to_set m' = set (it_to_list reverse_iterateoi m)\n 3. \\<And>m m'.\n       (m, m') \\<in> br \\<alpha> invar \\<Longrightarrow>\n       sorted_wrt (key_rel (\\<lambda>x y. y \\<le> x))\n        (it_to_list reverse_iterateoi m)", "assume \"(m, m') \\<in> br \\<alpha> invar\""], ["proof (state)\nthis:\n  (m, m') \\<in> br \\<alpha> invar\n\ngoal (3 subgoals):\n 1. \\<And>m m'.\n       (m, m') \\<in> br \\<alpha> invar \\<Longrightarrow>\n       distinct (it_to_list reverse_iterateoi m)\n 2. \\<And>m m'.\n       (m, m') \\<in> br \\<alpha> invar \\<Longrightarrow>\n       map_to_set m' = set (it_to_list reverse_iterateoi m)\n 3. \\<And>m m'.\n       (m, m') \\<in> br \\<alpha> invar \\<Longrightarrow>\n       sorted_wrt (key_rel (\\<lambda>x y. y \\<le> x))\n        (it_to_list reverse_iterateoi m)", "hence I: \"invar m\" and M': \"m' = \\<alpha> m\""], ["proof (prove)\nusing this:\n  (m, m') \\<in> br \\<alpha> invar\n\ngoal (1 subgoal):\n 1. invar m &&& m' = \\<alpha> m", "by (simp_all add: br_def)"], ["proof (state)\nthis:\n  invar m\n  m' = \\<alpha> m\n\ngoal (3 subgoals):\n 1. \\<And>m m'.\n       (m, m') \\<in> br \\<alpha> invar \\<Longrightarrow>\n       distinct (it_to_list reverse_iterateoi m)\n 2. \\<And>m m'.\n       (m, m') \\<in> br \\<alpha> invar \\<Longrightarrow>\n       map_to_set m' = set (it_to_list reverse_iterateoi m)\n 3. \\<And>m m'.\n       (m, m') \\<in> br \\<alpha> invar \\<Longrightarrow>\n       sorted_wrt (key_rel (\\<lambda>x y. y \\<le> x))\n        (it_to_list reverse_iterateoi m)", "have [simp]: \"\\<And>c. (\\<lambda>(_,_). c) = (\\<lambda>_. c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c. (\\<lambda>(uu_, uu_). c) = (\\<lambda>_. c)", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>(uu_, uu_). ?c4) = (\\<lambda>_. ?c4)\n\ngoal (3 subgoals):\n 1. \\<And>m m'.\n       (m, m') \\<in> br \\<alpha> invar \\<Longrightarrow>\n       distinct (it_to_list reverse_iterateoi m)\n 2. \\<And>m m'.\n       (m, m') \\<in> br \\<alpha> invar \\<Longrightarrow>\n       map_to_set m' = set (it_to_list reverse_iterateoi m)\n 3. \\<And>m m'.\n       (m, m') \\<in> br \\<alpha> invar \\<Longrightarrow>\n       sorted_wrt (key_rel (\\<lambda>x y. y \\<le> x))\n        (it_to_list reverse_iterateoi m)", "from map_it_to_list_rev_linord_correct[where it = rev_iterateoi, \n      OF rev_iterateoi_correct[OF I]\n    ]"], ["proof (chain)\npicking this:\n  map_of (it_to_list reverse_iterateoi m) = \\<alpha> m \\<and>\n  distinct (map fst (it_to_list reverse_iterateoi m)) \\<and>\n  sorted (rev (map fst (it_to_list reverse_iterateoi m)))", "have \n        M: \"map_of (it_to_list rev_iterateoi m) = \\<alpha> m\"\n        and D: \"distinct (map fst (it_to_list rev_iterateoi m))\"\n        and S: \"sorted (rev (map fst (it_to_list rev_iterateoi m)))\""], ["proof (prove)\nusing this:\n  map_of (it_to_list reverse_iterateoi m) = \\<alpha> m \\<and>\n  distinct (map fst (it_to_list reverse_iterateoi m)) \\<and>\n  sorted (rev (map fst (it_to_list reverse_iterateoi m)))\n\ngoal (1 subgoal):\n 1. map_of (it_to_list reverse_iterateoi m) = \\<alpha> m &&&\n    distinct (map fst (it_to_list reverse_iterateoi m)) &&&\n    sorted (rev (map fst (it_to_list reverse_iterateoi m)))", "by (simp_all)"], ["proof (state)\nthis:\n  map_of (it_to_list reverse_iterateoi m) = \\<alpha> m\n  distinct (map fst (it_to_list reverse_iterateoi m))\n  sorted (rev (map fst (it_to_list reverse_iterateoi m)))\n\ngoal (3 subgoals):\n 1. \\<And>m m'.\n       (m, m') \\<in> br \\<alpha> invar \\<Longrightarrow>\n       distinct (it_to_list reverse_iterateoi m)\n 2. \\<And>m m'.\n       (m, m') \\<in> br \\<alpha> invar \\<Longrightarrow>\n       map_to_set m' = set (it_to_list reverse_iterateoi m)\n 3. \\<And>m m'.\n       (m, m') \\<in> br \\<alpha> invar \\<Longrightarrow>\n       sorted_wrt (key_rel (\\<lambda>x y. y \\<le> x))\n        (it_to_list reverse_iterateoi m)", "from D"], ["proof (chain)\npicking this:\n  distinct (map fst (it_to_list reverse_iterateoi m))", "show \"distinct (it_to_list rev_iterateoi m)\""], ["proof (prove)\nusing this:\n  distinct (map fst (it_to_list reverse_iterateoi m))\n\ngoal (1 subgoal):\n 1. distinct (it_to_list reverse_iterateoi m)", "by (rule distinct_mapI)"], ["proof (state)\nthis:\n  distinct (it_to_list reverse_iterateoi m)\n\ngoal (2 subgoals):\n 1. \\<And>m m'.\n       (m, m') \\<in> br \\<alpha> invar \\<Longrightarrow>\n       map_to_set m' = set (it_to_list reverse_iterateoi m)\n 2. \\<And>m m'.\n       (m, m') \\<in> br \\<alpha> invar \\<Longrightarrow>\n       sorted_wrt (key_rel (\\<lambda>x y. y \\<le> x))\n        (it_to_list reverse_iterateoi m)", "from M"], ["proof (chain)\npicking this:\n  map_of (it_to_list reverse_iterateoi m) = \\<alpha> m", "show \"map_to_set m' = set (it_to_list rev_iterateoi m)\""], ["proof (prove)\nusing this:\n  map_of (it_to_list reverse_iterateoi m) = \\<alpha> m\n\ngoal (1 subgoal):\n 1. map_to_set m' = set (it_to_list reverse_iterateoi m)", "by (simp add: M' map_of_map_to_set[OF D])"], ["proof (state)\nthis:\n  map_to_set m' = set (it_to_list reverse_iterateoi m)\n\ngoal (1 subgoal):\n 1. \\<And>m m'.\n       (m, m') \\<in> br \\<alpha> invar \\<Longrightarrow>\n       sorted_wrt (key_rel (\\<lambda>x y. y \\<le> x))\n        (it_to_list reverse_iterateoi m)", "from S"], ["proof (chain)\npicking this:\n  sorted (rev (map fst (it_to_list reverse_iterateoi m)))", "show \"sorted_wrt (key_rel (\\<ge>)) (it_to_list rev_iterateoi m)\""], ["proof (prove)\nusing this:\n  sorted (rev (map fst (it_to_list reverse_iterateoi m)))\n\ngoal (1 subgoal):\n 1. sorted_wrt (key_rel (\\<lambda>x y. y \\<le> x))\n     (it_to_list reverse_iterateoi m)", "by (simp add: key_rel_def[abs_def])"], ["proof (state)\nthis:\n  sorted_wrt (key_rel (\\<lambda>x y. y \\<le> x))\n   (it_to_list reverse_iterateoi m)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  is_map_to_sorted_list (\\<lambda>x y. y \\<le> x) Rk Rv rel\n   (it_to_list reverse_iterateoi)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}