{"file_name": "/home/qj213/afp-2021-10-22/thys/Collections/ICF/gen_algo/Algos.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Collections", "problem_names": ["lemma inatseg_simps[simp]:\n  \"inatseg {}\"\n  \"inatseg {0}\"", "lemma map_to_nat_correct:\n    assumes INV[simp]: \"s.invar s\"\n    shows \n      \\<comment> \\<open>All elements have got a number\\<close>\n      \"dom (m.\\<alpha> (map_to_nat s)) = s.\\<alpha> s\" (is ?T1) and\n      \\<comment> \\<open>No two elements got the same number\\<close>\n      [rule_format]: \"inj_on (m.\\<alpha> (map_to_nat s)) (s.\\<alpha> s)\" (is ?T2) and\n      \\<comment> \\<open>Numbering is inatseg\\<close>\n      [rule_format]: \"inatseg (ran (m.\\<alpha> (map_to_nat s)))\" (is ?T3) and\n      \\<comment> \\<open>The result satisfies the map invariant\\<close>\n      \"m.invar (map_to_nat s)\" (is ?T4)", "lemma it_dom_fun_to_map_correct:\n    assumes INV: \"s.invar s\"\n    shows \"m.\\<alpha> (it_dom_fun_to_map s f) k \n      = (if k \\<in> s.\\<alpha> s then Some (f k) else None)\" (is ?G1)\n    and \"m.invar (it_dom_fun_to_map s f)\" (is ?G2)", "lemma g_set_to_listl_correct: \n    assumes I: \"s.invar s\"\n    shows \"List.set (l.\\<alpha> (g_set_to_listl s)) = s.\\<alpha> s\"\n    and \"l.invar (g_set_to_listl s)\"\n    and \"distinct (l.\\<alpha> (g_set_to_listl s))\"", "lemma g_set_to_listr_correct: \n    assumes I: \"s.invar s\"\n    shows \"List.set (l.\\<alpha> (g_set_to_listr s)) = s.\\<alpha> s\"\n    and \"l.invar (g_set_to_listr s)\"\n    and \"distinct (l.\\<alpha> (g_set_to_listr s))\""], "translations": [["", "lemma inatseg_simps[simp]:\n  \"inatseg {}\"\n  \"inatseg {0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inatseg {} &&& inatseg {0}", "by (unfold inatseg_def)\n    auto"], ["", "text \"Compute an injective map from objects into an initial \n    segment of the natural numbers\""], ["", "locale map_to_nat_loc = \n  s: StdSet s_ops +\n  m: StdMap m_ops\n  for s_ops :: \"('x,'s,'more1) set_ops_scheme\"\n  and m_ops :: \"('x,nat,'m,'more2) map_ops_scheme\"\nbegin"], ["", "definition map_to_nat \n    :: \"'s \\<Rightarrow> 'm\" where\n    \"map_to_nat s ==\n      snd (s.iterate s (\\<lambda>x (c,m). (c+1,m.update x c m)) (0,m.empty ()))\""], ["", "lemma map_to_nat_correct:\n    assumes INV[simp]: \"s.invar s\"\n    shows \n      \\<comment> \\<open>All elements have got a number\\<close>\n      \"dom (m.\\<alpha> (map_to_nat s)) = s.\\<alpha> s\" (is ?T1) and\n      \\<comment> \\<open>No two elements got the same number\\<close>\n      [rule_format]: \"inj_on (m.\\<alpha> (map_to_nat s)) (s.\\<alpha> s)\" (is ?T2) and\n      \\<comment> \\<open>Numbering is inatseg\\<close>\n      [rule_format]: \"inatseg (ran (m.\\<alpha> (map_to_nat s)))\" (is ?T3) and\n      \\<comment> \\<open>The result satisfies the map invariant\\<close>\n      \"m.invar (map_to_nat s)\" (is ?T4)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (dom (m.\\<alpha> (map_to_nat s)) = s.\\<alpha> s &&&\n     inj_on (m.\\<alpha> (map_to_nat s)) (s.\\<alpha> s)) &&&\n    inatseg (ran (m.\\<alpha> (map_to_nat s))) &&& m.invar (map_to_nat s)", "proof -"], ["proof (state)\ngoal (4 subgoals):\n 1. dom (m.\\<alpha> (map_to_nat s)) = s.\\<alpha> s\n 2. inj_on (m.\\<alpha> (map_to_nat s)) (s.\\<alpha> s)\n 3. inatseg (ran (m.\\<alpha> (map_to_nat s)))\n 4. m.invar (map_to_nat s)", "have i_aux: \"!!m S S' k v. \\<lbrakk>inj_on m S; S' = insert k S; v\\<notin>ran m\\<rbrakk> \n                                 \\<Longrightarrow> inj_on (m(k\\<mapsto>v)) S'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m S S' k v.\n       \\<lbrakk>inj_on m S; S' = insert k S; v \\<notin> ran m\\<rbrakk>\n       \\<Longrightarrow> inj_on (m(k \\<mapsto> v)) S'", "apply (rule inj_onI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m S S' k v x y.\n       \\<lbrakk>inj_on m S; S' = insert k S; v \\<notin> ran m; x \\<in> S';\n        y \\<in> S'; (m(k \\<mapsto> v)) x = (m(k \\<mapsto> v)) y\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (simp split: if_split_asm)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>m S S' k v x y.\n       \\<lbrakk>inj_on m S; S' = insert k S; v \\<notin> ran m; x \\<in> S;\n        y = k; x \\<noteq> k; m x = Some v\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>m S S' k v x y.\n       \\<lbrakk>inj_on m S; S' = insert k S; v \\<notin> ran m; y \\<in> S;\n        y \\<noteq> k; x = k; Some v = m y\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>m S S' k v x y.\n       \\<lbrakk>inj_on m S; S' = insert k S; v \\<notin> ran m; x \\<in> S;\n        y \\<in> S; y \\<noteq> k; x \\<noteq> k; m x = m y\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (simp add: ran_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m S S' k v x y.\n       \\<lbrakk>inj_on m S; S' = insert k S; v \\<notin> ran m; y \\<in> S;\n        y \\<noteq> k; x = k; Some v = m y\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>m S S' k v x y.\n       \\<lbrakk>inj_on m S; S' = insert k S; v \\<notin> ran m; x \\<in> S;\n        y \\<in> S; y \\<noteq> k; x \\<noteq> k; m x = m y\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (simp add: ran_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m S S' k v x y.\n       \\<lbrakk>inj_on m S; S' = insert k S; \\<forall>a. m a \\<noteq> m y;\n        y \\<in> S; y \\<noteq> k; x = k; Some v = m y\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>m S S' k v x y.\n       \\<lbrakk>inj_on m S; S' = insert k S; v \\<notin> ran m; x \\<in> S;\n        y \\<in> S; y \\<noteq> k; x \\<noteq> k; m x = m y\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m S S' k v x y.\n       \\<lbrakk>inj_on m S; S' = insert k S; v \\<notin> ran m; x \\<in> S;\n        y \\<in> S; y \\<noteq> k; x \\<noteq> k; m x = m y\\<rbrakk>\n       \\<Longrightarrow> x = y", "apply (blast dest: inj_onD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<lbrakk>inj_on ?m2 ?S2; ?S'2 = insert ?k2 ?S2;\n   ?v2 \\<notin> ran ?m2\\<rbrakk>\n  \\<Longrightarrow> inj_on (?m2(?k2 \\<mapsto> ?v2)) ?S'2\n\ngoal (4 subgoals):\n 1. dom (m.\\<alpha> (map_to_nat s)) = s.\\<alpha> s\n 2. inj_on (m.\\<alpha> (map_to_nat s)) (s.\\<alpha> s)\n 3. inatseg (ran (m.\\<alpha> (map_to_nat s)))\n 4. m.invar (map_to_nat s)", "have \"?T1 \\<and> ?T2 \\<and> ?T3 \\<and> ?T4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (m.\\<alpha> (map_to_nat s)) = s.\\<alpha> s \\<and>\n    inj_on (m.\\<alpha> (map_to_nat s)) (s.\\<alpha> s) \\<and>\n    inatseg (ran (m.\\<alpha> (map_to_nat s))) \\<and> m.invar (map_to_nat s)", "apply (unfold map_to_nat_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (m.\\<alpha>\n          (snd (s.iterate s (\\<lambda>x (c, m). (c + 1, m.update x c m))\n                 (0, m.empty ())))) =\n    s.\\<alpha> s \\<and>\n    inj_on\n     (m.\\<alpha>\n       (snd (s.iterate s (\\<lambda>x (c, m). (c + 1, m.update x c m))\n              (0, m.empty ()))))\n     (s.\\<alpha> s) \\<and>\n    inatseg\n     (ran (m.\\<alpha>\n            (snd (s.iterate s (\\<lambda>x (c, m). (c + 1, m.update x c m))\n                   (0, m.empty ()))))) \\<and>\n    m.invar\n     (snd (s.iterate s (\\<lambda>x (c, m). (c + 1, m.update x c m))\n            (0, m.empty ())))", "apply (rule_tac I=\"\\<lambda>it (c,m). \n          m.invar m \\<and> \n          dom (m.\\<alpha> m) = s.\\<alpha> s - it \\<and> \n          inj_on (m.\\<alpha> m) (s.\\<alpha> s - it) \\<and> \n          (ran (m.\\<alpha> m) = {i. i<c})\n          \" in s.iterate_rule_P)"], ["proof (prove)\ngoal (4 subgoals):\n 1. s.invar s\n 2. case (0, m.empty ()) of\n    (c, m) \\<Rightarrow>\n      m.invar m \\<and>\n      dom (m.\\<alpha> m) = s.\\<alpha> s - s.\\<alpha> s \\<and>\n      inj_on (m.\\<alpha> m) (s.\\<alpha> s - s.\\<alpha> s) \\<and>\n      ran (m.\\<alpha> m) = {i. i < c}\n 3. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> s.\\<alpha> s;\n        case \\<sigma> of\n        (c, m) \\<Rightarrow>\n          m.invar m \\<and>\n          dom (m.\\<alpha> m) = s.\\<alpha> s - it \\<and>\n          inj_on (m.\\<alpha> m) (s.\\<alpha> s - it) \\<and>\n          ran (m.\\<alpha> m) = {i. i < c}\\<rbrakk>\n       \\<Longrightarrow> case case \\<sigma> of\n                              (c, m) \\<Rightarrow>\n                                (c + 1, m.update x c m) of\n                         (c, m) \\<Rightarrow>\n                           m.invar m \\<and>\n                           dom (m.\\<alpha> m) =\n                           s.\\<alpha> s - (it - {x}) \\<and>\n                           inj_on (m.\\<alpha> m)\n                            (s.\\<alpha> s - (it - {x})) \\<and>\n                           ran (m.\\<alpha> m) = {i. i < c}\n 4. \\<And>\\<sigma>.\n       case \\<sigma> of\n       (c, m) \\<Rightarrow>\n         m.invar m \\<and>\n         dom (m.\\<alpha> m) = s.\\<alpha> s - {} \\<and>\n         inj_on (m.\\<alpha> m) (s.\\<alpha> s - {}) \\<and>\n         ran (m.\\<alpha> m) = {i. i < c} \\<Longrightarrow>\n       dom (m.\\<alpha> (snd \\<sigma>)) = s.\\<alpha> s \\<and>\n       inj_on (m.\\<alpha> (snd \\<sigma>)) (s.\\<alpha> s) \\<and>\n       inatseg (ran (m.\\<alpha> (snd \\<sigma>))) \\<and>\n       m.invar (snd \\<sigma>)", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. case (0, m.empty ()) of\n    (c, m) \\<Rightarrow>\n      m.invar m \\<and>\n      dom (m.\\<alpha> m) = s.\\<alpha> s - s.\\<alpha> s \\<and>\n      inj_on (m.\\<alpha> m) (s.\\<alpha> s - s.\\<alpha> s) \\<and>\n      ran (m.\\<alpha> m) = {i. i < c}\n 2. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> s.\\<alpha> s;\n        case \\<sigma> of\n        (c, m) \\<Rightarrow>\n          m.invar m \\<and>\n          dom (m.\\<alpha> m) = s.\\<alpha> s - it \\<and>\n          inj_on (m.\\<alpha> m) (s.\\<alpha> s - it) \\<and>\n          ran (m.\\<alpha> m) = {i. i < c}\\<rbrakk>\n       \\<Longrightarrow> case case \\<sigma> of\n                              (c, m) \\<Rightarrow>\n                                (c + 1, m.update x c m) of\n                         (c, m) \\<Rightarrow>\n                           m.invar m \\<and>\n                           dom (m.\\<alpha> m) =\n                           s.\\<alpha> s - (it - {x}) \\<and>\n                           inj_on (m.\\<alpha> m)\n                            (s.\\<alpha> s - (it - {x})) \\<and>\n                           ran (m.\\<alpha> m) = {i. i < c}\n 3. \\<And>\\<sigma>.\n       case \\<sigma> of\n       (c, m) \\<Rightarrow>\n         m.invar m \\<and>\n         dom (m.\\<alpha> m) = s.\\<alpha> s - {} \\<and>\n         inj_on (m.\\<alpha> m) (s.\\<alpha> s - {}) \\<and>\n         ran (m.\\<alpha> m) = {i. i < c} \\<Longrightarrow>\n       dom (m.\\<alpha> (snd \\<sigma>)) = s.\\<alpha> s \\<and>\n       inj_on (m.\\<alpha> (snd \\<sigma>)) (s.\\<alpha> s) \\<and>\n       inatseg (ran (m.\\<alpha> (snd \\<sigma>))) \\<and>\n       m.invar (snd \\<sigma>)", "apply (simp add: m.empty_correct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> s.\\<alpha> s;\n        case \\<sigma> of\n        (c, m) \\<Rightarrow>\n          m.invar m \\<and>\n          dom (m.\\<alpha> m) = s.\\<alpha> s - it \\<and>\n          inj_on (m.\\<alpha> m) (s.\\<alpha> s - it) \\<and>\n          ran (m.\\<alpha> m) = {i. i < c}\\<rbrakk>\n       \\<Longrightarrow> case case \\<sigma> of\n                              (c, m) \\<Rightarrow>\n                                (c + 1, m.update x c m) of\n                         (c, m) \\<Rightarrow>\n                           m.invar m \\<and>\n                           dom (m.\\<alpha> m) =\n                           s.\\<alpha> s - (it - {x}) \\<and>\n                           inj_on (m.\\<alpha> m)\n                            (s.\\<alpha> s - (it - {x})) \\<and>\n                           ran (m.\\<alpha> m) = {i. i < c}\n 2. \\<And>\\<sigma>.\n       case \\<sigma> of\n       (c, m) \\<Rightarrow>\n         m.invar m \\<and>\n         dom (m.\\<alpha> m) = s.\\<alpha> s - {} \\<and>\n         inj_on (m.\\<alpha> m) (s.\\<alpha> s - {}) \\<and>\n         ran (m.\\<alpha> m) = {i. i < c} \\<Longrightarrow>\n       dom (m.\\<alpha> (snd \\<sigma>)) = s.\\<alpha> s \\<and>\n       inj_on (m.\\<alpha> (snd \\<sigma>)) (s.\\<alpha> s) \\<and>\n       inatseg (ran (m.\\<alpha> (snd \\<sigma>))) \\<and>\n       m.invar (snd \\<sigma>)", "apply (case_tac \\<sigma>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x it \\<sigma> a b.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> s.\\<alpha> s;\n        case \\<sigma> of\n        (c, m) \\<Rightarrow>\n          m.invar m \\<and>\n          dom (m.\\<alpha> m) = s.\\<alpha> s - it \\<and>\n          inj_on (m.\\<alpha> m) (s.\\<alpha> s - it) \\<and>\n          ran (m.\\<alpha> m) = {i. i < c};\n        \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> case case \\<sigma> of\n                              (c, m) \\<Rightarrow>\n                                (c + 1, m.update x c m) of\n                         (c, m) \\<Rightarrow>\n                           m.invar m \\<and>\n                           dom (m.\\<alpha> m) =\n                           s.\\<alpha> s - (it - {x}) \\<and>\n                           inj_on (m.\\<alpha> m)\n                            (s.\\<alpha> s - (it - {x})) \\<and>\n                           ran (m.\\<alpha> m) = {i. i < c}\n 2. \\<And>\\<sigma>.\n       case \\<sigma> of\n       (c, m) \\<Rightarrow>\n         m.invar m \\<and>\n         dom (m.\\<alpha> m) = s.\\<alpha> s - {} \\<and>\n         inj_on (m.\\<alpha> m) (s.\\<alpha> s - {}) \\<and>\n         ran (m.\\<alpha> m) = {i. i < c} \\<Longrightarrow>\n       dom (m.\\<alpha> (snd \\<sigma>)) = s.\\<alpha> s \\<and>\n       inj_on (m.\\<alpha> (snd \\<sigma>)) (s.\\<alpha> s) \\<and>\n       inatseg (ran (m.\\<alpha> (snd \\<sigma>))) \\<and>\n       m.invar (snd \\<sigma>)", "apply (simp add: m.empty_correct m.update_correct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x it \\<sigma> a b.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> s.\\<alpha> s;\n        m.invar b \\<and>\n        dom (m.\\<alpha> b) = s.\\<alpha> s - it \\<and>\n        inj_on (m.\\<alpha> b) (s.\\<alpha> s - it) \\<and>\n        ran (m.\\<alpha> b) = {i. i < a};\n        \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> insert x (s.\\<alpha> s - it) =\n                         s.\\<alpha> s - (it - {x}) \\<and>\n                         inj_on (m.\\<alpha> b(x \\<mapsto> a))\n                          (s.\\<alpha> s - (it - {x})) \\<and>\n                         ran (m.\\<alpha> b(x \\<mapsto> a)) = {i. i < Suc a}\n 2. \\<And>\\<sigma>.\n       case \\<sigma> of\n       (c, m) \\<Rightarrow>\n         m.invar m \\<and>\n         dom (m.\\<alpha> m) = s.\\<alpha> s - {} \\<and>\n         inj_on (m.\\<alpha> m) (s.\\<alpha> s - {}) \\<and>\n         ran (m.\\<alpha> m) = {i. i < c} \\<Longrightarrow>\n       dom (m.\\<alpha> (snd \\<sigma>)) = s.\\<alpha> s \\<and>\n       inj_on (m.\\<alpha> (snd \\<sigma>)) (s.\\<alpha> s) \\<and>\n       inatseg (ran (m.\\<alpha> (snd \\<sigma>))) \\<and>\n       m.invar (snd \\<sigma>)", "apply (intro conjI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x it \\<sigma> a b.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> s.\\<alpha> s;\n        m.invar b \\<and>\n        dom (m.\\<alpha> b) = s.\\<alpha> s - it \\<and>\n        inj_on (m.\\<alpha> b) (s.\\<alpha> s - it) \\<and>\n        ran (m.\\<alpha> b) = {i. i < a};\n        \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> insert x (s.\\<alpha> s - it) =\n                         s.\\<alpha> s - (it - {x})\n 2. \\<And>x it \\<sigma> a b.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> s.\\<alpha> s;\n        m.invar b \\<and>\n        dom (m.\\<alpha> b) = s.\\<alpha> s - it \\<and>\n        inj_on (m.\\<alpha> b) (s.\\<alpha> s - it) \\<and>\n        ran (m.\\<alpha> b) = {i. i < a};\n        \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> inj_on (m.\\<alpha> b(x \\<mapsto> a))\n                          (s.\\<alpha> s - (it - {x}))\n 3. \\<And>x it \\<sigma> a b.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> s.\\<alpha> s;\n        m.invar b \\<and>\n        dom (m.\\<alpha> b) = s.\\<alpha> s - it \\<and>\n        inj_on (m.\\<alpha> b) (s.\\<alpha> s - it) \\<and>\n        ran (m.\\<alpha> b) = {i. i < a};\n        \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> ran (m.\\<alpha> b(x \\<mapsto> a)) = {i. i < Suc a}\n 4. \\<And>\\<sigma>.\n       case \\<sigma> of\n       (c, m) \\<Rightarrow>\n         m.invar m \\<and>\n         dom (m.\\<alpha> m) = s.\\<alpha> s - {} \\<and>\n         inj_on (m.\\<alpha> m) (s.\\<alpha> s - {}) \\<and>\n         ran (m.\\<alpha> m) = {i. i < c} \\<Longrightarrow>\n       dom (m.\\<alpha> (snd \\<sigma>)) = s.\\<alpha> s \\<and>\n       inj_on (m.\\<alpha> (snd \\<sigma>)) (s.\\<alpha> s) \\<and>\n       inatseg (ran (m.\\<alpha> (snd \\<sigma>))) \\<and>\n       m.invar (snd \\<sigma>)", "apply blast"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x it \\<sigma> a b.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> s.\\<alpha> s;\n        m.invar b \\<and>\n        dom (m.\\<alpha> b) = s.\\<alpha> s - it \\<and>\n        inj_on (m.\\<alpha> b) (s.\\<alpha> s - it) \\<and>\n        ran (m.\\<alpha> b) = {i. i < a};\n        \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> inj_on (m.\\<alpha> b(x \\<mapsto> a))\n                          (s.\\<alpha> s - (it - {x}))\n 2. \\<And>x it \\<sigma> a b.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> s.\\<alpha> s;\n        m.invar b \\<and>\n        dom (m.\\<alpha> b) = s.\\<alpha> s - it \\<and>\n        inj_on (m.\\<alpha> b) (s.\\<alpha> s - it) \\<and>\n        ran (m.\\<alpha> b) = {i. i < a};\n        \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> ran (m.\\<alpha> b(x \\<mapsto> a)) = {i. i < Suc a}\n 3. \\<And>\\<sigma>.\n       case \\<sigma> of\n       (c, m) \\<Rightarrow>\n         m.invar m \\<and>\n         dom (m.\\<alpha> m) = s.\\<alpha> s - {} \\<and>\n         inj_on (m.\\<alpha> m) (s.\\<alpha> s - {}) \\<and>\n         ran (m.\\<alpha> m) = {i. i < c} \\<Longrightarrow>\n       dom (m.\\<alpha> (snd \\<sigma>)) = s.\\<alpha> s \\<and>\n       inj_on (m.\\<alpha> (snd \\<sigma>)) (s.\\<alpha> s) \\<and>\n       inatseg (ran (m.\\<alpha> (snd \\<sigma>))) \\<and>\n       m.invar (snd \\<sigma>)", "apply clarify"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x it a b aa ba.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> s.\\<alpha> s; m.invar ba;\n        dom (m.\\<alpha> ba) = s.\\<alpha> s - it;\n        inj_on (m.\\<alpha> ba) (s.\\<alpha> s - it);\n        ran (m.\\<alpha> ba) = {i. i < aa}\\<rbrakk>\n       \\<Longrightarrow> inj_on (m.\\<alpha> ba(x \\<mapsto> aa))\n                          (s.\\<alpha> s - (it - {x}))\n 2. \\<And>x it \\<sigma> a b.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> s.\\<alpha> s;\n        m.invar b \\<and>\n        dom (m.\\<alpha> b) = s.\\<alpha> s - it \\<and>\n        inj_on (m.\\<alpha> b) (s.\\<alpha> s - it) \\<and>\n        ran (m.\\<alpha> b) = {i. i < a};\n        \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> ran (m.\\<alpha> b(x \\<mapsto> a)) = {i. i < Suc a}\n 3. \\<And>\\<sigma>.\n       case \\<sigma> of\n       (c, m) \\<Rightarrow>\n         m.invar m \\<and>\n         dom (m.\\<alpha> m) = s.\\<alpha> s - {} \\<and>\n         inj_on (m.\\<alpha> m) (s.\\<alpha> s - {}) \\<and>\n         ran (m.\\<alpha> m) = {i. i < c} \\<Longrightarrow>\n       dom (m.\\<alpha> (snd \\<sigma>)) = s.\\<alpha> s \\<and>\n       inj_on (m.\\<alpha> (snd \\<sigma>)) (s.\\<alpha> s) \\<and>\n       inatseg (ran (m.\\<alpha> (snd \\<sigma>))) \\<and>\n       m.invar (snd \\<sigma>)", "apply (rule_tac m2=\"m.\\<alpha> ba\" and \n                        k2=x and v2=aa and \n                        S'2=\"(s.\\<alpha> s - (it - {x}))\" and \n                        S2=\"(s.\\<alpha> s - it)\" \n                        in i_aux)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x it a b aa ba.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> s.\\<alpha> s; m.invar ba;\n        dom (m.\\<alpha> ba) = s.\\<alpha> s - it;\n        inj_on (m.\\<alpha> ba) (s.\\<alpha> s - it);\n        ran (m.\\<alpha> ba) = {i. i < aa}\\<rbrakk>\n       \\<Longrightarrow> inj_on (m.\\<alpha> ba) (s.\\<alpha> s - it)\n 2. \\<And>x it a b aa ba.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> s.\\<alpha> s; m.invar ba;\n        dom (m.\\<alpha> ba) = s.\\<alpha> s - it;\n        inj_on (m.\\<alpha> ba) (s.\\<alpha> s - it);\n        ran (m.\\<alpha> ba) = {i. i < aa}\\<rbrakk>\n       \\<Longrightarrow> s.\\<alpha> s - (it - {x}) =\n                         insert x (s.\\<alpha> s - it)\n 3. \\<And>x it a b aa ba.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> s.\\<alpha> s; m.invar ba;\n        dom (m.\\<alpha> ba) = s.\\<alpha> s - it;\n        inj_on (m.\\<alpha> ba) (s.\\<alpha> s - it);\n        ran (m.\\<alpha> ba) = {i. i < aa}\\<rbrakk>\n       \\<Longrightarrow> aa \\<notin> ran (m.\\<alpha> ba)\n 4. \\<And>x it \\<sigma> a b.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> s.\\<alpha> s;\n        m.invar b \\<and>\n        dom (m.\\<alpha> b) = s.\\<alpha> s - it \\<and>\n        inj_on (m.\\<alpha> b) (s.\\<alpha> s - it) \\<and>\n        ran (m.\\<alpha> b) = {i. i < a};\n        \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> ran (m.\\<alpha> b(x \\<mapsto> a)) = {i. i < Suc a}\n 5. \\<And>\\<sigma>.\n       case \\<sigma> of\n       (c, m) \\<Rightarrow>\n         m.invar m \\<and>\n         dom (m.\\<alpha> m) = s.\\<alpha> s - {} \\<and>\n         inj_on (m.\\<alpha> m) (s.\\<alpha> s - {}) \\<and>\n         ran (m.\\<alpha> m) = {i. i < c} \\<Longrightarrow>\n       dom (m.\\<alpha> (snd \\<sigma>)) = s.\\<alpha> s \\<and>\n       inj_on (m.\\<alpha> (snd \\<sigma>)) (s.\\<alpha> s) \\<and>\n       inatseg (ran (m.\\<alpha> (snd \\<sigma>))) \\<and>\n       m.invar (snd \\<sigma>)", "apply auto [3]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x it \\<sigma> a b.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> s.\\<alpha> s;\n        m.invar b \\<and>\n        dom (m.\\<alpha> b) = s.\\<alpha> s - it \\<and>\n        inj_on (m.\\<alpha> b) (s.\\<alpha> s - it) \\<and>\n        ran (m.\\<alpha> b) = {i. i < a};\n        \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> ran (m.\\<alpha> b(x \\<mapsto> a)) = {i. i < Suc a}\n 2. \\<And>\\<sigma>.\n       case \\<sigma> of\n       (c, m) \\<Rightarrow>\n         m.invar m \\<and>\n         dom (m.\\<alpha> m) = s.\\<alpha> s - {} \\<and>\n         inj_on (m.\\<alpha> m) (s.\\<alpha> s - {}) \\<and>\n         ran (m.\\<alpha> m) = {i. i < c} \\<Longrightarrow>\n       dom (m.\\<alpha> (snd \\<sigma>)) = s.\\<alpha> s \\<and>\n       inj_on (m.\\<alpha> (snd \\<sigma>)) (s.\\<alpha> s) \\<and>\n       inatseg (ran (m.\\<alpha> (snd \\<sigma>))) \\<and>\n       m.invar (snd \\<sigma>)", "apply auto [1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       case \\<sigma> of\n       (c, m) \\<Rightarrow>\n         m.invar m \\<and>\n         dom (m.\\<alpha> m) = s.\\<alpha> s - {} \\<and>\n         inj_on (m.\\<alpha> m) (s.\\<alpha> s - {}) \\<and>\n         ran (m.\\<alpha> m) = {i. i < c} \\<Longrightarrow>\n       dom (m.\\<alpha> (snd \\<sigma>)) = s.\\<alpha> s \\<and>\n       inj_on (m.\\<alpha> (snd \\<sigma>)) (s.\\<alpha> s) \\<and>\n       inatseg (ran (m.\\<alpha> (snd \\<sigma>))) \\<and>\n       m.invar (snd \\<sigma>)", "apply (case_tac \\<sigma>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> a b.\n       \\<lbrakk>case \\<sigma> of\n                (c, m) \\<Rightarrow>\n                  m.invar m \\<and>\n                  dom (m.\\<alpha> m) = s.\\<alpha> s - {} \\<and>\n                  inj_on (m.\\<alpha> m) (s.\\<alpha> s - {}) \\<and>\n                  ran (m.\\<alpha> m) = {i. i < c};\n        \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> dom (m.\\<alpha> (snd \\<sigma>)) =\n                         s.\\<alpha> s \\<and>\n                         inj_on (m.\\<alpha> (snd \\<sigma>))\n                          (s.\\<alpha> s) \\<and>\n                         inatseg (ran (m.\\<alpha> (snd \\<sigma>))) \\<and>\n                         m.invar (snd \\<sigma>)", "apply (auto simp add: inatseg_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  dom (m.\\<alpha> (map_to_nat s)) = s.\\<alpha> s \\<and>\n  inj_on (m.\\<alpha> (map_to_nat s)) (s.\\<alpha> s) \\<and>\n  inatseg (ran (m.\\<alpha> (map_to_nat s))) \\<and> m.invar (map_to_nat s)\n\ngoal (4 subgoals):\n 1. dom (m.\\<alpha> (map_to_nat s)) = s.\\<alpha> s\n 2. inj_on (m.\\<alpha> (map_to_nat s)) (s.\\<alpha> s)\n 3. inatseg (ran (m.\\<alpha> (map_to_nat s)))\n 4. m.invar (map_to_nat s)", "thus ?T1 ?T2 ?T3 ?T4"], ["proof (prove)\nusing this:\n  dom (m.\\<alpha> (map_to_nat s)) = s.\\<alpha> s \\<and>\n  inj_on (m.\\<alpha> (map_to_nat s)) (s.\\<alpha> s) \\<and>\n  inatseg (ran (m.\\<alpha> (map_to_nat s))) \\<and> m.invar (map_to_nat s)\n\ngoal (1 subgoal):\n 1. (dom (m.\\<alpha> (map_to_nat s)) = s.\\<alpha> s &&&\n     inj_on (m.\\<alpha> (map_to_nat s)) (s.\\<alpha> s)) &&&\n    inatseg (ran (m.\\<alpha> (map_to_nat s))) &&& m.invar (map_to_nat s)", "by auto"], ["proof (state)\nthis:\n  dom (m.\\<alpha> (map_to_nat s)) = s.\\<alpha> s\n  inj_on (m.\\<alpha> (map_to_nat s)) (s.\\<alpha> s)\n  inatseg (ran (m.\\<alpha> (map_to_nat s)))\n  m.invar (map_to_nat s)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \"Map from Set\""], ["", "text \"Build a map using a set of keys and a function to compute the values.\""], ["", "locale it_dom_fun_to_map_loc =\n  s: StdSet s_ops\n+ m: StdMap m_ops \n  for s_ops :: \"('k,'s,'more1) set_ops_scheme\"\n  and m_ops :: \"('k,'v,'m,'more2) map_ops_scheme\"\nbegin"], ["", "definition it_dom_fun_to_map ::\n    \"'s \\<Rightarrow> ('k \\<Rightarrow> 'v) \\<Rightarrow> 'm\"\n    where \"it_dom_fun_to_map s f == \n           s.iterate s (\\<lambda>k m. m.update_dj k (f k) m) (m.empty ())\""], ["", "lemma it_dom_fun_to_map_correct:\n    assumes INV: \"s.invar s\"\n    shows \"m.\\<alpha> (it_dom_fun_to_map s f) k \n      = (if k \\<in> s.\\<alpha> s then Some (f k) else None)\" (is ?G1)\n    and \"m.invar (it_dom_fun_to_map s f)\" (is ?G2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. m.\\<alpha> (it_dom_fun_to_map s f) k =\n    (if k \\<in> s.\\<alpha> s then Some (f k) else None) &&&\n    m.invar (it_dom_fun_to_map s f)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. m.\\<alpha> (it_dom_fun_to_map s f) k =\n    (if k \\<in> s.\\<alpha> s then Some (f k) else None)\n 2. m.invar (it_dom_fun_to_map s f)", "have \"m.\\<alpha> (it_dom_fun_to_map s f) k \n      = (if k \\<in> s.\\<alpha> s then Some (f k) else None) \\<and>\n      m.invar (it_dom_fun_to_map s f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m.\\<alpha> (it_dom_fun_to_map s f) k =\n    (if k \\<in> s.\\<alpha> s then Some (f k) else None) \\<and>\n    m.invar (it_dom_fun_to_map s f)", "unfolding it_dom_fun_to_map_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. m.\\<alpha> (s.iterate s (\\<lambda>k. m.update_dj k (f k)) (m.empty ()))\n     k =\n    (if k \\<in> s.\\<alpha> s then Some (f k) else None) \\<and>\n    m.invar (s.iterate s (\\<lambda>k. m.update_dj k (f k)) (m.empty ()))", "apply (rule s.iterate_rule_P[where \n        I = \"\\<lambda>it res. m.invar res \n        \\<and> (\\<forall>k. m.\\<alpha> res k = (if (k \\<in> (s.\\<alpha> s) - it) then Some (f k) else None))\"\n        ])"], ["proof (prove)\ngoal (4 subgoals):\n 1. s.invar s\n 2. m.invar (m.empty ()) \\<and>\n    (\\<forall>k.\n        m.\\<alpha> (m.empty ()) k =\n        (if k \\<in> s.\\<alpha> s - s.\\<alpha> s then Some (f k) else None))\n 3. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> s.\\<alpha> s;\n        m.invar \\<sigma> \\<and>\n        (\\<forall>k.\n            m.\\<alpha> \\<sigma> k =\n            (if k \\<in> s.\\<alpha> s - it then Some (f k)\n             else None))\\<rbrakk>\n       \\<Longrightarrow> m.invar (m.update_dj x (f x) \\<sigma>) \\<and>\n                         (\\<forall>k.\n                             m.\\<alpha> (m.update_dj x (f x) \\<sigma>) k =\n                             (if k \\<in> s.\\<alpha> s - (it - {x})\n                              then Some (f k) else None))\n 4. \\<And>\\<sigma>.\n       m.invar \\<sigma> \\<and>\n       (\\<forall>k.\n           m.\\<alpha> \\<sigma> k =\n           (if k \\<in> s.\\<alpha> s - {} then Some (f k)\n            else None)) \\<Longrightarrow>\n       m.\\<alpha> \\<sigma> k =\n       (if k \\<in> s.\\<alpha> s then Some (f k) else None) \\<and>\n       m.invar \\<sigma>", "apply (simp add: INV)"], ["proof (prove)\ngoal (3 subgoals):\n 1. m.invar (m.empty ()) \\<and>\n    (\\<forall>k.\n        m.\\<alpha> (m.empty ()) k =\n        (if k \\<in> s.\\<alpha> s - s.\\<alpha> s then Some (f k) else None))\n 2. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> s.\\<alpha> s;\n        m.invar \\<sigma> \\<and>\n        (\\<forall>k.\n            m.\\<alpha> \\<sigma> k =\n            (if k \\<in> s.\\<alpha> s - it then Some (f k)\n             else None))\\<rbrakk>\n       \\<Longrightarrow> m.invar (m.update_dj x (f x) \\<sigma>) \\<and>\n                         (\\<forall>k.\n                             m.\\<alpha> (m.update_dj x (f x) \\<sigma>) k =\n                             (if k \\<in> s.\\<alpha> s - (it - {x})\n                              then Some (f k) else None))\n 3. \\<And>\\<sigma>.\n       m.invar \\<sigma> \\<and>\n       (\\<forall>k.\n           m.\\<alpha> \\<sigma> k =\n           (if k \\<in> s.\\<alpha> s - {} then Some (f k)\n            else None)) \\<Longrightarrow>\n       m.\\<alpha> \\<sigma> k =\n       (if k \\<in> s.\\<alpha> s then Some (f k) else None) \\<and>\n       m.invar \\<sigma>", "apply (simp add: m.empty_correct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> s.\\<alpha> s;\n        m.invar \\<sigma> \\<and>\n        (\\<forall>k.\n            m.\\<alpha> \\<sigma> k =\n            (if k \\<in> s.\\<alpha> s - it then Some (f k)\n             else None))\\<rbrakk>\n       \\<Longrightarrow> m.invar (m.update_dj x (f x) \\<sigma>) \\<and>\n                         (\\<forall>k.\n                             m.\\<alpha> (m.update_dj x (f x) \\<sigma>) k =\n                             (if k \\<in> s.\\<alpha> s - (it - {x})\n                              then Some (f k) else None))\n 2. \\<And>\\<sigma>.\n       m.invar \\<sigma> \\<and>\n       (\\<forall>k.\n           m.\\<alpha> \\<sigma> k =\n           (if k \\<in> s.\\<alpha> s - {} then Some (f k)\n            else None)) \\<Longrightarrow>\n       m.\\<alpha> \\<sigma> k =\n       (if k \\<in> s.\\<alpha> s then Some (f k) else None) \\<and>\n       m.invar \\<sigma>", "apply (subgoal_tac \"x\\<notin>dom (m.\\<alpha> \\<sigma>)\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> s.\\<alpha> s;\n        m.invar \\<sigma> \\<and>\n        (\\<forall>k.\n            m.\\<alpha> \\<sigma> k =\n            (if k \\<in> s.\\<alpha> s - it then Some (f k) else None));\n        x \\<notin> dom (m.\\<alpha> \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> m.invar (m.update_dj x (f x) \\<sigma>) \\<and>\n                         (\\<forall>k.\n                             m.\\<alpha> (m.update_dj x (f x) \\<sigma>) k =\n                             (if k \\<in> s.\\<alpha> s - (it - {x})\n                              then Some (f k) else None))\n 2. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> s.\\<alpha> s;\n        m.invar \\<sigma> \\<and>\n        (\\<forall>k.\n            m.\\<alpha> \\<sigma> k =\n            (if k \\<in> s.\\<alpha> s - it then Some (f k)\n             else None))\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> dom (m.\\<alpha> \\<sigma>)\n 3. \\<And>\\<sigma>.\n       m.invar \\<sigma> \\<and>\n       (\\<forall>k.\n           m.\\<alpha> \\<sigma> k =\n           (if k \\<in> s.\\<alpha> s - {} then Some (f k)\n            else None)) \\<Longrightarrow>\n       m.\\<alpha> \\<sigma> k =\n       (if k \\<in> s.\\<alpha> s then Some (f k) else None) \\<and>\n       m.invar \\<sigma>", "apply (auto simp: INV m.empty_correct m.update_dj_correct) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> s.\\<alpha> s;\n        m.invar \\<sigma> \\<and>\n        (\\<forall>k.\n            m.\\<alpha> \\<sigma> k =\n            (if k \\<in> s.\\<alpha> s - it then Some (f k)\n             else None))\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> dom (m.\\<alpha> \\<sigma>)\n 2. \\<And>\\<sigma>.\n       m.invar \\<sigma> \\<and>\n       (\\<forall>k.\n           m.\\<alpha> \\<sigma> k =\n           (if k \\<in> s.\\<alpha> s - {} then Some (f k)\n            else None)) \\<Longrightarrow>\n       m.\\<alpha> \\<sigma> k =\n       (if k \\<in> s.\\<alpha> s then Some (f k) else None) \\<and>\n       m.invar \\<sigma>", "apply auto [2]"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  m.\\<alpha> (it_dom_fun_to_map s f) k =\n  (if k \\<in> s.\\<alpha> s then Some (f k) else None) \\<and>\n  m.invar (it_dom_fun_to_map s f)\n\ngoal (2 subgoals):\n 1. m.\\<alpha> (it_dom_fun_to_map s f) k =\n    (if k \\<in> s.\\<alpha> s then Some (f k) else None)\n 2. m.invar (it_dom_fun_to_map s f)", "thus ?G1 and ?G2"], ["proof (prove)\nusing this:\n  m.\\<alpha> (it_dom_fun_to_map s f) k =\n  (if k \\<in> s.\\<alpha> s then Some (f k) else None) \\<and>\n  m.invar (it_dom_fun_to_map s f)\n\ngoal (1 subgoal):\n 1. m.\\<alpha> (it_dom_fun_to_map s f) k =\n    (if k \\<in> s.\\<alpha> s then Some (f k) else None) &&&\n    m.invar (it_dom_fun_to_map s f)", "by auto"], ["proof (state)\nthis:\n  m.\\<alpha> (it_dom_fun_to_map s f) k =\n  (if k \\<in> s.\\<alpha> s then Some (f k) else None)\n  m.invar (it_dom_fun_to_map s f)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "locale set_to_list_defs_loc =\n  s: StdSetDefs s_ops\n+ l: StdListDefs l_ops\n  for s_ops :: \"('x,'s,'more1) set_ops_scheme\"\n  and l_ops :: \"('x,'l,'more2) list_ops_scheme\"\nbegin"], ["", "definition \"g_set_to_listl s \\<equiv> s.iterate s l.appendl (l.empty ())\""], ["", "definition \"g_set_to_listr s \\<equiv> s.iterate s l.appendr (l.empty ())\""], ["", "end"], ["", "locale set_to_list_loc = set_to_list_defs_loc s_ops l_ops\n+ s: StdSet s_ops\n+ l: StdList l_ops\n  for s_ops :: \"('x,'s,'more1) set_ops_scheme\"\n  and l_ops :: \"('x,'l,'more2) list_ops_scheme\"\nbegin"], ["", "lemma g_set_to_listl_correct: \n    assumes I: \"s.invar s\"\n    shows \"List.set (l.\\<alpha> (g_set_to_listl s)) = s.\\<alpha> s\"\n    and \"l.invar (g_set_to_listl s)\"\n    and \"distinct (l.\\<alpha> (g_set_to_listl s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (l.\\<alpha> (g_set_to_listl s)) = s.\\<alpha> s &&&\n    l.invar (g_set_to_listl s) &&& distinct (l.\\<alpha> (g_set_to_listl s))", "using I"], ["proof (prove)\nusing this:\n  s.invar s\n\ngoal (1 subgoal):\n 1. set (l.\\<alpha> (g_set_to_listl s)) = s.\\<alpha> s &&&\n    l.invar (g_set_to_listl s) &&& distinct (l.\\<alpha> (g_set_to_listl s))", "apply -"], ["proof (prove)\ngoal (3 subgoals):\n 1. s.invar s \\<Longrightarrow>\n    set (l.\\<alpha> (g_set_to_listl s)) = s.\\<alpha> s\n 2. s.invar s \\<Longrightarrow> l.invar (g_set_to_listl s)\n 3. s.invar s \\<Longrightarrow> distinct (l.\\<alpha> (g_set_to_listl s))", "unfolding g_set_to_listl_def"], ["proof (prove)\ngoal (3 subgoals):\n 1. s.invar s \\<Longrightarrow>\n    set (l.\\<alpha> (s.iterate s l.appendl (l.empty ()))) = s.\\<alpha> s\n 2. s.invar s \\<Longrightarrow> l.invar (s.iterate s l.appendl (l.empty ()))\n 3. s.invar s \\<Longrightarrow>\n    distinct (l.\\<alpha> (s.iterate s l.appendl (l.empty ())))", "apply (rule_tac I=\"\\<lambda>it \\<sigma>. l.invar \\<sigma> \\<and> List.set (l.\\<alpha> \\<sigma>) = it \n      \\<and> distinct (l.\\<alpha> \\<sigma>)\" \n      in s.iterate_rule_insert_P, auto simp: l.correct)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma g_set_to_listr_correct: \n    assumes I: \"s.invar s\"\n    shows \"List.set (l.\\<alpha> (g_set_to_listr s)) = s.\\<alpha> s\"\n    and \"l.invar (g_set_to_listr s)\"\n    and \"distinct (l.\\<alpha> (g_set_to_listr s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (l.\\<alpha> (g_set_to_listr s)) = s.\\<alpha> s &&&\n    l.invar (g_set_to_listr s) &&& distinct (l.\\<alpha> (g_set_to_listr s))", "using I"], ["proof (prove)\nusing this:\n  s.invar s\n\ngoal (1 subgoal):\n 1. set (l.\\<alpha> (g_set_to_listr s)) = s.\\<alpha> s &&&\n    l.invar (g_set_to_listr s) &&& distinct (l.\\<alpha> (g_set_to_listr s))", "apply -"], ["proof (prove)\ngoal (3 subgoals):\n 1. s.invar s \\<Longrightarrow>\n    set (l.\\<alpha> (g_set_to_listr s)) = s.\\<alpha> s\n 2. s.invar s \\<Longrightarrow> l.invar (g_set_to_listr s)\n 3. s.invar s \\<Longrightarrow> distinct (l.\\<alpha> (g_set_to_listr s))", "unfolding g_set_to_listr_def"], ["proof (prove)\ngoal (3 subgoals):\n 1. s.invar s \\<Longrightarrow>\n    set (l.\\<alpha> (s.iterate s l.appendr (l.empty ()))) = s.\\<alpha> s\n 2. s.invar s \\<Longrightarrow> l.invar (s.iterate s l.appendr (l.empty ()))\n 3. s.invar s \\<Longrightarrow>\n    distinct (l.\\<alpha> (s.iterate s l.appendr (l.empty ())))", "apply (rule_tac I=\"\\<lambda>it \\<sigma>. l.invar \\<sigma> \\<and> List.set (l.\\<alpha> \\<sigma>) = it\n      \\<and> distinct (l.\\<alpha> \\<sigma>)\" \n      in s.iterate_rule_insert_P, auto simp: l.correct)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "end"]]}