{"file_name": "/home/qj213/afp-2021-10-22/thys/Collections/Iterator/SetIteratorGA.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Collections", "problem_names": ["lemma iterate_ball_correct :\nassumes it: \"set_iterator it S0\"\nshows \"iterate_ball it P = (\\<forall>x\\<in>S0. P x)\"", "lemma iterate_bex_correct :\nassumes it: \"set_iterator it S0\"\nshows \"iterate_bex it P = (\\<exists>x\\<in>S0. P x)\"", "lemma iterate_to_list_foldli [simp] :\n  \"iterate_to_list (foldli xs) = rev xs\"", "lemma iterate_to_list_genord_correct :\nassumes it: \"set_iterator_genord it S0 R\"\nshows \"set (iterate_to_list it) = S0 \\<and> distinct (iterate_to_list it) \\<and>\n       sorted_wrt R (rev (iterate_to_list it))\"", "lemma iterate_to_list_correct :\nassumes it: \"set_iterator it S0\"\nshows \"set (iterate_to_list it) = S0 \\<and> distinct (iterate_to_list it)\"", "lemma (in linorder) iterate_to_list_linord_correct :\nfixes S0 :: \"'a set\"\nassumes it_OK: \"set_iterator_linord it S0\"\nshows \"set (iterate_to_list it) = S0 \\<and> distinct (iterate_to_list it) \\<and>\n       sorted (rev (iterate_to_list it))\"", "lemma (in linorder) iterate_to_list_rev_linord_correct :\nfixes S0 :: \"'a set\"\nassumes it_OK: \"set_iterator_rev_linord it S0\"\nshows \"set (iterate_to_list it) = S0 \\<and> distinct (iterate_to_list it) \\<and>\n       sorted (iterate_to_list it)\"", "lemma (in linorder) iterate_to_list_map_linord_correct :\nassumes it_OK: \"map_iterator_linord it m\"\nshows \"map_of (iterate_to_list it) = m \\<and> distinct (map fst (iterate_to_list it)) \\<and>\n       sorted (map fst (rev (iterate_to_list it)))\"", "lemma (in linorder) iterate_to_list_map_rev_linord_correct :\nassumes it_OK: \"map_iterator_rev_linord it m\"\nshows \"map_of (iterate_to_list it) = m \\<and> distinct (map fst (iterate_to_list it)) \\<and>\n       sorted (map fst (iterate_to_list it))\"", "lemma set_iterator_finite :\nassumes it: \"set_iterator it S0\"\nshows \"finite S0\"", "lemma map_iterator_finite :\nassumes it: \"map_iterator it m\"\nshows \"finite (dom m)\"", "lemma iterate_size_correct :\nassumes it: \"set_iterator it S0\"\nshows \"iterate_size it = card S0 \\<and> finite S0\"", "lemma iterate_size_abort_correct :\nassumes it: \"set_iterator it S0\"\nshows \"iterate_size_abort it n = (min n (card S0)) \\<and> finite S0\"", "lemma iterate_is_empty_by_size_correct :\nassumes it: \"set_iterator it S0\"\nshows \"iterate_is_empty_by_size it = (S0 = {})\"", "lemma iterate_is_empty_correct :\nassumes it: \"set_iterator it S0\"\nshows \"iterate_is_empty it = (S0 = {})\"", "lemma iterate_is_sng_correct :\nassumes it: \"set_iterator it S0\"\nshows \"iterate_is_sng it = (card S0 = 1)\"", "lemma iterate_sel_genord_correct :\nassumes it_OK: \"set_iterator_genord it S0 R\"\nshows \"iterate_sel it f = None \\<longleftrightarrow> (\\<forall>x\\<in>S0. (f x = None))\"\n      \"iterate_sel it f = Some y \\<Longrightarrow> (\\<exists>x \\<in> S0. f x = Some y \\<and> (\\<forall>x' \\<in> S0-{x}. \\<forall>y. f x' = Some y' \\<longrightarrow> R x x'))\"", "lemmas iterate_sel_no_map_alt_def = iterate_sel_no_map_def[unfolded iterate_sel_def, code]", "lemma iterate_sel_no_map_genord_correct :\nassumes it_OK: \"set_iterator_genord it S0 R\"\nshows \"iterate_sel_no_map it P = None \\<longleftrightarrow> (\\<forall>x\\<in>S0. \\<not>(P x))\"\n      \"iterate_sel_no_map it P = Some x \\<Longrightarrow> (x \\<in> S0 \\<and> P x \\<and> (\\<forall>x' \\<in> S0-{x}. P x' \\<longrightarrow> R x x'))\"", "lemma iterate_sel_no_map_correct :\nassumes it_OK: \"set_iterator it S0\"\nshows \"iterate_sel_no_map it P = None \\<longleftrightarrow> (\\<forall>x\\<in>S0. \\<not>(P x))\"\n      \"iterate_sel_no_map it P = Some x \\<Longrightarrow> x \\<in> S0 \\<and> P x\"", "lemma (in linorder) iterate_sel_no_map_linord_correct :\nassumes it_OK: \"set_iterator_linord it S0\"\nshows \"iterate_sel_no_map it P = None \\<longleftrightarrow> (\\<forall>x\\<in>S0. \\<not>(P x))\"\n      \"iterate_sel_no_map it P = Some x \\<Longrightarrow> (x \\<in> S0 \\<and> P x \\<and> (\\<forall>x'\\<in>S0. P x' \\<longrightarrow> x \\<le> x'))\"", "lemma (in linorder) iterate_sel_no_map_rev_linord_correct :\nassumes it_OK: \"set_iterator_rev_linord it S0\"\nshows \"iterate_sel_no_map it P = None \\<longleftrightarrow> (\\<forall>x\\<in>S0. \\<not>(P x))\"\n      \"iterate_sel_no_map it P = Some x \\<Longrightarrow> (x \\<in> S0 \\<and> P x \\<and> (\\<forall>x'\\<in>S0. P x' \\<longrightarrow> x' \\<le> x))\"", "lemma iterate_sel_no_map_map_correct :\nassumes it_OK: \"map_iterator it m\"\nshows \"iterate_sel_no_map it P = None \\<longleftrightarrow> (\\<forall>k v. m k = Some v \\<longrightarrow> \\<not>(P (k, v)))\"\n      \"iterate_sel_no_map it P = Some (k, v) \\<Longrightarrow> (m k = Some v \\<and> P (k, v))\"", "lemma (in linorder) iterate_sel_no_map_map_linord_correct :\nassumes it_OK: \"map_iterator_linord it m\"\nshows \"iterate_sel_no_map it P = None \\<longleftrightarrow> (\\<forall>k v. m k = Some v \\<longrightarrow> \\<not>(P (k, v)))\"\n      \"iterate_sel_no_map it P = Some (k, v) \\<Longrightarrow> (m k = Some v \\<and> P (k, v) \\<and> (\\<forall>k' v' . m k' = Some v' \\<and>\n           P (k', v') \\<longrightarrow> k \\<le> k'))\"", "lemma (in linorder) iterate_sel_no_map_map_rev_linord_correct :\nassumes it_OK: \"map_iterator_rev_linord it m\"\nshows \"iterate_sel_no_map it P = None \\<longleftrightarrow> (\\<forall>k v. m k = Some v \\<longrightarrow> \\<not>(P (k, v)))\"\n      \"iterate_sel_no_map it P = Some (k, v) \\<Longrightarrow> (m k = Some v \\<and> P (k, v) \\<and> (\\<forall>k' v' . m k' = Some v' \\<and>\n           P (k', v') \\<longrightarrow> k' \\<le> k))\"", "lemma iterator_to_ordered_iterator_correct :\nassumes sort_fun_OK: \"\\<And>l. sorted_wrt R (sort_fun l) \\<and> mset (sort_fun l) = mset l\"\n    and it_OK: \"set_iterator it S0\"\nshows \"set_iterator_genord (iterator_to_ordered_iterator sort_fun it) S0 R\"", "lemmas iterator_to_ordered_iterator_quicksort_code[code] =\n  iterator_to_ordered_iterator_quicksort_def[unfolded iterator_to_ordered_iterator_def]", "lemma iterator_to_ordered_iterator_quicksort_correct :\nassumes lin : \"\\<And>x y. (R x y) \\<or> (R y x)\"\n    and trans_R: \"\\<And>x y z. R x y \\<Longrightarrow> R y z \\<Longrightarrow> R x z\"\n    and it_OK: \"set_iterator it S0\"\nshows \"set_iterator_genord (iterator_to_ordered_iterator_quicksort R it) S0 R\"", "lemmas iterator_to_ordered_iterator_mergesort_code[code] =\n  iterator_to_ordered_iterator_mergesort_def[unfolded iterator_to_ordered_iterator_def]", "lemma iterator_to_ordered_iterator_mergesort_correct :\nassumes lin : \"\\<And>x y. (R x y) \\<or> (R y x)\"\n    and trans_R: \"\\<And>x y z. R x y \\<Longrightarrow> R y z \\<Longrightarrow> R x z\"\n    and it_OK: \"set_iterator it S0\"\nshows \"set_iterator_genord (iterator_to_ordered_iterator_mergesort R it) S0 R\""], "translations": [["", "lemma iterate_ball_correct :\nassumes it: \"set_iterator it S0\"\nshows \"iterate_ball it P = (\\<forall>x\\<in>S0. P x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iterate_ball it P = (\\<forall>x\\<in>S0. P x)", "unfolding iterate_ball_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. it id (\\<lambda>x \\<sigma>. P x) True = (\\<forall>x\\<in>S0. P x)", "apply (rule set_iterator_rule_P [OF it,\n            where I = \"\\<lambda>S \\<sigma>. \\<sigma> = (\\<forall>x\\<in>S0-S. P x)\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. True = (\\<forall>x\\<in>S0 - S0. P x)\n 2. \\<And>S \\<sigma> x.\n       \\<lbrakk>id \\<sigma>; x \\<in> S;\n        \\<sigma> = (\\<forall>x\\<in>S0 - S. P x); S \\<subseteq> S0\\<rbrakk>\n       \\<Longrightarrow> P x = (\\<forall>x\\<in>S0 - (S - {x}). P x)\n 3. \\<And>\\<sigma>.\n       \\<sigma> = (\\<forall>x\\<in>S0 - {}. P x) \\<Longrightarrow>\n       \\<sigma> = (\\<forall>x\\<in>S0. P x)\n 4. \\<And>\\<sigma> S.\n       \\<lbrakk>S \\<subseteq> S0; S \\<noteq> {}; \\<not> id \\<sigma>;\n        \\<sigma> = (\\<forall>x\\<in>S0 - S. P x)\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = (\\<forall>x\\<in>S0. P x)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition iterate_bex where\n    \"iterate_bex (it::('x,bool) set_iterator) P = it (\\<lambda>\\<sigma>. \\<not>\\<sigma>) (\\<lambda>x \\<sigma>. P x) False\""], ["", "lemma iterate_bex_correct :\nassumes it: \"set_iterator it S0\"\nshows \"iterate_bex it P = (\\<exists>x\\<in>S0. P x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iterate_bex it P = (\\<exists>x\\<in>S0. P x)", "unfolding iterate_bex_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. it Not (\\<lambda>x \\<sigma>. P x) False = (\\<exists>x\\<in>S0. P x)", "apply (rule set_iterator_rule_P [OF it, where I = \"\\<lambda>S \\<sigma>. \\<sigma> = (\\<exists>x\\<in>S0-S. P x)\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. False = (\\<exists>x\\<in>S0 - S0. P x)\n 2. \\<And>S \\<sigma> x.\n       \\<lbrakk>\\<not> \\<sigma>; x \\<in> S;\n        \\<sigma> = (\\<exists>x\\<in>S0 - S. P x); S \\<subseteq> S0\\<rbrakk>\n       \\<Longrightarrow> P x = (\\<exists>x\\<in>S0 - (S - {x}). P x)\n 3. \\<And>\\<sigma>.\n       \\<sigma> = (\\<exists>x\\<in>S0 - {}. P x) \\<Longrightarrow>\n       \\<sigma> = (\\<exists>x\\<in>S0. P x)\n 4. \\<And>\\<sigma> S.\n       \\<lbrakk>S \\<subseteq> S0; S \\<noteq> {}; \\<not> \\<not> \\<sigma>;\n        \\<sigma> = (\\<exists>x\\<in>S0 - S. P x)\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = (\\<exists>x\\<in>S0. P x)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Iterator to List\\<close>"], ["", "definition iterate_to_list where\n    \"iterate_to_list (it::('x,'x list) set_iterator) = it (\\<lambda>_. True) (\\<lambda>x \\<sigma>. x # \\<sigma>) []\""], ["", "lemma iterate_to_list_foldli [simp] :\n  \"iterate_to_list (foldli xs) = rev xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iterate_to_list (foldli xs) = rev xs", "unfolding iterate_to_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli xs (\\<lambda>_. True) (#) [] = rev xs", "by (induct xs rule: rev_induct, simp_all add: foldli_snoc)"], ["", "lemma iterate_to_list_genord_correct :\nassumes it: \"set_iterator_genord it S0 R\"\nshows \"set (iterate_to_list it) = S0 \\<and> distinct (iterate_to_list it) \\<and>\n       sorted_wrt R (rev (iterate_to_list it))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (iterate_to_list it) = S0 \\<and>\n    distinct (iterate_to_list it) \\<and>\n    sorted_wrt R (rev (iterate_to_list it))", "using it"], ["proof (prove)\nusing this:\n  set_iterator_genord it S0 R\n\ngoal (1 subgoal):\n 1. set (iterate_to_list it) = S0 \\<and>\n    distinct (iterate_to_list it) \\<and>\n    sorted_wrt R (rev (iterate_to_list it))", "unfolding set_iterator_genord_foldli_conv"], ["proof (prove)\nusing this:\n  \\<exists>l0.\n     distinct l0 \\<and>\n     S0 = set l0 \\<and> sorted_wrt R l0 \\<and> it = foldli l0\n\ngoal (1 subgoal):\n 1. set (iterate_to_list it) = S0 \\<and>\n    distinct (iterate_to_list it) \\<and>\n    sorted_wrt R (rev (iterate_to_list it))", "by auto"], ["", "lemma iterate_to_list_correct :\nassumes it: \"set_iterator it S0\"\nshows \"set (iterate_to_list it) = S0 \\<and> distinct (iterate_to_list it)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (iterate_to_list it) = S0 \\<and> distinct (iterate_to_list it)", "using iterate_to_list_genord_correct [OF it[unfolded set_iterator_def]]"], ["proof (prove)\nusing this:\n  set (iterate_to_list it) = S0 \\<and>\n  distinct (iterate_to_list it) \\<and>\n  sorted_wrt (\\<lambda>_ _. True) (rev (iterate_to_list it))\n\ngoal (1 subgoal):\n 1. set (iterate_to_list it) = S0 \\<and> distinct (iterate_to_list it)", "by simp"], ["", "lemma (in linorder) iterate_to_list_linord_correct :\nfixes S0 :: \"'a set\"\nassumes it_OK: \"set_iterator_linord it S0\"\nshows \"set (iterate_to_list it) = S0 \\<and> distinct (iterate_to_list it) \\<and>\n       sorted (rev (iterate_to_list it))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (iterate_to_list it) = S0 \\<and>\n    distinct (iterate_to_list it) \\<and> sorted (rev (iterate_to_list it))", "using it_OK"], ["proof (prove)\nusing this:\n  set_iterator_linord it S0\n\ngoal (1 subgoal):\n 1. set (iterate_to_list it) = S0 \\<and>\n    distinct (iterate_to_list it) \\<and> sorted (rev (iterate_to_list it))", "unfolding set_iterator_linord_foldli_conv"], ["proof (prove)\nusing this:\n  \\<exists>l0.\n     distinct l0 \\<and> S0 = set l0 \\<and> sorted l0 \\<and> it = foldli l0\n\ngoal (1 subgoal):\n 1. set (iterate_to_list it) = S0 \\<and>\n    distinct (iterate_to_list it) \\<and> sorted (rev (iterate_to_list it))", "by auto"], ["", "lemma (in linorder) iterate_to_list_rev_linord_correct :\nfixes S0 :: \"'a set\"\nassumes it_OK: \"set_iterator_rev_linord it S0\"\nshows \"set (iterate_to_list it) = S0 \\<and> distinct (iterate_to_list it) \\<and>\n       sorted (iterate_to_list it)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (iterate_to_list it) = S0 \\<and>\n    distinct (iterate_to_list it) \\<and> sorted (iterate_to_list it)", "using it_OK"], ["proof (prove)\nusing this:\n  set_iterator_rev_linord it S0\n\ngoal (1 subgoal):\n 1. set (iterate_to_list it) = S0 \\<and>\n    distinct (iterate_to_list it) \\<and> sorted (iterate_to_list it)", "unfolding set_iterator_rev_linord_foldli_conv"], ["proof (prove)\nusing this:\n  \\<exists>l0.\n     distinct l0 \\<and>\n     S0 = set l0 \\<and> sorted (rev l0) \\<and> it = foldli l0\n\ngoal (1 subgoal):\n 1. set (iterate_to_list it) = S0 \\<and>\n    distinct (iterate_to_list it) \\<and> sorted (iterate_to_list it)", "by auto"], ["", "lemma (in linorder) iterate_to_list_map_linord_correct :\nassumes it_OK: \"map_iterator_linord it m\"\nshows \"map_of (iterate_to_list it) = m \\<and> distinct (map fst (iterate_to_list it)) \\<and>\n       sorted (map fst (rev (iterate_to_list it)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (iterate_to_list it) = m \\<and>\n    distinct (map fst (iterate_to_list it)) \\<and>\n    sorted (map fst (rev (iterate_to_list it)))", "using it_OK"], ["proof (prove)\nusing this:\n  map_iterator_linord it m\n\ngoal (1 subgoal):\n 1. map_of (iterate_to_list it) = m \\<and>\n    distinct (map fst (iterate_to_list it)) \\<and>\n    sorted (map fst (rev (iterate_to_list it)))", "unfolding map_iterator_linord_foldli_conv"], ["proof (prove)\nusing this:\n  \\<exists>l0.\n     distinct (map fst l0) \\<and>\n     m = map_of l0 \\<and> sorted (map fst l0) \\<and> it = foldli l0\n\ngoal (1 subgoal):\n 1. map_of (iterate_to_list it) = m \\<and>\n    distinct (map fst (iterate_to_list it)) \\<and>\n    sorted (map fst (rev (iterate_to_list it)))", "by clarify (simp add: rev_map[symmetric])"], ["", "lemma (in linorder) iterate_to_list_map_rev_linord_correct :\nassumes it_OK: \"map_iterator_rev_linord it m\"\nshows \"map_of (iterate_to_list it) = m \\<and> distinct (map fst (iterate_to_list it)) \\<and>\n       sorted (map fst (iterate_to_list it))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (iterate_to_list it) = m \\<and>\n    distinct (map fst (iterate_to_list it)) \\<and>\n    sorted (map fst (iterate_to_list it))", "using it_OK"], ["proof (prove)\nusing this:\n  map_iterator_rev_linord it m\n\ngoal (1 subgoal):\n 1. map_of (iterate_to_list it) = m \\<and>\n    distinct (map fst (iterate_to_list it)) \\<and>\n    sorted (map fst (iterate_to_list it))", "unfolding map_iterator_rev_linord_foldli_conv"], ["proof (prove)\nusing this:\n  \\<exists>l0.\n     distinct (map fst l0) \\<and>\n     m = map_of l0 \\<and> sorted (rev (map fst l0)) \\<and> it = foldli l0\n\ngoal (1 subgoal):\n 1. map_of (iterate_to_list it) = m \\<and>\n    distinct (map fst (iterate_to_list it)) \\<and>\n    sorted (map fst (iterate_to_list it))", "by clarify (simp add: rev_map[symmetric])"], ["", "subsection \\<open>Size\\<close>"], ["", "lemma set_iterator_finite :\nassumes it: \"set_iterator it S0\"\nshows \"finite S0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite S0", "using set_iterator_genord.finite_S0 [OF it[unfolded set_iterator_def]]"], ["proof (prove)\nusing this:\n  finite S0\n\ngoal (1 subgoal):\n 1. finite S0", "."], ["", "lemma map_iterator_finite :\nassumes it: \"map_iterator it m\"\nshows \"finite (dom m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (dom m)", "using set_iterator_genord.finite_S0 [OF it[unfolded set_iterator_def]]"], ["proof (prove)\nusing this:\n  finite (map_to_set m)\n\ngoal (1 subgoal):\n 1. finite (dom m)", "by (simp add: finite_map_to_set)"], ["", "definition iterate_size where\n    \"iterate_size (it::('x,nat) set_iterator) = it (\\<lambda>_. True) (\\<lambda>x \\<sigma>. Suc \\<sigma>) 0\""], ["", "lemma iterate_size_correct :\nassumes it: \"set_iterator it S0\"\nshows \"iterate_size it = card S0 \\<and> finite S0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iterate_size it = card S0 \\<and> finite S0", "unfolding iterate_size_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. it (\\<lambda>_. True) (\\<lambda>x. Suc) 0 = card S0 \\<and> finite S0", "apply (rule_tac set_iterator_rule_insert_P [OF it, \n    where I = \"\\<lambda>S \\<sigma>. \\<sigma> = card S \\<and> finite S\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. 0 = card {} \\<and> finite {}\n 2. \\<And>S \\<sigma> x.\n       \\<lbrakk>True; x \\<in> S0 - S; \\<sigma> = card S \\<and> finite S;\n        S \\<subseteq> S0\\<rbrakk>\n       \\<Longrightarrow> Suc \\<sigma> = card (insert x S) \\<and>\n                         finite (insert x S)\n 3. \\<And>\\<sigma>.\n       \\<sigma> = card S0 \\<and> finite S0 \\<Longrightarrow>\n       \\<sigma> = card S0 \\<and> finite S0\n 4. \\<And>\\<sigma> S.\n       \\<lbrakk>S \\<subseteq> S0; S \\<noteq> S0; \\<not> True;\n        \\<sigma> = card S \\<and> finite S\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = card S0 \\<and> finite S0", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition iterate_size_abort where\n  \"iterate_size_abort (it::('x,nat) set_iterator) n = it (\\<lambda>\\<sigma>. \\<sigma> < n) (\\<lambda>x \\<sigma>. Suc \\<sigma>) 0\""], ["", "lemma iterate_size_abort_correct :\nassumes it: \"set_iterator it S0\"\nshows \"iterate_size_abort it n = (min n (card S0)) \\<and> finite S0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iterate_size_abort it n = min n (card S0) \\<and> finite S0", "unfolding iterate_size_abort_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. it (\\<lambda>\\<sigma>. \\<sigma> < n) (\\<lambda>x. Suc) 0 =\n    min n (card S0) \\<and>\n    finite S0", "proof (rule set_iterator_rule_insert_P [OF it,\n   where I = \"\\<lambda>S \\<sigma>. \\<sigma> = (min n (card S)) \\<and> finite S\"], goal_cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. 0 = min n (card {}) \\<and> finite {}\n 2. \\<And>S \\<sigma> x.\n       \\<lbrakk>\\<sigma> < n; x \\<in> S0 - S;\n        \\<sigma> = min n (card S) \\<and> finite S; S \\<subseteq> S0\\<rbrakk>\n       \\<Longrightarrow> Suc \\<sigma> = min n (card (insert x S)) \\<and>\n                         finite (insert x S)\n 3. \\<And>\\<sigma>.\n       \\<sigma> = min n (card S0) \\<and> finite S0 \\<Longrightarrow>\n       \\<sigma> = min n (card S0) \\<and> finite S0\n 4. \\<And>\\<sigma> S.\n       \\<lbrakk>S \\<subseteq> S0; S \\<noteq> S0; \\<not> \\<sigma> < n;\n        \\<sigma> = min n (card S) \\<and> finite S\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = min n (card S0) \\<and> finite S0", "case (4 \\<sigma> S)"], ["proof (state)\nthis:\n  S \\<subseteq> S0\n  S \\<noteq> S0\n  \\<not> \\<sigma> < n\n  \\<sigma> = min n (card S) \\<and> finite S\n\ngoal (4 subgoals):\n 1. 0 = min n (card {}) \\<and> finite {}\n 2. \\<And>S \\<sigma> x.\n       \\<lbrakk>\\<sigma> < n; x \\<in> S0 - S;\n        \\<sigma> = min n (card S) \\<and> finite S; S \\<subseteq> S0\\<rbrakk>\n       \\<Longrightarrow> Suc \\<sigma> = min n (card (insert x S)) \\<and>\n                         finite (insert x S)\n 3. \\<And>\\<sigma>.\n       \\<sigma> = min n (card S0) \\<and> finite S0 \\<Longrightarrow>\n       \\<sigma> = min n (card S0) \\<and> finite S0\n 4. \\<And>\\<sigma> S.\n       \\<lbrakk>S \\<subseteq> S0; S \\<noteq> S0; \\<not> \\<sigma> < n;\n        \\<sigma> = min n (card S) \\<and> finite S\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = min n (card S0) \\<and> finite S0", "assume \"S \\<subseteq> S0\" \"S \\<noteq> S0\" \"\\<not> \\<sigma> < n\" \"\\<sigma> = min n (card S) \\<and> finite S\""], ["proof (state)\nthis:\n  S \\<subseteq> S0\n  S \\<noteq> S0\n  \\<not> \\<sigma> < n\n  \\<sigma> = min n (card S) \\<and> finite S\n\ngoal (4 subgoals):\n 1. 0 = min n (card {}) \\<and> finite {}\n 2. \\<And>S \\<sigma> x.\n       \\<lbrakk>\\<sigma> < n; x \\<in> S0 - S;\n        \\<sigma> = min n (card S) \\<and> finite S; S \\<subseteq> S0\\<rbrakk>\n       \\<Longrightarrow> Suc \\<sigma> = min n (card (insert x S)) \\<and>\n                         finite (insert x S)\n 3. \\<And>\\<sigma>.\n       \\<sigma> = min n (card S0) \\<and> finite S0 \\<Longrightarrow>\n       \\<sigma> = min n (card S0) \\<and> finite S0\n 4. \\<And>\\<sigma> S.\n       \\<lbrakk>S \\<subseteq> S0; S \\<noteq> S0; \\<not> \\<sigma> < n;\n        \\<sigma> = min n (card S) \\<and> finite S\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = min n (card S0) \\<and> finite S0", "from \\<open>\\<sigma> = min n (card S) \\<and> finite S\\<close> \\<open>\\<not> \\<sigma> < n\\<close>"], ["proof (chain)\npicking this:\n  \\<sigma> = min n (card S) \\<and> finite S\n  \\<not> \\<sigma> < n", "have \"\\<sigma> = n\" \"n \\<le> card S\""], ["proof (prove)\nusing this:\n  \\<sigma> = min n (card S) \\<and> finite S\n  \\<not> \\<sigma> < n\n\ngoal (1 subgoal):\n 1. \\<sigma> = n &&& n \\<le> card S", "by (auto simp add: min_less_iff_disj)"], ["proof (state)\nthis:\n  \\<sigma> = n\n  n \\<le> card S\n\ngoal (4 subgoals):\n 1. 0 = min n (card {}) \\<and> finite {}\n 2. \\<And>S \\<sigma> x.\n       \\<lbrakk>\\<sigma> < n; x \\<in> S0 - S;\n        \\<sigma> = min n (card S) \\<and> finite S; S \\<subseteq> S0\\<rbrakk>\n       \\<Longrightarrow> Suc \\<sigma> = min n (card (insert x S)) \\<and>\n                         finite (insert x S)\n 3. \\<And>\\<sigma>.\n       \\<sigma> = min n (card S0) \\<and> finite S0 \\<Longrightarrow>\n       \\<sigma> = min n (card S0) \\<and> finite S0\n 4. \\<And>\\<sigma> S.\n       \\<lbrakk>S \\<subseteq> S0; S \\<noteq> S0; \\<not> \\<sigma> < n;\n        \\<sigma> = min n (card S) \\<and> finite S\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = min n (card S0) \\<and> finite S0", "note fin_S0 = set_iterator_genord.finite_S0 [OF it[unfolded set_iterator_def]]"], ["proof (state)\nthis:\n  finite S0\n\ngoal (4 subgoals):\n 1. 0 = min n (card {}) \\<and> finite {}\n 2. \\<And>S \\<sigma> x.\n       \\<lbrakk>\\<sigma> < n; x \\<in> S0 - S;\n        \\<sigma> = min n (card S) \\<and> finite S; S \\<subseteq> S0\\<rbrakk>\n       \\<Longrightarrow> Suc \\<sigma> = min n (card (insert x S)) \\<and>\n                         finite (insert x S)\n 3. \\<And>\\<sigma>.\n       \\<sigma> = min n (card S0) \\<and> finite S0 \\<Longrightarrow>\n       \\<sigma> = min n (card S0) \\<and> finite S0\n 4. \\<And>\\<sigma> S.\n       \\<lbrakk>S \\<subseteq> S0; S \\<noteq> S0; \\<not> \\<sigma> < n;\n        \\<sigma> = min n (card S) \\<and> finite S\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = min n (card S0) \\<and> finite S0", "from card_mono [OF fin_S0 \\<open>S \\<subseteq> S0\\<close>]"], ["proof (chain)\npicking this:\n  card S \\<le> card S0", "have \"card S \\<le> card S0\""], ["proof (prove)\nusing this:\n  card S \\<le> card S0\n\ngoal (1 subgoal):\n 1. card S \\<le> card S0", "."], ["proof (state)\nthis:\n  card S \\<le> card S0\n\ngoal (4 subgoals):\n 1. 0 = min n (card {}) \\<and> finite {}\n 2. \\<And>S \\<sigma> x.\n       \\<lbrakk>\\<sigma> < n; x \\<in> S0 - S;\n        \\<sigma> = min n (card S) \\<and> finite S; S \\<subseteq> S0\\<rbrakk>\n       \\<Longrightarrow> Suc \\<sigma> = min n (card (insert x S)) \\<and>\n                         finite (insert x S)\n 3. \\<And>\\<sigma>.\n       \\<sigma> = min n (card S0) \\<and> finite S0 \\<Longrightarrow>\n       \\<sigma> = min n (card S0) \\<and> finite S0\n 4. \\<And>\\<sigma> S.\n       \\<lbrakk>S \\<subseteq> S0; S \\<noteq> S0; \\<not> \\<sigma> < n;\n        \\<sigma> = min n (card S) \\<and> finite S\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = min n (card S0) \\<and> finite S0", "with \\<open>\\<sigma> = n\\<close> \\<open>n \\<le> card S\\<close> fin_S0"], ["proof (chain)\npicking this:\n  \\<sigma> = n\n  n \\<le> card S\n  finite S0\n  card S \\<le> card S0", "show \"\\<sigma> = min n (card S0) \\<and> finite S0\""], ["proof (prove)\nusing this:\n  \\<sigma> = n\n  n \\<le> card S\n  finite S0\n  card S \\<le> card S0\n\ngoal (1 subgoal):\n 1. \\<sigma> = min n (card S0) \\<and> finite S0", "by simp"], ["proof (state)\nthis:\n  \\<sigma> = min n (card S0) \\<and> finite S0\n\ngoal (3 subgoals):\n 1. 0 = min n (card {}) \\<and> finite {}\n 2. \\<And>S \\<sigma> x.\n       \\<lbrakk>\\<sigma> < n; x \\<in> S0 - S;\n        \\<sigma> = min n (card S) \\<and> finite S; S \\<subseteq> S0\\<rbrakk>\n       \\<Longrightarrow> Suc \\<sigma> = min n (card (insert x S)) \\<and>\n                         finite (insert x S)\n 3. \\<And>\\<sigma>.\n       \\<sigma> = min n (card S0) \\<and> finite S0 \\<Longrightarrow>\n       \\<sigma> = min n (card S0) \\<and> finite S0", "qed simp_all"], ["", "subsection \\<open>Emptyness Check\\<close>"], ["", "definition iterate_is_empty_by_size where\n    \"iterate_is_empty_by_size it = (iterate_size_abort it 1 = 0)\""], ["", "lemma iterate_is_empty_by_size_correct :\nassumes it: \"set_iterator it S0\"\nshows \"iterate_is_empty_by_size it = (S0 = {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iterate_is_empty_by_size it = (S0 = {})", "using iterate_size_abort_correct[OF it, of 1]"], ["proof (prove)\nusing this:\n  iterate_size_abort it 1 = min 1 (card S0) \\<and> finite S0\n\ngoal (1 subgoal):\n 1. iterate_is_empty_by_size it = (S0 = {})", "unfolding iterate_is_empty_by_size_def"], ["proof (prove)\nusing this:\n  iterate_size_abort it 1 = min 1 (card S0) \\<and> finite S0\n\ngoal (1 subgoal):\n 1. (iterate_size_abort it 1 = 0) = (S0 = {})", "by (cases \"card S0\") auto"], ["", "definition iterate_is_empty where\n    \"iterate_is_empty (it::('x,bool) set_iterator) = (it (\\<lambda>b. b) (\\<lambda>_ _. False) True)\""], ["", "lemma iterate_is_empty_correct :\nassumes it: \"set_iterator it S0\"\nshows \"iterate_is_empty it = (S0 = {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iterate_is_empty it = (S0 = {})", "unfolding iterate_is_empty_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. it (\\<lambda>b. b) (\\<lambda>_ _. False) True = (S0 = {})", "apply (rule set_iterator_rule_insert_P [OF it,\n   where I = \"\\<lambda>S \\<sigma>. \\<sigma> \\<longleftrightarrow> S = {}\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. True = ({} = {})\n 2. \\<And>S \\<sigma> x.\n       \\<lbrakk>\\<sigma>; x \\<in> S0 - S; \\<sigma> = (S = {});\n        S \\<subseteq> S0\\<rbrakk>\n       \\<Longrightarrow> False = (insert x S = {})\n 3. \\<And>\\<sigma>.\n       \\<sigma> = (S0 = {}) \\<Longrightarrow> \\<sigma> = (S0 = {})\n 4. \\<And>\\<sigma> S.\n       \\<lbrakk>S \\<subseteq> S0; S \\<noteq> S0; \\<not> \\<sigma>;\n        \\<sigma> = (S = {})\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = (S0 = {})", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Check for singleton Sets\\<close>"], ["", "definition iterate_is_sng where\n    \"iterate_is_sng it = (iterate_size_abort it 2 = 1)\""], ["", "lemma iterate_is_sng_correct :\nassumes it: \"set_iterator it S0\"\nshows \"iterate_is_sng it = (card S0 = 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iterate_is_sng it = (card S0 = 1)", "using iterate_size_abort_correct[OF it, of 2]"], ["proof (prove)\nusing this:\n  iterate_size_abort it 2 = min 2 (card S0) \\<and> finite S0\n\ngoal (1 subgoal):\n 1. iterate_is_sng it = (card S0 = 1)", "unfolding iterate_is_sng_def"], ["proof (prove)\nusing this:\n  iterate_size_abort it 2 = min 2 (card S0) \\<and> finite S0\n\ngoal (1 subgoal):\n 1. (iterate_size_abort it 2 = 1) = (card S0 = 1)", "apply (cases \"card S0\", simp, rename_tac n')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n'.\n       \\<lbrakk>iterate_size_abort it 2 = min 2 (card S0) \\<and> finite S0;\n        card S0 = Suc n';\n        iterate_size_abort it 2 = min 2 (card S0) \\<and> finite S0\\<rbrakk>\n       \\<Longrightarrow> (iterate_size_abort it 2 = 1) = (card S0 = 1)", "apply (case_tac n')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n'.\n       \\<lbrakk>iterate_size_abort it 2 = min 2 (card S0) \\<and> finite S0;\n        card S0 = Suc n';\n        iterate_size_abort it 2 = min 2 (card S0) \\<and> finite S0;\n        n' = 0\\<rbrakk>\n       \\<Longrightarrow> (iterate_size_abort it 2 = 1) = (card S0 = 1)\n 2. \\<And>n' nat.\n       \\<lbrakk>iterate_size_abort it 2 = min 2 (card S0) \\<and> finite S0;\n        card S0 = Suc n';\n        iterate_size_abort it 2 = min 2 (card S0) \\<and> finite S0;\n        n' = Suc nat\\<rbrakk>\n       \\<Longrightarrow> (iterate_size_abort it 2 = 1) = (card S0 = 1)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Selection\\<close>"], ["", "definition iterate_sel where\n    \"iterate_sel (it::('x,'y option) set_iterator) f = it (\\<lambda>\\<sigma>. \\<sigma> = None) (\\<lambda>x \\<sigma>. f x) None\""], ["", "lemma iterate_sel_genord_correct :\nassumes it_OK: \"set_iterator_genord it S0 R\"\nshows \"iterate_sel it f = None \\<longleftrightarrow> (\\<forall>x\\<in>S0. (f x = None))\"\n      \"iterate_sel it f = Some y \\<Longrightarrow> (\\<exists>x \\<in> S0. f x = Some y \\<and> (\\<forall>x' \\<in> S0-{x}. \\<forall>y. f x' = Some y' \\<longrightarrow> R x x'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (iterate_sel it f = None) = (\\<forall>x\\<in>S0. f x = None) &&&\n    (iterate_sel it f = Some y \\<Longrightarrow>\n     \\<exists>x\\<in>S0.\n        f x = Some y \\<and>\n        (\\<forall>x'\\<in>S0 - {x}.\n            \\<forall>y. f x' = Some y' \\<longrightarrow> R x x'))", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. (iterate_sel it f = None) = (\\<forall>x\\<in>S0. f x = None)\n 2. iterate_sel it f = Some y \\<Longrightarrow>\n    \\<exists>x\\<in>S0.\n       f x = Some y \\<and>\n       (\\<forall>x'\\<in>S0 - {x}.\n           \\<forall>y. f x' = Some y' \\<longrightarrow> R x x')", "show \"iterate_sel it f = None \\<longleftrightarrow> (\\<forall>x\\<in>S0. (f x = None))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (iterate_sel it f = None) = (\\<forall>x\\<in>S0. f x = None)", "unfolding iterate_sel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (it (\\<lambda>\\<sigma>. \\<sigma> = None) (\\<lambda>x \\<sigma>. f x)\n      None =\n     None) =\n    (\\<forall>x\\<in>S0. f x = None)", "apply (rule_tac set_iterator_genord.iteratei_rule_insert_P [OF it_OK, \n       where I = \"\\<lambda>S \\<sigma>. (\\<sigma> = None) \\<longleftrightarrow> (\\<forall>x\\<in>S. (f x = None))\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. (None = None) = (\\<forall>x\\<in>{}. f x = None)\n 2. \\<And>S \\<sigma> x.\n       \\<lbrakk>\\<sigma> = None; x \\<in> S0 - S;\n        (\\<sigma> = None) = (\\<forall>x\\<in>S. f x = None);\n        S \\<subseteq> S0; \\<forall>y\\<in>S0 - S - {x}. R x y;\n        \\<forall>y\\<in>S. R y x\\<rbrakk>\n       \\<Longrightarrow> (f x = None) =\n                         (\\<forall>x\\<in>insert x S. f x = None)\n 3. \\<And>\\<sigma>.\n       (\\<sigma> = None) = (\\<forall>x\\<in>S0. f x = None) \\<Longrightarrow>\n       (\\<sigma> = None) = (\\<forall>x\\<in>S0. f x = None)\n 4. \\<And>\\<sigma> S.\n       \\<lbrakk>S \\<subseteq> S0; S \\<noteq> S0; \\<sigma> \\<noteq> None;\n        (\\<sigma> = None) = (\\<forall>x\\<in>S. f x = None);\n        \\<forall>x\\<in>S0 - S. \\<forall>y\\<in>S. R y x\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma> = None) = (\\<forall>x\\<in>S0. f x = None)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (iterate_sel it f = None) = (\\<forall>x\\<in>S0. f x = None)\n\ngoal (1 subgoal):\n 1. iterate_sel it f = Some y \\<Longrightarrow>\n    \\<exists>x\\<in>S0.\n       f x = Some y \\<and>\n       (\\<forall>x'\\<in>S0 - {x}.\n           \\<forall>y. f x' = Some y' \\<longrightarrow> R x x')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. iterate_sel it f = Some y \\<Longrightarrow>\n    \\<exists>x\\<in>S0.\n       f x = Some y \\<and>\n       (\\<forall>x'\\<in>S0 - {x}.\n           \\<forall>y. f x' = Some y' \\<longrightarrow> R x x')", "have \"iterate_sel it f = Some y \\<longrightarrow> (\\<exists>x \\<in> S0. f x = Some y \\<and> (\\<forall>x' \\<in> S0-{x}. \\<forall>y'. f x' = Some y' \\<longrightarrow> R x x'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iterate_sel it f = Some y \\<longrightarrow>\n    (\\<exists>x\\<in>S0.\n        f x = Some y \\<and>\n        (\\<forall>x'\\<in>S0 - {x}.\n            \\<forall>y'. f x' = Some y' \\<longrightarrow> R x x'))", "unfolding iterate_sel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. it (\\<lambda>\\<sigma>. \\<sigma> = None) (\\<lambda>x \\<sigma>. f x)\n     None =\n    Some y \\<longrightarrow>\n    (\\<exists>x\\<in>S0.\n        f x = Some y \\<and>\n        (\\<forall>x'\\<in>S0 - {x}.\n            \\<forall>y'. f x' = Some y' \\<longrightarrow> R x x'))", "apply (rule_tac set_iterator_genord.iteratei_rule_insert_P [OF it_OK, \n       where I = \"\\<lambda>S \\<sigma>. (\\<forall>y. \\<sigma> = Some y \\<longrightarrow> (\\<exists>x \\<in> S. f x = Some y \\<and> (\\<forall>x' \\<in> S-{x}.\\<forall>y'. f x' = Some y' \\<longrightarrow> R x x'))) \\<and>\n                        ((\\<sigma> = None) \\<longleftrightarrow> (\\<forall>x\\<in>S. f x = None))\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. (\\<forall>y.\n        None = Some y \\<longrightarrow>\n        (\\<exists>x\\<in>{}.\n            f x = Some y \\<and>\n            (\\<forall>x'\\<in>{} - {x}.\n                \\<forall>y'.\n                   f x' = Some y' \\<longrightarrow> R x x'))) \\<and>\n    (None = None) = (\\<forall>x\\<in>{}. f x = None)\n 2. \\<And>S \\<sigma> x.\n       \\<lbrakk>\\<sigma> = None; x \\<in> S0 - S;\n        (\\<forall>y.\n            \\<sigma> = Some y \\<longrightarrow>\n            (\\<exists>x\\<in>S.\n                f x = Some y \\<and>\n                (\\<forall>x'\\<in>S - {x}.\n                    \\<forall>y'.\n                       f x' = Some y' \\<longrightarrow> R x x'))) \\<and>\n        (\\<sigma> = None) = (\\<forall>x\\<in>S. f x = None);\n        S \\<subseteq> S0; \\<forall>y\\<in>S0 - S - {x}. R x y;\n        \\<forall>y\\<in>S. R y x\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>y.\n                             f x = Some y \\<longrightarrow>\n                             (\\<exists>xa\\<in>insert x S.\n                                 f xa = Some y \\<and>\n                                 (\\<forall>x'\\<in>insert x S - {xa}.\n                                     \\<forall>y'.\n  f x' = Some y' \\<longrightarrow> R xa x'))) \\<and>\n                         (f x = None) =\n                         (\\<forall>x\\<in>insert x S. f x = None)\n 3. \\<And>\\<sigma>.\n       (\\<forall>y.\n           \\<sigma> = Some y \\<longrightarrow>\n           (\\<exists>x\\<in>S0.\n               f x = Some y \\<and>\n               (\\<forall>x'\\<in>S0 - {x}.\n                   \\<forall>y'.\n                      f x' = Some y' \\<longrightarrow> R x x'))) \\<and>\n       (\\<sigma> = None) = (\\<forall>x\\<in>S0. f x = None) \\<Longrightarrow>\n       \\<sigma> = Some y \\<longrightarrow>\n       (\\<exists>x\\<in>S0.\n           f x = Some y \\<and>\n           (\\<forall>x'\\<in>S0 - {x}.\n               \\<forall>y'. f x' = Some y' \\<longrightarrow> R x x'))\n 4. \\<And>\\<sigma> S.\n       \\<lbrakk>S \\<subseteq> S0; S \\<noteq> S0; \\<sigma> \\<noteq> None;\n        (\\<forall>y.\n            \\<sigma> = Some y \\<longrightarrow>\n            (\\<exists>x\\<in>S.\n                f x = Some y \\<and>\n                (\\<forall>x'\\<in>S - {x}.\n                    \\<forall>y'.\n                       f x' = Some y' \\<longrightarrow> R x x'))) \\<and>\n        (\\<sigma> = None) = (\\<forall>x\\<in>S. f x = None);\n        \\<forall>x\\<in>S0 - S. \\<forall>y\\<in>S. R y x\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = Some y \\<longrightarrow>\n                         (\\<exists>x\\<in>S0.\n                             f x = Some y \\<and>\n                             (\\<forall>x'\\<in>S0 - {x}.\n                                 \\<forall>y'.\n                                    f x' = Some y' \\<longrightarrow>\n                                    R x x'))", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>S \\<sigma> x.\n       \\<lbrakk>\\<sigma> = None; x \\<in> S0 - S;\n        (\\<forall>y.\n            \\<sigma> = Some y \\<longrightarrow>\n            (\\<exists>x\\<in>S.\n                f x = Some y \\<and>\n                (\\<forall>x'\\<in>S - {x}.\n                    \\<forall>y'.\n                       f x' = Some y' \\<longrightarrow> R x x'))) \\<and>\n        (\\<sigma> = None) = (\\<forall>x\\<in>S. f x = None);\n        S \\<subseteq> S0; \\<forall>y\\<in>S0 - S - {x}. R x y;\n        \\<forall>y\\<in>S. R y x\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>y.\n                             f x = Some y \\<longrightarrow>\n                             (\\<exists>xa\\<in>insert x S.\n                                 f xa = Some y \\<and>\n                                 (\\<forall>x'\\<in>insert x S - {xa}.\n                                     \\<forall>y'.\n  f x' = Some y' \\<longrightarrow> R xa x'))) \\<and>\n                         (f x = None) =\n                         (\\<forall>x\\<in>insert x S. f x = None)\n 2. \\<And>\\<sigma>.\n       (\\<forall>y.\n           \\<sigma> = Some y \\<longrightarrow>\n           (\\<exists>x\\<in>S0.\n               f x = Some y \\<and>\n               (\\<forall>x'\\<in>S0 - {x}.\n                   \\<forall>y'.\n                      f x' = Some y' \\<longrightarrow> R x x'))) \\<and>\n       (\\<sigma> = None) = (\\<forall>x\\<in>S0. f x = None) \\<Longrightarrow>\n       \\<sigma> = Some y \\<longrightarrow>\n       (\\<exists>x\\<in>S0.\n           f x = Some y \\<and>\n           (\\<forall>x'\\<in>S0 - {x}.\n               \\<forall>y'. f x' = Some y' \\<longrightarrow> R x x'))\n 3. \\<And>\\<sigma> S.\n       \\<lbrakk>S \\<subseteq> S0; S \\<noteq> S0; \\<sigma> \\<noteq> None;\n        (\\<forall>y.\n            \\<sigma> = Some y \\<longrightarrow>\n            (\\<exists>x\\<in>S.\n                f x = Some y \\<and>\n                (\\<forall>x'\\<in>S - {x}.\n                    \\<forall>y'.\n                       f x' = Some y' \\<longrightarrow> R x x'))) \\<and>\n        (\\<sigma> = None) = (\\<forall>x\\<in>S. f x = None);\n        \\<forall>x\\<in>S0 - S. \\<forall>y\\<in>S. R y x\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = Some y \\<longrightarrow>\n                         (\\<exists>x\\<in>S0.\n                             f x = Some y \\<and>\n                             (\\<forall>x'\\<in>S0 - {x}.\n                                 \\<forall>y'.\n                                    f x' = Some y' \\<longrightarrow>\n                                    R x x'))", "apply (auto simp add: Bex_def subset_iff Ball_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>S x ya xa xb xc.\n       \\<lbrakk>\\<forall>t. t \\<in> S \\<longrightarrow> t \\<in> S0;\n        \\<forall>x.\n           x \\<in> S0 \\<and> x \\<notin> S \\<longrightarrow>\n           (\\<forall>xa. xa \\<in> S \\<longrightarrow> R xa x);\n        x \\<in> S; f x = Some ya;\n        \\<forall>x.\n           f x = Some y \\<longrightarrow>\n           x \\<in> S0 \\<longrightarrow>\n           (\\<exists>xa.\n               xa \\<in> S0 \\<and>\n               xa \\<noteq> x \\<and>\n               (\\<exists>y'. f xa = Some y') \\<and> \\<not> R x xa);\n        xa \\<in> S0; xa \\<notin> S; xb \\<in> S; xc \\<in> S; f xc = Some y;\n        \\<forall>x.\n           x \\<in> S \\<and> x \\<noteq> xc \\<longrightarrow>\n           (\\<exists>y'. f x = Some y') \\<longrightarrow> R xc x\\<rbrakk>\n       \\<Longrightarrow> f xb = None", "apply metis"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  iterate_sel it f = Some y \\<longrightarrow>\n  (\\<exists>x\\<in>S0.\n      f x = Some y \\<and>\n      (\\<forall>x'\\<in>S0 - {x}.\n          \\<forall>y'. f x' = Some y' \\<longrightarrow> R x x'))\n\ngoal (1 subgoal):\n 1. iterate_sel it f = Some y \\<Longrightarrow>\n    \\<exists>x\\<in>S0.\n       f x = Some y \\<and>\n       (\\<forall>x'\\<in>S0 - {x}.\n           \\<forall>y. f x' = Some y' \\<longrightarrow> R x x')", "moreover"], ["proof (state)\nthis:\n  iterate_sel it f = Some y \\<longrightarrow>\n  (\\<exists>x\\<in>S0.\n      f x = Some y \\<and>\n      (\\<forall>x'\\<in>S0 - {x}.\n          \\<forall>y'. f x' = Some y' \\<longrightarrow> R x x'))\n\ngoal (1 subgoal):\n 1. iterate_sel it f = Some y \\<Longrightarrow>\n    \\<exists>x\\<in>S0.\n       f x = Some y \\<and>\n       (\\<forall>x'\\<in>S0 - {x}.\n           \\<forall>y. f x' = Some y' \\<longrightarrow> R x x')", "assume \"iterate_sel it f = Some y\""], ["proof (state)\nthis:\n  iterate_sel it f = Some y\n\ngoal (1 subgoal):\n 1. iterate_sel it f = Some y \\<Longrightarrow>\n    \\<exists>x\\<in>S0.\n       f x = Some y \\<and>\n       (\\<forall>x'\\<in>S0 - {x}.\n           \\<forall>y. f x' = Some y' \\<longrightarrow> R x x')", "finally"], ["proof (chain)\npicking this:\n  \\<exists>x\\<in>S0.\n     f x = Some y \\<and>\n     (\\<forall>x'\\<in>S0 - {x}.\n         \\<forall>y'. f x' = Some y' \\<longrightarrow> R x x')", "show \"(\\<exists>x \\<in> S0. f x = Some y \\<and> (\\<forall>x' \\<in> S0-{x}. \\<forall>y. f x' = Some y' \\<longrightarrow> R x x'))\""], ["proof (prove)\nusing this:\n  \\<exists>x\\<in>S0.\n     f x = Some y \\<and>\n     (\\<forall>x'\\<in>S0 - {x}.\n         \\<forall>y'. f x' = Some y' \\<longrightarrow> R x x')\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>S0.\n       f x = Some y \\<and>\n       (\\<forall>x'\\<in>S0 - {x}.\n           \\<forall>y. f x' = Some y' \\<longrightarrow> R x x')", "by blast"], ["proof (state)\nthis:\n  \\<exists>x\\<in>S0.\n     f x = Some y \\<and>\n     (\\<forall>x'\\<in>S0 - {x}.\n         \\<forall>y. f x' = Some y' \\<longrightarrow> R x x')\n\ngoal:\nNo subgoals!", "qed"], ["", "definition iterate_sel_no_map where\n    \"iterate_sel_no_map it P = iterate_sel it (\\<lambda>x. if P x then Some x else None)\""], ["", "lemmas iterate_sel_no_map_alt_def = iterate_sel_no_map_def[unfolded iterate_sel_def, code]"], ["", "lemma iterate_sel_no_map_genord_correct :\nassumes it_OK: \"set_iterator_genord it S0 R\"\nshows \"iterate_sel_no_map it P = None \\<longleftrightarrow> (\\<forall>x\\<in>S0. \\<not>(P x))\"\n      \"iterate_sel_no_map it P = Some x \\<Longrightarrow> (x \\<in> S0 \\<and> P x \\<and> (\\<forall>x' \\<in> S0-{x}. P x' \\<longrightarrow> R x x'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (iterate_sel_no_map it P = None) = (\\<forall>x\\<in>S0. \\<not> P x) &&&\n    (iterate_sel_no_map it P = Some x \\<Longrightarrow>\n     x \\<in> S0 \\<and>\n     P x \\<and> (\\<forall>x'\\<in>S0 - {x}. P x' \\<longrightarrow> R x x'))", "unfolding iterate_sel_no_map_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (iterate_sel it (\\<lambda>x. if P x then Some x else None) = None) =\n    (\\<forall>x\\<in>S0. \\<not> P x) &&&\n    (iterate_sel it (\\<lambda>x. if P x then Some x else None) =\n     Some x \\<Longrightarrow>\n     x \\<in> S0 \\<and>\n     P x \\<and> (\\<forall>x'\\<in>S0 - {x}. P x' \\<longrightarrow> R x x'))", "using iterate_sel_genord_correct[OF it_OK, of \"\\<lambda>x. if P x then Some x else None\"]"], ["proof (prove)\nusing this:\n  (iterate_sel it (\\<lambda>x. if P x then Some x else None) = None) =\n  (\\<forall>x\\<in>S0. (if P x then Some x else None) = None)\n  iterate_sel it (\\<lambda>x. if P x then Some x else None) =\n  Some ?y \\<Longrightarrow>\n  \\<exists>x\\<in>S0.\n     (if P x then Some x else None) = Some ?y \\<and>\n     (\\<forall>x'\\<in>S0 - {x}.\n         \\<forall>y.\n            (if P x' then Some x' else None) = Some ?y' \\<longrightarrow>\n            R x x')\n\ngoal (1 subgoal):\n 1. (iterate_sel it (\\<lambda>x. if P x then Some x else None) = None) =\n    (\\<forall>x\\<in>S0. \\<not> P x) &&&\n    (iterate_sel it (\\<lambda>x. if P x then Some x else None) =\n     Some x \\<Longrightarrow>\n     x \\<in> S0 \\<and>\n     P x \\<and> (\\<forall>x'\\<in>S0 - {x}. P x' \\<longrightarrow> R x x'))", "apply (simp_all add: Bex_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>iterate_sel it (\\<lambda>x. if P x then Some x else None) =\n             Some x;\n     \\<exists>x.\n        x \\<in> S0 \\<and>\n        (\\<exists>y. (if P x then Some x else None) = Some y);\n     \\<And>y y'.\n        x = y \\<Longrightarrow>\n        \\<exists>x.\n           x \\<in> S0 \\<and>\n           (if P x then Some x else None) = Some y \\<and>\n           (\\<forall>x'\\<in>S0 - {x}.\n               (if P x' then Some x' else None) = Some y' \\<longrightarrow>\n               R x x')\\<rbrakk>\n    \\<Longrightarrow> x \\<in> S0 \\<and>\n                      P x \\<and>\n                      (\\<forall>x'\\<in>S0 - {x}.\n                          P x' \\<longrightarrow> R x x')", "apply (metis option.inject option.simps(2))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iterate_sel_no_map_correct :\nassumes it_OK: \"set_iterator it S0\"\nshows \"iterate_sel_no_map it P = None \\<longleftrightarrow> (\\<forall>x\\<in>S0. \\<not>(P x))\"\n      \"iterate_sel_no_map it P = Some x \\<Longrightarrow> x \\<in> S0 \\<and> P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (iterate_sel_no_map it P = None) = (\\<forall>x\\<in>S0. \\<not> P x) &&&\n    (iterate_sel_no_map it P = Some x \\<Longrightarrow>\n     x \\<in> S0 \\<and> P x)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. (iterate_sel_no_map it P = None) = (\\<forall>x\\<in>S0. \\<not> P x)\n 2. iterate_sel_no_map it P = Some x \\<Longrightarrow> x \\<in> S0 \\<and> P x", "note iterate_sel_no_map_genord_correct [OF it_OK[unfolded set_iterator_def], of P]"], ["proof (state)\nthis:\n  (iterate_sel_no_map it P = None) = (\\<forall>x\\<in>S0. \\<not> P x)\n  iterate_sel_no_map it P = Some ?x \\<Longrightarrow>\n  ?x \\<in> S0 \\<and>\n  P ?x \\<and> (\\<forall>x'\\<in>S0 - {?x}. P x' \\<longrightarrow> True)\n\ngoal (2 subgoals):\n 1. (iterate_sel_no_map it P = None) = (\\<forall>x\\<in>S0. \\<not> P x)\n 2. iterate_sel_no_map it P = Some x \\<Longrightarrow> x \\<in> S0 \\<and> P x", "thus \"iterate_sel_no_map it P = None \\<longleftrightarrow> (\\<forall>x\\<in>S0. \\<not>(P x))\"\n       \"iterate_sel_no_map it P = Some x \\<Longrightarrow> x \\<in> S0 \\<and> P x\""], ["proof (prove)\nusing this:\n  (iterate_sel_no_map it P = None) = (\\<forall>x\\<in>S0. \\<not> P x)\n  iterate_sel_no_map it P = Some ?x \\<Longrightarrow>\n  ?x \\<in> S0 \\<and>\n  P ?x \\<and> (\\<forall>x'\\<in>S0 - {?x}. P x' \\<longrightarrow> True)\n\ngoal (1 subgoal):\n 1. (iterate_sel_no_map it P = None) = (\\<forall>x\\<in>S0. \\<not> P x) &&&\n    (iterate_sel_no_map it P = Some x \\<Longrightarrow>\n     x \\<in> S0 \\<and> P x)", "by simp_all"], ["proof (state)\nthis:\n  (iterate_sel_no_map it P = None) = (\\<forall>x\\<in>S0. \\<not> P x)\n  iterate_sel_no_map it P = Some x \\<Longrightarrow> x \\<in> S0 \\<and> P x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in linorder) iterate_sel_no_map_linord_correct :\nassumes it_OK: \"set_iterator_linord it S0\"\nshows \"iterate_sel_no_map it P = None \\<longleftrightarrow> (\\<forall>x\\<in>S0. \\<not>(P x))\"\n      \"iterate_sel_no_map it P = Some x \\<Longrightarrow> (x \\<in> S0 \\<and> P x \\<and> (\\<forall>x'\\<in>S0. P x' \\<longrightarrow> x \\<le> x'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (iterate_sel_no_map it P = None) = (\\<forall>x\\<in>S0. \\<not> P x) &&&\n    (iterate_sel_no_map it P = Some x \\<Longrightarrow>\n     x \\<in> S0 \\<and>\n     P x \\<and> (\\<forall>x'\\<in>S0. P x' \\<longrightarrow> x \\<le> x'))", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. (iterate_sel_no_map it P = None) = (\\<forall>x\\<in>S0. \\<not> P x)\n 2. iterate_sel_no_map it P = Some x \\<Longrightarrow>\n    x \\<in> S0 \\<and>\n    P x \\<and> (\\<forall>x'\\<in>S0. P x' \\<longrightarrow> x \\<le> x')", "note iterate_sel_no_map_genord_correct [OF it_OK[unfolded set_iterator_linord_def], of P]"], ["proof (state)\nthis:\n  (iterate_sel_no_map it P = None) = (\\<forall>x\\<in>S0. \\<not> P x)\n  iterate_sel_no_map it P = Some ?x \\<Longrightarrow>\n  ?x \\<in> S0 \\<and>\n  P ?x \\<and>\n  (\\<forall>x'\\<in>S0 - {?x}. P x' \\<longrightarrow> ?x \\<le> x')\n\ngoal (2 subgoals):\n 1. (iterate_sel_no_map it P = None) = (\\<forall>x\\<in>S0. \\<not> P x)\n 2. iterate_sel_no_map it P = Some x \\<Longrightarrow>\n    x \\<in> S0 \\<and>\n    P x \\<and> (\\<forall>x'\\<in>S0. P x' \\<longrightarrow> x \\<le> x')", "thus \"iterate_sel_no_map it P = None \\<longleftrightarrow> (\\<forall>x\\<in>S0. \\<not>(P x))\"\n       \"iterate_sel_no_map it P = Some x \\<Longrightarrow> (x \\<in> S0 \\<and> P x \\<and> (\\<forall>x'\\<in>S0. P x' \\<longrightarrow> x \\<le> x'))\""], ["proof (prove)\nusing this:\n  (iterate_sel_no_map it P = None) = (\\<forall>x\\<in>S0. \\<not> P x)\n  iterate_sel_no_map it P = Some ?x \\<Longrightarrow>\n  ?x \\<in> S0 \\<and>\n  P ?x \\<and>\n  (\\<forall>x'\\<in>S0 - {?x}. P x' \\<longrightarrow> ?x \\<le> x')\n\ngoal (1 subgoal):\n 1. (iterate_sel_no_map it P = None) = (\\<forall>x\\<in>S0. \\<not> P x) &&&\n    (iterate_sel_no_map it P = Some x \\<Longrightarrow>\n     x \\<in> S0 \\<and>\n     P x \\<and> (\\<forall>x'\\<in>S0. P x' \\<longrightarrow> x \\<le> x'))", "by auto"], ["proof (state)\nthis:\n  (iterate_sel_no_map it P = None) = (\\<forall>x\\<in>S0. \\<not> P x)\n  iterate_sel_no_map it P = Some x \\<Longrightarrow>\n  x \\<in> S0 \\<and>\n  P x \\<and> (\\<forall>x'\\<in>S0. P x' \\<longrightarrow> x \\<le> x')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in linorder) iterate_sel_no_map_rev_linord_correct :\nassumes it_OK: \"set_iterator_rev_linord it S0\"\nshows \"iterate_sel_no_map it P = None \\<longleftrightarrow> (\\<forall>x\\<in>S0. \\<not>(P x))\"\n      \"iterate_sel_no_map it P = Some x \\<Longrightarrow> (x \\<in> S0 \\<and> P x \\<and> (\\<forall>x'\\<in>S0. P x' \\<longrightarrow> x' \\<le> x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (iterate_sel_no_map it P = None) = (\\<forall>x\\<in>S0. \\<not> P x) &&&\n    (iterate_sel_no_map it P = Some x \\<Longrightarrow>\n     x \\<in> S0 \\<and>\n     P x \\<and> (\\<forall>x'\\<in>S0. P x' \\<longrightarrow> x' \\<le> x))", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. (iterate_sel_no_map it P = None) = (\\<forall>x\\<in>S0. \\<not> P x)\n 2. iterate_sel_no_map it P = Some x \\<Longrightarrow>\n    x \\<in> S0 \\<and>\n    P x \\<and> (\\<forall>x'\\<in>S0. P x' \\<longrightarrow> x' \\<le> x)", "note iterate_sel_no_map_genord_correct [OF it_OK[unfolded set_iterator_rev_linord_def], of P]"], ["proof (state)\nthis:\n  (iterate_sel_no_map it P = None) = (\\<forall>x\\<in>S0. \\<not> P x)\n  iterate_sel_no_map it P = Some ?x \\<Longrightarrow>\n  ?x \\<in> S0 \\<and>\n  P ?x \\<and>\n  (\\<forall>x'\\<in>S0 - {?x}. P x' \\<longrightarrow> x' \\<le> ?x)\n\ngoal (2 subgoals):\n 1. (iterate_sel_no_map it P = None) = (\\<forall>x\\<in>S0. \\<not> P x)\n 2. iterate_sel_no_map it P = Some x \\<Longrightarrow>\n    x \\<in> S0 \\<and>\n    P x \\<and> (\\<forall>x'\\<in>S0. P x' \\<longrightarrow> x' \\<le> x)", "thus \"iterate_sel_no_map it P = None \\<longleftrightarrow> (\\<forall>x\\<in>S0. \\<not>(P x))\"\n       \"iterate_sel_no_map it P = Some x \\<Longrightarrow> (x \\<in> S0 \\<and> P x \\<and> (\\<forall>x'\\<in>S0. P x' \\<longrightarrow> x' \\<le> x))\""], ["proof (prove)\nusing this:\n  (iterate_sel_no_map it P = None) = (\\<forall>x\\<in>S0. \\<not> P x)\n  iterate_sel_no_map it P = Some ?x \\<Longrightarrow>\n  ?x \\<in> S0 \\<and>\n  P ?x \\<and>\n  (\\<forall>x'\\<in>S0 - {?x}. P x' \\<longrightarrow> x' \\<le> ?x)\n\ngoal (1 subgoal):\n 1. (iterate_sel_no_map it P = None) = (\\<forall>x\\<in>S0. \\<not> P x) &&&\n    (iterate_sel_no_map it P = Some x \\<Longrightarrow>\n     x \\<in> S0 \\<and>\n     P x \\<and> (\\<forall>x'\\<in>S0. P x' \\<longrightarrow> x' \\<le> x))", "by auto"], ["proof (state)\nthis:\n  (iterate_sel_no_map it P = None) = (\\<forall>x\\<in>S0. \\<not> P x)\n  iterate_sel_no_map it P = Some x \\<Longrightarrow>\n  x \\<in> S0 \\<and>\n  P x \\<and> (\\<forall>x'\\<in>S0. P x' \\<longrightarrow> x' \\<le> x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma iterate_sel_no_map_map_correct :\nassumes it_OK: \"map_iterator it m\"\nshows \"iterate_sel_no_map it P = None \\<longleftrightarrow> (\\<forall>k v. m k = Some v \\<longrightarrow> \\<not>(P (k, v)))\"\n      \"iterate_sel_no_map it P = Some (k, v) \\<Longrightarrow> (m k = Some v \\<and> P (k, v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (iterate_sel_no_map it P = None) =\n    (\\<forall>k v. m k = Some v \\<longrightarrow> \\<not> P (k, v)) &&&\n    (iterate_sel_no_map it P = Some (k, v) \\<Longrightarrow>\n     m k = Some v \\<and> P (k, v))", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. (iterate_sel_no_map it P = None) =\n    (\\<forall>k v. m k = Some v \\<longrightarrow> \\<not> P (k, v))\n 2. iterate_sel_no_map it P = Some (k, v) \\<Longrightarrow>\n    m k = Some v \\<and> P (k, v)", "note iterate_sel_no_map_genord_correct [OF it_OK[unfolded set_iterator_def], of P]"], ["proof (state)\nthis:\n  (iterate_sel_no_map it P = None) =\n  (\\<forall>x\\<in>map_to_set m. \\<not> P x)\n  iterate_sel_no_map it P = Some ?x \\<Longrightarrow>\n  ?x \\<in> map_to_set m \\<and>\n  P ?x \\<and>\n  (\\<forall>x'\\<in>map_to_set m - {?x}. P x' \\<longrightarrow> True)\n\ngoal (2 subgoals):\n 1. (iterate_sel_no_map it P = None) =\n    (\\<forall>k v. m k = Some v \\<longrightarrow> \\<not> P (k, v))\n 2. iterate_sel_no_map it P = Some (k, v) \\<Longrightarrow>\n    m k = Some v \\<and> P (k, v)", "thus \"iterate_sel_no_map it P = None \\<longleftrightarrow> (\\<forall>k v. m k = Some v \\<longrightarrow> \\<not>(P (k, v)))\"\n       \"iterate_sel_no_map it P = Some (k, v) \\<Longrightarrow> (m k = Some v \\<and> P (k, v))\""], ["proof (prove)\nusing this:\n  (iterate_sel_no_map it P = None) =\n  (\\<forall>x\\<in>map_to_set m. \\<not> P x)\n  iterate_sel_no_map it P = Some ?x \\<Longrightarrow>\n  ?x \\<in> map_to_set m \\<and>\n  P ?x \\<and>\n  (\\<forall>x'\\<in>map_to_set m - {?x}. P x' \\<longrightarrow> True)\n\ngoal (1 subgoal):\n 1. (iterate_sel_no_map it P = None) =\n    (\\<forall>k v. m k = Some v \\<longrightarrow> \\<not> P (k, v)) &&&\n    (iterate_sel_no_map it P = Some (k, v) \\<Longrightarrow>\n     m k = Some v \\<and> P (k, v))", "by (auto simp add: map_to_set_def)"], ["proof (state)\nthis:\n  (iterate_sel_no_map it P = None) =\n  (\\<forall>k v. m k = Some v \\<longrightarrow> \\<not> P (k, v))\n  iterate_sel_no_map it P = Some (k, v) \\<Longrightarrow>\n  m k = Some v \\<and> P (k, v)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in linorder) iterate_sel_no_map_map_linord_correct :\nassumes it_OK: \"map_iterator_linord it m\"\nshows \"iterate_sel_no_map it P = None \\<longleftrightarrow> (\\<forall>k v. m k = Some v \\<longrightarrow> \\<not>(P (k, v)))\"\n      \"iterate_sel_no_map it P = Some (k, v) \\<Longrightarrow> (m k = Some v \\<and> P (k, v) \\<and> (\\<forall>k' v' . m k' = Some v' \\<and>\n           P (k', v') \\<longrightarrow> k \\<le> k'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (iterate_sel_no_map it P = None) =\n    (\\<forall>k v. m k = Some v \\<longrightarrow> \\<not> P (k, v)) &&&\n    (iterate_sel_no_map it P = Some (k, v) \\<Longrightarrow>\n     m k = Some v \\<and>\n     P (k, v) \\<and>\n     (\\<forall>k' v'.\n         m k' = Some v' \\<and> P (k', v') \\<longrightarrow> k \\<le> k'))", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. (iterate_sel_no_map it P = None) =\n    (\\<forall>k v. m k = Some v \\<longrightarrow> \\<not> P (k, v))\n 2. iterate_sel_no_map it P = Some (k, v) \\<Longrightarrow>\n    m k = Some v \\<and>\n    P (k, v) \\<and>\n    (\\<forall>k' v'.\n        m k' = Some v' \\<and> P (k', v') \\<longrightarrow> k \\<le> k')", "note iterate_sel_no_map_genord_correct [OF it_OK[unfolded set_iterator_map_linord_def], of P]"], ["proof (state)\nthis:\n  (iterate_sel_no_map it P = None) =\n  (\\<forall>x\\<in>map_to_set m. \\<not> P x)\n  iterate_sel_no_map it P = Some ?x \\<Longrightarrow>\n  ?x \\<in> map_to_set m \\<and>\n  P ?x \\<and>\n  (\\<forall>x'\\<in>map_to_set m - {?x}.\n      P x' \\<longrightarrow>\n      (case ?x of (k, uu_) \\<Rightarrow> \\<lambda>(k', uu_). k \\<le> k') x')\n\ngoal (2 subgoals):\n 1. (iterate_sel_no_map it P = None) =\n    (\\<forall>k v. m k = Some v \\<longrightarrow> \\<not> P (k, v))\n 2. iterate_sel_no_map it P = Some (k, v) \\<Longrightarrow>\n    m k = Some v \\<and>\n    P (k, v) \\<and>\n    (\\<forall>k' v'.\n        m k' = Some v' \\<and> P (k', v') \\<longrightarrow> k \\<le> k')", "thus \"iterate_sel_no_map it P = None \\<longleftrightarrow> (\\<forall>k v. m k = Some v \\<longrightarrow> \\<not>(P (k, v)))\"\n       \"iterate_sel_no_map it P = Some (k, v) \\<Longrightarrow> (m k = Some v \\<and> P (k, v) \\<and> (\\<forall>k' v' . m k' = Some v' \\<and>\n           P (k', v') \\<longrightarrow> k \\<le> k'))\""], ["proof (prove)\nusing this:\n  (iterate_sel_no_map it P = None) =\n  (\\<forall>x\\<in>map_to_set m. \\<not> P x)\n  iterate_sel_no_map it P = Some ?x \\<Longrightarrow>\n  ?x \\<in> map_to_set m \\<and>\n  P ?x \\<and>\n  (\\<forall>x'\\<in>map_to_set m - {?x}.\n      P x' \\<longrightarrow>\n      (case ?x of (k, uu_) \\<Rightarrow> \\<lambda>(k', uu_). k \\<le> k') x')\n\ngoal (1 subgoal):\n 1. (iterate_sel_no_map it P = None) =\n    (\\<forall>k v. m k = Some v \\<longrightarrow> \\<not> P (k, v)) &&&\n    (iterate_sel_no_map it P = Some (k, v) \\<Longrightarrow>\n     m k = Some v \\<and>\n     P (k, v) \\<and>\n     (\\<forall>k' v'.\n         m k' = Some v' \\<and> P (k', v') \\<longrightarrow> k \\<le> k'))", "apply (auto simp add: map_to_set_def Ball_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (iterate_sel_no_map it P = None) =\n  (\\<forall>k v. m k = Some v \\<longrightarrow> \\<not> P (k, v))\n  iterate_sel_no_map it P = Some (k, v) \\<Longrightarrow>\n  m k = Some v \\<and>\n  P (k, v) \\<and>\n  (\\<forall>k' v'.\n      m k' = Some v' \\<and> P (k', v') \\<longrightarrow> k \\<le> k')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in linorder) iterate_sel_no_map_map_rev_linord_correct :\nassumes it_OK: \"map_iterator_rev_linord it m\"\nshows \"iterate_sel_no_map it P = None \\<longleftrightarrow> (\\<forall>k v. m k = Some v \\<longrightarrow> \\<not>(P (k, v)))\"\n      \"iterate_sel_no_map it P = Some (k, v) \\<Longrightarrow> (m k = Some v \\<and> P (k, v) \\<and> (\\<forall>k' v' . m k' = Some v' \\<and>\n           P (k', v') \\<longrightarrow> k' \\<le> k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (iterate_sel_no_map it P = None) =\n    (\\<forall>k v. m k = Some v \\<longrightarrow> \\<not> P (k, v)) &&&\n    (iterate_sel_no_map it P = Some (k, v) \\<Longrightarrow>\n     m k = Some v \\<and>\n     P (k, v) \\<and>\n     (\\<forall>k' v'.\n         m k' = Some v' \\<and> P (k', v') \\<longrightarrow> k' \\<le> k))", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. (iterate_sel_no_map it P = None) =\n    (\\<forall>k v. m k = Some v \\<longrightarrow> \\<not> P (k, v))\n 2. iterate_sel_no_map it P = Some (k, v) \\<Longrightarrow>\n    m k = Some v \\<and>\n    P (k, v) \\<and>\n    (\\<forall>k' v'.\n        m k' = Some v' \\<and> P (k', v') \\<longrightarrow> k' \\<le> k)", "note iterate_sel_no_map_genord_correct [OF it_OK[unfolded set_iterator_map_rev_linord_def], of P]"], ["proof (state)\nthis:\n  (iterate_sel_no_map it P = None) =\n  (\\<forall>x\\<in>map_to_set m. \\<not> P x)\n  iterate_sel_no_map it P = Some ?x \\<Longrightarrow>\n  ?x \\<in> map_to_set m \\<and>\n  P ?x \\<and>\n  (\\<forall>x'\\<in>map_to_set m - {?x}.\n      P x' \\<longrightarrow>\n      (case ?x of (k, uu_) \\<Rightarrow> \\<lambda>(k', uu_). k' \\<le> k) x')\n\ngoal (2 subgoals):\n 1. (iterate_sel_no_map it P = None) =\n    (\\<forall>k v. m k = Some v \\<longrightarrow> \\<not> P (k, v))\n 2. iterate_sel_no_map it P = Some (k, v) \\<Longrightarrow>\n    m k = Some v \\<and>\n    P (k, v) \\<and>\n    (\\<forall>k' v'.\n        m k' = Some v' \\<and> P (k', v') \\<longrightarrow> k' \\<le> k)", "thus \"iterate_sel_no_map it P = None \\<longleftrightarrow> (\\<forall>k v. m k = Some v \\<longrightarrow> \\<not>(P (k, v)))\"\n       \"iterate_sel_no_map it P = Some (k, v) \\<Longrightarrow> (m k = Some v \\<and> P (k, v) \\<and> (\\<forall>k' v' . m k' = Some v' \\<and>\n           P (k', v') \\<longrightarrow> k' \\<le> k))\""], ["proof (prove)\nusing this:\n  (iterate_sel_no_map it P = None) =\n  (\\<forall>x\\<in>map_to_set m. \\<not> P x)\n  iterate_sel_no_map it P = Some ?x \\<Longrightarrow>\n  ?x \\<in> map_to_set m \\<and>\n  P ?x \\<and>\n  (\\<forall>x'\\<in>map_to_set m - {?x}.\n      P x' \\<longrightarrow>\n      (case ?x of (k, uu_) \\<Rightarrow> \\<lambda>(k', uu_). k' \\<le> k) x')\n\ngoal (1 subgoal):\n 1. (iterate_sel_no_map it P = None) =\n    (\\<forall>k v. m k = Some v \\<longrightarrow> \\<not> P (k, v)) &&&\n    (iterate_sel_no_map it P = Some (k, v) \\<Longrightarrow>\n     m k = Some v \\<and>\n     P (k, v) \\<and>\n     (\\<forall>k' v'.\n         m k' = Some v' \\<and> P (k', v') \\<longrightarrow> k' \\<le> k))", "apply (auto simp add: map_to_set_def Ball_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (iterate_sel_no_map it P = None) =\n  (\\<forall>k v. m k = Some v \\<longrightarrow> \\<not> P (k, v))\n  iterate_sel_no_map it P = Some (k, v) \\<Longrightarrow>\n  m k = Some v \\<and>\n  P (k, v) \\<and>\n  (\\<forall>k' v'.\n      m k' = Some v' \\<and> P (k', v') \\<longrightarrow> k' \\<le> k)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Creating ordered iterators\\<close>"], ["", "text \\<open>One can transform an iterator into an ordered one by converting it to list, \n        sorting this list and then converting back to an iterator. In general, this brute-force\n        method is inefficient, though.\\<close>"], ["", "definition iterator_to_ordered_iterator where\n  \"iterator_to_ordered_iterator sort_fun it =\n   foldli (sort_fun (iterate_to_list it))\""], ["", "lemma iterator_to_ordered_iterator_correct :\nassumes sort_fun_OK: \"\\<And>l. sorted_wrt R (sort_fun l) \\<and> mset (sort_fun l) = mset l\"\n    and it_OK: \"set_iterator it S0\"\nshows \"set_iterator_genord (iterator_to_ordered_iterator sort_fun it) S0 R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_genord (iterator_to_ordered_iterator sort_fun it) S0 R", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set_iterator_genord (iterator_to_ordered_iterator sort_fun it) S0 R", "define l where \"l = iterate_to_list it\""], ["proof (state)\nthis:\n  l = iterate_to_list it\n\ngoal (1 subgoal):\n 1. set_iterator_genord (iterator_to_ordered_iterator sort_fun it) S0 R", "have l_props: \"set l = S0\" \"distinct l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set l = S0 &&& distinct l", "using iterate_to_list_correct [OF it_OK, folded l_def]"], ["proof (prove)\nusing this:\n  set l = S0 \\<and> distinct l\n\ngoal (1 subgoal):\n 1. set l = S0 &&& distinct l", "by simp_all"], ["proof (state)\nthis:\n  set l = S0\n  distinct l\n\ngoal (1 subgoal):\n 1. set_iterator_genord (iterator_to_ordered_iterator sort_fun it) S0 R", "with sort_fun_OK[of l]"], ["proof (chain)\npicking this:\n  sorted_wrt R (sort_fun l) \\<and> mset (sort_fun l) = mset l\n  set l = S0\n  distinct l", "have sort_l_props:\n    \"sorted_wrt R (sort_fun l)\"\n    \"set (sort_fun l) = S0\" \"distinct (sort_fun l)\""], ["proof (prove)\nusing this:\n  sorted_wrt R (sort_fun l) \\<and> mset (sort_fun l) = mset l\n  set l = S0\n  distinct l\n\ngoal (1 subgoal):\n 1. sorted_wrt R (sort_fun l) &&&\n    set (sort_fun l) = S0 &&& distinct (sort_fun l)", "apply (simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>sorted_wrt R (sort_fun l) \\<and> mset (sort_fun l) = mset l;\n     set l = S0; distinct l\\<rbrakk>\n    \\<Longrightarrow> set (sort_fun l) = S0\n 2. \\<lbrakk>sorted_wrt R (sort_fun l) \\<and> mset (sort_fun l) = mset l;\n     set l = S0; distinct l\\<rbrakk>\n    \\<Longrightarrow> distinct (sort_fun l)", "apply (metis set_mset_mset)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_wrt R (sort_fun l) \\<and> mset (sort_fun l) = mset l;\n     set l = S0; distinct l\\<rbrakk>\n    \\<Longrightarrow> distinct (sort_fun l)", "apply (metis distinct_count_atmost_1 set_mset_mset)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  sorted_wrt R (sort_fun l)\n  set (sort_fun l) = S0\n  distinct (sort_fun l)\n\ngoal (1 subgoal):\n 1. set_iterator_genord (iterator_to_ordered_iterator sort_fun it) S0 R", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_genord (iterator_to_ordered_iterator sort_fun it) S0 R", "apply (rule set_iterator_genord_I[of \"sort_fun l\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. distinct (sort_fun l)\n 2. S0 = set (sort_fun l)\n 3. sorted_wrt R (sort_fun l)\n 4. iterator_to_ordered_iterator sort_fun it = foldli (sort_fun l)", "apply (simp_all add: sort_l_props iterator_to_ordered_iterator_def l_def[symmetric])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  set_iterator_genord (iterator_to_ordered_iterator sort_fun it) S0 R\n\ngoal:\nNo subgoals!", "qed"], ["", "definition iterator_to_ordered_iterator_quicksort where\n  \"iterator_to_ordered_iterator_quicksort R it =\n   iterator_to_ordered_iterator (quicksort_by_rel R []) it\""], ["", "lemmas iterator_to_ordered_iterator_quicksort_code[code] =\n  iterator_to_ordered_iterator_quicksort_def[unfolded iterator_to_ordered_iterator_def]"], ["", "lemma iterator_to_ordered_iterator_quicksort_correct :\nassumes lin : \"\\<And>x y. (R x y) \\<or> (R y x)\"\n    and trans_R: \"\\<And>x y z. R x y \\<Longrightarrow> R y z \\<Longrightarrow> R x z\"\n    and it_OK: \"set_iterator it S0\"\nshows \"set_iterator_genord (iterator_to_ordered_iterator_quicksort R it) S0 R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_genord (iterator_to_ordered_iterator_quicksort R it) S0 R", "unfolding iterator_to_ordered_iterator_quicksort_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_genord\n     (iterator_to_ordered_iterator (quicksort_by_rel R []) it) S0 R", "apply (rule iterator_to_ordered_iterator_correct [OF _ it_OK])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l.\n       sorted_wrt R (quicksort_by_rel R [] l) \\<and>\n       mset (quicksort_by_rel R [] l) = mset l", "apply (simp_all add: sorted_wrt_quicksort_by_rel[OF lin trans_R])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition iterator_to_ordered_iterator_mergesort where\n  \"iterator_to_ordered_iterator_mergesort R it =\n   iterator_to_ordered_iterator (mergesort_by_rel R) it\""], ["", "lemmas iterator_to_ordered_iterator_mergesort_code[code] =\n  iterator_to_ordered_iterator_mergesort_def[unfolded iterator_to_ordered_iterator_def]"], ["", "lemma iterator_to_ordered_iterator_mergesort_correct :\nassumes lin : \"\\<And>x y. (R x y) \\<or> (R y x)\"\n    and trans_R: \"\\<And>x y z. R x y \\<Longrightarrow> R y z \\<Longrightarrow> R x z\"\n    and it_OK: \"set_iterator it S0\"\nshows \"set_iterator_genord (iterator_to_ordered_iterator_mergesort R it) S0 R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_genord (iterator_to_ordered_iterator_mergesort R it) S0 R", "unfolding iterator_to_ordered_iterator_mergesort_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_genord\n     (iterator_to_ordered_iterator (mergesort_by_rel R) it) S0 R", "apply (rule iterator_to_ordered_iterator_correct [OF _ it_OK])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l.\n       sorted_wrt R (mergesort_by_rel R l) \\<and>\n       mset (mergesort_by_rel R l) = mset l", "apply (simp_all add: sorted_wrt_mergesort_by_rel[OF lin trans_R])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}