{"file_name": "/home/qj213/afp-2021-10-22/thys/Collections/ICF/spec/PrioUniqueSpec.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Collections", "problem_names": ["lemma popE: \n    assumes \n    \"invar s\" \n    \"\\<alpha> s \\<noteq> Map.empty\" \n    obtains e a s' where \n    \"pop s = (e, a, s')\" \n    \"invar s'\" \n    \"\\<alpha> s' = (\\<alpha> s)(e := None)\" \n    \"(\\<alpha> s) e = Some a\" \n    \"(\\<forall>y \\<in> ran (\\<alpha> s). a \\<le> y)\"", "lemmas correct = \n    finite_correct \n    empty_correct \n    isEmpty_correct \n    insert_correct \n    prio_correct"], "translations": [["", "lemma popE: \n    assumes \n    \"invar s\" \n    \"\\<alpha> s \\<noteq> Map.empty\" \n    obtains e a s' where \n    \"pop s = (e, a, s')\" \n    \"invar s'\" \n    \"\\<alpha> s' = (\\<alpha> s)(e := None)\" \n    \"(\\<alpha> s) e = Some a\" \n    \"(\\<forall>y \\<in> ran (\\<alpha> s). a \\<le> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e a s'.\n        \\<lbrakk>pop s = (e, a, s'); invar s';\n         \\<alpha> s' = (\\<alpha> s)(e := None); \\<alpha> s e = Some a;\n         \\<forall>y\\<in>ran (\\<alpha> s). a \\<le> y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  invar s\n  \\<alpha> s \\<noteq> Map.empty\n\ngoal (1 subgoal):\n 1. (\\<And>e a s'.\n        \\<lbrakk>pop s = (e, a, s'); invar s';\n         \\<alpha> s' = (\\<alpha> s)(e := None); \\<alpha> s e = Some a;\n         \\<forall>y\\<in>ran (\\<alpha> s). a \\<le> y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (cases \"pop s\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>\\<And>e a s'.\n                   \\<lbrakk>pop s = (e, a, s'); invar s';\n                    \\<alpha> s' = (\\<alpha> s)(e := None);\n                    \\<alpha> s e = Some a;\n                    \\<forall>y\\<in>ran (\\<alpha> s). a \\<le> y\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        invar s; \\<alpha> s \\<noteq> Map.empty; pop s = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (drule (2) pop_correct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>\\<And>e a s'.\n                   \\<lbrakk>pop s = (e, a, s'); invar s';\n                    \\<alpha> s' = (\\<alpha> s)(e := None);\n                    \\<alpha> s e = Some a;\n                    \\<forall>y\\<in>ran (\\<alpha> s). a \\<le> y\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<alpha> s \\<noteq> Map.empty; pop s = (a, b, c);\n        invar c \\<and>\n        \\<alpha> c = (\\<alpha> s)(a := None) \\<and>\n        \\<alpha> s a = Some b \\<and>\n        (\\<forall>y\\<in>ran (\\<alpha> s). b \\<le> y)\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "subsubsection \"Insert\""], ["", "text \\<open>\n  If an existing element is inserted, its priority will be overwritten.\n  This can be used to implement a decrease-key operation.\n\\<close>"], ["", "(* TODO: Implement decrease-key generic algorithm, and specify decrease-key operation here! *)"], ["", "locale uprio_insert = uprio +\n  constrains \\<alpha> :: \"'s \\<Rightarrow> ('e \\<rightharpoonup> 'a::linorder)\"\n  fixes insert :: \"'s \\<Rightarrow> 'e \\<Rightarrow> 'a \\<Rightarrow> 's\"\n  assumes insert_correct: \n  \"invar s \\<Longrightarrow> invar (insert s e a)\"\n  \"invar s \\<Longrightarrow> \\<alpha> (insert s e a) = (\\<alpha> s)(e \\<mapsto> a)\""], ["", "subsubsection \"Distinct Insert\""], ["", "text \\<open>\n  This operation only allows insertion of elements\n  that are not yet in the queue.\n\\<close>"], ["", "locale uprio_distinct_insert = uprio +\n  constrains \\<alpha> :: \"'s \\<Rightarrow> ('e \\<rightharpoonup> 'a::linorder)\"\n  fixes insert :: \"'s \\<Rightarrow> 'e \\<Rightarrow> 'a \\<Rightarrow> 's\"\n  assumes distinct_insert_correct: \n  \"\\<lbrakk>invar s; e \\<notin> dom (\\<alpha> s)\\<rbrakk> \\<Longrightarrow> invar (insert s e a)\"\n  \"\\<lbrakk>invar s; e \\<notin> dom (\\<alpha> s)\\<rbrakk> \\<Longrightarrow> \\<alpha> (insert s e a) = (\\<alpha> s)(e \\<mapsto> a)\""], ["", "subsubsection \"Looking up Priorities\""], ["", "locale uprio_prio = uprio +\n  constrains \\<alpha> :: \"'s \\<Rightarrow> ('e \\<rightharpoonup> 'a::linorder)\"\n  fixes prio :: \"'s \\<Rightarrow> 'e \\<Rightarrow> 'a option\"\n  assumes prio_correct: \n  \"invar s \\<Longrightarrow> prio s e = (\\<alpha> s) e\""], ["", "subsection \"Record Based Interface\""], ["", "record ('e, 'a, 's) uprio_ops =\n  upr_\\<alpha> :: \"'s \\<Rightarrow> ('e \\<rightharpoonup> 'a)\" \n  upr_invar :: \"'s \\<Rightarrow> bool\"                 \n  upr_empty :: \"unit \\<Rightarrow> 's\"\n  upr_isEmpty :: \"'s \\<Rightarrow> bool\"\n  upr_insert :: \"'s \\<Rightarrow> 'e \\<Rightarrow> 'a \\<Rightarrow> 's\"\n  upr_pop :: \"'s \\<Rightarrow> ('e \\<times> 'a \\<times> 's)\"\n  upr_prio :: \"'s \\<Rightarrow> 'e \\<Rightarrow> 'a option\""], ["", "locale StdUprioDefs =\n  fixes ops :: \"('e,'a::linorder,'s, 'more) uprio_ops_scheme\"\nbegin"], ["", "abbreviation \\<alpha> where \"\\<alpha> == upr_\\<alpha> ops\""], ["", "abbreviation invar where \"invar == upr_invar ops\""], ["", "abbreviation empty where \"empty == upr_empty ops\""], ["", "abbreviation isEmpty where \"isEmpty == upr_isEmpty ops\""], ["", "abbreviation insert where \"insert == upr_insert ops\""], ["", "abbreviation pop where \"pop == upr_pop ops\""], ["", "abbreviation prio where \"prio == upr_prio ops\""], ["", "end"], ["", "locale StdUprio =  StdUprioDefs ops +\n  uprio_finite \\<alpha> invar + \n  uprio_empty \\<alpha> invar empty + \n  uprio_isEmpty \\<alpha> invar isEmpty + \n  uprio_insert \\<alpha> invar insert + \n  uprio_pop \\<alpha> invar pop + \n  uprio_prio \\<alpha> invar prio\n  for ops\nbegin"], ["", "lemmas correct = \n    finite_correct \n    empty_correct \n    isEmpty_correct \n    insert_correct \n    prio_correct"], ["", "end"], ["", "locale StdUprio_no_invar = StdUprio + uprio_no_invar \\<alpha> invar"], ["", "end"]]}