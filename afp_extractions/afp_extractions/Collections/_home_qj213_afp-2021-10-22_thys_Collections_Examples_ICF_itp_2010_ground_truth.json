{"file_name": "/home/qj213/afp-2021-10-22/thys/Collections/Examples/ICF/itp_2010.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Collections", "problem_names": ["lemma set_a_correct: \"set_a l s = set l \\<union> s\"", "lemma (in StdSet) set_i_impl: \"invar s \\<Longrightarrow> invar (set_i l s) \\<and> \\<alpha> (set_i l s) = set_a l (\\<alpha> s)\"", "lemmas hs_set_i_impl = hs.set_i_impl[folded hs_seti_def]", "lemma set_a2_correct: \"set_a2 l = set l\"", "lemma (in StdSet) set_i2_impl: \"invar s \\<Longrightarrow> invar (set_i2 l) \\<and> \\<alpha> (set_i2 l) = set_a2 l\"", "lemmas hs_set_i2_impl = hs.set_i2_impl[folded hs_seti2_def]\n\n  \\<comment> \\<open>Code generation\\<close>", "lemma (in StdSet) set_i'_impl:\n    \"invar s \\<Longrightarrow> invar (set_i' ins l s) \\<and> \\<alpha> (set_i' ins l s) = set_a l (\\<alpha> s)\"", "lemmas hs_set_i'_impl = hs.set_i'_impl[folded hs_seti'_def]\n\n  \\<comment> \\<open>Code generation\\<close>", "lemma avg_aux_correct: \"invar s \\<Longrightarrow> avg_aux s = (card (\\<alpha> s), \\<Sum>(\\<alpha> s) )\"", "lemma avg_correct: \"invar s \\<Longrightarrow> avg s = average (\\<alpha> s)\"", "lemma filter_le_avg_correct: \n      \"invar s \\<Longrightarrow> \n        invar (filter_le_avg s) \\<and> \n        \\<alpha> (filter_le_avg s) = {x\\<in>\\<alpha> s. x\\<le>average (\\<alpha> s)}\"", "lemmas my_correct = hs.correct", "lemmas my_iterate_rule_P = hs.iterate_rule_P", "lemma avg_aux_correct: \"my_invar s \\<Longrightarrow> avg_aux s = (card (my_\\<alpha> s), \\<Sum>(my_\\<alpha> s) )\"", "lemma avg_correct: \"my_invar s \\<Longrightarrow> avg s = average (my_\\<alpha> s)\"", "lemma filter_le_avg_correct: \n    \"my_invar s \\<Longrightarrow> \n    my_invar (filter_le_avg s) \\<and> \n    my_\\<alpha> (filter_le_avg s) = {x\\<in>my_\\<alpha> s. x\\<le>average (my_\\<alpha> s)}\""], "translations": [["", "lemma set_a_correct: \"set_a l s = set l \\<union> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_a l s = set l \\<union> s", "by (induct l arbitrary: s) auto\n\n  \\<comment> \\<open>Generic algorithm\\<close>"], ["", "setup Locale_Code.open_block \\<comment> \\<open>Required to make definitions inside locales\n    executable\\<close>"], ["", "fun (in StdSetDefs) set_i where\n    \"set_i [] s = s\" |\n    \"set_i (a#l) s = set_i l (ins a s)\""], ["", "setup Locale_Code.close_block\n\n  \\<comment> \\<open>Correct implementation of ca\\<close>"], ["", "lemma (in StdSet) set_i_impl: \"invar s \\<Longrightarrow> invar (set_i l s) \\<and> \\<alpha> (set_i l s) = set_a l (\\<alpha> s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar s \\<Longrightarrow>\n    invar (set_i l s) \\<and> \\<alpha> (set_i l s) = set_a l (\\<alpha> s)", "by (induct l arbitrary: s) (auto simp add: correct)\n\n  \\<comment> \\<open>Instantiation\\<close>"], ["", "(* We need to declare a constant to make the code generator work *)"], ["", "definition \"hs_seti == hs.set_i\""], ["", "(*declare hs.set_i.simps[folded hs_seti_def, code]*)"], ["", "lemmas hs_set_i_impl = hs.set_i_impl[folded hs_seti_def]"], ["", "export_code hs_seti checking SML\n\n  \\<comment> \\<open>Code generation\\<close>"], ["", "ML \\<open>@{code hs_seti}\\<close>"], ["", "(*value \"hs_seti [1,2,3::nat] hs_empty\"*)"], ["", "subsubsection \"Tail-Recursive version\"\n  \\<comment> \\<open>Abstract algorithm\\<close>"], ["", "fun set_a2 where\n    \"set_a2 [] = {}\" |\n    \"set_a2 (a#l) = (insert a (set_a2 l))\"\n\n  \\<comment> \\<open>Correctness of aa\\<close>"], ["", "lemma set_a2_correct: \"set_a2 l = set l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_a2 l = set l", "by (induct l) auto\n\n  \\<comment> \\<open>Generic algorithm\\<close>"], ["", "setup Locale_Code.open_block"], ["", "fun (in StdSetDefs) set_i2 where\n    \"set_i2 [] = empty ()\" |\n    \"set_i2 (a#l) = (ins a (set_i2 l))\""], ["", "setup Locale_Code.close_block\n\n  \\<comment> \\<open>Correct implementation of ca\\<close>"], ["", "lemma (in StdSet) set_i2_impl: \"invar s \\<Longrightarrow> invar (set_i2 l) \\<and> \\<alpha> (set_i2 l) = set_a2 l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar s \\<Longrightarrow>\n    invar (set_i2 l) \\<and> \\<alpha> (set_i2 l) = set_a2 l", "by (induct l) (auto simp add: correct)\n\n  \\<comment> \\<open>Instantiation\\<close>"], ["", "definition \"hs_seti2 == hs.set_i2\""], ["", "(*declare hsr.set_i2.simps[folded hs_seti2_def, code]*)"], ["", "lemmas hs_set_i2_impl = hs.set_i2_impl[folded hs_seti2_def]\n\n  \\<comment> \\<open>Code generation\\<close>"], ["", "ML \\<open>@{code hs_seti2}\\<close>"], ["", "(*value \"hs_seti [1,2,3::nat] hs_empty\"*)"], ["", "subsubsection \"With explicit operation parameters\"\n\n  \\<comment> \\<open>Alternative for few operation parameters\\<close>"], ["", "fun set_i' where\n    \"!!ins. set_i' ins [] s = s\" |\n    \"!!ins. set_i' ins (a#l) s = set_i' ins l (ins a s)\""], ["", "lemma (in StdSet) set_i'_impl:\n    \"invar s \\<Longrightarrow> invar (set_i' ins l s) \\<and> \\<alpha> (set_i' ins l s) = set_a l (\\<alpha> s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar s \\<Longrightarrow>\n    invar (set_i' ins l s) \\<and>\n    \\<alpha> (set_i' ins l s) = set_a l (\\<alpha> s)", "by (induct l arbitrary: s) (auto simp add: correct)\n\n  \\<comment> \\<open>Instantiation\\<close>"], ["", "definition \"hs_seti' == set_i' hs.ins\""], ["", "lemmas hs_set_i'_impl = hs.set_i'_impl[folded hs_seti'_def]\n\n  \\<comment> \\<open>Code generation\\<close>"], ["", "ML \\<open>@{code hs_seti'}\\<close>"], ["", "(*value \"hs_seti' [1,2,3::nat] hs_empty\"*)"], ["", "subsection \"Filter Average\""], ["", "text \\<open>\n  In this more complex example, we develop a function that filters from a set all\n  numbers that are above the average of the set.\n \n  First, we formulate this as a generic algorithm using a locale.\n  This solution shows how the ICF v2 overcomes some technical problems that\n  ICF v1 had: \n  \\begin{itemize}\n    \\item Iterators are now polymorphic in the type, even inside locales.\n      Hence, there is no special handling of iterators, as it was required\n      in ICF v1.\n    \\item The Locale-Code package handles code generation for the instantiated\n      locale. There is no need for lengthy boilerplate code as it was required\n      in ICF v1.\n  \\end{itemize}\n\n\n  Another possibility is to fix the used \n  implementations beforehand. Changing the implementation is still easy by\n  changing the used operations. In this example, all used operations are \n  introduced by abbbreviations, localizing the required changes to a small part\n  of the theory. This approach is more powerful, as operations are now \n  polymorphic also in the element type. However, it only allows as single \n  instantiation at a time, which is no option for generic algorithms.\n\\<close>"], ["", "abbreviation \"average S == \\<Sum>S div card S\""], ["", "subsubsection \"Generic Algorithm\""], ["", "locale MyContext =\n    StdSet ops for ops :: \"(nat,'s,'more) set_ops_scheme\"\n  begin"], ["", "definition avg_aux :: \"'s \\<Rightarrow> nat\\<times>nat\" \n      where\n      \"avg_aux s == iterate s (\\<lambda>x (c,s). (c+1, s+x)) (0,0)\""], ["", "definition \"avg s == case avg_aux s of (c,s) \\<Rightarrow> s div c\""], ["", "definition \"filter_le_avg s == let a=avg s in\n      iterate s (\\<lambda>x s. if x\\<le>a then ins x s else s) (empty ())\""], ["", "lemma avg_aux_correct: \"invar s \\<Longrightarrow> avg_aux s = (card (\\<alpha> s), \\<Sum>(\\<alpha> s) )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar s \\<Longrightarrow>\n    avg_aux s = (card (\\<alpha> s), \\<Sum> (\\<alpha> s))", "apply (unfold avg_aux_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. invar s \\<Longrightarrow>\n    iterate s (\\<lambda>x (c, s). (c + 1, s + x)) (0, 0) =\n    (card (\\<alpha> s), \\<Sum> (\\<alpha> s))", "apply (rule_tac \n        I=\"\\<lambda>it (c,sum). c=card (\\<alpha> s - it) \\<and> sum=\\<Sum>(\\<alpha> s - it)\" \n        in iterate_rule_P)"], ["proof (prove)\ngoal (4 subgoals):\n 1. invar s \\<Longrightarrow> invar s\n 2. invar s \\<Longrightarrow>\n    case (0, 0) of\n    (c, sum) \\<Rightarrow>\n      c = card (\\<alpha> s - \\<alpha> s) \\<and>\n      sum = \\<Sum> (\\<alpha> s - \\<alpha> s)\n 3. \\<And>x it \\<sigma>.\n       \\<lbrakk>invar s; x \\<in> it; it \\<subseteq> \\<alpha> s;\n        case \\<sigma> of\n        (c, sum) \\<Rightarrow>\n          c = card (\\<alpha> s - it) \\<and>\n          sum = \\<Sum> (\\<alpha> s - it)\\<rbrakk>\n       \\<Longrightarrow> case case \\<sigma> of\n                              (c, s) \\<Rightarrow> (c + 1, s + x) of\n                         (c, sum) \\<Rightarrow>\n                           c = card (\\<alpha> s - (it - {x})) \\<and>\n                           sum = \\<Sum> (\\<alpha> s - (it - {x}))\n 4. \\<And>\\<sigma>.\n       \\<lbrakk>invar s;\n        case \\<sigma> of\n        (c, sum) \\<Rightarrow>\n          c = card (\\<alpha> s - {}) \\<and>\n          sum = \\<Sum> (\\<alpha> s - {})\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = (card (\\<alpha> s), \\<Sum> (\\<alpha> s))", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x it.\n       \\<lbrakk>invar s; x \\<in> it; it \\<subseteq> \\<alpha> s\\<rbrakk>\n       \\<Longrightarrow> Suc (card (\\<alpha> s - it)) =\n                         card (\\<alpha> s - (it - {x}))\n 2. \\<And>x it.\n       \\<lbrakk>invar s; x \\<in> it; it \\<subseteq> \\<alpha> s\\<rbrakk>\n       \\<Longrightarrow> \\<Sum> (\\<alpha> s - it) + x =\n                         \\<Sum> (\\<alpha> s - (it - {x}))", "apply (subgoal_tac \"\\<alpha> s - (it - {x}) = insert x (\\<alpha> s - it)\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x it.\n       \\<lbrakk>invar s; x \\<in> it; it \\<subseteq> \\<alpha> s;\n        \\<alpha> s - (it - {x}) = insert x (\\<alpha> s - it)\\<rbrakk>\n       \\<Longrightarrow> Suc (card (\\<alpha> s - it)) =\n                         card (\\<alpha> s - (it - {x}))\n 2. \\<And>x it.\n       \\<lbrakk>invar s; x \\<in> it; it \\<subseteq> \\<alpha> s\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> s - (it - {x}) =\n                         insert x (\\<alpha> s - it)\n 3. \\<And>x it.\n       \\<lbrakk>invar s; x \\<in> it; it \\<subseteq> \\<alpha> s\\<rbrakk>\n       \\<Longrightarrow> \\<Sum> (\\<alpha> s - it) + x =\n                         \\<Sum> (\\<alpha> s - (it - {x}))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x it.\n       \\<lbrakk>invar s; x \\<in> it; it \\<subseteq> \\<alpha> s\\<rbrakk>\n       \\<Longrightarrow> \\<Sum> (\\<alpha> s - it) + x =\n                         \\<Sum> (\\<alpha> s - (it - {x}))", "apply (subgoal_tac \"\\<alpha> s - (it - {x}) = insert x (\\<alpha> s - it)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x it.\n       \\<lbrakk>invar s; x \\<in> it; it \\<subseteq> \\<alpha> s;\n        \\<alpha> s - (it - {x}) = insert x (\\<alpha> s - it)\\<rbrakk>\n       \\<Longrightarrow> \\<Sum> (\\<alpha> s - it) + x =\n                         \\<Sum> (\\<alpha> s - (it - {x}))\n 2. \\<And>x it.\n       \\<lbrakk>invar s; x \\<in> it; it \\<subseteq> \\<alpha> s\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> s - (it - {x}) =\n                         insert x (\\<alpha> s - it)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma avg_correct: \"invar s \\<Longrightarrow> avg s = average (\\<alpha> s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar s \\<Longrightarrow> avg s = average (\\<alpha> s)", "unfolding avg_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. invar s \\<Longrightarrow>\n    (case avg_aux s of (c, s) \\<Rightarrow> s div c) = average (\\<alpha> s)", "using avg_aux_correct"], ["proof (prove)\nusing this:\n  invar ?s \\<Longrightarrow>\n  avg_aux ?s = (card (\\<alpha> ?s), \\<Sum> (\\<alpha> ?s))\n\ngoal (1 subgoal):\n 1. invar s \\<Longrightarrow>\n    (case avg_aux s of (c, s) \\<Rightarrow> s div c) = average (\\<alpha> s)", "by auto"], ["", "lemma filter_le_avg_correct: \n      \"invar s \\<Longrightarrow> \n        invar (filter_le_avg s) \\<and> \n        \\<alpha> (filter_le_avg s) = {x\\<in>\\<alpha> s. x\\<le>average (\\<alpha> s)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar s \\<Longrightarrow>\n    invar (filter_le_avg s) \\<and>\n    \\<alpha> (filter_le_avg s) =\n    {x \\<in> \\<alpha> s. x \\<le> average (\\<alpha> s)}", "unfolding filter_le_avg_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. invar s \\<Longrightarrow>\n    invar\n     (iterate s (\\<lambda>x sa. if x \\<le> avg s then ins x sa else sa)\n       (local.empty ())) \\<and>\n    \\<alpha>\n     (iterate s (\\<lambda>x sa. if x \\<le> avg s then ins x sa else sa)\n       (local.empty ())) =\n    {x \\<in> \\<alpha> s. x \\<le> average (\\<alpha> s)}", "apply (rule_tac\n        I=\"\\<lambda>it r. invar r \\<and> \\<alpha> r = {x\\<in>\\<alpha> s - it. x\\<le>average (\\<alpha> s)}\"\n        in iterate_rule_P)"], ["proof (prove)\ngoal (4 subgoals):\n 1. invar s \\<Longrightarrow> invar s\n 2. invar s \\<Longrightarrow>\n    invar (local.empty ()) \\<and>\n    \\<alpha> (local.empty ()) =\n    {x \\<in> \\<alpha> s - \\<alpha> s. x \\<le> average (\\<alpha> s)}\n 3. \\<And>x it \\<sigma>.\n       \\<lbrakk>invar s; x \\<in> it; it \\<subseteq> \\<alpha> s;\n        invar \\<sigma> \\<and>\n        \\<alpha> \\<sigma> =\n        {x \\<in> \\<alpha> s - it. x \\<le> average (\\<alpha> s)}\\<rbrakk>\n       \\<Longrightarrow> invar\n                          (if x \\<le> avg s then ins x \\<sigma>\n                           else \\<sigma>) \\<and>\n                         \\<alpha>\n                          (if x \\<le> avg s then ins x \\<sigma>\n                           else \\<sigma>) =\n                         {xa \\<in> \\<alpha> s - (it - {x}).\n                          xa \\<le> average (\\<alpha> s)}\n 4. \\<And>\\<sigma>.\n       \\<lbrakk>invar s;\n        invar \\<sigma> \\<and>\n        \\<alpha> \\<sigma> =\n        {x \\<in> \\<alpha> s - {}. x \\<le> average (\\<alpha> s)}\\<rbrakk>\n       \\<Longrightarrow> invar \\<sigma> \\<and>\n                         \\<alpha> \\<sigma> =\n                         {x \\<in> \\<alpha> s. x \\<le> average (\\<alpha> s)}", "apply (auto simp add: correct avg_correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "setup Locale_Code.open_block"], ["", "interpretation hs_ctx: MyContext hs_ops"], ["proof (prove)\ngoal (1 subgoal):\n 1. MyContext hs_ops", "by unfold_locales"], ["", "interpretation rs_ctx: MyContext rs_ops"], ["proof (prove)\ngoal (1 subgoal):\n 1. MyContext rs_ops", "by unfold_locales"], ["", "setup Locale_Code.close_block"], ["", "definition \"hs_flt_avg_test \\<equiv> hs.to_list \n    o hs_ctx.filter_le_avg \n    o hs.from_list\""], ["", "definition \"rs_flt_avg_test \\<equiv> rs.to_list \n    o rs_ctx.filter_le_avg \n    o rs.from_list\""], ["", "text \"Code generation\""], ["", "ML_val \\<open>\n    if @{code hs_flt_avg_test} (map @{code nat_of_integer} [1,2,3,4,6,7])\n    <> @{code rs_flt_avg_test} (map @{code nat_of_integer} [1,2,3,4,6,7])\n    then error \"Oops\"\n    else ()\n\\<close>"], ["", "subsubsection \"Using abbreviations\""], ["", "type_synonym 'a my_set = \"'a hs\""], ["", "abbreviation \"my_\\<alpha> == hs.\\<alpha>\""], ["", "abbreviation \"my_invar == hs.invar\""], ["", "abbreviation \"my_empty == hs.empty\""], ["", "abbreviation \"my_ins == hs.ins\""], ["", "abbreviation \"my_iterate == hs.iteratei\""], ["", "lemmas my_correct = hs.correct"], ["", "lemmas my_iterate_rule_P = hs.iterate_rule_P"], ["", "definition avg_aux :: \"nat my_set \\<Rightarrow> nat\\<times>nat\" \n    where\n    \"avg_aux s == my_iterate s (\\<lambda>_. True) (\\<lambda>x (c,s). (c+1, s+x)) (0,0)\""], ["", "definition \"avg s == case avg_aux s of (c,s) \\<Rightarrow> s div c\""], ["", "definition \"filter_le_avg s == let a=avg s in\n    my_iterate s (\\<lambda>_. True) (\\<lambda>x s. if x\\<le>a then my_ins x s else s) (my_empty ())\""], ["", "lemma avg_aux_correct: \"my_invar s \\<Longrightarrow> avg_aux s = (card (my_\\<alpha> s), \\<Sum>(my_\\<alpha> s) )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. my_invar s \\<Longrightarrow>\n    avg_aux s = (card (my_\\<alpha> s), \\<Sum> (my_\\<alpha> s))", "apply (unfold avg_aux_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. my_invar s \\<Longrightarrow>\n    hs.iterate s (\\<lambda>x (c, s). (c + 1, s + x)) (0, 0) =\n    (card (my_\\<alpha> s), \\<Sum> (my_\\<alpha> s))", "apply (rule_tac \n      I=\"\\<lambda>it (c,sum). c=card (my_\\<alpha> s - it) \\<and> sum=\\<Sum>(my_\\<alpha> s - it)\" \n      in my_iterate_rule_P)"], ["proof (prove)\ngoal (4 subgoals):\n 1. my_invar s \\<Longrightarrow> my_invar s\n 2. my_invar s \\<Longrightarrow>\n    case (0, 0) of\n    (c, sum) \\<Rightarrow>\n      c = card (my_\\<alpha> s - my_\\<alpha> s) \\<and>\n      sum = \\<Sum> (my_\\<alpha> s - my_\\<alpha> s)\n 3. \\<And>x it \\<sigma>.\n       \\<lbrakk>my_invar s; x \\<in> it; it \\<subseteq> my_\\<alpha> s;\n        case \\<sigma> of\n        (c, sum) \\<Rightarrow>\n          c = card (my_\\<alpha> s - it) \\<and>\n          sum = \\<Sum> (my_\\<alpha> s - it)\\<rbrakk>\n       \\<Longrightarrow> case case \\<sigma> of\n                              (c, s) \\<Rightarrow> (c + 1, s + x) of\n                         (c, sum) \\<Rightarrow>\n                           c = card (my_\\<alpha> s - (it - {x})) \\<and>\n                           sum = \\<Sum> (my_\\<alpha> s - (it - {x}))\n 4. \\<And>\\<sigma>.\n       \\<lbrakk>my_invar s;\n        case \\<sigma> of\n        (c, sum) \\<Rightarrow>\n          c = card (my_\\<alpha> s - {}) \\<and>\n          sum = \\<Sum> (my_\\<alpha> s - {})\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> =\n                         (card (my_\\<alpha> s), \\<Sum> (my_\\<alpha> s))", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x it.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> my_\\<alpha> s\\<rbrakk>\n       \\<Longrightarrow> Suc (card (my_\\<alpha> s - it)) =\n                         card (my_\\<alpha> s - (it - {x}))\n 2. \\<And>x it.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> my_\\<alpha> s\\<rbrakk>\n       \\<Longrightarrow> \\<Sum> (my_\\<alpha> s - it) + x =\n                         \\<Sum> (my_\\<alpha> s - (it - {x}))", "apply (subgoal_tac \"my_\\<alpha> s - (it - {x}) = insert x (my_\\<alpha> s - it)\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x it.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> my_\\<alpha> s;\n        my_\\<alpha> s - (it - {x}) = insert x (my_\\<alpha> s - it)\\<rbrakk>\n       \\<Longrightarrow> Suc (card (my_\\<alpha> s - it)) =\n                         card (my_\\<alpha> s - (it - {x}))\n 2. \\<And>x it.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> my_\\<alpha> s\\<rbrakk>\n       \\<Longrightarrow> my_\\<alpha> s - (it - {x}) =\n                         insert x (my_\\<alpha> s - it)\n 3. \\<And>x it.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> my_\\<alpha> s\\<rbrakk>\n       \\<Longrightarrow> \\<Sum> (my_\\<alpha> s - it) + x =\n                         \\<Sum> (my_\\<alpha> s - (it - {x}))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x it.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> my_\\<alpha> s\\<rbrakk>\n       \\<Longrightarrow> \\<Sum> (my_\\<alpha> s - it) + x =\n                         \\<Sum> (my_\\<alpha> s - (it - {x}))", "apply (subgoal_tac \"my_\\<alpha> s - (it - {x}) = insert x (my_\\<alpha> s - it)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x it.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> my_\\<alpha> s;\n        my_\\<alpha> s - (it - {x}) = insert x (my_\\<alpha> s - it)\\<rbrakk>\n       \\<Longrightarrow> \\<Sum> (my_\\<alpha> s - it) + x =\n                         \\<Sum> (my_\\<alpha> s - (it - {x}))\n 2. \\<And>x it.\n       \\<lbrakk>x \\<in> it; it \\<subseteq> my_\\<alpha> s\\<rbrakk>\n       \\<Longrightarrow> my_\\<alpha> s - (it - {x}) =\n                         insert x (my_\\<alpha> s - it)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma avg_correct: \"my_invar s \\<Longrightarrow> avg s = average (my_\\<alpha> s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. my_invar s \\<Longrightarrow> avg s = average (my_\\<alpha> s)", "unfolding avg_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. my_invar s \\<Longrightarrow>\n    (case avg_aux s of (c, s) \\<Rightarrow> s div c) =\n    average (my_\\<alpha> s)", "using avg_aux_correct"], ["proof (prove)\nusing this:\n  my_invar ?s \\<Longrightarrow>\n  avg_aux ?s = (card (my_\\<alpha> ?s), \\<Sum> (my_\\<alpha> ?s))\n\ngoal (1 subgoal):\n 1. my_invar s \\<Longrightarrow>\n    (case avg_aux s of (c, s) \\<Rightarrow> s div c) =\n    average (my_\\<alpha> s)", "by auto"], ["", "lemma filter_le_avg_correct: \n    \"my_invar s \\<Longrightarrow> \n    my_invar (filter_le_avg s) \\<and> \n    my_\\<alpha> (filter_le_avg s) = {x\\<in>my_\\<alpha> s. x\\<le>average (my_\\<alpha> s)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. my_invar s \\<Longrightarrow>\n    my_invar (filter_le_avg s) \\<and>\n    my_\\<alpha> (filter_le_avg s) =\n    {x \\<in> my_\\<alpha> s. x \\<le> average (my_\\<alpha> s)}", "unfolding filter_le_avg_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. my_invar s \\<Longrightarrow>\n    my_invar\n     (hs.iterate s\n       (\\<lambda>x sa. if x \\<le> avg s then my_ins x sa else sa)\n       (my_empty ())) \\<and>\n    my_\\<alpha>\n     (hs.iterate s\n       (\\<lambda>x sa. if x \\<le> avg s then my_ins x sa else sa)\n       (my_empty ())) =\n    {x \\<in> my_\\<alpha> s. x \\<le> average (my_\\<alpha> s)}", "apply (rule_tac\n      I=\"\\<lambda>it r. my_invar r \\<and> my_\\<alpha> r = {x\\<in>my_\\<alpha> s - it. x\\<le>average (my_\\<alpha> s)}\"\n      in my_iterate_rule_P)"], ["proof (prove)\ngoal (4 subgoals):\n 1. my_invar s \\<Longrightarrow> my_invar s\n 2. my_invar s \\<Longrightarrow>\n    my_invar (my_empty ()) \\<and>\n    my_\\<alpha> (my_empty ()) =\n    {x \\<in> my_\\<alpha> s - my_\\<alpha> s. x \\<le> average (my_\\<alpha> s)}\n 3. \\<And>x it \\<sigma>.\n       \\<lbrakk>my_invar s; x \\<in> it; it \\<subseteq> my_\\<alpha> s;\n        my_invar \\<sigma> \\<and>\n        my_\\<alpha> \\<sigma> =\n        {x \\<in> my_\\<alpha> s - it.\n         x \\<le> average (my_\\<alpha> s)}\\<rbrakk>\n       \\<Longrightarrow> my_invar\n                          (if x \\<le> avg s then my_ins x \\<sigma>\n                           else \\<sigma>) \\<and>\n                         my_\\<alpha>\n                          (if x \\<le> avg s then my_ins x \\<sigma>\n                           else \\<sigma>) =\n                         {xa \\<in> my_\\<alpha> s - (it - {x}).\n                          xa \\<le> average (my_\\<alpha> s)}\n 4. \\<And>\\<sigma>.\n       \\<lbrakk>my_invar s;\n        my_invar \\<sigma> \\<and>\n        my_\\<alpha> \\<sigma> =\n        {x \\<in> my_\\<alpha> s - {}.\n         x \\<le> average (my_\\<alpha> s)}\\<rbrakk>\n       \\<Longrightarrow> my_invar \\<sigma> \\<and>\n                         my_\\<alpha> \\<sigma> =\n                         {x \\<in> my_\\<alpha> s.\n                          x \\<le> average (my_\\<alpha> s)}", "apply (auto simp add: my_correct avg_correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition \"test_set == my_ins (1::nat) (my_ins 2 (my_ins 3 (my_empty ())))\""], ["", "export_code avg_aux avg filter_le_avg test_set in SML module_name Test"], ["", "end"]]}