{"file_name": "/home/qj213/afp-2021-10-22/thys/Collections/ICF/gen_algo/MapGA.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Collections", "problem_names": ["lemmas correct[simp] = empty_correct lookup_correct update_correct \n    update_dj_correct delete_correct", "lemma update_dj_by_update: \n  assumes \"map_update \\<alpha> invar update\"\n  shows \"map_update_dj \\<alpha> invar update\"", "lemma map_iterator_linord_is_it: \n  \"map_iterator_linord m it \\<Longrightarrow> map_iterator m it\"", "lemma map_rev_iterator_linord_is_it: \n  \"map_iterator_rev_linord m it \\<Longrightarrow> map_iterator m it\"", "lemma g_sng_impl: \"map_sng \\<alpha> invar g_sng\"", "lemma g_add_impl: \"map_add \\<alpha> invar g_add\"", "lemma g_sel_impl: \"map_sel' \\<alpha> invar g_sel\"", "lemma g_bex_impl: \"map_bex \\<alpha> invar g_bex\"", "lemma g_ball_impl: \"map_ball \\<alpha> invar g_ball\"", "lemma g_size_impl: \"map_size \\<alpha> invar g_size\"", "lemma g_size_abort_impl: \"map_size_abort \\<alpha> invar g_size_abort\"", "lemma g_isEmpty_impl: \"map_isEmpty \\<alpha> invar g_isEmpty\"", "lemma g_isSng_impl: \"map_isSng \\<alpha> invar g_isSng\"", "lemma g_to_list_impl: \"map_to_list \\<alpha> invar g_to_list\"", "lemma g_list_to_map_impl: \"list_to_map \\<alpha> invar g_list_to_map\"", "lemma g_add_dj_impl: \"map_add_dj \\<alpha> invar g_add_dj\"", "lemma g_restrict_impl: \"map_restrict \\<alpha> invar \\<alpha> invar g_restrict\"", "lemma dflt_ops_impl: \"StdMap dflt_ops\"", "lemma g_min_impl: \"map_min \\<alpha> invar g_min\"", "lemma g_max_impl: \"map_max \\<alpha> invar g_max\"", "lemma g_to_sorted_list_impl: \"map_to_sorted_list \\<alpha> invar g_to_sorted_list\"", "lemma g_to_rev_list_impl: \"map_to_rev_list \\<alpha> invar g_to_rev_list\"", "lemma dflt_oops_impl: \"StdOMap dflt_oops\"", "lemma g_image_filter_impl: \n    \"map_image_filter m1.\\<alpha> m1.invar m2.\\<alpha> m2.invar g_image_filter\"", "lemma restrict_map_dom_subset: \"\\<lbrakk> dom m \\<subseteq> R\\<rbrakk> \\<Longrightarrow> m|`R = m\"", "lemma g_value_image_filter_impl: \n    \"map_value_image_filter m1.\\<alpha> m1.invar m2.\\<alpha> m2.invar g_value_image_filter\""], "translations": [["", "lemmas correct[simp] = empty_correct lookup_correct update_correct \n    update_dj_correct delete_correct"], ["", "end"], ["", "locale StdBasicOMap = \n  StdBasicOMapDefs ops +\n  StdBasicMap ops +\n  poly_map_iterateoi \\<alpha> invar ordered_list_it +\n  poly_map_rev_iterateoi \\<alpha> invar rev_list_it\n  for ops :: \"('k::linorder,'v,'s,'more) omap_basic_ops_scheme\"\nbegin"], ["", "end"], ["", "context StdBasicMapDefs begin"], ["", "definition \"g_sng k v \\<equiv> update k v (empty ())\""], ["", "definition \"g_add m1 m2 \\<equiv> iterate m2 (\\<lambda>(k,v) \\<sigma>. update k v \\<sigma>) m1\""], ["", "definition \n    \"g_sel m P \\<equiv> \n      iteratei m (\\<lambda>\\<sigma>. \\<sigma> = None) (\\<lambda>x \\<sigma>. if P x then Some x else None) None\""], ["", "definition \"g_bex m P \\<equiv> iteratei m (\\<lambda>x. \\<not>x) (\\<lambda>kv \\<sigma>. P kv) False\""], ["", "definition \"g_ball m P \\<equiv> iteratei m id (\\<lambda>kv \\<sigma>. P kv) True\""], ["", "definition \"g_size m \\<equiv> iterate m (\\<lambda>_. Suc) (0::nat)\""], ["", "definition \"g_size_abort b m \\<equiv> iteratei m (\\<lambda>s. s<b) (\\<lambda>_. Suc) (0::nat)\""], ["", "definition \"g_isEmpty m \\<equiv> g_size_abort 1 m = 0\""], ["", "definition \"g_isSng m \\<equiv> g_size_abort 2 m = 1\""], ["", "definition \"g_to_list m \\<equiv> iterate m (#) []\""], ["", "definition \"g_list_to_map l \\<equiv> foldl (\\<lambda>m (k,v). update k v m) (empty ()) \n    (rev l)\""], ["", "definition \"g_add_dj m1 m2 \\<equiv> iterate m2 (\\<lambda>(k,v) \\<sigma>. update_dj k v \\<sigma>) m1\""], ["", "definition \"g_restrict P m \\<equiv> iterate m \n    (\\<lambda>(k,v) \\<sigma>. if P (k,v) then update_dj k v \\<sigma> else \\<sigma>) (empty ())\""], ["", "definition dflt_ops :: \"('k,'v,'s) map_ops\" \n    where [icf_rec_def]:\n    \"dflt_ops \\<equiv> \n      \\<lparr> \n        map_op_\\<alpha> = \\<alpha>,\n        map_op_invar = invar,\n        map_op_empty = empty,\n        map_op_lookup = lookup,\n        map_op_update = update,\n        map_op_update_dj = update_dj,\n        map_op_delete = delete,\n        map_op_list_it = list_it,\n        map_op_sng = g_sng,\n        map_op_restrict = g_restrict, \n        map_op_add = g_add, \n        map_op_add_dj = g_add_dj, \n        map_op_isEmpty = g_isEmpty, \n        map_op_isSng = g_isSng, \n        map_op_ball = g_ball, \n        map_op_bex = g_bex, \n        map_op_size = g_size, \n        map_op_size_abort = g_size_abort, \n        map_op_sel = g_sel, \n        map_op_to_list = g_to_list, \n        map_op_to_map = g_list_to_map\n      \\<rparr>\""], ["", "local_setup \\<open>Locale_Code.lc_decl_del @{term dflt_ops}\\<close>"], ["", "end"], ["", "lemma update_dj_by_update: \n  assumes \"map_update \\<alpha> invar update\"\n  shows \"map_update_dj \\<alpha> invar update\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_update_dj \\<alpha> invar update", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map_update_dj \\<alpha> invar update", "interpret map_update \\<alpha> invar update"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_update \\<alpha> invar update", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. map_update_dj \\<alpha> invar update", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_update_dj \\<alpha> invar update", "apply (unfold_locales)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m k v.\n       \\<lbrakk>invar m; k \\<notin> dom (\\<alpha> m)\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> (update k v m) = \\<alpha> m(k \\<mapsto> v)\n 2. \\<And>m k v.\n       \\<lbrakk>invar m; k \\<notin> dom (\\<alpha> m)\\<rbrakk>\n       \\<Longrightarrow> invar (update k v m)", "apply (auto simp add: update_correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  map_update_dj \\<alpha> invar update\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_iterator_linord_is_it: \n  \"map_iterator_linord m it \\<Longrightarrow> map_iterator m it\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_iterator_linord m it \\<Longrightarrow> map_iterator m it", "unfolding set_iterator_def set_iterator_map_linord_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_iterator_genord m it\n     (\\<lambda>(k, uu_) (k', uu_). k \\<le> k') \\<Longrightarrow>\n    map_iterator_genord m it (\\<lambda>_ _. True)", "apply (erule set_iterator_genord.set_iterator_weaken_R)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> map_to_set it; y \\<in> map_to_set it;\n        (case x of (k, uu_) \\<Rightarrow> \\<lambda>(k', uu_). k \\<le> k')\n         y\\<rbrakk>\n       \\<Longrightarrow> True", ".."], ["", "lemma map_rev_iterator_linord_is_it: \n  \"map_iterator_rev_linord m it \\<Longrightarrow> map_iterator m it\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_iterator_rev_linord m it \\<Longrightarrow> map_iterator m it", "unfolding set_iterator_def set_iterator_map_rev_linord_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_iterator_genord m it\n     (\\<lambda>(k, uu_) (k', uu_). k' \\<le> k) \\<Longrightarrow>\n    map_iterator_genord m it (\\<lambda>_ _. True)", "apply (erule set_iterator_genord.set_iterator_weaken_R)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> map_to_set it; y \\<in> map_to_set it;\n        (case x of (k, uu_) \\<Rightarrow> \\<lambda>(k', uu_). k' \\<le> k)\n         y\\<rbrakk>\n       \\<Longrightarrow> True", ".."], ["", "context StdBasicMap \nbegin"], ["", "lemma g_sng_impl: \"map_sng \\<alpha> invar g_sng\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_sng \\<alpha> invar g_sng", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>k v. \\<alpha> (g_sng k v) = [k \\<mapsto> v]\n 2. \\<And>k v. invar (g_sng k v)", "apply (simp_all add: update_correct empty_correct g_sng_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma g_add_impl: \"map_add \\<alpha> invar g_add\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MapSpec.map_add \\<alpha> invar g_add", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m1 m2.\n       \\<lbrakk>invar m1; invar m2\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> (g_add m1 m2) = \\<alpha> m1 ++ \\<alpha> m2\n 2. \\<And>m1 m2.\n       \\<lbrakk>invar m1; invar m2\\<rbrakk>\n       \\<Longrightarrow> invar (g_add m1 m2)", "fix m1 m2"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m1 m2.\n       \\<lbrakk>invar m1; invar m2\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> (g_add m1 m2) = \\<alpha> m1 ++ \\<alpha> m2\n 2. \\<And>m1 m2.\n       \\<lbrakk>invar m1; invar m2\\<rbrakk>\n       \\<Longrightarrow> invar (g_add m1 m2)", "assume \"invar m1\" \"invar m2\""], ["proof (state)\nthis:\n  invar m1\n  invar m2\n\ngoal (2 subgoals):\n 1. \\<And>m1 m2.\n       \\<lbrakk>invar m1; invar m2\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> (g_add m1 m2) = \\<alpha> m1 ++ \\<alpha> m2\n 2. \\<And>m1 m2.\n       \\<lbrakk>invar m1; invar m2\\<rbrakk>\n       \\<Longrightarrow> invar (g_add m1 m2)", "have A: \"g_add m1 m2 = iterate_add_to_map m1 update (iteratei m2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g_add m1 m2 = iterate_add_to_map m1 update (iteratei m2)", "unfolding g_add_def iterate_add_to_map_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. iterate m2 (\\<lambda>(x, y). update x y) m1 =\n    iterate m2 (\\<lambda>(x, y). update x y) m1", "by simp"], ["proof (state)\nthis:\n  g_add m1 m2 = iterate_add_to_map m1 update (iteratei m2)\n\ngoal (2 subgoals):\n 1. \\<And>m1 m2.\n       \\<lbrakk>invar m1; invar m2\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> (g_add m1 m2) = \\<alpha> m1 ++ \\<alpha> m2\n 2. \\<And>m1 m2.\n       \\<lbrakk>invar m1; invar m2\\<rbrakk>\n       \\<Longrightarrow> invar (g_add m1 m2)", "have \"\\<alpha> (g_add m1 m2) = \\<alpha> m1 ++ \\<alpha> m2 \\<and> invar (g_add m1 m2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (g_add m1 m2) = \\<alpha> m1 ++ \\<alpha> m2 \\<and>\n    invar (g_add m1 m2)", "unfolding A"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (iterate_add_to_map m1 update (iteratei m2)) =\n    \\<alpha> m1 ++ \\<alpha> m2 \\<and>\n    invar (iterate_add_to_map m1 update (iteratei m2))", "apply (rule \n        iterate_add_to_map_correct[of \\<alpha> invar update m1 \"iteratei m2\" \"\\<alpha> m2\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. map_update \\<alpha> invar update\n 2. invar m1\n 3. map_iterator (iteratei m2) (\\<alpha> m2)", "apply unfold_locales []"], ["proof (prove)\ngoal (2 subgoals):\n 1. invar m1\n 2. map_iterator (iteratei m2) (\\<alpha> m2)", "apply fact"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_iterator (iteratei m2) (\\<alpha> m2)", "apply (rule iteratei_correct, fact)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<alpha> (g_add m1 m2) = \\<alpha> m1 ++ \\<alpha> m2 \\<and>\n  invar (g_add m1 m2)\n\ngoal (2 subgoals):\n 1. \\<And>m1 m2.\n       \\<lbrakk>invar m1; invar m2\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> (g_add m1 m2) = \\<alpha> m1 ++ \\<alpha> m2\n 2. \\<And>m1 m2.\n       \\<lbrakk>invar m1; invar m2\\<rbrakk>\n       \\<Longrightarrow> invar (g_add m1 m2)", "thus \"\\<alpha> (g_add m1 m2) = \\<alpha> m1 ++ \\<alpha> m2\" \"invar (g_add m1 m2)\""], ["proof (prove)\nusing this:\n  \\<alpha> (g_add m1 m2) = \\<alpha> m1 ++ \\<alpha> m2 \\<and>\n  invar (g_add m1 m2)\n\ngoal (1 subgoal):\n 1. \\<alpha> (g_add m1 m2) = \\<alpha> m1 ++ \\<alpha> m2 &&&\n    invar (g_add m1 m2)", "by auto"], ["proof (state)\nthis:\n  \\<alpha> (g_add m1 m2) = \\<alpha> m1 ++ \\<alpha> m2\n  invar (g_add m1 m2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma g_sel_impl: \"map_sel' \\<alpha> invar g_sel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_sel' \\<alpha> invar g_sel", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map_sel' \\<alpha> invar g_sel", "have A: \"\\<And>m P. g_sel m P = iterate_sel_no_map (iteratei m) P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m P. g_sel m P = iterate_sel_no_map (iteratei m) P", "unfolding g_sel_def iterate_sel_no_map_def iterate_sel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m P.\n       iteratei m (\\<lambda>\\<sigma>. \\<sigma> = None)\n        (\\<lambda>x \\<sigma>. if P x then Some x else None) None =\n       iteratei m (\\<lambda>\\<sigma>. \\<sigma> = None)\n        (\\<lambda>x \\<sigma>. if P x then Some x else None) None", "by simp"], ["proof (state)\nthis:\n  g_sel ?m2 ?P2 = iterate_sel_no_map (iteratei ?m2) ?P2\n\ngoal (1 subgoal):\n 1. map_sel' \\<alpha> invar g_sel", "{"], ["proof (state)\nthis:\n  g_sel ?m2 ?P2 = iterate_sel_no_map (iteratei ?m2) ?P2\n\ngoal (1 subgoal):\n 1. map_sel' \\<alpha> invar g_sel", "fix m P"], ["proof (state)\ngoal (1 subgoal):\n 1. map_sel' \\<alpha> invar g_sel", "assume I: \"invar m\""], ["proof (state)\nthis:\n  invar m\n\ngoal (1 subgoal):\n 1. map_sel' \\<alpha> invar g_sel", "note iterate_sel_no_map_correct[OF iteratei_correct[OF I], of P]"], ["proof (state)\nthis:\n  (iterate_sel_no_map (iteratei m) P = None) =\n  (\\<forall>x\\<in>map_to_set (\\<alpha> m). \\<not> P x)\n  iterate_sel_no_map (iteratei m) P = Some ?x \\<Longrightarrow>\n  ?x \\<in> map_to_set (\\<alpha> m) \\<and> P ?x\n\ngoal (1 subgoal):\n 1. map_sel' \\<alpha> invar g_sel", "}"], ["proof (state)\nthis:\n  invar ?m4 \\<Longrightarrow>\n  (iterate_sel_no_map (iteratei ?m4) ?P4 = None) =\n  (\\<forall>x\\<in>map_to_set (\\<alpha> ?m4). \\<not> ?P4 x)\n  \\<lbrakk>invar ?m4;\n   iterate_sel_no_map (iteratei ?m4) ?P4 = Some ?x\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> map_to_set (\\<alpha> ?m4) \\<and> ?P4 ?x\n\ngoal (1 subgoal):\n 1. map_sel' \\<alpha> invar g_sel", "thus ?thesis"], ["proof (prove)\nusing this:\n  invar ?m4 \\<Longrightarrow>\n  (iterate_sel_no_map (iteratei ?m4) ?P4 = None) =\n  (\\<forall>x\\<in>map_to_set (\\<alpha> ?m4). \\<not> ?P4 x)\n  \\<lbrakk>invar ?m4;\n   iterate_sel_no_map (iteratei ?m4) ?P4 = Some ?x\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> map_to_set (\\<alpha> ?m4) \\<and> ?P4 ?x\n\ngoal (1 subgoal):\n 1. map_sel' \\<alpha> invar g_sel", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m u v P Q.\n       \\<lbrakk>\\<And>m P.\n                   invar m \\<Longrightarrow>\n                   (iterate_sel_no_map (iteratei m) P = None) =\n                   (\\<forall>x\\<in>map_to_set (\\<alpha> m). \\<not> P x);\n        \\<And>m P x.\n           \\<lbrakk>invar m;\n            iterate_sel_no_map (iteratei m) P = Some x\\<rbrakk>\n           \\<Longrightarrow> x \\<in> map_to_set (\\<alpha> m) \\<and> P x;\n        invar m; \\<alpha> m u = Some v; P (u, v);\n        \\<And>u v.\n           \\<lbrakk>g_sel m P = Some (u, v); \\<alpha> m u = Some v;\n            P (u, v)\\<rbrakk>\n           \\<Longrightarrow> Q\\<rbrakk>\n       \\<Longrightarrow> Q\n 2. \\<And>m P.\n       \\<lbrakk>\\<And>m P.\n                   invar m \\<Longrightarrow>\n                   (iterate_sel_no_map (iteratei m) P = None) =\n                   (\\<forall>x\\<in>map_to_set (\\<alpha> m). \\<not> P x);\n        \\<And>m P x.\n           \\<lbrakk>invar m;\n            iterate_sel_no_map (iteratei m) P = Some x\\<rbrakk>\n           \\<Longrightarrow> x \\<in> map_to_set (\\<alpha> m) \\<and> P x;\n        invar m;\n        \\<forall>u v.\n           \\<alpha> m u = Some v \\<longrightarrow> \\<not> P (u, v)\\<rbrakk>\n       \\<Longrightarrow> g_sel m P = None", "unfolding A"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m u v P Q.\n       \\<lbrakk>\\<And>m P.\n                   invar m \\<Longrightarrow>\n                   (iterate_sel_no_map (iteratei m) P = None) =\n                   (\\<forall>x\\<in>map_to_set (\\<alpha> m). \\<not> P x);\n        \\<And>m P x.\n           \\<lbrakk>invar m;\n            iterate_sel_no_map (iteratei m) P = Some x\\<rbrakk>\n           \\<Longrightarrow> x \\<in> map_to_set (\\<alpha> m) \\<and> P x;\n        invar m; \\<alpha> m u = Some v; P (u, v);\n        \\<And>u v.\n           \\<lbrakk>iterate_sel_no_map (iteratei m) P = Some (u, v);\n            \\<alpha> m u = Some v; P (u, v)\\<rbrakk>\n           \\<Longrightarrow> Q\\<rbrakk>\n       \\<Longrightarrow> Q\n 2. \\<And>m P.\n       \\<lbrakk>\\<And>m P.\n                   invar m \\<Longrightarrow>\n                   (iterate_sel_no_map (iteratei m) P = None) =\n                   (\\<forall>x\\<in>map_to_set (\\<alpha> m). \\<not> P x);\n        \\<And>m P x.\n           \\<lbrakk>invar m;\n            iterate_sel_no_map (iteratei m) P = Some x\\<rbrakk>\n           \\<Longrightarrow> x \\<in> map_to_set (\\<alpha> m) \\<and> P x;\n        invar m;\n        \\<forall>u v.\n           \\<alpha> m u = Some v \\<longrightarrow> \\<not> P (u, v)\\<rbrakk>\n       \\<Longrightarrow> iterate_sel_no_map (iteratei m) P = None", "apply (simp add: Bex_def Ball_def image_iff map_to_set_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m u v P Q.\n       \\<lbrakk>\\<And>m P.\n                   invar m \\<Longrightarrow>\n                   (iterate_sel_no_map (iteratei m) P = None) =\n                   (\\<forall>a b.\n                       \\<alpha> m a = Some b \\<longrightarrow>\n                       \\<not> P (a, b));\n        \\<And>m P x.\n           \\<lbrakk>invar m;\n            iterate_sel_no_map (iteratei m) P = Some x\\<rbrakk>\n           \\<Longrightarrow> (case x of\n                              (k, v) \\<Rightarrow>\n                                \\<alpha> m k = Some v) \\<and>\n                             P x;\n        invar m; \\<alpha> m u = Some v; P (u, v);\n        \\<And>u v.\n           \\<lbrakk>iterate_sel_no_map (iteratei m) P = Some (u, v);\n            \\<alpha> m u = Some v; P (u, v)\\<rbrakk>\n           \\<Longrightarrow> Q\\<rbrakk>\n       \\<Longrightarrow> Q\n 2. \\<And>m P.\n       \\<lbrakk>\\<And>m P.\n                   invar m \\<Longrightarrow>\n                   (iterate_sel_no_map (iteratei m) P = None) =\n                   (\\<forall>x\\<in>map_to_set (\\<alpha> m). \\<not> P x);\n        \\<And>m P x.\n           \\<lbrakk>invar m;\n            iterate_sel_no_map (iteratei m) P = Some x\\<rbrakk>\n           \\<Longrightarrow> x \\<in> map_to_set (\\<alpha> m) \\<and> P x;\n        invar m;\n        \\<forall>u v.\n           \\<alpha> m u = Some v \\<longrightarrow> \\<not> P (u, v)\\<rbrakk>\n       \\<Longrightarrow> iterate_sel_no_map (iteratei m) P = None", "apply clarify"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m u v P Q.\n       \\<lbrakk>\\<And>m P.\n                   invar m \\<Longrightarrow>\n                   (iterate_sel_no_map (iteratei m) P = None) =\n                   (\\<forall>a b.\n                       \\<alpha> m a = Some b \\<longrightarrow>\n                       \\<not> P (a, b));\n        \\<And>m P a b.\n           \\<lbrakk>invar m;\n            iterate_sel_no_map (iteratei m) P = Some (a, b)\\<rbrakk>\n           \\<Longrightarrow> \\<alpha> m a = Some b \\<and> P (a, b);\n        invar m; \\<alpha> m u = Some v; P (u, v);\n        \\<And>u v.\n           \\<lbrakk>iterate_sel_no_map (iteratei m) P = Some (u, v);\n            \\<alpha> m u = Some v; P (u, v)\\<rbrakk>\n           \\<Longrightarrow> Q\\<rbrakk>\n       \\<Longrightarrow> Q\n 2. \\<And>m P.\n       \\<lbrakk>\\<And>m P.\n                   invar m \\<Longrightarrow>\n                   (iterate_sel_no_map (iteratei m) P = None) =\n                   (\\<forall>x\\<in>map_to_set (\\<alpha> m). \\<not> P x);\n        \\<And>m P x.\n           \\<lbrakk>invar m;\n            iterate_sel_no_map (iteratei m) P = Some x\\<rbrakk>\n           \\<Longrightarrow> x \\<in> map_to_set (\\<alpha> m) \\<and> P x;\n        invar m;\n        \\<forall>u v.\n           \\<alpha> m u = Some v \\<longrightarrow> \\<not> P (u, v)\\<rbrakk>\n       \\<Longrightarrow> iterate_sel_no_map (iteratei m) P = None", "apply (metis option.exhaust prod.exhaust)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m P.\n       \\<lbrakk>\\<And>m P.\n                   invar m \\<Longrightarrow>\n                   (iterate_sel_no_map (iteratei m) P = None) =\n                   (\\<forall>x\\<in>map_to_set (\\<alpha> m). \\<not> P x);\n        \\<And>m P x.\n           \\<lbrakk>invar m;\n            iterate_sel_no_map (iteratei m) P = Some x\\<rbrakk>\n           \\<Longrightarrow> x \\<in> map_to_set (\\<alpha> m) \\<and> P x;\n        invar m;\n        \\<forall>u v.\n           \\<alpha> m u = Some v \\<longrightarrow> \\<not> P (u, v)\\<rbrakk>\n       \\<Longrightarrow> iterate_sel_no_map (iteratei m) P = None", "apply (simp add: Bex_def Ball_def image_iff map_to_set_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  map_sel' \\<alpha> invar g_sel\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma g_bex_impl: \"map_bex \\<alpha> invar g_bex\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_bex \\<alpha> invar g_bex", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m P.\n       invar m \\<Longrightarrow>\n       g_bex m P = (\\<exists>u v. \\<alpha> m u = Some v \\<and> P (u, v))", "unfolding g_bex_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m P.\n       invar m \\<Longrightarrow>\n       iteratei m Not (\\<lambda>kv \\<sigma>. P kv) False =\n       (\\<exists>u v. \\<alpha> m u = Some v \\<and> P (u, v))", "apply (rule_tac I=\"\\<lambda>it \\<sigma>. \\<sigma> \\<longleftrightarrow> (\\<exists>kv\\<in>it. P kv)\" \n      in iteratei_rule_insert_P)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>m P. invar m \\<Longrightarrow> invar m\n 2. \\<And>m P. invar m \\<Longrightarrow> False = (\\<exists>kv\\<in>{}. P kv)\n 3. \\<And>m P k v it \\<sigma>.\n       \\<lbrakk>invar m; \\<not> \\<sigma>;\n        (k, v) \\<in> map_to_set (\\<alpha> m) - it;\n        it \\<subseteq> map_to_set (\\<alpha> m);\n        \\<sigma> = (\\<exists>kv\\<in>it. P kv)\\<rbrakk>\n       \\<Longrightarrow> P (k, v) = (\\<exists>kv\\<in>insert (k, v) it. P kv)\n 4. \\<And>m P \\<sigma>.\n       \\<lbrakk>invar m;\n        \\<sigma> = (\\<exists>kv\\<in>map_to_set (\\<alpha> m). P kv)\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> =\n                         (\\<exists>u v.\n                             \\<alpha> m u = Some v \\<and> P (u, v))\n 5. \\<And>m P \\<sigma> it.\n       \\<lbrakk>invar m; it \\<subseteq> map_to_set (\\<alpha> m);\n        it \\<noteq> map_to_set (\\<alpha> m); \\<not> \\<not> \\<sigma>;\n        \\<sigma> = (\\<exists>kv\\<in>it. P kv)\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> =\n                         (\\<exists>u v.\n                             \\<alpha> m u = Some v \\<and> P (u, v))", "by (auto simp: map_to_set_def)"], ["", "lemma g_ball_impl: \"map_ball \\<alpha> invar g_ball\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_ball \\<alpha> invar g_ball", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m P.\n       invar m \\<Longrightarrow>\n       g_ball m P =\n       (\\<forall>u v. \\<alpha> m u = Some v \\<longrightarrow> P (u, v))", "unfolding g_ball_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m P.\n       invar m \\<Longrightarrow>\n       iteratei m id (\\<lambda>kv \\<sigma>. P kv) True =\n       (\\<forall>u v. \\<alpha> m u = Some v \\<longrightarrow> P (u, v))", "apply (rule_tac I=\"\\<lambda>it \\<sigma>. \\<sigma> \\<longleftrightarrow> (\\<forall>kv\\<in>it. P kv)\" \n      in iteratei_rule_insert_P)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>m P. invar m \\<Longrightarrow> invar m\n 2. \\<And>m P. invar m \\<Longrightarrow> True = (\\<forall>kv\\<in>{}. P kv)\n 3. \\<And>m P k v it \\<sigma>.\n       \\<lbrakk>invar m; id \\<sigma>;\n        (k, v) \\<in> map_to_set (\\<alpha> m) - it;\n        it \\<subseteq> map_to_set (\\<alpha> m);\n        \\<sigma> = (\\<forall>kv\\<in>it. P kv)\\<rbrakk>\n       \\<Longrightarrow> P (k, v) = (\\<forall>kv\\<in>insert (k, v) it. P kv)\n 4. \\<And>m P \\<sigma>.\n       \\<lbrakk>invar m;\n        \\<sigma> = (\\<forall>kv\\<in>map_to_set (\\<alpha> m). P kv)\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> =\n                         (\\<forall>u v.\n                             \\<alpha> m u = Some v \\<longrightarrow>\n                             P (u, v))\n 5. \\<And>m P \\<sigma> it.\n       \\<lbrakk>invar m; it \\<subseteq> map_to_set (\\<alpha> m);\n        it \\<noteq> map_to_set (\\<alpha> m); \\<not> id \\<sigma>;\n        \\<sigma> = (\\<forall>kv\\<in>it. P kv)\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> =\n                         (\\<forall>u v.\n                             \\<alpha> m u = Some v \\<longrightarrow>\n                             P (u, v))", "apply (auto simp: map_to_set_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma g_size_impl: \"map_size \\<alpha> invar g_size\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_size \\<alpha> invar g_size", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. invar s \\<Longrightarrow> g_size s = card (dom (\\<alpha> s))", "fix m"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. invar s \\<Longrightarrow> g_size s = card (dom (\\<alpha> s))", "assume I: \"invar m\""], ["proof (state)\nthis:\n  invar m\n\ngoal (1 subgoal):\n 1. \\<And>s. invar s \\<Longrightarrow> g_size s = card (dom (\\<alpha> s))", "have A: \"g_size m \\<equiv> iterate_size (iteratei m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g_size m \\<equiv> iterate_size (iteratei m)", "unfolding g_size_def iterate_size_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. iterate m (\\<lambda>_. Suc) 0 \\<equiv> iterate m (\\<lambda>x. Suc) 0", "by simp"], ["proof (state)\nthis:\n  g_size m \\<equiv> iterate_size (iteratei m)\n\ngoal (1 subgoal):\n 1. \\<And>s. invar s \\<Longrightarrow> g_size s = card (dom (\\<alpha> s))", "from iterate_size_correct [OF iteratei_correct[OF I]]"], ["proof (chain)\npicking this:\n  iterate_size (iteratei m) = card (map_to_set (\\<alpha> m)) \\<and>\n  finite (map_to_set (\\<alpha> m))", "show \"g_size m = card (dom (\\<alpha> m))\""], ["proof (prove)\nusing this:\n  iterate_size (iteratei m) = card (map_to_set (\\<alpha> m)) \\<and>\n  finite (map_to_set (\\<alpha> m))\n\ngoal (1 subgoal):\n 1. g_size m = card (dom (\\<alpha> m))", "unfolding A"], ["proof (prove)\nusing this:\n  iterate_size (iteratei m) = card (map_to_set (\\<alpha> m)) \\<and>\n  finite (map_to_set (\\<alpha> m))\n\ngoal (1 subgoal):\n 1. iterate_size (iteratei m) = card (dom (\\<alpha> m))", "by (simp_all add: card_map_to_set)"], ["proof (state)\nthis:\n  g_size m = card (dom (\\<alpha> m))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma g_size_abort_impl: \"map_size_abort \\<alpha> invar g_size_abort\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_size_abort \\<alpha> invar g_size_abort", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s m.\n       invar s \\<Longrightarrow>\n       g_size_abort m s = min m (card (dom (\\<alpha> s)))", "fix s m"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s m.\n       invar s \\<Longrightarrow>\n       g_size_abort m s = min m (card (dom (\\<alpha> s)))", "assume I: \"invar m\""], ["proof (state)\nthis:\n  invar m\n\ngoal (1 subgoal):\n 1. \\<And>s m.\n       invar s \\<Longrightarrow>\n       g_size_abort m s = min m (card (dom (\\<alpha> s)))", "have A: \"g_size_abort s m \\<equiv> iterate_size_abort (iteratei m) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g_size_abort s m \\<equiv> iterate_size_abort (iteratei m) s", "unfolding g_size_abort_def iterate_size_abort_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. iteratei m (\\<lambda>sa. sa < s) (\\<lambda>_. Suc) 0 \\<equiv>\n    iteratei m (\\<lambda>\\<sigma>. \\<sigma> < s) (\\<lambda>x. Suc) 0", "by simp"], ["proof (state)\nthis:\n  g_size_abort s m \\<equiv> iterate_size_abort (iteratei m) s\n\ngoal (1 subgoal):\n 1. \\<And>s m.\n       invar s \\<Longrightarrow>\n       g_size_abort m s = min m (card (dom (\\<alpha> s)))", "from iterate_size_abort_correct [OF iteratei_correct[OF I]]"], ["proof (chain)\npicking this:\n  iterate_size_abort (iteratei m) ?n =\n  min ?n (card (map_to_set (\\<alpha> m))) \\<and>\n  finite (map_to_set (\\<alpha> m))", "show \"g_size_abort s m = min s (card (dom (\\<alpha> m)))\""], ["proof (prove)\nusing this:\n  iterate_size_abort (iteratei m) ?n =\n  min ?n (card (map_to_set (\\<alpha> m))) \\<and>\n  finite (map_to_set (\\<alpha> m))\n\ngoal (1 subgoal):\n 1. g_size_abort s m = min s (card (dom (\\<alpha> m)))", "unfolding A"], ["proof (prove)\nusing this:\n  iterate_size_abort (iteratei m) ?n =\n  min ?n (card (map_to_set (\\<alpha> m))) \\<and>\n  finite (map_to_set (\\<alpha> m))\n\ngoal (1 subgoal):\n 1. iterate_size_abort (iteratei m) s = min s (card (dom (\\<alpha> m)))", "by (simp_all add: card_map_to_set)"], ["proof (state)\nthis:\n  g_size_abort s m = min s (card (dom (\\<alpha> m)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma g_isEmpty_impl: \"map_isEmpty \\<alpha> invar g_isEmpty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_isEmpty \\<alpha> invar g_isEmpty", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m.\n       invar m \\<Longrightarrow> g_isEmpty m = (\\<alpha> m = Map.empty)", "fix m"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m.\n       invar m \\<Longrightarrow> g_isEmpty m = (\\<alpha> m = Map.empty)", "assume I: \"invar m\""], ["proof (state)\nthis:\n  invar m\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       invar m \\<Longrightarrow> g_isEmpty m = (\\<alpha> m = Map.empty)", "interpret map_size_abort \\<alpha> invar g_size_abort"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_size_abort \\<alpha> invar g_size_abort", "by (rule g_size_abort_impl)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m.\n       invar m \\<Longrightarrow> g_isEmpty m = (\\<alpha> m = Map.empty)", "from size_abort_correct[OF I]"], ["proof (chain)\npicking this:\n  g_size_abort ?m m = min ?m (card (dom (\\<alpha> m)))", "have \n      \"g_size_abort 1 m = min 1 (card (dom (\\<alpha> m)))\""], ["proof (prove)\nusing this:\n  g_size_abort ?m m = min ?m (card (dom (\\<alpha> m)))\n\ngoal (1 subgoal):\n 1. g_size_abort 1 m = min 1 (card (dom (\\<alpha> m)))", "."], ["proof (state)\nthis:\n  g_size_abort 1 m = min 1 (card (dom (\\<alpha> m)))\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       invar m \\<Longrightarrow> g_isEmpty m = (\\<alpha> m = Map.empty)", "thus \"g_isEmpty m = (\\<alpha> m = Map.empty)\""], ["proof (prove)\nusing this:\n  g_size_abort 1 m = min 1 (card (dom (\\<alpha> m)))\n\ngoal (1 subgoal):\n 1. g_isEmpty m = (\\<alpha> m = Map.empty)", "unfolding g_isEmpty_def"], ["proof (prove)\nusing this:\n  g_size_abort 1 m = min 1 (card (dom (\\<alpha> m)))\n\ngoal (1 subgoal):\n 1. (g_size_abort 1 m = 0) = (\\<alpha> m = Map.empty)", "by (auto simp: min_def card_0_eq[OF finite] I)"], ["proof (state)\nthis:\n  g_isEmpty m = (\\<alpha> m = Map.empty)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma g_isSng_impl: \"map_isSng \\<alpha> invar g_isSng\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_isSng \\<alpha> invar g_isSng", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       invar s \\<Longrightarrow>\n       g_isSng s = (\\<exists>k v. \\<alpha> s = [k \\<mapsto> v])", "fix m"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       invar s \\<Longrightarrow>\n       g_isSng s = (\\<exists>k v. \\<alpha> s = [k \\<mapsto> v])", "assume I: \"invar m\""], ["proof (state)\nthis:\n  invar m\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       invar s \\<Longrightarrow>\n       g_isSng s = (\\<exists>k v. \\<alpha> s = [k \\<mapsto> v])", "interpret map_size_abort \\<alpha> invar g_size_abort"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_size_abort \\<alpha> invar g_size_abort", "by (rule g_size_abort_impl)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       invar s \\<Longrightarrow>\n       g_isSng s = (\\<exists>k v. \\<alpha> s = [k \\<mapsto> v])", "from size_abort_correct[OF I]"], ["proof (chain)\npicking this:\n  g_size_abort ?m m = min ?m (card (dom (\\<alpha> m)))", "have \n      \"g_size_abort 2 m = min 2 (card (dom (\\<alpha> m)))\""], ["proof (prove)\nusing this:\n  g_size_abort ?m m = min ?m (card (dom (\\<alpha> m)))\n\ngoal (1 subgoal):\n 1. g_size_abort 2 m = min 2 (card (dom (\\<alpha> m)))", "."], ["proof (state)\nthis:\n  g_size_abort 2 m = min 2 (card (dom (\\<alpha> m)))\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       invar s \\<Longrightarrow>\n       g_isSng s = (\\<exists>k v. \\<alpha> s = [k \\<mapsto> v])", "thus \"g_isSng m = (\\<exists>k v. \\<alpha> m = [k \\<mapsto> v])\""], ["proof (prove)\nusing this:\n  g_size_abort 2 m = min 2 (card (dom (\\<alpha> m)))\n\ngoal (1 subgoal):\n 1. g_isSng m = (\\<exists>k v. \\<alpha> m = [k \\<mapsto> v])", "unfolding g_isSng_def"], ["proof (prove)\nusing this:\n  g_size_abort 2 m = min 2 (card (dom (\\<alpha> m)))\n\ngoal (1 subgoal):\n 1. (g_size_abort 2 m = 1) = (\\<exists>k v. \\<alpha> m = [k \\<mapsto> v])", "by (auto simp: min_def I card_Suc_eq dom_eq_singleton_conv)"], ["proof (state)\nthis:\n  g_isSng m = (\\<exists>k v. \\<alpha> m = [k \\<mapsto> v])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma g_to_list_impl: \"map_to_list \\<alpha> invar g_to_list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_to_list \\<alpha> invar g_to_list", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m. invar m \\<Longrightarrow> map_of (g_to_list m) = \\<alpha> m\n 2. \\<And>m. invar m \\<Longrightarrow> distinct (map fst (g_to_list m))", "fix m"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m. invar m \\<Longrightarrow> map_of (g_to_list m) = \\<alpha> m\n 2. \\<And>m. invar m \\<Longrightarrow> distinct (map fst (g_to_list m))", "assume I: \"invar m\""], ["proof (state)\nthis:\n  invar m\n\ngoal (2 subgoals):\n 1. \\<And>m. invar m \\<Longrightarrow> map_of (g_to_list m) = \\<alpha> m\n 2. \\<And>m. invar m \\<Longrightarrow> distinct (map fst (g_to_list m))", "have A: \"g_to_list m = iterate_to_list (iteratei m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g_to_list m = iterate_to_list (iteratei m)", "unfolding g_to_list_def iterate_to_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. iterate m (#) [] = iterate m (#) []", "by simp"], ["proof (state)\nthis:\n  g_to_list m = iterate_to_list (iteratei m)\n\ngoal (2 subgoals):\n 1. \\<And>m. invar m \\<Longrightarrow> map_of (g_to_list m) = \\<alpha> m\n 2. \\<And>m. invar m \\<Longrightarrow> distinct (map fst (g_to_list m))", "from iterate_to_list_correct [OF iteratei_correct[OF I]]"], ["proof (chain)\npicking this:\n  set (iterate_to_list (iteratei m)) = map_to_set (\\<alpha> m) \\<and>\n  distinct (iterate_to_list (iteratei m))", "have set_l_eq: \"set (g_to_list m) = map_to_set (\\<alpha> m)\" and \n      dist_l: \"distinct (g_to_list m)\""], ["proof (prove)\nusing this:\n  set (iterate_to_list (iteratei m)) = map_to_set (\\<alpha> m) \\<and>\n  distinct (iterate_to_list (iteratei m))\n\ngoal (1 subgoal):\n 1. set (g_to_list m) = map_to_set (\\<alpha> m) &&& distinct (g_to_list m)", "unfolding A"], ["proof (prove)\nusing this:\n  set (iterate_to_list (iteratei m)) = map_to_set (\\<alpha> m) \\<and>\n  distinct (iterate_to_list (iteratei m))\n\ngoal (1 subgoal):\n 1. set (iterate_to_list (iteratei m)) = map_to_set (\\<alpha> m) &&&\n    distinct (iterate_to_list (iteratei m))", "by simp_all"], ["proof (state)\nthis:\n  set (g_to_list m) = map_to_set (\\<alpha> m)\n  distinct (g_to_list m)\n\ngoal (2 subgoals):\n 1. \\<And>m. invar m \\<Longrightarrow> map_of (g_to_list m) = \\<alpha> m\n 2. \\<And>m. invar m \\<Longrightarrow> distinct (map fst (g_to_list m))", "from dist_l"], ["proof (chain)\npicking this:\n  distinct (g_to_list m)", "show dist_fst_l: \"distinct (map fst (g_to_list m))\""], ["proof (prove)\nusing this:\n  distinct (g_to_list m)\n\ngoal (1 subgoal):\n 1. distinct (map fst (g_to_list m))", "by (simp add: distinct_map set_l_eq map_to_set_def inj_on_def)"], ["proof (state)\nthis:\n  distinct (map fst (g_to_list m))\n\ngoal (1 subgoal):\n 1. \\<And>m. invar m \\<Longrightarrow> map_of (g_to_list m) = \\<alpha> m", "from map_of_map_to_set[of \"(g_to_list m)\" \"\\<alpha> m\", OF dist_fst_l] set_l_eq"], ["proof (chain)\npicking this:\n  (map_of (g_to_list m) = \\<alpha> m) =\n  (set (g_to_list m) = map_to_set (\\<alpha> m))\n  set (g_to_list m) = map_to_set (\\<alpha> m)", "show \"map_of (g_to_list m) = \\<alpha> m\""], ["proof (prove)\nusing this:\n  (map_of (g_to_list m) = \\<alpha> m) =\n  (set (g_to_list m) = map_to_set (\\<alpha> m))\n  set (g_to_list m) = map_to_set (\\<alpha> m)\n\ngoal (1 subgoal):\n 1. map_of (g_to_list m) = \\<alpha> m", "by simp"], ["proof (state)\nthis:\n  map_of (g_to_list m) = \\<alpha> m\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma g_list_to_map_impl: \"list_to_map \\<alpha> invar g_list_to_map\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_to_map \\<alpha> invar g_list_to_map", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. list_to_map \\<alpha> invar g_list_to_map", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. list_to_map \\<alpha> invar g_list_to_map", "fix m0 l"], ["proof (state)\ngoal (1 subgoal):\n 1. list_to_map \\<alpha> invar g_list_to_map", "assume \"invar m0\""], ["proof (state)\nthis:\n  invar m0\n\ngoal (1 subgoal):\n 1. list_to_map \\<alpha> invar g_list_to_map", "hence \"invar (foldl (\\<lambda>s (k,v). update k v s) m0 l) \\<and> \n        \\<alpha> (foldl (\\<lambda>s (k,v). update k v s) m0 l) = \\<alpha> m0 ++ map_of (rev l)\""], ["proof (prove)\nusing this:\n  invar m0\n\ngoal (1 subgoal):\n 1. invar (foldl (\\<lambda>s (k, v). update k v s) m0 l) \\<and>\n    \\<alpha> (foldl (\\<lambda>s (k, v). update k v s) m0 l) =\n    \\<alpha> m0 ++ map_of (rev l)", "proof (induction l arbitrary: m0)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m0.\n       invar m0 \\<Longrightarrow>\n       invar (foldl (\\<lambda>s (k, v). update k v s) m0 []) \\<and>\n       \\<alpha> (foldl (\\<lambda>s (k, v). update k v s) m0 []) =\n       \\<alpha> m0 ++ map_of (rev [])\n 2. \\<And>a l m0.\n       \\<lbrakk>\\<And>m0.\n                   invar m0 \\<Longrightarrow>\n                   invar\n                    (foldl (\\<lambda>s (k, v). update k v s) m0 l) \\<and>\n                   \\<alpha> (foldl (\\<lambda>s (k, v). update k v s) m0 l) =\n                   \\<alpha> m0 ++ map_of (rev l);\n        invar m0\\<rbrakk>\n       \\<Longrightarrow> invar\n                          (foldl (\\<lambda>s (k, v). update k v s) m0\n                            (a # l)) \\<and>\n                         \\<alpha>\n                          (foldl (\\<lambda>s (k, v). update k v s) m0\n                            (a # l)) =\n                         \\<alpha> m0 ++ map_of (rev (a # l))", "case Nil"], ["proof (state)\nthis:\n  invar m0\n\ngoal (2 subgoals):\n 1. \\<And>m0.\n       invar m0 \\<Longrightarrow>\n       invar (foldl (\\<lambda>s (k, v). update k v s) m0 []) \\<and>\n       \\<alpha> (foldl (\\<lambda>s (k, v). update k v s) m0 []) =\n       \\<alpha> m0 ++ map_of (rev [])\n 2. \\<And>a l m0.\n       \\<lbrakk>\\<And>m0.\n                   invar m0 \\<Longrightarrow>\n                   invar\n                    (foldl (\\<lambda>s (k, v). update k v s) m0 l) \\<and>\n                   \\<alpha> (foldl (\\<lambda>s (k, v). update k v s) m0 l) =\n                   \\<alpha> m0 ++ map_of (rev l);\n        invar m0\\<rbrakk>\n       \\<Longrightarrow> invar\n                          (foldl (\\<lambda>s (k, v). update k v s) m0\n                            (a # l)) \\<and>\n                         \\<alpha>\n                          (foldl (\\<lambda>s (k, v). update k v s) m0\n                            (a # l)) =\n                         \\<alpha> m0 ++ map_of (rev (a # l))", "thus ?case"], ["proof (prove)\nusing this:\n  invar m0\n\ngoal (1 subgoal):\n 1. invar\n     (foldl (\\<lambda>s a. case a of (k, v) \\<Rightarrow> update k v s) m0\n       []) \\<and>\n    \\<alpha>\n     (foldl (\\<lambda>s a. case a of (k, v) \\<Rightarrow> update k v s) m0\n       []) =\n    \\<alpha> m0 ++ map_of (rev [])", "by simp"], ["proof (state)\nthis:\n  invar\n   (foldl (\\<lambda>s a. case a of (k, v) \\<Rightarrow> update k v s) m0\n     []) \\<and>\n  \\<alpha>\n   (foldl (\\<lambda>s a. case a of (k, v) \\<Rightarrow> update k v s) m0\n     []) =\n  \\<alpha> m0 ++ map_of (rev [])\n\ngoal (1 subgoal):\n 1. \\<And>a l m0.\n       \\<lbrakk>\\<And>m0.\n                   invar m0 \\<Longrightarrow>\n                   invar\n                    (foldl (\\<lambda>s (k, v). update k v s) m0 l) \\<and>\n                   \\<alpha> (foldl (\\<lambda>s (k, v). update k v s) m0 l) =\n                   \\<alpha> m0 ++ map_of (rev l);\n        invar m0\\<rbrakk>\n       \\<Longrightarrow> invar\n                          (foldl (\\<lambda>s (k, v). update k v s) m0\n                            (a # l)) \\<and>\n                         \\<alpha>\n                          (foldl (\\<lambda>s (k, v). update k v s) m0\n                            (a # l)) =\n                         \\<alpha> m0 ++ map_of (rev (a # l))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a l m0.\n       \\<lbrakk>\\<And>m0.\n                   invar m0 \\<Longrightarrow>\n                   invar\n                    (foldl (\\<lambda>s (k, v). update k v s) m0 l) \\<and>\n                   \\<alpha> (foldl (\\<lambda>s (k, v). update k v s) m0 l) =\n                   \\<alpha> m0 ++ map_of (rev l);\n        invar m0\\<rbrakk>\n       \\<Longrightarrow> invar\n                          (foldl (\\<lambda>s (k, v). update k v s) m0\n                            (a # l)) \\<and>\n                         \\<alpha>\n                          (foldl (\\<lambda>s (k, v). update k v s) m0\n                            (a # l)) =\n                         \\<alpha> m0 ++ map_of (rev (a # l))", "case (Cons kv l)"], ["proof (state)\nthis:\n  invar ?m0.2 \\<Longrightarrow>\n  invar\n   (foldl (\\<lambda>s a. case a of (k, v) \\<Rightarrow> update k v s) ?m0.2\n     l) \\<and>\n  \\<alpha>\n   (foldl (\\<lambda>s a. case a of (k, v) \\<Rightarrow> update k v s) ?m0.2\n     l) =\n  \\<alpha> ?m0.2 ++ map_of (rev l)\n  invar m0\n\ngoal (1 subgoal):\n 1. \\<And>a l m0.\n       \\<lbrakk>\\<And>m0.\n                   invar m0 \\<Longrightarrow>\n                   invar\n                    (foldl (\\<lambda>s (k, v). update k v s) m0 l) \\<and>\n                   \\<alpha> (foldl (\\<lambda>s (k, v). update k v s) m0 l) =\n                   \\<alpha> m0 ++ map_of (rev l);\n        invar m0\\<rbrakk>\n       \\<Longrightarrow> invar\n                          (foldl (\\<lambda>s (k, v). update k v s) m0\n                            (a # l)) \\<and>\n                         \\<alpha>\n                          (foldl (\\<lambda>s (k, v). update k v s) m0\n                            (a # l)) =\n                         \\<alpha> m0 ++ map_of (rev (a # l))", "obtain k v where [simp]: \"kv=(k,v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k v. kv = (k, v) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases kv) auto"], ["proof (state)\nthis:\n  kv = (k, v)\n\ngoal (1 subgoal):\n 1. \\<And>a l m0.\n       \\<lbrakk>\\<And>m0.\n                   invar m0 \\<Longrightarrow>\n                   invar\n                    (foldl (\\<lambda>s (k, v). update k v s) m0 l) \\<and>\n                   \\<alpha> (foldl (\\<lambda>s (k, v). update k v s) m0 l) =\n                   \\<alpha> m0 ++ map_of (rev l);\n        invar m0\\<rbrakk>\n       \\<Longrightarrow> invar\n                          (foldl (\\<lambda>s (k, v). update k v s) m0\n                            (a # l)) \\<and>\n                         \\<alpha>\n                          (foldl (\\<lambda>s (k, v). update k v s) m0\n                            (a # l)) =\n                         \\<alpha> m0 ++ map_of (rev (a # l))", "have \"invar (foldl (\\<lambda>s (k, v). update k v s) m0 (kv # l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar (foldl (\\<lambda>s (k, v). update k v s) m0 (kv # l))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. invar (foldl (\\<lambda>s (k, v). update k v s) (update k v m0) l)", "apply (rule conjunct1[OF Cons.IH])"], ["proof (prove)\ngoal (1 subgoal):\n 1. invar (update k v m0)", "apply (simp add: update_correct Cons.prems)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  invar (foldl (\\<lambda>s (k, v). update k v s) m0 (kv # l))\n\ngoal (1 subgoal):\n 1. \\<And>a l m0.\n       \\<lbrakk>\\<And>m0.\n                   invar m0 \\<Longrightarrow>\n                   invar\n                    (foldl (\\<lambda>s (k, v). update k v s) m0 l) \\<and>\n                   \\<alpha> (foldl (\\<lambda>s (k, v). update k v s) m0 l) =\n                   \\<alpha> m0 ++ map_of (rev l);\n        invar m0\\<rbrakk>\n       \\<Longrightarrow> invar\n                          (foldl (\\<lambda>s (k, v). update k v s) m0\n                            (a # l)) \\<and>\n                         \\<alpha>\n                          (foldl (\\<lambda>s (k, v). update k v s) m0\n                            (a # l)) =\n                         \\<alpha> m0 ++ map_of (rev (a # l))", "moreover"], ["proof (state)\nthis:\n  invar (foldl (\\<lambda>s (k, v). update k v s) m0 (kv # l))\n\ngoal (1 subgoal):\n 1. \\<And>a l m0.\n       \\<lbrakk>\\<And>m0.\n                   invar m0 \\<Longrightarrow>\n                   invar\n                    (foldl (\\<lambda>s (k, v). update k v s) m0 l) \\<and>\n                   \\<alpha> (foldl (\\<lambda>s (k, v). update k v s) m0 l) =\n                   \\<alpha> m0 ++ map_of (rev l);\n        invar m0\\<rbrakk>\n       \\<Longrightarrow> invar\n                          (foldl (\\<lambda>s (k, v). update k v s) m0\n                            (a # l)) \\<and>\n                         \\<alpha>\n                          (foldl (\\<lambda>s (k, v). update k v s) m0\n                            (a # l)) =\n                         \\<alpha> m0 ++ map_of (rev (a # l))", "have \"\\<alpha> (foldl (\\<lambda>s (k, v). update k v s) m0 (kv # l)) =\n          \\<alpha> m0 ++ map_of (rev (kv # l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (foldl (\\<lambda>s (k, v). update k v s) m0 (kv # l)) =\n    \\<alpha> m0 ++ map_of (rev (kv # l))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (foldl (\\<lambda>s (k, v). update k v s) (update k v m0) l) =\n    \\<alpha> m0(k \\<mapsto> v) ++ map_of (rev l)", "apply (rule trans[OF conjunct2[OF Cons.IH]])"], ["proof (prove)\ngoal (2 subgoals):\n 1. invar (update k v m0)\n 2. \\<alpha> (update k v m0) ++ map_of (rev l) =\n    \\<alpha> m0(k \\<mapsto> v) ++ map_of (rev l)", "apply (auto \n            simp: update_correct Cons.prems Map.map_add_def[abs_def]\n            split: option.split\n          )"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<alpha> (foldl (\\<lambda>s (k, v). update k v s) m0 (kv # l)) =\n  \\<alpha> m0 ++ map_of (rev (kv # l))\n\ngoal (1 subgoal):\n 1. \\<And>a l m0.\n       \\<lbrakk>\\<And>m0.\n                   invar m0 \\<Longrightarrow>\n                   invar\n                    (foldl (\\<lambda>s (k, v). update k v s) m0 l) \\<and>\n                   \\<alpha> (foldl (\\<lambda>s (k, v). update k v s) m0 l) =\n                   \\<alpha> m0 ++ map_of (rev l);\n        invar m0\\<rbrakk>\n       \\<Longrightarrow> invar\n                          (foldl (\\<lambda>s (k, v). update k v s) m0\n                            (a # l)) \\<and>\n                         \\<alpha>\n                          (foldl (\\<lambda>s (k, v). update k v s) m0\n                            (a # l)) =\n                         \\<alpha> m0 ++ map_of (rev (a # l))", "ultimately"], ["proof (chain)\npicking this:\n  invar (foldl (\\<lambda>s (k, v). update k v s) m0 (kv # l))\n  \\<alpha> (foldl (\\<lambda>s (k, v). update k v s) m0 (kv # l)) =\n  \\<alpha> m0 ++ map_of (rev (kv # l))", "show ?case"], ["proof (prove)\nusing this:\n  invar (foldl (\\<lambda>s (k, v). update k v s) m0 (kv # l))\n  \\<alpha> (foldl (\\<lambda>s (k, v). update k v s) m0 (kv # l)) =\n  \\<alpha> m0 ++ map_of (rev (kv # l))\n\ngoal (1 subgoal):\n 1. invar\n     (foldl (\\<lambda>s a. case a of (k, v) \\<Rightarrow> update k v s) m0\n       (kv # l)) \\<and>\n    \\<alpha>\n     (foldl (\\<lambda>s a. case a of (k, v) \\<Rightarrow> update k v s) m0\n       (kv # l)) =\n    \\<alpha> m0 ++ map_of (rev (kv # l))", "by simp"], ["proof (state)\nthis:\n  invar\n   (foldl (\\<lambda>s a. case a of (k, v) \\<Rightarrow> update k v s) m0\n     (kv # l)) \\<and>\n  \\<alpha>\n   (foldl (\\<lambda>s a. case a of (k, v) \\<Rightarrow> update k v s) m0\n     (kv # l)) =\n  \\<alpha> m0 ++ map_of (rev (kv # l))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  invar (foldl (\\<lambda>s (k, v). update k v s) m0 l) \\<and>\n  \\<alpha> (foldl (\\<lambda>s (k, v). update k v s) m0 l) =\n  \\<alpha> m0 ++ map_of (rev l)\n\ngoal (1 subgoal):\n 1. list_to_map \\<alpha> invar g_list_to_map", "}"], ["proof (state)\nthis:\n  invar ?m0.4 \\<Longrightarrow>\n  invar (foldl (\\<lambda>s (k, v). update k v s) ?m0.4 ?l4) \\<and>\n  \\<alpha> (foldl (\\<lambda>s (k, v). update k v s) ?m0.4 ?l4) =\n  \\<alpha> ?m0.4 ++ map_of (rev ?l4)\n\ngoal (1 subgoal):\n 1. list_to_map \\<alpha> invar g_list_to_map", "thus ?thesis"], ["proof (prove)\nusing this:\n  invar ?m0.4 \\<Longrightarrow>\n  invar (foldl (\\<lambda>s (k, v). update k v s) ?m0.4 ?l4) \\<and>\n  \\<alpha> (foldl (\\<lambda>s (k, v). update k v s) ?m0.4 ?l4) =\n  \\<alpha> ?m0.4 ++ map_of (rev ?l4)\n\ngoal (1 subgoal):\n 1. list_to_map \\<alpha> invar g_list_to_map", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l.\n       (\\<And>m0 l.\n           invar m0 \\<Longrightarrow>\n           invar (foldl (\\<lambda>s (k, v). update k v s) m0 l) \\<and>\n           \\<alpha> (foldl (\\<lambda>s (k, v). update k v s) m0 l) =\n           \\<alpha> m0 ++ map_of (rev l)) \\<Longrightarrow>\n       \\<alpha> (g_list_to_map l) = map_of l\n 2. \\<And>l.\n       (\\<And>m0 l.\n           invar m0 \\<Longrightarrow>\n           invar (foldl (\\<lambda>s (k, v). update k v s) m0 l) \\<and>\n           \\<alpha> (foldl (\\<lambda>s (k, v). update k v s) m0 l) =\n           \\<alpha> m0 ++ map_of (rev l)) \\<Longrightarrow>\n       invar (g_list_to_map l)", "unfolding g_list_to_map_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l.\n       (\\<And>m0 l.\n           invar m0 \\<Longrightarrow>\n           invar (foldl (\\<lambda>s (k, v). update k v s) m0 l) \\<and>\n           \\<alpha> (foldl (\\<lambda>s (k, v). update k v s) m0 l) =\n           \\<alpha> m0 ++ map_of (rev l)) \\<Longrightarrow>\n       \\<alpha>\n        (foldl (\\<lambda>m (k, v). update k v m) (local.empty ()) (rev l)) =\n       map_of l\n 2. \\<And>l.\n       (\\<And>m0 l.\n           invar m0 \\<Longrightarrow>\n           invar (foldl (\\<lambda>s (k, v). update k v s) m0 l) \\<and>\n           \\<alpha> (foldl (\\<lambda>s (k, v). update k v s) m0 l) =\n           \\<alpha> m0 ++ map_of (rev l)) \\<Longrightarrow>\n       invar\n        (foldl (\\<lambda>m (k, v). update k v m) (local.empty ()) (rev l))", "apply (auto simp: empty_correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  list_to_map \\<alpha> invar g_list_to_map\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma g_add_dj_impl: \"map_add_dj \\<alpha> invar g_add_dj\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_add_dj \\<alpha> invar g_add_dj", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m1 m2.\n       \\<lbrakk>invar m1; invar m2;\n        dom (\\<alpha> m1) \\<inter> dom (\\<alpha> m2) = {}\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> (g_add_dj m1 m2) =\n                         \\<alpha> m1 ++ \\<alpha> m2\n 2. \\<And>m1 m2.\n       \\<lbrakk>invar m1; invar m2;\n        dom (\\<alpha> m1) \\<inter> dom (\\<alpha> m2) = {}\\<rbrakk>\n       \\<Longrightarrow> invar (g_add_dj m1 m2)", "fix m1 m2"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m1 m2.\n       \\<lbrakk>invar m1; invar m2;\n        dom (\\<alpha> m1) \\<inter> dom (\\<alpha> m2) = {}\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> (g_add_dj m1 m2) =\n                         \\<alpha> m1 ++ \\<alpha> m2\n 2. \\<And>m1 m2.\n       \\<lbrakk>invar m1; invar m2;\n        dom (\\<alpha> m1) \\<inter> dom (\\<alpha> m2) = {}\\<rbrakk>\n       \\<Longrightarrow> invar (g_add_dj m1 m2)", "assume \"invar m1\" \"invar m2\" and DJ: \"dom (\\<alpha> m1) \\<inter> dom (\\<alpha> m2) = {}\""], ["proof (state)\nthis:\n  invar m1\n  invar m2\n  dom (\\<alpha> m1) \\<inter> dom (\\<alpha> m2) = {}\n\ngoal (2 subgoals):\n 1. \\<And>m1 m2.\n       \\<lbrakk>invar m1; invar m2;\n        dom (\\<alpha> m1) \\<inter> dom (\\<alpha> m2) = {}\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> (g_add_dj m1 m2) =\n                         \\<alpha> m1 ++ \\<alpha> m2\n 2. \\<And>m1 m2.\n       \\<lbrakk>invar m1; invar m2;\n        dom (\\<alpha> m1) \\<inter> dom (\\<alpha> m2) = {}\\<rbrakk>\n       \\<Longrightarrow> invar (g_add_dj m1 m2)", "have A: \"g_add_dj m1 m2 = iterate_add_to_map m1 update_dj (iteratei m2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g_add_dj m1 m2 = iterate_add_to_map m1 update_dj (iteratei m2)", "unfolding g_add_dj_def iterate_add_to_map_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. iterate m2 (\\<lambda>(x, y). update_dj x y) m1 =\n    iterate m2 (\\<lambda>(x, y). update_dj x y) m1", "by simp"], ["proof (state)\nthis:\n  g_add_dj m1 m2 = iterate_add_to_map m1 update_dj (iteratei m2)\n\ngoal (2 subgoals):\n 1. \\<And>m1 m2.\n       \\<lbrakk>invar m1; invar m2;\n        dom (\\<alpha> m1) \\<inter> dom (\\<alpha> m2) = {}\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> (g_add_dj m1 m2) =\n                         \\<alpha> m1 ++ \\<alpha> m2\n 2. \\<And>m1 m2.\n       \\<lbrakk>invar m1; invar m2;\n        dom (\\<alpha> m1) \\<inter> dom (\\<alpha> m2) = {}\\<rbrakk>\n       \\<Longrightarrow> invar (g_add_dj m1 m2)", "have \"\\<alpha> (g_add_dj m1 m2) = \\<alpha> m1 ++ \\<alpha> m2 \\<and> invar (g_add_dj m1 m2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (g_add_dj m1 m2) = \\<alpha> m1 ++ \\<alpha> m2 \\<and>\n    invar (g_add_dj m1 m2)", "unfolding A"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (iterate_add_to_map m1 update_dj (iteratei m2)) =\n    \\<alpha> m1 ++ \\<alpha> m2 \\<and>\n    invar (iterate_add_to_map m1 update_dj (iteratei m2))", "apply (rule \n        iterate_add_to_map_dj_correct[\n        of \\<alpha> invar update_dj m1 \"iteratei m2\" \"\\<alpha> m2\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. map_update_dj \\<alpha> invar update_dj\n 2. invar m1\n 3. map_iterator (iteratei m2) (\\<alpha> m2)\n 4. dom (\\<alpha> m2) \\<inter> dom (\\<alpha> m1) = {}", "apply unfold_locales []"], ["proof (prove)\ngoal (3 subgoals):\n 1. invar m1\n 2. map_iterator (iteratei m2) (\\<alpha> m2)\n 3. dom (\\<alpha> m2) \\<inter> dom (\\<alpha> m1) = {}", "apply fact"], ["proof (prove)\ngoal (2 subgoals):\n 1. map_iterator (iteratei m2) (\\<alpha> m2)\n 2. dom (\\<alpha> m2) \\<inter> dom (\\<alpha> m1) = {}", "apply (rule iteratei_correct, fact)"], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (\\<alpha> m2) \\<inter> dom (\\<alpha> m1) = {}", "using DJ"], ["proof (prove)\nusing this:\n  dom (\\<alpha> m1) \\<inter> dom (\\<alpha> m2) = {}\n\ngoal (1 subgoal):\n 1. dom (\\<alpha> m2) \\<inter> dom (\\<alpha> m1) = {}", "apply (simp add: Int_ac)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<alpha> (g_add_dj m1 m2) = \\<alpha> m1 ++ \\<alpha> m2 \\<and>\n  invar (g_add_dj m1 m2)\n\ngoal (2 subgoals):\n 1. \\<And>m1 m2.\n       \\<lbrakk>invar m1; invar m2;\n        dom (\\<alpha> m1) \\<inter> dom (\\<alpha> m2) = {}\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> (g_add_dj m1 m2) =\n                         \\<alpha> m1 ++ \\<alpha> m2\n 2. \\<And>m1 m2.\n       \\<lbrakk>invar m1; invar m2;\n        dom (\\<alpha> m1) \\<inter> dom (\\<alpha> m2) = {}\\<rbrakk>\n       \\<Longrightarrow> invar (g_add_dj m1 m2)", "thus \"\\<alpha> (g_add_dj m1 m2) = \\<alpha> m1 ++ \\<alpha> m2\" \"invar (g_add_dj m1 m2)\""], ["proof (prove)\nusing this:\n  \\<alpha> (g_add_dj m1 m2) = \\<alpha> m1 ++ \\<alpha> m2 \\<and>\n  invar (g_add_dj m1 m2)\n\ngoal (1 subgoal):\n 1. \\<alpha> (g_add_dj m1 m2) = \\<alpha> m1 ++ \\<alpha> m2 &&&\n    invar (g_add_dj m1 m2)", "by auto"], ["proof (state)\nthis:\n  \\<alpha> (g_add_dj m1 m2) = \\<alpha> m1 ++ \\<alpha> m2\n  invar (g_add_dj m1 m2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma g_restrict_impl: \"map_restrict \\<alpha> invar \\<alpha> invar g_restrict\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_restrict \\<alpha> invar \\<alpha> invar g_restrict", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m P.\n       invar m \\<Longrightarrow>\n       \\<alpha> (g_restrict P m) =\n       \\<alpha> m |` {k. \\<exists>v. \\<alpha> m k = Some v \\<and> P (k, v)}\n 2. \\<And>m P. invar m \\<Longrightarrow> invar (g_restrict P m)", "fix m P"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m P.\n       invar m \\<Longrightarrow>\n       \\<alpha> (g_restrict P m) =\n       \\<alpha> m |` {k. \\<exists>v. \\<alpha> m k = Some v \\<and> P (k, v)}\n 2. \\<And>m P. invar m \\<Longrightarrow> invar (g_restrict P m)", "assume I: \"invar m\""], ["proof (state)\nthis:\n  invar m\n\ngoal (2 subgoals):\n 1. \\<And>m P.\n       invar m \\<Longrightarrow>\n       \\<alpha> (g_restrict P m) =\n       \\<alpha> m |` {k. \\<exists>v. \\<alpha> m k = Some v \\<and> P (k, v)}\n 2. \\<And>m P. invar m \\<Longrightarrow> invar (g_restrict P m)", "have AUX: \"\\<And>k v it \\<sigma>.\n       \\<lbrakk>it \\<subseteq> {(k, v). \\<alpha> m k = Some v}; \\<alpha> m k = Some v; (k, v) \\<notin> it;\n        {(k, v). \\<alpha> \\<sigma> k = Some v} = it \\<inter> Collect P\\<rbrakk>\n       \\<Longrightarrow> k \\<notin> dom (\\<alpha> \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>it \\<subseteq> {(k, v). \\<alpha> m k = Some v};\n        \\<alpha> m k = Some v; (k, v) \\<notin> it;\n        {(k, v). \\<alpha> \\<sigma> k = Some v} =\n        it \\<inter> Collect P\\<rbrakk>\n       \\<Longrightarrow> k \\<notin> dom (\\<alpha> \\<sigma>)", "proof (rule ccontr, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>it \\<subseteq> {(k, v). \\<alpha> m k = Some v};\n        \\<alpha> m k = Some v; (k, v) \\<notin> it;\n        {(k, v). \\<alpha> \\<sigma> k = Some v} = it \\<inter> Collect P;\n        k \\<in> dom (\\<alpha> \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> False", "fix k v it \\<sigma>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>it \\<subseteq> {(k, v). \\<alpha> m k = Some v};\n        \\<alpha> m k = Some v; (k, v) \\<notin> it;\n        {(k, v). \\<alpha> \\<sigma> k = Some v} = it \\<inter> Collect P;\n        k \\<in> dom (\\<alpha> \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"k\\<in>dom (\\<alpha> \\<sigma>)\""], ["proof (state)\nthis:\n  k \\<in> dom (\\<alpha> \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>it \\<subseteq> {(k, v). \\<alpha> m k = Some v};\n        \\<alpha> m k = Some v; (k, v) \\<notin> it;\n        {(k, v). \\<alpha> \\<sigma> k = Some v} = it \\<inter> Collect P;\n        k \\<in> dom (\\<alpha> \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  k \\<in> dom (\\<alpha> \\<sigma>)", "obtain v' where \"\\<alpha> \\<sigma> k = Some v'\""], ["proof (prove)\nusing this:\n  k \\<in> dom (\\<alpha> \\<sigma>)\n\ngoal (1 subgoal):\n 1. (\\<And>v'.\n        \\<alpha> \\<sigma> k = Some v' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<alpha> \\<sigma> k = Some v'\n\ngoal (1 subgoal):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>it \\<subseteq> {(k, v). \\<alpha> m k = Some v};\n        \\<alpha> m k = Some v; (k, v) \\<notin> it;\n        {(k, v). \\<alpha> \\<sigma> k = Some v} = it \\<inter> Collect P;\n        k \\<in> dom (\\<alpha> \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  \\<alpha> \\<sigma> k = Some v'\n\ngoal (1 subgoal):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>it \\<subseteq> {(k, v). \\<alpha> m k = Some v};\n        \\<alpha> m k = Some v; (k, v) \\<notin> it;\n        {(k, v). \\<alpha> \\<sigma> k = Some v} = it \\<inter> Collect P;\n        k \\<in> dom (\\<alpha> \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"{(k, v). \\<alpha> \\<sigma> k = Some v} = it \\<inter> Collect P\""], ["proof (state)\nthis:\n  {(k, v). \\<alpha> \\<sigma> k = Some v} = it \\<inter> Collect P\n\ngoal (1 subgoal):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>it \\<subseteq> {(k, v). \\<alpha> m k = Some v};\n        \\<alpha> m k = Some v; (k, v) \\<notin> it;\n        {(k, v). \\<alpha> \\<sigma> k = Some v} = it \\<inter> Collect P;\n        k \\<in> dom (\\<alpha> \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  \\<alpha> \\<sigma> k = Some v'\n  {(k, v). \\<alpha> \\<sigma> k = Some v} = it \\<inter> Collect P", "have MEM: \"(k,v')\\<in>it\""], ["proof (prove)\nusing this:\n  \\<alpha> \\<sigma> k = Some v'\n  {(k, v). \\<alpha> \\<sigma> k = Some v} = it \\<inter> Collect P\n\ngoal (1 subgoal):\n 1. (k, v') \\<in> it", "by auto"], ["proof (state)\nthis:\n  (k, v') \\<in> it\n\ngoal (1 subgoal):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>it \\<subseteq> {(k, v). \\<alpha> m k = Some v};\n        \\<alpha> m k = Some v; (k, v) \\<notin> it;\n        {(k, v). \\<alpha> \\<sigma> k = Some v} = it \\<inter> Collect P;\n        k \\<in> dom (\\<alpha> \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  (k, v') \\<in> it\n\ngoal (1 subgoal):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>it \\<subseteq> {(k, v). \\<alpha> m k = Some v};\n        \\<alpha> m k = Some v; (k, v) \\<notin> it;\n        {(k, v). \\<alpha> \\<sigma> k = Some v} = it \\<inter> Collect P;\n        k \\<in> dom (\\<alpha> \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"it \\<subseteq> {(k, v). \\<alpha> m k = Some v}\" and \"\\<alpha> m k = Some v\""], ["proof (state)\nthis:\n  it \\<subseteq> {(k, v). \\<alpha> m k = Some v}\n  \\<alpha> m k = Some v\n\ngoal (1 subgoal):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>it \\<subseteq> {(k, v). \\<alpha> m k = Some v};\n        \\<alpha> m k = Some v; (k, v) \\<notin> it;\n        {(k, v). \\<alpha> \\<sigma> k = Some v} = it \\<inter> Collect P;\n        k \\<in> dom (\\<alpha> \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  (k, v') \\<in> it\n  it \\<subseteq> {(k, v). \\<alpha> m k = Some v}\n  \\<alpha> m k = Some v", "have \"v'=v\""], ["proof (prove)\nusing this:\n  (k, v') \\<in> it\n  it \\<subseteq> {(k, v). \\<alpha> m k = Some v}\n  \\<alpha> m k = Some v\n\ngoal (1 subgoal):\n 1. v' = v", "by auto"], ["proof (state)\nthis:\n  v' = v\n\ngoal (1 subgoal):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>it \\<subseteq> {(k, v). \\<alpha> m k = Some v};\n        \\<alpha> m k = Some v; (k, v) \\<notin> it;\n        {(k, v). \\<alpha> \\<sigma> k = Some v} = it \\<inter> Collect P;\n        k \\<in> dom (\\<alpha> \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  v' = v\n\ngoal (1 subgoal):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>it \\<subseteq> {(k, v). \\<alpha> m k = Some v};\n        \\<alpha> m k = Some v; (k, v) \\<notin> it;\n        {(k, v). \\<alpha> \\<sigma> k = Some v} = it \\<inter> Collect P;\n        k \\<in> dom (\\<alpha> \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"(k,v)\\<notin>it\""], ["proof (state)\nthis:\n  (k, v) \\<notin> it\n\ngoal (1 subgoal):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>it \\<subseteq> {(k, v). \\<alpha> m k = Some v};\n        \\<alpha> m k = Some v; (k, v) \\<notin> it;\n        {(k, v). \\<alpha> \\<sigma> k = Some v} = it \\<inter> Collect P;\n        k \\<in> dom (\\<alpha> \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  (k, v) \\<notin> it\n\ngoal (1 subgoal):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>it \\<subseteq> {(k, v). \\<alpha> m k = Some v};\n        \\<alpha> m k = Some v; (k, v) \\<notin> it;\n        {(k, v). \\<alpha> \\<sigma> k = Some v} = it \\<inter> Collect P;\n        k \\<in> dom (\\<alpha> \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> False", "note MEM"], ["proof (state)\nthis:\n  (k, v') \\<in> it\n\ngoal (1 subgoal):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>it \\<subseteq> {(k, v). \\<alpha> m k = Some v};\n        \\<alpha> m k = Some v; (k, v) \\<notin> it;\n        {(k, v). \\<alpha> \\<sigma> k = Some v} = it \\<inter> Collect P;\n        k \\<in> dom (\\<alpha> \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  v' = v\n  (k, v) \\<notin> it\n  (k, v') \\<in> it", "show False"], ["proof (prove)\nusing this:\n  v' = v\n  (k, v) \\<notin> it\n  (k, v') \\<in> it\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?it2 \\<subseteq> {(k, v). \\<alpha> m k = Some v};\n   \\<alpha> m ?k2 = Some ?v2; (?k2, ?v2) \\<notin> ?it2;\n   {(k, v). \\<alpha> ?\\<sigma>2 k = Some v} =\n   ?it2 \\<inter> Collect P\\<rbrakk>\n  \\<Longrightarrow> ?k2 \\<notin> dom (\\<alpha> ?\\<sigma>2)\n\ngoal (2 subgoals):\n 1. \\<And>m P.\n       invar m \\<Longrightarrow>\n       \\<alpha> (g_restrict P m) =\n       \\<alpha> m |` {k. \\<exists>v. \\<alpha> m k = Some v \\<and> P (k, v)}\n 2. \\<And>m P. invar m \\<Longrightarrow> invar (g_restrict P m)", "have \"\\<alpha> (g_restrict P m) = \\<alpha> m |` {k. \\<exists>v. \\<alpha> m k = Some v \\<and> P (k, v)} \\<and>\n      invar (g_restrict P m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (g_restrict P m) =\n    \\<alpha> m |`\n    {k. \\<exists>v. \\<alpha> m k = Some v \\<and> P (k, v)} \\<and>\n    invar (g_restrict P m)", "unfolding g_restrict_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha>\n     (iterate m\n       (\\<lambda>(k, v) \\<sigma>.\n           if P (k, v) then update_dj k v \\<sigma> else \\<sigma>)\n       (local.empty ())) =\n    \\<alpha> m |`\n    {k. \\<exists>v. \\<alpha> m k = Some v \\<and> P (k, v)} \\<and>\n    invar\n     (iterate m\n       (\\<lambda>(k, v) \\<sigma>.\n           if P (k, v) then update_dj k v \\<sigma> else \\<sigma>)\n       (local.empty ()))", "apply (rule_tac I=\"\\<lambda>it \\<sigma>. invar \\<sigma> \n        \\<and> map_to_set (\\<alpha> \\<sigma>) = it \\<inter> Collect P\"\n        in iterate_rule_insert_P)"], ["proof (prove)\ngoal (4 subgoals):\n 1. invar m\n 2. invar (local.empty ()) \\<and>\n    map_to_set (\\<alpha> (local.empty ())) = {} \\<inter> Collect P\n 3. \\<And>k v it \\<sigma>.\n       \\<lbrakk>(k, v) \\<in> map_to_set (\\<alpha> m) - it;\n        it \\<subseteq> map_to_set (\\<alpha> m);\n        invar \\<sigma> \\<and>\n        map_to_set (\\<alpha> \\<sigma>) = it \\<inter> Collect P\\<rbrakk>\n       \\<Longrightarrow> invar\n                          ((case (k, v) of\n                            (k, v) \\<Rightarrow>\n                              \\<lambda>\\<sigma>.\n                                 if P (k, v) then update_dj k v \\<sigma>\n                                 else \\<sigma>)\n                            \\<sigma>) \\<and>\n                         map_to_set\n                          (\\<alpha>\n                            ((case (k, v) of\n                              (k, v) \\<Rightarrow>\n                                \\<lambda>\\<sigma>.\n                                   if P (k, v) then update_dj k v \\<sigma>\n                                   else \\<sigma>)\n                              \\<sigma>)) =\n                         insert (k, v) it \\<inter> Collect P\n 4. \\<And>\\<sigma>.\n       invar \\<sigma> \\<and>\n       map_to_set (\\<alpha> \\<sigma>) =\n       map_to_set (\\<alpha> m) \\<inter> Collect P \\<Longrightarrow>\n       \\<alpha> \\<sigma> =\n       \\<alpha> m |`\n       {k. \\<exists>v. \\<alpha> m k = Some v \\<and> P (k, v)} \\<and>\n       invar \\<sigma>", "apply (auto simp: I empty_correct update_dj_correct map_to_set_def AUX)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>k v it \\<sigma> a b.\n       \\<lbrakk>it \\<subseteq> {(k, v). \\<alpha> m k = Some v};\n        \\<alpha> m k = Some v; (k, v) \\<notin> it; invar \\<sigma>;\n        {(k, v). \\<alpha> \\<sigma> k = Some v} = it \\<inter> Collect P;\n        P (k, v); (if a = k then Some v else \\<alpha> \\<sigma> a) = Some b;\n        (a, b) \\<notin> it\\<rbrakk>\n       \\<Longrightarrow> b = v\n 2. \\<And>k v it \\<sigma> a b.\n       \\<lbrakk>it \\<subseteq> {(k, v). \\<alpha> m k = Some v};\n        \\<alpha> m k = Some v; (k, v) \\<notin> it; invar \\<sigma>;\n        {(k, v). \\<alpha> \\<sigma> k = Some v} = it \\<inter> Collect P;\n        P (k, v); (if a = k then Some v else \\<alpha> \\<sigma> a) = Some b;\n        \\<not> P (a, b)\\<rbrakk>\n       \\<Longrightarrow> b = v\n 3. \\<And>k v it \\<sigma> b.\n       \\<lbrakk>it \\<subseteq> {(k, v). \\<alpha> m k = Some v};\n        \\<alpha> m k = Some v; (k, v) \\<notin> it; invar \\<sigma>;\n        {(k, v). \\<alpha> \\<sigma> k = Some v} = it \\<inter> Collect P;\n        P (k, v); (k, b) \\<in> it; P (k, b)\\<rbrakk>\n       \\<Longrightarrow> v = b\n 4. \\<And>k v it \\<sigma> a b.\n       \\<lbrakk>it \\<subseteq> {(k, v). \\<alpha> m k = Some v};\n        \\<alpha> m k = Some v; (k, v) \\<notin> it; invar \\<sigma>;\n        {(k, v). \\<alpha> \\<sigma> k = Some v} = it \\<inter> Collect P;\n        P (k, v); (a, b) \\<in> it; P (a, b); a \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> \\<sigma> a = Some b\n 5. \\<And>\\<sigma>.\n       \\<lbrakk>invar \\<sigma>;\n        {(k, v). \\<alpha> \\<sigma> k = Some v} =\n        {(k, v). \\<alpha> m k = Some v} \\<inter> Collect P\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> \\<sigma> =\n                         \\<alpha> m |`\n                         {k. \\<exists>v.\n                                \\<alpha> m k = Some v \\<and> P (k, v)}", "apply (auto split: if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<lbrakk>invar \\<sigma>;\n        {(k, v). \\<alpha> \\<sigma> k = Some v} =\n        {(k, v). \\<alpha> m k = Some v} \\<inter> Collect P\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> \\<sigma> =\n                         \\<alpha> m |`\n                         {k. \\<exists>v.\n                                \\<alpha> m k = Some v \\<and> P (k, v)}", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> x.\n       \\<lbrakk>invar \\<sigma>;\n        {(k, v). \\<alpha> \\<sigma> k = Some v} =\n        {(k, v). \\<alpha> m k = Some v} \\<inter> Collect P\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> \\<sigma> x =\n                         (\\<alpha> m |`\n                          {k. \\<exists>v.\n                                 \\<alpha> m k = Some v \\<and> P (k, v)})\n                          x", "apply (auto simp: Map.restrict_map_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma> x v.\n       \\<lbrakk>invar \\<sigma>;\n        {(k, v). \\<alpha> \\<sigma> k = Some v} =\n        {(k, v). \\<alpha> m k = Some v} \\<inter> Collect P;\n        \\<alpha> m x = Some v; P (x, v)\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> \\<sigma> x = Some v\n 2. \\<And>\\<sigma> x.\n       \\<lbrakk>invar \\<sigma>;\n        {(k, v). \\<alpha> \\<sigma> k = Some v} =\n        {(k, v). \\<alpha> m k = Some v} \\<inter> Collect P;\n        \\<forall>v.\n           \\<alpha> m x = Some v \\<longrightarrow> \\<not> P (x, v)\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> \\<sigma> x = None", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> x.\n       \\<lbrakk>invar \\<sigma>;\n        {(k, v). \\<alpha> \\<sigma> k = Some v} =\n        {(k, v). \\<alpha> m k = Some v} \\<inter> Collect P;\n        \\<forall>v.\n           \\<alpha> m x = Some v \\<longrightarrow> \\<not> P (x, v)\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> \\<sigma> x = None", "apply (rule ccontr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> x.\n       \\<lbrakk>invar \\<sigma>;\n        {(k, v). \\<alpha> \\<sigma> k = Some v} =\n        {(k, v). \\<alpha> m k = Some v} \\<inter> Collect P;\n        \\<forall>v. \\<alpha> m x = Some v \\<longrightarrow> \\<not> P (x, v);\n        \\<alpha> \\<sigma> x \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> False", "apply force"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<alpha> (g_restrict P m) =\n  \\<alpha> m |`\n  {k. \\<exists>v. \\<alpha> m k = Some v \\<and> P (k, v)} \\<and>\n  invar (g_restrict P m)\n\ngoal (2 subgoals):\n 1. \\<And>m P.\n       invar m \\<Longrightarrow>\n       \\<alpha> (g_restrict P m) =\n       \\<alpha> m |` {k. \\<exists>v. \\<alpha> m k = Some v \\<and> P (k, v)}\n 2. \\<And>m P. invar m \\<Longrightarrow> invar (g_restrict P m)", "thus \"\\<alpha> (g_restrict P m) = \\<alpha> m |` {k. \\<exists>v. \\<alpha> m k = Some v \\<and> P (k, v)}\"\n      \"invar (g_restrict P m)\""], ["proof (prove)\nusing this:\n  \\<alpha> (g_restrict P m) =\n  \\<alpha> m |`\n  {k. \\<exists>v. \\<alpha> m k = Some v \\<and> P (k, v)} \\<and>\n  invar (g_restrict P m)\n\ngoal (1 subgoal):\n 1. \\<alpha> (g_restrict P m) =\n    \\<alpha> m |` {k. \\<exists>v. \\<alpha> m k = Some v \\<and> P (k, v)} &&&\n    invar (g_restrict P m)", "by auto"], ["proof (state)\nthis:\n  \\<alpha> (g_restrict P m) =\n  \\<alpha> m |` {k. \\<exists>v. \\<alpha> m k = Some v \\<and> P (k, v)}\n  invar (g_restrict P m)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dflt_ops_impl: \"StdMap dflt_ops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. StdMap dflt_ops", "apply (rule StdMap_intro)"], ["proof (prove)\ngoal (19 subgoals):\n 1. map_empty (map_op_\\<alpha> dflt_ops) (map_op_invar dflt_ops)\n     (map_op_empty dflt_ops)\n 2. map_lookup (map_op_\\<alpha> dflt_ops) (map_op_invar dflt_ops)\n     (map_op_lookup dflt_ops)\n 3. map_update (map_op_\\<alpha> dflt_ops) (map_op_invar dflt_ops)\n     (map_op_update dflt_ops)\n 4. map_update_dj (map_op_\\<alpha> dflt_ops) (map_op_invar dflt_ops)\n     (map_op_update_dj dflt_ops)\n 5. map_delete (map_op_\\<alpha> dflt_ops) (map_op_invar dflt_ops)\n     (map_op_delete dflt_ops)\n 6. poly_map_iteratei (map_op_\\<alpha> dflt_ops) (map_op_invar dflt_ops)\n     (map_op_list_it dflt_ops)\n 7. map_sng (map_op_\\<alpha> dflt_ops) (map_op_invar dflt_ops)\n     (map_op_sng dflt_ops)\n 8. map_restrict (map_op_\\<alpha> dflt_ops) (map_op_invar dflt_ops)\n     (map_op_\\<alpha> dflt_ops) (map_op_invar dflt_ops)\n     (map_op_restrict dflt_ops)\n 9. MapSpec.map_add (map_op_\\<alpha> dflt_ops) (map_op_invar dflt_ops)\n     (map_op_add dflt_ops)\n 10. map_add_dj (map_op_\\<alpha> dflt_ops) (map_op_invar dflt_ops)\n      (map_op_add_dj dflt_ops)\nA total of 19 subgoals...", "apply icf_locales"], ["proof (prove)\ngoal (13 subgoals):\n 1. map_sng (map_op_\\<alpha> dflt_ops) (map_op_invar dflt_ops)\n     (map_op_sng dflt_ops)\n 2. map_restrict (map_op_\\<alpha> dflt_ops) (map_op_invar dflt_ops)\n     (map_op_\\<alpha> dflt_ops) (map_op_invar dflt_ops)\n     (map_op_restrict dflt_ops)\n 3. MapSpec.map_add (map_op_\\<alpha> dflt_ops) (map_op_invar dflt_ops)\n     (map_op_add dflt_ops)\n 4. map_add_dj (map_op_\\<alpha> dflt_ops) (map_op_invar dflt_ops)\n     (map_op_add_dj dflt_ops)\n 5. map_isEmpty (map_op_\\<alpha> dflt_ops) (map_op_invar dflt_ops)\n     (map_op_isEmpty dflt_ops)\n 6. map_isSng (map_op_\\<alpha> dflt_ops) (map_op_invar dflt_ops)\n     (map_op_isSng dflt_ops)\n 7. map_ball (map_op_\\<alpha> dflt_ops) (map_op_invar dflt_ops)\n     (map_op_ball dflt_ops)\n 8. map_bex (map_op_\\<alpha> dflt_ops) (map_op_invar dflt_ops)\n     (map_op_bex dflt_ops)\n 9. map_size (map_op_\\<alpha> dflt_ops) (map_op_invar dflt_ops)\n     (map_op_size dflt_ops)\n 10. map_size_abort (map_op_\\<alpha> dflt_ops) (map_op_invar dflt_ops)\n      (map_op_size_abort dflt_ops)\nA total of 13 subgoals...", "apply (simp_all add: icf_rec_unf)"], ["proof (prove)\ngoal (13 subgoals):\n 1. map_sng \\<alpha> invar g_sng\n 2. map_restrict \\<alpha> invar \\<alpha> invar g_restrict\n 3. MapSpec.map_add \\<alpha> invar g_add\n 4. map_add_dj \\<alpha> invar g_add_dj\n 5. map_isEmpty \\<alpha> invar g_isEmpty\n 6. map_isSng \\<alpha> invar g_isSng\n 7. map_ball \\<alpha> invar g_ball\n 8. map_bex \\<alpha> invar g_bex\n 9. map_size \\<alpha> invar g_size\n 10. map_size_abort \\<alpha> invar g_size_abort\nA total of 13 subgoals...", "apply (rule g_sng_impl g_restrict_impl g_add_impl g_add_dj_impl \n      g_isEmpty_impl g_isSng_impl g_ball_impl g_bex_impl g_size_impl\n      g_size_abort_impl g_sel_impl g_to_list_impl g_list_to_map_impl)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "context StdBasicOMapDefs \nbegin"], ["", "definition \n    \"g_min m P \\<equiv> \n      iterateoi m (\\<lambda>\\<sigma>. \\<sigma> = None) (\\<lambda>x \\<sigma>. if P x then Some x else None) None\""], ["", "definition \n    \"g_max m P \\<equiv> \n      rev_iterateoi m (\\<lambda>\\<sigma>. \\<sigma> = None) (\\<lambda>x \\<sigma>. if P x then Some x else None) None\""], ["", "definition \"g_to_sorted_list m \\<equiv> rev_iterateo m (#) []\""], ["", "definition \"g_to_rev_list m \\<equiv> iterateo m (#) []\""], ["", "definition dflt_oops :: \"('k,'v,'s) omap_ops\" \n    where [icf_rec_def]:\n    \"dflt_oops \\<equiv> map_ops.extend dflt_ops\n      \\<lparr> \n        map_op_ordered_list_it = ordered_list_it,\n        map_op_rev_list_it = rev_list_it,\n        map_op_min = g_min,\n        map_op_max = g_max,\n        map_op_to_sorted_list = g_to_sorted_list,\n        map_op_to_rev_list = g_to_rev_list\n      \\<rparr>\""], ["", "local_setup \\<open>Locale_Code.lc_decl_del @{term dflt_oops}\\<close>"], ["", "end"], ["", "context StdBasicOMap \nbegin"], ["", "lemma g_min_impl: \"map_min \\<alpha> invar g_min\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_min \\<alpha> invar g_min", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s P.\n       \\<lbrakk>invar s; rel_of (\\<alpha> s) P \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> g_min s P \\<in> Some ` rel_of (\\<alpha> s) P\n 2. \\<And>s k v P.\n       \\<lbrakk>invar s; (k, v) \\<in> rel_of (\\<alpha> s) P\\<rbrakk>\n       \\<Longrightarrow> fst (the (g_min s P)) \\<le> k\n 3. \\<And>s P.\n       \\<lbrakk>invar s; rel_of (\\<alpha> s) P = {}\\<rbrakk>\n       \\<Longrightarrow> g_min s P = None", "fix m P"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s P.\n       \\<lbrakk>invar s; rel_of (\\<alpha> s) P \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> g_min s P \\<in> Some ` rel_of (\\<alpha> s) P\n 2. \\<And>s k v P.\n       \\<lbrakk>invar s; (k, v) \\<in> rel_of (\\<alpha> s) P\\<rbrakk>\n       \\<Longrightarrow> fst (the (g_min s P)) \\<le> k\n 3. \\<And>s P.\n       \\<lbrakk>invar s; rel_of (\\<alpha> s) P = {}\\<rbrakk>\n       \\<Longrightarrow> g_min s P = None", "assume I: \"invar m\""], ["proof (state)\nthis:\n  invar m\n\ngoal (3 subgoals):\n 1. \\<And>s P.\n       \\<lbrakk>invar s; rel_of (\\<alpha> s) P \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> g_min s P \\<in> Some ` rel_of (\\<alpha> s) P\n 2. \\<And>s k v P.\n       \\<lbrakk>invar s; (k, v) \\<in> rel_of (\\<alpha> s) P\\<rbrakk>\n       \\<Longrightarrow> fst (the (g_min s P)) \\<le> k\n 3. \\<And>s P.\n       \\<lbrakk>invar s; rel_of (\\<alpha> s) P = {}\\<rbrakk>\n       \\<Longrightarrow> g_min s P = None", "from iterateoi_correct[OF I]"], ["proof (chain)\npicking this:\n  map_iterator_linord (iterateoi m) (\\<alpha> m)", "have iti': \"map_iterator_linord (iterateoi m) (\\<alpha> m)\""], ["proof (prove)\nusing this:\n  map_iterator_linord (iterateoi m) (\\<alpha> m)\n\ngoal (1 subgoal):\n 1. map_iterator_linord (iterateoi m) (\\<alpha> m)", "by simp"], ["proof (state)\nthis:\n  map_iterator_linord (iterateoi m) (\\<alpha> m)\n\ngoal (3 subgoals):\n 1. \\<And>s P.\n       \\<lbrakk>invar s; rel_of (\\<alpha> s) P \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> g_min s P \\<in> Some ` rel_of (\\<alpha> s) P\n 2. \\<And>s k v P.\n       \\<lbrakk>invar s; (k, v) \\<in> rel_of (\\<alpha> s) P\\<rbrakk>\n       \\<Longrightarrow> fst (the (g_min s P)) \\<le> k\n 3. \\<And>s P.\n       \\<lbrakk>invar s; rel_of (\\<alpha> s) P = {}\\<rbrakk>\n       \\<Longrightarrow> g_min s P = None", "note sel_correct = iterate_sel_no_map_map_linord_correct[OF iti', of P]"], ["proof (state)\nthis:\n  (iterate_sel_no_map (iterateoi m) P = None) =\n  (\\<forall>k v. \\<alpha> m k = Some v \\<longrightarrow> \\<not> P (k, v))\n  iterate_sel_no_map (iterateoi m) P = Some (?k, ?v) \\<Longrightarrow>\n  \\<alpha> m ?k = Some ?v \\<and>\n  P (?k, ?v) \\<and>\n  (\\<forall>k' v'.\n      \\<alpha> m k' = Some v' \\<and> P (k', v') \\<longrightarrow>\n      ?k \\<le> k')\n\ngoal (3 subgoals):\n 1. \\<And>s P.\n       \\<lbrakk>invar s; rel_of (\\<alpha> s) P \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> g_min s P \\<in> Some ` rel_of (\\<alpha> s) P\n 2. \\<And>s k v P.\n       \\<lbrakk>invar s; (k, v) \\<in> rel_of (\\<alpha> s) P\\<rbrakk>\n       \\<Longrightarrow> fst (the (g_min s P)) \\<le> k\n 3. \\<And>s P.\n       \\<lbrakk>invar s; rel_of (\\<alpha> s) P = {}\\<rbrakk>\n       \\<Longrightarrow> g_min s P = None", "have A: \"g_min m P = iterate_sel_no_map (iterateoi m) P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g_min m P = iterate_sel_no_map (iterateoi m) P", "unfolding g_min_def iterate_sel_no_map_def iterate_sel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. iterateoi m (\\<lambda>\\<sigma>. \\<sigma> = None)\n     (\\<lambda>x \\<sigma>. if P x then Some x else None) None =\n    iterateoi m (\\<lambda>\\<sigma>. \\<sigma> = None)\n     (\\<lambda>x \\<sigma>. if P x then Some x else None) None", "by simp"], ["proof (state)\nthis:\n  g_min m P = iterate_sel_no_map (iterateoi m) P\n\ngoal (3 subgoals):\n 1. \\<And>s P.\n       \\<lbrakk>invar s; rel_of (\\<alpha> s) P \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> g_min s P \\<in> Some ` rel_of (\\<alpha> s) P\n 2. \\<And>s k v P.\n       \\<lbrakk>invar s; (k, v) \\<in> rel_of (\\<alpha> s) P\\<rbrakk>\n       \\<Longrightarrow> fst (the (g_min s P)) \\<le> k\n 3. \\<And>s P.\n       \\<lbrakk>invar s; rel_of (\\<alpha> s) P = {}\\<rbrakk>\n       \\<Longrightarrow> g_min s P = None", "{"], ["proof (state)\nthis:\n  g_min m P = iterate_sel_no_map (iterateoi m) P\n\ngoal (3 subgoals):\n 1. \\<And>s P.\n       \\<lbrakk>invar s; rel_of (\\<alpha> s) P \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> g_min s P \\<in> Some ` rel_of (\\<alpha> s) P\n 2. \\<And>s k v P.\n       \\<lbrakk>invar s; (k, v) \\<in> rel_of (\\<alpha> s) P\\<rbrakk>\n       \\<Longrightarrow> fst (the (g_min s P)) \\<le> k\n 3. \\<And>s P.\n       \\<lbrakk>invar s; rel_of (\\<alpha> s) P = {}\\<rbrakk>\n       \\<Longrightarrow> g_min s P = None", "assume \"rel_of (\\<alpha> m) P \\<noteq> {}\""], ["proof (state)\nthis:\n  rel_of (\\<alpha> m) P \\<noteq> {}\n\ngoal (3 subgoals):\n 1. \\<And>s P.\n       \\<lbrakk>invar s; rel_of (\\<alpha> s) P \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> g_min s P \\<in> Some ` rel_of (\\<alpha> s) P\n 2. \\<And>s k v P.\n       \\<lbrakk>invar s; (k, v) \\<in> rel_of (\\<alpha> s) P\\<rbrakk>\n       \\<Longrightarrow> fst (the (g_min s P)) \\<le> k\n 3. \\<And>s P.\n       \\<lbrakk>invar s; rel_of (\\<alpha> s) P = {}\\<rbrakk>\n       \\<Longrightarrow> g_min s P = None", "with sel_correct"], ["proof (chain)\npicking this:\n  (iterate_sel_no_map (iterateoi m) P = None) =\n  (\\<forall>k v. \\<alpha> m k = Some v \\<longrightarrow> \\<not> P (k, v))\n  iterate_sel_no_map (iterateoi m) P = Some (?k, ?v) \\<Longrightarrow>\n  \\<alpha> m ?k = Some ?v \\<and>\n  P (?k, ?v) \\<and>\n  (\\<forall>k' v'.\n      \\<alpha> m k' = Some v' \\<and> P (k', v') \\<longrightarrow>\n      ?k \\<le> k')\n  rel_of (\\<alpha> m) P \\<noteq> {}", "show \"g_min m P \\<in> Some ` rel_of (\\<alpha> m) P\""], ["proof (prove)\nusing this:\n  (iterate_sel_no_map (iterateoi m) P = None) =\n  (\\<forall>k v. \\<alpha> m k = Some v \\<longrightarrow> \\<not> P (k, v))\n  iterate_sel_no_map (iterateoi m) P = Some (?k, ?v) \\<Longrightarrow>\n  \\<alpha> m ?k = Some ?v \\<and>\n  P (?k, ?v) \\<and>\n  (\\<forall>k' v'.\n      \\<alpha> m k' = Some v' \\<and> P (k', v') \\<longrightarrow>\n      ?k \\<le> k')\n  rel_of (\\<alpha> m) P \\<noteq> {}\n\ngoal (1 subgoal):\n 1. g_min m P \\<in> Some ` rel_of (\\<alpha> m) P", "unfolding A"], ["proof (prove)\nusing this:\n  (iterate_sel_no_map (iterateoi m) P = None) =\n  (\\<forall>k v. \\<alpha> m k = Some v \\<longrightarrow> \\<not> P (k, v))\n  iterate_sel_no_map (iterateoi m) P = Some (?k, ?v) \\<Longrightarrow>\n  \\<alpha> m ?k = Some ?v \\<and>\n  P (?k, ?v) \\<and>\n  (\\<forall>k' v'.\n      \\<alpha> m k' = Some v' \\<and> P (k', v') \\<longrightarrow>\n      ?k \\<le> k')\n  rel_of (\\<alpha> m) P \\<noteq> {}\n\ngoal (1 subgoal):\n 1. iterate_sel_no_map (iterateoi m) P \\<in> Some ` rel_of (\\<alpha> m) P", "by (auto simp add: image_iff rel_of_def)"], ["proof (state)\nthis:\n  g_min m P \\<in> Some ` rel_of (\\<alpha> m) P\n\ngoal (2 subgoals):\n 1. \\<And>s k v P.\n       \\<lbrakk>invar s; (k, v) \\<in> rel_of (\\<alpha> s) P\\<rbrakk>\n       \\<Longrightarrow> fst (the (g_min s P)) \\<le> k\n 2. \\<And>s P.\n       \\<lbrakk>invar s; rel_of (\\<alpha> s) P = {}\\<rbrakk>\n       \\<Longrightarrow> g_min s P = None", "}"], ["proof (state)\nthis:\n  rel_of (\\<alpha> m) P \\<noteq> {} \\<Longrightarrow>\n  g_min m P \\<in> Some ` rel_of (\\<alpha> m) P\n\ngoal (2 subgoals):\n 1. \\<And>s k v P.\n       \\<lbrakk>invar s; (k, v) \\<in> rel_of (\\<alpha> s) P\\<rbrakk>\n       \\<Longrightarrow> fst (the (g_min s P)) \\<le> k\n 2. \\<And>s P.\n       \\<lbrakk>invar s; rel_of (\\<alpha> s) P = {}\\<rbrakk>\n       \\<Longrightarrow> g_min s P = None", "{"], ["proof (state)\nthis:\n  rel_of (\\<alpha> m) P \\<noteq> {} \\<Longrightarrow>\n  g_min m P \\<in> Some ` rel_of (\\<alpha> m) P\n\ngoal (2 subgoals):\n 1. \\<And>s k v P.\n       \\<lbrakk>invar s; (k, v) \\<in> rel_of (\\<alpha> s) P\\<rbrakk>\n       \\<Longrightarrow> fst (the (g_min s P)) \\<le> k\n 2. \\<And>s P.\n       \\<lbrakk>invar s; rel_of (\\<alpha> s) P = {}\\<rbrakk>\n       \\<Longrightarrow> g_min s P = None", "assume \"rel_of (\\<alpha> m) P = {}\""], ["proof (state)\nthis:\n  rel_of (\\<alpha> m) P = {}\n\ngoal (2 subgoals):\n 1. \\<And>s k v P.\n       \\<lbrakk>invar s; (k, v) \\<in> rel_of (\\<alpha> s) P\\<rbrakk>\n       \\<Longrightarrow> fst (the (g_min s P)) \\<le> k\n 2. \\<And>s P.\n       \\<lbrakk>invar s; rel_of (\\<alpha> s) P = {}\\<rbrakk>\n       \\<Longrightarrow> g_min s P = None", "with sel_correct"], ["proof (chain)\npicking this:\n  (iterate_sel_no_map (iterateoi m) P = None) =\n  (\\<forall>k v. \\<alpha> m k = Some v \\<longrightarrow> \\<not> P (k, v))\n  iterate_sel_no_map (iterateoi m) P = Some (?k, ?v) \\<Longrightarrow>\n  \\<alpha> m ?k = Some ?v \\<and>\n  P (?k, ?v) \\<and>\n  (\\<forall>k' v'.\n      \\<alpha> m k' = Some v' \\<and> P (k', v') \\<longrightarrow>\n      ?k \\<le> k')\n  rel_of (\\<alpha> m) P = {}", "show \"g_min m P = None\""], ["proof (prove)\nusing this:\n  (iterate_sel_no_map (iterateoi m) P = None) =\n  (\\<forall>k v. \\<alpha> m k = Some v \\<longrightarrow> \\<not> P (k, v))\n  iterate_sel_no_map (iterateoi m) P = Some (?k, ?v) \\<Longrightarrow>\n  \\<alpha> m ?k = Some ?v \\<and>\n  P (?k, ?v) \\<and>\n  (\\<forall>k' v'.\n      \\<alpha> m k' = Some v' \\<and> P (k', v') \\<longrightarrow>\n      ?k \\<le> k')\n  rel_of (\\<alpha> m) P = {}\n\ngoal (1 subgoal):\n 1. g_min m P = None", "unfolding A"], ["proof (prove)\nusing this:\n  (iterate_sel_no_map (iterateoi m) P = None) =\n  (\\<forall>k v. \\<alpha> m k = Some v \\<longrightarrow> \\<not> P (k, v))\n  iterate_sel_no_map (iterateoi m) P = Some (?k, ?v) \\<Longrightarrow>\n  \\<alpha> m ?k = Some ?v \\<and>\n  P (?k, ?v) \\<and>\n  (\\<forall>k' v'.\n      \\<alpha> m k' = Some v' \\<and> P (k', v') \\<longrightarrow>\n      ?k \\<le> k')\n  rel_of (\\<alpha> m) P = {}\n\ngoal (1 subgoal):\n 1. iterate_sel_no_map (iterateoi m) P = None", "by (auto simp add: image_iff rel_of_def)"], ["proof (state)\nthis:\n  g_min m P = None\n\ngoal (1 subgoal):\n 1. \\<And>s k v P.\n       \\<lbrakk>invar s; (k, v) \\<in> rel_of (\\<alpha> s) P\\<rbrakk>\n       \\<Longrightarrow> fst (the (g_min s P)) \\<le> k", "}"], ["proof (state)\nthis:\n  rel_of (\\<alpha> m) P = {} \\<Longrightarrow> g_min m P = None\n\ngoal (1 subgoal):\n 1. \\<And>s k v P.\n       \\<lbrakk>invar s; (k, v) \\<in> rel_of (\\<alpha> s) P\\<rbrakk>\n       \\<Longrightarrow> fst (the (g_min s P)) \\<le> k", "{"], ["proof (state)\nthis:\n  rel_of (\\<alpha> m) P = {} \\<Longrightarrow> g_min m P = None\n\ngoal (1 subgoal):\n 1. \\<And>s k v P.\n       \\<lbrakk>invar s; (k, v) \\<in> rel_of (\\<alpha> s) P\\<rbrakk>\n       \\<Longrightarrow> fst (the (g_min s P)) \\<le> k", "fix k v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s k v P.\n       \\<lbrakk>invar s; (k, v) \\<in> rel_of (\\<alpha> s) P\\<rbrakk>\n       \\<Longrightarrow> fst (the (g_min s P)) \\<le> k", "assume \"(k, v) \\<in> rel_of (\\<alpha> m) P\""], ["proof (state)\nthis:\n  (k, v) \\<in> rel_of (\\<alpha> m) P\n\ngoal (1 subgoal):\n 1. \\<And>s k v P.\n       \\<lbrakk>invar s; (k, v) \\<in> rel_of (\\<alpha> s) P\\<rbrakk>\n       \\<Longrightarrow> fst (the (g_min s P)) \\<le> k", "with sel_correct"], ["proof (chain)\npicking this:\n  (iterate_sel_no_map (iterateoi m) P = None) =\n  (\\<forall>k v. \\<alpha> m k = Some v \\<longrightarrow> \\<not> P (k, v))\n  iterate_sel_no_map (iterateoi m) P = Some (?k, ?v) \\<Longrightarrow>\n  \\<alpha> m ?k = Some ?v \\<and>\n  P (?k, ?v) \\<and>\n  (\\<forall>k' v'.\n      \\<alpha> m k' = Some v' \\<and> P (k', v') \\<longrightarrow>\n      ?k \\<le> k')\n  (k, v) \\<in> rel_of (\\<alpha> m) P", "show \"fst (the (g_min m P)) \\<le> k\""], ["proof (prove)\nusing this:\n  (iterate_sel_no_map (iterateoi m) P = None) =\n  (\\<forall>k v. \\<alpha> m k = Some v \\<longrightarrow> \\<not> P (k, v))\n  iterate_sel_no_map (iterateoi m) P = Some (?k, ?v) \\<Longrightarrow>\n  \\<alpha> m ?k = Some ?v \\<and>\n  P (?k, ?v) \\<and>\n  (\\<forall>k' v'.\n      \\<alpha> m k' = Some v' \\<and> P (k', v') \\<longrightarrow>\n      ?k \\<le> k')\n  (k, v) \\<in> rel_of (\\<alpha> m) P\n\ngoal (1 subgoal):\n 1. fst (the (g_min m P)) \\<le> k", "unfolding A"], ["proof (prove)\nusing this:\n  (iterate_sel_no_map (iterateoi m) P = None) =\n  (\\<forall>k v. \\<alpha> m k = Some v \\<longrightarrow> \\<not> P (k, v))\n  iterate_sel_no_map (iterateoi m) P = Some (?k, ?v) \\<Longrightarrow>\n  \\<alpha> m ?k = Some ?v \\<and>\n  P (?k, ?v) \\<and>\n  (\\<forall>k' v'.\n      \\<alpha> m k' = Some v' \\<and> P (k', v') \\<longrightarrow>\n      ?k \\<le> k')\n  (k, v) \\<in> rel_of (\\<alpha> m) P\n\ngoal (1 subgoal):\n 1. fst (the (iterate_sel_no_map (iterateoi m) P)) \\<le> k", "by (auto simp add: image_iff rel_of_def)"], ["proof (state)\nthis:\n  fst (the (g_min m P)) \\<le> k\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  (?k7, ?v7) \\<in> rel_of (\\<alpha> m) P \\<Longrightarrow>\n  fst (the (g_min m P)) \\<le> ?k7\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma g_max_impl: \"map_max \\<alpha> invar g_max\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_max \\<alpha> invar g_max", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s P.\n       \\<lbrakk>invar s; rel_of (\\<alpha> s) P \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> g_max s P \\<in> Some ` rel_of (\\<alpha> s) P\n 2. \\<And>s k v P.\n       \\<lbrakk>invar s; (k, v) \\<in> rel_of (\\<alpha> s) P\\<rbrakk>\n       \\<Longrightarrow> k \\<le> fst (the (g_max s P))\n 3. \\<And>s P.\n       \\<lbrakk>invar s; rel_of (\\<alpha> s) P = {}\\<rbrakk>\n       \\<Longrightarrow> g_max s P = None", "fix m P"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s P.\n       \\<lbrakk>invar s; rel_of (\\<alpha> s) P \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> g_max s P \\<in> Some ` rel_of (\\<alpha> s) P\n 2. \\<And>s k v P.\n       \\<lbrakk>invar s; (k, v) \\<in> rel_of (\\<alpha> s) P\\<rbrakk>\n       \\<Longrightarrow> k \\<le> fst (the (g_max s P))\n 3. \\<And>s P.\n       \\<lbrakk>invar s; rel_of (\\<alpha> s) P = {}\\<rbrakk>\n       \\<Longrightarrow> g_max s P = None", "assume I: \"invar m\""], ["proof (state)\nthis:\n  invar m\n\ngoal (3 subgoals):\n 1. \\<And>s P.\n       \\<lbrakk>invar s; rel_of (\\<alpha> s) P \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> g_max s P \\<in> Some ` rel_of (\\<alpha> s) P\n 2. \\<And>s k v P.\n       \\<lbrakk>invar s; (k, v) \\<in> rel_of (\\<alpha> s) P\\<rbrakk>\n       \\<Longrightarrow> k \\<le> fst (the (g_max s P))\n 3. \\<And>s P.\n       \\<lbrakk>invar s; rel_of (\\<alpha> s) P = {}\\<rbrakk>\n       \\<Longrightarrow> g_max s P = None", "from rev_iterateoi_correct[OF I]"], ["proof (chain)\npicking this:\n  map_iterator_rev_linord (reverse_iterateoi m) (\\<alpha> m)", "have iti': \"map_iterator_rev_linord (rev_iterateoi m) (\\<alpha> m)\""], ["proof (prove)\nusing this:\n  map_iterator_rev_linord (reverse_iterateoi m) (\\<alpha> m)\n\ngoal (1 subgoal):\n 1. map_iterator_rev_linord (reverse_iterateoi m) (\\<alpha> m)", "by simp"], ["proof (state)\nthis:\n  map_iterator_rev_linord (reverse_iterateoi m) (\\<alpha> m)\n\ngoal (3 subgoals):\n 1. \\<And>s P.\n       \\<lbrakk>invar s; rel_of (\\<alpha> s) P \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> g_max s P \\<in> Some ` rel_of (\\<alpha> s) P\n 2. \\<And>s k v P.\n       \\<lbrakk>invar s; (k, v) \\<in> rel_of (\\<alpha> s) P\\<rbrakk>\n       \\<Longrightarrow> k \\<le> fst (the (g_max s P))\n 3. \\<And>s P.\n       \\<lbrakk>invar s; rel_of (\\<alpha> s) P = {}\\<rbrakk>\n       \\<Longrightarrow> g_max s P = None", "note sel_correct = iterate_sel_no_map_map_rev_linord_correct[OF iti', of P]"], ["proof (state)\nthis:\n  (iterate_sel_no_map (reverse_iterateoi m) P = None) =\n  (\\<forall>k v. \\<alpha> m k = Some v \\<longrightarrow> \\<not> P (k, v))\n  iterate_sel_no_map (reverse_iterateoi m) P =\n  Some (?k, ?v) \\<Longrightarrow>\n  \\<alpha> m ?k = Some ?v \\<and>\n  P (?k, ?v) \\<and>\n  (\\<forall>k' v'.\n      \\<alpha> m k' = Some v' \\<and> P (k', v') \\<longrightarrow>\n      k' \\<le> ?k)\n\ngoal (3 subgoals):\n 1. \\<And>s P.\n       \\<lbrakk>invar s; rel_of (\\<alpha> s) P \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> g_max s P \\<in> Some ` rel_of (\\<alpha> s) P\n 2. \\<And>s k v P.\n       \\<lbrakk>invar s; (k, v) \\<in> rel_of (\\<alpha> s) P\\<rbrakk>\n       \\<Longrightarrow> k \\<le> fst (the (g_max s P))\n 3. \\<And>s P.\n       \\<lbrakk>invar s; rel_of (\\<alpha> s) P = {}\\<rbrakk>\n       \\<Longrightarrow> g_max s P = None", "have A: \"g_max m P = iterate_sel_no_map (rev_iterateoi m) P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g_max m P = iterate_sel_no_map (reverse_iterateoi m) P", "unfolding g_max_def iterate_sel_no_map_def iterate_sel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. reverse_iterateoi m (\\<lambda>\\<sigma>. \\<sigma> = None)\n     (\\<lambda>x \\<sigma>. if P x then Some x else None) None =\n    reverse_iterateoi m (\\<lambda>\\<sigma>. \\<sigma> = None)\n     (\\<lambda>x \\<sigma>. if P x then Some x else None) None", "by simp"], ["proof (state)\nthis:\n  g_max m P = iterate_sel_no_map (reverse_iterateoi m) P\n\ngoal (3 subgoals):\n 1. \\<And>s P.\n       \\<lbrakk>invar s; rel_of (\\<alpha> s) P \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> g_max s P \\<in> Some ` rel_of (\\<alpha> s) P\n 2. \\<And>s k v P.\n       \\<lbrakk>invar s; (k, v) \\<in> rel_of (\\<alpha> s) P\\<rbrakk>\n       \\<Longrightarrow> k \\<le> fst (the (g_max s P))\n 3. \\<And>s P.\n       \\<lbrakk>invar s; rel_of (\\<alpha> s) P = {}\\<rbrakk>\n       \\<Longrightarrow> g_max s P = None", "{"], ["proof (state)\nthis:\n  g_max m P = iterate_sel_no_map (reverse_iterateoi m) P\n\ngoal (3 subgoals):\n 1. \\<And>s P.\n       \\<lbrakk>invar s; rel_of (\\<alpha> s) P \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> g_max s P \\<in> Some ` rel_of (\\<alpha> s) P\n 2. \\<And>s k v P.\n       \\<lbrakk>invar s; (k, v) \\<in> rel_of (\\<alpha> s) P\\<rbrakk>\n       \\<Longrightarrow> k \\<le> fst (the (g_max s P))\n 3. \\<And>s P.\n       \\<lbrakk>invar s; rel_of (\\<alpha> s) P = {}\\<rbrakk>\n       \\<Longrightarrow> g_max s P = None", "assume \"rel_of (\\<alpha> m) P \\<noteq> {}\""], ["proof (state)\nthis:\n  rel_of (\\<alpha> m) P \\<noteq> {}\n\ngoal (3 subgoals):\n 1. \\<And>s P.\n       \\<lbrakk>invar s; rel_of (\\<alpha> s) P \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> g_max s P \\<in> Some ` rel_of (\\<alpha> s) P\n 2. \\<And>s k v P.\n       \\<lbrakk>invar s; (k, v) \\<in> rel_of (\\<alpha> s) P\\<rbrakk>\n       \\<Longrightarrow> k \\<le> fst (the (g_max s P))\n 3. \\<And>s P.\n       \\<lbrakk>invar s; rel_of (\\<alpha> s) P = {}\\<rbrakk>\n       \\<Longrightarrow> g_max s P = None", "with sel_correct"], ["proof (chain)\npicking this:\n  (iterate_sel_no_map (reverse_iterateoi m) P = None) =\n  (\\<forall>k v. \\<alpha> m k = Some v \\<longrightarrow> \\<not> P (k, v))\n  iterate_sel_no_map (reverse_iterateoi m) P =\n  Some (?k, ?v) \\<Longrightarrow>\n  \\<alpha> m ?k = Some ?v \\<and>\n  P (?k, ?v) \\<and>\n  (\\<forall>k' v'.\n      \\<alpha> m k' = Some v' \\<and> P (k', v') \\<longrightarrow>\n      k' \\<le> ?k)\n  rel_of (\\<alpha> m) P \\<noteq> {}", "show \"g_max m P \\<in> Some ` rel_of (\\<alpha> m) P\""], ["proof (prove)\nusing this:\n  (iterate_sel_no_map (reverse_iterateoi m) P = None) =\n  (\\<forall>k v. \\<alpha> m k = Some v \\<longrightarrow> \\<not> P (k, v))\n  iterate_sel_no_map (reverse_iterateoi m) P =\n  Some (?k, ?v) \\<Longrightarrow>\n  \\<alpha> m ?k = Some ?v \\<and>\n  P (?k, ?v) \\<and>\n  (\\<forall>k' v'.\n      \\<alpha> m k' = Some v' \\<and> P (k', v') \\<longrightarrow>\n      k' \\<le> ?k)\n  rel_of (\\<alpha> m) P \\<noteq> {}\n\ngoal (1 subgoal):\n 1. g_max m P \\<in> Some ` rel_of (\\<alpha> m) P", "unfolding A"], ["proof (prove)\nusing this:\n  (iterate_sel_no_map (reverse_iterateoi m) P = None) =\n  (\\<forall>k v. \\<alpha> m k = Some v \\<longrightarrow> \\<not> P (k, v))\n  iterate_sel_no_map (reverse_iterateoi m) P =\n  Some (?k, ?v) \\<Longrightarrow>\n  \\<alpha> m ?k = Some ?v \\<and>\n  P (?k, ?v) \\<and>\n  (\\<forall>k' v'.\n      \\<alpha> m k' = Some v' \\<and> P (k', v') \\<longrightarrow>\n      k' \\<le> ?k)\n  rel_of (\\<alpha> m) P \\<noteq> {}\n\ngoal (1 subgoal):\n 1. iterate_sel_no_map (reverse_iterateoi m) P\n    \\<in> Some ` rel_of (\\<alpha> m) P", "by (auto simp add: image_iff rel_of_def)"], ["proof (state)\nthis:\n  g_max m P \\<in> Some ` rel_of (\\<alpha> m) P\n\ngoal (2 subgoals):\n 1. \\<And>s k v P.\n       \\<lbrakk>invar s; (k, v) \\<in> rel_of (\\<alpha> s) P\\<rbrakk>\n       \\<Longrightarrow> k \\<le> fst (the (g_max s P))\n 2. \\<And>s P.\n       \\<lbrakk>invar s; rel_of (\\<alpha> s) P = {}\\<rbrakk>\n       \\<Longrightarrow> g_max s P = None", "}"], ["proof (state)\nthis:\n  rel_of (\\<alpha> m) P \\<noteq> {} \\<Longrightarrow>\n  g_max m P \\<in> Some ` rel_of (\\<alpha> m) P\n\ngoal (2 subgoals):\n 1. \\<And>s k v P.\n       \\<lbrakk>invar s; (k, v) \\<in> rel_of (\\<alpha> s) P\\<rbrakk>\n       \\<Longrightarrow> k \\<le> fst (the (g_max s P))\n 2. \\<And>s P.\n       \\<lbrakk>invar s; rel_of (\\<alpha> s) P = {}\\<rbrakk>\n       \\<Longrightarrow> g_max s P = None", "{"], ["proof (state)\nthis:\n  rel_of (\\<alpha> m) P \\<noteq> {} \\<Longrightarrow>\n  g_max m P \\<in> Some ` rel_of (\\<alpha> m) P\n\ngoal (2 subgoals):\n 1. \\<And>s k v P.\n       \\<lbrakk>invar s; (k, v) \\<in> rel_of (\\<alpha> s) P\\<rbrakk>\n       \\<Longrightarrow> k \\<le> fst (the (g_max s P))\n 2. \\<And>s P.\n       \\<lbrakk>invar s; rel_of (\\<alpha> s) P = {}\\<rbrakk>\n       \\<Longrightarrow> g_max s P = None", "assume \"rel_of (\\<alpha> m) P = {}\""], ["proof (state)\nthis:\n  rel_of (\\<alpha> m) P = {}\n\ngoal (2 subgoals):\n 1. \\<And>s k v P.\n       \\<lbrakk>invar s; (k, v) \\<in> rel_of (\\<alpha> s) P\\<rbrakk>\n       \\<Longrightarrow> k \\<le> fst (the (g_max s P))\n 2. \\<And>s P.\n       \\<lbrakk>invar s; rel_of (\\<alpha> s) P = {}\\<rbrakk>\n       \\<Longrightarrow> g_max s P = None", "with sel_correct"], ["proof (chain)\npicking this:\n  (iterate_sel_no_map (reverse_iterateoi m) P = None) =\n  (\\<forall>k v. \\<alpha> m k = Some v \\<longrightarrow> \\<not> P (k, v))\n  iterate_sel_no_map (reverse_iterateoi m) P =\n  Some (?k, ?v) \\<Longrightarrow>\n  \\<alpha> m ?k = Some ?v \\<and>\n  P (?k, ?v) \\<and>\n  (\\<forall>k' v'.\n      \\<alpha> m k' = Some v' \\<and> P (k', v') \\<longrightarrow>\n      k' \\<le> ?k)\n  rel_of (\\<alpha> m) P = {}", "show \"g_max m P = None\""], ["proof (prove)\nusing this:\n  (iterate_sel_no_map (reverse_iterateoi m) P = None) =\n  (\\<forall>k v. \\<alpha> m k = Some v \\<longrightarrow> \\<not> P (k, v))\n  iterate_sel_no_map (reverse_iterateoi m) P =\n  Some (?k, ?v) \\<Longrightarrow>\n  \\<alpha> m ?k = Some ?v \\<and>\n  P (?k, ?v) \\<and>\n  (\\<forall>k' v'.\n      \\<alpha> m k' = Some v' \\<and> P (k', v') \\<longrightarrow>\n      k' \\<le> ?k)\n  rel_of (\\<alpha> m) P = {}\n\ngoal (1 subgoal):\n 1. g_max m P = None", "unfolding A"], ["proof (prove)\nusing this:\n  (iterate_sel_no_map (reverse_iterateoi m) P = None) =\n  (\\<forall>k v. \\<alpha> m k = Some v \\<longrightarrow> \\<not> P (k, v))\n  iterate_sel_no_map (reverse_iterateoi m) P =\n  Some (?k, ?v) \\<Longrightarrow>\n  \\<alpha> m ?k = Some ?v \\<and>\n  P (?k, ?v) \\<and>\n  (\\<forall>k' v'.\n      \\<alpha> m k' = Some v' \\<and> P (k', v') \\<longrightarrow>\n      k' \\<le> ?k)\n  rel_of (\\<alpha> m) P = {}\n\ngoal (1 subgoal):\n 1. iterate_sel_no_map (reverse_iterateoi m) P = None", "by (auto simp add: image_iff rel_of_def)"], ["proof (state)\nthis:\n  g_max m P = None\n\ngoal (1 subgoal):\n 1. \\<And>s k v P.\n       \\<lbrakk>invar s; (k, v) \\<in> rel_of (\\<alpha> s) P\\<rbrakk>\n       \\<Longrightarrow> k \\<le> fst (the (g_max s P))", "}"], ["proof (state)\nthis:\n  rel_of (\\<alpha> m) P = {} \\<Longrightarrow> g_max m P = None\n\ngoal (1 subgoal):\n 1. \\<And>s k v P.\n       \\<lbrakk>invar s; (k, v) \\<in> rel_of (\\<alpha> s) P\\<rbrakk>\n       \\<Longrightarrow> k \\<le> fst (the (g_max s P))", "{"], ["proof (state)\nthis:\n  rel_of (\\<alpha> m) P = {} \\<Longrightarrow> g_max m P = None\n\ngoal (1 subgoal):\n 1. \\<And>s k v P.\n       \\<lbrakk>invar s; (k, v) \\<in> rel_of (\\<alpha> s) P\\<rbrakk>\n       \\<Longrightarrow> k \\<le> fst (the (g_max s P))", "fix k v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s k v P.\n       \\<lbrakk>invar s; (k, v) \\<in> rel_of (\\<alpha> s) P\\<rbrakk>\n       \\<Longrightarrow> k \\<le> fst (the (g_max s P))", "assume \"(k, v) \\<in> rel_of (\\<alpha> m) P\""], ["proof (state)\nthis:\n  (k, v) \\<in> rel_of (\\<alpha> m) P\n\ngoal (1 subgoal):\n 1. \\<And>s k v P.\n       \\<lbrakk>invar s; (k, v) \\<in> rel_of (\\<alpha> s) P\\<rbrakk>\n       \\<Longrightarrow> k \\<le> fst (the (g_max s P))", "with sel_correct"], ["proof (chain)\npicking this:\n  (iterate_sel_no_map (reverse_iterateoi m) P = None) =\n  (\\<forall>k v. \\<alpha> m k = Some v \\<longrightarrow> \\<not> P (k, v))\n  iterate_sel_no_map (reverse_iterateoi m) P =\n  Some (?k, ?v) \\<Longrightarrow>\n  \\<alpha> m ?k = Some ?v \\<and>\n  P (?k, ?v) \\<and>\n  (\\<forall>k' v'.\n      \\<alpha> m k' = Some v' \\<and> P (k', v') \\<longrightarrow>\n      k' \\<le> ?k)\n  (k, v) \\<in> rel_of (\\<alpha> m) P", "show \"fst (the (g_max m P)) \\<ge> k\""], ["proof (prove)\nusing this:\n  (iterate_sel_no_map (reverse_iterateoi m) P = None) =\n  (\\<forall>k v. \\<alpha> m k = Some v \\<longrightarrow> \\<not> P (k, v))\n  iterate_sel_no_map (reverse_iterateoi m) P =\n  Some (?k, ?v) \\<Longrightarrow>\n  \\<alpha> m ?k = Some ?v \\<and>\n  P (?k, ?v) \\<and>\n  (\\<forall>k' v'.\n      \\<alpha> m k' = Some v' \\<and> P (k', v') \\<longrightarrow>\n      k' \\<le> ?k)\n  (k, v) \\<in> rel_of (\\<alpha> m) P\n\ngoal (1 subgoal):\n 1. k \\<le> fst (the (g_max m P))", "unfolding A"], ["proof (prove)\nusing this:\n  (iterate_sel_no_map (reverse_iterateoi m) P = None) =\n  (\\<forall>k v. \\<alpha> m k = Some v \\<longrightarrow> \\<not> P (k, v))\n  iterate_sel_no_map (reverse_iterateoi m) P =\n  Some (?k, ?v) \\<Longrightarrow>\n  \\<alpha> m ?k = Some ?v \\<and>\n  P (?k, ?v) \\<and>\n  (\\<forall>k' v'.\n      \\<alpha> m k' = Some v' \\<and> P (k', v') \\<longrightarrow>\n      k' \\<le> ?k)\n  (k, v) \\<in> rel_of (\\<alpha> m) P\n\ngoal (1 subgoal):\n 1. k \\<le> fst (the (iterate_sel_no_map (reverse_iterateoi m) P))", "by (auto simp add: image_iff rel_of_def)"], ["proof (state)\nthis:\n  k \\<le> fst (the (g_max m P))\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  (?k7, ?v7) \\<in> rel_of (\\<alpha> m) P \\<Longrightarrow>\n  ?k7 \\<le> fst (the (g_max m P))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma g_to_sorted_list_impl: \"map_to_sorted_list \\<alpha> invar g_to_sorted_list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MapSpec.map_to_sorted_list \\<alpha> invar g_to_sorted_list", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>m.\n       invar m \\<Longrightarrow> map_of (g_to_sorted_list m) = \\<alpha> m\n 2. \\<And>m.\n       invar m \\<Longrightarrow> distinct (map fst (g_to_sorted_list m))\n 3. \\<And>m. invar m \\<Longrightarrow> sorted (map fst (g_to_sorted_list m))", "fix m"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>m.\n       invar m \\<Longrightarrow> map_of (g_to_sorted_list m) = \\<alpha> m\n 2. \\<And>m.\n       invar m \\<Longrightarrow> distinct (map fst (g_to_sorted_list m))\n 3. \\<And>m. invar m \\<Longrightarrow> sorted (map fst (g_to_sorted_list m))", "assume I: \"invar m\""], ["proof (state)\nthis:\n  invar m\n\ngoal (3 subgoals):\n 1. \\<And>m.\n       invar m \\<Longrightarrow> map_of (g_to_sorted_list m) = \\<alpha> m\n 2. \\<And>m.\n       invar m \\<Longrightarrow> distinct (map fst (g_to_sorted_list m))\n 3. \\<And>m. invar m \\<Longrightarrow> sorted (map fst (g_to_sorted_list m))", "note iti = rev_iterateoi_correct[OF I]"], ["proof (state)\nthis:\n  map_iterator_rev_linord (reverse_iterateoi m) (\\<alpha> m)\n\ngoal (3 subgoals):\n 1. \\<And>m.\n       invar m \\<Longrightarrow> map_of (g_to_sorted_list m) = \\<alpha> m\n 2. \\<And>m.\n       invar m \\<Longrightarrow> distinct (map fst (g_to_sorted_list m))\n 3. \\<And>m. invar m \\<Longrightarrow> sorted (map fst (g_to_sorted_list m))", "from iterate_to_list_map_rev_linord_correct[OF iti]"], ["proof (chain)\npicking this:\n  map_of (iterate_to_list (reverse_iterateoi m)) = \\<alpha> m \\<and>\n  distinct (map fst (iterate_to_list (reverse_iterateoi m))) \\<and>\n  sorted (map fst (iterate_to_list (reverse_iterateoi m)))", "show \"sorted (map fst (g_to_sorted_list m))\" \n         \"distinct (map fst (g_to_sorted_list m))\"\n         \"map_of (g_to_sorted_list m) = \\<alpha> m\""], ["proof (prove)\nusing this:\n  map_of (iterate_to_list (reverse_iterateoi m)) = \\<alpha> m \\<and>\n  distinct (map fst (iterate_to_list (reverse_iterateoi m))) \\<and>\n  sorted (map fst (iterate_to_list (reverse_iterateoi m)))\n\ngoal (1 subgoal):\n 1. sorted (map fst (g_to_sorted_list m)) &&&\n    distinct (map fst (g_to_sorted_list m)) &&&\n    map_of (g_to_sorted_list m) = \\<alpha> m", "unfolding g_to_sorted_list_def iterate_to_list_def"], ["proof (prove)\nusing this:\n  map_of (reverse_iterateo m (#) []) = \\<alpha> m \\<and>\n  distinct (map fst (reverse_iterateo m (#) [])) \\<and>\n  sorted (map fst (reverse_iterateo m (#) []))\n\ngoal (1 subgoal):\n 1. sorted (map fst (reverse_iterateo m (#) [])) &&&\n    distinct (map fst (reverse_iterateo m (#) [])) &&&\n    map_of (reverse_iterateo m (#) []) = \\<alpha> m", "by simp_all"], ["proof (state)\nthis:\n  sorted (map fst (g_to_sorted_list m))\n  distinct (map fst (g_to_sorted_list m))\n  map_of (g_to_sorted_list m) = \\<alpha> m\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma g_to_rev_list_impl: \"map_to_rev_list \\<alpha> invar g_to_rev_list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_to_rev_list \\<alpha> invar g_to_rev_list", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>m. invar m \\<Longrightarrow> map_of (g_to_rev_list m) = \\<alpha> m\n 2. \\<And>m. invar m \\<Longrightarrow> distinct (map fst (g_to_rev_list m))\n 3. \\<And>m.\n       invar m \\<Longrightarrow> sorted (rev (map fst (g_to_rev_list m)))", "fix m"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>m. invar m \\<Longrightarrow> map_of (g_to_rev_list m) = \\<alpha> m\n 2. \\<And>m. invar m \\<Longrightarrow> distinct (map fst (g_to_rev_list m))\n 3. \\<And>m.\n       invar m \\<Longrightarrow> sorted (rev (map fst (g_to_rev_list m)))", "assume I: \"invar m\""], ["proof (state)\nthis:\n  invar m\n\ngoal (3 subgoals):\n 1. \\<And>m. invar m \\<Longrightarrow> map_of (g_to_rev_list m) = \\<alpha> m\n 2. \\<And>m. invar m \\<Longrightarrow> distinct (map fst (g_to_rev_list m))\n 3. \\<And>m.\n       invar m \\<Longrightarrow> sorted (rev (map fst (g_to_rev_list m)))", "note iti = iterateoi_correct[OF I]"], ["proof (state)\nthis:\n  map_iterator_linord (iterateoi m) (\\<alpha> m)\n\ngoal (3 subgoals):\n 1. \\<And>m. invar m \\<Longrightarrow> map_of (g_to_rev_list m) = \\<alpha> m\n 2. \\<And>m. invar m \\<Longrightarrow> distinct (map fst (g_to_rev_list m))\n 3. \\<And>m.\n       invar m \\<Longrightarrow> sorted (rev (map fst (g_to_rev_list m)))", "from iterate_to_list_map_linord_correct[OF iti]"], ["proof (chain)\npicking this:\n  map_of (iterate_to_list (iterateoi m)) = \\<alpha> m \\<and>\n  distinct (map fst (iterate_to_list (iterateoi m))) \\<and>\n  sorted (map fst (rev (iterate_to_list (iterateoi m))))", "show \"sorted (rev (map fst (g_to_rev_list m)))\" \n         \"distinct (map fst (g_to_rev_list m))\"\n         \"map_of (g_to_rev_list m) = \\<alpha> m\""], ["proof (prove)\nusing this:\n  map_of (iterate_to_list (iterateoi m)) = \\<alpha> m \\<and>\n  distinct (map fst (iterate_to_list (iterateoi m))) \\<and>\n  sorted (map fst (rev (iterate_to_list (iterateoi m))))\n\ngoal (1 subgoal):\n 1. sorted (rev (map fst (g_to_rev_list m))) &&&\n    distinct (map fst (g_to_rev_list m)) &&&\n    map_of (g_to_rev_list m) = \\<alpha> m", "unfolding g_to_rev_list_def iterate_to_list_def"], ["proof (prove)\nusing this:\n  map_of (iterateo m (#) []) = \\<alpha> m \\<and>\n  distinct (map fst (iterateo m (#) [])) \\<and>\n  sorted (map fst (rev (iterateo m (#) [])))\n\ngoal (1 subgoal):\n 1. sorted (rev (map fst (iterateo m (#) []))) &&&\n    distinct (map fst (iterateo m (#) [])) &&&\n    map_of (iterateo m (#) []) = \\<alpha> m", "by (simp_all add: rev_map)"], ["proof (state)\nthis:\n  sorted (rev (map fst (g_to_rev_list m)))\n  distinct (map fst (g_to_rev_list m))\n  map_of (g_to_rev_list m) = \\<alpha> m\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dflt_oops_impl: \"StdOMap dflt_oops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. StdOMap dflt_oops", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. StdOMap dflt_oops", "interpret aux: StdMap dflt_ops"], ["proof (prove)\ngoal (1 subgoal):\n 1. StdMap dflt_ops", "by (rule dflt_ops_impl)"], ["proof (state)\ngoal (1 subgoal):\n 1. StdOMap dflt_oops", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. StdOMap dflt_oops", "apply (rule StdOMap_intro)"], ["proof (prove)\ngoal (25 subgoals):\n 1. map_empty (map_op_\\<alpha> dflt_oops) (map_op_invar dflt_oops)\n     (map_op_empty dflt_oops)\n 2. map_lookup (map_op_\\<alpha> dflt_oops) (map_op_invar dflt_oops)\n     (map_op_lookup dflt_oops)\n 3. map_update (map_op_\\<alpha> dflt_oops) (map_op_invar dflt_oops)\n     (map_op_update dflt_oops)\n 4. map_update_dj (map_op_\\<alpha> dflt_oops) (map_op_invar dflt_oops)\n     (map_op_update_dj dflt_oops)\n 5. map_delete (map_op_\\<alpha> dflt_oops) (map_op_invar dflt_oops)\n     (map_op_delete dflt_oops)\n 6. poly_map_iteratei (map_op_\\<alpha> dflt_oops) (map_op_invar dflt_oops)\n     (map_op_list_it dflt_oops)\n 7. map_sng (map_op_\\<alpha> dflt_oops) (map_op_invar dflt_oops)\n     (map_op_sng dflt_oops)\n 8. map_restrict (map_op_\\<alpha> dflt_oops) (map_op_invar dflt_oops)\n     (map_op_\\<alpha> dflt_oops) (map_op_invar dflt_oops)\n     (map_op_restrict dflt_oops)\n 9. MapSpec.map_add (map_op_\\<alpha> dflt_oops) (map_op_invar dflt_oops)\n     (map_op_add dflt_oops)\n 10. map_add_dj (map_op_\\<alpha> dflt_oops) (map_op_invar dflt_oops)\n      (map_op_add_dj dflt_oops)\nA total of 25 subgoals...", "apply icf_locales"], ["proof (prove)\ngoal (4 subgoals):\n 1. map_min (map_op_\\<alpha> dflt_oops) (map_op_invar dflt_oops)\n     (map_op_min dflt_oops)\n 2. map_max (map_op_\\<alpha> dflt_oops) (map_op_invar dflt_oops)\n     (map_op_max dflt_oops)\n 3. MapSpec.map_to_sorted_list (map_op_\\<alpha> dflt_oops)\n     (map_op_invar dflt_oops) (map_op_to_sorted_list dflt_oops)\n 4. map_to_rev_list (map_op_\\<alpha> dflt_oops) (map_op_invar dflt_oops)\n     (map_op_to_rev_list dflt_oops)", "apply (simp_all add: icf_rec_unf)"], ["proof (prove)\ngoal (4 subgoals):\n 1. map_min \\<alpha> invar g_min\n 2. map_max \\<alpha> invar g_max\n 3. MapSpec.map_to_sorted_list \\<alpha> invar g_to_sorted_list\n 4. map_to_rev_list \\<alpha> invar g_to_rev_list", "apply (rule g_min_impl)"], ["proof (prove)\ngoal (3 subgoals):\n 1. map_max \\<alpha> invar g_max\n 2. MapSpec.map_to_sorted_list \\<alpha> invar g_to_sorted_list\n 3. map_to_rev_list \\<alpha> invar g_to_rev_list", "apply (rule g_max_impl)"], ["proof (prove)\ngoal (2 subgoals):\n 1. MapSpec.map_to_sorted_list \\<alpha> invar g_to_sorted_list\n 2. map_to_rev_list \\<alpha> invar g_to_rev_list", "apply (rule g_to_sorted_list_impl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_to_rev_list \\<alpha> invar g_to_rev_list", "apply (rule g_to_rev_list_impl)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  StdOMap dflt_oops\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "locale g_image_filter_defs_loc = \n  m1: StdMapDefs ops1 + \n  m2: StdMapDefs ops2\n  for ops1 :: \"('k1,'v1,'s1,'m1) map_ops_scheme\"\n  and ops2 :: \"('k2,'v2,'s2,'m2) map_ops_scheme\"\nbegin"], ["", "definition \"g_image_filter f m1 \\<equiv> m1.iterate m1 (\\<lambda>kv \\<sigma>. case f kv of \n      None => \\<sigma>\n    | Some (k',v') => m2.update_dj k' v' \\<sigma>\n    ) (m2.empty ())\""], ["", "end"], ["", "locale g_image_filter_loc = g_image_filter_defs_loc ops1 ops2 + \n  m1: StdMap ops1 + \n  m2: StdMap ops2\n  for ops1 :: \"('k1,'v1,'s1,'m1) map_ops_scheme\"\n  and ops2 :: \"('k2,'v2,'s2,'m2) map_ops_scheme\"\nbegin"], ["", "lemma g_image_filter_impl: \n    \"map_image_filter m1.\\<alpha> m1.invar m2.\\<alpha> m2.invar g_image_filter\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_image_filter m1.\\<alpha> m1.invar m2.\\<alpha> m2.invar\n     g_image_filter", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m f k' v'.\n       \\<lbrakk>m1.invar m;\n        transforms_to_unique_keys (m1.\\<alpha> m) f\\<rbrakk>\n       \\<Longrightarrow> m2.invar (g_image_filter f m) \\<and>\n                         (m2.\\<alpha> (g_image_filter f m) k' = Some v') =\n                         (\\<exists>k v.\n                             m1.\\<alpha> m k = Some v \\<and>\n                             f (k, v) = Some (k', v'))", "fix m k' v' and f :: \"('k1 \\<times> 'v1) \\<Rightarrow> ('k2 \\<times> 'v2) option\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m f k' v'.\n       \\<lbrakk>m1.invar m;\n        transforms_to_unique_keys (m1.\\<alpha> m) f\\<rbrakk>\n       \\<Longrightarrow> m2.invar (g_image_filter f m) \\<and>\n                         (m2.\\<alpha> (g_image_filter f m) k' = Some v') =\n                         (\\<exists>k v.\n                             m1.\\<alpha> m k = Some v \\<and>\n                             f (k, v) = Some (k', v'))", "assume invar_m: \"m1.invar m\" and\n           unique_f: \"transforms_to_unique_keys (m1.\\<alpha> m) f\""], ["proof (state)\nthis:\n  m1.invar m\n  transforms_to_unique_keys (m1.\\<alpha> m) f\n\ngoal (1 subgoal):\n 1. \\<And>m f k' v'.\n       \\<lbrakk>m1.invar m;\n        transforms_to_unique_keys (m1.\\<alpha> m) f\\<rbrakk>\n       \\<Longrightarrow> m2.invar (g_image_filter f m) \\<and>\n                         (m2.\\<alpha> (g_image_filter f m) k' = Some v') =\n                         (\\<exists>k v.\n                             m1.\\<alpha> m k = Some v \\<and>\n                             f (k, v) = Some (k', v'))", "have A: \"g_image_filter f m = \n      iterate_to_map m2.empty m2.update_dj (\n        set_iterator_image_filter f (m1.iteratei m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g_image_filter f m =\n    iterate_to_map m2.empty m2.update_dj\n     (set_iterator_image_filter f (m1.iteratei m))", "unfolding g_image_filter_def iterate_to_map_alt_def \n        set_iterator_image_filter_def case_prod_beta"], ["proof (prove)\ngoal (1 subgoal):\n 1. m1.iterate m\n     (\\<lambda>kv \\<sigma>.\n         case f kv of None \\<Rightarrow> \\<sigma>\n         | Some a \\<Rightarrow> m2.update_dj (fst a) (snd a) \\<sigma>)\n     (m2.empty ()) =\n    m1.iterate m\n     (\\<lambda>x \\<sigma>.\n         case f x of None \\<Rightarrow> \\<sigma>\n         | Some x' \\<Rightarrow> m2.update_dj (fst x') (snd x') \\<sigma>)\n     (m2.empty ())", "by simp"], ["proof (state)\nthis:\n  g_image_filter f m =\n  iterate_to_map m2.empty m2.update_dj\n   (set_iterator_image_filter f (m1.iteratei m))\n\ngoal (1 subgoal):\n 1. \\<And>m f k' v'.\n       \\<lbrakk>m1.invar m;\n        transforms_to_unique_keys (m1.\\<alpha> m) f\\<rbrakk>\n       \\<Longrightarrow> m2.invar (g_image_filter f m) \\<and>\n                         (m2.\\<alpha> (g_image_filter f m) k' = Some v') =\n                         (\\<exists>k v.\n                             m1.\\<alpha> m k = Some v \\<and>\n                             f (k, v) = Some (k', v'))", "from m1.iteratei_correct[OF invar_m]"], ["proof (chain)\npicking this:\n  map_iterator (m1.iteratei m) (m1.\\<alpha> m)", "have iti_m: \"map_iterator (m1.iteratei m) (m1.\\<alpha> m)\""], ["proof (prove)\nusing this:\n  map_iterator (m1.iteratei m) (m1.\\<alpha> m)\n\ngoal (1 subgoal):\n 1. map_iterator (m1.iteratei m) (m1.\\<alpha> m)", "by simp"], ["proof (state)\nthis:\n  map_iterator (m1.iteratei m) (m1.\\<alpha> m)\n\ngoal (1 subgoal):\n 1. \\<And>m f k' v'.\n       \\<lbrakk>m1.invar m;\n        transforms_to_unique_keys (m1.\\<alpha> m) f\\<rbrakk>\n       \\<Longrightarrow> m2.invar (g_image_filter f m) \\<and>\n                         (m2.\\<alpha> (g_image_filter f m) k' = Some v') =\n                         (\\<exists>k v.\n                             m1.\\<alpha> m k = Some v \\<and>\n                             f (k, v) = Some (k', v'))", "from unique_f"], ["proof (chain)\npicking this:\n  transforms_to_unique_keys (m1.\\<alpha> m) f", "have inj_on_f: \"inj_on f (map_to_set (m1.\\<alpha> m) \\<inter> dom f)\""], ["proof (prove)\nusing this:\n  transforms_to_unique_keys (m1.\\<alpha> m) f\n\ngoal (1 subgoal):\n 1. inj_on f (map_to_set (m1.\\<alpha> m) \\<inter> dom f)", "unfolding transforms_to_unique_keys_def inj_on_def Ball_def map_to_set_def"], ["proof (prove)\nusing this:\n  \\<forall>k1 k2 v1 v2 k' v1' v2'.\n     m1.\\<alpha> m k1 = Some v1 \\<and>\n     m1.\\<alpha> m k2 = Some v2 \\<and>\n     f (k1, v1) = Some (k', v1') \\<and>\n     f (k2, v2) = Some (k', v2') \\<longrightarrow>\n     k1 = k2\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       x \\<in> {(k, v). m1.\\<alpha> m k = Some v} \\<inter>\n               dom f \\<longrightarrow>\n       (\\<forall>xa.\n           xa \\<in> {(k, v). m1.\\<alpha> m k = Some v} \\<inter>\n                    dom f \\<longrightarrow>\n           f x = f xa \\<longrightarrow> x = xa)", "by auto (metis option.inject)"], ["proof (state)\nthis:\n  inj_on f (map_to_set (m1.\\<alpha> m) \\<inter> dom f)\n\ngoal (1 subgoal):\n 1. \\<And>m f k' v'.\n       \\<lbrakk>m1.invar m;\n        transforms_to_unique_keys (m1.\\<alpha> m) f\\<rbrakk>\n       \\<Longrightarrow> m2.invar (g_image_filter f m) \\<and>\n                         (m2.\\<alpha> (g_image_filter f m) k' = Some v') =\n                         (\\<exists>k v.\n                             m1.\\<alpha> m k = Some v \\<and>\n                             f (k, v) = Some (k', v'))", "define vP where \"vP k v \\<longleftrightarrow> (\\<exists>k' v'. m1.\\<alpha> m k' = Some v' \\<and> f (k', v') = Some (k, v))\" for k v"], ["proof (state)\nthis:\n  vP ?k ?v =\n  (\\<exists>k' v'.\n      m1.\\<alpha> m k' = Some v' \\<and> f (k', v') = Some (?k, ?v))\n\ngoal (1 subgoal):\n 1. \\<And>m f k' v'.\n       \\<lbrakk>m1.invar m;\n        transforms_to_unique_keys (m1.\\<alpha> m) f\\<rbrakk>\n       \\<Longrightarrow> m2.invar (g_image_filter f m) \\<and>\n                         (m2.\\<alpha> (g_image_filter f m) k' = Some v') =\n                         (\\<exists>k v.\n                             m1.\\<alpha> m k = Some v \\<and>\n                             f (k, v) = Some (k', v'))", "have vP_intro: \"\\<And>k v. (\\<exists>k' v'. m1.\\<alpha> m k' = Some v' \n        \\<and> f (k', v') = Some (k, v)) \\<longleftrightarrow> vP k v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k v.\n       (\\<exists>k' v'.\n           m1.\\<alpha> m k' = Some v' \\<and> f (k', v') = Some (k, v)) =\n       vP k v", "unfolding vP_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k v.\n       (\\<exists>k' v'.\n           m1.\\<alpha> m k' = Some v' \\<and> f (k', v') = Some (k, v)) =\n       (\\<exists>k' v'.\n           m1.\\<alpha> m k' = Some v' \\<and> f (k', v') = Some (k, v))", "by simp"], ["proof (state)\nthis:\n  (\\<exists>k' v'.\n      m1.\\<alpha> m k' = Some v' \\<and> f (k', v') = Some (?k3, ?v3)) =\n  vP ?k3 ?v3\n\ngoal (1 subgoal):\n 1. \\<And>m f k' v'.\n       \\<lbrakk>m1.invar m;\n        transforms_to_unique_keys (m1.\\<alpha> m) f\\<rbrakk>\n       \\<Longrightarrow> m2.invar (g_image_filter f m) \\<and>\n                         (m2.\\<alpha> (g_image_filter f m) k' = Some v') =\n                         (\\<exists>k v.\n                             m1.\\<alpha> m k = Some v \\<and>\n                             f (k, v) = Some (k', v'))", "{"], ["proof (state)\nthis:\n  (\\<exists>k' v'.\n      m1.\\<alpha> m k' = Some v' \\<and> f (k', v') = Some (?k3, ?v3)) =\n  vP ?k3 ?v3\n\ngoal (1 subgoal):\n 1. \\<And>m f k' v'.\n       \\<lbrakk>m1.invar m;\n        transforms_to_unique_keys (m1.\\<alpha> m) f\\<rbrakk>\n       \\<Longrightarrow> m2.invar (g_image_filter f m) \\<and>\n                         (m2.\\<alpha> (g_image_filter f m) k' = Some v') =\n                         (\\<exists>k v.\n                             m1.\\<alpha> m k = Some v \\<and>\n                             f (k, v) = Some (k', v'))", "fix k v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m f k' v'.\n       \\<lbrakk>m1.invar m;\n        transforms_to_unique_keys (m1.\\<alpha> m) f\\<rbrakk>\n       \\<Longrightarrow> m2.invar (g_image_filter f m) \\<and>\n                         (m2.\\<alpha> (g_image_filter f m) k' = Some v') =\n                         (\\<exists>k v.\n                             m1.\\<alpha> m k = Some v \\<and>\n                             f (k, v) = Some (k', v'))", "have \"Eps_Opt (vP k) = Some v \\<longleftrightarrow> vP k v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Eps_Opt (vP k) = Some v) = vP k v", "using unique_f"], ["proof (prove)\nusing this:\n  transforms_to_unique_keys (m1.\\<alpha> m) f\n\ngoal (1 subgoal):\n 1. (Eps_Opt (vP k) = Some v) = vP k v", "unfolding vP_def transforms_to_unique_keys_def"], ["proof (prove)\nusing this:\n  \\<forall>k1 k2 v1 v2 k' v1' v2'.\n     m1.\\<alpha> m k1 = Some v1 \\<and>\n     m1.\\<alpha> m k2 = Some v2 \\<and>\n     f (k1, v1) = Some (k', v1') \\<and>\n     f (k2, v2) = Some (k', v2') \\<longrightarrow>\n     k1 = k2\n\ngoal (1 subgoal):\n 1. (Eps_Opt\n      (\\<lambda>v.\n          \\<exists>k' v'.\n             m1.\\<alpha> m k' = Some v' \\<and> f (k', v') = Some (k, v)) =\n     Some v) =\n    (\\<exists>k' v'.\n        m1.\\<alpha> m k' = Some v' \\<and> f (k', v') = Some (k, v))", "apply (rule_tac Eps_Opt_eq_Some)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x'.\n       \\<lbrakk>\\<forall>k1 k2 v1 v2 k' v1' v2'.\n                   m1.\\<alpha> m k1 = Some v1 \\<and>\n                   m1.\\<alpha> m k2 = Some v2 \\<and>\n                   f (k1, v1) = Some (k', v1') \\<and>\n                   f (k2, v2) = Some (k', v2') \\<longrightarrow>\n                   k1 = k2;\n        \\<exists>k' v'.\n           m1.\\<alpha> m k' = Some v' \\<and> f (k', v') = Some (k, v);\n        \\<exists>k' v'.\n           m1.\\<alpha> m k' = Some v' \\<and>\n           f (k', v') = Some (k, x')\\<rbrakk>\n       \\<Longrightarrow> x' = v", "apply (metis prod.inject option.inject)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (Eps_Opt (vP k) = Some v) = vP k v\n\ngoal (1 subgoal):\n 1. \\<And>m f k' v'.\n       \\<lbrakk>m1.invar m;\n        transforms_to_unique_keys (m1.\\<alpha> m) f\\<rbrakk>\n       \\<Longrightarrow> m2.invar (g_image_filter f m) \\<and>\n                         (m2.\\<alpha> (g_image_filter f m) k' = Some v') =\n                         (\\<exists>k v.\n                             m1.\\<alpha> m k = Some v \\<and>\n                             f (k, v) = Some (k', v'))", "}"], ["proof (state)\nthis:\n  (Eps_Opt (vP ?k5) = Some ?v5) = vP ?k5 ?v5\n\ngoal (1 subgoal):\n 1. \\<And>m f k' v'.\n       \\<lbrakk>m1.invar m;\n        transforms_to_unique_keys (m1.\\<alpha> m) f\\<rbrakk>\n       \\<Longrightarrow> m2.invar (g_image_filter f m) \\<and>\n                         (m2.\\<alpha> (g_image_filter f m) k' = Some v') =\n                         (\\<exists>k v.\n                             m1.\\<alpha> m k = Some v \\<and>\n                             f (k, v) = Some (k', v'))", "note Eps_vP_elim[simp] = this"], ["proof (state)\nthis:\n  (Eps_Opt (vP ?k5) = Some ?v5) = vP ?k5 ?v5\n\ngoal (1 subgoal):\n 1. \\<And>m f k' v'.\n       \\<lbrakk>m1.invar m;\n        transforms_to_unique_keys (m1.\\<alpha> m) f\\<rbrakk>\n       \\<Longrightarrow> m2.invar (g_image_filter f m) \\<and>\n                         (m2.\\<alpha> (g_image_filter f m) k' = Some v') =\n                         (\\<exists>k v.\n                             m1.\\<alpha> m k = Some v \\<and>\n                             f (k, v) = Some (k', v'))", "have map_intro: \"{y. \\<exists>x. x \\<in> map_to_set (m1.\\<alpha> m) \\<and> f x = Some y} \n      = map_to_set (\\<lambda>k. Eps_Opt (vP k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {y. \\<exists>x.\n           x \\<in> map_to_set (m1.\\<alpha> m) \\<and> f x = Some y} =\n    map_to_set (\\<lambda>k. Eps_Opt (vP k))", "by (simp add: map_to_set_def vP_intro set_eq_iff split: prod.splits)"], ["proof (state)\nthis:\n  {y. \\<exists>x. x \\<in> map_to_set (m1.\\<alpha> m) \\<and> f x = Some y} =\n  map_to_set (\\<lambda>k. Eps_Opt (vP k))\n\ngoal (1 subgoal):\n 1. \\<And>m f k' v'.\n       \\<lbrakk>m1.invar m;\n        transforms_to_unique_keys (m1.\\<alpha> m) f\\<rbrakk>\n       \\<Longrightarrow> m2.invar (g_image_filter f m) \\<and>\n                         (m2.\\<alpha> (g_image_filter f m) k' = Some v') =\n                         (\\<exists>k v.\n                             m1.\\<alpha> m k = Some v \\<and>\n                             f (k, v) = Some (k', v'))", "from set_iterator_image_filter_correct [OF iti_m, OF inj_on_f, \n      unfolded map_intro]"], ["proof (chain)\npicking this:\n  map_iterator (set_iterator_image_filter f (m1.iteratei m))\n   (\\<lambda>k. Eps_Opt (vP k))", "have iti_filter: \"map_iterator (set_iterator_image_filter f (m1.iteratei m))\n          (\\<lambda>k. Eps_Opt (vP k))\""], ["proof (prove)\nusing this:\n  map_iterator (set_iterator_image_filter f (m1.iteratei m))\n   (\\<lambda>k. Eps_Opt (vP k))\n\ngoal (1 subgoal):\n 1. map_iterator (set_iterator_image_filter f (m1.iteratei m))\n     (\\<lambda>k. Eps_Opt (vP k))", "by auto"], ["proof (state)\nthis:\n  map_iterator (set_iterator_image_filter f (m1.iteratei m))\n   (\\<lambda>k. Eps_Opt (vP k))\n\ngoal (1 subgoal):\n 1. \\<And>m f k' v'.\n       \\<lbrakk>m1.invar m;\n        transforms_to_unique_keys (m1.\\<alpha> m) f\\<rbrakk>\n       \\<Longrightarrow> m2.invar (g_image_filter f m) \\<and>\n                         (m2.\\<alpha> (g_image_filter f m) k' = Some v') =\n                         (\\<exists>k v.\n                             m1.\\<alpha> m k = Some v \\<and>\n                             f (k, v) = Some (k', v'))", "have upd: \"map_update_dj m2.\\<alpha> m2.invar m2.update_dj\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_update_dj m2.\\<alpha> m2.invar m2.update_dj", "by unfold_locales"], ["proof (state)\nthis:\n  map_update_dj m2.\\<alpha> m2.invar m2.update_dj\n\ngoal (1 subgoal):\n 1. \\<And>m f k' v'.\n       \\<lbrakk>m1.invar m;\n        transforms_to_unique_keys (m1.\\<alpha> m) f\\<rbrakk>\n       \\<Longrightarrow> m2.invar (g_image_filter f m) \\<and>\n                         (m2.\\<alpha> (g_image_filter f m) k' = Some v') =\n                         (\\<exists>k v.\n                             m1.\\<alpha> m k = Some v \\<and>\n                             f (k, v) = Some (k', v'))", "have emp: \"map_empty m2.\\<alpha> m2.invar m2.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_empty m2.\\<alpha> m2.invar m2.empty", "by unfold_locales"], ["proof (state)\nthis:\n  map_empty m2.\\<alpha> m2.invar m2.empty\n\ngoal (1 subgoal):\n 1. \\<And>m f k' v'.\n       \\<lbrakk>m1.invar m;\n        transforms_to_unique_keys (m1.\\<alpha> m) f\\<rbrakk>\n       \\<Longrightarrow> m2.invar (g_image_filter f m) \\<and>\n                         (m2.\\<alpha> (g_image_filter f m) k' = Some v') =\n                         (\\<exists>k v.\n                             m1.\\<alpha> m k = Some v \\<and>\n                             f (k, v) = Some (k', v'))", "from iterate_to_map_correct[OF upd emp iti_filter]"], ["proof (chain)\npicking this:\n  m2.\\<alpha>\n   (iterate_to_map m2.empty m2.update_dj\n     (set_iterator_image_filter f (m1.iteratei m))) =\n  (\\<lambda>k. Eps_Opt (vP k)) \\<and>\n  m2.invar\n   (iterate_to_map m2.empty m2.update_dj\n     (set_iterator_image_filter f (m1.iteratei m)))", "show\n      \"map_op_invar ops2 (g_image_filter f m) \\<and>\n          (map_op_\\<alpha> ops2 (g_image_filter f m) k' = Some v') =\n          (\\<exists>k v. map_op_\\<alpha> ops1 m k = Some v \\<and> f (k, v) = Some (k', v'))\""], ["proof (prove)\nusing this:\n  m2.\\<alpha>\n   (iterate_to_map m2.empty m2.update_dj\n     (set_iterator_image_filter f (m1.iteratei m))) =\n  (\\<lambda>k. Eps_Opt (vP k)) \\<and>\n  m2.invar\n   (iterate_to_map m2.empty m2.update_dj\n     (set_iterator_image_filter f (m1.iteratei m)))\n\ngoal (1 subgoal):\n 1. m2.invar (g_image_filter f m) \\<and>\n    (m2.\\<alpha> (g_image_filter f m) k' = Some v') =\n    (\\<exists>k v. m1.\\<alpha> m k = Some v \\<and> f (k, v) = Some (k', v'))", "unfolding A vP_def[symmetric]"], ["proof (prove)\nusing this:\n  m2.\\<alpha>\n   (iterate_to_map m2.empty m2.update_dj\n     (set_iterator_image_filter f (m1.iteratei m))) =\n  (\\<lambda>k. Eps_Opt (vP k)) \\<and>\n  m2.invar\n   (iterate_to_map m2.empty m2.update_dj\n     (set_iterator_image_filter f (m1.iteratei m)))\n\ngoal (1 subgoal):\n 1. m2.invar\n     (iterate_to_map m2.empty m2.update_dj\n       (set_iterator_image_filter f (m1.iteratei m))) \\<and>\n    (m2.\\<alpha>\n      (iterate_to_map m2.empty m2.update_dj\n        (set_iterator_image_filter f (m1.iteratei m)))\n      k' =\n     Some v') =\n    vP k' v'", "by (simp add: vP_intro)"], ["proof (state)\nthis:\n  m2.invar (g_image_filter f m) \\<and>\n  (m2.\\<alpha> (g_image_filter f m) k' = Some v') =\n  (\\<exists>k v. m1.\\<alpha> m k = Some v \\<and> f (k, v) = Some (k', v'))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "sublocale g_image_filter_loc \n  < map_image_filter m1.\\<alpha> m1.invar m2.\\<alpha> m2.invar g_image_filter"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_image_filter m1.\\<alpha> m1.invar m2.\\<alpha> m2.invar\n     g_image_filter", "by (rule g_image_filter_impl)"], ["", "locale g_value_image_filter_defs_loc = \n  m1: StdMapDefs ops1 + \n  m2: StdMapDefs ops2\n  for ops1 :: \"('k,'v1,'s1,'m1) map_ops_scheme\"\n  and ops2 :: \"('k,'v2,'s2,'m2) map_ops_scheme\"\nbegin"], ["", "definition \"g_value_image_filter f m1 \\<equiv> m1.iterate m1 (\\<lambda>(k,v) \\<sigma>. \n    case f k v of \n      None => \\<sigma>\n    | Some v' => m2.update_dj k v' \\<sigma>\n    ) (m2.empty ())\""], ["", "end"], ["", "(* TODO: Move to Misc *)"], ["", "lemma restrict_map_dom_subset: \"\\<lbrakk> dom m \\<subseteq> R\\<rbrakk> \\<Longrightarrow> m|`R = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom m \\<subseteq> R \\<Longrightarrow> m |` R = m", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. dom m \\<subseteq> R \\<Longrightarrow> (m |` R) x = m x", "apply (auto simp: restrict_map_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>dom m \\<subseteq> R; x \\<notin> R\\<rbrakk>\n       \\<Longrightarrow> None = m x", "apply (case_tac \"m x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>dom m \\<subseteq> R; x \\<notin> R; m x = None\\<rbrakk>\n       \\<Longrightarrow> None = m x\n 2. \\<And>x a.\n       \\<lbrakk>dom m \\<subseteq> R; x \\<notin> R; m x = Some a\\<rbrakk>\n       \\<Longrightarrow> None = m x", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "locale g_value_image_filter_loc = g_value_image_filter_defs_loc ops1 ops2 + \n  m1: StdMap ops1 + \n  m2: StdMap ops2\n  for ops1 :: \"('k,'v1,'s1,'m1) map_ops_scheme\"\n  and ops2 :: \"('k,'v2,'s2,'m2) map_ops_scheme\"\nbegin"], ["", "lemma g_value_image_filter_impl: \n    \"map_value_image_filter m1.\\<alpha> m1.invar m2.\\<alpha> m2.invar g_value_image_filter\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_value_image_filter m1.\\<alpha> m1.invar m2.\\<alpha> m2.invar\n     g_value_image_filter", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m f.\n       m1.invar m \\<Longrightarrow>\n       m2.invar (g_value_image_filter f m) \\<and>\n       m2.\\<alpha> (g_value_image_filter f m) =\n       (\\<lambda>k. m1.\\<alpha> m k \\<bind> f k)", "unfolding g_value_image_filter_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m f.\n       m1.invar m \\<Longrightarrow>\n       m2.invar\n        (m1.iterate m\n          (\\<lambda>(k, v) \\<sigma>.\n              case f k v of None \\<Rightarrow> \\<sigma>\n              | Some v' \\<Rightarrow> m2.update_dj k v' \\<sigma>)\n          (m2.empty ())) \\<and>\n       m2.\\<alpha>\n        (m1.iterate m\n          (\\<lambda>(k, v) \\<sigma>.\n              case f k v of None \\<Rightarrow> \\<sigma>\n              | Some v' \\<Rightarrow> m2.update_dj k v' \\<sigma>)\n          (m2.empty ())) =\n       (\\<lambda>k. m1.\\<alpha> m k \\<bind> f k)", "apply (rule_tac I=\"\\<lambda>it \\<sigma>. m2.invar \\<sigma> \n      \\<and> m2.\\<alpha> \\<sigma> = (\\<lambda>k. Option.bind (map_op_\\<alpha> ops1 m k) (f k)) |` it\"\n      in m1.old_iterate_rule_insert_P)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>m f. m1.invar m \\<Longrightarrow> m1.invar m\n 2. \\<And>m f.\n       m1.invar m \\<Longrightarrow>\n       m2.invar (m2.empty ()) \\<and>\n       m2.\\<alpha> (m2.empty ()) =\n       (\\<lambda>k. m1.\\<alpha> m k \\<bind> f k) |` {}\n 3. \\<And>m f k v it \\<sigma>.\n       \\<lbrakk>m1.invar m; k \\<in> dom (m1.\\<alpha> m) - it;\n        m1.\\<alpha> m k = Some v; it \\<subseteq> dom (m1.\\<alpha> m);\n        m2.invar \\<sigma> \\<and>\n        m2.\\<alpha> \\<sigma> =\n        (\\<lambda>k. m1.\\<alpha> m k \\<bind> f k) |` it\\<rbrakk>\n       \\<Longrightarrow> m2.invar\n                          ((case (k, v) of\n                            (k, v) \\<Rightarrow>\n                              \\<lambda>\\<sigma>.\n                                 case f k v of None \\<Rightarrow> \\<sigma>\n                                 | Some v' \\<Rightarrow>\n                                     m2.update_dj k v' \\<sigma>)\n                            \\<sigma>) \\<and>\n                         m2.\\<alpha>\n                          ((case (k, v) of\n                            (k, v) \\<Rightarrow>\n                              \\<lambda>\\<sigma>.\n                                 case f k v of None \\<Rightarrow> \\<sigma>\n                                 | Some v' \\<Rightarrow>\n                                     m2.update_dj k v' \\<sigma>)\n                            \\<sigma>) =\n                         (\\<lambda>k. m1.\\<alpha> m k \\<bind> f k) |`\n                         insert k it\n 4. \\<And>m f \\<sigma>.\n       \\<lbrakk>m1.invar m;\n        m2.invar \\<sigma> \\<and>\n        m2.\\<alpha> \\<sigma> =\n        (\\<lambda>k. m1.\\<alpha> m k \\<bind> f k) |`\n        dom (m1.\\<alpha> m)\\<rbrakk>\n       \\<Longrightarrow> m2.invar \\<sigma> \\<and>\n                         m2.\\<alpha> \\<sigma> =\n                         (\\<lambda>k. m1.\\<alpha> m k \\<bind> f k)", "apply auto []"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>m f.\n       m1.invar m \\<Longrightarrow>\n       m2.invar (m2.empty ()) \\<and>\n       m2.\\<alpha> (m2.empty ()) =\n       (\\<lambda>k. m1.\\<alpha> m k \\<bind> f k) |` {}\n 2. \\<And>m f k v it \\<sigma>.\n       \\<lbrakk>m1.invar m; k \\<in> dom (m1.\\<alpha> m) - it;\n        m1.\\<alpha> m k = Some v; it \\<subseteq> dom (m1.\\<alpha> m);\n        m2.invar \\<sigma> \\<and>\n        m2.\\<alpha> \\<sigma> =\n        (\\<lambda>k. m1.\\<alpha> m k \\<bind> f k) |` it\\<rbrakk>\n       \\<Longrightarrow> m2.invar\n                          ((case (k, v) of\n                            (k, v) \\<Rightarrow>\n                              \\<lambda>\\<sigma>.\n                                 case f k v of None \\<Rightarrow> \\<sigma>\n                                 | Some v' \\<Rightarrow>\n                                     m2.update_dj k v' \\<sigma>)\n                            \\<sigma>) \\<and>\n                         m2.\\<alpha>\n                          ((case (k, v) of\n                            (k, v) \\<Rightarrow>\n                              \\<lambda>\\<sigma>.\n                                 case f k v of None \\<Rightarrow> \\<sigma>\n                                 | Some v' \\<Rightarrow>\n                                     m2.update_dj k v' \\<sigma>)\n                            \\<sigma>) =\n                         (\\<lambda>k. m1.\\<alpha> m k \\<bind> f k) |`\n                         insert k it\n 3. \\<And>m f \\<sigma>.\n       \\<lbrakk>m1.invar m;\n        m2.invar \\<sigma> \\<and>\n        m2.\\<alpha> \\<sigma> =\n        (\\<lambda>k. m1.\\<alpha> m k \\<bind> f k) |`\n        dom (m1.\\<alpha> m)\\<rbrakk>\n       \\<Longrightarrow> m2.invar \\<sigma> \\<and>\n                         m2.\\<alpha> \\<sigma> =\n                         (\\<lambda>k. m1.\\<alpha> m k \\<bind> f k)", "apply (auto simp: m2.empty_correct) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m f k v it \\<sigma>.\n       \\<lbrakk>m1.invar m; k \\<in> dom (m1.\\<alpha> m) - it;\n        m1.\\<alpha> m k = Some v; it \\<subseteq> dom (m1.\\<alpha> m);\n        m2.invar \\<sigma> \\<and>\n        m2.\\<alpha> \\<sigma> =\n        (\\<lambda>k. m1.\\<alpha> m k \\<bind> f k) |` it\\<rbrakk>\n       \\<Longrightarrow> m2.invar\n                          ((case (k, v) of\n                            (k, v) \\<Rightarrow>\n                              \\<lambda>\\<sigma>.\n                                 case f k v of None \\<Rightarrow> \\<sigma>\n                                 | Some v' \\<Rightarrow>\n                                     m2.update_dj k v' \\<sigma>)\n                            \\<sigma>) \\<and>\n                         m2.\\<alpha>\n                          ((case (k, v) of\n                            (k, v) \\<Rightarrow>\n                              \\<lambda>\\<sigma>.\n                                 case f k v of None \\<Rightarrow> \\<sigma>\n                                 | Some v' \\<Rightarrow>\n                                     m2.update_dj k v' \\<sigma>)\n                            \\<sigma>) =\n                         (\\<lambda>k. m1.\\<alpha> m k \\<bind> f k) |`\n                         insert k it\n 2. \\<And>m f \\<sigma>.\n       \\<lbrakk>m1.invar m;\n        m2.invar \\<sigma> \\<and>\n        m2.\\<alpha> \\<sigma> =\n        (\\<lambda>k. m1.\\<alpha> m k \\<bind> f k) |`\n        dom (m1.\\<alpha> m)\\<rbrakk>\n       \\<Longrightarrow> m2.invar \\<sigma> \\<and>\n                         m2.\\<alpha> \\<sigma> =\n                         (\\<lambda>k. m1.\\<alpha> m k \\<bind> f k)", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m f \\<sigma>.\n       \\<lbrakk>m1.invar m;\n        m2.invar \\<sigma> \\<and>\n        m2.\\<alpha> \\<sigma> =\n        (\\<lambda>k. m1.\\<alpha> m k \\<bind> f k) |`\n        dom (m1.\\<alpha> m)\\<rbrakk>\n       \\<Longrightarrow> m2.invar \\<sigma> \\<and>\n                         m2.\\<alpha> \\<sigma> =\n                         (\\<lambda>k. m1.\\<alpha> m k \\<bind> f k)\n 2. \\<And>m f k v it \\<sigma>.\n       \\<lbrakk>m1.invar m; k \\<in> dom (m1.\\<alpha> m) - it;\n        m1.\\<alpha> m k = Some v; it \\<subseteq> dom (m1.\\<alpha> m);\n        m2.invar \\<sigma> \\<and>\n        m2.\\<alpha> \\<sigma> =\n        (\\<lambda>k. m1.\\<alpha> m k \\<bind> f k) |` it\\<rbrakk>\n       \\<Longrightarrow> m2.invar\n                          ((case (k, v) of\n                            (k, v) \\<Rightarrow>\n                              \\<lambda>\\<sigma>.\n                                 case f k v of None \\<Rightarrow> \\<sigma>\n                                 | Some v' \\<Rightarrow>\n                                     m2.update_dj k v' \\<sigma>)\n                            \\<sigma>) \\<and>\n                         m2.\\<alpha>\n                          ((case (k, v) of\n                            (k, v) \\<Rightarrow>\n                              \\<lambda>\\<sigma>.\n                                 case f k v of None \\<Rightarrow> \\<sigma>\n                                 | Some v' \\<Rightarrow>\n                                     m2.update_dj k v' \\<sigma>)\n                            \\<sigma>) =\n                         (\\<lambda>k. m1.\\<alpha> m k \\<bind> f k) |`\n                         insert k it", "apply simp []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m f \\<sigma>.\n       \\<lbrakk>m1.invar m;\n        m2.invar \\<sigma> \\<and>\n        m2.\\<alpha> \\<sigma> =\n        (\\<lambda>k. m1.\\<alpha> m k \\<bind> f k) |`\n        dom (m1.\\<alpha> m)\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>k. m1.\\<alpha> m k \\<bind> f k) |`\n                         dom (m1.\\<alpha> m) =\n                         (\\<lambda>k. m1.\\<alpha> m k \\<bind> f k)\n 2. \\<And>m f k v it \\<sigma>.\n       \\<lbrakk>m1.invar m; k \\<in> dom (m1.\\<alpha> m) - it;\n        m1.\\<alpha> m k = Some v; it \\<subseteq> dom (m1.\\<alpha> m);\n        m2.invar \\<sigma> \\<and>\n        m2.\\<alpha> \\<sigma> =\n        (\\<lambda>k. m1.\\<alpha> m k \\<bind> f k) |` it\\<rbrakk>\n       \\<Longrightarrow> m2.invar\n                          ((case (k, v) of\n                            (k, v) \\<Rightarrow>\n                              \\<lambda>\\<sigma>.\n                                 case f k v of None \\<Rightarrow> \\<sigma>\n                                 | Some v' \\<Rightarrow>\n                                     m2.update_dj k v' \\<sigma>)\n                            \\<sigma>) \\<and>\n                         m2.\\<alpha>\n                          ((case (k, v) of\n                            (k, v) \\<Rightarrow>\n                              \\<lambda>\\<sigma>.\n                                 case f k v of None \\<Rightarrow> \\<sigma>\n                                 | Some v' \\<Rightarrow>\n                                     m2.update_dj k v' \\<sigma>)\n                            \\<sigma>) =\n                         (\\<lambda>k. m1.\\<alpha> m k \\<bind> f k) |`\n                         insert k it", "apply (rule restrict_map_dom_subset)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m f \\<sigma>.\n       \\<lbrakk>m1.invar m;\n        m2.invar \\<sigma> \\<and>\n        m2.\\<alpha> \\<sigma> =\n        (\\<lambda>k. m1.\\<alpha> m k \\<bind> f k) |`\n        dom (m1.\\<alpha> m)\\<rbrakk>\n       \\<Longrightarrow> dom (\\<lambda>k. m1.\\<alpha> m k \\<bind> f k)\n                         \\<subseteq> dom (m1.\\<alpha> m)\n 2. \\<And>m f k v it \\<sigma>.\n       \\<lbrakk>m1.invar m; k \\<in> dom (m1.\\<alpha> m) - it;\n        m1.\\<alpha> m k = Some v; it \\<subseteq> dom (m1.\\<alpha> m);\n        m2.invar \\<sigma> \\<and>\n        m2.\\<alpha> \\<sigma> =\n        (\\<lambda>k. m1.\\<alpha> m k \\<bind> f k) |` it\\<rbrakk>\n       \\<Longrightarrow> m2.invar\n                          ((case (k, v) of\n                            (k, v) \\<Rightarrow>\n                              \\<lambda>\\<sigma>.\n                                 case f k v of None \\<Rightarrow> \\<sigma>\n                                 | Some v' \\<Rightarrow>\n                                     m2.update_dj k v' \\<sigma>)\n                            \\<sigma>) \\<and>\n                         m2.\\<alpha>\n                          ((case (k, v) of\n                            (k, v) \\<Rightarrow>\n                              \\<lambda>\\<sigma>.\n                                 case f k v of None \\<Rightarrow> \\<sigma>\n                                 | Some v' \\<Rightarrow>\n                                     m2.update_dj k v' \\<sigma>)\n                            \\<sigma>) =\n                         (\\<lambda>k. m1.\\<alpha> m k \\<bind> f k) |`\n                         insert k it", "apply (auto) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m f \\<sigma> x y.\n       \\<lbrakk>m1.invar m; m1.\\<alpha> m x \\<bind> f x = Some y;\n        m2.invar \\<sigma>;\n        m2.\\<alpha> \\<sigma> =\n        (\\<lambda>k. m1.\\<alpha> m k \\<bind> f k) |`\n        dom (m1.\\<alpha> m)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. m1.\\<alpha> m x = Some y\n 2. \\<And>m f k v it \\<sigma>.\n       \\<lbrakk>m1.invar m; k \\<in> dom (m1.\\<alpha> m) - it;\n        m1.\\<alpha> m k = Some v; it \\<subseteq> dom (m1.\\<alpha> m);\n        m2.invar \\<sigma> \\<and>\n        m2.\\<alpha> \\<sigma> =\n        (\\<lambda>k. m1.\\<alpha> m k \\<bind> f k) |` it\\<rbrakk>\n       \\<Longrightarrow> m2.invar\n                          ((case (k, v) of\n                            (k, v) \\<Rightarrow>\n                              \\<lambda>\\<sigma>.\n                                 case f k v of None \\<Rightarrow> \\<sigma>\n                                 | Some v' \\<Rightarrow>\n                                     m2.update_dj k v' \\<sigma>)\n                            \\<sigma>) \\<and>\n                         m2.\\<alpha>\n                          ((case (k, v) of\n                            (k, v) \\<Rightarrow>\n                              \\<lambda>\\<sigma>.\n                                 case f k v of None \\<Rightarrow> \\<sigma>\n                                 | Some v' \\<Rightarrow>\n                                     m2.update_dj k v' \\<sigma>)\n                            \\<sigma>) =\n                         (\\<lambda>k. m1.\\<alpha> m k \\<bind> f k) |`\n                         insert k it", "apply (case_tac \"m1.\\<alpha> m x\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>m f \\<sigma> x y.\n       \\<lbrakk>m1.invar m; m1.\\<alpha> m x \\<bind> f x = Some y;\n        m2.invar \\<sigma>;\n        m2.\\<alpha> \\<sigma> =\n        (\\<lambda>k. m1.\\<alpha> m k \\<bind> f k) |` dom (m1.\\<alpha> m);\n        m1.\\<alpha> m x = None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. m1.\\<alpha> m x = Some y\n 2. \\<And>m f \\<sigma> x y a.\n       \\<lbrakk>m1.invar m; m1.\\<alpha> m x \\<bind> f x = Some y;\n        m2.invar \\<sigma>;\n        m2.\\<alpha> \\<sigma> =\n        (\\<lambda>k. m1.\\<alpha> m k \\<bind> f k) |` dom (m1.\\<alpha> m);\n        m1.\\<alpha> m x = Some a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. m1.\\<alpha> m x = Some y\n 3. \\<And>m f k v it \\<sigma>.\n       \\<lbrakk>m1.invar m; k \\<in> dom (m1.\\<alpha> m) - it;\n        m1.\\<alpha> m k = Some v; it \\<subseteq> dom (m1.\\<alpha> m);\n        m2.invar \\<sigma> \\<and>\n        m2.\\<alpha> \\<sigma> =\n        (\\<lambda>k. m1.\\<alpha> m k \\<bind> f k) |` it\\<rbrakk>\n       \\<Longrightarrow> m2.invar\n                          ((case (k, v) of\n                            (k, v) \\<Rightarrow>\n                              \\<lambda>\\<sigma>.\n                                 case f k v of None \\<Rightarrow> \\<sigma>\n                                 | Some v' \\<Rightarrow>\n                                     m2.update_dj k v' \\<sigma>)\n                            \\<sigma>) \\<and>\n                         m2.\\<alpha>\n                          ((case (k, v) of\n                            (k, v) \\<Rightarrow>\n                              \\<lambda>\\<sigma>.\n                                 case f k v of None \\<Rightarrow> \\<sigma>\n                                 | Some v' \\<Rightarrow>\n                                     m2.update_dj k v' \\<sigma>)\n                            \\<sigma>) =\n                         (\\<lambda>k. m1.\\<alpha> m k \\<bind> f k) |`\n                         insert k it", "apply (auto) [2]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m f k v it \\<sigma>.\n       \\<lbrakk>m1.invar m; k \\<in> dom (m1.\\<alpha> m) - it;\n        m1.\\<alpha> m k = Some v; it \\<subseteq> dom (m1.\\<alpha> m);\n        m2.invar \\<sigma> \\<and>\n        m2.\\<alpha> \\<sigma> =\n        (\\<lambda>k. m1.\\<alpha> m k \\<bind> f k) |` it\\<rbrakk>\n       \\<Longrightarrow> m2.invar\n                          ((case (k, v) of\n                            (k, v) \\<Rightarrow>\n                              \\<lambda>\\<sigma>.\n                                 case f k v of None \\<Rightarrow> \\<sigma>\n                                 | Some v' \\<Rightarrow>\n                                     m2.update_dj k v' \\<sigma>)\n                            \\<sigma>) \\<and>\n                         m2.\\<alpha>\n                          ((case (k, v) of\n                            (k, v) \\<Rightarrow>\n                              \\<lambda>\\<sigma>.\n                                 case f k v of None \\<Rightarrow> \\<sigma>\n                                 | Some v' \\<Rightarrow>\n                                     m2.update_dj k v' \\<sigma>)\n                            \\<sigma>) =\n                         (\\<lambda>k. m1.\\<alpha> m k \\<bind> f k) |`\n                         insert k it", "apply (auto split: option.split simp: m2.update_dj_correct intro!: ext)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m f k v it \\<sigma> x.\n       \\<lbrakk>m1.invar m; it \\<subseteq> dom (m1.\\<alpha> m);\n        k \\<notin> it; m1.\\<alpha> m k = Some v; m2.invar \\<sigma>;\n        m2.\\<alpha> \\<sigma> =\n        (\\<lambda>k. m1.\\<alpha> m k \\<bind> f k) |` it;\n        f k v = None\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>k. m1.\\<alpha> m k \\<bind> f k) |` it)\n                          x =\n                         ((\\<lambda>k. m1.\\<alpha> m k \\<bind> f k) |`\n                          insert k it)\n                          x\n 2. \\<And>m f k v it \\<sigma> x2 x.\n       \\<lbrakk>m1.invar m; it \\<subseteq> dom (m1.\\<alpha> m);\n        k \\<notin> it; m1.\\<alpha> m k = Some v; m2.invar \\<sigma>;\n        m2.\\<alpha> \\<sigma> =\n        (\\<lambda>k. m1.\\<alpha> m k \\<bind> f k) |` it;\n        f k v = Some x2; x \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> ((\\<lambda>k. m1.\\<alpha> m k \\<bind> f k) |` it)\n                          x =\n                         ((\\<lambda>k. m1.\\<alpha> m k \\<bind> f k) |`\n                          insert k it)\n                          x", "apply (auto simp: restrict_map_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "sublocale g_value_image_filter_loc \n  < map_value_image_filter m1.\\<alpha> m1.invar m2.\\<alpha> m2.invar g_value_image_filter"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_value_image_filter m1.\\<alpha> m1.invar m2.\\<alpha> m2.invar\n     g_value_image_filter", "by (rule g_value_image_filter_impl)"], ["", "end"]]}