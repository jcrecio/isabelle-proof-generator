{"file_name": "/home/qj213/afp-2021-10-22/thys/Collections/Examples/Refine_Monadic/Bfs_Impl.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Collections", "problem_names": ["theorem bfs_impl_correct:\n    shows \"bfs_impl succ src dst \\<le> Graph.bfs_spec (ls.\\<alpha>\\<circ>succ) src dst\"", "theorem bfs_code_correct:\n    \"bfs_code succ src dst = dRETURN None \n      \\<Longrightarrow> \\<not>(Graph.conn (ls.\\<alpha> \\<circ> succ) src dst)\" \n    \"bfs_code succ src dst = dRETURN (Some d) \n      \\<Longrightarrow> Graph.conn (ls.\\<alpha> \\<circ> succ) src dst \n          \\<and> Graph.min_dist (ls.\\<alpha> \\<circ> succ) src dst = d\"\n    \"bfs_code succ src dst \\<noteq> dFAIL\""], "translations": [["", "theorem bfs_impl_correct:\n    shows \"bfs_impl succ src dst \\<le> Graph.bfs_spec (ls.\\<alpha>\\<circ>succ) src dst\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bfs_impl succ src dst\n    \\<le> Graph.bfs_spec (ls.\\<alpha> \\<circ> succ) src dst", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. bfs_impl succ src dst\n    \\<le> Graph.bfs_spec (ls.\\<alpha> \\<circ> succ) src dst", "txt \\<open>As list-sets are always finite, our setting satisfies the\n      finitely-branching assumption made about graphs\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. bfs_impl succ src dst\n    \\<le> Graph.bfs_spec (ls.\\<alpha> \\<circ> succ) src dst", "interpret Graph \"ls.\\<alpha>\\<circ>succ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Graph (ls.\\<alpha> \\<circ> succ)", "by unfold_locales simp"], ["proof (state)\ngoal (1 subgoal):\n 1. bfs_impl succ src dst \\<le> bfs_spec src dst", "txt \\<open>The refinement framework can prove automatically that\n      the implementation refines the abstract algorithm.\n\n      The notation \\<open>S \\<le> \\<Down>R S'\\<close> means, that the program \\<open>S\\<close>\n      refines the program \\<open>S'\\<close> w.r.t.\\ the refinement relation \n      (also called coupling invariant occasionally) \\<open>R\\<close>.\n\n      In our case, the refinement relation is the identity, as\n      the result type was not refined.\n\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. bfs_impl succ src dst \\<le> bfs_spec src dst", "have \"bfs_impl succ src dst \\<le> \\<Down>Id (Graph.bfs (ls.\\<alpha>\\<circ>succ) src dst)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bfs_impl succ src dst \\<le> \\<Down> Id (bfs src dst)", "unfolding bfs_impl_def bfs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. WHILE (\\<lambda>(f, V, C, N, d). f = False \\<and> \\<not> ls.isEmpty C)\n     (\\<lambda>(f, V, C, N, d).\n         RETURN (the (ls.sel C (\\<lambda>_. True))) \\<bind>\n         (\\<lambda>v.\n             let C = ls.delete v C\n             in if v = dst\n                then RETURN (True, hs.empty (), ls.empty (), ls.empty (), d)\n                else FOREACH (ls.\\<alpha> (succ v))\n                      (\\<lambda>w (V, N).\n                          if \\<not> hs.memb w V\n                          then RETURN (hs.ins w V, ls.ins_dj w N)\n                          else RETURN (V, N))\n                      (V, N) \\<bind>\n                     (\\<lambda>(V, N).\n                         if ls.isEmpty C\n                         then let C = N; N = ls.empty (); d = d + 1\n                              in RETURN (f, V, C, N, d)\n                         else RETURN (f, V, C, N, d))))\n     (False, hs.sng src, ls.sng src, ls.empty (), 0) \\<bind>\n    (\\<lambda>(f, uu_, uu_, uu_, d).\n        if f then RETURN (Some d) else RETURN None)\n    \\<le> \\<Down> Id\n           (WHILE\\<^bsup>bfs_invar src dst\\<^esup>\n             (\\<lambda>(f, V, C, N, d). f = False \\<and> C \\<noteq> {})\n             (\\<lambda>(f, V, C, N, d).\n                 SPEC (\\<lambda>v. v \\<in> C) \\<bind>\n                 (\\<lambda>v.\n                     let C = C - {v}\n                     in if v = dst then RETURN (True, {}, {}, {}, d)\n                        else FOREACH\\<^bsup>FE_invar V N v\\<^esup>\n                              ((ls.\\<alpha> \\<circ> succ) v)\n                              (\\<lambda>w (V, N).\n                                  if w \\<notin> V\n                                  then ASSERT (w \\<notin> N) \\<bind>\n (\\<lambda>_. RETURN (insert w V, insert w N))\n                                  else RETURN (V, N))\n                              (V, N) \\<bind>\n                             (\\<lambda>(V, N).\n                                 ASSERT\n                                  (bfs_invar' src dst\n                                    (f, V, C, N, d)) \\<bind>\n                                 (\\<lambda>_.\n                                     if C = {}\n                                     then let C = N; N = {}; d = d + 1\n    in RETURN (f, V, C, N, d)\n                                     else RETURN (f, V, C, N, d)))))\n             (False, {src}, {src}, {}, 0) \\<bind>\n            (\\<lambda>(f, uu_, uu_, uu_, d).\n                if f then RETURN (Some d) else RETURN None))", "apply (refine_rcg)"], ["proof (prove)\ngoal (16 subgoals):\n 1. bfs_invar src dst (False, {src}, {src}, {}, 0) \\<Longrightarrow>\n    ((False, hs.sng src, ls.sng src, ls.empty (), 0), False, {src}, {src},\n     {}, 0)\n    \\<in> ?R'\n 2. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g\n       x2g.\n       \\<lbrakk>(x, x') \\<in> ?R'; bfs_invar src dst x'; x2b = (x1c, x2c);\n        x2a = (x1b, x2b); x2 = (x1a, x2a); x = (x1, x2); x2f = (x1g, x2g);\n        x2e = (x1f, x2f); x2d = (x1e, x2e); x' = (x1d, x2d)\\<rbrakk>\n       \\<Longrightarrow> (x1 = False \\<and> \\<not> ls.isEmpty x1b) =\n                         (x1d = False \\<and> x1f \\<noteq> {})\n 3. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g\n       x2g.\n       \\<lbrakk>(x, x') \\<in> ?R';\n        case x of\n        (f, V, C, N, d) \\<Rightarrow> f = False \\<and> \\<not> ls.isEmpty C;\n        case x' of\n        (f, V, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        bfs_invar src dst x'; x2b = (x1c, x2c); x2a = (x1b, x2b);\n        x2 = (x1a, x2a); x' = (x1, x2); x2f = (x1g, x2g); x2e = (x1f, x2f);\n        x2d = (x1e, x2e); x = (x1d, x2d)\\<rbrakk>\n       \\<Longrightarrow> RETURN (the (ls.sel x1f (\\<lambda>_. True)))\n                         \\<le> SPEC (\\<lambda>v. v \\<in> x1b)\n 4. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g\n       v va.\n       \\<lbrakk>(x, x') \\<in> ?R';\n        case x of\n        (f, V, C, N, d) \\<Rightarrow> f = False \\<and> \\<not> ls.isEmpty C;\n        case x' of\n        (f, V, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        bfs_invar src dst x'; x2b = (x1c, x2c); x2a = (x1b, x2b);\n        x2 = (x1a, x2a); x' = (x1, x2); x2f = (x1g, x2g); x2e = (x1f, x2f);\n        x2d = (x1e, x2e); x = (x1d, x2d); (v, va) \\<in> nat_rel;\n        va \\<in> {v. v \\<in> x1b}\\<rbrakk>\n       \\<Longrightarrow> (v = dst) = (va = dst)\n 5. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g\n       v va.\n       \\<lbrakk>(x, x') \\<in> ?R';\n        case x of\n        (f, V, C, N, d) \\<Rightarrow> f = False \\<and> \\<not> ls.isEmpty C;\n        case x' of\n        (f, V, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        bfs_invar src dst x'; x2b = (x1c, x2c); x2a = (x1b, x2b);\n        x2 = (x1a, x2a); x' = (x1, x2); x2f = (x1g, x2g); x2e = (x1f, x2f);\n        x2d = (x1e, x2e); x = (x1d, x2d); (v, va) \\<in> nat_rel;\n        va \\<in> {v. v \\<in> x1b}; v = dst; va = dst\\<rbrakk>\n       \\<Longrightarrow> ((True, hs.empty (), ls.empty (), ls.empty (),\n                           x2g),\n                          True, {}, {}, {}, x2c)\n                         \\<in> ?R'\n 6. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g\n       v va.\n       \\<lbrakk>(x, x') \\<in> ?R';\n        case x of\n        (f, V, C, N, d) \\<Rightarrow> f = False \\<and> \\<not> ls.isEmpty C;\n        case x' of\n        (f, V, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        bfs_invar src dst x'; x2b = (x1c, x2c); x2a = (x1b, x2b);\n        x2 = (x1a, x2a); x' = (x1, x2); x2f = (x1g, x2g); x2e = (x1f, x2f);\n        x2d = (x1e, x2e); x = (x1d, x2d); (v, va) \\<in> nat_rel;\n        va \\<in> {v. v \\<in> x1b}; v \\<noteq> dst; va \\<noteq> dst\\<rbrakk>\n       \\<Longrightarrow> inj_on\n                          (?\\<alpha>408 x x' x1 x2 x1a x2a x1b x2b x1c x2c\n                            x1d x2d x1e x2e x1f x2f x1g x2g v va)\n                          (ls.\\<alpha> (succ v))\n 7. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g\n       v va.\n       \\<lbrakk>(x, x') \\<in> ?R';\n        case x of\n        (f, V, C, N, d) \\<Rightarrow> f = False \\<and> \\<not> ls.isEmpty C;\n        case x' of\n        (f, V, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        bfs_invar src dst x'; x2b = (x1c, x2c); x2a = (x1b, x2b);\n        x2 = (x1a, x2a); x' = (x1, x2); x2f = (x1g, x2g); x2e = (x1f, x2f);\n        x2d = (x1e, x2e); x = (x1d, x2d); (v, va) \\<in> nat_rel;\n        va \\<in> {v. v \\<in> x1b}; v \\<noteq> dst; va \\<noteq> dst\\<rbrakk>\n       \\<Longrightarrow> (ls.\\<alpha> \\<circ> succ) va =\n                         ?\\<alpha>408 x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d\n                          x2d x1e x2e x1f x2f x1g x2g v va `\n                         ls.\\<alpha> (succ v)\n 8. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g\n       v va.\n       \\<lbrakk>(x, x') \\<in> ?R';\n        case x of\n        (f, V, C, N, d) \\<Rightarrow> f = False \\<and> \\<not> ls.isEmpty C;\n        case x' of\n        (f, V, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        bfs_invar src dst x'; x2b = (x1c, x2c); x2a = (x1b, x2b);\n        x2 = (x1a, x2a); x' = (x1, x2); x2f = (x1g, x2g); x2e = (x1f, x2f);\n        x2d = (x1e, x2e); x = (x1d, x2d); (v, va) \\<in> nat_rel;\n        va \\<in> {v. v \\<in> x1b}; v \\<noteq> dst; va \\<noteq> dst\\<rbrakk>\n       \\<Longrightarrow> ((x1e, x1g), x1a, x1c)\n                         \\<in> ?R'407 x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d\n                                x2d x1e x2e x1f x2f x1g x2g v va\n 9. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g\n       v va xa it \\<sigma> x'a it' \\<sigma>' x1h x2h x1i x2i.\n       \\<lbrakk>(x, x') \\<in> ?R';\n        case x of\n        (f, V, C, N, d) \\<Rightarrow> f = False \\<and> \\<not> ls.isEmpty C;\n        case x' of\n        (f, V, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        bfs_invar src dst x'; x2b = (x1c, x2c); x2a = (x1b, x2b);\n        x2 = (x1a, x2a); x' = (x1, x2); x2f = (x1g, x2g); x2e = (x1f, x2f);\n        x2d = (x1e, x2e); x = (x1d, x2d); (v, va) \\<in> nat_rel;\n        va \\<in> {v. v \\<in> x1b}; v \\<noteq> dst; va \\<noteq> dst;\n        x'a =\n        ?\\<alpha>408 x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f\n         x2f x1g x2g v va xa;\n        xa \\<in> it; x'a \\<in> it';\n        it' =\n        ?\\<alpha>408 x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f\n         x2f x1g x2g v va `\n        it;\n        it \\<subseteq> ls.\\<alpha> (succ v);\n        it' \\<subseteq> (ls.\\<alpha> \\<circ> succ) va;\n        FE_invar x1a x1c va it' \\<sigma>';\n        (\\<sigma>, \\<sigma>')\n        \\<in> ?R'407 x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f\n               x2f x1g x2g v va;\n        \\<sigma>' = (x1h, x2h); \\<sigma> = (x1i, x2i)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> hs.memb xa x1i) = (x'a \\<notin> x1h)\n 10. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g\n        x2g v va xa it \\<sigma> x'a it' \\<sigma>' x1h x2h x1i x2i.\n        \\<lbrakk>(x, x') \\<in> ?R';\n         case x of\n         (f, V, C, N, d) \\<Rightarrow> f = False \\<and> \\<not> ls.isEmpty C;\n         case x' of\n         (f, V, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n         bfs_invar src dst x'; x2b = (x1c, x2c); x2a = (x1b, x2b);\n         x2 = (x1a, x2a); x' = (x1, x2); x2f = (x1g, x2g); x2e = (x1f, x2f);\n         x2d = (x1e, x2e); x = (x1d, x2d); (v, va) \\<in> nat_rel;\n         va \\<in> {v. v \\<in> x1b}; v \\<noteq> dst; va \\<noteq> dst;\n         x'a =\n         ?\\<alpha>408 x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f\n          x2f x1g x2g v va xa;\n         xa \\<in> it; x'a \\<in> it';\n         it' =\n         ?\\<alpha>408 x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f\n          x2f x1g x2g v va `\n         it;\n         it \\<subseteq> ls.\\<alpha> (succ v);\n         it' \\<subseteq> (ls.\\<alpha> \\<circ> succ) va;\n         FE_invar x1a x1c va it' \\<sigma>';\n         (\\<sigma>, \\<sigma>')\n         \\<in> ?R'407 x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f\n                x2f x1g x2g v va;\n         \\<sigma>' = (x1h, x2h); \\<sigma> = (x1i, x2i);\n         \\<not> hs.memb xa x1i; x'a \\<notin> x1h; x'a \\<notin> x2h\\<rbrakk>\n        \\<Longrightarrow> ((hs.ins xa x1i, ls.ins_dj xa x2i),\n                           insert x'a x1h, insert x'a x2h)\n                          \\<in> ?R'407 x x' x1 x2 x1a x2a x1b x2b x1c x2c\n                                 x1d x2d x1e x2e x1f x2f x1g x2g v va\nA total of 16 subgoals...", "apply (refine_dref_type)"], ["proof (prove)\ngoal (16 subgoals):\n 1. bfs_invar src dst (False, {src}, {src}, {}, 0) \\<Longrightarrow>\n    ((False, hs.sng src, ls.sng src, ls.empty (), 0), False, {src}, {src},\n     {}, 0)\n    \\<in> bool_rel \\<times>\\<^sub>r\n          br hs.\\<alpha> hs.invar \\<times>\\<^sub>r\n          br ls.\\<alpha> ls.invar \\<times>\\<^sub>r\n          br ls.\\<alpha> ls.invar \\<times>\\<^sub>r nat_rel\n 2. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g\n       x2g.\n       \\<lbrakk>(x, x')\n                \\<in> bool_rel \\<times>\\<^sub>r\n                      br hs.\\<alpha> hs.invar \\<times>\\<^sub>r\n                      br ls.\\<alpha> ls.invar \\<times>\\<^sub>r\n                      br ls.\\<alpha> ls.invar \\<times>\\<^sub>r nat_rel;\n        bfs_invar src dst x'; x2b = (x1c, x2c); x2a = (x1b, x2b);\n        x2 = (x1a, x2a); x = (x1, x2); x2f = (x1g, x2g); x2e = (x1f, x2f);\n        x2d = (x1e, x2e); x' = (x1d, x2d)\\<rbrakk>\n       \\<Longrightarrow> (x1 = False \\<and> \\<not> ls.isEmpty x1b) =\n                         (x1d = False \\<and> x1f \\<noteq> {})\n 3. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g\n       x2g.\n       \\<lbrakk>(x, x')\n                \\<in> bool_rel \\<times>\\<^sub>r\n                      br hs.\\<alpha> hs.invar \\<times>\\<^sub>r\n                      br ls.\\<alpha> ls.invar \\<times>\\<^sub>r\n                      br ls.\\<alpha> ls.invar \\<times>\\<^sub>r nat_rel;\n        case x of\n        (f, V, C, N, d) \\<Rightarrow> f = False \\<and> \\<not> ls.isEmpty C;\n        case x' of\n        (f, V, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        bfs_invar src dst x'; x2b = (x1c, x2c); x2a = (x1b, x2b);\n        x2 = (x1a, x2a); x' = (x1, x2); x2f = (x1g, x2g); x2e = (x1f, x2f);\n        x2d = (x1e, x2e); x = (x1d, x2d)\\<rbrakk>\n       \\<Longrightarrow> RETURN (the (ls.sel x1f (\\<lambda>_. True)))\n                         \\<le> SPEC (\\<lambda>v. v \\<in> x1b)\n 4. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g\n       v va.\n       \\<lbrakk>(x, x')\n                \\<in> bool_rel \\<times>\\<^sub>r\n                      br hs.\\<alpha> hs.invar \\<times>\\<^sub>r\n                      br ls.\\<alpha> ls.invar \\<times>\\<^sub>r\n                      br ls.\\<alpha> ls.invar \\<times>\\<^sub>r nat_rel;\n        case x of\n        (f, V, C, N, d) \\<Rightarrow> f = False \\<and> \\<not> ls.isEmpty C;\n        case x' of\n        (f, V, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        bfs_invar src dst x'; x2b = (x1c, x2c); x2a = (x1b, x2b);\n        x2 = (x1a, x2a); x' = (x1, x2); x2f = (x1g, x2g); x2e = (x1f, x2f);\n        x2d = (x1e, x2e); x = (x1d, x2d); (v, va) \\<in> nat_rel;\n        va \\<in> {v. v \\<in> x1b}\\<rbrakk>\n       \\<Longrightarrow> (v = dst) = (va = dst)\n 5. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g\n       v va.\n       \\<lbrakk>(x, x')\n                \\<in> bool_rel \\<times>\\<^sub>r\n                      br hs.\\<alpha> hs.invar \\<times>\\<^sub>r\n                      br ls.\\<alpha> ls.invar \\<times>\\<^sub>r\n                      br ls.\\<alpha> ls.invar \\<times>\\<^sub>r nat_rel;\n        case x of\n        (f, V, C, N, d) \\<Rightarrow> f = False \\<and> \\<not> ls.isEmpty C;\n        case x' of\n        (f, V, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        bfs_invar src dst x'; x2b = (x1c, x2c); x2a = (x1b, x2b);\n        x2 = (x1a, x2a); x' = (x1, x2); x2f = (x1g, x2g); x2e = (x1f, x2f);\n        x2d = (x1e, x2e); x = (x1d, x2d); (v, va) \\<in> nat_rel;\n        va \\<in> {v. v \\<in> x1b}; v = dst; va = dst\\<rbrakk>\n       \\<Longrightarrow> ((True, hs.empty (), ls.empty (), ls.empty (),\n                           x2g),\n                          True, {}, {}, {}, x2c)\n                         \\<in> bool_rel \\<times>\\<^sub>r\n                               br hs.\\<alpha> hs.invar \\<times>\\<^sub>r\n                               br ls.\\<alpha> ls.invar \\<times>\\<^sub>r\n                               br ls.\\<alpha> ls.invar \\<times>\\<^sub>r\n                               nat_rel\n 6. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g\n       v va.\n       \\<lbrakk>(x, x')\n                \\<in> bool_rel \\<times>\\<^sub>r\n                      br hs.\\<alpha> hs.invar \\<times>\\<^sub>r\n                      br ls.\\<alpha> ls.invar \\<times>\\<^sub>r\n                      br ls.\\<alpha> ls.invar \\<times>\\<^sub>r nat_rel;\n        case x of\n        (f, V, C, N, d) \\<Rightarrow> f = False \\<and> \\<not> ls.isEmpty C;\n        case x' of\n        (f, V, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        bfs_invar src dst x'; x2b = (x1c, x2c); x2a = (x1b, x2b);\n        x2 = (x1a, x2a); x' = (x1, x2); x2f = (x1g, x2g); x2e = (x1f, x2f);\n        x2d = (x1e, x2e); x = (x1d, x2d); (v, va) \\<in> nat_rel;\n        va \\<in> {v. v \\<in> x1b}; v \\<noteq> dst; va \\<noteq> dst\\<rbrakk>\n       \\<Longrightarrow> inj_on\n                          (?\\<alpha>408 x x' x1 x2 x1a x2a x1b x2b x1c x2c\n                            x1d x2d x1e x2e x1f x2f x1g x2g v va)\n                          (ls.\\<alpha> (succ v))\n 7. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g\n       v va.\n       \\<lbrakk>(x, x')\n                \\<in> bool_rel \\<times>\\<^sub>r\n                      br hs.\\<alpha> hs.invar \\<times>\\<^sub>r\n                      br ls.\\<alpha> ls.invar \\<times>\\<^sub>r\n                      br ls.\\<alpha> ls.invar \\<times>\\<^sub>r nat_rel;\n        case x of\n        (f, V, C, N, d) \\<Rightarrow> f = False \\<and> \\<not> ls.isEmpty C;\n        case x' of\n        (f, V, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        bfs_invar src dst x'; x2b = (x1c, x2c); x2a = (x1b, x2b);\n        x2 = (x1a, x2a); x' = (x1, x2); x2f = (x1g, x2g); x2e = (x1f, x2f);\n        x2d = (x1e, x2e); x = (x1d, x2d); (v, va) \\<in> nat_rel;\n        va \\<in> {v. v \\<in> x1b}; v \\<noteq> dst; va \\<noteq> dst\\<rbrakk>\n       \\<Longrightarrow> (ls.\\<alpha> \\<circ> succ) va =\n                         ?\\<alpha>408 x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d\n                          x2d x1e x2e x1f x2f x1g x2g v va `\n                         ls.\\<alpha> (succ v)\n 8. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g\n       v va.\n       \\<lbrakk>(x, x')\n                \\<in> bool_rel \\<times>\\<^sub>r\n                      br hs.\\<alpha> hs.invar \\<times>\\<^sub>r\n                      br ls.\\<alpha> ls.invar \\<times>\\<^sub>r\n                      br ls.\\<alpha> ls.invar \\<times>\\<^sub>r nat_rel;\n        case x of\n        (f, V, C, N, d) \\<Rightarrow> f = False \\<and> \\<not> ls.isEmpty C;\n        case x' of\n        (f, V, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        bfs_invar src dst x'; x2b = (x1c, x2c); x2a = (x1b, x2b);\n        x2 = (x1a, x2a); x' = (x1, x2); x2f = (x1g, x2g); x2e = (x1f, x2f);\n        x2d = (x1e, x2e); x = (x1d, x2d); (v, va) \\<in> nat_rel;\n        va \\<in> {v. v \\<in> x1b}; v \\<noteq> dst; va \\<noteq> dst\\<rbrakk>\n       \\<Longrightarrow> ((x1e, x1g), x1a, x1c)\n                         \\<in> br hs.\\<alpha> hs.invar \\<times>\\<^sub>r\n                               br ls.\\<alpha> ls.invar\n 9. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g x2g\n       v va xa it \\<sigma> x'a it' \\<sigma>' x1h x2h x1i x2i.\n       \\<lbrakk>(x, x')\n                \\<in> bool_rel \\<times>\\<^sub>r\n                      br hs.\\<alpha> hs.invar \\<times>\\<^sub>r\n                      br ls.\\<alpha> ls.invar \\<times>\\<^sub>r\n                      br ls.\\<alpha> ls.invar \\<times>\\<^sub>r nat_rel;\n        case x of\n        (f, V, C, N, d) \\<Rightarrow> f = False \\<and> \\<not> ls.isEmpty C;\n        case x' of\n        (f, V, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n        bfs_invar src dst x'; x2b = (x1c, x2c); x2a = (x1b, x2b);\n        x2 = (x1a, x2a); x' = (x1, x2); x2f = (x1g, x2g); x2e = (x1f, x2f);\n        x2d = (x1e, x2e); x = (x1d, x2d); (v, va) \\<in> nat_rel;\n        va \\<in> {v. v \\<in> x1b}; v \\<noteq> dst; va \\<noteq> dst;\n        x'a =\n        ?\\<alpha>408 x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f\n         x2f x1g x2g v va xa;\n        xa \\<in> it; x'a \\<in> it';\n        it' =\n        ?\\<alpha>408 x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f\n         x2f x1g x2g v va `\n        it;\n        it \\<subseteq> ls.\\<alpha> (succ v);\n        it' \\<subseteq> (ls.\\<alpha> \\<circ> succ) va;\n        FE_invar x1a x1c va it' \\<sigma>';\n        (\\<sigma>, \\<sigma>')\n        \\<in> br hs.\\<alpha> hs.invar \\<times>\\<^sub>r\n              br ls.\\<alpha> ls.invar;\n        \\<sigma>' = (x1h, x2h); \\<sigma> = (x1i, x2i)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> hs.memb xa x1i) = (x'a \\<notin> x1h)\n 10. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f x2f x1g\n        x2g v va xa it \\<sigma> x'a it' \\<sigma>' x1h x2h x1i x2i.\n        \\<lbrakk>(x, x')\n                 \\<in> bool_rel \\<times>\\<^sub>r\n                       br hs.\\<alpha> hs.invar \\<times>\\<^sub>r\n                       br ls.\\<alpha> ls.invar \\<times>\\<^sub>r\n                       br ls.\\<alpha> ls.invar \\<times>\\<^sub>r nat_rel;\n         case x of\n         (f, V, C, N, d) \\<Rightarrow> f = False \\<and> \\<not> ls.isEmpty C;\n         case x' of\n         (f, V, C, N, d) \\<Rightarrow> f = False \\<and> C \\<noteq> {};\n         bfs_invar src dst x'; x2b = (x1c, x2c); x2a = (x1b, x2b);\n         x2 = (x1a, x2a); x' = (x1, x2); x2f = (x1g, x2g); x2e = (x1f, x2f);\n         x2d = (x1e, x2e); x = (x1d, x2d); (v, va) \\<in> nat_rel;\n         va \\<in> {v. v \\<in> x1b}; v \\<noteq> dst; va \\<noteq> dst;\n         x'a =\n         ?\\<alpha>408 x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f\n          x2f x1g x2g v va xa;\n         xa \\<in> it; x'a \\<in> it';\n         it' =\n         ?\\<alpha>408 x x' x1 x2 x1a x2a x1b x2b x1c x2c x1d x2d x1e x2e x1f\n          x2f x1g x2g v va `\n         it;\n         it \\<subseteq> ls.\\<alpha> (succ v);\n         it' \\<subseteq> (ls.\\<alpha> \\<circ> succ) va;\n         FE_invar x1a x1c va it' \\<sigma>';\n         (\\<sigma>, \\<sigma>')\n         \\<in> br hs.\\<alpha> hs.invar \\<times>\\<^sub>r\n               br ls.\\<alpha> ls.invar;\n         \\<sigma>' = (x1h, x2h); \\<sigma> = (x1i, x2i);\n         \\<not> hs.memb xa x1i; x'a \\<notin> x1h; x'a \\<notin> x2h\\<rbrakk>\n        \\<Longrightarrow> ((hs.ins xa x1i, ls.ins_dj xa x2i),\n                           insert x'a x1h, insert x'a x2h)\n                          \\<in> br hs.\\<alpha> hs.invar \\<times>\\<^sub>r\n                                br ls.\\<alpha> ls.invar\nA total of 16 subgoals...", "apply (simp_all add: refine_hsimp refine_rel_defs\n        hs.correct hs.sng_correct ls.correct ls.sng_correct\n        split: prod.split prod.split_asm)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x x' x1 x2 x2a x2b x2c x1d x2d x1e x2e x1f x2f x1g v va.\n       \\<lbrakk>\\<not> x1d; \\<not> x1 \\<and> ls.\\<alpha> x1f \\<noteq> {};\n        bfs_invar src dst\n         (False, hs.\\<alpha> x1e, ls.\\<alpha> x1f, ls.\\<alpha> x1g, x2c);\n        x2b = (ls.\\<alpha> x1g, x2c);\n        x2a = (ls.\\<alpha> x1f, ls.\\<alpha> x1g, x2c);\n        x2 = (hs.\\<alpha> x1e, ls.\\<alpha> x1f, ls.\\<alpha> x1g, x2c);\n        x' =\n        (False, hs.\\<alpha> x1e, ls.\\<alpha> x1f, ls.\\<alpha> x1g, x2c);\n        x2f = (x1g, x2c); x2e = (x1f, x1g, x2c); x2d = (x1e, x1f, x1g, x2c);\n        x = (False, x1e, x1f, x1g, x2c); v = va; va \\<in> ls.\\<alpha> x1f;\n        va \\<noteq> dst\\<rbrakk>\n       \\<Longrightarrow> inj_on\n                          (?\\<alpha>408 (False, x1e, x1f, x1g, x2c)\n                            (False, hs.\\<alpha> x1e, ls.\\<alpha> x1f,\n                             ls.\\<alpha> x1g, x2c)\n                            False\n                            (hs.\\<alpha> x1e, ls.\\<alpha> x1f,\n                             ls.\\<alpha> x1g, x2c)\n                            (hs.\\<alpha> x1e)\n                            (ls.\\<alpha> x1f, ls.\\<alpha> x1g, x2c)\n                            (ls.\\<alpha> x1f) (ls.\\<alpha> x1g, x2c)\n                            (ls.\\<alpha> x1g) x2c False (x1e, x1f, x1g, x2c)\n                            x1e (x1f, x1g, x2c) x1f (x1g, x2c) x1g x2c va\n                            va)\n                          (ls.\\<alpha> (succ va))\n 2. \\<And>x x' x1 x2 x2a x2b x2c x1d x2d x1e x2e x1f x2f x1g v va.\n       \\<lbrakk>\\<not> x1d; \\<not> x1 \\<and> ls.\\<alpha> x1f \\<noteq> {};\n        bfs_invar src dst\n         (False, hs.\\<alpha> x1e, ls.\\<alpha> x1f, ls.\\<alpha> x1g, x2c);\n        x2b = (ls.\\<alpha> x1g, x2c);\n        x2a = (ls.\\<alpha> x1f, ls.\\<alpha> x1g, x2c);\n        x2 = (hs.\\<alpha> x1e, ls.\\<alpha> x1f, ls.\\<alpha> x1g, x2c);\n        x' =\n        (False, hs.\\<alpha> x1e, ls.\\<alpha> x1f, ls.\\<alpha> x1g, x2c);\n        x2f = (x1g, x2c); x2e = (x1f, x1g, x2c); x2d = (x1e, x1f, x1g, x2c);\n        x = (False, x1e, x1f, x1g, x2c); v = va; va \\<in> ls.\\<alpha> x1f;\n        va \\<noteq> dst\\<rbrakk>\n       \\<Longrightarrow> ls.\\<alpha> (succ va) =\n                         ?\\<alpha>408 (False, x1e, x1f, x1g, x2c)\n                          (False, hs.\\<alpha> x1e, ls.\\<alpha> x1f,\n                           ls.\\<alpha> x1g, x2c)\n                          False\n                          (hs.\\<alpha> x1e, ls.\\<alpha> x1f,\n                           ls.\\<alpha> x1g, x2c)\n                          (hs.\\<alpha> x1e)\n                          (ls.\\<alpha> x1f, ls.\\<alpha> x1g, x2c)\n                          (ls.\\<alpha> x1f) (ls.\\<alpha> x1g, x2c)\n                          (ls.\\<alpha> x1g) x2c False (x1e, x1f, x1g, x2c)\n                          x1e (x1f, x1g, x2c) x1f (x1g, x2c) x1g x2c va va `\n                         ls.\\<alpha> (succ va)\n 3. \\<And>x x' x1 x2 x2a x2b x2c x1d x2d x1e x2e x1f x2f x1g v va xa it\n       \\<sigma> x'a it' \\<sigma>' x1h x1i x2i.\n       \\<lbrakk>\\<not> x1d; \\<not> x1 \\<and> ls.\\<alpha> x1f \\<noteq> {};\n        bfs_invar src dst\n         (False, hs.\\<alpha> x1e, ls.\\<alpha> x1f, ls.\\<alpha> x1g, x2c);\n        x2b = (ls.\\<alpha> x1g, x2c);\n        x2a = (ls.\\<alpha> x1f, ls.\\<alpha> x1g, x2c);\n        x2 = (hs.\\<alpha> x1e, ls.\\<alpha> x1f, ls.\\<alpha> x1g, x2c);\n        x' =\n        (False, hs.\\<alpha> x1e, ls.\\<alpha> x1f, ls.\\<alpha> x1g, x2c);\n        x2f = (x1g, x2c); x2e = (x1f, x1g, x2c); x2d = (x1e, x1f, x1g, x2c);\n        x = (False, x1e, x1f, x1g, x2c); v = va; va \\<in> ls.\\<alpha> x1f;\n        va \\<noteq> dst;\n        x'a =\n        ?\\<alpha>408 (False, x1e, x1f, x1g, x2c)\n         (False, hs.\\<alpha> x1e, ls.\\<alpha> x1f, ls.\\<alpha> x1g, x2c)\n         False (hs.\\<alpha> x1e, ls.\\<alpha> x1f, ls.\\<alpha> x1g, x2c)\n         (hs.\\<alpha> x1e) (ls.\\<alpha> x1f, ls.\\<alpha> x1g, x2c)\n         (ls.\\<alpha> x1f) (ls.\\<alpha> x1g, x2c) (ls.\\<alpha> x1g) x2c\n         False (x1e, x1f, x1g, x2c) x1e (x1f, x1g, x2c) x1f (x1g, x2c) x1g\n         x2c va va xa;\n        xa \\<in> it; x'a \\<in> it';\n        it' =\n        ?\\<alpha>408 (False, x1e, x1f, x1g, x2c)\n         (False, hs.\\<alpha> x1e, ls.\\<alpha> x1f, ls.\\<alpha> x1g, x2c)\n         False (hs.\\<alpha> x1e, ls.\\<alpha> x1f, ls.\\<alpha> x1g, x2c)\n         (hs.\\<alpha> x1e) (ls.\\<alpha> x1f, ls.\\<alpha> x1g, x2c)\n         (ls.\\<alpha> x1f) (ls.\\<alpha> x1g, x2c) (ls.\\<alpha> x1g) x2c\n         False (x1e, x1f, x1g, x2c) x1e (x1f, x1g, x2c) x1f (x1g, x2c) x1g\n         x2c va va `\n        it;\n        it \\<subseteq> ls.\\<alpha> (succ va);\n        it' \\<subseteq> ls.\\<alpha> (succ va);\n        FE_invar (hs.\\<alpha> x1e) (ls.\\<alpha> x1g) va it'\n         (hs.\\<alpha> x1i, ls.\\<alpha> x2i);\n        x1h = hs.\\<alpha> x1i;\n        \\<sigma>' = (hs.\\<alpha> x1i, ls.\\<alpha> x2i);\n        \\<sigma> = (x1i, x2i)\\<rbrakk>\n       \\<Longrightarrow> (xa \\<in> hs.\\<alpha> x1i) =\n                         (x'a \\<in> hs.\\<alpha> x1i)\n 4. \\<And>x x' x1 x2 x2a x2b x2c x1d x2d x1e x2e x1f x2f x1g v va xa it\n       \\<sigma> x'a it' \\<sigma>' x1h x1i x2i.\n       \\<lbrakk>\\<not> x1d; \\<not> x1 \\<and> ls.\\<alpha> x1f \\<noteq> {};\n        bfs_invar src dst\n         (False, hs.\\<alpha> x1e, ls.\\<alpha> x1f, ls.\\<alpha> x1g, x2c);\n        x2b = (ls.\\<alpha> x1g, x2c);\n        x2a = (ls.\\<alpha> x1f, ls.\\<alpha> x1g, x2c);\n        x2 = (hs.\\<alpha> x1e, ls.\\<alpha> x1f, ls.\\<alpha> x1g, x2c);\n        x' =\n        (False, hs.\\<alpha> x1e, ls.\\<alpha> x1f, ls.\\<alpha> x1g, x2c);\n        x2f = (x1g, x2c); x2e = (x1f, x1g, x2c); x2d = (x1e, x1f, x1g, x2c);\n        x = (False, x1e, x1f, x1g, x2c); v = va; va \\<in> ls.\\<alpha> x1f;\n        va \\<noteq> dst;\n        x'a =\n        ?\\<alpha>408 (False, x1e, x1f, x1g, x2c)\n         (False, hs.\\<alpha> x1e, ls.\\<alpha> x1f, ls.\\<alpha> x1g, x2c)\n         False (hs.\\<alpha> x1e, ls.\\<alpha> x1f, ls.\\<alpha> x1g, x2c)\n         (hs.\\<alpha> x1e) (ls.\\<alpha> x1f, ls.\\<alpha> x1g, x2c)\n         (ls.\\<alpha> x1f) (ls.\\<alpha> x1g, x2c) (ls.\\<alpha> x1g) x2c\n         False (x1e, x1f, x1g, x2c) x1e (x1f, x1g, x2c) x1f (x1g, x2c) x1g\n         x2c va va xa;\n        xa \\<in> it; x'a \\<in> it';\n        it' =\n        ?\\<alpha>408 (False, x1e, x1f, x1g, x2c)\n         (False, hs.\\<alpha> x1e, ls.\\<alpha> x1f, ls.\\<alpha> x1g, x2c)\n         False (hs.\\<alpha> x1e, ls.\\<alpha> x1f, ls.\\<alpha> x1g, x2c)\n         (hs.\\<alpha> x1e) (ls.\\<alpha> x1f, ls.\\<alpha> x1g, x2c)\n         (ls.\\<alpha> x1f) (ls.\\<alpha> x1g, x2c) (ls.\\<alpha> x1g) x2c\n         False (x1e, x1f, x1g, x2c) x1e (x1f, x1g, x2c) x1f (x1g, x2c) x1g\n         x2c va va `\n        it;\n        it \\<subseteq> ls.\\<alpha> (succ va);\n        it' \\<subseteq> ls.\\<alpha> (succ va);\n        FE_invar (hs.\\<alpha> x1e) (ls.\\<alpha> x1g) va it'\n         (hs.\\<alpha> x1i, ls.\\<alpha> x2i);\n        x1h = hs.\\<alpha> x1i;\n        \\<sigma>' = (hs.\\<alpha> x1i, ls.\\<alpha> x2i);\n        \\<sigma> = (x1i, x2i); xa \\<notin> hs.\\<alpha> x1i;\n        x'a \\<notin> hs.\\<alpha> x1i; x'a \\<notin> ls.\\<alpha> x2i\\<rbrakk>\n       \\<Longrightarrow> insert x'a (hs.\\<alpha> x1i) =\n                         insert xa (hs.\\<alpha> x1i) \\<and>\n                         insert x'a (ls.\\<alpha> x2i) =\n                         ls.\\<alpha> (ls.ins_dj xa x2i)", "apply (rule inj_on_id)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x x' x1 x2 x2a x2b x2c x1d x2d x1e x2e x1f x2f x1g v va.\n       \\<lbrakk>\\<not> x1d; \\<not> x1 \\<and> ls.\\<alpha> x1f \\<noteq> {};\n        bfs_invar src dst\n         (False, hs.\\<alpha> x1e, ls.\\<alpha> x1f, ls.\\<alpha> x1g, x2c);\n        x2b = (ls.\\<alpha> x1g, x2c);\n        x2a = (ls.\\<alpha> x1f, ls.\\<alpha> x1g, x2c);\n        x2 = (hs.\\<alpha> x1e, ls.\\<alpha> x1f, ls.\\<alpha> x1g, x2c);\n        x' =\n        (False, hs.\\<alpha> x1e, ls.\\<alpha> x1f, ls.\\<alpha> x1g, x2c);\n        x2f = (x1g, x2c); x2e = (x1f, x1g, x2c); x2d = (x1e, x1f, x1g, x2c);\n        x = (False, x1e, x1f, x1g, x2c); v = va; va \\<in> ls.\\<alpha> x1f;\n        va \\<noteq> dst\\<rbrakk>\n       \\<Longrightarrow> ls.\\<alpha> (succ va) = id ` ls.\\<alpha> (succ va)\n 2. \\<And>x x' x1 x2 x2a x2b x2c x1d x2d x1e x2e x1f x2f x1g v va xa it\n       \\<sigma> x'a it' \\<sigma>' x1h x1i x2i.\n       \\<lbrakk>\\<not> x1d; \\<not> x1 \\<and> ls.\\<alpha> x1f \\<noteq> {};\n        bfs_invar src dst\n         (False, hs.\\<alpha> x1e, ls.\\<alpha> x1f, ls.\\<alpha> x1g, x2c);\n        x2b = (ls.\\<alpha> x1g, x2c);\n        x2a = (ls.\\<alpha> x1f, ls.\\<alpha> x1g, x2c);\n        x2 = (hs.\\<alpha> x1e, ls.\\<alpha> x1f, ls.\\<alpha> x1g, x2c);\n        x' =\n        (False, hs.\\<alpha> x1e, ls.\\<alpha> x1f, ls.\\<alpha> x1g, x2c);\n        x2f = (x1g, x2c); x2e = (x1f, x1g, x2c); x2d = (x1e, x1f, x1g, x2c);\n        x = (False, x1e, x1f, x1g, x2c); v = va; va \\<in> ls.\\<alpha> x1f;\n        va \\<noteq> dst; x'a = id xa; xa \\<in> it; x'a \\<in> it';\n        it' = id ` it; it \\<subseteq> ls.\\<alpha> (succ va);\n        it' \\<subseteq> ls.\\<alpha> (succ va);\n        FE_invar (hs.\\<alpha> x1e) (ls.\\<alpha> x1g) va it'\n         (hs.\\<alpha> x1i, ls.\\<alpha> x2i);\n        x1h = hs.\\<alpha> x1i;\n        \\<sigma>' = (hs.\\<alpha> x1i, ls.\\<alpha> x2i);\n        \\<sigma> = (x1i, x2i)\\<rbrakk>\n       \\<Longrightarrow> (xa \\<in> hs.\\<alpha> x1i) =\n                         (x'a \\<in> hs.\\<alpha> x1i)\n 3. \\<And>x x' x1 x2 x2a x2b x2c x1d x2d x1e x2e x1f x2f x1g v va xa it\n       \\<sigma> x'a it' \\<sigma>' x1h x1i x2i.\n       \\<lbrakk>\\<not> x1d; \\<not> x1 \\<and> ls.\\<alpha> x1f \\<noteq> {};\n        bfs_invar src dst\n         (False, hs.\\<alpha> x1e, ls.\\<alpha> x1f, ls.\\<alpha> x1g, x2c);\n        x2b = (ls.\\<alpha> x1g, x2c);\n        x2a = (ls.\\<alpha> x1f, ls.\\<alpha> x1g, x2c);\n        x2 = (hs.\\<alpha> x1e, ls.\\<alpha> x1f, ls.\\<alpha> x1g, x2c);\n        x' =\n        (False, hs.\\<alpha> x1e, ls.\\<alpha> x1f, ls.\\<alpha> x1g, x2c);\n        x2f = (x1g, x2c); x2e = (x1f, x1g, x2c); x2d = (x1e, x1f, x1g, x2c);\n        x = (False, x1e, x1f, x1g, x2c); v = va; va \\<in> ls.\\<alpha> x1f;\n        va \\<noteq> dst; x'a = id xa; xa \\<in> it; x'a \\<in> it';\n        it' = id ` it; it \\<subseteq> ls.\\<alpha> (succ va);\n        it' \\<subseteq> ls.\\<alpha> (succ va);\n        FE_invar (hs.\\<alpha> x1e) (ls.\\<alpha> x1g) va it'\n         (hs.\\<alpha> x1i, ls.\\<alpha> x2i);\n        x1h = hs.\\<alpha> x1i;\n        \\<sigma>' = (hs.\\<alpha> x1i, ls.\\<alpha> x2i);\n        \\<sigma> = (x1i, x2i); xa \\<notin> hs.\\<alpha> x1i;\n        x'a \\<notin> hs.\\<alpha> x1i; x'a \\<notin> ls.\\<alpha> x2i\\<rbrakk>\n       \\<Longrightarrow> insert x'a (hs.\\<alpha> x1i) =\n                         insert xa (hs.\\<alpha> x1i) \\<and>\n                         insert x'a (ls.\\<alpha> x2i) =\n                         ls.\\<alpha> (ls.ins_dj xa x2i)", "apply (simp_all add: refine_hsimp refine_rel_defs\n        hs.correct hs.sng_correct ls.correct ls.sng_correct\n        split: prod.split prod.split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  bfs_impl succ src dst \\<le> \\<Down> Id (bfs src dst)\n\ngoal (1 subgoal):\n 1. bfs_impl succ src dst \\<le> bfs_spec src dst", "txt \\<open>The result then follows due to transitivity of refinement.\\<close>"], ["proof (state)\nthis:\n  bfs_impl succ src dst \\<le> \\<Down> Id (bfs src dst)\n\ngoal (1 subgoal):\n 1. bfs_impl succ src dst \\<le> bfs_spec src dst", "also"], ["proof (state)\nthis:\n  bfs_impl succ src dst \\<le> \\<Down> Id (bfs src dst)\n\ngoal (1 subgoal):\n 1. bfs_impl succ src dst \\<le> bfs_spec src dst", "have \"\\<dots> \\<le> bfs_spec src dst\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Down> Id (bfs src dst) \\<le> bfs_spec src dst", "by (simp add: bfs_correct)"], ["proof (state)\nthis:\n  \\<Down> Id (bfs src dst) \\<le> bfs_spec src dst\n\ngoal (1 subgoal):\n 1. bfs_impl succ src dst \\<le> bfs_spec src dst", "finally"], ["proof (chain)\npicking this:\n  bfs_impl succ src dst \\<le> bfs_spec src dst", "show ?thesis"], ["proof (prove)\nusing this:\n  bfs_impl succ src dst \\<le> bfs_spec src dst\n\ngoal (1 subgoal):\n 1. bfs_impl succ src dst \\<le> bfs_spec src dst", "."], ["proof (state)\nthis:\n  bfs_impl succ src dst \\<le> bfs_spec src dst\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The last step is to actually generate executable ML-code.\n\\<close>"], ["", "text \\<open>\n    We first use the partial-correctness code generator of our framework\n    to automatically turn the algorithm described in our framework into\n    a function that is independent from our framework. This step also\n    removes the last nondeterminism, that has remained in the iteration order\n    of the inner loop.\n\n    The result of the function is an option type, returning \\<open>None\\<close>\n    for nontermination. Inside this option-type, there is the option type\n    that encodes whether we return with failure or a distance.\n\\<close>"], ["", "schematic_goal bfs_code_refine_aux: \n    \"nres_of ?bfs_code \\<le> bfs_impl succ src dst\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nres_of ?bfs_code \\<le> bfs_impl succ src dst", "unfolding bfs_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nres_of ?bfs_code\n    \\<le> WHILE\n           (\\<lambda>(f, V, C, N, d). f = False \\<and> \\<not> ls.isEmpty C)\n           (\\<lambda>(f, V, C, N, d).\n               RETURN (the (ls.sel C (\\<lambda>_. True))) \\<bind>\n               (\\<lambda>v.\n                   let C = ls.delete v C\n                   in if v = dst\n                      then RETURN\n                            (True, hs.empty (), ls.empty (), ls.empty (), d)\n                      else FOREACH (ls.\\<alpha> (succ v))\n                            (\\<lambda>w (V, N).\n                                if \\<not> hs.memb w V\n                                then RETURN (hs.ins w V, ls.ins_dj w N)\n                                else RETURN (V, N))\n                            (V, N) \\<bind>\n                           (\\<lambda>(V, N).\n                               if ls.isEmpty C\n                               then let C = N; N = ls.empty (); d = d + 1\n                                    in RETURN (f, V, C, N, d)\n                               else RETURN (f, V, C, N, d))))\n           (False, hs.sng src, ls.sng src, ls.empty (), 0) \\<bind>\n          (\\<lambda>(f, uu_, uu_, uu_, d).\n              if f then RETURN (Some d) else RETURN None)", "apply (refine_transfer)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "concrete_definition bfs_code for succ src dst uses bfs_code_refine_aux"], ["", "text \\<open>\n    As a last step, we make the correctness property independent of our \n    refinement framework. This step drastically decreases the trusted code \n    base, as it completely eliminates the specifications made in the\n    refinement framework from the trusted code base.\n\n    The following theorem solves both verification tasks, without depending\n    on any concepts of the refinement framework, except the deterministic result\n    monad.\n\\<close>"], ["", "theorem bfs_code_correct:\n    \"bfs_code succ src dst = dRETURN None \n      \\<Longrightarrow> \\<not>(Graph.conn (ls.\\<alpha> \\<circ> succ) src dst)\" \n    \"bfs_code succ src dst = dRETURN (Some d) \n      \\<Longrightarrow> Graph.conn (ls.\\<alpha> \\<circ> succ) src dst \n          \\<and> Graph.min_dist (ls.\\<alpha> \\<circ> succ) src dst = d\"\n    \"bfs_code succ src dst \\<noteq> dFAIL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bfs_code succ src dst = dRETURN None \\<Longrightarrow>\n     \\<not> Graph.conn (ls.\\<alpha> \\<circ> succ) src dst) &&&\n    (bfs_code succ src dst = dRETURN (Some d) \\<Longrightarrow>\n     Graph.conn (ls.\\<alpha> \\<circ> succ) src dst \\<and>\n     Graph.min_dist (ls.\\<alpha> \\<circ> succ) src dst = d) &&&\n    bfs_code succ src dst \\<noteq> dFAIL", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. bfs_code succ src dst = dRETURN None \\<Longrightarrow>\n    \\<not> Graph.conn (ls.\\<alpha> \\<circ> succ) src dst\n 2. bfs_code succ src dst = dRETURN (Some d) \\<Longrightarrow>\n    Graph.conn (ls.\\<alpha> \\<circ> succ) src dst \\<and>\n    Graph.min_dist (ls.\\<alpha> \\<circ> succ) src dst = d\n 3. bfs_code succ src dst \\<noteq> dFAIL", "interpret Graph \"ls.\\<alpha>\\<circ>succ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Graph (ls.\\<alpha> \\<circ> succ)", "by unfold_locales simp"], ["proof (state)\ngoal (3 subgoals):\n 1. bfs_code succ src dst = dRETURN None \\<Longrightarrow>\n    \\<not> conn src dst\n 2. bfs_code succ src dst = dRETURN (Some d) \\<Longrightarrow>\n    conn src dst \\<and> min_dist src dst = d\n 3. bfs_code succ src dst \\<noteq> dFAIL", "from order_trans[OF bfs_code.refine bfs_impl_correct, of succ src dst]"], ["proof (chain)\npicking this:\n  nres_of (bfs_code succ src dst) \\<le> bfs_spec src dst", "show \"bfs_code succ src dst = dRETURN None \n      \\<Longrightarrow> \\<not>(Graph.conn (ls.\\<alpha> \\<circ> succ) src dst)\" \n      \"bfs_code succ src dst = dRETURN (Some d) \n      \\<Longrightarrow> Graph.conn (ls.\\<alpha> \\<circ> succ) src dst \n          \\<and> Graph.min_dist (ls.\\<alpha> \\<circ> succ) src dst = d\"\n      \"bfs_code succ src dst \\<noteq> dFAIL\""], ["proof (prove)\nusing this:\n  nres_of (bfs_code succ src dst) \\<le> bfs_spec src dst\n\ngoal (1 subgoal):\n 1. (bfs_code succ src dst = dRETURN None \\<Longrightarrow>\n     \\<not> conn src dst) &&&\n    (bfs_code succ src dst = dRETURN (Some d) \\<Longrightarrow>\n     conn src dst \\<and> min_dist src dst = d) &&&\n    bfs_code succ src dst \\<noteq> dFAIL", "apply (unfold bfs_spec_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>bfs_code succ src dst = dRETURN None;\n     nres_of (bfs_code succ src dst)\n     \\<le> SPEC\n            (\\<lambda>r.\n                case r of None \\<Rightarrow> \\<not> conn src dst\n                | Some d \\<Rightarrow>\n                    conn src dst \\<and> min_dist src dst = d)\\<rbrakk>\n    \\<Longrightarrow> \\<not> conn src dst\n 2. \\<lbrakk>bfs_code succ src dst = dRETURN (Some d);\n     nres_of (bfs_code succ src dst)\n     \\<le> SPEC\n            (\\<lambda>r.\n                case r of None \\<Rightarrow> \\<not> conn src dst\n                | Some d \\<Rightarrow>\n                    conn src dst \\<and> min_dist src dst = d)\\<rbrakk>\n    \\<Longrightarrow> conn src dst \\<and> min_dist src dst = d\n 3. nres_of (bfs_code succ src dst)\n    \\<le> SPEC\n           (\\<lambda>r.\n               case r of None \\<Rightarrow> \\<not> conn src dst\n               | Some d \\<Rightarrow>\n                   conn src dst \\<and>\n                   min_dist src dst = d) \\<Longrightarrow>\n    bfs_code succ src dst \\<noteq> dFAIL", "apply (auto split: option.split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  bfs_code succ src dst = dRETURN None \\<Longrightarrow> \\<not> conn src dst\n  bfs_code succ src dst = dRETURN (Some d) \\<Longrightarrow>\n  conn src dst \\<and> min_dist src dst = d\n  bfs_code succ src dst \\<noteq> dFAIL\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Now we can use the code-generator of Isabelle/HOL to generate\n    code into various target languages:\\<close>"], ["", "export_code bfs_code checking SML"], ["", "export_code bfs_code checking OCaml?"], ["", "export_code bfs_code checking Haskell?"], ["", "export_code bfs_code checking Scala"], ["", "text \\<open>The generated code is most conveniently executed within \n    Isabelle/HOL itself. We use a small test graph here:\\<close>"], ["", "definition nat_list:: \"nat list \\<Rightarrow> _\" where \"nat_list \\<equiv> dlist_of_list\""], ["", "ML_val \\<open>\n    fun il l = @{code nat_list} (map @{code nat_of_integer} l)\n    fun bfs succ s d = \n      @{code bfs_code} (succ o @{code integer_of_nat})\n        (@{code nat_of_integer} s) (@{code nat_of_integer} d)\n\n    (* Define a test graph. *)\n    fun succ 1 = il [2,3]\n        | succ 2 = il [4]\n        | succ 4 = il [5]\n        | succ 5 = il [2]\n        | succ 3 = il [6]\n        | succ _ = il [];\n\n    (* Execute algorithm for some node pairs. *)\n    bfs succ 1 1;\n    bfs succ 1 2;\n    bfs succ 1 5;\n    bfs succ 1 7;\n\\<close>"], ["", "end"]]}