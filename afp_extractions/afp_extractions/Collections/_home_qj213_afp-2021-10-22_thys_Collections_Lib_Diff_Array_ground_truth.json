{"file_name": "/home/qj213/afp-2021-10-22/thys/Collections/Lib/Diff_Array.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Collections", "problem_names": ["lemma array_length_new_array [simp]:\n  \"array_length (new_array a n) = n\"", "lemma array_length_array_set [simp]:\n  \"array_length (array_set a i e) = array_length a\"", "lemma array_get_new_array [simp]:\n  \"i < n \\<Longrightarrow> array_get (new_array a n) i = a\"", "lemma array_get_array_set_same [simp]:\n  \"n < array_length A \\<Longrightarrow> array_get (array_set A n a) n = a\"", "lemma array_get_array_set_other:\n  \"n \\<noteq> n' \\<Longrightarrow> array_get (array_set A n a) n' = array_get A n'\"", "lemma list_of_array_grow [simp]:\n  \"list_of_array (array_grow a inc x) = list_of_array a @ replicate inc x\"", "lemma array_grow_length [simp]:\n  \"array_length (array_grow a inc x) = array_length a + inc\"", "lemma array_grow_get [simp]:\n  \"i < array_length a \\<Longrightarrow> array_get (array_grow a inc x) i = array_get a i\"\n  \"\\<lbrakk> i \\<ge> array_length a;  i < array_length a + inc\\<rbrakk> \\<Longrightarrow> array_get (array_grow a inc x) i = x\"", "lemma list_of_array_shrink [simp]:\n  \"\\<lbrakk> s \\<le> array_length a\\<rbrakk> \\<Longrightarrow> list_of_array (array_shrink a s) = take s (list_of_array a)\"", "lemma array_shrink_get [simp]:\n  \"\\<lbrakk> i < s; s \\<le> array_length a \\<rbrakk> \\<Longrightarrow> array_get (array_shrink a s) i = array_get a i\"", "lemma list_of_array_id [simp]: \"list_of_array (array_of_list l) = l\"", "lemma map_of_assoc_list_of_array:\n  \"map_of (assoc_list_of_array a) k = (if k < array_length a then Some (array_get a k) else None)\"", "lemma length_assoc_list_of_array [simp]:\n  \"length (assoc_list_of_array a) = array_length a\"", "lemma distinct_assoc_list_of_array:\n  \"distinct (map fst (assoc_list_of_array a))\"", "lemma array_length_array_map [simp]:\n  \"array_length (array_map f a) = array_length a\"", "lemma array_get_array_map [simp]:\n  \"i < array_length a \\<Longrightarrow> array_get (array_map f a) i = f i (array_get a i)\"", "lemma array_foldr_foldr:\n  \"array_foldr (\\<lambda>n. f) (Array a) b = foldr f a b\"", "lemma assoc_list_of_array_code_induct:\n  assumes IH: \"\\<And>n. (n < array_length a \\<Longrightarrow> P (Suc n)) \\<Longrightarrow> P n\"\n  shows \"P n\"", "lemma assoc_list_of_array_code [code]:\n  \"assoc_list_of_array a = assoc_list_of_array_code a 0\"", "lemma list_of_array_code [code]:\n  \"list_of_array a = array_foldr (\\<lambda>n. Cons) a []\"", "lemma array_foldr_cong [fundef_cong]:\n  \"\\<lbrakk> a = a'; b = b';\n    \\<And>i b. i < array_length a \\<Longrightarrow> f i (array_get a i) b = g i (array_get a i) b \\<rbrakk>\n  \\<Longrightarrow> array_foldr f a b = array_foldr g a' b'\"", "lemma array_foldl_foldl:\n  \"array_foldl (\\<lambda>n. f) b (Array a) = foldl f b a\"", "lemma array_map_conv_foldl_array_set:\n  assumes len: \"array_length A = array_length a\"\n  shows \"array_map f a = foldl (\\<lambda>A (k, v). array_set A k (f k v)) A (assoc_list_of_array a)\"", "lemma array_length_eq_0 [simp]:\n  \"array_length a = 0 \\<longleftrightarrow> a = Array []\"", "lemma new_array_0 [simp]: \"new_array v 0 = Array []\"", "lemma array_of_list_Nil [simp]:\n  \"array_of_list [] = Array []\"", "lemma array_map_Nil [simp]:\n  \"array_map f (Array []) = Array []\"", "lemma array_foldl_Nil [simp]:\n  \"array_foldl f b (Array []) = b\"", "lemma array_foldr_Nil [simp]:\n  \"array_foldr f (Array []) b = b\"", "lemma prod_foldl_conv:\n  \"(foldl f a xs, foldl g b xs) = foldl (\\<lambda>(a, b) x. (f a x, g b x)) (a, b) xs\"", "lemma prod_array_foldl_conv:\n  \"(array_foldl f b a, array_foldl g c a) = array_foldl (\\<lambda>h (b, c) v. (f h b v, g h c v)) (b, c) a\"", "lemma array_foldl_array_foldr_comm:\n  \"comp_fun_commute (\\<lambda>(h, v) b. f h b v) \\<Longrightarrow> array_foldl f b a = array_foldr (\\<lambda>h v b. f h b v) a b\"", "lemma array_map_conv_array_foldl:\n  \"array_map f a = array_foldl (\\<lambda>h a v. array_set a h (f h v)) a a\"", "lemma array_foldl_new_array:\n  \"array_foldl f b (new_array a n) = foldl (\\<lambda>b (k, v). f k b v) b (zip [0..<n] (replicate n a))\"", "lemma array_list_of_set[simp]:\n  \"list_of_array (array_set a i x) = (list_of_array a) [i := x]\"", "lemma array_length_list: \"array_length a = length (list_of_array a)\"", "lemma rec_array_is_case[simp]: \"rec_array = case_array\"", "lemma array_rel_def:\n  \"\\<langle>R\\<rangle>array_rel \\<equiv> {(Array xs, Array ys)|xs ys. (xs,ys) \\<in> \\<langle>R\\<rangle>list_rel}\"", "lemma array_relD:\n  \"(Array l, Array l') \\<in> \\<langle>R\\<rangle>array_rel \\<Longrightarrow> (l,l') \\<in> \\<langle>R\\<rangle>list_rel\"", "lemma array_rel_alt:\n  \"\\<langle>R\\<rangle>array_rel =\n  { (Array l, l) | l. True }\n  O \\<langle>R\\<rangle>list_rel\n  O {(l,Array l) | l. True}\"", "lemma array_rel_sv[relator_props]:\n  shows \"single_valued R \\<Longrightarrow> single_valued (\\<langle>R\\<rangle>array_rel)\"", "lemma param_Array[param]:\n  \"(Array,Array) \\<in> \\<langle>R\\<rangle> list_rel \\<rightarrow> \\<langle>R\\<rangle> array_rel\"", "lemma param_rec_array[param]:\n  \"(rec_array,rec_array) \\<in> (\\<langle>Ra\\<rangle>list_rel \\<rightarrow> Rb) \\<rightarrow> \\<langle>Ra\\<rangle>array_rel \\<rightarrow> Rb\"", "lemma param_case_array[param]:\n  \"(case_array,case_array) \\<in> (\\<langle>Ra\\<rangle>list_rel \\<rightarrow> Rb) \\<rightarrow> \\<langle>Ra\\<rangle>array_rel \\<rightarrow> Rb\"", "lemma param_case_array1':\n  assumes \"(a,a')\\<in>\\<langle>Ra\\<rangle>array_rel\"\n  assumes \"\\<And>l l'. \\<lbrakk> a=Array l; a'=Array l'; (l,l')\\<in>\\<langle>Ra\\<rangle>list_rel \\<rbrakk>\n    \\<Longrightarrow> (f l,f' l') \\<in> Rb\"\n  shows \"(case_array f a,case_array f' a') \\<in> Rb\"", "lemmas param_case_array2' = param_case_array1'[folded rec_array_is_case]", "lemmas param_case_array' = param_case_array1' param_case_array2'", "lemma param_array_length[param]:\n    \"(array_length,array_length) \\<in> \\<langle>Rb\\<rangle>array_rel \\<rightarrow> nat_rel\"", "lemma param_array_grow[param]:\n  \"(array_grow,array_grow) \\<in> \\<langle>R\\<rangle>array_rel \\<rightarrow> nat_rel \\<rightarrow> R \\<rightarrow> \\<langle>R\\<rangle>array_rel\"", "lemma array_rel_imp_same_length:\n  \"(a, a') \\<in> \\<langle>R\\<rangle>array_rel \\<Longrightarrow> array_length a = array_length a'\"", "lemma param_array_get[param]:\n  assumes I: \"i<array_length a\"\n  assumes IR: \"(i,i')\\<in>nat_rel\"\n  assumes AR: \"(a,a')\\<in>\\<langle>R\\<rangle>array_rel\"\n  shows \"(array_get a i, array_get a' i') \\<in> R\"", "lemma param_array_set[param]:\n  \"(array_set,array_set)\\<in>\\<langle>R\\<rangle>array_rel\\<rightarrow>nat_rel\\<rightarrow>R\\<rightarrow>\\<langle>R\\<rangle>array_rel\"", "lemma param_array_of_list[param]:\n  \"(array_of_list, array_of_list) \\<in> \\<langle>R\\<rangle> list_rel \\<rightarrow> \\<langle>R\\<rangle> array_rel\"", "lemma param_array_shrink[param]:\n  assumes N: \"array_length a \\<ge> n\"\n  assumes NR: \"(n,n')\\<in>nat_rel\"\n  assumes AR: \"(a,a')\\<in>\\<langle>R\\<rangle>array_rel\"\n  shows \"(array_shrink a n, array_shrink a' n') \\<in> \\<langle>R\\<rangle> array_rel\"", "lemma param_assoc_list_of_array[param]:\n  \"(assoc_list_of_array, assoc_list_of_array) \\<in>\n       \\<langle>R\\<rangle> array_rel \\<rightarrow> \\<langle>\\<langle>nat_rel,R\\<rangle>prod_rel\\<rangle>list_rel\"", "lemma param_array_map[param]:\n  \"(array_map, array_map) \\<in>\n       (nat_rel \\<rightarrow> Ra \\<rightarrow> Rb) \\<rightarrow> \\<langle>Ra\\<rangle>array_rel \\<rightarrow> \\<langle>Rb\\<rangle>array_rel\"", "lemma param_array_foldr[param]:\n  \"(array_foldr, array_foldr) \\<in>\n       (nat_rel \\<rightarrow> Ra \\<rightarrow> Rb \\<rightarrow> Rb) \\<rightarrow> \\<langle>Ra\\<rangle>array_rel \\<rightarrow> Rb \\<rightarrow> Rb\"", "lemma param_array_foldl[param]:\n  \"(array_foldl, array_foldl) \\<in>\n       (nat_rel \\<rightarrow> Rb \\<rightarrow> Ra \\<rightarrow> Rb) \\<rightarrow> Rb \\<rightarrow> \\<langle>Ra\\<rangle>array_rel \\<rightarrow> Rb\"", "lemma [code]:\n  \"new_array v == new_array' v o integer_of_nat\"\n  \"array_length == nat_of_integer o array_length'\"\n  \"array_get a == array_get' a o integer_of_nat\"\n  \"array_set a == array_set' a o integer_of_nat\"\n  \"array_grow a == array_grow' a o integer_of_nat\"\n  \"array_shrink a == array_shrink' a o integer_of_nat\"\n  \"array_get_oo x a == array_get_oo' x a o integer_of_nat\"\n  \"array_set_oo f a == array_set_oo' f a o integer_of_nat\"", "lemmas [code] = array_get_oo'_def[unfolded array_get_oo_def[abs_def]]", "lemmas [code] = array_set_oo'_def[unfolded array_set_oo_def[abs_def]]"], "translations": [["", "lemma array_length_new_array [simp]:\n  \"array_length (new_array a n) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. array_length (new_array a n) = n", "by(simp add: new_array_def)"], ["", "lemma array_length_array_set [simp]:\n  \"array_length (array_set a i e) = array_length a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. array_length (array_set a i e) = array_length a", "by(cases a) simp"], ["", "lemma array_get_new_array [simp]:\n  \"i < n \\<Longrightarrow> array_get (new_array a n) i = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < n \\<Longrightarrow> array_get (new_array a n) i = a", "by(simp add: new_array_def)"], ["", "lemma array_get_array_set_same [simp]:\n  \"n < array_length A \\<Longrightarrow> array_get (array_set A n a) n = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < array_length A \\<Longrightarrow> array_get (array_set A n a) n = a", "by(cases A) simp"], ["", "lemma array_get_array_set_other:\n  \"n \\<noteq> n' \\<Longrightarrow> array_get (array_set A n a) n' = array_get A n'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<noteq> n' \\<Longrightarrow>\n    array_get (array_set A n a) n' = array_get A n'", "by(cases A) simp"], ["", "lemma list_of_array_grow [simp]:\n  \"list_of_array (array_grow a inc x) = list_of_array a @ replicate inc x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_array (array_grow a inc x) = list_of_array a @ replicate inc x", "by (cases a) (simp)"], ["", "lemma array_grow_length [simp]:\n  \"array_length (array_grow a inc x) = array_length a + inc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. array_length (array_grow a inc x) = array_length a + inc", "by (cases a)(simp add: array_of_list_def)"], ["", "lemma array_grow_get [simp]:\n  \"i < array_length a \\<Longrightarrow> array_get (array_grow a inc x) i = array_get a i\"\n  \"\\<lbrakk> i \\<ge> array_length a;  i < array_length a + inc\\<rbrakk> \\<Longrightarrow> array_get (array_grow a inc x) i = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (i < array_length a \\<Longrightarrow>\n     array_get (array_grow a inc x) i = array_get a i) &&&\n    (\\<lbrakk>array_length a \\<le> i; i < array_length a + inc\\<rbrakk>\n     \\<Longrightarrow> array_get (array_grow a inc x) i = x)", "by (cases a, simp add: nth_append)+"], ["", "lemma list_of_array_shrink [simp]:\n  \"\\<lbrakk> s \\<le> array_length a\\<rbrakk> \\<Longrightarrow> list_of_array (array_shrink a s) = take s (list_of_array a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<le> array_length a \\<Longrightarrow>\n    list_of_array (array_shrink a s) = take s (list_of_array a)", "by (cases a) simp"], ["", "lemma array_shrink_get [simp]:\n  \"\\<lbrakk> i < s; s \\<le> array_length a \\<rbrakk> \\<Longrightarrow> array_get (array_shrink a s) i = array_get a i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < s; s \\<le> array_length a\\<rbrakk>\n    \\<Longrightarrow> array_get (array_shrink a s) i = array_get a i", "by (cases a) (simp)"], ["", "lemma list_of_array_id [simp]: \"list_of_array (array_of_list l) = l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_array (array_of_list l) = l", "by (cases l)(simp_all add: array_of_list_def)"], ["", "lemma map_of_assoc_list_of_array:\n  \"map_of (assoc_list_of_array a) k = (if k < array_length a then Some (array_get a k) else None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (assoc_list_of_array a) k =\n    (if k < array_length a then Some (array_get a k) else None)", "by(cases a, cases \"k < array_length a\")(force simp add: set_zip)+"], ["", "lemma length_assoc_list_of_array [simp]:\n  \"length (assoc_list_of_array a) = array_length a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (assoc_list_of_array a) = array_length a", "by(cases a) simp"], ["", "lemma distinct_assoc_list_of_array:\n  \"distinct (map fst (assoc_list_of_array a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst (assoc_list_of_array a))", "by(cases a)(auto)"], ["", "lemma array_length_array_map [simp]:\n  \"array_length (array_map f a) = array_length a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. array_length (array_map f a) = array_length a", "by(simp add: array_map_def array_of_list_def)"], ["", "lemma array_get_array_map [simp]:\n  \"i < array_length a \\<Longrightarrow> array_get (array_map f a) i = f i (array_get a i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < array_length a \\<Longrightarrow>\n    array_get (array_map f a) i = f i (array_get a i)", "by(cases a)(simp add: array_map_def map_ran_conv_map array_of_list_def)"], ["", "lemma array_foldr_foldr:\n  \"array_foldr (\\<lambda>n. f) (Array a) b = foldr f a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. array_foldr (\\<lambda>n. f) (Array a) b = foldr f a b", "by(simp add: array_foldr_def foldr_snd_zip)"], ["", "lemma assoc_list_of_array_code_induct:\n  assumes IH: \"\\<And>n. (n < array_length a \\<Longrightarrow> P (Suc n)) \\<Longrightarrow> P n\"\n  shows \"P n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P n", "have \"a = a \\<longrightarrow> P n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = a \\<longrightarrow> P n", "by(rule assoc_list_of_array_code.induct[where P=\"\\<lambda>a' n. a = a' \\<longrightarrow> P n\"])(auto intro: IH)"], ["proof (state)\nthis:\n  a = a \\<longrightarrow> P n\n\ngoal (1 subgoal):\n 1. P n", "thus ?thesis"], ["proof (prove)\nusing this:\n  a = a \\<longrightarrow> P n\n\ngoal (1 subgoal):\n 1. P n", "by simp"], ["proof (state)\nthis:\n  P n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma assoc_list_of_array_code [code]:\n  \"assoc_list_of_array a = assoc_list_of_array_code a 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. assoc_list_of_array a = assoc_list_of_array_code a 0", "proof(cases a)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       a = Array x \\<Longrightarrow>\n       assoc_list_of_array a = assoc_list_of_array_code a 0", "case (Array A)"], ["proof (state)\nthis:\n  a = Array A\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       a = Array x \\<Longrightarrow>\n       assoc_list_of_array a = assoc_list_of_array_code a 0", "{"], ["proof (state)\nthis:\n  a = Array A\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       a = Array x \\<Longrightarrow>\n       assoc_list_of_array a = assoc_list_of_array_code a 0", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       a = Array x \\<Longrightarrow>\n       assoc_list_of_array a = assoc_list_of_array_code a 0", "have \"zip [n..<length A] (drop n A) = assoc_list_of_array_code (Array A) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zip [n..<length A] (drop n A) = assoc_list_of_array_code (Array A) n", "proof(induct n taking: \"Array A\" rule: assoc_list_of_array_code_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       (n < array_length (Array A) \\<Longrightarrow>\n        zip [Suc n..<length A] (drop (Suc n) A) =\n        assoc_list_of_array_code (Array A) (Suc n)) \\<Longrightarrow>\n       zip [n..<length A] (drop n A) = assoc_list_of_array_code (Array A) n", "case (1 n)"], ["proof (state)\nthis:\n  n < array_length (Array A) \\<Longrightarrow>\n  zip [Suc n..<length A] (drop (Suc n) A) =\n  assoc_list_of_array_code (Array A) (Suc n)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       (n < array_length (Array A) \\<Longrightarrow>\n        zip [Suc n..<length A] (drop (Suc n) A) =\n        assoc_list_of_array_code (Array A) (Suc n)) \\<Longrightarrow>\n       zip [n..<length A] (drop n A) = assoc_list_of_array_code (Array A) n", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. zip [n..<length A] (drop n A) = assoc_list_of_array_code (Array A) n", "proof(cases \"n < array_length (Array A)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n < array_length (Array A) \\<Longrightarrow>\n    zip [n..<length A] (drop n A) = assoc_list_of_array_code (Array A) n\n 2. \\<not> n < array_length (Array A) \\<Longrightarrow>\n    zip [n..<length A] (drop n A) = assoc_list_of_array_code (Array A) n", "case False"], ["proof (state)\nthis:\n  \\<not> n < array_length (Array A)\n\ngoal (2 subgoals):\n 1. n < array_length (Array A) \\<Longrightarrow>\n    zip [n..<length A] (drop n A) = assoc_list_of_array_code (Array A) n\n 2. \\<not> n < array_length (Array A) \\<Longrightarrow>\n    zip [n..<length A] (drop n A) = assoc_list_of_array_code (Array A) n", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> n < array_length (Array A)\n\ngoal (1 subgoal):\n 1. zip [n..<length A] (drop n A) = assoc_list_of_array_code (Array A) n", "by(simp add: assoc_list_of_array_code.simps)"], ["proof (state)\nthis:\n  zip [n..<length A] (drop n A) = assoc_list_of_array_code (Array A) n\n\ngoal (1 subgoal):\n 1. n < array_length (Array A) \\<Longrightarrow>\n    zip [n..<length A] (drop n A) = assoc_list_of_array_code (Array A) n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n < array_length (Array A) \\<Longrightarrow>\n    zip [n..<length A] (drop n A) = assoc_list_of_array_code (Array A) n", "case True"], ["proof (state)\nthis:\n  n < array_length (Array A)\n\ngoal (1 subgoal):\n 1. n < array_length (Array A) \\<Longrightarrow>\n    zip [n..<length A] (drop n A) = assoc_list_of_array_code (Array A) n", "hence \"zip [Suc n..<length A] (drop (Suc n) A) = assoc_list_of_array_code (Array A) (Suc n)\""], ["proof (prove)\nusing this:\n  n < array_length (Array A)\n\ngoal (1 subgoal):\n 1. zip [Suc n..<length A] (drop (Suc n) A) =\n    assoc_list_of_array_code (Array A) (Suc n)", "by(rule 1)"], ["proof (state)\nthis:\n  zip [Suc n..<length A] (drop (Suc n) A) =\n  assoc_list_of_array_code (Array A) (Suc n)\n\ngoal (1 subgoal):\n 1. n < array_length (Array A) \\<Longrightarrow>\n    zip [n..<length A] (drop n A) = assoc_list_of_array_code (Array A) n", "moreover"], ["proof (state)\nthis:\n  zip [Suc n..<length A] (drop (Suc n) A) =\n  assoc_list_of_array_code (Array A) (Suc n)\n\ngoal (1 subgoal):\n 1. n < array_length (Array A) \\<Longrightarrow>\n    zip [n..<length A] (drop n A) = assoc_list_of_array_code (Array A) n", "from True"], ["proof (chain)\npicking this:\n  n < array_length (Array A)", "have \"n < length A\""], ["proof (prove)\nusing this:\n  n < array_length (Array A)\n\ngoal (1 subgoal):\n 1. n < length A", "by simp"], ["proof (state)\nthis:\n  n < length A\n\ngoal (1 subgoal):\n 1. n < array_length (Array A) \\<Longrightarrow>\n    zip [n..<length A] (drop n A) = assoc_list_of_array_code (Array A) n", "moreover"], ["proof (state)\nthis:\n  n < length A\n\ngoal (1 subgoal):\n 1. n < array_length (Array A) \\<Longrightarrow>\n    zip [n..<length A] (drop n A) = assoc_list_of_array_code (Array A) n", "then"], ["proof (chain)\npicking this:\n  n < length A", "obtain a A' where A: \"drop n A = a # A'\""], ["proof (prove)\nusing this:\n  n < length A\n\ngoal (1 subgoal):\n 1. (\\<And>a A'.\n        drop n A = a # A' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases \"drop n A\") auto"], ["proof (state)\nthis:\n  drop n A = a # A'\n\ngoal (1 subgoal):\n 1. n < array_length (Array A) \\<Longrightarrow>\n    zip [n..<length A] (drop n A) = assoc_list_of_array_code (Array A) n", "moreover"], ["proof (state)\nthis:\n  drop n A = a # A'\n\ngoal (1 subgoal):\n 1. n < array_length (Array A) \\<Longrightarrow>\n    zip [n..<length A] (drop n A) = assoc_list_of_array_code (Array A) n", "with \\<open>n < length A\\<close>"], ["proof (chain)\npicking this:\n  n < length A\n  drop n A = a # A'", "have [simp]: \"a = A ! n\""], ["proof (prove)\nusing this:\n  n < length A\n  drop n A = a # A'\n\ngoal (1 subgoal):\n 1. a = A ! n", "by(subst append_take_drop_id[symmetric, where n=n])(simp add: nth_append min_def)"], ["proof (state)\nthis:\n  a = A ! n\n\ngoal (1 subgoal):\n 1. n < array_length (Array A) \\<Longrightarrow>\n    zip [n..<length A] (drop n A) = assoc_list_of_array_code (Array A) n", "moreover"], ["proof (state)\nthis:\n  a = A ! n\n\ngoal (1 subgoal):\n 1. n < array_length (Array A) \\<Longrightarrow>\n    zip [n..<length A] (drop n A) = assoc_list_of_array_code (Array A) n", "from A"], ["proof (chain)\npicking this:\n  drop n A = a # A'", "have \"drop (Suc n) A = A'\""], ["proof (prove)\nusing this:\n  drop n A = a # A'\n\ngoal (1 subgoal):\n 1. drop (Suc n) A = A'", "by(induct A arbitrary: n)(simp_all add: drop_Cons split: nat.split_asm)"], ["proof (state)\nthis:\n  drop (Suc n) A = A'\n\ngoal (1 subgoal):\n 1. n < array_length (Array A) \\<Longrightarrow>\n    zip [n..<length A] (drop n A) = assoc_list_of_array_code (Array A) n", "ultimately"], ["proof (chain)\npicking this:\n  zip [Suc n..<length A] (drop (Suc n) A) =\n  assoc_list_of_array_code (Array A) (Suc n)\n  n < length A\n  drop n A = a # A'\n  a = A ! n\n  drop (Suc n) A = A'", "show ?thesis"], ["proof (prove)\nusing this:\n  zip [Suc n..<length A] (drop (Suc n) A) =\n  assoc_list_of_array_code (Array A) (Suc n)\n  n < length A\n  drop n A = a # A'\n  a = A ! n\n  drop (Suc n) A = A'\n\ngoal (1 subgoal):\n 1. zip [n..<length A] (drop n A) = assoc_list_of_array_code (Array A) n", "by(subst upt_rec)(simp add: assoc_list_of_array_code.simps)"], ["proof (state)\nthis:\n  zip [n..<length A] (drop n A) = assoc_list_of_array_code (Array A) n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  zip [n..<length A] (drop n A) = assoc_list_of_array_code (Array A) n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  zip [n..<length A] (drop n A) = assoc_list_of_array_code (Array A) n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       a = Array x \\<Longrightarrow>\n       assoc_list_of_array a = assoc_list_of_array_code a 0", "}"], ["proof (state)\nthis:\n  zip [?n2..<length A] (drop ?n2 A) = assoc_list_of_array_code (Array A) ?n2\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       a = Array x \\<Longrightarrow>\n       assoc_list_of_array a = assoc_list_of_array_code a 0", "note this[of 0]"], ["proof (state)\nthis:\n  zip [0..<length A] (drop 0 A) = assoc_list_of_array_code (Array A) 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       a = Array x \\<Longrightarrow>\n       assoc_list_of_array a = assoc_list_of_array_code a 0", "with Array"], ["proof (chain)\npicking this:\n  a = Array A\n  zip [0..<length A] (drop 0 A) = assoc_list_of_array_code (Array A) 0", "show ?thesis"], ["proof (prove)\nusing this:\n  a = Array A\n  zip [0..<length A] (drop 0 A) = assoc_list_of_array_code (Array A) 0\n\ngoal (1 subgoal):\n 1. assoc_list_of_array a = assoc_list_of_array_code a 0", "by simp"], ["proof (state)\nthis:\n  assoc_list_of_array a = assoc_list_of_array_code a 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma list_of_array_code [code]:\n  \"list_of_array a = array_foldr (\\<lambda>n. Cons) a []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_array a = array_foldr (\\<lambda>n. (#)) a []", "by(cases a)(simp add: array_foldr_foldr foldr_Cons)"], ["", "lemma array_foldr_cong [fundef_cong]:\n  \"\\<lbrakk> a = a'; b = b';\n    \\<And>i b. i < array_length a \\<Longrightarrow> f i (array_get a i) b = g i (array_get a i) b \\<rbrakk>\n  \\<Longrightarrow> array_foldr f a b = array_foldr g a' b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a = a'; b = b';\n     \\<And>i b.\n        i < array_length a \\<Longrightarrow>\n        f i (array_get a i) b = g i (array_get a i) b\\<rbrakk>\n    \\<Longrightarrow> array_foldr f a b = array_foldr g a' b'", "by(cases a)(auto simp add: array_foldr_def set_zip intro!: foldr_cong)"], ["", "lemma array_foldl_foldl:\n  \"array_foldl (\\<lambda>n. f) b (Array a) = foldl f b a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. array_foldl (\\<lambda>n. f) b (Array a) = foldl f b a", "by(simp add: array_foldl_def foldl_snd_zip)"], ["", "lemma array_map_conv_foldl_array_set:\n  assumes len: \"array_length A = array_length a\"\n  shows \"array_map f a = foldl (\\<lambda>A (k, v). array_set A k (f k v)) A (assoc_list_of_array a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. array_map f a =\n    foldl (\\<lambda>A (k, v). array_set A k (f k v)) A\n     (assoc_list_of_array a)", "proof(cases a)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       a = Array x \\<Longrightarrow>\n       array_map f a =\n       foldl (\\<lambda>A (k, v). array_set A k (f k v)) A\n        (assoc_list_of_array a)", "case (Array xs)"], ["proof (state)\nthis:\n  a = Array xs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       a = Array x \\<Longrightarrow>\n       array_map f a =\n       foldl (\\<lambda>A (k, v). array_set A k (f k v)) A\n        (assoc_list_of_array a)", "obtain ys where [simp]: \"A = Array ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ys. A = Array ys \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases A)"], ["proof (state)\nthis:\n  A = Array ys\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       a = Array x \\<Longrightarrow>\n       array_map f a =\n       foldl (\\<lambda>A (k, v). array_set A k (f k v)) A\n        (assoc_list_of_array a)", "with Array len"], ["proof (chain)\npicking this:\n  a = Array xs\n  array_length A = array_length a\n  A = Array ys", "have \"length xs \\<le> length ys\""], ["proof (prove)\nusing this:\n  a = Array xs\n  array_length A = array_length a\n  A = Array ys\n\ngoal (1 subgoal):\n 1. length xs \\<le> length ys", "by simp"], ["proof (state)\nthis:\n  length xs \\<le> length ys\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       a = Array x \\<Longrightarrow>\n       array_map f a =\n       foldl (\\<lambda>A (k, v). array_set A k (f k v)) A\n        (assoc_list_of_array a)", "hence \"foldr (\\<lambda>x y. array_set y (fst x) (f (fst x) (snd x)))\n               (rev (zip [0..<length xs] xs)) (Array ys) =\n         Array (map (\\<lambda>x. f (fst x) (snd x)) (zip [0..<length xs] xs) @ drop (length xs) ys)\""], ["proof (prove)\nusing this:\n  length xs \\<le> length ys\n\ngoal (1 subgoal):\n 1. foldr (\\<lambda>x y. array_set y (fst x) (f (fst x) (snd x)))\n     (rev (zip [0..<length xs] xs)) (Array ys) =\n    Array\n     (map (\\<lambda>x. f (fst x) (snd x)) (zip [0..<length xs] xs) @\n      drop (length xs) ys)", "proof(induct xs arbitrary: ys rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys.\n       length [] \\<le> length ys \\<Longrightarrow>\n       foldr (\\<lambda>x y. array_set y (fst x) (f (fst x) (snd x)))\n        (rev (zip [0..<length []] [])) (Array ys) =\n       Array\n        (map (\\<lambda>x. f (fst x) (snd x)) (zip [0..<length []] []) @\n         drop (length []) ys)\n 2. \\<And>x xs ys.\n       \\<lbrakk>\\<And>ys.\n                   length xs \\<le> length ys \\<Longrightarrow>\n                   foldr\n                    (\\<lambda>x y. array_set y (fst x) (f (fst x) (snd x)))\n                    (rev (zip [0..<length xs] xs)) (Array ys) =\n                   Array\n                    (map (\\<lambda>x. f (fst x) (snd x))\n                      (zip [0..<length xs] xs) @\n                     drop (length xs) ys);\n        length (xs @ [x]) \\<le> length ys\\<rbrakk>\n       \\<Longrightarrow> foldr\n                          (\\<lambda>x y.\n                              array_set y (fst x) (f (fst x) (snd x)))\n                          (rev (zip [0..<length (xs @ [x])] (xs @ [x])))\n                          (Array ys) =\n                         Array\n                          (map (\\<lambda>x. f (fst x) (snd x))\n                            (zip [0..<length (xs @ [x])] (xs @ [x])) @\n                           drop (length (xs @ [x])) ys)", "case Nil"], ["proof (state)\nthis:\n  length [] \\<le> length ys\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       length [] \\<le> length ys \\<Longrightarrow>\n       foldr (\\<lambda>x y. array_set y (fst x) (f (fst x) (snd x)))\n        (rev (zip [0..<length []] [])) (Array ys) =\n       Array\n        (map (\\<lambda>x. f (fst x) (snd x)) (zip [0..<length []] []) @\n         drop (length []) ys)\n 2. \\<And>x xs ys.\n       \\<lbrakk>\\<And>ys.\n                   length xs \\<le> length ys \\<Longrightarrow>\n                   foldr\n                    (\\<lambda>x y. array_set y (fst x) (f (fst x) (snd x)))\n                    (rev (zip [0..<length xs] xs)) (Array ys) =\n                   Array\n                    (map (\\<lambda>x. f (fst x) (snd x))\n                      (zip [0..<length xs] xs) @\n                     drop (length xs) ys);\n        length (xs @ [x]) \\<le> length ys\\<rbrakk>\n       \\<Longrightarrow> foldr\n                          (\\<lambda>x y.\n                              array_set y (fst x) (f (fst x) (snd x)))\n                          (rev (zip [0..<length (xs @ [x])] (xs @ [x])))\n                          (Array ys) =\n                         Array\n                          (map (\\<lambda>x. f (fst x) (snd x))\n                            (zip [0..<length (xs @ [x])] (xs @ [x])) @\n                           drop (length (xs @ [x])) ys)", "thus ?case"], ["proof (prove)\nusing this:\n  length [] \\<le> length ys\n\ngoal (1 subgoal):\n 1. foldr (\\<lambda>x y. array_set y (fst x) (f (fst x) (snd x)))\n     (rev (zip [0..<length []] [])) (Array ys) =\n    Array\n     (map (\\<lambda>x. f (fst x) (snd x)) (zip [0..<length []] []) @\n      drop (length []) ys)", "by simp"], ["proof (state)\nthis:\n  foldr (\\<lambda>x y. array_set y (fst x) (f (fst x) (snd x)))\n   (rev (zip [0..<length []] [])) (Array ys) =\n  Array\n   (map (\\<lambda>x. f (fst x) (snd x)) (zip [0..<length []] []) @\n    drop (length []) ys)\n\ngoal (1 subgoal):\n 1. \\<And>x xs ys.\n       \\<lbrakk>\\<And>ys.\n                   length xs \\<le> length ys \\<Longrightarrow>\n                   foldr\n                    (\\<lambda>x y. array_set y (fst x) (f (fst x) (snd x)))\n                    (rev (zip [0..<length xs] xs)) (Array ys) =\n                   Array\n                    (map (\\<lambda>x. f (fst x) (snd x))\n                      (zip [0..<length xs] xs) @\n                     drop (length xs) ys);\n        length (xs @ [x]) \\<le> length ys\\<rbrakk>\n       \\<Longrightarrow> foldr\n                          (\\<lambda>x y.\n                              array_set y (fst x) (f (fst x) (snd x)))\n                          (rev (zip [0..<length (xs @ [x])] (xs @ [x])))\n                          (Array ys) =\n                         Array\n                          (map (\\<lambda>x. f (fst x) (snd x))\n                            (zip [0..<length (xs @ [x])] (xs @ [x])) @\n                           drop (length (xs @ [x])) ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs ys.\n       \\<lbrakk>\\<And>ys.\n                   length xs \\<le> length ys \\<Longrightarrow>\n                   foldr\n                    (\\<lambda>x y. array_set y (fst x) (f (fst x) (snd x)))\n                    (rev (zip [0..<length xs] xs)) (Array ys) =\n                   Array\n                    (map (\\<lambda>x. f (fst x) (snd x))\n                      (zip [0..<length xs] xs) @\n                     drop (length xs) ys);\n        length (xs @ [x]) \\<le> length ys\\<rbrakk>\n       \\<Longrightarrow> foldr\n                          (\\<lambda>x y.\n                              array_set y (fst x) (f (fst x) (snd x)))\n                          (rev (zip [0..<length (xs @ [x])] (xs @ [x])))\n                          (Array ys) =\n                         Array\n                          (map (\\<lambda>x. f (fst x) (snd x))\n                            (zip [0..<length (xs @ [x])] (xs @ [x])) @\n                           drop (length (xs @ [x])) ys)", "case (snoc x xs ys)"], ["proof (state)\nthis:\n  length xs \\<le> length ?ys \\<Longrightarrow>\n  foldr (\\<lambda>x y. array_set y (fst x) (f (fst x) (snd x)))\n   (rev (zip [0..<length xs] xs)) (Array ?ys) =\n  Array\n   (map (\\<lambda>x. f (fst x) (snd x)) (zip [0..<length xs] xs) @\n    drop (length xs) ?ys)\n  length (xs @ [x]) \\<le> length ys\n\ngoal (1 subgoal):\n 1. \\<And>x xs ys.\n       \\<lbrakk>\\<And>ys.\n                   length xs \\<le> length ys \\<Longrightarrow>\n                   foldr\n                    (\\<lambda>x y. array_set y (fst x) (f (fst x) (snd x)))\n                    (rev (zip [0..<length xs] xs)) (Array ys) =\n                   Array\n                    (map (\\<lambda>x. f (fst x) (snd x))\n                      (zip [0..<length xs] xs) @\n                     drop (length xs) ys);\n        length (xs @ [x]) \\<le> length ys\\<rbrakk>\n       \\<Longrightarrow> foldr\n                          (\\<lambda>x y.\n                              array_set y (fst x) (f (fst x) (snd x)))\n                          (rev (zip [0..<length (xs @ [x])] (xs @ [x])))\n                          (Array ys) =\n                         Array\n                          (map (\\<lambda>x. f (fst x) (snd x))\n                            (zip [0..<length (xs @ [x])] (xs @ [x])) @\n                           drop (length (xs @ [x])) ys)", "from \\<open>length (xs @ [x]) \\<le> length ys\\<close>"], ["proof (chain)\npicking this:\n  length (xs @ [x]) \\<le> length ys", "have \"length xs \\<le> length ys\""], ["proof (prove)\nusing this:\n  length (xs @ [x]) \\<le> length ys\n\ngoal (1 subgoal):\n 1. length xs \\<le> length ys", "by simp"], ["proof (state)\nthis:\n  length xs \\<le> length ys\n\ngoal (1 subgoal):\n 1. \\<And>x xs ys.\n       \\<lbrakk>\\<And>ys.\n                   length xs \\<le> length ys \\<Longrightarrow>\n                   foldr\n                    (\\<lambda>x y. array_set y (fst x) (f (fst x) (snd x)))\n                    (rev (zip [0..<length xs] xs)) (Array ys) =\n                   Array\n                    (map (\\<lambda>x. f (fst x) (snd x))\n                      (zip [0..<length xs] xs) @\n                     drop (length xs) ys);\n        length (xs @ [x]) \\<le> length ys\\<rbrakk>\n       \\<Longrightarrow> foldr\n                          (\\<lambda>x y.\n                              array_set y (fst x) (f (fst x) (snd x)))\n                          (rev (zip [0..<length (xs @ [x])] (xs @ [x])))\n                          (Array ys) =\n                         Array\n                          (map (\\<lambda>x. f (fst x) (snd x))\n                            (zip [0..<length (xs @ [x])] (xs @ [x])) @\n                           drop (length (xs @ [x])) ys)", "hence \"foldr (\\<lambda>x y. array_set y (fst x) (f (fst x) (snd x)))\n                 (rev (zip [0..<length xs] xs)) (Array ys) =\n           Array (map (\\<lambda>x. f (fst x) (snd x)) (zip [0..<length xs] xs) @ drop (length xs) ys)\""], ["proof (prove)\nusing this:\n  length xs \\<le> length ys\n\ngoal (1 subgoal):\n 1. foldr (\\<lambda>x y. array_set y (fst x) (f (fst x) (snd x)))\n     (rev (zip [0..<length xs] xs)) (Array ys) =\n    Array\n     (map (\\<lambda>x. f (fst x) (snd x)) (zip [0..<length xs] xs) @\n      drop (length xs) ys)", "by(rule snoc)"], ["proof (state)\nthis:\n  foldr (\\<lambda>x y. array_set y (fst x) (f (fst x) (snd x)))\n   (rev (zip [0..<length xs] xs)) (Array ys) =\n  Array\n   (map (\\<lambda>x. f (fst x) (snd x)) (zip [0..<length xs] xs) @\n    drop (length xs) ys)\n\ngoal (1 subgoal):\n 1. \\<And>x xs ys.\n       \\<lbrakk>\\<And>ys.\n                   length xs \\<le> length ys \\<Longrightarrow>\n                   foldr\n                    (\\<lambda>x y. array_set y (fst x) (f (fst x) (snd x)))\n                    (rev (zip [0..<length xs] xs)) (Array ys) =\n                   Array\n                    (map (\\<lambda>x. f (fst x) (snd x))\n                      (zip [0..<length xs] xs) @\n                     drop (length xs) ys);\n        length (xs @ [x]) \\<le> length ys\\<rbrakk>\n       \\<Longrightarrow> foldr\n                          (\\<lambda>x y.\n                              array_set y (fst x) (f (fst x) (snd x)))\n                          (rev (zip [0..<length (xs @ [x])] (xs @ [x])))\n                          (Array ys) =\n                         Array\n                          (map (\\<lambda>x. f (fst x) (snd x))\n                            (zip [0..<length (xs @ [x])] (xs @ [x])) @\n                           drop (length (xs @ [x])) ys)", "moreover"], ["proof (state)\nthis:\n  foldr (\\<lambda>x y. array_set y (fst x) (f (fst x) (snd x)))\n   (rev (zip [0..<length xs] xs)) (Array ys) =\n  Array\n   (map (\\<lambda>x. f (fst x) (snd x)) (zip [0..<length xs] xs) @\n    drop (length xs) ys)\n\ngoal (1 subgoal):\n 1. \\<And>x xs ys.\n       \\<lbrakk>\\<And>ys.\n                   length xs \\<le> length ys \\<Longrightarrow>\n                   foldr\n                    (\\<lambda>x y. array_set y (fst x) (f (fst x) (snd x)))\n                    (rev (zip [0..<length xs] xs)) (Array ys) =\n                   Array\n                    (map (\\<lambda>x. f (fst x) (snd x))\n                      (zip [0..<length xs] xs) @\n                     drop (length xs) ys);\n        length (xs @ [x]) \\<le> length ys\\<rbrakk>\n       \\<Longrightarrow> foldr\n                          (\\<lambda>x y.\n                              array_set y (fst x) (f (fst x) (snd x)))\n                          (rev (zip [0..<length (xs @ [x])] (xs @ [x])))\n                          (Array ys) =\n                         Array\n                          (map (\\<lambda>x. f (fst x) (snd x))\n                            (zip [0..<length (xs @ [x])] (xs @ [x])) @\n                           drop (length (xs @ [x])) ys)", "from \\<open>length (xs @ [x]) \\<le> length ys\\<close>"], ["proof (chain)\npicking this:\n  length (xs @ [x]) \\<le> length ys", "obtain y ys' where ys: \"drop (length xs) ys = y # ys'\""], ["proof (prove)\nusing this:\n  length (xs @ [x]) \\<le> length ys\n\ngoal (1 subgoal):\n 1. (\\<And>y ys'.\n        drop (length xs) ys = y # ys' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases \"drop (length xs) ys\") auto"], ["proof (state)\nthis:\n  drop (length xs) ys = y # ys'\n\ngoal (1 subgoal):\n 1. \\<And>x xs ys.\n       \\<lbrakk>\\<And>ys.\n                   length xs \\<le> length ys \\<Longrightarrow>\n                   foldr\n                    (\\<lambda>x y. array_set y (fst x) (f (fst x) (snd x)))\n                    (rev (zip [0..<length xs] xs)) (Array ys) =\n                   Array\n                    (map (\\<lambda>x. f (fst x) (snd x))\n                      (zip [0..<length xs] xs) @\n                     drop (length xs) ys);\n        length (xs @ [x]) \\<le> length ys\\<rbrakk>\n       \\<Longrightarrow> foldr\n                          (\\<lambda>x y.\n                              array_set y (fst x) (f (fst x) (snd x)))\n                          (rev (zip [0..<length (xs @ [x])] (xs @ [x])))\n                          (Array ys) =\n                         Array\n                          (map (\\<lambda>x. f (fst x) (snd x))\n                            (zip [0..<length (xs @ [x])] (xs @ [x])) @\n                           drop (length (xs @ [x])) ys)", "moreover"], ["proof (state)\nthis:\n  drop (length xs) ys = y # ys'\n\ngoal (1 subgoal):\n 1. \\<And>x xs ys.\n       \\<lbrakk>\\<And>ys.\n                   length xs \\<le> length ys \\<Longrightarrow>\n                   foldr\n                    (\\<lambda>x y. array_set y (fst x) (f (fst x) (snd x)))\n                    (rev (zip [0..<length xs] xs)) (Array ys) =\n                   Array\n                    (map (\\<lambda>x. f (fst x) (snd x))\n                      (zip [0..<length xs] xs) @\n                     drop (length xs) ys);\n        length (xs @ [x]) \\<le> length ys\\<rbrakk>\n       \\<Longrightarrow> foldr\n                          (\\<lambda>x y.\n                              array_set y (fst x) (f (fst x) (snd x)))\n                          (rev (zip [0..<length (xs @ [x])] (xs @ [x])))\n                          (Array ys) =\n                         Array\n                          (map (\\<lambda>x. f (fst x) (snd x))\n                            (zip [0..<length (xs @ [x])] (xs @ [x])) @\n                           drop (length (xs @ [x])) ys)", "hence \"drop (Suc (length xs)) ys = ys'\""], ["proof (prove)\nusing this:\n  drop (length xs) ys = y # ys'\n\ngoal (1 subgoal):\n 1. drop (Suc (length xs)) ys = ys'", "by(auto dest: drop_eq_ConsD)"], ["proof (state)\nthis:\n  drop (Suc (length xs)) ys = ys'\n\ngoal (1 subgoal):\n 1. \\<And>x xs ys.\n       \\<lbrakk>\\<And>ys.\n                   length xs \\<le> length ys \\<Longrightarrow>\n                   foldr\n                    (\\<lambda>x y. array_set y (fst x) (f (fst x) (snd x)))\n                    (rev (zip [0..<length xs] xs)) (Array ys) =\n                   Array\n                    (map (\\<lambda>x. f (fst x) (snd x))\n                      (zip [0..<length xs] xs) @\n                     drop (length xs) ys);\n        length (xs @ [x]) \\<le> length ys\\<rbrakk>\n       \\<Longrightarrow> foldr\n                          (\\<lambda>x y.\n                              array_set y (fst x) (f (fst x) (snd x)))\n                          (rev (zip [0..<length (xs @ [x])] (xs @ [x])))\n                          (Array ys) =\n                         Array\n                          (map (\\<lambda>x. f (fst x) (snd x))\n                            (zip [0..<length (xs @ [x])] (xs @ [x])) @\n                           drop (length (xs @ [x])) ys)", "ultimately"], ["proof (chain)\npicking this:\n  foldr (\\<lambda>x y. array_set y (fst x) (f (fst x) (snd x)))\n   (rev (zip [0..<length xs] xs)) (Array ys) =\n  Array\n   (map (\\<lambda>x. f (fst x) (snd x)) (zip [0..<length xs] xs) @\n    drop (length xs) ys)\n  drop (length xs) ys = y # ys'\n  drop (Suc (length xs)) ys = ys'", "show ?case"], ["proof (prove)\nusing this:\n  foldr (\\<lambda>x y. array_set y (fst x) (f (fst x) (snd x)))\n   (rev (zip [0..<length xs] xs)) (Array ys) =\n  Array\n   (map (\\<lambda>x. f (fst x) (snd x)) (zip [0..<length xs] xs) @\n    drop (length xs) ys)\n  drop (length xs) ys = y # ys'\n  drop (Suc (length xs)) ys = ys'\n\ngoal (1 subgoal):\n 1. foldr (\\<lambda>x y. array_set y (fst x) (f (fst x) (snd x)))\n     (rev (zip [0..<length (xs @ [x])] (xs @ [x]))) (Array ys) =\n    Array\n     (map (\\<lambda>x. f (fst x) (snd x))\n       (zip [0..<length (xs @ [x])] (xs @ [x])) @\n      drop (length (xs @ [x])) ys)", "by(simp add: list_update_append)"], ["proof (state)\nthis:\n  foldr (\\<lambda>x y. array_set y (fst x) (f (fst x) (snd x)))\n   (rev (zip [0..<length (xs @ [x])] (xs @ [x]))) (Array ys) =\n  Array\n   (map (\\<lambda>x. f (fst x) (snd x))\n     (zip [0..<length (xs @ [x])] (xs @ [x])) @\n    drop (length (xs @ [x])) ys)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  foldr (\\<lambda>x y. array_set y (fst x) (f (fst x) (snd x)))\n   (rev (zip [0..<length xs] xs)) (Array ys) =\n  Array\n   (map (\\<lambda>x. f (fst x) (snd x)) (zip [0..<length xs] xs) @\n    drop (length xs) ys)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       a = Array x \\<Longrightarrow>\n       array_map f a =\n       foldl (\\<lambda>A (k, v). array_set A k (f k v)) A\n        (assoc_list_of_array a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  foldr (\\<lambda>x y. array_set y (fst x) (f (fst x) (snd x)))\n   (rev (zip [0..<length xs] xs)) (Array ys) =\n  Array\n   (map (\\<lambda>x. f (fst x) (snd x)) (zip [0..<length xs] xs) @\n    drop (length xs) ys)\n\ngoal (1 subgoal):\n 1. array_map f a =\n    foldl (\\<lambda>A (k, v). array_set A k (f k v)) A\n     (assoc_list_of_array a)", "using Array len"], ["proof (prove)\nusing this:\n  foldr (\\<lambda>x y. array_set y (fst x) (f (fst x) (snd x)))\n   (rev (zip [0..<length xs] xs)) (Array ys) =\n  Array\n   (map (\\<lambda>x. f (fst x) (snd x)) (zip [0..<length xs] xs) @\n    drop (length xs) ys)\n  a = Array xs\n  array_length A = array_length a\n\ngoal (1 subgoal):\n 1. array_map f a =\n    foldl (\\<lambda>A (k, v). array_set A k (f k v)) A\n     (assoc_list_of_array a)", "by(simp add: array_map_def split_beta array_of_list_def foldl_conv_foldr)"], ["proof (state)\nthis:\n  array_map f a =\n  foldl (\\<lambda>A (k, v). array_set A k (f k v)) A (assoc_list_of_array a)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Lemmas about empty arrays\\<close>"], ["", "lemma array_length_eq_0 [simp]:\n  \"array_length a = 0 \\<longleftrightarrow> a = Array []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (array_length a = 0) = (a = Array [])", "by(cases a) simp"], ["", "lemma new_array_0 [simp]: \"new_array v 0 = Array []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. new_array v 0 = Array []", "by(simp add: new_array_def)"], ["", "lemma array_of_list_Nil [simp]:\n  \"array_of_list [] = Array []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. array_of_list [] = Array []", "by(simp add: array_of_list_def)"], ["", "lemma array_map_Nil [simp]:\n  \"array_map f (Array []) = Array []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. array_map f (Array []) = Array []", "by(simp add: array_map_def)"], ["", "lemma array_foldl_Nil [simp]:\n  \"array_foldl f b (Array []) = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. array_foldl f b (Array []) = b", "by(simp add: array_foldl_def)"], ["", "lemma array_foldr_Nil [simp]:\n  \"array_foldr f (Array []) b = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. array_foldr f (Array []) b = b", "by(simp add: array_foldr_def)"], ["", "lemma prod_foldl_conv:\n  \"(foldl f a xs, foldl g b xs) = foldl (\\<lambda>(a, b) x. (f a x, g b x)) (a, b) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (foldl f a xs, foldl g b xs) =\n    foldl (\\<lambda>(a, b) x. (f a x, g b x)) (a, b) xs", "by(induct xs arbitrary: a b) simp_all"], ["", "lemma prod_array_foldl_conv:\n  \"(array_foldl f b a, array_foldl g c a) = array_foldl (\\<lambda>h (b, c) v. (f h b v, g h c v)) (b, c) a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (array_foldl f b a, array_foldl g c a) =\n    array_foldl (\\<lambda>h (b, c) v. (f h b v, g h c v)) (b, c) a", "by(cases a)(simp add: array_foldl_def foldl_map prod_foldl_conv split_def)"], ["", "lemma array_foldl_array_foldr_comm:\n  \"comp_fun_commute (\\<lambda>(h, v) b. f h b v) \\<Longrightarrow> array_foldl f b a = array_foldr (\\<lambda>h v b. f h b v) a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_fun_commute (\\<lambda>(h, v) b. f h b v) \\<Longrightarrow>\n    array_foldl f b a = array_foldr (\\<lambda>h v b. f h b v) a b", "by(cases a)(simp add: array_foldl_def array_foldr_def split_def comp_fun_commute.foldr_conv_foldl)"], ["", "lemma array_map_conv_array_foldl:\n  \"array_map f a = array_foldl (\\<lambda>h a v. array_set a h (f h v)) a a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. array_map f a = array_foldl (\\<lambda>h a v. array_set a h (f h v)) a a", "proof(cases a)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       a = Array x \\<Longrightarrow>\n       array_map f a =\n       array_foldl (\\<lambda>h a v. array_set a h (f h v)) a a", "case (Array xs)"], ["proof (state)\nthis:\n  a = Array xs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       a = Array x \\<Longrightarrow>\n       array_map f a =\n       array_foldl (\\<lambda>h a v. array_set a h (f h v)) a a", "define a where \"a = xs\""], ["proof (state)\nthis:\n  a = xs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       a = Array x \\<Longrightarrow>\n       array_map f a =\n       array_foldl (\\<lambda>h a v. array_set a h (f h v)) a a", "hence \"length xs \\<le> length a\""], ["proof (prove)\nusing this:\n  a = xs\n\ngoal (1 subgoal):\n 1. length xs \\<le> length a", "by simp"], ["proof (state)\nthis:\n  length xs \\<le> length a\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       a = Array x \\<Longrightarrow>\n       array_map f a =\n       array_foldl (\\<lambda>h a v. array_set a h (f h v)) a a", "hence \"foldl (\\<lambda>a (k, v). array_set a k (f k v))\n              (Array a) (zip [0..<length xs] xs)\n         = Array (map (\\<lambda>(k, v). f k v) (zip [0..<length xs] xs) @ drop (length xs) a)\""], ["proof (prove)\nusing this:\n  length xs \\<le> length a\n\ngoal (1 subgoal):\n 1. foldl (\\<lambda>a (k, v). array_set a k (f k v)) (Array a)\n     (zip [0..<length xs] xs) =\n    Array (map2 f [0..<length xs] xs @ drop (length xs) a)", "proof(induct xs rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. length [] \\<le> length a \\<Longrightarrow>\n    foldl (\\<lambda>a (k, v). array_set a k (f k v)) (Array a)\n     (zip [0..<length []] []) =\n    Array (map2 f [0..<length []] [] @ drop (length []) a)\n 2. \\<And>x xs.\n       \\<lbrakk>length xs \\<le> length a \\<Longrightarrow>\n                foldl (\\<lambda>a (k, v). array_set a k (f k v)) (Array a)\n                 (zip [0..<length xs] xs) =\n                Array (map2 f [0..<length xs] xs @ drop (length xs) a);\n        length (xs @ [x]) \\<le> length a\\<rbrakk>\n       \\<Longrightarrow> foldl (\\<lambda>a (k, v). array_set a k (f k v))\n                          (Array a)\n                          (zip [0..<length (xs @ [x])] (xs @ [x])) =\n                         Array\n                          (map2 f [0..<length (xs @ [x])] (xs @ [x]) @\n                           drop (length (xs @ [x])) a)", "case Nil"], ["proof (state)\nthis:\n  length [] \\<le> length a\n\ngoal (2 subgoals):\n 1. length [] \\<le> length a \\<Longrightarrow>\n    foldl (\\<lambda>a (k, v). array_set a k (f k v)) (Array a)\n     (zip [0..<length []] []) =\n    Array (map2 f [0..<length []] [] @ drop (length []) a)\n 2. \\<And>x xs.\n       \\<lbrakk>length xs \\<le> length a \\<Longrightarrow>\n                foldl (\\<lambda>a (k, v). array_set a k (f k v)) (Array a)\n                 (zip [0..<length xs] xs) =\n                Array (map2 f [0..<length xs] xs @ drop (length xs) a);\n        length (xs @ [x]) \\<le> length a\\<rbrakk>\n       \\<Longrightarrow> foldl (\\<lambda>a (k, v). array_set a k (f k v))\n                          (Array a)\n                          (zip [0..<length (xs @ [x])] (xs @ [x])) =\n                         Array\n                          (map2 f [0..<length (xs @ [x])] (xs @ [x]) @\n                           drop (length (xs @ [x])) a)", "thus ?case"], ["proof (prove)\nusing this:\n  length [] \\<le> length a\n\ngoal (1 subgoal):\n 1. foldl\n     (\\<lambda>a b. case b of (k, v) \\<Rightarrow> array_set a k (f k v))\n     (Array a) (zip [0..<length []] []) =\n    Array (map2 f [0..<length []] [] @ drop (length []) a)", "by simp"], ["proof (state)\nthis:\n  foldl (\\<lambda>a b. case b of (k, v) \\<Rightarrow> array_set a k (f k v))\n   (Array a) (zip [0..<length []] []) =\n  Array (map2 f [0..<length []] [] @ drop (length []) a)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>length xs \\<le> length a \\<Longrightarrow>\n                foldl (\\<lambda>a (k, v). array_set a k (f k v)) (Array a)\n                 (zip [0..<length xs] xs) =\n                Array (map2 f [0..<length xs] xs @ drop (length xs) a);\n        length (xs @ [x]) \\<le> length a\\<rbrakk>\n       \\<Longrightarrow> foldl (\\<lambda>a (k, v). array_set a k (f k v))\n                          (Array a)\n                          (zip [0..<length (xs @ [x])] (xs @ [x])) =\n                         Array\n                          (map2 f [0..<length (xs @ [x])] (xs @ [x]) @\n                           drop (length (xs @ [x])) a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>length xs \\<le> length a \\<Longrightarrow>\n                foldl (\\<lambda>a (k, v). array_set a k (f k v)) (Array a)\n                 (zip [0..<length xs] xs) =\n                Array (map2 f [0..<length xs] xs @ drop (length xs) a);\n        length (xs @ [x]) \\<le> length a\\<rbrakk>\n       \\<Longrightarrow> foldl (\\<lambda>a (k, v). array_set a k (f k v))\n                          (Array a)\n                          (zip [0..<length (xs @ [x])] (xs @ [x])) =\n                         Array\n                          (map2 f [0..<length (xs @ [x])] (xs @ [x]) @\n                           drop (length (xs @ [x])) a)", "case (snoc x xs)"], ["proof (state)\nthis:\n  length xs \\<le> length a \\<Longrightarrow>\n  foldl (\\<lambda>a b. case b of (k, v) \\<Rightarrow> array_set a k (f k v))\n   (Array a) (zip [0..<length xs] xs) =\n  Array (map2 f [0..<length xs] xs @ drop (length xs) a)\n  length (xs @ [x]) \\<le> length a\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>length xs \\<le> length a \\<Longrightarrow>\n                foldl (\\<lambda>a (k, v). array_set a k (f k v)) (Array a)\n                 (zip [0..<length xs] xs) =\n                Array (map2 f [0..<length xs] xs @ drop (length xs) a);\n        length (xs @ [x]) \\<le> length a\\<rbrakk>\n       \\<Longrightarrow> foldl (\\<lambda>a (k, v). array_set a k (f k v))\n                          (Array a)\n                          (zip [0..<length (xs @ [x])] (xs @ [x])) =\n                         Array\n                          (map2 f [0..<length (xs @ [x])] (xs @ [x]) @\n                           drop (length (xs @ [x])) a)", "have \"foldl (\\<lambda>a (k, v). array_set a k (f k v)) (Array a) (zip [0..<length (xs @ [x])] (xs @ [x])) =\n          array_set (foldl (\\<lambda>a (k, v). array_set a k (f k v)) (Array a) (zip [0..<length xs] xs))\n                    (length xs) (f (length xs) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (\\<lambda>a (k, v). array_set a k (f k v)) (Array a)\n     (zip [0..<length (xs @ [x])] (xs @ [x])) =\n    array_set\n     (foldl (\\<lambda>a (k, v). array_set a k (f k v)) (Array a)\n       (zip [0..<length xs] xs))\n     (length xs) (f (length xs) x)", "by simp"], ["proof (state)\nthis:\n  foldl (\\<lambda>a (k, v). array_set a k (f k v)) (Array a)\n   (zip [0..<length (xs @ [x])] (xs @ [x])) =\n  array_set\n   (foldl (\\<lambda>a (k, v). array_set a k (f k v)) (Array a)\n     (zip [0..<length xs] xs))\n   (length xs) (f (length xs) x)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>length xs \\<le> length a \\<Longrightarrow>\n                foldl (\\<lambda>a (k, v). array_set a k (f k v)) (Array a)\n                 (zip [0..<length xs] xs) =\n                Array (map2 f [0..<length xs] xs @ drop (length xs) a);\n        length (xs @ [x]) \\<le> length a\\<rbrakk>\n       \\<Longrightarrow> foldl (\\<lambda>a (k, v). array_set a k (f k v))\n                          (Array a)\n                          (zip [0..<length (xs @ [x])] (xs @ [x])) =\n                         Array\n                          (map2 f [0..<length (xs @ [x])] (xs @ [x]) @\n                           drop (length (xs @ [x])) a)", "also"], ["proof (state)\nthis:\n  foldl (\\<lambda>a (k, v). array_set a k (f k v)) (Array a)\n   (zip [0..<length (xs @ [x])] (xs @ [x])) =\n  array_set\n   (foldl (\\<lambda>a (k, v). array_set a k (f k v)) (Array a)\n     (zip [0..<length xs] xs))\n   (length xs) (f (length xs) x)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>length xs \\<le> length a \\<Longrightarrow>\n                foldl (\\<lambda>a (k, v). array_set a k (f k v)) (Array a)\n                 (zip [0..<length xs] xs) =\n                Array (map2 f [0..<length xs] xs @ drop (length xs) a);\n        length (xs @ [x]) \\<le> length a\\<rbrakk>\n       \\<Longrightarrow> foldl (\\<lambda>a (k, v). array_set a k (f k v))\n                          (Array a)\n                          (zip [0..<length (xs @ [x])] (xs @ [x])) =\n                         Array\n                          (map2 f [0..<length (xs @ [x])] (xs @ [x]) @\n                           drop (length (xs @ [x])) a)", "from \\<open>length (xs @ [x]) \\<le> length a\\<close>"], ["proof (chain)\npicking this:\n  length (xs @ [x]) \\<le> length a", "have \"length xs \\<le> length a\""], ["proof (prove)\nusing this:\n  length (xs @ [x]) \\<le> length a\n\ngoal (1 subgoal):\n 1. length xs \\<le> length a", "by simp"], ["proof (state)\nthis:\n  length xs \\<le> length a\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>length xs \\<le> length a \\<Longrightarrow>\n                foldl (\\<lambda>a (k, v). array_set a k (f k v)) (Array a)\n                 (zip [0..<length xs] xs) =\n                Array (map2 f [0..<length xs] xs @ drop (length xs) a);\n        length (xs @ [x]) \\<le> length a\\<rbrakk>\n       \\<Longrightarrow> foldl (\\<lambda>a (k, v). array_set a k (f k v))\n                          (Array a)\n                          (zip [0..<length (xs @ [x])] (xs @ [x])) =\n                         Array\n                          (map2 f [0..<length (xs @ [x])] (xs @ [x]) @\n                           drop (length (xs @ [x])) a)", "hence \"foldl (\\<lambda>a (k, v). array_set a k (f k v)) (Array a) (zip [0..<length xs] xs) =\n           Array (map (\\<lambda>(k, v). f k v) (zip [0..<length xs] xs) @ drop (length xs) a)\""], ["proof (prove)\nusing this:\n  length xs \\<le> length a\n\ngoal (1 subgoal):\n 1. foldl (\\<lambda>a (k, v). array_set a k (f k v)) (Array a)\n     (zip [0..<length xs] xs) =\n    Array (map2 f [0..<length xs] xs @ drop (length xs) a)", "by(rule snoc)"], ["proof (state)\nthis:\n  foldl (\\<lambda>a (k, v). array_set a k (f k v)) (Array a)\n   (zip [0..<length xs] xs) =\n  Array (map2 f [0..<length xs] xs @ drop (length xs) a)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>length xs \\<le> length a \\<Longrightarrow>\n                foldl (\\<lambda>a (k, v). array_set a k (f k v)) (Array a)\n                 (zip [0..<length xs] xs) =\n                Array (map2 f [0..<length xs] xs @ drop (length xs) a);\n        length (xs @ [x]) \\<le> length a\\<rbrakk>\n       \\<Longrightarrow> foldl (\\<lambda>a (k, v). array_set a k (f k v))\n                          (Array a)\n                          (zip [0..<length (xs @ [x])] (xs @ [x])) =\n                         Array\n                          (map2 f [0..<length (xs @ [x])] (xs @ [x]) @\n                           drop (length (xs @ [x])) a)", "also"], ["proof (state)\nthis:\n  foldl (\\<lambda>a (k, v). array_set a k (f k v)) (Array a)\n   (zip [0..<length xs] xs) =\n  Array (map2 f [0..<length xs] xs @ drop (length xs) a)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>length xs \\<le> length a \\<Longrightarrow>\n                foldl (\\<lambda>a (k, v). array_set a k (f k v)) (Array a)\n                 (zip [0..<length xs] xs) =\n                Array (map2 f [0..<length xs] xs @ drop (length xs) a);\n        length (xs @ [x]) \\<le> length a\\<rbrakk>\n       \\<Longrightarrow> foldl (\\<lambda>a (k, v). array_set a k (f k v))\n                          (Array a)\n                          (zip [0..<length (xs @ [x])] (xs @ [x])) =\n                         Array\n                          (map2 f [0..<length (xs @ [x])] (xs @ [x]) @\n                           drop (length (xs @ [x])) a)", "note array_set.simps"], ["proof (state)\nthis:\n  array_set (Array ?A) ?n ?a = Array (?A[?n := ?a])\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>length xs \\<le> length a \\<Longrightarrow>\n                foldl (\\<lambda>a (k, v). array_set a k (f k v)) (Array a)\n                 (zip [0..<length xs] xs) =\n                Array (map2 f [0..<length xs] xs @ drop (length xs) a);\n        length (xs @ [x]) \\<le> length a\\<rbrakk>\n       \\<Longrightarrow> foldl (\\<lambda>a (k, v). array_set a k (f k v))\n                          (Array a)\n                          (zip [0..<length (xs @ [x])] (xs @ [x])) =\n                         Array\n                          (map2 f [0..<length (xs @ [x])] (xs @ [x]) @\n                           drop (length (xs @ [x])) a)", "also"], ["proof (state)\nthis:\n  array_set (Array ?A) ?n ?a = Array (?A[?n := ?a])\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>length xs \\<le> length a \\<Longrightarrow>\n                foldl (\\<lambda>a (k, v). array_set a k (f k v)) (Array a)\n                 (zip [0..<length xs] xs) =\n                Array (map2 f [0..<length xs] xs @ drop (length xs) a);\n        length (xs @ [x]) \\<le> length a\\<rbrakk>\n       \\<Longrightarrow> foldl (\\<lambda>a (k, v). array_set a k (f k v))\n                          (Array a)\n                          (zip [0..<length (xs @ [x])] (xs @ [x])) =\n                         Array\n                          (map2 f [0..<length (xs @ [x])] (xs @ [x]) @\n                           drop (length (xs @ [x])) a)", "have \"(map (\\<lambda>(k, v). f k v) (zip [0..<length xs] xs) @ drop (length xs) a) [length xs := f (length xs) x] =\n              (map (\\<lambda>(k, v). f k v) (zip [0..<length xs] xs) @ (drop (length xs) a) [0 := f (length xs) x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map2 f [0..<length xs] xs @ drop (length xs) a)\n    [length xs := f (length xs) x] =\n    map2 f [0..<length xs] xs @ (drop (length xs) a)[0 := f (length xs) x]", "by(simp add: list_update_append)"], ["proof (state)\nthis:\n  (map2 f [0..<length xs] xs @ drop (length xs) a)\n  [length xs := f (length xs) x] =\n  map2 f [0..<length xs] xs @ (drop (length xs) a)[0 := f (length xs) x]\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>length xs \\<le> length a \\<Longrightarrow>\n                foldl (\\<lambda>a (k, v). array_set a k (f k v)) (Array a)\n                 (zip [0..<length xs] xs) =\n                Array (map2 f [0..<length xs] xs @ drop (length xs) a);\n        length (xs @ [x]) \\<le> length a\\<rbrakk>\n       \\<Longrightarrow> foldl (\\<lambda>a (k, v). array_set a k (f k v))\n                          (Array a)\n                          (zip [0..<length (xs @ [x])] (xs @ [x])) =\n                         Array\n                          (map2 f [0..<length (xs @ [x])] (xs @ [x]) @\n                           drop (length (xs @ [x])) a)", "also"], ["proof (state)\nthis:\n  (map2 f [0..<length xs] xs @ drop (length xs) a)\n  [length xs := f (length xs) x] =\n  map2 f [0..<length xs] xs @ (drop (length xs) a)[0 := f (length xs) x]\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>length xs \\<le> length a \\<Longrightarrow>\n                foldl (\\<lambda>a (k, v). array_set a k (f k v)) (Array a)\n                 (zip [0..<length xs] xs) =\n                Array (map2 f [0..<length xs] xs @ drop (length xs) a);\n        length (xs @ [x]) \\<le> length a\\<rbrakk>\n       \\<Longrightarrow> foldl (\\<lambda>a (k, v). array_set a k (f k v))\n                          (Array a)\n                          (zip [0..<length (xs @ [x])] (xs @ [x])) =\n                         Array\n                          (map2 f [0..<length (xs @ [x])] (xs @ [x]) @\n                           drop (length (xs @ [x])) a)", "from \\<open>length (xs @ [x]) \\<le> length a\\<close>"], ["proof (chain)\npicking this:\n  length (xs @ [x]) \\<le> length a", "have \"(drop (length xs) a)[0 := f (length xs) x] =\n          f (length xs) x # drop (Suc (length xs)) a\""], ["proof (prove)\nusing this:\n  length (xs @ [x]) \\<le> length a\n\ngoal (1 subgoal):\n 1. (drop (length xs) a)[0 := f (length xs) x] =\n    f (length xs) x # drop (Suc (length xs)) a", "by(simp add: upd_conv_take_nth_drop)"], ["proof (state)\nthis:\n  (drop (length xs) a)[0 := f (length xs) x] =\n  f (length xs) x # drop (Suc (length xs)) a\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>length xs \\<le> length a \\<Longrightarrow>\n                foldl (\\<lambda>a (k, v). array_set a k (f k v)) (Array a)\n                 (zip [0..<length xs] xs) =\n                Array (map2 f [0..<length xs] xs @ drop (length xs) a);\n        length (xs @ [x]) \\<le> length a\\<rbrakk>\n       \\<Longrightarrow> foldl (\\<lambda>a (k, v). array_set a k (f k v))\n                          (Array a)\n                          (zip [0..<length (xs @ [x])] (xs @ [x])) =\n                         Array\n                          (map2 f [0..<length (xs @ [x])] (xs @ [x]) @\n                           drop (length (xs @ [x])) a)", "also"], ["proof (state)\nthis:\n  (drop (length xs) a)[0 := f (length xs) x] =\n  f (length xs) x # drop (Suc (length xs)) a\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>length xs \\<le> length a \\<Longrightarrow>\n                foldl (\\<lambda>a (k, v). array_set a k (f k v)) (Array a)\n                 (zip [0..<length xs] xs) =\n                Array (map2 f [0..<length xs] xs @ drop (length xs) a);\n        length (xs @ [x]) \\<le> length a\\<rbrakk>\n       \\<Longrightarrow> foldl (\\<lambda>a (k, v). array_set a k (f k v))\n                          (Array a)\n                          (zip [0..<length (xs @ [x])] (xs @ [x])) =\n                         Array\n                          (map2 f [0..<length (xs @ [x])] (xs @ [x]) @\n                           drop (length (xs @ [x])) a)", "have \"map (\\<lambda>(k, v). f k v) (zip [0..<length xs] xs) @ f (length xs) x # drop (Suc (length xs)) a =\n             (map (\\<lambda>(k, v). f k v) (zip [0..<length xs] xs) @ [f (length xs) x]) @ drop (Suc (length xs)) a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map2 f [0..<length xs] xs @ f (length xs) x # drop (Suc (length xs)) a =\n    (map2 f [0..<length xs] xs @ [f (length xs) x]) @\n    drop (Suc (length xs)) a", "by simp"], ["proof (state)\nthis:\n  map2 f [0..<length xs] xs @ f (length xs) x # drop (Suc (length xs)) a =\n  (map2 f [0..<length xs] xs @ [f (length xs) x]) @ drop (Suc (length xs)) a\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>length xs \\<le> length a \\<Longrightarrow>\n                foldl (\\<lambda>a (k, v). array_set a k (f k v)) (Array a)\n                 (zip [0..<length xs] xs) =\n                Array (map2 f [0..<length xs] xs @ drop (length xs) a);\n        length (xs @ [x]) \\<le> length a\\<rbrakk>\n       \\<Longrightarrow> foldl (\\<lambda>a (k, v). array_set a k (f k v))\n                          (Array a)\n                          (zip [0..<length (xs @ [x])] (xs @ [x])) =\n                         Array\n                          (map2 f [0..<length (xs @ [x])] (xs @ [x]) @\n                           drop (length (xs @ [x])) a)", "also"], ["proof (state)\nthis:\n  map2 f [0..<length xs] xs @ f (length xs) x # drop (Suc (length xs)) a =\n  (map2 f [0..<length xs] xs @ [f (length xs) x]) @ drop (Suc (length xs)) a\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>length xs \\<le> length a \\<Longrightarrow>\n                foldl (\\<lambda>a (k, v). array_set a k (f k v)) (Array a)\n                 (zip [0..<length xs] xs) =\n                Array (map2 f [0..<length xs] xs @ drop (length xs) a);\n        length (xs @ [x]) \\<le> length a\\<rbrakk>\n       \\<Longrightarrow> foldl (\\<lambda>a (k, v). array_set a k (f k v))\n                          (Array a)\n                          (zip [0..<length (xs @ [x])] (xs @ [x])) =\n                         Array\n                          (map2 f [0..<length (xs @ [x])] (xs @ [x]) @\n                           drop (length (xs @ [x])) a)", "have \"\\<dots> = map (\\<lambda>(k, v). f k v) (zip [0..<length (xs @ [x])] (xs @ [x])) @ drop (length (xs @ [x])) a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map2 f [0..<length xs] xs @ [f (length xs) x]) @\n    drop (Suc (length xs)) a =\n    map2 f [0..<length (xs @ [x])] (xs @ [x]) @ drop (length (xs @ [x])) a", "by(simp)"], ["proof (state)\nthis:\n  (map2 f [0..<length xs] xs @ [f (length xs) x]) @\n  drop (Suc (length xs)) a =\n  map2 f [0..<length (xs @ [x])] (xs @ [x]) @ drop (length (xs @ [x])) a\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>length xs \\<le> length a \\<Longrightarrow>\n                foldl (\\<lambda>a (k, v). array_set a k (f k v)) (Array a)\n                 (zip [0..<length xs] xs) =\n                Array (map2 f [0..<length xs] xs @ drop (length xs) a);\n        length (xs @ [x]) \\<le> length a\\<rbrakk>\n       \\<Longrightarrow> foldl (\\<lambda>a (k, v). array_set a k (f k v))\n                          (Array a)\n                          (zip [0..<length (xs @ [x])] (xs @ [x])) =\n                         Array\n                          (map2 f [0..<length (xs @ [x])] (xs @ [x]) @\n                           drop (length (xs @ [x])) a)", "finally"], ["proof (chain)\npicking this:\n  foldl (\\<lambda>a b. case b of (k, v) \\<Rightarrow> array_set a k (f k v))\n   (Array a) (zip [0..<length (xs @ [x])] (xs @ [x])) =\n  Array\n   (map2 f [0..<length (xs @ [x])] (xs @ [x]) @ drop (length (xs @ [x])) a)", "show ?case"], ["proof (prove)\nusing this:\n  foldl (\\<lambda>a b. case b of (k, v) \\<Rightarrow> array_set a k (f k v))\n   (Array a) (zip [0..<length (xs @ [x])] (xs @ [x])) =\n  Array\n   (map2 f [0..<length (xs @ [x])] (xs @ [x]) @ drop (length (xs @ [x])) a)\n\ngoal (1 subgoal):\n 1. foldl\n     (\\<lambda>a b. case b of (k, v) \\<Rightarrow> array_set a k (f k v))\n     (Array a) (zip [0..<length (xs @ [x])] (xs @ [x])) =\n    Array\n     (map2 f [0..<length (xs @ [x])] (xs @ [x]) @\n      drop (length (xs @ [x])) a)", "."], ["proof (state)\nthis:\n  foldl (\\<lambda>a b. case b of (k, v) \\<Rightarrow> array_set a k (f k v))\n   (Array a) (zip [0..<length (xs @ [x])] (xs @ [x])) =\n  Array\n   (map2 f [0..<length (xs @ [x])] (xs @ [x]) @ drop (length (xs @ [x])) a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  foldl (\\<lambda>a (k, v). array_set a k (f k v)) (Array a)\n   (zip [0..<length xs] xs) =\n  Array (map2 f [0..<length xs] xs @ drop (length xs) a)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       a = Array x \\<Longrightarrow>\n       array_map f a =\n       array_foldl (\\<lambda>h a v. array_set a h (f h v)) a a", "with a_def Array"], ["proof (chain)\npicking this:\n  a = xs\n  a = Array xs\n  foldl (\\<lambda>a (k, v). array_set a k (f k v)) (Array a)\n   (zip [0..<length xs] xs) =\n  Array (map2 f [0..<length xs] xs @ drop (length xs) a)", "show ?thesis"], ["proof (prove)\nusing this:\n  a = xs\n  a = Array xs\n  foldl (\\<lambda>a (k, v). array_set a k (f k v)) (Array a)\n   (zip [0..<length xs] xs) =\n  Array (map2 f [0..<length xs] xs @ drop (length xs) a)\n\ngoal (1 subgoal):\n 1. array_map f a = array_foldl (\\<lambda>h a v. array_set a h (f h v)) a a", "by(simp add: array_foldl_def array_map_def array_of_list_def)"], ["proof (state)\nthis:\n  array_map f a = array_foldl (\\<lambda>h a v. array_set a h (f h v)) a a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma array_foldl_new_array:\n  \"array_foldl f b (new_array a n) = foldl (\\<lambda>b (k, v). f k b v) b (zip [0..<n] (replicate n a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. array_foldl f b (new_array a n) =\n    foldl (\\<lambda>b (k, v). f k b v) b (zip [0..<n] (replicate n a))", "by(simp add: new_array_def array_foldl_def)"], ["", "lemma array_list_of_set[simp]:\n  \"list_of_array (array_set a i x) = (list_of_array a) [i := x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_of_array (array_set a i x) = (list_of_array a)[i := x]", "by (cases a) simp"], ["", "lemma array_length_list: \"array_length a = length (list_of_array a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. array_length a = length (list_of_array a)", "by (cases a) simp"], ["", "subsection \\<open>Parametricity lemmas\\<close>"], ["", "lemma rec_array_is_case[simp]: \"rec_array = case_array\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rec_array = case_array", "apply (intro ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa. rec_array x xa = (case xa of Array xa \\<Rightarrow> x xa)", "apply (auto split: array.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition array_rel_def_internal:\n  \"array_rel R \\<equiv>\n    {(Array xs, Array ys)|xs ys. (xs,ys) \\<in> \\<langle>R\\<rangle>list_rel}\""], ["", "lemma array_rel_def:\n  \"\\<langle>R\\<rangle>array_rel \\<equiv> {(Array xs, Array ys)|xs ys. (xs,ys) \\<in> \\<langle>R\\<rangle>list_rel}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>R\\<rangle>array_rel \\<equiv>\n    {(Array xs, Array ys) |xs ys.\n     (xs, ys) \\<in> \\<langle>R\\<rangle>list_rel}", "unfolding array_rel_def_internal relAPP_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(Array xs, Array ys) |xs ys. (xs, ys) \\<in> list_rel R} \\<equiv>\n    {(Array xs, Array ys) |xs ys. (xs, ys) \\<in> list_rel R}", "."], ["", "lemma array_relD:\n  \"(Array l, Array l') \\<in> \\<langle>R\\<rangle>array_rel \\<Longrightarrow> (l,l') \\<in> \\<langle>R\\<rangle>list_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Array l, Array l') \\<in> \\<langle>R\\<rangle>array_rel \\<Longrightarrow>\n    (l, l') \\<in> \\<langle>R\\<rangle>list_rel", "by (simp add: array_rel_def)"], ["", "lemma array_rel_alt:\n  \"\\<langle>R\\<rangle>array_rel =\n  { (Array l, l) | l. True }\n  O \\<langle>R\\<rangle>list_rel\n  O {(l,Array l) | l. True}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>R\\<rangle>array_rel =\n    {(Array l, l) |l. True} O\n    \\<langle>R\\<rangle>list_rel O {(l, Array l) |l. True}", "by (auto simp: array_rel_def)"], ["", "lemma array_rel_sv[relator_props]:\n  shows \"single_valued R \\<Longrightarrow> single_valued (\\<langle>R\\<rangle>array_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued R \\<Longrightarrow>\n    single_valued (\\<langle>R\\<rangle>array_rel)", "unfolding array_rel_alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued R \\<Longrightarrow>\n    single_valued\n     ({(Array l, l) |l. True} O\n      \\<langle>R\\<rangle>list_rel O {(l, Array l) |l. True})", "apply (intro relator_props )"], ["proof (prove)\ngoal (3 subgoals):\n 1. single_valued R \\<Longrightarrow> single_valued {(Array l, l) |l. True}\n 2. single_valued R \\<Longrightarrow> single_valued R\n 3. single_valued R \\<Longrightarrow> single_valued {(l, Array l) |l. True}", "apply (auto intro: single_valuedI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma param_Array[param]:\n  \"(Array,Array) \\<in> \\<langle>R\\<rangle> list_rel \\<rightarrow> \\<langle>R\\<rangle> array_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Array, Array)\n    \\<in> \\<langle>R\\<rangle>list_rel \\<rightarrow>\n          \\<langle>R\\<rangle>array_rel", "apply (intro fun_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>R\\<rangle>list_rel \\<Longrightarrow>\n       (Array a, Array a') \\<in> \\<langle>R\\<rangle>array_rel", "apply (simp add: array_rel_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma param_rec_array[param]:\n  \"(rec_array,rec_array) \\<in> (\\<langle>Ra\\<rangle>list_rel \\<rightarrow> Rb) \\<rightarrow> \\<langle>Ra\\<rangle>array_rel \\<rightarrow> Rb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rec_array, rec_array)\n    \\<in> (\\<langle>Ra\\<rangle>list_rel \\<rightarrow> Rb) \\<rightarrow>\n          \\<langle>Ra\\<rangle>array_rel \\<rightarrow> Rb", "apply (intro fun_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Ra\\<rangle>list_rel \\<rightarrow> Rb;\n        (aa, a'a) \\<in> \\<langle>Ra\\<rangle>array_rel\\<rbrakk>\n       \\<Longrightarrow> (rec_array a aa, rec_array a' a'a) \\<in> Rb", "apply (rename_tac f f' a a', case_tac a, case_tac a')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f f' a a' x xa.\n       \\<lbrakk>(f, f') \\<in> \\<langle>Ra\\<rangle>list_rel \\<rightarrow> Rb;\n        (a, a') \\<in> \\<langle>Ra\\<rangle>array_rel; a = Array x;\n        a' = Array xa\\<rbrakk>\n       \\<Longrightarrow> (rec_array f a, rec_array f' a') \\<in> Rb", "apply (auto dest: fun_relD array_relD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma param_case_array[param]:\n  \"(case_array,case_array) \\<in> (\\<langle>Ra\\<rangle>list_rel \\<rightarrow> Rb) \\<rightarrow> \\<langle>Ra\\<rangle>array_rel \\<rightarrow> Rb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case_array, case_array)\n    \\<in> (\\<langle>Ra\\<rangle>list_rel \\<rightarrow> Rb) \\<rightarrow>\n          \\<langle>Ra\\<rangle>array_rel \\<rightarrow> Rb", "apply (clarsimp split: array.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' x xa.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Ra\\<rangle>list_rel \\<rightarrow> Rb;\n        (Array x, Array xa) \\<in> \\<langle>Ra\\<rangle>array_rel\\<rbrakk>\n       \\<Longrightarrow> (a x, a' xa) \\<in> Rb", "apply (drule array_relD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' x xa.\n       \\<lbrakk>(a, a') \\<in> \\<langle>Ra\\<rangle>list_rel \\<rightarrow> Rb;\n        (x, xa) \\<in> \\<langle>Ra\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (a x, a' xa) \\<in> Rb", "by parametricity"], ["", "lemma param_case_array1':\n  assumes \"(a,a')\\<in>\\<langle>Ra\\<rangle>array_rel\"\n  assumes \"\\<And>l l'. \\<lbrakk> a=Array l; a'=Array l'; (l,l')\\<in>\\<langle>Ra\\<rangle>list_rel \\<rbrakk>\n    \\<Longrightarrow> (f l,f' l') \\<in> Rb\"\n  shows \"(case_array f a,case_array f' a') \\<in> Rb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case a of Array x \\<Rightarrow> f x,\n     case a' of Array x \\<Rightarrow> f' x)\n    \\<in> Rb", "using assms"], ["proof (prove)\nusing this:\n  (a, a') \\<in> \\<langle>Ra\\<rangle>array_rel\n  \\<lbrakk>a = Array ?l; a' = Array ?l';\n   (?l, ?l') \\<in> \\<langle>Ra\\<rangle>list_rel\\<rbrakk>\n  \\<Longrightarrow> (f ?l, f' ?l') \\<in> Rb\n\ngoal (1 subgoal):\n 1. (case a of Array x \\<Rightarrow> f x,\n     case a' of Array x \\<Rightarrow> f' x)\n    \\<in> Rb", "apply (clarsimp split: array.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>(Array x, Array xa) \\<in> \\<langle>Ra\\<rangle>array_rel;\n        \\<And>l l'.\n           \\<lbrakk>x = l; xa = l';\n            (l, l') \\<in> \\<langle>Ra\\<rangle>list_rel\\<rbrakk>\n           \\<Longrightarrow> (f l, f' l') \\<in> Rb;\n        a = Array x; a' = Array xa\\<rbrakk>\n       \\<Longrightarrow> (f x, f' xa) \\<in> Rb", "apply (drule array_relD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>\\<And>l l'.\n                   \\<lbrakk>x = l; xa = l';\n                    (l, l') \\<in> \\<langle>Ra\\<rangle>list_rel\\<rbrakk>\n                   \\<Longrightarrow> (f l, f' l') \\<in> Rb;\n        a = Array x; a' = Array xa;\n        (x, xa) \\<in> \\<langle>Ra\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (f x, f' xa) \\<in> Rb", "apply parametricity"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>a = Array x; a' = Array xa;\n        (x, xa) \\<in> \\<langle>Ra\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> x = x\n 2. \\<And>x xa.\n       \\<lbrakk>a = Array x; a' = Array xa;\n        (x, xa) \\<in> \\<langle>Ra\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> xa = xa", "by (rule refl)+"], ["", "lemmas param_case_array2' = param_case_array1'[folded rec_array_is_case]"], ["", "lemmas param_case_array' = param_case_array1' param_case_array2'"], ["", "lemma param_array_length[param]:\n    \"(array_length,array_length) \\<in> \\<langle>Rb\\<rangle>array_rel \\<rightarrow> nat_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (array_length, array_length)\n    \\<in> \\<langle>Rb\\<rangle>array_rel \\<rightarrow> nat_rel", "unfolding array_length_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rec_array length, rec_array length)\n    \\<in> \\<langle>Rb\\<rangle>array_rel \\<rightarrow> nat_rel", "by parametricity"], ["", "lemma param_array_grow[param]:\n  \"(array_grow,array_grow) \\<in> \\<langle>R\\<rangle>array_rel \\<rightarrow> nat_rel \\<rightarrow> R \\<rightarrow> \\<langle>R\\<rangle>array_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (array_grow, array_grow)\n    \\<in> \\<langle>R\\<rangle>array_rel \\<rightarrow>\n          nat_rel \\<rightarrow> R \\<rightarrow> \\<langle>R\\<rangle>array_rel", "unfolding array_grow_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rec_array (\\<lambda>A inc x. Array (A @ replicate inc x)),\n     rec_array (\\<lambda>A inc x. Array (A @ replicate inc x)))\n    \\<in> \\<langle>R\\<rangle>array_rel \\<rightarrow>\n          nat_rel \\<rightarrow> R \\<rightarrow> \\<langle>R\\<rangle>array_rel", "by parametricity"], ["", "lemma array_rel_imp_same_length:\n  \"(a, a') \\<in> \\<langle>R\\<rangle>array_rel \\<Longrightarrow> array_length a = array_length a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a, a') \\<in> \\<langle>R\\<rangle>array_rel \\<Longrightarrow>\n    array_length a = array_length a'", "apply (cases a, cases a')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>(a, a') \\<in> \\<langle>R\\<rangle>array_rel; a = Array x;\n        a' = Array xa\\<rbrakk>\n       \\<Longrightarrow> array_length a = array_length a'", "apply (auto simp add: list_rel_imp_same_length dest!: array_relD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma param_array_get[param]:\n  assumes I: \"i<array_length a\"\n  assumes IR: \"(i,i')\\<in>nat_rel\"\n  assumes AR: \"(a,a')\\<in>\\<langle>R\\<rangle>array_rel\"\n  shows \"(array_get a i, array_get a' i') \\<in> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (array_get a i, array_get a' i') \\<in> R", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (array_get a i, array_get a' i') \\<in> R", "obtain l l' where [simp]: \"a = Array l\" \"a' = Array l'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l l'.\n        \\<lbrakk>a = Array l; a' = Array l'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases a, cases a', simp_all)"], ["proof (state)\nthis:\n  a = Array l\n  a' = Array l'\n\ngoal (1 subgoal):\n 1. (array_get a i, array_get a' i') \\<in> R", "from AR"], ["proof (chain)\npicking this:\n  (a, a') \\<in> \\<langle>R\\<rangle>array_rel", "have LR: \"(l,l') \\<in> \\<langle>R\\<rangle>list_rel\""], ["proof (prove)\nusing this:\n  (a, a') \\<in> \\<langle>R\\<rangle>array_rel\n\ngoal (1 subgoal):\n 1. (l, l') \\<in> \\<langle>R\\<rangle>list_rel", "by (force dest!: array_relD)"], ["proof (state)\nthis:\n  (l, l') \\<in> \\<langle>R\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. (array_get a i, array_get a' i') \\<in> R", "thus ?thesis"], ["proof (prove)\nusing this:\n  (l, l') \\<in> \\<langle>R\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. (array_get a i, array_get a' i') \\<in> R", "using assms"], ["proof (prove)\nusing this:\n  (l, l') \\<in> \\<langle>R\\<rangle>list_rel\n  i < array_length a\n  (i, i') \\<in> nat_rel\n  (a, a') \\<in> \\<langle>R\\<rangle>array_rel\n\ngoal (1 subgoal):\n 1. (array_get a i, array_get a' i') \\<in> R", "unfolding array_get_def"], ["proof (prove)\nusing this:\n  (l, l') \\<in> \\<langle>R\\<rangle>list_rel\n  i < array_length a\n  (i, i') \\<in> nat_rel\n  (a, a') \\<in> \\<langle>R\\<rangle>array_rel\n\ngoal (1 subgoal):\n 1. (rec_array (!) a i, rec_array (!) a' i') \\<in> R", "apply (auto intro!: param_nth[param_fo] dest: list_rel_imp_same_length)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (array_get a i, array_get a' i') \\<in> R\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma param_array_set[param]:\n  \"(array_set,array_set)\\<in>\\<langle>R\\<rangle>array_rel\\<rightarrow>nat_rel\\<rightarrow>R\\<rightarrow>\\<langle>R\\<rangle>array_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (array_set, array_set)\n    \\<in> \\<langle>R\\<rangle>array_rel \\<rightarrow>\n          nat_rel \\<rightarrow> R \\<rightarrow> \\<langle>R\\<rangle>array_rel", "unfolding array_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rec_array (\\<lambda>A n a. Array (A[n := a])),\n     rec_array (\\<lambda>A n a. Array (A[n := a])))\n    \\<in> \\<langle>R\\<rangle>array_rel \\<rightarrow>\n          nat_rel \\<rightarrow> R \\<rightarrow> \\<langle>R\\<rangle>array_rel", "by parametricity"], ["", "lemma param_array_of_list[param]:\n  \"(array_of_list, array_of_list) \\<in> \\<langle>R\\<rangle> list_rel \\<rightarrow> \\<langle>R\\<rangle> array_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (array_of_list, array_of_list)\n    \\<in> \\<langle>R\\<rangle>list_rel \\<rightarrow>\n          \\<langle>R\\<rangle>array_rel", "unfolding array_of_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Array, Array)\n    \\<in> \\<langle>R\\<rangle>list_rel \\<rightarrow>\n          \\<langle>R\\<rangle>array_rel", "by parametricity"], ["", "lemma param_array_shrink[param]:\n  assumes N: \"array_length a \\<ge> n\"\n  assumes NR: \"(n,n')\\<in>nat_rel\"\n  assumes AR: \"(a,a')\\<in>\\<langle>R\\<rangle>array_rel\"\n  shows \"(array_shrink a n, array_shrink a' n') \\<in> \\<langle>R\\<rangle> array_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (array_shrink a n, array_shrink a' n')\n    \\<in> \\<langle>R\\<rangle>array_rel", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (array_shrink a n, array_shrink a' n')\n    \\<in> \\<langle>R\\<rangle>array_rel", "obtain l l' where [simp]: \"a = Array l\" \"a' = Array l'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l l'.\n        \\<lbrakk>a = Array l; a' = Array l'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases a, cases a', simp_all)"], ["proof (state)\nthis:\n  a = Array l\n  a' = Array l'\n\ngoal (1 subgoal):\n 1. (array_shrink a n, array_shrink a' n')\n    \\<in> \\<langle>R\\<rangle>array_rel", "from AR"], ["proof (chain)\npicking this:\n  (a, a') \\<in> \\<langle>R\\<rangle>array_rel", "have LR: \"(l,l') \\<in> \\<langle>R\\<rangle>list_rel\""], ["proof (prove)\nusing this:\n  (a, a') \\<in> \\<langle>R\\<rangle>array_rel\n\ngoal (1 subgoal):\n 1. (l, l') \\<in> \\<langle>R\\<rangle>list_rel", "by (auto dest: array_relD)"], ["proof (state)\nthis:\n  (l, l') \\<in> \\<langle>R\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. (array_shrink a n, array_shrink a' n')\n    \\<in> \\<langle>R\\<rangle>array_rel", "with assms"], ["proof (chain)\npicking this:\n  n \\<le> array_length a\n  (n, n') \\<in> nat_rel\n  (a, a') \\<in> \\<langle>R\\<rangle>array_rel\n  (l, l') \\<in> \\<langle>R\\<rangle>list_rel", "show ?thesis"], ["proof (prove)\nusing this:\n  n \\<le> array_length a\n  (n, n') \\<in> nat_rel\n  (a, a') \\<in> \\<langle>R\\<rangle>array_rel\n  (l, l') \\<in> \\<langle>R\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. (array_shrink a n, array_shrink a' n')\n    \\<in> \\<langle>R\\<rangle>array_rel", "by (auto intro:\n      param_Array[param_fo] param_take[param_fo]\n      dest: array_rel_imp_same_length\n    )"], ["proof (state)\nthis:\n  (array_shrink a n, array_shrink a' n') \\<in> \\<langle>R\\<rangle>array_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma param_assoc_list_of_array[param]:\n  \"(assoc_list_of_array, assoc_list_of_array) \\<in>\n       \\<langle>R\\<rangle> array_rel \\<rightarrow> \\<langle>\\<langle>nat_rel,R\\<rangle>prod_rel\\<rangle>list_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (assoc_list_of_array, assoc_list_of_array)\n    \\<in> \\<langle>R\\<rangle>array_rel \\<rightarrow>\n          \\<langle>nat_rel \\<times>\\<^sub>r R\\<rangle>list_rel", "unfolding assoc_list_of_array_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rec_array (\\<lambda>a. zip [0..<length a] a),\n     rec_array (\\<lambda>a. zip [0..<length a] a))\n    \\<in> \\<langle>R\\<rangle>array_rel \\<rightarrow>\n          \\<langle>nat_rel \\<times>\\<^sub>r R\\<rangle>list_rel", "by parametricity"], ["", "lemma param_array_map[param]:\n  \"(array_map, array_map) \\<in>\n       (nat_rel \\<rightarrow> Ra \\<rightarrow> Rb) \\<rightarrow> \\<langle>Ra\\<rangle>array_rel \\<rightarrow> \\<langle>Rb\\<rangle>array_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (array_map, array_map)\n    \\<in> (nat_rel \\<rightarrow> Ra \\<rightarrow> Rb) \\<rightarrow>\n          \\<langle>Ra\\<rangle>array_rel \\<rightarrow>\n          \\<langle>Rb\\<rangle>array_rel", "unfolding array_map_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>f a.\n        array_of_list\n         (map (\\<lambda>(x, y). f x y) (assoc_list_of_array a)),\n     \\<lambda>f a.\n        array_of_list\n         (map (\\<lambda>(x, y). f x y) (assoc_list_of_array a)))\n    \\<in> (nat_rel \\<rightarrow> Ra \\<rightarrow> Rb) \\<rightarrow>\n          \\<langle>Ra\\<rangle>array_rel \\<rightarrow>\n          \\<langle>Rb\\<rangle>array_rel", "by parametricity"], ["", "lemma param_array_foldr[param]:\n  \"(array_foldr, array_foldr) \\<in>\n       (nat_rel \\<rightarrow> Ra \\<rightarrow> Rb \\<rightarrow> Rb) \\<rightarrow> \\<langle>Ra\\<rangle>array_rel \\<rightarrow> Rb \\<rightarrow> Rb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (array_foldr, array_foldr)\n    \\<in> (nat_rel \\<rightarrow>\n           Ra \\<rightarrow> Rb \\<rightarrow> Rb) \\<rightarrow>\n          \\<langle>Ra\\<rangle>array_rel \\<rightarrow> Rb \\<rightarrow> Rb", "unfolding array_foldr_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>f a. foldr (\\<lambda>(x, y). f x y) (assoc_list_of_array a),\n     \\<lambda>f a. foldr (\\<lambda>(x, y). f x y) (assoc_list_of_array a))\n    \\<in> (nat_rel \\<rightarrow>\n           Ra \\<rightarrow> Rb \\<rightarrow> Rb) \\<rightarrow>\n          \\<langle>Ra\\<rangle>array_rel \\<rightarrow> Rb \\<rightarrow> Rb", "by parametricity"], ["", "lemma param_array_foldl[param]:\n  \"(array_foldl, array_foldl) \\<in>\n       (nat_rel \\<rightarrow> Rb \\<rightarrow> Ra \\<rightarrow> Rb) \\<rightarrow> Rb \\<rightarrow> \\<langle>Ra\\<rangle>array_rel \\<rightarrow> Rb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (array_foldl, array_foldl)\n    \\<in> (nat_rel \\<rightarrow>\n           Rb \\<rightarrow> Ra \\<rightarrow> Rb) \\<rightarrow>\n          Rb \\<rightarrow> \\<langle>Ra\\<rangle>array_rel \\<rightarrow> Rb", "unfolding array_foldl_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>f b a.\n        foldl (\\<lambda>b (k, y). f k b y) b (assoc_list_of_array a),\n     \\<lambda>f b a.\n        foldl (\\<lambda>b (k, y). f k b y) b (assoc_list_of_array a))\n    \\<in> (nat_rel \\<rightarrow>\n           Rb \\<rightarrow> Ra \\<rightarrow> Rb) \\<rightarrow>\n          Rb \\<rightarrow> \\<langle>Ra\\<rangle>array_rel \\<rightarrow> Rb", "by parametricity"], ["", "subsection \\<open>Code Generator Setup\\<close>"], ["", "subsubsection \\<open>Code-Numeral Preparation\\<close>"], ["", "definition [code del]: \"new_array' v == new_array v o nat_of_integer\""], ["", "definition [code del]: \"array_length' == integer_of_nat o array_length\""], ["", "definition [code del]: \"array_get' a == array_get a o nat_of_integer\""], ["", "definition [code del]: \"array_set' a == array_set a o nat_of_integer\""], ["", "definition [code del]: \"array_grow' a == array_grow a o nat_of_integer\""], ["", "definition [code del]: \"array_shrink' a == array_shrink a o nat_of_integer\""], ["", "definition [code del]:\n  \"array_get_oo' x a == array_get_oo x a o nat_of_integer\""], ["", "definition [code del]:\n  \"array_set_oo' f a == array_set_oo f a o nat_of_integer\""], ["", "lemma [code]:\n  \"new_array v == new_array' v o integer_of_nat\"\n  \"array_length == nat_of_integer o array_length'\"\n  \"array_get a == array_get' a o integer_of_nat\"\n  \"array_set a == array_set' a o integer_of_nat\"\n  \"array_grow a == array_grow' a o integer_of_nat\"\n  \"array_shrink a == array_shrink' a o integer_of_nat\"\n  \"array_get_oo x a == array_get_oo' x a o integer_of_nat\"\n  \"array_set_oo f a == array_set_oo' f a o integer_of_nat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((new_array v \\<equiv> new_array' v \\<circ> integer_of_nat) &&&\n      array_length \\<equiv> nat_of_integer \\<circ> array_length') &&&\n     (array_get a \\<equiv> array_get' a \\<circ> integer_of_nat) &&&\n     array_set a \\<equiv> array_set' a \\<circ> integer_of_nat) &&&\n    ((array_grow a \\<equiv> array_grow' a \\<circ> integer_of_nat) &&&\n     array_shrink a \\<equiv> array_shrink' a \\<circ> integer_of_nat) &&&\n    (array_get_oo x a \\<equiv> array_get_oo' x a \\<circ> integer_of_nat) &&&\n    array_set_oo f a \\<equiv> array_set_oo' f a \\<circ> integer_of_nat", "by (simp_all\n    add: o_def\n    add: new_array'_def array_length'_def array_get'_def array_set'_def\n      array_grow'_def array_shrink'_def array_get_oo'_def array_set_oo'_def)"], ["", "text \\<open>Fallbacks\\<close>"], ["", "lemmas [code] = array_get_oo'_def[unfolded array_get_oo_def[abs_def]]"], ["", "lemmas [code] = array_set_oo'_def[unfolded array_set_oo_def[abs_def]]"], ["", "subsubsection \\<open>Code generator setup for Haskell\\<close>"], ["", "code_printing type_constructor array \\<rightharpoonup>\n  (Haskell) \"Array.ArrayType/ _\""], ["", "code_reserved Haskell array_of_list"], ["", "(*\ncode_printing code_module \"Array\" \\<rightharpoonup>\n  (Haskell) {*\n--import qualified Data.Array.Diff as Arr;\nimport qualified Data.Array as Arr;\nimport Data.Array.IArray;\nimport Nat;\n\ninstance Ix Nat where {\n    range (Nat a, Nat b) = map Nat (range (a, b));\n    index (Nat a, Nat b) (Nat c) = index (a,b) c;\n    inRange (Nat a, Nat b) (Nat c) = inRange (a, b) c;\n    rangeSize (Nat a, Nat b) = rangeSize (a, b);\n};\n\ntype ArrayType = Arr.DiffArray Nat;\n--type ArrayType = Arr.Array Nat;\n\n-- we need to start at 1 and not 0, because the empty array\n-- is modelled by having s > e for (s,e) = bounds\n-- and as we are in Nat, 0 is the smallest number\n\narray_of_size :: Nat -> [e] -> ArrayType e;\narray_of_size n = Arr.listArray (1, n);\n\nnew_array :: e -> Nat -> ArrayType e;\nnew_array a n = array_of_size n (repeat a);\n\narray_length :: ArrayType e -> Nat;\narray_length a = let (s, e) = bounds a in if s > e then 0 else e - s + 1;\n-- the `if` is actually needed, because in Nat we have s > e --> e - s + 1 = 1\n\narray_get :: ArrayType e -> Nat -> e;\narray_get a i = a ! (i + 1);\n\narray_set :: ArrayType e -> Nat -> e -> ArrayType e;\narray_set a i e = a // [(i + 1, e)];\n\narray_of_list :: [e] -> ArrayType e;\narray_of_list xs = array_of_size (fromInteger (toInteger (length xs - 1))) xs;\n\narray_grow :: ArrayType e -> Nat -> e -> ArrayType e;\narray_grow a i x = let (s, e) = bounds a in Arr.listArray (s, e+i) (Arr.elems a ++ repeat x);\n\narray_shrink :: ArrayType e -> Nat -> ArrayType e;\narray_shrink a sz = if sz > array_length a then undefined else array_of_size sz (Arr.elems a);\n*}\n*)\n\n(* TODO/FIXME: Using standard functional arrays here, as DiffArray seems \n  to be discontinued in Haskell! *)"], ["", "code_printing code_module \"Array\" \\<rightharpoonup>\n  (Haskell) \\<open>module Array where {\n\n--import qualified Data.Array.Diff as Arr;\nimport qualified Data.Array as Arr;\n\ntype ArrayType = Arr.Array Integer;\n\n\narray_of_size :: Integer -> [e] -> ArrayType e;\narray_of_size n = Arr.listArray (0, n-1);\n\nnew_array :: e -> Integer -> ArrayType e;\nnew_array a n = array_of_size n (repeat a);\n\narray_length :: ArrayType e -> Integer;\narray_length a = let (s, e) = Arr.bounds a in e;\n\narray_get :: ArrayType e -> Integer -> e;\narray_get a i = a Arr.! i;\n\narray_set :: ArrayType e -> Integer -> e -> ArrayType e;\narray_set a i e = a Arr.// [(i, e)];\n\narray_of_list :: [e] -> ArrayType e;\narray_of_list xs = array_of_size (toInteger (length xs)) xs;\n\narray_grow :: ArrayType e -> Integer -> e -> ArrayType e;\narray_grow a i x = let (s, e) = Arr.bounds a in Arr.listArray (s, e+i) (Arr.elems a ++ repeat x);\n\narray_shrink :: ArrayType e -> Integer -> ArrayType e;\narray_shrink a sz = if sz > array_length a then undefined else array_of_size sz (Arr.elems a);\n}\\<close>"], ["", "code_printing constant Array \\<rightharpoonup> (Haskell) \"Array.array'_of'_list\""], ["", "code_printing constant new_array' \\<rightharpoonup> (Haskell) \"Array.new'_array\""], ["", "code_printing constant array_length' \\<rightharpoonup> (Haskell) \"Array.array'_length\""], ["", "code_printing constant array_get' \\<rightharpoonup> (Haskell) \"Array.array'_get\""], ["", "code_printing constant array_set' \\<rightharpoonup> (Haskell) \"Array.array'_set\""], ["", "code_printing constant array_of_list \\<rightharpoonup> (Haskell) \"Array.array'_of'_list\""], ["", "code_printing constant array_grow' \\<rightharpoonup> (Haskell) \"Array.array'_grow\""], ["", "code_printing constant array_shrink' \\<rightharpoonup> (Haskell) \"Array.array'_shrink\""], ["", "subsubsection \\<open>Code Generator Setup For SML\\<close>"], ["", "text \\<open>\n  We have the choice between single-threaded arrays, that raise an exception if an old version is accessed,\n  and truly functional arrays, that update the array in place, but store undo-information to restore\n  old versions.\n\\<close>"], ["", "code_printing code_module \"STArray\" \\<rightharpoonup>\n  (SML)\n\\<open>\nstructure STArray = struct\n\ndatatype 'a Cell = Invalid | Value of 'a array;\n\nexception AccessedOldVersion;\n\ntype 'a array = 'a Cell Unsynchronized.ref;\n\nfun fromList l = Unsynchronized.ref (Value (Array.fromList l));\nfun array (size, v) = Unsynchronized.ref (Value (Array.array (size,v)));\nfun tabulate (size, f) = Unsynchronized.ref (Value (Array.tabulate(size, f)));\nfun sub (Unsynchronized.ref Invalid, idx) = raise AccessedOldVersion |\n    sub (Unsynchronized.ref (Value a), idx) = Array.sub (a,idx);\nfun update (aref,idx,v) =\n  case aref of\n    (Unsynchronized.ref Invalid) => raise AccessedOldVersion |\n    (Unsynchronized.ref (Value a)) => (\n      aref := Invalid;\n      Array.update (a,idx,v);\n      Unsynchronized.ref (Value a)\n    );\n\nfun length (Unsynchronized.ref Invalid) = raise AccessedOldVersion |\n    length (Unsynchronized.ref (Value a)) = Array.length a\n\nfun grow (aref, i, x) = case aref of\n  (Unsynchronized.ref Invalid) => raise AccessedOldVersion |\n  (Unsynchronized.ref (Value a)) => (\n    let val len=Array.length a;\n        val na = Array.array (len+i,x)\n    in\n      aref := Invalid;\n      Array.copy {src=a, dst=na, di=0};\n      Unsynchronized.ref (Value na)\n    end\n    );\n\nfun shrink (aref, sz) = case aref of\n  (Unsynchronized.ref Invalid) => raise AccessedOldVersion |\n  (Unsynchronized.ref (Value a)) => (\n    if sz > Array.length a then\n      raise Size\n    else (\n      aref:=Invalid;\n      Unsynchronized.ref (Value (Array.tabulate (sz,fn i => Array.sub (a,i))))\n    )\n  );\n\nstructure IsabelleMapping = struct\ntype 'a ArrayType = 'a array;\n\nfun new_array (a:'a) (n:IntInf.int) = array (IntInf.toInt n, a);\n\nfun array_length (a:'a ArrayType) = IntInf.fromInt (length a);\n\nfun array_get (a:'a ArrayType) (i:IntInf.int) = sub (a, IntInf.toInt i);\n\nfun array_set (a:'a ArrayType) (i:IntInf.int) (e:'a) = update (a, IntInf.toInt i, e);\n\nfun array_of_list (xs:'a list) = fromList xs;\n\nfun array_grow (a:'a ArrayType) (i:IntInf.int) (x:'a) = grow (a, IntInf.toInt i, x);\n\nfun array_shrink (a:'a ArrayType) (sz:IntInf.int) = shrink (a,IntInf.toInt sz);\n\nend;\n\nend;\n\nstructure FArray = struct\n  datatype 'a Cell = Value of 'a Array.array | Upd of (int*'a*'a Cell Unsynchronized.ref);\n\n  type 'a array = 'a Cell Unsynchronized.ref;\n\n  fun array (size,v) = Unsynchronized.ref (Value (Array.array (size,v)));\n  fun tabulate (size, f) = Unsynchronized.ref (Value (Array.tabulate(size, f)));\n  fun fromList l = Unsynchronized.ref (Value (Array.fromList l));\n\n  fun sub (Unsynchronized.ref (Value a), idx) = Array.sub (a,idx) |\n      sub (Unsynchronized.ref (Upd (i,v,cr)),idx) =\n        if i=idx then v\n        else sub (cr,idx);\n\n  fun length (Unsynchronized.ref (Value a)) = Array.length a |\n      length (Unsynchronized.ref (Upd (i,v,cr))) = length cr;\n\n  fun realize_aux (aref, v) =\n    case aref of\n      (Unsynchronized.ref (Value a)) => (\n        let\n          val len = Array.length a;\n          val a' = Array.array (len,v);\n        in\n          Array.copy {src=a, dst=a', di=0};\n          Unsynchronized.ref (Value a')\n        end\n      ) |\n      (Unsynchronized.ref (Upd (i,v,cr))) => (\n        let val res=realize_aux (cr,v) in\n          case res of\n            (Unsynchronized.ref (Value a)) => (Array.update (a,i,v); res)\n        end\n      );\n\n  fun realize aref =\n    case aref of\n      (Unsynchronized.ref (Value _)) => aref |\n      (Unsynchronized.ref (Upd (i,v,cr))) => realize_aux(aref,v);\n\n  fun update (aref,idx,v) =\n    case aref of\n      (Unsynchronized.ref (Value a)) => (\n        let val nref=Unsynchronized.ref (Value a) in\n          aref := Upd (idx,Array.sub(a,idx),nref);\n          Array.update (a,idx,v);\n          nref\n        end\n      ) |\n      (Unsynchronized.ref (Upd _)) =>\n        let val ra = realize_aux(aref,v) in\n          case ra of\n            (Unsynchronized.ref (Value a)) => Array.update (a,idx,v);\n          ra\n        end\n      ;\n\n  fun grow (aref, inc, x) = case aref of\n    (Unsynchronized.ref (Value a)) => (\n      let val len=Array.length a;\n          val na = Array.array (len+inc,x)\n      in\n        Array.copy {src=a, dst=na, di=0};\n        Unsynchronized.ref (Value na)\n      end\n      )\n  | (Unsynchronized.ref (Upd _)) => (\n    grow (realize aref, inc, x)\n  );\n\n  fun shrink (aref, sz) = case aref of\n    (Unsynchronized.ref (Value a)) => (\n      if sz > Array.length a then\n        raise Size\n      else (\n        Unsynchronized.ref (Value (Array.tabulate (sz,fn i => Array.sub (a,i))))\n      )\n    ) |\n    (Unsynchronized.ref (Upd _)) => (\n      shrink (realize aref,sz)\n    );\n\nstructure IsabelleMapping = struct\ntype 'a ArrayType = 'a array;\n\nfun new_array (a:'a) (n:IntInf.int) = array (IntInf.toInt n, a);\n\nfun array_length (a:'a ArrayType) = IntInf.fromInt (length a);\n\nfun array_get (a:'a ArrayType) (i:IntInf.int) = sub (a, IntInf.toInt i);\n\nfun array_set (a:'a ArrayType) (i:IntInf.int) (e:'a) = update (a, IntInf.toInt i, e);\n\nfun array_of_list (xs:'a list) = fromList xs;\n\nfun array_grow (a:'a ArrayType) (i:IntInf.int) (x:'a) = grow (a, IntInf.toInt i, x);\n\nfun array_shrink (a:'a ArrayType) (sz:IntInf.int) = shrink (a,IntInf.toInt sz);\n\nfun array_get_oo (d:'a) (a:'a ArrayType) (i:IntInf.int) =\n  sub (a,IntInf.toInt i) handle Subscript => d\n\nfun array_set_oo (d:(unit->'a ArrayType)) (a:'a ArrayType) (i:IntInf.int) (e:'a) =\n  update (a, IntInf.toInt i, e) handle Subscript => d ()\n\nend;\nend;\n\n\n\\<close>"], ["", "code_printing\n  type_constructor array \\<rightharpoonup> (SML) \"_/ FArray.IsabelleMapping.ArrayType\"\n| constant Array \\<rightharpoonup> (SML) \"FArray.IsabelleMapping.array'_of'_list\"\n| constant new_array' \\<rightharpoonup> (SML) \"FArray.IsabelleMapping.new'_array\"\n| constant array_length' \\<rightharpoonup> (SML) \"FArray.IsabelleMapping.array'_length\"\n| constant array_get' \\<rightharpoonup> (SML) \"FArray.IsabelleMapping.array'_get\"\n| constant array_set' \\<rightharpoonup> (SML) \"FArray.IsabelleMapping.array'_set\"\n| constant array_grow' \\<rightharpoonup> (SML) \"FArray.IsabelleMapping.array'_grow\"\n| constant array_shrink' \\<rightharpoonup> (SML) \"FArray.IsabelleMapping.array'_shrink\"\n| constant array_of_list \\<rightharpoonup> (SML) \"FArray.IsabelleMapping.array'_of'_list\"\n| constant array_get_oo' \\<rightharpoonup> (SML) \"FArray.IsabelleMapping.array'_get'_oo\"\n| constant array_set_oo' \\<rightharpoonup> (SML) \"FArray.IsabelleMapping.array'_set'_oo\""], ["", "subsection \\<open>Code Generator Setup for Scala\\<close>"], ["", "text \\<open>\n  We use a DiffArray-Implementation in Scala.\n\\<close>"], ["", "code_printing code_module \"DiffArray\" \\<rightharpoonup>\n  (Scala) \\<open>\nobject DiffArray {\n\n  import scala.collection.mutable.ArraySeq\n\n  protected abstract sealed class DiffArray_D[A]\n  final case class Current[A] (a:ArraySeq[AnyRef]) extends DiffArray_D[A]\n  final case class Upd[A] (i:Int, v:A, n:DiffArray_D[A]) extends DiffArray_D[A]\n\n  object DiffArray_Realizer {\n    def realize[A](a:DiffArray_D[A]) : ArraySeq[AnyRef] = a match {\n      case Current(a) => ArraySeq.empty ++ a\n      case Upd(j,v,n) => {val a = realize(n); a.update(j, v.asInstanceOf[AnyRef]); a}\n    }\n  }\n\n  class T[A] (var d:DiffArray_D[A]) {\n\n    def realize (): ArraySeq[AnyRef] = { val a=DiffArray_Realizer.realize(d); d = Current(a); a }\n    override def toString() = realize().toSeq.toString\n\n    override def equals(obj:Any) =\n      if (obj.isInstanceOf[T[A]]) obj.asInstanceOf[T[A]].realize().equals(realize())\n      else false\n\n  }\n\n\n  def array_of_list[A](l : List[A]) : T[A] = new T(Current(ArraySeq.empty ++ l.asInstanceOf[List[AnyRef]]))\n  def new_array[A](v:A, sz : BigInt) = new T[A](Current[A](ArraySeq.fill[AnyRef](sz.intValue)(v.asInstanceOf[AnyRef])))\n\n  private def length[A](a:DiffArray_D[A]) : BigInt = a match {\n    case Current(a) => a.length\n    case Upd(_,_,n) => length(n)\n  }\n\n  def length[A](a : T[A]) : BigInt = length(a.d)\n\n  private def sub[A](a:DiffArray_D[A], i:Int) : A = a match {\n    case Current(a) => a(i).asInstanceOf[A]\n    case Upd(j,v,n) => if (i==j) v else sub(n,i)\n  }\n\n  def get[A](a:T[A], i:BigInt) : A = sub(a.d,i.intValue)\n\n  private def realize[A](a:DiffArray_D[A]): ArraySeq[AnyRef] = DiffArray_Realizer.realize[A](a)\n\n  def set[A](a:T[A], i:BigInt,v:A) : T[A] = a.d match {\n    case Current(ad) => {\n      val ii = i.intValue;\n      a.d = Upd(ii,ad(ii).asInstanceOf[A],a.d);\n      //ad.update(ii,v);\n      ad(ii)=v.asInstanceOf[AnyRef]\n      new T[A](Current(ad))\n    }\n    case Upd(_,_,_) => set(new T[A](Current(realize(a.d))), i.intValue,v)\n  }\n\n  def grow[A](a:T[A], sz:BigInt, v:A) : T[A] = a.d match {\n    case Current(ad) => {\n      val adt = ArraySeq.fill[AnyRef](sz.intValue)(v.asInstanceOf[AnyRef])\n      System.arraycopy(ad.array, 0, adt.array, 0, ad.length);\n      new T[A](Current[A](adt))\n    }\n    case Upd (_,_,_) =>  {\n      val adt = ArraySeq.fill[AnyRef](sz.intValue)(v.asInstanceOf[AnyRef])\n      val ad = realize(a.d)\n      System.arraycopy(ad.array, 0, adt.array, 0, ad.length);\n      new T[A](Current[A](adt))\n    }\n  }\n\n  def shrink[A](a:T[A], sz:BigInt) : T[A] =\n    if (sz==0) {\n      array_of_list(Nil)\n    } else {\n      a.d match {\n        case Current(ad) => {\n          val v=ad(0);\n          val szz=sz.intValue\n          val adt = ArraySeq.fill[AnyRef](szz)(v);\n          System.arraycopy(ad.array, 0, adt.array, 0, szz);\n          new T[A](Current[A](adt))\n        }\n        case Upd (_,_,_) =>  {\n          val ad = realize(a.d);\n          val szz=sz.intValue\n          val v=ad(0);\n          val adt = ArraySeq.fill[AnyRef](szz)(v);\n          System.arraycopy(ad.array, 0, adt.array, 0, szz);\n          new T[A](Current[A](adt))\n        }\n      }\n    }\n\n  def get_oo[A](d: => A, a:T[A], i:BigInt):A = try get(a,i) catch {\n    case _:scala.IndexOutOfBoundsException => d\n  }\n\n  def set_oo[A](d: Unit => T[A], a:T[A], i:BigInt, v:A) : T[A] = try set(a,i,v) catch {\n    case _:scala.IndexOutOfBoundsException => d(())\n  }\n\n}\n\n/*\nobject Test {\n\n\n\n  def assert (b : Boolean) : Unit = if (b) () else throw new java.lang.AssertionError(\"Assertion Failed\")\n\n  def eql[A] (a:DiffArray.T[A], b:List[A]) = assert (a.realize.corresponds(b)((x,y) => x.equals(y)))\n\n\n  def tests1(): Unit = {\n    val a = DiffArray.array_of_list(1::2::3::4::Nil)\n      eql(a,1::2::3::4::Nil)\n\n    // Simple update\n    val b = DiffArray.set(a,2,9)\n      eql(a,1::2::3::4::Nil)\n      eql(b,1::2::9::4::Nil)\n\n    // Another update\n    val c = DiffArray.set(b,3,9)\n      eql(a,1::2::3::4::Nil)\n      eql(b,1::2::9::4::Nil)\n      eql(c,1::2::9::9::Nil)\n\n    // Update of old version (forces realize)\n    val d = DiffArray.set(b,2,8)\n      eql(a,1::2::3::4::Nil)\n      eql(b,1::2::9::4::Nil)\n      eql(c,1::2::9::9::Nil)\n      eql(d,1::2::8::4::Nil)\n\n    }\n\n  def tests2(): Unit = {\n    val a = DiffArray.array_of_list(1::2::3::4::Nil)\n      eql(a,1::2::3::4::Nil)\n\n    // Simple update\n    val b = DiffArray.set(a,2,9)\n      eql(a,1::2::3::4::Nil)\n      eql(b,1::2::9::4::Nil)\n\n    // Grow of current version\n    val c = DiffArray.grow(b,6,9)\n      eql(a,1::2::3::4::Nil)\n      eql(b,1::2::9::4::Nil)\n      eql(c,1::2::9::4::9::9::Nil)\n\n    // Grow of old version\n    val d = DiffArray.grow(a,6,9)\n      eql(a,1::2::3::4::Nil)\n      eql(b,1::2::9::4::Nil)\n      eql(c,1::2::9::4::9::9::Nil)\n      eql(d,1::2::3::4::9::9::Nil)\n\n  }\n\n  def tests3(): Unit = {\n    val a = DiffArray.array_of_list(1::2::3::4::Nil)\n      eql(a,1::2::3::4::Nil)\n\n    // Simple update\n    val b = DiffArray.set(a,2,9)\n      eql(a,1::2::3::4::Nil)\n      eql(b,1::2::9::4::Nil)\n\n    // Shrink of current version\n    val c = DiffArray.shrink(b,3)\n      eql(a,1::2::3::4::Nil)\n      eql(b,1::2::9::4::Nil)\n      eql(c,1::2::9::Nil)\n\n    // Shrink of old version\n    val d = DiffArray.shrink(a,3)\n      eql(a,1::2::3::4::Nil)\n      eql(b,1::2::9::4::Nil)\n      eql(c,1::2::9::Nil)\n      eql(d,1::2::3::Nil)\n\n  }\n\n  def tests4(): Unit = {\n    val a = DiffArray.array_of_list(1::2::3::4::Nil)\n      eql(a,1::2::3::4::Nil)\n\n    // Update _oo (succeeds)\n    val b = DiffArray.set_oo((_) => a,a,2,9)\n      eql(a,1::2::3::4::Nil)\n      eql(b,1::2::9::4::Nil)\n\n    // Update _oo (current version,fails)\n    val c = DiffArray.set_oo((_) => a,b,5,9)\n      eql(a,1::2::3::4::Nil)\n      eql(b,1::2::9::4::Nil)\n      eql(c,1::2::3::4::Nil)\n\n    // Update _oo (old version,fails)\n    val d = DiffArray.set_oo((_) => b,a,5,9)\n      eql(a,1::2::3::4::Nil)\n      eql(b,1::2::9::4::Nil)\n      eql(c,1::2::3::4::Nil)\n      eql(d,1::2::9::4::Nil)\n\n  }\n\n  def tests5(): Unit = {\n    val a = DiffArray.array_of_list(1::2::3::4::Nil)\n      eql(a,1::2::3::4::Nil)\n\n    // Update\n    val b = DiffArray.set(a,2,9)\n      eql(a,1::2::3::4::Nil)\n      eql(b,1::2::9::4::Nil)\n\n    // Get_oo (current version, succeeds)\n      assert (DiffArray.get_oo(0,b,2)==9)\n    // Get_oo (current version, fails)\n      assert (DiffArray.get_oo(0,b,5)==0)\n    // Get_oo (old version, succeeds)\n      assert (DiffArray.get_oo(0,a,2)==3)\n    // Get_oo (old version, fails)\n      assert (DiffArray.get_oo(0,a,5)==0)\n\n  }\n\n\n\n\n  def main(args: Array[String]): Unit = {\n    tests1 ()\n    tests2 ()\n    tests3 ()\n    tests4 ()\n    tests5 ()\n\n\n    Console.println(\"Tests passed\")\n  }\n\n}*/\n\n\\<close>"], ["", "code_printing\n  type_constructor array \\<rightharpoonup> (Scala) \"DiffArray.T[_]\"\n| constant Array \\<rightharpoonup> (Scala) \"DiffArray.array'_of'_list\"\n| constant new_array' \\<rightharpoonup> (Scala) \"DiffArray.new'_array((_),(_).toInt)\"\n| constant array_length' \\<rightharpoonup> (Scala) \"DiffArray.length((_)).toInt\"\n| constant array_get' \\<rightharpoonup> (Scala) \"DiffArray.get((_),(_).toInt)\"\n| constant array_set' \\<rightharpoonup> (Scala) \"DiffArray.set((_),(_).toInt,(_))\"\n| constant array_grow' \\<rightharpoonup> (Scala) \"DiffArray.grow((_),(_).toInt,(_))\"\n| constant array_shrink' \\<rightharpoonup> (Scala) \"DiffArray.shrink((_),(_).toInt)\"\n| constant array_of_list \\<rightharpoonup> (Scala) \"DiffArray.array'_of'_list\"\n| constant array_get_oo' \\<rightharpoonup> (Scala) \"DiffArray.get'_oo((_),(_),(_).toInt)\"\n| constant array_set_oo' \\<rightharpoonup> (Scala) \"DiffArray.set'_oo((_),(_),(_).toInt,(_))\""], ["", "context begin"], ["", "(*private*)"], ["", "definition \"test_diffarray_setup \\<equiv> (Array,new_array',array_length',array_get', array_set', array_grow', array_shrink',array_of_list,array_get_oo',array_set_oo')\""], ["", "export_code test_diffarray_setup checking Scala SML OCaml? Haskell?"], ["", "end"], ["", "end"]]}