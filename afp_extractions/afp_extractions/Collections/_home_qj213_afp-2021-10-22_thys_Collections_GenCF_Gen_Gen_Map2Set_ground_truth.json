{"file_name": "/home/qj213/afp-2021-10-22/thys/Collections/GenCF/Gen/Gen_Map2Set.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Collections", "problem_names": ["lemma map_fst_unit_distinct_eq[simp]:\n  fixes l :: \"('k\\<times>unit) list\"\n  shows \"distinct (map fst l) \\<longleftrightarrow> distinct l\"", "lemma map2set_rel_def: \"\\<langle>Rk\\<rangle>(map2set_rel R) \n  = \\<langle>Rk,Id::(unit\\<times>_) set\\<rangle>R O {(m,dom m)| m. True}\"", "lemma map2set_relI:\n  assumes \"(s,m')\\<in>\\<langle>Rk,Id\\<rangle>R\" and \"s'=dom m'\"\n  shows \"(s,s')\\<in>\\<langle>Rk\\<rangle>map2set_rel R\"", "lemma map2set_relE:\n  assumes \"(s,s')\\<in>\\<langle>Rk\\<rangle>map2set_rel R\"\n  obtains m' where \"(s,m')\\<in>\\<langle>Rk,Id\\<rangle>R\" and \"s'=dom m'\"", "lemma map2set_rel_sv[relator_props]:\n  \"single_valued (\\<langle>Rk,Id\\<rangle>Rm) \\<Longrightarrow> single_valued (\\<langle>Rk\\<rangle>map2set_rel Rm)\"", "lemma map2set_empty[autoref_rules_raw]:\n  assumes \"PRIO_TAG_GEN_ALGO\"\n  assumes \"GEN_OP e op_map_empty (\\<langle>Rk,Id\\<rangle>R)\"\n  shows \"(e,{})\\<in>\\<langle>Rk\\<rangle>map2set_rel R\"", "lemmas [autoref_rel_intf] = \n  REL_INTFI[of \"map2set_rel R\" i_set] for R", "lemma map2set_insert[autoref_rules_raw]:\n  assumes \"PRIO_TAG_GEN_ALGO\"\n  assumes \"GEN_OP i op_map_update (Rk \\<rightarrow> Id \\<rightarrow> \\<langle>Rk,Id\\<rangle>R \\<rightarrow> \\<langle>Rk,Id\\<rangle>R)\"\n  shows \n    \"(map2set_insert i,Set.insert)\\<in>Rk\\<rightarrow>\\<langle>Rk\\<rangle>map2set_rel R \\<rightarrow> \\<langle>Rk\\<rangle>map2set_rel R\"", "lemma map2set_memb[autoref_rules_raw]:\n  assumes \"PRIO_TAG_GEN_ALGO\"\n  assumes \"GEN_OP l op_map_lookup (Rk \\<rightarrow> \\<langle>Rk,Id\\<rangle>R \\<rightarrow> \\<langle>Id\\<rangle>option_rel)\"\n  shows \"(map2set_memb l ,(\\<in>))\n    \\<in> Rk\\<rightarrow>\\<langle>Rk\\<rangle>map2set_rel R\\<rightarrow>Id\"", "lemma map2set_delete[autoref_rules_raw]:\n  assumes \"PRIO_TAG_GEN_ALGO\"\n  assumes \"GEN_OP d op_map_delete (Rk\\<rightarrow>\\<langle>Rk,Id\\<rangle>R\\<rightarrow>\\<langle>Rk,Id\\<rangle>R)\"\n  shows \"(d,op_set_delete)\\<in>Rk\\<rightarrow>\\<langle>Rk\\<rangle>map2set_rel R\\<rightarrow>\\<langle>Rk\\<rangle>map2set_rel R\"", "lemma map2set_to_sorted_list[autoref_ga_rules]:\n  fixes it :: \"'m \\<Rightarrow> ('k\\<times>unit) list\"\n  assumes A: \"GEN_ALGO_tag (is_map_to_sorted_list ordR Rk Id R it)\"\n  shows \"is_set_to_sorted_list ordR Rk (map2set_rel R) \n    (it_to_list (map_iterator_dom o (foldli o it)))\"", "lemma map2set_to_list[autoref_ga_rules]:\n  fixes it :: \"'m \\<Rightarrow> ('k\\<times>unit) list\"\n  assumes A: \"GEN_ALGO_tag (is_map_to_list Rk Id R it)\"\n  shows \"is_set_to_list Rk (map2set_rel R) \n    (it_to_list (map_iterator_dom o (foldli o it)))\"", "lemma map2set_union[autoref_rules_raw]:\n  assumes \"MINOR_PRIO_TAG (- 9)\"\n  assumes \"GEN_OP u (++) (\\<langle>Rk,Id\\<rangle>R\\<rightarrow>\\<langle>Rk,Id\\<rangle>R\\<rightarrow>\\<langle>Rk,Id\\<rangle>R)\"\n  shows \"(u,(\\<union>))\\<in>\\<langle>Rk\\<rangle>map2set_rel R\\<rightarrow>\\<langle>Rk\\<rangle>map2set_rel R\\<rightarrow>\\<langle>Rk\\<rangle>map2set_rel R\"", "lemmas [autoref_ga_rules] = cmp_unit_eq_linorder", "lemmas [autoref_rules_raw] = param_cmp_unit", "lemma cmp_lex_zip_unit[simp]:\n  \"cmp_lex (cmp_prod cmp cmp_unit) (map (\\<lambda>k. (k, ())) l)\n           (map (\\<lambda>k. (k, ())) m) =\n          cmp_lex cmp l m\"", "lemma cmp_img_zip_unit[simp]:\n  \"cmp_img (\\<lambda>m. map (\\<lambda>k. (k,())) (f m)) (cmp_lex (cmp_prod cmp1 cmp_unit))\n    = cmp_img f (cmp_lex cmp1)\"", "lemma map2set_finite[relator_props]:\n  assumes \"finite_map_rel (\\<langle>Rk,Id\\<rangle>R)\"\n  shows \"finite_set_rel (\\<langle>Rk\\<rangle>map2set_rel R)\"", "lemma map2set_cmp[autoref_rules_raw]:\n  assumes ELO: \"SIDE_GEN_ALGO (eq_linorder cmpk)\"\n  assumes MPAR:\n    \"GEN_OP cmp (cmp_map cmpk cmp_unit) (\\<langle>Rk,Id\\<rangle>R \\<rightarrow> \\<langle>Rk,Id\\<rangle>R \\<rightarrow> Id)\"\n  assumes FIN: \"PREFER finite_map_rel (\\<langle>Rk, Id\\<rangle>R)\"\n  shows \"(cmp,cmp_set cmpk)\\<in>\\<langle>Rk\\<rangle>map2set_rel R \\<rightarrow> \\<langle>Rk\\<rangle>map2set_rel R \\<rightarrow> Id\""], "translations": [["", "lemma map_fst_unit_distinct_eq[simp]:\n  fixes l :: \"('k\\<times>unit) list\"\n  shows \"distinct (map fst l) \\<longleftrightarrow> distinct l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst l) = distinct l", "by (induct l) auto"], ["", "definition \n  map2set_rel :: \"\n    (('ki\\<times>'k) set \\<Rightarrow> (unit\\<times>unit) set \\<Rightarrow> ('mi\\<times>('k\\<rightharpoonup>unit))set) \\<Rightarrow> \n    ('ki\\<times>'k) set \\<Rightarrow> \n    ('mi\\<times>('k set)) set\"\n  where \n  map2set_rel_def_internal: \n  \"map2set_rel R Rk \\<equiv> \\<langle>Rk,Id::(unit\\<times>_) set\\<rangle>R O {(m,dom m)| m. True}\""], ["", "lemma map2set_rel_def: \"\\<langle>Rk\\<rangle>(map2set_rel R) \n  = \\<langle>Rk,Id::(unit\\<times>_) set\\<rangle>R O {(m,dom m)| m. True}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>Rk\\<rangle>map2set_rel R =\n    \\<langle>Rk, unit_rel\\<rangle>R O {(m, dom m) |m. True}", "unfolding map2set_rel_def_internal[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>Rk\\<rangle>(\\<lambda>Rk.\n                            \\<langle>Rk, unit_rel\\<rangle>R O\n                            {(m, dom m) |m. True}) =\n    \\<langle>Rk, unit_rel\\<rangle>R O {(m, dom m) |m. True}", "by (simp add: relAPP_def)"], ["", "lemma map2set_relI:\n  assumes \"(s,m')\\<in>\\<langle>Rk,Id\\<rangle>R\" and \"s'=dom m'\"\n  shows \"(s,s')\\<in>\\<langle>Rk\\<rangle>map2set_rel R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s, s') \\<in> \\<langle>Rk\\<rangle>map2set_rel R", "using assms"], ["proof (prove)\nusing this:\n  (s, m') \\<in> \\<langle>Rk, unit_rel\\<rangle>R\n  s' = dom m'\n\ngoal (1 subgoal):\n 1. (s, s') \\<in> \\<langle>Rk\\<rangle>map2set_rel R", "unfolding map2set_rel_def"], ["proof (prove)\nusing this:\n  (s, m') \\<in> \\<langle>Rk, unit_rel\\<rangle>R\n  s' = dom m'\n\ngoal (1 subgoal):\n 1. (s, s') \\<in> \\<langle>Rk, unit_rel\\<rangle>R O {(m, dom m) |m. True}", "by blast"], ["", "lemma map2set_relE:\n  assumes \"(s,s')\\<in>\\<langle>Rk\\<rangle>map2set_rel R\"\n  obtains m' where \"(s,m')\\<in>\\<langle>Rk,Id\\<rangle>R\" and \"s'=dom m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m'.\n        \\<lbrakk>(s, m') \\<in> \\<langle>Rk, unit_rel\\<rangle>R;\n         s' = dom m'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  (s, s') \\<in> \\<langle>Rk\\<rangle>map2set_rel R\n\ngoal (1 subgoal):\n 1. (\\<And>m'.\n        \\<lbrakk>(s, m') \\<in> \\<langle>Rk, unit_rel\\<rangle>R;\n         s' = dom m'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding map2set_rel_def"], ["proof (prove)\nusing this:\n  (s, s') \\<in> \\<langle>Rk, unit_rel\\<rangle>R O {(m, dom m) |m. True}\n\ngoal (1 subgoal):\n 1. (\\<And>m'.\n        \\<lbrakk>(s, m') \\<in> \\<langle>Rk, unit_rel\\<rangle>R;\n         s' = dom m'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["", "lemma map2set_rel_sv[relator_props]:\n  \"single_valued (\\<langle>Rk,Id\\<rangle>Rm) \\<Longrightarrow> single_valued (\\<langle>Rk\\<rangle>map2set_rel Rm)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued (\\<langle>Rk, unit_rel\\<rangle>Rm) \\<Longrightarrow>\n    single_valued (\\<langle>Rk\\<rangle>map2set_rel Rm)", "unfolding map2set_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued (\\<langle>Rk, unit_rel\\<rangle>Rm) \\<Longrightarrow>\n    single_valued (\\<langle>Rk, unit_rel\\<rangle>Rm O {(m, dom m) |m. True})", "by (auto intro: single_valuedI dest: single_valuedD)"], ["", "lemma map2set_empty[autoref_rules_raw]:\n  assumes \"PRIO_TAG_GEN_ALGO\"\n  assumes \"GEN_OP e op_map_empty (\\<langle>Rk,Id\\<rangle>R)\"\n  shows \"(e,{})\\<in>\\<langle>Rk\\<rangle>map2set_rel R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (e, {}) \\<in> \\<langle>Rk\\<rangle>map2set_rel R", "using assms"], ["proof (prove)\nusing this:\n  PRIO_TAG_GEN_ALGO\n  GEN_OP e op_map_empty (\\<langle>Rk, unit_rel\\<rangle>R)\n\ngoal (1 subgoal):\n 1. (e, {}) \\<in> \\<langle>Rk\\<rangle>map2set_rel R", "unfolding map2set_rel_def"], ["proof (prove)\nusing this:\n  PRIO_TAG_GEN_ALGO\n  GEN_OP e op_map_empty (\\<langle>Rk, unit_rel\\<rangle>R)\n\ngoal (1 subgoal):\n 1. (e, {}) \\<in> \\<langle>Rk, unit_rel\\<rangle>R O {(m, dom m) |m. True}", "by auto"], ["", "lemmas [autoref_rel_intf] = \n  REL_INTFI[of \"map2set_rel R\" i_set] for R"], ["", "definition \"map2set_insert i k s \\<equiv> i k () s\""], ["", "lemma map2set_insert[autoref_rules_raw]:\n  assumes \"PRIO_TAG_GEN_ALGO\"\n  assumes \"GEN_OP i op_map_update (Rk \\<rightarrow> Id \\<rightarrow> \\<langle>Rk,Id\\<rangle>R \\<rightarrow> \\<langle>Rk,Id\\<rangle>R)\"\n  shows \n    \"(map2set_insert i,Set.insert)\\<in>Rk\\<rightarrow>\\<langle>Rk\\<rangle>map2set_rel R \\<rightarrow> \\<langle>Rk\\<rangle>map2set_rel R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map2set_insert i, insert)\n    \\<in> Rk \\<rightarrow>\n          \\<langle>Rk\\<rangle>map2set_rel R \\<rightarrow>\n          \\<langle>Rk\\<rangle>map2set_rel R", "using assms"], ["proof (prove)\nusing this:\n  PRIO_TAG_GEN_ALGO\n  GEN_OP i op_map_update\n   (Rk \\<rightarrow>\n    unit_rel \\<rightarrow>\n    \\<langle>Rk, unit_rel\\<rangle>R \\<rightarrow> \\<langle>Rk,\n    unit_rel\\<rangle>R)\n\ngoal (1 subgoal):\n 1. (map2set_insert i, insert)\n    \\<in> Rk \\<rightarrow>\n          \\<langle>Rk\\<rangle>map2set_rel R \\<rightarrow>\n          \\<langle>Rk\\<rangle>map2set_rel R", "unfolding map2set_rel_def map2set_insert_def[abs_def]"], ["proof (prove)\nusing this:\n  PRIO_TAG_GEN_ALGO\n  GEN_OP i op_map_update\n   (Rk \\<rightarrow>\n    unit_rel \\<rightarrow>\n    \\<langle>Rk, unit_rel\\<rangle>R \\<rightarrow> \\<langle>Rk,\n    unit_rel\\<rangle>R)\n\ngoal (1 subgoal):\n 1. (\\<lambda>k. i k (), insert)\n    \\<in> Rk \\<rightarrow>\n          \\<langle>Rk, unit_rel\\<rangle>R O\n          {(m, dom m) |m. True} \\<rightarrow>\n          \\<langle>Rk, unit_rel\\<rangle>R O {(m, dom m) |m. True}", "by (force dest: fun_relD)"], ["", "definition \"map2set_memb l k s \\<equiv> case l k s of None \\<Rightarrow> False | Some _ \\<Rightarrow> True\""], ["", "lemma map2set_memb[autoref_rules_raw]:\n  assumes \"PRIO_TAG_GEN_ALGO\"\n  assumes \"GEN_OP l op_map_lookup (Rk \\<rightarrow> \\<langle>Rk,Id\\<rangle>R \\<rightarrow> \\<langle>Id\\<rangle>option_rel)\"\n  shows \"(map2set_memb l ,(\\<in>))\n    \\<in> Rk\\<rightarrow>\\<langle>Rk\\<rangle>map2set_rel R\\<rightarrow>Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map2set_memb l, (\\<in>))\n    \\<in> Rk \\<rightarrow>\n          \\<langle>Rk\\<rangle>map2set_rel R \\<rightarrow> bool_rel", "using assms"], ["proof (prove)\nusing this:\n  PRIO_TAG_GEN_ALGO\n  GEN_OP l op_map_lookup\n   (Rk \\<rightarrow>\n    \\<langle>Rk, unit_rel\\<rangle>R \\<rightarrow>\n    \\<langle>unit_rel\\<rangle>option_rel)\n\ngoal (1 subgoal):\n 1. (map2set_memb l, (\\<in>))\n    \\<in> Rk \\<rightarrow>\n          \\<langle>Rk\\<rangle>map2set_rel R \\<rightarrow> bool_rel", "unfolding map2set_rel_def map2set_memb_def[abs_def]"], ["proof (prove)\nusing this:\n  PRIO_TAG_GEN_ALGO\n  GEN_OP l op_map_lookup\n   (Rk \\<rightarrow>\n    \\<langle>Rk, unit_rel\\<rangle>R \\<rightarrow>\n    \\<langle>unit_rel\\<rangle>option_rel)\n\ngoal (1 subgoal):\n 1. (\\<lambda>k s.\n        case l k s of None \\<Rightarrow> False | Some x \\<Rightarrow> True,\n     (\\<in>))\n    \\<in> Rk \\<rightarrow>\n          \\<langle>Rk, unit_rel\\<rangle>R O\n          {(m, dom m) |m. True} \\<rightarrow>\n          bool_rel", "by (force dest: fun_relD split: option.splits)"], ["", "lemma map2set_delete[autoref_rules_raw]:\n  assumes \"PRIO_TAG_GEN_ALGO\"\n  assumes \"GEN_OP d op_map_delete (Rk\\<rightarrow>\\<langle>Rk,Id\\<rangle>R\\<rightarrow>\\<langle>Rk,Id\\<rangle>R)\"\n  shows \"(d,op_set_delete)\\<in>Rk\\<rightarrow>\\<langle>Rk\\<rangle>map2set_rel R\\<rightarrow>\\<langle>Rk\\<rangle>map2set_rel R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (d, op_set_delete)\n    \\<in> Rk \\<rightarrow>\n          \\<langle>Rk\\<rangle>map2set_rel R \\<rightarrow>\n          \\<langle>Rk\\<rangle>map2set_rel R", "using assms"], ["proof (prove)\nusing this:\n  PRIO_TAG_GEN_ALGO\n  GEN_OP d op_map_delete\n   (Rk \\<rightarrow>\n    \\<langle>Rk, unit_rel\\<rangle>R \\<rightarrow> \\<langle>Rk,\n    unit_rel\\<rangle>R)\n\ngoal (1 subgoal):\n 1. (d, op_set_delete)\n    \\<in> Rk \\<rightarrow>\n          \\<langle>Rk\\<rangle>map2set_rel R \\<rightarrow>\n          \\<langle>Rk\\<rangle>map2set_rel R", "unfolding map2set_rel_def"], ["proof (prove)\nusing this:\n  PRIO_TAG_GEN_ALGO\n  GEN_OP d op_map_delete\n   (Rk \\<rightarrow>\n    \\<langle>Rk, unit_rel\\<rangle>R \\<rightarrow> \\<langle>Rk,\n    unit_rel\\<rangle>R)\n\ngoal (1 subgoal):\n 1. (d, op_set_delete)\n    \\<in> Rk \\<rightarrow>\n          \\<langle>Rk, unit_rel\\<rangle>R O\n          {(m, dom m) |m. True} \\<rightarrow>\n          \\<langle>Rk, unit_rel\\<rangle>R O {(m, dom m) |m. True}", "by (force dest: fun_relD)"], ["", "lemma map2set_to_sorted_list[autoref_ga_rules]:\n  fixes it :: \"'m \\<Rightarrow> ('k\\<times>unit) list\"\n  assumes A: \"GEN_ALGO_tag (is_map_to_sorted_list ordR Rk Id R it)\"\n  shows \"is_set_to_sorted_list ordR Rk (map2set_rel R) \n    (it_to_list (map_iterator_dom o (foldli o it)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_set_to_sorted_list ordR Rk (map2set_rel R)\n     (it_to_list\n       ((map_iterator_dom \\<circ>\\<circ>\\<circ> (\\<circ>)) foldli it))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_set_to_sorted_list ordR Rk (map2set_rel R)\n     (it_to_list\n       ((map_iterator_dom \\<circ>\\<circ>\\<circ> (\\<circ>)) foldli it))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. is_set_to_sorted_list ordR Rk (map2set_rel R)\n     (it_to_list\n       ((map_iterator_dom \\<circ>\\<circ>\\<circ> (\\<circ>)) foldli it))", "fix l::\"('k\\<times>unit) list\""], ["proof (state)\ngoal (1 subgoal):\n 1. is_set_to_sorted_list ordR Rk (map2set_rel R)\n     (it_to_list\n       ((map_iterator_dom \\<circ>\\<circ>\\<circ> (\\<circ>)) foldli it))", "have \"\\<And>l0. foldli l (\\<lambda>_. True) (\\<lambda>x \\<sigma>. \\<sigma> @ [fst x]) l0 = l0@map fst l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l0.\n       foldli l (\\<lambda>_. True) (\\<lambda>x \\<sigma>. \\<sigma> @ [fst x])\n        l0 =\n       l0 @ map fst l", "by (induct l) auto"], ["proof (state)\nthis:\n  foldli l (\\<lambda>_. True) (\\<lambda>x \\<sigma>. \\<sigma> @ [fst x])\n   ?l0.0 =\n  ?l0.0 @ map fst l\n\ngoal (1 subgoal):\n 1. is_set_to_sorted_list ordR Rk (map2set_rel R)\n     (it_to_list\n       ((map_iterator_dom \\<circ>\\<circ>\\<circ> (\\<circ>)) foldli it))", "}"], ["proof (state)\nthis:\n  foldli ?l3 (\\<lambda>_. True) (\\<lambda>x \\<sigma>. \\<sigma> @ [fst x])\n   ?l0.0 =\n  ?l0.0 @ map fst ?l3\n\ngoal (1 subgoal):\n 1. is_set_to_sorted_list ordR Rk (map2set_rel R)\n     (it_to_list\n       ((map_iterator_dom \\<circ>\\<circ>\\<circ> (\\<circ>)) foldli it))", "hence S: \"it_to_list (map_iterator_dom o (foldli o it)) = map fst o it\""], ["proof (prove)\nusing this:\n  foldli ?l3 (\\<lambda>_. True) (\\<lambda>x \\<sigma>. \\<sigma> @ [fst x])\n   ?l0.0 =\n  ?l0.0 @ map fst ?l3\n\ngoal (1 subgoal):\n 1. it_to_list\n     ((map_iterator_dom \\<circ>\\<circ>\\<circ> (\\<circ>)) foldli it) =\n    map fst \\<circ> it", "unfolding it_to_list_def[abs_def] map_iterator_dom_def[abs_def]\n      set_iterator_image_def set_iterator_image_filter_def"], ["proof (prove)\nusing this:\n  foldli ?l3 (\\<lambda>_. True) (\\<lambda>x \\<sigma>. \\<sigma> @ [fst x])\n   ?l0.0 =\n  ?l0.0 @ map fst ?l3\n\ngoal (1 subgoal):\n 1. (\\<lambda>s.\n        ((\\<lambda>it c f.\n             it c\n              (\\<lambda>x \\<sigma>.\n                  case Some (fst x) of None \\<Rightarrow> \\<sigma>\n                  | Some x' \\<Rightarrow>\n                      f x' \\<sigma>)) \\<circ>\\<circ>\\<circ>\n         (\\<circ>))\n         foldli it s (\\<lambda>_. True) (\\<lambda>x l. l @ [x]) []) =\n    map fst \\<circ> it", "by (auto)"], ["proof (state)\nthis:\n  it_to_list\n   ((map_iterator_dom \\<circ>\\<circ>\\<circ> (\\<circ>)) foldli it) =\n  map fst \\<circ> it\n\ngoal (1 subgoal):\n 1. is_set_to_sorted_list ordR Rk (map2set_rel R)\n     (it_to_list\n       ((map_iterator_dom \\<circ>\\<circ>\\<circ> (\\<circ>)) foldli it))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_set_to_sorted_list ordR Rk (map2set_rel R)\n     (it_to_list\n       ((map_iterator_dom \\<circ>\\<circ>\\<circ> (\\<circ>)) foldli it))", "unfolding S"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_set_to_sorted_list ordR Rk (map2set_rel R) (map fst \\<circ> it)", "using assms"], ["proof (prove)\nusing this:\n  GEN_ALGO_tag (is_map_to_sorted_list ordR Rk unit_rel R it)\n\ngoal (1 subgoal):\n 1. is_set_to_sorted_list ordR Rk (map2set_rel R) (map fst \\<circ> it)", "unfolding is_map_to_sorted_list_def is_set_to_sorted_list_def"], ["proof (prove)\nusing this:\n  GEN_ALGO_tag\n   (\\<forall>m m'.\n       (m, m') \\<in> \\<langle>Rk, unit_rel\\<rangle>R \\<longrightarrow>\n       (\\<exists>l'.\n           (it m, l')\n           \\<in> \\<langle>Rk \\<times>\\<^sub>r\n                          unit_rel\\<rangle>list_rel \\<and>\n           RETURN l'\n           \\<le> it_to_sorted_list (key_rel ordR) (map_to_set m')))\n\ngoal (1 subgoal):\n 1. \\<forall>s s'.\n       (s, s') \\<in> \\<langle>Rk\\<rangle>map2set_rel R \\<longrightarrow>\n       (\\<exists>l'.\n           ((map fst \\<circ> it) s, l')\n           \\<in> \\<langle>Rk\\<rangle>list_rel \\<and>\n           RETURN l' \\<le> it_to_sorted_list ordR s')", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>\\<forall>m m'.\n                   (m, m') \\<in> \\<langle>Rk,\n                   unit_rel\\<rangle>R \\<longrightarrow>\n                   (\\<exists>l'.\n                       (it m, l')\n                       \\<in> \\<langle>Rk \\<times>\\<^sub>r\nunit_rel\\<rangle>list_rel \\<and>\n                       RETURN l'\n                       \\<le> it_to_sorted_list (key_rel ordR)\n                              (map_to_set m'));\n        (s, s') \\<in> \\<langle>Rk\\<rangle>map2set_rel R\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            (map fst (it s), l')\n                            \\<in> \\<langle>Rk\\<rangle>list_rel \\<and>\n                            RETURN l' \\<le> it_to_sorted_list ordR s'", "apply (erule map2set_relE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s' m'.\n       \\<lbrakk>\\<forall>m m'.\n                   (m, m') \\<in> \\<langle>Rk,\n                   unit_rel\\<rangle>R \\<longrightarrow>\n                   (\\<exists>l'.\n                       (it m, l')\n                       \\<in> \\<langle>Rk \\<times>\\<^sub>r\nunit_rel\\<rangle>list_rel \\<and>\n                       RETURN l'\n                       \\<le> it_to_sorted_list (key_rel ordR)\n                              (map_to_set m'));\n        (s, m') \\<in> \\<langle>Rk, unit_rel\\<rangle>R; s' = dom m'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            (map fst (it s), l')\n                            \\<in> \\<langle>Rk\\<rangle>list_rel \\<and>\n                            RETURN l' \\<le> it_to_sorted_list ordR s'", "apply (drule spec, drule spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s' m'.\n       \\<lbrakk>(s, m') \\<in> \\<langle>Rk, unit_rel\\<rangle>R; s' = dom m';\n        (?m8 s s' m', ?m'10 s s' m') \\<in> \\<langle>Rk,\n        unit_rel\\<rangle>R \\<longrightarrow>\n        (\\<exists>l'.\n            (it (?m8 s s' m'), l')\n            \\<in> \\<langle>Rk \\<times>\\<^sub>r\n                           unit_rel\\<rangle>list_rel \\<and>\n            RETURN l'\n            \\<le> it_to_sorted_list (key_rel ordR)\n                   (map_to_set (?m'10 s s' m')))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            (map fst (it s), l')\n                            \\<in> \\<langle>Rk\\<rangle>list_rel \\<and>\n                            RETURN l' \\<le> it_to_sorted_list ordR s'", "apply (drule (1) mp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s' m'.\n       \\<lbrakk>(s, m') \\<in> \\<langle>Rk, unit_rel\\<rangle>R; s' = dom m';\n        \\<exists>l'.\n           (it s, l')\n           \\<in> \\<langle>Rk \\<times>\\<^sub>r\n                          unit_rel\\<rangle>list_rel \\<and>\n           RETURN l'\n           \\<le> it_to_sorted_list (key_rel ordR) (map_to_set m')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            (map fst (it s), l')\n                            \\<in> \\<langle>Rk\\<rangle>list_rel \\<and>\n                            RETURN l' \\<le> it_to_sorted_list ordR s'", "apply (elim exE conjE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s' m' l'.\n       \\<lbrakk>(s, m') \\<in> \\<langle>Rk, unit_rel\\<rangle>R; s' = dom m';\n        (it s, l')\n        \\<in> \\<langle>Rk \\<times>\\<^sub>r unit_rel\\<rangle>list_rel;\n        RETURN l'\n        \\<le> it_to_sorted_list (key_rel ordR) (map_to_set m')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            (map fst (it s), l')\n                            \\<in> \\<langle>Rk\\<rangle>list_rel \\<and>\n                            RETURN l' \\<le> it_to_sorted_list ordR s'", "apply (rule_tac x=\"map fst l'\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s' m' l'.\n       \\<lbrakk>(s, m') \\<in> \\<langle>Rk, unit_rel\\<rangle>R; s' = dom m';\n        (it s, l')\n        \\<in> \\<langle>Rk \\<times>\\<^sub>r unit_rel\\<rangle>list_rel;\n        RETURN l'\n        \\<le> it_to_sorted_list (key_rel ordR) (map_to_set m')\\<rbrakk>\n       \\<Longrightarrow> (map fst (it s), map fst l')\n                         \\<in> \\<langle>Rk\\<rangle>list_rel \\<and>\n                         RETURN (map fst l') \\<le> it_to_sorted_list ordR s'", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s' m' l'.\n       \\<lbrakk>(s, m') \\<in> \\<langle>Rk, unit_rel\\<rangle>R; s' = dom m';\n        (it s, l')\n        \\<in> \\<langle>Rk \\<times>\\<^sub>r unit_rel\\<rangle>list_rel;\n        RETURN l'\n        \\<le> it_to_sorted_list (key_rel ordR) (map_to_set m')\\<rbrakk>\n       \\<Longrightarrow> (map fst (it s), map fst l')\n                         \\<in> \\<langle>Rk\\<rangle>list_rel\n 2. \\<And>s s' m' l'.\n       \\<lbrakk>(s, m') \\<in> \\<langle>Rk, unit_rel\\<rangle>R; s' = dom m';\n        (it s, l')\n        \\<in> \\<langle>Rk \\<times>\\<^sub>r unit_rel\\<rangle>list_rel;\n        RETURN l'\n        \\<le> it_to_sorted_list (key_rel ordR) (map_to_set m')\\<rbrakk>\n       \\<Longrightarrow> RETURN (map fst l') \\<le> it_to_sorted_list ordR s'", "apply parametricity"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s' m' l'.\n       \\<lbrakk>(s, m') \\<in> \\<langle>Rk, unit_rel\\<rangle>R; s' = dom m';\n        (it s, l')\n        \\<in> \\<langle>Rk \\<times>\\<^sub>r unit_rel\\<rangle>list_rel;\n        RETURN l'\n        \\<le> it_to_sorted_list (key_rel ordR) (map_to_set m')\\<rbrakk>\n       \\<Longrightarrow> RETURN (map fst l') \\<le> it_to_sorted_list ordR s'", "unfolding it_to_sorted_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s' m' l'.\n       \\<lbrakk>(s, m') \\<in> \\<langle>Rk, unit_rel\\<rangle>R; s' = dom m';\n        (it s, l')\n        \\<in> \\<langle>Rk \\<times>\\<^sub>r unit_rel\\<rangle>list_rel;\n        RETURN l'\n        \\<le> SPEC\n               (\\<lambda>l.\n                   distinct l \\<and>\n                   map_to_set m' = set l \\<and>\n                   sorted_wrt (key_rel ordR) l)\\<rbrakk>\n       \\<Longrightarrow> RETURN (map fst l')\n                         \\<le> SPEC\n                                (\\<lambda>l.\n                                    distinct l \\<and>\n                                    s' = set l \\<and> sorted_wrt ordR l)", "apply (simp add: map_to_set_dom)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s' m' l'.\n       \\<lbrakk>(s, m') \\<in> \\<langle>Rk, unit_rel\\<rangle>R;\n        s' = fst ` set l';\n        (it s, l')\n        \\<in> \\<langle>Rk \\<times>\\<^sub>r unit_rel\\<rangle>list_rel;\n        distinct l' \\<and>\n        map_to_set m' = set l' \\<and> sorted_wrt (key_rel ordR) l'\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt ordR (map fst l')", "apply (simp add: sorted_wrt_map key_rel_def[abs_def])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  is_set_to_sorted_list ordR Rk (map2set_rel R)\n   (it_to_list\n     ((map_iterator_dom \\<circ>\\<circ>\\<circ> (\\<circ>)) foldli it))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map2set_to_list[autoref_ga_rules]:\n  fixes it :: \"'m \\<Rightarrow> ('k\\<times>unit) list\"\n  assumes A: \"GEN_ALGO_tag (is_map_to_list Rk Id R it)\"\n  shows \"is_set_to_list Rk (map2set_rel R) \n    (it_to_list (map_iterator_dom o (foldli o it)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_set_to_list Rk (map2set_rel R)\n     (it_to_list\n       ((map_iterator_dom \\<circ>\\<circ>\\<circ> (\\<circ>)) foldli it))", "using assms"], ["proof (prove)\nusing this:\n  GEN_ALGO_tag (is_map_to_list Rk unit_rel R it)\n\ngoal (1 subgoal):\n 1. is_set_to_list Rk (map2set_rel R)\n     (it_to_list\n       ((map_iterator_dom \\<circ>\\<circ>\\<circ> (\\<circ>)) foldli it))", "unfolding is_set_to_list_def is_map_to_list_def"], ["proof (prove)\nusing this:\n  GEN_ALGO_tag (is_map_to_sorted_list (\\<lambda>_ _. True) Rk unit_rel R it)\n\ngoal (1 subgoal):\n 1. is_set_to_sorted_list (\\<lambda>_ _. True) Rk (map2set_rel R)\n     (it_to_list\n       ((map_iterator_dom \\<circ>\\<circ>\\<circ> (\\<circ>)) foldli it))", "by (rule map2set_to_sorted_list)"], ["", "(*lemma map2set_it_simp[iterator_simps]:\n  \"foldli ((map fst o it) x) c f s = foldli (it x) c (\\<lambda>(k,v) s. f k s) s\" \n  by (simp add: foldli_map comp_def fn_fst_conv)\n*)"], ["", "text \\<open>Transfering also non-basic operations results in specializations\n  of map-algorithms to also be used for sets\\<close>"], ["", "lemma map2set_union[autoref_rules_raw]:\n  assumes \"MINOR_PRIO_TAG (- 9)\"\n  assumes \"GEN_OP u (++) (\\<langle>Rk,Id\\<rangle>R\\<rightarrow>\\<langle>Rk,Id\\<rangle>R\\<rightarrow>\\<langle>Rk,Id\\<rangle>R)\"\n  shows \"(u,(\\<union>))\\<in>\\<langle>Rk\\<rangle>map2set_rel R\\<rightarrow>\\<langle>Rk\\<rangle>map2set_rel R\\<rightarrow>\\<langle>Rk\\<rangle>map2set_rel R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, (\\<union>))\n    \\<in> \\<langle>Rk\\<rangle>map2set_rel R \\<rightarrow>\n          \\<langle>Rk\\<rangle>map2set_rel R \\<rightarrow>\n          \\<langle>Rk\\<rangle>map2set_rel R", "using assms"], ["proof (prove)\nusing this:\n  MINOR_PRIO_TAG (- 9)\n  GEN_OP u (++)\n   (\\<langle>Rk, unit_rel\\<rangle>R \\<rightarrow>\n    \\<langle>Rk, unit_rel\\<rangle>R \\<rightarrow> \\<langle>Rk,\n    unit_rel\\<rangle>R)\n\ngoal (1 subgoal):\n 1. (u, (\\<union>))\n    \\<in> \\<langle>Rk\\<rangle>map2set_rel R \\<rightarrow>\n          \\<langle>Rk\\<rangle>map2set_rel R \\<rightarrow>\n          \\<langle>Rk\\<rangle>map2set_rel R", "unfolding map2set_rel_def"], ["proof (prove)\nusing this:\n  MINOR_PRIO_TAG (- 9)\n  GEN_OP u (++)\n   (\\<langle>Rk, unit_rel\\<rangle>R \\<rightarrow>\n    \\<langle>Rk, unit_rel\\<rangle>R \\<rightarrow> \\<langle>Rk,\n    unit_rel\\<rangle>R)\n\ngoal (1 subgoal):\n 1. (u, (\\<union>))\n    \\<in> \\<langle>Rk, unit_rel\\<rangle>R O\n          {(m, dom m) |m. True} \\<rightarrow>\n          \\<langle>Rk, unit_rel\\<rangle>R O\n          {(m, dom m) |m. True} \\<rightarrow>\n          \\<langle>Rk, unit_rel\\<rangle>R O {(m, dom m) |m. True}", "by (force dest: fun_relD)"], ["", "lemmas [autoref_ga_rules] = cmp_unit_eq_linorder"], ["", "lemmas [autoref_rules_raw] = param_cmp_unit"], ["", "lemma cmp_lex_zip_unit[simp]:\n  \"cmp_lex (cmp_prod cmp cmp_unit) (map (\\<lambda>k. (k, ())) l)\n           (map (\\<lambda>k. (k, ())) m) =\n          cmp_lex cmp l m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmp_lex (cmp_prod cmp cmp_unit) (map (\\<lambda>k. (k, ())) l)\n     (map (\\<lambda>k. (k, ())) m) =\n    cmp_lex cmp l m", "apply (induct cmp l m rule: cmp_lex.induct)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>cmp.\n       cmp_lex (cmp_prod cmp cmp_unit) (map (\\<lambda>k. (k, ())) [])\n        (map (\\<lambda>k. (k, ())) []) =\n       cmp_lex cmp [] []\n 2. \\<And>cmp v va.\n       cmp_lex (cmp_prod cmp cmp_unit) (map (\\<lambda>k. (k, ())) [])\n        (map (\\<lambda>k. (k, ())) (v # va)) =\n       cmp_lex cmp [] (v # va)\n 3. \\<And>cmp v va.\n       cmp_lex (cmp_prod cmp cmp_unit) (map (\\<lambda>k. (k, ())) (v # va))\n        (map (\\<lambda>k. (k, ())) []) =\n       cmp_lex cmp (v # va) []\n 4. \\<And>cmp a l b m.\n       (cmp a b = EQUAL \\<Longrightarrow>\n        cmp_lex (cmp_prod cmp cmp_unit) (map (\\<lambda>k. (k, ())) l)\n         (map (\\<lambda>k. (k, ())) m) =\n        cmp_lex cmp l m) \\<Longrightarrow>\n       cmp_lex (cmp_prod cmp cmp_unit) (map (\\<lambda>k. (k, ())) (a # l))\n        (map (\\<lambda>k. (k, ())) (b # m)) =\n       cmp_lex cmp (a # l) (b # m)", "apply (auto split: comp_res.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma cmp_img_zip_unit[simp]:\n  \"cmp_img (\\<lambda>m. map (\\<lambda>k. (k,())) (f m)) (cmp_lex (cmp_prod cmp1 cmp_unit))\n    = cmp_img f (cmp_lex cmp1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmp_img (\\<lambda>m. map (\\<lambda>k. (k, ())) (f m))\n     (cmp_lex (cmp_prod cmp1 cmp_unit)) =\n    cmp_img f (cmp_lex cmp1)", "unfolding cmp_img_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>a b.\n        cmp_lex (cmp_prod cmp1 cmp_unit) (map (\\<lambda>k. (k, ())) (f a))\n         (map (\\<lambda>k. (k, ())) (f b))) =\n    (\\<lambda>a b. cmp_lex cmp1 (f a) (f b))", "apply (intro ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       cmp_lex (cmp_prod cmp1 cmp_unit) (map (\\<lambda>k. (k, ())) (f a))\n        (map (\\<lambda>k. (k, ())) (f b)) =\n       cmp_lex cmp1 (f a) (f b)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(* TODO: Move *)"], ["", "lemma map2set_finite[relator_props]:\n  assumes \"finite_map_rel (\\<langle>Rk,Id\\<rangle>R)\"\n  shows \"finite_set_rel (\\<langle>Rk\\<rangle>map2set_rel R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_set_rel (\\<langle>Rk\\<rangle>map2set_rel R)", "using assms"], ["proof (prove)\nusing this:\n  finite_map_rel (\\<langle>Rk, unit_rel\\<rangle>R)\n\ngoal (1 subgoal):\n 1. finite_set_rel (\\<langle>Rk\\<rangle>map2set_rel R)", "unfolding map2set_rel_def finite_set_rel_def finite_map_rel_def"], ["proof (prove)\nusing this:\n  Range (\\<langle>Rk, unit_rel\\<rangle>R)\n  \\<subseteq> Collect (finite \\<circ> dom)\n\ngoal (1 subgoal):\n 1. Range (\\<langle>Rk, unit_rel\\<rangle>R O {(m, dom m) |m. True})\n    \\<subseteq> Collect finite", "by auto"], ["", "lemma map2set_cmp[autoref_rules_raw]:\n  assumes ELO: \"SIDE_GEN_ALGO (eq_linorder cmpk)\"\n  assumes MPAR:\n    \"GEN_OP cmp (cmp_map cmpk cmp_unit) (\\<langle>Rk,Id\\<rangle>R \\<rightarrow> \\<langle>Rk,Id\\<rangle>R \\<rightarrow> Id)\"\n  assumes FIN: \"PREFER finite_map_rel (\\<langle>Rk, Id\\<rangle>R)\"\n  shows \"(cmp,cmp_set cmpk)\\<in>\\<langle>Rk\\<rangle>map2set_rel R \\<rightarrow> \\<langle>Rk\\<rangle>map2set_rel R \\<rightarrow> Id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cmp, cmp_set cmpk)\n    \\<in> \\<langle>Rk\\<rangle>map2set_rel R \\<rightarrow>\n          \\<langle>Rk\\<rangle>map2set_rel R \\<rightarrow> comp_res_rel", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (cmp, cmp_set cmpk)\n    \\<in> \\<langle>Rk\\<rangle>map2set_rel R \\<rightarrow>\n          \\<langle>Rk\\<rangle>map2set_rel R \\<rightarrow> comp_res_rel", "interpret linorder \"comp2le cmpk\" \"comp2lt cmpk\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.linorder (comp2le cmpk) (comp2lt cmpk)", "using ELO"], ["proof (prove)\nusing this:\n  SIDE_GEN_ALGO (eq_linorder cmpk)\n\ngoal (1 subgoal):\n 1. class.linorder (comp2le cmpk) (comp2lt cmpk)", "by (simp add: eq_linorder_class_conv)"], ["proof (state)\ngoal (1 subgoal):\n 1. (cmp, cmp_set cmpk)\n    \\<in> \\<langle>Rk\\<rangle>map2set_rel R \\<rightarrow>\n          \\<langle>Rk\\<rangle>map2set_rel R \\<rightarrow> comp_res_rel", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cmp, cmp_set cmpk)\n    \\<in> \\<langle>Rk\\<rangle>map2set_rel R \\<rightarrow>\n          \\<langle>Rk\\<rangle>map2set_rel R \\<rightarrow> comp_res_rel", "using MPAR"], ["proof (prove)\nusing this:\n  GEN_OP cmp (cmp_map cmpk cmp_unit)\n   (\\<langle>Rk, unit_rel\\<rangle>R \\<rightarrow>\n    \\<langle>Rk, unit_rel\\<rangle>R \\<rightarrow> comp_res_rel)\n\ngoal (1 subgoal):\n 1. (cmp, cmp_set cmpk)\n    \\<in> \\<langle>Rk\\<rangle>map2set_rel R \\<rightarrow>\n          \\<langle>Rk\\<rangle>map2set_rel R \\<rightarrow> comp_res_rel", "unfolding cmp_map_def cmp_set_def"], ["proof (prove)\nusing this:\n  GEN_OP cmp\n   (cmp_extend (Collect (finite \\<circ> dom))\n     (cmp_img local.sorted_list_of_map (cmp_lex (cmp_prod cmpk cmp_unit))))\n   (\\<langle>Rk, unit_rel\\<rangle>R \\<rightarrow>\n    \\<langle>Rk, unit_rel\\<rangle>R \\<rightarrow> comp_res_rel)\n\ngoal (1 subgoal):\n 1. (cmp,\n     cmp_extend (Collect finite)\n      (cmp_img local.sorted_list_of_set (cmp_lex cmpk)))\n    \\<in> \\<langle>Rk\\<rangle>map2set_rel R \\<rightarrow>\n          \\<langle>Rk\\<rangle>map2set_rel R \\<rightarrow> comp_res_rel", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cmp,\n     cmp_extend (Collect (finite \\<circ> dom))\n      (cmp_img local.sorted_list_of_map (cmp_lex (cmp_prod cmpk cmp_unit))))\n    \\<in> \\<langle>Rk, unit_rel\\<rangle>R \\<rightarrow>\n          \\<langle>Rk, unit_rel\\<rangle>R \\<rightarrow>\n          comp_res_rel \\<Longrightarrow>\n    (cmp,\n     cmp_extend (Collect finite)\n      (cmp_img local.sorted_list_of_set (cmp_lex cmpk)))\n    \\<in> \\<langle>Rk\\<rangle>map2set_rel R \\<rightarrow>\n          \\<langle>Rk\\<rangle>map2set_rel R \\<rightarrow> comp_res_rel", "apply parametricity"], ["proof (prove)\ngoal (2 subgoals):\n 1. (cmp,\n     cmp_extend (Collect (finite \\<circ> dom))\n      (cmp_img local.sorted_list_of_map (cmp_lex (cmp_prod cmpk cmp_unit))))\n    \\<in> \\<langle>Rk, unit_rel\\<rangle>R \\<rightarrow>\n          \\<langle>Rk, unit_rel\\<rangle>R \\<rightarrow>\n          comp_res_rel \\<Longrightarrow>\n    (cmp, cmp_img local.sorted_list_of_set (cmp_lex cmpk))\n    \\<in> \\<langle>Rk\\<rangle>map2set_rel R \\<rightarrow>\n          \\<langle>Rk\\<rangle>map2set_rel R \\<rightarrow> comp_res_rel\n 2. (cmp,\n     cmp_extend (Collect (finite \\<circ> dom))\n      (cmp_img local.sorted_list_of_map (cmp_lex (cmp_prod cmpk cmp_unit))))\n    \\<in> \\<langle>Rk, unit_rel\\<rangle>R \\<rightarrow>\n          \\<langle>Rk, unit_rel\\<rangle>R \\<rightarrow>\n          comp_res_rel \\<Longrightarrow>\n    Range (\\<langle>Rk\\<rangle>map2set_rel R) \\<subseteq> Collect finite", "apply (drule cmp_extend_paramD)"], ["proof (prove)\ngoal (3 subgoals):\n 1. Range (\\<langle>Rk, unit_rel\\<rangle>R)\n    \\<subseteq> Collect (finite \\<circ> dom)\n 2. (cmp,\n     cmp_img local.sorted_list_of_map (cmp_lex (cmp_prod cmpk cmp_unit)))\n    \\<in> \\<langle>Rk, unit_rel\\<rangle>R \\<rightarrow>\n          \\<langle>Rk, unit_rel\\<rangle>R \\<rightarrow>\n          comp_res_rel \\<Longrightarrow>\n    (cmp, cmp_img local.sorted_list_of_set (cmp_lex cmpk))\n    \\<in> \\<langle>Rk\\<rangle>map2set_rel R \\<rightarrow>\n          \\<langle>Rk\\<rangle>map2set_rel R \\<rightarrow> comp_res_rel\n 3. (cmp,\n     cmp_extend (Collect (finite \\<circ> dom))\n      (cmp_img local.sorted_list_of_map (cmp_lex (cmp_prod cmpk cmp_unit))))\n    \\<in> \\<langle>Rk, unit_rel\\<rangle>R \\<rightarrow>\n          \\<langle>Rk, unit_rel\\<rangle>R \\<rightarrow>\n          comp_res_rel \\<Longrightarrow>\n    Range (\\<langle>Rk\\<rangle>map2set_rel R) \\<subseteq> Collect finite", "apply (insert FIN, fastforce simp add: finite_map_rel_def) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. (cmp,\n     cmp_img local.sorted_list_of_map (cmp_lex (cmp_prod cmpk cmp_unit)))\n    \\<in> \\<langle>Rk, unit_rel\\<rangle>R \\<rightarrow>\n          \\<langle>Rk, unit_rel\\<rangle>R \\<rightarrow>\n          comp_res_rel \\<Longrightarrow>\n    (cmp, cmp_img local.sorted_list_of_set (cmp_lex cmpk))\n    \\<in> \\<langle>Rk\\<rangle>map2set_rel R \\<rightarrow>\n          \\<langle>Rk\\<rangle>map2set_rel R \\<rightarrow> comp_res_rel\n 2. (cmp,\n     cmp_extend (Collect (finite \\<circ> dom))\n      (cmp_img local.sorted_list_of_map (cmp_lex (cmp_prod cmpk cmp_unit))))\n    \\<in> \\<langle>Rk, unit_rel\\<rangle>R \\<rightarrow>\n          \\<langle>Rk, unit_rel\\<rangle>R \\<rightarrow>\n          comp_res_rel \\<Longrightarrow>\n    Range (\\<langle>Rk\\<rangle>map2set_rel R) \\<subseteq> Collect finite", "apply (simp add: sorted_list_of_map_def[abs_def])"], ["proof (prove)\ngoal (2 subgoals):\n 1. (cmp,\n     cmp_img (\\<lambda>m. local.sorted_list_of_set (dom m)) (cmp_lex cmpk))\n    \\<in> \\<langle>Rk, unit_rel\\<rangle>R \\<rightarrow>\n          \\<langle>Rk, unit_rel\\<rangle>R \\<rightarrow>\n          comp_res_rel \\<Longrightarrow>\n    (cmp, cmp_img local.sorted_list_of_set (cmp_lex cmpk))\n    \\<in> \\<langle>Rk\\<rangle>map2set_rel R \\<rightarrow>\n          \\<langle>Rk\\<rangle>map2set_rel R \\<rightarrow> comp_res_rel\n 2. (cmp,\n     cmp_extend (Collect (finite \\<circ> dom))\n      (cmp_img local.sorted_list_of_map (cmp_lex (cmp_prod cmpk cmp_unit))))\n    \\<in> \\<langle>Rk, unit_rel\\<rangle>R \\<rightarrow>\n          \\<langle>Rk, unit_rel\\<rangle>R \\<rightarrow>\n          comp_res_rel \\<Longrightarrow>\n    Range (\\<langle>Rk\\<rangle>map2set_rel R) \\<subseteq> Collect finite", "apply (auto simp: map2set_rel_def cmp_img_def[abs_def] dest: fun_relD) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cmp,\n     cmp_extend (Collect (finite \\<circ> dom))\n      (cmp_img local.sorted_list_of_map (cmp_lex (cmp_prod cmpk cmp_unit))))\n    \\<in> \\<langle>Rk, unit_rel\\<rangle>R \\<rightarrow>\n          \\<langle>Rk, unit_rel\\<rangle>R \\<rightarrow>\n          comp_res_rel \\<Longrightarrow>\n    Range (\\<langle>Rk\\<rangle>map2set_rel R) \\<subseteq> Collect finite", "apply (insert map2set_finite[OF FIN[unfolded autoref_tag_defs]],\n      fastforce simp add: finite_set_rel_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (cmp, cmp_set cmpk)\n  \\<in> \\<langle>Rk\\<rangle>map2set_rel R \\<rightarrow>\n        \\<langle>Rk\\<rangle>map2set_rel R \\<rightarrow> comp_res_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}