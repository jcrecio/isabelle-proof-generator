{"file_name": "/home/qj213/afp-2021-10-22/thys/Collections/Iterator/Gen_Iterator.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Collections", "problem_names": ["lemma param_it_to_list[param]: \"(it_to_list,it_to_list) \\<in>\n    (Rs \\<rightarrow> (Ra \\<rightarrow> bool_rel) \\<rightarrow> \n    (Rb \\<rightarrow> \\<langle>Rb\\<rangle>list_rel \\<rightarrow> \\<langle>Rb\\<rangle>list_rel) \\<rightarrow> \\<langle>Rc\\<rangle>list_rel \\<rightarrow> Rd) \\<rightarrow> Rs \\<rightarrow> Rd\"", "lemma key_rel_UNIV[simp]: \"key_rel (\\<lambda>_ _. True) = (\\<lambda>_ _. True)\"", "lemma set_to_sorted_list_itype[autoref_itype]: \n    \"set_to_sorted_list R ::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i \\<langle>\\<langle>I\\<rangle>\\<^sub>ii_list\\<rangle>\\<^sub>ii_nres\"", "lemma set_to_sorted_list_pat[autoref_op_pat]: \n    \"it_to_sorted_list R S \\<equiv> OP (set_to_sorted_list R) S\"", "lemma map_to_sorted_list_itype[autoref_itype]:\n    \"map_to_sorted_list R ::\\<^sub>i \\<langle>Rk,Rv\\<rangle>\\<^sub>ii_map \\<rightarrow>\\<^sub>i \\<langle>\\<langle>\\<langle>Rk,Rv\\<rangle>\\<^sub>ii_prod\\<rangle>\\<^sub>ii_list\\<rangle>\\<^sub>ii_nres\"", "lemma map_to_sorted_list_pat[autoref_op_pat]:\n    \"it_to_sorted_list (key_rel R) (map_to_set M) \n      \\<equiv> OP (map_to_sorted_list R) M\"\n    \"it_to_sorted_list (\\<lambda>_ _. True) (map_to_set M) \n      \\<equiv> OP (map_to_sorted_list (\\<lambda>_ _. True)) M\"", "lemma is_set_to_sorted_listE:\n    assumes \"is_set_to_sorted_list ordR Rk Rs tsl\"\n    assumes \"(s,s')\\<in>\\<langle>Rk\\<rangle>Rs\"\n    obtains l' where \"(tsl s,l')\\<in>\\<langle>Rk\\<rangle>list_rel\" \n    and \"RETURN l' \\<le> it_to_sorted_list ordR s'\"", "lemma it_to_sorted_list_weaken: \n    \"R\\<le>R' \\<Longrightarrow> it_to_sorted_list R s \\<le> it_to_sorted_list R' s\"", "lemma set_to_list_by_set_to_sorted_list[autoref_ga_rules]:\n    assumes \"GEN_ALGO_tag (is_set_to_sorted_list ordR Rk Rs tsl)\"\n    shows \"is_set_to_list Rk Rs tsl\"", "lemma det_fold_setI[intro?]:\n    assumes \"\\<And>l. \\<lbrakk>distinct l; sorted_wrt R l\\<rbrakk> \n      \\<Longrightarrow> foldli l c f \\<sigma> = result (set l)\"\n    shows \"det_fold_set R c f \\<sigma> result\"", "lemma det_fold_sorted_set:\n    assumes 1: \"det_fold_set ordR c' f' \\<sigma>' result\"\n    assumes 2: \"is_set_to_sorted_list ordR Rk Rs tsl\"\n    assumes SREF[param]: \"(s,s')\\<in>\\<langle>Rk\\<rangle>Rs\"\n    assumes [param]:  \"(c,c')\\<in>R\\<sigma>\\<rightarrow>Id\"\n    assumes [param]: \"(f,f')\\<in>Rk \\<rightarrow> R\\<sigma> \\<rightarrow> R\\<sigma>\"\n    assumes [param]: \"(\\<sigma>,\\<sigma>')\\<in>R\\<sigma>\"\n    shows \"(foldli (tsl s) c f \\<sigma>, result s') \\<in> R\\<sigma>\"", "lemma det_fold_set:\n    assumes \"det_fold_set (\\<lambda>_ _. True) c' f' \\<sigma>' result\"\n    assumes \"is_set_to_list Rk Rs tsl\"\n    assumes \"(s,s')\\<in>\\<langle>Rk\\<rangle>Rs\"\n    assumes \"(c,c')\\<in>R\\<sigma>\\<rightarrow>Id\"\n    assumes \"(f,f')\\<in>Rk \\<rightarrow> R\\<sigma> \\<rightarrow> R\\<sigma>\"\n    assumes \"(\\<sigma>,\\<sigma>')\\<in>R\\<sigma>\"\n    shows \"(foldli (tsl s) c f \\<sigma>, result s') \\<in> R\\<sigma>\"", "lemma is_map_to_sorted_listE:\n    assumes \"is_map_to_sorted_list ordR Rk Rv Rm tsl\"\n    assumes \"(m,m')\\<in>\\<langle>Rk,Rv\\<rangle>Rm\"\n    obtains l' where \"(tsl m,l')\\<in>\\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel\" \n    and \"RETURN l' \\<le> it_to_sorted_list (key_rel ordR) (map_to_set m')\"", "lemma map_to_list_by_map_to_sorted_list[autoref_ga_rules]:\n    assumes \"GEN_ALGO_tag (is_map_to_sorted_list ordR Rk Rv Rm tsl)\"\n    shows \"is_map_to_list Rk Rv Rm tsl\"", "lemma det_fold_mapI[intro?]:\n    assumes \"\\<And>l. \\<lbrakk>distinct (map fst l); sorted_wrt (key_rel R) l\\<rbrakk> \n      \\<Longrightarrow> foldli l c f \\<sigma> = result (map_of l)\"\n    shows \"det_fold_map R c f \\<sigma> result\"", "lemma det_fold_map_aux:\n    assumes 1: \"\\<lbrakk>distinct (map fst l); sorted_wrt (key_rel R) l \\<rbrakk>\n      \\<Longrightarrow> foldli l c f \\<sigma> = result (map_of l)\"\n    assumes 2: \"RETURN l \\<le> it_to_sorted_list (key_rel R) (map_to_set m)\"\n    shows \"foldli l c f \\<sigma> = result m\"", "lemma det_fold_sorted_map:\n    assumes 1: \"det_fold_map ordR c' f' \\<sigma>' result\"\n    assumes 2: \"is_map_to_sorted_list ordR Rk Rv Rm tsl\"\n    assumes MREF[param]: \"(m,m')\\<in>\\<langle>Rk,Rv\\<rangle>Rm\"\n    assumes [param]:  \"(c,c')\\<in>R\\<sigma>\\<rightarrow>Id\"\n    assumes [param]: \"(f,f')\\<in>\\<langle>Rk,Rv\\<rangle>prod_rel \\<rightarrow> R\\<sigma> \\<rightarrow> R\\<sigma>\"\n    assumes [param]: \"(\\<sigma>,\\<sigma>')\\<in>R\\<sigma>\"\n    shows \"(foldli (tsl m) c f \\<sigma>, result m') \\<in> R\\<sigma>\"", "lemma det_fold_map:\n    assumes \"det_fold_map (\\<lambda>_ _. True) c' f' \\<sigma>' result\"\n    assumes \"is_map_to_list Rk Rv Rm tsl\"\n    assumes \"(m,m')\\<in>\\<langle>Rk,Rv\\<rangle>Rm\"\n    assumes \"(c,c')\\<in>R\\<sigma>\\<rightarrow>Id\"\n    assumes \"(f,f')\\<in>\\<langle>Rk,Rv\\<rangle>prod_rel \\<rightarrow> R\\<sigma> \\<rightarrow> R\\<sigma>\"\n    assumes \"(\\<sigma>,\\<sigma>')\\<in>R\\<sigma>\"\n    shows \"(foldli (tsl m) c f \\<sigma>, result m') \\<in> R\\<sigma>\"", "lemma set_to_sorted_list_by_tsl[autoref_rules]:\n  assumes \"MINOR_PRIO_TAG (- 11)\"\n  assumes TSL: \"SIDE_GEN_ALGO (is_set_to_sorted_list R Rk Rs tsl)\"\n  shows \"(\\<lambda>s. RETURN (tsl s), set_to_sorted_list R) \n    \\<in> \\<langle>Rk\\<rangle>Rs \\<rightarrow> \\<langle>\\<langle>Rk\\<rangle>list_rel\\<rangle>nres_rel\"", "lemma set_to_list_by_tsl[autoref_rules]:\n  assumes \"MINOR_PRIO_TAG (- 10)\"\n  assumes TSL: \"SIDE_GEN_ALGO (is_set_to_list Rk Rs tsl)\"\n  shows \"(\\<lambda>s. RETURN (tsl s), set_to_sorted_list (\\<lambda>_ _. True)) \n    \\<in> \\<langle>Rk\\<rangle>Rs \\<rightarrow> \\<langle>\\<langle>Rk\\<rangle>list_rel\\<rangle>nres_rel\"", "lemma map_to_sorted_list_by_tsl[autoref_rules]:\n  assumes \"MINOR_PRIO_TAG (- 11)\"\n  assumes TSL: \"SIDE_GEN_ALGO (is_map_to_sorted_list R Rk Rv Rs tsl)\"\n  shows \"(\\<lambda>s. RETURN (tsl s), map_to_sorted_list R) \n    \\<in> \\<langle>Rk,Rv\\<rangle>Rs \\<rightarrow> \\<langle>\\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel\\<rangle>nres_rel\"", "lemma map_to_list_by_tsl[autoref_rules]:\n  assumes \"MINOR_PRIO_TAG (- 10)\"\n  assumes TSL: \"SIDE_GEN_ALGO (is_map_to_list Rk Rv Rs tsl)\"\n  shows \"(\\<lambda>s. RETURN (tsl s), map_to_sorted_list (\\<lambda>_ _. True)) \n    \\<in> \\<langle>Rk,Rv\\<rangle>Rs \\<rightarrow> \\<langle>\\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel\\<rangle>nres_rel\"", "lemma proper_it_mono_dres_pair:\n  assumes PR: \"proper_it' it it'\"\n  assumes A: \"\\<And>k v x. f k v x \\<le> f' k v x\"\n  shows \"\n    it' s (case_dres False False c) (\\<lambda>(k,v) s. s \\<bind> f k v) \\<sigma>\n    \\<le> it' s (case_dres False False c) (\\<lambda>(k,v) s. s \\<bind> f' k v) \\<sigma>\" (is \"?a \\<le> ?b\")", "lemma proper_it_mono_dres_pair_flat:\n  assumes PR: \"proper_it' it it'\"\n  assumes A: \"\\<And>k v x. flat_ge (f k v x) (f' k v x)\"\n  shows \"\n    flat_ge (it' s (case_dres False False c) (\\<lambda>(k,v) s. s \\<bind> f k v) \\<sigma>)\n      (it' s (case_dres False False c) (\\<lambda>(k,v) s. s \\<bind> f' k v) \\<sigma>)\" \n      (is \"flat_ge ?a ?b\")", "lemma proper_it_mono_dres:\n  assumes PR: \"proper_it' it it'\"\n  assumes A: \"\\<And>kv x. f kv x \\<le> f' kv x\"\n  shows \"\n    it' s (case_dres False False c) (\\<lambda>kv s. s \\<bind> f kv) \\<sigma>\n    \\<le> it' s (case_dres False False c) (\\<lambda>kv s. s \\<bind> f' kv) \\<sigma>\"", "lemma proper_it_mono_dres_flat:\n  assumes PR: \"proper_it' it it'\"\n  assumes A: \"\\<And>kv x. flat_ge (f kv x) (f' kv x)\"\n  shows \"\n    flat_ge (it' s (case_dres False False c) (\\<lambda>kv s. s \\<bind> f kv) \\<sigma>)\n      (it' s (case_dres False False c) (\\<lambda>kv s. s \\<bind> f' kv) \\<sigma>)\"", "lemma pi'_dom[icf_proper_iteratorI]: \"proper_it' it it' \n  \\<Longrightarrow> proper_it' (map_iterator_dom o it) (map_iterator_dom o it')\"", "lemma proper_it_mono_dres_dom:\n  assumes PR: \"proper_it' it it'\"\n  assumes A: \"\\<And>kv x. f kv x \\<le> f' kv x\"\n  shows \"\n    (map_iterator_dom o it') s (case_dres False False c) (\\<lambda>kv s. s \\<bind> f kv) \\<sigma>\n    \\<le> \n    (map_iterator_dom o it') s (case_dres False False c) (\\<lambda>kv s. s \\<bind> f' kv) \\<sigma>\"", "lemma proper_it_mono_dres_dom_flat:\n  assumes PR: \"proper_it' it it'\"\n  assumes A: \"\\<And>kv x. flat_ge (f kv x) (f' kv x)\"\n  shows \"flat_ge \n    ((map_iterator_dom o it') s (case_dres False False c) (\\<lambda>kv s. s \\<bind> f kv) \\<sigma>)\n    ((map_iterator_dom o it') s (case_dres False False c) (\\<lambda>kv s. s \\<bind> f' kv) \\<sigma>)\"", "lemmas proper_it_monos = \n  proper_it_mono_dres_pair proper_it_mono_dres_pair_flat\n  proper_it_mono_dres proper_it_mono_dres_flat\n  proper_it_mono_dres_dom proper_it_mono_dres_dom_flat"], "translations": [["", "lemma param_it_to_list[param]: \"(it_to_list,it_to_list) \\<in>\n    (Rs \\<rightarrow> (Ra \\<rightarrow> bool_rel) \\<rightarrow> \n    (Rb \\<rightarrow> \\<langle>Rb\\<rangle>list_rel \\<rightarrow> \\<langle>Rb\\<rangle>list_rel) \\<rightarrow> \\<langle>Rc\\<rangle>list_rel \\<rightarrow> Rd) \\<rightarrow> Rs \\<rightarrow> Rd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (it_to_list, it_to_list)\n    \\<in> (Rs \\<rightarrow>\n           (Ra \\<rightarrow> bool_rel) \\<rightarrow>\n           (Rb \\<rightarrow>\n            \\<langle>Rb\\<rangle>list_rel \\<rightarrow>\n            \\<langle>Rb\\<rangle>list_rel) \\<rightarrow>\n           \\<langle>Rc\\<rangle>list_rel \\<rightarrow> Rd) \\<rightarrow>\n          Rs \\<rightarrow> Rd", "unfolding it_to_list_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>it s. it s (\\<lambda>_. True) (\\<lambda>x l. l @ [x]) [],\n     \\<lambda>it s. it s (\\<lambda>_. True) (\\<lambda>x l. l @ [x]) [])\n    \\<in> (Rs \\<rightarrow>\n           (Ra \\<rightarrow> bool_rel) \\<rightarrow>\n           (Rb \\<rightarrow>\n            \\<langle>Rb\\<rangle>list_rel \\<rightarrow>\n            \\<langle>Rb\\<rangle>list_rel) \\<rightarrow>\n           \\<langle>Rc\\<rangle>list_rel \\<rightarrow> Rd) \\<rightarrow>\n          Rs \\<rightarrow> Rd", "by parametricity"], ["", "definition key_rel :: \"('k \\<Rightarrow> 'k \\<Rightarrow> bool) \\<Rightarrow> ('k\\<times>'v) \\<Rightarrow> ('k\\<times>'v) \\<Rightarrow> bool\"\n    where \"key_rel R a b \\<equiv> R (fst a) (fst b)\""], ["", "lemma key_rel_UNIV[simp]: \"key_rel (\\<lambda>_ _. True) = (\\<lambda>_ _. True)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. key_rel (\\<lambda>_ _. True) = (\\<lambda>_ _. True)", "unfolding key_rel_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>a b. True) = (\\<lambda>_ _. True)", "by auto"], ["", "subsection \\<open>Setup for Autoref\\<close>"], ["", "text \\<open>Default pattern rules for \\<open>it_to_sorted_list\\<close>\\<close>"], ["", "definition \"set_to_sorted_list R S \\<equiv> it_to_sorted_list R S\""], ["", "lemma set_to_sorted_list_itype[autoref_itype]: \n    \"set_to_sorted_list R ::\\<^sub>i \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i \\<langle>\\<langle>I\\<rangle>\\<^sub>ii_list\\<rangle>\\<^sub>ii_nres\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_to_sorted_list R ::\\<^sub>i\n    \\<langle>I\\<rangle>\\<^sub>ii_set \\<rightarrow>\\<^sub>i\n    \\<langle>\\<langle>I\\<rangle>\\<^sub>ii_list\\<rangle>\\<^sub>ii_nres", "by simp"], ["", "context begin"], ["", "interpretation autoref_syn"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma set_to_sorted_list_pat[autoref_op_pat]: \n    \"it_to_sorted_list R S \\<equiv> OP (set_to_sorted_list R) S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. it_to_sorted_list R S \\<equiv> OP (set_to_sorted_list R) S", "unfolding set_to_sorted_list_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. it_to_sorted_list R S \\<equiv> OP (it_to_sorted_list R) S", "by auto"], ["", "end"], ["", "definition \"map_to_sorted_list R M \n    \\<equiv> it_to_sorted_list (key_rel R) (map_to_set M)\""], ["", "lemma map_to_sorted_list_itype[autoref_itype]:\n    \"map_to_sorted_list R ::\\<^sub>i \\<langle>Rk,Rv\\<rangle>\\<^sub>ii_map \\<rightarrow>\\<^sub>i \\<langle>\\<langle>\\<langle>Rk,Rv\\<rangle>\\<^sub>ii_prod\\<rangle>\\<^sub>ii_list\\<rangle>\\<^sub>ii_nres\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_to_sorted_list R ::\\<^sub>i\n    \\<langle>Rk, Rv\\<rangle>\\<^sub>ii_map \\<rightarrow>\\<^sub>i\n    \\<langle>\\<langle>\\<langle>Rk,\n    Rv\\<rangle>\\<^sub>ii_prod\\<rangle>\\<^sub>ii_list\\<rangle>\\<^sub>ii_nres", "by simp"], ["", "context begin"], ["", "interpretation autoref_syn"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma map_to_sorted_list_pat[autoref_op_pat]:\n    \"it_to_sorted_list (key_rel R) (map_to_set M) \n      \\<equiv> OP (map_to_sorted_list R) M\"\n    \"it_to_sorted_list (\\<lambda>_ _. True) (map_to_set M) \n      \\<equiv> OP (map_to_sorted_list (\\<lambda>_ _. True)) M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (it_to_sorted_list (key_rel R) (map_to_set M) \\<equiv>\n     OP (map_to_sorted_list R) M) &&&\n    it_to_sorted_list (\\<lambda>_ _. True) (map_to_set M) \\<equiv>\n    OP (map_to_sorted_list (\\<lambda>_ _. True)) M", "unfolding map_to_sorted_list_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (it_to_sorted_list (key_rel R) (map_to_set M) \\<equiv>\n     OP (\\<lambda>M. it_to_sorted_list (key_rel R) (map_to_set M)) M) &&&\n    it_to_sorted_list (\\<lambda>_ _. True) (map_to_set M) \\<equiv>\n    OP (\\<lambda>M.\n           it_to_sorted_list (key_rel (\\<lambda>_ _. True)) (map_to_set M))\n     M", "by auto"], ["", "end"], ["", "subsection \\<open>Set iterators\\<close>"], ["", "(*definition \"is_set_to_sorted_list_deprecated ordR Rk Rs tsl \\<equiv> \\<forall>s s'.\n    (s,s')\\<in>\\<langle>Rk\\<rangle>Rs \\<longrightarrow> \n      (RETURN (tsl s),it_to_sorted_list ordR s')\\<in>\\<langle>\\<langle>Rk\\<rangle>list_rel\\<rangle>nres_rel\"\n    *)"], ["", "definition \"is_set_to_sorted_list ordR Rk Rs tsl \\<equiv> \\<forall>s s'.\n    (s,s')\\<in>\\<langle>Rk\\<rangle>Rs \n      \\<longrightarrow> ( \\<exists>l'. (tsl s,l')\\<in>\\<langle>Rk\\<rangle>list_rel \n            \\<and> RETURN l' \\<le> it_to_sorted_list ordR s')\""], ["", "definition \"is_set_to_list \\<equiv> is_set_to_sorted_list (\\<lambda>_ _. True)\""], ["", "lemma is_set_to_sorted_listE:\n    assumes \"is_set_to_sorted_list ordR Rk Rs tsl\"\n    assumes \"(s,s')\\<in>\\<langle>Rk\\<rangle>Rs\"\n    obtains l' where \"(tsl s,l')\\<in>\\<langle>Rk\\<rangle>list_rel\" \n    and \"RETURN l' \\<le> it_to_sorted_list ordR s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>(tsl s, l') \\<in> \\<langle>Rk\\<rangle>list_rel;\n         RETURN l' \\<le> it_to_sorted_list ordR s'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  is_set_to_sorted_list ordR Rk Rs tsl\n  (s, s') \\<in> \\<langle>Rk\\<rangle>Rs\n\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>(tsl s, l') \\<in> \\<langle>Rk\\<rangle>list_rel;\n         RETURN l' \\<le> it_to_sorted_list ordR s'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding is_set_to_sorted_list_def"], ["proof (prove)\nusing this:\n  \\<forall>s s'.\n     (s, s') \\<in> \\<langle>Rk\\<rangle>Rs \\<longrightarrow>\n     (\\<exists>l'.\n         (tsl s, l') \\<in> \\<langle>Rk\\<rangle>list_rel \\<and>\n         RETURN l' \\<le> it_to_sorted_list ordR s')\n  (s, s') \\<in> \\<langle>Rk\\<rangle>Rs\n\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>(tsl s, l') \\<in> \\<langle>Rk\\<rangle>list_rel;\n         RETURN l' \\<le> it_to_sorted_list ordR s'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["", "(* TODO: Move *)"], ["", "lemma it_to_sorted_list_weaken: \n    \"R\\<le>R' \\<Longrightarrow> it_to_sorted_list R s \\<le> it_to_sorted_list R' s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<le> R' \\<Longrightarrow>\n    it_to_sorted_list R s \\<le> it_to_sorted_list R' s", "unfolding it_to_sorted_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<le> R' \\<Longrightarrow>\n    SPEC (\\<lambda>l. distinct l \\<and> s = set l \\<and> sorted_wrt R l)\n    \\<le> SPEC\n           (\\<lambda>l. distinct l \\<and> s = set l \\<and> sorted_wrt R' l)", "by (auto intro!: sorted_wrt_mono_rel[where P=R])"], ["", "lemma set_to_list_by_set_to_sorted_list[autoref_ga_rules]:\n    assumes \"GEN_ALGO_tag (is_set_to_sorted_list ordR Rk Rs tsl)\"\n    shows \"is_set_to_list Rk Rs tsl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_set_to_list Rk Rs tsl", "using assms"], ["proof (prove)\nusing this:\n  GEN_ALGO_tag (is_set_to_sorted_list ordR Rk Rs tsl)\n\ngoal (1 subgoal):\n 1. is_set_to_list Rk Rs tsl", "unfolding is_set_to_list_def is_set_to_sorted_list_def autoref_tag_defs"], ["proof (prove)\nusing this:\n  \\<forall>s s'.\n     (s, s') \\<in> \\<langle>Rk\\<rangle>Rs \\<longrightarrow>\n     (\\<exists>l'.\n         (tsl s, l') \\<in> \\<langle>Rk\\<rangle>list_rel \\<and>\n         RETURN l' \\<le> it_to_sorted_list ordR s')\n\ngoal (1 subgoal):\n 1. \\<forall>s s'.\n       (s, s') \\<in> \\<langle>Rk\\<rangle>Rs \\<longrightarrow>\n       (\\<exists>l'.\n           (tsl s, l') \\<in> \\<langle>Rk\\<rangle>list_rel \\<and>\n           RETURN l' \\<le> it_to_sorted_list (\\<lambda>_ _. True) s')", "apply (safe)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>\\<forall>s s'.\n                   (s, s') \\<in> \\<langle>Rk\\<rangle>Rs \\<longrightarrow>\n                   (\\<exists>l'.\n                       (tsl s, l') \\<in> \\<langle>Rk\\<rangle>list_rel \\<and>\n                       RETURN l' \\<le> it_to_sorted_list ordR s');\n        (s, s') \\<in> \\<langle>Rk\\<rangle>Rs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            (tsl s, l')\n                            \\<in> \\<langle>Rk\\<rangle>list_rel \\<and>\n                            RETURN l'\n                            \\<le> it_to_sorted_list (\\<lambda>_ _. True) s'", "apply (drule spec, drule spec, drule (1) mp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s'.\n       \\<lbrakk>(s, s') \\<in> \\<langle>Rk\\<rangle>Rs;\n        \\<exists>l'.\n           (tsl s, l') \\<in> \\<langle>Rk\\<rangle>list_rel \\<and>\n           RETURN l' \\<le> it_to_sorted_list ordR s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            (tsl s, l')\n                            \\<in> \\<langle>Rk\\<rangle>list_rel \\<and>\n                            RETURN l'\n                            \\<le> it_to_sorted_list (\\<lambda>_ _. True) s'", "apply (elim exE conjE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s' l'.\n       \\<lbrakk>(s, s') \\<in> \\<langle>Rk\\<rangle>Rs;\n        (tsl s, l') \\<in> \\<langle>Rk\\<rangle>list_rel;\n        RETURN l' \\<le> it_to_sorted_list ordR s'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            (tsl s, l')\n                            \\<in> \\<langle>Rk\\<rangle>list_rel \\<and>\n                            RETURN l'\n                            \\<le> it_to_sorted_list (\\<lambda>_ _. True) s'", "apply (rule exI, rule conjI, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s' l'.\n       \\<lbrakk>(s, s') \\<in> \\<langle>Rk\\<rangle>Rs;\n        (tsl s, l') \\<in> \\<langle>Rk\\<rangle>list_rel;\n        RETURN l' \\<le> it_to_sorted_list ordR s'\\<rbrakk>\n       \\<Longrightarrow> RETURN l'\n                         \\<le> it_to_sorted_list (\\<lambda>_ _. True) s'", "apply (rule order_trans, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s' l'.\n       \\<lbrakk>(s, s') \\<in> \\<langle>Rk\\<rangle>Rs;\n        (tsl s, l') \\<in> \\<langle>Rk\\<rangle>list_rel;\n        RETURN l' \\<le> it_to_sorted_list ordR s'\\<rbrakk>\n       \\<Longrightarrow> it_to_sorted_list ordR s'\n                         \\<le> it_to_sorted_list (\\<lambda>_ _. True) s'", "apply (rule it_to_sorted_list_weaken)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s s' l'.\n       \\<lbrakk>(s, s') \\<in> \\<langle>Rk\\<rangle>Rs;\n        (tsl s, l') \\<in> \\<langle>Rk\\<rangle>list_rel;\n        RETURN l' \\<le> it_to_sorted_list ordR s'\\<rbrakk>\n       \\<Longrightarrow> ordR \\<le> (\\<lambda>_ _. True)", "by blast"], ["", "definition \"det_fold_set R c f \\<sigma> result \\<equiv> \n    \\<forall>l. distinct l \\<and> sorted_wrt R l \\<longrightarrow> foldli l c f \\<sigma> = result (set l)\""], ["", "lemma det_fold_setI[intro?]:\n    assumes \"\\<And>l. \\<lbrakk>distinct l; sorted_wrt R l\\<rbrakk> \n      \\<Longrightarrow> foldli l c f \\<sigma> = result (set l)\"\n    shows \"det_fold_set R c f \\<sigma> result\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det_fold_set R c f \\<sigma> result", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct ?l; sorted_wrt R ?l\\<rbrakk>\n  \\<Longrightarrow> foldli ?l c f \\<sigma> = result (set ?l)\n\ngoal (1 subgoal):\n 1. det_fold_set R c f \\<sigma> result", "unfolding det_fold_set_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct ?l; sorted_wrt R ?l\\<rbrakk>\n  \\<Longrightarrow> foldli ?l c f \\<sigma> = result (set ?l)\n\ngoal (1 subgoal):\n 1. \\<forall>l.\n       distinct l \\<and> sorted_wrt R l \\<longrightarrow>\n       foldli l c f \\<sigma> = result (set l)", "by auto"], ["", "text \\<open>Template lemma for generic algorithm using set iterator\\<close>"], ["", "lemma det_fold_sorted_set:\n    assumes 1: \"det_fold_set ordR c' f' \\<sigma>' result\"\n    assumes 2: \"is_set_to_sorted_list ordR Rk Rs tsl\"\n    assumes SREF[param]: \"(s,s')\\<in>\\<langle>Rk\\<rangle>Rs\"\n    assumes [param]:  \"(c,c')\\<in>R\\<sigma>\\<rightarrow>Id\"\n    assumes [param]: \"(f,f')\\<in>Rk \\<rightarrow> R\\<sigma> \\<rightarrow> R\\<sigma>\"\n    assumes [param]: \"(\\<sigma>,\\<sigma>')\\<in>R\\<sigma>\"\n    shows \"(foldli (tsl s) c f \\<sigma>, result s') \\<in> R\\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (foldli (tsl s) c f \\<sigma>, result s') \\<in> R\\<sigma>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (foldli (tsl s) c f \\<sigma>, result s') \\<in> R\\<sigma>", "obtain tsl' where\n      [param]: \"(tsl s,tsl') \\<in> \\<langle>Rk\\<rangle>list_rel\" \n      and IT: \"RETURN tsl' \\<le> it_to_sorted_list ordR s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>tsl'.\n        \\<lbrakk>(tsl s, tsl') \\<in> \\<langle>Rk\\<rangle>list_rel;\n         RETURN tsl' \\<le> it_to_sorted_list ordR s'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using 2 SREF"], ["proof (prove)\nusing this:\n  is_set_to_sorted_list ordR Rk Rs tsl\n  (s, s') \\<in> \\<langle>Rk\\<rangle>Rs\n\ngoal (1 subgoal):\n 1. (\\<And>tsl'.\n        \\<lbrakk>(tsl s, tsl') \\<in> \\<langle>Rk\\<rangle>list_rel;\n         RETURN tsl' \\<le> it_to_sorted_list ordR s'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule is_set_to_sorted_listE)"], ["proof (state)\nthis:\n  (tsl s, tsl') \\<in> \\<langle>Rk\\<rangle>list_rel\n  RETURN tsl' \\<le> it_to_sorted_list ordR s'\n\ngoal (1 subgoal):\n 1. (foldli (tsl s) c f \\<sigma>, result s') \\<in> R\\<sigma>", "have \"(foldli (tsl s) c f \\<sigma>, foldli tsl' c' f' \\<sigma>') \\<in> R\\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (foldli (tsl s) c f \\<sigma>, foldli tsl' c' f' \\<sigma>')\n    \\<in> R\\<sigma>", "by parametricity"], ["proof (state)\nthis:\n  (foldli (tsl s) c f \\<sigma>, foldli tsl' c' f' \\<sigma>') \\<in> R\\<sigma>\n\ngoal (1 subgoal):\n 1. (foldli (tsl s) c f \\<sigma>, result s') \\<in> R\\<sigma>", "also"], ["proof (state)\nthis:\n  (foldli (tsl s) c f \\<sigma>, foldli tsl' c' f' \\<sigma>') \\<in> R\\<sigma>\n\ngoal (1 subgoal):\n 1. (foldli (tsl s) c f \\<sigma>, result s') \\<in> R\\<sigma>", "have \"foldli tsl' c' f' \\<sigma>' = result s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli tsl' c' f' \\<sigma>' = result s'", "using 1 IT"], ["proof (prove)\nusing this:\n  det_fold_set ordR c' f' \\<sigma>' result\n  RETURN tsl' \\<le> it_to_sorted_list ordR s'\n\ngoal (1 subgoal):\n 1. foldli tsl' c' f' \\<sigma>' = result s'", "unfolding det_fold_set_def it_to_sorted_list_def"], ["proof (prove)\nusing this:\n  \\<forall>l.\n     distinct l \\<and> sorted_wrt ordR l \\<longrightarrow>\n     foldli l c' f' \\<sigma>' = result (set l)\n  RETURN tsl'\n  \\<le> SPEC\n         (\\<lambda>l. distinct l \\<and> s' = set l \\<and> sorted_wrt ordR l)\n\ngoal (1 subgoal):\n 1. foldli tsl' c' f' \\<sigma>' = result s'", "by simp"], ["proof (state)\nthis:\n  foldli tsl' c' f' \\<sigma>' = result s'\n\ngoal (1 subgoal):\n 1. (foldli (tsl s) c f \\<sigma>, result s') \\<in> R\\<sigma>", "finally"], ["proof (chain)\npicking this:\n  (foldli (tsl s) c f \\<sigma>, result s') \\<in> R\\<sigma>", "show ?thesis"], ["proof (prove)\nusing this:\n  (foldli (tsl s) c f \\<sigma>, result s') \\<in> R\\<sigma>\n\ngoal (1 subgoal):\n 1. (foldli (tsl s) c f \\<sigma>, result s') \\<in> R\\<sigma>", "."], ["proof (state)\nthis:\n  (foldli (tsl s) c f \\<sigma>, result s') \\<in> R\\<sigma>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma det_fold_set:\n    assumes \"det_fold_set (\\<lambda>_ _. True) c' f' \\<sigma>' result\"\n    assumes \"is_set_to_list Rk Rs tsl\"\n    assumes \"(s,s')\\<in>\\<langle>Rk\\<rangle>Rs\"\n    assumes \"(c,c')\\<in>R\\<sigma>\\<rightarrow>Id\"\n    assumes \"(f,f')\\<in>Rk \\<rightarrow> R\\<sigma> \\<rightarrow> R\\<sigma>\"\n    assumes \"(\\<sigma>,\\<sigma>')\\<in>R\\<sigma>\"\n    shows \"(foldli (tsl s) c f \\<sigma>, result s') \\<in> R\\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (foldli (tsl s) c f \\<sigma>, result s') \\<in> R\\<sigma>", "using assms"], ["proof (prove)\nusing this:\n  det_fold_set (\\<lambda>_ _. True) c' f' \\<sigma>' result\n  is_set_to_list Rk Rs tsl\n  (s, s') \\<in> \\<langle>Rk\\<rangle>Rs\n  (c, c') \\<in> R\\<sigma> \\<rightarrow> bool_rel\n  (f, f') \\<in> Rk \\<rightarrow> R\\<sigma> \\<rightarrow> R\\<sigma>\n  (\\<sigma>, \\<sigma>') \\<in> R\\<sigma>\n\ngoal (1 subgoal):\n 1. (foldli (tsl s) c f \\<sigma>, result s') \\<in> R\\<sigma>", "unfolding  is_set_to_list_def"], ["proof (prove)\nusing this:\n  det_fold_set (\\<lambda>_ _. True) c' f' \\<sigma>' result\n  is_set_to_sorted_list (\\<lambda>_ _. True) Rk Rs tsl\n  (s, s') \\<in> \\<langle>Rk\\<rangle>Rs\n  (c, c') \\<in> R\\<sigma> \\<rightarrow> bool_rel\n  (f, f') \\<in> Rk \\<rightarrow> R\\<sigma> \\<rightarrow> R\\<sigma>\n  (\\<sigma>, \\<sigma>') \\<in> R\\<sigma>\n\ngoal (1 subgoal):\n 1. (foldli (tsl s) c f \\<sigma>, result s') \\<in> R\\<sigma>", "by (rule det_fold_sorted_set)"], ["", "subsection \\<open>Map iterators\\<close>"], ["", "text \\<open>Build relation on keys\\<close>"], ["", "(*definition \"is_map_to_sorted_list_deprecated ordR Rk Rv Rm tsl \\<equiv> \\<forall>m m'.\n    (m,m')\\<in>\\<langle>Rk,Rv\\<rangle>Rm \\<longrightarrow> \n      (RETURN (tsl m),it_to_sorted_list (key_rel ordR) (map_to_set m'))\n      \\<in>\\<langle>\\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel\\<rangle>nres_rel\"*)"], ["", "definition \"is_map_to_sorted_list ordR Rk Rv Rm tsl \\<equiv> \\<forall>m m'.\n    (m,m')\\<in>\\<langle>Rk,Rv\\<rangle>Rm \\<longrightarrow> (\n      \\<exists>l'. (tsl m,l')\\<in>\\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel\n        \\<and> RETURN l' \\<le> it_to_sorted_list (key_rel ordR) (map_to_set m'))\""], ["", "definition \"is_map_to_list Rk Rv Rm tsl \n    \\<equiv> is_map_to_sorted_list (\\<lambda>_ _. True) Rk Rv Rm tsl\""], ["", "lemma is_map_to_sorted_listE:\n    assumes \"is_map_to_sorted_list ordR Rk Rv Rm tsl\"\n    assumes \"(m,m')\\<in>\\<langle>Rk,Rv\\<rangle>Rm\"\n    obtains l' where \"(tsl m,l')\\<in>\\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel\" \n    and \"RETURN l' \\<le> it_to_sorted_list (key_rel ordR) (map_to_set m')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>(tsl m, l')\n                 \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel;\n         RETURN l'\n         \\<le> it_to_sorted_list (key_rel ordR) (map_to_set m')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  is_map_to_sorted_list ordR Rk Rv Rm tsl\n  (m, m') \\<in> \\<langle>Rk, Rv\\<rangle>Rm\n\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>(tsl m, l')\n                 \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel;\n         RETURN l'\n         \\<le> it_to_sorted_list (key_rel ordR) (map_to_set m')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding is_map_to_sorted_list_def"], ["proof (prove)\nusing this:\n  \\<forall>m m'.\n     (m, m') \\<in> \\<langle>Rk, Rv\\<rangle>Rm \\<longrightarrow>\n     (\\<exists>l'.\n         (tsl m, l')\n         \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel \\<and>\n         RETURN l' \\<le> it_to_sorted_list (key_rel ordR) (map_to_set m'))\n  (m, m') \\<in> \\<langle>Rk, Rv\\<rangle>Rm\n\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>(tsl m, l')\n                 \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel;\n         RETURN l'\n         \\<le> it_to_sorted_list (key_rel ordR) (map_to_set m')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["", "lemma map_to_list_by_map_to_sorted_list[autoref_ga_rules]:\n    assumes \"GEN_ALGO_tag (is_map_to_sorted_list ordR Rk Rv Rm tsl)\"\n    shows \"is_map_to_list Rk Rv Rm tsl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_map_to_list Rk Rv Rm tsl", "using assms"], ["proof (prove)\nusing this:\n  GEN_ALGO_tag (is_map_to_sorted_list ordR Rk Rv Rm tsl)\n\ngoal (1 subgoal):\n 1. is_map_to_list Rk Rv Rm tsl", "unfolding is_map_to_list_def is_map_to_sorted_list_def autoref_tag_defs"], ["proof (prove)\nusing this:\n  \\<forall>m m'.\n     (m, m') \\<in> \\<langle>Rk, Rv\\<rangle>Rm \\<longrightarrow>\n     (\\<exists>l'.\n         (tsl m, l')\n         \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel \\<and>\n         RETURN l' \\<le> it_to_sorted_list (key_rel ordR) (map_to_set m'))\n\ngoal (1 subgoal):\n 1. \\<forall>m m'.\n       (m, m') \\<in> \\<langle>Rk, Rv\\<rangle>Rm \\<longrightarrow>\n       (\\<exists>l'.\n           (tsl m, l')\n           \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel \\<and>\n           RETURN l'\n           \\<le> it_to_sorted_list (key_rel (\\<lambda>_ _. True))\n                  (map_to_set m'))", "apply (safe)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m m'.\n       \\<lbrakk>\\<forall>m m'.\n                   (m, m') \\<in> \\<langle>Rk,\n                   Rv\\<rangle>Rm \\<longrightarrow>\n                   (\\<exists>l'.\n                       (tsl m, l')\n                       \\<in> \\<langle>Rk \\<times>\\<^sub>r\nRv\\<rangle>list_rel \\<and>\n                       RETURN l'\n                       \\<le> it_to_sorted_list (key_rel ordR)\n                              (map_to_set m'));\n        (m, m') \\<in> \\<langle>Rk, Rv\\<rangle>Rm\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            (tsl m, l')\n                            \\<in> \\<langle>Rk \\<times>\\<^sub>r\n     Rv\\<rangle>list_rel \\<and>\n                            RETURN l'\n                            \\<le> it_to_sorted_list\n                                   (key_rel (\\<lambda>_ _. True))\n                                   (map_to_set m')", "apply (drule spec, drule spec, drule (1) mp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m m'.\n       \\<lbrakk>(m, m') \\<in> \\<langle>Rk, Rv\\<rangle>Rm;\n        \\<exists>l'.\n           (tsl m, l')\n           \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel \\<and>\n           RETURN l'\n           \\<le> it_to_sorted_list (key_rel ordR) (map_to_set m')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            (tsl m, l')\n                            \\<in> \\<langle>Rk \\<times>\\<^sub>r\n     Rv\\<rangle>list_rel \\<and>\n                            RETURN l'\n                            \\<le> it_to_sorted_list\n                                   (key_rel (\\<lambda>_ _. True))\n                                   (map_to_set m')", "apply (elim exE conjE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m m' l'.\n       \\<lbrakk>(m, m') \\<in> \\<langle>Rk, Rv\\<rangle>Rm;\n        (tsl m, l') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel;\n        RETURN l'\n        \\<le> it_to_sorted_list (key_rel ordR) (map_to_set m')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l'.\n                            (tsl m, l')\n                            \\<in> \\<langle>Rk \\<times>\\<^sub>r\n     Rv\\<rangle>list_rel \\<and>\n                            RETURN l'\n                            \\<le> it_to_sorted_list\n                                   (key_rel (\\<lambda>_ _. True))\n                                   (map_to_set m')", "apply (rule exI, rule conjI, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m m' l'.\n       \\<lbrakk>(m, m') \\<in> \\<langle>Rk, Rv\\<rangle>Rm;\n        (tsl m, l') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel;\n        RETURN l'\n        \\<le> it_to_sorted_list (key_rel ordR) (map_to_set m')\\<rbrakk>\n       \\<Longrightarrow> RETURN l'\n                         \\<le> it_to_sorted_list\n                                (key_rel (\\<lambda>_ _. True))\n                                (map_to_set m')", "apply (rule order_trans, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m m' l'.\n       \\<lbrakk>(m, m') \\<in> \\<langle>Rk, Rv\\<rangle>Rm;\n        (tsl m, l') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel;\n        RETURN l'\n        \\<le> it_to_sorted_list (key_rel ordR) (map_to_set m')\\<rbrakk>\n       \\<Longrightarrow> it_to_sorted_list (key_rel ordR) (map_to_set m')\n                         \\<le> it_to_sorted_list\n                                (key_rel (\\<lambda>_ _. True))\n                                (map_to_set m')", "apply (rule it_to_sorted_list_weaken)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m m' l'.\n       \\<lbrakk>(m, m') \\<in> \\<langle>Rk, Rv\\<rangle>Rm;\n        (tsl m, l') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel;\n        RETURN l'\n        \\<le> it_to_sorted_list (key_rel ordR) (map_to_set m')\\<rbrakk>\n       \\<Longrightarrow> key_rel ordR \\<le> key_rel (\\<lambda>_ _. True)", "unfolding key_rel_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m m' l'.\n       \\<lbrakk>(m, m') \\<in> \\<langle>Rk, Rv\\<rangle>Rm;\n        (tsl m, l') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel;\n        RETURN l'\n        \\<le> it_to_sorted_list (\\<lambda>a b. ordR (fst a) (fst b))\n               (map_to_set m')\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>a b. ordR (fst a) (fst b))\n                         \\<le> (\\<lambda>a b. True)", "by blast"], ["", "definition \"det_fold_map R c f \\<sigma> result \\<equiv> \n    \\<forall>l. distinct (map fst l) \\<and> sorted_wrt (key_rel R) l \n      \\<longrightarrow> foldli l c f \\<sigma> = result (map_of l)\""], ["", "lemma det_fold_mapI[intro?]:\n    assumes \"\\<And>l. \\<lbrakk>distinct (map fst l); sorted_wrt (key_rel R) l\\<rbrakk> \n      \\<Longrightarrow> foldli l c f \\<sigma> = result (map_of l)\"\n    shows \"det_fold_map R c f \\<sigma> result\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det_fold_map R c f \\<sigma> result", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct (map fst ?l); sorted_wrt (key_rel R) ?l\\<rbrakk>\n  \\<Longrightarrow> foldli ?l c f \\<sigma> = result (map_of ?l)\n\ngoal (1 subgoal):\n 1. det_fold_map R c f \\<sigma> result", "unfolding det_fold_map_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct (map fst ?l); sorted_wrt (key_rel R) ?l\\<rbrakk>\n  \\<Longrightarrow> foldli ?l c f \\<sigma> = result (map_of ?l)\n\ngoal (1 subgoal):\n 1. \\<forall>l.\n       distinct (map fst l) \\<and>\n       sorted_wrt (key_rel R) l \\<longrightarrow>\n       foldli l c f \\<sigma> = result (map_of l)", "by auto"], ["", "lemma det_fold_map_aux:\n    assumes 1: \"\\<lbrakk>distinct (map fst l); sorted_wrt (key_rel R) l \\<rbrakk>\n      \\<Longrightarrow> foldli l c f \\<sigma> = result (map_of l)\"\n    assumes 2: \"RETURN l \\<le> it_to_sorted_list (key_rel R) (map_to_set m)\"\n    shows \"foldli l c f \\<sigma> = result m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli l c f \\<sigma> = result m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. foldli l c f \\<sigma> = result m", "from 2"], ["proof (chain)\npicking this:\n  RETURN l \\<le> it_to_sorted_list (key_rel R) (map_to_set m)", "have \"distinct l\" and \"set l = map_to_set m\" \n      and SORTED: \"sorted_wrt (key_rel R) l\""], ["proof (prove)\nusing this:\n  RETURN l \\<le> it_to_sorted_list (key_rel R) (map_to_set m)\n\ngoal (1 subgoal):\n 1. distinct l &&& set l = map_to_set m &&& sorted_wrt (key_rel R) l", "unfolding it_to_sorted_list_def"], ["proof (prove)\nusing this:\n  RETURN l\n  \\<le> SPEC\n         (\\<lambda>l.\n             distinct l \\<and>\n             map_to_set m = set l \\<and> sorted_wrt (key_rel R) l)\n\ngoal (1 subgoal):\n 1. distinct l &&& set l = map_to_set m &&& sorted_wrt (key_rel R) l", "by simp_all"], ["proof (state)\nthis:\n  distinct l\n  set l = map_to_set m\n  sorted_wrt (key_rel R) l\n\ngoal (1 subgoal):\n 1. foldli l c f \\<sigma> = result m", "hence \"\\<forall>(k,v)\\<in>set l. \\<forall>(k',v')\\<in>set l. k=k' \\<longrightarrow> v=v'\""], ["proof (prove)\nusing this:\n  distinct l\n  set l = map_to_set m\n  sorted_wrt (key_rel R) l\n\ngoal (1 subgoal):\n 1. \\<forall>(k, v)\\<in>set l.\n       \\<forall>(k', v')\\<in>set l. k = k' \\<longrightarrow> v = v'", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct l; set l = map_to_set m;\n     sorted_wrt (key_rel R) l\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>map_to_set m.\n                         case x of\n                         (k, v) \\<Rightarrow>\n                           \\<forall>x\\<in>map_to_set m.\n                              case x of\n                              (k', v') \\<Rightarrow>\n                                k = k' \\<longrightarrow> v = v'", "unfolding map_to_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct l; set l = {(k, v). m k = Some v};\n     sorted_wrt (key_rel R) l\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>{(k, v). m k = Some v}.\n                         case x of\n                         (k, v) \\<Rightarrow>\n                           \\<forall>x\\<in>{(k, v). m k = Some v}.\n                              case x of\n                              (k', v') \\<Rightarrow>\n                                k = k' \\<longrightarrow> v = v'", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>(k, v)\\<in>set l.\n     \\<forall>(k', v')\\<in>set l. k = k' \\<longrightarrow> v = v'\n\ngoal (1 subgoal):\n 1. foldli l c f \\<sigma> = result m", "with \\<open>distinct l\\<close>"], ["proof (chain)\npicking this:\n  distinct l\n  \\<forall>(k, v)\\<in>set l.\n     \\<forall>(k', v')\\<in>set l. k = k' \\<longrightarrow> v = v'", "have DF: \"distinct (map fst l)\""], ["proof (prove)\nusing this:\n  distinct l\n  \\<forall>(k, v)\\<in>set l.\n     \\<forall>(k', v')\\<in>set l. k = k' \\<longrightarrow> v = v'\n\ngoal (1 subgoal):\n 1. distinct (map fst l)", "apply (induct l)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct [];\n     \\<forall>(k, v)\\<in>set [].\n        \\<forall>(k', v')\\<in>set [].\n           k = k' \\<longrightarrow> v = v'\\<rbrakk>\n    \\<Longrightarrow> distinct (map fst [])\n 2. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>distinct l;\n                 \\<forall>(k, v)\\<in>set l.\n                    \\<forall>(k', v')\\<in>set l.\n                       k = k' \\<longrightarrow> v = v'\\<rbrakk>\n                \\<Longrightarrow> distinct (map fst l);\n        distinct (a # l);\n        \\<forall>(k, v)\\<in>set (a # l).\n           \\<forall>(k', v')\\<in>set (a # l).\n              k = k' \\<longrightarrow> v = v'\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst (a # l))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>\\<lbrakk>distinct l;\n                 \\<forall>(k, v)\\<in>set l.\n                    \\<forall>(k', v')\\<in>set l.\n                       k = k' \\<longrightarrow> v = v'\\<rbrakk>\n                \\<Longrightarrow> distinct (map fst l);\n        distinct (a # l);\n        \\<forall>(k, v)\\<in>set (a # l).\n           \\<forall>(k', v')\\<in>set (a # l).\n              k = k' \\<longrightarrow> v = v'\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst (a # l))", "apply force"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  distinct (map fst l)\n\ngoal (1 subgoal):\n 1. foldli l c f \\<sigma> = result m", "with \\<open>set l = map_to_set m\\<close>"], ["proof (chain)\npicking this:\n  set l = map_to_set m\n  distinct (map fst l)", "have [simp]: \"m = map_of l\""], ["proof (prove)\nusing this:\n  set l = map_to_set m\n  distinct (map fst l)\n\ngoal (1 subgoal):\n 1. m = map_of l", "by (metis map_of_map_to_set)"], ["proof (state)\nthis:\n  m = map_of l\n\ngoal (1 subgoal):\n 1. foldli l c f \\<sigma> = result m", "from 1[OF DF SORTED]"], ["proof (chain)\npicking this:\n  foldli l c f \\<sigma> = result (map_of l)", "show ?thesis"], ["proof (prove)\nusing this:\n  foldli l c f \\<sigma> = result (map_of l)\n\ngoal (1 subgoal):\n 1. foldli l c f \\<sigma> = result m", "by simp"], ["proof (state)\nthis:\n  foldli l c f \\<sigma> = result m\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Template lemma for generic algorithm using map iterator\\<close>"], ["", "lemma det_fold_sorted_map:\n    assumes 1: \"det_fold_map ordR c' f' \\<sigma>' result\"\n    assumes 2: \"is_map_to_sorted_list ordR Rk Rv Rm tsl\"\n    assumes MREF[param]: \"(m,m')\\<in>\\<langle>Rk,Rv\\<rangle>Rm\"\n    assumes [param]:  \"(c,c')\\<in>R\\<sigma>\\<rightarrow>Id\"\n    assumes [param]: \"(f,f')\\<in>\\<langle>Rk,Rv\\<rangle>prod_rel \\<rightarrow> R\\<sigma> \\<rightarrow> R\\<sigma>\"\n    assumes [param]: \"(\\<sigma>,\\<sigma>')\\<in>R\\<sigma>\"\n    shows \"(foldli (tsl m) c f \\<sigma>, result m') \\<in> R\\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (foldli (tsl m) c f \\<sigma>, result m') \\<in> R\\<sigma>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (foldli (tsl m) c f \\<sigma>, result m') \\<in> R\\<sigma>", "obtain tsl' where\n      [param]: \"(tsl m,tsl') \\<in> \\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel\" \n      and IT: \"RETURN tsl' \\<le> it_to_sorted_list (key_rel ordR) (map_to_set m')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>tsl'.\n        \\<lbrakk>(tsl m, tsl')\n                 \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel;\n         RETURN tsl'\n         \\<le> it_to_sorted_list (key_rel ordR) (map_to_set m')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using 2 MREF"], ["proof (prove)\nusing this:\n  is_map_to_sorted_list ordR Rk Rv Rm tsl\n  (m, m') \\<in> \\<langle>Rk, Rv\\<rangle>Rm\n\ngoal (1 subgoal):\n 1. (\\<And>tsl'.\n        \\<lbrakk>(tsl m, tsl')\n                 \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel;\n         RETURN tsl'\n         \\<le> it_to_sorted_list (key_rel ordR) (map_to_set m')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule is_map_to_sorted_listE)"], ["proof (state)\nthis:\n  (tsl m, tsl') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n  RETURN tsl' \\<le> it_to_sorted_list (key_rel ordR) (map_to_set m')\n\ngoal (1 subgoal):\n 1. (foldli (tsl m) c f \\<sigma>, result m') \\<in> R\\<sigma>", "have \"(foldli (tsl m) c f \\<sigma>, foldli tsl' c' f' \\<sigma>') \\<in> R\\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (foldli (tsl m) c f \\<sigma>, foldli tsl' c' f' \\<sigma>')\n    \\<in> R\\<sigma>", "by parametricity"], ["proof (state)\nthis:\n  (foldli (tsl m) c f \\<sigma>, foldli tsl' c' f' \\<sigma>') \\<in> R\\<sigma>\n\ngoal (1 subgoal):\n 1. (foldli (tsl m) c f \\<sigma>, result m') \\<in> R\\<sigma>", "also"], ["proof (state)\nthis:\n  (foldli (tsl m) c f \\<sigma>, foldli tsl' c' f' \\<sigma>') \\<in> R\\<sigma>\n\ngoal (1 subgoal):\n 1. (foldli (tsl m) c f \\<sigma>, result m') \\<in> R\\<sigma>", "have \"foldli tsl' c' f' \\<sigma>' = result m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli tsl' c' f' \\<sigma>' = result m'", "using det_fold_map_aux[of tsl' ordR c' f' \\<sigma>' result] 1 IT"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<lbrakk>distinct (map fst tsl');\n            sorted_wrt (key_rel ordR) tsl'\\<rbrakk>\n           \\<Longrightarrow> foldli tsl' c' f' \\<sigma>' =\n                             result (map_of tsl');\n   RETURN tsl'\n   \\<le> it_to_sorted_list (key_rel ordR) (map_to_set ?m)\\<rbrakk>\n  \\<Longrightarrow> foldli tsl' c' f' \\<sigma>' = result ?m\n  det_fold_map ordR c' f' \\<sigma>' result\n  RETURN tsl' \\<le> it_to_sorted_list (key_rel ordR) (map_to_set m')\n\ngoal (1 subgoal):\n 1. foldli tsl' c' f' \\<sigma>' = result m'", "unfolding det_fold_map_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<lbrakk>distinct (map fst tsl');\n            sorted_wrt (key_rel ordR) tsl'\\<rbrakk>\n           \\<Longrightarrow> foldli tsl' c' f' \\<sigma>' =\n                             result (map_of tsl');\n   RETURN tsl'\n   \\<le> it_to_sorted_list (key_rel ordR) (map_to_set ?m)\\<rbrakk>\n  \\<Longrightarrow> foldli tsl' c' f' \\<sigma>' = result ?m\n  \\<forall>l.\n     distinct (map fst l) \\<and>\n     sorted_wrt (key_rel ordR) l \\<longrightarrow>\n     foldli l c' f' \\<sigma>' = result (map_of l)\n  RETURN tsl' \\<le> it_to_sorted_list (key_rel ordR) (map_to_set m')\n\ngoal (1 subgoal):\n 1. foldli tsl' c' f' \\<sigma>' = result m'", "by clarsimp"], ["proof (state)\nthis:\n  foldli tsl' c' f' \\<sigma>' = result m'\n\ngoal (1 subgoal):\n 1. (foldli (tsl m) c f \\<sigma>, result m') \\<in> R\\<sigma>", "finally"], ["proof (chain)\npicking this:\n  (foldli (tsl m) c f \\<sigma>, result m') \\<in> R\\<sigma>", "show ?thesis"], ["proof (prove)\nusing this:\n  (foldli (tsl m) c f \\<sigma>, result m') \\<in> R\\<sigma>\n\ngoal (1 subgoal):\n 1. (foldli (tsl m) c f \\<sigma>, result m') \\<in> R\\<sigma>", "."], ["proof (state)\nthis:\n  (foldli (tsl m) c f \\<sigma>, result m') \\<in> R\\<sigma>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma det_fold_map:\n    assumes \"det_fold_map (\\<lambda>_ _. True) c' f' \\<sigma>' result\"\n    assumes \"is_map_to_list Rk Rv Rm tsl\"\n    assumes \"(m,m')\\<in>\\<langle>Rk,Rv\\<rangle>Rm\"\n    assumes \"(c,c')\\<in>R\\<sigma>\\<rightarrow>Id\"\n    assumes \"(f,f')\\<in>\\<langle>Rk,Rv\\<rangle>prod_rel \\<rightarrow> R\\<sigma> \\<rightarrow> R\\<sigma>\"\n    assumes \"(\\<sigma>,\\<sigma>')\\<in>R\\<sigma>\"\n    shows \"(foldli (tsl m) c f \\<sigma>, result m') \\<in> R\\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (foldli (tsl m) c f \\<sigma>, result m') \\<in> R\\<sigma>", "using assms"], ["proof (prove)\nusing this:\n  det_fold_map (\\<lambda>_ _. True) c' f' \\<sigma>' result\n  is_map_to_list Rk Rv Rm tsl\n  (m, m') \\<in> \\<langle>Rk, Rv\\<rangle>Rm\n  (c, c') \\<in> R\\<sigma> \\<rightarrow> bool_rel\n  (f, f')\n  \\<in> Rk \\<times>\\<^sub>r Rv \\<rightarrow>\n        R\\<sigma> \\<rightarrow> R\\<sigma>\n  (\\<sigma>, \\<sigma>') \\<in> R\\<sigma>\n\ngoal (1 subgoal):\n 1. (foldli (tsl m) c f \\<sigma>, result m') \\<in> R\\<sigma>", "unfolding is_map_to_list_def"], ["proof (prove)\nusing this:\n  det_fold_map (\\<lambda>_ _. True) c' f' \\<sigma>' result\n  is_map_to_sorted_list (\\<lambda>_ _. True) Rk Rv Rm tsl\n  (m, m') \\<in> \\<langle>Rk, Rv\\<rangle>Rm\n  (c, c') \\<in> R\\<sigma> \\<rightarrow> bool_rel\n  (f, f')\n  \\<in> Rk \\<times>\\<^sub>r Rv \\<rightarrow>\n        R\\<sigma> \\<rightarrow> R\\<sigma>\n  (\\<sigma>, \\<sigma>') \\<in> R\\<sigma>\n\ngoal (1 subgoal):\n 1. (foldli (tsl m) c f \\<sigma>, result m') \\<in> R\\<sigma>", "by (rule det_fold_sorted_map)"], ["", "lemma set_to_sorted_list_by_tsl[autoref_rules]:\n  assumes \"MINOR_PRIO_TAG (- 11)\"\n  assumes TSL: \"SIDE_GEN_ALGO (is_set_to_sorted_list R Rk Rs tsl)\"\n  shows \"(\\<lambda>s. RETURN (tsl s), set_to_sorted_list R) \n    \\<in> \\<langle>Rk\\<rangle>Rs \\<rightarrow> \\<langle>\\<langle>Rk\\<rangle>list_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>s. RETURN (tsl s), set_to_sorted_list R)\n    \\<in> \\<langle>Rk\\<rangle>Rs \\<rightarrow>\n          \\<langle>\\<langle>Rk\\<rangle>list_rel\\<rangle>nres_rel", "proof (intro fun_relI nres_relI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk\\<rangle>Rs \\<Longrightarrow>\n       RETURN (tsl a)\n       \\<le> \\<Down> (\\<langle>Rk\\<rangle>list_rel)\n              (set_to_sorted_list R a')", "fix s s'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk\\<rangle>Rs \\<Longrightarrow>\n       RETURN (tsl a)\n       \\<le> \\<Down> (\\<langle>Rk\\<rangle>list_rel)\n              (set_to_sorted_list R a')", "assume \"(s,s')\\<in>\\<langle>Rk\\<rangle>Rs\""], ["proof (state)\nthis:\n  (s, s') \\<in> \\<langle>Rk\\<rangle>Rs\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk\\<rangle>Rs \\<Longrightarrow>\n       RETURN (tsl a)\n       \\<le> \\<Down> (\\<langle>Rk\\<rangle>list_rel)\n              (set_to_sorted_list R a')", "with TSL"], ["proof (chain)\npicking this:\n  SIDE_GEN_ALGO (is_set_to_sorted_list R Rk Rs tsl)\n  (s, s') \\<in> \\<langle>Rk\\<rangle>Rs", "obtain l' where \n    R1: \"(tsl s, l') \\<in> \\<langle>Rk\\<rangle>list_rel\" \n      and R2: \"RETURN l' \\<le> set_to_sorted_list R s'\""], ["proof (prove)\nusing this:\n  SIDE_GEN_ALGO (is_set_to_sorted_list R Rk Rs tsl)\n  (s, s') \\<in> \\<langle>Rk\\<rangle>Rs\n\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>(tsl s, l') \\<in> \\<langle>Rk\\<rangle>list_rel;\n         RETURN l' \\<le> set_to_sorted_list R s'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding is_set_to_sorted_list_def set_to_sorted_list_def autoref_tag_defs"], ["proof (prove)\nusing this:\n  \\<forall>s s'.\n     (s, s') \\<in> \\<langle>Rk\\<rangle>Rs \\<longrightarrow>\n     (\\<exists>l'.\n         (tsl s, l') \\<in> \\<langle>Rk\\<rangle>list_rel \\<and>\n         RETURN l' \\<le> it_to_sorted_list R s')\n  (s, s') \\<in> \\<langle>Rk\\<rangle>Rs\n\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>(tsl s, l') \\<in> \\<langle>Rk\\<rangle>list_rel;\n         RETURN l' \\<le> it_to_sorted_list R s'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (tsl s, l') \\<in> \\<langle>Rk\\<rangle>list_rel\n  RETURN l' \\<le> set_to_sorted_list R s'\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk\\<rangle>Rs \\<Longrightarrow>\n       RETURN (tsl a)\n       \\<le> \\<Down> (\\<langle>Rk\\<rangle>list_rel)\n              (set_to_sorted_list R a')", "have \"RETURN (tsl s) \\<le> \\<Down>(\\<langle>Rk\\<rangle>list_rel) (RETURN l')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN (tsl s) \\<le> \\<Down> (\\<langle>Rk\\<rangle>list_rel) (RETURN l')", "by (rule RETURN_refine) fact"], ["proof (state)\nthis:\n  RETURN (tsl s) \\<le> \\<Down> (\\<langle>Rk\\<rangle>list_rel) (RETURN l')\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk\\<rangle>Rs \\<Longrightarrow>\n       RETURN (tsl a)\n       \\<le> \\<Down> (\\<langle>Rk\\<rangle>list_rel)\n              (set_to_sorted_list R a')", "also"], ["proof (state)\nthis:\n  RETURN (tsl s) \\<le> \\<Down> (\\<langle>Rk\\<rangle>list_rel) (RETURN l')\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk\\<rangle>Rs \\<Longrightarrow>\n       RETURN (tsl a)\n       \\<le> \\<Down> (\\<langle>Rk\\<rangle>list_rel)\n              (set_to_sorted_list R a')", "note R2"], ["proof (state)\nthis:\n  RETURN l' \\<le> set_to_sorted_list R s'\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk\\<rangle>Rs \\<Longrightarrow>\n       RETURN (tsl a)\n       \\<le> \\<Down> (\\<langle>Rk\\<rangle>list_rel)\n              (set_to_sorted_list R a')", "finally"], ["proof (chain)\npicking this:\n  RETURN (tsl s)\n  \\<le> \\<Down> (\\<langle>Rk\\<rangle>list_rel) (set_to_sorted_list R s')", "show \"RETURN (tsl s) \\<le> \\<Down> (\\<langle>Rk\\<rangle>list_rel) (set_to_sorted_list R s')\""], ["proof (prove)\nusing this:\n  RETURN (tsl s)\n  \\<le> \\<Down> (\\<langle>Rk\\<rangle>list_rel) (set_to_sorted_list R s')\n\ngoal (1 subgoal):\n 1. RETURN (tsl s)\n    \\<le> \\<Down> (\\<langle>Rk\\<rangle>list_rel) (set_to_sorted_list R s')", "."], ["proof (state)\nthis:\n  RETURN (tsl s)\n  \\<le> \\<Down> (\\<langle>Rk\\<rangle>list_rel) (set_to_sorted_list R s')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_to_list_by_tsl[autoref_rules]:\n  assumes \"MINOR_PRIO_TAG (- 10)\"\n  assumes TSL: \"SIDE_GEN_ALGO (is_set_to_list Rk Rs tsl)\"\n  shows \"(\\<lambda>s. RETURN (tsl s), set_to_sorted_list (\\<lambda>_ _. True)) \n    \\<in> \\<langle>Rk\\<rangle>Rs \\<rightarrow> \\<langle>\\<langle>Rk\\<rangle>list_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>s. RETURN (tsl s), set_to_sorted_list (\\<lambda>_ _. True))\n    \\<in> \\<langle>Rk\\<rangle>Rs \\<rightarrow>\n          \\<langle>\\<langle>Rk\\<rangle>list_rel\\<rangle>nres_rel", "using assms(2-)"], ["proof (prove)\nusing this:\n  SIDE_GEN_ALGO (is_set_to_list Rk Rs tsl)\n\ngoal (1 subgoal):\n 1. (\\<lambda>s. RETURN (tsl s), set_to_sorted_list (\\<lambda>_ _. True))\n    \\<in> \\<langle>Rk\\<rangle>Rs \\<rightarrow>\n          \\<langle>\\<langle>Rk\\<rangle>list_rel\\<rangle>nres_rel", "unfolding is_set_to_list_def"], ["proof (prove)\nusing this:\n  SIDE_GEN_ALGO (is_set_to_sorted_list (\\<lambda>_ _. True) Rk Rs tsl)\n\ngoal (1 subgoal):\n 1. (\\<lambda>s. RETURN (tsl s), set_to_sorted_list (\\<lambda>_ _. True))\n    \\<in> \\<langle>Rk\\<rangle>Rs \\<rightarrow>\n          \\<langle>\\<langle>Rk\\<rangle>list_rel\\<rangle>nres_rel", "by (rule set_to_sorted_list_by_tsl[OF PRIO_TAGI])"], ["", "lemma map_to_sorted_list_by_tsl[autoref_rules]:\n  assumes \"MINOR_PRIO_TAG (- 11)\"\n  assumes TSL: \"SIDE_GEN_ALGO (is_map_to_sorted_list R Rk Rv Rs tsl)\"\n  shows \"(\\<lambda>s. RETURN (tsl s), map_to_sorted_list R) \n    \\<in> \\<langle>Rk,Rv\\<rangle>Rs \\<rightarrow> \\<langle>\\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>s. RETURN (tsl s), map_to_sorted_list R)\n    \\<in> \\<langle>Rk, Rv\\<rangle>Rs \\<rightarrow>\n          \\<langle>\\<langle>Rk \\<times>\\<^sub>r\n                            Rv\\<rangle>list_rel\\<rangle>nres_rel", "proof (intro fun_relI nres_relI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk, Rv\\<rangle>Rs \\<Longrightarrow>\n       RETURN (tsl a)\n       \\<le> \\<Down> (\\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel)\n              (map_to_sorted_list R a')", "fix s s'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk, Rv\\<rangle>Rs \\<Longrightarrow>\n       RETURN (tsl a)\n       \\<le> \\<Down> (\\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel)\n              (map_to_sorted_list R a')", "assume \"(s,s')\\<in>\\<langle>Rk,Rv\\<rangle>Rs\""], ["proof (state)\nthis:\n  (s, s') \\<in> \\<langle>Rk, Rv\\<rangle>Rs\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk, Rv\\<rangle>Rs \\<Longrightarrow>\n       RETURN (tsl a)\n       \\<le> \\<Down> (\\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel)\n              (map_to_sorted_list R a')", "with TSL"], ["proof (chain)\npicking this:\n  SIDE_GEN_ALGO (is_map_to_sorted_list R Rk Rv Rs tsl)\n  (s, s') \\<in> \\<langle>Rk, Rv\\<rangle>Rs", "obtain l' where \n    R1: \"(tsl s, l') \\<in> \\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel\" \n      and R2: \"RETURN l' \\<le> map_to_sorted_list R s'\""], ["proof (prove)\nusing this:\n  SIDE_GEN_ALGO (is_map_to_sorted_list R Rk Rv Rs tsl)\n  (s, s') \\<in> \\<langle>Rk, Rv\\<rangle>Rs\n\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>(tsl s, l')\n                 \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel;\n         RETURN l' \\<le> map_to_sorted_list R s'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding is_map_to_sorted_list_def map_to_sorted_list_def autoref_tag_defs"], ["proof (prove)\nusing this:\n  \\<forall>m m'.\n     (m, m') \\<in> \\<langle>Rk, Rv\\<rangle>Rs \\<longrightarrow>\n     (\\<exists>l'.\n         (tsl m, l')\n         \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel \\<and>\n         RETURN l' \\<le> it_to_sorted_list (key_rel R) (map_to_set m'))\n  (s, s') \\<in> \\<langle>Rk, Rv\\<rangle>Rs\n\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>(tsl s, l')\n                 \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel;\n         RETURN l'\n         \\<le> it_to_sorted_list (key_rel R) (map_to_set s')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (tsl s, l') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n  RETURN l' \\<le> map_to_sorted_list R s'\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk, Rv\\<rangle>Rs \\<Longrightarrow>\n       RETURN (tsl a)\n       \\<le> \\<Down> (\\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel)\n              (map_to_sorted_list R a')", "have \"RETURN (tsl s) \\<le> \\<Down>(\\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel) (RETURN l')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN (tsl s)\n    \\<le> \\<Down> (\\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel)\n           (RETURN l')", "apply (rule RETURN_refine)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (tsl s, l') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel", "by fact"], ["proof (state)\nthis:\n  RETURN (tsl s)\n  \\<le> \\<Down> (\\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel)\n         (RETURN l')\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk, Rv\\<rangle>Rs \\<Longrightarrow>\n       RETURN (tsl a)\n       \\<le> \\<Down> (\\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel)\n              (map_to_sorted_list R a')", "also"], ["proof (state)\nthis:\n  RETURN (tsl s)\n  \\<le> \\<Down> (\\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel)\n         (RETURN l')\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk, Rv\\<rangle>Rs \\<Longrightarrow>\n       RETURN (tsl a)\n       \\<le> \\<Down> (\\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel)\n              (map_to_sorted_list R a')", "note R2"], ["proof (state)\nthis:\n  RETURN l' \\<le> map_to_sorted_list R s'\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       (a, a') \\<in> \\<langle>Rk, Rv\\<rangle>Rs \\<Longrightarrow>\n       RETURN (tsl a)\n       \\<le> \\<Down> (\\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel)\n              (map_to_sorted_list R a')", "finally"], ["proof (chain)\npicking this:\n  RETURN (tsl s)\n  \\<le> \\<Down> (\\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel)\n         (map_to_sorted_list R s')", "show \n    \"RETURN (tsl s) \\<le> \\<Down> (\\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel) (map_to_sorted_list R s')\""], ["proof (prove)\nusing this:\n  RETURN (tsl s)\n  \\<le> \\<Down> (\\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel)\n         (map_to_sorted_list R s')\n\ngoal (1 subgoal):\n 1. RETURN (tsl s)\n    \\<le> \\<Down> (\\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel)\n           (map_to_sorted_list R s')", "."], ["proof (state)\nthis:\n  RETURN (tsl s)\n  \\<le> \\<Down> (\\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel)\n         (map_to_sorted_list R s')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_to_list_by_tsl[autoref_rules]:\n  assumes \"MINOR_PRIO_TAG (- 10)\"\n  assumes TSL: \"SIDE_GEN_ALGO (is_map_to_list Rk Rv Rs tsl)\"\n  shows \"(\\<lambda>s. RETURN (tsl s), map_to_sorted_list (\\<lambda>_ _. True)) \n    \\<in> \\<langle>Rk,Rv\\<rangle>Rs \\<rightarrow> \\<langle>\\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel\\<rangle>nres_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>s. RETURN (tsl s), map_to_sorted_list (\\<lambda>_ _. True))\n    \\<in> \\<langle>Rk, Rv\\<rangle>Rs \\<rightarrow>\n          \\<langle>\\<langle>Rk \\<times>\\<^sub>r\n                            Rv\\<rangle>list_rel\\<rangle>nres_rel", "using assms(2-)"], ["proof (prove)\nusing this:\n  SIDE_GEN_ALGO (is_map_to_list Rk Rv Rs tsl)\n\ngoal (1 subgoal):\n 1. (\\<lambda>s. RETURN (tsl s), map_to_sorted_list (\\<lambda>_ _. True))\n    \\<in> \\<langle>Rk, Rv\\<rangle>Rs \\<rightarrow>\n          \\<langle>\\<langle>Rk \\<times>\\<^sub>r\n                            Rv\\<rangle>list_rel\\<rangle>nres_rel", "unfolding is_map_to_list_def"], ["proof (prove)\nusing this:\n  SIDE_GEN_ALGO (is_map_to_sorted_list (\\<lambda>_ _. True) Rk Rv Rs tsl)\n\ngoal (1 subgoal):\n 1. (\\<lambda>s. RETURN (tsl s), map_to_sorted_list (\\<lambda>_ _. True))\n    \\<in> \\<langle>Rk, Rv\\<rangle>Rs \\<rightarrow>\n          \\<langle>\\<langle>Rk \\<times>\\<^sub>r\n                            Rv\\<rangle>list_rel\\<rangle>nres_rel", "by (rule map_to_sorted_list_by_tsl[OF PRIO_TAGI])"], ["", "(*lemma dres_it_FOREACH_it_simp[iterator_simps]: \n  \"dres_it_FOREACH (\\<lambda>s. dRETURN (i s)) s c f \\<sigma> \n    = foldli (i s) (case_dres False False c) (\\<lambda>x s. s \\<bind> f x) (dRETURN \\<sigma>)\"\n  unfolding dres_it_FOREACH_def\n  by simp\n*)"], ["", "text \\<open>\n  TODO/FIXME: \n    * Integrate mono-prover properly into solver-infrastructure,\n        i.e. tag a mono-goal.\n    * Tag iterators, such that, for the mono-prover, we can just convert\n        a proper iterator back to its foldli-equivalent!\n\\<close>"], ["", "lemma proper_it_mono_dres_pair:\n  assumes PR: \"proper_it' it it'\"\n  assumes A: \"\\<And>k v x. f k v x \\<le> f' k v x\"\n  shows \"\n    it' s (case_dres False False c) (\\<lambda>(k,v) s. s \\<bind> f k v) \\<sigma>\n    \\<le> it' s (case_dres False False c) (\\<lambda>(k,v) s. s \\<bind> f' k v) \\<sigma>\" (is \"?a \\<le> ?b\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. it' s (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f k v)\n     \\<sigma>\n    \\<le> it' s (case_dres False False c)\n           (\\<lambda>(k, v) s. s \\<bind> f' k v) \\<sigma>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. it' s (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f k v)\n     \\<sigma>\n    \\<le> it' s (case_dres False False c)\n           (\\<lambda>(k, v) s. s \\<bind> f' k v) \\<sigma>", "from proper_itE[OF PR[THEN proper_it'D]]"], ["proof (chain)\npicking this:\n  (\\<And>l.\n      \\<lbrakk>it ?s1 = foldli l; it' ?s1 = foldli l\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain l where \n    A_FMT: \n      \"?a = foldli l (case_dres False False c) (\\<lambda>(k,v) s. s \\<bind> f k v) \\<sigma>\" \n        (is \"_ = ?a'\")\n    and B_FMT: \n      \"?b = foldli l (case_dres False False c) (\\<lambda>(k,v) s. s \\<bind> f' k v) \\<sigma>\" \n        (is \"_ = ?b'\")"], ["proof (prove)\nusing this:\n  (\\<And>l.\n      \\<lbrakk>it ?s1 = foldli l; it' ?s1 = foldli l\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>it' s (case_dres False False c)\n                  (\\<lambda>(k, v) s. s \\<bind> f k v) \\<sigma> =\n                 foldli l (case_dres False False c)\n                  (\\<lambda>(k, v) s. s \\<bind> f k v) \\<sigma>;\n         it' s (case_dres False False c)\n          (\\<lambda>(k, v) s. s \\<bind> f' k v) \\<sigma> =\n         foldli l (case_dres False False c)\n          (\\<lambda>(k, v) s. s \\<bind> f' k v) \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  it' s (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f k v)\n   \\<sigma> =\n  foldli l (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f k v)\n   \\<sigma>\n  it' s (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f' k v)\n   \\<sigma> =\n  foldli l (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f' k v)\n   \\<sigma>\n\ngoal (1 subgoal):\n 1. it' s (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f k v)\n     \\<sigma>\n    \\<le> it' s (case_dres False False c)\n           (\\<lambda>(k, v) s. s \\<bind> f' k v) \\<sigma>", "from A"], ["proof (chain)\npicking this:\n  f ?k ?v ?x \\<le> f' ?k ?v ?x", "have A': \"\\<And>kv x. case_prod f kv x \\<le> case_prod f' kv x\""], ["proof (prove)\nusing this:\n  f ?k ?v ?x \\<le> f' ?k ?v ?x\n\ngoal (1 subgoal):\n 1. \\<And>kv x.\n       (case kv of (x, xa) \\<Rightarrow> f x xa) x\n       \\<le> (case kv of (x, xa) \\<Rightarrow> f' x xa) x", "by auto"], ["proof (state)\nthis:\n  (case ?kv of (x, xa) \\<Rightarrow> f x xa) ?x\n  \\<le> (case ?kv of (x, xa) \\<Rightarrow> f' x xa) ?x\n\ngoal (1 subgoal):\n 1. it' s (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f k v)\n     \\<sigma>\n    \\<le> it' s (case_dres False False c)\n           (\\<lambda>(k, v) s. s \\<bind> f' k v) \\<sigma>", "note A_FMT"], ["proof (state)\nthis:\n  it' s (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f k v)\n   \\<sigma> =\n  foldli l (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f k v)\n   \\<sigma>\n\ngoal (1 subgoal):\n 1. it' s (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f k v)\n     \\<sigma>\n    \\<le> it' s (case_dres False False c)\n           (\\<lambda>(k, v) s. s \\<bind> f' k v) \\<sigma>", "also"], ["proof (state)\nthis:\n  it' s (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f k v)\n   \\<sigma> =\n  foldli l (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f k v)\n   \\<sigma>\n\ngoal (1 subgoal):\n 1. it' s (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f k v)\n     \\<sigma>\n    \\<le> it' s (case_dres False False c)\n           (\\<lambda>(k, v) s. s \\<bind> f' k v) \\<sigma>", "have \n    \"?a' = foldli l (case_dres False False c) (\\<lambda>kv s. s \\<bind> case_prod f kv) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli l (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f k v)\n     \\<sigma> =\n    foldli l (case_dres False False c)\n     (\\<lambda>kv s. s \\<bind> (case kv of (x, xa) \\<Rightarrow> f x xa))\n     \\<sigma>", "apply (fo_rule fun_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli l (case_dres False False c)\n     (\\<lambda>(k, v) s. s \\<bind> f k v) =\n    foldli l (case_dres False False c)\n     (\\<lambda>kv s. s \\<bind> (case kv of (x, xa) \\<Rightarrow> f x xa))", "apply (fo_rule arg_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(k, v) s. s \\<bind> f k v) =\n    (\\<lambda>kv s. s \\<bind> (case kv of (x, xa) \\<Rightarrow> f x xa))", "by auto"], ["proof (state)\nthis:\n  foldli l (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f k v)\n   \\<sigma> =\n  foldli l (case_dres False False c)\n   (\\<lambda>kv s. s \\<bind> (case kv of (x, xa) \\<Rightarrow> f x xa))\n   \\<sigma>\n\ngoal (1 subgoal):\n 1. it' s (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f k v)\n     \\<sigma>\n    \\<le> it' s (case_dres False False c)\n           (\\<lambda>(k, v) s. s \\<bind> f' k v) \\<sigma>", "also"], ["proof (state)\nthis:\n  foldli l (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f k v)\n   \\<sigma> =\n  foldli l (case_dres False False c)\n   (\\<lambda>kv s. s \\<bind> (case kv of (x, xa) \\<Rightarrow> f x xa))\n   \\<sigma>\n\ngoal (1 subgoal):\n 1. it' s (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f k v)\n     \\<sigma>\n    \\<le> it' s (case_dres False False c)\n           (\\<lambda>(k, v) s. s \\<bind> f' k v) \\<sigma>", "note foldli_mono_dres[OF A']"], ["proof (state)\nthis:\n  foldli ?l (case_dres False False ?c)\n   (\\<lambda>x s.\n       s \\<bind>\n       (\\<lambda>xa.\n           (case ?kv1 x xa of (x, xa) \\<Rightarrow> f x xa) (?x1 x xa)))\n   ?\\<sigma>\n  \\<le> foldli ?l (case_dres False False ?c)\n         (\\<lambda>x s.\n             s \\<bind>\n             (\\<lambda>xa.\n                 (case ?kv1 x xa of (x, xa) \\<Rightarrow> f' x xa)\n                  (?x1 x xa)))\n         ?\\<sigma>\n\ngoal (1 subgoal):\n 1. it' s (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f k v)\n     \\<sigma>\n    \\<le> it' s (case_dres False False c)\n           (\\<lambda>(k, v) s. s \\<bind> f' k v) \\<sigma>", "also"], ["proof (state)\nthis:\n  foldli ?l (case_dres False False ?c)\n   (\\<lambda>x s.\n       s \\<bind>\n       (\\<lambda>xa.\n           (case ?kv1 x xa of (x, xa) \\<Rightarrow> f x xa) (?x1 x xa)))\n   ?\\<sigma>\n  \\<le> foldli ?l (case_dres False False ?c)\n         (\\<lambda>x s.\n             s \\<bind>\n             (\\<lambda>xa.\n                 (case ?kv1 x xa of (x, xa) \\<Rightarrow> f' x xa)\n                  (?x1 x xa)))\n         ?\\<sigma>\n\ngoal (1 subgoal):\n 1. it' s (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f k v)\n     \\<sigma>\n    \\<le> it' s (case_dres False False c)\n           (\\<lambda>(k, v) s. s \\<bind> f' k v) \\<sigma>", "have \n    \"foldli l (case_dres False False c) (\\<lambda>kv s. s \\<bind> case_prod f' kv) \\<sigma> = ?b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli l (case_dres False False c)\n     (\\<lambda>kv s. s \\<bind> (case kv of (x, xa) \\<Rightarrow> f' x xa))\n     \\<sigma> =\n    foldli l (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f' k v)\n     \\<sigma>", "apply (fo_rule fun_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli l (case_dres False False c)\n     (\\<lambda>kv s. s \\<bind> (case kv of (x, xa) \\<Rightarrow> f' x xa)) =\n    foldli l (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f' k v)", "apply (fo_rule arg_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>kv s. s \\<bind> (case kv of (x, xa) \\<Rightarrow> f' x xa)) =\n    (\\<lambda>(k, v) s. s \\<bind> f' k v)", "by auto"], ["proof (state)\nthis:\n  foldli l (case_dres False False c)\n   (\\<lambda>kv s. s \\<bind> (case kv of (x, xa) \\<Rightarrow> f' x xa))\n   \\<sigma> =\n  foldli l (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f' k v)\n   \\<sigma>\n\ngoal (1 subgoal):\n 1. it' s (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f k v)\n     \\<sigma>\n    \\<le> it' s (case_dres False False c)\n           (\\<lambda>(k, v) s. s \\<bind> f' k v) \\<sigma>", "also"], ["proof (state)\nthis:\n  foldli l (case_dres False False c)\n   (\\<lambda>kv s. s \\<bind> (case kv of (x, xa) \\<Rightarrow> f' x xa))\n   \\<sigma> =\n  foldli l (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f' k v)\n   \\<sigma>\n\ngoal (1 subgoal):\n 1. it' s (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f k v)\n     \\<sigma>\n    \\<le> it' s (case_dres False False c)\n           (\\<lambda>(k, v) s. s \\<bind> f' k v) \\<sigma>", "note B_FMT[symmetric]"], ["proof (state)\nthis:\n  foldli l (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f' k v)\n   \\<sigma> =\n  it' s (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f' k v)\n   \\<sigma>\n\ngoal (1 subgoal):\n 1. it' s (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f k v)\n     \\<sigma>\n    \\<le> it' s (case_dres False False c)\n           (\\<lambda>(k, v) s. s \\<bind> f' k v) \\<sigma>", "finally"], ["proof (chain)\npicking this:\n  it' s (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f k v)\n   \\<sigma>\n  \\<le> it' s (case_dres False False c)\n         (\\<lambda>(k, v) s. s \\<bind> f' k v) \\<sigma>", "show ?thesis"], ["proof (prove)\nusing this:\n  it' s (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f k v)\n   \\<sigma>\n  \\<le> it' s (case_dres False False c)\n         (\\<lambda>(k, v) s. s \\<bind> f' k v) \\<sigma>\n\ngoal (1 subgoal):\n 1. it' s (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f k v)\n     \\<sigma>\n    \\<le> it' s (case_dres False False c)\n           (\\<lambda>(k, v) s. s \\<bind> f' k v) \\<sigma>", "."], ["proof (state)\nthis:\n  it' s (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f k v)\n   \\<sigma>\n  \\<le> it' s (case_dres False False c)\n         (\\<lambda>(k, v) s. s \\<bind> f' k v) \\<sigma>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proper_it_mono_dres_pair_flat:\n  assumes PR: \"proper_it' it it'\"\n  assumes A: \"\\<And>k v x. flat_ge (f k v x) (f' k v x)\"\n  shows \"\n    flat_ge (it' s (case_dres False False c) (\\<lambda>(k,v) s. s \\<bind> f k v) \\<sigma>)\n      (it' s (case_dres False False c) (\\<lambda>(k,v) s. s \\<bind> f' k v) \\<sigma>)\" \n      (is \"flat_ge ?a ?b\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. flat_ge\n     (it' s (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f k v)\n       \\<sigma>)\n     (it' s (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f' k v)\n       \\<sigma>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. flat_ge\n     (it' s (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f k v)\n       \\<sigma>)\n     (it' s (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f' k v)\n       \\<sigma>)", "from proper_itE[OF PR[THEN proper_it'D]]"], ["proof (chain)\npicking this:\n  (\\<And>l.\n      \\<lbrakk>it ?s1 = foldli l; it' ?s1 = foldli l\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain l where \n    A_FMT: \n      \"?a = foldli l (case_dres False False c) (\\<lambda>(k,v) s. s \\<bind> f k v) \\<sigma>\" \n        (is \"_ = ?a'\")\n    and B_FMT: \n      \"?b = foldli l (case_dres False False c) (\\<lambda>(k,v) s. s \\<bind> f' k v) \\<sigma>\" \n        (is \"_ = ?b'\")"], ["proof (prove)\nusing this:\n  (\\<And>l.\n      \\<lbrakk>it ?s1 = foldli l; it' ?s1 = foldli l\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>it' s (case_dres False False c)\n                  (\\<lambda>(k, v) s. s \\<bind> f k v) \\<sigma> =\n                 foldli l (case_dres False False c)\n                  (\\<lambda>(k, v) s. s \\<bind> f k v) \\<sigma>;\n         it' s (case_dres False False c)\n          (\\<lambda>(k, v) s. s \\<bind> f' k v) \\<sigma> =\n         foldli l (case_dres False False c)\n          (\\<lambda>(k, v) s. s \\<bind> f' k v) \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  it' s (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f k v)\n   \\<sigma> =\n  foldli l (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f k v)\n   \\<sigma>\n  it' s (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f' k v)\n   \\<sigma> =\n  foldli l (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f' k v)\n   \\<sigma>\n\ngoal (1 subgoal):\n 1. flat_ge\n     (it' s (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f k v)\n       \\<sigma>)\n     (it' s (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f' k v)\n       \\<sigma>)", "from A"], ["proof (chain)\npicking this:\n  flat_ge (f ?k ?v ?x) (f' ?k ?v ?x)", "have A': \"\\<And>kv x. flat_ge (case_prod f kv x) (case_prod f' kv x)\""], ["proof (prove)\nusing this:\n  flat_ge (f ?k ?v ?x) (f' ?k ?v ?x)\n\ngoal (1 subgoal):\n 1. \\<And>kv x.\n       flat_ge ((case kv of (x, xa) \\<Rightarrow> f x xa) x)\n        ((case kv of (x, xa) \\<Rightarrow> f' x xa) x)", "by auto"], ["proof (state)\nthis:\n  flat_ge ((case ?kv of (x, xa) \\<Rightarrow> f x xa) ?x)\n   ((case ?kv of (x, xa) \\<Rightarrow> f' x xa) ?x)\n\ngoal (1 subgoal):\n 1. flat_ge\n     (it' s (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f k v)\n       \\<sigma>)\n     (it' s (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f' k v)\n       \\<sigma>)", "note A_FMT"], ["proof (state)\nthis:\n  it' s (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f k v)\n   \\<sigma> =\n  foldli l (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f k v)\n   \\<sigma>\n\ngoal (1 subgoal):\n 1. flat_ge\n     (it' s (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f k v)\n       \\<sigma>)\n     (it' s (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f' k v)\n       \\<sigma>)", "also"], ["proof (state)\nthis:\n  it' s (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f k v)\n   \\<sigma> =\n  foldli l (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f k v)\n   \\<sigma>\n\ngoal (1 subgoal):\n 1. flat_ge\n     (it' s (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f k v)\n       \\<sigma>)\n     (it' s (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f' k v)\n       \\<sigma>)", "have \n    \"?a' = foldli l (case_dres False False c) (\\<lambda>kv s. s \\<bind> case_prod f kv) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli l (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f k v)\n     \\<sigma> =\n    foldli l (case_dres False False c)\n     (\\<lambda>kv s. s \\<bind> (case kv of (x, xa) \\<Rightarrow> f x xa))\n     \\<sigma>", "apply (fo_rule fun_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli l (case_dres False False c)\n     (\\<lambda>(k, v) s. s \\<bind> f k v) =\n    foldli l (case_dres False False c)\n     (\\<lambda>kv s. s \\<bind> (case kv of (x, xa) \\<Rightarrow> f x xa))", "apply (fo_rule arg_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>(k, v) s. s \\<bind> f k v) =\n    (\\<lambda>kv s. s \\<bind> (case kv of (x, xa) \\<Rightarrow> f x xa))", "by auto"], ["proof (state)\nthis:\n  foldli l (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f k v)\n   \\<sigma> =\n  foldli l (case_dres False False c)\n   (\\<lambda>kv s. s \\<bind> (case kv of (x, xa) \\<Rightarrow> f x xa))\n   \\<sigma>\n\ngoal (1 subgoal):\n 1. flat_ge\n     (it' s (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f k v)\n       \\<sigma>)\n     (it' s (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f' k v)\n       \\<sigma>)", "also"], ["proof (state)\nthis:\n  foldli l (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f k v)\n   \\<sigma> =\n  foldli l (case_dres False False c)\n   (\\<lambda>kv s. s \\<bind> (case kv of (x, xa) \\<Rightarrow> f x xa))\n   \\<sigma>\n\ngoal (1 subgoal):\n 1. flat_ge\n     (it' s (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f k v)\n       \\<sigma>)\n     (it' s (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f' k v)\n       \\<sigma>)", "note foldli_mono_dres_flat[OF A']"], ["proof (state)\nthis:\n  flat_ge\n   (foldli ?l (case_dres False False ?c)\n     (\\<lambda>x s.\n         s \\<bind>\n         (\\<lambda>xa.\n             (case ?kv1 x xa of (x, xa) \\<Rightarrow> f x xa) (?x1 x xa)))\n     ?\\<sigma>)\n   (foldli ?l (case_dres False False ?c)\n     (\\<lambda>x s.\n         s \\<bind>\n         (\\<lambda>xa.\n             (case ?kv1 x xa of (x, xa) \\<Rightarrow> f' x xa) (?x1 x xa)))\n     ?\\<sigma>)\n\ngoal (1 subgoal):\n 1. flat_ge\n     (it' s (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f k v)\n       \\<sigma>)\n     (it' s (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f' k v)\n       \\<sigma>)", "also"], ["proof (state)\nthis:\n  flat_ge\n   (foldli ?l (case_dres False False ?c)\n     (\\<lambda>x s.\n         s \\<bind>\n         (\\<lambda>xa.\n             (case ?kv1 x xa of (x, xa) \\<Rightarrow> f x xa) (?x1 x xa)))\n     ?\\<sigma>)\n   (foldli ?l (case_dres False False ?c)\n     (\\<lambda>x s.\n         s \\<bind>\n         (\\<lambda>xa.\n             (case ?kv1 x xa of (x, xa) \\<Rightarrow> f' x xa) (?x1 x xa)))\n     ?\\<sigma>)\n\ngoal (1 subgoal):\n 1. flat_ge\n     (it' s (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f k v)\n       \\<sigma>)\n     (it' s (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f' k v)\n       \\<sigma>)", "have \n    \"foldli l (case_dres False False c) (\\<lambda>kv s. s \\<bind> case_prod f' kv) \\<sigma> = ?b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli l (case_dres False False c)\n     (\\<lambda>kv s. s \\<bind> (case kv of (x, xa) \\<Rightarrow> f' x xa))\n     \\<sigma> =\n    foldli l (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f' k v)\n     \\<sigma>", "apply (fo_rule fun_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli l (case_dres False False c)\n     (\\<lambda>kv s. s \\<bind> (case kv of (x, xa) \\<Rightarrow> f' x xa)) =\n    foldli l (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f' k v)", "apply (fo_rule arg_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>kv s. s \\<bind> (case kv of (x, xa) \\<Rightarrow> f' x xa)) =\n    (\\<lambda>(k, v) s. s \\<bind> f' k v)", "by auto"], ["proof (state)\nthis:\n  foldli l (case_dres False False c)\n   (\\<lambda>kv s. s \\<bind> (case kv of (x, xa) \\<Rightarrow> f' x xa))\n   \\<sigma> =\n  foldli l (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f' k v)\n   \\<sigma>\n\ngoal (1 subgoal):\n 1. flat_ge\n     (it' s (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f k v)\n       \\<sigma>)\n     (it' s (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f' k v)\n       \\<sigma>)", "also"], ["proof (state)\nthis:\n  foldli l (case_dres False False c)\n   (\\<lambda>kv s. s \\<bind> (case kv of (x, xa) \\<Rightarrow> f' x xa))\n   \\<sigma> =\n  foldli l (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f' k v)\n   \\<sigma>\n\ngoal (1 subgoal):\n 1. flat_ge\n     (it' s (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f k v)\n       \\<sigma>)\n     (it' s (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f' k v)\n       \\<sigma>)", "note B_FMT[symmetric]"], ["proof (state)\nthis:\n  foldli l (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f' k v)\n   \\<sigma> =\n  it' s (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f' k v)\n   \\<sigma>\n\ngoal (1 subgoal):\n 1. flat_ge\n     (it' s (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f k v)\n       \\<sigma>)\n     (it' s (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f' k v)\n       \\<sigma>)", "finally"], ["proof (chain)\npicking this:\n  flat_ge\n   (it' s (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f k v)\n     \\<sigma>)\n   (it' s (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f' k v)\n     \\<sigma>)", "show ?thesis"], ["proof (prove)\nusing this:\n  flat_ge\n   (it' s (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f k v)\n     \\<sigma>)\n   (it' s (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f' k v)\n     \\<sigma>)\n\ngoal (1 subgoal):\n 1. flat_ge\n     (it' s (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f k v)\n       \\<sigma>)\n     (it' s (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f' k v)\n       \\<sigma>)", "."], ["proof (state)\nthis:\n  flat_ge\n   (it' s (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f k v)\n     \\<sigma>)\n   (it' s (case_dres False False c) (\\<lambda>(k, v) s. s \\<bind> f' k v)\n     \\<sigma>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma proper_it_mono_dres:\n  assumes PR: \"proper_it' it it'\"\n  assumes A: \"\\<And>kv x. f kv x \\<le> f' kv x\"\n  shows \"\n    it' s (case_dres False False c) (\\<lambda>kv s. s \\<bind> f kv) \\<sigma>\n    \\<le> it' s (case_dres False False c) (\\<lambda>kv s. s \\<bind> f' kv) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. it' s (case_dres False False c) (\\<lambda>kv s. s \\<bind> f kv) \\<sigma>\n    \\<le> it' s (case_dres False False c) (\\<lambda>kv s. s \\<bind> f' kv)\n           \\<sigma>", "apply (rule proper_itE[OF PR[THEN proper_it'D[where s=s]]])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>it s = foldli l; it' s = foldli l\\<rbrakk>\n       \\<Longrightarrow> it' s (case_dres False False c)\n                          (\\<lambda>kv s. s \\<bind> f kv) \\<sigma>\n                         \\<le> it' s (case_dres False False c)\n                                (\\<lambda>kv s. s \\<bind> f' kv) \\<sigma>", "apply (erule_tac t=\"it' s\" in ssubst)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l.\n       it s = foldli l \\<Longrightarrow>\n       foldli l\n        (\\<lambda>a.\n            case a of dRETURN a \\<Rightarrow> c a | _ \\<Rightarrow> False)\n        (\\<lambda>a aa. aa \\<bind> f a) \\<sigma>\n       \\<le> foldli l\n              (\\<lambda>a.\n                  case a of dRETURN a \\<Rightarrow> c a\n                  | _ \\<Rightarrow> False)\n              (\\<lambda>a aa. aa \\<bind> f' a) \\<sigma>", "apply (rule foldli_mono_dres[OF A])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma proper_it_mono_dres_flat:\n  assumes PR: \"proper_it' it it'\"\n  assumes A: \"\\<And>kv x. flat_ge (f kv x) (f' kv x)\"\n  shows \"\n    flat_ge (it' s (case_dres False False c) (\\<lambda>kv s. s \\<bind> f kv) \\<sigma>)\n      (it' s (case_dres False False c) (\\<lambda>kv s. s \\<bind> f' kv) \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flat_ge\n     (it' s (case_dres False False c) (\\<lambda>kv s. s \\<bind> f kv)\n       \\<sigma>)\n     (it' s (case_dres False False c) (\\<lambda>kv s. s \\<bind> f' kv)\n       \\<sigma>)", "apply (rule proper_itE[OF PR[THEN proper_it'D[where s=s]]])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>it s = foldli l; it' s = foldli l\\<rbrakk>\n       \\<Longrightarrow> flat_ge\n                          (it' s (case_dres False False c)\n                            (\\<lambda>kv s. s \\<bind> f kv) \\<sigma>)\n                          (it' s (case_dres False False c)\n                            (\\<lambda>kv s. s \\<bind> f' kv) \\<sigma>)", "apply (erule_tac t=\"it' s\" in ssubst)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l.\n       it s = foldli l \\<Longrightarrow>\n       flat_ge\n        (foldli l\n          (\\<lambda>a.\n              case a of dRETURN a \\<Rightarrow> c a | _ \\<Rightarrow> False)\n          (\\<lambda>a aa. aa \\<bind> f a) \\<sigma>)\n        (foldli l\n          (\\<lambda>a.\n              case a of dRETURN a \\<Rightarrow> c a | _ \\<Rightarrow> False)\n          (\\<lambda>a aa. aa \\<bind> f' a) \\<sigma>)", "apply (rule foldli_mono_dres_flat[OF A])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma pi'_dom[icf_proper_iteratorI]: \"proper_it' it it' \n  \\<Longrightarrow> proper_it' (map_iterator_dom o it) (map_iterator_dom o it')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it' it it' \\<Longrightarrow>\n    proper_it' (map_iterator_dom \\<circ> it) (map_iterator_dom \\<circ> it')", "apply (rule proper_it'I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       proper_it' it it' \\<Longrightarrow>\n       proper_it ((map_iterator_dom \\<circ> it) s)\n        ((map_iterator_dom \\<circ> it') s)", "apply (simp add: comp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       proper_it' it it' \\<Longrightarrow>\n       proper_it (map_iterator_dom (it s)) (map_iterator_dom (it' s))", "apply (rule icf_proper_iteratorI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s. proper_it' it it' \\<Longrightarrow> proper_it (it s) (it' s)", "apply (erule proper_it'D)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma proper_it_mono_dres_dom:\n  assumes PR: \"proper_it' it it'\"\n  assumes A: \"\\<And>kv x. f kv x \\<le> f' kv x\"\n  shows \"\n    (map_iterator_dom o it') s (case_dres False False c) (\\<lambda>kv s. s \\<bind> f kv) \\<sigma>\n    \\<le> \n    (map_iterator_dom o it') s (case_dres False False c) (\\<lambda>kv s. s \\<bind> f' kv) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map_iterator_dom \\<circ> it') s (case_dres False False c)\n     (\\<lambda>kv s. s \\<bind> f kv) \\<sigma>\n    \\<le> (map_iterator_dom \\<circ> it') s (case_dres False False c)\n           (\\<lambda>kv s. s \\<bind> f' kv) \\<sigma>", "apply (rule proper_it_mono_dres)"], ["proof (prove)\ngoal (2 subgoals):\n 1. proper_it' ?it (map_iterator_dom \\<circ> it')\n 2. \\<And>kv x. f kv x \\<le> f' kv x", "apply (rule icf_proper_iteratorI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. proper_it' ?it12 it'\n 2. \\<And>kv x. f kv x \\<le> f' kv x", "by fact+"], ["", "lemma proper_it_mono_dres_dom_flat:\n  assumes PR: \"proper_it' it it'\"\n  assumes A: \"\\<And>kv x. flat_ge (f kv x) (f' kv x)\"\n  shows \"flat_ge \n    ((map_iterator_dom o it') s (case_dres False False c) (\\<lambda>kv s. s \\<bind> f kv) \\<sigma>)\n    ((map_iterator_dom o it') s (case_dres False False c) (\\<lambda>kv s. s \\<bind> f' kv) \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flat_ge\n     ((map_iterator_dom \\<circ> it') s (case_dres False False c)\n       (\\<lambda>kv s. s \\<bind> f kv) \\<sigma>)\n     ((map_iterator_dom \\<circ> it') s (case_dres False False c)\n       (\\<lambda>kv s. s \\<bind> f' kv) \\<sigma>)", "apply (rule proper_it_mono_dres_flat)"], ["proof (prove)\ngoal (2 subgoals):\n 1. proper_it' ?it (map_iterator_dom \\<circ> it')\n 2. \\<And>kv x. flat_ge (f kv x) (f' kv x)", "apply (rule icf_proper_iteratorI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. proper_it' ?it12 it'\n 2. \\<And>kv x. flat_ge (f kv x) (f' kv x)", "by fact+"], ["", "(* TODO/FIXME: Hack! Mono-prover should be able to find proper-iterators itself\n*)"], ["", "lemmas proper_it_monos = \n  proper_it_mono_dres_pair proper_it_mono_dres_pair_flat\n  proper_it_mono_dres proper_it_mono_dres_flat\n  proper_it_mono_dres_dom proper_it_mono_dres_dom_flat"], ["", "(* TODO: Conceptually, this leads to some kind of bundles: \n  Each bundle has a list of processors, that are invoked for every registered\n  theorem. *)"], ["", "attribute_setup \"proper_it\" = \\<open>\n  Scan.succeed (Thm.declaration_attribute (fn thm => fn context => \n    let\n      val mono_thms = map_filter (try (curry (RS) thm)) @{thms proper_it_monos}\n      (*val mono_thms = map (fn mt => thm RS mt) @{thms proper_it_monos}*)\n      val context = context \n        |> Icf_Proper_Iterator.add_thm thm\n        |> fold Refine_Mono_Prover.add_mono_thm mono_thms\n    in\n      context\n    end\n  ))\n\\<close>\n  \"Proper iterator declaration\""], ["", "end"]]}