{"file_name": "/home/qj213/afp-2021-10-22/thys/Collections/Examples/Refine_Monadic/Foreach_Refine.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Collections", "problem_names": ["lemma find_max_correct:\n  fixes S:: \"'a::{linorder} set\"\n  assumes \"finite S\"\n  shows \"find_max P S \\<le> SPEC (\\<lambda>\\<sigma>. case \\<sigma> of None \\<Rightarrow> \\<forall>x\\<in>S. \\<not>(P x)\n                                          | Some y \\<Rightarrow> (P y \\<and> y \\<in> S \\<and> (\\<forall>x\\<in>S. P x \\<longrightarrow> y \\<ge> x)))\"", "lemma find_max_impl_refine:\n  assumes invar_S: \"rs.invar S\"\n  shows \"RETURN (find_max_impl P S) \\<le> (find_max P (rs.\\<alpha> S))\"", "lemma find_max_impl_correct :\nassumes invar_S: \"rs.invar S\"\nshows \"case find_max_impl P S of None \\<Rightarrow> \\<forall>x\\<in>rs.\\<alpha> S. \\<not>(P x)\n                               | Some y \\<Rightarrow> (P y \\<and> y \\<in> (rs.\\<alpha> S) \n                                 \\<and> (\\<forall>x\\<in>rs.\\<alpha> S. P x \\<longrightarrow> y \\<ge> x))\""], "translations": [["", "lemma find_max_correct:\n  fixes S:: \"'a::{linorder} set\"\n  assumes \"finite S\"\n  shows \"find_max P S \\<le> SPEC (\\<lambda>\\<sigma>. case \\<sigma> of None \\<Rightarrow> \\<forall>x\\<in>S. \\<not>(P x)\n                                          | Some y \\<Rightarrow> (P y \\<and> y \\<in> S \\<and> (\\<forall>x\\<in>S. P x \\<longrightarrow> y \\<ge> x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. find_max P S\n    \\<le> SPEC\n           (\\<lambda>\\<sigma>.\n               case \\<sigma> of\n               None \\<Rightarrow> \\<forall>x\\<in>S. \\<not> P x\n               | Some y \\<Rightarrow>\n                   P y \\<and>\n                   y \\<in> S \\<and>\n                   (\\<forall>x\\<in>S. P x \\<longrightarrow> x \\<le> y))", "unfolding find_max_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH\\<^sub>O\\<^sub>C\\<^bsup>\\<lambda>x y.\ny \\<le> x,find_max_invar P S\\<^esup>\n     S (\\<lambda>\\<sigma>. \\<sigma> = None)\n     (\\<lambda>x _. RETURN (if P x then Some x else None)) None\n    \\<le> SPEC\n           (\\<lambda>\\<sigma>.\n               case \\<sigma> of\n               None \\<Rightarrow> \\<forall>x\\<in>S. \\<not> P x\n               | Some y \\<Rightarrow>\n                   P y \\<and>\n                   y \\<in> S \\<and>\n                   (\\<forall>x\\<in>S. P x \\<longrightarrow> x \\<le> y))", "proof (rule FOREACHoci_rule)"], ["proof (state)\ngoal (5 subgoals):\n 1. finite S\n 2. find_max_invar P S S None\n 3. \\<And>x it \\<sigma>.\n       \\<lbrakk>\\<sigma> = None; x \\<in> it; it \\<subseteq> S;\n        find_max_invar P S it \\<sigma>; \\<forall>y\\<in>it - {x}. y \\<le> x;\n        \\<forall>y\\<in>S - it. x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> RETURN (if P x then Some x else None)\n                         \\<le> SPEC (find_max_invar P S (it - {x}))\n 4. \\<And>\\<sigma>.\n       find_max_invar P S {} \\<sigma> \\<Longrightarrow>\n       case \\<sigma> of None \\<Rightarrow> \\<forall>x\\<in>S. \\<not> P x\n       | Some y \\<Rightarrow>\n           P y \\<and>\n           y \\<in> S \\<and>\n           (\\<forall>x\\<in>S. P x \\<longrightarrow> x \\<le> y)\n 5. \\<And>it \\<sigma>.\n       \\<lbrakk>it \\<noteq> {}; it \\<subseteq> S;\n        find_max_invar P S it \\<sigma>; \\<sigma> \\<noteq> None;\n        \\<forall>x\\<in>it. \\<forall>y\\<in>S - it. x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> case \\<sigma> of\n                         None \\<Rightarrow> \\<forall>x\\<in>S. \\<not> P x\n                         | Some y \\<Rightarrow>\n                             P y \\<and>\n                             y \\<in> S \\<and>\n                             (\\<forall>x\\<in>S.\n                                 P x \\<longrightarrow> x \\<le> y)", "show \"finite S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite S", "by fact"], ["proof (state)\nthis:\n  finite S\n\ngoal (4 subgoals):\n 1. find_max_invar P S S None\n 2. \\<And>x it \\<sigma>.\n       \\<lbrakk>\\<sigma> = None; x \\<in> it; it \\<subseteq> S;\n        find_max_invar P S it \\<sigma>; \\<forall>y\\<in>it - {x}. y \\<le> x;\n        \\<forall>y\\<in>S - it. x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> RETURN (if P x then Some x else None)\n                         \\<le> SPEC (find_max_invar P S (it - {x}))\n 3. \\<And>\\<sigma>.\n       find_max_invar P S {} \\<sigma> \\<Longrightarrow>\n       case \\<sigma> of None \\<Rightarrow> \\<forall>x\\<in>S. \\<not> P x\n       | Some y \\<Rightarrow>\n           P y \\<and>\n           y \\<in> S \\<and>\n           (\\<forall>x\\<in>S. P x \\<longrightarrow> x \\<le> y)\n 4. \\<And>it \\<sigma>.\n       \\<lbrakk>it \\<noteq> {}; it \\<subseteq> S;\n        find_max_invar P S it \\<sigma>; \\<sigma> \\<noteq> None;\n        \\<forall>x\\<in>it. \\<forall>y\\<in>S - it. x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> case \\<sigma> of\n                         None \\<Rightarrow> \\<forall>x\\<in>S. \\<not> P x\n                         | Some y \\<Rightarrow>\n                             P y \\<and>\n                             y \\<in> S \\<and>\n                             (\\<forall>x\\<in>S.\n                                 P x \\<longrightarrow> x \\<le> y)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. find_max_invar P S S None\n 2. \\<And>x it \\<sigma>.\n       \\<lbrakk>\\<sigma> = None; x \\<in> it; it \\<subseteq> S;\n        find_max_invar P S it \\<sigma>; \\<forall>y\\<in>it - {x}. y \\<le> x;\n        \\<forall>y\\<in>S - it. x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> RETURN (if P x then Some x else None)\n                         \\<le> SPEC (find_max_invar P S (it - {x}))\n 3. \\<And>\\<sigma>.\n       find_max_invar P S {} \\<sigma> \\<Longrightarrow>\n       case \\<sigma> of None \\<Rightarrow> \\<forall>x\\<in>S. \\<not> P x\n       | Some y \\<Rightarrow>\n           P y \\<and>\n           y \\<in> S \\<and>\n           (\\<forall>x\\<in>S. P x \\<longrightarrow> x \\<le> y)\n 4. \\<And>it \\<sigma>.\n       \\<lbrakk>it \\<noteq> {}; it \\<subseteq> S;\n        find_max_invar P S it \\<sigma>; \\<sigma> \\<noteq> None;\n        \\<forall>x\\<in>it. \\<forall>y\\<in>S - it. x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> case \\<sigma> of\n                         None \\<Rightarrow> \\<forall>x\\<in>S. \\<not> P x\n                         | Some y \\<Rightarrow>\n                             P y \\<and>\n                             y \\<in> S \\<and>\n                             (\\<forall>x\\<in>S.\n                                 P x \\<longrightarrow> x \\<le> y)", "show \"find_max_invar P S S None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. find_max_invar P S S None", "unfolding find_max_invar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. case None of None \\<Rightarrow> \\<forall>x\\<in>S - S. \\<not> P x\n    | Some y \\<Rightarrow>\n        P y \\<and>\n        y \\<in> S - S \\<and> (\\<forall>x\\<in>S - S - {y}. \\<not> P x)", "by simp"], ["proof (state)\nthis:\n  find_max_invar P S S None\n\ngoal (3 subgoals):\n 1. \\<And>x it \\<sigma>.\n       \\<lbrakk>\\<sigma> = None; x \\<in> it; it \\<subseteq> S;\n        find_max_invar P S it \\<sigma>; \\<forall>y\\<in>it - {x}. y \\<le> x;\n        \\<forall>y\\<in>S - it. x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> RETURN (if P x then Some x else None)\n                         \\<le> SPEC (find_max_invar P S (it - {x}))\n 2. \\<And>\\<sigma>.\n       find_max_invar P S {} \\<sigma> \\<Longrightarrow>\n       case \\<sigma> of None \\<Rightarrow> \\<forall>x\\<in>S. \\<not> P x\n       | Some y \\<Rightarrow>\n           P y \\<and>\n           y \\<in> S \\<and>\n           (\\<forall>x\\<in>S. P x \\<longrightarrow> x \\<le> y)\n 3. \\<And>it \\<sigma>.\n       \\<lbrakk>it \\<noteq> {}; it \\<subseteq> S;\n        find_max_invar P S it \\<sigma>; \\<sigma> \\<noteq> None;\n        \\<forall>x\\<in>it. \\<forall>y\\<in>S - it. x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> case \\<sigma> of\n                         None \\<Rightarrow> \\<forall>x\\<in>S. \\<not> P x\n                         | Some y \\<Rightarrow>\n                             P y \\<and>\n                             y \\<in> S \\<and>\n                             (\\<forall>x\\<in>S.\n                                 P x \\<longrightarrow> x \\<le> y)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x it \\<sigma>.\n       \\<lbrakk>\\<sigma> = None; x \\<in> it; it \\<subseteq> S;\n        find_max_invar P S it \\<sigma>; \\<forall>y\\<in>it - {x}. y \\<le> x;\n        \\<forall>y\\<in>S - it. x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> RETURN (if P x then Some x else None)\n                         \\<le> SPEC (find_max_invar P S (it - {x}))\n 2. \\<And>\\<sigma>.\n       find_max_invar P S {} \\<sigma> \\<Longrightarrow>\n       case \\<sigma> of None \\<Rightarrow> \\<forall>x\\<in>S. \\<not> P x\n       | Some y \\<Rightarrow>\n           P y \\<and>\n           y \\<in> S \\<and>\n           (\\<forall>x\\<in>S. P x \\<longrightarrow> x \\<le> y)\n 3. \\<And>it \\<sigma>.\n       \\<lbrakk>it \\<noteq> {}; it \\<subseteq> S;\n        find_max_invar P S it \\<sigma>; \\<sigma> \\<noteq> None;\n        \\<forall>x\\<in>it. \\<forall>y\\<in>S - it. x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> case \\<sigma> of\n                         None \\<Rightarrow> \\<forall>x\\<in>S. \\<not> P x\n                         | Some y \\<Rightarrow>\n                             P y \\<and>\n                             y \\<in> S \\<and>\n                             (\\<forall>x\\<in>S.\n                                 P x \\<longrightarrow> x \\<le> y)", "fix x it \\<sigma>"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x it \\<sigma>.\n       \\<lbrakk>\\<sigma> = None; x \\<in> it; it \\<subseteq> S;\n        find_max_invar P S it \\<sigma>; \\<forall>y\\<in>it - {x}. y \\<le> x;\n        \\<forall>y\\<in>S - it. x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> RETURN (if P x then Some x else None)\n                         \\<le> SPEC (find_max_invar P S (it - {x}))\n 2. \\<And>\\<sigma>.\n       find_max_invar P S {} \\<sigma> \\<Longrightarrow>\n       case \\<sigma> of None \\<Rightarrow> \\<forall>x\\<in>S. \\<not> P x\n       | Some y \\<Rightarrow>\n           P y \\<and>\n           y \\<in> S \\<and>\n           (\\<forall>x\\<in>S. P x \\<longrightarrow> x \\<le> y)\n 3. \\<And>it \\<sigma>.\n       \\<lbrakk>it \\<noteq> {}; it \\<subseteq> S;\n        find_max_invar P S it \\<sigma>; \\<sigma> \\<noteq> None;\n        \\<forall>x\\<in>it. \\<forall>y\\<in>S - it. x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> case \\<sigma> of\n                         None \\<Rightarrow> \\<forall>x\\<in>S. \\<not> P x\n                         | Some y \\<Rightarrow>\n                             P y \\<and>\n                             y \\<in> S \\<and>\n                             (\\<forall>x\\<in>S.\n                                 P x \\<longrightarrow> x \\<le> y)", "assume \"\\<sigma> = None\"\n         \"x \\<in> it\"\n         \"it \\<subseteq> S\"\n         \"find_max_invar P S it \\<sigma>\"\n         \"\\<forall>y\\<in>it - {x}. y \\<le> x\"\n         \"\\<forall>y\\<in>S - it. x \\<le> y\""], ["proof (state)\nthis:\n  \\<sigma> = None\n  x \\<in> it\n  it \\<subseteq> S\n  find_max_invar P S it \\<sigma>\n  \\<forall>y\\<in>it - {x}. y \\<le> x\n  \\<forall>y\\<in>S - it. x \\<le> y\n\ngoal (3 subgoals):\n 1. \\<And>x it \\<sigma>.\n       \\<lbrakk>\\<sigma> = None; x \\<in> it; it \\<subseteq> S;\n        find_max_invar P S it \\<sigma>; \\<forall>y\\<in>it - {x}. y \\<le> x;\n        \\<forall>y\\<in>S - it. x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> RETURN (if P x then Some x else None)\n                         \\<le> SPEC (find_max_invar P S (it - {x}))\n 2. \\<And>\\<sigma>.\n       find_max_invar P S {} \\<sigma> \\<Longrightarrow>\n       case \\<sigma> of None \\<Rightarrow> \\<forall>x\\<in>S. \\<not> P x\n       | Some y \\<Rightarrow>\n           P y \\<and>\n           y \\<in> S \\<and>\n           (\\<forall>x\\<in>S. P x \\<longrightarrow> x \\<le> y)\n 3. \\<And>it \\<sigma>.\n       \\<lbrakk>it \\<noteq> {}; it \\<subseteq> S;\n        find_max_invar P S it \\<sigma>; \\<sigma> \\<noteq> None;\n        \\<forall>x\\<in>it. \\<forall>y\\<in>S - it. x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> case \\<sigma> of\n                         None \\<Rightarrow> \\<forall>x\\<in>S. \\<not> P x\n                         | Some y \\<Rightarrow>\n                             P y \\<and>\n                             y \\<in> S \\<and>\n                             (\\<forall>x\\<in>S.\n                                 P x \\<longrightarrow> x \\<le> y)", "from \\<open>find_max_invar P S it \\<sigma>\\<close> \\<open>\\<sigma> = None\\<close>"], ["proof (chain)\npicking this:\n  find_max_invar P S it \\<sigma>\n  \\<sigma> = None", "have not_P_others: \"\\<forall>x\\<in>S - it. \\<not> P x\""], ["proof (prove)\nusing this:\n  find_max_invar P S it \\<sigma>\n  \\<sigma> = None\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>S - it. \\<not> P x", "by (simp add: find_max_invar_def)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>S - it. \\<not> P x\n\ngoal (3 subgoals):\n 1. \\<And>x it \\<sigma>.\n       \\<lbrakk>\\<sigma> = None; x \\<in> it; it \\<subseteq> S;\n        find_max_invar P S it \\<sigma>; \\<forall>y\\<in>it - {x}. y \\<le> x;\n        \\<forall>y\\<in>S - it. x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> RETURN (if P x then Some x else None)\n                         \\<le> SPEC (find_max_invar P S (it - {x}))\n 2. \\<And>\\<sigma>.\n       find_max_invar P S {} \\<sigma> \\<Longrightarrow>\n       case \\<sigma> of None \\<Rightarrow> \\<forall>x\\<in>S. \\<not> P x\n       | Some y \\<Rightarrow>\n           P y \\<and>\n           y \\<in> S \\<and>\n           (\\<forall>x\\<in>S. P x \\<longrightarrow> x \\<le> y)\n 3. \\<And>it \\<sigma>.\n       \\<lbrakk>it \\<noteq> {}; it \\<subseteq> S;\n        find_max_invar P S it \\<sigma>; \\<sigma> \\<noteq> None;\n        \\<forall>x\\<in>it. \\<forall>y\\<in>S - it. x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> case \\<sigma> of\n                         None \\<Rightarrow> \\<forall>x\\<in>S. \\<not> P x\n                         | Some y \\<Rightarrow>\n                             P y \\<and>\n                             y \\<in> S \\<and>\n                             (\\<forall>x\\<in>S.\n                                 P x \\<longrightarrow> x \\<le> y)", "from \\<open>x \\<in> it\\<close> \\<open>it \\<subseteq> S\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> it\n  it \\<subseteq> S", "have \"x \\<in> S\""], ["proof (prove)\nusing this:\n  x \\<in> it\n  it \\<subseteq> S\n\ngoal (1 subgoal):\n 1. x \\<in> S", "by blast"], ["proof (state)\nthis:\n  x \\<in> S\n\ngoal (3 subgoals):\n 1. \\<And>x it \\<sigma>.\n       \\<lbrakk>\\<sigma> = None; x \\<in> it; it \\<subseteq> S;\n        find_max_invar P S it \\<sigma>; \\<forall>y\\<in>it - {x}. y \\<le> x;\n        \\<forall>y\\<in>S - it. x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> RETURN (if P x then Some x else None)\n                         \\<le> SPEC (find_max_invar P S (it - {x}))\n 2. \\<And>\\<sigma>.\n       find_max_invar P S {} \\<sigma> \\<Longrightarrow>\n       case \\<sigma> of None \\<Rightarrow> \\<forall>x\\<in>S. \\<not> P x\n       | Some y \\<Rightarrow>\n           P y \\<and>\n           y \\<in> S \\<and>\n           (\\<forall>x\\<in>S. P x \\<longrightarrow> x \\<le> y)\n 3. \\<And>it \\<sigma>.\n       \\<lbrakk>it \\<noteq> {}; it \\<subseteq> S;\n        find_max_invar P S it \\<sigma>; \\<sigma> \\<noteq> None;\n        \\<forall>x\\<in>it. \\<forall>y\\<in>S - it. x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> case \\<sigma> of\n                         None \\<Rightarrow> \\<forall>x\\<in>S. \\<not> P x\n                         | Some y \\<Rightarrow>\n                             P y \\<and>\n                             y \\<in> S \\<and>\n                             (\\<forall>x\\<in>S.\n                                 P x \\<longrightarrow> x \\<le> y)", "show \"RETURN (if P x then Some x else None) \\<le> SPEC (find_max_invar P S (it - {x}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN (if P x then Some x else None)\n    \\<le> SPEC (find_max_invar P S (it - {x}))", "using not_P_others \\<open>x \\<in> S\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>S - it. \\<not> P x\n  x \\<in> S\n\ngoal (1 subgoal):\n 1. RETURN (if P x then Some x else None)\n    \\<le> SPEC (find_max_invar P S (it - {x}))", "by (auto simp add: find_max_invar_def)"], ["proof (state)\nthis:\n  RETURN (if P x then Some x else None)\n  \\<le> SPEC (find_max_invar P S (it - {x}))\n\ngoal (2 subgoals):\n 1. \\<And>\\<sigma>.\n       find_max_invar P S {} \\<sigma> \\<Longrightarrow>\n       case \\<sigma> of None \\<Rightarrow> \\<forall>x\\<in>S. \\<not> P x\n       | Some y \\<Rightarrow>\n           P y \\<and>\n           y \\<in> S \\<and>\n           (\\<forall>x\\<in>S. P x \\<longrightarrow> x \\<le> y)\n 2. \\<And>it \\<sigma>.\n       \\<lbrakk>it \\<noteq> {}; it \\<subseteq> S;\n        find_max_invar P S it \\<sigma>; \\<sigma> \\<noteq> None;\n        \\<forall>x\\<in>it. \\<forall>y\\<in>S - it. x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> case \\<sigma> of\n                         None \\<Rightarrow> \\<forall>x\\<in>S. \\<not> P x\n                         | Some y \\<Rightarrow>\n                             P y \\<and>\n                             y \\<in> S \\<and>\n                             (\\<forall>x\\<in>S.\n                                 P x \\<longrightarrow> x \\<le> y)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma>.\n       find_max_invar P S {} \\<sigma> \\<Longrightarrow>\n       case \\<sigma> of None \\<Rightarrow> \\<forall>x\\<in>S. \\<not> P x\n       | Some y \\<Rightarrow>\n           P y \\<and>\n           y \\<in> S \\<and>\n           (\\<forall>x\\<in>S. P x \\<longrightarrow> x \\<le> y)\n 2. \\<And>it \\<sigma>.\n       \\<lbrakk>it \\<noteq> {}; it \\<subseteq> S;\n        find_max_invar P S it \\<sigma>; \\<sigma> \\<noteq> None;\n        \\<forall>x\\<in>it. \\<forall>y\\<in>S - it. x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> case \\<sigma> of\n                         None \\<Rightarrow> \\<forall>x\\<in>S. \\<not> P x\n                         | Some y \\<Rightarrow>\n                             P y \\<and>\n                             y \\<in> S \\<and>\n                             (\\<forall>x\\<in>S.\n                                 P x \\<longrightarrow> x \\<le> y)", "fix \\<sigma>"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma>.\n       find_max_invar P S {} \\<sigma> \\<Longrightarrow>\n       case \\<sigma> of None \\<Rightarrow> \\<forall>x\\<in>S. \\<not> P x\n       | Some y \\<Rightarrow>\n           P y \\<and>\n           y \\<in> S \\<and>\n           (\\<forall>x\\<in>S. P x \\<longrightarrow> x \\<le> y)\n 2. \\<And>it \\<sigma>.\n       \\<lbrakk>it \\<noteq> {}; it \\<subseteq> S;\n        find_max_invar P S it \\<sigma>; \\<sigma> \\<noteq> None;\n        \\<forall>x\\<in>it. \\<forall>y\\<in>S - it. x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> case \\<sigma> of\n                         None \\<Rightarrow> \\<forall>x\\<in>S. \\<not> P x\n                         | Some y \\<Rightarrow>\n                             P y \\<and>\n                             y \\<in> S \\<and>\n                             (\\<forall>x\\<in>S.\n                                 P x \\<longrightarrow> x \\<le> y)", "assume \"find_max_invar P S {} \\<sigma>\""], ["proof (state)\nthis:\n  find_max_invar P S {} \\<sigma>\n\ngoal (2 subgoals):\n 1. \\<And>\\<sigma>.\n       find_max_invar P S {} \\<sigma> \\<Longrightarrow>\n       case \\<sigma> of None \\<Rightarrow> \\<forall>x\\<in>S. \\<not> P x\n       | Some y \\<Rightarrow>\n           P y \\<and>\n           y \\<in> S \\<and>\n           (\\<forall>x\\<in>S. P x \\<longrightarrow> x \\<le> y)\n 2. \\<And>it \\<sigma>.\n       \\<lbrakk>it \\<noteq> {}; it \\<subseteq> S;\n        find_max_invar P S it \\<sigma>; \\<sigma> \\<noteq> None;\n        \\<forall>x\\<in>it. \\<forall>y\\<in>S - it. x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> case \\<sigma> of\n                         None \\<Rightarrow> \\<forall>x\\<in>S. \\<not> P x\n                         | Some y \\<Rightarrow>\n                             P y \\<and>\n                             y \\<in> S \\<and>\n                             (\\<forall>x\\<in>S.\n                                 P x \\<longrightarrow> x \\<le> y)", "thus \"case \\<sigma> of None \\<Rightarrow> \\<forall>x\\<in>S. \\<not> P x\n        | Some y \\<Rightarrow> P y \\<and> y \\<in> S \\<and> (\\<forall>x\\<in>S. P x \\<longrightarrow> x \\<le> y)\""], ["proof (prove)\nusing this:\n  find_max_invar P S {} \\<sigma>\n\ngoal (1 subgoal):\n 1. case \\<sigma> of None \\<Rightarrow> \\<forall>x\\<in>S. \\<not> P x\n    | Some y \\<Rightarrow>\n        P y \\<and>\n        y \\<in> S \\<and> (\\<forall>x\\<in>S. P x \\<longrightarrow> x \\<le> y)", "by (cases \\<sigma>, auto simp add: find_max_invar_def)"], ["proof (state)\nthis:\n  case \\<sigma> of None \\<Rightarrow> \\<forall>x\\<in>S. \\<not> P x\n  | Some y \\<Rightarrow>\n      P y \\<and>\n      y \\<in> S \\<and> (\\<forall>x\\<in>S. P x \\<longrightarrow> x \\<le> y)\n\ngoal (1 subgoal):\n 1. \\<And>it \\<sigma>.\n       \\<lbrakk>it \\<noteq> {}; it \\<subseteq> S;\n        find_max_invar P S it \\<sigma>; \\<sigma> \\<noteq> None;\n        \\<forall>x\\<in>it. \\<forall>y\\<in>S - it. x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> case \\<sigma> of\n                         None \\<Rightarrow> \\<forall>x\\<in>S. \\<not> P x\n                         | Some y \\<Rightarrow>\n                             P y \\<and>\n                             y \\<in> S \\<and>\n                             (\\<forall>x\\<in>S.\n                                 P x \\<longrightarrow> x \\<le> y)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>it \\<sigma>.\n       \\<lbrakk>it \\<noteq> {}; it \\<subseteq> S;\n        find_max_invar P S it \\<sigma>; \\<sigma> \\<noteq> None;\n        \\<forall>x\\<in>it. \\<forall>y\\<in>S - it. x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> case \\<sigma> of\n                         None \\<Rightarrow> \\<forall>x\\<in>S. \\<not> P x\n                         | Some y \\<Rightarrow>\n                             P y \\<and>\n                             y \\<in> S \\<and>\n                             (\\<forall>x\\<in>S.\n                                 P x \\<longrightarrow> x \\<le> y)", "fix it \\<sigma>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>it \\<sigma>.\n       \\<lbrakk>it \\<noteq> {}; it \\<subseteq> S;\n        find_max_invar P S it \\<sigma>; \\<sigma> \\<noteq> None;\n        \\<forall>x\\<in>it. \\<forall>y\\<in>S - it. x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> case \\<sigma> of\n                         None \\<Rightarrow> \\<forall>x\\<in>S. \\<not> P x\n                         | Some y \\<Rightarrow>\n                             P y \\<and>\n                             y \\<in> S \\<and>\n                             (\\<forall>x\\<in>S.\n                                 P x \\<longrightarrow> x \\<le> y)", "assume \"it \\<noteq> {}\"\n         \"it \\<subseteq> S\"\n         \"find_max_invar P S it \\<sigma>\"\n         \"\\<sigma> \\<noteq> None\"\n         \"\\<forall>x\\<in>it. \\<forall>y\\<in>S - it. x \\<le> y\""], ["proof (state)\nthis:\n  it \\<noteq> {}\n  it \\<subseteq> S\n  find_max_invar P S it \\<sigma>\n  \\<sigma> \\<noteq> None\n  \\<forall>x\\<in>it. \\<forall>y\\<in>S - it. x \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>it \\<sigma>.\n       \\<lbrakk>it \\<noteq> {}; it \\<subseteq> S;\n        find_max_invar P S it \\<sigma>; \\<sigma> \\<noteq> None;\n        \\<forall>x\\<in>it. \\<forall>y\\<in>S - it. x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> case \\<sigma> of\n                         None \\<Rightarrow> \\<forall>x\\<in>S. \\<not> P x\n                         | Some y \\<Rightarrow>\n                             P y \\<and>\n                             y \\<in> S \\<and>\n                             (\\<forall>x\\<in>S.\n                                 P x \\<longrightarrow> x \\<le> y)", "from \\<open>\\<sigma> \\<noteq> None\\<close>"], ["proof (chain)\npicking this:\n  \\<sigma> \\<noteq> None", "obtain y where \\<sigma>_eq[simp]: \"\\<sigma> = Some y\""], ["proof (prove)\nusing this:\n  \\<sigma> \\<noteq> None\n\ngoal (1 subgoal):\n 1. (\\<And>y. \\<sigma> = Some y \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<sigma> = Some y\n\ngoal (1 subgoal):\n 1. \\<And>it \\<sigma>.\n       \\<lbrakk>it \\<noteq> {}; it \\<subseteq> S;\n        find_max_invar P S it \\<sigma>; \\<sigma> \\<noteq> None;\n        \\<forall>x\\<in>it. \\<forall>y\\<in>S - it. x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> case \\<sigma> of\n                         None \\<Rightarrow> \\<forall>x\\<in>S. \\<not> P x\n                         | Some y \\<Rightarrow>\n                             P y \\<and>\n                             y \\<in> S \\<and>\n                             (\\<forall>x\\<in>S.\n                                 P x \\<longrightarrow> x \\<le> y)", "from \\<open>find_max_invar P S it \\<sigma>\\<close>"], ["proof (chain)\npicking this:\n  find_max_invar P S it \\<sigma>", "have y_props[simp]: \"P y\" \"y \\<in> S\" \"y \\<notin> it\" and not_P: \"\\<forall>x\\<in>S - it - {y}. \\<not> P x\""], ["proof (prove)\nusing this:\n  find_max_invar P S it \\<sigma>\n\ngoal (1 subgoal):\n 1. (P y &&& y \\<in> S &&& y \\<notin> it) &&&\n    \\<forall>x\\<in>S - it - {y}. \\<not> P x", "by (simp_all add: find_max_invar_def)"], ["proof (state)\nthis:\n  P y\n  y \\<in> S\n  y \\<notin> it\n  \\<forall>x\\<in>S - it - {y}. \\<not> P x\n\ngoal (1 subgoal):\n 1. \\<And>it \\<sigma>.\n       \\<lbrakk>it \\<noteq> {}; it \\<subseteq> S;\n        find_max_invar P S it \\<sigma>; \\<sigma> \\<noteq> None;\n        \\<forall>x\\<in>it. \\<forall>y\\<in>S - it. x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> case \\<sigma> of\n                         None \\<Rightarrow> \\<forall>x\\<in>S. \\<not> P x\n                         | Some y \\<Rightarrow>\n                             P y \\<and>\n                             y \\<in> S \\<and>\n                             (\\<forall>x\\<in>S.\n                                 P x \\<longrightarrow> x \\<le> y)", "{"], ["proof (state)\nthis:\n  P y\n  y \\<in> S\n  y \\<notin> it\n  \\<forall>x\\<in>S - it - {y}. \\<not> P x\n\ngoal (1 subgoal):\n 1. \\<And>it \\<sigma>.\n       \\<lbrakk>it \\<noteq> {}; it \\<subseteq> S;\n        find_max_invar P S it \\<sigma>; \\<sigma> \\<noteq> None;\n        \\<forall>x\\<in>it. \\<forall>y\\<in>S - it. x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> case \\<sigma> of\n                         None \\<Rightarrow> \\<forall>x\\<in>S. \\<not> P x\n                         | Some y \\<Rightarrow>\n                             P y \\<and>\n                             y \\<in> S \\<and>\n                             (\\<forall>x\\<in>S.\n                                 P x \\<longrightarrow> x \\<le> y)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>it \\<sigma>.\n       \\<lbrakk>it \\<noteq> {}; it \\<subseteq> S;\n        find_max_invar P S it \\<sigma>; \\<sigma> \\<noteq> None;\n        \\<forall>x\\<in>it. \\<forall>y\\<in>S - it. x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> case \\<sigma> of\n                         None \\<Rightarrow> \\<forall>x\\<in>S. \\<not> P x\n                         | Some y \\<Rightarrow>\n                             P y \\<and>\n                             y \\<in> S \\<and>\n                             (\\<forall>x\\<in>S.\n                                 P x \\<longrightarrow> x \\<le> y)", "assume \"x \\<in> S\" \"P x\""], ["proof (state)\nthis:\n  x \\<in> S\n  P x\n\ngoal (1 subgoal):\n 1. \\<And>it \\<sigma>.\n       \\<lbrakk>it \\<noteq> {}; it \\<subseteq> S;\n        find_max_invar P S it \\<sigma>; \\<sigma> \\<noteq> None;\n        \\<forall>x\\<in>it. \\<forall>y\\<in>S - it. x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> case \\<sigma> of\n                         None \\<Rightarrow> \\<forall>x\\<in>S. \\<not> P x\n                         | Some y \\<Rightarrow>\n                             P y \\<and>\n                             y \\<in> S \\<and>\n                             (\\<forall>x\\<in>S.\n                                 P x \\<longrightarrow> x \\<le> y)", "with not_P"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>S - it - {y}. \\<not> P x\n  x \\<in> S\n  P x", "have \"x \\<in> it \\<or> x = y\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>S - it - {y}. \\<not> P x\n  x \\<in> S\n  P x\n\ngoal (1 subgoal):\n 1. x \\<in> it \\<or> x = y", "by auto"], ["proof (state)\nthis:\n  x \\<in> it \\<or> x = y\n\ngoal (1 subgoal):\n 1. \\<And>it \\<sigma>.\n       \\<lbrakk>it \\<noteq> {}; it \\<subseteq> S;\n        find_max_invar P S it \\<sigma>; \\<sigma> \\<noteq> None;\n        \\<forall>x\\<in>it. \\<forall>y\\<in>S - it. x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> case \\<sigma> of\n                         None \\<Rightarrow> \\<forall>x\\<in>S. \\<not> P x\n                         | Some y \\<Rightarrow>\n                             P y \\<and>\n                             y \\<in> S \\<and>\n                             (\\<forall>x\\<in>S.\n                                 P x \\<longrightarrow> x \\<le> y)", "with \\<open>\\<forall>x\\<in>it. \\<forall>y\\<in>S - it. x \\<le> y\\<close> y_props"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>it. \\<forall>y\\<in>S - it. x \\<le> y\n  P y\n  y \\<in> S\n  y \\<notin> it\n  x \\<in> it \\<or> x = y", "have \"x \\<le> y\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>it. \\<forall>y\\<in>S - it. x \\<le> y\n  P y\n  y \\<in> S\n  y \\<notin> it\n  x \\<in> it \\<or> x = y\n\ngoal (1 subgoal):\n 1. x \\<le> y", "by auto"], ["proof (state)\nthis:\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>it \\<sigma>.\n       \\<lbrakk>it \\<noteq> {}; it \\<subseteq> S;\n        find_max_invar P S it \\<sigma>; \\<sigma> \\<noteq> None;\n        \\<forall>x\\<in>it. \\<forall>y\\<in>S - it. x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> case \\<sigma> of\n                         None \\<Rightarrow> \\<forall>x\\<in>S. \\<not> P x\n                         | Some y \\<Rightarrow>\n                             P y \\<and>\n                             y \\<in> S \\<and>\n                             (\\<forall>x\\<in>S.\n                                 P x \\<longrightarrow> x \\<le> y)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?x2 \\<in> S; P ?x2\\<rbrakk> \\<Longrightarrow> ?x2 \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>it \\<sigma>.\n       \\<lbrakk>it \\<noteq> {}; it \\<subseteq> S;\n        find_max_invar P S it \\<sigma>; \\<sigma> \\<noteq> None;\n        \\<forall>x\\<in>it. \\<forall>y\\<in>S - it. x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> case \\<sigma> of\n                         None \\<Rightarrow> \\<forall>x\\<in>S. \\<not> P x\n                         | Some y \\<Rightarrow>\n                             P y \\<and>\n                             y \\<in> S \\<and>\n                             (\\<forall>x\\<in>S.\n                                 P x \\<longrightarrow> x \\<le> y)", "note less_eq_y = this"], ["proof (state)\nthis:\n  \\<lbrakk>?x2 \\<in> S; P ?x2\\<rbrakk> \\<Longrightarrow> ?x2 \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>it \\<sigma>.\n       \\<lbrakk>it \\<noteq> {}; it \\<subseteq> S;\n        find_max_invar P S it \\<sigma>; \\<sigma> \\<noteq> None;\n        \\<forall>x\\<in>it. \\<forall>y\\<in>S - it. x \\<le> y\\<rbrakk>\n       \\<Longrightarrow> case \\<sigma> of\n                         None \\<Rightarrow> \\<forall>x\\<in>S. \\<not> P x\n                         | Some y \\<Rightarrow>\n                             P y \\<and>\n                             y \\<in> S \\<and>\n                             (\\<forall>x\\<in>S.\n                                 P x \\<longrightarrow> x \\<le> y)", "show \"case \\<sigma> of None \\<Rightarrow> \\<forall>x\\<in>S. \\<not> P x\n        | Some y \\<Rightarrow> P y \\<and> y \\<in> S \\<and> (\\<forall>x\\<in>S. P x \\<longrightarrow> x \\<le> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. case \\<sigma> of None \\<Rightarrow> \\<forall>x\\<in>S. \\<not> P x\n    | Some y \\<Rightarrow>\n        P y \\<and>\n        y \\<in> S \\<and> (\\<forall>x\\<in>S. P x \\<longrightarrow> x \\<le> y)", "by (simp add: find_max_invar_def Ball_def less_eq_y)"], ["proof (state)\nthis:\n  case \\<sigma> of None \\<Rightarrow> \\<forall>x\\<in>S. \\<not> P x\n  | Some y \\<Rightarrow>\n      P y \\<and>\n      y \\<in> S \\<and> (\\<forall>x\\<in>S. P x \\<longrightarrow> x \\<le> y)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Data Refinement and Determinization\\<close>"], ["", "text \\<open>\n  Next, we use automatic data refinement and transfer to generate an\n  executable algorithm using a red-black-tree. \n\\<close>"], ["", "schematic_goal find_max_impl_refine_aux:\n  assumes invar_S: \"rs.invar S\"\n  shows \"RETURN (?f) \\<le> (find_max P (rs.\\<alpha> S))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?f \\<le> find_max P (rs.\\<alpha> S)", "unfolding find_max_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?f\n    \\<le> FOREACH\\<^sub>O\\<^sub>C\\<^bsup>\\<lambda>x y.\n      y \\<le> x,find_max_invar P (rs.\\<alpha> S)\\<^esup>\n           (rs.\\<alpha> S) (\\<lambda>\\<sigma>. \\<sigma> = None)\n           (\\<lambda>x _. RETURN (if P x then Some x else None)) None", "by (refine_transfer \n    RBTSetImpl.rs.rev_iterateoi_correct[unfolded set_iterator_rev_linord_def,\n    OF invar_S])"], ["", "concrete_definition find_max_impl for P S uses find_max_impl_refine_aux"], ["", "lemma find_max_impl_refine:\n  assumes invar_S: \"rs.invar S\"\n  shows \"RETURN (find_max_impl P S) \\<le> (find_max P (rs.\\<alpha> S))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN (find_max_impl P S) \\<le> find_max P (rs.\\<alpha> S)", "using assms"], ["proof (prove)\nusing this:\n  rs.invar S\n\ngoal (1 subgoal):\n 1. RETURN (find_max_impl P S) \\<le> find_max P (rs.\\<alpha> S)", "by (rule find_max_impl.refine)"], ["", "subsubsection \\<open>Executable Code\\<close>"], ["", "lemma find_max_impl_correct :\nassumes invar_S: \"rs.invar S\"\nshows \"case find_max_impl P S of None \\<Rightarrow> \\<forall>x\\<in>rs.\\<alpha> S. \\<not>(P x)\n                               | Some y \\<Rightarrow> (P y \\<and> y \\<in> (rs.\\<alpha> S) \n                                 \\<and> (\\<forall>x\\<in>rs.\\<alpha> S. P x \\<longrightarrow> y \\<ge> x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. case find_max_impl P S of\n    None \\<Rightarrow> \\<forall>x\\<in>rs.\\<alpha> S. \\<not> P x\n    | Some y \\<Rightarrow>\n        P y \\<and>\n        y \\<in> rs.\\<alpha> S \\<and>\n        (\\<forall>x\\<in>rs.\\<alpha> S. P x \\<longrightarrow> x \\<le> y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. case find_max_impl P S of\n    None \\<Rightarrow> \\<forall>x\\<in>rs.\\<alpha> S. \\<not> P x\n    | Some y \\<Rightarrow>\n        P y \\<and>\n        y \\<in> rs.\\<alpha> S \\<and>\n        (\\<forall>x\\<in>rs.\\<alpha> S. P x \\<longrightarrow> x \\<le> y)", "note find_max_impl_refine [of S P, OF invar_S]"], ["proof (state)\nthis:\n  RETURN (find_max_impl P S) \\<le> find_max P (rs.\\<alpha> S)\n\ngoal (1 subgoal):\n 1. case find_max_impl P S of\n    None \\<Rightarrow> \\<forall>x\\<in>rs.\\<alpha> S. \\<not> P x\n    | Some y \\<Rightarrow>\n        P y \\<and>\n        y \\<in> rs.\\<alpha> S \\<and>\n        (\\<forall>x\\<in>rs.\\<alpha> S. P x \\<longrightarrow> x \\<le> y)", "also"], ["proof (state)\nthis:\n  RETURN (find_max_impl P S) \\<le> find_max P (rs.\\<alpha> S)\n\ngoal (1 subgoal):\n 1. case find_max_impl P S of\n    None \\<Rightarrow> \\<forall>x\\<in>rs.\\<alpha> S. \\<not> P x\n    | Some y \\<Rightarrow>\n        P y \\<and>\n        y \\<in> rs.\\<alpha> S \\<and>\n        (\\<forall>x\\<in>rs.\\<alpha> S. P x \\<longrightarrow> x \\<le> y)", "note find_max_correct [OF RBTSetImpl.rs.finite[of S, OF invar_S], of P]"], ["proof (state)\nthis:\n  find_max P (rs.\\<alpha> S)\n  \\<le> SPEC\n         (\\<lambda>\\<sigma>.\n             case \\<sigma> of\n             None \\<Rightarrow> \\<forall>x\\<in>rs.\\<alpha> S. \\<not> P x\n             | Some y \\<Rightarrow>\n                 P y \\<and>\n                 y \\<in> rs.\\<alpha> S \\<and>\n                 (\\<forall>x\\<in>rs.\\<alpha> S.\n                     P x \\<longrightarrow> x \\<le> y))\n\ngoal (1 subgoal):\n 1. case find_max_impl P S of\n    None \\<Rightarrow> \\<forall>x\\<in>rs.\\<alpha> S. \\<not> P x\n    | Some y \\<Rightarrow>\n        P y \\<and>\n        y \\<in> rs.\\<alpha> S \\<and>\n        (\\<forall>x\\<in>rs.\\<alpha> S. P x \\<longrightarrow> x \\<le> y)", "finally"], ["proof (chain)\npicking this:\n  RETURN (find_max_impl P S)\n  \\<le> SPEC\n         (\\<lambda>\\<sigma>.\n             case \\<sigma> of\n             None \\<Rightarrow> \\<forall>x\\<in>rs.\\<alpha> S. \\<not> P x\n             | Some y \\<Rightarrow>\n                 P y \\<and>\n                 y \\<in> rs.\\<alpha> S \\<and>\n                 (\\<forall>x\\<in>rs.\\<alpha> S.\n                     P x \\<longrightarrow> x \\<le> y))", "show ?thesis"], ["proof (prove)\nusing this:\n  RETURN (find_max_impl P S)\n  \\<le> SPEC\n         (\\<lambda>\\<sigma>.\n             case \\<sigma> of\n             None \\<Rightarrow> \\<forall>x\\<in>rs.\\<alpha> S. \\<not> P x\n             | Some y \\<Rightarrow>\n                 P y \\<and>\n                 y \\<in> rs.\\<alpha> S \\<and>\n                 (\\<forall>x\\<in>rs.\\<alpha> S.\n                     P x \\<longrightarrow> x \\<le> y))\n\ngoal (1 subgoal):\n 1. case find_max_impl P S of\n    None \\<Rightarrow> \\<forall>x\\<in>rs.\\<alpha> S. \\<not> P x\n    | Some y \\<Rightarrow>\n        P y \\<and>\n        y \\<in> rs.\\<alpha> S \\<and>\n        (\\<forall>x\\<in>rs.\\<alpha> S. P x \\<longrightarrow> x \\<le> y)", "by simp"], ["proof (state)\nthis:\n  case find_max_impl P S of\n  None \\<Rightarrow> \\<forall>x\\<in>rs.\\<alpha> S. \\<not> P x\n  | Some y \\<Rightarrow>\n      P y \\<and>\n      y \\<in> rs.\\<alpha> S \\<and>\n      (\\<forall>x\\<in>rs.\\<alpha> S. P x \\<longrightarrow> x \\<le> y)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Finally, we can generate code\\<close>"], ["", "export_code find_max_impl checking SML"], ["", "export_code find_max_impl checking OCaml?"], ["", "export_code find_max_impl checking Haskell?"], ["", "export_code find_max_impl checking Scala"], ["", "end"]]}