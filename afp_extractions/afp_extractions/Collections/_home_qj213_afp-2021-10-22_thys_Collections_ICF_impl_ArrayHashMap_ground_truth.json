{"file_name": "/home/qj213/afp-2021-10-22/thys/Collections/ICF/impl/ArrayHashMap.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Collections", "problem_names": ["lemma ahm_invar_impl_of [simp, intro]: \"ArrayHashMap_Impl.ahm_invar (impl_of hm)\"", "lemma HashMap_impl_of [code abstype]: \"HashMap (impl_of t) = t\"", "lemma impl_of_ahm_empty [code abstract]:\n  \"impl_of ahm_empty_const = ArrayHashMap_Impl.ahm_empty ()\"", "lemma impl_of_ahm_update [code abstract]:\n  \"impl_of (ahm_update k v hm) = ArrayHashMap_Impl.ahm_update k v (impl_of hm)\"", "lemma impl_of_ahm_delete [code abstract]:\n  \"impl_of (ahm_delete k hm) = ArrayHashMap_Impl.ahm_delete k (impl_of hm)\"", "lemma finite_dom_ahm_\\<alpha>[simp]: \"finite (dom (ahm_\\<alpha> hm))\"", "lemma ahm_empty_correct[simp]: \"ahm_\\<alpha> (ahm_empty ()) = Map.empty\"", "lemma ahm_lookup_correct[simp]: \"ahm_lookup k m = ahm_\\<alpha> m k\"", "lemma ahm_update_correct[simp]: \"ahm_\\<alpha> (ahm_update k v hm) = (ahm_\\<alpha> hm)(k \\<mapsto> v)\"", "lemma ahm_delete_correct[simp]:\n  \"ahm_\\<alpha> (ahm_delete k hm) = (ahm_\\<alpha> hm) |` (- {k})\"", "lemma ahm_iteratei_impl[simp]: \"map_iterator (ahm_iteratei m) (ahm_\\<alpha> m)\"", "lemma pi_ahm[proper_it]: \n  \"proper_it' ahm_iteratei ahm_iteratei\""], "translations": [["", "lemma ahm_invar_impl_of [simp, intro]: \"ArrayHashMap_Impl.ahm_invar (impl_of hm)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ArrayHashMap_Impl.ahm_invar (impl_of hm)", "using impl_of[of hm]"], ["proof (prove)\nusing this:\n  impl_of hm \\<in> {hm. ArrayHashMap_Impl.ahm_invar hm}\n\ngoal (1 subgoal):\n 1. ArrayHashMap_Impl.ahm_invar (impl_of hm)", "by simp"], ["", "lemma HashMap_impl_of [code abstype]: \"HashMap (impl_of t) = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HashMap (impl_of t) = t", "by(rule impl_of_inverse)"], ["", "subsection \\<open>Primitive operations\\<close>"], ["", "definition ahm_empty_const :: \"('key :: hashable, 'val) hashmap\"\nwhere \"ahm_empty_const \\<equiv> (HashMap (ArrayHashMap_Impl.ahm_empty ()))\""], ["", "definition ahm_empty :: \"unit \\<Rightarrow> ('key :: hashable, 'val) hashmap\"\nwhere \"ahm_empty \\<equiv> \\<lambda>_. ahm_empty_const\""], ["", "definition ahm_\\<alpha> :: \"('key :: hashable, 'val) hashmap \\<Rightarrow> 'key \\<Rightarrow> 'val option\"\nwhere \"ahm_\\<alpha> hm = ArrayHashMap_Impl.ahm_\\<alpha> (impl_of hm)\""], ["", "definition ahm_lookup :: \"'key \\<Rightarrow> ('key :: hashable, 'val) hashmap \\<Rightarrow> 'val option\"\nwhere \"ahm_lookup k hm = ArrayHashMap_Impl.ahm_lookup k (impl_of hm)\""], ["", "definition ahm_iteratei :: \"('key :: hashable, 'val) hashmap \\<Rightarrow> ('key \\<times> 'val, '\\<sigma>) set_iterator\"\nwhere \"ahm_iteratei hm = ArrayHashMap_Impl.ahm_iteratei (impl_of hm)\""], ["", "definition ahm_update :: \"'key \\<Rightarrow> 'val \\<Rightarrow> ('key :: hashable, 'val) hashmap \\<Rightarrow> ('key, 'val) hashmap\"\nwhere\n  \"ahm_update k v hm = HashMap (ArrayHashMap_Impl.ahm_update k v (impl_of hm))\""], ["", "definition ahm_delete :: \"'key \\<Rightarrow> ('key :: hashable, 'val) hashmap \\<Rightarrow> ('key, 'val) hashmap\"\nwhere\n  \"ahm_delete k hm = HashMap (ArrayHashMap_Impl.ahm_delete k (impl_of hm))\""], ["", "lemma impl_of_ahm_empty [code abstract]:\n  \"impl_of ahm_empty_const = ArrayHashMap_Impl.ahm_empty ()\""], ["proof (prove)\ngoal (1 subgoal):\n 1. impl_of ahm_empty_const = ArrayHashMap_Impl.ahm_empty ()", "by(simp add: ahm_empty_const_def HashMap_inverse)"], ["", "lemma impl_of_ahm_update [code abstract]:\n  \"impl_of (ahm_update k v hm) = ArrayHashMap_Impl.ahm_update k v (impl_of hm)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. impl_of (ahm_update k v hm) =\n    ArrayHashMap_Impl.ahm_update k v (impl_of hm)", "by(simp add: ahm_update_def HashMap_inverse ahm_update_correct)"], ["", "lemma impl_of_ahm_delete [code abstract]:\n  \"impl_of (ahm_delete k hm) = ArrayHashMap_Impl.ahm_delete k (impl_of hm)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. impl_of (ahm_delete k hm) = ArrayHashMap_Impl.ahm_delete k (impl_of hm)", "by(simp add: ahm_delete_def HashMap_inverse ahm_delete_correct)"], ["", "lemma finite_dom_ahm_\\<alpha>[simp]: \"finite (dom (ahm_\\<alpha> hm))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (dom (ahm_\\<alpha> hm))", "by (simp add: ahm_\\<alpha>_def finite_dom_ahm_\\<alpha>)"], ["", "lemma ahm_empty_correct[simp]: \"ahm_\\<alpha> (ahm_empty ()) = Map.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ahm_\\<alpha> (ahm_empty ()) = Map.empty", "by(simp add: ahm_\\<alpha>_def ahm_empty_def ahm_empty_const_def HashMap_inverse)"], ["", "lemma ahm_lookup_correct[simp]: \"ahm_lookup k m = ahm_\\<alpha> m k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ahm_lookup k m = ahm_\\<alpha> m k", "by (simp add: ahm_lookup_def ArrayHashMap_Impl.ahm_lookup_def ahm_\\<alpha>_def)"], ["", "lemma ahm_update_correct[simp]: \"ahm_\\<alpha> (ahm_update k v hm) = (ahm_\\<alpha> hm)(k \\<mapsto> v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ahm_\\<alpha> (ahm_update k v hm) = ahm_\\<alpha> hm(k \\<mapsto> v)", "by (simp add: ahm_\\<alpha>_def ahm_update_def ahm_update_correct HashMap_inverse)"], ["", "lemma ahm_delete_correct[simp]:\n  \"ahm_\\<alpha> (ahm_delete k hm) = (ahm_\\<alpha> hm) |` (- {k})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ahm_\\<alpha> (ahm_delete k hm) = ahm_\\<alpha> hm |` (- {k})", "by (simp add: ahm_\\<alpha>_def ahm_delete_def HashMap_inverse ahm_delete_correct)"], ["", "lemma ahm_iteratei_impl[simp]: \"map_iterator (ahm_iteratei m) (ahm_\\<alpha> m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_iterator (ahm_iteratei m) (ahm_\\<alpha> m)", "unfolding ahm_iteratei_def ahm_\\<alpha>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_iterator (ArrayHashMap_Impl.ahm_iteratei (impl_of m))\n     (ArrayHashMap_Impl.ahm_\\<alpha> (impl_of m))", "apply (rule ahm_iteratei_correct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ArrayHashMap_Impl.ahm_invar (impl_of m)", "by simp"], ["", "subsection \\<open>ICF Integration\\<close>"], ["", "definition [icf_rec_def]: \"ahm_basic_ops \\<equiv> \\<lparr>\n  bmap_op_\\<alpha> = ahm_\\<alpha>,\n  bmap_op_invar = \\<lambda>_. True,\n  bmap_op_empty = ahm_empty,\n  bmap_op_lookup = ahm_lookup,\n  bmap_op_update = ahm_update,\n  bmap_op_update_dj = ahm_update, \\<comment> \\<open>TODO: We could use a more efficient bucket update here\\<close>\n  bmap_op_delete = ahm_delete,\n  bmap_op_list_it = ahm_iteratei\n\\<rparr>\""], ["", "setup Locale_Code.open_block"], ["", "interpretation ahm_basic: StdBasicMap ahm_basic_ops"], ["proof (prove)\ngoal (1 subgoal):\n 1. StdBasicMap ahm_basic_ops", "apply unfold_locales"], ["proof (prove)\ngoal (11 subgoals):\n 1. bmap_op_\\<alpha> ahm_basic_ops (bmap_op_empty ahm_basic_ops ()) =\n    Map.empty\n 2. bmap_op_invar ahm_basic_ops (bmap_op_empty ahm_basic_ops ())\n 3. \\<And>m k.\n       bmap_op_invar ahm_basic_ops m \\<Longrightarrow>\n       bmap_op_lookup ahm_basic_ops k m = bmap_op_\\<alpha> ahm_basic_ops m k\n 4. \\<And>m k v.\n       bmap_op_invar ahm_basic_ops m \\<Longrightarrow>\n       bmap_op_\\<alpha> ahm_basic_ops (bmap_op_update ahm_basic_ops k v m) =\n       bmap_op_\\<alpha> ahm_basic_ops m(k \\<mapsto> v)\n 5. \\<And>m k v.\n       bmap_op_invar ahm_basic_ops m \\<Longrightarrow>\n       bmap_op_invar ahm_basic_ops (bmap_op_update ahm_basic_ops k v m)\n 6. \\<And>m k v.\n       \\<lbrakk>bmap_op_invar ahm_basic_ops m;\n        k \\<notin> dom (bmap_op_\\<alpha> ahm_basic_ops m)\\<rbrakk>\n       \\<Longrightarrow> bmap_op_\\<alpha> ahm_basic_ops\n                          (bmap_op_update_dj ahm_basic_ops k v m) =\n                         bmap_op_\\<alpha> ahm_basic_ops m(k \\<mapsto> v)\n 7. \\<And>m k v.\n       \\<lbrakk>bmap_op_invar ahm_basic_ops m;\n        k \\<notin> dom (bmap_op_\\<alpha> ahm_basic_ops m)\\<rbrakk>\n       \\<Longrightarrow> bmap_op_invar ahm_basic_ops\n                          (bmap_op_update_dj ahm_basic_ops k v m)\n 8. \\<And>m k.\n       bmap_op_invar ahm_basic_ops m \\<Longrightarrow>\n       bmap_op_\\<alpha> ahm_basic_ops (bmap_op_delete ahm_basic_ops k m) =\n       bmap_op_\\<alpha> ahm_basic_ops m |` (- {k})\n 9. \\<And>m k.\n       bmap_op_invar ahm_basic_ops m \\<Longrightarrow>\n       bmap_op_invar ahm_basic_ops (bmap_op_delete ahm_basic_ops k m)\n 10. \\<And>m.\n        bmap_op_invar ahm_basic_ops m \\<Longrightarrow>\n        finite (dom (bmap_op_\\<alpha> ahm_basic_ops m))\nA total of 11 subgoals...", "apply (simp_all add: icf_rec_unf)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "setup Locale_Code.close_block"], ["", "definition [icf_rec_def]: \"ahm_ops \\<equiv> ahm_basic.dflt_ops\""], ["", "setup Locale_Code.open_block"], ["", "interpretation ahm: StdMap ahm_ops"], ["proof (prove)\ngoal (1 subgoal):\n 1. StdMap ahm_ops", "unfolding ahm_ops_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. StdMap ahm_basic.dflt_ops", "by (rule ahm_basic.dflt_ops_impl)"], ["", "interpretation ahm: StdMap_no_invar ahm_ops"], ["proof (prove)\ngoal (1 subgoal):\n 1. StdMap_no_invar ahm_ops", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s. ahm.invar s", "unfolding icf_rec_unf"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s. True", ".."], ["", "setup Locale_Code.close_block"], ["", "setup \\<open>ICF_Tools.revert_abbrevs \"ahm\"\\<close>"], ["", "lemma pi_ahm[proper_it]: \n  \"proper_it' ahm_iteratei ahm_iteratei\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it' ahm_iteratei ahm_iteratei", "unfolding ahm_iteratei_def[abs_def] \n    ArrayHashMap_Impl.ahm_iteratei_def ArrayHashMap_Impl.ahm_iteratei_aux_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it'\n     (\\<lambda>hm.\n         rec_hashmap\n          (\\<lambda>a n. rec_array (\\<lambda>xs. foldli (concat xs)) a)\n          (impl_of hm))\n     (\\<lambda>hm.\n         rec_hashmap\n          (\\<lambda>a n. rec_array (\\<lambda>xs. foldli (concat xs)) a)\n          (impl_of hm))", "apply (rule proper_it'I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       proper_it\n        (rec_hashmap\n          (\\<lambda>a n. rec_array (\\<lambda>xs. foldli (concat xs)) a)\n          (impl_of s))\n        (rec_hashmap\n          (\\<lambda>a n. rec_array (\\<lambda>xs. foldli (concat xs)) a)\n          (impl_of s))", "apply (case_tac \"impl_of s\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s x1 x2.\n       impl_of s = ArrayHashMap_Impl.hashmap.HashMap x1 x2 \\<Longrightarrow>\n       proper_it\n        (rec_hashmap\n          (\\<lambda>a n. rec_array (\\<lambda>xs. foldli (concat xs)) a)\n          (impl_of s))\n        (rec_hashmap\n          (\\<lambda>a n. rec_array (\\<lambda>xs. foldli (concat xs)) a)\n          (impl_of s))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s x1 x2.\n       impl_of s = ArrayHashMap_Impl.hashmap.HashMap x1 x2 \\<Longrightarrow>\n       proper_it (case x1 of Array xs \\<Rightarrow> foldli (concat xs))\n        (case x1 of Array xs \\<Rightarrow> foldli (concat xs))", "apply (rename_tac array nat)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s array nat.\n       impl_of s =\n       ArrayHashMap_Impl.hashmap.HashMap array nat \\<Longrightarrow>\n       proper_it (case array of Array xs \\<Rightarrow> foldli (concat xs))\n        (case array of Array xs \\<Rightarrow> foldli (concat xs))", "apply (case_tac array)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s array nat x.\n       \\<lbrakk>impl_of s = ArrayHashMap_Impl.hashmap.HashMap array nat;\n        array = Array x\\<rbrakk>\n       \\<Longrightarrow> proper_it\n                          (case array of\n                           Array xs \\<Rightarrow> foldli (concat xs))\n                          (case array of\n                           Array xs \\<Rightarrow> foldli (concat xs))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s array nat x.\n       \\<lbrakk>impl_of s = ArrayHashMap_Impl.hashmap.HashMap (Array x) nat;\n        array = Array x\\<rbrakk>\n       \\<Longrightarrow> proper_it (foldli (concat x)) (foldli (concat x))", "by (intro icf_proper_iteratorI)"], ["", "interpretation pi_ahm: proper_it_loc ahm_iteratei ahm_iteratei"], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it_loc ahm_iteratei ahm_iteratei", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it' ahm_iteratei ahm_iteratei", "apply (rule pi_ahm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Code generator test\\<close>"], ["", "definition test_codegen where \"test_codegen \\<equiv> (\n  ahm.add ,\n  ahm.add_dj ,\n  ahm.ball ,\n  ahm.bex ,\n  ahm.delete ,\n  ahm.empty ,\n  ahm.isEmpty ,\n  ahm.isSng ,\n  ahm.iterate ,\n  ahm.iteratei ,\n  ahm.list_it ,\n  ahm.lookup ,\n  ahm.restrict ,\n  ahm.sel ,\n  ahm.size ,\n  ahm.size_abort ,\n  ahm.sng ,\n  ahm.to_list ,\n  ahm.to_map ,\n  ahm.update ,\n  ahm.update_dj)\""], ["", "export_code test_codegen checking SML"], ["", "end"]]}