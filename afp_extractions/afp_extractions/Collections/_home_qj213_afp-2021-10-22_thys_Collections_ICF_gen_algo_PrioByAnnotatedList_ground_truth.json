{"file_name": "/home/qj213/afp-2021-10-22/thys/Collections/ICF/gen_algo/PrioByAnnotatedList.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Collections", "problem_names": ["lemma p_min_re_neut[simp]: \"p_min a Infty = a\"", "lemma p_min_le_neut[simp]: \"p_min Infty a = a\"", "lemma p_min_asso: \"p_min (p_min a b) c = p_min a (p_min b c)\"", "lemma lp_mono: \"class.monoid_add p_min Infty\"", "lemma p_less_le_not_le : \"p_less x y \\<longleftrightarrow> p_less_eq x y \\<and> \\<not> (p_less_eq y x)\"", "lemma p_order_refl : \"p_less_eq x x\"", "lemma p_le_inf : \"p_less_eq Infty x \\<Longrightarrow> x = Infty\"", "lemma p_order_trans : \"\\<lbrakk>p_less_eq x y; p_less_eq y z\\<rbrakk> \\<Longrightarrow> p_less_eq x z\"", "lemma p_linear2 : \"p_less_eq x y \\<or> p_less_eq y x\"", "lemmas alprio_defs =\n  alprio_invar_def\n  alprio_\\<alpha>_def\n  alprio_empty_def\n  alprio_isEmpty_def\n  alprio_insert_def\n  alprio_find_def\n  alprio_delete_def\n  alprio_meld_def", "lemma sum_list_split: \"sum_list (l @ (a::'a::monoid_add) # r) = (sum_list l) + a + (sum_list r)\"", "lemma p_linear: \"(x::('e, 'a::linorder) Prio) \\<le> y \\<or> y \\<le> x\"", "lemma p_min_mon: \"(x::(('e,'a::linorder) Prio)) \\<le> y \\<Longrightarrow> (z + x) \\<le> y\"", "lemma p_min_mon2: \"p_less_eq x y \\<Longrightarrow> p_less_eq (p_min z x) y\"", "lemma ls_min: \" \\<forall>x \\<in> set (xs:: ('e,'a::linorder) Prio list) . sum_list xs \\<le> x\"", "lemma infadd: \"x \\<noteq> Infty \\<Longrightarrow>x + y \\<noteq> Infty\"", "lemma prio_selects_one: \"a+b = a \\<or> a+b=(b::('e,'a::linorder) Prio)\"", "lemma sum_list_in_set: \"(l::('x \\<times> ('e,'a::linorder) Prio) list)\\<noteq>[] \\<Longrightarrow> \n  sum_list (map snd l) \\<in> set (map snd l)\"", "lemma p_unwrap_less_sum: \"snd (p_unwrap ((Prio e aa) + b)) \\<le> aa\"", "lemma prio_add_alb: \"\\<not> b \\<le> (a::('e,'a::linorder)Prio)  \\<Longrightarrow> b + a = a\"", "lemma prio_add_alb2: \" (a::('e,'a::linorder)Prio)  \\<le> a + b \\<Longrightarrow>  a + b = a\"", "lemma prio_add_abc:\n  assumes \"(l::('e,'a::linorder)Prio) + a \\<le> c\" \n  and \"\\<not> l \\<le> c\"\n  shows  \"\\<not> l \\<le> a\"", "lemma prio_add_abc2:\n  assumes \"(a::('e,'a::linorder)Prio) \\<le> a + b\" \n  shows \"a \\<le> b\"", "lemma alprio_empty_correct: \n  assumes \"al_empty \\<alpha> invar empt\"\n  shows \"prio_empty (alprio_\\<alpha> \\<alpha>) (alprio_invar \\<alpha> invar) (alprio_empty empt)\"", "lemma alprio_isEmpty_correct: \n  assumes \"al_isEmpty \\<alpha> invar isEmpty\"\n  shows \"prio_isEmpty (alprio_\\<alpha> \\<alpha>) (alprio_invar \\<alpha> invar) (alprio_isEmpty isEmpty)\"", "lemma alprio_insert_correct: \n  assumes \"al_consl \\<alpha> invar consl\"\n  shows \"prio_insert (alprio_\\<alpha> \\<alpha>) (alprio_invar \\<alpha> invar) (alprio_insert consl)\"", "lemma alprio_meld_correct: \n  assumes \"al_app \\<alpha> invar app\"\n  shows \"prio_meld (alprio_\\<alpha> \\<alpha>) (alprio_invar \\<alpha> invar) (alprio_meld app)\"", "lemma annot_not_inf :\n  assumes \"(alprio_invar \\<alpha> invar) s\" \n  and \"(alprio_\\<alpha> \\<alpha>) s \\<noteq> {#}\"\n  and \"al_annot \\<alpha> invar annot\"\n  shows \"annot s \\<noteq> Infty\"", "lemma annot_in_set: \n  assumes \"(alprio_invar \\<alpha> invar) s\" \n  and \"(alprio_\\<alpha> \\<alpha>) s \\<noteq> {#}\"\n  and \"al_annot \\<alpha> invar annot\"\n  shows \"p_unwrap (annot s) \\<in># ((alprio_\\<alpha> \\<alpha>) s)\"", "lemma  sum_list_less_elems: \"\\<forall>x\\<in>set xs. snd x \\<noteq> Infty \\<Longrightarrow>\n   \\<forall>y\\<in>set_mset (mset (map p_unwrap (map snd xs))).\n              snd (p_unwrap (sum_list (map snd xs))) \\<le> snd y\"", "lemma alprio_find_correct: \n  assumes  \"al_annot \\<alpha> invar annot\"\n  shows \"prio_find (alprio_\\<alpha> \\<alpha>) (alprio_invar \\<alpha> invar) (alprio_find annot)\"", "lemma delpred_mon: \n  \"\\<forall>(a:: ('e, 'a::linorder) Prio) b. ((\\<lambda> x. x \\<le> y) a \n    \\<longrightarrow> (\\<lambda> x. x \\<le> y) (a + b)) \"", "lemma alpriodel_invar: \n  assumes \"alprio_invar \\<alpha> invar s\"\n  and \"al_annot \\<alpha> invar annot\"\n  and \"alprio_\\<alpha> \\<alpha> s \\<noteq> {#}\"\n  and \"al_splits \\<alpha> invar splits\"\n  and \"al_app \\<alpha> invar app\"\n  shows \"alprio_invar \\<alpha> invar (alprio_delete splits annot app s)\"", "lemma sum_list_elem:\n  assumes \" ins = l @ (a::('e,'a::linorder)Prio) # r\"  \n  and \"\\<not> sum_list l \\<le> sum_list ins\"  \n  and \"sum_list l + a \\<le> sum_list ins \"\n  shows \" a = sum_list ins\"", "lemma alpriodel_right:\n  assumes \"alprio_invar \\<alpha> invar s\"\n  and \"al_annot \\<alpha> invar annot\"\n  and \"alprio_\\<alpha> \\<alpha> s \\<noteq> {#}\"\n  and \"al_splits \\<alpha> invar splits\"\n  and \"al_app \\<alpha> invar app\"\n  shows \"alprio_\\<alpha> \\<alpha> (alprio_delete splits annot app s) = \n          alprio_\\<alpha> \\<alpha> s - {#p_unwrap (annot s)#}\"", "lemma alprio_delete_correct: \n  assumes \"al_annot \\<alpha> invar annot\"\n  and \"al_splits \\<alpha> invar splits\"\n  and \"al_app \\<alpha> invar app\"\n  shows \"prio_delete (alprio_\\<alpha> \\<alpha>) (alprio_invar \\<alpha> invar) \n           (alprio_find annot) (alprio_delete splits annot app)\"", "lemmas alprio_correct =\n  alprio_empty_correct\n  alprio_isEmpty_correct\n  alprio_insert_correct\n  alprio_delete_correct\n  alprio_find_correct\n  alprio_meld_correct", "lemma alprio_ops_impl: \"StdPrio alprio_ops\""], "translations": [["", "lemma p_min_re_neut[simp]: \"p_min a Infty = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p_min a Infty = a", "by (induct a) auto"], ["", "lemma p_min_le_neut[simp]: \"p_min Infty a = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p_min Infty a = a", "by (induct a) auto"], ["", "lemma p_min_asso: \"p_min (p_min a b) c = p_min a (p_min b c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p_min (p_min a b) c = p_min a (p_min b c)", "apply(induct a b  rule: p_min.induct )"], ["proof (prove)\ngoal (4 subgoals):\n 1. p_min (p_min Infty Infty) c = p_min Infty (p_min Infty c)\n 2. \\<And>e a.\n       p_min (p_min Infty (Prio e a)) c = p_min Infty (p_min (Prio e a) c)\n 3. \\<And>e a.\n       p_min (p_min (Prio e a) Infty) c = p_min (Prio e a) (p_min Infty c)\n 4. \\<And>e1 a e2 b.\n       p_min (p_min (Prio e1 a) (Prio e2 b)) c =\n       p_min (Prio e1 a) (p_min (Prio e2 b) c)", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>e1 a e2 b.\n       a \\<le> b \\<Longrightarrow>\n       p_min (Prio e1 a) c = p_min (Prio e1 a) (p_min (Prio e2 b) c)\n 2. \\<And>e1 a e2 b.\n       \\<not> a \\<le> b \\<Longrightarrow>\n       p_min (Prio e2 b) c = p_min (Prio e1 a) (p_min (Prio e2 b) c)", "apply (induct c)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>e1 a e2 b.\n       a \\<le> b \\<Longrightarrow>\n       p_min (Prio e1 a) Infty = p_min (Prio e1 a) (p_min (Prio e2 b) Infty)\n 2. \\<And>x1 x2 e1 a e2 b.\n       a \\<le> b \\<Longrightarrow>\n       p_min (Prio e1 a) (Prio x1 x2) =\n       p_min (Prio e1 a) (p_min (Prio e2 b) (Prio x1 x2))\n 3. \\<And>e1 a e2 b.\n       \\<not> a \\<le> b \\<Longrightarrow>\n       p_min (Prio e2 b) c = p_min (Prio e1 a) (p_min (Prio e2 b) c)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>e1 a e2 b.\n       \\<not> a \\<le> b \\<Longrightarrow>\n       p_min (Prio e2 b) c = p_min (Prio e1 a) (p_min (Prio e2 b) c)", "apply (induct c)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>e1 a e2 b.\n       \\<not> a \\<le> b \\<Longrightarrow>\n       p_min (Prio e2 b) Infty = p_min (Prio e1 a) (p_min (Prio e2 b) Infty)\n 2. \\<And>x1 x2 e1 a e2 b.\n       \\<not> a \\<le> b \\<Longrightarrow>\n       p_min (Prio e2 b) (Prio x1 x2) =\n       p_min (Prio e1 a) (p_min (Prio e2 b) (Prio x1 x2))", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma lp_mono: \"class.monoid_add p_min Infty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.monoid_add p_min Infty", "by unfold_locales (auto simp add: p_min_asso)"], ["", "instantiation Prio :: (type,linorder) monoid_add\nbegin"], ["", "definition zero_def: \"0 == Infty\""], ["", "definition plus_def: \"a+b == p_min a b\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) Prio, monoid_add_class)", "by \n  intro_classes \n(auto simp add: p_min_asso zero_def plus_def)"], ["", "end"], ["", "fun p_less_eq :: \"('e, 'a::linorder) Prio \\<Rightarrow> ('e, 'a) Prio \\<Rightarrow> bool\" where\n  \"p_less_eq (Prio e a) (Prio f b) = (a \\<le> b)\"|\n  \"p_less_eq  _ Infty = True\"|\n  \"p_less_eq Infty (Prio e a) = False\""], ["", "fun p_less :: \"('e, 'a::linorder) Prio \\<Rightarrow> ('e, 'a) Prio \\<Rightarrow> bool\" where\n  \"p_less (Prio e a) (Prio f b) = (a < b)\"|\n  \"p_less (Prio e a) Infty = True\"|\n  \"p_less Infty _ = False\""], ["", "lemma p_less_le_not_le : \"p_less x y \\<longleftrightarrow> p_less_eq x y \\<and> \\<not> (p_less_eq y x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p_less x y = (p_less_eq x y \\<and> \\<not> p_less_eq y x)", "by (induct x y rule: p_less.induct) auto"], ["", "lemma p_order_refl : \"p_less_eq x x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p_less_eq x x", "by (induct x) auto"], ["", "lemma p_le_inf : \"p_less_eq Infty x \\<Longrightarrow> x = Infty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p_less_eq Infty x \\<Longrightarrow> x = Infty", "by (induct x) auto"], ["", "lemma p_order_trans : \"\\<lbrakk>p_less_eq x y; p_less_eq y z\\<rbrakk> \\<Longrightarrow> p_less_eq x z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p_less_eq x y; p_less_eq y z\\<rbrakk>\n    \\<Longrightarrow> p_less_eq x z", "apply (induct y z rule: p_less.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>e a f b.\n       \\<lbrakk>p_less_eq x (Prio e a);\n        p_less_eq (Prio e a) (Prio f b)\\<rbrakk>\n       \\<Longrightarrow> p_less_eq x (Prio f b)\n 2. \\<And>e a.\n       \\<lbrakk>p_less_eq x (Prio e a); p_less_eq (Prio e a) Infty\\<rbrakk>\n       \\<Longrightarrow> p_less_eq x Infty\n 3. \\<And>uu_.\n       \\<lbrakk>p_less_eq x Infty; p_less_eq Infty uu_\\<rbrakk>\n       \\<Longrightarrow> p_less_eq x uu_", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>e a f b.\n       \\<lbrakk>p_less_eq x (Prio e a); a \\<le> b\\<rbrakk>\n       \\<Longrightarrow> p_less_eq x (Prio f b)\n 2. \\<And>uu_. p_less_eq Infty uu_ \\<Longrightarrow> p_less_eq x uu_", "apply (induct x)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>e a f b.\n       \\<lbrakk>p_less_eq Infty (Prio e a); a \\<le> b\\<rbrakk>\n       \\<Longrightarrow> p_less_eq Infty (Prio f b)\n 2. \\<And>x1 x2 e a f b.\n       \\<lbrakk>p_less_eq (Prio x1 x2) (Prio e a); a \\<le> b\\<rbrakk>\n       \\<Longrightarrow> p_less_eq (Prio x1 x2) (Prio f b)\n 3. \\<And>uu_. p_less_eq Infty uu_ \\<Longrightarrow> p_less_eq x uu_", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>uu_. p_less_eq Infty uu_ \\<Longrightarrow> p_less_eq x uu_", "apply (cases x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>uu_.\n       \\<lbrakk>p_less_eq Infty uu_; x = Infty\\<rbrakk>\n       \\<Longrightarrow> p_less_eq x uu_\n 2. \\<And>uu_ x21 x22.\n       \\<lbrakk>p_less_eq Infty uu_; x = Prio x21 x22\\<rbrakk>\n       \\<Longrightarrow> p_less_eq x uu_", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>uu_ x21 x22.\n       \\<lbrakk>p_less_eq Infty uu_; x = Prio x21 x22\\<rbrakk>\n       \\<Longrightarrow> p_less_eq (Prio x21 x22) uu_", "apply(induct x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>uu_ x21 x22.\n       \\<lbrakk>p_less_eq Infty uu_; Infty = Prio x21 x22\\<rbrakk>\n       \\<Longrightarrow> p_less_eq (Prio x21 x22) uu_\n 2. \\<And>x1 x2 uu_ x21 x22.\n       \\<lbrakk>p_less_eq Infty uu_; Prio x1 x2 = Prio x21 x22\\<rbrakk>\n       \\<Longrightarrow> p_less_eq (Prio x21 x22) uu_", "apply (auto simp add: p_le_inf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2 uu_ x21.\n       p_less_eq Infty uu_ \\<Longrightarrow> p_less_eq (Prio x21 x2) uu_", "apply (metis p_le_inf p_less_eq.simps(2))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma p_linear2 : \"p_less_eq x y \\<or> p_less_eq y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p_less_eq x y \\<or> p_less_eq y x", "apply (induct x y rule: p_less_eq.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>e a f b.\n       p_less_eq (Prio e a) (Prio f b) \\<or> p_less_eq (Prio f b) (Prio e a)\n 2. \\<And>uu_. p_less_eq uu_ Infty \\<or> p_less_eq Infty uu_\n 3. \\<And>e a. p_less_eq Infty (Prio e a) \\<or> p_less_eq (Prio e a) Infty", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "instantiation Prio :: (type, linorder) preorder\nbegin"], ["", "definition plesseq_def: \"less_eq = p_less_eq\""], ["", "definition pless_def: \"less = p_less\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) Prio, preorder_class)", "apply (intro_classes)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z", "apply (simp only: p_less_le_not_le pless_def plesseq_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<le> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z", "apply (simp only: p_order_refl plesseq_def pless_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z", "apply (simp only: plesseq_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>p_less_eq x y; p_less_eq y z\\<rbrakk>\n       \\<Longrightarrow> p_less_eq x z", "apply (metis p_order_trans)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "subsubsection \"Operations\""], ["", "definition alprio_\\<alpha> :: \"('s \\<Rightarrow> (unit \\<times> ('e,'a::linorder) Prio) list) \n  \\<Rightarrow> 's \\<Rightarrow> ('e \\<times> 'a::linorder) multiset\"\n  where \n  \"alprio_\\<alpha> \\<alpha> al == (mset (map p_unwrap (map snd (\\<alpha> al))))\""], ["", "definition alprio_invar :: \"('s \\<Rightarrow> (unit \\<times> ('c, 'd::linorder) Prio) list) \n  \\<Rightarrow> ('s \\<Rightarrow> bool) \\<Rightarrow> 's \\<Rightarrow> bool\" \n  where\n  \"alprio_invar \\<alpha> invar al == invar al \\<and> (\\<forall> x\\<in>set (\\<alpha> al). snd x\\<noteq>Infty)\""], ["", "definition alprio_empty  where \n  \"alprio_empty empt = empt\""], ["", "definition alprio_isEmpty  where \n  \"alprio_isEmpty isEmpty = isEmpty\""], ["", "definition alprio_insert :: \"(unit \\<Rightarrow> ('e,'a) Prio \\<Rightarrow> 's \\<Rightarrow> 's) \n  \\<Rightarrow> 'e \\<Rightarrow> 'a::linorder \\<Rightarrow> 's  \\<Rightarrow> 's\"  \n  where\n  \"alprio_insert consl e a s = consl () (Prio e a) s\""], ["", "definition alprio_find :: \"('s \\<Rightarrow> ('e,'a::linorder) Prio) \\<Rightarrow> 's \\<Rightarrow> ('e \\<times> 'a)\" \nwhere\n\"alprio_find annot s = p_unwrap (annot s)\""], ["", "definition alprio_delete :: \"((('e,'a::linorder) Prio \\<Rightarrow> bool) \n  \\<Rightarrow> ('e,'a) Prio \\<Rightarrow> 's \\<Rightarrow> ('s \\<times> (unit \\<times> ('e,'a) Prio) \\<times> 's)) \n                      \\<Rightarrow> ('s \\<Rightarrow> ('e,'a) Prio) \\<Rightarrow> ('s \\<Rightarrow> 's \\<Rightarrow> 's) \\<Rightarrow> 's \\<Rightarrow> 's\" \n  where\n  \"alprio_delete splits annot app s = (let (l, _ , r) \n    = splits (\\<lambda> x. x\\<le>(annot s)) Infty s in app l r) \""], ["", "definition alprio_meld where\n  \"alprio_meld app = app\""], ["", "lemmas alprio_defs =\n  alprio_invar_def\n  alprio_\\<alpha>_def\n  alprio_empty_def\n  alprio_isEmpty_def\n  alprio_insert_def\n  alprio_find_def\n  alprio_delete_def\n  alprio_meld_def"], ["", "subsection \"Correctness\""], ["", "subsubsection \"Auxiliary Lemmas\""], ["", "lemma sum_list_split: \"sum_list (l @ (a::'a::monoid_add) # r) = (sum_list l) + a + (sum_list r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (l @ a # r) = sum_list l + a + sum_list r", "by (induct l) (auto simp add: add.assoc)"], ["", "lemma p_linear: \"(x::('e, 'a::linorder) Prio) \\<le> y \\<or> y \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<or> y \\<le> x", "by (unfold plesseq_def) (simp only: p_linear2)"], ["", "lemma p_min_mon: \"(x::(('e,'a::linorder) Prio)) \\<le> y \\<Longrightarrow> (z + x) \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> z + x \\<le> y", "apply (unfold plus_def plesseq_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. p_less_eq x y \\<Longrightarrow> p_less_eq (p_min z x) y", "apply (induct x y rule: p_less_eq.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>e a f b.\n       p_less_eq (Prio e a) (Prio f b) \\<Longrightarrow>\n       p_less_eq (p_min z (Prio e a)) (Prio f b)\n 2. \\<And>uu_.\n       p_less_eq uu_ Infty \\<Longrightarrow> p_less_eq (p_min z uu_) Infty\n 3. \\<And>e a.\n       p_less_eq Infty (Prio e a) \\<Longrightarrow>\n       p_less_eq (p_min z Infty) (Prio e a)", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>e a f b.\n       a \\<le> b \\<Longrightarrow> p_less_eq (p_min z (Prio e a)) (Prio f b)", "apply (induct z)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>e a f b.\n       a \\<le> b \\<Longrightarrow>\n       p_less_eq (p_min Infty (Prio e a)) (Prio f b)\n 2. \\<And>x1 x2 e a f b.\n       a \\<le> b \\<Longrightarrow>\n       p_less_eq (p_min (Prio x1 x2) (Prio e a)) (Prio f b)", "apply (auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma p_min_mon2: \"p_less_eq x y \\<Longrightarrow> p_less_eq (p_min z x) y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p_less_eq x y \\<Longrightarrow> p_less_eq (p_min z x) y", "apply (induct x y rule: p_less_eq.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>e a f b.\n       p_less_eq (Prio e a) (Prio f b) \\<Longrightarrow>\n       p_less_eq (p_min z (Prio e a)) (Prio f b)\n 2. \\<And>uu_.\n       p_less_eq uu_ Infty \\<Longrightarrow> p_less_eq (p_min z uu_) Infty\n 3. \\<And>e a.\n       p_less_eq Infty (Prio e a) \\<Longrightarrow>\n       p_less_eq (p_min z Infty) (Prio e a)", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>e a f b.\n       a \\<le> b \\<Longrightarrow> p_less_eq (p_min z (Prio e a)) (Prio f b)", "apply (induct z)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>e a f b.\n       a \\<le> b \\<Longrightarrow>\n       p_less_eq (p_min Infty (Prio e a)) (Prio f b)\n 2. \\<And>x1 x2 e a f b.\n       a \\<le> b \\<Longrightarrow>\n       p_less_eq (p_min (Prio x1 x2) (Prio e a)) (Prio f b)", "apply (auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ls_min: \" \\<forall>x \\<in> set (xs:: ('e,'a::linorder) Prio list) . sum_list xs \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set xs. sum_list xs \\<le> x", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>set []. sum_list [] \\<le> x\n 2. \\<And>a xs.\n       \\<forall>x\\<in>set xs. sum_list xs \\<le> x \\<Longrightarrow>\n       \\<forall>x\\<in>set (a # xs). sum_list (a # xs) \\<le> x", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>set []. sum_list [] \\<le> x\n 2. \\<And>a xs.\n       \\<forall>x\\<in>set xs. sum_list xs \\<le> x \\<Longrightarrow>\n       \\<forall>x\\<in>set (a # xs). sum_list (a # xs) \\<le> x", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set []. sum_list [] \\<le> x", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set []. sum_list [] \\<le> x\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<forall>x\\<in>set xs. sum_list xs \\<le> x \\<Longrightarrow>\n       \\<forall>x\\<in>set (a # xs). sum_list (a # xs) \\<le> x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<forall>x\\<in>set xs. sum_list xs \\<le> x \\<Longrightarrow>\n       \\<forall>x\\<in>set (a # xs). sum_list (a # xs) \\<le> x", "case (Cons a ins)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set ins. sum_list ins \\<le> x\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<forall>x\\<in>set xs. sum_list xs \\<le> x \\<Longrightarrow>\n       \\<forall>x\\<in>set (a # xs). sum_list (a # xs) \\<le> x", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set ins. sum_list ins \\<le> x\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (a # ins). sum_list (a # ins) \\<le> x", "apply (auto simp add: plus_def plesseq_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>set ins. p_less_eq (sum_list ins) x \\<Longrightarrow>\n    p_less_eq (p_min a (sum_list ins)) a\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>x\\<in>set ins. p_less_eq (sum_list ins) x;\n        x \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> p_less_eq (p_min a (sum_list ins)) x", "apply (cases a)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>x\\<in>set ins. p_less_eq (sum_list ins) x;\n     a = Infty\\<rbrakk>\n    \\<Longrightarrow> p_less_eq (p_min a (sum_list ins)) a\n 2. \\<And>x21 x22.\n       \\<lbrakk>\\<forall>x\\<in>set ins. p_less_eq (sum_list ins) x;\n        a = Prio x21 x22\\<rbrakk>\n       \\<Longrightarrow> p_less_eq (p_min a (sum_list ins)) a\n 3. \\<And>x.\n       \\<lbrakk>\\<forall>x\\<in>set ins. p_less_eq (sum_list ins) x;\n        x \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> p_less_eq (p_min a (sum_list ins)) x", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<forall>x\\<in>set ins. p_less_eq (sum_list ins) x;\n        a = Prio x21 x22\\<rbrakk>\n       \\<Longrightarrow> p_less_eq (p_min (Prio x21 x22) (sum_list ins))\n                          (Prio x21 x22)\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>x\\<in>set ins. p_less_eq (sum_list ins) x;\n        x \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> p_less_eq (p_min a (sum_list ins)) x", "apply (cases \"sum_list ins\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<forall>x\\<in>set ins. p_less_eq (sum_list ins) x;\n        a = Prio x21 x22; sum_list ins = Infty\\<rbrakk>\n       \\<Longrightarrow> p_less_eq (p_min (Prio x21 x22) (sum_list ins))\n                          (Prio x21 x22)\n 2. \\<And>x21 x22 x21a x22a.\n       \\<lbrakk>\\<forall>x\\<in>set ins. p_less_eq (sum_list ins) x;\n        a = Prio x21 x22; sum_list ins = Prio x21a x22a\\<rbrakk>\n       \\<Longrightarrow> p_less_eq (p_min (Prio x21 x22) (sum_list ins))\n                          (Prio x21 x22)\n 3. \\<And>x.\n       \\<lbrakk>\\<forall>x\\<in>set ins. p_less_eq (sum_list ins) x;\n        x \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> p_less_eq (p_min a (sum_list ins)) x", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>x\\<in>set ins. p_less_eq (sum_list ins) x;\n        x \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> p_less_eq (p_min a (sum_list ins)) x", "apply (case_tac x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>x\\<in>set ins. p_less_eq (sum_list ins) x;\n        x \\<in> set ins; x = Infty\\<rbrakk>\n       \\<Longrightarrow> p_less_eq (p_min a (sum_list ins)) x\n 2. \\<And>x x21 x22.\n       \\<lbrakk>\\<forall>x\\<in>set ins. p_less_eq (sum_list ins) x;\n        x \\<in> set ins; x = Prio x21 x22\\<rbrakk>\n       \\<Longrightarrow> p_less_eq (p_min a (sum_list ins)) x", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<forall>x\\<in>set ins. p_less_eq (sum_list ins) x;\n        Prio x21 x22 \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> p_less_eq (p_min a (sum_list ins)) (Prio x21 x22)", "apply (cases a)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<forall>x\\<in>set ins. p_less_eq (sum_list ins) x;\n        Prio x21 x22 \\<in> set ins; a = Infty\\<rbrakk>\n       \\<Longrightarrow> p_less_eq (p_min a (sum_list ins)) (Prio x21 x22)\n 2. \\<And>x21 x22 x21a x22a.\n       \\<lbrakk>\\<forall>x\\<in>set ins. p_less_eq (sum_list ins) x;\n        Prio x21 x22 \\<in> set ins; a = Prio x21a x22a\\<rbrakk>\n       \\<Longrightarrow> p_less_eq (p_min a (sum_list ins)) (Prio x21 x22)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x21a x22a.\n       \\<lbrakk>\\<forall>x\\<in>set ins. p_less_eq (sum_list ins) x;\n        Prio x21 x22 \\<in> set ins; a = Prio x21a x22a\\<rbrakk>\n       \\<Longrightarrow> p_less_eq (p_min (Prio x21a x22a) (sum_list ins))\n                          (Prio x21 x22)", "apply (cases \"sum_list ins\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x21 x22 x21a x22a.\n       \\<lbrakk>\\<forall>x\\<in>set ins. p_less_eq (sum_list ins) x;\n        Prio x21 x22 \\<in> set ins; a = Prio x21a x22a;\n        sum_list ins = Infty\\<rbrakk>\n       \\<Longrightarrow> p_less_eq (p_min (Prio x21a x22a) (sum_list ins))\n                          (Prio x21 x22)\n 2. \\<And>x21 x22 x21a x22a x21b x22b.\n       \\<lbrakk>\\<forall>x\\<in>set ins. p_less_eq (sum_list ins) x;\n        Prio x21 x22 \\<in> set ins; a = Prio x21a x22a;\n        sum_list ins = Prio x21b x22b\\<rbrakk>\n       \\<Longrightarrow> p_less_eq (p_min (Prio x21a x22a) (sum_list ins))\n                          (Prio x21 x22)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (a # ins). sum_list (a # ins) \\<le> x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma infadd: \"x \\<noteq> Infty \\<Longrightarrow>x + y \\<noteq> Infty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> Infty \\<Longrightarrow> x + y \\<noteq> Infty", "apply (unfold plus_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> Infty \\<Longrightarrow> p_min x y \\<noteq> Infty", "apply (induct x y rule: p_min.induct)"], ["proof (prove)\ngoal (4 subgoals):\n 1. Infty \\<noteq> Infty \\<Longrightarrow> p_min Infty Infty \\<noteq> Infty\n 2. \\<And>e a.\n       Infty \\<noteq> Infty \\<Longrightarrow>\n       p_min Infty (Prio e a) \\<noteq> Infty\n 3. \\<And>e a.\n       Prio e a \\<noteq> Infty \\<Longrightarrow>\n       p_min (Prio e a) Infty \\<noteq> Infty\n 4. \\<And>e1 a e2 b.\n       Prio e1 a \\<noteq> Infty \\<Longrightarrow>\n       p_min (Prio e1 a) (Prio e2 b) \\<noteq> Infty", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma prio_selects_one: \"a+b = a \\<or> a+b=(b::('e,'a::linorder) Prio)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a + b = a \\<or> a + b = b", "apply (simp add: plus_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. p_min a b = a \\<or> p_min a b = b", "apply (cases \"(a,b)\" rule: p_min.cases)"], ["proof (prove)\ngoal (4 subgoals):\n 1. (a, b) = (Infty, Infty) \\<Longrightarrow>\n    p_min a b = a \\<or> p_min a b = b\n 2. \\<And>e aa.\n       (a, b) = (Infty, Prio e aa) \\<Longrightarrow>\n       p_min a b = a \\<or> p_min a b = b\n 3. \\<And>e aa.\n       (a, b) = (Prio e aa, Infty) \\<Longrightarrow>\n       p_min a b = a \\<or> p_min a b = b\n 4. \\<And>e1 aa e2 ba.\n       (a, b) = (Prio e1 aa, Prio e2 ba) \\<Longrightarrow>\n       p_min a b = a \\<or> p_min a b = b", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sum_list_in_set: \"(l::('x \\<times> ('e,'a::linorder) Prio) list)\\<noteq>[] \\<Longrightarrow> \n  sum_list (map snd l) \\<in> set (map snd l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<noteq> [] \\<Longrightarrow>\n    sum_list (map snd l) \\<in> set (map snd l)", "apply (induct l)"], ["proof (prove)\ngoal (2 subgoals):\n 1. [] \\<noteq> [] \\<Longrightarrow>\n    sum_list (map snd []) \\<in> set (map snd [])\n 2. \\<And>a l.\n       \\<lbrakk>l \\<noteq> [] \\<Longrightarrow>\n                sum_list (map snd l) \\<in> set (map snd l);\n        a # l \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> sum_list (map snd (a # l))\n                         \\<in> set (map snd (a # l))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a l.\n       \\<lbrakk>l \\<noteq> [] \\<Longrightarrow>\n                sum_list (map snd l) \\<in> set (map snd l);\n        a # l \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> sum_list (map snd (a # l))\n                         \\<in> set (map snd (a # l))", "apply (case_tac l)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a l.\n       \\<lbrakk>l \\<noteq> [] \\<Longrightarrow>\n                sum_list (map snd l) \\<in> set (map snd l);\n        a # l \\<noteq> []; l = []\\<rbrakk>\n       \\<Longrightarrow> sum_list (map snd (a # l))\n                         \\<in> set (map snd (a # l))\n 2. \\<And>a l aa list.\n       \\<lbrakk>l \\<noteq> [] \\<Longrightarrow>\n                sum_list (map snd l) \\<in> set (map snd l);\n        a # l \\<noteq> []; l = aa # list\\<rbrakk>\n       \\<Longrightarrow> sum_list (map snd (a # l))\n                         \\<in> set (map snd (a # l))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a l aa list.\n       \\<lbrakk>l \\<noteq> [] \\<Longrightarrow>\n                sum_list (map snd l) \\<in> set (map snd l);\n        a # l \\<noteq> []; l = aa # list\\<rbrakk>\n       \\<Longrightarrow> sum_list (map snd (a # l))\n                         \\<in> set (map snd (a # l))", "using prio_selects_one"], ["proof (prove)\nusing this:\n  ?a + ?b = ?a \\<or> ?a + ?b = ?b\n\ngoal (1 subgoal):\n 1. \\<And>a l aa list.\n       \\<lbrakk>l \\<noteq> [] \\<Longrightarrow>\n                sum_list (map snd l) \\<in> set (map snd l);\n        a # l \\<noteq> []; l = aa # list\\<rbrakk>\n       \\<Longrightarrow> sum_list (map snd (a # l))\n                         \\<in> set (map snd (a # l))", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b ba list.\n       \\<lbrakk>\\<And>a b. a + b = a \\<or> a + b = b; b + ba \\<noteq> b;\n        b + ba \\<notin> snd ` set list;\n        ba + sum_list (map snd list) = ba\\<rbrakk>\n       \\<Longrightarrow> b + ba = ba\n 2. \\<And>b ba list a.\n       \\<lbrakk>\\<And>a b. a + b = a \\<or> a + b = b;\n        b + (ba + sum_list (map snd list)) \\<noteq> b;\n        b + (ba + sum_list (map snd list)) \\<notin> snd ` set list;\n        (a, ba + sum_list (map snd list)) \\<in> set list\\<rbrakk>\n       \\<Longrightarrow> b + (ba + sum_list (map snd list)) = ba", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b ba list a.\n       \\<lbrakk>\\<And>a b. a + b = a \\<or> a + b = b;\n        b + (ba + sum_list (map snd list)) \\<noteq> b;\n        b + (ba + sum_list (map snd list)) \\<notin> snd ` set list;\n        (a, ba + sum_list (map snd list)) \\<in> set list\\<rbrakk>\n       \\<Longrightarrow> b + (ba + sum_list (map snd list)) = ba", "apply force"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma p_unwrap_less_sum: \"snd (p_unwrap ((Prio e aa) + b)) \\<le> aa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (p_unwrap (Prio e aa + b)) \\<le> aa", "apply (cases b)"], ["proof (prove)\ngoal (2 subgoals):\n 1. b = Infty \\<Longrightarrow> snd (p_unwrap (Prio e aa + b)) \\<le> aa\n 2. \\<And>x21 x22.\n       b = Prio x21 x22 \\<Longrightarrow>\n       snd (p_unwrap (Prio e aa + b)) \\<le> aa", "apply (auto simp add: plus_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma prio_add_alb: \"\\<not> b \\<le> (a::('e,'a::linorder)Prio)  \\<Longrightarrow> b + a = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> b \\<le> a \\<Longrightarrow> b + a = a", "by (auto simp add: plus_def, cases \"(a,b)\" rule: p_min.cases) (auto simp add: plesseq_def)"], ["", "lemma prio_add_alb2: \" (a::('e,'a::linorder)Prio)  \\<le> a + b \\<Longrightarrow>  a + b = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> a + b \\<Longrightarrow> a + b = a", "by (auto simp add: plus_def, cases \"(a,b)\" rule: p_min.cases) (auto simp add: plesseq_def)"], ["", "lemma prio_add_abc:\n  assumes \"(l::('e,'a::linorder)Prio) + a \\<le> c\" \n  and \"\\<not> l \\<le> c\"\n  shows  \"\\<not> l \\<le> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> l \\<le> a", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<not> l \\<le> a \\<Longrightarrow> False", "assume \"\\<not> \\<not> l \\<le> a\""], ["proof (state)\nthis:\n  \\<not> \\<not> l \\<le> a\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> l \\<le> a \\<Longrightarrow> False", "with assms"], ["proof (chain)\npicking this:\n  l + a \\<le> c\n  \\<not> l \\<le> c\n  \\<not> \\<not> l \\<le> a", "have \"l + a = l\""], ["proof (prove)\nusing this:\n  l + a \\<le> c\n  \\<not> l \\<le> c\n  \\<not> \\<not> l \\<le> a\n\ngoal (1 subgoal):\n 1. l + a = l", "apply (auto simp add: plus_def plesseq_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p_less_eq (p_min l a) c; \\<not> p_less_eq l c;\n     p_less_eq l a\\<rbrakk>\n    \\<Longrightarrow> p_min l a = l", "apply (cases \"(l,a)\" rule: p_less_eq.cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>e aa f b.\n       \\<lbrakk>p_less_eq (p_min l a) c; \\<not> p_less_eq l c;\n        p_less_eq l a; (l, a) = (Prio e aa, Prio f b)\\<rbrakk>\n       \\<Longrightarrow> p_min l a = l\n 2. \\<And>uu_.\n       \\<lbrakk>p_less_eq (p_min l a) c; \\<not> p_less_eq l c;\n        p_less_eq l a; (l, a) = (uu_, Infty)\\<rbrakk>\n       \\<Longrightarrow> p_min l a = l\n 3. \\<And>e aa.\n       \\<lbrakk>p_less_eq (p_min l a) c; \\<not> p_less_eq l c;\n        p_less_eq l a; (l, a) = (Infty, Prio e aa)\\<rbrakk>\n       \\<Longrightarrow> p_min l a = l", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  l + a = l\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> l \\<le> a \\<Longrightarrow> False", "with assms"], ["proof (chain)\npicking this:\n  l + a \\<le> c\n  \\<not> l \\<le> c\n  l + a = l", "show False"], ["proof (prove)\nusing this:\n  l + a \\<le> c\n  \\<not> l \\<le> c\n  l + a = l\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma prio_add_abc2:\n  assumes \"(a::('e,'a::linorder)Prio) \\<le> a + b\" \n  shows \"a \\<le> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> b", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> a \\<le> b \\<Longrightarrow> False", "assume ann: \"\\<not> a \\<le> b\""], ["proof (state)\nthis:\n  \\<not> a \\<le> b\n\ngoal (1 subgoal):\n 1. \\<not> a \\<le> b \\<Longrightarrow> False", "hence \"a + b = b\""], ["proof (prove)\nusing this:\n  \\<not> a \\<le> b\n\ngoal (1 subgoal):\n 1. a + b = b", "apply (auto simp add: plus_def plesseq_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> p_less_eq a b \\<Longrightarrow> p_min a b = b", "apply (cases \"(a,b)\" rule: p_min.cases)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<not> p_less_eq a b; (a, b) = (Infty, Infty)\\<rbrakk>\n    \\<Longrightarrow> p_min a b = b\n 2. \\<And>e aa.\n       \\<lbrakk>\\<not> p_less_eq a b; (a, b) = (Infty, Prio e aa)\\<rbrakk>\n       \\<Longrightarrow> p_min a b = b\n 3. \\<And>e aa.\n       \\<lbrakk>\\<not> p_less_eq a b; (a, b) = (Prio e aa, Infty)\\<rbrakk>\n       \\<Longrightarrow> p_min a b = b\n 4. \\<And>e1 aa e2 ba.\n       \\<lbrakk>\\<not> p_less_eq a b;\n        (a, b) = (Prio e1 aa, Prio e2 ba)\\<rbrakk>\n       \\<Longrightarrow> p_min a b = b", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  a + b = b\n\ngoal (1 subgoal):\n 1. \\<not> a \\<le> b \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  a + b = b\n\ngoal (1 subgoal):\n 1. False", "using assms ann"], ["proof (prove)\nusing this:\n  a + b = b\n  a \\<le> a + b\n  \\<not> a \\<le> b\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \"Empty\""], ["", "lemma alprio_empty_correct: \n  assumes \"al_empty \\<alpha> invar empt\"\n  shows \"prio_empty (alprio_\\<alpha> \\<alpha>) (alprio_invar \\<alpha> invar) (alprio_empty empt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prio_empty (alprio_\\<alpha> \\<alpha>) (alprio_invar \\<alpha> invar)\n     (alprio_empty empt)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. prio_empty (alprio_\\<alpha> \\<alpha>) (alprio_invar \\<alpha> invar)\n     (alprio_empty empt)", "interpret al_empty \\<alpha> invar empt"], ["proof (prove)\ngoal (1 subgoal):\n 1. al_empty \\<alpha> invar empt", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. prio_empty (alprio_\\<alpha> \\<alpha>) (alprio_invar \\<alpha> invar)\n     (alprio_empty empt)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. prio_empty (alprio_\\<alpha> \\<alpha>) (alprio_invar \\<alpha> invar)\n     (alprio_empty empt)", "apply (unfold_locales)"], ["proof (prove)\ngoal (2 subgoals):\n 1. alprio_invar \\<alpha> invar (alprio_empty empt ())\n 2. alprio_\\<alpha> \\<alpha> (alprio_empty empt ()) = {#}", "apply (unfold alprio_invar_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. invar (alprio_empty empt ()) \\<and>\n    (\\<forall>x\\<in>set (\\<alpha> (alprio_empty empt ())).\n        snd x \\<noteq> Infty)\n 2. alprio_\\<alpha> \\<alpha> (alprio_empty empt ()) = {#}", "apply auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. invar (alprio_empty empt ())\n 2. ((), Infty)\n    \\<in> set (\\<alpha> (alprio_empty empt ())) \\<Longrightarrow>\n    False\n 3. alprio_\\<alpha> \\<alpha> (alprio_empty empt ()) = {#}", "apply (unfold alprio_empty_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. invar (empt ())\n 2. ((), Infty) \\<in> set (\\<alpha> (empt ())) \\<Longrightarrow> False\n 3. alprio_\\<alpha> \\<alpha> (empt ()) = {#}", "apply (auto simp add: empty_correct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. alprio_\\<alpha> \\<alpha> (empt ()) = {#}", "apply (unfold alprio_\\<alpha>_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (map p_unwrap (map snd (\\<alpha> (empt ())))) = {#}", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (empt ()) = []", "apply (simp only: empty_correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  prio_empty (alprio_\\<alpha> \\<alpha>) (alprio_invar \\<alpha> invar)\n   (alprio_empty empt)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \"Is Empty\""], ["", "lemma alprio_isEmpty_correct: \n  assumes \"al_isEmpty \\<alpha> invar isEmpty\"\n  shows \"prio_isEmpty (alprio_\\<alpha> \\<alpha>) (alprio_invar \\<alpha> invar) (alprio_isEmpty isEmpty)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prio_isEmpty (alprio_\\<alpha> \\<alpha>) (alprio_invar \\<alpha> invar)\n     (alprio_isEmpty isEmpty)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. prio_isEmpty (alprio_\\<alpha> \\<alpha>) (alprio_invar \\<alpha> invar)\n     (alprio_isEmpty isEmpty)", "interpret al_isEmpty \\<alpha> invar isEmpty"], ["proof (prove)\ngoal (1 subgoal):\n 1. al_isEmpty \\<alpha> invar isEmpty", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. prio_isEmpty (alprio_\\<alpha> \\<alpha>) (alprio_invar \\<alpha> invar)\n     (alprio_isEmpty isEmpty)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. prio_isEmpty (alprio_\\<alpha> \\<alpha>) (alprio_invar \\<alpha> invar)\n     (alprio_isEmpty isEmpty)", "by (unfold_locales) (auto simp add: alprio_defs isEmpty_correct)"], ["proof (state)\nthis:\n  prio_isEmpty (alprio_\\<alpha> \\<alpha>) (alprio_invar \\<alpha> invar)\n   (alprio_isEmpty isEmpty)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \"Insert\""], ["", "lemma alprio_insert_correct: \n  assumes \"al_consl \\<alpha> invar consl\"\n  shows \"prio_insert (alprio_\\<alpha> \\<alpha>) (alprio_invar \\<alpha> invar) (alprio_insert consl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prio_insert (alprio_\\<alpha> \\<alpha>) (alprio_invar \\<alpha> invar)\n     (alprio_insert consl)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. prio_insert (alprio_\\<alpha> \\<alpha>) (alprio_invar \\<alpha> invar)\n     (alprio_insert consl)", "interpret al_consl \\<alpha> invar consl"], ["proof (prove)\ngoal (1 subgoal):\n 1. al_consl \\<alpha> invar consl", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. prio_insert (alprio_\\<alpha> \\<alpha>) (alprio_invar \\<alpha> invar)\n     (alprio_insert consl)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. prio_insert (alprio_\\<alpha> \\<alpha>) (alprio_invar \\<alpha> invar)\n     (alprio_insert consl)", "by unfold_locales (auto simp add: alprio_defs consl_correct)"], ["proof (state)\nthis:\n  prio_insert (alprio_\\<alpha> \\<alpha>) (alprio_invar \\<alpha> invar)\n   (alprio_insert consl)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \"Meld\""], ["", "lemma alprio_meld_correct: \n  assumes \"al_app \\<alpha> invar app\"\n  shows \"prio_meld (alprio_\\<alpha> \\<alpha>) (alprio_invar \\<alpha> invar) (alprio_meld app)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prio_meld (alprio_\\<alpha> \\<alpha>) (alprio_invar \\<alpha> invar)\n     (alprio_meld app)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. prio_meld (alprio_\\<alpha> \\<alpha>) (alprio_invar \\<alpha> invar)\n     (alprio_meld app)", "interpret al_app \\<alpha> invar app"], ["proof (prove)\ngoal (1 subgoal):\n 1. al_app \\<alpha> invar app", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. prio_meld (alprio_\\<alpha> \\<alpha>) (alprio_invar \\<alpha> invar)\n     (alprio_meld app)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. prio_meld (alprio_\\<alpha> \\<alpha>) (alprio_invar \\<alpha> invar)\n     (alprio_meld app)", "by unfold_locales (auto simp add: alprio_defs app_correct)"], ["proof (state)\nthis:\n  prio_meld (alprio_\\<alpha> \\<alpha>) (alprio_invar \\<alpha> invar)\n   (alprio_meld app)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \"Find\""], ["", "lemma annot_not_inf :\n  assumes \"(alprio_invar \\<alpha> invar) s\" \n  and \"(alprio_\\<alpha> \\<alpha>) s \\<noteq> {#}\"\n  and \"al_annot \\<alpha> invar annot\"\n  shows \"annot s \\<noteq> Infty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. annot s \\<noteq> Infty", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. annot s \\<noteq> Infty", "interpret al_annot \\<alpha> invar annot"], ["proof (prove)\ngoal (1 subgoal):\n 1. al_annot \\<alpha> invar annot", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. annot s \\<noteq> Infty", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. annot s \\<noteq> Infty", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. annot s \\<noteq> Infty", "from assms(1)"], ["proof (chain)\npicking this:\n  alprio_invar \\<alpha> invar s", "have invs: \"invar s\""], ["proof (prove)\nusing this:\n  alprio_invar \\<alpha> invar s\n\ngoal (1 subgoal):\n 1. invar s", "by (simp add: alprio_defs)"], ["proof (state)\nthis:\n  invar s\n\ngoal (1 subgoal):\n 1. annot s \\<noteq> Infty", "from assms(2)"], ["proof (chain)\npicking this:\n  alprio_\\<alpha> \\<alpha> s \\<noteq> {#}", "have sne: \"set (\\<alpha> s) \\<noteq> {}\""], ["proof (prove)\nusing this:\n  alprio_\\<alpha> \\<alpha> s \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. set (\\<alpha> s) \\<noteq> {}", "proof (cases \"set (\\<alpha> s) = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>alprio_\\<alpha> \\<alpha> s \\<noteq> {#};\n     set (\\<alpha> s) = {}\\<rbrakk>\n    \\<Longrightarrow> set (\\<alpha> s) \\<noteq> {}\n 2. \\<lbrakk>alprio_\\<alpha> \\<alpha> s \\<noteq> {#};\n     set (\\<alpha> s) \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> set (\\<alpha> s) \\<noteq> {}", "case True"], ["proof (state)\nthis:\n  set (\\<alpha> s) = {}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>alprio_\\<alpha> \\<alpha> s \\<noteq> {#};\n     set (\\<alpha> s) = {}\\<rbrakk>\n    \\<Longrightarrow> set (\\<alpha> s) \\<noteq> {}\n 2. \\<lbrakk>alprio_\\<alpha> \\<alpha> s \\<noteq> {#};\n     set (\\<alpha> s) \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> set (\\<alpha> s) \\<noteq> {}", "hence \"\\<alpha> s = []\""], ["proof (prove)\nusing this:\n  set (\\<alpha> s) = {}\n\ngoal (1 subgoal):\n 1. \\<alpha> s = []", "by simp"], ["proof (state)\nthis:\n  \\<alpha> s = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>alprio_\\<alpha> \\<alpha> s \\<noteq> {#};\n     set (\\<alpha> s) = {}\\<rbrakk>\n    \\<Longrightarrow> set (\\<alpha> s) \\<noteq> {}\n 2. \\<lbrakk>alprio_\\<alpha> \\<alpha> s \\<noteq> {#};\n     set (\\<alpha> s) \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> set (\\<alpha> s) \\<noteq> {}", "hence \"(alprio_\\<alpha> \\<alpha>) s = {#}\""], ["proof (prove)\nusing this:\n  \\<alpha> s = []\n\ngoal (1 subgoal):\n 1. alprio_\\<alpha> \\<alpha> s = {#}", "by (simp add: alprio_defs)"], ["proof (state)\nthis:\n  alprio_\\<alpha> \\<alpha> s = {#}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>alprio_\\<alpha> \\<alpha> s \\<noteq> {#};\n     set (\\<alpha> s) = {}\\<rbrakk>\n    \\<Longrightarrow> set (\\<alpha> s) \\<noteq> {}\n 2. \\<lbrakk>alprio_\\<alpha> \\<alpha> s \\<noteq> {#};\n     set (\\<alpha> s) \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> set (\\<alpha> s) \\<noteq> {}", "from this assms(2)"], ["proof (chain)\npicking this:\n  alprio_\\<alpha> \\<alpha> s = {#}\n  alprio_\\<alpha> \\<alpha> s \\<noteq> {#}", "show ?thesis"], ["proof (prove)\nusing this:\n  alprio_\\<alpha> \\<alpha> s = {#}\n  alprio_\\<alpha> \\<alpha> s \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. set (\\<alpha> s) \\<noteq> {}", "by simp"], ["proof (state)\nthis:\n  set (\\<alpha> s) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>alprio_\\<alpha> \\<alpha> s \\<noteq> {#};\n     set (\\<alpha> s) \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> set (\\<alpha> s) \\<noteq> {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>alprio_\\<alpha> \\<alpha> s \\<noteq> {#};\n     set (\\<alpha> s) \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> set (\\<alpha> s) \\<noteq> {}", "case False"], ["proof (state)\nthis:\n  set (\\<alpha> s) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>alprio_\\<alpha> \\<alpha> s \\<noteq> {#};\n     set (\\<alpha> s) \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> set (\\<alpha> s) \\<noteq> {}", "thus ?thesis"], ["proof (prove)\nusing this:\n  set (\\<alpha> s) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. set (\\<alpha> s) \\<noteq> {}", "by simp"], ["proof (state)\nthis:\n  set (\\<alpha> s) \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (\\<alpha> s) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. annot s \\<noteq> Infty", "hence \"(\\<alpha> s) \\<noteq> []\""], ["proof (prove)\nusing this:\n  set (\\<alpha> s) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<alpha> s \\<noteq> []", "by simp"], ["proof (state)\nthis:\n  \\<alpha> s \\<noteq> []\n\ngoal (1 subgoal):\n 1. annot s \\<noteq> Infty", "hence \" \\<exists>x xs. (\\<alpha> s) = x # xs\""], ["proof (prove)\nusing this:\n  \\<alpha> s \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<exists>x xs. \\<alpha> s = x # xs", "by (cases \"\\<alpha> s\") auto"], ["proof (state)\nthis:\n  \\<exists>x xs. \\<alpha> s = x # xs\n\ngoal (1 subgoal):\n 1. annot s \\<noteq> Infty", "from this"], ["proof (chain)\npicking this:\n  \\<exists>x xs. \\<alpha> s = x # xs", "obtain x xs where [simp]: \"(\\<alpha> s) = x # xs\""], ["proof (prove)\nusing this:\n  \\<exists>x xs. \\<alpha> s = x # xs\n\ngoal (1 subgoal):\n 1. (\\<And>x xs.\n        \\<alpha> s = x # xs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<alpha> s = x # xs\n\ngoal (1 subgoal):\n 1. annot s \\<noteq> Infty", "from this assms(1)"], ["proof (chain)\npicking this:\n  \\<alpha> s = x # xs\n  alprio_invar \\<alpha> invar s", "have \"snd x \\<noteq> Infty\""], ["proof (prove)\nusing this:\n  \\<alpha> s = x # xs\n  alprio_invar \\<alpha> invar s\n\ngoal (1 subgoal):\n 1. snd x \\<noteq> Infty", "by (auto simp add: alprio_defs)"], ["proof (state)\nthis:\n  snd x \\<noteq> Infty\n\ngoal (1 subgoal):\n 1. annot s \\<noteq> Infty", "hence \"sum_list (map snd (\\<alpha> s)) \\<noteq> Infty\""], ["proof (prove)\nusing this:\n  snd x \\<noteq> Infty\n\ngoal (1 subgoal):\n 1. sum_list (map snd (\\<alpha> s)) \\<noteq> Infty", "by (auto simp add: infadd)"], ["proof (state)\nthis:\n  sum_list (map snd (\\<alpha> s)) \\<noteq> Infty\n\ngoal (1 subgoal):\n 1. annot s \\<noteq> Infty", "thus \"annot s \\<noteq> Infty\""], ["proof (prove)\nusing this:\n  sum_list (map snd (\\<alpha> s)) \\<noteq> Infty\n\ngoal (1 subgoal):\n 1. annot s \\<noteq> Infty", "using annot_correct invs"], ["proof (prove)\nusing this:\n  sum_list (map snd (\\<alpha> s)) \\<noteq> Infty\n  invar ?s \\<Longrightarrow> annot ?s = sum_list (map snd (\\<alpha> ?s))\n  invar s\n\ngoal (1 subgoal):\n 1. annot s \\<noteq> Infty", "by simp"], ["proof (state)\nthis:\n  annot s \\<noteq> Infty\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  annot s \\<noteq> Infty\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma annot_in_set: \n  assumes \"(alprio_invar \\<alpha> invar) s\" \n  and \"(alprio_\\<alpha> \\<alpha>) s \\<noteq> {#}\"\n  and \"al_annot \\<alpha> invar annot\"\n  shows \"p_unwrap (annot s) \\<in># ((alprio_\\<alpha> \\<alpha>) s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p_unwrap (annot s) \\<in># alprio_\\<alpha> \\<alpha> s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p_unwrap (annot s) \\<in># alprio_\\<alpha> \\<alpha> s", "interpret al_annot \\<alpha> invar annot"], ["proof (prove)\ngoal (1 subgoal):\n 1. al_annot \\<alpha> invar annot", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. p_unwrap (annot s) \\<in># alprio_\\<alpha> \\<alpha> s", "from assms(2)"], ["proof (chain)\npicking this:\n  alprio_\\<alpha> \\<alpha> s \\<noteq> {#}", "have snn: \"\\<alpha> s \\<noteq> []\""], ["proof (prove)\nusing this:\n  alprio_\\<alpha> \\<alpha> s \\<noteq> {#}\n\ngoal (1 subgoal):\n 1. \\<alpha> s \\<noteq> []", "by (auto simp add: alprio_defs)"], ["proof (state)\nthis:\n  \\<alpha> s \\<noteq> []\n\ngoal (1 subgoal):\n 1. p_unwrap (annot s) \\<in># alprio_\\<alpha> \\<alpha> s", "from assms(1)"], ["proof (chain)\npicking this:\n  alprio_invar \\<alpha> invar s", "have invs: \"invar s\""], ["proof (prove)\nusing this:\n  alprio_invar \\<alpha> invar s\n\ngoal (1 subgoal):\n 1. invar s", "by (simp add: alprio_defs)"], ["proof (state)\nthis:\n  invar s\n\ngoal (1 subgoal):\n 1. p_unwrap (annot s) \\<in># alprio_\\<alpha> \\<alpha> s", "hence ans: \"annot s = sum_list (map snd (\\<alpha> s))\""], ["proof (prove)\nusing this:\n  invar s\n\ngoal (1 subgoal):\n 1. annot s = sum_list (map snd (\\<alpha> s))", "by (simp add: annot_correct)"], ["proof (state)\nthis:\n  annot s = sum_list (map snd (\\<alpha> s))\n\ngoal (1 subgoal):\n 1. p_unwrap (annot s) \\<in># alprio_\\<alpha> \\<alpha> s", "let ?P = \"map snd (\\<alpha> s)\""], ["proof (state)\ngoal (1 subgoal):\n 1. p_unwrap (annot s) \\<in># alprio_\\<alpha> \\<alpha> s", "have \"annot s \\<in> set ?P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. annot s \\<in> set (map snd (\\<alpha> s))", "by (unfold ans) (rule sum_list_in_set[OF snn])"], ["proof (state)\nthis:\n  annot s \\<in> set (map snd (\\<alpha> s))\n\ngoal (1 subgoal):\n 1. p_unwrap (annot s) \\<in># alprio_\\<alpha> \\<alpha> s", "then"], ["proof (chain)\npicking this:\n  annot s \\<in> set (map snd (\\<alpha> s))", "show ?thesis"], ["proof (prove)\nusing this:\n  annot s \\<in> set (map snd (\\<alpha> s))\n\ngoal (1 subgoal):\n 1. p_unwrap (annot s) \\<in># alprio_\\<alpha> \\<alpha> s", "by (auto intro!: image_eqI simp add: alprio_\\<alpha>_def)"], ["proof (state)\nthis:\n  p_unwrap (annot s) \\<in># alprio_\\<alpha> \\<alpha> s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma  sum_list_less_elems: \"\\<forall>x\\<in>set xs. snd x \\<noteq> Infty \\<Longrightarrow>\n   \\<forall>y\\<in>set_mset (mset (map p_unwrap (map snd xs))).\n              snd (p_unwrap (sum_list (map snd xs))) \\<le> snd y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set xs. snd x \\<noteq> Infty \\<Longrightarrow>\n    \\<forall>y\\<in>#mset (map p_unwrap (map snd xs)).\n       snd (p_unwrap (sum_list (map snd xs))) \\<le> snd y", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>set []. snd x \\<noteq> Infty \\<Longrightarrow>\n    \\<forall>y\\<in>#mset (map p_unwrap (map snd [])).\n       snd (p_unwrap (sum_list (map snd []))) \\<le> snd y\n 2. \\<And>a xs.\n       \\<lbrakk>\\<forall>x\\<in>set xs.\n                   snd x \\<noteq> Infty \\<Longrightarrow>\n                \\<forall>y\\<in>#mset (map p_unwrap (map snd xs)).\n                   snd (p_unwrap (sum_list (map snd xs))) \\<le> snd y;\n        \\<forall>x\\<in>set (a # xs). snd x \\<noteq> Infty\\<rbrakk>\n       \\<Longrightarrow> \\<forall>y\\<in>#mset\n    (map p_unwrap (map snd (a # xs))).\n                            snd (p_unwrap (sum_list (map snd (a # xs))))\n                            \\<le> snd y", "case Nil"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set []. snd x \\<noteq> Infty\n\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>set []. snd x \\<noteq> Infty \\<Longrightarrow>\n    \\<forall>y\\<in>#mset (map p_unwrap (map snd [])).\n       snd (p_unwrap (sum_list (map snd []))) \\<le> snd y\n 2. \\<And>a xs.\n       \\<lbrakk>\\<forall>x\\<in>set xs.\n                   snd x \\<noteq> Infty \\<Longrightarrow>\n                \\<forall>y\\<in>#mset (map p_unwrap (map snd xs)).\n                   snd (p_unwrap (sum_list (map snd xs))) \\<le> snd y;\n        \\<forall>x\\<in>set (a # xs). snd x \\<noteq> Infty\\<rbrakk>\n       \\<Longrightarrow> \\<forall>y\\<in>#mset\n    (map p_unwrap (map snd (a # xs))).\n                            snd (p_unwrap (sum_list (map snd (a # xs))))\n                            \\<le> snd y", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set []. snd x \\<noteq> Infty\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>#mset (map p_unwrap (map snd [])).\n       snd (p_unwrap (sum_list (map snd []))) \\<le> snd y", "by simp"], ["proof (state)\nthis:\n  \\<forall>y\\<in>#mset (map p_unwrap (map snd [])).\n     snd (p_unwrap (sum_list (map snd []))) \\<le> snd y\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<forall>x\\<in>set xs.\n                   snd x \\<noteq> Infty \\<Longrightarrow>\n                \\<forall>y\\<in>#mset (map p_unwrap (map snd xs)).\n                   snd (p_unwrap (sum_list (map snd xs))) \\<le> snd y;\n        \\<forall>x\\<in>set (a # xs). snd x \\<noteq> Infty\\<rbrakk>\n       \\<Longrightarrow> \\<forall>y\\<in>#mset\n    (map p_unwrap (map snd (a # xs))).\n                            snd (p_unwrap (sum_list (map snd (a # xs))))\n                            \\<le> snd y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<forall>x\\<in>set xs.\n                   snd x \\<noteq> Infty \\<Longrightarrow>\n                \\<forall>y\\<in>#mset (map p_unwrap (map snd xs)).\n                   snd (p_unwrap (sum_list (map snd xs))) \\<le> snd y;\n        \\<forall>x\\<in>set (a # xs). snd x \\<noteq> Infty\\<rbrakk>\n       \\<Longrightarrow> \\<forall>y\\<in>#mset\n    (map p_unwrap (map snd (a # xs))).\n                            snd (p_unwrap (sum_list (map snd (a # xs))))\n                            \\<le> snd y", "case (Cons a as)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set as. snd x \\<noteq> Infty \\<Longrightarrow>\n  \\<forall>y\\<in>#mset (map p_unwrap (map snd as)).\n     snd (p_unwrap (sum_list (map snd as))) \\<le> snd y\n  \\<forall>x\\<in>set (a # as). snd x \\<noteq> Infty\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<forall>x\\<in>set xs.\n                   snd x \\<noteq> Infty \\<Longrightarrow>\n                \\<forall>y\\<in>#mset (map p_unwrap (map snd xs)).\n                   snd (p_unwrap (sum_list (map snd xs))) \\<le> snd y;\n        \\<forall>x\\<in>set (a # xs). snd x \\<noteq> Infty\\<rbrakk>\n       \\<Longrightarrow> \\<forall>y\\<in>#mset\n    (map p_unwrap (map snd (a # xs))).\n                            snd (p_unwrap (sum_list (map snd (a # xs))))\n                            \\<le> snd y", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set as. snd x \\<noteq> Infty \\<Longrightarrow>\n  \\<forall>y\\<in>#mset (map p_unwrap (map snd as)).\n     snd (p_unwrap (sum_list (map snd as))) \\<le> snd y\n  \\<forall>x\\<in>set (a # as). snd x \\<noteq> Infty\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>#mset (map p_unwrap (map snd (a # as))).\n       snd (p_unwrap (sum_list (map snd (a # as)))) \\<le> snd y", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>y\\<in>set as.\n                snd (p_unwrap (sum_list (map snd as)))\n                \\<le> snd (p_unwrap (snd y));\n     snd a \\<noteq> Infty;\n     \\<forall>x\\<in>set as. snd x \\<noteq> Infty\\<rbrakk>\n    \\<Longrightarrow> snd (p_unwrap (snd a + sum_list (map snd as)))\n                      \\<le> snd (p_unwrap (snd a))\n 2. \\<And>aa b.\n       \\<lbrakk>\\<forall>y\\<in>set as.\n                   snd (p_unwrap (sum_list (map snd as)))\n                   \\<le> snd (p_unwrap (snd y));\n        snd a \\<noteq> Infty; \\<forall>x\\<in>set as. snd x \\<noteq> Infty;\n        (aa, b) \\<in> set as\\<rbrakk>\n       \\<Longrightarrow> snd (p_unwrap (snd a + sum_list (map snd as)))\n                         \\<le> snd (p_unwrap b)", "apply (cases \"(snd a)\" rule: p_unwrap.cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>e aa.\n       \\<lbrakk>\\<forall>y\\<in>set as.\n                   snd (p_unwrap (sum_list (map snd as)))\n                   \\<le> snd (p_unwrap (snd y));\n        snd a \\<noteq> Infty; \\<forall>x\\<in>set as. snd x \\<noteq> Infty;\n        snd a = Prio e aa\\<rbrakk>\n       \\<Longrightarrow> snd (p_unwrap (snd a + sum_list (map snd as)))\n                         \\<le> snd (p_unwrap (snd a))\n 2. \\<lbrakk>\\<forall>y\\<in>set as.\n                snd (p_unwrap (sum_list (map snd as)))\n                \\<le> snd (p_unwrap (snd y));\n     snd a \\<noteq> Infty; \\<forall>x\\<in>set as. snd x \\<noteq> Infty;\n     snd a = Infty\\<rbrakk>\n    \\<Longrightarrow> snd (p_unwrap (snd a + sum_list (map snd as)))\n                      \\<le> snd (p_unwrap (snd a))\n 3. \\<And>aa b.\n       \\<lbrakk>\\<forall>y\\<in>set as.\n                   snd (p_unwrap (sum_list (map snd as)))\n                   \\<le> snd (p_unwrap (snd y));\n        snd a \\<noteq> Infty; \\<forall>x\\<in>set as. snd x \\<noteq> Infty;\n        (aa, b) \\<in> set as\\<rbrakk>\n       \\<Longrightarrow> snd (p_unwrap (snd a + sum_list (map snd as)))\n                         \\<le> snd (p_unwrap b)", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>e aa.\n       \\<lbrakk>\\<forall>y\\<in>set as.\n                   snd (p_unwrap (sum_list (map snd as)))\n                   \\<le> snd (p_unwrap (snd y));\n        \\<forall>x\\<in>set as. snd x \\<noteq> Infty;\n        snd a = Prio e aa\\<rbrakk>\n       \\<Longrightarrow> snd (p_unwrap (Prio e aa + sum_list (map snd as)))\n                         \\<le> aa\n 2. \\<And>aa b.\n       \\<lbrakk>\\<forall>y\\<in>set as.\n                   snd (p_unwrap (sum_list (map snd as)))\n                   \\<le> snd (p_unwrap (snd y));\n        snd a \\<noteq> Infty; \\<forall>x\\<in>set as. snd x \\<noteq> Infty;\n        (aa, b) \\<in> set as\\<rbrakk>\n       \\<Longrightarrow> snd (p_unwrap (snd a + sum_list (map snd as)))\n                         \\<le> snd (p_unwrap b)", "apply (cases \"sum_list (map snd as)\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>e aa.\n       \\<lbrakk>\\<forall>y\\<in>set as.\n                   snd (p_unwrap (sum_list (map snd as)))\n                   \\<le> snd (p_unwrap (snd y));\n        \\<forall>x\\<in>set as. snd x \\<noteq> Infty; snd a = Prio e aa;\n        sum_list (map snd as) = Infty\\<rbrakk>\n       \\<Longrightarrow> snd (p_unwrap (Prio e aa + sum_list (map snd as)))\n                         \\<le> aa\n 2. \\<And>e aa x21 x22.\n       \\<lbrakk>\\<forall>y\\<in>set as.\n                   snd (p_unwrap (sum_list (map snd as)))\n                   \\<le> snd (p_unwrap (snd y));\n        \\<forall>x\\<in>set as. snd x \\<noteq> Infty; snd a = Prio e aa;\n        sum_list (map snd as) = Prio x21 x22\\<rbrakk>\n       \\<Longrightarrow> snd (p_unwrap (Prio e aa + sum_list (map snd as)))\n                         \\<le> aa\n 3. \\<And>aa b.\n       \\<lbrakk>\\<forall>y\\<in>set as.\n                   snd (p_unwrap (sum_list (map snd as)))\n                   \\<le> snd (p_unwrap (snd y));\n        snd a \\<noteq> Infty; \\<forall>x\\<in>set as. snd x \\<noteq> Infty;\n        (aa, b) \\<in> set as\\<rbrakk>\n       \\<Longrightarrow> snd (p_unwrap (snd a + sum_list (map snd as)))\n                         \\<le> snd (p_unwrap b)", "apply auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>e aa.\n       \\<lbrakk>\\<forall>y\\<in>set as.\n                   snd (p_unwrap Infty) \\<le> snd (p_unwrap (snd y));\n        \\<forall>x\\<in>set as. snd x \\<noteq> Infty; snd a = Prio e aa;\n        sum_list (map snd as) = Infty\\<rbrakk>\n       \\<Longrightarrow> snd (p_unwrap (Prio e aa + Infty)) \\<le> aa\n 2. \\<And>e aa x21 x22.\n       \\<lbrakk>\\<forall>y\\<in>set as. x22 \\<le> snd (p_unwrap (snd y));\n        \\<forall>x\\<in>set as. snd x \\<noteq> Infty; snd a = Prio e aa;\n        sum_list (map snd as) = Prio x21 x22\\<rbrakk>\n       \\<Longrightarrow> snd (p_unwrap (Prio e aa + Prio x21 x22)) \\<le> aa\n 3. \\<And>aa b.\n       \\<lbrakk>\\<forall>y\\<in>set as.\n                   snd (p_unwrap (sum_list (map snd as)))\n                   \\<le> snd (p_unwrap (snd y));\n        snd a \\<noteq> Infty; \\<forall>x\\<in>set as. snd x \\<noteq> Infty;\n        (aa, b) \\<in> set as\\<rbrakk>\n       \\<Longrightarrow> snd (p_unwrap (snd a + sum_list (map snd as)))\n                         \\<le> snd (p_unwrap b)", "apply (metis linorder_linear p_min_re_neut \n        p_unwrap.simps plus_def [abs_def] snd_eqD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>e aa x21 x22.\n       \\<lbrakk>\\<forall>y\\<in>set as. x22 \\<le> snd (p_unwrap (snd y));\n        \\<forall>x\\<in>set as. snd x \\<noteq> Infty; snd a = Prio e aa;\n        sum_list (map snd as) = Prio x21 x22\\<rbrakk>\n       \\<Longrightarrow> snd (p_unwrap (Prio e aa + Prio x21 x22)) \\<le> aa\n 2. \\<And>aa b.\n       \\<lbrakk>\\<forall>y\\<in>set as.\n                   snd (p_unwrap (sum_list (map snd as)))\n                   \\<le> snd (p_unwrap (snd y));\n        snd a \\<noteq> Infty; \\<forall>x\\<in>set as. snd x \\<noteq> Infty;\n        (aa, b) \\<in> set as\\<rbrakk>\n       \\<Longrightarrow> snd (p_unwrap (snd a + sum_list (map snd as)))\n                         \\<le> snd (p_unwrap b)", "apply (auto simp add: p_unwrap_less_sum)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>\\<forall>y\\<in>set as.\n                   snd (p_unwrap (sum_list (map snd as)))\n                   \\<le> snd (p_unwrap (snd y));\n        snd a \\<noteq> Infty; \\<forall>x\\<in>set as. snd x \\<noteq> Infty;\n        (aa, b) \\<in> set as\\<rbrakk>\n       \\<Longrightarrow> snd (p_unwrap (snd a + sum_list (map snd as)))\n                         \\<le> snd (p_unwrap b)", "apply (unfold plus_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>\\<forall>y\\<in>set as.\n                   snd (p_unwrap (sum_list (map snd as)))\n                   \\<le> snd (p_unwrap (snd y));\n        snd a \\<noteq> Infty; \\<forall>x\\<in>set as. snd x \\<noteq> Infty;\n        (aa, b) \\<in> set as\\<rbrakk>\n       \\<Longrightarrow> snd (p_unwrap\n                               (p_min (snd a) (sum_list (map snd as))))\n                         \\<le> snd (p_unwrap b)", "apply (cases \"(snd a, sum_list (map snd as))\" rule: p_min.cases)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>aa b.\n       \\<lbrakk>\\<forall>y\\<in>set as.\n                   snd (p_unwrap (sum_list (map snd as)))\n                   \\<le> snd (p_unwrap (snd y));\n        snd a \\<noteq> Infty; \\<forall>x\\<in>set as. snd x \\<noteq> Infty;\n        (aa, b) \\<in> set as;\n        (snd a, sum_list (map snd as)) = (Infty, Infty)\\<rbrakk>\n       \\<Longrightarrow> snd (p_unwrap\n                               (p_min (snd a) (sum_list (map snd as))))\n                         \\<le> snd (p_unwrap b)\n 2. \\<And>aa b e aaa.\n       \\<lbrakk>\\<forall>y\\<in>set as.\n                   snd (p_unwrap (sum_list (map snd as)))\n                   \\<le> snd (p_unwrap (snd y));\n        snd a \\<noteq> Infty; \\<forall>x\\<in>set as. snd x \\<noteq> Infty;\n        (aa, b) \\<in> set as;\n        (snd a, sum_list (map snd as)) = (Infty, Prio e aaa)\\<rbrakk>\n       \\<Longrightarrow> snd (p_unwrap\n                               (p_min (snd a) (sum_list (map snd as))))\n                         \\<le> snd (p_unwrap b)\n 3. \\<And>aa b e aaa.\n       \\<lbrakk>\\<forall>y\\<in>set as.\n                   snd (p_unwrap (sum_list (map snd as)))\n                   \\<le> snd (p_unwrap (snd y));\n        snd a \\<noteq> Infty; \\<forall>x\\<in>set as. snd x \\<noteq> Infty;\n        (aa, b) \\<in> set as;\n        (snd a, sum_list (map snd as)) = (Prio e aaa, Infty)\\<rbrakk>\n       \\<Longrightarrow> snd (p_unwrap\n                               (p_min (snd a) (sum_list (map snd as))))\n                         \\<le> snd (p_unwrap b)\n 4. \\<And>aa b e1 aaa e2 ba.\n       \\<lbrakk>\\<forall>y\\<in>set as.\n                   snd (p_unwrap (sum_list (map snd as)))\n                   \\<le> snd (p_unwrap (snd y));\n        snd a \\<noteq> Infty; \\<forall>x\\<in>set as. snd x \\<noteq> Infty;\n        (aa, b) \\<in> set as;\n        (snd a, sum_list (map snd as)) = (Prio e1 aaa, Prio e2 ba)\\<rbrakk>\n       \\<Longrightarrow> snd (p_unwrap\n                               (p_min (snd a) (sum_list (map snd as))))\n                         \\<le> snd (p_unwrap b)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b e aaa.\n       \\<lbrakk>\\<forall>y\\<in>set as.\n                   snd (p_unwrap Infty) \\<le> snd (p_unwrap (snd y));\n        \\<forall>x\\<in>set as. snd x \\<noteq> Infty; (aa, b) \\<in> set as;\n        snd a = Prio e aaa; sum_list (map snd as) = Infty\\<rbrakk>\n       \\<Longrightarrow> aaa \\<le> snd (p_unwrap b)", "apply (cases \"map snd as\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b e aaa.\n       \\<lbrakk>\\<forall>y\\<in>set as.\n                   snd (p_unwrap Infty) \\<le> snd (p_unwrap (snd y));\n        \\<forall>x\\<in>set as. snd x \\<noteq> Infty; (aa, b) \\<in> set as;\n        snd a = Prio e aaa; sum_list (map snd as) = Infty;\n        map snd as = []\\<rbrakk>\n       \\<Longrightarrow> aaa \\<le> snd (p_unwrap b)\n 2. \\<And>aa b e aaa ab list.\n       \\<lbrakk>\\<forall>y\\<in>set as.\n                   snd (p_unwrap Infty) \\<le> snd (p_unwrap (snd y));\n        \\<forall>x\\<in>set as. snd x \\<noteq> Infty; (aa, b) \\<in> set as;\n        snd a = Prio e aaa; sum_list (map snd as) = Infty;\n        map snd as = ab # list\\<rbrakk>\n       \\<Longrightarrow> aaa \\<le> snd (p_unwrap b)", "apply (auto simp add: infadd)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>y\\<in>#mset (map p_unwrap (map snd (a # as))).\n     snd (p_unwrap (sum_list (map snd (a # as)))) \\<le> snd y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma alprio_find_correct: \n  assumes  \"al_annot \\<alpha> invar annot\"\n  shows \"prio_find (alprio_\\<alpha> \\<alpha>) (alprio_invar \\<alpha> invar) (alprio_find annot)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prio_find (alprio_\\<alpha> \\<alpha>) (alprio_invar \\<alpha> invar)\n     (alprio_find annot)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. prio_find (alprio_\\<alpha> \\<alpha>) (alprio_invar \\<alpha> invar)\n     (alprio_find annot)", "interpret al_annot \\<alpha> invar annot"], ["proof (prove)\ngoal (1 subgoal):\n 1. al_annot \\<alpha> invar annot", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. prio_find (alprio_\\<alpha> \\<alpha>) (alprio_invar \\<alpha> invar)\n     (alprio_find annot)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. prio_find (alprio_\\<alpha> \\<alpha>) (alprio_invar \\<alpha> invar)\n     (alprio_find annot)", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>alprio_invar \\<alpha> invar p;\n        alprio_\\<alpha> \\<alpha> p \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> alprio_find annot p\n                         \\<in># alprio_\\<alpha> \\<alpha> p \\<and>\n                         (\\<forall>y\\<in>#alprio_\\<alpha> \\<alpha> p.\n                             snd (alprio_find annot p) \\<le> snd y)", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>alprio_invar \\<alpha> invar p;\n        alprio_\\<alpha> \\<alpha> p \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> alprio_find annot p\n                         \\<in># alprio_\\<alpha> \\<alpha> p\n 2. \\<And>p.\n       \\<lbrakk>alprio_invar \\<alpha> invar p;\n        alprio_\\<alpha> \\<alpha> p \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> \\<forall>y\\<in>#alprio_\\<alpha> \\<alpha> p.\n                            snd (alprio_find annot p) \\<le> snd y", "apply (insert assms)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>alprio_invar \\<alpha> invar p;\n        alprio_\\<alpha> \\<alpha> p \\<noteq> {#};\n        al_annot \\<alpha> invar annot\\<rbrakk>\n       \\<Longrightarrow> alprio_find annot p\n                         \\<in># alprio_\\<alpha> \\<alpha> p\n 2. \\<And>p.\n       \\<lbrakk>alprio_invar \\<alpha> invar p;\n        alprio_\\<alpha> \\<alpha> p \\<noteq> {#};\n        al_annot \\<alpha> invar annot\\<rbrakk>\n       \\<Longrightarrow> \\<forall>y\\<in>#alprio_\\<alpha> \\<alpha> p.\n                            snd (alprio_find annot p) \\<le> snd y", "apply (unfold alprio_find_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>alprio_invar \\<alpha> invar p;\n        alprio_\\<alpha> \\<alpha> p \\<noteq> {#};\n        al_annot \\<alpha> invar annot\\<rbrakk>\n       \\<Longrightarrow> p_unwrap (annot p)\n                         \\<in># alprio_\\<alpha> \\<alpha> p\n 2. \\<And>p.\n       \\<lbrakk>alprio_invar \\<alpha> invar p;\n        alprio_\\<alpha> \\<alpha> p \\<noteq> {#};\n        al_annot \\<alpha> invar annot\\<rbrakk>\n       \\<Longrightarrow> \\<forall>y\\<in>#alprio_\\<alpha> \\<alpha> p.\n                            snd (p_unwrap (annot p)) \\<le> snd y", "apply (simp add:annot_in_set)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>alprio_invar \\<alpha> invar p;\n        alprio_\\<alpha> \\<alpha> p \\<noteq> {#};\n        al_annot \\<alpha> invar annot\\<rbrakk>\n       \\<Longrightarrow> \\<forall>y\\<in>#alprio_\\<alpha> \\<alpha> p.\n                            snd (p_unwrap (annot p)) \\<le> snd y", "apply (unfold alprio_defs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>invar p \\<and>\n                (\\<forall>x\\<in>set (\\<alpha> p). snd x \\<noteq> Infty);\n        mset (map p_unwrap (map snd (\\<alpha> p))) \\<noteq> {#};\n        al_annot \\<alpha> invar annot\\<rbrakk>\n       \\<Longrightarrow> \\<forall>y\\<in>#mset\n    (map p_unwrap (map snd (\\<alpha> p))).\n                            snd (p_unwrap (annot p)) \\<le> snd y", "apply (simp add: annot_correct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>invar p \\<and>\n                (\\<forall>x\\<in>set (\\<alpha> p). snd x \\<noteq> Infty);\n        \\<alpha> p \\<noteq> []; al_annot \\<alpha> invar annot\\<rbrakk>\n       \\<Longrightarrow> \\<forall>y\\<in>set (\\<alpha> p).\n                            snd (p_unwrap (sum_list (map snd (\\<alpha> p))))\n                            \\<le> snd (p_unwrap (snd y))", "apply (auto simp add: sum_list_less_elems)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  prio_find (alprio_\\<alpha> \\<alpha>) (alprio_invar \\<alpha> invar)\n   (alprio_find annot)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \"Delete\""], ["", "lemma delpred_mon: \n  \"\\<forall>(a:: ('e, 'a::linorder) Prio) b. ((\\<lambda> x. x \\<le> y) a \n    \\<longrightarrow> (\\<lambda> x. x \\<le> y) (a + b)) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a b. a \\<le> y \\<longrightarrow> a + b \\<le> y", "proof (intro impI allI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. a \\<le> y \\<Longrightarrow> a + b \\<le> y", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b. a \\<le> y \\<Longrightarrow> a + b \\<le> y", "show \"a \\<le> y \\<Longrightarrow> a + b \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> y \\<Longrightarrow> a + b \\<le> y", "apply (induct a b rule: p_less.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>e a f b.\n       Prio e a \\<le> y \\<Longrightarrow> Prio e a + Prio f b \\<le> y\n 2. \\<And>e a. Prio e a \\<le> y \\<Longrightarrow> Prio e a + Infty \\<le> y\n 3. \\<And>uu_. Infty \\<le> y \\<Longrightarrow> Infty + uu_ \\<le> y", "apply (auto simp add: plus_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>e a f b.\n       \\<lbrakk>Prio e a \\<le> y; \\<not> a \\<le> b\\<rbrakk>\n       \\<Longrightarrow> Prio f b \\<le> y\n 2. \\<And>uu_. Infty \\<le> y \\<Longrightarrow> uu_ \\<le> y", "apply (metis linorder_linear order_trans \n      p_linear p_min.simps(4) p_min_mon plus_def prio_selects_one)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>uu_. Infty \\<le> y \\<Longrightarrow> uu_ \\<le> y", "apply (metis order_trans p_linear p_min_mon p_min_re_neut plus_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  a \\<le> y \\<Longrightarrow> a + b \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["", "(* alprio_delete erh?lt die Invariante *)"], ["", "lemma alpriodel_invar: \n  assumes \"alprio_invar \\<alpha> invar s\"\n  and \"al_annot \\<alpha> invar annot\"\n  and \"alprio_\\<alpha> \\<alpha> s \\<noteq> {#}\"\n  and \"al_splits \\<alpha> invar splits\"\n  and \"al_app \\<alpha> invar app\"\n  shows \"alprio_invar \\<alpha> invar (alprio_delete splits annot app s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alprio_invar \\<alpha> invar (alprio_delete splits annot app s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. alprio_invar \\<alpha> invar (alprio_delete splits annot app s)", "interpret al_splits \\<alpha> invar splits"], ["proof (prove)\ngoal (1 subgoal):\n 1. al_splits \\<alpha> invar splits", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. alprio_invar \\<alpha> invar (alprio_delete splits annot app s)", "let ?P = \"\\<lambda>x. x \\<le> annot s\""], ["proof (state)\ngoal (1 subgoal):\n 1. alprio_invar \\<alpha> invar (alprio_delete splits annot app s)", "obtain l p r where \n    [simp]:\"splits ?P Infty s = (l, p, r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l p r.\n        splits (\\<lambda>x. x \\<le> annot s) Infty s =\n        (l, p, r) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"splits ?P Infty s\")  auto"], ["proof (state)\nthis:\n  splits (\\<lambda>x. x \\<le> annot s) Infty s = (l, p, r)\n\ngoal (1 subgoal):\n 1. alprio_invar \\<alpha> invar (alprio_delete splits annot app s)", "obtain e a where \n    \"p = (e, a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e a. p = (e, a) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases p, blast)"], ["proof (state)\nthis:\n  p = (e, a)\n\ngoal (1 subgoal):\n 1. alprio_invar \\<alpha> invar (alprio_delete splits annot app s)", "hence \n    lear:\"splits ?P Infty s = (l, (e,a), r)\""], ["proof (prove)\nusing this:\n  p = (e, a)\n\ngoal (1 subgoal):\n 1. splits (\\<lambda>x. x \\<le> annot s) Infty s = (l, (e, a), r)", "by simp"], ["proof (state)\nthis:\n  splits (\\<lambda>x. x \\<le> annot s) Infty s = (l, (e, a), r)\n\ngoal (1 subgoal):\n 1. alprio_invar \\<alpha> invar (alprio_delete splits annot app s)", "from annot_not_inf[OF assms(1) assms(3) assms(2)]"], ["proof (chain)\npicking this:\n  annot s \\<noteq> Infty", "have \n    \"annot s \\<noteq> Infty\""], ["proof (prove)\nusing this:\n  annot s \\<noteq> Infty\n\ngoal (1 subgoal):\n 1. annot s \\<noteq> Infty", "."], ["proof (state)\nthis:\n  annot s \\<noteq> Infty\n\ngoal (1 subgoal):\n 1. alprio_invar \\<alpha> invar (alprio_delete splits annot app s)", "hence \n    sv1: \"\\<not> Infty \\<le> annot s\""], ["proof (prove)\nusing this:\n  annot s \\<noteq> Infty\n\ngoal (1 subgoal):\n 1. \\<not> Infty \\<le> annot s", "by (simp add: plesseq_def, cases \"annot s\", auto)"], ["proof (state)\nthis:\n  \\<not> Infty \\<le> annot s\n\ngoal (1 subgoal):\n 1. alprio_invar \\<alpha> invar (alprio_delete splits annot app s)", "from assms(1)"], ["proof (chain)\npicking this:\n  alprio_invar \\<alpha> invar s", "have \n    invs: \"invar s\""], ["proof (prove)\nusing this:\n  alprio_invar \\<alpha> invar s\n\ngoal (1 subgoal):\n 1. invar s", "unfolding alprio_invar_def"], ["proof (prove)\nusing this:\n  invar s \\<and> (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty)\n\ngoal (1 subgoal):\n 1. invar s", "by simp"], ["proof (state)\nthis:\n  invar s\n\ngoal (1 subgoal):\n 1. alprio_invar \\<alpha> invar (alprio_delete splits annot app s)", "interpret al_annot \\<alpha> invar annot"], ["proof (prove)\ngoal (1 subgoal):\n 1. al_annot \\<alpha> invar annot", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. alprio_invar \\<alpha> invar (alprio_delete splits annot app s)", "from invs"], ["proof (chain)\npicking this:\n  invar s", "have \n    sv2: \"Infty + sum_list (map snd (\\<alpha> s)) \\<le> annot s\""], ["proof (prove)\nusing this:\n  invar s\n\ngoal (1 subgoal):\n 1. Infty + sum_list (map snd (\\<alpha> s)) \\<le> annot s", "by (auto simp add: annot_correct plus_def \n      plesseq_def p_min_le_neut p_order_refl)"], ["proof (state)\nthis:\n  Infty + sum_list (map snd (\\<alpha> s)) \\<le> annot s\n\ngoal (1 subgoal):\n 1. alprio_invar \\<alpha> invar (alprio_delete splits annot app s)", "note sp = splits_correct[of s \"?P\" Infty l e a r]"], ["proof (state)\nthis:\n  \\<lbrakk>invar s;\n   \\<forall>a b. a \\<le> annot s \\<longrightarrow> a + b \\<le> annot s;\n   \\<not> Infty \\<le> annot s;\n   Infty + sum_list (map snd (\\<alpha> s)) \\<le> annot s;\n   splits (\\<lambda>x. x \\<le> annot s) Infty s = (l, (e, a), r)\\<rbrakk>\n  \\<Longrightarrow> \\<alpha> s = \\<alpha> l @ (e, a) # \\<alpha> r \\<and>\n                    \\<not> Infty + sum_list (map snd (\\<alpha> l))\n                           \\<le> annot s \\<and>\n                    Infty + sum_list (map snd (\\<alpha> l)) + a\n                    \\<le> annot s \\<and>\n                    invar l \\<and> invar r\n\ngoal (1 subgoal):\n 1. alprio_invar \\<alpha> invar (alprio_delete splits annot app s)", "note dp = delpred_mon[of \"annot s\"]"], ["proof (state)\nthis:\n  \\<forall>a b. a \\<le> annot s \\<longrightarrow> a + b \\<le> annot s\n\ngoal (1 subgoal):\n 1. alprio_invar \\<alpha> invar (alprio_delete splits annot app s)", "from sp[OF invs dp sv1 sv2 lear]"], ["proof (chain)\npicking this:\n  \\<alpha> s = \\<alpha> l @ (e, a) # \\<alpha> r \\<and>\n  \\<not> Infty + sum_list (map snd (\\<alpha> l)) \\<le> annot s \\<and>\n  Infty + sum_list (map snd (\\<alpha> l)) + a \\<le> annot s \\<and>\n  invar l \\<and> invar r", "have \n    invlr: \"invar l \\<and> invar r\" and \n    alr: \"\\<alpha> s = \\<alpha> l @ (e, a) # \\<alpha> r\""], ["proof (prove)\nusing this:\n  \\<alpha> s = \\<alpha> l @ (e, a) # \\<alpha> r \\<and>\n  \\<not> Infty + sum_list (map snd (\\<alpha> l)) \\<le> annot s \\<and>\n  Infty + sum_list (map snd (\\<alpha> l)) + a \\<le> annot s \\<and>\n  invar l \\<and> invar r\n\ngoal (1 subgoal):\n 1. invar l \\<and> invar r &&& \\<alpha> s = \\<alpha> l @ (e, a) # \\<alpha> r", "by auto"], ["proof (state)\nthis:\n  invar l \\<and> invar r\n  \\<alpha> s = \\<alpha> l @ (e, a) # \\<alpha> r\n\ngoal (1 subgoal):\n 1. alprio_invar \\<alpha> invar (alprio_delete splits annot app s)", "interpret al_app \\<alpha> invar app"], ["proof (prove)\ngoal (1 subgoal):\n 1. al_app \\<alpha> invar app", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. alprio_invar \\<alpha> invar (alprio_delete splits annot app s)", "from invlr app_correct"], ["proof (chain)\npicking this:\n  invar l \\<and> invar r\n  \\<lbrakk>invar ?s; invar ?s'\\<rbrakk>\n  \\<Longrightarrow> \\<alpha> (app ?s ?s') = \\<alpha> ?s @ \\<alpha> ?s'\n  \\<lbrakk>invar ?s; invar ?s'\\<rbrakk> \\<Longrightarrow> invar (app ?s ?s')", "have \n    invapplr: \"invar (app l r)\""], ["proof (prove)\nusing this:\n  invar l \\<and> invar r\n  \\<lbrakk>invar ?s; invar ?s'\\<rbrakk>\n  \\<Longrightarrow> \\<alpha> (app ?s ?s') = \\<alpha> ?s @ \\<alpha> ?s'\n  \\<lbrakk>invar ?s; invar ?s'\\<rbrakk> \\<Longrightarrow> invar (app ?s ?s')\n\ngoal (1 subgoal):\n 1. invar (app l r)", "by simp"], ["proof (state)\nthis:\n  invar (app l r)\n\ngoal (1 subgoal):\n 1. alprio_invar \\<alpha> invar (alprio_delete splits annot app s)", "from invlr app_correct"], ["proof (chain)\npicking this:\n  invar l \\<and> invar r\n  \\<lbrakk>invar ?s; invar ?s'\\<rbrakk>\n  \\<Longrightarrow> \\<alpha> (app ?s ?s') = \\<alpha> ?s @ \\<alpha> ?s'\n  \\<lbrakk>invar ?s; invar ?s'\\<rbrakk> \\<Longrightarrow> invar (app ?s ?s')", "have \n    sr: \"\\<alpha> (app l r) = (\\<alpha> l) @ (\\<alpha> r)\""], ["proof (prove)\nusing this:\n  invar l \\<and> invar r\n  \\<lbrakk>invar ?s; invar ?s'\\<rbrakk>\n  \\<Longrightarrow> \\<alpha> (app ?s ?s') = \\<alpha> ?s @ \\<alpha> ?s'\n  \\<lbrakk>invar ?s; invar ?s'\\<rbrakk> \\<Longrightarrow> invar (app ?s ?s')\n\ngoal (1 subgoal):\n 1. \\<alpha> (app l r) = \\<alpha> l @ \\<alpha> r", "by simp"], ["proof (state)\nthis:\n  \\<alpha> (app l r) = \\<alpha> l @ \\<alpha> r\n\ngoal (1 subgoal):\n 1. alprio_invar \\<alpha> invar (alprio_delete splits annot app s)", "from alr"], ["proof (chain)\npicking this:\n  \\<alpha> s = \\<alpha> l @ (e, a) # \\<alpha> r", "have  \n    \"set (\\<alpha> s) \\<supseteq> (set (\\<alpha> l) Un set (\\<alpha> r))\""], ["proof (prove)\nusing this:\n  \\<alpha> s = \\<alpha> l @ (e, a) # \\<alpha> r\n\ngoal (1 subgoal):\n 1. set (\\<alpha> l) \\<union> set (\\<alpha> r) \\<subseteq> set (\\<alpha> s)", "by auto"], ["proof (state)\nthis:\n  set (\\<alpha> l) \\<union> set (\\<alpha> r) \\<subseteq> set (\\<alpha> s)\n\ngoal (1 subgoal):\n 1. alprio_invar \\<alpha> invar (alprio_delete splits annot app s)", "with app_correct[of l r] invlr"], ["proof (chain)\npicking this:\n  \\<lbrakk>invar l; invar r\\<rbrakk>\n  \\<Longrightarrow> \\<alpha> (app l r) = \\<alpha> l @ \\<alpha> r\n  \\<lbrakk>invar l; invar r\\<rbrakk> \\<Longrightarrow> invar (app l r)\n  invar l \\<and> invar r\n  set (\\<alpha> l) \\<union> set (\\<alpha> r) \\<subseteq> set (\\<alpha> s)", "have \n    \"set (\\<alpha> s) \\<supseteq> set (\\<alpha> (app l r))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>invar l; invar r\\<rbrakk>\n  \\<Longrightarrow> \\<alpha> (app l r) = \\<alpha> l @ \\<alpha> r\n  \\<lbrakk>invar l; invar r\\<rbrakk> \\<Longrightarrow> invar (app l r)\n  invar l \\<and> invar r\n  set (\\<alpha> l) \\<union> set (\\<alpha> r) \\<subseteq> set (\\<alpha> s)\n\ngoal (1 subgoal):\n 1. set (\\<alpha> (app l r)) \\<subseteq> set (\\<alpha> s)", "by auto"], ["proof (state)\nthis:\n  set (\\<alpha> (app l r)) \\<subseteq> set (\\<alpha> s)\n\ngoal (1 subgoal):\n 1. alprio_invar \\<alpha> invar (alprio_delete splits annot app s)", "with invapplr assms(1)"], ["proof (chain)\npicking this:\n  invar (app l r)\n  alprio_invar \\<alpha> invar s\n  set (\\<alpha> (app l r)) \\<subseteq> set (\\<alpha> s)", "show ?thesis"], ["proof (prove)\nusing this:\n  invar (app l r)\n  alprio_invar \\<alpha> invar s\n  set (\\<alpha> (app l r)) \\<subseteq> set (\\<alpha> s)\n\ngoal (1 subgoal):\n 1. alprio_invar \\<alpha> invar (alprio_delete splits annot app s)", "unfolding alprio_defs"], ["proof (prove)\nusing this:\n  invar (app l r)\n  invar s \\<and> (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty)\n  set (\\<alpha> (app l r)) \\<subseteq> set (\\<alpha> s)\n\ngoal (1 subgoal):\n 1. invar\n     (let (l, uu_, y) = splits (\\<lambda>x. x \\<le> annot s) Infty s\n      in app l y) \\<and>\n    (\\<forall>x\\<in>set (\\<alpha>\n                          (let (l, uu_, y) =\n                                 splits (\\<lambda>x. x \\<le> annot s) Infty\n                                  s\n                           in app l y)).\n        snd x \\<noteq> Infty)", "by auto"], ["proof (state)\nthis:\n  alprio_invar \\<alpha> invar (alprio_delete splits annot app s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sum_list_elem:\n  assumes \" ins = l @ (a::('e,'a::linorder)Prio) # r\"  \n  and \"\\<not> sum_list l \\<le> sum_list ins\"  \n  and \"sum_list l + a \\<le> sum_list ins \"\n  shows \" a = sum_list ins\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = sum_list ins", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a = sum_list ins", "have \"\\<not> sum_list l \\<le> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> sum_list l \\<le> a", "using assms prio_add_abc"], ["proof (prove)\nusing this:\n  ins = l @ a # r\n  \\<not> sum_list l \\<le> sum_list ins\n  sum_list l + a \\<le> sum_list ins\n  \\<lbrakk>?l + ?a \\<le> ?c; \\<not> ?l \\<le> ?c\\<rbrakk>\n  \\<Longrightarrow> \\<not> ?l \\<le> ?a\n\ngoal (1 subgoal):\n 1. \\<not> sum_list l \\<le> a", "by simp"], ["proof (state)\nthis:\n  \\<not> sum_list l \\<le> a\n\ngoal (1 subgoal):\n 1. a = sum_list ins", "hence lpa: \"sum_list l + a = a\""], ["proof (prove)\nusing this:\n  \\<not> sum_list l \\<le> a\n\ngoal (1 subgoal):\n 1. sum_list l + a = a", "using prio_add_alb"], ["proof (prove)\nusing this:\n  \\<not> sum_list l \\<le> a\n  \\<not> ?b \\<le> ?a \\<Longrightarrow> ?b + ?a = ?a\n\ngoal (1 subgoal):\n 1. sum_list l + a = a", "by auto"], ["proof (state)\nthis:\n  sum_list l + a = a\n\ngoal (1 subgoal):\n 1. a = sum_list ins", "hence als: \"a \\<le> sum_list ins\""], ["proof (prove)\nusing this:\n  sum_list l + a = a\n\ngoal (1 subgoal):\n 1. a \\<le> sum_list ins", "using assms(3)"], ["proof (prove)\nusing this:\n  sum_list l + a = a\n  sum_list l + a \\<le> sum_list ins\n\ngoal (1 subgoal):\n 1. a \\<le> sum_list ins", "by simp"], ["proof (state)\nthis:\n  a \\<le> sum_list ins\n\ngoal (1 subgoal):\n 1. a = sum_list ins", "have \"sum_list ins = a + sum_list r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list ins = a + sum_list r", "using lpa sum_list_split[of l a r] assms(1)"], ["proof (prove)\nusing this:\n  sum_list l + a = a\n  sum_list (l @ a # r) = sum_list l + a + sum_list r\n  ins = l @ a # r\n\ngoal (1 subgoal):\n 1. sum_list ins = a + sum_list r", "by auto"], ["proof (state)\nthis:\n  sum_list ins = a + sum_list r\n\ngoal (1 subgoal):\n 1. a = sum_list ins", "thus ?thesis"], ["proof (prove)\nusing this:\n  sum_list ins = a + sum_list r\n\ngoal (1 subgoal):\n 1. a = sum_list ins", "using prio_add_alb2[of a \"sum_list r\"] prio_add_abc2 als"], ["proof (prove)\nusing this:\n  sum_list ins = a + sum_list r\n  a \\<le> a + sum_list r \\<Longrightarrow> a + sum_list r = a\n  ?a \\<le> ?a + ?b \\<Longrightarrow> ?a \\<le> ?b\n  a \\<le> sum_list ins\n\ngoal (1 subgoal):\n 1. a = sum_list ins", "by auto"], ["proof (state)\nthis:\n  a = sum_list ins\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma alpriodel_right:\n  assumes \"alprio_invar \\<alpha> invar s\"\n  and \"al_annot \\<alpha> invar annot\"\n  and \"alprio_\\<alpha> \\<alpha> s \\<noteq> {#}\"\n  and \"al_splits \\<alpha> invar splits\"\n  and \"al_app \\<alpha> invar app\"\n  shows \"alprio_\\<alpha> \\<alpha> (alprio_delete splits annot app s) = \n          alprio_\\<alpha> \\<alpha> s - {#p_unwrap (annot s)#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alprio_\\<alpha> \\<alpha> (alprio_delete splits annot app s) =\n    alprio_\\<alpha> \\<alpha> s - {#p_unwrap (annot s)#}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. alprio_\\<alpha> \\<alpha> (alprio_delete splits annot app s) =\n    alprio_\\<alpha> \\<alpha> s - {#p_unwrap (annot s)#}", "interpret al_splits \\<alpha> invar splits"], ["proof (prove)\ngoal (1 subgoal):\n 1. al_splits \\<alpha> invar splits", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. alprio_\\<alpha> \\<alpha> (alprio_delete splits annot app s) =\n    alprio_\\<alpha> \\<alpha> s - {#p_unwrap (annot s)#}", "let ?P = \"\\<lambda>x. x \\<le> annot s\""], ["proof (state)\ngoal (1 subgoal):\n 1. alprio_\\<alpha> \\<alpha> (alprio_delete splits annot app s) =\n    alprio_\\<alpha> \\<alpha> s - {#p_unwrap (annot s)#}", "obtain l p r where \n    [simp]:\"splits ?P Infty s = (l, p, r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l p r.\n        splits (\\<lambda>x. x \\<le> annot s) Infty s =\n        (l, p, r) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"splits ?P Infty s\")  auto"], ["proof (state)\nthis:\n  splits (\\<lambda>x. x \\<le> annot s) Infty s = (l, p, r)\n\ngoal (1 subgoal):\n 1. alprio_\\<alpha> \\<alpha> (alprio_delete splits annot app s) =\n    alprio_\\<alpha> \\<alpha> s - {#p_unwrap (annot s)#}", "obtain e a where \n    \"p = (e, a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>e a. p = (e, a) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases p, blast)"], ["proof (state)\nthis:\n  p = (e, a)\n\ngoal (1 subgoal):\n 1. alprio_\\<alpha> \\<alpha> (alprio_delete splits annot app s) =\n    alprio_\\<alpha> \\<alpha> s - {#p_unwrap (annot s)#}", "hence \n    lear:\"splits ?P Infty s = (l, (e,a), r)\""], ["proof (prove)\nusing this:\n  p = (e, a)\n\ngoal (1 subgoal):\n 1. splits (\\<lambda>x. x \\<le> annot s) Infty s = (l, (e, a), r)", "by simp"], ["proof (state)\nthis:\n  splits (\\<lambda>x. x \\<le> annot s) Infty s = (l, (e, a), r)\n\ngoal (1 subgoal):\n 1. alprio_\\<alpha> \\<alpha> (alprio_delete splits annot app s) =\n    alprio_\\<alpha> \\<alpha> s - {#p_unwrap (annot s)#}", "from annot_not_inf[OF assms(1) assms(3) assms(2)]"], ["proof (chain)\npicking this:\n  annot s \\<noteq> Infty", "have \n    \"annot s \\<noteq> Infty\""], ["proof (prove)\nusing this:\n  annot s \\<noteq> Infty\n\ngoal (1 subgoal):\n 1. annot s \\<noteq> Infty", "."], ["proof (state)\nthis:\n  annot s \\<noteq> Infty\n\ngoal (1 subgoal):\n 1. alprio_\\<alpha> \\<alpha> (alprio_delete splits annot app s) =\n    alprio_\\<alpha> \\<alpha> s - {#p_unwrap (annot s)#}", "hence \n    sv1: \"\\<not> Infty \\<le> annot s\""], ["proof (prove)\nusing this:\n  annot s \\<noteq> Infty\n\ngoal (1 subgoal):\n 1. \\<not> Infty \\<le> annot s", "by (simp add: plesseq_def, cases \"annot s\", auto)"], ["proof (state)\nthis:\n  \\<not> Infty \\<le> annot s\n\ngoal (1 subgoal):\n 1. alprio_\\<alpha> \\<alpha> (alprio_delete splits annot app s) =\n    alprio_\\<alpha> \\<alpha> s - {#p_unwrap (annot s)#}", "from assms(1)"], ["proof (chain)\npicking this:\n  alprio_invar \\<alpha> invar s", "have \n    invs: \"invar s\""], ["proof (prove)\nusing this:\n  alprio_invar \\<alpha> invar s\n\ngoal (1 subgoal):\n 1. invar s", "unfolding alprio_invar_def"], ["proof (prove)\nusing this:\n  invar s \\<and> (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty)\n\ngoal (1 subgoal):\n 1. invar s", "by simp"], ["proof (state)\nthis:\n  invar s\n\ngoal (1 subgoal):\n 1. alprio_\\<alpha> \\<alpha> (alprio_delete splits annot app s) =\n    alprio_\\<alpha> \\<alpha> s - {#p_unwrap (annot s)#}", "interpret al_annot \\<alpha> invar annot"], ["proof (prove)\ngoal (1 subgoal):\n 1. al_annot \\<alpha> invar annot", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. alprio_\\<alpha> \\<alpha> (alprio_delete splits annot app s) =\n    alprio_\\<alpha> \\<alpha> s - {#p_unwrap (annot s)#}", "from invs"], ["proof (chain)\npicking this:\n  invar s", "have \n    sv2: \"Infty + sum_list (map snd (\\<alpha> s)) \\<le> annot s\""], ["proof (prove)\nusing this:\n  invar s\n\ngoal (1 subgoal):\n 1. Infty + sum_list (map snd (\\<alpha> s)) \\<le> annot s", "by (auto simp add: annot_correct plus_def \n      plesseq_def p_min_le_neut p_order_refl)"], ["proof (state)\nthis:\n  Infty + sum_list (map snd (\\<alpha> s)) \\<le> annot s\n\ngoal (1 subgoal):\n 1. alprio_\\<alpha> \\<alpha> (alprio_delete splits annot app s) =\n    alprio_\\<alpha> \\<alpha> s - {#p_unwrap (annot s)#}", "note sp = splits_correct[of s \"?P\" Infty l e a r]"], ["proof (state)\nthis:\n  \\<lbrakk>invar s;\n   \\<forall>a b. a \\<le> annot s \\<longrightarrow> a + b \\<le> annot s;\n   \\<not> Infty \\<le> annot s;\n   Infty + sum_list (map snd (\\<alpha> s)) \\<le> annot s;\n   splits (\\<lambda>x. x \\<le> annot s) Infty s = (l, (e, a), r)\\<rbrakk>\n  \\<Longrightarrow> \\<alpha> s = \\<alpha> l @ (e, a) # \\<alpha> r \\<and>\n                    \\<not> Infty + sum_list (map snd (\\<alpha> l))\n                           \\<le> annot s \\<and>\n                    Infty + sum_list (map snd (\\<alpha> l)) + a\n                    \\<le> annot s \\<and>\n                    invar l \\<and> invar r\n\ngoal (1 subgoal):\n 1. alprio_\\<alpha> \\<alpha> (alprio_delete splits annot app s) =\n    alprio_\\<alpha> \\<alpha> s - {#p_unwrap (annot s)#}", "note dp = delpred_mon[of \"annot s\"]"], ["proof (state)\nthis:\n  \\<forall>a b. a \\<le> annot s \\<longrightarrow> a + b \\<le> annot s\n\ngoal (1 subgoal):\n 1. alprio_\\<alpha> \\<alpha> (alprio_delete splits annot app s) =\n    alprio_\\<alpha> \\<alpha> s - {#p_unwrap (annot s)#}", "from sp[OF invs dp sv1 sv2 lear]"], ["proof (chain)\npicking this:\n  \\<alpha> s = \\<alpha> l @ (e, a) # \\<alpha> r \\<and>\n  \\<not> Infty + sum_list (map snd (\\<alpha> l)) \\<le> annot s \\<and>\n  Infty + sum_list (map snd (\\<alpha> l)) + a \\<le> annot s \\<and>\n  invar l \\<and> invar r", "have \n    invlr: \"invar l \\<and> invar r\" and \n    alr: \"\\<alpha> s = \\<alpha> l @ (e, a) # \\<alpha> r\" and\n    anlel: \"\\<not> sum_list (map snd (\\<alpha> l)) \\<le> annot s\" and \n    aneqa: \"(sum_list (map snd (\\<alpha> l)) + a) \\<le> annot s\""], ["proof (prove)\nusing this:\n  \\<alpha> s = \\<alpha> l @ (e, a) # \\<alpha> r \\<and>\n  \\<not> Infty + sum_list (map snd (\\<alpha> l)) \\<le> annot s \\<and>\n  Infty + sum_list (map snd (\\<alpha> l)) + a \\<le> annot s \\<and>\n  invar l \\<and> invar r\n\ngoal (1 subgoal):\n 1. (invar l \\<and> invar r &&&\n     \\<alpha> s = \\<alpha> l @ (e, a) # \\<alpha> r) &&&\n    \\<not> sum_list (map snd (\\<alpha> l)) \\<le> annot s &&&\n    sum_list (map snd (\\<alpha> l)) + a \\<le> annot s", "by (auto simp add: plus_def zero_def)"], ["proof (state)\nthis:\n  invar l \\<and> invar r\n  \\<alpha> s = \\<alpha> l @ (e, a) # \\<alpha> r\n  \\<not> sum_list (map snd (\\<alpha> l)) \\<le> annot s\n  sum_list (map snd (\\<alpha> l)) + a \\<le> annot s\n\ngoal (1 subgoal):\n 1. alprio_\\<alpha> \\<alpha> (alprio_delete splits annot app s) =\n    alprio_\\<alpha> \\<alpha> s - {#p_unwrap (annot s)#}", "have mapalr: \"map snd (\\<alpha> s) = (map snd (\\<alpha> l)) @ a # (map snd (\\<alpha> r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map snd (\\<alpha> s) = map snd (\\<alpha> l) @ a # map snd (\\<alpha> r)", "using alr"], ["proof (prove)\nusing this:\n  \\<alpha> s = \\<alpha> l @ (e, a) # \\<alpha> r\n\ngoal (1 subgoal):\n 1. map snd (\\<alpha> s) = map snd (\\<alpha> l) @ a # map snd (\\<alpha> r)", "by simp"], ["proof (state)\nthis:\n  map snd (\\<alpha> s) = map snd (\\<alpha> l) @ a # map snd (\\<alpha> r)\n\ngoal (1 subgoal):\n 1. alprio_\\<alpha> \\<alpha> (alprio_delete splits annot app s) =\n    alprio_\\<alpha> \\<alpha> s - {#p_unwrap (annot s)#}", "note lsa = sum_list_elem[of \"map snd (\\<alpha> s)\" \"map snd (\\<alpha> l)\" a \"map snd (\\<alpha> r)\"]"], ["proof (state)\nthis:\n  \\<lbrakk>map snd (\\<alpha> s) =\n           map snd (\\<alpha> l) @ a # map snd (\\<alpha> r);\n   \\<not> sum_list (map snd (\\<alpha> l))\n          \\<le> sum_list (map snd (\\<alpha> s));\n   sum_list (map snd (\\<alpha> l)) + a\n   \\<le> sum_list (map snd (\\<alpha> s))\\<rbrakk>\n  \\<Longrightarrow> a = sum_list (map snd (\\<alpha> s))\n\ngoal (1 subgoal):\n 1. alprio_\\<alpha> \\<alpha> (alprio_delete splits annot app s) =\n    alprio_\\<alpha> \\<alpha> s - {#p_unwrap (annot s)#}", "note lsa2 = lsa[OF mapalr]"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> sum_list (map snd (\\<alpha> l))\n                  \\<le> sum_list (map snd (\\<alpha> s));\n   sum_list (map snd (\\<alpha> l)) + a\n   \\<le> sum_list (map snd (\\<alpha> s))\\<rbrakk>\n  \\<Longrightarrow> a = sum_list (map snd (\\<alpha> s))\n\ngoal (1 subgoal):\n 1. alprio_\\<alpha> \\<alpha> (alprio_delete splits annot app s) =\n    alprio_\\<alpha> \\<alpha> s - {#p_unwrap (annot s)#}", "hence a_is_annot: \"a = annot s\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> sum_list (map snd (\\<alpha> l))\n                  \\<le> sum_list (map snd (\\<alpha> s));\n   sum_list (map snd (\\<alpha> l)) + a\n   \\<le> sum_list (map snd (\\<alpha> s))\\<rbrakk>\n  \\<Longrightarrow> a = sum_list (map snd (\\<alpha> s))\n\ngoal (1 subgoal):\n 1. a = annot s", "using annot_correct[OF invs] anlel aneqa"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<not> sum_list (map snd (\\<alpha> l))\n                  \\<le> sum_list (map snd (\\<alpha> s));\n   sum_list (map snd (\\<alpha> l)) + a\n   \\<le> sum_list (map snd (\\<alpha> s))\\<rbrakk>\n  \\<Longrightarrow> a = sum_list (map snd (\\<alpha> s))\n  annot s = sum_list (map snd (\\<alpha> s))\n  \\<not> sum_list (map snd (\\<alpha> l)) \\<le> annot s\n  sum_list (map snd (\\<alpha> l)) + a \\<le> annot s\n\ngoal (1 subgoal):\n 1. a = annot s", "by auto"], ["proof (state)\nthis:\n  a = annot s\n\ngoal (1 subgoal):\n 1. alprio_\\<alpha> \\<alpha> (alprio_delete splits annot app s) =\n    alprio_\\<alpha> \\<alpha> s - {#p_unwrap (annot s)#}", "have \"map p_unwrap (map snd (\\<alpha> s)) = \n    (map p_unwrap (map snd (\\<alpha> l))) @ (p_unwrap a) \n      # (map p_unwrap (map snd (\\<alpha> r)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map p_unwrap (map snd (\\<alpha> s)) =\n    map p_unwrap (map snd (\\<alpha> l)) @\n    p_unwrap a # map p_unwrap (map snd (\\<alpha> r))", "using alr"], ["proof (prove)\nusing this:\n  \\<alpha> s = \\<alpha> l @ (e, a) # \\<alpha> r\n\ngoal (1 subgoal):\n 1. map p_unwrap (map snd (\\<alpha> s)) =\n    map p_unwrap (map snd (\\<alpha> l)) @\n    p_unwrap a # map p_unwrap (map snd (\\<alpha> r))", "by simp"], ["proof (state)\nthis:\n  map p_unwrap (map snd (\\<alpha> s)) =\n  map p_unwrap (map snd (\\<alpha> l)) @\n  p_unwrap a # map p_unwrap (map snd (\\<alpha> r))\n\ngoal (1 subgoal):\n 1. alprio_\\<alpha> \\<alpha> (alprio_delete splits annot app s) =\n    alprio_\\<alpha> \\<alpha> s - {#p_unwrap (annot s)#}", "hence alpriolst: \"(alprio_\\<alpha> \\<alpha> s) = (alprio_\\<alpha> \\<alpha> l) +{# p_unwrap a #}+ (alprio_\\<alpha> \\<alpha> r)\""], ["proof (prove)\nusing this:\n  map p_unwrap (map snd (\\<alpha> s)) =\n  map p_unwrap (map snd (\\<alpha> l)) @\n  p_unwrap a # map p_unwrap (map snd (\\<alpha> r))\n\ngoal (1 subgoal):\n 1. alprio_\\<alpha> \\<alpha> s =\n    alprio_\\<alpha> \\<alpha> l + {#p_unwrap a#} + alprio_\\<alpha> \\<alpha> r", "unfolding alprio_defs"], ["proof (prove)\nusing this:\n  map p_unwrap (map snd (\\<alpha> s)) =\n  map p_unwrap (map snd (\\<alpha> l)) @\n  p_unwrap a # map p_unwrap (map snd (\\<alpha> r))\n\ngoal (1 subgoal):\n 1. mset (map p_unwrap (map snd (\\<alpha> s))) =\n    mset (map p_unwrap (map snd (\\<alpha> l))) + {#p_unwrap a#} +\n    mset (map p_unwrap (map snd (\\<alpha> r)))", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  alprio_\\<alpha> \\<alpha> s =\n  alprio_\\<alpha> \\<alpha> l + {#p_unwrap a#} + alprio_\\<alpha> \\<alpha> r\n\ngoal (1 subgoal):\n 1. alprio_\\<alpha> \\<alpha> (alprio_delete splits annot app s) =\n    alprio_\\<alpha> \\<alpha> s - {#p_unwrap (annot s)#}", "interpret al_app \\<alpha> invar app"], ["proof (prove)\ngoal (1 subgoal):\n 1. al_app \\<alpha> invar app", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. alprio_\\<alpha> \\<alpha> (alprio_delete splits annot app s) =\n    alprio_\\<alpha> \\<alpha> s - {#p_unwrap (annot s)#}", "from alpriolst"], ["proof (chain)\npicking this:\n  alprio_\\<alpha> \\<alpha> s =\n  alprio_\\<alpha> \\<alpha> l + {#p_unwrap a#} + alprio_\\<alpha> \\<alpha> r", "show ?thesis"], ["proof (prove)\nusing this:\n  alprio_\\<alpha> \\<alpha> s =\n  alprio_\\<alpha> \\<alpha> l + {#p_unwrap a#} + alprio_\\<alpha> \\<alpha> r\n\ngoal (1 subgoal):\n 1. alprio_\\<alpha> \\<alpha> (alprio_delete splits annot app s) =\n    alprio_\\<alpha> \\<alpha> s - {#p_unwrap (annot s)#}", "using app_correct[of l r] invlr a_is_annot"], ["proof (prove)\nusing this:\n  alprio_\\<alpha> \\<alpha> s =\n  alprio_\\<alpha> \\<alpha> l + {#p_unwrap a#} + alprio_\\<alpha> \\<alpha> r\n  \\<lbrakk>invar l; invar r\\<rbrakk>\n  \\<Longrightarrow> \\<alpha> (app l r) = \\<alpha> l @ \\<alpha> r\n  \\<lbrakk>invar l; invar r\\<rbrakk> \\<Longrightarrow> invar (app l r)\n  invar l \\<and> invar r\n  a = annot s\n\ngoal (1 subgoal):\n 1. alprio_\\<alpha> \\<alpha> (alprio_delete splits annot app s) =\n    alprio_\\<alpha> \\<alpha> s - {#p_unwrap (annot s)#}", "by (auto simp add: alprio_defs algebra_simps)"], ["proof (state)\nthis:\n  alprio_\\<alpha> \\<alpha> (alprio_delete splits annot app s) =\n  alprio_\\<alpha> \\<alpha> s - {#p_unwrap (annot s)#}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma alprio_delete_correct: \n  assumes \"al_annot \\<alpha> invar annot\"\n  and \"al_splits \\<alpha> invar splits\"\n  and \"al_app \\<alpha> invar app\"\n  shows \"prio_delete (alprio_\\<alpha> \\<alpha>) (alprio_invar \\<alpha> invar) \n           (alprio_find annot) (alprio_delete splits annot app)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prio_delete (alprio_\\<alpha> \\<alpha>) (alprio_invar \\<alpha> invar)\n     (alprio_find annot) (alprio_delete splits annot app)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. prio_delete (alprio_\\<alpha> \\<alpha>) (alprio_invar \\<alpha> invar)\n     (alprio_find annot) (alprio_delete splits annot app)", "interpret al_annot \\<alpha> invar annot"], ["proof (prove)\ngoal (1 subgoal):\n 1. al_annot \\<alpha> invar annot", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. prio_delete (alprio_\\<alpha> \\<alpha>) (alprio_invar \\<alpha> invar)\n     (alprio_find annot) (alprio_delete splits annot app)", "interpret al_splits \\<alpha> invar splits"], ["proof (prove)\ngoal (1 subgoal):\n 1. al_splits \\<alpha> invar splits", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. prio_delete (alprio_\\<alpha> \\<alpha>) (alprio_invar \\<alpha> invar)\n     (alprio_find annot) (alprio_delete splits annot app)", "interpret al_app \\<alpha> invar app"], ["proof (prove)\ngoal (1 subgoal):\n 1. al_app \\<alpha> invar app", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. prio_delete (alprio_\\<alpha> \\<alpha>) (alprio_invar \\<alpha> invar)\n     (alprio_find annot) (alprio_delete splits annot app)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. prio_delete (alprio_\\<alpha> \\<alpha>) (alprio_invar \\<alpha> invar)\n     (alprio_find annot) (alprio_delete splits annot app)", "apply intro_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. prio_find (alprio_\\<alpha> \\<alpha>) (alprio_invar \\<alpha> invar)\n     (alprio_find annot)\n 2. prio_delete_axioms (alprio_\\<alpha> \\<alpha>)\n     (alprio_invar \\<alpha> invar) (alprio_find annot)\n     (alprio_delete splits annot app)", "apply (rule alprio_find_correct,simp add: assms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. prio_delete_axioms (alprio_\\<alpha> \\<alpha>)\n     (alprio_invar \\<alpha> invar) (alprio_find annot)\n     (alprio_delete splits annot app)", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>alprio_invar \\<alpha> invar p;\n        alprio_\\<alpha> \\<alpha> p \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> alprio_invar \\<alpha> invar\n                          (alprio_delete splits annot app p)\n 2. \\<And>p.\n       \\<lbrakk>alprio_invar \\<alpha> invar p;\n        alprio_\\<alpha> \\<alpha> p \\<noteq> {#}\\<rbrakk>\n       \\<Longrightarrow> alprio_\\<alpha> \\<alpha>\n                          (alprio_delete splits annot app p) =\n                         alprio_\\<alpha> \\<alpha> p -\n                         {#alprio_find annot p#}", "apply (insert assms)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>alprio_invar \\<alpha> invar p;\n        alprio_\\<alpha> \\<alpha> p \\<noteq> {#};\n        al_annot \\<alpha> invar annot; al_splits \\<alpha> invar splits;\n        al_app \\<alpha> invar app\\<rbrakk>\n       \\<Longrightarrow> alprio_invar \\<alpha> invar\n                          (alprio_delete splits annot app p)\n 2. \\<And>p.\n       \\<lbrakk>alprio_invar \\<alpha> invar p;\n        alprio_\\<alpha> \\<alpha> p \\<noteq> {#};\n        al_annot \\<alpha> invar annot; al_splits \\<alpha> invar splits;\n        al_app \\<alpha> invar app\\<rbrakk>\n       \\<Longrightarrow> alprio_\\<alpha> \\<alpha>\n                          (alprio_delete splits annot app p) =\n                         alprio_\\<alpha> \\<alpha> p -\n                         {#alprio_find annot p#}", "apply (simp add: alpriodel_invar)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>alprio_invar \\<alpha> invar p;\n        alprio_\\<alpha> \\<alpha> p \\<noteq> {#};\n        al_annot \\<alpha> invar annot; al_splits \\<alpha> invar splits;\n        al_app \\<alpha> invar app\\<rbrakk>\n       \\<Longrightarrow> alprio_\\<alpha> \\<alpha>\n                          (alprio_delete splits annot app p) =\n                         alprio_\\<alpha> \\<alpha> p -\n                         {#alprio_find annot p#}", "apply (simp add: alpriodel_right alprio_find_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  prio_delete (alprio_\\<alpha> \\<alpha>) (alprio_invar \\<alpha> invar)\n   (alprio_find annot) (alprio_delete splits annot app)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas alprio_correct =\n  alprio_empty_correct\n  alprio_isEmpty_correct\n  alprio_insert_correct\n  alprio_delete_correct\n  alprio_find_correct\n  alprio_meld_correct"], ["", "locale alprio_defs = StdALDefs ops \n  for ops :: \"(unit,('e,'a::linorder) Prio,'s) alist_ops\"\nbegin"], ["", "definition [icf_rec_def]: \"alprio_ops \\<equiv> \\<lparr>\n    prio_op_\\<alpha> = alprio_\\<alpha> \\<alpha>,\n    prio_op_invar = alprio_invar \\<alpha> invar,\n    prio_op_empty = alprio_empty empty,\n    prio_op_isEmpty = alprio_isEmpty isEmpty,\n    prio_op_insert = alprio_insert consl,\n    prio_op_find = alprio_find annot,\n    prio_op_delete = alprio_delete splits annot app,\n    prio_op_meld = alprio_meld app\n    \\<rparr>\""], ["", "end"], ["", "locale alprio = alprio_defs ops + StdAL ops \n  for ops :: \"(unit,('e,'a::linorder) Prio,'s) alist_ops\"\nbegin"], ["", "lemma alprio_ops_impl: \"StdPrio alprio_ops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. StdPrio alprio_ops", "apply (rule StdPrio.intro)"], ["proof (prove)\ngoal (6 subgoals):\n 1. prio_empty (prio_op_\\<alpha> alprio_ops) (prio_op_invar alprio_ops)\n     (prio_op_empty alprio_ops)\n 2. prio_isEmpty (prio_op_\\<alpha> alprio_ops) (prio_op_invar alprio_ops)\n     (prio_op_isEmpty alprio_ops)\n 3. prio_find (prio_op_\\<alpha> alprio_ops) (prio_op_invar alprio_ops)\n     (prio_op_find alprio_ops)\n 4. prio_insert (prio_op_\\<alpha> alprio_ops) (prio_op_invar alprio_ops)\n     (prio_op_insert alprio_ops)\n 5. prio_meld (prio_op_\\<alpha> alprio_ops) (prio_op_invar alprio_ops)\n     (prio_op_meld alprio_ops)\n 6. prio_delete (prio_op_\\<alpha> alprio_ops) (prio_op_invar alprio_ops)\n     (prio_op_find alprio_ops) (prio_op_delete alprio_ops)", "apply (simp_all add: icf_rec_unf)"], ["proof (prove)\ngoal (6 subgoals):\n 1. prio_empty (alprio_\\<alpha> \\<alpha>) (alprio_invar \\<alpha> invar)\n     (alprio_empty local.empty)\n 2. prio_isEmpty (alprio_\\<alpha> \\<alpha>) (alprio_invar \\<alpha> invar)\n     (alprio_isEmpty isEmpty)\n 3. prio_find (alprio_\\<alpha> \\<alpha>) (alprio_invar \\<alpha> invar)\n     (alprio_find annot)\n 4. prio_insert (alprio_\\<alpha> \\<alpha>) (alprio_invar \\<alpha> invar)\n     (alprio_insert consl)\n 5. prio_meld (alprio_\\<alpha> \\<alpha>) (alprio_invar \\<alpha> invar)\n     (alprio_meld app)\n 6. prio_delete (alprio_\\<alpha> \\<alpha>) (alprio_invar \\<alpha> invar)\n     (alprio_find annot) (alprio_delete splits annot app)", "apply (rule alprio_correct, unfold_locales) []"], ["proof (prove)\ngoal (5 subgoals):\n 1. prio_isEmpty (alprio_\\<alpha> \\<alpha>) (alprio_invar \\<alpha> invar)\n     (alprio_isEmpty isEmpty)\n 2. prio_find (alprio_\\<alpha> \\<alpha>) (alprio_invar \\<alpha> invar)\n     (alprio_find annot)\n 3. prio_insert (alprio_\\<alpha> \\<alpha>) (alprio_invar \\<alpha> invar)\n     (alprio_insert consl)\n 4. prio_meld (alprio_\\<alpha> \\<alpha>) (alprio_invar \\<alpha> invar)\n     (alprio_meld app)\n 5. prio_delete (alprio_\\<alpha> \\<alpha>) (alprio_invar \\<alpha> invar)\n     (alprio_find annot) (alprio_delete splits annot app)", "apply (rule alprio_correct, unfold_locales) []"], ["proof (prove)\ngoal (4 subgoals):\n 1. prio_find (alprio_\\<alpha> \\<alpha>) (alprio_invar \\<alpha> invar)\n     (alprio_find annot)\n 2. prio_insert (alprio_\\<alpha> \\<alpha>) (alprio_invar \\<alpha> invar)\n     (alprio_insert consl)\n 3. prio_meld (alprio_\\<alpha> \\<alpha>) (alprio_invar \\<alpha> invar)\n     (alprio_meld app)\n 4. prio_delete (alprio_\\<alpha> \\<alpha>) (alprio_invar \\<alpha> invar)\n     (alprio_find annot) (alprio_delete splits annot app)", "apply (rule alprio_correct, unfold_locales) []"], ["proof (prove)\ngoal (3 subgoals):\n 1. prio_insert (alprio_\\<alpha> \\<alpha>) (alprio_invar \\<alpha> invar)\n     (alprio_insert consl)\n 2. prio_meld (alprio_\\<alpha> \\<alpha>) (alprio_invar \\<alpha> invar)\n     (alprio_meld app)\n 3. prio_delete (alprio_\\<alpha> \\<alpha>) (alprio_invar \\<alpha> invar)\n     (alprio_find annot) (alprio_delete splits annot app)", "apply (rule alprio_correct, unfold_locales) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. prio_meld (alprio_\\<alpha> \\<alpha>) (alprio_invar \\<alpha> invar)\n     (alprio_meld app)\n 2. prio_delete (alprio_\\<alpha> \\<alpha>) (alprio_invar \\<alpha> invar)\n     (alprio_find annot) (alprio_delete splits annot app)", "apply (rule alprio_correct, unfold_locales) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. prio_delete (alprio_\\<alpha> \\<alpha>) (alprio_invar \\<alpha> invar)\n     (alprio_find annot) (alprio_delete splits annot app)", "apply (rule alprio_correct, unfold_locales) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "end"]]}