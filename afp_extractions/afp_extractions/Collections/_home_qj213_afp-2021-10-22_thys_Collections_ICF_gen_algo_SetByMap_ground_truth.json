{"file_name": "/home/qj213/afp-2021-10-22/thys/Collections/ICF/gen_algo/SetByMap.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Collections", "problem_names": ["lemma foldli_foldli_map_eq:\n  \"foldli (foldli l (\\<lambda>x. True) (\\<lambda>x l. l@[f x]) []) c f' \\<sigma>0\n    = foldli l c (f' o f) \\<sigma>0\"", "lemma list_it_alt: \"list_it s = map_iterator_dom (map.iteratei s)\"", "lemma list_it_unfold:\n    \"it_to_it (list_it s) c f \\<sigma>0 = map.iteratei s c (f o fst) \\<sigma>0\"", "lemma empty_impl: \"set_empty \\<alpha> invar empty\"", "lemma memb_impl: \"set_memb \\<alpha> invar memb\"", "lemma ins_impl: \"set_ins \\<alpha> invar ins\"", "lemma ins_dj_impl: \"set_ins_dj \\<alpha> invar ins_dj\"", "lemma delete_impl: \"set_delete \\<alpha> invar delete\"", "lemma list_it_impl: \"poly_set_iteratei \\<alpha> invar list_it\"", "lemma dflt_basic_ops_impl: \"StdBasicSet dflt_basic_ops\"", "lemma ordered_list_it_impl: \"poly_set_iterateoi \\<alpha> invar ordered_list_it\"", "lemma rev_list_it_impl: \"poly_set_rev_iterateoi \\<alpha> invar rev_list_it\"", "lemma dflt_basic_oops_impl: \"StdBasicOSet dflt_basic_oops\"", "lemma proper_it'_map2set: \"proper_it' it it' \n  \\<Longrightarrow> proper_it' (\\<lambda>s c f. it s c (f o fst)) (\\<lambda>s c f. it' s c (f o fst))\""], "translations": [["", "lemma foldli_foldli_map_eq:\n  \"foldli (foldli l (\\<lambda>x. True) (\\<lambda>x l. l@[f x]) []) c f' \\<sigma>0\n    = foldli l c (f' o f) \\<sigma>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli (foldli l (\\<lambda>x. True) (\\<lambda>x l. l @ [f x]) []) c f'\n     \\<sigma>0 =\n    foldli l c (f' \\<circ> f) \\<sigma>0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. foldli (foldli l (\\<lambda>x. True) (\\<lambda>x l. l @ [f x]) []) c f'\n     \\<sigma>0 =\n    foldli l c (f' \\<circ> f) \\<sigma>0", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli (foldli l (\\<lambda>x. True) (\\<lambda>x l. l @ [f x]) []) c f'\n     \\<sigma>0 =\n    foldli l c (f' \\<circ> f) \\<sigma>0", "apply (simp add: map_by_foldl foldli_map foldli_foldl)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  foldli (foldli l (\\<lambda>x. True) (\\<lambda>x l. l @ [f x]) []) c f'\n   \\<sigma>0 =\n  foldli l c (f' \\<circ> f) \\<sigma>0\n\ngoal:\nNo subgoals!", "qed"], ["", "locale SetByMapDefs =\n  map: StdBasicMapDefs ops\n  for ops :: \"('x,unit,'s,'more) map_basic_ops_scheme\"\nbegin"], ["", "definition \"\\<alpha> s \\<equiv> dom (map.\\<alpha> s)\""], ["", "definition \"invar s \\<equiv> map.invar s\""], ["", "definition empty where \"empty \\<equiv> map.empty\""], ["", "definition \"memb x s \\<equiv> map.lookup x s \\<noteq> None\""], ["", "definition \"ins x s \\<equiv> map.update x () s\""], ["", "definition \"ins_dj x s \\<equiv> map.update_dj x () s\""], ["", "definition \"delete x s \\<equiv> map.delete x s\""], ["", "definition list_it :: \"'s \\<Rightarrow> ('x,'x list) set_iterator\" \n    where \"list_it s c f \\<sigma>0 \\<equiv> it_to_it (map.list_it s) c (f o fst) \\<sigma>0\""], ["", "local_setup \\<open>Locale_Code.lc_decl_del @{term list_it}\\<close>"], ["", "lemma list_it_alt: \"list_it s = map_iterator_dom (map.iteratei s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_it s = map_iterator_dom (map.iteratei s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. list_it s = map_iterator_dom (map.iteratei s)", "have A: \"\\<And>f. (\\<lambda>(x,_). f x) = (\\<lambda>x. f (fst x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f. (\\<lambda>(x, uu_). f x) = (\\<lambda>x. f (fst x))", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>(x, uu_). ?f2 x) = (\\<lambda>x. ?f2 (fst x))\n\ngoal (1 subgoal):\n 1. list_it s = map_iterator_dom (map.iteratei s)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_it s = map_iterator_dom (map.iteratei s)", "unfolding list_it_def[abs_def] map_iterator_dom_def\n        poly_map_iteratei_defs.iteratei_def\n        set_iterator_image_def set_iterator_image_filter_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>c f. it_to_it (map.list_it s) c (f \\<circ> fst)) =\n    (\\<lambda>c f.\n        it_to_it (map.list_it s) c\n         (\\<lambda>x \\<sigma>.\n             case Some (fst x) of None \\<Rightarrow> \\<sigma>\n             | Some x' \\<Rightarrow> f x' \\<sigma>))", "by (auto simp: comp_def)"], ["proof (state)\nthis:\n  list_it s = map_iterator_dom (map.iteratei s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma list_it_unfold:\n    \"it_to_it (list_it s) c f \\<sigma>0 = map.iteratei s c (f o fst) \\<sigma>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. it_to_it (list_it s) c f \\<sigma>0 =\n    map.iteratei s c (f \\<circ> fst) \\<sigma>0", "unfolding list_it_def[abs_def] it_to_it_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli\n     (foldli (map.list_it s (\\<lambda>_. True) (\\<lambda>x l. l @ [x]) [])\n       (\\<lambda>_. True) ((\\<lambda>x l. l @ [x]) \\<circ> fst) [])\n     c f \\<sigma>0 =\n    map.iteratei s c (f \\<circ> fst) \\<sigma>0", "unfolding poly_map_iteratei_defs.iteratei_def it_to_it_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli\n     (foldli (map.list_it s (\\<lambda>_. True) (\\<lambda>x l. l @ [x]) [])\n       (\\<lambda>_. True) ((\\<lambda>x l. l @ [x]) \\<circ> fst) [])\n     c f \\<sigma>0 =\n    foldli (map.list_it s (\\<lambda>_. True) (\\<lambda>x l. l @ [x]) []) c\n     (f \\<circ> fst) \\<sigma>0", "by (simp add: foldli_foldli_map_eq comp_def)"], ["", "definition [icf_rec_def]: \"dflt_basic_ops \\<equiv> \\<lparr>\n    bset_op_\\<alpha> = \\<alpha>,\n    bset_op_invar = invar,\n    bset_op_empty = empty,\n    bset_op_memb = memb,\n    bset_op_ins = ins,\n    bset_op_ins_dj = ins_dj,\n    bset_op_delete = delete,\n    bset_op_list_it = list_it\n    \\<rparr>\""], ["", "local_setup \\<open>Locale_Code.lc_decl_del @{term dflt_basic_ops}\\<close>"], ["", "end"], ["", "setup \\<open>\n  (Record_Intf.add_unf_thms_global @{thms \n    SetByMapDefs.list_it_def[abs_def]\n  })\n\\<close>"], ["", "(*lemmas [code_unfold] = SetByMapDefs.list_it_def[abs_def]*)"], ["", "locale SetByMap = SetByMapDefs ops +\n  map: StdBasicMap ops\n  for ops :: \"('x,unit,'s,'more) map_basic_ops_scheme\"\nbegin"], ["", "lemma empty_impl: \"set_empty \\<alpha> invar empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_empty \\<alpha> invar local.empty", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<alpha> (local.empty ()) = {}\n 2. invar (local.empty ())", "unfolding \\<alpha>_def invar_def empty_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. dom (map.\\<alpha> (map.empty ())) = {}\n 2. map.invar (map.empty ())", "by (auto simp: map.empty_correct)"], ["", "lemma memb_impl: \"set_memb \\<alpha> invar memb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_memb \\<alpha> invar memb", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s x. invar s \\<Longrightarrow> memb x s = (x \\<in> \\<alpha> s)", "unfolding \\<alpha>_def invar_def memb_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s x.\n       map.invar s \\<Longrightarrow>\n       (map.lookup x s \\<noteq> None) = (x \\<in> dom (map.\\<alpha> s))", "by (auto simp: map.lookup_correct)"], ["", "lemma ins_impl: \"set_ins \\<alpha> invar ins\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_ins \\<alpha> invar ins", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s x.\n       invar s \\<Longrightarrow> \\<alpha> (ins x s) = insert x (\\<alpha> s)\n 2. \\<And>s x. invar s \\<Longrightarrow> invar (ins x s)", "unfolding \\<alpha>_def invar_def ins_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s x.\n       map.invar s \\<Longrightarrow>\n       dom (map.\\<alpha> (map.update x () s)) =\n       insert x (dom (map.\\<alpha> s))\n 2. \\<And>s x. map.invar s \\<Longrightarrow> map.invar (map.update x () s)", "by (auto simp: map.update_correct)"], ["", "lemma ins_dj_impl: \"set_ins_dj \\<alpha> invar ins_dj\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_ins_dj \\<alpha> invar ins_dj", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s x.\n       \\<lbrakk>invar s; x \\<notin> \\<alpha> s\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> (ins_dj x s) = insert x (\\<alpha> s)\n 2. \\<And>s x.\n       \\<lbrakk>invar s; x \\<notin> \\<alpha> s\\<rbrakk>\n       \\<Longrightarrow> invar (ins_dj x s)", "unfolding \\<alpha>_def invar_def ins_dj_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s x.\n       \\<lbrakk>map.invar s; x \\<notin> dom (map.\\<alpha> s)\\<rbrakk>\n       \\<Longrightarrow> dom (map.\\<alpha> (map.update_dj x () s)) =\n                         insert x (dom (map.\\<alpha> s))\n 2. \\<And>s x.\n       \\<lbrakk>map.invar s; x \\<notin> dom (map.\\<alpha> s)\\<rbrakk>\n       \\<Longrightarrow> map.invar (map.update_dj x () s)", "by (auto simp: map.update_dj_correct)"], ["", "lemma delete_impl: \"set_delete \\<alpha> invar delete\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_delete \\<alpha> invar delete", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s x.\n       invar s \\<Longrightarrow> \\<alpha> (delete x s) = \\<alpha> s - {x}\n 2. \\<And>s x. invar s \\<Longrightarrow> invar (delete x s)", "unfolding \\<alpha>_def invar_def delete_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s x.\n       map.invar s \\<Longrightarrow>\n       dom (map.\\<alpha> (map.delete x s)) = dom (map.\\<alpha> s) - {x}\n 2. \\<And>s x. map.invar s \\<Longrightarrow> map.invar (map.delete x s)", "by (auto simp: map.delete_correct)"], ["", "lemma list_it_impl: \"poly_set_iteratei \\<alpha> invar list_it\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_set_iteratei \\<alpha> invar list_it", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s. invar s \\<Longrightarrow> finite (\\<alpha> s)\n 2. \\<And>s. invar s \\<Longrightarrow> set_iterator (list_it s) (\\<alpha> s)", "fix s"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s. invar s \\<Longrightarrow> finite (\\<alpha> s)\n 2. \\<And>s. invar s \\<Longrightarrow> set_iterator (list_it s) (\\<alpha> s)", "assume I: \"invar s\""], ["proof (state)\nthis:\n  invar s\n\ngoal (2 subgoals):\n 1. \\<And>s. invar s \\<Longrightarrow> finite (\\<alpha> s)\n 2. \\<And>s. invar s \\<Longrightarrow> set_iterator (list_it s) (\\<alpha> s)", "hence I': \"map.invar s\""], ["proof (prove)\nusing this:\n  invar s\n\ngoal (1 subgoal):\n 1. map.invar s", "unfolding invar_def"], ["proof (prove)\nusing this:\n  map.invar s\n\ngoal (1 subgoal):\n 1. map.invar s", "."], ["proof (state)\nthis:\n  map.invar s\n\ngoal (2 subgoals):\n 1. \\<And>s. invar s \\<Longrightarrow> finite (\\<alpha> s)\n 2. \\<And>s. invar s \\<Longrightarrow> set_iterator (list_it s) (\\<alpha> s)", "have S: \"\\<And>f. (\\<lambda>(x,_). f x) = (\\<lambda>xy. f (fst xy))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f. (\\<lambda>(x, uu_). f x) = (\\<lambda>xy. f (fst xy))", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>(x, uu_). ?f2 x) = (\\<lambda>xy. ?f2 (fst xy))\n\ngoal (2 subgoals):\n 1. \\<And>s. invar s \\<Longrightarrow> finite (\\<alpha> s)\n 2. \\<And>s. invar s \\<Longrightarrow> set_iterator (list_it s) (\\<alpha> s)", "from map_iterator_dom_correct[OF map.iteratei_correct[OF I']]"], ["proof (chain)\npicking this:\n  set_iterator (map_iterator_dom (map.iteratei s)) (dom (map.\\<alpha> s))", "show \"set_iterator (list_it s) (\\<alpha> s)\""], ["proof (prove)\nusing this:\n  set_iterator (map_iterator_dom (map.iteratei s)) (dom (map.\\<alpha> s))\n\ngoal (1 subgoal):\n 1. set_iterator (list_it s) (\\<alpha> s)", "unfolding \\<alpha>_def list_it_alt"], ["proof (prove)\nusing this:\n  set_iterator (map_iterator_dom (map.iteratei s)) (dom (map.\\<alpha> s))\n\ngoal (1 subgoal):\n 1. set_iterator (map_iterator_dom (map.iteratei s)) (dom (map.\\<alpha> s))", "."], ["proof (state)\nthis:\n  set_iterator (list_it s) (\\<alpha> s)\n\ngoal (1 subgoal):\n 1. \\<And>s. invar s \\<Longrightarrow> finite (\\<alpha> s)", "show \"finite (\\<alpha> s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (\\<alpha> s)", "unfolding \\<alpha>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (dom (map.\\<alpha> s))", "by (simp add: map.finite[OF I'])"], ["proof (state)\nthis:\n  finite (\\<alpha> s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dflt_basic_ops_impl: \"StdBasicSet dflt_basic_ops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. StdBasicSet dflt_basic_ops", "apply (rule StdBasicSet.intro)"], ["proof (prove)\ngoal (6 subgoals):\n 1. set_empty (bset_op_\\<alpha> dflt_basic_ops)\n     (bset_op_invar dflt_basic_ops) (bset_op_empty dflt_basic_ops)\n 2. set_memb (bset_op_\\<alpha> dflt_basic_ops)\n     (bset_op_invar dflt_basic_ops) (bset_op_memb dflt_basic_ops)\n 3. set_ins (bset_op_\\<alpha> dflt_basic_ops) (bset_op_invar dflt_basic_ops)\n     (bset_op_ins dflt_basic_ops)\n 4. set_ins_dj (bset_op_\\<alpha> dflt_basic_ops)\n     (bset_op_invar dflt_basic_ops) (bset_op_ins_dj dflt_basic_ops)\n 5. set_delete (bset_op_\\<alpha> dflt_basic_ops)\n     (bset_op_invar dflt_basic_ops) (bset_op_delete dflt_basic_ops)\n 6. poly_set_iteratei (bset_op_\\<alpha> dflt_basic_ops)\n     (bset_op_invar dflt_basic_ops) (bset_op_list_it dflt_basic_ops)", "apply (simp_all add: icf_rec_unf)"], ["proof (prove)\ngoal (6 subgoals):\n 1. set_empty \\<alpha> invar local.empty\n 2. set_memb \\<alpha> invar memb\n 3. set_ins \\<alpha> invar ins\n 4. set_ins_dj \\<alpha> invar ins_dj\n 5. set_delete \\<alpha> invar delete\n 6. poly_set_iteratei \\<alpha> invar\n     (\\<lambda>s c f. it_to_it (map.list_it s) c (f \\<circ> fst))", "apply (rule empty_impl memb_impl ins_impl\n      ins_dj_impl delete_impl \n      list_it_impl[unfolded SetByMapDefs.list_it_def[abs_def]]\n    )+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "locale OSetByOMapDefs = SetByMapDefs ops +\n  map: StdBasicOMapDefs ops\n  for ops :: \"('x::linorder,unit,'s,'more) omap_basic_ops_scheme\"\nbegin"], ["", "definition ordered_list_it :: \"'s \\<Rightarrow> ('x,'x list) set_iterator\" \n    where \"ordered_list_it s c f \\<sigma>0 \n    \\<equiv> it_to_it (map.ordered_list_it s) c (f o fst) \\<sigma>0\""], ["", "(*where \"list_it s c f \\<sigma>0 \\<equiv> it_to_it (map.list_it s) c (f o fst) \\<sigma>0\"*)"], ["", "local_setup \\<open>Locale_Code.lc_decl_del @{term ordered_list_it}\\<close>"], ["", "definition rev_list_it :: \"'s \\<Rightarrow> ('x,'x list) set_iterator\" \n    where \"rev_list_it s c f \\<sigma>0 \\<equiv> it_to_it (map.rev_list_it s) c (f o fst) \\<sigma>0\""], ["", "(*where \"rev_list_it s c f \\<sigma>0 \\<equiv> map.rev_iterateoi s c (f o fst) \\<sigma>0\"*)"], ["", "local_setup \\<open>Locale_Code.lc_decl_del @{term rev_list_it}\\<close>"], ["", "definition [icf_rec_def]: \"dflt_basic_oops \\<equiv> \n    set_basic_ops.extend dflt_basic_ops \\<lparr>\n      bset_op_ordered_list_it = ordered_list_it,\n      bset_op_rev_list_it = rev_list_it\n      \\<rparr>\""], ["", "local_setup \\<open>Locale_Code.lc_decl_del @{term dflt_basic_oops}\\<close>"], ["", "end"], ["", "setup \\<open>\n  (Record_Intf.add_unf_thms_global @{thms \n    OSetByOMapDefs.ordered_list_it_def[abs_def]\n    OSetByOMapDefs.rev_list_it_def[abs_def]\n  })\n\\<close>"], ["", "(*lemmas [code_unfold] = OSetByOMapDefs.ordered_list_it_def[abs_def]\n  OSetByOMapDefs.rev_list_it_def[abs_def]*)"], ["", "locale OSetByOMap = OSetByOMapDefs ops +\n  SetByMap ops + map: StdBasicOMap ops\n  for ops :: \"('x::linorder,unit,'s,'more) omap_basic_ops_scheme\"\nbegin"], ["", "lemma ordered_list_it_impl: \"poly_set_iterateoi \\<alpha> invar ordered_list_it\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_set_iterateoi \\<alpha> invar ordered_list_it", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s. invar s \\<Longrightarrow> finite (\\<alpha> s)\n 2. \\<And>x.\n       invar x \\<Longrightarrow>\n       set_iterator_linord (ordered_list_it x) (\\<alpha> x)", "fix s"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s. invar s \\<Longrightarrow> finite (\\<alpha> s)\n 2. \\<And>x.\n       invar x \\<Longrightarrow>\n       set_iterator_linord (ordered_list_it x) (\\<alpha> x)", "assume I: \"invar s\""], ["proof (state)\nthis:\n  invar s\n\ngoal (2 subgoals):\n 1. \\<And>s. invar s \\<Longrightarrow> finite (\\<alpha> s)\n 2. \\<And>x.\n       invar x \\<Longrightarrow>\n       set_iterator_linord (ordered_list_it x) (\\<alpha> x)", "hence I': \"map.invar s\""], ["proof (prove)\nusing this:\n  invar s\n\ngoal (1 subgoal):\n 1. map.invar s", "unfolding invar_def"], ["proof (prove)\nusing this:\n  map.invar s\n\ngoal (1 subgoal):\n 1. map.invar s", "."], ["proof (state)\nthis:\n  map.invar s\n\ngoal (2 subgoals):\n 1. \\<And>s. invar s \\<Longrightarrow> finite (\\<alpha> s)\n 2. \\<And>x.\n       invar x \\<Longrightarrow>\n       set_iterator_linord (ordered_list_it x) (\\<alpha> x)", "have S: \"\\<And>f. (\\<lambda>(x,_). f x) = (\\<lambda>xy. f (fst xy))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f. (\\<lambda>(x, uu_). f x) = (\\<lambda>xy. f (fst xy))", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>(x, uu_). ?f4 x) = (\\<lambda>xy. ?f4 (fst xy))\n\ngoal (2 subgoals):\n 1. \\<And>s. invar s \\<Longrightarrow> finite (\\<alpha> s)\n 2. \\<And>x.\n       invar x \\<Longrightarrow>\n       set_iterator_linord (ordered_list_it x) (\\<alpha> x)", "have A: \"\\<And>s. ordered_list_it s = map_iterator_dom (map.iterateoi s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s. ordered_list_it s = map_iterator_dom (map.iterateoi s)", "unfolding ordered_list_it_def[abs_def] \n        map_iterator_dom_def set_iterator_image_alt_def map.iterateoi_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       (\\<lambda>c f. it_to_it (map.ordered_list_it s) c (f \\<circ> fst)) =\n       (\\<lambda>c f.\n           it_to_it (map.ordered_list_it s) c (\\<lambda>x. f (fst x)))", "by (simp add: S comp_def)"], ["proof (state)\nthis:\n  ordered_list_it ?s5 = map_iterator_dom (map.iterateoi ?s5)\n\ngoal (2 subgoals):\n 1. \\<And>s. invar s \\<Longrightarrow> finite (\\<alpha> s)\n 2. \\<And>x.\n       invar x \\<Longrightarrow>\n       set_iterator_linord (ordered_list_it x) (\\<alpha> x)", "from map_iterator_linord_dom_correct[OF map.iterateoi_correct[OF I']]"], ["proof (chain)\npicking this:\n  set_iterator_linord (map_iterator_dom (map.iterateoi s))\n   (dom (map.\\<alpha> s))", "show \"set_iterator_linord (ordered_list_it s) (\\<alpha> s)\""], ["proof (prove)\nusing this:\n  set_iterator_linord (map_iterator_dom (map.iterateoi s))\n   (dom (map.\\<alpha> s))\n\ngoal (1 subgoal):\n 1. set_iterator_linord (ordered_list_it s) (\\<alpha> s)", "unfolding \\<alpha>_def A"], ["proof (prove)\nusing this:\n  set_iterator_linord (map_iterator_dom (map.iterateoi s))\n   (dom (map.\\<alpha> s))\n\ngoal (1 subgoal):\n 1. set_iterator_linord (map_iterator_dom (map.iterateoi s))\n     (dom (map.\\<alpha> s))", "."], ["proof (state)\nthis:\n  set_iterator_linord (ordered_list_it s) (\\<alpha> s)\n\ngoal (1 subgoal):\n 1. \\<And>s. invar s \\<Longrightarrow> finite (\\<alpha> s)", "show \"finite (\\<alpha> s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (\\<alpha> s)", "unfolding \\<alpha>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (dom (map.\\<alpha> s))", "by (simp add: map.finite[OF I'])"], ["proof (state)\nthis:\n  finite (\\<alpha> s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rev_list_it_impl: \"poly_set_rev_iterateoi \\<alpha> invar rev_list_it\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_set_rev_iterateoi \\<alpha> invar rev_list_it", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s. invar s \\<Longrightarrow> finite (\\<alpha> s)\n 2. \\<And>s.\n       invar s \\<Longrightarrow>\n       set_iterator_rev_linord (rev_list_it s) (\\<alpha> s)", "fix s"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s. invar s \\<Longrightarrow> finite (\\<alpha> s)\n 2. \\<And>s.\n       invar s \\<Longrightarrow>\n       set_iterator_rev_linord (rev_list_it s) (\\<alpha> s)", "assume I: \"invar s\""], ["proof (state)\nthis:\n  invar s\n\ngoal (2 subgoals):\n 1. \\<And>s. invar s \\<Longrightarrow> finite (\\<alpha> s)\n 2. \\<And>s.\n       invar s \\<Longrightarrow>\n       set_iterator_rev_linord (rev_list_it s) (\\<alpha> s)", "hence I': \"map.invar s\""], ["proof (prove)\nusing this:\n  invar s\n\ngoal (1 subgoal):\n 1. map.invar s", "unfolding invar_def"], ["proof (prove)\nusing this:\n  map.invar s\n\ngoal (1 subgoal):\n 1. map.invar s", "."], ["proof (state)\nthis:\n  map.invar s\n\ngoal (2 subgoals):\n 1. \\<And>s. invar s \\<Longrightarrow> finite (\\<alpha> s)\n 2. \\<And>s.\n       invar s \\<Longrightarrow>\n       set_iterator_rev_linord (rev_list_it s) (\\<alpha> s)", "have S: \"\\<And>f. (\\<lambda>(x,_). f x) = (\\<lambda>xy. f (fst xy))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f. (\\<lambda>(x, uu_). f x) = (\\<lambda>xy. f (fst xy))", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>(x, uu_). ?f4 x) = (\\<lambda>xy. ?f4 (fst xy))\n\ngoal (2 subgoals):\n 1. \\<And>s. invar s \\<Longrightarrow> finite (\\<alpha> s)\n 2. \\<And>s.\n       invar s \\<Longrightarrow>\n       set_iterator_rev_linord (rev_list_it s) (\\<alpha> s)", "have A: \"\\<And>s. rev_list_it s = map_iterator_dom (map.rev_iterateoi s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s. rev_list_it s = map_iterator_dom (map.reverse_iterateoi s)", "unfolding rev_list_it_def[abs_def] \n        map_iterator_dom_def set_iterator_image_alt_def map.rev_iterateoi_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       (\\<lambda>c f. it_to_it (map.rev_list_it s) c (f \\<circ> fst)) =\n       (\\<lambda>c f.\n           it_to_it (map.rev_list_it s) c (\\<lambda>x. f (fst x)))", "by (simp add: S comp_def)"], ["proof (state)\nthis:\n  rev_list_it ?s5 = map_iterator_dom (map.reverse_iterateoi ?s5)\n\ngoal (2 subgoals):\n 1. \\<And>s. invar s \\<Longrightarrow> finite (\\<alpha> s)\n 2. \\<And>s.\n       invar s \\<Longrightarrow>\n       set_iterator_rev_linord (rev_list_it s) (\\<alpha> s)", "from map_iterator_rev_linord_dom_correct[\n      OF map.rev_iterateoi_correct[OF I']]"], ["proof (chain)\npicking this:\n  set_iterator_rev_linord (map_iterator_dom (map.reverse_iterateoi s))\n   (dom (map.\\<alpha> s))", "show \"set_iterator_rev_linord (rev_list_it s) (\\<alpha> s)\""], ["proof (prove)\nusing this:\n  set_iterator_rev_linord (map_iterator_dom (map.reverse_iterateoi s))\n   (dom (map.\\<alpha> s))\n\ngoal (1 subgoal):\n 1. set_iterator_rev_linord (rev_list_it s) (\\<alpha> s)", "unfolding \\<alpha>_def A"], ["proof (prove)\nusing this:\n  set_iterator_rev_linord (map_iterator_dom (map.reverse_iterateoi s))\n   (dom (map.\\<alpha> s))\n\ngoal (1 subgoal):\n 1. set_iterator_rev_linord (map_iterator_dom (map.reverse_iterateoi s))\n     (dom (map.\\<alpha> s))", "."], ["proof (state)\nthis:\n  set_iterator_rev_linord (rev_list_it s) (\\<alpha> s)\n\ngoal (1 subgoal):\n 1. \\<And>s. invar s \\<Longrightarrow> finite (\\<alpha> s)", "show \"finite (\\<alpha> s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (\\<alpha> s)", "unfolding \\<alpha>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (dom (map.\\<alpha> s))", "by (simp add: map.finite[OF I'])"], ["proof (state)\nthis:\n  finite (\\<alpha> s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dflt_basic_oops_impl: \"StdBasicOSet dflt_basic_oops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. StdBasicOSet dflt_basic_oops", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. StdBasicOSet dflt_basic_oops", "interpret aux: StdBasicSet dflt_basic_ops"], ["proof (prove)\ngoal (1 subgoal):\n 1. StdBasicSet dflt_basic_ops", "by (rule dflt_basic_ops_impl)"], ["proof (state)\ngoal (1 subgoal):\n 1. StdBasicOSet dflt_basic_oops", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. StdBasicOSet dflt_basic_oops", "apply (rule StdBasicOSet.intro)"], ["proof (prove)\ngoal (3 subgoals):\n 1. StdBasicSet dflt_basic_oops\n 2. poly_set_iterateoi (bset_op_\\<alpha> dflt_basic_oops)\n     (bset_op_invar dflt_basic_oops)\n     (bset_op_ordered_list_it dflt_basic_oops)\n 3. poly_set_rev_iterateoi (bset_op_\\<alpha> dflt_basic_oops)\n     (bset_op_invar dflt_basic_oops) (bset_op_rev_list_it dflt_basic_oops)", "apply (rule StdBasicSet.intro)"], ["proof (prove)\ngoal (8 subgoals):\n 1. set_empty (bset_op_\\<alpha> dflt_basic_oops)\n     (bset_op_invar dflt_basic_oops) (bset_op_empty dflt_basic_oops)\n 2. set_memb (bset_op_\\<alpha> dflt_basic_oops)\n     (bset_op_invar dflt_basic_oops) (bset_op_memb dflt_basic_oops)\n 3. set_ins (bset_op_\\<alpha> dflt_basic_oops)\n     (bset_op_invar dflt_basic_oops) (bset_op_ins dflt_basic_oops)\n 4. set_ins_dj (bset_op_\\<alpha> dflt_basic_oops)\n     (bset_op_invar dflt_basic_oops) (bset_op_ins_dj dflt_basic_oops)\n 5. set_delete (bset_op_\\<alpha> dflt_basic_oops)\n     (bset_op_invar dflt_basic_oops) (bset_op_delete dflt_basic_oops)\n 6. poly_set_iteratei (bset_op_\\<alpha> dflt_basic_oops)\n     (bset_op_invar dflt_basic_oops) (bset_op_list_it dflt_basic_oops)\n 7. poly_set_iterateoi (bset_op_\\<alpha> dflt_basic_oops)\n     (bset_op_invar dflt_basic_oops)\n     (bset_op_ordered_list_it dflt_basic_oops)\n 8. poly_set_rev_iterateoi (bset_op_\\<alpha> dflt_basic_oops)\n     (bset_op_invar dflt_basic_oops) (bset_op_rev_list_it dflt_basic_oops)", "apply icf_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. poly_set_iterateoi (bset_op_\\<alpha> dflt_basic_oops)\n     (bset_op_invar dflt_basic_oops)\n     (bset_op_ordered_list_it dflt_basic_oops)\n 2. poly_set_rev_iterateoi (bset_op_\\<alpha> dflt_basic_oops)\n     (bset_op_invar dflt_basic_oops) (bset_op_rev_list_it dflt_basic_oops)", "apply (simp_all add: icf_rec_unf)"], ["proof (prove)\ngoal (2 subgoals):\n 1. poly_set_iterateoi \\<alpha> invar\n     (\\<lambda>s c f. it_to_it (map.ordered_list_it s) c (f \\<circ> fst))\n 2. poly_set_rev_iterateoi \\<alpha> invar\n     (\\<lambda>s c f. it_to_it (map.rev_list_it s) c (f \\<circ> fst))", "apply (rule \n        ordered_list_it_impl[unfolded ordered_list_it_def[abs_def]] \n        rev_list_it_impl[unfolded rev_list_it_def[abs_def]]\n      )+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  StdBasicOSet dflt_basic_oops\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "sublocale SetByMap < basic: StdBasicSet \"dflt_basic_ops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. StdBasicSet dflt_basic_ops", "by (rule dflt_basic_ops_impl)"], ["", "sublocale OSetByOMap < obasic: StdBasicOSet \"dflt_basic_oops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. StdBasicOSet dflt_basic_oops", "by (rule dflt_basic_oops_impl)"], ["", "lemma proper_it'_map2set: \"proper_it' it it' \n  \\<Longrightarrow> proper_it' (\\<lambda>s c f. it s c (f o fst)) (\\<lambda>s c f. it' s c (f o fst))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it' it it' \\<Longrightarrow>\n    proper_it' (\\<lambda>s c f. it s c (f \\<circ> fst))\n     (\\<lambda>s c f. it' s c (f \\<circ> fst))", "unfolding proper_it'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s. proper_it (it s) (it' s) \\<Longrightarrow>\n    \\<forall>s.\n       proper_it (\\<lambda>c f. it s c (f \\<circ> fst))\n        (\\<lambda>c f. it' s c (f \\<circ> fst))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<forall>s. proper_it (it s) (it' s) \\<Longrightarrow>\n       proper_it (\\<lambda>c f. it s c (f \\<circ> fst))\n        (\\<lambda>c f. it' s c (f \\<circ> fst))", "apply (drule_tac x=s in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       proper_it (it s) (it' s) \\<Longrightarrow>\n       proper_it (\\<lambda>c f. it s c (f \\<circ> fst))\n        (\\<lambda>c f. it' s c (f \\<circ> fst))", "apply (erule proper_itE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s l.\n       \\<lbrakk>it s = foldli l; it' s = foldli l\\<rbrakk>\n       \\<Longrightarrow> proper_it (\\<lambda>c f. it s c (f \\<circ> fst))\n                          (\\<lambda>c f. it' s c (f \\<circ> fst))", "apply (rule proper_itI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s l.\n       \\<lbrakk>it s = foldli l; it' s = foldli l\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>c f. it s c (f \\<circ> fst)) =\n                         foldli (?l5 s l) \\<and>\n                         (\\<lambda>c f. it' s c (f \\<circ> fst)) =\n                         foldli (?l5 s l)", "apply (auto simp add: foldli_map[symmetric] intro!: ext)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}