{"file_name": "/home/qj213/afp-2021-10-22/thys/Collections/ICF/gen_algo/SetIndex.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Collections", "problem_names": ["lemma indexI: \"\\<lbrakk> x\\<in>s; f x = i \\<rbrakk> \\<Longrightarrow> x\\<in>index f s i\"", "lemma indexD: \n  \"x\\<in>index f s i \\<Longrightarrow> x\\<in>s\"\n  \"x\\<in>index f s i \\<Longrightarrow> f x = i\"", "lemma index_iff[simp]: \"x\\<in>index f s i \\<longleftrightarrow> x\\<in>s \\<and> f x = i\"", "lemma index_map_correct: \"im_\\<alpha> (index_map f s) = index f s\"", "lemma ci_impl_minvar: \"ci_invar m \\<Longrightarrow> m.invar m\"", "lemma is_index_invar: \"is_index f s idx \\<Longrightarrow> ci_invar idx\"", "lemma is_index_correct: \"is_index f s idx \\<Longrightarrow> ci_\\<alpha> idx = index f s\"", "lemma lookup_invar': \"ci_invar m \\<Longrightarrow> s.invar (lookup i m)\"", "lemma lookup_correct:\n    assumes I[simp, intro!]: \"is_index f s idx\"\n    shows \n      \"s.\\<alpha> (lookup i idx) = index f s i\"\n      \"s.invar (lookup i idx)\"", "lemma idx_build_correct:\n    assumes I: \"t.invar t\"\n    shows \"ci_\\<alpha>' (idx_build f t) = index_map f (t.\\<alpha> t)\" (is ?T1) and\n    [simp]: \"ci_invar (idx_build f t)\" (is ?T2)", "lemma idx_build_is_index: \n    \"t.invar t \\<Longrightarrow> is_index f (t.\\<alpha> t) (idx_build f t)\""], "translations": [["", "lemma indexI: \"\\<lbrakk> x\\<in>s; f x = i \\<rbrakk> \\<Longrightarrow> x\\<in>index f s i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> s; f x = i\\<rbrakk>\n    \\<Longrightarrow> x \\<in> index f s i", "by (unfold index_def) auto"], ["", "lemma indexD: \n  \"x\\<in>index f s i \\<Longrightarrow> x\\<in>s\"\n  \"x\\<in>index f s i \\<Longrightarrow> f x = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> index f s i \\<Longrightarrow> x \\<in> s) &&&\n    (x \\<in> index f s i \\<Longrightarrow> f x = i)", "by (unfold index_def) auto"], ["", "lemma index_iff[simp]: \"x\\<in>index f s i \\<longleftrightarrow> x\\<in>s \\<and> f x = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> index f s i) = (x \\<in> s \\<and> f x = i)", "by (simp add: index_def)"], ["", "subsection \"Indexing by Map\""], ["", "definition index_map :: \"('a \\<Rightarrow> 'i) \\<Rightarrow> 'a set \\<Rightarrow> 'i \\<rightharpoonup> 'a set\"\n  where \"index_map f s i == let s=index f s i in if s={} then None else Some s\""], ["", "definition im_\\<alpha> where \"im_\\<alpha> im i == case im i of None \\<Rightarrow> {} | Some s \\<Rightarrow> s\""], ["", "lemma index_map_correct: \"im_\\<alpha> (index_map f s) = index f s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. im_\\<alpha> (index_map f s) = index f s", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. im_\\<alpha> (index_map f s) x = index f s x", "apply (unfold index_def index_map_def im_\\<alpha>_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (case let s = {xa \\<in> s. f xa = x}\n             in if s = {} then None else Some s of\n        None \\<Rightarrow> {} | Some s \\<Rightarrow> s) =\n       {xa \\<in> s. f xa = x}", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \"Indexing by Maps and Sets from the Isabelle Collections Framework\""], ["", "text \\<open>\n  In this theory, we define the generic algorithm as constants outside any locale,\n  but prove the correctness lemmas inside a locale that assumes correctness of all\n  prerequisite functions.\n  Finally, we export the correctness lemmas from the locale.\n\\<close>"], ["", "locale index_loc = \n  m: StdMap m_ops +\n  s: StdSet s_ops\n  for m_ops :: \"('i,'s,'m,'more1) map_ops_scheme\"\n  and s_ops :: \"('x,'s,'more2) set_ops_scheme\"\nbegin\n  \\<comment> \\<open>Mapping indices to abstract indices\\<close>"], ["", "definition ci_\\<alpha>' where\n    \"ci_\\<alpha>' ci i == case m.\\<alpha> ci i of None \\<Rightarrow> None | Some s \\<Rightarrow> Some (s.\\<alpha> s)\""], ["", "definition \"ci_\\<alpha> == im_\\<alpha> \\<circ> ci_\\<alpha>'\""], ["", "definition ci_invar where\n    \"ci_invar ci == m.invar ci \\<and> (\\<forall>i s. m.\\<alpha> ci i = Some s \\<longrightarrow> s.invar s)\""], ["", "lemma ci_impl_minvar: \"ci_invar m \\<Longrightarrow> m.invar m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ci_invar m \\<Longrightarrow> m.invar m", "by (unfold ci_invar_def) auto"], ["", "definition is_index :: \"('x \\<Rightarrow> 'i) \\<Rightarrow> 'x set \\<Rightarrow> 'm \\<Rightarrow> bool\"\n  where\n    \"is_index f s idx == ci_invar idx \\<and> ci_\\<alpha>' idx = index_map f s\""], ["", "lemma is_index_invar: \"is_index f s idx \\<Longrightarrow> ci_invar idx\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_index f s idx \\<Longrightarrow> ci_invar idx", "by (simp add: is_index_def)"], ["", "lemma is_index_correct: \"is_index f s idx \\<Longrightarrow> ci_\\<alpha> idx = index f s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_index f s idx \\<Longrightarrow> ci_\\<alpha> idx = index f s", "by (simp only: is_index_def index_map_def ci_\\<alpha>_def)\n       (simp add: index_map_correct)"], ["", "definition lookup :: \"'i \\<Rightarrow> 'm \\<Rightarrow> 's\" where\n    \"lookup i m == case m.lookup i m of None \\<Rightarrow> (s.empty ()) | Some s \\<Rightarrow> s\""], ["", "lemma lookup_invar': \"ci_invar m \\<Longrightarrow> s.invar (lookup i m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ci_invar m \\<Longrightarrow> s.invar (lookup i m)", "apply (unfold ci_invar_def lookup_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. m.invar m \\<and>\n    (\\<forall>i s.\n        m.\\<alpha> m i = Some s \\<longrightarrow>\n        s.invar s) \\<Longrightarrow>\n    s.invar\n     (case m.lookup i m of None \\<Rightarrow> s.empty ()\n      | Some s \\<Rightarrow> s)", "apply (auto split: option.split simp add: m.lookup_correct s.empty_correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma lookup_correct:\n    assumes I[simp, intro!]: \"is_index f s idx\"\n    shows \n      \"s.\\<alpha> (lookup i idx) = index f s i\"\n      \"s.invar (lookup i idx)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s.\\<alpha> (lookup i idx) = index f s i &&& s.invar (lookup i idx)", "proof goal_cases"], ["proof (state)\ngoal (2 subgoals):\n 1. s.\\<alpha> (lookup i idx) = index f s i\n 2. s.invar (lookup i idx)", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. s.\\<alpha> (lookup i idx) = index f s i\n 2. s.invar (lookup i idx)", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. s.invar (lookup i idx)", "using I"], ["proof (prove)\nusing this:\n  is_index f s idx\n\ngoal (1 subgoal):\n 1. s.invar (lookup i idx)", "by (simp add: is_index_def lookup_invar')"], ["proof (state)\nthis:\n  s.invar (lookup i idx)\n\ngoal (1 subgoal):\n 1. s.\\<alpha> (lookup i idx) = index f s i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. s.\\<alpha> (lookup i idx) = index f s i", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. s.\\<alpha> (lookup i idx) = index f s i", "have [simp, intro!]: \"m.invar idx\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m.invar idx", "using ci_impl_minvar[OF is_index_invar[OF I]]"], ["proof (prove)\nusing this:\n  m.invar idx\n\ngoal (1 subgoal):\n 1. m.invar idx", "by simp"], ["proof (state)\nthis:\n  m.invar idx\n\ngoal (1 subgoal):\n 1. s.\\<alpha> (lookup i idx) = index f s i", "thus ?case"], ["proof (prove)\nusing this:\n  m.invar idx\n\ngoal (1 subgoal):\n 1. s.\\<alpha> (lookup i idx) = index f s i", "proof (cases \"m.lookup i idx\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>m.invar idx; m.lookup i idx = None\\<rbrakk>\n    \\<Longrightarrow> s.\\<alpha> (lookup i idx) = index f s i\n 2. \\<And>a.\n       \\<lbrakk>m.invar idx; m.lookup i idx = Some a\\<rbrakk>\n       \\<Longrightarrow> s.\\<alpha> (lookup i idx) = index f s i", "case None"], ["proof (state)\nthis:\n  m.lookup i idx = None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>m.invar idx; m.lookup i idx = None\\<rbrakk>\n    \\<Longrightarrow> s.\\<alpha> (lookup i idx) = index f s i\n 2. \\<And>a.\n       \\<lbrakk>m.invar idx; m.lookup i idx = Some a\\<rbrakk>\n       \\<Longrightarrow> s.\\<alpha> (lookup i idx) = index f s i", "hence [simp]: \"m.\\<alpha> idx i = None\""], ["proof (prove)\nusing this:\n  m.lookup i idx = None\n\ngoal (1 subgoal):\n 1. m.\\<alpha> idx i = None", "by (simp add: m.lookup_correct)"], ["proof (state)\nthis:\n  m.\\<alpha> idx i = None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>m.invar idx; m.lookup i idx = None\\<rbrakk>\n    \\<Longrightarrow> s.\\<alpha> (lookup i idx) = index f s i\n 2. \\<And>a.\n       \\<lbrakk>m.invar idx; m.lookup i idx = Some a\\<rbrakk>\n       \\<Longrightarrow> s.\\<alpha> (lookup i idx) = index f s i", "from is_index_correct[OF I]"], ["proof (chain)\npicking this:\n  ci_\\<alpha> idx = index f s", "have \"index f s i = ci_\\<alpha> idx i\""], ["proof (prove)\nusing this:\n  ci_\\<alpha> idx = index f s\n\ngoal (1 subgoal):\n 1. index f s i = ci_\\<alpha> idx i", "by simp"], ["proof (state)\nthis:\n  index f s i = ci_\\<alpha> idx i\n\ngoal (2 subgoals):\n 1. \\<lbrakk>m.invar idx; m.lookup i idx = None\\<rbrakk>\n    \\<Longrightarrow> s.\\<alpha> (lookup i idx) = index f s i\n 2. \\<And>a.\n       \\<lbrakk>m.invar idx; m.lookup i idx = Some a\\<rbrakk>\n       \\<Longrightarrow> s.\\<alpha> (lookup i idx) = index f s i", "also"], ["proof (state)\nthis:\n  index f s i = ci_\\<alpha> idx i\n\ngoal (2 subgoals):\n 1. \\<lbrakk>m.invar idx; m.lookup i idx = None\\<rbrakk>\n    \\<Longrightarrow> s.\\<alpha> (lookup i idx) = index f s i\n 2. \\<And>a.\n       \\<lbrakk>m.invar idx; m.lookup i idx = Some a\\<rbrakk>\n       \\<Longrightarrow> s.\\<alpha> (lookup i idx) = index f s i", "have \"\\<dots> = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ci_\\<alpha> idx i = {}", "by (simp add: ci_\\<alpha>_def ci_\\<alpha>'_def im_\\<alpha>_def)"], ["proof (state)\nthis:\n  ci_\\<alpha> idx i = {}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>m.invar idx; m.lookup i idx = None\\<rbrakk>\n    \\<Longrightarrow> s.\\<alpha> (lookup i idx) = index f s i\n 2. \\<And>a.\n       \\<lbrakk>m.invar idx; m.lookup i idx = Some a\\<rbrakk>\n       \\<Longrightarrow> s.\\<alpha> (lookup i idx) = index f s i", "finally"], ["proof (chain)\npicking this:\n  index f s i = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  index f s i = {}\n\ngoal (1 subgoal):\n 1. s.\\<alpha> (lookup i idx) = index f s i", "by (simp add: lookup_def None s.empty_correct)"], ["proof (state)\nthis:\n  s.\\<alpha> (lookup i idx) = index f s i\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>m.invar idx; m.lookup i idx = Some a\\<rbrakk>\n       \\<Longrightarrow> s.\\<alpha> (lookup i idx) = index f s i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>m.invar idx; m.lookup i idx = Some a\\<rbrakk>\n       \\<Longrightarrow> s.\\<alpha> (lookup i idx) = index f s i", "case (Some si)"], ["proof (state)\nthis:\n  m.lookup i idx = Some si\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>m.invar idx; m.lookup i idx = Some a\\<rbrakk>\n       \\<Longrightarrow> s.\\<alpha> (lookup i idx) = index f s i", "hence [simp]: \"m.\\<alpha> idx i = Some si\""], ["proof (prove)\nusing this:\n  m.lookup i idx = Some si\n\ngoal (1 subgoal):\n 1. m.\\<alpha> idx i = Some si", "by (simp add: m.lookup_correct)"], ["proof (state)\nthis:\n  m.\\<alpha> idx i = Some si\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>m.invar idx; m.lookup i idx = Some a\\<rbrakk>\n       \\<Longrightarrow> s.\\<alpha> (lookup i idx) = index f s i", "from is_index_correct[OF I]"], ["proof (chain)\npicking this:\n  ci_\\<alpha> idx = index f s", "have \"index f s i = ci_\\<alpha> idx i\""], ["proof (prove)\nusing this:\n  ci_\\<alpha> idx = index f s\n\ngoal (1 subgoal):\n 1. index f s i = ci_\\<alpha> idx i", "by simp"], ["proof (state)\nthis:\n  index f s i = ci_\\<alpha> idx i\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>m.invar idx; m.lookup i idx = Some a\\<rbrakk>\n       \\<Longrightarrow> s.\\<alpha> (lookup i idx) = index f s i", "also"], ["proof (state)\nthis:\n  index f s i = ci_\\<alpha> idx i\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>m.invar idx; m.lookup i idx = Some a\\<rbrakk>\n       \\<Longrightarrow> s.\\<alpha> (lookup i idx) = index f s i", "have \"\\<dots> = s.\\<alpha> si\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ci_\\<alpha> idx i = s.\\<alpha> si", "by (simp add: ci_\\<alpha>_def ci_\\<alpha>'_def im_\\<alpha>_def)"], ["proof (state)\nthis:\n  ci_\\<alpha> idx i = s.\\<alpha> si\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>m.invar idx; m.lookup i idx = Some a\\<rbrakk>\n       \\<Longrightarrow> s.\\<alpha> (lookup i idx) = index f s i", "finally"], ["proof (chain)\npicking this:\n  index f s i = s.\\<alpha> si", "show ?thesis"], ["proof (prove)\nusing this:\n  index f s i = s.\\<alpha> si\n\ngoal (1 subgoal):\n 1. s.\\<alpha> (lookup i idx) = index f s i", "by (simp add: lookup_def Some s.empty_correct)"], ["proof (state)\nthis:\n  s.\\<alpha> (lookup i idx) = index f s i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s.\\<alpha> (lookup i idx) = index f s i\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "locale build_index_loc = index_loc m_ops s_ops +\n  t: StdSet t_ops\n  for m_ops :: \"('i,'s,'m,'more1) map_ops_scheme\"\n  and s_ops :: \"('x,'s,'more3) set_ops_scheme\"\n  and t_ops :: \"('x,'t,'more2) set_ops_scheme\"\nbegin"], ["", "text \"Building indices\""], ["", "definition idx_build_stepfun :: \"('x \\<Rightarrow> 'i) \\<Rightarrow> 'x \\<Rightarrow> 'm \\<Rightarrow> 'm\" where\n    \"idx_build_stepfun f x m == \n      let i=f x in\n        (case m.lookup i m of\n          None \\<Rightarrow> m.update i (s.ins x (s.empty ())) m |\n          Some s \\<Rightarrow> m.update i (s.ins x s) m\n      )\""], ["", "definition idx_build :: \"('x \\<Rightarrow> 'i) \\<Rightarrow> 't \\<Rightarrow> 'm\" where\n    \"idx_build f t == t.iterate t (idx_build_stepfun f) (m.empty ())\""], ["", "lemma idx_build_correct:\n    assumes I: \"t.invar t\"\n    shows \"ci_\\<alpha>' (idx_build f t) = index_map f (t.\\<alpha> t)\" (is ?T1) and\n    [simp]: \"ci_invar (idx_build f t)\" (is ?T2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ci_\\<alpha>' (idx_build f t) = index_map f (t.\\<alpha> t) &&&\n    ci_invar (idx_build f t)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. ci_\\<alpha>' (idx_build f t) = index_map f (t.\\<alpha> t)\n 2. ci_invar (idx_build f t)", "have \"t.invar t \\<Longrightarrow> \n      ci_\\<alpha>' (idx_build f t) = index_map f (t.\\<alpha> t) \\<and> ci_invar (idx_build f t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t.invar t \\<Longrightarrow>\n    ci_\\<alpha>' (idx_build f t) = index_map f (t.\\<alpha> t) \\<and>\n    ci_invar (idx_build f t)", "apply (unfold idx_build_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. t.invar t \\<Longrightarrow>\n    ci_\\<alpha>' (t.iterate t (idx_build_stepfun f) (m.empty ())) =\n    index_map f (t.\\<alpha> t) \\<and>\n    ci_invar (t.iterate t (idx_build_stepfun f) (m.empty ()))", "apply (rule_tac \n          I=\"\\<lambda>it m. ci_\\<alpha>' m = index_map f (t.\\<alpha> t - it) \\<and> ci_invar m\" \n          in t.iterate_rule_P)"], ["proof (prove)\ngoal (4 subgoals):\n 1. t.invar t \\<Longrightarrow> t.invar t\n 2. t.invar t \\<Longrightarrow>\n    ci_\\<alpha>' (m.empty ()) =\n    index_map f (t.\\<alpha> t - t.\\<alpha> t) \\<and>\n    ci_invar (m.empty ())\n 3. \\<And>x it \\<sigma>.\n       \\<lbrakk>t.invar t; x \\<in> it; it \\<subseteq> t.\\<alpha> t;\n        ci_\\<alpha>' \\<sigma> = index_map f (t.\\<alpha> t - it) \\<and>\n        ci_invar \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> ci_\\<alpha>' (idx_build_stepfun f x \\<sigma>) =\n                         index_map f (t.\\<alpha> t - (it - {x})) \\<and>\n                         ci_invar (idx_build_stepfun f x \\<sigma>)\n 4. \\<And>\\<sigma>.\n       \\<lbrakk>t.invar t;\n        ci_\\<alpha>' \\<sigma> = index_map f (t.\\<alpha> t - {}) \\<and>\n        ci_invar \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> ci_\\<alpha>' \\<sigma> =\n                         index_map f (t.\\<alpha> t) \\<and>\n                         ci_invar \\<sigma>", "apply assumption"], ["proof (prove)\ngoal (3 subgoals):\n 1. t.invar t \\<Longrightarrow>\n    ci_\\<alpha>' (m.empty ()) =\n    index_map f (t.\\<alpha> t - t.\\<alpha> t) \\<and>\n    ci_invar (m.empty ())\n 2. \\<And>x it \\<sigma>.\n       \\<lbrakk>t.invar t; x \\<in> it; it \\<subseteq> t.\\<alpha> t;\n        ci_\\<alpha>' \\<sigma> = index_map f (t.\\<alpha> t - it) \\<and>\n        ci_invar \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> ci_\\<alpha>' (idx_build_stepfun f x \\<sigma>) =\n                         index_map f (t.\\<alpha> t - (it - {x})) \\<and>\n                         ci_invar (idx_build_stepfun f x \\<sigma>)\n 3. \\<And>\\<sigma>.\n       \\<lbrakk>t.invar t;\n        ci_\\<alpha>' \\<sigma> = index_map f (t.\\<alpha> t - {}) \\<and>\n        ci_invar \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> ci_\\<alpha>' \\<sigma> =\n                         index_map f (t.\\<alpha> t) \\<and>\n                         ci_invar \\<sigma>", "apply (simp add: ci_invar_def m.empty_correct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. t.invar t \\<Longrightarrow> ci_\\<alpha>' (m.empty ()) = index_map f {}\n 2. \\<And>x it \\<sigma>.\n       \\<lbrakk>t.invar t; x \\<in> it; it \\<subseteq> t.\\<alpha> t;\n        ci_\\<alpha>' \\<sigma> = index_map f (t.\\<alpha> t - it) \\<and>\n        ci_invar \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> ci_\\<alpha>' (idx_build_stepfun f x \\<sigma>) =\n                         index_map f (t.\\<alpha> t - (it - {x})) \\<and>\n                         ci_invar (idx_build_stepfun f x \\<sigma>)\n 3. \\<And>\\<sigma>.\n       \\<lbrakk>t.invar t;\n        ci_\\<alpha>' \\<sigma> = index_map f (t.\\<alpha> t - {}) \\<and>\n        ci_invar \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> ci_\\<alpha>' \\<sigma> =\n                         index_map f (t.\\<alpha> t) \\<and>\n                         ci_invar \\<sigma>", "apply (rule ext)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       t.invar t \\<Longrightarrow>\n       ci_\\<alpha>' (m.empty ()) x = index_map f {} x\n 2. \\<And>x it \\<sigma>.\n       \\<lbrakk>t.invar t; x \\<in> it; it \\<subseteq> t.\\<alpha> t;\n        ci_\\<alpha>' \\<sigma> = index_map f (t.\\<alpha> t - it) \\<and>\n        ci_invar \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> ci_\\<alpha>' (idx_build_stepfun f x \\<sigma>) =\n                         index_map f (t.\\<alpha> t - (it - {x})) \\<and>\n                         ci_invar (idx_build_stepfun f x \\<sigma>)\n 3. \\<And>\\<sigma>.\n       \\<lbrakk>t.invar t;\n        ci_\\<alpha>' \\<sigma> = index_map f (t.\\<alpha> t - {}) \\<and>\n        ci_invar \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> ci_\\<alpha>' \\<sigma> =\n                         index_map f (t.\\<alpha> t) \\<and>\n                         ci_invar \\<sigma>", "apply (unfold ci_\\<alpha>'_def index_map_def index_def)[1]"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       t.invar t \\<Longrightarrow>\n       (case m.\\<alpha> (m.empty ()) x of None \\<Rightarrow> None\n        | Some s \\<Rightarrow> Some (s.\\<alpha> s)) =\n       (let s = {xa \\<in> {}. f xa = x} in if s = {} then None else Some s)\n 2. \\<And>x it \\<sigma>.\n       \\<lbrakk>t.invar t; x \\<in> it; it \\<subseteq> t.\\<alpha> t;\n        ci_\\<alpha>' \\<sigma> = index_map f (t.\\<alpha> t - it) \\<and>\n        ci_invar \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> ci_\\<alpha>' (idx_build_stepfun f x \\<sigma>) =\n                         index_map f (t.\\<alpha> t - (it - {x})) \\<and>\n                         ci_invar (idx_build_stepfun f x \\<sigma>)\n 3. \\<And>\\<sigma>.\n       \\<lbrakk>t.invar t;\n        ci_\\<alpha>' \\<sigma> = index_map f (t.\\<alpha> t - {}) \\<and>\n        ci_invar \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> ci_\\<alpha>' \\<sigma> =\n                         index_map f (t.\\<alpha> t) \\<and>\n                         ci_invar \\<sigma>", "apply (simp add: m.empty_correct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x it \\<sigma>.\n       \\<lbrakk>t.invar t; x \\<in> it; it \\<subseteq> t.\\<alpha> t;\n        ci_\\<alpha>' \\<sigma> = index_map f (t.\\<alpha> t - it) \\<and>\n        ci_invar \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> ci_\\<alpha>' (idx_build_stepfun f x \\<sigma>) =\n                         index_map f (t.\\<alpha> t - (it - {x})) \\<and>\n                         ci_invar (idx_build_stepfun f x \\<sigma>)\n 2. \\<And>\\<sigma>.\n       \\<lbrakk>t.invar t;\n        ci_\\<alpha>' \\<sigma> = index_map f (t.\\<alpha> t - {}) \\<and>\n        ci_invar \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> ci_\\<alpha>' \\<sigma> =\n                         index_map f (t.\\<alpha> t) \\<and>\n                         ci_invar \\<sigma>", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma>.\n       \\<lbrakk>t.invar t;\n        ci_\\<alpha>' \\<sigma> = index_map f (t.\\<alpha> t - {}) \\<and>\n        ci_invar \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> ci_\\<alpha>' \\<sigma> =\n                         index_map f (t.\\<alpha> t) \\<and>\n                         ci_invar \\<sigma>\n 2. \\<And>x it \\<sigma>.\n       \\<lbrakk>t.invar t; x \\<in> it; it \\<subseteq> t.\\<alpha> t;\n        ci_\\<alpha>' \\<sigma> = index_map f (t.\\<alpha> t - it) \\<and>\n        ci_invar \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> ci_\\<alpha>' (idx_build_stepfun f x \\<sigma>) =\n                         index_map f (t.\\<alpha> t - (it - {x})) \\<and>\n                         ci_invar (idx_build_stepfun f x \\<sigma>)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x it \\<sigma>.\n       \\<lbrakk>t.invar t; x \\<in> it; it \\<subseteq> t.\\<alpha> t;\n        ci_\\<alpha>' \\<sigma> = index_map f (t.\\<alpha> t - it) \\<and>\n        ci_invar \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> ci_\\<alpha>' (idx_build_stepfun f x \\<sigma>) =\n                         index_map f (t.\\<alpha> t - (it - {x})) \\<and>\n                         ci_invar (idx_build_stepfun f x \\<sigma>)", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x it \\<sigma>.\n       \\<lbrakk>t.invar t; x \\<in> it; it \\<subseteq> t.\\<alpha> t;\n        ci_\\<alpha>' \\<sigma> = index_map f (t.\\<alpha> t - it) \\<and>\n        ci_invar \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> ci_\\<alpha>' (idx_build_stepfun f x \\<sigma>) =\n                         index_map f (t.\\<alpha> t - (it - {x}))\n 2. \\<And>x it \\<sigma>.\n       \\<lbrakk>t.invar t; x \\<in> it; it \\<subseteq> t.\\<alpha> t;\n        ci_\\<alpha>' \\<sigma> = index_map f (t.\\<alpha> t - it) \\<and>\n        ci_invar \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> ci_invar (idx_build_stepfun f x \\<sigma>)", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x it \\<sigma>.\n       \\<lbrakk>t.invar t; x \\<in> it; it \\<subseteq> t.\\<alpha> t;\n        ci_\\<alpha>' \\<sigma> = index_map f (t.\\<alpha> t - it) \\<and>\n        ci_invar \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> ci_invar (idx_build_stepfun f x \\<sigma>)\n 2. \\<And>x it \\<sigma>.\n       \\<lbrakk>t.invar t; x \\<in> it; it \\<subseteq> t.\\<alpha> t;\n        ci_\\<alpha>' \\<sigma> = index_map f (t.\\<alpha> t - it) \\<and>\n        ci_invar \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> ci_\\<alpha>' (idx_build_stepfun f x \\<sigma>) =\n                         index_map f (t.\\<alpha> t - (it - {x}))", "apply (unfold idx_build_stepfun_def)[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x it \\<sigma>.\n       \\<lbrakk>t.invar t; x \\<in> it; it \\<subseteq> t.\\<alpha> t;\n        ci_\\<alpha>' \\<sigma> = index_map f (t.\\<alpha> t - it) \\<and>\n        ci_invar \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> ci_invar\n                          (let i = f x\n                           in case m.lookup i \\<sigma> of\n                              None \\<Rightarrow>\n                                m.update i (s.ins x (s.empty ())) \\<sigma>\n                              | Some s \\<Rightarrow>\n                                  m.update i (s.ins x s) \\<sigma>)\n 2. \\<And>x it \\<sigma>.\n       \\<lbrakk>t.invar t; x \\<in> it; it \\<subseteq> t.\\<alpha> t;\n        ci_\\<alpha>' \\<sigma> = index_map f (t.\\<alpha> t - it) \\<and>\n        ci_invar \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> ci_\\<alpha>' (idx_build_stepfun f x \\<sigma>) =\n                         index_map f (t.\\<alpha> t - (it - {x}))", "apply (auto \n        simp add: ci_invar_def m.update_correct m.lookup_correct \n                  s.empty_correct s.ins_correct Let_def \n        split: option.split) [1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x it \\<sigma>.\n       \\<lbrakk>t.invar t; x \\<in> it; it \\<subseteq> t.\\<alpha> t;\n        ci_\\<alpha>' \\<sigma> = index_map f (t.\\<alpha> t - it) \\<and>\n        ci_invar \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> ci_\\<alpha>' (idx_build_stepfun f x \\<sigma>) =\n                         index_map f (t.\\<alpha> t - (it - {x}))", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x it \\<sigma> xa.\n       \\<lbrakk>t.invar t; x \\<in> it; it \\<subseteq> t.\\<alpha> t;\n        ci_\\<alpha>' \\<sigma> = index_map f (t.\\<alpha> t - it) \\<and>\n        ci_invar \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> ci_\\<alpha>' (idx_build_stepfun f x \\<sigma>) xa =\n                         index_map f (t.\\<alpha> t - (it - {x})) xa", "proof goal_cases"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x it \\<sigma> xa.\n       \\<lbrakk>t.invar t; x \\<in> it; it \\<subseteq> t.\\<alpha> t;\n        ci_\\<alpha>' \\<sigma> = index_map f (t.\\<alpha> t - it) \\<and>\n        ci_invar \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> ci_\\<alpha>' (idx_build_stepfun f x \\<sigma>) xa =\n                         index_map f (t.\\<alpha> t - (it - {x})) xa", "case prems: (1 x it m i)"], ["proof (state)\nthis:\n  t.invar t\n  x \\<in> it\n  it \\<subseteq> t.\\<alpha> t\n  ci_\\<alpha>' m = index_map f (t.\\<alpha> t - it) \\<and> ci_invar m\n\ngoal (1 subgoal):\n 1. \\<And>x it \\<sigma> xa.\n       \\<lbrakk>t.invar t; x \\<in> it; it \\<subseteq> t.\\<alpha> t;\n        ci_\\<alpha>' \\<sigma> = index_map f (t.\\<alpha> t - it) \\<and>\n        ci_invar \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> ci_\\<alpha>' (idx_build_stepfun f x \\<sigma>) xa =\n                         index_map f (t.\\<alpha> t - (it - {x})) xa", "hence INV[simp, intro!]: \"m.invar m\""], ["proof (prove)\nusing this:\n  t.invar t\n  x \\<in> it\n  it \\<subseteq> t.\\<alpha> t\n  ci_\\<alpha>' m = index_map f (t.\\<alpha> t - it) \\<and> ci_invar m\n\ngoal (1 subgoal):\n 1. m.invar m", "by (simp add: ci_invar_def)"], ["proof (state)\nthis:\n  m.invar m\n\ngoal (1 subgoal):\n 1. \\<And>x it \\<sigma> xa.\n       \\<lbrakk>t.invar t; x \\<in> it; it \\<subseteq> t.\\<alpha> t;\n        ci_\\<alpha>' \\<sigma> = index_map f (t.\\<alpha> t - it) \\<and>\n        ci_invar \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> ci_\\<alpha>' (idx_build_stepfun f x \\<sigma>) xa =\n                         index_map f (t.\\<alpha> t - (it - {x})) xa", "from prems"], ["proof (chain)\npicking this:\n  t.invar t\n  x \\<in> it\n  it \\<subseteq> t.\\<alpha> t\n  ci_\\<alpha>' m = index_map f (t.\\<alpha> t - it) \\<and> ci_invar m", "have \n        INVS[simp, intro]: \"!!q s. m.\\<alpha> m q = Some s \\<Longrightarrow> s.invar s\""], ["proof (prove)\nusing this:\n  t.invar t\n  x \\<in> it\n  it \\<subseteq> t.\\<alpha> t\n  ci_\\<alpha>' m = index_map f (t.\\<alpha> t - it) \\<and> ci_invar m\n\ngoal (1 subgoal):\n 1. \\<And>q s. m.\\<alpha> m q = Some s \\<Longrightarrow> s.invar s", "by (simp add: ci_invar_def)"], ["proof (state)\nthis:\n  m.\\<alpha> m ?q2 = Some ?s2 \\<Longrightarrow> s.invar ?s2\n\ngoal (1 subgoal):\n 1. \\<And>x it \\<sigma> xa.\n       \\<lbrakk>t.invar t; x \\<in> it; it \\<subseteq> t.\\<alpha> t;\n        ci_\\<alpha>' \\<sigma> = index_map f (t.\\<alpha> t - it) \\<and>\n        ci_invar \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> ci_\\<alpha>' (idx_build_stepfun f x \\<sigma>) xa =\n                         index_map f (t.\\<alpha> t - (it - {x})) xa", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ci_\\<alpha>' (idx_build_stepfun f x m) i =\n    index_map f (t.\\<alpha> t - (it - {x})) i", "proof (cases \"i=f x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = f x \\<Longrightarrow>\n    ci_\\<alpha>' (idx_build_stepfun f x m) i =\n    index_map f (t.\\<alpha> t - (it - {x})) i\n 2. i \\<noteq> f x \\<Longrightarrow>\n    ci_\\<alpha>' (idx_build_stepfun f x m) i =\n    index_map f (t.\\<alpha> t - (it - {x})) i", "case [simp]: True"], ["proof (state)\nthis:\n  i = f x\n\ngoal (2 subgoals):\n 1. i = f x \\<Longrightarrow>\n    ci_\\<alpha>' (idx_build_stepfun f x m) i =\n    index_map f (t.\\<alpha> t - (it - {x})) i\n 2. i \\<noteq> f x \\<Longrightarrow>\n    ci_\\<alpha>' (idx_build_stepfun f x m) i =\n    index_map f (t.\\<alpha> t - (it - {x})) i", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ci_\\<alpha>' (idx_build_stepfun f x m) i =\n    index_map f (t.\\<alpha> t - (it - {x})) i", "proof (cases \"m.\\<alpha> m (f x)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. m.\\<alpha> m (f x) = None \\<Longrightarrow>\n    ci_\\<alpha>' (idx_build_stepfun f x m) i =\n    index_map f (t.\\<alpha> t - (it - {x})) i\n 2. \\<And>a.\n       m.\\<alpha> m (f x) = Some a \\<Longrightarrow>\n       ci_\\<alpha>' (idx_build_stepfun f x m) i =\n       index_map f (t.\\<alpha> t - (it - {x})) i", "case [simp]: None"], ["proof (state)\nthis:\n  m.\\<alpha> m (f x) = None\n\ngoal (2 subgoals):\n 1. m.\\<alpha> m (f x) = None \\<Longrightarrow>\n    ci_\\<alpha>' (idx_build_stepfun f x m) i =\n    index_map f (t.\\<alpha> t - (it - {x})) i\n 2. \\<And>a.\n       m.\\<alpha> m (f x) = Some a \\<Longrightarrow>\n       ci_\\<alpha>' (idx_build_stepfun f x m) i =\n       index_map f (t.\\<alpha> t - (it - {x})) i", "hence \"idx_build_stepfun f x m = m.update i (s.ins x (s.empty ())) m\""], ["proof (prove)\nusing this:\n  m.\\<alpha> m (f x) = None\n\ngoal (1 subgoal):\n 1. idx_build_stepfun f x m = m.update i (s.ins x (s.empty ())) m", "apply (unfold idx_build_stepfun_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. m.\\<alpha> m (f x) = None \\<Longrightarrow>\n    (let i = f x\n     in case m.lookup i m of\n        None \\<Rightarrow> m.update i (s.ins x (s.empty ())) m\n        | Some s \\<Rightarrow> m.update i (s.ins x s) m) =\n    m.update i (s.ins x (s.empty ())) m", "apply (simp add: m.update_correct m.lookup_correct s.empty_correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  idx_build_stepfun f x m = m.update i (s.ins x (s.empty ())) m\n\ngoal (2 subgoals):\n 1. m.\\<alpha> m (f x) = None \\<Longrightarrow>\n    ci_\\<alpha>' (idx_build_stepfun f x m) i =\n    index_map f (t.\\<alpha> t - (it - {x})) i\n 2. \\<And>a.\n       m.\\<alpha> m (f x) = Some a \\<Longrightarrow>\n       ci_\\<alpha>' (idx_build_stepfun f x m) i =\n       index_map f (t.\\<alpha> t - (it - {x})) i", "hence \"ci_\\<alpha>' (idx_build_stepfun f x m) i = Some {x}\""], ["proof (prove)\nusing this:\n  idx_build_stepfun f x m = m.update i (s.ins x (s.empty ())) m\n\ngoal (1 subgoal):\n 1. ci_\\<alpha>' (idx_build_stepfun f x m) i = Some {x}", "by (simp add: m.update_correct \n                          s.ins_correct s.empty_correct ci_\\<alpha>'_def)"], ["proof (state)\nthis:\n  ci_\\<alpha>' (idx_build_stepfun f x m) i = Some {x}\n\ngoal (2 subgoals):\n 1. m.\\<alpha> m (f x) = None \\<Longrightarrow>\n    ci_\\<alpha>' (idx_build_stepfun f x m) i =\n    index_map f (t.\\<alpha> t - (it - {x})) i\n 2. \\<And>a.\n       m.\\<alpha> m (f x) = Some a \\<Longrightarrow>\n       ci_\\<alpha>' (idx_build_stepfun f x m) i =\n       index_map f (t.\\<alpha> t - (it - {x})) i", "also"], ["proof (state)\nthis:\n  ci_\\<alpha>' (idx_build_stepfun f x m) i = Some {x}\n\ngoal (2 subgoals):\n 1. m.\\<alpha> m (f x) = None \\<Longrightarrow>\n    ci_\\<alpha>' (idx_build_stepfun f x m) i =\n    index_map f (t.\\<alpha> t - (it - {x})) i\n 2. \\<And>a.\n       m.\\<alpha> m (f x) = Some a \\<Longrightarrow>\n       ci_\\<alpha>' (idx_build_stepfun f x m) i =\n       index_map f (t.\\<alpha> t - (it - {x})) i", "{"], ["proof (state)\nthis:\n  ci_\\<alpha>' (idx_build_stepfun f x m) i = Some {x}\n\ngoal (2 subgoals):\n 1. m.\\<alpha> m (f x) = None \\<Longrightarrow>\n    ci_\\<alpha>' (idx_build_stepfun f x m) i =\n    index_map f (t.\\<alpha> t - (it - {x})) i\n 2. \\<And>a.\n       m.\\<alpha> m (f x) = Some a \\<Longrightarrow>\n       ci_\\<alpha>' (idx_build_stepfun f x m) i =\n       index_map f (t.\\<alpha> t - (it - {x})) i", "have \"None = ci_\\<alpha>' m (f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. None = ci_\\<alpha>' m (f x)", "by (simp add: ci_\\<alpha>'_def)"], ["proof (state)\nthis:\n  None = ci_\\<alpha>' m (f x)\n\ngoal (2 subgoals):\n 1. m.\\<alpha> m (f x) = None \\<Longrightarrow>\n    ci_\\<alpha>' (idx_build_stepfun f x m) i =\n    index_map f (t.\\<alpha> t - (it - {x})) i\n 2. \\<And>a.\n       m.\\<alpha> m (f x) = Some a \\<Longrightarrow>\n       ci_\\<alpha>' (idx_build_stepfun f x m) i =\n       index_map f (t.\\<alpha> t - (it - {x})) i", "also"], ["proof (state)\nthis:\n  None = ci_\\<alpha>' m (f x)\n\ngoal (2 subgoals):\n 1. m.\\<alpha> m (f x) = None \\<Longrightarrow>\n    ci_\\<alpha>' (idx_build_stepfun f x m) i =\n    index_map f (t.\\<alpha> t - (it - {x})) i\n 2. \\<And>a.\n       m.\\<alpha> m (f x) = Some a \\<Longrightarrow>\n       ci_\\<alpha>' (idx_build_stepfun f x m) i =\n       index_map f (t.\\<alpha> t - (it - {x})) i", "from prems(4)"], ["proof (chain)\npicking this:\n  ci_\\<alpha>' m = index_map f (t.\\<alpha> t - it) \\<and> ci_invar m", "have \"\\<dots> = index_map f (t.\\<alpha> t - it) i\""], ["proof (prove)\nusing this:\n  ci_\\<alpha>' m = index_map f (t.\\<alpha> t - it) \\<and> ci_invar m\n\ngoal (1 subgoal):\n 1. ci_\\<alpha>' m (f x) = index_map f (t.\\<alpha> t - it) i", "by simp"], ["proof (state)\nthis:\n  ci_\\<alpha>' m (f x) = index_map f (t.\\<alpha> t - it) i\n\ngoal (2 subgoals):\n 1. m.\\<alpha> m (f x) = None \\<Longrightarrow>\n    ci_\\<alpha>' (idx_build_stepfun f x m) i =\n    index_map f (t.\\<alpha> t - (it - {x})) i\n 2. \\<And>a.\n       m.\\<alpha> m (f x) = Some a \\<Longrightarrow>\n       ci_\\<alpha>' (idx_build_stepfun f x m) i =\n       index_map f (t.\\<alpha> t - (it - {x})) i", "finally"], ["proof (chain)\npicking this:\n  None = index_map f (t.\\<alpha> t - it) i", "have E: \"{xa \\<in> t.\\<alpha> t - it. f xa = i} = {}\""], ["proof (prove)\nusing this:\n  None = index_map f (t.\\<alpha> t - it) i\n\ngoal (1 subgoal):\n 1. {xa \\<in> t.\\<alpha> t - it. f xa = i} = {}", "by (simp add: index_map_def index_def split: if_split_asm)"], ["proof (state)\nthis:\n  {xa \\<in> t.\\<alpha> t - it. f xa = i} = {}\n\ngoal (2 subgoals):\n 1. m.\\<alpha> m (f x) = None \\<Longrightarrow>\n    ci_\\<alpha>' (idx_build_stepfun f x m) i =\n    index_map f (t.\\<alpha> t - (it - {x})) i\n 2. \\<And>a.\n       m.\\<alpha> m (f x) = Some a \\<Longrightarrow>\n       ci_\\<alpha>' (idx_build_stepfun f x m) i =\n       index_map f (t.\\<alpha> t - (it - {x})) i", "moreover"], ["proof (state)\nthis:\n  {xa \\<in> t.\\<alpha> t - it. f xa = i} = {}\n\ngoal (2 subgoals):\n 1. m.\\<alpha> m (f x) = None \\<Longrightarrow>\n    ci_\\<alpha>' (idx_build_stepfun f x m) i =\n    index_map f (t.\\<alpha> t - (it - {x})) i\n 2. \\<And>a.\n       m.\\<alpha> m (f x) = Some a \\<Longrightarrow>\n       ci_\\<alpha>' (idx_build_stepfun f x m) i =\n       index_map f (t.\\<alpha> t - (it - {x})) i", "have \n              \"{xa \\<in> t.\\<alpha> t - (it - {x}). f xa = i} \n               = {xa \\<in> t.\\<alpha> t - it. f xa = i} \\<union> {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {xa \\<in> t.\\<alpha> t - (it - {x}). f xa = i} =\n    {xa \\<in> t.\\<alpha> t - it. f xa = i} \\<union> {x}", "using prems(2,3)"], ["proof (prove)\nusing this:\n  x \\<in> it\n  it \\<subseteq> t.\\<alpha> t\n\ngoal (1 subgoal):\n 1. {xa \\<in> t.\\<alpha> t - (it - {x}). f xa = i} =\n    {xa \\<in> t.\\<alpha> t - it. f xa = i} \\<union> {x}", "by auto"], ["proof (state)\nthis:\n  {xa \\<in> t.\\<alpha> t - (it - {x}). f xa = i} =\n  {xa \\<in> t.\\<alpha> t - it. f xa = i} \\<union> {x}\n\ngoal (2 subgoals):\n 1. m.\\<alpha> m (f x) = None \\<Longrightarrow>\n    ci_\\<alpha>' (idx_build_stepfun f x m) i =\n    index_map f (t.\\<alpha> t - (it - {x})) i\n 2. \\<And>a.\n       m.\\<alpha> m (f x) = Some a \\<Longrightarrow>\n       ci_\\<alpha>' (idx_build_stepfun f x m) i =\n       index_map f (t.\\<alpha> t - (it - {x})) i", "ultimately"], ["proof (chain)\npicking this:\n  {xa \\<in> t.\\<alpha> t - it. f xa = i} = {}\n  {xa \\<in> t.\\<alpha> t - (it - {x}). f xa = i} =\n  {xa \\<in> t.\\<alpha> t - it. f xa = i} \\<union> {x}", "have \"Some {x} = index_map f (t.\\<alpha> t - (it - {x})) i\""], ["proof (prove)\nusing this:\n  {xa \\<in> t.\\<alpha> t - it. f xa = i} = {}\n  {xa \\<in> t.\\<alpha> t - (it - {x}). f xa = i} =\n  {xa \\<in> t.\\<alpha> t - it. f xa = i} \\<union> {x}\n\ngoal (1 subgoal):\n 1. Some {x} = index_map f (t.\\<alpha> t - (it - {x})) i", "by (unfold index_map_def index_def) auto"], ["proof (state)\nthis:\n  Some {x} = index_map f (t.\\<alpha> t - (it - {x})) i\n\ngoal (2 subgoals):\n 1. m.\\<alpha> m (f x) = None \\<Longrightarrow>\n    ci_\\<alpha>' (idx_build_stepfun f x m) i =\n    index_map f (t.\\<alpha> t - (it - {x})) i\n 2. \\<And>a.\n       m.\\<alpha> m (f x) = Some a \\<Longrightarrow>\n       ci_\\<alpha>' (idx_build_stepfun f x m) i =\n       index_map f (t.\\<alpha> t - (it - {x})) i", "}"], ["proof (state)\nthis:\n  Some {x} = index_map f (t.\\<alpha> t - (it - {x})) i\n\ngoal (2 subgoals):\n 1. m.\\<alpha> m (f x) = None \\<Longrightarrow>\n    ci_\\<alpha>' (idx_build_stepfun f x m) i =\n    index_map f (t.\\<alpha> t - (it - {x})) i\n 2. \\<And>a.\n       m.\\<alpha> m (f x) = Some a \\<Longrightarrow>\n       ci_\\<alpha>' (idx_build_stepfun f x m) i =\n       index_map f (t.\\<alpha> t - (it - {x})) i", "finally"], ["proof (chain)\npicking this:\n  ci_\\<alpha>' (idx_build_stepfun f x m) i =\n  index_map f (t.\\<alpha> t - (it - {x})) i", "show ?thesis"], ["proof (prove)\nusing this:\n  ci_\\<alpha>' (idx_build_stepfun f x m) i =\n  index_map f (t.\\<alpha> t - (it - {x})) i\n\ngoal (1 subgoal):\n 1. ci_\\<alpha>' (idx_build_stepfun f x m) i =\n    index_map f (t.\\<alpha> t - (it - {x})) i", "."], ["proof (state)\nthis:\n  ci_\\<alpha>' (idx_build_stepfun f x m) i =\n  index_map f (t.\\<alpha> t - (it - {x})) i\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       m.\\<alpha> m (f x) = Some a \\<Longrightarrow>\n       ci_\\<alpha>' (idx_build_stepfun f x m) i =\n       index_map f (t.\\<alpha> t - (it - {x})) i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       m.\\<alpha> m (f x) = Some a \\<Longrightarrow>\n       ci_\\<alpha>' (idx_build_stepfun f x m) i =\n       index_map f (t.\\<alpha> t - (it - {x})) i", "case [simp]: (Some ss)"], ["proof (state)\nthis:\n  m.\\<alpha> m (f x) = Some ss\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       m.\\<alpha> m (f x) = Some a \\<Longrightarrow>\n       ci_\\<alpha>' (idx_build_stepfun f x m) i =\n       index_map f (t.\\<alpha> t - (it - {x})) i", "hence [simp, intro!]: \"s.invar ss\""], ["proof (prove)\nusing this:\n  m.\\<alpha> m (f x) = Some ss\n\ngoal (1 subgoal):\n 1. s.invar ss", "by (simp del: Some)"], ["proof (state)\nthis:\n  s.invar ss\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       m.\\<alpha> m (f x) = Some a \\<Longrightarrow>\n       ci_\\<alpha>' (idx_build_stepfun f x m) i =\n       index_map f (t.\\<alpha> t - (it - {x})) i", "hence \"idx_build_stepfun f x m = m.update (f x) (s.ins x ss) m\""], ["proof (prove)\nusing this:\n  s.invar ss\n\ngoal (1 subgoal):\n 1. idx_build_stepfun f x m = m.update (f x) (s.ins x ss) m", "by (unfold idx_build_stepfun_def) \n               (simp add: m.update_correct m.lookup_correct)"], ["proof (state)\nthis:\n  idx_build_stepfun f x m = m.update (f x) (s.ins x ss) m\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       m.\\<alpha> m (f x) = Some a \\<Longrightarrow>\n       ci_\\<alpha>' (idx_build_stepfun f x m) i =\n       index_map f (t.\\<alpha> t - (it - {x})) i", "hence \"ci_\\<alpha>' (idx_build_stepfun f x m) i = Some (insert x (s.\\<alpha> ss))\""], ["proof (prove)\nusing this:\n  idx_build_stepfun f x m = m.update (f x) (s.ins x ss) m\n\ngoal (1 subgoal):\n 1. ci_\\<alpha>' (idx_build_stepfun f x m) i =\n    Some (insert x (s.\\<alpha> ss))", "by (simp add: m.update_correct s.ins_correct ci_\\<alpha>'_def)"], ["proof (state)\nthis:\n  ci_\\<alpha>' (idx_build_stepfun f x m) i = Some (insert x (s.\\<alpha> ss))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       m.\\<alpha> m (f x) = Some a \\<Longrightarrow>\n       ci_\\<alpha>' (idx_build_stepfun f x m) i =\n       index_map f (t.\\<alpha> t - (it - {x})) i", "also"], ["proof (state)\nthis:\n  ci_\\<alpha>' (idx_build_stepfun f x m) i = Some (insert x (s.\\<alpha> ss))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       m.\\<alpha> m (f x) = Some a \\<Longrightarrow>\n       ci_\\<alpha>' (idx_build_stepfun f x m) i =\n       index_map f (t.\\<alpha> t - (it - {x})) i", "{"], ["proof (state)\nthis:\n  ci_\\<alpha>' (idx_build_stepfun f x m) i = Some (insert x (s.\\<alpha> ss))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       m.\\<alpha> m (f x) = Some a \\<Longrightarrow>\n       ci_\\<alpha>' (idx_build_stepfun f x m) i =\n       index_map f (t.\\<alpha> t - (it - {x})) i", "have \"Some (s.\\<alpha> ss) = ci_\\<alpha>' m (f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Some (s.\\<alpha> ss) = ci_\\<alpha>' m (f x)", "by (simp add: ci_\\<alpha>'_def)"], ["proof (state)\nthis:\n  Some (s.\\<alpha> ss) = ci_\\<alpha>' m (f x)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       m.\\<alpha> m (f x) = Some a \\<Longrightarrow>\n       ci_\\<alpha>' (idx_build_stepfun f x m) i =\n       index_map f (t.\\<alpha> t - (it - {x})) i", "also"], ["proof (state)\nthis:\n  Some (s.\\<alpha> ss) = ci_\\<alpha>' m (f x)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       m.\\<alpha> m (f x) = Some a \\<Longrightarrow>\n       ci_\\<alpha>' (idx_build_stepfun f x m) i =\n       index_map f (t.\\<alpha> t - (it - {x})) i", "from prems(4)"], ["proof (chain)\npicking this:\n  ci_\\<alpha>' m = index_map f (t.\\<alpha> t - it) \\<and> ci_invar m", "have \"\\<dots> = index_map f (t.\\<alpha> t - it) i\""], ["proof (prove)\nusing this:\n  ci_\\<alpha>' m = index_map f (t.\\<alpha> t - it) \\<and> ci_invar m\n\ngoal (1 subgoal):\n 1. ci_\\<alpha>' m (f x) = index_map f (t.\\<alpha> t - it) i", "by simp"], ["proof (state)\nthis:\n  ci_\\<alpha>' m (f x) = index_map f (t.\\<alpha> t - it) i\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       m.\\<alpha> m (f x) = Some a \\<Longrightarrow>\n       ci_\\<alpha>' (idx_build_stepfun f x m) i =\n       index_map f (t.\\<alpha> t - (it - {x})) i", "finally"], ["proof (chain)\npicking this:\n  Some (s.\\<alpha> ss) = index_map f (t.\\<alpha> t - it) i", "have E: \"{xa \\<in> t.\\<alpha> t - it. f xa = i} = s.\\<alpha> ss\""], ["proof (prove)\nusing this:\n  Some (s.\\<alpha> ss) = index_map f (t.\\<alpha> t - it) i\n\ngoal (1 subgoal):\n 1. {xa \\<in> t.\\<alpha> t - it. f xa = i} = s.\\<alpha> ss", "by (simp add: index_map_def index_def split: if_split_asm)"], ["proof (state)\nthis:\n  {xa \\<in> t.\\<alpha> t - it. f xa = i} = s.\\<alpha> ss\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       m.\\<alpha> m (f x) = Some a \\<Longrightarrow>\n       ci_\\<alpha>' (idx_build_stepfun f x m) i =\n       index_map f (t.\\<alpha> t - (it - {x})) i", "moreover"], ["proof (state)\nthis:\n  {xa \\<in> t.\\<alpha> t - it. f xa = i} = s.\\<alpha> ss\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       m.\\<alpha> m (f x) = Some a \\<Longrightarrow>\n       ci_\\<alpha>' (idx_build_stepfun f x m) i =\n       index_map f (t.\\<alpha> t - (it - {x})) i", "have \n              \"{xa \\<in> t.\\<alpha> t - (it - {x}). f xa = i} \n               = {xa \\<in> t.\\<alpha> t - it. f xa = i} \\<union> {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {xa \\<in> t.\\<alpha> t - (it - {x}). f xa = i} =\n    {xa \\<in> t.\\<alpha> t - it. f xa = i} \\<union> {x}", "using prems(2,3)"], ["proof (prove)\nusing this:\n  x \\<in> it\n  it \\<subseteq> t.\\<alpha> t\n\ngoal (1 subgoal):\n 1. {xa \\<in> t.\\<alpha> t - (it - {x}). f xa = i} =\n    {xa \\<in> t.\\<alpha> t - it. f xa = i} \\<union> {x}", "by auto"], ["proof (state)\nthis:\n  {xa \\<in> t.\\<alpha> t - (it - {x}). f xa = i} =\n  {xa \\<in> t.\\<alpha> t - it. f xa = i} \\<union> {x}\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       m.\\<alpha> m (f x) = Some a \\<Longrightarrow>\n       ci_\\<alpha>' (idx_build_stepfun f x m) i =\n       index_map f (t.\\<alpha> t - (it - {x})) i", "ultimately"], ["proof (chain)\npicking this:\n  {xa \\<in> t.\\<alpha> t - it. f xa = i} = s.\\<alpha> ss\n  {xa \\<in> t.\\<alpha> t - (it - {x}). f xa = i} =\n  {xa \\<in> t.\\<alpha> t - it. f xa = i} \\<union> {x}", "have \n              \"Some (insert x (s.\\<alpha> ss)) = index_map f (t.\\<alpha> t - (it - {x})) i\""], ["proof (prove)\nusing this:\n  {xa \\<in> t.\\<alpha> t - it. f xa = i} = s.\\<alpha> ss\n  {xa \\<in> t.\\<alpha> t - (it - {x}). f xa = i} =\n  {xa \\<in> t.\\<alpha> t - it. f xa = i} \\<union> {x}\n\ngoal (1 subgoal):\n 1. Some (insert x (s.\\<alpha> ss)) =\n    index_map f (t.\\<alpha> t - (it - {x})) i", "by (unfold index_map_def index_def) auto"], ["proof (state)\nthis:\n  Some (insert x (s.\\<alpha> ss)) =\n  index_map f (t.\\<alpha> t - (it - {x})) i\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       m.\\<alpha> m (f x) = Some a \\<Longrightarrow>\n       ci_\\<alpha>' (idx_build_stepfun f x m) i =\n       index_map f (t.\\<alpha> t - (it - {x})) i", "}"], ["proof (state)\nthis:\n  Some (insert x (s.\\<alpha> ss)) =\n  index_map f (t.\\<alpha> t - (it - {x})) i\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       m.\\<alpha> m (f x) = Some a \\<Longrightarrow>\n       ci_\\<alpha>' (idx_build_stepfun f x m) i =\n       index_map f (t.\\<alpha> t - (it - {x})) i", "finally"], ["proof (chain)\npicking this:\n  ci_\\<alpha>' (idx_build_stepfun f x m) i =\n  index_map f (t.\\<alpha> t - (it - {x})) i", "show ?thesis"], ["proof (prove)\nusing this:\n  ci_\\<alpha>' (idx_build_stepfun f x m) i =\n  index_map f (t.\\<alpha> t - (it - {x})) i\n\ngoal (1 subgoal):\n 1. ci_\\<alpha>' (idx_build_stepfun f x m) i =\n    index_map f (t.\\<alpha> t - (it - {x})) i", "."], ["proof (state)\nthis:\n  ci_\\<alpha>' (idx_build_stepfun f x m) i =\n  index_map f (t.\\<alpha> t - (it - {x})) i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ci_\\<alpha>' (idx_build_stepfun f x m) i =\n  index_map f (t.\\<alpha> t - (it - {x})) i\n\ngoal (1 subgoal):\n 1. i \\<noteq> f x \\<Longrightarrow>\n    ci_\\<alpha>' (idx_build_stepfun f x m) i =\n    index_map f (t.\\<alpha> t - (it - {x})) i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> f x \\<Longrightarrow>\n    ci_\\<alpha>' (idx_build_stepfun f x m) i =\n    index_map f (t.\\<alpha> t - (it - {x})) i", "case False"], ["proof (state)\nthis:\n  i \\<noteq> f x\n\ngoal (1 subgoal):\n 1. i \\<noteq> f x \\<Longrightarrow>\n    ci_\\<alpha>' (idx_build_stepfun f x m) i =\n    index_map f (t.\\<alpha> t - (it - {x})) i", "hence C: \"i\\<noteq>f x\" \"f x\\<noteq>i\""], ["proof (prove)\nusing this:\n  i \\<noteq> f x\n\ngoal (1 subgoal):\n 1. i \\<noteq> f x &&& f x \\<noteq> i", "by simp_all"], ["proof (state)\nthis:\n  i \\<noteq> f x\n  f x \\<noteq> i\n\ngoal (1 subgoal):\n 1. i \\<noteq> f x \\<Longrightarrow>\n    ci_\\<alpha>' (idx_build_stepfun f x m) i =\n    index_map f (t.\\<alpha> t - (it - {x})) i", "have \"ci_\\<alpha>' (idx_build_stepfun f x m) i = ci_\\<alpha>' m i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ci_\\<alpha>' (idx_build_stepfun f x m) i = ci_\\<alpha>' m i", "apply (unfold ci_\\<alpha>'_def idx_build_stepfun_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case m.\\<alpha>\n           (let i = f x\n            in case m.lookup i m of\n               None \\<Rightarrow> m.update i (s.ins x (s.empty ())) m\n               | Some s \\<Rightarrow> m.update i (s.ins x s) m)\n           i of\n     None \\<Rightarrow> None | Some s \\<Rightarrow> Some (s.\\<alpha> s)) =\n    (case m.\\<alpha> m i of None \\<Rightarrow> None\n     | Some s \\<Rightarrow> Some (s.\\<alpha> s))", "apply (simp \n            split: option.split_asm option.split \n            add: Let_def m.lookup_correct m.update_correct \n                 s.ins_correct s.empty_correct C)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ci_\\<alpha>' (idx_build_stepfun f x m) i = ci_\\<alpha>' m i\n\ngoal (1 subgoal):\n 1. i \\<noteq> f x \\<Longrightarrow>\n    ci_\\<alpha>' (idx_build_stepfun f x m) i =\n    index_map f (t.\\<alpha> t - (it - {x})) i", "also"], ["proof (state)\nthis:\n  ci_\\<alpha>' (idx_build_stepfun f x m) i = ci_\\<alpha>' m i\n\ngoal (1 subgoal):\n 1. i \\<noteq> f x \\<Longrightarrow>\n    ci_\\<alpha>' (idx_build_stepfun f x m) i =\n    index_map f (t.\\<alpha> t - (it - {x})) i", "from prems(4)"], ["proof (chain)\npicking this:\n  ci_\\<alpha>' m = index_map f (t.\\<alpha> t - it) \\<and> ci_invar m", "have \"ci_\\<alpha>' m i = index_map f (t.\\<alpha> t - it) i\""], ["proof (prove)\nusing this:\n  ci_\\<alpha>' m = index_map f (t.\\<alpha> t - it) \\<and> ci_invar m\n\ngoal (1 subgoal):\n 1. ci_\\<alpha>' m i = index_map f (t.\\<alpha> t - it) i", "by simp"], ["proof (state)\nthis:\n  ci_\\<alpha>' m i = index_map f (t.\\<alpha> t - it) i\n\ngoal (1 subgoal):\n 1. i \\<noteq> f x \\<Longrightarrow>\n    ci_\\<alpha>' (idx_build_stepfun f x m) i =\n    index_map f (t.\\<alpha> t - (it - {x})) i", "also"], ["proof (state)\nthis:\n  ci_\\<alpha>' m i = index_map f (t.\\<alpha> t - it) i\n\ngoal (1 subgoal):\n 1. i \\<noteq> f x \\<Longrightarrow>\n    ci_\\<alpha>' (idx_build_stepfun f x m) i =\n    index_map f (t.\\<alpha> t - (it - {x})) i", "have \n          \"{xa \\<in> t.\\<alpha> t - (it - {x}). f xa = i} = {xa \\<in> t.\\<alpha> t - it. f xa = i}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {xa \\<in> t.\\<alpha> t - (it - {x}). f xa = i} =\n    {xa \\<in> t.\\<alpha> t - it. f xa = i}", "using prems(2,3) C"], ["proof (prove)\nusing this:\n  x \\<in> it\n  it \\<subseteq> t.\\<alpha> t\n  i \\<noteq> f x\n  f x \\<noteq> i\n\ngoal (1 subgoal):\n 1. {xa \\<in> t.\\<alpha> t - (it - {x}). f xa = i} =\n    {xa \\<in> t.\\<alpha> t - it. f xa = i}", "by auto"], ["proof (state)\nthis:\n  {xa \\<in> t.\\<alpha> t - (it - {x}). f xa = i} =\n  {xa \\<in> t.\\<alpha> t - it. f xa = i}\n\ngoal (1 subgoal):\n 1. i \\<noteq> f x \\<Longrightarrow>\n    ci_\\<alpha>' (idx_build_stepfun f x m) i =\n    index_map f (t.\\<alpha> t - (it - {x})) i", "hence \"index_map f (t.\\<alpha> t - it) i = index_map f (t.\\<alpha> t - (it-{x})) i\""], ["proof (prove)\nusing this:\n  {xa \\<in> t.\\<alpha> t - (it - {x}). f xa = i} =\n  {xa \\<in> t.\\<alpha> t - it. f xa = i}\n\ngoal (1 subgoal):\n 1. index_map f (t.\\<alpha> t - it) i =\n    index_map f (t.\\<alpha> t - (it - {x})) i", "by (unfold index_map_def index_def) simp"], ["proof (state)\nthis:\n  index_map f (t.\\<alpha> t - it) i =\n  index_map f (t.\\<alpha> t - (it - {x})) i\n\ngoal (1 subgoal):\n 1. i \\<noteq> f x \\<Longrightarrow>\n    ci_\\<alpha>' (idx_build_stepfun f x m) i =\n    index_map f (t.\\<alpha> t - (it - {x})) i", "finally"], ["proof (chain)\npicking this:\n  ci_\\<alpha>' (idx_build_stepfun f x m) i =\n  index_map f (t.\\<alpha> t - (it - {x})) i", "show ?thesis"], ["proof (prove)\nusing this:\n  ci_\\<alpha>' (idx_build_stepfun f x m) i =\n  index_map f (t.\\<alpha> t - (it - {x})) i\n\ngoal (1 subgoal):\n 1. ci_\\<alpha>' (idx_build_stepfun f x m) i =\n    index_map f (t.\\<alpha> t - (it - {x})) i", "."], ["proof (state)\nthis:\n  ci_\\<alpha>' (idx_build_stepfun f x m) i =\n  index_map f (t.\\<alpha> t - (it - {x})) i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ci_\\<alpha>' (idx_build_stepfun f x m) i =\n  index_map f (t.\\<alpha> t - (it - {x})) i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  t.invar t \\<Longrightarrow>\n  ci_\\<alpha>' (idx_build f t) = index_map f (t.\\<alpha> t) \\<and>\n  ci_invar (idx_build f t)\n\ngoal (2 subgoals):\n 1. ci_\\<alpha>' (idx_build f t) = index_map f (t.\\<alpha> t)\n 2. ci_invar (idx_build f t)", "with I"], ["proof (chain)\npicking this:\n  t.invar t\n  t.invar t \\<Longrightarrow>\n  ci_\\<alpha>' (idx_build f t) = index_map f (t.\\<alpha> t) \\<and>\n  ci_invar (idx_build f t)", "show ?T1 ?T2"], ["proof (prove)\nusing this:\n  t.invar t\n  t.invar t \\<Longrightarrow>\n  ci_\\<alpha>' (idx_build f t) = index_map f (t.\\<alpha> t) \\<and>\n  ci_invar (idx_build f t)\n\ngoal (1 subgoal):\n 1. ci_\\<alpha>' (idx_build f t) = index_map f (t.\\<alpha> t) &&&\n    ci_invar (idx_build f t)", "by auto"], ["proof (state)\nthis:\n  ci_\\<alpha>' (idx_build f t) = index_map f (t.\\<alpha> t)\n  ci_invar (idx_build f t)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma idx_build_is_index: \n    \"t.invar t \\<Longrightarrow> is_index f (t.\\<alpha> t) (idx_build f t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t.invar t \\<Longrightarrow> is_index f (t.\\<alpha> t) (idx_build f t)", "by (simp add: idx_build_correct index_map_correct ci_\\<alpha>_def is_index_def)"], ["", "end"], ["", "end"]]}