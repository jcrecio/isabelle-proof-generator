{"file_name": "/home/qj213/afp-2021-10-22/thys/Collections/ICF/impl/HashMap.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Collections", "problem_names": ["lemma impl_of_RBT_HM_invar [simp, intro!]: \"HashMap_Impl.invar (impl_of_RBT_HM hm)\"", "lemma RBT_HM_imp_of_RBT_HM [code abstype]:\n  \"RBT_HM (impl_of_RBT_HM hm) = hm\"", "lemma impl_of_hm_empty [simp, code abstract]:\n  \"impl_of_RBT_HM (hm_empty_const) = HashMap_Impl.empty ()\"", "lemma impl_of_hm_update [simp, code abstract]:\n  \"impl_of_RBT_HM (hm_update k v hm) = HashMap_Impl.update k v (impl_of_RBT_HM hm)\"", "lemma impl_of_hm_delete [simp, code abstract]:\n  \"impl_of_RBT_HM (hm_delete k hm) = HashMap_Impl.delete k (impl_of_RBT_HM hm)\"", "lemma hm_aux_correct:\n  \"hm_\\<alpha> (hm_empty ()) = Map.empty \"\n  \"hm_lookup k m = hm_\\<alpha> m k\"\n  \"hm_\\<alpha> (hm_update k v m) = (hm_\\<alpha> m)(k\\<mapsto>v)\"\n  \"hm_\\<alpha> (hm_delete k m) = (hm_\\<alpha> m) |` (-{k})\"", "lemma hm_finite[simp, intro!]:\n  \"finite (dom (hm_\\<alpha> m))\"", "lemma hm_iteratei_impl: \n  \"map_iterator (hm_iteratei m) (hm_\\<alpha> m)\"", "lemma pi_hm[proper_it]:\n  shows \"proper_it' hm_iteratei hm_iteratei\""], "translations": [["", "lemma impl_of_RBT_HM_invar [simp, intro!]: \"HashMap_Impl.invar (impl_of_RBT_HM hm)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HashMap_Impl.invar (impl_of_RBT_HM hm)", "using impl_of_RBT_HM[of hm]"], ["proof (prove)\nusing this:\n  impl_of_RBT_HM hm \\<in> {hm. HashMap_Impl.invar hm}\n\ngoal (1 subgoal):\n 1. HashMap_Impl.invar (impl_of_RBT_HM hm)", "by simp"], ["", "lemma RBT_HM_imp_of_RBT_HM [code abstype]:\n  \"RBT_HM (impl_of_RBT_HM hm) = hm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RBT_HM (impl_of_RBT_HM hm) = hm", "by(fact impl_of_RBT_HM_inverse)"], ["", "definition hm_empty_const :: \"('k :: hashable, 'v) hashmap\"\nwhere \"hm_empty_const = RBT_HM (HashMap_Impl.empty ())\""], ["", "definition hm_empty :: \"unit \\<Rightarrow> ('k :: hashable, 'v) hashmap\"\nwhere \"hm_empty = (\\<lambda>_. hm_empty_const)\""], ["", "definition \"hm_lookup k hm == HashMap_Impl.lookup k (impl_of_RBT_HM hm)\""], ["", "definition hm_update :: \"('k :: hashable) \\<Rightarrow> 'v \\<Rightarrow> ('k, 'v) hashmap \\<Rightarrow> ('k, 'v) hashmap\"\nwhere \"hm_update k v hm = RBT_HM (HashMap_Impl.update k v (impl_of_RBT_HM hm))\""], ["", "definition hm_update_dj :: \"('k :: hashable) \\<Rightarrow> 'v \\<Rightarrow> ('k, 'v) hashmap \\<Rightarrow> ('k, 'v) hashmap\"\nwhere \"hm_update_dj = hm_update\""], ["", "definition hm_delete :: \"('k :: hashable) \\<Rightarrow> ('k, 'v) hashmap \\<Rightarrow> ('k, 'v) hashmap\"\nwhere \"hm_delete k hm = RBT_HM (HashMap_Impl.delete k (impl_of_RBT_HM hm))\""], ["", "definition hm_isEmpty :: \"('k :: hashable, 'v) hashmap \\<Rightarrow> bool\"\nwhere \"hm_isEmpty hm = HashMap_Impl.isEmpty (impl_of_RBT_HM hm)\""], ["", "(*definition hm_sel :: \"('k :: hashable, 'v) hashmap \\<Rightarrow> ('k \\<times> 'v \\<rightharpoonup> 'a) \\<rightharpoonup> 'a\"\n  where \"hm_sel hm = HashMap_Impl.sel (impl_of_RBT_HM hm)\"*)\n\n(*definition \"hm_sel' = MapGA.sel_sel' hm_sel\"*)"], ["", "definition \"hm_iteratei hm == HashMap_Impl.iteratei (impl_of_RBT_HM hm)\""], ["", "lemma impl_of_hm_empty [simp, code abstract]:\n  \"impl_of_RBT_HM (hm_empty_const) = HashMap_Impl.empty ()\""], ["proof (prove)\ngoal (1 subgoal):\n 1. impl_of_RBT_HM hm_empty_const = HashMap_Impl.empty ()", "by(simp add: hm_empty_const_def empty_correct' RBT_HM_inverse)"], ["", "lemma impl_of_hm_update [simp, code abstract]:\n  \"impl_of_RBT_HM (hm_update k v hm) = HashMap_Impl.update k v (impl_of_RBT_HM hm)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. impl_of_RBT_HM (hm_update k v hm) =\n    HashMap_Impl.update k v (impl_of_RBT_HM hm)", "by(simp add: hm_update_def update_correct' RBT_HM_inverse)"], ["", "lemma impl_of_hm_delete [simp, code abstract]:\n  \"impl_of_RBT_HM (hm_delete k hm) = HashMap_Impl.delete k (impl_of_RBT_HM hm)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. impl_of_RBT_HM (hm_delete k hm) =\n    HashMap_Impl.delete k (impl_of_RBT_HM hm)", "by(simp add: hm_delete_def delete_correct' RBT_HM_inverse)"], ["", "subsection \"Correctness w.r.t. Map\""], ["", "text \\<open>\n  The next lemmas establish the correctness of the hashmap operations w.r.t. the \n  associated map. This is achieved by chaining the correctness lemmas of the \n  concrete hashmap w.r.t. the abstract hashmap and the correctness lemmas of the\n  abstract hashmap w.r.t. maps.\n\\<close>"], ["", "type_synonym ('k, 'v) hm = \"('k, 'v) hashmap\"\n\n  \\<comment> \\<open>Abstract concrete hashmap to map\\<close>"], ["", "definition \"hm_\\<alpha> == ahm_\\<alpha> \\<circ> hm_\\<alpha>' \\<circ> impl_of_RBT_HM\""], ["", "abbreviation (input) hm_invar :: \"('k :: hashable, 'v) hashmap \\<Rightarrow> bool\"\nwhere \"hm_invar == \\<lambda>_. True\""], ["", "lemma hm_aux_correct:\n  \"hm_\\<alpha> (hm_empty ()) = Map.empty \"\n  \"hm_lookup k m = hm_\\<alpha> m k\"\n  \"hm_\\<alpha> (hm_update k v m) = (hm_\\<alpha> m)(k\\<mapsto>v)\"\n  \"hm_\\<alpha> (hm_delete k m) = (hm_\\<alpha> m) |` (-{k})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (hm_\\<alpha> (hm_empty ()) = Map.empty &&&\n     hm_lookup k m = hm_\\<alpha> m k) &&&\n    hm_\\<alpha> (hm_update k v m) = hm_\\<alpha> m(k \\<mapsto> v) &&&\n    hm_\\<alpha> (hm_delete k m) = hm_\\<alpha> m |` (- {k})", "by(auto simp add: hm_\\<alpha>_def hm_correct' hm_empty_def ahm_correct hm_lookup_def)"], ["", "lemma hm_finite[simp, intro!]:\n  \"finite (dom (hm_\\<alpha> m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (dom (hm_\\<alpha> m))", "proof(cases m)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>m = RBT_HM y; y \\<in> {hm. HashMap_Impl.invar hm}\\<rbrakk>\n       \\<Longrightarrow> finite (dom (hm_\\<alpha> m))", "case (RBT_HM m')"], ["proof (state)\nthis:\n  m = RBT_HM m'\n  m' \\<in> {hm. HashMap_Impl.invar hm}\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>m = RBT_HM y; y \\<in> {hm. HashMap_Impl.invar hm}\\<rbrakk>\n       \\<Longrightarrow> finite (dom (hm_\\<alpha> m))", "hence SS: \"dom (hm_\\<alpha> m) \\<subseteq> \\<Union>{ dom (lm.\\<alpha> lm) | lm hc. rm.\\<alpha> m' hc = Some lm }\""], ["proof (prove)\nusing this:\n  m = RBT_HM m'\n  m' \\<in> {hm. HashMap_Impl.invar hm}\n\ngoal (1 subgoal):\n 1. dom (hm_\\<alpha> m)\n    \\<subseteq> \\<Union>\n                 {uu_.\n                  \\<exists>lm hc.\n                     uu_ = dom (lm.\\<alpha> lm) \\<and>\n                     rm.\\<alpha> m' hc = Some lm}", "apply(clarsimp simp add: RBT_HM_inverse hm_\\<alpha>_def hm_\\<alpha>'_def [abs_def] ahm_\\<alpha>_def [abs_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>m = RBT_HM m'; HashMap_Impl.invar m';\n        (case case rm.\\<alpha> m' (hashcode x) of None \\<Rightarrow> None\n              | Some lm \\<Rightarrow> Some (lm.\\<alpha> lm) of\n         None \\<Rightarrow> None | Some cm \\<Rightarrow> cm x) =\n        Some y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa.\n                            (\\<exists>lm.\n                                xa = dom (lm.\\<alpha> lm) \\<and>\n                                (\\<exists>hc.\n                                    rm.\\<alpha> m' hc = Some lm)) \\<and>\n                            x \\<in> xa", "apply(auto split: option.split_asm option.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  dom (hm_\\<alpha> m)\n  \\<subseteq> \\<Union>\n               {uu_.\n                \\<exists>lm hc.\n                   uu_ = dom (lm.\\<alpha> lm) \\<and>\n                   rm.\\<alpha> m' hc = Some lm}\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>m = RBT_HM y; y \\<in> {hm. HashMap_Impl.invar hm}\\<rbrakk>\n       \\<Longrightarrow> finite (dom (hm_\\<alpha> m))", "moreover"], ["proof (state)\nthis:\n  dom (hm_\\<alpha> m)\n  \\<subseteq> \\<Union>\n               {uu_.\n                \\<exists>lm hc.\n                   uu_ = dom (lm.\\<alpha> lm) \\<and>\n                   rm.\\<alpha> m' hc = Some lm}\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>m = RBT_HM y; y \\<in> {hm. HashMap_Impl.invar hm}\\<rbrakk>\n       \\<Longrightarrow> finite (dom (hm_\\<alpha> m))", "have \"finite \\<dots>\" (is \"finite (\\<Union>?A)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (\\<Union>\n       {uu_.\n        \\<exists>lm hc.\n           uu_ = dom (lm.\\<alpha> lm) \\<and> rm.\\<alpha> m' hc = Some lm})", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. finite\n     {uu_.\n      \\<exists>lm hc.\n         uu_ = dom (lm.\\<alpha> lm) \\<and> rm.\\<alpha> m' hc = Some lm}\n 2. \\<And>M.\n       M \\<in> {uu_.\n                \\<exists>lm hc.\n                   uu_ = dom (lm.\\<alpha> lm) \\<and>\n                   rm.\\<alpha> m' hc = Some lm} \\<Longrightarrow>\n       finite M", "have \"{ dom (lm.\\<alpha> lm) | lm hc. rm.\\<alpha> m' hc = Some lm } \n          \\<subseteq> (\\<lambda>hc. dom (lm.\\<alpha> (the (rm.\\<alpha> m' hc)) )) ` (dom (rm.\\<alpha> m'))\" \n      (is \"?S \\<subseteq> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. {uu_.\n     \\<exists>lm hc.\n        uu_ = dom (lm.\\<alpha> lm) \\<and> rm.\\<alpha> m' hc = Some lm}\n    \\<subseteq> (\\<lambda>hc. dom (lm.\\<alpha> (the (rm.\\<alpha> m' hc)))) `\n                dom (rm.\\<alpha> m')", "by force"], ["proof (state)\nthis:\n  {uu_.\n   \\<exists>lm hc.\n      uu_ = dom (lm.\\<alpha> lm) \\<and> rm.\\<alpha> m' hc = Some lm}\n  \\<subseteq> (\\<lambda>hc. dom (lm.\\<alpha> (the (rm.\\<alpha> m' hc)))) `\n              dom (rm.\\<alpha> m')\n\ngoal (2 subgoals):\n 1. finite\n     {uu_.\n      \\<exists>lm hc.\n         uu_ = dom (lm.\\<alpha> lm) \\<and> rm.\\<alpha> m' hc = Some lm}\n 2. \\<And>M.\n       M \\<in> {uu_.\n                \\<exists>lm hc.\n                   uu_ = dom (lm.\\<alpha> lm) \\<and>\n                   rm.\\<alpha> m' hc = Some lm} \\<Longrightarrow>\n       finite M", "thus \"finite ?A\""], ["proof (prove)\nusing this:\n  {uu_.\n   \\<exists>lm hc.\n      uu_ = dom (lm.\\<alpha> lm) \\<and> rm.\\<alpha> m' hc = Some lm}\n  \\<subseteq> (\\<lambda>hc. dom (lm.\\<alpha> (the (rm.\\<alpha> m' hc)))) `\n              dom (rm.\\<alpha> m')\n\ngoal (1 subgoal):\n 1. finite\n     {uu_.\n      \\<exists>lm hc.\n         uu_ = dom (lm.\\<alpha> lm) \\<and> rm.\\<alpha> m' hc = Some lm}", "by(rule finite_subset) auto"], ["proof (state)\nthis:\n  finite\n   {uu_.\n    \\<exists>lm hc.\n       uu_ = dom (lm.\\<alpha> lm) \\<and> rm.\\<alpha> m' hc = Some lm}\n\ngoal (1 subgoal):\n 1. \\<And>M.\n       M \\<in> {uu_.\n                \\<exists>lm hc.\n                   uu_ = dom (lm.\\<alpha> lm) \\<and>\n                   rm.\\<alpha> m' hc = Some lm} \\<Longrightarrow>\n       finite M", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>M.\n       M \\<in> {uu_.\n                \\<exists>lm hc.\n                   uu_ = dom (lm.\\<alpha> lm) \\<and>\n                   rm.\\<alpha> m' hc = Some lm} \\<Longrightarrow>\n       finite M", "fix M"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>M.\n       M \\<in> {uu_.\n                \\<exists>lm hc.\n                   uu_ = dom (lm.\\<alpha> lm) \\<and>\n                   rm.\\<alpha> m' hc = Some lm} \\<Longrightarrow>\n       finite M", "assume \"M \\<in> ?A\""], ["proof (state)\nthis:\n  M \\<in> {uu_.\n           \\<exists>lm hc.\n              uu_ = dom (lm.\\<alpha> lm) \\<and> rm.\\<alpha> m' hc = Some lm}\n\ngoal (1 subgoal):\n 1. \\<And>M.\n       M \\<in> {uu_.\n                \\<exists>lm hc.\n                   uu_ = dom (lm.\\<alpha> lm) \\<and>\n                   rm.\\<alpha> m' hc = Some lm} \\<Longrightarrow>\n       finite M", "thus \"finite M\""], ["proof (prove)\nusing this:\n  M \\<in> {uu_.\n           \\<exists>lm hc.\n              uu_ = dom (lm.\\<alpha> lm) \\<and> rm.\\<alpha> m' hc = Some lm}\n\ngoal (1 subgoal):\n 1. finite M", "by auto"], ["proof (state)\nthis:\n  finite M\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite\n   (\\<Union>\n     {uu_.\n      \\<exists>lm hc.\n         uu_ = dom (lm.\\<alpha> lm) \\<and> rm.\\<alpha> m' hc = Some lm})\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>m = RBT_HM y; y \\<in> {hm. HashMap_Impl.invar hm}\\<rbrakk>\n       \\<Longrightarrow> finite (dom (hm_\\<alpha> m))", "ultimately"], ["proof (chain)\npicking this:\n  dom (hm_\\<alpha> m)\n  \\<subseteq> \\<Union>\n               {uu_.\n                \\<exists>lm hc.\n                   uu_ = dom (lm.\\<alpha> lm) \\<and>\n                   rm.\\<alpha> m' hc = Some lm}\n  finite\n   (\\<Union>\n     {uu_.\n      \\<exists>lm hc.\n         uu_ = dom (lm.\\<alpha> lm) \\<and> rm.\\<alpha> m' hc = Some lm})", "show ?thesis"], ["proof (prove)\nusing this:\n  dom (hm_\\<alpha> m)\n  \\<subseteq> \\<Union>\n               {uu_.\n                \\<exists>lm hc.\n                   uu_ = dom (lm.\\<alpha> lm) \\<and>\n                   rm.\\<alpha> m' hc = Some lm}\n  finite\n   (\\<Union>\n     {uu_.\n      \\<exists>lm hc.\n         uu_ = dom (lm.\\<alpha> lm) \\<and> rm.\\<alpha> m' hc = Some lm})\n\ngoal (1 subgoal):\n 1. finite (dom (hm_\\<alpha> m))", "unfolding RBT_HM"], ["proof (prove)\nusing this:\n  dom (hm_\\<alpha> (RBT_HM m'))\n  \\<subseteq> \\<Union>\n               {uu_.\n                \\<exists>lm hc.\n                   uu_ = dom (lm.\\<alpha> lm) \\<and>\n                   rm.\\<alpha> m' hc = Some lm}\n  finite\n   (\\<Union>\n     {uu_.\n      \\<exists>lm hc.\n         uu_ = dom (lm.\\<alpha> lm) \\<and> rm.\\<alpha> m' hc = Some lm})\n\ngoal (1 subgoal):\n 1. finite (dom (hm_\\<alpha> (RBT_HM m')))", "by(rule finite_subset)"], ["proof (state)\nthis:\n  finite (dom (hm_\\<alpha> m))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hm_iteratei_impl: \n  \"map_iterator (hm_iteratei m) (hm_\\<alpha> m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_iterator (hm_iteratei m) (hm_\\<alpha> m)", "apply (unfold hm_\\<alpha>_def hm_iteratei_def o_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_iterator (HashMap_Impl.iteratei (impl_of_RBT_HM m))\n     (ahm_\\<alpha> (hm_\\<alpha>' (impl_of_RBT_HM m)))", "apply(rule iteratei_correct'[OF impl_of_RBT_HM_invar])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \"Integration in Isabelle Collections Framework\""], ["", "text \\<open>\n  In this section, we integrate hashmaps into the Isabelle Collections Framework.\n\\<close>"], ["", "definition [icf_rec_def]: \"hm_basic_ops \\<equiv> \\<lparr>\n  bmap_op_\\<alpha> = hm_\\<alpha>,\n  bmap_op_invar = \\<lambda>_. True,\n  bmap_op_empty = hm_empty,\n  bmap_op_lookup = hm_lookup,\n  bmap_op_update = hm_update,\n  bmap_op_update_dj = hm_update, \\<comment> \\<open>TODO: Optimize bucket-ins here\\<close>\n  bmap_op_delete = hm_delete,\n  bmap_op_list_it = hm_iteratei\n\\<rparr>\""], ["", "setup Locale_Code.open_block"], ["", "interpretation hm_basic: StdBasicMap hm_basic_ops"], ["proof (prove)\ngoal (1 subgoal):\n 1. StdBasicMap hm_basic_ops", "apply unfold_locales"], ["proof (prove)\ngoal (11 subgoals):\n 1. bmap_op_\\<alpha> hm_basic_ops (bmap_op_empty hm_basic_ops ()) =\n    Map.empty\n 2. bmap_op_invar hm_basic_ops (bmap_op_empty hm_basic_ops ())\n 3. \\<And>m k.\n       bmap_op_invar hm_basic_ops m \\<Longrightarrow>\n       bmap_op_lookup hm_basic_ops k m = bmap_op_\\<alpha> hm_basic_ops m k\n 4. \\<And>m k v.\n       bmap_op_invar hm_basic_ops m \\<Longrightarrow>\n       bmap_op_\\<alpha> hm_basic_ops (bmap_op_update hm_basic_ops k v m) =\n       bmap_op_\\<alpha> hm_basic_ops m(k \\<mapsto> v)\n 5. \\<And>m k v.\n       bmap_op_invar hm_basic_ops m \\<Longrightarrow>\n       bmap_op_invar hm_basic_ops (bmap_op_update hm_basic_ops k v m)\n 6. \\<And>m k v.\n       \\<lbrakk>bmap_op_invar hm_basic_ops m;\n        k \\<notin> dom (bmap_op_\\<alpha> hm_basic_ops m)\\<rbrakk>\n       \\<Longrightarrow> bmap_op_\\<alpha> hm_basic_ops\n                          (bmap_op_update_dj hm_basic_ops k v m) =\n                         bmap_op_\\<alpha> hm_basic_ops m(k \\<mapsto> v)\n 7. \\<And>m k v.\n       \\<lbrakk>bmap_op_invar hm_basic_ops m;\n        k \\<notin> dom (bmap_op_\\<alpha> hm_basic_ops m)\\<rbrakk>\n       \\<Longrightarrow> bmap_op_invar hm_basic_ops\n                          (bmap_op_update_dj hm_basic_ops k v m)\n 8. \\<And>m k.\n       bmap_op_invar hm_basic_ops m \\<Longrightarrow>\n       bmap_op_\\<alpha> hm_basic_ops (bmap_op_delete hm_basic_ops k m) =\n       bmap_op_\\<alpha> hm_basic_ops m |` (- {k})\n 9. \\<And>m k.\n       bmap_op_invar hm_basic_ops m \\<Longrightarrow>\n       bmap_op_invar hm_basic_ops (bmap_op_delete hm_basic_ops k m)\n 10. \\<And>m.\n        bmap_op_invar hm_basic_ops m \\<Longrightarrow>\n        finite (dom (bmap_op_\\<alpha> hm_basic_ops m))\nA total of 11 subgoals...", "apply (simp_all add: icf_rec_unf hm_aux_correct hm_iteratei_impl)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "setup Locale_Code.close_block"], ["", "definition [icf_rec_def]: \"hm_ops \\<equiv> hm_basic.dflt_ops\""], ["", "setup Locale_Code.open_block"], ["", "interpretation hm: StdMapDefs hm_ops"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "interpretation hm: StdMap hm_ops"], ["proof (prove)\ngoal (1 subgoal):\n 1. StdMap hm_ops", "unfolding hm_ops_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. StdMap hm_basic.dflt_ops", "by (rule hm_basic.dflt_ops_impl)"], ["", "interpretation hm: StdMap_no_invar hm_ops"], ["proof (prove)\ngoal (1 subgoal):\n 1. StdMap_no_invar hm_ops", "by unfold_locales (simp add: icf_rec_unf)"], ["", "setup Locale_Code.close_block"], ["", "setup \\<open>ICF_Tools.revert_abbrevs \"hm\"\\<close>"], ["", "lemma pi_hm[proper_it]:\n  shows \"proper_it' hm_iteratei hm_iteratei\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it' hm_iteratei hm_iteratei", "apply (rule proper_it'I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s. proper_it (hm_iteratei s) (hm_iteratei s)", "unfolding hm_iteratei_def HashMap_Impl.iteratei_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       proper_it\n        (set_iterator_image snd\n          (set_iterator_product (rm.iteratei (impl_of_RBT_HM s))\n            (\\<lambda>hclm. lm.iteratei (snd hclm))))\n        (set_iterator_image snd\n          (set_iterator_product (rm.iteratei (impl_of_RBT_HM s))\n            (\\<lambda>hclm. lm.iteratei (snd hclm))))", "by (intro icf_proper_iteratorI)"], ["", "interpretation pi_hm: proper_it_loc hm_iteratei hm_iteratei"], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it_loc hm_iteratei hm_iteratei", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it' hm_iteratei hm_iteratei", "apply (rule pi_hm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Code generator test\\<close>"], ["", "definition test_codegen where \"test_codegen \\<equiv> (\n  hm.add ,\n  hm.add_dj ,\n  hm.ball ,\n  hm.bex ,\n  hm.delete ,\n  hm.empty ,\n  hm.isEmpty ,\n  hm.isSng ,\n  hm.iterate ,\n  hm.iteratei ,\n  hm.list_it ,\n  hm.lookup ,\n  hm.restrict ,\n  hm.sel ,\n  hm.size ,\n  hm.size_abort ,\n  hm.sng ,\n  hm.to_list ,\n  hm.to_map ,\n  hm.update ,\n  hm.update_dj)\""], ["", "export_code test_codegen checking SML"], ["", "end"]]}