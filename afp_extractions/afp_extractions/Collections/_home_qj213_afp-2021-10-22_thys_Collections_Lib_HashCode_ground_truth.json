{"file_name": "/home/qj213/afp-2021-10-22/thys/Collections/Lib/HashCode.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Collections", "problem_names": ["lemma bounded_hashcode_bounds: \"1 < n \\<Longrightarrow> bounded_hashcode n a < n\"", "lemma bounded_hashcode_nat_bounds: \"1 < n \\<Longrightarrow> bounded_hashcode_nat n a < n\"", "lemma hashcode_option_simps [simp]:\n  \"hashcode None = 0\"\n  \"hashcode (Some a) = 1 + hashcode a\"", "lemma bounded_hashcode_option_simps [simp]:\n  \"bounded_hashcode n None = 0\"\n  \"bounded_hashcode n (Some a) = (hashcode a + 1) mod n\""], "translations": [["", "lemma bounded_hashcode_bounds: \"1 < n \\<Longrightarrow> bounded_hashcode n a < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < n \\<Longrightarrow> bounded_hashcode n a < n", "unfolding bounded_hashcode_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < n \\<Longrightarrow> hashcode a mod n < n", "by (transfer, simp add: word_less_def uint_mod)"], ["", "definition bounded_hashcode_nat :: \"nat \\<Rightarrow> 'a \\<Rightarrow> nat\" where\n    \"bounded_hashcode_nat n x = nat_of_hashcode (hashcode x) mod n\""], ["", "lemma bounded_hashcode_nat_bounds: \"1 < n \\<Longrightarrow> bounded_hashcode_nat n a < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < n \\<Longrightarrow> bounded_hashcode_nat n a < n", "unfolding bounded_hashcode_nat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < n \\<Longrightarrow> nat_of_hashcode (hashcode a) mod n < n", "by transfer simp"], ["", "end"], ["", "instantiation unit :: hashable\nbegin"], ["", "definition [simp]: \"hashcode (u :: unit) = 0\""], ["", "definition \"def_hashmap_size = (\\<lambda>_ :: unit itself. 2)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(unit, hashable_class)", "by (intro_classes)(simp_all add: def_hashmap_size_unit_def)"], ["", "end"], ["", "instantiation bool :: hashable\nbegin"], ["", "definition [simp]: \"hashcode (b :: bool) = (if b then 1 else 0)\""], ["", "definition \"def_hashmap_size = (\\<lambda>_ :: bool itself. 2)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(bool, hashable_class)", "by (intro_classes)(simp_all add: def_hashmap_size_bool_def)"], ["", "end"], ["", "instantiation \"int\" :: hashable\nbegin"], ["", "definition [simp]: \"hashcode (i :: int) = uint32_of_int i\""], ["", "definition \"def_hashmap_size = (\\<lambda>_ :: int itself. 16)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(int, hashable_class)", "by(intro_classes)(simp_all add: def_hashmap_size_int_def)"], ["", "end"], ["", "instantiation \"integer\" :: hashable\nbegin"], ["", "definition [simp]: \"hashcode (i :: integer) = Uint32 i\""], ["", "definition \"def_hashmap_size = (\\<lambda>_ :: integer itself. 16)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(integer, hashable_class)", "by(intro_classes)(simp_all add: def_hashmap_size_integer_def)"], ["", "end"], ["", "instantiation \"nat\" :: hashable\nbegin"], ["", "definition [simp]: \"hashcode (n :: nat) = uint32_of_int (int n)\""], ["", "definition \"def_hashmap_size = (\\<lambda>_ :: nat itself. 16)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(nat, hashable_class)", "by(intro_classes)(simp_all add: def_hashmap_size_nat_def)"], ["", "end"], ["", "instantiation char :: hashable\nbegin"], ["", "definition [simp]: \"hashcode (c :: char) == uint32_of_int (of_char c)\""], ["", "definition \"def_hashmap_size = (\\<lambda>_ :: char itself. 32)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(char, hashable_class)", "by(intro_classes)(simp_all add: def_hashmap_size_char_def)"], ["", "end"], ["", "instantiation prod :: (hashable, hashable) hashable\nbegin"], ["", "definition \"hashcode x == (hashcode (fst x) * 33 + hashcode (snd x))\""], ["", "definition \"def_hashmap_size = (\\<lambda>_ :: ('a \\<times> 'b) itself. def_hashmap_size TYPE('a) + def_hashmap_size TYPE('b))\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a \\<times> 'b, hashable_class)", "using def_hashmap_size[where ?'a=\"'a\"] def_hashmap_size[where ?'a=\"'b\"]"], ["proof (prove)\nusing this:\n  1 < def_hashmap_size TYPE('a)\n  1 < def_hashmap_size TYPE('b)\n\ngoal (1 subgoal):\n 1. OFCLASS('a \\<times> 'b, hashable_class)", "by(intro_classes)(simp_all add: def_hashmap_size_prod_def)"], ["", "end"], ["", "instantiation sum :: (hashable, hashable) hashable\nbegin"], ["", "definition \"hashcode x == (case x of Inl a \\<Rightarrow> 2 * hashcode a | Inr b \\<Rightarrow> 2 * hashcode b + 1)\""], ["", "definition \"def_hashmap_size = (\\<lambda>_ :: ('a + 'b) itself. def_hashmap_size TYPE('a) + def_hashmap_size TYPE('b))\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a + 'b, hashable_class)", "using def_hashmap_size[where ?'a=\"'a\"] def_hashmap_size[where ?'a=\"'b\"]"], ["proof (prove)\nusing this:\n  1 < def_hashmap_size TYPE('a)\n  1 < def_hashmap_size TYPE('b)\n\ngoal (1 subgoal):\n 1. OFCLASS('a + 'b, hashable_class)", "by(intro_classes)(simp_all add: bounded_hashcode_bounds def_hashmap_size_sum_def split: sum.split)"], ["", "end"], ["", "instantiation list :: (hashable) hashable\nbegin"], ["", "definition \"hashcode = foldl (\\<lambda>h x. h * 33 + hashcode x) 5381\""], ["", "definition \"def_hashmap_size = (\\<lambda>_ :: 'a list itself. 2 * def_hashmap_size TYPE('a))\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a list, hashable_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. 1 < def_hashmap_size TYPE('a list)", "from def_hashmap_size[where ?'a = \"'a\"]"], ["proof (chain)\npicking this:\n  1 < def_hashmap_size TYPE('a)", "show \"1 < def_hashmap_size TYPE('a list)\""], ["proof (prove)\nusing this:\n  1 < def_hashmap_size TYPE('a)\n\ngoal (1 subgoal):\n 1. 1 < def_hashmap_size TYPE('a list)", "by(simp add: def_hashmap_size_list_def)"], ["proof (state)\nthis:\n  1 < def_hashmap_size TYPE('a list)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "instantiation option :: (hashable) hashable\nbegin"], ["", "definition \"hashcode opt = (case opt of None \\<Rightarrow> 0 | Some a \\<Rightarrow> hashcode a + 1)\""], ["", "definition \"def_hashmap_size = (\\<lambda>_ :: 'a option itself. def_hashmap_size TYPE('a) + 1)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a option, hashable_class)", "using def_hashmap_size[where ?'a = \"'a\"]"], ["proof (prove)\nusing this:\n  1 < def_hashmap_size TYPE('a)\n\ngoal (1 subgoal):\n 1. OFCLASS('a option, hashable_class)", "by(intro_classes)(simp_all add: def_hashmap_size_option_def split: option.split)"], ["", "end"], ["", "lemma hashcode_option_simps [simp]:\n  \"hashcode None = 0\"\n  \"hashcode (Some a) = 1 + hashcode a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hashcode None = 0 &&& hashcode (Some a) = 1 + hashcode a", "by(simp_all add: hashcode_option_def)"], ["", "lemma bounded_hashcode_option_simps [simp]:\n  \"bounded_hashcode n None = 0\"\n  \"bounded_hashcode n (Some a) = (hashcode a + 1) mod n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_hashcode n None = 0 &&&\n    bounded_hashcode n (Some a) = (hashcode a + 1) mod n", "by (simp_all add: bounded_hashcode_def ac_simps)"], ["", "(*\nlemma bounded_hashcode_option_simps [simp]:\n  \"bounded_hashcode n None = 0\"\n  \"bounded_hashcode n (Some a) = (bounded_hashcode n a + 1) mod n\"\n  apply (simp_all add: bounded_hashcode_def, transfer, simp_all add: word_mod_def)\n  apply (simp_all add: algebra_simps mod_add_right_eq)\n*)"], ["", "instantiation String.literal :: hashable\nbegin"], ["", "definition hashcode_literal :: \"String.literal \\<Rightarrow> uint32\" \n  where \"hashcode_literal s = hashcode (String.explode s)\""], ["", "definition def_hashmap_size_literal  :: \"String.literal itself \\<Rightarrow> nat\"\n  where \"def_hashmap_size_literal _ = 10\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(String.literal, hashable_class)", "by standard (simp_all only: def_hashmap_size_literal_def)"], ["", "end"], ["", "hide_type (open) word"], ["", "end"]]}