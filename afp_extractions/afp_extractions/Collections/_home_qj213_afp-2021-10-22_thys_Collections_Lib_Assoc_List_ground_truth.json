{"file_name": "/home/qj213/afp-2021-10-22/thys/Collections/Lib/Assoc_List.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Collections", "problem_names": ["lemma assoc_list_ext: \"impl_of xs = impl_of ys \\<Longrightarrow> xs = ys\"", "lemma expand_assoc_list_eq: \"xs = ys \\<longleftrightarrow> impl_of xs = impl_of ys\"", "lemma impl_of_distinct [simp, intro]: \"distinct (map fst (impl_of al))\"", "lemma impl_of_distinct_full [simp, intro]: \"distinct (impl_of al)\"", "lemma Assoc_List_impl_of [code abstype]: \"Assoc_List (impl_of al) = al\"", "lemma impl_of_empty [code abstract]: \"impl_of empty = []\"", "lemma impl_of_update_with [code abstract]:\n  \"impl_of (update_with v k f al) = AList.update_with_aux v k f (impl_of al)\"", "lemma impl_of_delete [code abstract]:\n  \"impl_of (delete k al) = AList.delete_aux k (impl_of al)\"", "lemma lookup_empty [simp]: \"lookup empty k = None\"", "lemma lookup_empty': \"lookup empty = Map.empty\"", "lemma lookup_update_with [simp]: \n  \"lookup (update_with v k f al) = (lookup al)(k \\<mapsto> case lookup al k of None \\<Rightarrow> f v | Some v \\<Rightarrow> f v)\"", "lemma lookup_delete [simp]: \"lookup (delete k al) = (lookup al)(k := None)\"", "lemma finite_dom_lookup [simp, intro!]: \"finite (dom (lookup m))\"", "lemma iteratei_correct:\n  \"map_iterator (iteratei m) (lookup m)\"", "lemma lookup_update [simp]: \"lookup (update k v al) = (lookup al)(k \\<mapsto> v)\"", "lemma set_empty [simp]: \"set empty = {}\"", "lemma set_update_with:\n  \"set (update_with v k f al) = \n  (set al - {k} \\<times> UNIV \\<union> {(k, f (case lookup al k of None \\<Rightarrow> v | Some v \\<Rightarrow> v))})\"", "lemma set_update: \"set (update k v al) = (set al - {k} \\<times> UNIV \\<union> {(k, v)})\"", "lemma set_delete: \"set (delete k al) = set al - {k} \\<times> UNIV\"", "lemma map_ran_conv: \"map_of (map_ran f al) k = map_option (f k) (map_of al k)\"", "lemma dom_map_ran: \"fst ` set (map_ran f al) = fst ` set al\"", "lemma distinct_map_ran: \"distinct (map fst al) \\<Longrightarrow> distinct (map fst (map_ran f al))\"", "lemma map_ran_filter: \"map_ran f [(a, _)\\<leftarrow>ps. fst p \\<noteq> a] = [(a, _)\\<leftarrow>map_ran f ps. fst p \\<noteq> a]\"", "lemma clearjunk_map_ran: \"AList.clearjunk (map_ran f al) \n  = map_ran f (AList.clearjunk al)\"", "lemma map_ran_cong [fundef_cong]:\n  \"\\<lbrakk> al = al'; \\<And>k v. (k, v) \\<in> set al \\<Longrightarrow> f k v = g k v \\<rbrakk> \\<Longrightarrow> map_ran f al = map_ran g al'\"", "lemma size_list_delete: \"size_list f (AList.delete a al) \\<le> size_list f al\"", "lemma size_list_clearjunk: \"size_list f (AList.clearjunk al) \\<le> size_list f al\"", "lemma set_delete_conv: \"set (AList.delete a al) = set al - ({a} \\<times> UNIV)\"", "lemma set_clearjunk_subset: \"set (AList.clearjunk al) \\<subseteq> set al\"", "lemma map_ran_conv_map:\n  \"map_ran f xs = map (\\<lambda>(k, v). (k, f k v)) xs\"", "lemma card_dom_map_of: \"distinct (map fst al) \\<Longrightarrow> card (dom (map_of al)) = length al\"", "lemma map_of_map_inj_fst:\n  assumes \"inj f\"\n  shows \"map_of (map (\\<lambda>(k, v). (f k, v)) xs) (f x) = map_of xs x\"", "lemma length_map_ran [simp]: \"length (map_ran f xs) = length xs\"", "lemma length_update: \n  \"length (AList.update k v xs) \n  = (if k \\<in> fst ` set xs then length xs else Suc (length xs))\"", "lemma length_distinct: \n  \"distinct (map fst xs) \\<Longrightarrow> length (AList.delete k xs) \n  = (if k \\<in> fst ` set xs then length xs - 1 else length xs)\"", "lemma finite_Assoc_List_set_image:\n  assumes \"finite (Assoc_List.set ` A)\"\n  shows \"finite A\""], "translations": [["", "lemma assoc_list_ext: \"impl_of xs = impl_of ys \\<Longrightarrow> xs = ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. impl_of xs = impl_of ys \\<Longrightarrow> xs = ys", "by(simp add: impl_of_inject)"], ["", "lemma expand_assoc_list_eq: \"xs = ys \\<longleftrightarrow> impl_of xs = impl_of ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs = ys) = (impl_of xs = impl_of ys)", "by(simp add: impl_of_inject)"], ["", "lemma impl_of_distinct [simp, intro]: \"distinct (map fst (impl_of al))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst (impl_of al))", "using impl_of[of al]"], ["proof (prove)\nusing this:\n  impl_of al \\<in> {xs. distinct (map fst xs)}\n\ngoal (1 subgoal):\n 1. distinct (map fst (impl_of al))", "by simp"], ["", "lemma impl_of_distinct_full [simp, intro]: \"distinct (impl_of al)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (impl_of al)", "using impl_of_distinct[of al]"], ["proof (prove)\nusing this:\n  distinct (map fst (impl_of al))\n\ngoal (1 subgoal):\n 1. distinct (impl_of al)", "unfolding distinct_map"], ["proof (prove)\nusing this:\n  distinct (impl_of al) \\<and> inj_on fst (set (impl_of al))\n\ngoal (1 subgoal):\n 1. distinct (impl_of al)", "by simp"], ["", "lemma Assoc_List_impl_of [code abstype]: \"Assoc_List (impl_of al) = al\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Assoc_List (impl_of al) = al", "by(rule impl_of_inverse)"], ["", "subsection \\<open>Primitive operations\\<close>"], ["", "definition empty :: \"('k, 'v) assoc_list\"\nwhere [code del]: \"empty = Assoc_List []\""], ["", "definition lookup :: \"('k, 'v) assoc_list \\<Rightarrow> 'k \\<Rightarrow> 'v option\"\nwhere [code]: \"lookup al = map_of (impl_of al)\""], ["", "definition update_with :: \"'v \\<Rightarrow> 'k \\<Rightarrow> ('v \\<Rightarrow> 'v) \\<Rightarrow> ('k, 'v) assoc_list \\<Rightarrow> ('k, 'v) assoc_list\"\nwhere [code del]: \"update_with v k f al = Assoc_List (AList.update_with_aux v k f (impl_of al))\""], ["", "definition delete :: \"'k \\<Rightarrow> ('k, 'v) assoc_list \\<Rightarrow> ('k, 'v) assoc_list\"\nwhere [code del]: \"delete k al = Assoc_List (AList.delete_aux k (impl_of al))\""], ["", "definition iteratei :: \"('k, 'v) assoc_list \\<Rightarrow> ('s\\<Rightarrow>bool) \\<Rightarrow> ('k \\<times> 'v \\<Rightarrow> 's \\<Rightarrow> 's) \\<Rightarrow> 's \\<Rightarrow> 's\" \nwhere [code]: \"iteratei al c f = foldli (impl_of al) c f\""], ["", "lemma impl_of_empty [code abstract]: \"impl_of empty = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. impl_of Assoc_List.empty = []", "by(simp add: empty_def Assoc_List_inverse)"], ["", "lemma impl_of_update_with [code abstract]:\n  \"impl_of (update_with v k f al) = AList.update_with_aux v k f (impl_of al)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. impl_of (update_with v k f al) =\n    AList.update_with_aux v k f (impl_of al)", "by(simp add: update_with_def Assoc_List_inverse)"], ["", "lemma impl_of_delete [code abstract]:\n  \"impl_of (delete k al) = AList.delete_aux k (impl_of al)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. impl_of (delete k al) = AList.delete_aux k (impl_of al)", "by(simp add: delete_def Assoc_List_inverse)"], ["", "subsection \\<open>Abstract operation properties\\<close>"], ["", "lemma lookup_empty [simp]: \"lookup empty k = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup Assoc_List.empty k = None", "by(simp add: empty_def lookup_def Assoc_List_inverse)"], ["", "lemma lookup_empty': \"lookup empty = Map.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup Assoc_List.empty = Map.empty", "by(rule ext) simp"], ["", "lemma lookup_update_with [simp]: \n  \"lookup (update_with v k f al) = (lookup al)(k \\<mapsto> case lookup al k of None \\<Rightarrow> f v | Some v \\<Rightarrow> f v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (update_with v k f al) = lookup al(k \\<mapsto>\n    case lookup al k of None \\<Rightarrow> f v | Some v \\<Rightarrow> f v)", "by(simp add: lookup_def update_with_def Assoc_List_inverse map_of_update_with_aux)"], ["", "lemma lookup_delete [simp]: \"lookup (delete k al) = (lookup al)(k := None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (delete k al) = (lookup al)(k := None)", "by(simp add: lookup_def delete_def Assoc_List_inverse distinct_delete map_of_delete_aux')"], ["", "lemma finite_dom_lookup [simp, intro!]: \"finite (dom (lookup m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (dom (lookup m))", "by(simp add: lookup_def finite_dom_map_of)"], ["", "lemma iteratei_correct:\n  \"map_iterator (iteratei m) (lookup m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_iterator (iteratei m) (lookup m)", "unfolding iteratei_def[abs_def] lookup_def map_to_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator (foldli (impl_of m))\n     {(k, v). map_of (impl_of m) k = Some v}", "by (simp add: set_iterator_foldli_correct)"], ["", "subsection \\<open>Derived operations\\<close>"], ["", "definition update :: \"'key \\<Rightarrow> 'val \\<Rightarrow> ('key, 'val) assoc_list \\<Rightarrow> ('key, 'val) assoc_list\"\nwhere \"update k v = update_with v k (\\<lambda>_. v)\""], ["", "definition set :: \"('key, 'val) assoc_list \\<Rightarrow> ('key \\<times> 'val) set\"\nwhere \"set al = List.set (impl_of al)\""], ["", "lemma lookup_update [simp]: \"lookup (update k v al) = (lookup al)(k \\<mapsto> v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (update k v al) = lookup al(k \\<mapsto> v)", "by(simp add: update_def split: option.split)"], ["", "lemma set_empty [simp]: \"set empty = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Assoc_List.set Assoc_List.empty = {}", "by(simp add: set_def empty_def Assoc_List_inverse)"], ["", "lemma set_update_with:\n  \"set (update_with v k f al) = \n  (set al - {k} \\<times> UNIV \\<union> {(k, f (case lookup al k of None \\<Rightarrow> v | Some v \\<Rightarrow> v))})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Assoc_List.set (update_with v k f al) =\n    Assoc_List.set al - {k} \\<times> UNIV \\<union>\n    {(k, f (case lookup al k of None \\<Rightarrow> v\n            | Some v \\<Rightarrow> v))}", "by(simp add: set_def update_with_def Assoc_List_inverse set_update_with_aux lookup_def)"], ["", "lemma set_update: \"set (update k v al) = (set al - {k} \\<times> UNIV \\<union> {(k, v)})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Assoc_List.set (update k v al) =\n    Assoc_List.set al - {k} \\<times> UNIV \\<union> {(k, v)}", "by(simp add: update_def set_update_with)"], ["", "lemma set_delete: \"set (delete k al) = set al - {k} \\<times> UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Assoc_List.set (delete k al) = Assoc_List.set al - {k} \\<times> UNIV", "by(simp add: set_def delete_def Assoc_List_inverse set_delete_aux)"], ["", "subsection \\<open>Type classes\\<close>"], ["", "instantiation assoc_list :: (equal, equal) equal begin"], ["", "definition \"equal_class.equal (al :: ('a, 'b) assoc_list) al' == impl_of al = impl_of al'\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) assoc_list, equal_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. equal_class.equal x y = (x = y)", "qed (simp add: equal_assoc_list_def impl_of_inject)"], ["", "end"], ["", "instantiation assoc_list :: (type, type) size begin"], ["", "definition \"size (al :: ('a, 'b) assoc_list) = length (impl_of al)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) assoc_list, size_class)", ".."], ["", "end"], ["", "hide_const (open) impl_of empty lookup update_with set update delete iteratei"], ["", "subsection \\<open>@{const map_ran}\\<close>"], ["", "text \\<open>@{term map_ran} with more general type - lemmas replicated from AList in HOL/Library\\<close>"], ["", "hide_const (open) map_ran"], ["", "primrec\n  map_ran :: \"('key \\<Rightarrow> 'val \\<Rightarrow> 'val') \\<Rightarrow> ('key \\<times> 'val) list \\<Rightarrow> ('key \\<times> 'val') list\"\nwhere\n    \"map_ran f [] = []\"\n  | \"map_ran f (p#ps) = (fst p, f (fst p) (snd p)) # map_ran f ps\""], ["", "lemma map_ran_conv: \"map_of (map_ran f al) k = map_option (f k) (map_of al k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (map_ran f al) k = map_option (f k) (map_of al k)", "by (induct al) auto"], ["", "lemma dom_map_ran: \"fst ` set (map_ran f al) = fst ` set al\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` set (map_ran f al) = fst ` set al", "by (induct al) auto"], ["", "lemma distinct_map_ran: \"distinct (map fst al) \\<Longrightarrow> distinct (map fst (map_ran f al))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst al) \\<Longrightarrow>\n    distinct (map fst (map_ran f al))", "by (induct al) (auto simp add: dom_map_ran)"], ["", "lemma map_ran_filter: \"map_ran f [(a, _)\\<leftarrow>ps. fst p \\<noteq> a] = [(a, _)\\<leftarrow>map_ran f ps. fst p \\<noteq> a]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_ran f (filter (\\<lambda>(a, uu_). fst p \\<noteq> a) ps) =\n    filter (\\<lambda>(a, uu_). fst p \\<noteq> a) (map_ran f ps)", "by (induct ps) auto"], ["", "lemma clearjunk_map_ran: \"AList.clearjunk (map_ran f al) \n  = map_ran f (AList.clearjunk al)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. AList.clearjunk (map_ran f al) = map_ran f (AList.clearjunk al)", "by (induct al rule: clearjunk.induct) (simp_all add: AList.delete_eq map_ran_filter)"], ["", "text \\<open>new lemmas and definitions\\<close>"], ["", "lemma map_ran_cong [fundef_cong]:\n  \"\\<lbrakk> al = al'; \\<And>k v. (k, v) \\<in> set al \\<Longrightarrow> f k v = g k v \\<rbrakk> \\<Longrightarrow> map_ran f al = map_ran g al'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>al = al';\n     \\<And>k v. (k, v) \\<in> set al \\<Longrightarrow> f k v = g k v\\<rbrakk>\n    \\<Longrightarrow> map_ran f al = map_ran g al'", "by hypsubst_thin (induct al', auto)"], ["", "lemma size_list_delete: \"size_list f (AList.delete a al) \\<le> size_list f al\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size_list f (AList.delete a al) \\<le> size_list f al", "by(induct al) simp_all"], ["", "lemma size_list_clearjunk: \"size_list f (AList.clearjunk al) \\<le> size_list f al\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size_list f (AList.clearjunk al) \\<le> size_list f al", "by(induct al)(auto simp add: clearjunk_delete intro: le_trans[OF size_list_delete])"], ["", "lemma set_delete_conv: \"set (AList.delete a al) = set al - ({a} \\<times> UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (AList.delete a al) = set al - {a} \\<times> UNIV", "proof(induct al)"], ["proof (state)\ngoal (2 subgoals):\n 1. set (AList.delete a []) = set [] - {a} \\<times> UNIV\n 2. \\<And>aa al.\n       set (AList.delete a al) =\n       set al - {a} \\<times> UNIV \\<Longrightarrow>\n       set (AList.delete a (aa # al)) = set (aa # al) - {a} \\<times> UNIV", "case (Cons kv al)"], ["proof (state)\nthis:\n  set (AList.delete a al) = set al - {a} \\<times> UNIV\n\ngoal (2 subgoals):\n 1. set (AList.delete a []) = set [] - {a} \\<times> UNIV\n 2. \\<And>aa al.\n       set (AList.delete a al) =\n       set al - {a} \\<times> UNIV \\<Longrightarrow>\n       set (AList.delete a (aa # al)) = set (aa # al) - {a} \\<times> UNIV", "thus ?case"], ["proof (prove)\nusing this:\n  set (AList.delete a al) = set al - {a} \\<times> UNIV\n\ngoal (1 subgoal):\n 1. set (AList.delete a (kv # al)) = set (kv # al) - {a} \\<times> UNIV", "by(cases kv) auto"], ["proof (state)\nthis:\n  set (AList.delete a (kv # al)) = set (kv # al) - {a} \\<times> UNIV\n\ngoal (1 subgoal):\n 1. set (AList.delete a []) = set [] - {a} \\<times> UNIV", "qed simp"], ["", "lemma set_clearjunk_subset: \"set (AList.clearjunk al) \\<subseteq> set al\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (AList.clearjunk al) \\<subseteq> set al", "by(induct al)(auto simp add: clearjunk_delete set_delete_conv)"], ["", "lemma map_ran_conv_map:\n  \"map_ran f xs = map (\\<lambda>(k, v). (k, f k v)) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_ran f xs = map (\\<lambda>(k, v). (k, f k v)) xs", "by(induct xs) auto"], ["", "lemma card_dom_map_of: \"distinct (map fst al) \\<Longrightarrow> card (dom (map_of al)) = length al\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst al) \\<Longrightarrow>\n    card (dom (map_of al)) = length al", "by(induct al)(auto simp add: card_insert_if finite_dom_map_of dom_map_of_conv_image_fst)"], ["", "lemma map_of_map_inj_fst:\n  assumes \"inj f\"\n  shows \"map_of (map (\\<lambda>(k, v). (f k, v)) xs) (f x) = map_of xs x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (map (\\<lambda>(k, v). (f k, v)) xs) (f x) = map_of xs x", "by(induct xs)(auto dest: injD[OF \\<open>inj f\\<close>])"], ["", "lemma length_map_ran [simp]: \"length (map_ran f xs) = length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map_ran f xs) = length xs", "by(induct xs) simp_all"], ["", "lemma length_update: \n  \"length (AList.update k v xs) \n  = (if k \\<in> fst ` set xs then length xs else Suc (length xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (AList.update k v xs) =\n    (if k \\<in> fst ` set xs then length xs else Suc (length xs))", "by(induct xs) simp_all"], ["", "lemma length_distinct: \n  \"distinct (map fst xs) \\<Longrightarrow> length (AList.delete k xs) \n  = (if k \\<in> fst ` set xs then length xs - 1 else length xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst xs) \\<Longrightarrow>\n    length (AList.delete k xs) =\n    (if k \\<in> fst ` set xs then length xs - 1 else length xs)", "by(induct xs)(auto split: if_split_asm simp add: in_set_conv_nth)"], ["", "lemma finite_Assoc_List_set_image:\n  assumes \"finite (Assoc_List.set ` A)\"\n  shows \"finite A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite A", "have \"Assoc_List.set ` A = set ` Assoc_List.impl_of ` A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Assoc_List.set ` A = set ` assoc_list.impl_of ` A", "by (auto simp add: Assoc_List.set_def)"], ["proof (state)\nthis:\n  Assoc_List.set ` A = set ` assoc_list.impl_of ` A\n\ngoal (1 subgoal):\n 1. finite A", "with assms finite_set_image"], ["proof (chain)\npicking this:\n  finite (Assoc_List.set ` A)\n  \\<lbrakk>finite (set ` ?A);\n   \\<And>xs. xs \\<in> ?A \\<Longrightarrow> distinct xs\\<rbrakk>\n  \\<Longrightarrow> finite ?A\n  Assoc_List.set ` A = set ` assoc_list.impl_of ` A", "have \"finite (Assoc_List.impl_of ` A)\""], ["proof (prove)\nusing this:\n  finite (Assoc_List.set ` A)\n  \\<lbrakk>finite (set ` ?A);\n   \\<And>xs. xs \\<in> ?A \\<Longrightarrow> distinct xs\\<rbrakk>\n  \\<Longrightarrow> finite ?A\n  Assoc_List.set ` A = set ` assoc_list.impl_of ` A\n\ngoal (1 subgoal):\n 1. finite (assoc_list.impl_of ` A)", "by auto"], ["proof (state)\nthis:\n  finite (assoc_list.impl_of ` A)\n\ngoal (1 subgoal):\n 1. finite A", "with assoc_list_ext"], ["proof (chain)\npicking this:\n  assoc_list.impl_of ?xs = assoc_list.impl_of ?ys \\<Longrightarrow>\n  ?xs = ?ys\n  finite (assoc_list.impl_of ` A)", "show ?thesis"], ["proof (prove)\nusing this:\n  assoc_list.impl_of ?xs = assoc_list.impl_of ?ys \\<Longrightarrow>\n  ?xs = ?ys\n  finite (assoc_list.impl_of ` A)\n\ngoal (1 subgoal):\n 1. finite A", "by (metis inj_onI finite_imageD)"], ["proof (state)\nthis:\n  finite A\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}