{"file_name": "/home/qj213/afp-2021-10-22/thys/Collections/ICF/impl/Trie_Impl.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Collections", "problem_names": ["lemma iteratei_postfixed_interrupt:\n  \"\\<not> c \\<sigma> \\<Longrightarrow> iteratei_postfixed ks t c f \\<sigma> = \\<sigma>\"", "lemma iteratei_interrupt:\n  \"\\<not> c \\<sigma> \\<Longrightarrow> iteratei t c f \\<sigma> = \\<sigma>\"", "lemma iteratei_postfixed_alt_def :\n  \"iteratei_postfixed ks ((Trie vo ts)::('key, 'val) trie) =\n   (set_iterator_union \n     (case_option set_iterator_emp (\\<lambda>v. set_iterator_sng (ks, v)) vo) \n     (set_iterator_image snd\n     (set_iterator_product (foldli ts) \n        (\\<lambda>(k, t'). iteratei_postfixed (k # ks) t'))\n     ))\"", "lemma iteratei_postfixed_correct :\n  assumes invar: \"invar_trie (t :: ('key, 'val) trie)\"\n  shows \"set_iterator ((iteratei_postfixed ks0 t)::('key list \\<times> 'val, '\\<sigma>) set_iterator)\n           ((\\<lambda>ksv. (rev (fst ksv) @ ks0, (snd ksv))) ` (map_to_set (lookup_trie t)))\"", "lemma trie_reverse_key_alt_def[code] :\n  \"trie_reverse_key (ks, v) = (rev ks, v)\"", "lemma trie_reverse_key_reverse[simp] :\n  \"trie_reverse_key (trie_reverse_key ksv) = ksv\"", "lemma trie_iteratei_correct:\n  assumes invar: \"invar_trie (t :: ('key, 'val) trie)\"\n  shows \"set_iterator ((iteratei t)::('key list \\<times> 'val, '\\<sigma>) set_iterator)\n           (trie_reverse_key ` (map_to_set (lookup_trie t)))\""], "translations": [["", "lemma iteratei_postfixed_interrupt:\n  \"\\<not> c \\<sigma> \\<Longrightarrow> iteratei_postfixed ks t c f \\<sigma> = \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> c \\<sigma> \\<Longrightarrow>\n    iteratei_postfixed ks t c f \\<sigma> = \\<sigma>", "by(cases t) simp"], ["", "lemma iteratei_interrupt:\n  \"\\<not> c \\<sigma> \\<Longrightarrow> iteratei t c f \\<sigma> = \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> c \\<sigma> \\<Longrightarrow> iteratei t c f \\<sigma> = \\<sigma>", "unfolding iteratei_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> c \\<sigma> \\<Longrightarrow>\n    iteratei_postfixed [] t c f \\<sigma> = \\<sigma>", "by (simp add: iteratei_postfixed_interrupt)"], ["", "lemma iteratei_postfixed_alt_def :\n  \"iteratei_postfixed ks ((Trie vo ts)::('key, 'val) trie) =\n   (set_iterator_union \n     (case_option set_iterator_emp (\\<lambda>v. set_iterator_sng (ks, v)) vo) \n     (set_iterator_image snd\n     (set_iterator_product (foldli ts) \n        (\\<lambda>(k, t'). iteratei_postfixed (k # ks) t'))\n     ))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iteratei_postfixed ks (Trie vo ts) =\n    set_iterator_union\n     (case vo of None \\<Rightarrow> set_iterator_emp\n      | Some v \\<Rightarrow> set_iterator_sng (ks, v))\n     (set_iterator_image snd\n       (set_iterator_product (foldli ts)\n         (\\<lambda>(k, t'). iteratei_postfixed (k # ks) t')))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. iteratei_postfixed ks (Trie vo ts) =\n    set_iterator_union\n     (case vo of None \\<Rightarrow> set_iterator_emp\n      | Some v \\<Rightarrow> set_iterator_sng (ks, v))\n     (set_iterator_image snd\n       (set_iterator_product (foldli ts)\n         (\\<lambda>(k, t'). iteratei_postfixed (k # ks) t')))", "have aux: \"\\<And>c f. (\\<lambda>(k, t). iteratei_postfixed (k # ks) t c f) =\n              (\\<lambda>a. iteratei_postfixed (fst a # ks) (snd a) c f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c f.\n       (\\<lambda>(k, t). iteratei_postfixed (k # ks) t c f) =\n       (\\<lambda>a. iteratei_postfixed (fst a # ks) (snd a) c f)", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>(k, t). iteratei_postfixed (k # ks) t ?c ?f) =\n  (\\<lambda>a. iteratei_postfixed (fst a # ks) (snd a) ?c ?f)\n\ngoal (1 subgoal):\n 1. iteratei_postfixed ks (Trie vo ts) =\n    set_iterator_union\n     (case vo of None \\<Rightarrow> set_iterator_emp\n      | Some v \\<Rightarrow> set_iterator_sng (ks, v))\n     (set_iterator_image snd\n       (set_iterator_product (foldli ts)\n         (\\<lambda>(k, t'). iteratei_postfixed (k # ks) t')))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. iteratei_postfixed ks (Trie vo ts) =\n    set_iterator_union\n     (case vo of None \\<Rightarrow> set_iterator_emp\n      | Some v \\<Rightarrow> set_iterator_sng (ks, v))\n     (set_iterator_image snd\n       (set_iterator_product (foldli ts)\n         (\\<lambda>(k, t'). iteratei_postfixed (k # ks) t')))", "apply (rule ext)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       iteratei_postfixed ks (Trie vo ts) x xa xb =\n       set_iterator_union\n        (case vo of None \\<Rightarrow> set_iterator_emp\n         | Some v \\<Rightarrow> set_iterator_sng (ks, v))\n        (set_iterator_image snd\n          (set_iterator_product (foldli ts)\n            (\\<lambda>(k, t'). iteratei_postfixed (k # ks) t')))\n        x xa xb", "apply (rename_tac c f \\<sigma>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c f \\<sigma>.\n       iteratei_postfixed ks (Trie vo ts) c f \\<sigma> =\n       set_iterator_union\n        (case vo of None \\<Rightarrow> set_iterator_emp\n         | Some v \\<Rightarrow> set_iterator_sng (ks, v))\n        (set_iterator_image snd\n          (set_iterator_product (foldli ts)\n            (\\<lambda>(k, t'). iteratei_postfixed (k # ks) t')))\n        c f \\<sigma>", "apply (simp add: set_iterator_product_def set_iterator_image_filter_def\n                     set_iterator_union_def set_iterator_sng_def set_iterator_image_alt_def\n                     case_prod_beta set_iterator_emp_def \n            split: option.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c f \\<sigma>.\n       (vo = None \\<longrightarrow>\n        c \\<sigma> \\<longrightarrow>\n        foldli ts c (\\<lambda>(k, t). iteratei_postfixed (k # ks) t c f)\n         \\<sigma> =\n        foldli ts c\n         (\\<lambda>a. iteratei_postfixed (fst a # ks) (snd a) c f)\n         \\<sigma>) \\<and>\n       (\\<forall>x2.\n           vo = Some x2 \\<longrightarrow>\n           c \\<sigma> \\<longrightarrow>\n           foldli ts c (\\<lambda>(k, t). iteratei_postfixed (k # ks) t c f)\n            (f (ks, x2) \\<sigma>) =\n           foldli ts c\n            (\\<lambda>a. iteratei_postfixed (fst a # ks) (snd a) c f)\n            (f (ks, x2) \\<sigma>))", "apply (simp add: aux)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  iteratei_postfixed ks (Trie vo ts) =\n  set_iterator_union\n   (case vo of None \\<Rightarrow> set_iterator_emp\n    | Some v \\<Rightarrow> set_iterator_sng (ks, v))\n   (set_iterator_image snd\n     (set_iterator_product (foldli ts)\n       (\\<lambda>(k, t'). iteratei_postfixed (k # ks) t')))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma iteratei_postfixed_correct :\n  assumes invar: \"invar_trie (t :: ('key, 'val) trie)\"\n  shows \"set_iterator ((iteratei_postfixed ks0 t)::('key list \\<times> 'val, '\\<sigma>) set_iterator)\n           ((\\<lambda>ksv. (rev (fst ksv) @ ks0, (snd ksv))) ` (map_to_set (lookup_trie t)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator (iteratei_postfixed ks0 t)\n     ((\\<lambda>ksv. (rev (fst ksv) @ ks0, snd ksv)) `\n      map_to_set (lookup_trie t))", "using invar"], ["proof (prove)\nusing this:\n  invar_trie t\n\ngoal (1 subgoal):\n 1. set_iterator (iteratei_postfixed ks0 t)\n     ((\\<lambda>ksv. (rev (fst ksv) @ ks0, snd ksv)) `\n      map_to_set (lookup_trie t))", "proof (induct t arbitrary: ks0)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>vo kvs ks0.\n       \\<lbrakk>\\<And>k t ks0.\n                   \\<lbrakk>(k, t) \\<in> set kvs; invar_trie t\\<rbrakk>\n                   \\<Longrightarrow> set_iterator (iteratei_postfixed ks0 t)\n((\\<lambda>ksv. (rev (fst ksv) @ ks0, snd ksv)) `\n map_to_set (lookup_trie t));\n        invar_trie (Trie vo kvs)\\<rbrakk>\n       \\<Longrightarrow> set_iterator (iteratei_postfixed ks0 (Trie vo kvs))\n                          ((\\<lambda>ksv. (rev (fst ksv) @ ks0, snd ksv)) `\n                           map_to_set (lookup_trie (Trie vo kvs)))", "case (Trie vo kvs)"], ["proof (state)\nthis:\n  \\<lbrakk>(?k, ?t) \\<in> set kvs; invar_trie ?t\\<rbrakk>\n  \\<Longrightarrow> set_iterator (iteratei_postfixed ?ks0.0 ?t)\n                     ((\\<lambda>ksv. (rev (fst ksv) @ ?ks0.0, snd ksv)) `\n                      map_to_set (lookup_trie ?t))\n  invar_trie (Trie vo kvs)\n\ngoal (1 subgoal):\n 1. \\<And>vo kvs ks0.\n       \\<lbrakk>\\<And>k t ks0.\n                   \\<lbrakk>(k, t) \\<in> set kvs; invar_trie t\\<rbrakk>\n                   \\<Longrightarrow> set_iterator (iteratei_postfixed ks0 t)\n((\\<lambda>ksv. (rev (fst ksv) @ ks0, snd ksv)) `\n map_to_set (lookup_trie t));\n        invar_trie (Trie vo kvs)\\<rbrakk>\n       \\<Longrightarrow> set_iterator (iteratei_postfixed ks0 (Trie vo kvs))\n                          ((\\<lambda>ksv. (rev (fst ksv) @ ks0, snd ksv)) `\n                           map_to_set (lookup_trie (Trie vo kvs)))", "note ind_hyp = Trie(1)"], ["proof (state)\nthis:\n  \\<lbrakk>(?k, ?t) \\<in> set kvs; invar_trie ?t\\<rbrakk>\n  \\<Longrightarrow> set_iterator (iteratei_postfixed ?ks0.0 ?t)\n                     ((\\<lambda>ksv. (rev (fst ksv) @ ?ks0.0, snd ksv)) `\n                      map_to_set (lookup_trie ?t))\n\ngoal (1 subgoal):\n 1. \\<And>vo kvs ks0.\n       \\<lbrakk>\\<And>k t ks0.\n                   \\<lbrakk>(k, t) \\<in> set kvs; invar_trie t\\<rbrakk>\n                   \\<Longrightarrow> set_iterator (iteratei_postfixed ks0 t)\n((\\<lambda>ksv. (rev (fst ksv) @ ks0, snd ksv)) `\n map_to_set (lookup_trie t));\n        invar_trie (Trie vo kvs)\\<rbrakk>\n       \\<Longrightarrow> set_iterator (iteratei_postfixed ks0 (Trie vo kvs))\n                          ((\\<lambda>ksv. (rev (fst ksv) @ ks0, snd ksv)) `\n                           map_to_set (lookup_trie (Trie vo kvs)))", "note invar = Trie(2)"], ["proof (state)\nthis:\n  invar_trie (Trie vo kvs)\n\ngoal (1 subgoal):\n 1. \\<And>vo kvs ks0.\n       \\<lbrakk>\\<And>k t ks0.\n                   \\<lbrakk>(k, t) \\<in> set kvs; invar_trie t\\<rbrakk>\n                   \\<Longrightarrow> set_iterator (iteratei_postfixed ks0 t)\n((\\<lambda>ksv. (rev (fst ksv) @ ks0, snd ksv)) `\n map_to_set (lookup_trie t));\n        invar_trie (Trie vo kvs)\\<rbrakk>\n       \\<Longrightarrow> set_iterator (iteratei_postfixed ks0 (Trie vo kvs))\n                          ((\\<lambda>ksv. (rev (fst ksv) @ ks0, snd ksv)) `\n                           map_to_set (lookup_trie (Trie vo kvs)))", "from invar"], ["proof (chain)\npicking this:\n  invar_trie (Trie vo kvs)", "have dist_fst_kvs : \"distinct (map fst kvs)\"\n   and dist_kvs: \"distinct kvs\"\n   and invar_child: \"\\<And>k t. (k, t) \\<in> set kvs \\<Longrightarrow> invar_trie t\""], ["proof (prove)\nusing this:\n  invar_trie (Trie vo kvs)\n\ngoal (1 subgoal):\n 1. distinct (map fst kvs) &&&\n    distinct kvs &&&\n    (\\<And>k t. (k, t) \\<in> set kvs \\<Longrightarrow> invar_trie t)", "by (simp_all add: Ball_def distinct_map)\n\n  \\<comment> \\<open>root iterator\\<close>"], ["proof (state)\nthis:\n  distinct (map fst kvs)\n  distinct kvs\n  (?k, ?t) \\<in> set kvs \\<Longrightarrow> invar_trie ?t\n\ngoal (1 subgoal):\n 1. \\<And>vo kvs ks0.\n       \\<lbrakk>\\<And>k t ks0.\n                   \\<lbrakk>(k, t) \\<in> set kvs; invar_trie t\\<rbrakk>\n                   \\<Longrightarrow> set_iterator (iteratei_postfixed ks0 t)\n((\\<lambda>ksv. (rev (fst ksv) @ ks0, snd ksv)) `\n map_to_set (lookup_trie t));\n        invar_trie (Trie vo kvs)\\<rbrakk>\n       \\<Longrightarrow> set_iterator (iteratei_postfixed ks0 (Trie vo kvs))\n                          ((\\<lambda>ksv. (rev (fst ksv) @ ks0, snd ksv)) `\n                           map_to_set (lookup_trie (Trie vo kvs)))", "define it_vo :: \"('key list \\<times> 'val, '\\<sigma>) set_iterator\"\n    where \"it_vo =\n      (case vo of None \\<Rightarrow> set_iterator_emp \n       | Some v \\<Rightarrow> set_iterator_sng (ks0, v))\""], ["proof (state)\nthis:\n  it_vo =\n  (case vo of None \\<Rightarrow> set_iterator_emp\n   | Some v \\<Rightarrow> set_iterator_sng (ks0, v))\n\ngoal (1 subgoal):\n 1. \\<And>vo kvs ks0.\n       \\<lbrakk>\\<And>k t ks0.\n                   \\<lbrakk>(k, t) \\<in> set kvs; invar_trie t\\<rbrakk>\n                   \\<Longrightarrow> set_iterator (iteratei_postfixed ks0 t)\n((\\<lambda>ksv. (rev (fst ksv) @ ks0, snd ksv)) `\n map_to_set (lookup_trie t));\n        invar_trie (Trie vo kvs)\\<rbrakk>\n       \\<Longrightarrow> set_iterator (iteratei_postfixed ks0 (Trie vo kvs))\n                          ((\\<lambda>ksv. (rev (fst ksv) @ ks0, snd ksv)) `\n                           map_to_set (lookup_trie (Trie vo kvs)))", "define vo_S where \"vo_S = (case vo of None \\<Rightarrow> {} | Some v \\<Rightarrow> {(ks0, v)})\""], ["proof (state)\nthis:\n  vo_S =\n  (case vo of None \\<Rightarrow> {} | Some v \\<Rightarrow> {(ks0, v)})\n\ngoal (1 subgoal):\n 1. \\<And>vo kvs ks0.\n       \\<lbrakk>\\<And>k t ks0.\n                   \\<lbrakk>(k, t) \\<in> set kvs; invar_trie t\\<rbrakk>\n                   \\<Longrightarrow> set_iterator (iteratei_postfixed ks0 t)\n((\\<lambda>ksv. (rev (fst ksv) @ ks0, snd ksv)) `\n map_to_set (lookup_trie t));\n        invar_trie (Trie vo kvs)\\<rbrakk>\n       \\<Longrightarrow> set_iterator (iteratei_postfixed ks0 (Trie vo kvs))\n                          ((\\<lambda>ksv. (rev (fst ksv) @ ks0, snd ksv)) `\n                           map_to_set (lookup_trie (Trie vo kvs)))", "have it_vo_OK: \"set_iterator it_vo vo_S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator it_vo vo_S", "unfolding it_vo_def vo_S_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator\n     (case vo of None \\<Rightarrow> set_iterator_emp\n      | Some v \\<Rightarrow> set_iterator_sng (ks0, v))\n     (case vo of None \\<Rightarrow> {} | Some v \\<Rightarrow> {(ks0, v)})", "by (simp split: option.split \n             add: set_iterator_emp_correct set_iterator_sng_correct)\n\n  \\<comment> \\<open>children iterator\\<close>"], ["proof (state)\nthis:\n  set_iterator it_vo vo_S\n\ngoal (1 subgoal):\n 1. \\<And>vo kvs ks0.\n       \\<lbrakk>\\<And>k t ks0.\n                   \\<lbrakk>(k, t) \\<in> set kvs; invar_trie t\\<rbrakk>\n                   \\<Longrightarrow> set_iterator (iteratei_postfixed ks0 t)\n((\\<lambda>ksv. (rev (fst ksv) @ ks0, snd ksv)) `\n map_to_set (lookup_trie t));\n        invar_trie (Trie vo kvs)\\<rbrakk>\n       \\<Longrightarrow> set_iterator (iteratei_postfixed ks0 (Trie vo kvs))\n                          ((\\<lambda>ksv. (rev (fst ksv) @ ks0, snd ksv)) `\n                           map_to_set (lookup_trie (Trie vo kvs)))", "define it_prod :: \"(('key \\<times> ('key, 'val) trie) \\<times> 'key list \\<times> 'val, '\\<sigma>) set_iterator\"\n    where \"it_prod = set_iterator_product (foldli kvs) (\\<lambda>(k, y). iteratei_postfixed (k # ks0) y)\""], ["proof (state)\nthis:\n  it_prod =\n  set_iterator_product (foldli kvs)\n   (\\<lambda>(k, y). iteratei_postfixed (k # ks0) y)\n\ngoal (1 subgoal):\n 1. \\<And>vo kvs ks0.\n       \\<lbrakk>\\<And>k t ks0.\n                   \\<lbrakk>(k, t) \\<in> set kvs; invar_trie t\\<rbrakk>\n                   \\<Longrightarrow> set_iterator (iteratei_postfixed ks0 t)\n((\\<lambda>ksv. (rev (fst ksv) @ ks0, snd ksv)) `\n map_to_set (lookup_trie t));\n        invar_trie (Trie vo kvs)\\<rbrakk>\n       \\<Longrightarrow> set_iterator (iteratei_postfixed ks0 (Trie vo kvs))\n                          ((\\<lambda>ksv. (rev (fst ksv) @ ks0, snd ksv)) `\n                           map_to_set (lookup_trie (Trie vo kvs)))", "define it_prod_S where \"it_prod_S = (SIGMA kt:set kvs.\n       (\\<lambda>ksv. (rev (fst ksv) @ ((fst kt) # ks0), snd ksv)) `\n       map_to_set (lookup_trie (snd kt)))\""], ["proof (state)\nthis:\n  it_prod_S =\n  (SIGMA kt:set kvs.\n      (\\<lambda>ksv. (rev (fst ksv) @ fst kt # ks0, snd ksv)) `\n      map_to_set (lookup_trie (snd kt)))\n\ngoal (1 subgoal):\n 1. \\<And>vo kvs ks0.\n       \\<lbrakk>\\<And>k t ks0.\n                   \\<lbrakk>(k, t) \\<in> set kvs; invar_trie t\\<rbrakk>\n                   \\<Longrightarrow> set_iterator (iteratei_postfixed ks0 t)\n((\\<lambda>ksv. (rev (fst ksv) @ ks0, snd ksv)) `\n map_to_set (lookup_trie t));\n        invar_trie (Trie vo kvs)\\<rbrakk>\n       \\<Longrightarrow> set_iterator (iteratei_postfixed ks0 (Trie vo kvs))\n                          ((\\<lambda>ksv. (rev (fst ksv) @ ks0, snd ksv)) `\n                           map_to_set (lookup_trie (Trie vo kvs)))", "have it_prod_OK: \"set_iterator it_prod it_prod_S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator it_prod it_prod_S", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set_iterator it_prod it_prod_S", "from set_iterator_foldli_correct[OF dist_kvs]"], ["proof (chain)\npicking this:\n  set_iterator (foldli kvs) (set kvs)", "have it_foldli: \"set_iterator (foldli kvs) (set kvs)\""], ["proof (prove)\nusing this:\n  set_iterator (foldli kvs) (set kvs)\n\ngoal (1 subgoal):\n 1. set_iterator (foldli kvs) (set kvs)", "."], ["proof (state)\nthis:\n  set_iterator (foldli kvs) (set kvs)\n\ngoal (1 subgoal):\n 1. set_iterator it_prod it_prod_S", "{"], ["proof (state)\nthis:\n  set_iterator (foldli kvs) (set kvs)\n\ngoal (1 subgoal):\n 1. set_iterator it_prod it_prod_S", "fix kt"], ["proof (state)\ngoal (1 subgoal):\n 1. set_iterator it_prod it_prod_S", "assume kt_in: \"kt \\<in> set kvs\""], ["proof (state)\nthis:\n  kt \\<in> set kvs\n\ngoal (1 subgoal):\n 1. set_iterator it_prod it_prod_S", "hence k_t_in: \"(fst kt, snd kt) \\<in> set kvs\""], ["proof (prove)\nusing this:\n  kt \\<in> set kvs\n\ngoal (1 subgoal):\n 1. (fst kt, snd kt) \\<in> set kvs", "by simp"], ["proof (state)\nthis:\n  (fst kt, snd kt) \\<in> set kvs\n\ngoal (1 subgoal):\n 1. set_iterator it_prod it_prod_S", "note ind_hyp [OF k_t_in, OF invar_child[OF k_t_in], of \"fst kt # ks0\"]"], ["proof (state)\nthis:\n  set_iterator (iteratei_postfixed (fst kt # ks0) (snd kt))\n   ((\\<lambda>ksv. (rev (fst ksv) @ fst kt # ks0, snd ksv)) `\n    map_to_set (lookup_trie (snd kt)))\n\ngoal (1 subgoal):\n 1. set_iterator it_prod it_prod_S", "}"], ["proof (state)\nthis:\n  ?kt3 \\<in> set kvs \\<Longrightarrow>\n  set_iterator (iteratei_postfixed (fst ?kt3 # ks0) (snd ?kt3))\n   ((\\<lambda>ksv. (rev (fst ksv) @ fst ?kt3 # ks0, snd ksv)) `\n    map_to_set (lookup_trie (snd ?kt3)))\n\ngoal (1 subgoal):\n 1. set_iterator it_prod it_prod_S", "note it_child = this"], ["proof (state)\nthis:\n  ?kt3 \\<in> set kvs \\<Longrightarrow>\n  set_iterator (iteratei_postfixed (fst ?kt3 # ks0) (snd ?kt3))\n   ((\\<lambda>ksv. (rev (fst ksv) @ fst ?kt3 # ks0, snd ksv)) `\n    map_to_set (lookup_trie (snd ?kt3)))\n\ngoal (1 subgoal):\n 1. set_iterator it_prod it_prod_S", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator it_prod it_prod_S", "unfolding it_prod_def it_prod_S_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator\n     (set_iterator_product (foldli kvs)\n       (\\<lambda>(k, y). iteratei_postfixed (k # ks0) y))\n     (SIGMA kt:set kvs.\n         (\\<lambda>ksv. (rev (fst ksv) @ fst kt # ks0, snd ksv)) `\n         map_to_set (lookup_trie (snd kt)))", "apply (rule set_iterator_product_correct [OF it_foldli])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       a \\<in> set kvs \\<Longrightarrow>\n       set_iterator\n        (case a of (k, x) \\<Rightarrow> iteratei_postfixed (k # ks0) x)\n        ((\\<lambda>ksv. (rev (fst ksv) @ fst a # ks0, snd ksv)) `\n         map_to_set (lookup_trie (snd a)))", "apply (insert it_child)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> set kvs;\n        \\<And>kt.\n           kt \\<in> set kvs \\<Longrightarrow>\n           set_iterator (iteratei_postfixed (fst kt # ks0) (snd kt))\n            ((\\<lambda>ksv. (rev (fst ksv) @ fst kt # ks0, snd ksv)) `\n             map_to_set (lookup_trie (snd kt)))\\<rbrakk>\n       \\<Longrightarrow> set_iterator\n                          (case a of\n                           (k, x) \\<Rightarrow>\n                             iteratei_postfixed (k # ks0) x)\n                          ((\\<lambda>ksv.\n                               (rev (fst ksv) @ fst a # ks0, snd ksv)) `\n                           map_to_set (lookup_trie (snd a)))", "apply (simp add: case_prod_beta)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  set_iterator it_prod it_prod_S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set_iterator it_prod it_prod_S\n\ngoal (1 subgoal):\n 1. \\<And>vo kvs ks0.\n       \\<lbrakk>\\<And>k t ks0.\n                   \\<lbrakk>(k, t) \\<in> set kvs; invar_trie t\\<rbrakk>\n                   \\<Longrightarrow> set_iterator (iteratei_postfixed ks0 t)\n((\\<lambda>ksv. (rev (fst ksv) @ ks0, snd ksv)) `\n map_to_set (lookup_trie t));\n        invar_trie (Trie vo kvs)\\<rbrakk>\n       \\<Longrightarrow> set_iterator (iteratei_postfixed ks0 (Trie vo kvs))\n                          ((\\<lambda>ksv. (rev (fst ksv) @ ks0, snd ksv)) `\n                           map_to_set (lookup_trie (Trie vo kvs)))", "have it_image_OK : \"set_iterator (set_iterator_image snd it_prod) (snd ` it_prod_S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator (set_iterator_image snd it_prod) (snd ` it_prod_S)", "proof (rule set_iterator_image_correct[OF it_prod_OK])"], ["proof (state)\ngoal (2 subgoals):\n 1. inj_on snd it_prod_S\n 2. snd ` it_prod_S = snd ` it_prod_S", "from dist_fst_kvs"], ["proof (chain)\npicking this:\n  distinct (map fst kvs)", "have \"\\<And>k v1 v2. (k, v1) \\<in> set kvs \\<Longrightarrow> (k, v2) \\<in> set kvs \\<Longrightarrow> v1 = v2\""], ["proof (prove)\nusing this:\n  distinct (map fst kvs)\n\ngoal (1 subgoal):\n 1. \\<And>k v1 v2.\n       \\<lbrakk>(k, v1) \\<in> set kvs; (k, v2) \\<in> set kvs\\<rbrakk>\n       \\<Longrightarrow> v1 = v2", "by (induct kvs) (auto simp add: image_iff)"], ["proof (state)\nthis:\n  \\<lbrakk>(?k, ?v1.0) \\<in> set kvs; (?k, ?v2.0) \\<in> set kvs\\<rbrakk>\n  \\<Longrightarrow> ?v1.0 = ?v2.0\n\ngoal (2 subgoals):\n 1. inj_on snd it_prod_S\n 2. snd ` it_prod_S = snd ` it_prod_S", "thus \"inj_on snd it_prod_S\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(?k, ?v1.0) \\<in> set kvs; (?k, ?v2.0) \\<in> set kvs\\<rbrakk>\n  \\<Longrightarrow> ?v1.0 = ?v2.0\n\ngoal (1 subgoal):\n 1. inj_on snd it_prod_S", "unfolding inj_on_def it_prod_S_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?k, ?v1.0) \\<in> set kvs; (?k, ?v2.0) \\<in> set kvs\\<rbrakk>\n  \\<Longrightarrow> ?v1.0 = ?v2.0\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>SIGMA kt:set kvs.\n                      (\\<lambda>ksv.\n                          (rev (fst ksv) @ fst kt # ks0, snd ksv)) `\n                      map_to_set (lookup_trie (snd kt)).\n       \\<forall>y\\<in>SIGMA kt:set kvs.\n                         (\\<lambda>ksv.\n                             (rev (fst ksv) @ fst kt # ks0, snd ksv)) `\n                         map_to_set (lookup_trie (snd kt)).\n          snd x = snd y \\<longrightarrow> x = y", "apply (simp add: image_iff Ball_def map_to_set_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k v1 v2.\n        \\<lbrakk>(k, v1) \\<in> set kvs; (k, v2) \\<in> set kvs\\<rbrakk>\n        \\<Longrightarrow> v1 = v2) \\<Longrightarrow>\n    \\<forall>a b aa ba.\n       (a, b) \\<in> set kvs \\<and>\n       (\\<exists>ab.\n           lookup_trie b ab = Some ba \\<and>\n           aa = rev ab @ a # ks0) \\<longrightarrow>\n       (\\<forall>ab bb.\n           (ab, bb) \\<in> set kvs \\<and>\n           (\\<exists>a.\n               lookup_trie bb a = Some ba \\<and>\n               aa = rev a @ ab # ks0) \\<longrightarrow>\n           a = ab \\<and> b = bb)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  inj_on snd it_prod_S\n\ngoal (1 subgoal):\n 1. snd ` it_prod_S = snd ` it_prod_S", "qed auto\n\n  \\<comment> \\<open>overall iterator\\<close>"], ["proof (state)\nthis:\n  set_iterator (set_iterator_image snd it_prod) (snd ` it_prod_S)\n\ngoal (1 subgoal):\n 1. \\<And>vo kvs ks0.\n       \\<lbrakk>\\<And>k t ks0.\n                   \\<lbrakk>(k, t) \\<in> set kvs; invar_trie t\\<rbrakk>\n                   \\<Longrightarrow> set_iterator (iteratei_postfixed ks0 t)\n((\\<lambda>ksv. (rev (fst ksv) @ ks0, snd ksv)) `\n map_to_set (lookup_trie t));\n        invar_trie (Trie vo kvs)\\<rbrakk>\n       \\<Longrightarrow> set_iterator (iteratei_postfixed ks0 (Trie vo kvs))\n                          ((\\<lambda>ksv. (rev (fst ksv) @ ks0, snd ksv)) `\n                           map_to_set (lookup_trie (Trie vo kvs)))", "have it_all_OK: \"set_iterator \n      ((iteratei_postfixed ks0 (Trie vo kvs)):: ('key list \\<times> 'val, '\\<sigma>) set_iterator)\n     (vo_S \\<union> snd ` it_prod_S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator (iteratei_postfixed ks0 (Trie vo kvs))\n     (vo_S \\<union> snd ` it_prod_S)", "unfolding iteratei_postfixed_alt_def \n       it_vo_def[symmetric]\n       it_prod_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator (set_iterator_union it_vo (set_iterator_image snd it_prod))\n     (vo_S \\<union> snd ` it_prod_S)", "proof (rule set_iterator_union_correct [OF it_vo_OK it_image_OK])"], ["proof (state)\ngoal (1 subgoal):\n 1. vo_S \\<inter> snd ` it_prod_S = {}", "show \"vo_S \\<inter> snd ` it_prod_S = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vo_S \\<inter> snd ` it_prod_S = {}", "unfolding vo_S_def it_prod_S_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case vo of None \\<Rightarrow> {}\n     | Some v \\<Rightarrow> {(ks0, v)}) \\<inter>\n    snd `\n    (SIGMA kt:set kvs.\n        (\\<lambda>ksv. (rev (fst ksv) @ fst kt # ks0, snd ksv)) `\n        map_to_set (lookup_trie (snd kt))) =\n    {}", "by (simp split: option.split add: set_eq_iff image_iff)"], ["proof (state)\nthis:\n  vo_S \\<inter> snd ` it_prod_S = {}\n\ngoal:\nNo subgoals!", "qed\n\n  \\<comment> \\<open>rewrite result set\\<close>"], ["proof (state)\nthis:\n  set_iterator (iteratei_postfixed ks0 (Trie vo kvs))\n   (vo_S \\<union> snd ` it_prod_S)\n\ngoal (1 subgoal):\n 1. \\<And>vo kvs ks0.\n       \\<lbrakk>\\<And>k t ks0.\n                   \\<lbrakk>(k, t) \\<in> set kvs; invar_trie t\\<rbrakk>\n                   \\<Longrightarrow> set_iterator (iteratei_postfixed ks0 t)\n((\\<lambda>ksv. (rev (fst ksv) @ ks0, snd ksv)) `\n map_to_set (lookup_trie t));\n        invar_trie (Trie vo kvs)\\<rbrakk>\n       \\<Longrightarrow> set_iterator (iteratei_postfixed ks0 (Trie vo kvs))\n                          ((\\<lambda>ksv. (rev (fst ksv) @ ks0, snd ksv)) `\n                           map_to_set (lookup_trie (Trie vo kvs)))", "have it_set_rewr: \"((\\<lambda>ksv. (rev (fst ksv) @ ks0, snd ksv)) `\n      map_to_set (lookup_trie (Trie vo kvs))) = (vo_S \\<union> snd ` it_prod_S)\"\n    (is \"?ls = ?rs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>ksv. (rev (fst ksv) @ ks0, snd ksv)) `\n    map_to_set (lookup_trie (Trie vo kvs)) =\n    vo_S \\<union> snd ` it_prod_S", "apply (simp add: map_to_set_def lookup_eq_Some_iff[OF invar]\n                     set_eq_iff image_iff vo_S_def it_prod_S_def Ball_def Bex_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a b.\n       (\\<exists>aa.\n           (aa = [] \\<and> vo = Some b \\<or>\n            (\\<exists>k t ks'.\n                aa = k # ks' \\<and>\n                (k, t) \\<in> set kvs \\<and>\n                lookup_trie t ks' = Some b)) \\<and>\n           a = rev aa @ ks0) =\n       ((a, b)\n        \\<in> (case vo of None \\<Rightarrow> {}\n               | Some v \\<Rightarrow> {(ks0, v)}) \\<or>\n        (\\<exists>aa ba.\n            (aa, ba) \\<in> set kvs \\<and>\n            (\\<exists>aaa.\n                lookup_trie ba aaa = Some b \\<and> a = rev aaa @ aa # ks0)))", "apply (simp split: option.split del: ex_simps add: ex_simps[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x2.\n       vo = Some x2 \\<longrightarrow>\n       (\\<forall>a b.\n           (\\<exists>aa k t ks'.\n               (aa = [] \\<and> x2 = b \\<or>\n                aa = k # ks' \\<and>\n                (k, t) \\<in> set kvs \\<and>\n                lookup_trie t ks' = Some b) \\<and>\n               a = rev aa @ ks0) =\n           (\\<exists>aa ba ab.\n               a = ks0 \\<and> b = x2 \\<or>\n               (aa, ba) \\<in> set kvs \\<and>\n               lookup_trie ba ab = Some b \\<and> a = rev ab @ aa # ks0))", "apply (intro allI impI iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x2 a b.\n       \\<lbrakk>vo = Some x2;\n        \\<exists>aa k t ks'.\n           (aa = [] \\<and> x2 = b \\<or>\n            aa = k # ks' \\<and>\n            (k, t) \\<in> set kvs \\<and> lookup_trie t ks' = Some b) \\<and>\n           a = rev aa @ ks0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa ba ab.\n                            a = ks0 \\<and> b = x2 \\<or>\n                            (aa, ba) \\<in> set kvs \\<and>\n                            lookup_trie ba ab = Some b \\<and>\n                            a = rev ab @ aa # ks0\n 2. \\<And>x2 a b.\n       \\<lbrakk>vo = Some x2;\n        \\<exists>aa ba ab.\n           a = ks0 \\<and> b = x2 \\<or>\n           (aa, ba) \\<in> set kvs \\<and>\n           lookup_trie ba ab = Some b \\<and> a = rev ab @ aa # ks0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa k t ks'.\n                            (aa = [] \\<and> x2 = b \\<or>\n                             aa = k # ks' \\<and>\n                             (k, t) \\<in> set kvs \\<and>\n                             lookup_trie t ks' = Some b) \\<and>\n                            a = rev aa @ ks0", "apply auto[]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2 a b.\n       \\<lbrakk>vo = Some x2;\n        \\<exists>aa ba ab.\n           a = ks0 \\<and> b = x2 \\<or>\n           (aa, ba) \\<in> set kvs \\<and>\n           lookup_trie ba ab = Some b \\<and> a = rev ab @ aa # ks0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>aa k t ks'.\n                            (aa = [] \\<and> x2 = b \\<or>\n                             aa = k # ks' \\<and>\n                             (k, t) \\<in> set kvs \\<and>\n                             lookup_trie t ks' = Some b) \\<and>\n                            a = rev aa @ ks0", "apply (metis append_Cons append_Nil append_assoc rev.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done\n    \n  \\<comment> \\<open>done\\<close>"], ["proof (state)\nthis:\n  (\\<lambda>ksv. (rev (fst ksv) @ ks0, snd ksv)) `\n  map_to_set (lookup_trie (Trie vo kvs)) =\n  vo_S \\<union> snd ` it_prod_S\n\ngoal (1 subgoal):\n 1. \\<And>vo kvs ks0.\n       \\<lbrakk>\\<And>k t ks0.\n                   \\<lbrakk>(k, t) \\<in> set kvs; invar_trie t\\<rbrakk>\n                   \\<Longrightarrow> set_iterator (iteratei_postfixed ks0 t)\n((\\<lambda>ksv. (rev (fst ksv) @ ks0, snd ksv)) `\n map_to_set (lookup_trie t));\n        invar_trie (Trie vo kvs)\\<rbrakk>\n       \\<Longrightarrow> set_iterator (iteratei_postfixed ks0 (Trie vo kvs))\n                          ((\\<lambda>ksv. (rev (fst ksv) @ ks0, snd ksv)) `\n                           map_to_set (lookup_trie (Trie vo kvs)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator (iteratei_postfixed ks0 (Trie vo kvs))\n     ((\\<lambda>ksv. (rev (fst ksv) @ ks0, snd ksv)) `\n      map_to_set (lookup_trie (Trie vo kvs)))", "unfolding it_set_rewr"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator (iteratei_postfixed ks0 (Trie vo kvs))\n     (vo_S \\<union> snd ` it_prod_S)", "using it_all_OK"], ["proof (prove)\nusing this:\n  set_iterator (iteratei_postfixed ks0 (Trie vo kvs))\n   (vo_S \\<union> snd ` it_prod_S)\n\ngoal (1 subgoal):\n 1. set_iterator (iteratei_postfixed ks0 (Trie vo kvs))\n     (vo_S \\<union> snd ` it_prod_S)", "by fast"], ["proof (state)\nthis:\n  set_iterator (iteratei_postfixed ks0 (Trie vo kvs))\n   ((\\<lambda>ksv. (rev (fst ksv) @ ks0, snd ksv)) `\n    map_to_set (lookup_trie (Trie vo kvs)))\n\ngoal:\nNo subgoals!", "qed"], ["", "definition trie_reverse_key where\n  \"trie_reverse_key ksv = (rev (fst ksv), (snd ksv))\""], ["", "lemma trie_reverse_key_alt_def[code] :\n  \"trie_reverse_key (ks, v) = (rev ks, v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trie_reverse_key (ks, v) = (rev ks, v)", "unfolding trie_reverse_key_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rev (fst (ks, v)), snd (ks, v)) = (rev ks, v)", "by auto"], ["", "lemma trie_reverse_key_reverse[simp] :\n  \"trie_reverse_key (trie_reverse_key ksv) = ksv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trie_reverse_key (trie_reverse_key ksv) = ksv", "by (simp add: trie_reverse_key_def)"], ["", "lemma trie_iteratei_correct:\n  assumes invar: \"invar_trie (t :: ('key, 'val) trie)\"\n  shows \"set_iterator ((iteratei t)::('key list \\<times> 'val, '\\<sigma>) set_iterator)\n           (trie_reverse_key ` (map_to_set (lookup_trie t)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator (iteratei t)\n     (trie_reverse_key ` map_to_set (lookup_trie t))", "unfolding trie_reverse_key_def[abs_def] iteratei_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator (iteratei_postfixed [] t)\n     ((\\<lambda>ksv. (rev (fst ksv), snd ksv)) ` map_to_set (lookup_trie t))", "using iteratei_postfixed_correct [OF invar, of \"[]\"]"], ["proof (prove)\nusing this:\n  set_iterator (iteratei_postfixed [] t)\n   ((\\<lambda>ksv. (rev (fst ksv) @ [], snd ksv)) `\n    map_to_set (lookup_trie t))\n\ngoal (1 subgoal):\n 1. set_iterator (iteratei_postfixed [] t)\n     ((\\<lambda>ksv. (rev (fst ksv), snd ksv)) ` map_to_set (lookup_trie t))", "by simp"], ["", "hide_const (open) iteratei"], ["", "hide_type (open) trie"], ["", "end"]]}