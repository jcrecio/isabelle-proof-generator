{"file_name": "/home/qj213/afp-2021-10-22/thys/Collections/Userguides/Refine_Monadic_Userguide.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Collections", "problem_names": ["lemma sum_max_invar_step:\n  assumes \"x\\<in>V\" \"sum_max_invar V\\<^sub>0 (V,s,m)\"\n  shows \"sum_max_invar V\\<^sub>0 (V-{x},s+x,max m x)\"", "theorem sum_max_correct:\n  assumes PRE: \"V\\<noteq>{}\" \n  shows \"sum_max V \\<le> SPEC (\\<lambda>(s,m). s=\\<Sum>V \\<and> m=Max V)\"", "theorem sum_max'_correct:\n  assumes NE: \"V\\<noteq>{}\" and FIN: \"finite V\"\n  shows \"sum_max' V \\<le> SPEC (\\<lambda>(s,m). s=\\<Sum>V \\<and> m=Max V)\"", "theorem sum_max_impl_refine: \n  assumes \"(V,V')\\<in>build_rel ls.\\<alpha> ls.invar\" \n  shows \"sum_max_impl V \\<le> \\<Down>Id (sum_max V')\"", "theorem sum_max_impl_correct:\n  assumes \"(V,V')\\<in>build_rel ls.\\<alpha> ls.invar\" and \"V'\\<noteq>{}\"\n  shows \"sum_max_impl V \\<le> SPEC (\\<lambda>(s,m). s=\\<Sum>V' \\<and> m=Max V')\"", "theorem sum_max'_impl_refine: \n  \"(V,V')\\<in>build_rel ls.\\<alpha> ls.invar \\<Longrightarrow> sum_max'_impl V \\<le> \\<Down>Id (sum_max' V')\"", "theorem sum_max'_impl_correct:\n  assumes \"(V,V')\\<in>build_rel ls.\\<alpha> ls.invar\" and \"V'\\<noteq>{}\"\n  shows \"sum_max'_impl V \\<le> SPEC (\\<lambda>(s,m). s=\\<Sum>V' \\<and> m=Max V')\"", "theorem sum_max_code_correct: \n  assumes \"ls.\\<alpha> V \\<noteq> {}\"\n  shows \"sum_max_code V = dRETURN (s,m) \\<Longrightarrow> s=\\<Sum>(ls.\\<alpha> V) \\<and> m=Max (ls.\\<alpha> V)\"\n    and \"sum_max_code V \\<noteq> dFAIL\"", "theorem sum_max'_code_correct: \n  \"\\<lbrakk>ls.\\<alpha> V \\<noteq> {}\\<rbrakk> \\<Longrightarrow> sum_max'_code V = (\\<Sum>(ls.\\<alpha> V), Max (ls.\\<alpha> V))\"", "theorem sum_max''_code_correct: \n  \"\\<lbrakk>ls.\\<alpha> V \\<noteq> {}\\<rbrakk> \\<Longrightarrow> sum_max''_code V = (\\<Sum>(ls.\\<alpha> V), Max (ls.\\<alpha> V))\"", "theorem sum_max_it_correct:\n  assumes PRE: \"V\\<noteq>{}\" and FIN: \"finite V\" \n  shows \"sum_max_it V \\<le> SPEC (\\<lambda>(s,m). s=\\<Sum>V \\<and> m=Max V)\"", "lemma sum_max_it_impl_refine: \n  notes [refine] = inj_on_id\n  assumes \"(V,V')\\<in>build_rel ls.\\<alpha> ls.invar\" \n  shows \"sum_max_it_impl V \\<le> \\<Down>Id (sum_max_it V')\"", "theorem sum_max_it_code_correct: \n  assumes \"ls.\\<alpha> V \\<noteq> {}\" \n  shows \"sum_max_it_code V = (\\<Sum>(ls.\\<alpha> V), Max (ls.\\<alpha> V))\"", "lemma \"do { ASSERT (fst p > 2); SPEC (\\<lambda>x. x\\<le>(2::nat)*(fst p + snd p)) }\n  \\<le> do { let (x,y)=p; z\\<leftarrow>SPEC (\\<lambda>z. z\\<le>x+y); \n          a\\<leftarrow>SPEC (\\<lambda>a. a\\<le>x+y); ASSERT (x>2); RETURN (a+z)}\""], "translations": [["", "lemma sum_max_invar_step:\n  assumes \"x\\<in>V\" \"sum_max_invar V\\<^sub>0 (V,s,m)\"\n  shows \"sum_max_invar V\\<^sub>0 (V-{x},s+x,max m x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_max_invar V\\<^sub>0 (V - {x}, s + x, max m x)", "txt \\<open>In our case the proof is rather straightforward, it only\n    requires the lemma @{thm [source] it_step_insert_iff}, that handles\n    the @{term \"(V\\<^sub>0-(V-{x}))\"} terms that occur in the invariant.\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_max_invar V\\<^sub>0 (V - {x}, s + x, max m x)", "using assms"], ["proof (prove)\nusing this:\n  x \\<in> V\n  sum_max_invar V\\<^sub>0 (V, s, m)\n\ngoal (1 subgoal):\n 1. sum_max_invar V\\<^sub>0 (V - {x}, s + x, max m x)", "unfolding sum_max_invar_def"], ["proof (prove)\nusing this:\n  x \\<in> V\n  case (V, s, m) of\n  (V, s, m) \\<Rightarrow>\n    V \\<subseteq> V\\<^sub>0 \\<and>\n    s = \\<Sum> (V\\<^sub>0 - V) \\<and>\n    m = (if V\\<^sub>0 - V = {} then 0 else Max (V\\<^sub>0 - V)) \\<and>\n    finite (V\\<^sub>0 - V)\n\ngoal (1 subgoal):\n 1. case (V - {x}, s + x, max m x) of\n    (V, s, m) \\<Rightarrow>\n      V \\<subseteq> V\\<^sub>0 \\<and>\n      s = \\<Sum> (V\\<^sub>0 - V) \\<and>\n      m = (if V\\<^sub>0 - V = {} then 0 else Max (V\\<^sub>0 - V)) \\<and>\n      finite (V\\<^sub>0 - V)", "by (auto simp: it_step_insert_iff)"], ["", "text \\<open>\n  The correctness is now proved by first invoking the verification condition\n  generator, and then discharging the verification conditions by \n  \\<open>auto\\<close>. Note that we have to apply the \n  @{thm [source] sum_max_invar_step} lemma, {\\em before} we unfold the \n  definition of the invariant to discharge the remaining verification \n  conditions.\n\\<close>"], ["", "theorem sum_max_correct:\n  assumes PRE: \"V\\<noteq>{}\" \n  shows \"sum_max V \\<le> SPEC (\\<lambda>(s,m). s=\\<Sum>V \\<and> m=Max V)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_max V \\<le> SPEC (\\<lambda>(s, m). s = \\<Sum> V \\<and> m = Max V)", "txt \\<open>\n    The precondition \\<open>V\\<noteq>{}\\<close> is necessary, as the\n    \\<open>Max\\<close>-operator from Isabelle/HOL's standard library is not defined\n    for empty sets.\n\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_max V \\<le> SPEC (\\<lambda>(s, m). s = \\<Sum> V \\<and> m = Max V)", "using PRE"], ["proof (prove)\nusing this:\n  V \\<noteq> {}\n\ngoal (1 subgoal):\n 1. sum_max V \\<le> SPEC (\\<lambda>(s, m). s = \\<Sum> V \\<and> m = Max V)", "unfolding sum_max_def"], ["proof (prove)\nusing this:\n  V \\<noteq> {}\n\ngoal (1 subgoal):\n 1. WHILE (\\<lambda>(V, s, m). V \\<noteq> {})\n     (\\<lambda>(V, s, m).\n         SPEC (\\<lambda>x. x \\<in> V) \\<bind>\n         (\\<lambda>x.\n             let V = V - {x}; s = s + x; m = max m x in RETURN (V, s, m)))\n     (V, 0, 0) \\<bind>\n    (\\<lambda>(uu_, s, m). RETURN (s, m))\n    \\<le> SPEC (\\<lambda>(s, m). s = \\<Sum> V \\<and> m = Max V)", "apply (intro WHILE_rule[where I=\"sum_max_invar V\"] refine_vcg) \\<comment> \\<open>Invoke vcg\\<close>"], ["proof (prove)\ngoal (3 subgoals):\n 1. V \\<noteq> {} \\<Longrightarrow> sum_max_invar V (V, 0, 0)\n 2. \\<And>s a b aa ba x.\n       \\<lbrakk>V \\<noteq> {}; sum_max_invar V s;\n        case s of (V, s, m) \\<Rightarrow> V \\<noteq> {}; s = (a, b);\n        b = (aa, ba); x \\<in> a\\<rbrakk>\n       \\<Longrightarrow> sum_max_invar V (a - {x}, aa + x, max ba x)\n 3. \\<And>s a b aa ba.\n       \\<lbrakk>V \\<noteq> {}; sum_max_invar V s;\n        \\<not> (case s of (V, s, m) \\<Rightarrow> V \\<noteq> {});\n        s = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> case (aa, ba) of\n                         (s, m) \\<Rightarrow> s = \\<Sum> V \\<and> m = Max V", "txt \\<open>Note that we have explicitely instantiated \n    the rule for the while-loop with the invariant. If this is not done,\n    the verification condition generator will stop at the WHILE-loop.\n\\<close>"], ["proof (prove)\ngoal (3 subgoals):\n 1. V \\<noteq> {} \\<Longrightarrow> sum_max_invar V (V, 0, 0)\n 2. \\<And>s a b aa ba x.\n       \\<lbrakk>V \\<noteq> {}; sum_max_invar V s;\n        case s of (V, s, m) \\<Rightarrow> V \\<noteq> {}; s = (a, b);\n        b = (aa, ba); x \\<in> a\\<rbrakk>\n       \\<Longrightarrow> sum_max_invar V (a - {x}, aa + x, max ba x)\n 3. \\<And>s a b aa ba.\n       \\<lbrakk>V \\<noteq> {}; sum_max_invar V s;\n        \\<not> (case s of (V, s, m) \\<Rightarrow> V \\<noteq> {});\n        s = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> case (aa, ba) of\n                         (s, m) \\<Rightarrow> s = \\<Sum> V \\<and> m = Max V", "apply (auto intro: sum_max_invar_step) \\<comment> \\<open>Discharge step\\<close>"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<not> sum_max_invar V (V, 0, 0); x \\<in> V\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>aaa baa x.\n       \\<lbrakk>sum_max_invar V ({}, aaa, baa); x \\<in> V\\<rbrakk>\n       \\<Longrightarrow> aaa = \\<Sum> V\n 3. \\<And>aaa baa x.\n       \\<lbrakk>sum_max_invar V ({}, aaa, baa); x \\<in> V\\<rbrakk>\n       \\<Longrightarrow> baa = Max V", "unfolding sum_max_invar_def \\<comment> \\<open>Unfold invariant definition\\<close>"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<not> (case (V, 0, 0) of\n                        (Va, s, m) \\<Rightarrow>\n                          Va \\<subseteq> V \\<and>\n                          s = \\<Sum> (V - Va) \\<and>\n                          m =\n                          (if V - Va = {} then 0 else Max (V - Va)) \\<and>\n                          finite (V - Va));\n        x \\<in> V\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>aaa baa x.\n       \\<lbrakk>case ({}, aaa, baa) of\n                (Va, s, m) \\<Rightarrow>\n                  Va \\<subseteq> V \\<and>\n                  s = \\<Sum> (V - Va) \\<and>\n                  m = (if V - Va = {} then 0 else Max (V - Va)) \\<and>\n                  finite (V - Va);\n        x \\<in> V\\<rbrakk>\n       \\<Longrightarrow> aaa = \\<Sum> V\n 3. \\<And>aaa baa x.\n       \\<lbrakk>case ({}, aaa, baa) of\n                (Va, s, m) \\<Rightarrow>\n                  Va \\<subseteq> V \\<and>\n                  s = \\<Sum> (V - Va) \\<and>\n                  m = (if V - Va = {} then 0 else Max (V - Va)) \\<and>\n                  finite (V - Va);\n        x \\<in> V\\<rbrakk>\n       \\<Longrightarrow> baa = Max V", "apply (auto) \\<comment> \\<open>Discharge remaining goals\\<close>"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>\n  In this proof, we specified the invariant explicitely.\n  Alternatively, we may annotate the invariant at the while loop,\n  using the syntax @{term \"WHILE\\<^bsup>I\\<^esup> b f \\<sigma>\\<^sub>0\"}. Then, the verification condition\n  generator will use the annotated invariant automatically.\n\\<close>"], ["", "text_raw\\<open>\\paragraph{Total Correctness}\\<close>"], ["", "text \\<open>\n  Now, we reformulate our program to use a total correct while loop,\n  and annotate the invariant at the loop. The invariant is strengthened by\n  stating that the set of elements is finite.\n\\<close>"], ["", "definition \"sum_max'_invar V\\<^sub>0 \\<sigma> \\<equiv> \n  sum_max_invar V\\<^sub>0 \\<sigma> \n  \\<and> (let (V,_,_)=\\<sigma> in finite (V\\<^sub>0-V))\""], ["", "definition sum_max' :: \"nat set \\<Rightarrow> (nat\\<times>nat) nres\" where\n  \"sum_max' V \\<equiv> do {\n    (_,s,m) \\<leftarrow> WHILE\\<^sub>T\\<^bsup>sum_max'_invar V\\<^esup> (\\<lambda>(V,s,m). V\\<noteq>{}) (\\<lambda>(V,s,m). do {\n      x\\<leftarrow>SPEC (\\<lambda>x. x\\<in>V); \n      let V=V-{x};\n      let s=s+x;\n      let m=max m x;\n      RETURN (V,s,m)\n    }) (V,0,0);\n    RETURN (s,m)\n  }\""], ["", "theorem sum_max'_correct:\n  assumes NE: \"V\\<noteq>{}\" and FIN: \"finite V\"\n  shows \"sum_max' V \\<le> SPEC (\\<lambda>(s,m). s=\\<Sum>V \\<and> m=Max V)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_max' V \\<le> SPEC (\\<lambda>(s, m). s = \\<Sum> V \\<and> m = Max V)", "using NE FIN"], ["proof (prove)\nusing this:\n  V \\<noteq> {}\n  finite V\n\ngoal (1 subgoal):\n 1. sum_max' V \\<le> SPEC (\\<lambda>(s, m). s = \\<Sum> V \\<and> m = Max V)", "unfolding sum_max'_def"], ["proof (prove)\nusing this:\n  V \\<noteq> {}\n  finite V\n\ngoal (1 subgoal):\n 1. WHILE\\<^sub>T\\<^bsup>sum_max'_invar V\\<^esup>\n     (\\<lambda>(V, s, m). V \\<noteq> {})\n     (\\<lambda>(V, s, m).\n         SPEC (\\<lambda>x. x \\<in> V) \\<bind>\n         (\\<lambda>x.\n             let V = V - {x}; s = s + x; m = max m x in RETURN (V, s, m)))\n     (V, 0, 0) \\<bind>\n    (\\<lambda>(uu_, s, m). RETURN (s, m))\n    \\<le> SPEC (\\<lambda>(s, m). s = \\<Sum> V \\<and> m = Max V)", "apply (intro refine_vcg) \\<comment> \\<open>Invoke vcg\\<close>"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>V \\<noteq> {}; finite V\\<rbrakk> \\<Longrightarrow> wf ?R3\n 2. \\<lbrakk>V \\<noteq> {}; finite V\\<rbrakk>\n    \\<Longrightarrow> sum_max'_invar V (V, 0, 0)\n 3. \\<And>s a b aa ba x.\n       \\<lbrakk>V \\<noteq> {}; finite V; sum_max'_invar V s;\n        case s of (V, s, m) \\<Rightarrow> V \\<noteq> {}; s = (a, b);\n        b = (aa, ba); x \\<in> a\\<rbrakk>\n       \\<Longrightarrow> sum_max'_invar V (a - {x}, aa + x, max ba x) \\<and>\n                         ((a - {x}, aa + x, max ba x), s) \\<in> ?R3\n 4. \\<And>s a b aa ba.\n       \\<lbrakk>V \\<noteq> {}; finite V; sum_max'_invar V s;\n        \\<not> (case s of (V, s, m) \\<Rightarrow> V \\<noteq> {});\n        s = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> case (aa, ba) of\n                         (s, m) \\<Rightarrow> s = \\<Sum> V \\<and> m = Max V", "txt \\<open>This time, the verification condition generator uses the annotated\n    invariant. Moreover, it leaves us with a variant. We have to specify a \n    well-founded relation, and show that the loop body respects this\n    relation. In our case, the set \\<open>V\\<close> decreases in each step, and\n    is initially finite. We use the relation @{const \"finite_psubset\"} and the\n    @{const \"inv_image\"} combinator from the Isabelle/HOL standard library.\\<close>"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>V \\<noteq> {}; finite V\\<rbrakk> \\<Longrightarrow> wf ?R3\n 2. \\<lbrakk>V \\<noteq> {}; finite V\\<rbrakk>\n    \\<Longrightarrow> sum_max'_invar V (V, 0, 0)\n 3. \\<And>s a b aa ba x.\n       \\<lbrakk>V \\<noteq> {}; finite V; sum_max'_invar V s;\n        case s of (V, s, m) \\<Rightarrow> V \\<noteq> {}; s = (a, b);\n        b = (aa, ba); x \\<in> a\\<rbrakk>\n       \\<Longrightarrow> sum_max'_invar V (a - {x}, aa + x, max ba x) \\<and>\n                         ((a - {x}, aa + x, max ba x), s) \\<in> ?R3\n 4. \\<And>s a b aa ba.\n       \\<lbrakk>V \\<noteq> {}; finite V; sum_max'_invar V s;\n        \\<not> (case s of (V, s, m) \\<Rightarrow> V \\<noteq> {});\n        s = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> case (aa, ba) of\n                         (s, m) \\<Rightarrow> s = \\<Sum> V \\<and> m = Max V", "apply (subgoal_tac \"wf (inv_image finite_psubset fst)\",\n    assumption) \\<comment> \\<open>Instantiate variant\\<close>"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>V \\<noteq> {}; finite V\\<rbrakk>\n    \\<Longrightarrow> wf (inv_image finite_psubset fst)\n 2. \\<lbrakk>V \\<noteq> {}; finite V\\<rbrakk>\n    \\<Longrightarrow> sum_max'_invar V (V, 0, 0)\n 3. \\<And>s a b aa ba x.\n       \\<lbrakk>V \\<noteq> {}; finite V; sum_max'_invar V s;\n        case s of (V, s, m) \\<Rightarrow> V \\<noteq> {}; s = (a, b);\n        b = (aa, ba); x \\<in> a\\<rbrakk>\n       \\<Longrightarrow> sum_max'_invar V (a - {x}, aa + x, max ba x) \\<and>\n                         ((a - {x}, aa + x, max ba x), s)\n                         \\<in> inv_image finite_psubset fst\n 4. \\<And>s a b aa ba.\n       \\<lbrakk>V \\<noteq> {}; finite V; sum_max'_invar V s;\n        \\<not> (case s of (V, s, m) \\<Rightarrow> V \\<noteq> {});\n        s = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> case (aa, ba) of\n                         (s, m) \\<Rightarrow> s = \\<Sum> V \\<and> m = Max V", "apply simp \\<comment> \\<open>Show variant well-founded\\<close>"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>V \\<noteq> {}; finite V\\<rbrakk>\n    \\<Longrightarrow> sum_max'_invar V (V, 0, 0)\n 2. \\<And>s a b aa ba x.\n       \\<lbrakk>V \\<noteq> {}; finite V; sum_max'_invar V s;\n        case s of (V, s, m) \\<Rightarrow> V \\<noteq> {}; s = (a, b);\n        b = (aa, ba); x \\<in> a\\<rbrakk>\n       \\<Longrightarrow> sum_max'_invar V (a - {x}, aa + x, max ba x) \\<and>\n                         ((a - {x}, aa + x, max ba x), s)\n                         \\<in> inv_image finite_psubset fst\n 3. \\<And>s a b aa ba.\n       \\<lbrakk>V \\<noteq> {}; finite V; sum_max'_invar V s;\n        \\<not> (case s of (V, s, m) \\<Rightarrow> V \\<noteq> {});\n        s = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> case (aa, ba) of\n                         (s, m) \\<Rightarrow> s = \\<Sum> V \\<and> m = Max V", "unfolding sum_max'_invar_def \\<comment> \\<open>Unfold definition of invariant\\<close>"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>V \\<noteq> {}; finite V\\<rbrakk>\n    \\<Longrightarrow> sum_max_invar V (V, 0, 0) \\<and>\n                      (let (Va, uu_, uu_) = (V, 0, 0) in finite (V - Va))\n 2. \\<And>s a b aa ba x.\n       \\<lbrakk>V \\<noteq> {}; finite V;\n        sum_max_invar V s \\<and>\n        (let (Va, uu_, uu_) = s in finite (V - Va));\n        case s of (V, s, m) \\<Rightarrow> V \\<noteq> {}; s = (a, b);\n        b = (aa, ba); x \\<in> a\\<rbrakk>\n       \\<Longrightarrow> (sum_max_invar V (a - {x}, aa + x, max ba x) \\<and>\n                          (let (Va, uu_, uu_) = (a - {x}, aa + x, max ba x)\n                           in finite (V - Va))) \\<and>\n                         ((a - {x}, aa + x, max ba x), s)\n                         \\<in> inv_image finite_psubset fst\n 3. \\<And>s a b aa ba.\n       \\<lbrakk>V \\<noteq> {}; finite V;\n        sum_max_invar V s \\<and>\n        (let (Va, uu_, uu_) = s in finite (V - Va));\n        \\<not> (case s of (V, s, m) \\<Rightarrow> V \\<noteq> {});\n        s = (a, b); b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> case (aa, ba) of\n                         (s, m) \\<Rightarrow> s = \\<Sum> V \\<and> m = Max V", "apply (auto intro: sum_max_invar_step) \\<comment> \\<open>Discharge step\\<close>"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>finite V; \\<not> sum_max_invar V (V, 0, 0);\n        x \\<in> V\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>ab aaa baa x xa xb.\n       \\<lbrakk>finite V; sum_max_invar V (ab, aaa, baa); x \\<in> ab;\n        xa \\<in> V; xb \\<in> ab\\<rbrakk>\n       \\<Longrightarrow> finite ab\n 3. \\<And>aaa baa x.\n       \\<lbrakk>finite V; sum_max_invar V ({}, aaa, baa); x \\<in> V\\<rbrakk>\n       \\<Longrightarrow> aaa = \\<Sum> V\n 4. \\<And>aaa baa x.\n       \\<lbrakk>finite V; sum_max_invar V ({}, aaa, baa); x \\<in> V\\<rbrakk>\n       \\<Longrightarrow> baa = Max V", "unfolding sum_max_invar_def \\<comment> \\<open>Unfold definition of invariant completely\\<close>"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>finite V;\n        \\<not> (case (V, 0, 0) of\n                (Va, s, m) \\<Rightarrow>\n                  Va \\<subseteq> V \\<and>\n                  s = \\<Sum> (V - Va) \\<and>\n                  m = (if V - Va = {} then 0 else Max (V - Va)) \\<and>\n                  finite (V - Va));\n        x \\<in> V\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>ab aaa baa x xa xb.\n       \\<lbrakk>finite V;\n        case (ab, aaa, baa) of\n        (Va, s, m) \\<Rightarrow>\n          Va \\<subseteq> V \\<and>\n          s = \\<Sum> (V - Va) \\<and>\n          m = (if V - Va = {} then 0 else Max (V - Va)) \\<and>\n          finite (V - Va);\n        x \\<in> ab; xa \\<in> V; xb \\<in> ab\\<rbrakk>\n       \\<Longrightarrow> finite ab\n 3. \\<And>aaa baa x.\n       \\<lbrakk>finite V;\n        case ({}, aaa, baa) of\n        (Va, s, m) \\<Rightarrow>\n          Va \\<subseteq> V \\<and>\n          s = \\<Sum> (V - Va) \\<and>\n          m = (if V - Va = {} then 0 else Max (V - Va)) \\<and>\n          finite (V - Va);\n        x \\<in> V\\<rbrakk>\n       \\<Longrightarrow> aaa = \\<Sum> V\n 4. \\<And>aaa baa x.\n       \\<lbrakk>finite V;\n        case ({}, aaa, baa) of\n        (Va, s, m) \\<Rightarrow>\n          Va \\<subseteq> V \\<and>\n          s = \\<Sum> (V - Va) \\<and>\n          m = (if V - Va = {} then 0 else Max (V - Va)) \\<and>\n          finite (V - Va);\n        x \\<in> V\\<rbrakk>\n       \\<Longrightarrow> baa = Max V", "apply (auto intro: finite_subset) \\<comment> \\<open>Discharge remaining goals\\<close>"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Refinement\\<close>"], ["", "text \\<open>\n  The next step in the program development is to refine the initial program\n  towards an executable program. This usually involves both, program refinement\n  and data refinement. Program refinement means changing the structure of the \n  program. Usually, some specification statements are replaced by more concrete\n  implementations. Data refinement means changing the used data types towards\n  implementable data types. \n\n  In our example, we implement the set \\<open>V\\<close> with a distinct list,\n  and replace the specification statement @{term \"SPEC (\\<lambda>x. x\\<in>V)\"} by\n  the head operation on distinct lists. For the lists, we use\n  the list-set data structure provided by the Isabelle Collection Framework\n  \\cite{L09_collections,LL10}.\n\n  For this example, we write the refined program ourselves.\n  An automation of this task can be achieved with the automatic refinement tool,\n  which is available as a prototype in Refine-Autoref. Usage examples are in\n  ex/Automatic-Refinement. \n\\<close>"], ["", "definition sum_max_impl :: \"nat ls \\<Rightarrow> (nat\\<times>nat) nres\" where\n  \"sum_max_impl V \\<equiv> do {\n    (_,s,m) \\<leftarrow> WHILE (\\<lambda>(V,s,m). \\<not>ls.isEmpty V) (\\<lambda>(V,s,m). do {\n      x\\<leftarrow>RETURN (the (ls.sel V (\\<lambda>x. True)));\n      let V=ls.delete x V;\n      let s=s+x;\n      let m=max m x;\n      RETURN (V,s,m)\n    }) (V,0,0);\n    RETURN (s,m)\n  }\""], ["", "text \\<open>\n  Note that we replaced the operations on sets by the respective operations\n  on lists (with the naming scheme \\<open>ls.xxx\\<close>). The specification \n  statement was replaced by @{term \"the (ls.sel V (\\<lambda>x. True))\"}, i.e.,\n  selection of an element that satisfies the predicate @{term \"(\\<lambda>x. True)\"}.\n  As @{const \"ls.sel\"} returns an option datatype, we extract the value with\n  @{const \"the\"}. Moreover, we omitted the loop invariant, as we don't need it\n  any more.\n\\<close>"], ["", "text \\<open>\n  Next, we have to show that our concrete pogram actually refines\n  the abstract one.\n\\<close>"], ["", "theorem sum_max_impl_refine: \n  assumes \"(V,V')\\<in>build_rel ls.\\<alpha> ls.invar\" \n  shows \"sum_max_impl V \\<le> \\<Down>Id (sum_max V')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_max_impl V \\<le> \\<Down> Id (sum_max V')", "txt \\<open>\n    Let \\<open>R\\<close> be a\n    {\\em refinement relation\\footnote{Also called coupling invariant.}},\n    that relates concrete and abstract values. \n  \n    Then, the function @{term \"\\<Down>R\"} maps a result-set over abstract values to\n    the greatest result-set over concrete values that is compatible \n    w.r.t.\\ \\<open>R\\<close>. The value @{const \"FAIL\"} is mapped to itself.\n\n    Thus, the proposition @{term \"S \\<le> \\<Down>R S'\"} means, that \\<open>S\\<close> refines\n    \\<open>S'\\<close> w.r.t.\\ \\<open>R\\<close>, i.e., every value in the result of \n    \\<open>S\\<close> can be abstracted to a value in the result of \\<open>S'\\<close>.\n    \n    Usually, the refinement relation consists of an invariant \\<open>I\\<close> and\n    an abstraction function \\<open>\\<alpha>\\<close>. In this case, we may use the\n    @{term \"build_rel I \\<alpha>\"}-function to define the refinement relation.\n    \n    In our example, we assume that the input is in the refinement relation \n    specified by list-sets, and show that the output is in the identity \n    relation. We use the identity here, as we do not change the datatypes of \n    the output.\n\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_max_impl V \\<le> \\<Down> Id (sum_max V')", "txt \\<open>The proof is done automatically by the refinement verification \n    condition generator.\n    Note that the theory \\<open>Collection_Bindings\\<close> sets up all the \n    necessary lemmas to discharge refinement conditions for the collection\n    framework.\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_max_impl V \\<le> \\<Down> Id (sum_max V')", "using assms"], ["proof (prove)\nusing this:\n  (V, V') \\<in> br ls.\\<alpha> ls.invar\n\ngoal (1 subgoal):\n 1. sum_max_impl V \\<le> \\<Down> Id (sum_max V')", "unfolding sum_max_impl_def sum_max_def"], ["proof (prove)\nusing this:\n  (V, V') \\<in> br ls.\\<alpha> ls.invar\n\ngoal (1 subgoal):\n 1. WHILE (\\<lambda>(V, s, m). \\<not> ls.isEmpty V)\n     (\\<lambda>(V, s, m).\n         RETURN (the (ls.sel V (\\<lambda>x. True))) \\<bind>\n         (\\<lambda>x.\n             let V = ls.delete x V; s = s + x; m = max m x\n             in RETURN (V, s, m)))\n     (V, 0, 0) \\<bind>\n    (\\<lambda>(uu_, s, m). RETURN (s, m))\n    \\<le> \\<Down> Id\n           (WHILE (\\<lambda>(V, s, m). V \\<noteq> {})\n             (\\<lambda>(V, s, m).\n                 SPEC (\\<lambda>x. x \\<in> V) \\<bind>\n                 (\\<lambda>x.\n                     let V = V - {x}; s = s + x; m = max m x\n                     in RETURN (V, s, m)))\n             (V', 0, 0) \\<bind>\n            (\\<lambda>(uu_, s, m). RETURN (s, m)))", "apply (refine_rcg) \\<comment> \\<open>Decompose combinators, generate data refinement goals\\<close>"], ["proof (prove)\ngoal (5 subgoals):\n 1. (V, V') \\<in> br ls.\\<alpha> ls.invar \\<Longrightarrow>\n    ((V, 0, 0), V', 0, 0) \\<in> ?R'1\n 2. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>(V, V') \\<in> br ls.\\<alpha> ls.invar; (x, x') \\<in> ?R'1;\n        x2 = (x1a, x2a); x = (x1, x2); x2b = (x1c, x2c);\n        x' = (x1b, x2b)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> ls.isEmpty x1) = (x1b \\<noteq> {})\n 3. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>(V, V') \\<in> br ls.\\<alpha> ls.invar; (x, x') \\<in> ?R'1;\n        case x of (V, s, m) \\<Rightarrow> \\<not> ls.isEmpty V;\n        case x' of (V, s, m) \\<Rightarrow> V \\<noteq> {}; x2 = (x1a, x2a);\n        x' = (x1, x2); x2b = (x1c, x2c); x = (x1b, x2b)\\<rbrakk>\n       \\<Longrightarrow> RETURN (the (ls.sel x1b (\\<lambda>x. True)))\n                         \\<le> SPEC (\\<lambda>x. x \\<in> x1)\n 4. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c xa xb.\n       \\<lbrakk>(V, V') \\<in> br ls.\\<alpha> ls.invar; (x, x') \\<in> ?R'1;\n        case x of (V, s, m) \\<Rightarrow> \\<not> ls.isEmpty V;\n        case x' of (V, s, m) \\<Rightarrow> V \\<noteq> {}; x2 = (x1a, x2a);\n        x' = (x1, x2); x2b = (x1c, x2c); x = (x1b, x2b);\n        (xa, xb) \\<in> nat_rel; xb \\<in> {x. x \\<in> x1}\\<rbrakk>\n       \\<Longrightarrow> ((ls.delete xa x1b, x1c + xa, max x2c xa),\n                          x1 - {xb}, x1a + xb, max x2a xb)\n                         \\<in> ?R'1\n 5. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>(V, V') \\<in> br ls.\\<alpha> ls.invar; (x, x') \\<in> ?R'1;\n        x2 = (x1a, x2a); x' = (x1, x2); x2b = (x1c, x2c);\n        x = (x1b, x2b)\\<rbrakk>\n       \\<Longrightarrow> ((x1c, x2c), x1a, x2a) \\<in> Id", "apply (refine_dref_type) \\<comment> \\<open>Type-based heuristics to instantiate data \n    refinement goals\\<close>"], ["proof (prove)\ngoal (5 subgoals):\n 1. (V, V') \\<in> br ls.\\<alpha> ls.invar \\<Longrightarrow>\n    ((V, 0, 0), V', 0, 0)\n    \\<in> br ls.\\<alpha> ls.invar \\<times>\\<^sub>r\n          nat_rel \\<times>\\<^sub>r nat_rel\n 2. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>(V, V') \\<in> br ls.\\<alpha> ls.invar;\n        (x, x')\n        \\<in> br ls.\\<alpha> ls.invar \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r nat_rel;\n        x2 = (x1a, x2a); x = (x1, x2); x2b = (x1c, x2c);\n        x' = (x1b, x2b)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> ls.isEmpty x1) = (x1b \\<noteq> {})\n 3. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>(V, V') \\<in> br ls.\\<alpha> ls.invar;\n        (x, x')\n        \\<in> br ls.\\<alpha> ls.invar \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r nat_rel;\n        case x of (V, s, m) \\<Rightarrow> \\<not> ls.isEmpty V;\n        case x' of (V, s, m) \\<Rightarrow> V \\<noteq> {}; x2 = (x1a, x2a);\n        x' = (x1, x2); x2b = (x1c, x2c); x = (x1b, x2b)\\<rbrakk>\n       \\<Longrightarrow> RETURN (the (ls.sel x1b (\\<lambda>x. True)))\n                         \\<le> SPEC (\\<lambda>x. x \\<in> x1)\n 4. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c xa xb.\n       \\<lbrakk>(V, V') \\<in> br ls.\\<alpha> ls.invar;\n        (x, x')\n        \\<in> br ls.\\<alpha> ls.invar \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r nat_rel;\n        case x of (V, s, m) \\<Rightarrow> \\<not> ls.isEmpty V;\n        case x' of (V, s, m) \\<Rightarrow> V \\<noteq> {}; x2 = (x1a, x2a);\n        x' = (x1, x2); x2b = (x1c, x2c); x = (x1b, x2b);\n        (xa, xb) \\<in> nat_rel; xb \\<in> {x. x \\<in> x1}\\<rbrakk>\n       \\<Longrightarrow> ((ls.delete xa x1b, x1c + xa, max x2c xa),\n                          x1 - {xb}, x1a + xb, max x2a xb)\n                         \\<in> br ls.\\<alpha> ls.invar \\<times>\\<^sub>r\n                               nat_rel \\<times>\\<^sub>r nat_rel\n 5. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>(V, V') \\<in> br ls.\\<alpha> ls.invar;\n        (x, x')\n        \\<in> br ls.\\<alpha> ls.invar \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r nat_rel;\n        x2 = (x1a, x2a); x' = (x1, x2); x2b = (x1c, x2c);\n        x = (x1b, x2b)\\<rbrakk>\n       \\<Longrightarrow> ((x1c, x2c), x1a, x2a) \\<in> Id", "apply (auto simp add: \n    ls.correct refine_hsimp refine_rel_defs) \\<comment> \\<open>Discharge proof obligations\\<close>"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>\n  Refinement is transitive, so it is easy to show that the concrete\n  program meets the specification.\n\\<close>"], ["", "theorem sum_max_impl_correct:\n  assumes \"(V,V')\\<in>build_rel ls.\\<alpha> ls.invar\" and \"V'\\<noteq>{}\"\n  shows \"sum_max_impl V \\<le> SPEC (\\<lambda>(s,m). s=\\<Sum>V' \\<and> m=Max V')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_max_impl V\n    \\<le> SPEC (\\<lambda>(s, m). s = \\<Sum> V' \\<and> m = Max V')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sum_max_impl V\n    \\<le> SPEC (\\<lambda>(s, m). s = \\<Sum> V' \\<and> m = Max V')", "note sum_max_impl_refine"], ["proof (state)\nthis:\n  (?V, ?V') \\<in> br ls.\\<alpha> ls.invar \\<Longrightarrow>\n  sum_max_impl ?V \\<le> \\<Down> Id (sum_max ?V')\n\ngoal (1 subgoal):\n 1. sum_max_impl V\n    \\<le> SPEC (\\<lambda>(s, m). s = \\<Sum> V' \\<and> m = Max V')", "also"], ["proof (state)\nthis:\n  (?V, ?V') \\<in> br ls.\\<alpha> ls.invar \\<Longrightarrow>\n  sum_max_impl ?V \\<le> \\<Down> Id (sum_max ?V')\n\ngoal (1 subgoal):\n 1. sum_max_impl V\n    \\<le> SPEC (\\<lambda>(s, m). s = \\<Sum> V' \\<and> m = Max V')", "note sum_max_correct"], ["proof (state)\nthis:\n  ?V \\<noteq> {} \\<Longrightarrow>\n  sum_max ?V \\<le> SPEC (\\<lambda>(s, m). s = \\<Sum> ?V \\<and> m = Max ?V)\n\ngoal (1 subgoal):\n 1. sum_max_impl V\n    \\<le> SPEC (\\<lambda>(s, m). s = \\<Sum> V' \\<and> m = Max V')", "finally"], ["proof (chain)\npicking this:\n  \\<lbrakk>(?V2, ?V1) \\<in> br ls.\\<alpha> ls.invar;\n   ?V1 \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> sum_max_impl ?V2\n                    \\<le> SPEC\n                           (\\<lambda>(s, m).\n                               s = \\<Sum> ?V1 \\<and> m = Max ?V1)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?V2, ?V1) \\<in> br ls.\\<alpha> ls.invar;\n   ?V1 \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> sum_max_impl ?V2\n                    \\<le> SPEC\n                           (\\<lambda>(s, m).\n                               s = \\<Sum> ?V1 \\<and> m = Max ?V1)\n\ngoal (1 subgoal):\n 1. sum_max_impl V\n    \\<le> SPEC (\\<lambda>(s, m). s = \\<Sum> V' \\<and> m = Max V')", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?V2, ?V1) \\<in> br ls.\\<alpha> ls.invar;\n   ?V1 \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> sum_max_impl ?V2\n                    \\<le> SPEC\n                           (\\<lambda>(s, m).\n                               s = \\<Sum> ?V1 \\<and> m = Max ?V1)\n  (V, V') \\<in> br ls.\\<alpha> ls.invar\n  V' \\<noteq> {}\n\ngoal (1 subgoal):\n 1. sum_max_impl V\n    \\<le> SPEC (\\<lambda>(s, m). s = \\<Sum> V' \\<and> m = Max V')", "."], ["proof (state)\nthis:\n  sum_max_impl V\n  \\<le> SPEC (\\<lambda>(s, m). s = \\<Sum> V' \\<and> m = Max V')\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  Just for completeness, we also refine the total correct program in the\n  same way. \n\\<close>"], ["", "definition sum_max'_impl :: \"nat ls \\<Rightarrow> (nat\\<times>nat) nres\" where\n  \"sum_max'_impl V \\<equiv> do {\n    (_,s,m) \\<leftarrow> WHILE\\<^sub>T (\\<lambda>(V,s,m). \\<not>ls.isEmpty V) (\\<lambda>(V,s,m). do {\n      x\\<leftarrow>RETURN (the (ls.sel V (\\<lambda>x. True)));\n      let V=ls.delete x V;\n      let s=s+x;\n      let m=max m x;\n      RETURN (V,s,m)\n    }) (V,0,0);\n    RETURN (s,m)\n  }\""], ["", "theorem sum_max'_impl_refine: \n  \"(V,V')\\<in>build_rel ls.\\<alpha> ls.invar \\<Longrightarrow> sum_max'_impl V \\<le> \\<Down>Id (sum_max' V')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (V, V') \\<in> br ls.\\<alpha> ls.invar \\<Longrightarrow>\n    sum_max'_impl V \\<le> \\<Down> Id (sum_max' V')", "unfolding sum_max'_impl_def sum_max'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (V, V') \\<in> br ls.\\<alpha> ls.invar \\<Longrightarrow>\n    WHILE\\<^sub>T (\\<lambda>(V, s, m). \\<not> ls.isEmpty V)\n     (\\<lambda>(V, s, m).\n         RETURN (the (ls.sel V (\\<lambda>x. True))) \\<bind>\n         (\\<lambda>x.\n             let V = ls.delete x V; s = s + x; m = max m x\n             in RETURN (V, s, m)))\n     (V, 0, 0) \\<bind>\n    (\\<lambda>(uu_, s, m). RETURN (s, m))\n    \\<le> \\<Down> Id\n           (WHILE\\<^sub>T\\<^bsup>sum_max'_invar V'\\<^esup>\n             (\\<lambda>(V, s, m). V \\<noteq> {})\n             (\\<lambda>(V, s, m).\n                 SPEC (\\<lambda>x. x \\<in> V) \\<bind>\n                 (\\<lambda>x.\n                     let V = V - {x}; s = s + x; m = max m x\n                     in RETURN (V, s, m)))\n             (V', 0, 0) \\<bind>\n            (\\<lambda>(uu_, s, m). RETURN (s, m)))", "apply refine_rcg"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>(V, V') \\<in> br ls.\\<alpha> ls.invar;\n     sum_max'_invar V' (V', 0, 0)\\<rbrakk>\n    \\<Longrightarrow> ((V, 0, 0), V', 0, 0) \\<in> ?R'\n 2. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>(V, V') \\<in> br ls.\\<alpha> ls.invar; (x, x') \\<in> ?R';\n        sum_max'_invar V' x'; x2 = (x1a, x2a); x = (x1, x2);\n        x2b = (x1c, x2c); x' = (x1b, x2b)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> ls.isEmpty x1) = (x1b \\<noteq> {})\n 3. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>(V, V') \\<in> br ls.\\<alpha> ls.invar; (x, x') \\<in> ?R';\n        case x of (V, s, m) \\<Rightarrow> \\<not> ls.isEmpty V;\n        case x' of (V, s, m) \\<Rightarrow> V \\<noteq> {};\n        sum_max'_invar V' x'; x2 = (x1a, x2a); x' = (x1, x2);\n        x2b = (x1c, x2c); x = (x1b, x2b)\\<rbrakk>\n       \\<Longrightarrow> RETURN (the (ls.sel x1b (\\<lambda>x. True)))\n                         \\<le> SPEC (\\<lambda>x. x \\<in> x1)\n 4. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c xa xb.\n       \\<lbrakk>(V, V') \\<in> br ls.\\<alpha> ls.invar; (x, x') \\<in> ?R';\n        case x of (V, s, m) \\<Rightarrow> \\<not> ls.isEmpty V;\n        case x' of (V, s, m) \\<Rightarrow> V \\<noteq> {};\n        sum_max'_invar V' x'; x2 = (x1a, x2a); x' = (x1, x2);\n        x2b = (x1c, x2c); x = (x1b, x2b); (xa, xb) \\<in> nat_rel;\n        xb \\<in> {x. x \\<in> x1}\\<rbrakk>\n       \\<Longrightarrow> ((ls.delete xa x1b, x1c + xa, max x2c xa),\n                          x1 - {xb}, x1a + xb, max x2a xb)\n                         \\<in> ?R'\n 5. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>(V, V') \\<in> br ls.\\<alpha> ls.invar; (x, x') \\<in> ?R';\n        x2 = (x1a, x2a); x' = (x1, x2); x2b = (x1c, x2c);\n        x = (x1b, x2b)\\<rbrakk>\n       \\<Longrightarrow> ((x1c, x2c), x1a, x2a) \\<in> Id", "apply refine_dref_type"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>(V, V') \\<in> br ls.\\<alpha> ls.invar;\n     sum_max'_invar V' (V', 0, 0)\\<rbrakk>\n    \\<Longrightarrow> ((V, 0, 0), V', 0, 0)\n                      \\<in> br ls.\\<alpha> ls.invar \\<times>\\<^sub>r\n                            nat_rel \\<times>\\<^sub>r nat_rel\n 2. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>(V, V') \\<in> br ls.\\<alpha> ls.invar;\n        (x, x')\n        \\<in> br ls.\\<alpha> ls.invar \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r nat_rel;\n        sum_max'_invar V' x'; x2 = (x1a, x2a); x = (x1, x2);\n        x2b = (x1c, x2c); x' = (x1b, x2b)\\<rbrakk>\n       \\<Longrightarrow> (\\<not> ls.isEmpty x1) = (x1b \\<noteq> {})\n 3. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>(V, V') \\<in> br ls.\\<alpha> ls.invar;\n        (x, x')\n        \\<in> br ls.\\<alpha> ls.invar \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r nat_rel;\n        case x of (V, s, m) \\<Rightarrow> \\<not> ls.isEmpty V;\n        case x' of (V, s, m) \\<Rightarrow> V \\<noteq> {};\n        sum_max'_invar V' x'; x2 = (x1a, x2a); x' = (x1, x2);\n        x2b = (x1c, x2c); x = (x1b, x2b)\\<rbrakk>\n       \\<Longrightarrow> RETURN (the (ls.sel x1b (\\<lambda>x. True)))\n                         \\<le> SPEC (\\<lambda>x. x \\<in> x1)\n 4. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c xa xb.\n       \\<lbrakk>(V, V') \\<in> br ls.\\<alpha> ls.invar;\n        (x, x')\n        \\<in> br ls.\\<alpha> ls.invar \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r nat_rel;\n        case x of (V, s, m) \\<Rightarrow> \\<not> ls.isEmpty V;\n        case x' of (V, s, m) \\<Rightarrow> V \\<noteq> {};\n        sum_max'_invar V' x'; x2 = (x1a, x2a); x' = (x1, x2);\n        x2b = (x1c, x2c); x = (x1b, x2b); (xa, xb) \\<in> nat_rel;\n        xb \\<in> {x. x \\<in> x1}\\<rbrakk>\n       \\<Longrightarrow> ((ls.delete xa x1b, x1c + xa, max x2c xa),\n                          x1 - {xb}, x1a + xb, max x2a xb)\n                         \\<in> br ls.\\<alpha> ls.invar \\<times>\\<^sub>r\n                               nat_rel \\<times>\\<^sub>r nat_rel\n 5. \\<And>x x' x1 x2 x1a x2a x1b x2b x1c x2c.\n       \\<lbrakk>(V, V') \\<in> br ls.\\<alpha> ls.invar;\n        (x, x')\n        \\<in> br ls.\\<alpha> ls.invar \\<times>\\<^sub>r\n              nat_rel \\<times>\\<^sub>r nat_rel;\n        x2 = (x1a, x2a); x' = (x1, x2); x2b = (x1c, x2c);\n        x = (x1b, x2b)\\<rbrakk>\n       \\<Longrightarrow> ((x1c, x2c), x1a, x2a) \\<in> Id", "apply (auto simp: refine_hsimp ls.correct refine_rel_defs)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "theorem sum_max'_impl_correct:\n  assumes \"(V,V')\\<in>build_rel ls.\\<alpha> ls.invar\" and \"V'\\<noteq>{}\"\n  shows \"sum_max'_impl V \\<le> SPEC (\\<lambda>(s,m). s=\\<Sum>V' \\<and> m=Max V')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_max'_impl V\n    \\<le> SPEC (\\<lambda>(s, m). s = \\<Sum> V' \\<and> m = Max V')", "using ref_two_step[OF sum_max'_impl_refine sum_max'_correct] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?V2, ?V1) \\<in> br ls.\\<alpha> ls.invar; ?V1 \\<noteq> {};\n   finite ?V1\\<rbrakk>\n  \\<Longrightarrow> sum_max'_impl ?V2\n                    \\<le> \\<Down> Id\n                           (SPEC\n                             (\\<lambda>(s, m).\n                                 s = \\<Sum> ?V1 \\<and> m = Max ?V1))\n  (V, V') \\<in> br ls.\\<alpha> ls.invar\n  V' \\<noteq> {}\n\ngoal (1 subgoal):\n 1. sum_max'_impl V\n    \\<le> SPEC (\\<lambda>(s, m). s = \\<Sum> V' \\<and> m = Max V')", "txt \\<open>Note that we do not need the finiteness precondition, as list-sets are\n    always finite. However, in order to exploit this, we have to\n    unfold the \\<open>build_rel\\<close> construct, that relates the list-set on\n    the concrete side to the set on the abstract side.\n\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?V2, ?V1) \\<in> br ls.\\<alpha> ls.invar; ?V1 \\<noteq> {};\n   finite ?V1\\<rbrakk>\n  \\<Longrightarrow> sum_max'_impl ?V2\n                    \\<le> \\<Down> Id\n                           (SPEC\n                             (\\<lambda>(s, m).\n                                 s = \\<Sum> ?V1 \\<and> m = Max ?V1))\n  (V, V') \\<in> br ls.\\<alpha> ls.invar\n  V' \\<noteq> {}\n\ngoal (1 subgoal):\n 1. sum_max'_impl V\n    \\<le> SPEC (\\<lambda>(s, m). s = \\<Sum> V' \\<and> m = Max V')", "apply (auto simp: build_rel_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Code Generation\\<close>"], ["", "text \\<open>\n  In order to generate code from the above definitions,\n  we convert the function defined in our monad to an ordinary, deterministic\n  function, for that the Isabelle/HOL code generator can generate code.\n\n  For partial correct algorithms, we can generate code inside a deterministic\n  result monad. The domain of this monad is a flat complete lattice, where\n  top means a failed assertion and bottom means nontermination. (Note that \n  executing a function in this monad will never return bottom, \n  but just diverge).\n  The construct @{term \"nres_of x\"} embeds the deterministic into the\n  nondeterministic monad. \n\n  Thus, we have to construct a function \\<open>?sum_max_code\\<close> such that:\n\\<close>"], ["", "schematic_goal sum_max_code_aux: \"nres_of ?sum_max_code \\<le> sum_max_impl V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nres_of ?sum_max_code \\<le> sum_max_impl V", "txt \\<open>This is done automatically by the transfer procedure of\n    our framework.\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. nres_of ?sum_max_code \\<le> sum_max_impl V", "unfolding sum_max_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nres_of ?sum_max_code\n    \\<le> WHILE (\\<lambda>(V, s, m). \\<not> ls.isEmpty V)\n           (\\<lambda>(V, s, m).\n               RETURN (the (ls.sel V (\\<lambda>x. True))) \\<bind>\n               (\\<lambda>x.\n                   let V = ls.delete x V; s = s + x; m = max m x\n                   in RETURN (V, s, m)))\n           (V, 0, 0) \\<bind>\n          (\\<lambda>(uu_, s, m). RETURN (s, m))", "apply (refine_transfer)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>\n  In order to define the function from the above lemma, we can use the\n  command \\<open>concrete_definition\\<close>, that is provided by our framework:\n\\<close>"], ["", "concrete_definition sum_max_code for V uses sum_max_code_aux"], ["", "text \\<open>This defines a new constant \\<open>sum_max_code\\<close>:\\<close>"], ["", "thm sum_max_code_def"], ["", "text \\<open>And proves the appropriate refinement lemma:\\<close>"], ["", "thm sum_max_code.refine"], ["", "text \\<open>Note that the \\<open>concrete_definition\\<close> command is sensitive to\n  patterns of the form \\<open>RETURN _\\<close> and \\<open>nres_of\\<close>, in which case\n  the defined constant will not contain the \\<open>RETURN\\<close> \n  or \\<open>nres_of\\<close>. In any other case, the defined constant will just be \n  the left hand side of the refinement statement.\n\\<close>"], ["", "text \\<open>Finally, we can prove a correctness statement that is independent\n  from our refinement framework:\\<close>"], ["", "theorem sum_max_code_correct: \n  assumes \"ls.\\<alpha> V \\<noteq> {}\"\n  shows \"sum_max_code V = dRETURN (s,m) \\<Longrightarrow> s=\\<Sum>(ls.\\<alpha> V) \\<and> m=Max (ls.\\<alpha> V)\"\n    and \"sum_max_code V \\<noteq> dFAIL\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sum_max_code V = dRETURN (s, m) \\<Longrightarrow>\n     s = \\<Sum> (ls.\\<alpha> V) \\<and> m = Max (ls.\\<alpha> V)) &&&\n    sum_max_code V \\<noteq> dFAIL", "txt \\<open>The proof is done by transitivity, and unfolding some \n    definitions:\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (sum_max_code V = dRETURN (s, m) \\<Longrightarrow>\n     s = \\<Sum> (ls.\\<alpha> V) \\<and> m = Max (ls.\\<alpha> V)) &&&\n    sum_max_code V \\<noteq> dFAIL", "using nres_correctD[OF order_trans[OF sum_max_code.refine sum_max_impl_correct,\n    of V \"ls.\\<alpha> V\"]] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>(V, ls.\\<alpha> V) \\<in> br ls.\\<alpha> ls.invar;\n   ls.\\<alpha> V \\<noteq> {}; sum_max_code V = dRETURN ?x\\<rbrakk>\n  \\<Longrightarrow> case ?x of\n                    (s, m) \\<Rightarrow>\n                      s = \\<Sum> (ls.\\<alpha> V) \\<and>\n                      m = Max (ls.\\<alpha> V)\n  \\<lbrakk>(V, ls.\\<alpha> V) \\<in> br ls.\\<alpha> ls.invar;\n   ls.\\<alpha> V \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> sum_max_code V \\<noteq> dFAIL\n  ls.\\<alpha> V \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (sum_max_code V = dRETURN (s, m) \\<Longrightarrow>\n     s = \\<Sum> (ls.\\<alpha> V) \\<and> m = Max (ls.\\<alpha> V)) &&&\n    sum_max_code V \\<noteq> dFAIL", "by (auto simp: refine_rel_defs)"], ["", "text \\<open>For total correctness, the approach is the same. The \n  only difference is, that we use @{const \"RETURN\"} instead \n  of @{const \"nres_of\"}:\\<close>"], ["", "schematic_goal sum_max'_code_aux: \n  \"RETURN ?sum_max'_code \\<le> sum_max'_impl V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?sum_max'_code \\<le> sum_max'_impl V", "unfolding sum_max'_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?sum_max'_code\n    \\<le> WHILE\\<^sub>T (\\<lambda>(V, s, m). \\<not> ls.isEmpty V)\n           (\\<lambda>(V, s, m).\n               RETURN (the (ls.sel V (\\<lambda>x. True))) \\<bind>\n               (\\<lambda>x.\n                   let V = ls.delete x V; s = s + x; m = max m x\n                   in RETURN (V, s, m)))\n           (V, 0, 0) \\<bind>\n          (\\<lambda>(uu_, s, m). RETURN (s, m))", "apply (refine_transfer)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "concrete_definition sum_max'_code for V uses sum_max'_code_aux"], ["", "theorem sum_max'_code_correct: \n  \"\\<lbrakk>ls.\\<alpha> V \\<noteq> {}\\<rbrakk> \\<Longrightarrow> sum_max'_code V = (\\<Sum>(ls.\\<alpha> V), Max (ls.\\<alpha> V))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ls.\\<alpha> V \\<noteq> {} \\<Longrightarrow>\n    sum_max'_code V = (\\<Sum> (ls.\\<alpha> V), Max (ls.\\<alpha> V))", "using order_trans[OF sum_max'_code.refine sum_max'_impl_correct,\n    of V \"ls.\\<alpha> V\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>(V, ls.\\<alpha> V) \\<in> br ls.\\<alpha> ls.invar;\n   ls.\\<alpha> V \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> RETURN (sum_max'_code V)\n                    \\<le> SPEC\n                           (\\<lambda>(s, m).\n                               s = \\<Sum> (ls.\\<alpha> V) \\<and>\n                               m = Max (ls.\\<alpha> V))\n\ngoal (1 subgoal):\n 1. ls.\\<alpha> V \\<noteq> {} \\<Longrightarrow>\n    sum_max'_code V = (\\<Sum> (ls.\\<alpha> V), Max (ls.\\<alpha> V))", "by (auto simp: refine_rel_defs)"], ["", "text \\<open>\n  If we use recursion combinators, a plain function can only be generated,\n  if the recursion combinators can be defined. Alternatively, for total correct\n  programs, we may generate a (plain) function that internally uses the \n  deterministic monad, and then extracts the result.\n\\<close>"], ["", "schematic_goal sum_max''_code_aux: \n  \"RETURN ?sum_max''_code \\<le> sum_max'_impl V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?sum_max''_code \\<le> sum_max'_impl V", "unfolding sum_max'_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?sum_max''_code\n    \\<le> WHILE\\<^sub>T (\\<lambda>(V, s, m). \\<not> ls.isEmpty V)\n           (\\<lambda>(V, s, m).\n               RETURN (the (ls.sel V (\\<lambda>x. True))) \\<bind>\n               (\\<lambda>x.\n                   let V = ls.delete x V; s = s + x; m = max m x\n                   in RETURN (V, s, m)))\n           (V, 0, 0) \\<bind>\n          (\\<lambda>(uu_, s, m). RETURN (s, m))", "apply (refine_transfer the_resI) \\<comment> \\<open>Using @{text \"the_resI\"} for internal monad and result extraction\\<close>"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "concrete_definition sum_max''_code for V uses sum_max''_code_aux"], ["", "theorem sum_max''_code_correct: \n  \"\\<lbrakk>ls.\\<alpha> V \\<noteq> {}\\<rbrakk> \\<Longrightarrow> sum_max''_code V = (\\<Sum>(ls.\\<alpha> V), Max (ls.\\<alpha> V))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ls.\\<alpha> V \\<noteq> {} \\<Longrightarrow>\n    sum_max''_code V = (\\<Sum> (ls.\\<alpha> V), Max (ls.\\<alpha> V))", "using order_trans[OF sum_max''_code.refine sum_max'_impl_correct,\n    of V \"ls.\\<alpha> V\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>(V, ls.\\<alpha> V) \\<in> br ls.\\<alpha> ls.invar;\n   ls.\\<alpha> V \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> RETURN (sum_max''_code V)\n                    \\<le> SPEC\n                           (\\<lambda>(s, m).\n                               s = \\<Sum> (ls.\\<alpha> V) \\<and>\n                               m = Max (ls.\\<alpha> V))\n\ngoal (1 subgoal):\n 1. ls.\\<alpha> V \\<noteq> {} \\<Longrightarrow>\n    sum_max''_code V = (\\<Sum> (ls.\\<alpha> V), Max (ls.\\<alpha> V))", "by (auto simp: refine_rel_defs)"], ["", "text \\<open>Now, we can generate verified code with the Isabelle/HOL code\n  generator:\\<close>"], ["", "export_code sum_max_code sum_max'_code sum_max''_code checking SML"], ["", "export_code sum_max_code sum_max'_code sum_max''_code checking OCaml?"], ["", "export_code sum_max_code sum_max'_code sum_max''_code checking Haskell?"], ["", "export_code sum_max_code sum_max'_code sum_max''_code checking Scala"], ["", "subsection \\<open>Foreach-Loops\\<close>"], ["", "text \\<open>\n  In the \\<open>sum_max\\<close> example above, we used a while-loop to iterate over\n  the elements of a set. As this pattern is used commonly, there is\n  an abbreviation for it in the refinement framework. The construct \n  @{term \"FOREACH S f \\<sigma>\\<^sub>0\"} iterates \\<open>f::'x\\<Rightarrow>'s\\<Rightarrow>'s\\<close> for each element \n  in \\<open>S::'x set\\<close>, starting with state \\<open>\\<sigma>\\<^sub>0::'s\\<close>.\n  \n  With foreach-loops, we could have written our example as follows:\n\\<close>"], ["", "definition sum_max_it :: \"nat set \\<Rightarrow> (nat\\<times>nat) nres\" where\n  \"sum_max_it V \\<equiv> FOREACH V (\\<lambda>x (s,m). RETURN (s+x,max m x)) (0,0)\""], ["", "theorem sum_max_it_correct:\n  assumes PRE: \"V\\<noteq>{}\" and FIN: \"finite V\" \n  shows \"sum_max_it V \\<le> SPEC (\\<lambda>(s,m). s=\\<Sum>V \\<and> m=Max V)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_max_it V \\<le> SPEC (\\<lambda>(s, m). s = \\<Sum> V \\<and> m = Max V)", "using PRE"], ["proof (prove)\nusing this:\n  V \\<noteq> {}\n\ngoal (1 subgoal):\n 1. sum_max_it V \\<le> SPEC (\\<lambda>(s, m). s = \\<Sum> V \\<and> m = Max V)", "unfolding sum_max_it_def"], ["proof (prove)\nusing this:\n  V \\<noteq> {}\n\ngoal (1 subgoal):\n 1. FOREACH V (\\<lambda>x (s, m). RETURN (s + x, max m x)) (0, 0)\n    \\<le> SPEC (\\<lambda>(s, m). s = \\<Sum> V \\<and> m = Max V)", "apply (intro FOREACH_rule[where I=\"\\<lambda>it \\<sigma>. sum_max_invar V (it,\\<sigma>)\"] refine_vcg)"], ["proof (prove)\ngoal (4 subgoals):\n 1. V \\<noteq> {} \\<Longrightarrow> finite V\n 2. V \\<noteq> {} \\<Longrightarrow> sum_max_invar V (V, 0, 0)\n 3. \\<And>x it \\<sigma> a b.\n       \\<lbrakk>V \\<noteq> {}; x \\<in> it; it \\<subseteq> V;\n        sum_max_invar V (it, \\<sigma>); \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> sum_max_invar V (it - {x}, a + x, max b x)\n 4. \\<And>\\<sigma>.\n       \\<lbrakk>V \\<noteq> {}; sum_max_invar V ({}, \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> case \\<sigma> of\n                         (s, m) \\<Rightarrow> s = \\<Sum> V \\<and> m = Max V", "apply (rule FIN) \\<comment> \\<open>Discharge finiteness of iterated set\\<close>"], ["proof (prove)\ngoal (3 subgoals):\n 1. V \\<noteq> {} \\<Longrightarrow> sum_max_invar V (V, 0, 0)\n 2. \\<And>x it \\<sigma> a b.\n       \\<lbrakk>V \\<noteq> {}; x \\<in> it; it \\<subseteq> V;\n        sum_max_invar V (it, \\<sigma>); \\<sigma> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> sum_max_invar V (it - {x}, a + x, max b x)\n 3. \\<And>\\<sigma>.\n       \\<lbrakk>V \\<noteq> {}; sum_max_invar V ({}, \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> case \\<sigma> of\n                         (s, m) \\<Rightarrow> s = \\<Sum> V \\<and> m = Max V", "apply (auto intro: sum_max_invar_step) \\<comment> \\<open>Discharge step\\<close>"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<not> sum_max_invar V (V, 0, 0); x \\<in> V\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a b x.\n       \\<lbrakk>sum_max_invar V ({}, a, b); x \\<in> V\\<rbrakk>\n       \\<Longrightarrow> a = \\<Sum> V\n 3. \\<And>a b x.\n       \\<lbrakk>sum_max_invar V ({}, a, b); x \\<in> V\\<rbrakk>\n       \\<Longrightarrow> b = Max V", "unfolding sum_max_invar_def \\<comment> \\<open>Unfold invariant definition\\<close>"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<not> (case (V, 0, 0) of\n                        (Va, s, m) \\<Rightarrow>\n                          Va \\<subseteq> V \\<and>\n                          s = \\<Sum> (V - Va) \\<and>\n                          m =\n                          (if V - Va = {} then 0 else Max (V - Va)) \\<and>\n                          finite (V - Va));\n        x \\<in> V\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a b x.\n       \\<lbrakk>case ({}, a, b) of\n                (Va, s, m) \\<Rightarrow>\n                  Va \\<subseteq> V \\<and>\n                  s = \\<Sum> (V - Va) \\<and>\n                  m = (if V - Va = {} then 0 else Max (V - Va)) \\<and>\n                  finite (V - Va);\n        x \\<in> V\\<rbrakk>\n       \\<Longrightarrow> a = \\<Sum> V\n 3. \\<And>a b x.\n       \\<lbrakk>case ({}, a, b) of\n                (Va, s, m) \\<Rightarrow>\n                  Va \\<subseteq> V \\<and>\n                  s = \\<Sum> (V - Va) \\<and>\n                  m = (if V - Va = {} then 0 else Max (V - Va)) \\<and>\n                  finite (V - Va);\n        x \\<in> V\\<rbrakk>\n       \\<Longrightarrow> b = Max V", "apply (auto) \\<comment> \\<open>Discharge remaining goals\\<close>"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition sum_max_it_impl :: \"nat ls \\<Rightarrow> (nat\\<times>nat) nres\" where\n  \"sum_max_it_impl V \\<equiv> FOREACH (ls.\\<alpha> V) (\\<lambda>x (s,m). RETURN (s+x,max m x)) (0,0)\""], ["", "text \\<open>Note: The nondeterminism for iterators is currently resolved at\n  transfer phase, where they are replaced by iterators from the ICF.\\<close>"], ["", "lemma sum_max_it_impl_refine: \n  notes [refine] = inj_on_id\n  assumes \"(V,V')\\<in>build_rel ls.\\<alpha> ls.invar\" \n  shows \"sum_max_it_impl V \\<le> \\<Down>Id (sum_max_it V')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_max_it_impl V \\<le> \\<Down> Id (sum_max_it V')", "unfolding sum_max_it_impl_def sum_max_it_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH (ls.\\<alpha> V) (\\<lambda>x (s, m). RETURN (s + x, max m x))\n     (0, 0)\n    \\<le> \\<Down> Id\n           (FOREACH V' (\\<lambda>x (s, m). RETURN (s + x, max m x)) (0, 0))", "txt \\<open>Note that we specified \\<open>inj_on_id\\<close> as additional introduction \n    rule. This is due to the very general iterator refinement rule, that may\n    also change the set over that is iterated.\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. FOREACH (ls.\\<alpha> V) (\\<lambda>x (s, m). RETURN (s + x, max m x))\n     (0, 0)\n    \\<le> \\<Down> Id\n           (FOREACH V' (\\<lambda>x (s, m). RETURN (s + x, max m x)) (0, 0))", "using assms"], ["proof (prove)\nusing this:\n  (V, V') \\<in> br ls.\\<alpha> ls.invar\n\ngoal (1 subgoal):\n 1. FOREACH (ls.\\<alpha> V) (\\<lambda>x (s, m). RETURN (s + x, max m x))\n     (0, 0)\n    \\<le> \\<Down> Id\n           (FOREACH V' (\\<lambda>x (s, m). RETURN (s + x, max m x)) (0, 0))", "apply refine_rcg \\<comment> \\<open>This time, we don't need the \n    @{text \"refine_dref_type\"} heuristics, as no schematic refinement \n    relations are generated.\\<close>"], ["proof (prove)\ngoal (3 subgoals):\n 1. (V, V') \\<in> br ls.\\<alpha> ls.invar \\<Longrightarrow>\n    V' = id ` ls.\\<alpha> V\n 2. (V, V') \\<in> br ls.\\<alpha> ls.invar \\<Longrightarrow>\n    ((0, 0), 0, 0) \\<in> Id\n 3. \\<And>x it \\<sigma> x' it' \\<sigma>' x1 x2 x1a x2a.\n       \\<lbrakk>(V, V') \\<in> br ls.\\<alpha> ls.invar; x' = id x;\n        x \\<in> it; x' \\<in> it'; it' = id ` it;\n        it \\<subseteq> ls.\\<alpha> V; it' \\<subseteq> V';\n        (\\<sigma>, \\<sigma>') \\<in> Id; \\<sigma>' = (x1, x2);\n        \\<sigma> = (x1a, x2a)\\<rbrakk>\n       \\<Longrightarrow> ((x1a + x, max x2a x), x1 + x', max x2 x') \\<in> Id", "apply (auto simp: refine_hsimp refine_rel_defs)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "schematic_goal sum_max_it_code_aux: \n  \"RETURN ?sum_max_it_code \\<le> sum_max_it_impl V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?sum_max_it_code \\<le> sum_max_it_impl V", "unfolding sum_max_it_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?sum_max_it_code\n    \\<le> FOREACH (ls.\\<alpha> V)\n           (\\<lambda>x (s, m). RETURN (s + x, max m x)) (0, 0)", "apply (refine_transfer)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Note that the transfer method has replaced the iterator by an iterator\n  from the Isabelle Collection Framework.\\<close>"], ["", "thm sum_max_it_code_aux"], ["", "concrete_definition sum_max_it_code for V uses sum_max_it_code_aux"], ["", "theorem sum_max_it_code_correct: \n  assumes \"ls.\\<alpha> V \\<noteq> {}\" \n  shows \"sum_max_it_code V = (\\<Sum>(ls.\\<alpha> V), Max (ls.\\<alpha> V))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_max_it_code V = (\\<Sum> (ls.\\<alpha> V), Max (ls.\\<alpha> V))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sum_max_it_code V = (\\<Sum> (ls.\\<alpha> V), Max (ls.\\<alpha> V))", "note sum_max_it_code.refine[of V]"], ["proof (state)\nthis:\n  RETURN (sum_max_it_code V) \\<le> sum_max_it_impl V\n\ngoal (1 subgoal):\n 1. sum_max_it_code V = (\\<Sum> (ls.\\<alpha> V), Max (ls.\\<alpha> V))", "also"], ["proof (state)\nthis:\n  RETURN (sum_max_it_code V) \\<le> sum_max_it_impl V\n\ngoal (1 subgoal):\n 1. sum_max_it_code V = (\\<Sum> (ls.\\<alpha> V), Max (ls.\\<alpha> V))", "note sum_max_it_impl_refine[of V \"ls.\\<alpha> V\"]"], ["proof (state)\nthis:\n  (V, ls.\\<alpha> V) \\<in> br ls.\\<alpha> ls.invar \\<Longrightarrow>\n  sum_max_it_impl V \\<le> \\<Down> Id (sum_max_it (ls.\\<alpha> V))\n\ngoal (1 subgoal):\n 1. sum_max_it_code V = (\\<Sum> (ls.\\<alpha> V), Max (ls.\\<alpha> V))", "also"], ["proof (state)\nthis:\n  (V, ls.\\<alpha> V) \\<in> br ls.\\<alpha> ls.invar \\<Longrightarrow>\n  sum_max_it_impl V \\<le> \\<Down> Id (sum_max_it (ls.\\<alpha> V))\n\ngoal (1 subgoal):\n 1. sum_max_it_code V = (\\<Sum> (ls.\\<alpha> V), Max (ls.\\<alpha> V))", "note sum_max_it_correct"], ["proof (state)\nthis:\n  \\<lbrakk>?V \\<noteq> {}; finite ?V\\<rbrakk>\n  \\<Longrightarrow> sum_max_it ?V\n                    \\<le> SPEC\n                           (\\<lambda>(s, m).\n                               s = \\<Sum> ?V \\<and> m = Max ?V)\n\ngoal (1 subgoal):\n 1. sum_max_it_code V = (\\<Sum> (ls.\\<alpha> V), Max (ls.\\<alpha> V))", "finally"], ["proof (chain)\npicking this:\n  \\<lbrakk>(V, ls.\\<alpha> V) \\<in> br ls.\\<alpha> ls.invar;\n   ls.\\<alpha> V \\<noteq> {}; finite (ls.\\<alpha> V)\\<rbrakk>\n  \\<Longrightarrow> RETURN (sum_max_it_code V)\n                    \\<le> SPEC\n                           (\\<lambda>(s, m).\n                               s = \\<Sum> (ls.\\<alpha> V) \\<and>\n                               m = Max (ls.\\<alpha> V))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>(V, ls.\\<alpha> V) \\<in> br ls.\\<alpha> ls.invar;\n   ls.\\<alpha> V \\<noteq> {}; finite (ls.\\<alpha> V)\\<rbrakk>\n  \\<Longrightarrow> RETURN (sum_max_it_code V)\n                    \\<le> SPEC\n                           (\\<lambda>(s, m).\n                               s = \\<Sum> (ls.\\<alpha> V) \\<and>\n                               m = Max (ls.\\<alpha> V))\n\ngoal (1 subgoal):\n 1. sum_max_it_code V = (\\<Sum> (ls.\\<alpha> V), Max (ls.\\<alpha> V))", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>(V, ls.\\<alpha> V) \\<in> br ls.\\<alpha> ls.invar;\n   ls.\\<alpha> V \\<noteq> {}; finite (ls.\\<alpha> V)\\<rbrakk>\n  \\<Longrightarrow> RETURN (sum_max_it_code V)\n                    \\<le> SPEC\n                           (\\<lambda>(s, m).\n                               s = \\<Sum> (ls.\\<alpha> V) \\<and>\n                               m = Max (ls.\\<alpha> V))\n  ls.\\<alpha> V \\<noteq> {}\n\ngoal (1 subgoal):\n 1. sum_max_it_code V = (\\<Sum> (ls.\\<alpha> V), Max (ls.\\<alpha> V))", "by (auto simp: refine_rel_defs)"], ["proof (state)\nthis:\n  sum_max_it_code V = (\\<Sum> (ls.\\<alpha> V), Max (ls.\\<alpha> V))\n\ngoal:\nNo subgoals!", "qed"], ["", "export_code sum_max_it_code checking SML"], ["", "export_code sum_max_it_code checking OCaml?"], ["", "export_code sum_max_it_code checking Haskell?"], ["", "export_code sum_max_it_code checking Scala"], ["", "definition \"sum_max_it_list \\<equiv> sum_max_it_code o ls.from_list\""], ["", "ML_val \\<open>\n  @{code sum_max_it_list} (map @{code nat_of_integer} [1,2,3,4,5])\n\\<close>"], ["", "section \\<open>Pointwise Reasoning\\<close>"], ["", "text \\<open>\n  In this section, we describe how to use pointwise reasoning to prove\n  refinement statements and other relations between element of the \n  nondeterminism monad.\n\n  Pointwise reasoning is often a powerful tool to show refinement between\n  structurally different program fragments.\n\\<close>"], ["", "text \\<open>\n  The refinement framework defines the predicates \n  @{const \"nofail\"} and @{const \"inres\"}.\n  @{term \"nofail S\"} states that \\<open>S\\<close> does not fail,\n  and @{term \"inres S x\"} states that one possible result of \\<open>S\\<close> is\n  \\<open>x\\<close> (Note that this includes the case that \\<open>S\\<close> fails).\n\n  Equality and refinement can be stated using @{const \"nofail\"} and \n  @{const \"inres\"}:\n  @{thm [display] pw_eq_iff}\n  @{thm [display] pw_le_iff}\n\n  Useful corollaries of this lemma are \n  @{thm [source] pw_leI}, @{thm [source] pw_eqI}, and @{thm [source] pwD}.\n\n  Once a refinement has been expressed via nofail/inres, the simplifier can be\n  used to propagate the nofail and inres predicates inwards over the structure\n  of the program. The relevant lemmas are contained in the named theorem \n  collection \\<open>refine_pw_simps\\<close>.\n\n  As an example, we show refinement of two structurally different programs here,\n  both returning some value in a certain range:\n\\<close>"], ["", "lemma \"do { ASSERT (fst p > 2); SPEC (\\<lambda>x. x\\<le>(2::nat)*(fst p + snd p)) }\n  \\<le> do { let (x,y)=p; z\\<leftarrow>SPEC (\\<lambda>z. z\\<le>x+y); \n          a\\<leftarrow>SPEC (\\<lambda>a. a\\<le>x+y); ASSERT (x>2); RETURN (a+z)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ASSERT (2 < fst p) \\<bind>\n    (\\<lambda>_. SPEC (\\<lambda>x. x \\<le> 2 * (fst p + snd p)))\n    \\<le> (let (x, y) = p\n           in SPEC (\\<lambda>z. z \\<le> x + y) \\<bind>\n              (\\<lambda>z.\n                  SPEC (\\<lambda>a. a \\<le> x + y) \\<bind>\n                  (\\<lambda>a.\n                      ASSERT (2 < x) \\<bind> (\\<lambda>_. RETURN (a + z)))))", "apply (rule pw_leI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. nofail\n     (let (x, y) = p\n      in SPEC (\\<lambda>z. z \\<le> x + y) \\<bind>\n         (\\<lambda>z.\n             SPEC (\\<lambda>a. a \\<le> x + y) \\<bind>\n             (\\<lambda>a.\n                 ASSERT (2 < x) \\<bind>\n                 (\\<lambda>_. RETURN (a + z))))) \\<longrightarrow>\n    nofail\n     (ASSERT (2 < fst p) \\<bind>\n      (\\<lambda>_. SPEC (\\<lambda>x. x \\<le> 2 * (fst p + snd p)))) \\<and>\n    (\\<forall>x.\n        inres\n         (ASSERT (2 < fst p) \\<bind>\n          (\\<lambda>_. SPEC (\\<lambda>x. x \\<le> 2 * (fst p + snd p))))\n         x \\<longrightarrow>\n        inres\n         (let (x, y) = p\n          in SPEC (\\<lambda>z. z \\<le> x + y) \\<bind>\n             (\\<lambda>z.\n                 SPEC (\\<lambda>a. a \\<le> x + y) \\<bind>\n                 (\\<lambda>a.\n                     ASSERT (2 < x) \\<bind> (\\<lambda>_. RETURN (a + z)))))\n         x)", "apply (auto simp add: refine_pw_simps split: prod.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x.\n       \\<lbrakk>p = (x1, x2); 2 < x1; x \\<le> 2 * x1 + 2 * x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<le>x1 + x2.\n                            \\<exists>ya\\<le>x1 + x2. ya + y = x", "apply (rename_tac a b x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b x.\n       \\<lbrakk>p = (a, b); 2 < a; x \\<le> 2 * a + 2 * b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<le>a + b.\n                            \\<exists>ya\\<le>a + b. ya + y = x", "apply (case_tac \"x\\<le>a+b\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b x.\n       \\<lbrakk>p = (a, b); 2 < a; x \\<le> 2 * a + 2 * b;\n        x \\<le> a + b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<le>a + b.\n                            \\<exists>ya\\<le>a + b. ya + y = x\n 2. \\<And>a b x.\n       \\<lbrakk>p = (a, b); 2 < a; x \\<le> 2 * a + 2 * b;\n        \\<not> x \\<le> a + b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<le>a + b.\n                            \\<exists>ya\\<le>a + b. ya + y = x", "apply (rule_tac x=0 in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b x.\n       \\<lbrakk>p = (a, b); 2 < a; x \\<le> 2 * a + 2 * b;\n        x \\<le> a + b\\<rbrakk>\n       \\<Longrightarrow> 0 \\<le> a + b \\<and>\n                         (\\<exists>y\\<le>a + b. y + 0 = x)\n 2. \\<And>a b x.\n       \\<lbrakk>p = (a, b); 2 < a; x \\<le> 2 * a + 2 * b;\n        \\<not> x \\<le> a + b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<le>a + b.\n                            \\<exists>ya\\<le>a + b. ya + y = x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b x.\n       \\<lbrakk>p = (a, b); 2 < a; x \\<le> 2 * a + 2 * b;\n        \\<not> x \\<le> a + b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<le>a + b.\n                            \\<exists>ya\\<le>a + b. ya + y = x", "apply (rule_tac x=\"a+b\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b x.\n       \\<lbrakk>p = (a, b); 2 < a; x \\<le> 2 * a + 2 * b;\n        \\<not> x \\<le> a + b\\<rbrakk>\n       \\<Longrightarrow> a + b \\<le> a + b \\<and>\n                         (\\<exists>y\\<le>a + b. y + (a + b) = x)", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b x.\n       \\<lbrakk>p = (a, b); 2 < a; x \\<le> 2 * a + 2 * b;\n        \\<not> x \\<le> a + b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y\\<le>a + b. y + (a + b) = x", "apply (rule_tac x=\"x-(a+b)\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b x.\n       \\<lbrakk>p = (a, b); 2 < a; x \\<le> 2 * a + 2 * b;\n        \\<not> x \\<le> a + b\\<rbrakk>\n       \\<Longrightarrow> x - (a + b) \\<le> a + b \\<and>\n                         x - (a + b) + (a + b) = x", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "section \"Arbitrary Recursion (TBD)\""], ["", "text \\<open>\n  While-loops are suited to express tail-recursion.\n  In order to express arbitrary recursion, the refinement framework provides\n  the nrec-mode for the \\<open>partial_function\\<close> command, as well as the fixed \n  point combinators @{const \"REC\"} (partial correctness) and \n  @{const \"RECT\"} (total correctness).\n\n  Examples for \\<open>partial_function\\<close> can be found in \n  \\<open>ex/Refine_Fold\\<close>. Examples for the recursion combinators can be found\n  in \\<open>ex/Recursion\\<close> and \\<open>ex/Nested_DFS\\<close>.\n\\<close>"], ["", "section \\<open>Reference\\<close>"], ["", "subsection \\<open>Statements\\<close>"], ["", "text_raw \\<open>\\label{sec:stmt_ref}\\<close>"], ["", "text \\<open>\n    \\begin{description}\n      \\item[@{const \"SUCCEED\"}] The empty set of results. Least element of\n        the refinement ordering.\n      \\item[@{const \"FAIL\"}] Result that indicates a failing assertion.\n        Greatest element of the refinement ordering.\n      \\item{@{term \"RES X\"}} All results from set \\<open>X\\<close>.\n      \\item[@{term \"RETURN x\"}] Return single result \\<open>x\\<close>. Defined in \n        terms of \\<open>RES\\<close>: @{lemma \"RETURN x = RES {x}\" by simp}.\n      \\item[@{term \"EMBED r\"}] Embed partial-correctness option type, i.e.,\n        succeed if \\<open>r=None\\<close>, otherwise return value of \\<open>r\\<close>.\n      \\item[@{term \"SPEC \\<Phi>\"}] Specification. \n        All results that satisfy predicate \\<open>\\<Phi>\\<close>. Defined in terms of\n        @{term \"RES\"}: @{lemma \"SPEC \\<Phi> = RES (Collect \\<Phi>)\" by simp}\n      \\item[@{term [source] \"bind M f\"}] Binding. \n        Nondeterministically choose a result from \n        \\<open>M\\<close> and apply \\<open>f\\<close> to it. Note that usually the \n        \\<open>do\\<close>-notation is used, i.e., \\<open>do {x\\<leftarrow>M; f x}\\<close> or\n        \\<open>do {M;f}\\<close> if the result of \\<open>M\\<close> is not important.\n        If \\<open>M\\<close> fails, @{term [source] \"bind M f\"} also fails.\n      \\item[@{term \"ASSERT \\<Phi>\"}] Assertion. Fails\n        if \\<open>\\<Phi>\\<close> does not hold, otherwise returns \\<open>()\\<close>.\n        Note that the default usage with the do-notation is: \n        @{term [source] \"do {ASSERT \\<Phi>; f}\"}.\n\n      \\item[@{term \"ASSUME \\<Phi>\"}] Assumption. Succeeds\n        if \\<open>\\<Phi>\\<close> does not hold, otherwise returns \\<open>()\\<close>. Note that\n        the default usage with the do-notation is: \n        @{term [source] \"do {ASSUME \\<Phi>; f}\"}.\n\n      \\item[@{term \"REC body\"}] Recursion for partial correctness. \n        May be used to express arbitrary recursion. Returns \\<open>SUCCEED\\<close> on\n        nontermination.\n      \\item[@{term \"RECT body\"}] Recursion for total correctness. \n        Returns \\<open>FAIL\\<close> on nontermination.\n      \\item[@{term \"WHILE b f \\<sigma>\\<^sub>0\"}] Partial correct while-loop. \n        Start with state \\<open>\\<sigma>\\<^sub>0\\<close>,\n        and repeatedly apply \\<open>f\\<close> as long as \\<open>b\\<close> holds for the\n        current state. Non-terminating paths are ignored, i.e., they do not\n        contribute a result.\n      \\item[@{term \"WHILE\\<^sub>T b f \\<sigma>\\<^sub>0\"}] Total correct while-loop. If there is a\n        non-terminating path, the result is @{term \"FAIL\"}.\n      \\item[@{term \"WHILE\\<^bsup>I\\<^esup> b f \\<sigma>\\<^sub>0\"}, @{term \"WHILE\\<^sub>T\\<^bsup>I\\<^esup> b f \\<sigma>\\<^sub>0\"}] While-loop with\n        annotated invariant. It is asserted that the invariant holds.\n      \\item[@{term \"FOREACH S f \\<sigma>\\<^sub>0\"}] Foreach loop.\n        Start with state \\<open>\\<sigma>\\<^sub>0\\<close>, and transform\n        the state with \\<open>f x\\<close> for each element \\<open>x\\<in>S\\<close>. Asserts that \n        \\<open>S\\<close> is finite.\n      \\item[@{term \"FOREACH\\<^bsup>I\\<^esup> S f \\<sigma>\\<^sub>0\"}] Foreach-loop with \n        annotated invariant. \n\n        Alternative syntax: @{term \"FOREACHi I S f \\<sigma>\\<^sub>0\"}.\n\n        The invariant is a predicate of type\n        \\<open>I::'a set \\<Rightarrow> 'b \\<Rightarrow> bool\\<close>, where \\<open>I it \\<sigma>\\<close> means, that\n        the invariant holds for the remaining set of elements \\<open>it\\<close> and\n        current state \\<open>\\<sigma>\\<close>. \n      \\item[@{term \"FOREACH\\<^sub>C S c f \\<sigma>\\<^sub>0\"}] Foreach-loop with explicit continuation \n        condition.\n\n        Alternative syntax: @{term \"FOREACHc S c f \\<sigma>\\<^sub>0\"}.\n\n        If \\<open>c::'\\<sigma>\\<Rightarrow>bool\\<close> becomes false for the current state,\n        the iteration immediately terminates.\n      \\item[@{term \"FOREACH\\<^sub>C\\<^bsup>I\\<^esup> S c f \\<sigma>\\<^sub>0\"}] Foreach-loop with explicit continuation \n        condition and annotated invariant.\n\n        Alternative syntax: @{term \"FOREACHci I S c f \\<sigma>\\<^sub>0\"}.\n      \\item[\\<open>partial_function (nrec)\\<close>] Mode of the partial function \n        package for the nondeterminism monad.\n    \\end{description}\n\\<close>"], ["", "subsection \\<open>Refinement\\<close>"], ["", "text \\<open>\n      \\begin{description}\n        \\item{@{term_type \"(\\<le>) :: 'a nres \\<Rightarrow> 'a nres \\<Rightarrow> bool\"}} \n          Refinement ordering.\n          \\<open>S \\<le> S'\\<close> means, that every result in \n          \\<open>S\\<close> is also a result in \\<open>S'\\<close>. \n          Moreover, \\<open>S\\<close> may only fail if \\<open>S'\\<close> fails.\n          \\<open>\\<le>\\<close> forms a complete lattice, with least element \n          \\<open>SUCCEED\\<close> and greatest element \\<open>FAIL\\<close>.\n        \\item{@{term \"\\<Down>R\"}} Concretization. Takes a refinement relation\n          \\<open>R::('c\\<times>'a) set\\<close> that relates concrete to abstract values, \n          and returns a concretization function \n          @{term \"\\<Down>R :: 'a nres \\<Rightarrow> 'c nres\"}.\n        \\item{@{term \"\\<Up>R\"}} Abstraction. Takes a refinement relation and\n          returns an abstraction function. \n          The functions \\<open>\\<Down>R\\<close> and \\<open>\\<Up>R\\<close> form a Galois-connection,\n          i.e., we have: \\<open>S \\<le> \\<Down>R S' \\<longleftrightarrow> \\<Up>R S \\<le> S'\\<close>.\n        \\item{@{term \"build_rel \\<alpha> I\"}} Builds a refinement relation from\n          an abstraction function and an invariant. Those refinement relations\n          are always single-valued.\n        \\item{@{term \"nofail S\"}} Predicate that states that \\<open>S\\<close> does\n          not fail.\n        \\item{@{term \"inres S x\"}} Predicate that states that \\<open>S\\<close> \n          includes result \\<open>x\\<close>. Note that a failing program includes all\n          results.\n      \\end{description}\n\\<close>"], ["", "subsection\\<open>Proof Tools\\<close>"], ["", "text \\<open>\n        \\begin{description}\n          \\item{Verification Condition Generator:}\n            \\begin{description}\n              \\item[Method:] \\<open>intro refine_vcg\\<close>\n              \\item[Attributes:] \\<open>refine_vcg\\<close>\n            \\end{description}\n\n            Transforms a subgoal of the\n            form \\<open>S \\<le> SPEC \\<Phi>\\<close> into verification conditions by \n            decomposing the structure of \\<open>S\\<close>. Invariants for loops \n            without annotation must be specified explicitely by instantiating\n            the respective proof-rule for the loop construct, e.g., \n            \\<open>intro WHILE_rule[where I=\\<dots>] refine_vcg\\<close>.\n\n            \\<open>refine_vcg\\<close> is a named theorems collection that contains\n            the rules that are used by default.\n\n          \\item{Refinement Condition Generator:}\n            \\begin{description}\n              \\item[Method:] \\<open>refine_rcg\\<close> [thms]. \n              \\item[Attributes:] \\<open>refine0\\<close>, \\<open>refine\\<close>, \n                \\<open>refine2\\<close>.\n              \\item[Flags:] \\<open>refine_no_prod_split\\<close>.\n            \\end{description}\n            Tries to prove a subgoal of the form \\<open>S \\<le> \\<Down>R S'\\<close> by \n            decomposing the structure of \\<open>S\\<close> and \\<open>S'\\<close>. \n            The rules to be used are contained in the theorem collection \n            \\<open>refine\\<close>. More rules may be passed as argument to the method.\n            Rules contained in \\<open>refine0\\<close> are always \n            tried first, and rules in \\<open>refine2\\<close> are tried last. \n            Usually, rules that decompose both programs equally\n            should be put into \\<open>refine\\<close>. Rules that may make big steps,\n            without decomposing the program further, should be put into\n            \\<open>refine0\\<close> (e.g., @{thm [source] Id_refine}). Rules that \n            decompose the programs differently and shall be used as last resort\n            before giving up should be put into \\<open>refine2\\<close>, e.g., \n            @{thm [source] remove_Let_refine}.\n\n            By default, this procedure will invoke the splitter to split\n            product types in the goals. This behaviour can be disabled by\n            setting the flag \\<open>refine_no_prod_split\\<close>.\n          \\item{Refinement Relation Heuristics:}\n            \\begin{description}\n              \\item[Method:] \\<open>refine_dref_type\\<close> [(trace)].\n              \\item[Attributes:] \\<open>refine_dref_RELATES\\<close>,  \n                \\<open>refine_dref_pattern\\<close>.\n              \\item[Flags:] \\<open>refine_dref_tracing\\<close>.\n            \\end{description}\n            Tries to instantiate schematic refinement relations based on their\n            type. By default, this rule is applied to all subgoals. \n            Internally, it uses the rules declared as \n            \\<open>refine_dref_pattern\\<close> to introduce a goal of the form\n            \\<open>RELATES ?R\\<close>, that is then solved by exhaustively \n            applying rules declared as \\<open>refine_dref_RELATES\\<close>.\n            \n            The flag \\<open>refine_dref_tracing\\<close> controls tracing of \n            resolving \\<open>RELATES\\<close>-goals. Tracing may also be enabled by\n            passing (trace) as argument.\n\n          \\item{Pointwise Reasoning Simplification Rules:}\n            \\begin{description}\n              \\item[Attributes:] \\<open>refine_pw_simps\\<close>\n            \\end{description}\n            A theorem collection that contains \n            simplification lemmas to push inwards @{term \"nofail\"} and\n            @{term \"inres\"} predicates into program constructs.\n\n          \\item{Refinement Simp Rules:}\n            \\begin{description}\n              \\item[Attributes:] \\<open>refine_hsimp\\<close>\n            \\end{description}\n            A theorem collection that contains some\n            simplification lemmas that are useful to prove membership in \n            refinement relations.\n\n          \\item{Transfer:}\n            \\begin{description}\n              \\item[Method:] \\<open>refine_transfer\\<close> [thms] \n              \\item[Attribute:] \\<open>refine_transfer\\<close>\n            \\end{description}\n            Tries to prove a subgoal of the form \\<open>\\<alpha> f \\<le> S\\<close> by \n            decomposing the structure of \\<open>f\\<close> and \\<open>S\\<close>. \n            This is usually used in connection\n            with a schematic lemma, to generate \\<open>f\\<close> from the structure\n            of \\<open>S\\<close>.\n\n            The theorems declared as \\<open>refine_transfer\\<close> are used to do\n            the transfer. More theorems may be passed as arguments to the method. \n            Moreover, some simplification for nested abstraction \n            over product types (\\<open>\\<lambda>(a,b) (c,d). \\<dots>\\<close>) is done, and the\n            monotonicity prover is used on monotonicity goals.\n\n            There is a standard setup for \\<open>\\<alpha>=RETURN\\<close> \n            (transfer to plain function for total correct code generation), and\n            \\<open>\\<alpha>=nres_of\\<close> (transfer to deterministic result monad, for \n            partial correct code generation).\n\n          \\item{Automatic Refinement:}\n            \\begin{description}\n              \\item[Method:] \\<open>refine_autoref\\<close> \n              \\item[Attributes:] ...\n            \\end{description}\n            See automatic refinement package for documentation (TBD)\n\n          \\item{Concrete Definition:}\n            \\begin{description}\n              \\item[Command:] \n               \\<open>concrete_definition name [attribs] for params uses thm\\<close>\n               where \\<open>attribs\\<close> and the \\<open>for\\<close>-part are optional.\n\n               Declares a new constant from the left-hand side of a refinement\n               lemma. Has special handling for left-hand sides of the forms \n               \\<open>RETURN _\\<close> and \\<open>nres_of\\<close>, in which cases those \n               topmost functions are not included in the defined constant.\n\n               The refinement lemma is folded with the new constant and \n               registered as \\<open>name.refine\\<close>.\n              \\item[Command:]\n              \\<open>prepare_code_thms thms\\<close> takes a list of definitional \n                theorems and sets up lemmas for the code generator for those \n                definitions. This includes handling of recursion combinators.\n            \\end{description}\n        \\end{description}\n\\<close>"], ["", "subsection\\<open>Packages\\<close>"], ["", "text \\<open>\n        The following parts of the refinement framework are not included\n        by default, but can be imported if necessary:\n        \\begin{description}\n          \\item{Collection-Bindings:} Sets up refinement rules for the \n            Isabelle Collection Framework. With this theory loaded, the\n            refinement condition generator will discharge most data refinements\n            using the ICF automatically. Moreover, the transfer procedure\n            will replace \\<open>FOREACH\\<close>-statements by the corresponding \n            ICF-iterators.\n        \\end{description}\n\\<close>"], ["", "end"]]}