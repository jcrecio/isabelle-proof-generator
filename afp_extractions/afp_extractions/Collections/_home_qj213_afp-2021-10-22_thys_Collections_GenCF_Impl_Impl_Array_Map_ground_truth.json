{"file_name": "/home/qj213/afp-2021-10-22/thys/Collections/GenCF/Impl/Impl_Array_Map.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Collections", "problem_names": ["lemma [code]: \"iam_\\<alpha> a i \\<equiv> array_get_oo None a i\"", "lemma incr_correct: \"\\<not> idx < l \\<Longrightarrow> idx < l + iam_increment l idx\"", "lemma [code]: \"iam_update k v a \\<equiv> array_set_oo \n  (\\<lambda>_. let l=array_length a in \n         array_set (array_grow a (iam_increment l k) None) k (Some v))\n  a k (Some v)\"", "lemma [code]: \"iam_delete k a \\<equiv> array_set_oo (\\<lambda>_. a) a k None\"", "lemma iam_rel_def: \"\\<langle>R\\<rangle> iam_rel = \\<langle>\\<langle>R\\<rangle> option_rel\\<rangle> array_rel\"", "lemma iam_rel_sv[relator_props]:\n  \"single_valued Rv \\<Longrightarrow> single_valued (\\<langle>Rv\\<rangle>iam_rel)\"", "lemma param_iam_\\<alpha>[param]:\n  \"(iam_\\<alpha>, iam_\\<alpha>) \\<in> \\<langle>R\\<rangle> iam_rel \\<rightarrow> nat_rel \\<rightarrow> \\<langle>R\\<rangle> option_rel\"", "lemma param_iam_invar[param]:\n  \"(iam_invar, iam_invar) \\<in> \\<langle>R\\<rangle> iam_rel \\<rightarrow> bool_rel\"", "lemma param_iam_empty[param]: \n  \"(iam_empty, iam_empty) \\<in> unit_rel \\<rightarrow> \\<langle>R\\<rangle>iam_rel\"", "lemma param_iam_lookup[param]: \n  \"(iam_lookup, iam_lookup) \\<in> nat_rel \\<rightarrow> \\<langle>R\\<rangle>iam_rel \\<rightarrow> \\<langle>R\\<rangle>option_rel\"", "lemma param_iam_increment[param]:\n  \"(iam_increment, iam_increment) \\<in> nat_rel \\<rightarrow> nat_rel \\<rightarrow> nat_rel\"", "lemma param_iam_update[param]:\n  \"(iam_update, iam_update) \\<in> nat_rel \\<rightarrow> R \\<rightarrow> \\<langle>R\\<rangle>iam_rel \\<rightarrow> \\<langle>R\\<rangle>iam_rel\"", "lemma param_iam_delete[param]:\n  \"(iam_delete, iam_delete) \\<in> nat_rel \\<rightarrow> \\<langle>R\\<rangle>iam_rel \\<rightarrow> \\<langle>R\\<rangle>iam_rel\"", "lemma param_iam_iteratei_aux[param]:\n  assumes I: \"i \\<le> array_length a\"\n  assumes IR: \"(i,i') \\<in> nat_rel\"\n  assumes AR: \"(a,a') \\<in> \\<langle>Ra\\<rangle>iam_rel\"\n  assumes CR: \"(c,c') \\<in> Rb \\<rightarrow> bool_rel\"\n  assumes FR: \"(f,f') \\<in> \\<langle>nat_rel,Ra\\<rangle>prod_rel \\<rightarrow> Rb \\<rightarrow> Rb\"\n  assumes \\<sigma>R: \"(\\<sigma>,\\<sigma>') \\<in> Rb\"\n  shows \"(iam_iteratei_aux i a c f \\<sigma>, iam_iteratei_aux i' a' c' f' \\<sigma>') \\<in> Rb\"", "lemma param_iam_iteratei[param]:\n  \"(iam_iteratei,iam_iteratei) \\<in> \\<langle>Ra\\<rangle>iam_rel \\<rightarrow> (Rb \\<rightarrow> bool_rel) \\<rightarrow> \n      (\\<langle>nat_rel,Ra\\<rangle>prod_rel \\<rightarrow> Rb \\<rightarrow> Rb) \\<rightarrow> Rb \\<rightarrow> Rb\"", "lemma iam_empty_correct:\n  \"(iam_empty (), Map.empty) \\<in>  iam_rel'\"", "lemma iam_update_correct:\n  \"(iam_update,op_map_update) \\<in> nat_rel \\<rightarrow> Id \\<rightarrow> iam_rel'  \\<rightarrow> iam_rel'\"", "lemma iam_lookup_correct:\n  \"(iam_lookup,op_map_lookup) \\<in> Id \\<rightarrow> iam_rel' \\<rightarrow> \\<langle>Id\\<rangle>option_rel\"", "lemma array_get_set_iff: \"i<array_length a \\<Longrightarrow> \n  array_get (array_set a i x) j = (if i=j then x else array_get a j)\"", "lemma iam_delete_correct:\n  \"(iam_delete,op_map_delete) \\<in> Id \\<rightarrow> iam_rel' \\<rightarrow> iam_rel'\"", "lemma iam_map_rel_def: \n  \"\\<langle>nat_rel,Rv\\<rangle>iam_map_rel \\<equiv> \\<langle>Rv\\<rangle>iam_rel O iam_rel'\"", "lemmas [autoref_rel_intf] = REL_INTFI[of \"iam_map_rel\" i_map]", "lemma iam_map_rel_sv[relator_props]:\n  \"single_valued Rv \\<Longrightarrow> single_valued (\\<langle>nat_rel,Rv\\<rangle>iam_map_rel)\"", "lemma iam_empty_impl: \n    \"(iam_empty (), op_map_empty) \\<in> \\<langle>nat_rel,R\\<rangle>iam_map_rel\"", "lemma iam_lookup_impl: \n    \"(iam_lookup, op_map_lookup) \n  \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel,R\\<rangle>iam_map_rel \\<rightarrow> \\<langle>R\\<rangle>option_rel\"", "lemma iam_update_impl:\n   \"(iam_update, op_map_update) \\<in> \n     nat_rel \\<rightarrow> R \\<rightarrow> \\<langle>nat_rel,R\\<rangle>iam_map_rel \\<rightarrow> \\<langle>nat_rel,R\\<rangle>iam_map_rel\"", "lemma iam_delete_impl: \n    \"(iam_delete, op_map_delete) \\<in>\n        nat_rel \\<rightarrow> \\<langle>nat_rel,R\\<rangle>iam_map_rel \\<rightarrow> \\<langle>nat_rel,R\\<rangle>iam_map_rel\"", "lemmas iam_map_impl =\n  iam_empty_impl\n  iam_lookup_impl\n  iam_update_impl\n  iam_delete_impl", "lemma distinct_iam_to_list_aux:\n  shows \"\\<lbrakk>distinct xs; \\<forall>(i,_)\\<in>set xs. i \\<ge> n\\<rbrakk> \\<Longrightarrow> \n        distinct (iam_iteratei_aux n a \n            (\\<lambda>_.True) (\\<lambda>x y. y @ [x]) xs)\" \n   (is \"\\<lbrakk>_;_\\<rbrakk> \\<Longrightarrow> distinct (?iam_to_list_aux n xs)\")", "lemma distinct_iam_to_list:\n  \"distinct (iam_to_list a)\"", "lemma iam_to_list_set_correct_aux:\n  assumes \"(a, m) \\<in> iam_rel'\"\n  shows \"\\<lbrakk>n \\<le> array_length a; map_to_set m - {(k,v). k < n} = set xs\\<rbrakk>\n         \\<Longrightarrow> map_to_set m = \n             set (iam_iteratei_aux n a (\\<lambda>_.True) (\\<lambda>x y. y @ [x]) xs)\"", "lemma iam_to_list_set_correct:\n  assumes \"(a, m) \\<in> iam_rel'\"\n  shows \"map_to_set m = set (iam_to_list a)\"", "lemma iam_iteratei_aux_append:\n  \"n \\<le> length xs \\<Longrightarrow> iam_iteratei_aux n (Array (xs @ ys)) = \n             iam_iteratei_aux n (Array xs)\"", "lemma iam_iteratei_append: \n  \"iam_iteratei (Array (xs @ [None])) c f \\<sigma> =\n       iam_iteratei (Array xs) c f \\<sigma>\"\n  \"iam_iteratei (Array (xs @ [Some x])) c f \\<sigma> = \n       iam_iteratei (Array xs) c f \n       (if c \\<sigma> then (f (length xs, x) \\<sigma>) else \\<sigma>)\"", "lemma iam_iteratei_aux_Cons:\n  \"n < array_length a \\<Longrightarrow>\n      iam_iteratei_aux n a (\\<lambda>_. True) (\\<lambda>x l. l @ [x]) (x#xs) =\n      x # iam_iteratei_aux n a (\\<lambda>_. True) (\\<lambda>x l. l @ [x]) xs\"", "lemma iam_to_list_append: \n  \"iam_to_list (Array (xs @ [None])) = iam_to_list (Array xs)\"\n  \"iam_to_list (Array (xs @ [Some x])) = \n       (length xs, x) # iam_to_list (Array xs)\"", "lemma autoref_iam_is_iterator[autoref_ga_rules]: \n  shows \"is_map_to_list nat_rel Rv iam_map_rel iam_to_list\"", "lemmas [autoref_ga_rules] = \n  autoref_iam_is_iterator[unfolded is_map_to_list_def]", "lemma iam_iteratei_altdef:\n    \"iam_iteratei a = foldli (iam_to_list a)\" \n     (is \"?f a = ?g (iam_to_list a)\")", "lemma pi_iam[icf_proper_iteratorI]: \n  \"proper_it (iam_iteratei a) (iam_iteratei a)\"", "lemma pi'_iam[icf_proper_iteratorI]: \n  \"proper_it' iam_iteratei iam_iteratei\""], "translations": [["", "lemma [code]: \"iam_\\<alpha> a i \\<equiv> array_get_oo None a i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iam_\\<alpha> a i \\<equiv> array_get_oo None a i", "unfolding array_get_oo_def iam_\\<alpha>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. if i < array_length a then array_get a i else None \\<equiv>\n    if i < array_length a then array_get a i else None", "."], ["", "abbreviation iam_invar :: \"'v iam \\<Rightarrow> bool\" where \"iam_invar \\<equiv> \\<lambda>_. True\""], ["", "definition iam_empty :: \"unit \\<Rightarrow> 'v iam\" \n  where \"iam_empty \\<equiv> \\<lambda>_::unit. array_of_list []\""], ["", "definition iam_lookup :: \"nat \\<Rightarrow> 'v iam \\<rightharpoonup> 'v\"\n  where [code_unfold]: \"iam_lookup k a \\<equiv> iam_\\<alpha> a k\""], ["", "definition \"iam_increment (l::nat) idx \\<equiv> \n  max (idx + 1 - l) (2 * l + 3)\""], ["", "lemma incr_correct: \"\\<not> idx < l \\<Longrightarrow> idx < l + iam_increment l idx\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> idx < l \\<Longrightarrow> idx < l + iam_increment l idx", "unfolding iam_increment_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> idx < l \\<Longrightarrow> idx < l + max (idx + 1 - l) (2 * l + 3)", "by auto"], ["", "definition iam_update :: \"nat \\<Rightarrow> 'v \\<Rightarrow> 'v iam \\<Rightarrow> 'v iam\"\n  where \"iam_update k v a \\<equiv> let\n    l = array_length a;\n    a = if k < l then a else array_grow a (iam_increment l k) None\n  in\n    array_set a k (Some v)\""], ["", "lemma [code]: \"iam_update k v a \\<equiv> array_set_oo \n  (\\<lambda>_. let l=array_length a in \n         array_set (array_grow a (iam_increment l k) None) k (Some v))\n  a k (Some v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iam_update k v a \\<equiv>\n    array_set_oo\n     (\\<lambda>_.\n         let l = array_length a\n         in array_set (array_grow a (iam_increment l k) None) k (Some v))\n     a k (Some v)", "unfolding iam_update_def array_set_oo_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. let l = array_length a;\n        a = if k < l then a else array_grow a (iam_increment l k) None\n    in array_set a k (Some v) \\<equiv>\n    if k < array_length a then array_set a k (Some v)\n    else let l = array_length a\n         in array_set (array_grow a (iam_increment l k) None) k (Some v)", "apply (rule eq_reflection)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let l = array_length a;\n         a = if k < l then a else array_grow a (iam_increment l k) None\n     in array_set a k (Some v)) =\n    (if k < array_length a then array_set a k (Some v)\n     else let l = array_length a\n          in array_set (array_grow a (iam_increment l k) None) k (Some v))", "by auto"], ["", "definition iam_delete :: \"nat \\<Rightarrow> 'v iam \\<Rightarrow> 'v iam\"\n  where \"iam_delete k a \\<equiv> \n  if k<array_length a then array_set a k None else a\""], ["", "lemma [code]: \"iam_delete k a \\<equiv> array_set_oo (\\<lambda>_. a) a k None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iam_delete k a \\<equiv> array_set_oo (\\<lambda>_. a) a k None", "unfolding iam_delete_def array_set_oo_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. if k < array_length a then array_set a k None else a \\<equiv>\n    if k < array_length a then array_set a k None else a", "by auto"], ["", "primrec iam_iteratei_aux \n  :: \"nat \\<Rightarrow> ('v iam) \\<Rightarrow> ('\\<sigma>\\<Rightarrow>bool) \\<Rightarrow> (nat \\<times> 'v\\<Rightarrow>'\\<sigma>\\<Rightarrow>'\\<sigma>) \\<Rightarrow> '\\<sigma> \\<Rightarrow> '\\<sigma>\" \n  where\n    \"iam_iteratei_aux 0 a c f \\<sigma> = \\<sigma>\"\n  | \"iam_iteratei_aux (Suc i) a c f \\<sigma> = (\n      if c \\<sigma> then   \n        iam_iteratei_aux i a c f (\n          case array_get a i of None \\<Rightarrow> \\<sigma> | Some x \\<Rightarrow> f (i, x) \\<sigma>\n        )\n      else \\<sigma>)\""], ["", "definition iam_iteratei :: \"'v iam \\<Rightarrow> (nat \\<times> 'v,'\\<sigma>) set_iterator\" where \n  \"iam_iteratei a = iam_iteratei_aux (array_length a) a\""], ["", "subsection \\<open>Parametricity\\<close>"], ["", "definition iam_rel_def_internal: \n  \"iam_rel R \\<equiv> \\<langle>\\<langle>R\\<rangle> option_rel\\<rangle> array_rel\""], ["", "lemma iam_rel_def: \"\\<langle>R\\<rangle> iam_rel = \\<langle>\\<langle>R\\<rangle> option_rel\\<rangle> array_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>R\\<rangle>iam_rel =\n    \\<langle>\\<langle>R\\<rangle>option_rel\\<rangle>array_rel", "by (simp add: iam_rel_def_internal relAPP_def)"], ["", "lemma iam_rel_sv[relator_props]:\n  \"single_valued Rv \\<Longrightarrow> single_valued (\\<langle>Rv\\<rangle>iam_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued Rv \\<Longrightarrow>\n    single_valued (\\<langle>Rv\\<rangle>iam_rel)", "unfolding iam_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued Rv \\<Longrightarrow>\n    single_valued\n     (\\<langle>\\<langle>Rv\\<rangle>option_rel\\<rangle>array_rel)", "by tagged_solver"], ["", "lemma param_iam_\\<alpha>[param]:\n  \"(iam_\\<alpha>, iam_\\<alpha>) \\<in> \\<langle>R\\<rangle> iam_rel \\<rightarrow> nat_rel \\<rightarrow> \\<langle>R\\<rangle> option_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (iam_\\<alpha>, iam_\\<alpha>)\n    \\<in> \\<langle>R\\<rangle>iam_rel \\<rightarrow>\n          nat_rel \\<rightarrow> \\<langle>R\\<rangle>option_rel", "unfolding iam_\\<alpha>_def[abs_def] iam_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>a i. if i < array_length a then array_get a i else None,\n     \\<lambda>a i. if i < array_length a then array_get a i else None)\n    \\<in> \\<langle>\\<langle>R\\<rangle>option_rel\\<rangle>array_rel \\<rightarrow>\n          nat_rel \\<rightarrow> \\<langle>R\\<rangle>option_rel", "by parametricity"], ["", "lemma param_iam_invar[param]:\n  \"(iam_invar, iam_invar) \\<in> \\<langle>R\\<rangle> iam_rel \\<rightarrow> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (iam_invar, iam_invar)\n    \\<in> \\<langle>R\\<rangle>iam_rel \\<rightarrow> bool_rel", "unfolding iam_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (iam_invar, iam_invar)\n    \\<in> \\<langle>\\<langle>R\\<rangle>option_rel\\<rangle>array_rel \\<rightarrow>\n          bool_rel", "by parametricity"], ["", "lemma param_iam_empty[param]: \n  \"(iam_empty, iam_empty) \\<in> unit_rel \\<rightarrow> \\<langle>R\\<rangle>iam_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (iam_empty, iam_empty)\n    \\<in> unit_rel \\<rightarrow> \\<langle>R\\<rangle>iam_rel", "unfolding iam_empty_def[abs_def] iam_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>_. array_of_list [], \\<lambda>_. array_of_list [])\n    \\<in> unit_rel \\<rightarrow>\n          \\<langle>\\<langle>R\\<rangle>option_rel\\<rangle>array_rel", "by parametricity"], ["", "lemma param_iam_lookup[param]: \n  \"(iam_lookup, iam_lookup) \\<in> nat_rel \\<rightarrow> \\<langle>R\\<rangle>iam_rel \\<rightarrow> \\<langle>R\\<rangle>option_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (iam_lookup, iam_lookup)\n    \\<in> nat_rel \\<rightarrow>\n          \\<langle>R\\<rangle>iam_rel \\<rightarrow>\n          \\<langle>R\\<rangle>option_rel", "unfolding iam_lookup_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>k a. iam_\\<alpha> a k, \\<lambda>k a. iam_\\<alpha> a k)\n    \\<in> nat_rel \\<rightarrow>\n          \\<langle>R\\<rangle>iam_rel \\<rightarrow>\n          \\<langle>R\\<rangle>option_rel", "by parametricity"], ["", "(* TODO: why does parametricity fail here? *)"], ["", "lemma param_iam_increment[param]:\n  \"(iam_increment, iam_increment) \\<in> nat_rel \\<rightarrow> nat_rel \\<rightarrow> nat_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (iam_increment, iam_increment)\n    \\<in> nat_rel \\<rightarrow> nat_rel \\<rightarrow> nat_rel", "unfolding iam_increment_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>l idx. max (idx + 1 - l) (2 * l + 3),\n     \\<lambda>l idx. max (idx + 1 - l) (2 * l + 3))\n    \\<in> nat_rel \\<rightarrow> nat_rel \\<rightarrow> nat_rel", "by simp"], ["", "(* TODO: The builtin \"Let\" rule for parametricity does some unpleasant things\n         here, leading to an unprovable subgoal. Investigate this. *)"], ["", "lemma param_iam_update[param]:\n  \"(iam_update, iam_update) \\<in> nat_rel \\<rightarrow> R \\<rightarrow> \\<langle>R\\<rangle>iam_rel \\<rightarrow> \\<langle>R\\<rangle>iam_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (iam_update, iam_update)\n    \\<in> nat_rel \\<rightarrow>\n          R \\<rightarrow>\n          \\<langle>R\\<rangle>iam_rel \\<rightarrow>\n          \\<langle>R\\<rangle>iam_rel", "unfolding iam_update_def[abs_def] iam_rel_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>k v a.\n        array_set\n         (if k < array_length a then a\n          else array_grow a (iam_increment (array_length a) k) None)\n         k (Some v),\n     \\<lambda>k v a.\n        array_set\n         (if k < array_length a then a\n          else array_grow a (iam_increment (array_length a) k) None)\n         k (Some v))\n    \\<in> nat_rel \\<rightarrow>\n          R \\<rightarrow>\n          \\<langle>\\<langle>R\\<rangle>option_rel\\<rangle>array_rel \\<rightarrow>\n          \\<langle>\\<langle>R\\<rangle>option_rel\\<rangle>array_rel", "apply parametricity"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma param_iam_delete[param]:\n  \"(iam_delete, iam_delete) \\<in> nat_rel \\<rightarrow> \\<langle>R\\<rangle>iam_rel \\<rightarrow> \\<langle>R\\<rangle>iam_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (iam_delete, iam_delete)\n    \\<in> nat_rel \\<rightarrow>\n          \\<langle>R\\<rangle>iam_rel \\<rightarrow>\n          \\<langle>R\\<rangle>iam_rel", "unfolding iam_delete_def[abs_def] iam_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>k a. if k < array_length a then array_set a k None else a,\n     \\<lambda>k a. if k < array_length a then array_set a k None else a)\n    \\<in> nat_rel \\<rightarrow>\n          \\<langle>\\<langle>R\\<rangle>option_rel\\<rangle>array_rel \\<rightarrow>\n          \\<langle>\\<langle>R\\<rangle>option_rel\\<rangle>array_rel", "by parametricity"], ["", "lemma param_iam_iteratei_aux[param]:\n  assumes I: \"i \\<le> array_length a\"\n  assumes IR: \"(i,i') \\<in> nat_rel\"\n  assumes AR: \"(a,a') \\<in> \\<langle>Ra\\<rangle>iam_rel\"\n  assumes CR: \"(c,c') \\<in> Rb \\<rightarrow> bool_rel\"\n  assumes FR: \"(f,f') \\<in> \\<langle>nat_rel,Ra\\<rangle>prod_rel \\<rightarrow> Rb \\<rightarrow> Rb\"\n  assumes \\<sigma>R: \"(\\<sigma>,\\<sigma>') \\<in> Rb\"\n  shows \"(iam_iteratei_aux i a c f \\<sigma>, iam_iteratei_aux i' a' c' f' \\<sigma>') \\<in> Rb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (iam_iteratei_aux i a c f \\<sigma>,\n     iam_iteratei_aux i' a' c' f' \\<sigma>')\n    \\<in> Rb", "using assms"], ["proof (prove)\nusing this:\n  i \\<le> array_length a\n  (i, i') \\<in> nat_rel\n  (a, a') \\<in> \\<langle>Ra\\<rangle>iam_rel\n  (c, c') \\<in> Rb \\<rightarrow> bool_rel\n  (f, f')\n  \\<in> nat_rel \\<times>\\<^sub>r Ra \\<rightarrow> Rb \\<rightarrow> Rb\n  (\\<sigma>, \\<sigma>') \\<in> Rb\n\ngoal (1 subgoal):\n 1. (iam_iteratei_aux i a c f \\<sigma>,\n     iam_iteratei_aux i' a' c' f' \\<sigma>')\n    \\<in> Rb", "unfolding iam_rel_def"], ["proof (prove)\nusing this:\n  i \\<le> array_length a\n  (i, i') \\<in> nat_rel\n  (a, a') \\<in> \\<langle>\\<langle>Ra\\<rangle>option_rel\\<rangle>array_rel\n  (c, c') \\<in> Rb \\<rightarrow> bool_rel\n  (f, f')\n  \\<in> nat_rel \\<times>\\<^sub>r Ra \\<rightarrow> Rb \\<rightarrow> Rb\n  (\\<sigma>, \\<sigma>') \\<in> Rb\n\ngoal (1 subgoal):\n 1. (iam_iteratei_aux i a c f \\<sigma>,\n     iam_iteratei_aux i' a' c' f' \\<sigma>')\n    \\<in> Rb", "apply (induct i' arbitrary: i \\<sigma> \\<sigma>')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i \\<sigma> \\<sigma>'.\n       \\<lbrakk>i \\<le> array_length a; (i, 0) \\<in> nat_rel;\n        (a, a')\n        \\<in> \\<langle>\\<langle>Ra\\<rangle>option_rel\\<rangle>array_rel;\n        (c, c') \\<in> Rb \\<rightarrow> bool_rel;\n        (f, f')\n        \\<in> nat_rel \\<times>\\<^sub>r Ra \\<rightarrow> Rb \\<rightarrow> Rb;\n        (\\<sigma>, \\<sigma>') \\<in> Rb\\<rbrakk>\n       \\<Longrightarrow> (iam_iteratei_aux i a c f \\<sigma>,\n                          iam_iteratei_aux 0 a' c' f' \\<sigma>')\n                         \\<in> Rb\n 2. \\<And>i' i \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<And>i \\<sigma> \\<sigma>'.\n                   \\<lbrakk>i \\<le> array_length a; (i, i') \\<in> nat_rel;\n                    (a, a')\n                    \\<in> \\<langle>\\<langle>Ra\\<rangle>option_rel\\<rangle>array_rel;\n                    (c, c') \\<in> Rb \\<rightarrow> bool_rel;\n                    (f, f')\n                    \\<in> nat_rel \\<times>\\<^sub>r Ra \\<rightarrow>\n                          Rb \\<rightarrow> Rb;\n                    (\\<sigma>, \\<sigma>') \\<in> Rb\\<rbrakk>\n                   \\<Longrightarrow> (iam_iteratei_aux i a c f \\<sigma>,\niam_iteratei_aux i' a' c' f' \\<sigma>')\n                                     \\<in> Rb;\n        i \\<le> array_length a; (i, Suc i') \\<in> nat_rel;\n        (a, a')\n        \\<in> \\<langle>\\<langle>Ra\\<rangle>option_rel\\<rangle>array_rel;\n        (c, c') \\<in> Rb \\<rightarrow> bool_rel;\n        (f, f')\n        \\<in> nat_rel \\<times>\\<^sub>r Ra \\<rightarrow> Rb \\<rightarrow> Rb;\n        (\\<sigma>, \\<sigma>') \\<in> Rb\\<rbrakk>\n       \\<Longrightarrow> (iam_iteratei_aux i a c f \\<sigma>,\n                          iam_iteratei_aux (Suc i') a' c' f' \\<sigma>')\n                         \\<in> Rb", "apply (simp_all only: pair_in_Id_conv iam_iteratei_aux.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i' i \\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<And>i \\<sigma> \\<sigma>'.\n                   \\<lbrakk>i' \\<le> array_length a; i = i'; True; True;\n                    True; (\\<sigma>, \\<sigma>') \\<in> Rb\\<rbrakk>\n                   \\<Longrightarrow> (iam_iteratei_aux i' a c f \\<sigma>,\niam_iteratei_aux i' a' c' f' \\<sigma>')\n                                     \\<in> Rb;\n        Suc i' \\<le> array_length a; i = Suc i';\n        (a, a')\n        \\<in> \\<langle>\\<langle>Ra\\<rangle>option_rel\\<rangle>array_rel;\n        (c, c') \\<in> Rb \\<rightarrow> bool_rel;\n        (f, f')\n        \\<in> nat_rel \\<times>\\<^sub>r Ra \\<rightarrow> Rb \\<rightarrow> Rb;\n        (\\<sigma>, \\<sigma>') \\<in> Rb\\<rbrakk>\n       \\<Longrightarrow> (if c \\<sigma>\n                          then iam_iteratei_aux i' a c f\n                                (case array_get a i' of\n                                 None \\<Rightarrow> \\<sigma>\n                                 | Some x \\<Rightarrow> f (i', x) \\<sigma>)\n                          else \\<sigma>,\n                          if c' \\<sigma>'\n                          then iam_iteratei_aux i' a' c' f'\n                                (case array_get a' i' of\n                                 None \\<Rightarrow> \\<sigma>'\n                                 | Some x \\<Rightarrow>\n                                     f' (i', x) \\<sigma>')\n                          else \\<sigma>')\n                         \\<in> Rb", "apply parametricity"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>i' i \\<sigma> \\<sigma>'.\n       \\<lbrakk>Suc i' \\<le> array_length a; i = Suc i';\n        (a, a')\n        \\<in> \\<langle>\\<langle>Ra\\<rangle>option_rel\\<rangle>array_rel;\n        (c, c') \\<in> Rb \\<rightarrow> bool_rel;\n        (f, f')\n        \\<in> nat_rel \\<times>\\<^sub>r Ra \\<rightarrow> Rb \\<rightarrow> Rb;\n        (\\<sigma>, \\<sigma>') \\<in> Rb; c \\<sigma>; c' \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> i' \\<le> array_length a\n 2. \\<And>i' i \\<sigma> \\<sigma>'.\n       \\<lbrakk>Suc i' \\<le> array_length a; i = Suc i';\n        (a, a')\n        \\<in> \\<langle>\\<langle>Ra\\<rangle>option_rel\\<rangle>array_rel;\n        (c, c') \\<in> Rb \\<rightarrow> bool_rel;\n        (f, f')\n        \\<in> nat_rel \\<times>\\<^sub>r Ra \\<rightarrow> Rb \\<rightarrow> Rb;\n        (\\<sigma>, \\<sigma>') \\<in> Rb; c \\<sigma>; c' \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> ?i15 i' i \\<sigma> \\<sigma>' = i'\n 3. \\<And>i' i \\<sigma> \\<sigma>'.\n       \\<lbrakk>Suc i' \\<le> array_length a; i = Suc i';\n        (a, a')\n        \\<in> \\<langle>\\<langle>Ra\\<rangle>option_rel\\<rangle>array_rel;\n        (c, c') \\<in> Rb \\<rightarrow> bool_rel;\n        (f, f')\n        \\<in> nat_rel \\<times>\\<^sub>r Ra \\<rightarrow> Rb \\<rightarrow> Rb;\n        (\\<sigma>, \\<sigma>') \\<in> Rb; c \\<sigma>; c' \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> True\n 4. \\<And>i' i \\<sigma> \\<sigma>'.\n       \\<lbrakk>Suc i' \\<le> array_length a; i = Suc i';\n        (a, a')\n        \\<in> \\<langle>\\<langle>Ra\\<rangle>option_rel\\<rangle>array_rel;\n        (c, c') \\<in> Rb \\<rightarrow> bool_rel;\n        (f, f')\n        \\<in> nat_rel \\<times>\\<^sub>r Ra \\<rightarrow> Rb \\<rightarrow> Rb;\n        (\\<sigma>, \\<sigma>') \\<in> Rb; c \\<sigma>; c' \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> True\n 5. \\<And>i' i \\<sigma> \\<sigma>'.\n       \\<lbrakk>Suc i' \\<le> array_length a; i = Suc i';\n        (a, a')\n        \\<in> \\<langle>\\<langle>Ra\\<rangle>option_rel\\<rangle>array_rel;\n        (c, c') \\<in> Rb \\<rightarrow> bool_rel;\n        (f, f')\n        \\<in> nat_rel \\<times>\\<^sub>r Ra \\<rightarrow> Rb \\<rightarrow> Rb;\n        (\\<sigma>, \\<sigma>') \\<in> Rb; c \\<sigma>; c' \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> True\n 6. \\<And>i' i \\<sigma> \\<sigma>' aa a'a.\n       \\<lbrakk>Suc i' \\<le> array_length a; i = Suc i';\n        (a, a')\n        \\<in> \\<langle>\\<langle>Ra\\<rangle>option_rel\\<rangle>array_rel;\n        (c, c') \\<in> Rb \\<rightarrow> bool_rel;\n        (f, f')\n        \\<in> nat_rel \\<times>\\<^sub>r Ra \\<rightarrow> Rb \\<rightarrow> Rb;\n        (\\<sigma>, \\<sigma>') \\<in> Rb; c \\<sigma>; c' \\<sigma>';\n        (aa, a'a) \\<in> Ra\\<rbrakk>\n       \\<Longrightarrow> (i', i') \\<in> nat_rel\n 7. \\<And>i' i \\<sigma> \\<sigma>'.\n       \\<lbrakk>Suc i' \\<le> array_length a; i = Suc i';\n        (a, a')\n        \\<in> \\<langle>\\<langle>Ra\\<rangle>option_rel\\<rangle>array_rel;\n        (c, c') \\<in> Rb \\<rightarrow> bool_rel;\n        (f, f')\n        \\<in> nat_rel \\<times>\\<^sub>r Ra \\<rightarrow> Rb \\<rightarrow> Rb;\n        (\\<sigma>, \\<sigma>') \\<in> Rb; c \\<sigma>; c' \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> i' < array_length a\n 8. \\<And>i' i \\<sigma> \\<sigma>'.\n       \\<lbrakk>Suc i' \\<le> array_length a; i = Suc i';\n        (a, a')\n        \\<in> \\<langle>\\<langle>Ra\\<rangle>option_rel\\<rangle>array_rel;\n        (c, c') \\<in> Rb \\<rightarrow> bool_rel;\n        (f, f')\n        \\<in> nat_rel \\<times>\\<^sub>r Ra \\<rightarrow> Rb \\<rightarrow> Rb;\n        (\\<sigma>, \\<sigma>') \\<in> Rb; c \\<sigma>; c' \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> (i', i') \\<in> nat_rel", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma param_iam_iteratei[param]:\n  \"(iam_iteratei,iam_iteratei) \\<in> \\<langle>Ra\\<rangle>iam_rel \\<rightarrow> (Rb \\<rightarrow> bool_rel) \\<rightarrow> \n      (\\<langle>nat_rel,Ra\\<rangle>prod_rel \\<rightarrow> Rb \\<rightarrow> Rb) \\<rightarrow> Rb \\<rightarrow> Rb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (iam_iteratei, iam_iteratei)\n    \\<in> \\<langle>Ra\\<rangle>iam_rel \\<rightarrow>\n          (Rb \\<rightarrow> bool_rel) \\<rightarrow>\n          (nat_rel \\<times>\\<^sub>r Ra \\<rightarrow>\n           Rb \\<rightarrow> Rb) \\<rightarrow>\n          Rb \\<rightarrow> Rb", "unfolding iam_iteratei_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>a. iam_iteratei_aux (array_length a) a,\n     \\<lambda>a. iam_iteratei_aux (array_length a) a)\n    \\<in> \\<langle>Ra\\<rangle>iam_rel \\<rightarrow>\n          (Rb \\<rightarrow> bool_rel) \\<rightarrow>\n          (nat_rel \\<times>\\<^sub>r Ra \\<rightarrow>\n           Rb \\<rightarrow> Rb) \\<rightarrow>\n          Rb \\<rightarrow> Rb", "by parametricity (simp_all add: iam_rel_def)"], ["", "subsection \\<open>Correctness\\<close>"], ["", "definition \"iam_rel' \\<equiv> br iam_\\<alpha> iam_invar\""], ["", "lemma iam_empty_correct:\n  \"(iam_empty (), Map.empty) \\<in>  iam_rel'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (iam_empty (), Map.empty) \\<in> iam_rel'", "by (simp add: iam_rel'_def br_def iam_\\<alpha>_def[abs_def] iam_empty_def)"], ["", "lemma iam_update_correct:\n  \"(iam_update,op_map_update) \\<in> nat_rel \\<rightarrow> Id \\<rightarrow> iam_rel'  \\<rightarrow> iam_rel'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (iam_update, op_map_update)\n    \\<in> nat_rel \\<rightarrow>\n          Id \\<rightarrow> iam_rel' \\<rightarrow> iam_rel'", "by (auto simp: iam_rel'_def br_def Let_def array_get_array_set_other \n                  incr_correct iam_\\<alpha>_def[abs_def] iam_update_def)"], ["", "lemma iam_lookup_correct:\n  \"(iam_lookup,op_map_lookup) \\<in> Id \\<rightarrow> iam_rel' \\<rightarrow> \\<langle>Id\\<rangle>option_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (iam_lookup, op_map_lookup)\n    \\<in> nat_rel \\<rightarrow>\n          iam_rel' \\<rightarrow> \\<langle>Id\\<rangle>option_rel", "by (auto simp: iam_rel'_def br_def iam_lookup_def[abs_def])"], ["", "lemma array_get_set_iff: \"i<array_length a \\<Longrightarrow> \n  array_get (array_set a i x) j = (if i=j then x else array_get a j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < array_length a \\<Longrightarrow>\n    array_get (array_set a i x) j = (if i = j then x else array_get a j)", "by (auto simp: array_get_array_set_other)"], ["", "lemma iam_delete_correct:\n  \"(iam_delete,op_map_delete) \\<in> Id \\<rightarrow> iam_rel' \\<rightarrow> iam_rel'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (iam_delete, op_map_delete)\n    \\<in> nat_rel \\<rightarrow> iam_rel' \\<rightarrow> iam_rel'", "unfolding iam_\\<alpha>_def[abs_def] iam_delete_def[abs_def] iam_rel'_def br_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>k a. if k < array_length a then array_set a k None else a,\n     op_map_delete)\n    \\<in> nat_rel \\<rightarrow>\n          {(c, a).\n           a =\n           (\\<lambda>i.\n               if i < array_length c then array_get c i else None) \\<and>\n           True} \\<rightarrow>\n          {(c, a).\n           a =\n           (\\<lambda>i.\n               if i < array_length c then array_get c i else None) \\<and>\n           True}", "by (auto simp: Let_def array_get_set_iff)"], ["", "definition iam_map_rel_def_internal: \n  \"iam_map_rel Rk Rv \\<equiv> \n    if Rk=nat_rel then \\<langle>Rv\\<rangle>iam_rel O iam_rel' else {}\""], ["", "lemma iam_map_rel_def: \n  \"\\<langle>nat_rel,Rv\\<rangle>iam_map_rel \\<equiv> \\<langle>Rv\\<rangle>iam_rel O iam_rel'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>nat_rel, Rv\\<rangle>iam_map_rel \\<equiv>\n    \\<langle>Rv\\<rangle>iam_rel O iam_rel'", "unfolding iam_map_rel_def_internal relAPP_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. if nat_rel = nat_rel then iam_rel Rv O iam_rel' else {} \\<equiv>\n    iam_rel Rv O iam_rel'", "by simp"], ["", "lemmas [autoref_rel_intf] = REL_INTFI[of \"iam_map_rel\" i_map]"], ["", "lemma iam_map_rel_sv[relator_props]:\n  \"single_valued Rv \\<Longrightarrow> single_valued (\\<langle>nat_rel,Rv\\<rangle>iam_map_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued Rv \\<Longrightarrow>\n    single_valued (\\<langle>nat_rel, Rv\\<rangle>iam_map_rel)", "unfolding iam_map_rel_def iam_rel'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued Rv \\<Longrightarrow>\n    single_valued (\\<langle>Rv\\<rangle>iam_rel O br iam_\\<alpha> iam_invar)", "by tagged_solver"], ["", "lemma iam_empty_impl: \n    \"(iam_empty (), op_map_empty) \\<in> \\<langle>nat_rel,R\\<rangle>iam_map_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (iam_empty (), op_map_empty) \\<in> \\<langle>nat_rel,\n    R\\<rangle>iam_map_rel", "unfolding iam_map_rel_def op_map_empty_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (iam_empty (), Map.empty) \\<in> \\<langle>R\\<rangle>iam_rel O iam_rel'", "apply (intro relcompI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (iam_empty (), ?b) \\<in> \\<langle>R\\<rangle>iam_rel\n 2. (?b, Map.empty) \\<in> iam_rel'", "apply (rule param_iam_empty[THEN fun_relD], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (iam_empty ?x'1, Map.empty) \\<in> iam_rel'", "apply (rule iam_empty_correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iam_lookup_impl: \n    \"(iam_lookup, op_map_lookup) \n  \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel,R\\<rangle>iam_map_rel \\<rightarrow> \\<langle>R\\<rangle>option_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (iam_lookup, op_map_lookup)\n    \\<in> nat_rel \\<rightarrow>\n          \\<langle>nat_rel, R\\<rangle>iam_map_rel \\<rightarrow>\n          \\<langle>R\\<rangle>option_rel", "unfolding iam_map_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (iam_lookup, op_map_lookup)\n    \\<in> nat_rel \\<rightarrow>\n          \\<langle>R\\<rangle>iam_rel O iam_rel' \\<rightarrow>\n          \\<langle>R\\<rangle>option_rel", "apply (intro fun_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> nat_rel;\n        (aa, a'a) \\<in> \\<langle>R\\<rangle>iam_rel O iam_rel'\\<rbrakk>\n       \\<Longrightarrow> (iam_lookup a aa, op_map_lookup a' a'a)\n                         \\<in> \\<langle>R\\<rangle>option_rel", "apply (elim relcompE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a x y z.\n       \\<lbrakk>(a, a') \\<in> nat_rel; (aa, a'a) = (x, z);\n        (x, y) \\<in> \\<langle>R\\<rangle>iam_rel;\n        (y, z) \\<in> iam_rel'\\<rbrakk>\n       \\<Longrightarrow> (iam_lookup a aa, op_map_lookup a' a'a)\n                         \\<in> \\<langle>R\\<rangle>option_rel", "apply (frule iam_lookup_correct[param_fo], assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a x y z.\n       \\<lbrakk>(a, a') \\<in> nat_rel; (aa, a'a) = (x, z);\n        (x, y) \\<in> \\<langle>R\\<rangle>iam_rel; (y, z) \\<in> iam_rel';\n        (iam_lookup a y, op_map_lookup a' z)\n        \\<in> \\<langle>Id\\<rangle>option_rel\\<rbrakk>\n       \\<Longrightarrow> (iam_lookup a aa, op_map_lookup a' a'a)\n                         \\<in> \\<langle>R\\<rangle>option_rel", "apply (frule param_iam_lookup[param_fo], assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a x y z.\n       \\<lbrakk>(a, a') \\<in> nat_rel; (aa, a'a) = (x, z);\n        (x, y) \\<in> \\<langle>R\\<rangle>iam_rel; (y, z) \\<in> iam_rel';\n        (iam_lookup a y, op_map_lookup a' z)\n        \\<in> \\<langle>Id\\<rangle>option_rel;\n        (iam_lookup a x, iam_lookup a' y)\n        \\<in> \\<langle>R\\<rangle>option_rel\\<rbrakk>\n       \\<Longrightarrow> (iam_lookup a aa, op_map_lookup a' a'a)\n                         \\<in> \\<langle>R\\<rangle>option_rel", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iam_update_impl:\n   \"(iam_update, op_map_update) \\<in> \n     nat_rel \\<rightarrow> R \\<rightarrow> \\<langle>nat_rel,R\\<rangle>iam_map_rel \\<rightarrow> \\<langle>nat_rel,R\\<rangle>iam_map_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (iam_update, op_map_update)\n    \\<in> nat_rel \\<rightarrow>\n          R \\<rightarrow>\n          \\<langle>nat_rel, R\\<rangle>iam_map_rel \\<rightarrow>\n          \\<langle>nat_rel, R\\<rangle>iam_map_rel", "unfolding iam_map_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (iam_update, op_map_update)\n    \\<in> nat_rel \\<rightarrow>\n          R \\<rightarrow>\n          \\<langle>R\\<rangle>iam_rel O iam_rel' \\<rightarrow>\n          \\<langle>R\\<rangle>iam_rel O iam_rel'", "apply (intro fun_relI, elim relcompEpair, intro relcompI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a a' aa a'a ab a'b b.\n       \\<lbrakk>(a, a') \\<in> nat_rel; (aa, a'a) \\<in> R;\n        (ab, b) \\<in> \\<langle>R\\<rangle>iam_rel;\n        (b, a'b) \\<in> iam_rel'\\<rbrakk>\n       \\<Longrightarrow> (iam_update a aa ab, ?b4 a a' aa a'a ab a'b b)\n                         \\<in> \\<langle>R\\<rangle>iam_rel\n 2. \\<And>a a' aa a'a ab a'b b.\n       \\<lbrakk>(a, a') \\<in> nat_rel; (aa, a'a) \\<in> R;\n        (ab, b) \\<in> \\<langle>R\\<rangle>iam_rel;\n        (b, a'b) \\<in> iam_rel'\\<rbrakk>\n       \\<Longrightarrow> (?b4 a a' aa a'a ab a'b b,\n                          op_map_update a' a'a a'b)\n                         \\<in> iam_rel'", "apply (erule (2) param_iam_update[param_fo])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b b.\n       \\<lbrakk>(a, a') \\<in> nat_rel; (aa, a'a) \\<in> R;\n        (ab, b) \\<in> \\<langle>R\\<rangle>iam_rel;\n        (b, a'b) \\<in> iam_rel'\\<rbrakk>\n       \\<Longrightarrow> (iam_update a' a'a b, op_map_update a' a'a a'b)\n                         \\<in> iam_rel'", "apply (rule iam_update_correct[param_fo])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a a' aa a'a ab a'b b.\n       \\<lbrakk>(a, a') \\<in> nat_rel; (aa, a'a) \\<in> R;\n        (ab, b) \\<in> \\<langle>R\\<rangle>iam_rel;\n        (b, a'b) \\<in> iam_rel'\\<rbrakk>\n       \\<Longrightarrow> (a', a') \\<in> nat_rel\n 2. \\<And>a a' aa a'a ab a'b b.\n       \\<lbrakk>(a, a') \\<in> nat_rel; (aa, a'a) \\<in> R;\n        (ab, b) \\<in> \\<langle>R\\<rangle>iam_rel;\n        (b, a'b) \\<in> iam_rel'\\<rbrakk>\n       \\<Longrightarrow> (a'a, a'a) \\<in> Id\n 3. \\<And>a a' aa a'a ab a'b b.\n       \\<lbrakk>(a, a') \\<in> nat_rel; (aa, a'a) \\<in> R;\n        (ab, b) \\<in> \\<langle>R\\<rangle>iam_rel;\n        (b, a'b) \\<in> iam_rel'\\<rbrakk>\n       \\<Longrightarrow> (b, a'b) \\<in> iam_rel'", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iam_delete_impl: \n    \"(iam_delete, op_map_delete) \\<in>\n        nat_rel \\<rightarrow> \\<langle>nat_rel,R\\<rangle>iam_map_rel \\<rightarrow> \\<langle>nat_rel,R\\<rangle>iam_map_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (iam_delete, op_map_delete)\n    \\<in> nat_rel \\<rightarrow>\n          \\<langle>nat_rel, R\\<rangle>iam_map_rel \\<rightarrow>\n          \\<langle>nat_rel, R\\<rangle>iam_map_rel", "unfolding iam_map_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (iam_delete, op_map_delete)\n    \\<in> nat_rel \\<rightarrow>\n          \\<langle>R\\<rangle>iam_rel O iam_rel' \\<rightarrow>\n          \\<langle>R\\<rangle>iam_rel O iam_rel'", "apply (intro fun_relI, elim relcompEpair, intro relcompI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a a' aa a'a b.\n       \\<lbrakk>(a, a') \\<in> nat_rel;\n        (aa, b) \\<in> \\<langle>R\\<rangle>iam_rel;\n        (b, a'a) \\<in> iam_rel'\\<rbrakk>\n       \\<Longrightarrow> (iam_delete a aa, ?b3 a a' aa a'a b)\n                         \\<in> \\<langle>R\\<rangle>iam_rel\n 2. \\<And>a a' aa a'a b.\n       \\<lbrakk>(a, a') \\<in> nat_rel;\n        (aa, b) \\<in> \\<langle>R\\<rangle>iam_rel;\n        (b, a'a) \\<in> iam_rel'\\<rbrakk>\n       \\<Longrightarrow> (?b3 a a' aa a'a b, op_map_delete a' a'a)\n                         \\<in> iam_rel'", "apply (erule (1) param_iam_delete[param_fo])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a b.\n       \\<lbrakk>(a, a') \\<in> nat_rel;\n        (aa, b) \\<in> \\<langle>R\\<rangle>iam_rel;\n        (b, a'a) \\<in> iam_rel'\\<rbrakk>\n       \\<Longrightarrow> (iam_delete a' b, op_map_delete a' a'a)\n                         \\<in> iam_rel'", "apply (rule iam_delete_correct[param_fo])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a a' aa a'a b.\n       \\<lbrakk>(a, a') \\<in> nat_rel;\n        (aa, b) \\<in> \\<langle>R\\<rangle>iam_rel;\n        (b, a'a) \\<in> iam_rel'\\<rbrakk>\n       \\<Longrightarrow> (a', a') \\<in> nat_rel\n 2. \\<And>a a' aa a'a b.\n       \\<lbrakk>(a, a') \\<in> nat_rel;\n        (aa, b) \\<in> \\<langle>R\\<rangle>iam_rel;\n        (b, a'a) \\<in> iam_rel'\\<rbrakk>\n       \\<Longrightarrow> (b, a'a) \\<in> iam_rel'", "by simp_all"], ["", "lemmas iam_map_impl =\n  iam_empty_impl\n  iam_lookup_impl\n  iam_update_impl\n  iam_delete_impl"], ["", "declare iam_map_impl[autoref_rules]"], ["", "subsection \\<open>Iterator proofs\\<close>"], ["", "abbreviation \"iam_to_list a \\<equiv> it_to_list iam_iteratei a\""], ["", "lemma distinct_iam_to_list_aux:\n  shows \"\\<lbrakk>distinct xs; \\<forall>(i,_)\\<in>set xs. i \\<ge> n\\<rbrakk> \\<Longrightarrow> \n        distinct (iam_iteratei_aux n a \n            (\\<lambda>_.True) (\\<lambda>x y. y @ [x]) xs)\" \n   (is \"\\<lbrakk>_;_\\<rbrakk> \\<Longrightarrow> distinct (?iam_to_list_aux n xs)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct xs; \\<forall>(i, uu_)\\<in>set xs. n \\<le> i\\<rbrakk>\n    \\<Longrightarrow> distinct\n                       (iam_iteratei_aux n a (\\<lambda>_. True)\n                         (\\<lambda>x y. y @ [x]) xs)", "proof (induction n arbitrary: xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>distinct xs;\n        \\<forall>(i, uu_)\\<in>set xs. 0 \\<le> i\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (iam_iteratei_aux 0 a (\\<lambda>_. True)\n                            (\\<lambda>x y. y @ [x]) xs)\n 2. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   \\<lbrakk>distinct xs;\n                    \\<forall>(i, uu_)\\<in>set xs. n \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> distinct\n(iam_iteratei_aux n a (\\<lambda>_. True) (\\<lambda>x y. y @ [x]) xs);\n        distinct xs; \\<forall>(i, uu_)\\<in>set xs. Suc n \\<le> i\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (iam_iteratei_aux (Suc n) a (\\<lambda>_. True)\n                            (\\<lambda>x y. y @ [x]) xs)", "case (0 xs)"], ["proof (state)\nthis:\n  distinct xs\n  \\<forall>a\\<in>set xs. case a of (i, uu_) \\<Rightarrow> 0 \\<le> i\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>distinct xs;\n        \\<forall>(i, uu_)\\<in>set xs. 0 \\<le> i\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (iam_iteratei_aux 0 a (\\<lambda>_. True)\n                            (\\<lambda>x y. y @ [x]) xs)\n 2. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   \\<lbrakk>distinct xs;\n                    \\<forall>(i, uu_)\\<in>set xs. n \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> distinct\n(iam_iteratei_aux n a (\\<lambda>_. True) (\\<lambda>x y. y @ [x]) xs);\n        distinct xs; \\<forall>(i, uu_)\\<in>set xs. Suc n \\<le> i\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (iam_iteratei_aux (Suc n) a (\\<lambda>_. True)\n                            (\\<lambda>x y. y @ [x]) xs)", "thus ?case"], ["proof (prove)\nusing this:\n  distinct xs\n  \\<forall>a\\<in>set xs. case a of (i, uu_) \\<Rightarrow> 0 \\<le> i\n\ngoal (1 subgoal):\n 1. distinct\n     (iam_iteratei_aux 0 a (\\<lambda>_. True) (\\<lambda>x y. y @ [x]) xs)", "by simp"], ["proof (state)\nthis:\n  distinct\n   (iam_iteratei_aux 0 a (\\<lambda>_. True) (\\<lambda>x y. y @ [x]) xs)\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   \\<lbrakk>distinct xs;\n                    \\<forall>(i, uu_)\\<in>set xs. n \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> distinct\n(iam_iteratei_aux n a (\\<lambda>_. True) (\\<lambda>x y. y @ [x]) xs);\n        distinct xs; \\<forall>(i, uu_)\\<in>set xs. Suc n \\<le> i\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (iam_iteratei_aux (Suc n) a (\\<lambda>_. True)\n                            (\\<lambda>x y. y @ [x]) xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   \\<lbrakk>distinct xs;\n                    \\<forall>(i, uu_)\\<in>set xs. n \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> distinct\n(iam_iteratei_aux n a (\\<lambda>_. True) (\\<lambda>x y. y @ [x]) xs);\n        distinct xs; \\<forall>(i, uu_)\\<in>set xs. Suc n \\<le> i\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (iam_iteratei_aux (Suc n) a (\\<lambda>_. True)\n                            (\\<lambda>x y. y @ [x]) xs)", "case (Suc i xs)"], ["proof (state)\nthis:\n  \\<lbrakk>distinct ?xs;\n   \\<forall>a\\<in>set ?xs.\n      case a of (ia, uu_) \\<Rightarrow> i \\<le> ia\\<rbrakk>\n  \\<Longrightarrow> distinct\n                     (iam_iteratei_aux i a (\\<lambda>_. True)\n                       (\\<lambda>x y. y @ [x]) ?xs)\n  distinct xs\n  \\<forall>a\\<in>set xs. case a of (ia, uu_) \\<Rightarrow> Suc i \\<le> ia\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   \\<lbrakk>distinct xs;\n                    \\<forall>(i, uu_)\\<in>set xs. n \\<le> i\\<rbrakk>\n                   \\<Longrightarrow> distinct\n(iam_iteratei_aux n a (\\<lambda>_. True) (\\<lambda>x y. y @ [x]) xs);\n        distinct xs; \\<forall>(i, uu_)\\<in>set xs. Suc n \\<le> i\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (iam_iteratei_aux (Suc n) a (\\<lambda>_. True)\n                            (\\<lambda>x y. y @ [x]) xs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     (iam_iteratei_aux (Suc i) a (\\<lambda>_. True) (\\<lambda>x y. y @ [x])\n       xs)", "proof (cases \"array_get a i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. array_get a i = None \\<Longrightarrow>\n    distinct\n     (iam_iteratei_aux (Suc i) a (\\<lambda>_. True) (\\<lambda>x y. y @ [x])\n       xs)\n 2. \\<And>aa.\n       array_get a i = Some aa \\<Longrightarrow>\n       distinct\n        (iam_iteratei_aux (Suc i) a (\\<lambda>_. True)\n          (\\<lambda>x y. y @ [x]) xs)", "case None"], ["proof (state)\nthis:\n  array_get a i = None\n\ngoal (2 subgoals):\n 1. array_get a i = None \\<Longrightarrow>\n    distinct\n     (iam_iteratei_aux (Suc i) a (\\<lambda>_. True) (\\<lambda>x y. y @ [x])\n       xs)\n 2. \\<And>aa.\n       array_get a i = Some aa \\<Longrightarrow>\n       distinct\n        (iam_iteratei_aux (Suc i) a (\\<lambda>_. True)\n          (\\<lambda>x y. y @ [x]) xs)", "with Suc.IH[OF Suc.prems(1)] Suc.prems(2)"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>set xs.\n     case a of (ia, uu_) \\<Rightarrow> i \\<le> ia \\<Longrightarrow>\n  distinct\n   (iam_iteratei_aux i a (\\<lambda>_. True) (\\<lambda>x y. y @ [x]) xs)\n  \\<forall>a\\<in>set xs. case a of (ia, uu_) \\<Rightarrow> Suc i \\<le> ia\n  array_get a i = None", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set xs.\n     case a of (ia, uu_) \\<Rightarrow> i \\<le> ia \\<Longrightarrow>\n  distinct\n   (iam_iteratei_aux i a (\\<lambda>_. True) (\\<lambda>x y. y @ [x]) xs)\n  \\<forall>a\\<in>set xs. case a of (ia, uu_) \\<Rightarrow> Suc i \\<le> ia\n  array_get a i = None\n\ngoal (1 subgoal):\n 1. distinct\n     (iam_iteratei_aux (Suc i) a (\\<lambda>_. True) (\\<lambda>x y. y @ [x])\n       xs)", "by force"], ["proof (state)\nthis:\n  distinct\n   (iam_iteratei_aux (Suc i) a (\\<lambda>_. True) (\\<lambda>x y. y @ [x])\n     xs)\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       array_get a i = Some aa \\<Longrightarrow>\n       distinct\n        (iam_iteratei_aux (Suc i) a (\\<lambda>_. True)\n          (\\<lambda>x y. y @ [x]) xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       array_get a i = Some aa \\<Longrightarrow>\n       distinct\n        (iam_iteratei_aux (Suc i) a (\\<lambda>_. True)\n          (\\<lambda>x y. y @ [x]) xs)", "case (Some x)"], ["proof (state)\nthis:\n  array_get a i = Some x\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       array_get a i = Some aa \\<Longrightarrow>\n       distinct\n        (iam_iteratei_aux (Suc i) a (\\<lambda>_. True)\n          (\\<lambda>x y. y @ [x]) xs)", "let ?xs' = \"xs @ [(i,x)]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       array_get a i = Some aa \\<Longrightarrow>\n       distinct\n        (iam_iteratei_aux (Suc i) a (\\<lambda>_. True)\n          (\\<lambda>x y. y @ [x]) xs)", "from Suc.prems"], ["proof (chain)\npicking this:\n  distinct xs\n  \\<forall>a\\<in>set xs. case a of (ia, uu_) \\<Rightarrow> Suc i \\<le> ia", "have \"distinct ?xs'\" and \n            \"\\<forall>(i',x)\\<in>set ?xs'. i' \\<ge> i\""], ["proof (prove)\nusing this:\n  distinct xs\n  \\<forall>a\\<in>set xs. case a of (ia, uu_) \\<Rightarrow> Suc i \\<le> ia\n\ngoal (1 subgoal):\n 1. distinct (xs @ [(i, x)]) &&&\n    \\<forall>(i', x)\\<in>set (xs @ [(i, x)]). i \\<le> i'", "by force+"], ["proof (state)\nthis:\n  distinct (xs @ [(i, x)])\n  \\<forall>(i', x)\\<in>set (xs @ [(i, x)]). i \\<le> i'\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       array_get a i = Some aa \\<Longrightarrow>\n       distinct\n        (iam_iteratei_aux (Suc i) a (\\<lambda>_. True)\n          (\\<lambda>x y. y @ [x]) xs)", "from Some and Suc.IH[OF this]"], ["proof (chain)\npicking this:\n  array_get a i = Some x\n  distinct\n   (iam_iteratei_aux i a (\\<lambda>_. True) (\\<lambda>x y. y @ [x])\n     (xs @ [(i, x)]))", "show ?thesis"], ["proof (prove)\nusing this:\n  array_get a i = Some x\n  distinct\n   (iam_iteratei_aux i a (\\<lambda>_. True) (\\<lambda>x y. y @ [x])\n     (xs @ [(i, x)]))\n\ngoal (1 subgoal):\n 1. distinct\n     (iam_iteratei_aux (Suc i) a (\\<lambda>_. True) (\\<lambda>x y. y @ [x])\n       xs)", "by simp"], ["proof (state)\nthis:\n  distinct\n   (iam_iteratei_aux (Suc i) a (\\<lambda>_. True) (\\<lambda>x y. y @ [x])\n     xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  distinct\n   (iam_iteratei_aux (Suc i) a (\\<lambda>_. True) (\\<lambda>x y. y @ [x])\n     xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma distinct_iam_to_list:\n  \"distinct (iam_to_list a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (iam_to_list a)", "unfolding it_to_list_def iam_iteratei_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     (iam_iteratei_aux (array_length a) a (\\<lambda>_. True)\n       (\\<lambda>x l. l @ [x]) [])", "by (force intro: distinct_iam_to_list_aux)"], ["", "lemma iam_to_list_set_correct_aux:\n  assumes \"(a, m) \\<in> iam_rel'\"\n  shows \"\\<lbrakk>n \\<le> array_length a; map_to_set m - {(k,v). k < n} = set xs\\<rbrakk>\n         \\<Longrightarrow> map_to_set m = \n             set (iam_iteratei_aux n a (\\<lambda>_.True) (\\<lambda>x y. y @ [x]) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<le> array_length a;\n     map_to_set m - {(k, v). k < n} = set xs\\<rbrakk>\n    \\<Longrightarrow> map_to_set m =\n                      set (iam_iteratei_aux n a (\\<lambda>_. True)\n                            (\\<lambda>x y. y @ [x]) xs)", "proof (induction n arbitrary: xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>0 \\<le> array_length a;\n        map_to_set m - {(k, v). k < 0} = set xs\\<rbrakk>\n       \\<Longrightarrow> map_to_set m =\n                         set (iam_iteratei_aux 0 a (\\<lambda>_. True)\n                               (\\<lambda>x y. y @ [x]) xs)\n 2. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   \\<lbrakk>n \\<le> array_length a;\n                    map_to_set m - {(k, v). k < n} = set xs\\<rbrakk>\n                   \\<Longrightarrow> map_to_set m =\n                                     set\n(iam_iteratei_aux n a (\\<lambda>_. True) (\\<lambda>x y. y @ [x]) xs);\n        Suc n \\<le> array_length a;\n        map_to_set m - {(k, v). k < Suc n} = set xs\\<rbrakk>\n       \\<Longrightarrow> map_to_set m =\n                         set (iam_iteratei_aux (Suc n) a (\\<lambda>_. True)\n                               (\\<lambda>x y. y @ [x]) xs)", "case (0 xs)"], ["proof (state)\nthis:\n  0 \\<le> array_length a\n  map_to_set m - {a. case a of (k, v) \\<Rightarrow> k < 0} = set xs\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>0 \\<le> array_length a;\n        map_to_set m - {(k, v). k < 0} = set xs\\<rbrakk>\n       \\<Longrightarrow> map_to_set m =\n                         set (iam_iteratei_aux 0 a (\\<lambda>_. True)\n                               (\\<lambda>x y. y @ [x]) xs)\n 2. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   \\<lbrakk>n \\<le> array_length a;\n                    map_to_set m - {(k, v). k < n} = set xs\\<rbrakk>\n                   \\<Longrightarrow> map_to_set m =\n                                     set\n(iam_iteratei_aux n a (\\<lambda>_. True) (\\<lambda>x y. y @ [x]) xs);\n        Suc n \\<le> array_length a;\n        map_to_set m - {(k, v). k < Suc n} = set xs\\<rbrakk>\n       \\<Longrightarrow> map_to_set m =\n                         set (iam_iteratei_aux (Suc n) a (\\<lambda>_. True)\n                               (\\<lambda>x y. y @ [x]) xs)", "thus ?case"], ["proof (prove)\nusing this:\n  0 \\<le> array_length a\n  map_to_set m - {a. case a of (k, v) \\<Rightarrow> k < 0} = set xs\n\ngoal (1 subgoal):\n 1. map_to_set m =\n    set (iam_iteratei_aux 0 a (\\<lambda>_. True) (\\<lambda>x y. y @ [x]) xs)", "by simp"], ["proof (state)\nthis:\n  map_to_set m =\n  set (iam_iteratei_aux 0 a (\\<lambda>_. True) (\\<lambda>x y. y @ [x]) xs)\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   \\<lbrakk>n \\<le> array_length a;\n                    map_to_set m - {(k, v). k < n} = set xs\\<rbrakk>\n                   \\<Longrightarrow> map_to_set m =\n                                     set\n(iam_iteratei_aux n a (\\<lambda>_. True) (\\<lambda>x y. y @ [x]) xs);\n        Suc n \\<le> array_length a;\n        map_to_set m - {(k, v). k < Suc n} = set xs\\<rbrakk>\n       \\<Longrightarrow> map_to_set m =\n                         set (iam_iteratei_aux (Suc n) a (\\<lambda>_. True)\n                               (\\<lambda>x y. y @ [x]) xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   \\<lbrakk>n \\<le> array_length a;\n                    map_to_set m - {(k, v). k < n} = set xs\\<rbrakk>\n                   \\<Longrightarrow> map_to_set m =\n                                     set\n(iam_iteratei_aux n a (\\<lambda>_. True) (\\<lambda>x y. y @ [x]) xs);\n        Suc n \\<le> array_length a;\n        map_to_set m - {(k, v). k < Suc n} = set xs\\<rbrakk>\n       \\<Longrightarrow> map_to_set m =\n                         set (iam_iteratei_aux (Suc n) a (\\<lambda>_. True)\n                               (\\<lambda>x y. y @ [x]) xs)", "case (Suc n xs)"], ["proof (state)\nthis:\n  \\<lbrakk>n \\<le> array_length a;\n   map_to_set m - {a. case a of (k, v) \\<Rightarrow> k < n} =\n   set ?xs\\<rbrakk>\n  \\<Longrightarrow> map_to_set m =\n                    set (iam_iteratei_aux n a (\\<lambda>_. True)\n                          (\\<lambda>x y. y @ [x]) ?xs)\n  Suc n \\<le> array_length a\n  map_to_set m - {a. case a of (k, v) \\<Rightarrow> k < Suc n} = set xs\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   \\<lbrakk>n \\<le> array_length a;\n                    map_to_set m - {(k, v). k < n} = set xs\\<rbrakk>\n                   \\<Longrightarrow> map_to_set m =\n                                     set\n(iam_iteratei_aux n a (\\<lambda>_. True) (\\<lambda>x y. y @ [x]) xs);\n        Suc n \\<le> array_length a;\n        map_to_set m - {(k, v). k < Suc n} = set xs\\<rbrakk>\n       \\<Longrightarrow> map_to_set m =\n                         set (iam_iteratei_aux (Suc n) a (\\<lambda>_. True)\n                               (\\<lambda>x y. y @ [x]) xs)", "with assms"], ["proof (chain)\npicking this:\n  (a, m) \\<in> iam_rel'\n  \\<lbrakk>n \\<le> array_length a;\n   map_to_set m - {a. case a of (k, v) \\<Rightarrow> k < n} =\n   set ?xs\\<rbrakk>\n  \\<Longrightarrow> map_to_set m =\n                    set (iam_iteratei_aux n a (\\<lambda>_. True)\n                          (\\<lambda>x y. y @ [x]) ?xs)\n  Suc n \\<le> array_length a\n  map_to_set m - {a. case a of (k, v) \\<Rightarrow> k < Suc n} = set xs", "have [simp]: \"array_get a n = m n\""], ["proof (prove)\nusing this:\n  (a, m) \\<in> iam_rel'\n  \\<lbrakk>n \\<le> array_length a;\n   map_to_set m - {a. case a of (k, v) \\<Rightarrow> k < n} =\n   set ?xs\\<rbrakk>\n  \\<Longrightarrow> map_to_set m =\n                    set (iam_iteratei_aux n a (\\<lambda>_. True)\n                          (\\<lambda>x y. y @ [x]) ?xs)\n  Suc n \\<le> array_length a\n  map_to_set m - {a. case a of (k, v) \\<Rightarrow> k < Suc n} = set xs\n\ngoal (1 subgoal):\n 1. array_get a n = m n", "unfolding iam_rel'_def br_def iam_\\<alpha>_def[abs_def]"], ["proof (prove)\nusing this:\n  (a, m)\n  \\<in> {(c, a).\n         a =\n         (\\<lambda>i.\n             if i < array_length c then array_get c i else None) \\<and>\n         True}\n  \\<lbrakk>n \\<le> array_length a;\n   map_to_set m - {a. case a of (k, v) \\<Rightarrow> k < n} =\n   set ?xs\\<rbrakk>\n  \\<Longrightarrow> map_to_set m =\n                    set (iam_iteratei_aux n a (\\<lambda>_. True)\n                          (\\<lambda>x y. y @ [x]) ?xs)\n  Suc n \\<le> array_length a\n  map_to_set m - {a. case a of (k, v) \\<Rightarrow> k < Suc n} = set xs\n\ngoal (1 subgoal):\n 1. array_get a n = m n", "by simp"], ["proof (state)\nthis:\n  array_get a n = m n\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   \\<lbrakk>n \\<le> array_length a;\n                    map_to_set m - {(k, v). k < n} = set xs\\<rbrakk>\n                   \\<Longrightarrow> map_to_set m =\n                                     set\n(iam_iteratei_aux n a (\\<lambda>_. True) (\\<lambda>x y. y @ [x]) xs);\n        Suc n \\<le> array_length a;\n        map_to_set m - {(k, v). k < Suc n} = set xs\\<rbrakk>\n       \\<Longrightarrow> map_to_set m =\n                         set (iam_iteratei_aux (Suc n) a (\\<lambda>_. True)\n                               (\\<lambda>x y. y @ [x]) xs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_to_set m =\n    set (iam_iteratei_aux (Suc n) a (\\<lambda>_. True)\n          (\\<lambda>x y. y @ [x]) xs)", "proof (cases \"m n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. m n = None \\<Longrightarrow>\n    map_to_set m =\n    set (iam_iteratei_aux (Suc n) a (\\<lambda>_. True)\n          (\\<lambda>x y. y @ [x]) xs)\n 2. \\<And>aa.\n       m n = Some aa \\<Longrightarrow>\n       map_to_set m =\n       set (iam_iteratei_aux (Suc n) a (\\<lambda>_. True)\n             (\\<lambda>x y. y @ [x]) xs)", "case None"], ["proof (state)\nthis:\n  m n = None\n\ngoal (2 subgoals):\n 1. m n = None \\<Longrightarrow>\n    map_to_set m =\n    set (iam_iteratei_aux (Suc n) a (\\<lambda>_. True)\n          (\\<lambda>x y. y @ [x]) xs)\n 2. \\<And>aa.\n       m n = Some aa \\<Longrightarrow>\n       map_to_set m =\n       set (iam_iteratei_aux (Suc n) a (\\<lambda>_. True)\n             (\\<lambda>x y. y @ [x]) xs)", "with Suc.prems(2)"], ["proof (chain)\npicking this:\n  map_to_set m - {a. case a of (k, v) \\<Rightarrow> k < Suc n} = set xs\n  m n = None", "have \"map_to_set m - {(k,v). k < n} = set xs\""], ["proof (prove)\nusing this:\n  map_to_set m - {a. case a of (k, v) \\<Rightarrow> k < Suc n} = set xs\n  m n = None\n\ngoal (1 subgoal):\n 1. map_to_set m - {(k, v). k < n} = set xs", "unfolding map_to_set_def"], ["proof (prove)\nusing this:\n  {(k, v). m k = Some v} - {a. case a of (k, v) \\<Rightarrow> k < Suc n} =\n  set xs\n  m n = None\n\ngoal (1 subgoal):\n 1. {(k, v). m k = Some v} - {(k, v). k < n} = set xs", "by (fastforce simp: less_Suc_eq)"], ["proof (state)\nthis:\n  map_to_set m - {(k, v). k < n} = set xs\n\ngoal (2 subgoals):\n 1. m n = None \\<Longrightarrow>\n    map_to_set m =\n    set (iam_iteratei_aux (Suc n) a (\\<lambda>_. True)\n          (\\<lambda>x y. y @ [x]) xs)\n 2. \\<And>aa.\n       m n = Some aa \\<Longrightarrow>\n       map_to_set m =\n       set (iam_iteratei_aux (Suc n) a (\\<lambda>_. True)\n             (\\<lambda>x y. y @ [x]) xs)", "from None and Suc.IH[OF _ this] and Suc.prems(1)"], ["proof (chain)\npicking this:\n  m n = None\n  n \\<le> array_length a \\<Longrightarrow>\n  map_to_set m =\n  set (iam_iteratei_aux n a (\\<lambda>_. True) (\\<lambda>x y. y @ [x]) xs)\n  Suc n \\<le> array_length a", "show ?thesis"], ["proof (prove)\nusing this:\n  m n = None\n  n \\<le> array_length a \\<Longrightarrow>\n  map_to_set m =\n  set (iam_iteratei_aux n a (\\<lambda>_. True) (\\<lambda>x y. y @ [x]) xs)\n  Suc n \\<le> array_length a\n\ngoal (1 subgoal):\n 1. map_to_set m =\n    set (iam_iteratei_aux (Suc n) a (\\<lambda>_. True)\n          (\\<lambda>x y. y @ [x]) xs)", "by simp"], ["proof (state)\nthis:\n  map_to_set m =\n  set (iam_iteratei_aux (Suc n) a (\\<lambda>_. True) (\\<lambda>x y. y @ [x])\n        xs)\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       m n = Some aa \\<Longrightarrow>\n       map_to_set m =\n       set (iam_iteratei_aux (Suc n) a (\\<lambda>_. True)\n             (\\<lambda>x y. y @ [x]) xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       m n = Some aa \\<Longrightarrow>\n       map_to_set m =\n       set (iam_iteratei_aux (Suc n) a (\\<lambda>_. True)\n             (\\<lambda>x y. y @ [x]) xs)", "case (Some x)"], ["proof (state)\nthis:\n  m n = Some x\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       m n = Some aa \\<Longrightarrow>\n       map_to_set m =\n       set (iam_iteratei_aux (Suc n) a (\\<lambda>_. True)\n             (\\<lambda>x y. y @ [x]) xs)", "let ?xs' = \"xs @ [(n,x)]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       m n = Some aa \\<Longrightarrow>\n       map_to_set m =\n       set (iam_iteratei_aux (Suc n) a (\\<lambda>_. True)\n             (\\<lambda>x y. y @ [x]) xs)", "from Some and Suc.prems(2)"], ["proof (chain)\npicking this:\n  m n = Some x\n  map_to_set m - {a. case a of (k, v) \\<Rightarrow> k < Suc n} = set xs", "have \"map_to_set m - {(k,v). k < n} = set ?xs'\""], ["proof (prove)\nusing this:\n  m n = Some x\n  map_to_set m - {a. case a of (k, v) \\<Rightarrow> k < Suc n} = set xs\n\ngoal (1 subgoal):\n 1. map_to_set m - {(k, v). k < n} = set (xs @ [(n, x)])", "unfolding map_to_set_def"], ["proof (prove)\nusing this:\n  m n = Some x\n  {(k, v). m k = Some v} - {a. case a of (k, v) \\<Rightarrow> k < Suc n} =\n  set xs\n\ngoal (1 subgoal):\n 1. {(k, v). m k = Some v} - {(k, v). k < n} = set (xs @ [(n, x)])", "by (fastforce simp: less_Suc_eq)"], ["proof (state)\nthis:\n  map_to_set m - {(k, v). k < n} = set (xs @ [(n, x)])\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       m n = Some aa \\<Longrightarrow>\n       map_to_set m =\n       set (iam_iteratei_aux (Suc n) a (\\<lambda>_. True)\n             (\\<lambda>x y. y @ [x]) xs)", "from Some and Suc.IH[OF _ this] and Suc.prems(1)"], ["proof (chain)\npicking this:\n  m n = Some x\n  n \\<le> array_length a \\<Longrightarrow>\n  map_to_set m =\n  set (iam_iteratei_aux n a (\\<lambda>_. True) (\\<lambda>x y. y @ [x])\n        (xs @ [(n, x)]))\n  Suc n \\<le> array_length a", "show ?thesis"], ["proof (prove)\nusing this:\n  m n = Some x\n  n \\<le> array_length a \\<Longrightarrow>\n  map_to_set m =\n  set (iam_iteratei_aux n a (\\<lambda>_. True) (\\<lambda>x y. y @ [x])\n        (xs @ [(n, x)]))\n  Suc n \\<le> array_length a\n\ngoal (1 subgoal):\n 1. map_to_set m =\n    set (iam_iteratei_aux (Suc n) a (\\<lambda>_. True)\n          (\\<lambda>x y. y @ [x]) xs)", "by simp"], ["proof (state)\nthis:\n  map_to_set m =\n  set (iam_iteratei_aux (Suc n) a (\\<lambda>_. True) (\\<lambda>x y. y @ [x])\n        xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map_to_set m =\n  set (iam_iteratei_aux (Suc n) a (\\<lambda>_. True) (\\<lambda>x y. y @ [x])\n        xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma iam_to_list_set_correct:\n  assumes \"(a, m) \\<in> iam_rel'\"\n  shows \"map_to_set m = set (iam_to_list a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_to_set m = set (iam_to_list a)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. map_to_set m = set (iam_to_list a)", "from assms"], ["proof (chain)\npicking this:\n  (a, m) \\<in> iam_rel'", "have A: \"map_to_set m - {(k, v). k < array_length a} = set []\""], ["proof (prove)\nusing this:\n  (a, m) \\<in> iam_rel'\n\ngoal (1 subgoal):\n 1. map_to_set m - {(k, v). k < array_length a} = set []", "unfolding map_to_set_def iam_rel'_def br_def iam_\\<alpha>_def[abs_def]"], ["proof (prove)\nusing this:\n  (a, m)\n  \\<in> {(c, a).\n         a =\n         (\\<lambda>i.\n             if i < array_length c then array_get c i else None) \\<and>\n         True}\n\ngoal (1 subgoal):\n 1. {(k, v). m k = Some v} - {(k, v). k < array_length a} = set []", "by (force split: if_split_asm)"], ["proof (state)\nthis:\n  map_to_set m - {(k, v). k < array_length a} = set []\n\ngoal (1 subgoal):\n 1. map_to_set m = set (iam_to_list a)", "with iam_to_list_set_correct_aux[OF assms _ A]"], ["proof (chain)\npicking this:\n  array_length a \\<le> array_length a \\<Longrightarrow>\n  map_to_set m =\n  set (iam_iteratei_aux (array_length a) a (\\<lambda>_. True)\n        (\\<lambda>x y. y @ [x]) [])\n  map_to_set m - {(k, v). k < array_length a} = set []", "show ?thesis"], ["proof (prove)\nusing this:\n  array_length a \\<le> array_length a \\<Longrightarrow>\n  map_to_set m =\n  set (iam_iteratei_aux (array_length a) a (\\<lambda>_. True)\n        (\\<lambda>x y. y @ [x]) [])\n  map_to_set m - {(k, v). k < array_length a} = set []\n\ngoal (1 subgoal):\n 1. map_to_set m = set (iam_to_list a)", "unfolding it_to_list_def iam_iteratei_def"], ["proof (prove)\nusing this:\n  array_length a \\<le> array_length a \\<Longrightarrow>\n  map_to_set m =\n  set (iam_iteratei_aux (array_length a) a (\\<lambda>_. True)\n        (\\<lambda>x y. y @ [x]) [])\n  map_to_set m - {(k, v). k < array_length a} = set []\n\ngoal (1 subgoal):\n 1. map_to_set m =\n    set (iam_iteratei_aux (array_length a) a (\\<lambda>_. True)\n          (\\<lambda>x l. l @ [x]) [])", "by simp"], ["proof (state)\nthis:\n  map_to_set m = set (iam_to_list a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma iam_iteratei_aux_append:\n  \"n \\<le> length xs \\<Longrightarrow> iam_iteratei_aux n (Array (xs @ ys)) = \n             iam_iteratei_aux n (Array xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> length xs \\<Longrightarrow>\n    iam_iteratei_aux n (Array (xs @ ys)) = iam_iteratei_aux n (Array xs)", "apply (induction n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 \\<le> length xs \\<Longrightarrow>\n    iam_iteratei_aux 0 (Array (xs @ ys)) = iam_iteratei_aux 0 (Array xs)\n 2. \\<And>n.\n       \\<lbrakk>n \\<le> length xs \\<Longrightarrow>\n                iam_iteratei_aux n (Array (xs @ ys)) =\n                iam_iteratei_aux n (Array xs);\n        Suc n \\<le> length xs\\<rbrakk>\n       \\<Longrightarrow> iam_iteratei_aux (Suc n) (Array (xs @ ys)) =\n                         iam_iteratei_aux (Suc n) (Array xs)", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n \\<le> length xs \\<Longrightarrow>\n                iam_iteratei_aux n (Array (xs @ ys)) =\n                iam_iteratei_aux n (Array xs);\n        Suc n \\<le> length xs\\<rbrakk>\n       \\<Longrightarrow> iam_iteratei_aux (Suc n) (Array (xs @ ys)) =\n                         iam_iteratei_aux (Suc n) (Array xs)", "apply (intro ext, auto split: option.split simp: nth_append)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iam_iteratei_append: \n  \"iam_iteratei (Array (xs @ [None])) c f \\<sigma> =\n       iam_iteratei (Array xs) c f \\<sigma>\"\n  \"iam_iteratei (Array (xs @ [Some x])) c f \\<sigma> = \n       iam_iteratei (Array xs) c f \n       (if c \\<sigma> then (f (length xs, x) \\<sigma>) else \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iam_iteratei (Array (xs @ [None])) c f \\<sigma> =\n    iam_iteratei (Array xs) c f \\<sigma> &&&\n    iam_iteratei (Array (xs @ [Some x])) c f \\<sigma> =\n    iam_iteratei (Array xs) c f\n     (if c \\<sigma> then f (length xs, x) \\<sigma> else \\<sigma>)", "unfolding  iam_iteratei_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. iam_iteratei_aux (array_length (Array (xs @ [None])))\n     (Array (xs @ [None])) c f \\<sigma> =\n    iam_iteratei_aux (array_length (Array xs)) (Array xs) c f \\<sigma> &&&\n    iam_iteratei_aux (array_length (Array (xs @ [Some x])))\n     (Array (xs @ [Some x])) c f \\<sigma> =\n    iam_iteratei_aux (array_length (Array xs)) (Array xs) c f\n     (if c \\<sigma> then f (length xs, x) \\<sigma> else \\<sigma>)", "apply (cases \"length xs\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. length xs = 0 \\<Longrightarrow>\n    iam_iteratei_aux (array_length (Array (xs @ [None])))\n     (Array (xs @ [None])) c f \\<sigma> =\n    iam_iteratei_aux (array_length (Array xs)) (Array xs) c f \\<sigma>\n 2. \\<And>nat.\n       length xs = Suc nat \\<Longrightarrow>\n       iam_iteratei_aux (array_length (Array (xs @ [None])))\n        (Array (xs @ [None])) c f \\<sigma> =\n       iam_iteratei_aux (array_length (Array xs)) (Array xs) c f \\<sigma>\n 3. iam_iteratei_aux (array_length (Array (xs @ [Some x])))\n     (Array (xs @ [Some x])) c f \\<sigma> =\n    iam_iteratei_aux (array_length (Array xs)) (Array xs) c f\n     (if c \\<sigma> then f (length xs, x) \\<sigma> else \\<sigma>)", "apply (simp add: iam_iteratei_aux_append)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>nat.\n       length xs = Suc nat \\<Longrightarrow>\n       iam_iteratei_aux (array_length (Array (xs @ [None])))\n        (Array (xs @ [None])) c f \\<sigma> =\n       iam_iteratei_aux (array_length (Array xs)) (Array xs) c f \\<sigma>\n 2. iam_iteratei_aux (array_length (Array (xs @ [Some x])))\n     (Array (xs @ [Some x])) c f \\<sigma> =\n    iam_iteratei_aux (array_length (Array xs)) (Array xs) c f\n     (if c \\<sigma> then f (length xs, x) \\<sigma> else \\<sigma>)", "apply (force simp: nth_append iam_iteratei_aux_append) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. iam_iteratei_aux (array_length (Array (xs @ [Some x])))\n     (Array (xs @ [Some x])) c f \\<sigma> =\n    iam_iteratei_aux (array_length (Array xs)) (Array xs) c f\n     (if c \\<sigma> then f (length xs, x) \\<sigma> else \\<sigma>)", "apply (cases \"length xs\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. length xs = 0 \\<Longrightarrow>\n    iam_iteratei_aux (array_length (Array (xs @ [Some x])))\n     (Array (xs @ [Some x])) c f \\<sigma> =\n    iam_iteratei_aux (array_length (Array xs)) (Array xs) c f\n     (if c \\<sigma> then f (length xs, x) \\<sigma> else \\<sigma>)\n 2. \\<And>nat.\n       length xs = Suc nat \\<Longrightarrow>\n       iam_iteratei_aux (array_length (Array (xs @ [Some x])))\n        (Array (xs @ [Some x])) c f \\<sigma> =\n       iam_iteratei_aux (array_length (Array xs)) (Array xs) c f\n        (if c \\<sigma> then f (length xs, x) \\<sigma> else \\<sigma>)", "apply (simp add: iam_iteratei_aux_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       length xs = Suc nat \\<Longrightarrow>\n       iam_iteratei_aux (array_length (Array (xs @ [Some x])))\n        (Array (xs @ [Some x])) c f \\<sigma> =\n       iam_iteratei_aux (array_length (Array xs)) (Array xs) c f\n        (if c \\<sigma> then f (length xs, x) \\<sigma> else \\<sigma>)", "apply (force split: option.split \n             simp: nth_append iam_iteratei_aux_append) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iam_iteratei_aux_Cons:\n  \"n < array_length a \\<Longrightarrow>\n      iam_iteratei_aux n a (\\<lambda>_. True) (\\<lambda>x l. l @ [x]) (x#xs) =\n      x # iam_iteratei_aux n a (\\<lambda>_. True) (\\<lambda>x l. l @ [x]) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < array_length a \\<Longrightarrow>\n    iam_iteratei_aux n a (\\<lambda>_. True) (\\<lambda>x l. l @ [x])\n     (x # xs) =\n    x # iam_iteratei_aux n a (\\<lambda>_. True) (\\<lambda>x l. l @ [x]) xs", "by (induction n arbitrary: xs, auto split: option.split)"], ["", "lemma iam_to_list_append: \n  \"iam_to_list (Array (xs @ [None])) = iam_to_list (Array xs)\"\n  \"iam_to_list (Array (xs @ [Some x])) = \n       (length xs, x) # iam_to_list (Array xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iam_to_list (Array (xs @ [None])) = iam_to_list (Array xs) &&&\n    iam_to_list (Array (xs @ [Some x])) =\n    (length xs, x) # iam_to_list (Array xs)", "unfolding  it_to_list_def iam_iteratei_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. iam_iteratei_aux (array_length (Array (xs @ [None])))\n     (Array (xs @ [None])) (\\<lambda>_. True) (\\<lambda>x l. l @ [x]) [] =\n    iam_iteratei_aux (array_length (Array xs)) (Array xs) (\\<lambda>_. True)\n     (\\<lambda>x l. l @ [x]) [] &&&\n    iam_iteratei_aux (array_length (Array (xs @ [Some x])))\n     (Array (xs @ [Some x])) (\\<lambda>_. True) (\\<lambda>x l. l @ [x]) [] =\n    (length xs, x) #\n    iam_iteratei_aux (array_length (Array xs)) (Array xs) (\\<lambda>_. True)\n     (\\<lambda>x l. l @ [x]) []", "apply (simp add: iam_iteratei_aux_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. iam_iteratei_aux (array_length (Array (xs @ [Some x])))\n     (Array (xs @ [Some x])) (\\<lambda>_. True) (\\<lambda>x l. l @ [x]) [] =\n    (length xs, x) #\n    iam_iteratei_aux (array_length (Array xs)) (Array xs) (\\<lambda>_. True)\n     (\\<lambda>x l. l @ [x]) []", "apply (simp add: iam_iteratei_aux_Cons)"], ["proof (prove)\ngoal (1 subgoal):\n 1. iam_iteratei_aux (length xs) (Array (xs @ [Some x])) (\\<lambda>_. True)\n     (\\<lambda>x l. l @ [x]) [] =\n    iam_iteratei_aux (length xs) (Array xs) (\\<lambda>_. True)\n     (\\<lambda>x l. l @ [x]) []", "apply (simp add: iam_iteratei_aux_append)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma autoref_iam_is_iterator[autoref_ga_rules]: \n  shows \"is_map_to_list nat_rel Rv iam_map_rel iam_to_list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_map_to_list nat_rel Rv iam_map_rel iam_to_list", "unfolding is_map_to_list_def is_map_to_sorted_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>m m'.\n       (m, m') \\<in> \\<langle>nat_rel,\n       Rv\\<rangle>iam_map_rel \\<longrightarrow>\n       (\\<exists>l'.\n           (iam_to_list m, l')\n           \\<in> \\<langle>nat_rel \\<times>\\<^sub>r\n                          Rv\\<rangle>list_rel \\<and>\n           RETURN l'\n           \\<le> it_to_sorted_list (key_rel (\\<lambda>_ _. True))\n                  (map_to_set m'))", "proof (clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m m'.\n       (m, m') \\<in> \\<langle>nat_rel,\n       Rv\\<rangle>iam_map_rel \\<Longrightarrow>\n       \\<exists>l'.\n          (iam_to_list m, l')\n          \\<in> \\<langle>nat_rel \\<times>\\<^sub>r Rv\\<rangle>list_rel \\<and>\n          RETURN l'\n          \\<le> it_to_sorted_list (key_rel (\\<lambda>_ _. True))\n                 (map_to_set m')", "fix a m'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m m'.\n       (m, m') \\<in> \\<langle>nat_rel,\n       Rv\\<rangle>iam_map_rel \\<Longrightarrow>\n       \\<exists>l'.\n          (iam_to_list m, l')\n          \\<in> \\<langle>nat_rel \\<times>\\<^sub>r Rv\\<rangle>list_rel \\<and>\n          RETURN l'\n          \\<le> it_to_sorted_list (key_rel (\\<lambda>_ _. True))\n                 (map_to_set m')", "assume \"(a,m') \\<in> \\<langle>nat_rel,Rv\\<rangle>iam_map_rel\""], ["proof (state)\nthis:\n  (a, m') \\<in> \\<langle>nat_rel, Rv\\<rangle>iam_map_rel\n\ngoal (1 subgoal):\n 1. \\<And>m m'.\n       (m, m') \\<in> \\<langle>nat_rel,\n       Rv\\<rangle>iam_map_rel \\<Longrightarrow>\n       \\<exists>l'.\n          (iam_to_list m, l')\n          \\<in> \\<langle>nat_rel \\<times>\\<^sub>r Rv\\<rangle>list_rel \\<and>\n          RETURN l'\n          \\<le> it_to_sorted_list (key_rel (\\<lambda>_ _. True))\n                 (map_to_set m')", "then"], ["proof (chain)\npicking this:\n  (a, m') \\<in> \\<langle>nat_rel, Rv\\<rangle>iam_map_rel", "obtain a' where [param]: \"(a,a')\\<in>\\<langle>Rv\\<rangle>iam_rel\" \n    and \"(a',m')\\<in>iam_rel'\""], ["proof (prove)\nusing this:\n  (a, m') \\<in> \\<langle>nat_rel, Rv\\<rangle>iam_map_rel\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>(a, a') \\<in> \\<langle>Rv\\<rangle>iam_rel;\n         (a', m') \\<in> iam_rel'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding iam_map_rel_def"], ["proof (prove)\nusing this:\n  (a, m') \\<in> \\<langle>Rv\\<rangle>iam_rel O iam_rel'\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>(a, a') \\<in> \\<langle>Rv\\<rangle>iam_rel;\n         (a', m') \\<in> iam_rel'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (a, a') \\<in> \\<langle>Rv\\<rangle>iam_rel\n  (a', m') \\<in> iam_rel'\n\ngoal (1 subgoal):\n 1. \\<And>m m'.\n       (m, m') \\<in> \\<langle>nat_rel,\n       Rv\\<rangle>iam_map_rel \\<Longrightarrow>\n       \\<exists>l'.\n          (iam_to_list m, l')\n          \\<in> \\<langle>nat_rel \\<times>\\<^sub>r Rv\\<rangle>list_rel \\<and>\n          RETURN l'\n          \\<le> it_to_sorted_list (key_rel (\\<lambda>_ _. True))\n                 (map_to_set m')", "have \"(iam_to_list a, iam_to_list a') \n            \\<in> \\<langle>\\<langle>nat_rel, Rv\\<rangle>prod_rel\\<rangle>list_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (iam_to_list a, iam_to_list a')\n    \\<in> \\<langle>nat_rel \\<times>\\<^sub>r Rv\\<rangle>list_rel", "by parametricity"], ["proof (state)\nthis:\n  (iam_to_list a, iam_to_list a')\n  \\<in> \\<langle>nat_rel \\<times>\\<^sub>r Rv\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. \\<And>m m'.\n       (m, m') \\<in> \\<langle>nat_rel,\n       Rv\\<rangle>iam_map_rel \\<Longrightarrow>\n       \\<exists>l'.\n          (iam_to_list m, l')\n          \\<in> \\<langle>nat_rel \\<times>\\<^sub>r Rv\\<rangle>list_rel \\<and>\n          RETURN l'\n          \\<le> it_to_sorted_list (key_rel (\\<lambda>_ _. True))\n                 (map_to_set m')", "moreover"], ["proof (state)\nthis:\n  (iam_to_list a, iam_to_list a')\n  \\<in> \\<langle>nat_rel \\<times>\\<^sub>r Rv\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. \\<And>m m'.\n       (m, m') \\<in> \\<langle>nat_rel,\n       Rv\\<rangle>iam_map_rel \\<Longrightarrow>\n       \\<exists>l'.\n          (iam_to_list m, l')\n          \\<in> \\<langle>nat_rel \\<times>\\<^sub>r Rv\\<rangle>list_rel \\<and>\n          RETURN l'\n          \\<le> it_to_sorted_list (key_rel (\\<lambda>_ _. True))\n                 (map_to_set m')", "from distinct_iam_to_list and \n                iam_to_list_set_correct[OF \\<open>(a',m')\\<in>iam_rel'\\<close>]"], ["proof (chain)\npicking this:\n  distinct (iam_to_list ?a)\n  map_to_set m' = set (iam_to_list a')", "have \"RETURN (iam_to_list a') \\<le> it_to_sorted_list\n               (key_rel (\\<lambda>_ _. True)) (map_to_set m')\""], ["proof (prove)\nusing this:\n  distinct (iam_to_list ?a)\n  map_to_set m' = set (iam_to_list a')\n\ngoal (1 subgoal):\n 1. RETURN (iam_to_list a')\n    \\<le> it_to_sorted_list (key_rel (\\<lambda>_ _. True)) (map_to_set m')", "unfolding it_to_sorted_list_def key_rel_def[abs_def]"], ["proof (prove)\nusing this:\n  distinct (iam_to_list ?a)\n  map_to_set m' = set (iam_to_list a')\n\ngoal (1 subgoal):\n 1. RETURN (iam_to_list a')\n    \\<le> SPEC\n           (\\<lambda>l.\n               distinct l \\<and>\n               map_to_set m' = set l \\<and>\n               sorted_wrt (\\<lambda>a b. True) l)", "by (force intro: refine_vcg)"], ["proof (state)\nthis:\n  RETURN (iam_to_list a')\n  \\<le> it_to_sorted_list (key_rel (\\<lambda>_ _. True)) (map_to_set m')\n\ngoal (1 subgoal):\n 1. \\<And>m m'.\n       (m, m') \\<in> \\<langle>nat_rel,\n       Rv\\<rangle>iam_map_rel \\<Longrightarrow>\n       \\<exists>l'.\n          (iam_to_list m, l')\n          \\<in> \\<langle>nat_rel \\<times>\\<^sub>r Rv\\<rangle>list_rel \\<and>\n          RETURN l'\n          \\<le> it_to_sorted_list (key_rel (\\<lambda>_ _. True))\n                 (map_to_set m')", "ultimately"], ["proof (chain)\npicking this:\n  (iam_to_list a, iam_to_list a')\n  \\<in> \\<langle>nat_rel \\<times>\\<^sub>r Rv\\<rangle>list_rel\n  RETURN (iam_to_list a')\n  \\<le> it_to_sorted_list (key_rel (\\<lambda>_ _. True)) (map_to_set m')", "show \"\\<exists>l'. (iam_to_list a, l') \\<in> \n                            \\<langle>\\<langle>nat_rel, Rv\\<rangle>prod_rel\\<rangle>list_rel\n                    \\<and> RETURN l' \\<le> it_to_sorted_list (\n                        key_rel (\\<lambda>_ _. True)) (map_to_set m')\""], ["proof (prove)\nusing this:\n  (iam_to_list a, iam_to_list a')\n  \\<in> \\<langle>nat_rel \\<times>\\<^sub>r Rv\\<rangle>list_rel\n  RETURN (iam_to_list a')\n  \\<le> it_to_sorted_list (key_rel (\\<lambda>_ _. True)) (map_to_set m')\n\ngoal (1 subgoal):\n 1. \\<exists>l'.\n       (iam_to_list a, l')\n       \\<in> \\<langle>nat_rel \\<times>\\<^sub>r Rv\\<rangle>list_rel \\<and>\n       RETURN l'\n       \\<le> it_to_sorted_list (key_rel (\\<lambda>_ _. True))\n              (map_to_set m')", "by blast"], ["proof (state)\nthis:\n  \\<exists>l'.\n     (iam_to_list a, l')\n     \\<in> \\<langle>nat_rel \\<times>\\<^sub>r Rv\\<rangle>list_rel \\<and>\n     RETURN l'\n     \\<le> it_to_sorted_list (key_rel (\\<lambda>_ _. True)) (map_to_set m')\n\ngoal:\nNo subgoals!", "qed"], ["", "(* We provide a ,,sorted'' iterator to simplify derivations of the\n    generic algorithm library *)"], ["", "lemmas [autoref_ga_rules] = \n  autoref_iam_is_iterator[unfolded is_map_to_list_def]"], ["", "lemma iam_iteratei_altdef:\n    \"iam_iteratei a = foldli (iam_to_list a)\" \n     (is \"?f a = ?g (iam_to_list a)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. iam_iteratei a = foldli (iam_to_list a)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. iam_iteratei a = foldli (iam_to_list a)", "obtain l where \"a = Array l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l. a = Array l \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (cases a)"], ["proof (state)\nthis:\n  a = Array l\n\ngoal (1 subgoal):\n 1. iam_iteratei a = foldli (iam_to_list a)", "have \"?f (Array l) = ?g (iam_to_list (Array l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iam_iteratei (Array l) = foldli (iam_to_list (Array l))", "proof (induction \"length l\" arbitrary: l)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l.\n       0 = length l \\<Longrightarrow>\n       iam_iteratei (Array l) = foldli (iam_to_list (Array l))\n 2. \\<And>x l.\n       \\<lbrakk>\\<And>l.\n                   x = length l \\<Longrightarrow>\n                   iam_iteratei (Array l) = foldli (iam_to_list (Array l));\n        Suc x = length l\\<rbrakk>\n       \\<Longrightarrow> iam_iteratei (Array l) =\n                         foldli (iam_to_list (Array l))", "case (0 l)"], ["proof (state)\nthis:\n  0 = length l\n\ngoal (2 subgoals):\n 1. \\<And>l.\n       0 = length l \\<Longrightarrow>\n       iam_iteratei (Array l) = foldli (iam_to_list (Array l))\n 2. \\<And>x l.\n       \\<lbrakk>\\<And>l.\n                   x = length l \\<Longrightarrow>\n                   iam_iteratei (Array l) = foldli (iam_to_list (Array l));\n        Suc x = length l\\<rbrakk>\n       \\<Longrightarrow> iam_iteratei (Array l) =\n                         foldli (iam_to_list (Array l))", "thus ?case"], ["proof (prove)\nusing this:\n  0 = length l\n\ngoal (1 subgoal):\n 1. iam_iteratei (Array l) = foldli (iam_to_list (Array l))", "by (intro ext, \n          simp add: iam_iteratei_def it_to_list_def)"], ["proof (state)\nthis:\n  iam_iteratei (Array l) = foldli (iam_to_list (Array l))\n\ngoal (1 subgoal):\n 1. \\<And>x l.\n       \\<lbrakk>\\<And>l.\n                   x = length l \\<Longrightarrow>\n                   iam_iteratei (Array l) = foldli (iam_to_list (Array l));\n        Suc x = length l\\<rbrakk>\n       \\<Longrightarrow> iam_iteratei (Array l) =\n                         foldli (iam_to_list (Array l))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x l.\n       \\<lbrakk>\\<And>l.\n                   x = length l \\<Longrightarrow>\n                   iam_iteratei (Array l) = foldli (iam_to_list (Array l));\n        Suc x = length l\\<rbrakk>\n       \\<Longrightarrow> iam_iteratei (Array l) =\n                         foldli (iam_to_list (Array l))", "case (Suc n l)"], ["proof (state)\nthis:\n  n = length ?l \\<Longrightarrow>\n  iam_iteratei (Array ?l) = foldli (iam_to_list (Array ?l))\n  Suc n = length l\n\ngoal (1 subgoal):\n 1. \\<And>x l.\n       \\<lbrakk>\\<And>l.\n                   x = length l \\<Longrightarrow>\n                   iam_iteratei (Array l) = foldli (iam_to_list (Array l));\n        Suc x = length l\\<rbrakk>\n       \\<Longrightarrow> iam_iteratei (Array l) =\n                         foldli (iam_to_list (Array l))", "hence \"l \\<noteq> []\" and [simp]: \"length l = Suc n\""], ["proof (prove)\nusing this:\n  n = length ?l \\<Longrightarrow>\n  iam_iteratei (Array ?l) = foldli (iam_to_list (Array ?l))\n  Suc n = length l\n\ngoal (1 subgoal):\n 1. l \\<noteq> [] &&& length l = Suc n", "by force+"], ["proof (state)\nthis:\n  l \\<noteq> []\n  length l = Suc n\n\ngoal (1 subgoal):\n 1. \\<And>x l.\n       \\<lbrakk>\\<And>l.\n                   x = length l \\<Longrightarrow>\n                   iam_iteratei (Array l) = foldli (iam_to_list (Array l));\n        Suc x = length l\\<rbrakk>\n       \\<Longrightarrow> iam_iteratei (Array l) =\n                         foldli (iam_to_list (Array l))", "with append_butlast_last_id"], ["proof (chain)\npicking this:\n  ?xs \\<noteq> [] \\<Longrightarrow> butlast ?xs @ [last ?xs] = ?xs\n  l \\<noteq> []\n  length l = Suc n", "have [simp]: \n          \"butlast l @ [last l] = l\""], ["proof (prove)\nusing this:\n  ?xs \\<noteq> [] \\<Longrightarrow> butlast ?xs @ [last ?xs] = ?xs\n  l \\<noteq> []\n  length l = Suc n\n\ngoal (1 subgoal):\n 1. butlast l @ [last l] = l", "by simp"], ["proof (state)\nthis:\n  butlast l @ [last l] = l\n\ngoal (1 subgoal):\n 1. \\<And>x l.\n       \\<lbrakk>\\<And>l.\n                   x = length l \\<Longrightarrow>\n                   iam_iteratei (Array l) = foldli (iam_to_list (Array l));\n        Suc x = length l\\<rbrakk>\n       \\<Longrightarrow> iam_iteratei (Array l) =\n                         foldli (iam_to_list (Array l))", "with Suc"], ["proof (chain)\npicking this:\n  n = length ?l \\<Longrightarrow>\n  iam_iteratei (Array ?l) = foldli (iam_to_list (Array ?l))\n  Suc n = length l\n  butlast l @ [last l] = l", "have [simp]: \"length (butlast l) = n\""], ["proof (prove)\nusing this:\n  n = length ?l \\<Longrightarrow>\n  iam_iteratei (Array ?l) = foldli (iam_to_list (Array ?l))\n  Suc n = length l\n  butlast l @ [last l] = l\n\ngoal (1 subgoal):\n 1. length (butlast l) = n", "by simp"], ["proof (state)\nthis:\n  length (butlast l) = n\n\ngoal (1 subgoal):\n 1. \\<And>x l.\n       \\<lbrakk>\\<And>l.\n                   x = length l \\<Longrightarrow>\n                   iam_iteratei (Array l) = foldli (iam_to_list (Array l));\n        Suc x = length l\\<rbrakk>\n       \\<Longrightarrow> iam_iteratei (Array l) =\n                         foldli (iam_to_list (Array l))", "note IH = Suc(1)[OF this[symmetric]]"], ["proof (state)\nthis:\n  iam_iteratei (Array (butlast l)) =\n  foldli (iam_to_list (Array (butlast l)))\n\ngoal (1 subgoal):\n 1. \\<And>x l.\n       \\<lbrakk>\\<And>l.\n                   x = length l \\<Longrightarrow>\n                   iam_iteratei (Array l) = foldli (iam_to_list (Array l));\n        Suc x = length l\\<rbrakk>\n       \\<Longrightarrow> iam_iteratei (Array l) =\n                         foldli (iam_to_list (Array l))", "let ?l' = \"iam_to_list (Array l)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x l.\n       \\<lbrakk>\\<And>l.\n                   x = length l \\<Longrightarrow>\n                   iam_iteratei (Array l) = foldli (iam_to_list (Array l));\n        Suc x = length l\\<rbrakk>\n       \\<Longrightarrow> iam_iteratei (Array l) =\n                         foldli (iam_to_list (Array l))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. iam_iteratei (Array l) = foldli (iam_to_list (Array l))", "proof (cases \"last l\")"], ["proof (state)\ngoal (2 subgoals):\n 1. last l = None \\<Longrightarrow>\n    iam_iteratei (Array l) = foldli (iam_to_list (Array l))\n 2. \\<And>a.\n       last l = Some a \\<Longrightarrow>\n       iam_iteratei (Array l) = foldli (iam_to_list (Array l))", "case None"], ["proof (state)\nthis:\n  last l = None\n\ngoal (2 subgoals):\n 1. last l = None \\<Longrightarrow>\n    iam_iteratei (Array l) = foldli (iam_to_list (Array l))\n 2. \\<And>a.\n       last l = Some a \\<Longrightarrow>\n       iam_iteratei (Array l) = foldli (iam_to_list (Array l))", "have \"?f (Array l) = \n              ?f (Array (butlast l @ [last l]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iam_iteratei (Array l) = iam_iteratei (Array (butlast l @ [last l]))", "by simp"], ["proof (state)\nthis:\n  iam_iteratei (Array l) = iam_iteratei (Array (butlast l @ [last l]))\n\ngoal (2 subgoals):\n 1. last l = None \\<Longrightarrow>\n    iam_iteratei (Array l) = foldli (iam_to_list (Array l))\n 2. \\<And>a.\n       last l = Some a \\<Longrightarrow>\n       iam_iteratei (Array l) = foldli (iam_to_list (Array l))", "also"], ["proof (state)\nthis:\n  iam_iteratei (Array l) = iam_iteratei (Array (butlast l @ [last l]))\n\ngoal (2 subgoals):\n 1. last l = None \\<Longrightarrow>\n    iam_iteratei (Array l) = foldli (iam_to_list (Array l))\n 2. \\<And>a.\n       last l = Some a \\<Longrightarrow>\n       iam_iteratei (Array l) = foldli (iam_to_list (Array l))", "have \"... = ?g (iam_to_list (Array (butlast l)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iam_iteratei (Array (butlast l @ [last l])) =\n    foldli (iam_to_list (Array (butlast l)))", "by (force simp: None iam_iteratei_append IH)"], ["proof (state)\nthis:\n  iam_iteratei (Array (butlast l @ [last l])) =\n  foldli (iam_to_list (Array (butlast l)))\n\ngoal (2 subgoals):\n 1. last l = None \\<Longrightarrow>\n    iam_iteratei (Array l) = foldli (iam_to_list (Array l))\n 2. \\<And>a.\n       last l = Some a \\<Longrightarrow>\n       iam_iteratei (Array l) = foldli (iam_to_list (Array l))", "also"], ["proof (state)\nthis:\n  iam_iteratei (Array (butlast l @ [last l])) =\n  foldli (iam_to_list (Array (butlast l)))\n\ngoal (2 subgoals):\n 1. last l = None \\<Longrightarrow>\n    iam_iteratei (Array l) = foldli (iam_to_list (Array l))\n 2. \\<And>a.\n       last l = Some a \\<Longrightarrow>\n       iam_iteratei (Array l) = foldli (iam_to_list (Array l))", "have \"iam_to_list (Array (butlast l)) = \n              iam_to_list (Array (butlast l @ [last l]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iam_to_list (Array (butlast l)) =\n    iam_to_list (Array (butlast l @ [last l]))", "using None"], ["proof (prove)\nusing this:\n  last l = None\n\ngoal (1 subgoal):\n 1. iam_to_list (Array (butlast l)) =\n    iam_to_list (Array (butlast l @ [last l]))", "by (simp add: iam_to_list_append)"], ["proof (state)\nthis:\n  iam_to_list (Array (butlast l)) =\n  iam_to_list (Array (butlast l @ [last l]))\n\ngoal (2 subgoals):\n 1. last l = None \\<Longrightarrow>\n    iam_iteratei (Array l) = foldli (iam_to_list (Array l))\n 2. \\<And>a.\n       last l = Some a \\<Longrightarrow>\n       iam_iteratei (Array l) = foldli (iam_to_list (Array l))", "finally"], ["proof (chain)\npicking this:\n  iam_iteratei (Array l) =\n  foldli (iam_to_list (Array (butlast l @ [last l])))", "show \"?f (Array l) = ?g ?l'\""], ["proof (prove)\nusing this:\n  iam_iteratei (Array l) =\n  foldli (iam_to_list (Array (butlast l @ [last l])))\n\ngoal (1 subgoal):\n 1. iam_iteratei (Array l) = foldli (iam_to_list (Array l))", "by simp"], ["proof (state)\nthis:\n  iam_iteratei (Array l) = foldli (iam_to_list (Array l))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       last l = Some a \\<Longrightarrow>\n       iam_iteratei (Array l) = foldli (iam_to_list (Array l))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       last l = Some a \\<Longrightarrow>\n       iam_iteratei (Array l) = foldli (iam_to_list (Array l))", "case (Some x)"], ["proof (state)\nthis:\n  last l = Some x\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       last l = Some a \\<Longrightarrow>\n       iam_iteratei (Array l) = foldli (iam_to_list (Array l))", "have \"?f (Array l) = \n              ?f (Array (butlast l @ [last l]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iam_iteratei (Array l) = iam_iteratei (Array (butlast l @ [last l]))", "by simp"], ["proof (state)\nthis:\n  iam_iteratei (Array l) = iam_iteratei (Array (butlast l @ [last l]))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       last l = Some a \\<Longrightarrow>\n       iam_iteratei (Array l) = foldli (iam_to_list (Array l))", "also"], ["proof (state)\nthis:\n  iam_iteratei (Array l) = iam_iteratei (Array (butlast l @ [last l]))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       last l = Some a \\<Longrightarrow>\n       iam_iteratei (Array l) = foldli (iam_to_list (Array l))", "have \"... = ?g (iam_to_list \n              (Array (butlast l @ [last l])))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iam_iteratei (Array (butlast l @ [last l])) =\n    foldli (iam_to_list (Array (butlast l @ [last l])))", "by (force simp: IH iam_iteratei_append \n                      iam_to_list_append Some)"], ["proof (state)\nthis:\n  iam_iteratei (Array (butlast l @ [last l])) =\n  foldli (iam_to_list (Array (butlast l @ [last l])))\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       last l = Some a \\<Longrightarrow>\n       iam_iteratei (Array l) = foldli (iam_to_list (Array l))", "finally"], ["proof (chain)\npicking this:\n  iam_iteratei (Array l) =\n  foldli (iam_to_list (Array (butlast l @ [last l])))", "show ?thesis"], ["proof (prove)\nusing this:\n  iam_iteratei (Array l) =\n  foldli (iam_to_list (Array (butlast l @ [last l])))\n\ngoal (1 subgoal):\n 1. iam_iteratei (Array l) = foldli (iam_to_list (Array l))", "by simp"], ["proof (state)\nthis:\n  iam_iteratei (Array l) = foldli (iam_to_list (Array l))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  iam_iteratei (Array l) = foldli (iam_to_list (Array l))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  iam_iteratei (Array l) = foldli (iam_to_list (Array l))\n\ngoal (1 subgoal):\n 1. iam_iteratei a = foldli (iam_to_list a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  iam_iteratei (Array l) = foldli (iam_to_list (Array l))\n\ngoal (1 subgoal):\n 1. iam_iteratei a = foldli (iam_to_list a)", "by (simp add: \\<open>a = Array l\\<close>)"], ["proof (state)\nthis:\n  iam_iteratei a = foldli (iam_to_list a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pi_iam[icf_proper_iteratorI]: \n  \"proper_it (iam_iteratei a) (iam_iteratei a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it (iam_iteratei a) (iam_iteratei a)", "unfolding proper_it_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>l. iam_iteratei a = foldli l \\<and> iam_iteratei a = foldli l", "by (force simp: iam_iteratei_altdef)"], ["", "lemma pi'_iam[icf_proper_iteratorI]: \n  \"proper_it' iam_iteratei iam_iteratei\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it' iam_iteratei iam_iteratei", "by (rule proper_it'I, rule pi_iam)"], ["", "end"]]}