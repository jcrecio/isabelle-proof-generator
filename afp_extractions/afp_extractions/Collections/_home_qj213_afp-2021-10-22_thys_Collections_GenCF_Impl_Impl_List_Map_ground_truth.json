{"file_name": "/home/qj213/afp-2021-10-22/thys/Collections/GenCF/Impl/Impl_List_Map.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Collections", "problem_names": ["lemma list_map_rel_def: \n    \"\\<langle>Rk,Rv\\<rangle>list_map_rel = \\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel O br map_of list_map_invar\"", "lemma list_rel_Range:\n    \"\\<forall>x'\\<in>set l'. x' \\<in> Range R \\<Longrightarrow> l' \\<in> Range (\\<langle>R\\<rangle>list_rel)\"", "lemma list_map_rel_range:\n  \"Range (\\<langle>Rk,Rv\\<rangle>list_map_rel) = \n       {m. finite (dom m) \\<and> dom m \\<subseteq> Range Rk \\<and> ran m \\<subseteq> Range Rv}\" \n       (is \"?A = ?B\")", "lemmas [autoref_rel_intf] = REL_INTFI[of list_map_rel i_map]", "lemma list_map_rel_finite[autoref_ga_rules]:\n    \"finite_map_rel (\\<langle>Rk,Rv\\<rangle>list_map_rel)\"", "lemma list_map_rel_sv[relator_props]:\n    \"single_valued Rk \\<Longrightarrow> single_valued Rv \\<Longrightarrow> \n        single_valued (\\<langle>Rk,Rv\\<rangle>list_map_rel)\"", "lemma list_map_autoref_empty[autoref_rules]:\n  \"([], op_map_empty)\\<in>\\<langle>Rk,Rv\\<rangle>list_map_rel\"", "lemma param_list_map_lookup[param]:\n  \"(list_map_lookup,list_map_lookup) \\<in> (Rk \\<rightarrow> Rk \\<rightarrow> bool_rel) \\<rightarrow> \n       Rk \\<rightarrow> \\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel \\<rightarrow> \\<langle>Rv\\<rangle>option_rel\"", "lemma list_map_autoref_lookup_aux:\n  assumes eq: \"GEN_OP eq (=) (Rk\\<rightarrow>Rk\\<rightarrow>Id)\"\n  assumes K: \"(k, k') \\<in> Rk\"\n  assumes M: \"(m, m') \\<in> \\<langle>\\<langle>Rk, Rv\\<rangle>prod_rel\\<rangle>list_rel\"\n  shows \"(list_map_lookup eq k m, op_map_lookup k' (map_of m'))\n               \\<in> \\<langle>Rv\\<rangle>option_rel\"", "lemma list_map_autoref_lookup[autoref_rules]:\n  assumes \"GEN_OP eq (=) (Rk\\<rightarrow>Rk\\<rightarrow>Id)\"\n  shows \"(list_map_lookup eq, op_map_lookup) \\<in> \n       Rk \\<rightarrow> \\<langle>Rk,Rv\\<rangle>list_map_rel \\<rightarrow> \\<langle>Rv\\<rangle>option_rel\"", "lemma param_list_map_update_aux[param]:\n  \"(list_map_update_aux,list_map_update_aux) \\<in> (Rk \\<rightarrow> Rk \\<rightarrow> bool_rel) \\<rightarrow> \n       Rk \\<rightarrow> Rv \\<rightarrow> \\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel \\<rightarrow> \\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel\n        \\<rightarrow> \\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel\"", "lemma param_list_map_update[param]:\n  \"(list_map_update,list_map_update) \\<in> (Rk \\<rightarrow> Rk \\<rightarrow> bool_rel) \\<rightarrow> \n       Rk \\<rightarrow> Rv \\<rightarrow> \\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel \\<rightarrow> \\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel\"", "lemma list_map_autoref_update_aux1:\n  assumes eq: \"(eq,(=)) \\<in> Rk \\<rightarrow> Rk \\<rightarrow> Id\"\n  assumes K: \"(k, k') \\<in> Rk\"\n  assumes V: \"(v, v') \\<in> Rv\"\n  assumes A: \"(accu, accu') \\<in> \\<langle>\\<langle>Rk, Rv\\<rangle>prod_rel\\<rangle>list_rel\"\n  assumes M: \"(m, m') \\<in> \\<langle>\\<langle>Rk, Rv\\<rangle>prod_rel\\<rangle>list_rel\"\n  shows \"(list_map_update_aux eq k v m accu, \n          list_map_update_aux (=) k' v' m' accu')\n               \\<in> \\<langle>\\<langle>Rk, Rv\\<rangle>prod_rel\\<rangle>list_rel\"", "lemma list_map_autoref_update1[param]:\n  assumes eq: \"(eq,(=)) \\<in> Rk \\<rightarrow> Rk \\<rightarrow> Id\"\n  shows \"(list_map_update eq, list_map_update (=)) \\<in> Rk \\<rightarrow> Rv \\<rightarrow> \n             \\<langle>\\<langle>Rk, Rv\\<rangle>prod_rel\\<rangle>list_rel \\<rightarrow> \\<langle>\\<langle>Rk, Rv\\<rangle>prod_rel\\<rangle>list_rel\"", "lemma map_add_sng_right: \"m ++ [k\\<mapsto>v] = m(k \\<mapsto> v)\"", "lemma map_add_sng_right': \n    \"m ++ (\\<lambda>a. if a = k then Some v else None) = m(k \\<mapsto> v)\"", "lemma list_map_autoref_update_aux2:\n  assumes K: \"(k, k') \\<in> Id\"\n  assumes V: \"(v, v') \\<in> Id\"\n  assumes A: \"(accu, accu') \\<in> br map_of list_map_invar\"\n  assumes A1: \"distinct (map fst (m @ accu))\"\n  assumes A2: \"k \\<notin> set (map fst accu)\"\n  assumes M: \"(m, m') \\<in> br map_of list_map_invar\"\n  shows \"(list_map_update_aux (=) k v m accu, \n          accu' ++ op_map_update k' v' m')\n               \\<in> br map_of list_map_invar\" (is \"(?f m accu, _) \\<in> _\")", "lemma list_map_autoref_update2[param]:\n  shows \"(list_map_update (=), op_map_update) \\<in> Id \\<rightarrow> Id \\<rightarrow> \n             br map_of list_map_invar \\<rightarrow> br map_of list_map_invar\"", "lemma list_map_autoref_update[autoref_rules]:\n  assumes eq: \"GEN_OP eq (=) (Rk\\<rightarrow>Rk\\<rightarrow>Id)\"\n  shows \"(list_map_update eq, op_map_update) \\<in>\n      Rk \\<rightarrow> Rv \\<rightarrow> \\<langle>Rk,Rv\\<rangle>list_map_rel \\<rightarrow> \\<langle>Rk,Rv\\<rangle>list_map_rel\"", "lemma list_map_autoref_update_dj[autoref_rules]:\n    assumes \"PRIO_TAG_OPTIMIZATION\"\n    assumes new: \"SIDE_PRECOND_OPT (k' \\<notin> dom m')\"\n    assumes K: \"(k,k')\\<in>Rk\" and V: \"(v,v')\\<in>Rv\"\n    assumes M: \"(l,m')\\<in>\\<langle>Rk, Rv\\<rangle>list_map_rel\"\n    defines \"R_annot \\<equiv> Rk \\<rightarrow> Rv \\<rightarrow> \\<langle>Rk,Rv\\<rangle>list_map_rel \\<rightarrow> \\<langle>Rk,Rv\\<rangle>list_map_rel\"\n    shows \"\n      ((k, v)#l, \n        (OP op_map_update:::R_annot)$k'$v'$m')\n      \\<in> \\<langle>Rk,Rv\\<rangle>list_map_rel\"", "lemma param_list_map_delete_aux[param]:\n  \"(list_map_delete_aux,list_map_delete_aux) \\<in> (Rk \\<rightarrow> Rk \\<rightarrow> bool_rel) \\<rightarrow> \n       Rk \\<rightarrow> \\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel \\<rightarrow> \\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel\n        \\<rightarrow> \\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel\"", "lemma param_list_map_delete[param]:\n  \"(list_map_delete,list_map_delete) \\<in> (Rk \\<rightarrow> Rk \\<rightarrow> bool_rel) \\<rightarrow> \n       Rk \\<rightarrow> \\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel \\<rightarrow> \\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel\"", "lemma list_map_autoref_delete_aux1:\n  assumes eq: \"(eq,(=)) \\<in> Rk \\<rightarrow> Rk \\<rightarrow> Id\"\n  assumes K: \"(k, k') \\<in> Rk\"\n  assumes A: \"(accu, accu') \\<in> \\<langle>\\<langle>Rk, Rv\\<rangle>prod_rel\\<rangle>list_rel\"\n  assumes M: \"(m, m') \\<in> \\<langle>\\<langle>Rk, Rv\\<rangle>prod_rel\\<rangle>list_rel\"\n  shows \"(list_map_delete_aux eq k m accu, \n          list_map_delete_aux (=) k' m' accu')\n               \\<in> \\<langle>\\<langle>Rk, Rv\\<rangle>prod_rel\\<rangle>list_rel\"", "lemma list_map_autoref_delete1[param]:\n  assumes eq: \"(eq,(=)) \\<in> Rk \\<rightarrow> Rk \\<rightarrow> Id\"\n  shows \"(list_map_delete eq, list_map_delete (=)) \\<in> Rk \\<rightarrow> \n             \\<langle>\\<langle>Rk, Rv\\<rangle>prod_rel\\<rangle>list_rel \\<rightarrow> \\<langle>\\<langle>Rk, Rv\\<rangle>prod_rel\\<rangle>list_rel\"", "lemma list_map_autoref_delete_aux2:\n  assumes K: \"(k, k') \\<in> Id\"\n  assumes A: \"(accu, accu') \\<in> br map_of list_map_invar\"\n  assumes A1: \"distinct (map fst (m @ accu))\"\n  assumes A2: \"k \\<notin> set (map fst accu)\"\n  assumes M: \"(m, m') \\<in> br map_of list_map_invar\"\n  shows \"(list_map_delete_aux (=) k m accu, \n          accu' ++ op_map_delete k' m')\n               \\<in> br map_of list_map_invar\" (is \"(?f m accu, _) \\<in> _\")", "lemma list_map_autoref_delete2[param]:\n  shows \"(list_map_delete (=), op_map_delete) \\<in> Id \\<rightarrow> \n             br map_of list_map_invar \\<rightarrow> br map_of list_map_invar\"", "lemma list_map_autoref_delete[autoref_rules]:\n  assumes eq: \"GEN_OP eq (=) (Rk\\<rightarrow>Rk\\<rightarrow>Id)\"\n  shows \"(list_map_delete eq, op_map_delete) \\<in>\n      Rk \\<rightarrow> \\<langle>Rk,Rv\\<rangle>list_map_rel \\<rightarrow> \\<langle>Rk,Rv\\<rangle>list_map_rel\"", "lemma list_map_autoref_isEmpty[autoref_rules]:\n  shows \"(list_map_isEmpty, op_map_isEmpty) \\<in>\n             \\<langle>Rk,Rv\\<rangle>list_map_rel \\<rightarrow> bool_rel\"", "lemma param_list_map_isSng[param]:\n  assumes \"(l,l') \\<in> \\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel\"\n  shows \"(list_map_isSng l, list_map_isSng l') \\<in> bool_rel\"", "lemma list_map_autoref_isSng_aux:\n  assumes \"(l',m') \\<in> br map_of list_map_invar\"\n  shows \"(list_map_isSng l', op_map_isSng m') \\<in> bool_rel\"", "lemma list_map_autoref_isSng[autoref_rules]:\n  \"(list_map_isSng, op_map_isSng) \\<in> \\<langle>Rk,Rv\\<rangle>list_map_rel \\<rightarrow> bool_rel\"", "lemma list_map_autoref_size_aux:\n  assumes \"distinct (map fst x)\"\n  shows \"card (dom (map_of x)) = length x\"", "lemma param_list_map_size[param]:\n  \"(list_map_size, list_map_size) \\<in> \\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel \\<rightarrow> nat_rel\"", "lemma list_map_autoref_size[autoref_rules]:\n  shows \"(list_map_size, op_map_size) \\<in>\n             \\<langle>Rk,Rv\\<rangle>list_map_rel \\<rightarrow> nat_rel\"", "lemma autoref_list_map_is_iterator[autoref_ga_rules]: \n  shows \"is_map_to_list Rk Rv list_map_rel list_map_to_list\"", "lemma pi_list_map[icf_proper_iteratorI]: \n  \"proper_it (list_map_iteratei m) (list_map_iteratei m)\"", "lemma pi'_list_map[icf_proper_iteratorI]: \n  \"proper_it' list_map_iteratei list_map_iteratei\"", "lemma list_map_autoref_pick_remove[autoref_rules]:\n    assumes NE: \"SIDE_PRECOND (m\\<noteq>Map.empty)\"\n    assumes R: \"(l,m)\\<in>\\<langle>Rk,Rv\\<rangle>list_map_rel\"\n    defines \"Rres \\<equiv> \\<langle>(Rk\\<times>\\<^sub>rRv) \\<times>\\<^sub>r \\<langle>Rk,Rv\\<rangle>list_map_rel\\<rangle>nres_rel\"\n    shows \"(\n        RETURN (list_map_pick_remove l),\n        (OP op_map_pick_remove ::: \\<langle>Rk,Rv\\<rangle>list_map_rel \\<rightarrow> Rres)$m\n      ) \\<in> Rres\""], "translations": [["", "lemma list_map_rel_def: \n    \"\\<langle>Rk,Rv\\<rangle>list_map_rel = \\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel O br map_of list_map_invar\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>Rk, Rv\\<rangle>list_map_rel =\n    \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel O\n    br map_of list_map_invar", "unfolding list_map_rel_internal_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>Rk,\n    Rv\\<rangle>(\\<lambda>Rk Rv.\n                   \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel O\n                   br map_of list_map_invar) =\n    \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel O\n    br map_of list_map_invar", "by (simp add: relAPP_def)"], ["", "lemma list_rel_Range:\n    \"\\<forall>x'\\<in>set l'. x' \\<in> Range R \\<Longrightarrow> l' \\<in> Range (\\<langle>R\\<rangle>list_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x'\\<in>set l'. x' \\<in> Range R \\<Longrightarrow>\n    l' \\<in> Range (\\<langle>R\\<rangle>list_rel)", "proof (induction l')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>x'\\<in>set []. x' \\<in> Range R \\<Longrightarrow>\n    [] \\<in> Range (\\<langle>R\\<rangle>list_rel)\n 2. \\<And>a l'.\n       \\<lbrakk>\\<forall>x'\\<in>set l'. x' \\<in> Range R \\<Longrightarrow>\n                l' \\<in> Range (\\<langle>R\\<rangle>list_rel);\n        \\<forall>x'\\<in>set (a # l'). x' \\<in> Range R\\<rbrakk>\n       \\<Longrightarrow> a # l' \\<in> Range (\\<langle>R\\<rangle>list_rel)", "case Nil"], ["proof (state)\nthis:\n  \\<forall>x'\\<in>set []. x' \\<in> Range R\n\ngoal (2 subgoals):\n 1. \\<forall>x'\\<in>set []. x' \\<in> Range R \\<Longrightarrow>\n    [] \\<in> Range (\\<langle>R\\<rangle>list_rel)\n 2. \\<And>a l'.\n       \\<lbrakk>\\<forall>x'\\<in>set l'. x' \\<in> Range R \\<Longrightarrow>\n                l' \\<in> Range (\\<langle>R\\<rangle>list_rel);\n        \\<forall>x'\\<in>set (a # l'). x' \\<in> Range R\\<rbrakk>\n       \\<Longrightarrow> a # l' \\<in> Range (\\<langle>R\\<rangle>list_rel)", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>x'\\<in>set []. x' \\<in> Range R\n\ngoal (1 subgoal):\n 1. [] \\<in> Range (\\<langle>R\\<rangle>list_rel)", "by force"], ["proof (state)\nthis:\n  [] \\<in> Range (\\<langle>R\\<rangle>list_rel)\n\ngoal (1 subgoal):\n 1. \\<And>a l'.\n       \\<lbrakk>\\<forall>x'\\<in>set l'. x' \\<in> Range R \\<Longrightarrow>\n                l' \\<in> Range (\\<langle>R\\<rangle>list_rel);\n        \\<forall>x'\\<in>set (a # l'). x' \\<in> Range R\\<rbrakk>\n       \\<Longrightarrow> a # l' \\<in> Range (\\<langle>R\\<rangle>list_rel)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a l'.\n       \\<lbrakk>\\<forall>x'\\<in>set l'. x' \\<in> Range R \\<Longrightarrow>\n                l' \\<in> Range (\\<langle>R\\<rangle>list_rel);\n        \\<forall>x'\\<in>set (a # l'). x' \\<in> Range R\\<rbrakk>\n       \\<Longrightarrow> a # l' \\<in> Range (\\<langle>R\\<rangle>list_rel)", "case (Cons x' xs')"], ["proof (state)\nthis:\n  \\<forall>x'\\<in>set xs'. x' \\<in> Range R \\<Longrightarrow>\n  xs' \\<in> Range (\\<langle>R\\<rangle>list_rel)\n  \\<forall>x'\\<in>set (x' # xs'). x' \\<in> Range R\n\ngoal (1 subgoal):\n 1. \\<And>a l'.\n       \\<lbrakk>\\<forall>x'\\<in>set l'. x' \\<in> Range R \\<Longrightarrow>\n                l' \\<in> Range (\\<langle>R\\<rangle>list_rel);\n        \\<forall>x'\\<in>set (a # l'). x' \\<in> Range R\\<rbrakk>\n       \\<Longrightarrow> a # l' \\<in> Range (\\<langle>R\\<rangle>list_rel)", "then"], ["proof (chain)\npicking this:\n  \\<forall>x'\\<in>set xs'. x' \\<in> Range R \\<Longrightarrow>\n  xs' \\<in> Range (\\<langle>R\\<rangle>list_rel)\n  \\<forall>x'\\<in>set (x' # xs'). x' \\<in> Range R", "obtain xs where \"(xs,xs') \\<in> \\<langle>R\\<rangle> list_rel\""], ["proof (prove)\nusing this:\n  \\<forall>x'\\<in>set xs'. x' \\<in> Range R \\<Longrightarrow>\n  xs' \\<in> Range (\\<langle>R\\<rangle>list_rel)\n  \\<forall>x'\\<in>set (x' # xs'). x' \\<in> Range R\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        (xs, xs') \\<in> \\<langle>R\\<rangle>list_rel \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  (xs, xs') \\<in> \\<langle>R\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. \\<And>a l'.\n       \\<lbrakk>\\<forall>x'\\<in>set l'. x' \\<in> Range R \\<Longrightarrow>\n                l' \\<in> Range (\\<langle>R\\<rangle>list_rel);\n        \\<forall>x'\\<in>set (a # l'). x' \\<in> Range R\\<rbrakk>\n       \\<Longrightarrow> a # l' \\<in> Range (\\<langle>R\\<rangle>list_rel)", "moreover"], ["proof (state)\nthis:\n  (xs, xs') \\<in> \\<langle>R\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. \\<And>a l'.\n       \\<lbrakk>\\<forall>x'\\<in>set l'. x' \\<in> Range R \\<Longrightarrow>\n                l' \\<in> Range (\\<langle>R\\<rangle>list_rel);\n        \\<forall>x'\\<in>set (a # l'). x' \\<in> Range R\\<rbrakk>\n       \\<Longrightarrow> a # l' \\<in> Range (\\<langle>R\\<rangle>list_rel)", "from Cons.prems"], ["proof (chain)\npicking this:\n  \\<forall>x'\\<in>set (x' # xs'). x' \\<in> Range R", "obtain x where \"(x,x') \\<in> R\""], ["proof (prove)\nusing this:\n  \\<forall>x'\\<in>set (x' # xs'). x' \\<in> Range R\n\ngoal (1 subgoal):\n 1. (\\<And>x. (x, x') \\<in> R \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  (x, x') \\<in> R\n\ngoal (1 subgoal):\n 1. \\<And>a l'.\n       \\<lbrakk>\\<forall>x'\\<in>set l'. x' \\<in> Range R \\<Longrightarrow>\n                l' \\<in> Range (\\<langle>R\\<rangle>list_rel);\n        \\<forall>x'\\<in>set (a # l'). x' \\<in> Range R\\<rbrakk>\n       \\<Longrightarrow> a # l' \\<in> Range (\\<langle>R\\<rangle>list_rel)", "ultimately"], ["proof (chain)\npicking this:\n  (xs, xs') \\<in> \\<langle>R\\<rangle>list_rel\n  (x, x') \\<in> R", "have \"(x#xs, x'#xs') \\<in> \\<langle>R\\<rangle> list_rel\""], ["proof (prove)\nusing this:\n  (xs, xs') \\<in> \\<langle>R\\<rangle>list_rel\n  (x, x') \\<in> R\n\ngoal (1 subgoal):\n 1. (x # xs, x' # xs') \\<in> \\<langle>R\\<rangle>list_rel", "by simp"], ["proof (state)\nthis:\n  (x # xs, x' # xs') \\<in> \\<langle>R\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. \\<And>a l'.\n       \\<lbrakk>\\<forall>x'\\<in>set l'. x' \\<in> Range R \\<Longrightarrow>\n                l' \\<in> Range (\\<langle>R\\<rangle>list_rel);\n        \\<forall>x'\\<in>set (a # l'). x' \\<in> Range R\\<rbrakk>\n       \\<Longrightarrow> a # l' \\<in> Range (\\<langle>R\\<rangle>list_rel)", "thus ?case"], ["proof (prove)\nusing this:\n  (x # xs, x' # xs') \\<in> \\<langle>R\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. x' # xs' \\<in> Range (\\<langle>R\\<rangle>list_rel)", ".."], ["proof (state)\nthis:\n  x' # xs' \\<in> Range (\\<langle>R\\<rangle>list_rel)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>All finite maps can be represented\\<close>"], ["", "lemma list_map_rel_range:\n  \"Range (\\<langle>Rk,Rv\\<rangle>list_map_rel) = \n       {m. finite (dom m) \\<and> dom m \\<subseteq> Range Rk \\<and> ran m \\<subseteq> Range Rv}\" \n       (is \"?A = ?B\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Range (\\<langle>Rk, Rv\\<rangle>list_map_rel) =\n    {m. finite (dom m) \\<and>\n        dom m \\<subseteq> Range Rk \\<and> ran m \\<subseteq> Range Rv}", "proof (intro equalityI subsetI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> Range\n                (\\<langle>Rk, Rv\\<rangle>list_map_rel) \\<Longrightarrow>\n       x \\<in> {m. finite (dom m) \\<and>\n                   dom m \\<subseteq> Range Rk \\<and>\n                   ran m \\<subseteq> Range Rv}\n 2. \\<And>x.\n       x \\<in> {m. finite (dom m) \\<and>\n                   dom m \\<subseteq> Range Rk \\<and>\n                   ran m \\<subseteq> Range Rv} \\<Longrightarrow>\n       x \\<in> Range (\\<langle>Rk, Rv\\<rangle>list_map_rel)", "fix m'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> Range\n                (\\<langle>Rk, Rv\\<rangle>list_map_rel) \\<Longrightarrow>\n       x \\<in> {m. finite (dom m) \\<and>\n                   dom m \\<subseteq> Range Rk \\<and>\n                   ran m \\<subseteq> Range Rv}\n 2. \\<And>x.\n       x \\<in> {m. finite (dom m) \\<and>\n                   dom m \\<subseteq> Range Rk \\<and>\n                   ran m \\<subseteq> Range Rv} \\<Longrightarrow>\n       x \\<in> Range (\\<langle>Rk, Rv\\<rangle>list_map_rel)", "assume \"m' \\<in> ?A\""], ["proof (state)\nthis:\n  m' \\<in> Range (\\<langle>Rk, Rv\\<rangle>list_map_rel)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> Range\n                (\\<langle>Rk, Rv\\<rangle>list_map_rel) \\<Longrightarrow>\n       x \\<in> {m. finite (dom m) \\<and>\n                   dom m \\<subseteq> Range Rk \\<and>\n                   ran m \\<subseteq> Range Rv}\n 2. \\<And>x.\n       x \\<in> {m. finite (dom m) \\<and>\n                   dom m \\<subseteq> Range Rk \\<and>\n                   ran m \\<subseteq> Range Rv} \\<Longrightarrow>\n       x \\<in> Range (\\<langle>Rk, Rv\\<rangle>list_map_rel)", "then"], ["proof (chain)\npicking this:\n  m' \\<in> Range (\\<langle>Rk, Rv\\<rangle>list_map_rel)", "obtain l l' where A: \"(l,l') \\<in> \\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel\" and\n                         B: \"m' = map_of l'\" and C: \"list_map_invar l'\""], ["proof (prove)\nusing this:\n  m' \\<in> Range (\\<langle>Rk, Rv\\<rangle>list_map_rel)\n\ngoal (1 subgoal):\n 1. (\\<And>l l'.\n        \\<lbrakk>(l, l')\n                 \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel;\n         m' = map_of l'; list_map_invar l'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding list_map_rel_def br_def"], ["proof (prove)\nusing this:\n  m' \\<in> Range\n            (\\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel O\n             {(c, a). a = map_of c \\<and> list_map_invar c})\n\ngoal (1 subgoal):\n 1. (\\<And>l l'.\n        \\<lbrakk>(l, l')\n                 \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel;\n         m' = map_of l'; list_map_invar l'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (l, l') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n  m' = map_of l'\n  list_map_invar l'\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> Range\n                (\\<langle>Rk, Rv\\<rangle>list_map_rel) \\<Longrightarrow>\n       x \\<in> {m. finite (dom m) \\<and>\n                   dom m \\<subseteq> Range Rk \\<and>\n                   ran m \\<subseteq> Range Rv}\n 2. \\<And>x.\n       x \\<in> {m. finite (dom m) \\<and>\n                   dom m \\<subseteq> Range Rk \\<and>\n                   ran m \\<subseteq> Range Rv} \\<Longrightarrow>\n       x \\<in> Range (\\<langle>Rk, Rv\\<rangle>list_map_rel)", "{"], ["proof (state)\nthis:\n  (l, l') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n  m' = map_of l'\n  list_map_invar l'\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> Range\n                (\\<langle>Rk, Rv\\<rangle>list_map_rel) \\<Longrightarrow>\n       x \\<in> {m. finite (dom m) \\<and>\n                   dom m \\<subseteq> Range Rk \\<and>\n                   ran m \\<subseteq> Range Rv}\n 2. \\<And>x.\n       x \\<in> {m. finite (dom m) \\<and>\n                   dom m \\<subseteq> Range Rk \\<and>\n                   ran m \\<subseteq> Range Rv} \\<Longrightarrow>\n       x \\<in> Range (\\<langle>Rk, Rv\\<rangle>list_map_rel)", "fix x' y'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> Range\n                (\\<langle>Rk, Rv\\<rangle>list_map_rel) \\<Longrightarrow>\n       x \\<in> {m. finite (dom m) \\<and>\n                   dom m \\<subseteq> Range Rk \\<and>\n                   ran m \\<subseteq> Range Rv}\n 2. \\<And>x.\n       x \\<in> {m. finite (dom m) \\<and>\n                   dom m \\<subseteq> Range Rk \\<and>\n                   ran m \\<subseteq> Range Rv} \\<Longrightarrow>\n       x \\<in> Range (\\<langle>Rk, Rv\\<rangle>list_map_rel)", "assume \"m' x' = Some y'\""], ["proof (state)\nthis:\n  m' x' = Some y'\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> Range\n                (\\<langle>Rk, Rv\\<rangle>list_map_rel) \\<Longrightarrow>\n       x \\<in> {m. finite (dom m) \\<and>\n                   dom m \\<subseteq> Range Rk \\<and>\n                   ran m \\<subseteq> Range Rv}\n 2. \\<And>x.\n       x \\<in> {m. finite (dom m) \\<and>\n                   dom m \\<subseteq> Range Rk \\<and>\n                   ran m \\<subseteq> Range Rv} \\<Longrightarrow>\n       x \\<in> Range (\\<langle>Rk, Rv\\<rangle>list_map_rel)", "with B"], ["proof (chain)\npicking this:\n  m' = map_of l'\n  m' x' = Some y'", "have \"(x',y') \\<in> set l'\""], ["proof (prove)\nusing this:\n  m' = map_of l'\n  m' x' = Some y'\n\ngoal (1 subgoal):\n 1. (x', y') \\<in> set l'", "by (fast dest: map_of_SomeD)"], ["proof (state)\nthis:\n  (x', y') \\<in> set l'\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> Range\n                (\\<langle>Rk, Rv\\<rangle>list_map_rel) \\<Longrightarrow>\n       x \\<in> {m. finite (dom m) \\<and>\n                   dom m \\<subseteq> Range Rk \\<and>\n                   ran m \\<subseteq> Range Rv}\n 2. \\<And>x.\n       x \\<in> {m. finite (dom m) \\<and>\n                   dom m \\<subseteq> Range Rk \\<and>\n                   ran m \\<subseteq> Range Rv} \\<Longrightarrow>\n       x \\<in> Range (\\<langle>Rk, Rv\\<rangle>list_map_rel)", "hence \"x' \\<in> Range Rk\" and \"y' \\<in> Range Rv\""], ["proof (prove)\nusing this:\n  (x', y') \\<in> set l'\n\ngoal (1 subgoal):\n 1. x' \\<in> Range Rk &&& y' \\<in> Range Rv", "by (induction rule: list_rel_induct[OF A], auto)"], ["proof (state)\nthis:\n  x' \\<in> Range Rk\n  y' \\<in> Range Rv\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> Range\n                (\\<langle>Rk, Rv\\<rangle>list_map_rel) \\<Longrightarrow>\n       x \\<in> {m. finite (dom m) \\<and>\n                   dom m \\<subseteq> Range Rk \\<and>\n                   ran m \\<subseteq> Range Rv}\n 2. \\<And>x.\n       x \\<in> {m. finite (dom m) \\<and>\n                   dom m \\<subseteq> Range Rk \\<and>\n                   ran m \\<subseteq> Range Rv} \\<Longrightarrow>\n       x \\<in> Range (\\<langle>Rk, Rv\\<rangle>list_map_rel)", "}"], ["proof (state)\nthis:\n  m' ?x'2 = Some ?y'2 \\<Longrightarrow> ?x'2 \\<in> Range Rk\n  m' ?x'2 = Some ?y'2 \\<Longrightarrow> ?y'2 \\<in> Range Rv\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> Range\n                (\\<langle>Rk, Rv\\<rangle>list_map_rel) \\<Longrightarrow>\n       x \\<in> {m. finite (dom m) \\<and>\n                   dom m \\<subseteq> Range Rk \\<and>\n                   ran m \\<subseteq> Range Rv}\n 2. \\<And>x.\n       x \\<in> {m. finite (dom m) \\<and>\n                   dom m \\<subseteq> Range Rk \\<and>\n                   ran m \\<subseteq> Range Rv} \\<Longrightarrow>\n       x \\<in> Range (\\<langle>Rk, Rv\\<rangle>list_map_rel)", "with B"], ["proof (chain)\npicking this:\n  m' = map_of l'\n  m' ?x'2 = Some ?y'2 \\<Longrightarrow> ?x'2 \\<in> Range Rk\n  m' ?x'2 = Some ?y'2 \\<Longrightarrow> ?y'2 \\<in> Range Rv", "show \"m' \\<in> ?B\""], ["proof (prove)\nusing this:\n  m' = map_of l'\n  m' ?x'2 = Some ?y'2 \\<Longrightarrow> ?x'2 \\<in> Range Rk\n  m' ?x'2 = Some ?y'2 \\<Longrightarrow> ?y'2 \\<in> Range Rv\n\ngoal (1 subgoal):\n 1. m' \\<in> {m. finite (dom m) \\<and>\n                 dom m \\<subseteq> Range Rk \\<and>\n                 ran m \\<subseteq> Range Rv}", "by (force dest: map_of_SomeD simp: ran_def)"], ["proof (state)\nthis:\n  m' \\<in> {m. finite (dom m) \\<and>\n               dom m \\<subseteq> Range Rk \\<and> ran m \\<subseteq> Range Rv}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {m. finite (dom m) \\<and>\n                   dom m \\<subseteq> Range Rk \\<and>\n                   ran m \\<subseteq> Range Rv} \\<Longrightarrow>\n       x \\<in> Range (\\<langle>Rk, Rv\\<rangle>list_map_rel)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {m. finite (dom m) \\<and>\n                   dom m \\<subseteq> Range Rk \\<and>\n                   ran m \\<subseteq> Range Rv} \\<Longrightarrow>\n       x \\<in> Range (\\<langle>Rk, Rv\\<rangle>list_map_rel)", "fix m'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {m. finite (dom m) \\<and>\n                   dom m \\<subseteq> Range Rk \\<and>\n                   ran m \\<subseteq> Range Rv} \\<Longrightarrow>\n       x \\<in> Range (\\<langle>Rk, Rv\\<rangle>list_map_rel)", "assume \"m' \\<in> ?B\""], ["proof (state)\nthis:\n  m' \\<in> {m. finite (dom m) \\<and>\n               dom m \\<subseteq> Range Rk \\<and> ran m \\<subseteq> Range Rv}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {m. finite (dom m) \\<and>\n                   dom m \\<subseteq> Range Rk \\<and>\n                   ran m \\<subseteq> Range Rv} \\<Longrightarrow>\n       x \\<in> Range (\\<langle>Rk, Rv\\<rangle>list_map_rel)", "hence A: \"finite (dom m')\" and B: \"dom m' \\<subseteq> Range Rk\" and \n        C: \"ran m' \\<subseteq> Range Rv\""], ["proof (prove)\nusing this:\n  m' \\<in> {m. finite (dom m) \\<and>\n               dom m \\<subseteq> Range Rk \\<and> ran m \\<subseteq> Range Rv}\n\ngoal (1 subgoal):\n 1. finite (dom m') &&&\n    dom m' \\<subseteq> Range Rk &&& ran m' \\<subseteq> Range Rv", "by simp_all"], ["proof (state)\nthis:\n  finite (dom m')\n  dom m' \\<subseteq> Range Rk\n  ran m' \\<subseteq> Range Rv\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {m. finite (dom m) \\<and>\n                   dom m \\<subseteq> Range Rk \\<and>\n                   ran m \\<subseteq> Range Rv} \\<Longrightarrow>\n       x \\<in> Range (\\<langle>Rk, Rv\\<rangle>list_map_rel)", "from A"], ["proof (chain)\npicking this:\n  finite (dom m')", "have \"finite (map_to_set m')\""], ["proof (prove)\nusing this:\n  finite (dom m')\n\ngoal (1 subgoal):\n 1. finite (map_to_set m')", "by (simp add: finite_map_to_set)"], ["proof (state)\nthis:\n  finite (map_to_set m')\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {m. finite (dom m) \\<and>\n                   dom m \\<subseteq> Range Rk \\<and>\n                   ran m \\<subseteq> Range Rv} \\<Longrightarrow>\n       x \\<in> Range (\\<langle>Rk, Rv\\<rangle>list_map_rel)", "from finite_distinct_list[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>xs. set xs = map_to_set m' \\<and> distinct xs", "obtain l' where l'_props: \"distinct l'\" \"set l' = map_to_set m'\""], ["proof (prove)\nusing this:\n  \\<exists>xs. set xs = map_to_set m' \\<and> distinct xs\n\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>distinct l'; set l' = map_to_set m'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  distinct l'\n  set l' = map_to_set m'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {m. finite (dom m) \\<and>\n                   dom m \\<subseteq> Range Rk \\<and>\n                   ran m \\<subseteq> Range Rv} \\<Longrightarrow>\n       x \\<in> Range (\\<langle>Rk, Rv\\<rangle>list_map_rel)", "hence *: \"distinct (map fst l')\""], ["proof (prove)\nusing this:\n  distinct l'\n  set l' = map_to_set m'\n\ngoal (1 subgoal):\n 1. distinct (map fst l')", "by (force simp: distinct_map inj_on_def map_to_set_def)"], ["proof (state)\nthis:\n  distinct (map fst l')\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {m. finite (dom m) \\<and>\n                   dom m \\<subseteq> Range Rk \\<and>\n                   ran m \\<subseteq> Range Rv} \\<Longrightarrow>\n       x \\<in> Range (\\<langle>Rk, Rv\\<rangle>list_map_rel)", "from map_of_map_to_set[OF this] and l'_props"], ["proof (chain)\npicking this:\n  (map_of l' = ?m) = (set l' = map_to_set ?m)\n  distinct l'\n  set l' = map_to_set m'", "have  \"map_of l' = m'\""], ["proof (prove)\nusing this:\n  (map_of l' = ?m) = (set l' = map_to_set ?m)\n  distinct l'\n  set l' = map_to_set m'\n\ngoal (1 subgoal):\n 1. map_of l' = m'", "by simp"], ["proof (state)\nthis:\n  map_of l' = m'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {m. finite (dom m) \\<and>\n                   dom m \\<subseteq> Range Rk \\<and>\n                   ran m \\<subseteq> Range Rv} \\<Longrightarrow>\n       x \\<in> Range (\\<langle>Rk, Rv\\<rangle>list_map_rel)", "with *"], ["proof (chain)\npicking this:\n  distinct (map fst l')\n  map_of l' = m'", "have \"(l',m') \\<in> br map_of list_map_invar\""], ["proof (prove)\nusing this:\n  distinct (map fst l')\n  map_of l' = m'\n\ngoal (1 subgoal):\n 1. (l', m') \\<in> br map_of list_map_invar", "unfolding br_def list_map_invar_def o_def"], ["proof (prove)\nusing this:\n  distinct (map fst l')\n  map_of l' = m'\n\ngoal (1 subgoal):\n 1. (l', m') \\<in> {(c, a). a = map_of c \\<and> distinct (map fst c)}", "by simp"], ["proof (state)\nthis:\n  (l', m') \\<in> br map_of list_map_invar\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {m. finite (dom m) \\<and>\n                   dom m \\<subseteq> Range Rk \\<and>\n                   ran m \\<subseteq> Range Rv} \\<Longrightarrow>\n       x \\<in> Range (\\<langle>Rk, Rv\\<rangle>list_map_rel)", "moreover"], ["proof (state)\nthis:\n  (l', m') \\<in> br map_of list_map_invar\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {m. finite (dom m) \\<and>\n                   dom m \\<subseteq> Range Rk \\<and>\n                   ran m \\<subseteq> Range Rv} \\<Longrightarrow>\n       x \\<in> Range (\\<langle>Rk, Rv\\<rangle>list_map_rel)", "from B and C and l'_props"], ["proof (chain)\npicking this:\n  dom m' \\<subseteq> Range Rk\n  ran m' \\<subseteq> Range Rv\n  distinct l'\n  set l' = map_to_set m'", "have \"\\<forall>x \\<in> set l'. x \\<in> Range (\\<langle>Rk,Rv\\<rangle>prod_rel)\""], ["proof (prove)\nusing this:\n  dom m' \\<subseteq> Range Rk\n  ran m' \\<subseteq> Range Rv\n  distinct l'\n  set l' = map_to_set m'\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set l'. x \\<in> Range (Rk \\<times>\\<^sub>r Rv)", "unfolding map_to_set_def ran_def prod_rel_def"], ["proof (prove)\nusing this:\n  dom m' \\<subseteq> Range Rk\n  {b. \\<exists>a. m' a = Some b} \\<subseteq> Range Rv\n  distinct l'\n  set l' = {(k, v). m' k = Some v}\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set l'.\n       x \\<in> Range\n                {((a, b), a', b'). (a, a') \\<in> Rk \\<and> (b, b') \\<in> Rv}", "by force"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set l'. x \\<in> Range (Rk \\<times>\\<^sub>r Rv)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {m. finite (dom m) \\<and>\n                   dom m \\<subseteq> Range Rk \\<and>\n                   ran m \\<subseteq> Range Rv} \\<Longrightarrow>\n       x \\<in> Range (\\<langle>Rk, Rv\\<rangle>list_map_rel)", "from list_rel_Range[OF this]"], ["proof (chain)\npicking this:\n  l' \\<in> Range (\\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel)", "obtain l where \n      \"(l,l') \\<in> \\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel\""], ["proof (prove)\nusing this:\n  l' \\<in> Range (\\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel)\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        (l, l')\n        \\<in> \\<langle>Rk \\<times>\\<^sub>r\n                       Rv\\<rangle>list_rel \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  (l, l') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {m. finite (dom m) \\<and>\n                   dom m \\<subseteq> Range Rk \\<and>\n                   ran m \\<subseteq> Range Rv} \\<Longrightarrow>\n       x \\<in> Range (\\<langle>Rk, Rv\\<rangle>list_map_rel)", "ultimately"], ["proof (chain)\npicking this:\n  (l', m') \\<in> br map_of list_map_invar\n  (l, l') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel", "show \"m' \\<in> ?A\""], ["proof (prove)\nusing this:\n  (l', m') \\<in> br map_of list_map_invar\n  (l, l') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. m' \\<in> Range (\\<langle>Rk, Rv\\<rangle>list_map_rel)", "unfolding list_map_rel_def"], ["proof (prove)\nusing this:\n  (l', m') \\<in> br map_of list_map_invar\n  (l, l') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. m' \\<in> Range\n              (\\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel O\n               br map_of list_map_invar)", "by blast"], ["proof (state)\nthis:\n  m' \\<in> Range (\\<langle>Rk, Rv\\<rangle>list_map_rel)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas [autoref_rel_intf] = REL_INTFI[of list_map_rel i_map]"], ["", "lemma list_map_rel_finite[autoref_ga_rules]:\n    \"finite_map_rel (\\<langle>Rk,Rv\\<rangle>list_map_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_map_rel (\\<langle>Rk, Rv\\<rangle>list_map_rel)", "unfolding finite_map_rel_def list_map_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Range\n     (\\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel O\n      br map_of list_map_invar)\n    \\<subseteq> Collect (finite \\<circ> dom)", "by (auto simp: br_def)"], ["", "lemma list_map_rel_sv[relator_props]:\n    \"single_valued Rk \\<Longrightarrow> single_valued Rv \\<Longrightarrow> \n        single_valued (\\<langle>Rk,Rv\\<rangle>list_map_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>single_valued Rk; single_valued Rv\\<rbrakk>\n    \\<Longrightarrow> single_valued (\\<langle>Rk, Rv\\<rangle>list_map_rel)", "unfolding list_map_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>single_valued Rk; single_valued Rv\\<rbrakk>\n    \\<Longrightarrow> single_valued\n                       (\\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel O\n                        br map_of list_map_invar)", "by tagged_solver"], ["", "(* TODO: Move to Misc *)"], ["", "subsection \\<open>Implementation\\<close>"], ["", "primrec list_map_lookup :: \n    \"('k \\<Rightarrow> 'k \\<Rightarrow> bool) \\<Rightarrow> 'k \\<Rightarrow> ('k,'v) list_map \\<Rightarrow> 'v option\" where\n\"list_map_lookup eq _ [] = None\" |\n\"list_map_lookup eq k (y#ys) = \n     (if eq (fst y) k then Some (snd y) else list_map_lookup eq k ys)\""], ["", "primrec list_map_update_aux :: \"('k \\<Rightarrow> 'k \\<Rightarrow> bool) \\<Rightarrow> 'k \\<Rightarrow> 'v \\<Rightarrow> \n    ('k,'v) list_map \\<Rightarrow> ('k,'v) list_map \\<Rightarrow> ('k,'v) list_map\"where\n\"list_map_update_aux eq k v [] accu = (k,v) # accu\" |\n\"list_map_update_aux eq k v (x#xs) accu = \n    (if eq (fst x) k\n        then (k,v) # xs @ accu \n        else list_map_update_aux eq k v xs (x#accu))\""], ["", "definition \"list_map_update eq k v m \\<equiv> \n    list_map_update_aux eq k v m []\""], ["", "primrec list_map_delete_aux :: \"('k \\<Rightarrow> 'k \\<Rightarrow> bool) \\<Rightarrow> 'k \\<Rightarrow> \n    ('k, 'v) list_map \\<Rightarrow> ('k, 'v) list_map \\<Rightarrow> ('k, 'v) list_map\" where\n\"list_map_delete_aux eq k [] accu = accu\" |\n\"list_map_delete_aux eq k (x#xs) accu =\n    (if eq (fst x) k\n        then xs @ accu\n        else list_map_delete_aux eq k xs (x#accu))\""], ["", "definition \"list_map_delete eq k m \\<equiv> list_map_delete_aux eq k m []\""], ["", "definition list_map_isEmpty :: \"('k,'v) list_map \\<Rightarrow> bool\"\n    where \"list_map_isEmpty \\<equiv> List.null\""], ["", "definition list_map_isSng :: \"('k,'v) list_map \\<Rightarrow> bool\"\n    where \"list_map_isSng m = (case m of [x] \\<Rightarrow> True | _ \\<Rightarrow> False)\""], ["", "definition list_map_size :: \"('k,'v) list_map \\<Rightarrow> nat\"\n    where \"list_map_size \\<equiv> length\""], ["", "definition list_map_iteratei :: \"('k,'v) list_map \\<Rightarrow> ('b \\<Rightarrow> bool) \\<Rightarrow>\n    (('k\\<times>'v) \\<Rightarrow> 'b \\<Rightarrow> 'b) \\<Rightarrow> 'b \\<Rightarrow> 'b\"\n    where \"list_map_iteratei \\<equiv> foldli\""], ["", "definition list_map_to_list :: \"('k,'v) list_map \\<Rightarrow> ('k\\<times>'v) list\"\n    where \"list_map_to_list = id\""], ["", "subsection \\<open>Parametricity\\<close>"], ["", "lemma list_map_autoref_empty[autoref_rules]:\n  \"([], op_map_empty)\\<in>\\<langle>Rk,Rv\\<rangle>list_map_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([], op_map_empty) \\<in> \\<langle>Rk, Rv\\<rangle>list_map_rel", "by (auto simp: list_map_rel_def br_def list_map_invar_def)"], ["", "lemma param_list_map_lookup[param]:\n  \"(list_map_lookup,list_map_lookup) \\<in> (Rk \\<rightarrow> Rk \\<rightarrow> bool_rel) \\<rightarrow> \n       Rk \\<rightarrow> \\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel \\<rightarrow> \\<langle>Rv\\<rangle>option_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_map_lookup, list_map_lookup)\n    \\<in> (Rk \\<rightarrow> Rk \\<rightarrow> bool_rel) \\<rightarrow>\n          Rk \\<rightarrow>\n          \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel \\<rightarrow>\n          \\<langle>Rv\\<rangle>option_rel", "unfolding list_map_lookup_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>uu uua uub.\n        rec_list (\\<lambda>eq. Map.empty)\n         (\\<lambda>y ys ysa eq k.\n             if eq (fst y) k then Some (snd y) else ysa eq k)\n         uub uu uua,\n     \\<lambda>uu uua uub.\n        rec_list (\\<lambda>eq. Map.empty)\n         (\\<lambda>y ys ysa eq k.\n             if eq (fst y) k then Some (snd y) else ysa eq k)\n         uub uu uua)\n    \\<in> (Rk \\<rightarrow> Rk \\<rightarrow> bool_rel) \\<rightarrow>\n          Rk \\<rightarrow>\n          \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel \\<rightarrow>\n          \\<langle>Rv\\<rangle>option_rel", "by parametricity"], ["", "lemma list_map_autoref_lookup_aux:\n  assumes eq: \"GEN_OP eq (=) (Rk\\<rightarrow>Rk\\<rightarrow>Id)\"\n  assumes K: \"(k, k') \\<in> Rk\"\n  assumes M: \"(m, m') \\<in> \\<langle>\\<langle>Rk, Rv\\<rangle>prod_rel\\<rangle>list_rel\"\n  shows \"(list_map_lookup eq k m, op_map_lookup k' (map_of m'))\n               \\<in> \\<langle>Rv\\<rangle>option_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_map_lookup eq k m, op_map_lookup k' (map_of m'))\n    \\<in> \\<langle>Rv\\<rangle>option_rel", "unfolding op_map_lookup_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_map_lookup eq k m, map_of m' k')\n    \\<in> \\<langle>Rv\\<rangle>option_rel", "proof (induction rule: list_rel_induct[OF M, case_names Nil Cons])"], ["proof (state)\ngoal (2 subgoals):\n 1. (list_map_lookup eq k [], map_of [] k')\n    \\<in> \\<langle>Rv\\<rangle>option_rel\n 2. \\<And>x x' l l'.\n       \\<lbrakk>(x, x') \\<in> Rk \\<times>\\<^sub>r Rv;\n        (l, l') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel;\n        (list_map_lookup eq k l, map_of l' k')\n        \\<in> \\<langle>Rv\\<rangle>option_rel\\<rbrakk>\n       \\<Longrightarrow> (list_map_lookup eq k (x # l), map_of (x' # l') k')\n                         \\<in> \\<langle>Rv\\<rangle>option_rel", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. (list_map_lookup eq k [], map_of [] k')\n    \\<in> \\<langle>Rv\\<rangle>option_rel\n 2. \\<And>x x' l l'.\n       \\<lbrakk>(x, x') \\<in> Rk \\<times>\\<^sub>r Rv;\n        (l, l') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel;\n        (list_map_lookup eq k l, map_of l' k')\n        \\<in> \\<langle>Rv\\<rangle>option_rel\\<rbrakk>\n       \\<Longrightarrow> (list_map_lookup eq k (x # l), map_of (x' # l') k')\n                         \\<in> \\<langle>Rv\\<rangle>option_rel", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_map_lookup eq k [], map_of [] k')\n    \\<in> \\<langle>Rv\\<rangle>option_rel", "by simp"], ["proof (state)\nthis:\n  (list_map_lookup eq k [], map_of [] k')\n  \\<in> \\<langle>Rv\\<rangle>option_rel\n\ngoal (1 subgoal):\n 1. \\<And>x x' l l'.\n       \\<lbrakk>(x, x') \\<in> Rk \\<times>\\<^sub>r Rv;\n        (l, l') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel;\n        (list_map_lookup eq k l, map_of l' k')\n        \\<in> \\<langle>Rv\\<rangle>option_rel\\<rbrakk>\n       \\<Longrightarrow> (list_map_lookup eq k (x # l), map_of (x' # l') k')\n                         \\<in> \\<langle>Rv\\<rangle>option_rel", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x x' l l'.\n       \\<lbrakk>(x, x') \\<in> Rk \\<times>\\<^sub>r Rv;\n        (l, l') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel;\n        (list_map_lookup eq k l, map_of l' k')\n        \\<in> \\<langle>Rv\\<rangle>option_rel\\<rbrakk>\n       \\<Longrightarrow> (list_map_lookup eq k (x # l), map_of (x' # l') k')\n                         \\<in> \\<langle>Rv\\<rangle>option_rel", "case (Cons x x' xs xs')"], ["proof (state)\nthis:\n  (x, x') \\<in> Rk \\<times>\\<^sub>r Rv\n  (xs, xs') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n  (list_map_lookup eq k xs, map_of xs' k')\n  \\<in> \\<langle>Rv\\<rangle>option_rel\n\ngoal (1 subgoal):\n 1. \\<And>x x' l l'.\n       \\<lbrakk>(x, x') \\<in> Rk \\<times>\\<^sub>r Rv;\n        (l, l') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel;\n        (list_map_lookup eq k l, map_of l' k')\n        \\<in> \\<langle>Rv\\<rangle>option_rel\\<rbrakk>\n       \\<Longrightarrow> (list_map_lookup eq k (x # l), map_of (x' # l') k')\n                         \\<in> \\<langle>Rv\\<rangle>option_rel", "from eq"], ["proof (chain)\npicking this:\n  GEN_OP eq (=) (Rk \\<rightarrow> Rk \\<rightarrow> bool_rel)", "have eq': \"(eq,(=)) \\<in> Rk \\<rightarrow> Rk \\<rightarrow> Id\""], ["proof (prove)\nusing this:\n  GEN_OP eq (=) (Rk \\<rightarrow> Rk \\<rightarrow> bool_rel)\n\ngoal (1 subgoal):\n 1. (eq, (=)) \\<in> Rk \\<rightarrow> Rk \\<rightarrow> bool_rel", "by simp"], ["proof (state)\nthis:\n  (eq, (=)) \\<in> Rk \\<rightarrow> Rk \\<rightarrow> bool_rel\n\ngoal (1 subgoal):\n 1. \\<And>x x' l l'.\n       \\<lbrakk>(x, x') \\<in> Rk \\<times>\\<^sub>r Rv;\n        (l, l') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel;\n        (list_map_lookup eq k l, map_of l' k')\n        \\<in> \\<langle>Rv\\<rangle>option_rel\\<rbrakk>\n       \\<Longrightarrow> (list_map_lookup eq k (x # l), map_of (x' # l') k')\n                         \\<in> \\<langle>Rv\\<rangle>option_rel", "with eq'[param_fo] and K  and Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>(?x1, ?x'1) \\<in> Rk; (?x, ?x') \\<in> Rk\\<rbrakk>\n  \\<Longrightarrow> (eq ?x1 ?x, ?x'1 = ?x') \\<in> bool_rel\n  (k, k') \\<in> Rk\n  (x, x') \\<in> Rk \\<times>\\<^sub>r Rv\n  (xs, xs') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n  (list_map_lookup eq k xs, map_of xs' k')\n  \\<in> \\<langle>Rv\\<rangle>option_rel\n  (eq, (=)) \\<in> Rk \\<rightarrow> Rk \\<rightarrow> bool_rel", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?x1, ?x'1) \\<in> Rk; (?x, ?x') \\<in> Rk\\<rbrakk>\n  \\<Longrightarrow> (eq ?x1 ?x, ?x'1 = ?x') \\<in> bool_rel\n  (k, k') \\<in> Rk\n  (x, x') \\<in> Rk \\<times>\\<^sub>r Rv\n  (xs, xs') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n  (list_map_lookup eq k xs, map_of xs' k')\n  \\<in> \\<langle>Rv\\<rangle>option_rel\n  (eq, (=)) \\<in> Rk \\<rightarrow> Rk \\<rightarrow> bool_rel\n\ngoal (1 subgoal):\n 1. (list_map_lookup eq k (x # xs), map_of (x' # xs') k')\n    \\<in> \\<langle>Rv\\<rangle>option_rel", "by (force simp: prod_rel_def)"], ["proof (state)\nthis:\n  (list_map_lookup eq k (x # xs), map_of (x' # xs') k')\n  \\<in> \\<langle>Rv\\<rangle>option_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma list_map_autoref_lookup[autoref_rules]:\n  assumes \"GEN_OP eq (=) (Rk\\<rightarrow>Rk\\<rightarrow>Id)\"\n  shows \"(list_map_lookup eq, op_map_lookup) \\<in> \n       Rk \\<rightarrow> \\<langle>Rk,Rv\\<rangle>list_map_rel \\<rightarrow> \\<langle>Rv\\<rangle>option_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_map_lookup eq, op_map_lookup)\n    \\<in> Rk \\<rightarrow>\n          \\<langle>Rk, Rv\\<rangle>list_map_rel \\<rightarrow>\n          \\<langle>Rv\\<rangle>option_rel", "by (force simp: list_map_rel_def br_def\n             dest: list_map_autoref_lookup_aux[OF assms])"], ["", "lemma param_list_map_update_aux[param]:\n  \"(list_map_update_aux,list_map_update_aux) \\<in> (Rk \\<rightarrow> Rk \\<rightarrow> bool_rel) \\<rightarrow> \n       Rk \\<rightarrow> Rv \\<rightarrow> \\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel \\<rightarrow> \\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel\n        \\<rightarrow> \\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_map_update_aux, list_map_update_aux)\n    \\<in> (Rk \\<rightarrow> Rk \\<rightarrow> bool_rel) \\<rightarrow>\n          Rk \\<rightarrow>\n          Rv \\<rightarrow>\n          \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel \\<rightarrow>\n          \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel \\<rightarrow>\n          \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel", "unfolding list_map_update_aux_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>uu uua uub uuc.\n        rec_list (\\<lambda>eq k v. (#) (k, v))\n         (\\<lambda>x xs xsa eq k v accu.\n             if eq (fst x) k then (k, v) # xs @ accu\n             else xsa eq k v (x # accu))\n         uuc uu uua uub,\n     \\<lambda>uu uua uub uuc.\n        rec_list (\\<lambda>eq k v. (#) (k, v))\n         (\\<lambda>x xs xsa eq k v accu.\n             if eq (fst x) k then (k, v) # xs @ accu\n             else xsa eq k v (x # accu))\n         uuc uu uua uub)\n    \\<in> (Rk \\<rightarrow> Rk \\<rightarrow> bool_rel) \\<rightarrow>\n          Rk \\<rightarrow>\n          Rv \\<rightarrow>\n          \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel \\<rightarrow>\n          \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel \\<rightarrow>\n          \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel", "by parametricity"], ["", "lemma param_list_map_update[param]:\n  \"(list_map_update,list_map_update) \\<in> (Rk \\<rightarrow> Rk \\<rightarrow> bool_rel) \\<rightarrow> \n       Rk \\<rightarrow> Rv \\<rightarrow> \\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel \\<rightarrow> \\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_map_update, list_map_update)\n    \\<in> (Rk \\<rightarrow> Rk \\<rightarrow> bool_rel) \\<rightarrow>\n          Rk \\<rightarrow>\n          Rv \\<rightarrow>\n          \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel \\<rightarrow>\n          \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel", "unfolding list_map_update_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>eq k v m. list_map_update_aux eq k v m [],\n     \\<lambda>eq k v m. list_map_update_aux eq k v m [])\n    \\<in> (Rk \\<rightarrow> Rk \\<rightarrow> bool_rel) \\<rightarrow>\n          Rk \\<rightarrow>\n          Rv \\<rightarrow>\n          \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel \\<rightarrow>\n          \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel", "by parametricity"], ["", "lemma list_map_autoref_update_aux1:\n  assumes eq: \"(eq,(=)) \\<in> Rk \\<rightarrow> Rk \\<rightarrow> Id\"\n  assumes K: \"(k, k') \\<in> Rk\"\n  assumes V: \"(v, v') \\<in> Rv\"\n  assumes A: \"(accu, accu') \\<in> \\<langle>\\<langle>Rk, Rv\\<rangle>prod_rel\\<rangle>list_rel\"\n  assumes M: \"(m, m') \\<in> \\<langle>\\<langle>Rk, Rv\\<rangle>prod_rel\\<rangle>list_rel\"\n  shows \"(list_map_update_aux eq k v m accu, \n          list_map_update_aux (=) k' v' m' accu')\n               \\<in> \\<langle>\\<langle>Rk, Rv\\<rangle>prod_rel\\<rangle>list_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_map_update_aux eq k v m accu,\n     list_map_update_aux (=) k' v' m' accu')\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel", "proof (insert A, induction arbitrary: accu accu' \n           rule: list_rel_induct[OF M, case_names Nil Cons])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>accu accu'.\n       (accu, accu')\n       \\<in> \\<langle>Rk \\<times>\\<^sub>r\n                      Rv\\<rangle>list_rel \\<Longrightarrow>\n       (list_map_update_aux eq k v [] accu,\n        list_map_update_aux (=) k' v' [] accu')\n       \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n 2. \\<And>x x' l l' accu accu'.\n       \\<lbrakk>(x, x') \\<in> Rk \\<times>\\<^sub>r Rv;\n        (l, l') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel;\n        \\<And>accu accu'.\n           (accu, accu')\n           \\<in> \\<langle>Rk \\<times>\\<^sub>r\n                          Rv\\<rangle>list_rel \\<Longrightarrow>\n           (list_map_update_aux eq k v l accu,\n            list_map_update_aux (=) k' v' l' accu')\n           \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel;\n        (accu, accu')\n        \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (list_map_update_aux eq k v (x # l) accu,\n                          list_map_update_aux (=) k' v' (x' # l') accu')\n                         \\<in> \\<langle>Rk \\<times>\\<^sub>r\n  Rv\\<rangle>list_rel", "case Nil"], ["proof (state)\nthis:\n  (accu, accu') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n\ngoal (2 subgoals):\n 1. \\<And>accu accu'.\n       (accu, accu')\n       \\<in> \\<langle>Rk \\<times>\\<^sub>r\n                      Rv\\<rangle>list_rel \\<Longrightarrow>\n       (list_map_update_aux eq k v [] accu,\n        list_map_update_aux (=) k' v' [] accu')\n       \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n 2. \\<And>x x' l l' accu accu'.\n       \\<lbrakk>(x, x') \\<in> Rk \\<times>\\<^sub>r Rv;\n        (l, l') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel;\n        \\<And>accu accu'.\n           (accu, accu')\n           \\<in> \\<langle>Rk \\<times>\\<^sub>r\n                          Rv\\<rangle>list_rel \\<Longrightarrow>\n           (list_map_update_aux eq k v l accu,\n            list_map_update_aux (=) k' v' l' accu')\n           \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel;\n        (accu, accu')\n        \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (list_map_update_aux eq k v (x # l) accu,\n                          list_map_update_aux (=) k' v' (x' # l') accu')\n                         \\<in> \\<langle>Rk \\<times>\\<^sub>r\n  Rv\\<rangle>list_rel", "thus ?case"], ["proof (prove)\nusing this:\n  (accu, accu') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. (list_map_update_aux eq k v [] accu,\n     list_map_update_aux (=) k' v' [] accu')\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel", "by (simp add: K V)"], ["proof (state)\nthis:\n  (list_map_update_aux eq k v [] accu,\n   list_map_update_aux (=) k' v' [] accu')\n  \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. \\<And>x x' l l' accu accu'.\n       \\<lbrakk>(x, x') \\<in> Rk \\<times>\\<^sub>r Rv;\n        (l, l') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel;\n        \\<And>accu accu'.\n           (accu, accu')\n           \\<in> \\<langle>Rk \\<times>\\<^sub>r\n                          Rv\\<rangle>list_rel \\<Longrightarrow>\n           (list_map_update_aux eq k v l accu,\n            list_map_update_aux (=) k' v' l' accu')\n           \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel;\n        (accu, accu')\n        \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (list_map_update_aux eq k v (x # l) accu,\n                          list_map_update_aux (=) k' v' (x' # l') accu')\n                         \\<in> \\<langle>Rk \\<times>\\<^sub>r\n  Rv\\<rangle>list_rel", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x x' l l' accu accu'.\n       \\<lbrakk>(x, x') \\<in> Rk \\<times>\\<^sub>r Rv;\n        (l, l') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel;\n        \\<And>accu accu'.\n           (accu, accu')\n           \\<in> \\<langle>Rk \\<times>\\<^sub>r\n                          Rv\\<rangle>list_rel \\<Longrightarrow>\n           (list_map_update_aux eq k v l accu,\n            list_map_update_aux (=) k' v' l' accu')\n           \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel;\n        (accu, accu')\n        \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (list_map_update_aux eq k v (x # l) accu,\n                          list_map_update_aux (=) k' v' (x' # l') accu')\n                         \\<in> \\<langle>Rk \\<times>\\<^sub>r\n  Rv\\<rangle>list_rel", "case (Cons x x' xs xs')"], ["proof (state)\nthis:\n  (x, x') \\<in> Rk \\<times>\\<^sub>r Rv\n  (xs, xs') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n  (?accu, ?accu')\n  \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel \\<Longrightarrow>\n  (list_map_update_aux eq k v xs ?accu,\n   list_map_update_aux (=) k' v' xs' ?accu')\n  \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n  (accu, accu') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. \\<And>x x' l l' accu accu'.\n       \\<lbrakk>(x, x') \\<in> Rk \\<times>\\<^sub>r Rv;\n        (l, l') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel;\n        \\<And>accu accu'.\n           (accu, accu')\n           \\<in> \\<langle>Rk \\<times>\\<^sub>r\n                          Rv\\<rangle>list_rel \\<Longrightarrow>\n           (list_map_update_aux eq k v l accu,\n            list_map_update_aux (=) k' v' l' accu')\n           \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel;\n        (accu, accu')\n        \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (list_map_update_aux eq k v (x # l) accu,\n                          list_map_update_aux (=) k' v' (x' # l') accu')\n                         \\<in> \\<langle>Rk \\<times>\\<^sub>r\n  Rv\\<rangle>list_rel", "from eq"], ["proof (chain)\npicking this:\n  (eq, (=)) \\<in> Rk \\<rightarrow> Rk \\<rightarrow> bool_rel", "have eq': \"(eq,(=)) \\<in> Rk \\<rightarrow> Rk \\<rightarrow> Id\""], ["proof (prove)\nusing this:\n  (eq, (=)) \\<in> Rk \\<rightarrow> Rk \\<rightarrow> bool_rel\n\ngoal (1 subgoal):\n 1. (eq, (=)) \\<in> Rk \\<rightarrow> Rk \\<rightarrow> bool_rel", "by simp"], ["proof (state)\nthis:\n  (eq, (=)) \\<in> Rk \\<rightarrow> Rk \\<rightarrow> bool_rel\n\ngoal (1 subgoal):\n 1. \\<And>x x' l l' accu accu'.\n       \\<lbrakk>(x, x') \\<in> Rk \\<times>\\<^sub>r Rv;\n        (l, l') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel;\n        \\<And>accu accu'.\n           (accu, accu')\n           \\<in> \\<langle>Rk \\<times>\\<^sub>r\n                          Rv\\<rangle>list_rel \\<Longrightarrow>\n           (list_map_update_aux eq k v l accu,\n            list_map_update_aux (=) k' v' l' accu')\n           \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel;\n        (accu, accu')\n        \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (list_map_update_aux eq k v (x # l) accu,\n                          list_map_update_aux (=) k' v' (x' # l') accu')\n                         \\<in> \\<langle>Rk \\<times>\\<^sub>r\n  Rv\\<rangle>list_rel", "from eq'[param_fo] Cons(1) K"], ["proof (chain)\npicking this:\n  \\<lbrakk>(?x1, ?x'1) \\<in> Rk; (?x, ?x') \\<in> Rk\\<rbrakk>\n  \\<Longrightarrow> (eq ?x1 ?x, ?x'1 = ?x') \\<in> bool_rel\n  (x, x') \\<in> Rk \\<times>\\<^sub>r Rv\n  (k, k') \\<in> Rk", "have [simp]: \"(eq (fst x) k) \\<longleftrightarrow> ((fst x') = k')\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(?x1, ?x'1) \\<in> Rk; (?x, ?x') \\<in> Rk\\<rbrakk>\n  \\<Longrightarrow> (eq ?x1 ?x, ?x'1 = ?x') \\<in> bool_rel\n  (x, x') \\<in> Rk \\<times>\\<^sub>r Rv\n  (k, k') \\<in> Rk\n\ngoal (1 subgoal):\n 1. eq (fst x) k = (fst x' = k')", "by (force simp: prod_rel_def)"], ["proof (state)\nthis:\n  eq (fst x) k = (fst x' = k')\n\ngoal (1 subgoal):\n 1. \\<And>x x' l l' accu accu'.\n       \\<lbrakk>(x, x') \\<in> Rk \\<times>\\<^sub>r Rv;\n        (l, l') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel;\n        \\<And>accu accu'.\n           (accu, accu')\n           \\<in> \\<langle>Rk \\<times>\\<^sub>r\n                          Rv\\<rangle>list_rel \\<Longrightarrow>\n           (list_map_update_aux eq k v l accu,\n            list_map_update_aux (=) k' v' l' accu')\n           \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel;\n        (accu, accu')\n        \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (list_map_update_aux eq k v (x # l) accu,\n                          list_map_update_aux (=) k' v' (x' # l') accu')\n                         \\<in> \\<langle>Rk \\<times>\\<^sub>r\n  Rv\\<rangle>list_rel", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_map_update_aux eq k v (x # xs) accu,\n     list_map_update_aux (=) k' v' (x' # xs') accu')\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel", "proof (cases \"eq (fst x) k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. eq (fst x) k \\<Longrightarrow>\n    (list_map_update_aux eq k v (x # xs) accu,\n     list_map_update_aux (=) k' v' (x' # xs') accu')\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n 2. \\<not> eq (fst x) k \\<Longrightarrow>\n    (list_map_update_aux eq k v (x # xs) accu,\n     list_map_update_aux (=) k' v' (x' # xs') accu')\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel", "case False"], ["proof (state)\nthis:\n  \\<not> eq (fst x) k\n\ngoal (2 subgoals):\n 1. eq (fst x) k \\<Longrightarrow>\n    (list_map_update_aux eq k v (x # xs) accu,\n     list_map_update_aux (=) k' v' (x' # xs') accu')\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n 2. \\<not> eq (fst x) k \\<Longrightarrow>\n    (list_map_update_aux eq k v (x # xs) accu,\n     list_map_update_aux (=) k' v' (x' # xs') accu')\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel", "from Cons.prems and Cons.hyps"], ["proof (chain)\npicking this:\n  (accu, accu') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n  (x, x') \\<in> Rk \\<times>\\<^sub>r Rv\n  (xs, xs') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel", "have \"(x # accu, x' # accu') \\<in> \n            \\<langle>\\<langle>Rk, Rv\\<rangle>prod_rel\\<rangle>list_rel\""], ["proof (prove)\nusing this:\n  (accu, accu') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n  (x, x') \\<in> Rk \\<times>\\<^sub>r Rv\n  (xs, xs') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. (x # accu, x' # accu')\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel", "by parametricity"], ["proof (state)\nthis:\n  (x # accu, x' # accu')\n  \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n\ngoal (2 subgoals):\n 1. eq (fst x) k \\<Longrightarrow>\n    (list_map_update_aux eq k v (x # xs) accu,\n     list_map_update_aux (=) k' v' (x' # xs') accu')\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n 2. \\<not> eq (fst x) k \\<Longrightarrow>\n    (list_map_update_aux eq k v (x # xs) accu,\n     list_map_update_aux (=) k' v' (x' # xs') accu')\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel", "from Cons.IH[OF this] and False"], ["proof (chain)\npicking this:\n  (list_map_update_aux eq k v xs (x # accu),\n   list_map_update_aux (=) k' v' xs' (x' # accu'))\n  \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n  \\<not> eq (fst x) k", "show ?thesis"], ["proof (prove)\nusing this:\n  (list_map_update_aux eq k v xs (x # accu),\n   list_map_update_aux (=) k' v' xs' (x' # accu'))\n  \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n  \\<not> eq (fst x) k\n\ngoal (1 subgoal):\n 1. (list_map_update_aux eq k v (x # xs) accu,\n     list_map_update_aux (=) k' v' (x' # xs') accu')\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel", "by simp"], ["proof (state)\nthis:\n  (list_map_update_aux eq k v (x # xs) accu,\n   list_map_update_aux (=) k' v' (x' # xs') accu')\n  \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. eq (fst x) k \\<Longrightarrow>\n    (list_map_update_aux eq k v (x # xs) accu,\n     list_map_update_aux (=) k' v' (x' # xs') accu')\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. eq (fst x) k \\<Longrightarrow>\n    (list_map_update_aux eq k v (x # xs) accu,\n     list_map_update_aux (=) k' v' (x' # xs') accu')\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel", "case True"], ["proof (state)\nthis:\n  eq (fst x) k\n\ngoal (1 subgoal):\n 1. eq (fst x) k \\<Longrightarrow>\n    (list_map_update_aux eq k v (x # xs) accu,\n     list_map_update_aux (=) k' v' (x' # xs') accu')\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel", "from Cons.prems and Cons.hyps"], ["proof (chain)\npicking this:\n  (accu, accu') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n  (x, x') \\<in> Rk \\<times>\\<^sub>r Rv\n  (xs, xs') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel", "have \"(xs @ accu, xs' @ accu') \\<in>\n            \\<langle>\\<langle>Rk, Rv\\<rangle>prod_rel\\<rangle>list_rel\""], ["proof (prove)\nusing this:\n  (accu, accu') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n  (x, x') \\<in> Rk \\<times>\\<^sub>r Rv\n  (xs, xs') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. (xs @ accu, xs' @ accu')\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel", "by parametricity"], ["proof (state)\nthis:\n  (xs @ accu, xs' @ accu')\n  \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. eq (fst x) k \\<Longrightarrow>\n    (list_map_update_aux eq k v (x # xs) accu,\n     list_map_update_aux (=) k' v' (x' # xs') accu')\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel", "with K and V and True"], ["proof (chain)\npicking this:\n  (k, k') \\<in> Rk\n  (v, v') \\<in> Rv\n  eq (fst x) k\n  (xs @ accu, xs' @ accu')\n  \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel", "show ?thesis"], ["proof (prove)\nusing this:\n  (k, k') \\<in> Rk\n  (v, v') \\<in> Rv\n  eq (fst x) k\n  (xs @ accu, xs' @ accu')\n  \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. (list_map_update_aux eq k v (x # xs) accu,\n     list_map_update_aux (=) k' v' (x' # xs') accu')\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel", "by simp"], ["proof (state)\nthis:\n  (list_map_update_aux eq k v (x # xs) accu,\n   list_map_update_aux (=) k' v' (x' # xs') accu')\n  \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (list_map_update_aux eq k v (x # xs) accu,\n   list_map_update_aux (=) k' v' (x' # xs') accu')\n  \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma list_map_autoref_update1[param]:\n  assumes eq: \"(eq,(=)) \\<in> Rk \\<rightarrow> Rk \\<rightarrow> Id\"\n  shows \"(list_map_update eq, list_map_update (=)) \\<in> Rk \\<rightarrow> Rv \\<rightarrow> \n             \\<langle>\\<langle>Rk, Rv\\<rangle>prod_rel\\<rangle>list_rel \\<rightarrow> \\<langle>\\<langle>Rk, Rv\\<rangle>prod_rel\\<rangle>list_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_map_update eq, list_map_update (=))\n    \\<in> Rk \\<rightarrow>\n          Rv \\<rightarrow>\n          \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel \\<rightarrow>\n          \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel", "unfolding list_map_update_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>k v m. list_map_update_aux eq k v m [],\n     \\<lambda>k v m. list_map_update_aux (=) k v m [])\n    \\<in> Rk \\<rightarrow>\n          Rv \\<rightarrow>\n          \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel \\<rightarrow>\n          \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel", "by (intro fun_relI, erule (1) list_map_autoref_update_aux1[OF eq], \n      simp_all)"], ["", "(* TODO: Move - Perhaps. *)"], ["", "lemma map_add_sng_right: \"m ++ [k\\<mapsto>v] = m(k \\<mapsto> v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m ++ [k \\<mapsto> v] = m(k \\<mapsto> v)", "unfolding map_add_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        case [k \\<mapsto> v] x of None \\<Rightarrow> m x\n        | Some x \\<Rightarrow> Some x) =\n    m(k \\<mapsto> v)", "by force"], ["", "lemma map_add_sng_right': \n    \"m ++ (\\<lambda>a. if a = k then Some v else None) = m(k \\<mapsto> v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m ++ (\\<lambda>a. if a = k then Some v else None) = m(k \\<mapsto> v)", "unfolding map_add_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        case if x = k then Some v else None of None \\<Rightarrow> m x\n        | Some x \\<Rightarrow> Some x) =\n    m(k \\<mapsto> v)", "by force"], ["", "lemma list_map_autoref_update_aux2:\n  assumes K: \"(k, k') \\<in> Id\"\n  assumes V: \"(v, v') \\<in> Id\"\n  assumes A: \"(accu, accu') \\<in> br map_of list_map_invar\"\n  assumes A1: \"distinct (map fst (m @ accu))\"\n  assumes A2: \"k \\<notin> set (map fst accu)\"\n  assumes M: \"(m, m') \\<in> br map_of list_map_invar\"\n  shows \"(list_map_update_aux (=) k v m accu, \n          accu' ++ op_map_update k' v' m')\n               \\<in> br map_of list_map_invar\" (is \"(?f m accu, _) \\<in> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_map_update_aux (=) k v m accu, accu' ++ op_map_update k' v' m')\n    \\<in> br map_of list_map_invar", "using M A A1 A2"], ["proof (prove)\nusing this:\n  (m, m') \\<in> br map_of list_map_invar\n  (accu, accu') \\<in> br map_of list_map_invar\n  distinct (map fst (m @ accu))\n  k \\<notin> set (map fst accu)\n\ngoal (1 subgoal):\n 1. (list_map_update_aux (=) k v m accu, accu' ++ op_map_update k' v' m')\n    \\<in> br map_of list_map_invar", "proof (induction m arbitrary: accu accu' m')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>accu accu' m'.\n       \\<lbrakk>([], m') \\<in> br map_of list_map_invar;\n        (accu, accu') \\<in> br map_of list_map_invar;\n        distinct (map fst ([] @ accu));\n        k \\<notin> set (map fst accu)\\<rbrakk>\n       \\<Longrightarrow> (list_map_update_aux (=) k v [] accu,\n                          accu' ++ op_map_update k' v' m')\n                         \\<in> br map_of list_map_invar\n 2. \\<And>a m accu accu' m'.\n       \\<lbrakk>\\<And>accu accu' m'.\n                   \\<lbrakk>(m, m') \\<in> br map_of list_map_invar;\n                    (accu, accu') \\<in> br map_of list_map_invar;\n                    distinct (map fst (m @ accu));\n                    k \\<notin> set (map fst accu)\\<rbrakk>\n                   \\<Longrightarrow> (list_map_update_aux (=) k v m accu,\naccu' ++ op_map_update k' v' m')\n                                     \\<in> br map_of list_map_invar;\n        (a # m, m') \\<in> br map_of list_map_invar;\n        (accu, accu') \\<in> br map_of list_map_invar;\n        distinct (map fst ((a # m) @ accu));\n        k \\<notin> set (map fst accu)\\<rbrakk>\n       \\<Longrightarrow> (list_map_update_aux (=) k v (a # m) accu,\n                          accu' ++ op_map_update k' v' m')\n                         \\<in> br map_of list_map_invar", "case Nil"], ["proof (state)\nthis:\n  ([], m') \\<in> br map_of list_map_invar\n  (accu, accu') \\<in> br map_of list_map_invar\n  distinct (map fst ([] @ accu))\n  k \\<notin> set (map fst accu)\n\ngoal (2 subgoals):\n 1. \\<And>accu accu' m'.\n       \\<lbrakk>([], m') \\<in> br map_of list_map_invar;\n        (accu, accu') \\<in> br map_of list_map_invar;\n        distinct (map fst ([] @ accu));\n        k \\<notin> set (map fst accu)\\<rbrakk>\n       \\<Longrightarrow> (list_map_update_aux (=) k v [] accu,\n                          accu' ++ op_map_update k' v' m')\n                         \\<in> br map_of list_map_invar\n 2. \\<And>a m accu accu' m'.\n       \\<lbrakk>\\<And>accu accu' m'.\n                   \\<lbrakk>(m, m') \\<in> br map_of list_map_invar;\n                    (accu, accu') \\<in> br map_of list_map_invar;\n                    distinct (map fst (m @ accu));\n                    k \\<notin> set (map fst accu)\\<rbrakk>\n                   \\<Longrightarrow> (list_map_update_aux (=) k v m accu,\naccu' ++ op_map_update k' v' m')\n                                     \\<in> br map_of list_map_invar;\n        (a # m, m') \\<in> br map_of list_map_invar;\n        (accu, accu') \\<in> br map_of list_map_invar;\n        distinct (map fst ((a # m) @ accu));\n        k \\<notin> set (map fst accu)\\<rbrakk>\n       \\<Longrightarrow> (list_map_update_aux (=) k v (a # m) accu,\n                          accu' ++ op_map_update k' v' m')\n                         \\<in> br map_of list_map_invar", "with K V"], ["proof (chain)\npicking this:\n  (k, k') \\<in> Id\n  (v, v') \\<in> Id\n  ([], m') \\<in> br map_of list_map_invar\n  (accu, accu') \\<in> br map_of list_map_invar\n  distinct (map fst ([] @ accu))\n  k \\<notin> set (map fst accu)", "show ?case"], ["proof (prove)\nusing this:\n  (k, k') \\<in> Id\n  (v, v') \\<in> Id\n  ([], m') \\<in> br map_of list_map_invar\n  (accu, accu') \\<in> br map_of list_map_invar\n  distinct (map fst ([] @ accu))\n  k \\<notin> set (map fst accu)\n\ngoal (1 subgoal):\n 1. (list_map_update_aux (=) k v [] accu, accu' ++ op_map_update k' v' m')\n    \\<in> br map_of list_map_invar", "by (auto simp: br_def list_map_invar_def \n        map_add_sng_right')"], ["proof (state)\nthis:\n  (list_map_update_aux (=) k v [] accu, accu' ++ op_map_update k' v' m')\n  \\<in> br map_of list_map_invar\n\ngoal (1 subgoal):\n 1. \\<And>a m accu accu' m'.\n       \\<lbrakk>\\<And>accu accu' m'.\n                   \\<lbrakk>(m, m') \\<in> br map_of list_map_invar;\n                    (accu, accu') \\<in> br map_of list_map_invar;\n                    distinct (map fst (m @ accu));\n                    k \\<notin> set (map fst accu)\\<rbrakk>\n                   \\<Longrightarrow> (list_map_update_aux (=) k v m accu,\naccu' ++ op_map_update k' v' m')\n                                     \\<in> br map_of list_map_invar;\n        (a # m, m') \\<in> br map_of list_map_invar;\n        (accu, accu') \\<in> br map_of list_map_invar;\n        distinct (map fst ((a # m) @ accu));\n        k \\<notin> set (map fst accu)\\<rbrakk>\n       \\<Longrightarrow> (list_map_update_aux (=) k v (a # m) accu,\n                          accu' ++ op_map_update k' v' m')\n                         \\<in> br map_of list_map_invar", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a m accu accu' m'.\n       \\<lbrakk>\\<And>accu accu' m'.\n                   \\<lbrakk>(m, m') \\<in> br map_of list_map_invar;\n                    (accu, accu') \\<in> br map_of list_map_invar;\n                    distinct (map fst (m @ accu));\n                    k \\<notin> set (map fst accu)\\<rbrakk>\n                   \\<Longrightarrow> (list_map_update_aux (=) k v m accu,\naccu' ++ op_map_update k' v' m')\n                                     \\<in> br map_of list_map_invar;\n        (a # m, m') \\<in> br map_of list_map_invar;\n        (accu, accu') \\<in> br map_of list_map_invar;\n        distinct (map fst ((a # m) @ accu));\n        k \\<notin> set (map fst accu)\\<rbrakk>\n       \\<Longrightarrow> (list_map_update_aux (=) k v (a # m) accu,\n                          accu' ++ op_map_update k' v' m')\n                         \\<in> br map_of list_map_invar", "case (Cons x xs accu accu' m')"], ["proof (state)\nthis:\n  \\<lbrakk>(xs, ?m') \\<in> br map_of list_map_invar;\n   (?accu, ?accu') \\<in> br map_of list_map_invar;\n   distinct (map fst (xs @ ?accu)); k \\<notin> set (map fst ?accu)\\<rbrakk>\n  \\<Longrightarrow> (list_map_update_aux (=) k v xs ?accu,\n                     ?accu' ++ op_map_update k' v' ?m')\n                    \\<in> br map_of list_map_invar\n  (x # xs, m') \\<in> br map_of list_map_invar\n  (accu, accu') \\<in> br map_of list_map_invar\n  distinct (map fst ((x # xs) @ accu))\n  k \\<notin> set (map fst accu)\n\ngoal (1 subgoal):\n 1. \\<And>a m accu accu' m'.\n       \\<lbrakk>\\<And>accu accu' m'.\n                   \\<lbrakk>(m, m') \\<in> br map_of list_map_invar;\n                    (accu, accu') \\<in> br map_of list_map_invar;\n                    distinct (map fst (m @ accu));\n                    k \\<notin> set (map fst accu)\\<rbrakk>\n                   \\<Longrightarrow> (list_map_update_aux (=) k v m accu,\naccu' ++ op_map_update k' v' m')\n                                     \\<in> br map_of list_map_invar;\n        (a # m, m') \\<in> br map_of list_map_invar;\n        (accu, accu') \\<in> br map_of list_map_invar;\n        distinct (map fst ((a # m) @ accu));\n        k \\<notin> set (map fst accu)\\<rbrakk>\n       \\<Longrightarrow> (list_map_update_aux (=) k v (a # m) accu,\n                          accu' ++ op_map_update k' v' m')\n                         \\<in> br map_of list_map_invar", "from Cons.prems"], ["proof (chain)\npicking this:\n  (x # xs, m') \\<in> br map_of list_map_invar\n  (accu, accu') \\<in> br map_of list_map_invar\n  distinct (map fst ((x # xs) @ accu))\n  k \\<notin> set (map fst accu)", "have A: \"m' = map_of (x#xs)\" \"accu' = map_of accu\""], ["proof (prove)\nusing this:\n  (x # xs, m') \\<in> br map_of list_map_invar\n  (accu, accu') \\<in> br map_of list_map_invar\n  distinct (map fst ((x # xs) @ accu))\n  k \\<notin> set (map fst accu)\n\ngoal (1 subgoal):\n 1. m' = map_of (x # xs) &&& accu' = map_of accu", "unfolding br_def"], ["proof (prove)\nusing this:\n  (x # xs, m') \\<in> {(c, a). a = map_of c \\<and> list_map_invar c}\n  (accu, accu') \\<in> {(c, a). a = map_of c \\<and> list_map_invar c}\n  distinct (map fst ((x # xs) @ accu))\n  k \\<notin> set (map fst accu)\n\ngoal (1 subgoal):\n 1. m' = map_of (x # xs) &&& accu' = map_of accu", "by simp_all"], ["proof (state)\nthis:\n  m' = map_of (x # xs)\n  accu' = map_of accu\n\ngoal (1 subgoal):\n 1. \\<And>a m accu accu' m'.\n       \\<lbrakk>\\<And>accu accu' m'.\n                   \\<lbrakk>(m, m') \\<in> br map_of list_map_invar;\n                    (accu, accu') \\<in> br map_of list_map_invar;\n                    distinct (map fst (m @ accu));\n                    k \\<notin> set (map fst accu)\\<rbrakk>\n                   \\<Longrightarrow> (list_map_update_aux (=) k v m accu,\naccu' ++ op_map_update k' v' m')\n                                     \\<in> br map_of list_map_invar;\n        (a # m, m') \\<in> br map_of list_map_invar;\n        (accu, accu') \\<in> br map_of list_map_invar;\n        distinct (map fst ((a # m) @ accu));\n        k \\<notin> set (map fst accu)\\<rbrakk>\n       \\<Longrightarrow> (list_map_update_aux (=) k v (a # m) accu,\n                          accu' ++ op_map_update k' v' m')\n                         \\<in> br map_of list_map_invar", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_map_update_aux (=) k v (x # xs) accu,\n     accu' ++ op_map_update k' v' m')\n    \\<in> br map_of list_map_invar", "proof (cases \"(fst x) =  k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. fst x = k \\<Longrightarrow>\n    (list_map_update_aux (=) k v (x # xs) accu,\n     accu' ++ op_map_update k' v' m')\n    \\<in> br map_of list_map_invar\n 2. fst x \\<noteq> k \\<Longrightarrow>\n    (list_map_update_aux (=) k v (x # xs) accu,\n     accu' ++ op_map_update k' v' m')\n    \\<in> br map_of list_map_invar", "case True"], ["proof (state)\nthis:\n  fst x = k\n\ngoal (2 subgoals):\n 1. fst x = k \\<Longrightarrow>\n    (list_map_update_aux (=) k v (x # xs) accu,\n     accu' ++ op_map_update k' v' m')\n    \\<in> br map_of list_map_invar\n 2. fst x \\<noteq> k \\<Longrightarrow>\n    (list_map_update_aux (=) k v (x # xs) accu,\n     accu' ++ op_map_update k' v' m')\n    \\<in> br map_of list_map_invar", "hence \"((k, v) # xs @ accu, accu' ++ op_map_update k' v' m')\n                   \\<in> br map_of list_map_invar\""], ["proof (prove)\nusing this:\n  fst x = k\n\ngoal (1 subgoal):\n 1. ((k, v) # xs @ accu, accu' ++ op_map_update k' v' m')\n    \\<in> br map_of list_map_invar", "using K V Cons.prems(3,4)"], ["proof (prove)\nusing this:\n  fst x = k\n  (k, k') \\<in> Id\n  (v, v') \\<in> Id\n  distinct (map fst ((x # xs) @ accu))\n  k \\<notin> set (map fst accu)\n\ngoal (1 subgoal):\n 1. ((k, v) # xs @ accu, accu' ++ op_map_update k' v' m')\n    \\<in> br map_of list_map_invar", "unfolding br_def"], ["proof (prove)\nusing this:\n  fst x = k\n  (k, k') \\<in> Id\n  (v, v') \\<in> Id\n  distinct (map fst ((x # xs) @ accu))\n  k \\<notin> set (map fst accu)\n\ngoal (1 subgoal):\n 1. ((k, v) # xs @ accu, accu' ++ op_map_update k' v' m')\n    \\<in> {(c, a). a = map_of c \\<and> list_map_invar c}", "by (force simp add: A list_map_invar_def)"], ["proof (state)\nthis:\n  ((k, v) # xs @ accu, accu' ++ op_map_update k' v' m')\n  \\<in> br map_of list_map_invar\n\ngoal (2 subgoals):\n 1. fst x = k \\<Longrightarrow>\n    (list_map_update_aux (=) k v (x # xs) accu,\n     accu' ++ op_map_update k' v' m')\n    \\<in> br map_of list_map_invar\n 2. fst x \\<noteq> k \\<Longrightarrow>\n    (list_map_update_aux (=) k v (x # xs) accu,\n     accu' ++ op_map_update k' v' m')\n    \\<in> br map_of list_map_invar", "also"], ["proof (state)\nthis:\n  ((k, v) # xs @ accu, accu' ++ op_map_update k' v' m')\n  \\<in> br map_of list_map_invar\n\ngoal (2 subgoals):\n 1. fst x = k \\<Longrightarrow>\n    (list_map_update_aux (=) k v (x # xs) accu,\n     accu' ++ op_map_update k' v' m')\n    \\<in> br map_of list_map_invar\n 2. fst x \\<noteq> k \\<Longrightarrow>\n    (list_map_update_aux (=) k v (x # xs) accu,\n     accu' ++ op_map_update k' v' m')\n    \\<in> br map_of list_map_invar", "from True"], ["proof (chain)\npicking this:\n  fst x = k", "have \"(k,v) # xs @ accu = ?f (x # xs) accu\""], ["proof (prove)\nusing this:\n  fst x = k\n\ngoal (1 subgoal):\n 1. (k, v) # xs @ accu = list_map_update_aux (=) k v (x # xs) accu", "by simp"], ["proof (state)\nthis:\n  (k, v) # xs @ accu = list_map_update_aux (=) k v (x # xs) accu\n\ngoal (2 subgoals):\n 1. fst x = k \\<Longrightarrow>\n    (list_map_update_aux (=) k v (x # xs) accu,\n     accu' ++ op_map_update k' v' m')\n    \\<in> br map_of list_map_invar\n 2. fst x \\<noteq> k \\<Longrightarrow>\n    (list_map_update_aux (=) k v (x # xs) accu,\n     accu' ++ op_map_update k' v' m')\n    \\<in> br map_of list_map_invar", "finally"], ["proof (chain)\npicking this:\n  (list_map_update_aux (=) k v (x # xs) accu,\n   accu' ++ op_map_update k' v' m')\n  \\<in> br map_of list_map_invar", "show ?thesis"], ["proof (prove)\nusing this:\n  (list_map_update_aux (=) k v (x # xs) accu,\n   accu' ++ op_map_update k' v' m')\n  \\<in> br map_of list_map_invar\n\ngoal (1 subgoal):\n 1. (list_map_update_aux (=) k v (x # xs) accu,\n     accu' ++ op_map_update k' v' m')\n    \\<in> br map_of list_map_invar", "."], ["proof (state)\nthis:\n  (list_map_update_aux (=) k v (x # xs) accu,\n   accu' ++ op_map_update k' v' m')\n  \\<in> br map_of list_map_invar\n\ngoal (1 subgoal):\n 1. fst x \\<noteq> k \\<Longrightarrow>\n    (list_map_update_aux (=) k v (x # xs) accu,\n     accu' ++ op_map_update k' v' m')\n    \\<in> br map_of list_map_invar", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. fst x \\<noteq> k \\<Longrightarrow>\n    (list_map_update_aux (=) k v (x # xs) accu,\n     accu' ++ op_map_update k' v' m')\n    \\<in> br map_of list_map_invar", "case False"], ["proof (state)\nthis:\n  fst x \\<noteq> k\n\ngoal (1 subgoal):\n 1. fst x \\<noteq> k \\<Longrightarrow>\n    (list_map_update_aux (=) k v (x # xs) accu,\n     accu' ++ op_map_update k' v' m')\n    \\<in> br map_of list_map_invar", "from Cons.prems(1)"], ["proof (chain)\npicking this:\n  (x # xs, m') \\<in> br map_of list_map_invar", "have B: \"(xs, map_of xs) \\<in> br map_of \n            list_map_invar\""], ["proof (prove)\nusing this:\n  (x # xs, m') \\<in> br map_of list_map_invar\n\ngoal (1 subgoal):\n 1. (xs, map_of xs) \\<in> br map_of list_map_invar", "by (simp add: br_def list_map_invar_def)"], ["proof (state)\nthis:\n  (xs, map_of xs) \\<in> br map_of list_map_invar\n\ngoal (1 subgoal):\n 1. fst x \\<noteq> k \\<Longrightarrow>\n    (list_map_update_aux (=) k v (x # xs) accu,\n     accu' ++ op_map_update k' v' m')\n    \\<in> br map_of list_map_invar", "from Cons.prems(2,3)"], ["proof (chain)\npicking this:\n  (accu, accu') \\<in> br map_of list_map_invar\n  distinct (map fst ((x # xs) @ accu))", "have C: \"(x#accu, map_of (x#accu)) \\<in> br map_of\n            list_map_invar\""], ["proof (prove)\nusing this:\n  (accu, accu') \\<in> br map_of list_map_invar\n  distinct (map fst ((x # xs) @ accu))\n\ngoal (1 subgoal):\n 1. (x # accu, map_of (x # accu)) \\<in> br map_of list_map_invar", "by (simp add: br_def list_map_invar_def)"], ["proof (state)\nthis:\n  (x # accu, map_of (x # accu)) \\<in> br map_of list_map_invar\n\ngoal (1 subgoal):\n 1. fst x \\<noteq> k \\<Longrightarrow>\n    (list_map_update_aux (=) k v (x # xs) accu,\n     accu' ++ op_map_update k' v' m')\n    \\<in> br map_of list_map_invar", "from Cons.prems(3)"], ["proof (chain)\npicking this:\n  distinct (map fst ((x # xs) @ accu))", "have D: \"distinct (map fst (xs @ x # accu))\""], ["proof (prove)\nusing this:\n  distinct (map fst ((x # xs) @ accu))\n\ngoal (1 subgoal):\n 1. distinct (map fst (xs @ x # accu))", "by simp"], ["proof (state)\nthis:\n  distinct (map fst (xs @ x # accu))\n\ngoal (1 subgoal):\n 1. fst x \\<noteq> k \\<Longrightarrow>\n    (list_map_update_aux (=) k v (x # xs) accu,\n     accu' ++ op_map_update k' v' m')\n    \\<in> br map_of list_map_invar", "from Cons.prems(4) and False"], ["proof (chain)\npicking this:\n  k \\<notin> set (map fst accu)\n  fst x \\<noteq> k", "have E: \"k \\<notin> set (map fst (x # accu))\""], ["proof (prove)\nusing this:\n  k \\<notin> set (map fst accu)\n  fst x \\<noteq> k\n\ngoal (1 subgoal):\n 1. k \\<notin> set (map fst (x # accu))", "by simp"], ["proof (state)\nthis:\n  k \\<notin> set (map fst (x # accu))\n\ngoal (1 subgoal):\n 1. fst x \\<noteq> k \\<Longrightarrow>\n    (list_map_update_aux (=) k v (x # xs) accu,\n     accu' ++ op_map_update k' v' m')\n    \\<in> br map_of list_map_invar", "note Cons.IH[OF B C D E]"], ["proof (state)\nthis:\n  (list_map_update_aux (=) k v xs (x # accu),\n   map_of (x # accu) ++ op_map_update k' v' (map_of xs))\n  \\<in> br map_of list_map_invar\n\ngoal (1 subgoal):\n 1. fst x \\<noteq> k \\<Longrightarrow>\n    (list_map_update_aux (=) k v (x # xs) accu,\n     accu' ++ op_map_update k' v' m')\n    \\<in> br map_of list_map_invar", "also"], ["proof (state)\nthis:\n  (list_map_update_aux (=) k v xs (x # accu),\n   map_of (x # accu) ++ op_map_update k' v' (map_of xs))\n  \\<in> br map_of list_map_invar\n\ngoal (1 subgoal):\n 1. fst x \\<noteq> k \\<Longrightarrow>\n    (list_map_update_aux (=) k v (x # xs) accu,\n     accu' ++ op_map_update k' v' m')\n    \\<in> br map_of list_map_invar", "from False"], ["proof (chain)\npicking this:\n  fst x \\<noteq> k", "have \"?f xs (x#accu) = ?f (x#xs) accu\""], ["proof (prove)\nusing this:\n  fst x \\<noteq> k\n\ngoal (1 subgoal):\n 1. list_map_update_aux (=) k v xs (x # accu) =\n    list_map_update_aux (=) k v (x # xs) accu", "by simp"], ["proof (state)\nthis:\n  list_map_update_aux (=) k v xs (x # accu) =\n  list_map_update_aux (=) k v (x # xs) accu\n\ngoal (1 subgoal):\n 1. fst x \\<noteq> k \\<Longrightarrow>\n    (list_map_update_aux (=) k v (x # xs) accu,\n     accu' ++ op_map_update k' v' m')\n    \\<in> br map_of list_map_invar", "also"], ["proof (state)\nthis:\n  list_map_update_aux (=) k v xs (x # accu) =\n  list_map_update_aux (=) k v (x # xs) accu\n\ngoal (1 subgoal):\n 1. fst x \\<noteq> k \\<Longrightarrow>\n    (list_map_update_aux (=) k v (x # xs) accu,\n     accu' ++ op_map_update k' v' m')\n    \\<in> br map_of list_map_invar", "from distinct_map_fstD[OF D]"], ["proof (chain)\npicking this:\n  \\<lbrakk>(?x, ?y) \\<in> set (xs @ x # accu);\n   (?x, ?z) \\<in> set (xs @ x # accu)\\<rbrakk>\n  \\<Longrightarrow> ?y = ?z", "have F: \"\\<And>z. (fst x, z) \\<in> set xs \\<Longrightarrow> z = snd x\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(?x, ?y) \\<in> set (xs @ x # accu);\n   (?x, ?z) \\<in> set (xs @ x # accu)\\<rbrakk>\n  \\<Longrightarrow> ?y = ?z\n\ngoal (1 subgoal):\n 1. \\<And>z. (fst x, z) \\<in> set xs \\<Longrightarrow> z = snd x", "by force"], ["proof (state)\nthis:\n  (fst x, ?z) \\<in> set xs \\<Longrightarrow> ?z = snd x\n\ngoal (1 subgoal):\n 1. fst x \\<noteq> k \\<Longrightarrow>\n    (list_map_update_aux (=) k v (x # xs) accu,\n     accu' ++ op_map_update k' v' m')\n    \\<in> br map_of list_map_invar", "have \"map_of (x # accu) ++ op_map_update k' v' (map_of xs) = \n                  accu' ++ op_map_update k' v' m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (x # accu) ++ op_map_update k' v' (map_of xs) =\n    accu' ++ op_map_update k' v' m'", "by (intro ext, auto simp: A F map_add_def \n                    dest: map_of_SomeD split: option.split)"], ["proof (state)\nthis:\n  map_of (x # accu) ++ op_map_update k' v' (map_of xs) =\n  accu' ++ op_map_update k' v' m'\n\ngoal (1 subgoal):\n 1. fst x \\<noteq> k \\<Longrightarrow>\n    (list_map_update_aux (=) k v (x # xs) accu,\n     accu' ++ op_map_update k' v' m')\n    \\<in> br map_of list_map_invar", "finally"], ["proof (chain)\npicking this:\n  (list_map_update_aux (=) k v (x # xs) accu,\n   accu' ++ op_map_update k' v' m')\n  \\<in> br map_of list_map_invar", "show ?thesis"], ["proof (prove)\nusing this:\n  (list_map_update_aux (=) k v (x # xs) accu,\n   accu' ++ op_map_update k' v' m')\n  \\<in> br map_of list_map_invar\n\ngoal (1 subgoal):\n 1. (list_map_update_aux (=) k v (x # xs) accu,\n     accu' ++ op_map_update k' v' m')\n    \\<in> br map_of list_map_invar", "."], ["proof (state)\nthis:\n  (list_map_update_aux (=) k v (x # xs) accu,\n   accu' ++ op_map_update k' v' m')\n  \\<in> br map_of list_map_invar\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (list_map_update_aux (=) k v (x # xs) accu,\n   accu' ++ op_map_update k' v' m')\n  \\<in> br map_of list_map_invar\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma list_map_autoref_update2[param]:\n  shows \"(list_map_update (=), op_map_update) \\<in> Id \\<rightarrow> Id \\<rightarrow> \n             br map_of list_map_invar \\<rightarrow> br map_of list_map_invar\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_map_update (=), op_map_update)\n    \\<in> Id \\<rightarrow>\n          Id \\<rightarrow>\n          br map_of list_map_invar \\<rightarrow> br map_of list_map_invar", "unfolding list_map_update_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>k v m. list_map_update_aux (=) k v m [], op_map_update)\n    \\<in> Id \\<rightarrow>\n          Id \\<rightarrow>\n          br map_of list_map_invar \\<rightarrow> br map_of list_map_invar", "apply (intro fun_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(a, a') \\<in> Id; (aa, a'a) \\<in> Id;\n        (ab, a'b) \\<in> br map_of list_map_invar\\<rbrakk>\n       \\<Longrightarrow> (list_map_update_aux (=) a aa ab [],\n                          op_map_update a' a'a a'b)\n                         \\<in> br map_of list_map_invar", "apply (drule list_map_autoref_update_aux2\n                 [where accu=\"[]\" and accu'=\"Map.empty\"])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(aa, a'a) \\<in> Id;\n        (ab, a'b) \\<in> br map_of list_map_invar\\<rbrakk>\n       \\<Longrightarrow> (?v3 a a' aa a'a ab a'b, ?v'3 a a' aa a'a ab a'b)\n                         \\<in> Id\n 2. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(aa, a'a) \\<in> Id;\n        (ab, a'b) \\<in> br map_of list_map_invar\\<rbrakk>\n       \\<Longrightarrow> ([], Map.empty) \\<in> br map_of list_map_invar\n 3. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(aa, a'a) \\<in> Id;\n        (ab, a'b) \\<in> br map_of list_map_invar\\<rbrakk>\n       \\<Longrightarrow> distinct (map fst (?m3 a a' aa a'a ab a'b @ []))\n 4. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(aa, a'a) \\<in> Id;\n        (ab, a'b) \\<in> br map_of list_map_invar\\<rbrakk>\n       \\<Longrightarrow> a \\<notin> set (map fst [])\n 5. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(aa, a'a) \\<in> Id;\n        (ab, a'b) \\<in> br map_of list_map_invar\\<rbrakk>\n       \\<Longrightarrow> (?m3 a a' aa a'a ab a'b, ?m'3 a a' aa a'a ab a'b)\n                         \\<in> br map_of list_map_invar\n 6. \\<And>a a' aa a'a ab a'b.\n       \\<lbrakk>(aa, a'a) \\<in> Id;\n        (ab, a'b) \\<in> br map_of list_map_invar;\n        (list_map_update_aux (=) a (?v3 a a' aa a'a ab a'b)\n          (?m3 a a' aa a'a ab a'b) [],\n         Map.empty ++\n         op_map_update a' (?v'3 a a' aa a'a ab a'b)\n          (?m'3 a a' aa a'a ab a'b))\n        \\<in> br map_of list_map_invar\\<rbrakk>\n       \\<Longrightarrow> (list_map_update_aux (=) a aa ab [],\n                          op_map_update a' a'a a'b)\n                         \\<in> br map_of list_map_invar", "apply (auto simp: br_def list_map_invar_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma list_map_autoref_update[autoref_rules]:\n  assumes eq: \"GEN_OP eq (=) (Rk\\<rightarrow>Rk\\<rightarrow>Id)\"\n  shows \"(list_map_update eq, op_map_update) \\<in>\n      Rk \\<rightarrow> Rv \\<rightarrow> \\<langle>Rk,Rv\\<rangle>list_map_rel \\<rightarrow> \\<langle>Rk,Rv\\<rangle>list_map_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_map_update eq, op_map_update)\n    \\<in> Rk \\<rightarrow>\n          Rv \\<rightarrow>\n          \\<langle>Rk, Rv\\<rangle>list_map_rel \\<rightarrow> \\<langle>Rk,\n          Rv\\<rangle>list_map_rel", "unfolding list_map_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_map_update eq, op_map_update)\n    \\<in> Rk \\<rightarrow>\n          Rv \\<rightarrow>\n          \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel O\n          br map_of list_map_invar \\<rightarrow>\n          \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel O\n          br map_of list_map_invar", "apply (intro fun_relI, elim relcompE, intro relcompI, clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a a' aa a'a a'b x y.\n       \\<lbrakk>(a, a') \\<in> Rk; (aa, a'a) \\<in> Rv;\n        (x, y) \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel;\n        (y, a'b) \\<in> br map_of list_map_invar\\<rbrakk>\n       \\<Longrightarrow> (list_map_update eq a aa x,\n                          ?b4 a a' aa a'a x a'b x y a'b)\n                         \\<in> \\<langle>Rk \\<times>\\<^sub>r\n  Rv\\<rangle>list_rel\n 2. \\<And>a a' aa a'a ab a'b x y z.\n       \\<lbrakk>(a, a') \\<in> Rk; (aa, a'a) \\<in> Rv; (ab, a'b) = (x, z);\n        (x, y) \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel;\n        (y, z) \\<in> br map_of list_map_invar\\<rbrakk>\n       \\<Longrightarrow> (?b4 a a' aa a'a ab a'b x y z,\n                          op_map_update a' a'a a'b)\n                         \\<in> br map_of list_map_invar", "apply (erule (2) list_map_autoref_update1[param_fo, OF eq[simplified]])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a ab a'b x y z.\n       \\<lbrakk>(a, a') \\<in> Rk; (aa, a'a) \\<in> Rv; (ab, a'b) = (x, z);\n        (x, y) \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel;\n        (y, z) \\<in> br map_of list_map_invar\\<rbrakk>\n       \\<Longrightarrow> (list_map_update (=) a' a'a y,\n                          op_map_update a' a'a a'b)\n                         \\<in> br map_of list_map_invar", "apply (rule list_map_autoref_update2[param_fo], simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "context begin"], ["", "interpretation autoref_syn"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma list_map_autoref_update_dj[autoref_rules]:\n    assumes \"PRIO_TAG_OPTIMIZATION\"\n    assumes new: \"SIDE_PRECOND_OPT (k' \\<notin> dom m')\"\n    assumes K: \"(k,k')\\<in>Rk\" and V: \"(v,v')\\<in>Rv\"\n    assumes M: \"(l,m')\\<in>\\<langle>Rk, Rv\\<rangle>list_map_rel\"\n    defines \"R_annot \\<equiv> Rk \\<rightarrow> Rv \\<rightarrow> \\<langle>Rk,Rv\\<rangle>list_map_rel \\<rightarrow> \\<langle>Rk,Rv\\<rangle>list_map_rel\"\n    shows \"\n      ((k, v)#l, \n        (OP op_map_update:::R_annot)$k'$v'$m')\n      \\<in> \\<langle>Rk,Rv\\<rangle>list_map_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((k, v) # l, (OP op_map_update ::: R_annot) $ k' $ v' $ m')\n    \\<in> \\<langle>Rk, Rv\\<rangle>list_map_rel", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((k, v) # l, (OP op_map_update ::: R_annot) $ k' $ v' $ m')\n    \\<in> \\<langle>Rk, Rv\\<rangle>list_map_rel", "from M"], ["proof (chain)\npicking this:\n  (l, m') \\<in> \\<langle>Rk, Rv\\<rangle>list_map_rel", "obtain l' where A: \"(l,l') \\<in> \\<langle>\\<langle>Rk, Rv\\<rangle>prod_rel\\<rangle>list_rel\" and\n      B: \"(l',m') \\<in> br map_of list_map_invar\""], ["proof (prove)\nusing this:\n  (l, m') \\<in> \\<langle>Rk, Rv\\<rangle>list_map_rel\n\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>(l, l')\n                 \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel;\n         (l', m') \\<in> br map_of list_map_invar\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding list_map_rel_def"], ["proof (prove)\nusing this:\n  (l, m')\n  \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel O\n        br map_of list_map_invar\n\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>(l, l')\n                 \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel;\n         (l', m') \\<in> br map_of list_map_invar\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (l, l') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n  (l', m') \\<in> br map_of list_map_invar\n\ngoal (1 subgoal):\n 1. ((k, v) # l, (OP op_map_update ::: R_annot) $ k' $ v' $ m')\n    \\<in> \\<langle>Rk, Rv\\<rangle>list_map_rel", "hence \"((k,v)#l, (k',v')#l')\\<in>\\<langle>\\<langle>Rk, Rv\\<rangle>prod_rel\\<rangle>list_rel\"\n      and \"((k',v')#l', m'(k' \\<mapsto> v')) \\<in> br map_of list_map_invar\""], ["proof (prove)\nusing this:\n  (l, l') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n  (l', m') \\<in> br map_of list_map_invar\n\ngoal (1 subgoal):\n 1. ((k, v) # l, (k', v') # l')\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel &&&\n    ((k', v') # l', m'(k' \\<mapsto> v')) \\<in> br map_of list_map_invar", "using assms"], ["proof (prove)\nusing this:\n  (l, l') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n  (l', m') \\<in> br map_of list_map_invar\n  PRIO_TAG_OPTIMIZATION\n  SIDE_PRECOND_OPT (k' \\<notin> dom m')\n  (k, k') \\<in> Rk\n  (v, v') \\<in> Rv\n  (l, m') \\<in> \\<langle>Rk, Rv\\<rangle>list_map_rel\n  R_annot \\<equiv>\n  Rk \\<rightarrow>\n  Rv \\<rightarrow>\n  \\<langle>Rk, Rv\\<rangle>list_map_rel \\<rightarrow> \\<langle>Rk,\n  Rv\\<rangle>list_map_rel\n\ngoal (1 subgoal):\n 1. ((k, v) # l, (k', v') # l')\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel &&&\n    ((k', v') # l', m'(k' \\<mapsto> v')) \\<in> br map_of list_map_invar", "unfolding br_def list_map_invar_def"], ["proof (prove)\nusing this:\n  (l, l') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n  (l', m')\n  \\<in> {(c, a). a = map_of c \\<and> (distinct \\<circ>\\<circ> map) fst c}\n  PRIO_TAG_OPTIMIZATION\n  SIDE_PRECOND_OPT (k' \\<notin> dom m')\n  (k, k') \\<in> Rk\n  (v, v') \\<in> Rv\n  (l, m') \\<in> \\<langle>Rk, Rv\\<rangle>list_map_rel\n  R_annot \\<equiv>\n  Rk \\<rightarrow>\n  Rv \\<rightarrow>\n  \\<langle>Rk, Rv\\<rangle>list_map_rel \\<rightarrow> \\<langle>Rk,\n  Rv\\<rangle>list_map_rel\n\ngoal (1 subgoal):\n 1. ((k, v) # l, (k', v') # l')\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel &&&\n    ((k', v') # l', m'(k' \\<mapsto> v'))\n    \\<in> {(c, a). a = map_of c \\<and> (distinct \\<circ>\\<circ> map) fst c}", "by (simp_all add: dom_map_of_conv_image_fst)"], ["proof (state)\nthis:\n  ((k, v) # l, (k', v') # l')\n  \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n  ((k', v') # l', m'(k' \\<mapsto> v')) \\<in> br map_of list_map_invar\n\ngoal (1 subgoal):\n 1. ((k, v) # l, (OP op_map_update ::: R_annot) $ k' $ v' $ m')\n    \\<in> \\<langle>Rk, Rv\\<rangle>list_map_rel", "thus ?thesis"], ["proof (prove)\nusing this:\n  ((k, v) # l, (k', v') # l')\n  \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n  ((k', v') # l', m'(k' \\<mapsto> v')) \\<in> br map_of list_map_invar\n\ngoal (1 subgoal):\n 1. ((k, v) # l, (OP op_map_update ::: R_annot) $ k' $ v' $ m')\n    \\<in> \\<langle>Rk, Rv\\<rangle>list_map_rel", "unfolding autoref_tag_defs"], ["proof (prove)\nusing this:\n  ((k, v) # l, (k', v') # l')\n  \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n  ((k', v') # l', m'(k' \\<mapsto> v')) \\<in> br map_of list_map_invar\n\ngoal (1 subgoal):\n 1. ((k, v) # l, op_map_update k' v' m') \\<in> \\<langle>Rk,\n    Rv\\<rangle>list_map_rel", "by (force simp: list_map_rel_def)"], ["proof (state)\nthis:\n  ((k, v) # l, (OP op_map_update ::: R_annot) $ k' $ v' $ m')\n  \\<in> \\<langle>Rk, Rv\\<rangle>list_map_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma param_list_map_delete_aux[param]:\n  \"(list_map_delete_aux,list_map_delete_aux) \\<in> (Rk \\<rightarrow> Rk \\<rightarrow> bool_rel) \\<rightarrow> \n       Rk \\<rightarrow> \\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel \\<rightarrow> \\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel\n        \\<rightarrow> \\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_map_delete_aux, list_map_delete_aux)\n    \\<in> (Rk \\<rightarrow> Rk \\<rightarrow> bool_rel) \\<rightarrow>\n          Rk \\<rightarrow>\n          \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel \\<rightarrow>\n          \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel \\<rightarrow>\n          \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel", "unfolding list_map_delete_aux_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>uu uua uub.\n        rec_list (\\<lambda>eq k accu. accu)\n         (\\<lambda>x xs xsa eq k accu.\n             if eq (fst x) k then xs @ accu else xsa eq k (x # accu))\n         uub uu uua,\n     \\<lambda>uu uua uub.\n        rec_list (\\<lambda>eq k accu. accu)\n         (\\<lambda>x xs xsa eq k accu.\n             if eq (fst x) k then xs @ accu else xsa eq k (x # accu))\n         uub uu uua)\n    \\<in> (Rk \\<rightarrow> Rk \\<rightarrow> bool_rel) \\<rightarrow>\n          Rk \\<rightarrow>\n          \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel \\<rightarrow>\n          \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel \\<rightarrow>\n          \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel", "by parametricity"], ["", "lemma param_list_map_delete[param]:\n  \"(list_map_delete,list_map_delete) \\<in> (Rk \\<rightarrow> Rk \\<rightarrow> bool_rel) \\<rightarrow> \n       Rk \\<rightarrow> \\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel \\<rightarrow> \\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_map_delete, list_map_delete)\n    \\<in> (Rk \\<rightarrow> Rk \\<rightarrow> bool_rel) \\<rightarrow>\n          Rk \\<rightarrow>\n          \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel \\<rightarrow>\n          \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel", "unfolding list_map_delete_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>eq k m. list_map_delete_aux eq k m [],\n     \\<lambda>eq k m. list_map_delete_aux eq k m [])\n    \\<in> (Rk \\<rightarrow> Rk \\<rightarrow> bool_rel) \\<rightarrow>\n          Rk \\<rightarrow>\n          \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel \\<rightarrow>\n          \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel", "by parametricity"], ["", "lemma list_map_autoref_delete_aux1:\n  assumes eq: \"(eq,(=)) \\<in> Rk \\<rightarrow> Rk \\<rightarrow> Id\"\n  assumes K: \"(k, k') \\<in> Rk\"\n  assumes A: \"(accu, accu') \\<in> \\<langle>\\<langle>Rk, Rv\\<rangle>prod_rel\\<rangle>list_rel\"\n  assumes M: \"(m, m') \\<in> \\<langle>\\<langle>Rk, Rv\\<rangle>prod_rel\\<rangle>list_rel\"\n  shows \"(list_map_delete_aux eq k m accu, \n          list_map_delete_aux (=) k' m' accu')\n               \\<in> \\<langle>\\<langle>Rk, Rv\\<rangle>prod_rel\\<rangle>list_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_map_delete_aux eq k m accu, list_map_delete_aux (=) k' m' accu')\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel", "proof (insert A, induction arbitrary: accu accu' \n           rule: list_rel_induct[OF M, case_names Nil Cons])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>accu accu'.\n       (accu, accu')\n       \\<in> \\<langle>Rk \\<times>\\<^sub>r\n                      Rv\\<rangle>list_rel \\<Longrightarrow>\n       (list_map_delete_aux eq k [] accu,\n        list_map_delete_aux (=) k' [] accu')\n       \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n 2. \\<And>x x' l l' accu accu'.\n       \\<lbrakk>(x, x') \\<in> Rk \\<times>\\<^sub>r Rv;\n        (l, l') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel;\n        \\<And>accu accu'.\n           (accu, accu')\n           \\<in> \\<langle>Rk \\<times>\\<^sub>r\n                          Rv\\<rangle>list_rel \\<Longrightarrow>\n           (list_map_delete_aux eq k l accu,\n            list_map_delete_aux (=) k' l' accu')\n           \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel;\n        (accu, accu')\n        \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (list_map_delete_aux eq k (x # l) accu,\n                          list_map_delete_aux (=) k' (x' # l') accu')\n                         \\<in> \\<langle>Rk \\<times>\\<^sub>r\n  Rv\\<rangle>list_rel", "case Nil"], ["proof (state)\nthis:\n  (accu, accu') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n\ngoal (2 subgoals):\n 1. \\<And>accu accu'.\n       (accu, accu')\n       \\<in> \\<langle>Rk \\<times>\\<^sub>r\n                      Rv\\<rangle>list_rel \\<Longrightarrow>\n       (list_map_delete_aux eq k [] accu,\n        list_map_delete_aux (=) k' [] accu')\n       \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n 2. \\<And>x x' l l' accu accu'.\n       \\<lbrakk>(x, x') \\<in> Rk \\<times>\\<^sub>r Rv;\n        (l, l') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel;\n        \\<And>accu accu'.\n           (accu, accu')\n           \\<in> \\<langle>Rk \\<times>\\<^sub>r\n                          Rv\\<rangle>list_rel \\<Longrightarrow>\n           (list_map_delete_aux eq k l accu,\n            list_map_delete_aux (=) k' l' accu')\n           \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel;\n        (accu, accu')\n        \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (list_map_delete_aux eq k (x # l) accu,\n                          list_map_delete_aux (=) k' (x' # l') accu')\n                         \\<in> \\<langle>Rk \\<times>\\<^sub>r\n  Rv\\<rangle>list_rel", "thus ?case"], ["proof (prove)\nusing this:\n  (accu, accu') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. (list_map_delete_aux eq k [] accu, list_map_delete_aux (=) k' [] accu')\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel", "by (simp add: K)"], ["proof (state)\nthis:\n  (list_map_delete_aux eq k [] accu, list_map_delete_aux (=) k' [] accu')\n  \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. \\<And>x x' l l' accu accu'.\n       \\<lbrakk>(x, x') \\<in> Rk \\<times>\\<^sub>r Rv;\n        (l, l') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel;\n        \\<And>accu accu'.\n           (accu, accu')\n           \\<in> \\<langle>Rk \\<times>\\<^sub>r\n                          Rv\\<rangle>list_rel \\<Longrightarrow>\n           (list_map_delete_aux eq k l accu,\n            list_map_delete_aux (=) k' l' accu')\n           \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel;\n        (accu, accu')\n        \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (list_map_delete_aux eq k (x # l) accu,\n                          list_map_delete_aux (=) k' (x' # l') accu')\n                         \\<in> \\<langle>Rk \\<times>\\<^sub>r\n  Rv\\<rangle>list_rel", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x x' l l' accu accu'.\n       \\<lbrakk>(x, x') \\<in> Rk \\<times>\\<^sub>r Rv;\n        (l, l') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel;\n        \\<And>accu accu'.\n           (accu, accu')\n           \\<in> \\<langle>Rk \\<times>\\<^sub>r\n                          Rv\\<rangle>list_rel \\<Longrightarrow>\n           (list_map_delete_aux eq k l accu,\n            list_map_delete_aux (=) k' l' accu')\n           \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel;\n        (accu, accu')\n        \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (list_map_delete_aux eq k (x # l) accu,\n                          list_map_delete_aux (=) k' (x' # l') accu')\n                         \\<in> \\<langle>Rk \\<times>\\<^sub>r\n  Rv\\<rangle>list_rel", "case (Cons x x' xs xs')"], ["proof (state)\nthis:\n  (x, x') \\<in> Rk \\<times>\\<^sub>r Rv\n  (xs, xs') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n  (?accu, ?accu')\n  \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel \\<Longrightarrow>\n  (list_map_delete_aux eq k xs ?accu, list_map_delete_aux (=) k' xs' ?accu')\n  \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n  (accu, accu') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. \\<And>x x' l l' accu accu'.\n       \\<lbrakk>(x, x') \\<in> Rk \\<times>\\<^sub>r Rv;\n        (l, l') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel;\n        \\<And>accu accu'.\n           (accu, accu')\n           \\<in> \\<langle>Rk \\<times>\\<^sub>r\n                          Rv\\<rangle>list_rel \\<Longrightarrow>\n           (list_map_delete_aux eq k l accu,\n            list_map_delete_aux (=) k' l' accu')\n           \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel;\n        (accu, accu')\n        \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (list_map_delete_aux eq k (x # l) accu,\n                          list_map_delete_aux (=) k' (x' # l') accu')\n                         \\<in> \\<langle>Rk \\<times>\\<^sub>r\n  Rv\\<rangle>list_rel", "from eq"], ["proof (chain)\npicking this:\n  (eq, (=)) \\<in> Rk \\<rightarrow> Rk \\<rightarrow> bool_rel", "have eq': \"(eq,(=)) \\<in> Rk \\<rightarrow> Rk \\<rightarrow> Id\""], ["proof (prove)\nusing this:\n  (eq, (=)) \\<in> Rk \\<rightarrow> Rk \\<rightarrow> bool_rel\n\ngoal (1 subgoal):\n 1. (eq, (=)) \\<in> Rk \\<rightarrow> Rk \\<rightarrow> bool_rel", "by simp"], ["proof (state)\nthis:\n  (eq, (=)) \\<in> Rk \\<rightarrow> Rk \\<rightarrow> bool_rel\n\ngoal (1 subgoal):\n 1. \\<And>x x' l l' accu accu'.\n       \\<lbrakk>(x, x') \\<in> Rk \\<times>\\<^sub>r Rv;\n        (l, l') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel;\n        \\<And>accu accu'.\n           (accu, accu')\n           \\<in> \\<langle>Rk \\<times>\\<^sub>r\n                          Rv\\<rangle>list_rel \\<Longrightarrow>\n           (list_map_delete_aux eq k l accu,\n            list_map_delete_aux (=) k' l' accu')\n           \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel;\n        (accu, accu')\n        \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (list_map_delete_aux eq k (x # l) accu,\n                          list_map_delete_aux (=) k' (x' # l') accu')\n                         \\<in> \\<langle>Rk \\<times>\\<^sub>r\n  Rv\\<rangle>list_rel", "from eq'[param_fo] Cons(1) K"], ["proof (chain)\npicking this:\n  \\<lbrakk>(?x1, ?x'1) \\<in> Rk; (?x, ?x') \\<in> Rk\\<rbrakk>\n  \\<Longrightarrow> (eq ?x1 ?x, ?x'1 = ?x') \\<in> bool_rel\n  (x, x') \\<in> Rk \\<times>\\<^sub>r Rv\n  (k, k') \\<in> Rk", "have [simp]: \"(eq (fst x) k) \\<longleftrightarrow> ((fst x') = k')\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(?x1, ?x'1) \\<in> Rk; (?x, ?x') \\<in> Rk\\<rbrakk>\n  \\<Longrightarrow> (eq ?x1 ?x, ?x'1 = ?x') \\<in> bool_rel\n  (x, x') \\<in> Rk \\<times>\\<^sub>r Rv\n  (k, k') \\<in> Rk\n\ngoal (1 subgoal):\n 1. eq (fst x) k = (fst x' = k')", "by (force simp: prod_rel_def)"], ["proof (state)\nthis:\n  eq (fst x) k = (fst x' = k')\n\ngoal (1 subgoal):\n 1. \\<And>x x' l l' accu accu'.\n       \\<lbrakk>(x, x') \\<in> Rk \\<times>\\<^sub>r Rv;\n        (l, l') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel;\n        \\<And>accu accu'.\n           (accu, accu')\n           \\<in> \\<langle>Rk \\<times>\\<^sub>r\n                          Rv\\<rangle>list_rel \\<Longrightarrow>\n           (list_map_delete_aux eq k l accu,\n            list_map_delete_aux (=) k' l' accu')\n           \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel;\n        (accu, accu')\n        \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\\<rbrakk>\n       \\<Longrightarrow> (list_map_delete_aux eq k (x # l) accu,\n                          list_map_delete_aux (=) k' (x' # l') accu')\n                         \\<in> \\<langle>Rk \\<times>\\<^sub>r\n  Rv\\<rangle>list_rel", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_map_delete_aux eq k (x # xs) accu,\n     list_map_delete_aux (=) k' (x' # xs') accu')\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel", "proof (cases \"eq (fst x) k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. eq (fst x) k \\<Longrightarrow>\n    (list_map_delete_aux eq k (x # xs) accu,\n     list_map_delete_aux (=) k' (x' # xs') accu')\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n 2. \\<not> eq (fst x) k \\<Longrightarrow>\n    (list_map_delete_aux eq k (x # xs) accu,\n     list_map_delete_aux (=) k' (x' # xs') accu')\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel", "case False"], ["proof (state)\nthis:\n  \\<not> eq (fst x) k\n\ngoal (2 subgoals):\n 1. eq (fst x) k \\<Longrightarrow>\n    (list_map_delete_aux eq k (x # xs) accu,\n     list_map_delete_aux (=) k' (x' # xs') accu')\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n 2. \\<not> eq (fst x) k \\<Longrightarrow>\n    (list_map_delete_aux eq k (x # xs) accu,\n     list_map_delete_aux (=) k' (x' # xs') accu')\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel", "from Cons.prems and Cons.hyps"], ["proof (chain)\npicking this:\n  (accu, accu') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n  (x, x') \\<in> Rk \\<times>\\<^sub>r Rv\n  (xs, xs') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel", "have \"(x # accu, x' # accu') \\<in> \n            \\<langle>\\<langle>Rk, Rv\\<rangle>prod_rel\\<rangle>list_rel\""], ["proof (prove)\nusing this:\n  (accu, accu') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n  (x, x') \\<in> Rk \\<times>\\<^sub>r Rv\n  (xs, xs') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. (x # accu, x' # accu')\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel", "by parametricity"], ["proof (state)\nthis:\n  (x # accu, x' # accu')\n  \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n\ngoal (2 subgoals):\n 1. eq (fst x) k \\<Longrightarrow>\n    (list_map_delete_aux eq k (x # xs) accu,\n     list_map_delete_aux (=) k' (x' # xs') accu')\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n 2. \\<not> eq (fst x) k \\<Longrightarrow>\n    (list_map_delete_aux eq k (x # xs) accu,\n     list_map_delete_aux (=) k' (x' # xs') accu')\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel", "from Cons.IH[OF this] and False"], ["proof (chain)\npicking this:\n  (list_map_delete_aux eq k xs (x # accu),\n   list_map_delete_aux (=) k' xs' (x' # accu'))\n  \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n  \\<not> eq (fst x) k", "show ?thesis"], ["proof (prove)\nusing this:\n  (list_map_delete_aux eq k xs (x # accu),\n   list_map_delete_aux (=) k' xs' (x' # accu'))\n  \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n  \\<not> eq (fst x) k\n\ngoal (1 subgoal):\n 1. (list_map_delete_aux eq k (x # xs) accu,\n     list_map_delete_aux (=) k' (x' # xs') accu')\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel", "by simp"], ["proof (state)\nthis:\n  (list_map_delete_aux eq k (x # xs) accu,\n   list_map_delete_aux (=) k' (x' # xs') accu')\n  \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. eq (fst x) k \\<Longrightarrow>\n    (list_map_delete_aux eq k (x # xs) accu,\n     list_map_delete_aux (=) k' (x' # xs') accu')\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. eq (fst x) k \\<Longrightarrow>\n    (list_map_delete_aux eq k (x # xs) accu,\n     list_map_delete_aux (=) k' (x' # xs') accu')\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel", "case True"], ["proof (state)\nthis:\n  eq (fst x) k\n\ngoal (1 subgoal):\n 1. eq (fst x) k \\<Longrightarrow>\n    (list_map_delete_aux eq k (x # xs) accu,\n     list_map_delete_aux (=) k' (x' # xs') accu')\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel", "from Cons.prems and Cons.hyps"], ["proof (chain)\npicking this:\n  (accu, accu') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n  (x, x') \\<in> Rk \\<times>\\<^sub>r Rv\n  (xs, xs') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel", "have \"(xs @ accu, xs' @ accu') \\<in>\n            \\<langle>\\<langle>Rk, Rv\\<rangle>prod_rel\\<rangle>list_rel\""], ["proof (prove)\nusing this:\n  (accu, accu') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n  (x, x') \\<in> Rk \\<times>\\<^sub>r Rv\n  (xs, xs') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. (xs @ accu, xs' @ accu')\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel", "by parametricity"], ["proof (state)\nthis:\n  (xs @ accu, xs' @ accu')\n  \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. eq (fst x) k \\<Longrightarrow>\n    (list_map_delete_aux eq k (x # xs) accu,\n     list_map_delete_aux (=) k' (x' # xs') accu')\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel", "with K and True"], ["proof (chain)\npicking this:\n  (k, k') \\<in> Rk\n  eq (fst x) k\n  (xs @ accu, xs' @ accu')\n  \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel", "show ?thesis"], ["proof (prove)\nusing this:\n  (k, k') \\<in> Rk\n  eq (fst x) k\n  (xs @ accu, xs' @ accu')\n  \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. (list_map_delete_aux eq k (x # xs) accu,\n     list_map_delete_aux (=) k' (x' # xs') accu')\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel", "by simp"], ["proof (state)\nthis:\n  (list_map_delete_aux eq k (x # xs) accu,\n   list_map_delete_aux (=) k' (x' # xs') accu')\n  \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (list_map_delete_aux eq k (x # xs) accu,\n   list_map_delete_aux (=) k' (x' # xs') accu')\n  \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma list_map_autoref_delete1[param]:\n  assumes eq: \"(eq,(=)) \\<in> Rk \\<rightarrow> Rk \\<rightarrow> Id\"\n  shows \"(list_map_delete eq, list_map_delete (=)) \\<in> Rk \\<rightarrow> \n             \\<langle>\\<langle>Rk, Rv\\<rangle>prod_rel\\<rangle>list_rel \\<rightarrow> \\<langle>\\<langle>Rk, Rv\\<rangle>prod_rel\\<rangle>list_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_map_delete eq, list_map_delete (=))\n    \\<in> Rk \\<rightarrow>\n          \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel \\<rightarrow>\n          \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel", "unfolding list_map_delete_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>k m. list_map_delete_aux eq k m [],\n     \\<lambda>k m. list_map_delete_aux (=) k m [])\n    \\<in> Rk \\<rightarrow>\n          \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel \\<rightarrow>\n          \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel", "by (intro fun_relI, erule list_map_autoref_delete_aux1[OF eq], \n      simp_all)"], ["", "lemma list_map_autoref_delete_aux2:\n  assumes K: \"(k, k') \\<in> Id\"\n  assumes A: \"(accu, accu') \\<in> br map_of list_map_invar\"\n  assumes A1: \"distinct (map fst (m @ accu))\"\n  assumes A2: \"k \\<notin> set (map fst accu)\"\n  assumes M: \"(m, m') \\<in> br map_of list_map_invar\"\n  shows \"(list_map_delete_aux (=) k m accu, \n          accu' ++ op_map_delete k' m')\n               \\<in> br map_of list_map_invar\" (is \"(?f m accu, _) \\<in> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_map_delete_aux (=) k m accu, accu' ++ op_map_delete k' m')\n    \\<in> br map_of list_map_invar", "using M A A1 A2"], ["proof (prove)\nusing this:\n  (m, m') \\<in> br map_of list_map_invar\n  (accu, accu') \\<in> br map_of list_map_invar\n  distinct (map fst (m @ accu))\n  k \\<notin> set (map fst accu)\n\ngoal (1 subgoal):\n 1. (list_map_delete_aux (=) k m accu, accu' ++ op_map_delete k' m')\n    \\<in> br map_of list_map_invar", "proof (induction m arbitrary: accu accu' m')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>accu accu' m'.\n       \\<lbrakk>([], m') \\<in> br map_of list_map_invar;\n        (accu, accu') \\<in> br map_of list_map_invar;\n        distinct (map fst ([] @ accu));\n        k \\<notin> set (map fst accu)\\<rbrakk>\n       \\<Longrightarrow> (list_map_delete_aux (=) k [] accu,\n                          accu' ++ op_map_delete k' m')\n                         \\<in> br map_of list_map_invar\n 2. \\<And>a m accu accu' m'.\n       \\<lbrakk>\\<And>accu accu' m'.\n                   \\<lbrakk>(m, m') \\<in> br map_of list_map_invar;\n                    (accu, accu') \\<in> br map_of list_map_invar;\n                    distinct (map fst (m @ accu));\n                    k \\<notin> set (map fst accu)\\<rbrakk>\n                   \\<Longrightarrow> (list_map_delete_aux (=) k m accu,\naccu' ++ op_map_delete k' m')\n                                     \\<in> br map_of list_map_invar;\n        (a # m, m') \\<in> br map_of list_map_invar;\n        (accu, accu') \\<in> br map_of list_map_invar;\n        distinct (map fst ((a # m) @ accu));\n        k \\<notin> set (map fst accu)\\<rbrakk>\n       \\<Longrightarrow> (list_map_delete_aux (=) k (a # m) accu,\n                          accu' ++ op_map_delete k' m')\n                         \\<in> br map_of list_map_invar", "case Nil"], ["proof (state)\nthis:\n  ([], m') \\<in> br map_of list_map_invar\n  (accu, accu') \\<in> br map_of list_map_invar\n  distinct (map fst ([] @ accu))\n  k \\<notin> set (map fst accu)\n\ngoal (2 subgoals):\n 1. \\<And>accu accu' m'.\n       \\<lbrakk>([], m') \\<in> br map_of list_map_invar;\n        (accu, accu') \\<in> br map_of list_map_invar;\n        distinct (map fst ([] @ accu));\n        k \\<notin> set (map fst accu)\\<rbrakk>\n       \\<Longrightarrow> (list_map_delete_aux (=) k [] accu,\n                          accu' ++ op_map_delete k' m')\n                         \\<in> br map_of list_map_invar\n 2. \\<And>a m accu accu' m'.\n       \\<lbrakk>\\<And>accu accu' m'.\n                   \\<lbrakk>(m, m') \\<in> br map_of list_map_invar;\n                    (accu, accu') \\<in> br map_of list_map_invar;\n                    distinct (map fst (m @ accu));\n                    k \\<notin> set (map fst accu)\\<rbrakk>\n                   \\<Longrightarrow> (list_map_delete_aux (=) k m accu,\naccu' ++ op_map_delete k' m')\n                                     \\<in> br map_of list_map_invar;\n        (a # m, m') \\<in> br map_of list_map_invar;\n        (accu, accu') \\<in> br map_of list_map_invar;\n        distinct (map fst ((a # m) @ accu));\n        k \\<notin> set (map fst accu)\\<rbrakk>\n       \\<Longrightarrow> (list_map_delete_aux (=) k (a # m) accu,\n                          accu' ++ op_map_delete k' m')\n                         \\<in> br map_of list_map_invar", "with K"], ["proof (chain)\npicking this:\n  (k, k') \\<in> Id\n  ([], m') \\<in> br map_of list_map_invar\n  (accu, accu') \\<in> br map_of list_map_invar\n  distinct (map fst ([] @ accu))\n  k \\<notin> set (map fst accu)", "show ?case"], ["proof (prove)\nusing this:\n  (k, k') \\<in> Id\n  ([], m') \\<in> br map_of list_map_invar\n  (accu, accu') \\<in> br map_of list_map_invar\n  distinct (map fst ([] @ accu))\n  k \\<notin> set (map fst accu)\n\ngoal (1 subgoal):\n 1. (list_map_delete_aux (=) k [] accu, accu' ++ op_map_delete k' m')\n    \\<in> br map_of list_map_invar", "by (auto simp: br_def list_map_invar_def \n        map_add_sng_right')"], ["proof (state)\nthis:\n  (list_map_delete_aux (=) k [] accu, accu' ++ op_map_delete k' m')\n  \\<in> br map_of list_map_invar\n\ngoal (1 subgoal):\n 1. \\<And>a m accu accu' m'.\n       \\<lbrakk>\\<And>accu accu' m'.\n                   \\<lbrakk>(m, m') \\<in> br map_of list_map_invar;\n                    (accu, accu') \\<in> br map_of list_map_invar;\n                    distinct (map fst (m @ accu));\n                    k \\<notin> set (map fst accu)\\<rbrakk>\n                   \\<Longrightarrow> (list_map_delete_aux (=) k m accu,\naccu' ++ op_map_delete k' m')\n                                     \\<in> br map_of list_map_invar;\n        (a # m, m') \\<in> br map_of list_map_invar;\n        (accu, accu') \\<in> br map_of list_map_invar;\n        distinct (map fst ((a # m) @ accu));\n        k \\<notin> set (map fst accu)\\<rbrakk>\n       \\<Longrightarrow> (list_map_delete_aux (=) k (a # m) accu,\n                          accu' ++ op_map_delete k' m')\n                         \\<in> br map_of list_map_invar", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a m accu accu' m'.\n       \\<lbrakk>\\<And>accu accu' m'.\n                   \\<lbrakk>(m, m') \\<in> br map_of list_map_invar;\n                    (accu, accu') \\<in> br map_of list_map_invar;\n                    distinct (map fst (m @ accu));\n                    k \\<notin> set (map fst accu)\\<rbrakk>\n                   \\<Longrightarrow> (list_map_delete_aux (=) k m accu,\naccu' ++ op_map_delete k' m')\n                                     \\<in> br map_of list_map_invar;\n        (a # m, m') \\<in> br map_of list_map_invar;\n        (accu, accu') \\<in> br map_of list_map_invar;\n        distinct (map fst ((a # m) @ accu));\n        k \\<notin> set (map fst accu)\\<rbrakk>\n       \\<Longrightarrow> (list_map_delete_aux (=) k (a # m) accu,\n                          accu' ++ op_map_delete k' m')\n                         \\<in> br map_of list_map_invar", "case (Cons x xs accu accu' m')"], ["proof (state)\nthis:\n  \\<lbrakk>(xs, ?m') \\<in> br map_of list_map_invar;\n   (?accu, ?accu') \\<in> br map_of list_map_invar;\n   distinct (map fst (xs @ ?accu)); k \\<notin> set (map fst ?accu)\\<rbrakk>\n  \\<Longrightarrow> (list_map_delete_aux (=) k xs ?accu,\n                     ?accu' ++ op_map_delete k' ?m')\n                    \\<in> br map_of list_map_invar\n  (x # xs, m') \\<in> br map_of list_map_invar\n  (accu, accu') \\<in> br map_of list_map_invar\n  distinct (map fst ((x # xs) @ accu))\n  k \\<notin> set (map fst accu)\n\ngoal (1 subgoal):\n 1. \\<And>a m accu accu' m'.\n       \\<lbrakk>\\<And>accu accu' m'.\n                   \\<lbrakk>(m, m') \\<in> br map_of list_map_invar;\n                    (accu, accu') \\<in> br map_of list_map_invar;\n                    distinct (map fst (m @ accu));\n                    k \\<notin> set (map fst accu)\\<rbrakk>\n                   \\<Longrightarrow> (list_map_delete_aux (=) k m accu,\naccu' ++ op_map_delete k' m')\n                                     \\<in> br map_of list_map_invar;\n        (a # m, m') \\<in> br map_of list_map_invar;\n        (accu, accu') \\<in> br map_of list_map_invar;\n        distinct (map fst ((a # m) @ accu));\n        k \\<notin> set (map fst accu)\\<rbrakk>\n       \\<Longrightarrow> (list_map_delete_aux (=) k (a # m) accu,\n                          accu' ++ op_map_delete k' m')\n                         \\<in> br map_of list_map_invar", "from Cons.prems"], ["proof (chain)\npicking this:\n  (x # xs, m') \\<in> br map_of list_map_invar\n  (accu, accu') \\<in> br map_of list_map_invar\n  distinct (map fst ((x # xs) @ accu))\n  k \\<notin> set (map fst accu)", "have A: \"m' = map_of (x#xs)\" \"accu' = map_of accu\""], ["proof (prove)\nusing this:\n  (x # xs, m') \\<in> br map_of list_map_invar\n  (accu, accu') \\<in> br map_of list_map_invar\n  distinct (map fst ((x # xs) @ accu))\n  k \\<notin> set (map fst accu)\n\ngoal (1 subgoal):\n 1. m' = map_of (x # xs) &&& accu' = map_of accu", "unfolding br_def"], ["proof (prove)\nusing this:\n  (x # xs, m') \\<in> {(c, a). a = map_of c \\<and> list_map_invar c}\n  (accu, accu') \\<in> {(c, a). a = map_of c \\<and> list_map_invar c}\n  distinct (map fst ((x # xs) @ accu))\n  k \\<notin> set (map fst accu)\n\ngoal (1 subgoal):\n 1. m' = map_of (x # xs) &&& accu' = map_of accu", "by simp_all"], ["proof (state)\nthis:\n  m' = map_of (x # xs)\n  accu' = map_of accu\n\ngoal (1 subgoal):\n 1. \\<And>a m accu accu' m'.\n       \\<lbrakk>\\<And>accu accu' m'.\n                   \\<lbrakk>(m, m') \\<in> br map_of list_map_invar;\n                    (accu, accu') \\<in> br map_of list_map_invar;\n                    distinct (map fst (m @ accu));\n                    k \\<notin> set (map fst accu)\\<rbrakk>\n                   \\<Longrightarrow> (list_map_delete_aux (=) k m accu,\naccu' ++ op_map_delete k' m')\n                                     \\<in> br map_of list_map_invar;\n        (a # m, m') \\<in> br map_of list_map_invar;\n        (accu, accu') \\<in> br map_of list_map_invar;\n        distinct (map fst ((a # m) @ accu));\n        k \\<notin> set (map fst accu)\\<rbrakk>\n       \\<Longrightarrow> (list_map_delete_aux (=) k (a # m) accu,\n                          accu' ++ op_map_delete k' m')\n                         \\<in> br map_of list_map_invar", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_map_delete_aux (=) k (x # xs) accu, accu' ++ op_map_delete k' m')\n    \\<in> br map_of list_map_invar", "proof (cases \"(fst x) =  k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. fst x = k \\<Longrightarrow>\n    (list_map_delete_aux (=) k (x # xs) accu, accu' ++ op_map_delete k' m')\n    \\<in> br map_of list_map_invar\n 2. fst x \\<noteq> k \\<Longrightarrow>\n    (list_map_delete_aux (=) k (x # xs) accu, accu' ++ op_map_delete k' m')\n    \\<in> br map_of list_map_invar", "case True"], ["proof (state)\nthis:\n  fst x = k\n\ngoal (2 subgoals):\n 1. fst x = k \\<Longrightarrow>\n    (list_map_delete_aux (=) k (x # xs) accu, accu' ++ op_map_delete k' m')\n    \\<in> br map_of list_map_invar\n 2. fst x \\<noteq> k \\<Longrightarrow>\n    (list_map_delete_aux (=) k (x # xs) accu, accu' ++ op_map_delete k' m')\n    \\<in> br map_of list_map_invar", "with Cons.prems(3)"], ["proof (chain)\npicking this:\n  distinct (map fst ((x # xs) @ accu))\n  fst x = k", "have \"map_of xs (fst x) = None\""], ["proof (prove)\nusing this:\n  distinct (map fst ((x # xs) @ accu))\n  fst x = k\n\ngoal (1 subgoal):\n 1. map_of xs (fst x) = None", "by (induction xs, simp_all)"], ["proof (state)\nthis:\n  map_of xs (fst x) = None\n\ngoal (2 subgoals):\n 1. fst x = k \\<Longrightarrow>\n    (list_map_delete_aux (=) k (x # xs) accu, accu' ++ op_map_delete k' m')\n    \\<in> br map_of list_map_invar\n 2. fst x \\<noteq> k \\<Longrightarrow>\n    (list_map_delete_aux (=) k (x # xs) accu, accu' ++ op_map_delete k' m')\n    \\<in> br map_of list_map_invar", "with fun_upd_triv[of \"map_of xs\" \"fst x\"]"], ["proof (chain)\npicking this:\n  (map_of xs)(fst x := map_of xs (fst x)) = map_of xs\n  map_of xs (fst x) = None", "have \"map_of xs |` (- {fst x}) = map_of xs\""], ["proof (prove)\nusing this:\n  (map_of xs)(fst x := map_of xs (fst x)) = map_of xs\n  map_of xs (fst x) = None\n\ngoal (1 subgoal):\n 1. map_of xs |` (- {fst x}) = map_of xs", "by (simp add: map_upd_eq_restrict)"], ["proof (state)\nthis:\n  map_of xs |` (- {fst x}) = map_of xs\n\ngoal (2 subgoals):\n 1. fst x = k \\<Longrightarrow>\n    (list_map_delete_aux (=) k (x # xs) accu, accu' ++ op_map_delete k' m')\n    \\<in> br map_of list_map_invar\n 2. fst x \\<noteq> k \\<Longrightarrow>\n    (list_map_delete_aux (=) k (x # xs) accu, accu' ++ op_map_delete k' m')\n    \\<in> br map_of list_map_invar", "with True"], ["proof (chain)\npicking this:\n  fst x = k\n  map_of xs |` (- {fst x}) = map_of xs", "have\"(xs @ accu, accu' ++ op_map_delete k' m')\n                           \\<in> br map_of list_map_invar\""], ["proof (prove)\nusing this:\n  fst x = k\n  map_of xs |` (- {fst x}) = map_of xs\n\ngoal (1 subgoal):\n 1. (xs @ accu, accu' ++ op_map_delete k' m') \\<in> br map_of list_map_invar", "using K Cons.prems"], ["proof (prove)\nusing this:\n  fst x = k\n  map_of xs |` (- {fst x}) = map_of xs\n  (k, k') \\<in> Id\n  (x # xs, m') \\<in> br map_of list_map_invar\n  (accu, accu') \\<in> br map_of list_map_invar\n  distinct (map fst ((x # xs) @ accu))\n  k \\<notin> set (map fst accu)\n\ngoal (1 subgoal):\n 1. (xs @ accu, accu' ++ op_map_delete k' m') \\<in> br map_of list_map_invar", "unfolding br_def"], ["proof (prove)\nusing this:\n  fst x = k\n  map_of xs |` (- {fst x}) = map_of xs\n  (k, k') \\<in> Id\n  (x # xs, m') \\<in> {(c, a). a = map_of c \\<and> list_map_invar c}\n  (accu, accu') \\<in> {(c, a). a = map_of c \\<and> list_map_invar c}\n  distinct (map fst ((x # xs) @ accu))\n  k \\<notin> set (map fst accu)\n\ngoal (1 subgoal):\n 1. (xs @ accu, accu' ++ op_map_delete k' m')\n    \\<in> {(c, a). a = map_of c \\<and> list_map_invar c}", "by (auto simp add: A list_map_invar_def)"], ["proof (state)\nthis:\n  (xs @ accu, accu' ++ op_map_delete k' m') \\<in> br map_of list_map_invar\n\ngoal (2 subgoals):\n 1. fst x = k \\<Longrightarrow>\n    (list_map_delete_aux (=) k (x # xs) accu, accu' ++ op_map_delete k' m')\n    \\<in> br map_of list_map_invar\n 2. fst x \\<noteq> k \\<Longrightarrow>\n    (list_map_delete_aux (=) k (x # xs) accu, accu' ++ op_map_delete k' m')\n    \\<in> br map_of list_map_invar", "thus ?thesis"], ["proof (prove)\nusing this:\n  (xs @ accu, accu' ++ op_map_delete k' m') \\<in> br map_of list_map_invar\n\ngoal (1 subgoal):\n 1. (list_map_delete_aux (=) k (x # xs) accu, accu' ++ op_map_delete k' m')\n    \\<in> br map_of list_map_invar", "using True"], ["proof (prove)\nusing this:\n  (xs @ accu, accu' ++ op_map_delete k' m') \\<in> br map_of list_map_invar\n  fst x = k\n\ngoal (1 subgoal):\n 1. (list_map_delete_aux (=) k (x # xs) accu, accu' ++ op_map_delete k' m')\n    \\<in> br map_of list_map_invar", "by simp"], ["proof (state)\nthis:\n  (list_map_delete_aux (=) k (x # xs) accu, accu' ++ op_map_delete k' m')\n  \\<in> br map_of list_map_invar\n\ngoal (1 subgoal):\n 1. fst x \\<noteq> k \\<Longrightarrow>\n    (list_map_delete_aux (=) k (x # xs) accu, accu' ++ op_map_delete k' m')\n    \\<in> br map_of list_map_invar", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. fst x \\<noteq> k \\<Longrightarrow>\n    (list_map_delete_aux (=) k (x # xs) accu, accu' ++ op_map_delete k' m')\n    \\<in> br map_of list_map_invar", "case False"], ["proof (state)\nthis:\n  fst x \\<noteq> k\n\ngoal (1 subgoal):\n 1. fst x \\<noteq> k \\<Longrightarrow>\n    (list_map_delete_aux (=) k (x # xs) accu, accu' ++ op_map_delete k' m')\n    \\<in> br map_of list_map_invar", "from False and K"], ["proof (chain)\npicking this:\n  fst x \\<noteq> k\n  (k, k') \\<in> Id", "have [simp]: \"fst x \\<noteq> k'\""], ["proof (prove)\nusing this:\n  fst x \\<noteq> k\n  (k, k') \\<in> Id\n\ngoal (1 subgoal):\n 1. fst x \\<noteq> k'", "by simp"], ["proof (state)\nthis:\n  fst x \\<noteq> k'\n\ngoal (1 subgoal):\n 1. fst x \\<noteq> k \\<Longrightarrow>\n    (list_map_delete_aux (=) k (x # xs) accu, accu' ++ op_map_delete k' m')\n    \\<in> br map_of list_map_invar", "from Cons.prems(1)"], ["proof (chain)\npicking this:\n  (x # xs, m') \\<in> br map_of list_map_invar", "have B: \"(xs, map_of xs) \\<in> br map_of \n            list_map_invar\""], ["proof (prove)\nusing this:\n  (x # xs, m') \\<in> br map_of list_map_invar\n\ngoal (1 subgoal):\n 1. (xs, map_of xs) \\<in> br map_of list_map_invar", "by (simp add: br_def list_map_invar_def)"], ["proof (state)\nthis:\n  (xs, map_of xs) \\<in> br map_of list_map_invar\n\ngoal (1 subgoal):\n 1. fst x \\<noteq> k \\<Longrightarrow>\n    (list_map_delete_aux (=) k (x # xs) accu, accu' ++ op_map_delete k' m')\n    \\<in> br map_of list_map_invar", "from Cons.prems(2,3)"], ["proof (chain)\npicking this:\n  (accu, accu') \\<in> br map_of list_map_invar\n  distinct (map fst ((x # xs) @ accu))", "have C: \"(x#accu, map_of (x#accu)) \\<in> br map_of\n            list_map_invar\""], ["proof (prove)\nusing this:\n  (accu, accu') \\<in> br map_of list_map_invar\n  distinct (map fst ((x # xs) @ accu))\n\ngoal (1 subgoal):\n 1. (x # accu, map_of (x # accu)) \\<in> br map_of list_map_invar", "by (simp add: br_def list_map_invar_def)"], ["proof (state)\nthis:\n  (x # accu, map_of (x # accu)) \\<in> br map_of list_map_invar\n\ngoal (1 subgoal):\n 1. fst x \\<noteq> k \\<Longrightarrow>\n    (list_map_delete_aux (=) k (x # xs) accu, accu' ++ op_map_delete k' m')\n    \\<in> br map_of list_map_invar", "from Cons.prems(3)"], ["proof (chain)\npicking this:\n  distinct (map fst ((x # xs) @ accu))", "have D: \"distinct (map fst (xs @ x # accu))\""], ["proof (prove)\nusing this:\n  distinct (map fst ((x # xs) @ accu))\n\ngoal (1 subgoal):\n 1. distinct (map fst (xs @ x # accu))", "by simp"], ["proof (state)\nthis:\n  distinct (map fst (xs @ x # accu))\n\ngoal (1 subgoal):\n 1. fst x \\<noteq> k \\<Longrightarrow>\n    (list_map_delete_aux (=) k (x # xs) accu, accu' ++ op_map_delete k' m')\n    \\<in> br map_of list_map_invar", "from Cons.prems(4) and False"], ["proof (chain)\npicking this:\n  k \\<notin> set (map fst accu)\n  fst x \\<noteq> k", "have E: \"k \\<notin> set (map fst (x # accu))\""], ["proof (prove)\nusing this:\n  k \\<notin> set (map fst accu)\n  fst x \\<noteq> k\n\ngoal (1 subgoal):\n 1. k \\<notin> set (map fst (x # accu))", "by simp"], ["proof (state)\nthis:\n  k \\<notin> set (map fst (x # accu))\n\ngoal (1 subgoal):\n 1. fst x \\<noteq> k \\<Longrightarrow>\n    (list_map_delete_aux (=) k (x # xs) accu, accu' ++ op_map_delete k' m')\n    \\<in> br map_of list_map_invar", "note Cons.IH[OF B C D E]"], ["proof (state)\nthis:\n  (list_map_delete_aux (=) k xs (x # accu),\n   map_of (x # accu) ++ op_map_delete k' (map_of xs))\n  \\<in> br map_of list_map_invar\n\ngoal (1 subgoal):\n 1. fst x \\<noteq> k \\<Longrightarrow>\n    (list_map_delete_aux (=) k (x # xs) accu, accu' ++ op_map_delete k' m')\n    \\<in> br map_of list_map_invar", "also"], ["proof (state)\nthis:\n  (list_map_delete_aux (=) k xs (x # accu),\n   map_of (x # accu) ++ op_map_delete k' (map_of xs))\n  \\<in> br map_of list_map_invar\n\ngoal (1 subgoal):\n 1. fst x \\<noteq> k \\<Longrightarrow>\n    (list_map_delete_aux (=) k (x # xs) accu, accu' ++ op_map_delete k' m')\n    \\<in> br map_of list_map_invar", "from False"], ["proof (chain)\npicking this:\n  fst x \\<noteq> k", "have \"?f xs (x#accu) = ?f (x#xs) accu\""], ["proof (prove)\nusing this:\n  fst x \\<noteq> k\n\ngoal (1 subgoal):\n 1. list_map_delete_aux (=) k xs (x # accu) =\n    list_map_delete_aux (=) k (x # xs) accu", "by simp"], ["proof (state)\nthis:\n  list_map_delete_aux (=) k xs (x # accu) =\n  list_map_delete_aux (=) k (x # xs) accu\n\ngoal (1 subgoal):\n 1. fst x \\<noteq> k \\<Longrightarrow>\n    (list_map_delete_aux (=) k (x # xs) accu, accu' ++ op_map_delete k' m')\n    \\<in> br map_of list_map_invar", "also"], ["proof (state)\nthis:\n  list_map_delete_aux (=) k xs (x # accu) =\n  list_map_delete_aux (=) k (x # xs) accu\n\ngoal (1 subgoal):\n 1. fst x \\<noteq> k \\<Longrightarrow>\n    (list_map_delete_aux (=) k (x # xs) accu, accu' ++ op_map_delete k' m')\n    \\<in> br map_of list_map_invar", "from distinct_map_fstD[OF D]"], ["proof (chain)\npicking this:\n  \\<lbrakk>(?x, ?y) \\<in> set (xs @ x # accu);\n   (?x, ?z) \\<in> set (xs @ x # accu)\\<rbrakk>\n  \\<Longrightarrow> ?y = ?z", "have F: \"\\<And>z. (fst x, z) \\<in> set xs \\<Longrightarrow> z = snd x\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(?x, ?y) \\<in> set (xs @ x # accu);\n   (?x, ?z) \\<in> set (xs @ x # accu)\\<rbrakk>\n  \\<Longrightarrow> ?y = ?z\n\ngoal (1 subgoal):\n 1. \\<And>z. (fst x, z) \\<in> set xs \\<Longrightarrow> z = snd x", "by force"], ["proof (state)\nthis:\n  (fst x, ?z) \\<in> set xs \\<Longrightarrow> ?z = snd x\n\ngoal (1 subgoal):\n 1. fst x \\<noteq> k \\<Longrightarrow>\n    (list_map_delete_aux (=) k (x # xs) accu, accu' ++ op_map_delete k' m')\n    \\<in> br map_of list_map_invar", "from Cons.prems(3)"], ["proof (chain)\npicking this:\n  distinct (map fst ((x # xs) @ accu))", "have \"map_of xs (fst x) = None\""], ["proof (prove)\nusing this:\n  distinct (map fst ((x # xs) @ accu))\n\ngoal (1 subgoal):\n 1. map_of xs (fst x) = None", "by (induction xs, simp_all)"], ["proof (state)\nthis:\n  map_of xs (fst x) = None\n\ngoal (1 subgoal):\n 1. fst x \\<noteq> k \\<Longrightarrow>\n    (list_map_delete_aux (=) k (x # xs) accu, accu' ++ op_map_delete k' m')\n    \\<in> br map_of list_map_invar", "hence \"map_of (x # accu) ++ op_map_delete k' (map_of xs) = \n               accu' ++ op_map_delete k' m'\""], ["proof (prove)\nusing this:\n  map_of xs (fst x) = None\n\ngoal (1 subgoal):\n 1. map_of (x # accu) ++ op_map_delete k' (map_of xs) =\n    accu' ++ op_map_delete k' m'", "apply (intro ext, simp add: map_add_def A\n                                   split: option.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       map_of xs (fst x) = None \\<Longrightarrow>\n       ((map_of xs |` (- {k'})) xa = None \\<longrightarrow>\n        (\\<forall>x2.\n            (map_of xs |` (- {k'} - {fst x})) xa = Some x2 \\<longrightarrow>\n            xa \\<noteq> fst x \\<longrightarrow>\n            map_of accu xa = Some x2)) \\<and>\n       (\\<forall>x2.\n           (map_of xs |` (- {k'})) xa = Some x2 \\<longrightarrow>\n           ((map_of xs |` (- {k'} - {fst x})) xa = None \\<longrightarrow>\n            xa \\<noteq> fst x \\<longrightarrow>\n            Some x2 = map_of accu xa) \\<and>\n           (\\<forall>x2a.\n               (map_of xs |` (- {k'} - {fst x})) xa =\n               Some x2a \\<longrightarrow>\n               xa \\<noteq> fst x \\<longrightarrow> x2 = x2a))", "apply (intro conjI impI allI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa x2.\n       \\<lbrakk>map_of xs (fst x) = None; (map_of xs |` (- {k'})) xa = None;\n        (map_of xs |` (- {k'} - {fst x})) xa = Some x2;\n        xa \\<noteq> fst x\\<rbrakk>\n       \\<Longrightarrow> map_of accu xa = Some x2\n 2. \\<And>xa x2.\n       \\<lbrakk>map_of xs (fst x) = None;\n        (map_of xs |` (- {k'})) xa = Some x2;\n        (map_of xs |` (- {k'} - {fst x})) xa = None;\n        xa \\<noteq> fst x\\<rbrakk>\n       \\<Longrightarrow> Some x2 = map_of accu xa\n 3. \\<And>xa x2 x2a.\n       \\<lbrakk>map_of xs (fst x) = None;\n        (map_of xs |` (- {k'})) xa = Some x2;\n        (map_of xs |` (- {k'} - {fst x})) xa = Some x2a;\n        xa \\<noteq> fst x\\<rbrakk>\n       \\<Longrightarrow> x2 = x2a", "apply (auto simp: restrict_map_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  map_of (x # accu) ++ op_map_delete k' (map_of xs) =\n  accu' ++ op_map_delete k' m'\n\ngoal (1 subgoal):\n 1. fst x \\<noteq> k \\<Longrightarrow>\n    (list_map_delete_aux (=) k (x # xs) accu, accu' ++ op_map_delete k' m')\n    \\<in> br map_of list_map_invar", "finally"], ["proof (chain)\npicking this:\n  (list_map_delete_aux (=) k (x # xs) accu, accu' ++ op_map_delete k' m')\n  \\<in> br map_of list_map_invar", "show ?thesis"], ["proof (prove)\nusing this:\n  (list_map_delete_aux (=) k (x # xs) accu, accu' ++ op_map_delete k' m')\n  \\<in> br map_of list_map_invar\n\ngoal (1 subgoal):\n 1. (list_map_delete_aux (=) k (x # xs) accu, accu' ++ op_map_delete k' m')\n    \\<in> br map_of list_map_invar", "."], ["proof (state)\nthis:\n  (list_map_delete_aux (=) k (x # xs) accu, accu' ++ op_map_delete k' m')\n  \\<in> br map_of list_map_invar\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (list_map_delete_aux (=) k (x # xs) accu, accu' ++ op_map_delete k' m')\n  \\<in> br map_of list_map_invar\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma list_map_autoref_delete2[param]:\n  shows \"(list_map_delete (=), op_map_delete) \\<in> Id \\<rightarrow> \n             br map_of list_map_invar \\<rightarrow> br map_of list_map_invar\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_map_delete (=), op_map_delete)\n    \\<in> Id \\<rightarrow>\n          br map_of list_map_invar \\<rightarrow> br map_of list_map_invar", "unfolding list_map_delete_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>k m. list_map_delete_aux (=) k m [], op_map_delete)\n    \\<in> Id \\<rightarrow>\n          br map_of list_map_invar \\<rightarrow> br map_of list_map_invar", "apply (intro fun_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> Id;\n        (aa, a'a) \\<in> br map_of list_map_invar\\<rbrakk>\n       \\<Longrightarrow> (list_map_delete_aux (=) a aa [],\n                          op_map_delete a' a'a)\n                         \\<in> br map_of list_map_invar", "apply (drule list_map_autoref_delete_aux2\n                 [where accu=\"[]\" and accu'=\"Map.empty\"])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a a' aa a'a.\n       (aa, a'a) \\<in> br map_of list_map_invar \\<Longrightarrow>\n       ([], Map.empty) \\<in> br map_of list_map_invar\n 2. \\<And>a a' aa a'a.\n       (aa, a'a) \\<in> br map_of list_map_invar \\<Longrightarrow>\n       distinct (map fst (?m2 a a' aa a'a @ []))\n 3. \\<And>a a' aa a'a.\n       (aa, a'a) \\<in> br map_of list_map_invar \\<Longrightarrow>\n       a \\<notin> set (map fst [])\n 4. \\<And>a a' aa a'a.\n       (aa, a'a) \\<in> br map_of list_map_invar \\<Longrightarrow>\n       (?m2 a a' aa a'a, ?m'2 a a' aa a'a) \\<in> br map_of list_map_invar\n 5. \\<And>a a' aa a'a.\n       \\<lbrakk>(aa, a'a) \\<in> br map_of list_map_invar;\n        (list_map_delete_aux (=) a (?m2 a a' aa a'a) [],\n         Map.empty ++ op_map_delete a' (?m'2 a a' aa a'a))\n        \\<in> br map_of list_map_invar\\<rbrakk>\n       \\<Longrightarrow> (list_map_delete_aux (=) a aa [],\n                          op_map_delete a' a'a)\n                         \\<in> br map_of list_map_invar", "apply (auto simp: br_def list_map_invar_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma list_map_autoref_delete[autoref_rules]:\n  assumes eq: \"GEN_OP eq (=) (Rk\\<rightarrow>Rk\\<rightarrow>Id)\"\n  shows \"(list_map_delete eq, op_map_delete) \\<in>\n      Rk \\<rightarrow> \\<langle>Rk,Rv\\<rangle>list_map_rel \\<rightarrow> \\<langle>Rk,Rv\\<rangle>list_map_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_map_delete eq, op_map_delete)\n    \\<in> Rk \\<rightarrow>\n          \\<langle>Rk, Rv\\<rangle>list_map_rel \\<rightarrow> \\<langle>Rk,\n          Rv\\<rangle>list_map_rel", "unfolding list_map_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_map_delete eq, op_map_delete)\n    \\<in> Rk \\<rightarrow>\n          \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel O\n          br map_of list_map_invar \\<rightarrow>\n          \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel O\n          br map_of list_map_invar", "apply (intro fun_relI, elim relcompE, intro relcompI, clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a a' a'a x y.\n       \\<lbrakk>(a, a') \\<in> Rk;\n        (x, y) \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel;\n        (y, a'a) \\<in> br map_of list_map_invar\\<rbrakk>\n       \\<Longrightarrow> (list_map_delete eq a x, ?b3 a a' x a'a x y a'a)\n                         \\<in> \\<langle>Rk \\<times>\\<^sub>r\n  Rv\\<rangle>list_rel\n 2. \\<And>a a' aa a'a x y z.\n       \\<lbrakk>(a, a') \\<in> Rk; (aa, a'a) = (x, z);\n        (x, y) \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel;\n        (y, z) \\<in> br map_of list_map_invar\\<rbrakk>\n       \\<Longrightarrow> (?b3 a a' aa a'a x y z, op_map_delete a' a'a)\n                         \\<in> br map_of list_map_invar", "apply (erule (1) list_map_autoref_delete1[param_fo, OF eq[simplified]])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a x y z.\n       \\<lbrakk>(a, a') \\<in> Rk; (aa, a'a) = (x, z);\n        (x, y) \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel;\n        (y, z) \\<in> br map_of list_map_invar\\<rbrakk>\n       \\<Longrightarrow> (list_map_delete (=) a' y, op_map_delete a' a'a)\n                         \\<in> br map_of list_map_invar", "apply (rule list_map_autoref_delete2[param_fo], simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma list_map_autoref_isEmpty[autoref_rules]:\n  shows \"(list_map_isEmpty, op_map_isEmpty) \\<in>\n             \\<langle>Rk,Rv\\<rangle>list_map_rel \\<rightarrow> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_map_isEmpty, op_map_isEmpty)\n    \\<in> \\<langle>Rk, Rv\\<rangle>list_map_rel \\<rightarrow> bool_rel", "unfolding list_map_isEmpty_def op_map_isEmpty_def[abs_def]\n    list_map_rel_def br_def List.null_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>xs. xs = [], \\<lambda>x. x = Map.empty)\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel O\n          {(c, a). a = map_of c \\<and> list_map_invar c} \\<rightarrow>\n          bool_rel", "by force"], ["", "lemma param_list_map_isSng[param]:\n  assumes \"(l,l') \\<in> \\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel\"\n  shows \"(list_map_isSng l, list_map_isSng l') \\<in> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_map_isSng l, list_map_isSng l') \\<in> bool_rel", "unfolding list_map_isSng_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case l of [] \\<Rightarrow> False | [x] \\<Rightarrow> True\n     | x # aa # lista \\<Rightarrow> False,\n     case l' of [] \\<Rightarrow> False | [x] \\<Rightarrow> True\n     | x # aa # lista \\<Rightarrow> False)\n    \\<in> bool_rel", "using assms"], ["proof (prove)\nusing this:\n  (l, l') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. (case l of [] \\<Rightarrow> False | [x] \\<Rightarrow> True\n     | x # aa # lista \\<Rightarrow> False,\n     case l' of [] \\<Rightarrow> False | [x] \\<Rightarrow> True\n     | x # aa # lista \\<Rightarrow> False)\n    \\<in> bool_rel", "by parametricity"], ["", "(* TODO: clean up this mess *)"], ["", "lemma list_map_autoref_isSng_aux:\n  assumes \"(l',m') \\<in> br map_of list_map_invar\"\n  shows \"(list_map_isSng l', op_map_isSng m') \\<in> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_map_isSng l', op_map_isSng m') \\<in> bool_rel", "using assms"], ["proof (prove)\nusing this:\n  (l', m') \\<in> br map_of list_map_invar\n\ngoal (1 subgoal):\n 1. (list_map_isSng l', op_map_isSng m') \\<in> bool_rel", "unfolding list_map_isSng_def op_map_isSng_def br_def list_map_invar_def"], ["proof (prove)\nusing this:\n  (l', m')\n  \\<in> {(c, a). a = map_of c \\<and> (distinct \\<circ>\\<circ> map) fst c}\n\ngoal (1 subgoal):\n 1. (case l' of [] \\<Rightarrow> False | [x] \\<Rightarrow> True\n     | x # aa # lista \\<Rightarrow> False,\n     \\<exists>k v. m' = [k \\<mapsto> v])\n    \\<in> bool_rel", "apply (clarsimp split: list.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m' = map_of l'; distinct (map fst l')\\<rbrakk>\n    \\<Longrightarrow> (l' = [] \\<longrightarrow>\n                       (\\<forall>k v.\n                           Map.empty \\<noteq> [k \\<mapsto> v])) \\<and>\n                      (\\<forall>a b x22.\n                          (x22 = [] \\<longrightarrow>\n                           l' = [(a, b)] \\<longrightarrow>\n                           (\\<exists>k v.\n                               [a \\<mapsto> b] = [k \\<mapsto> v])) \\<and>\n                          (\\<forall>aa ba x22a.\n                              x22 = (aa, ba) # x22a \\<longrightarrow>\n                              l' =\n                              (a, b) # (aa, ba) # x22a \\<longrightarrow>\n                              (\\<forall>k v.\n                                  map_of x22a(aa \\<mapsto> ba, a \\<mapsto>\n                                  b) \\<noteq> [k \\<mapsto> v])))", "apply (intro conjI impI allI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>k v.\n       \\<lbrakk>m' = map_of l'; distinct (map fst l'); l' = []\\<rbrakk>\n       \\<Longrightarrow> Map.empty \\<noteq> [k \\<mapsto> v]\n 2. \\<And>a b x22.\n       \\<lbrakk>m' = map_of l'; distinct (map fst l'); x22 = [];\n        l' = [(a, b)]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k v. [a \\<mapsto> b] = [k \\<mapsto> v]\n 3. \\<And>a b x22 aa ba x22a k v.\n       \\<lbrakk>m' = map_of l'; distinct (map fst l');\n        x22 = (aa, ba) # x22a; l' = (a, b) # (aa, ba) # x22a\\<rbrakk>\n       \\<Longrightarrow> map_of x22a(aa \\<mapsto> ba, a \\<mapsto>\n                         b) \\<noteq> [k \\<mapsto> v]", "apply (metis map_upd_nonempty)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b x22.\n       \\<lbrakk>m' = map_of l'; distinct (map fst l'); x22 = [];\n        l' = [(a, b)]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>k v. [a \\<mapsto> b] = [k \\<mapsto> v]\n 2. \\<And>a b x22 aa ba x22a k v.\n       \\<lbrakk>m' = map_of l'; distinct (map fst l');\n        x22 = (aa, ba) # x22a; l' = (a, b) # (aa, ba) # x22a\\<rbrakk>\n       \\<Longrightarrow> map_of x22a(aa \\<mapsto> ba, a \\<mapsto>\n                         b) \\<noteq> [k \\<mapsto> v]", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b x22 aa ba x22a k v.\n       \\<lbrakk>m' = map_of l'; distinct (map fst l');\n        x22 = (aa, ba) # x22a; l' = (a, b) # (aa, ba) # x22a\\<rbrakk>\n       \\<Longrightarrow> map_of x22a(aa \\<mapsto> ba, a \\<mapsto>\n                         b) \\<noteq> [k \\<mapsto> v]", "apply (simp, metis fun_upd_apply option.distinct(1))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma list_map_autoref_isSng[autoref_rules]:\n  \"(list_map_isSng, op_map_isSng) \\<in> \\<langle>Rk,Rv\\<rangle>list_map_rel \\<rightarrow> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_map_isSng, op_map_isSng)\n    \\<in> \\<langle>Rk, Rv\\<rangle>list_map_rel \\<rightarrow> bool_rel", "unfolding list_map_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_map_isSng, op_map_isSng)\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel O\n          br map_of list_map_invar \\<rightarrow>\n          bool_rel", "by (blast dest!: param_list_map_isSng list_map_autoref_isSng_aux)"], ["", "lemma list_map_autoref_size_aux:\n  assumes \"distinct (map fst x)\"\n  shows \"card (dom (map_of x)) = length x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (dom (map_of x)) = length x", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. card (dom (map_of x)) = length x", "have \"card (dom (map_of x)) = card (map_to_set (map_of x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (dom (map_of x)) = card (map_to_set (map_of x))", "by (simp add: card_map_to_set)"], ["proof (state)\nthis:\n  card (dom (map_of x)) = card (map_to_set (map_of x))\n\ngoal (1 subgoal):\n 1. card (dom (map_of x)) = length x", "also"], ["proof (state)\nthis:\n  card (dom (map_of x)) = card (map_to_set (map_of x))\n\ngoal (1 subgoal):\n 1. card (dom (map_of x)) = length x", "from assms"], ["proof (chain)\npicking this:\n  distinct (map fst x)", "have \"... = card (set x)\""], ["proof (prove)\nusing this:\n  distinct (map fst x)\n\ngoal (1 subgoal):\n 1. card (map_to_set (map_of x)) = card (set x)", "by (simp add: map_to_set_map_of)"], ["proof (state)\nthis:\n  card (map_to_set (map_of x)) = card (set x)\n\ngoal (1 subgoal):\n 1. card (dom (map_of x)) = length x", "also"], ["proof (state)\nthis:\n  card (map_to_set (map_of x)) = card (set x)\n\ngoal (1 subgoal):\n 1. card (dom (map_of x)) = length x", "from assms"], ["proof (chain)\npicking this:\n  distinct (map fst x)", "have \"... = length x\""], ["proof (prove)\nusing this:\n  distinct (map fst x)\n\ngoal (1 subgoal):\n 1. card (set x) = length x", "by (force simp: distinct_card dest!: distinct_mapI)"], ["proof (state)\nthis:\n  card (set x) = length x\n\ngoal (1 subgoal):\n 1. card (dom (map_of x)) = length x", "finally"], ["proof (chain)\npicking this:\n  card (dom (map_of x)) = length x", "show ?thesis"], ["proof (prove)\nusing this:\n  card (dom (map_of x)) = length x\n\ngoal (1 subgoal):\n 1. card (dom (map_of x)) = length x", "."], ["proof (state)\nthis:\n  card (dom (map_of x)) = length x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma param_list_map_size[param]:\n  \"(list_map_size, list_map_size) \\<in> \\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel \\<rightarrow> nat_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_map_size, list_map_size)\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel \\<rightarrow>\n          nat_rel", "unfolding list_map_size_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (length, length)\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel \\<rightarrow>\n          nat_rel", "by parametricity"], ["", "lemma list_map_autoref_size[autoref_rules]:\n  shows \"(list_map_size, op_map_size) \\<in>\n             \\<langle>Rk,Rv\\<rangle>list_map_rel \\<rightarrow> nat_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_map_size, op_map_size)\n    \\<in> \\<langle>Rk, Rv\\<rangle>list_map_rel \\<rightarrow> nat_rel", "unfolding list_map_size_def[abs_def] op_map_size_def[abs_def]\n    list_map_rel_def br_def list_map_invar_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (length, \\<lambda>m. card (dom m))\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel O\n          {(c, a).\n           a = map_of c \\<and>\n           (distinct \\<circ>\\<circ> map) fst c} \\<rightarrow>\n          nat_rel", "by (force simp: list_map_autoref_size_aux list_rel_imp_same_length)"], ["", "lemma autoref_list_map_is_iterator[autoref_ga_rules]: \n  shows \"is_map_to_list Rk Rv list_map_rel list_map_to_list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_map_to_list Rk Rv list_map_rel list_map_to_list", "unfolding is_map_to_list_def is_map_to_sorted_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>m m'.\n       (m, m') \\<in> \\<langle>Rk, Rv\\<rangle>list_map_rel \\<longrightarrow>\n       (\\<exists>l'.\n           (list_map_to_list m, l')\n           \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel \\<and>\n           RETURN l'\n           \\<le> it_to_sorted_list (key_rel (\\<lambda>_ _. True))\n                  (map_to_set m'))", "proof (clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m m'.\n       (m, m') \\<in> \\<langle>Rk, Rv\\<rangle>list_map_rel \\<Longrightarrow>\n       \\<exists>l'.\n          (list_map_to_list m, l')\n          \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel \\<and>\n          RETURN l'\n          \\<le> it_to_sorted_list (key_rel (\\<lambda>_ _. True))\n                 (map_to_set m')", "fix l m'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m m'.\n       (m, m') \\<in> \\<langle>Rk, Rv\\<rangle>list_map_rel \\<Longrightarrow>\n       \\<exists>l'.\n          (list_map_to_list m, l')\n          \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel \\<and>\n          RETURN l'\n          \\<le> it_to_sorted_list (key_rel (\\<lambda>_ _. True))\n                 (map_to_set m')", "assume \"(l,m') \\<in> \\<langle>Rk,Rv\\<rangle>list_map_rel\""], ["proof (state)\nthis:\n  (l, m') \\<in> \\<langle>Rk, Rv\\<rangle>list_map_rel\n\ngoal (1 subgoal):\n 1. \\<And>m m'.\n       (m, m') \\<in> \\<langle>Rk, Rv\\<rangle>list_map_rel \\<Longrightarrow>\n       \\<exists>l'.\n          (list_map_to_list m, l')\n          \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel \\<and>\n          RETURN l'\n          \\<le> it_to_sorted_list (key_rel (\\<lambda>_ _. True))\n                 (map_to_set m')", "then"], ["proof (chain)\npicking this:\n  (l, m') \\<in> \\<langle>Rk, Rv\\<rangle>list_map_rel", "obtain l' where *: \"(l,l')\\<in>\\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel\" \"(l',m')\\<in>br map_of list_map_invar\""], ["proof (prove)\nusing this:\n  (l, m') \\<in> \\<langle>Rk, Rv\\<rangle>list_map_rel\n\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>(l, l')\n                 \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel;\n         (l', m') \\<in> br map_of list_map_invar\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding list_map_rel_def"], ["proof (prove)\nusing this:\n  (l, m')\n  \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel O\n        br map_of list_map_invar\n\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>(l, l')\n                 \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel;\n         (l', m') \\<in> br map_of list_map_invar\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (l, l') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n  (l', m') \\<in> br map_of list_map_invar\n\ngoal (1 subgoal):\n 1. \\<And>m m'.\n       (m, m') \\<in> \\<langle>Rk, Rv\\<rangle>list_map_rel \\<Longrightarrow>\n       \\<exists>l'.\n          (list_map_to_list m, l')\n          \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel \\<and>\n          RETURN l'\n          \\<le> it_to_sorted_list (key_rel (\\<lambda>_ _. True))\n                 (map_to_set m')", "then"], ["proof (chain)\npicking this:\n  (l, l') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n  (l', m') \\<in> br map_of list_map_invar", "have \"RETURN l' \\<le> it_to_sorted_list (key_rel (\\<lambda>_ _. True)) (map_to_set m')\""], ["proof (prove)\nusing this:\n  (l, l') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n  (l', m') \\<in> br map_of list_map_invar\n\ngoal (1 subgoal):\n 1. RETURN l'\n    \\<le> it_to_sorted_list (key_rel (\\<lambda>_ _. True)) (map_to_set m')", "unfolding it_to_sorted_list_def"], ["proof (prove)\nusing this:\n  (l, l') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n  (l', m') \\<in> br map_of list_map_invar\n\ngoal (1 subgoal):\n 1. RETURN l'\n    \\<le> SPEC\n           (\\<lambda>l.\n               distinct l \\<and>\n               map_to_set m' = set l \\<and>\n               sorted_wrt (key_rel (\\<lambda>_ _. True)) l)", "apply (intro refine_vcg)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(l, l') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel;\n     (l', m') \\<in> br map_of list_map_invar\\<rbrakk>\n    \\<Longrightarrow> distinct l' \\<and>\n                      map_to_set m' = set l' \\<and>\n                      sorted_wrt (key_rel (\\<lambda>_ _. True)) l'", "unfolding br_def list_map_invar_def key_rel_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(l, l') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel;\n     (l', m')\n     \\<in> {(c, a).\n            a = map_of c \\<and>\n            (distinct \\<circ>\\<circ> map) fst c}\\<rbrakk>\n    \\<Longrightarrow> distinct l' \\<and>\n                      map_to_set m' = set l' \\<and>\n                      sorted_wrt (\\<lambda>a b. True) l'", "apply (auto intro: distinct_mapI simp: map_to_set_map_of)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  RETURN l'\n  \\<le> it_to_sorted_list (key_rel (\\<lambda>_ _. True)) (map_to_set m')\n\ngoal (1 subgoal):\n 1. \\<And>m m'.\n       (m, m') \\<in> \\<langle>Rk, Rv\\<rangle>list_map_rel \\<Longrightarrow>\n       \\<exists>l'.\n          (list_map_to_list m, l')\n          \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel \\<and>\n          RETURN l'\n          \\<le> it_to_sorted_list (key_rel (\\<lambda>_ _. True))\n                 (map_to_set m')", "with *"], ["proof (chain)\npicking this:\n  (l, l') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n  (l', m') \\<in> br map_of list_map_invar\n  RETURN l'\n  \\<le> it_to_sorted_list (key_rel (\\<lambda>_ _. True)) (map_to_set m')", "show\n      \"\\<exists>l'. (list_map_to_list l, l') \\<in> \\<langle>\\<langle>Rk, Rv\\<rangle>prod_rel\\<rangle>list_rel \\<and>\n            RETURN l' \\<le> it_to_sorted_list (key_rel (\\<lambda>_ _. True)) \n                             (map_to_set m')\""], ["proof (prove)\nusing this:\n  (l, l') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n  (l', m') \\<in> br map_of list_map_invar\n  RETURN l'\n  \\<le> it_to_sorted_list (key_rel (\\<lambda>_ _. True)) (map_to_set m')\n\ngoal (1 subgoal):\n 1. \\<exists>l'.\n       (list_map_to_list l, l')\n       \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel \\<and>\n       RETURN l'\n       \\<le> it_to_sorted_list (key_rel (\\<lambda>_ _. True))\n              (map_to_set m')", "unfolding list_map_to_list_def"], ["proof (prove)\nusing this:\n  (l, l') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n  (l', m') \\<in> br map_of list_map_invar\n  RETURN l'\n  \\<le> it_to_sorted_list (key_rel (\\<lambda>_ _. True)) (map_to_set m')\n\ngoal (1 subgoal):\n 1. \\<exists>l'.\n       (id l, l')\n       \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel \\<and>\n       RETURN l'\n       \\<le> it_to_sorted_list (key_rel (\\<lambda>_ _. True))\n              (map_to_set m')", "by force"], ["proof (state)\nthis:\n  \\<exists>l'.\n     (list_map_to_list l, l')\n     \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel \\<and>\n     RETURN l'\n     \\<le> it_to_sorted_list (key_rel (\\<lambda>_ _. True)) (map_to_set m')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pi_list_map[icf_proper_iteratorI]: \n  \"proper_it (list_map_iteratei m) (list_map_iteratei m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it (list_map_iteratei m) (list_map_iteratei m)", "unfolding proper_it_def list_map_iteratei_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>l. foldli m = foldli l \\<and> foldli m = foldli l", "by blast"], ["", "lemma pi'_list_map[icf_proper_iteratorI]: \n  \"proper_it' list_map_iteratei list_map_iteratei\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it' list_map_iteratei list_map_iteratei", "by (rule proper_it'I, rule pi_list_map)"], ["", "primrec list_map_pick_remove where\n  \"list_map_pick_remove [] = undefined\"\n| \"list_map_pick_remove (kv#l) = (kv,l)\""], ["", "context begin"], ["", "interpretation autoref_syn"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma list_map_autoref_pick_remove[autoref_rules]:\n    assumes NE: \"SIDE_PRECOND (m\\<noteq>Map.empty)\"\n    assumes R: \"(l,m)\\<in>\\<langle>Rk,Rv\\<rangle>list_map_rel\"\n    defines \"Rres \\<equiv> \\<langle>(Rk\\<times>\\<^sub>rRv) \\<times>\\<^sub>r \\<langle>Rk,Rv\\<rangle>list_map_rel\\<rangle>nres_rel\"\n    shows \"(\n        RETURN (list_map_pick_remove l),\n        (OP op_map_pick_remove ::: \\<langle>Rk,Rv\\<rangle>list_map_rel \\<rightarrow> Rres)$m\n      ) \\<in> Rres\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN (list_map_pick_remove l),\n     (OP op_map_pick_remove :::\n      \\<langle>Rk, Rv\\<rangle>list_map_rel \\<rightarrow> Rres) $\n     m)\n    \\<in> Rres", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (RETURN (list_map_pick_remove l),\n     (OP op_map_pick_remove :::\n      \\<langle>Rk, Rv\\<rangle>list_map_rel \\<rightarrow> Rres) $\n     m)\n    \\<in> Rres", "from NE R"], ["proof (chain)\npicking this:\n  SIDE_PRECOND (m \\<noteq> Map.empty)\n  (l, m) \\<in> \\<langle>Rk, Rv\\<rangle>list_map_rel", "obtain k v lr where \n      [simp]: \"l=(k,v)#lr\""], ["proof (prove)\nusing this:\n  SIDE_PRECOND (m \\<noteq> Map.empty)\n  (l, m) \\<in> \\<langle>Rk, Rv\\<rangle>list_map_rel\n\ngoal (1 subgoal):\n 1. (\\<And>k v lr.\n        l = (k, v) # lr \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases l) (auto simp: list_map_rel_def br_def)"], ["proof (state)\nthis:\n  l = (k, v) # lr\n\ngoal (1 subgoal):\n 1. (RETURN (list_map_pick_remove l),\n     (OP op_map_pick_remove :::\n      \\<langle>Rk, Rv\\<rangle>list_map_rel \\<rightarrow> Rres) $\n     m)\n    \\<in> Rres", "thm list_map_rel_def"], ["proof (state)\nthis:\n  l = (k, v) # lr\n\ngoal (1 subgoal):\n 1. (RETURN (list_map_pick_remove l),\n     (OP op_map_pick_remove :::\n      \\<langle>Rk, Rv\\<rangle>list_map_rel \\<rightarrow> Rres) $\n     m)\n    \\<in> Rres", "from R"], ["proof (chain)\npicking this:\n  (l, m) \\<in> \\<langle>Rk, Rv\\<rangle>list_map_rel", "obtain l' where \n      LL': \"(l,l')\\<in>\\<langle>Rk\\<times>\\<^sub>rRv\\<rangle>list_rel\" and \n      L'M: \"(l',m)\\<in>br map_of list_map_invar\""], ["proof (prove)\nusing this:\n  (l, m) \\<in> \\<langle>Rk, Rv\\<rangle>list_map_rel\n\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>(l, l')\n                 \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel;\n         (l', m) \\<in> br map_of list_map_invar\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding list_map_rel_def"], ["proof (prove)\nusing this:\n  (l, m)\n  \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel O\n        br map_of list_map_invar\n\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>(l, l')\n                 \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel;\n         (l', m) \\<in> br map_of list_map_invar\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (l, l') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n  (l', m) \\<in> br map_of list_map_invar\n\ngoal (1 subgoal):\n 1. (RETURN (list_map_pick_remove l),\n     (OP op_map_pick_remove :::\n      \\<langle>Rk, Rv\\<rangle>list_map_rel \\<rightarrow> Rres) $\n     m)\n    \\<in> Rres", "from LL'"], ["proof (chain)\npicking this:\n  (l, l') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel", "obtain k' v' lr' where\n      [simp]: \"l' = (k',v')#lr'\" and \n        KVR: \"(k,k')\\<in>Rk\" \"(v,v')\\<in>Rv\" and\n        LRR: \"(lr,lr')\\<in>\\<langle>Rk\\<times>\\<^sub>rRv\\<rangle>list_rel\""], ["proof (prove)\nusing this:\n  (l, l') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. (\\<And>k' v' lr'.\n        \\<lbrakk>l' = (k', v') # lr'; (k, k') \\<in> Rk; (v, v') \\<in> Rv;\n         (lr, lr')\n         \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fastforce elim!: list_relE)"], ["proof (state)\nthis:\n  l' = (k', v') # lr'\n  (k, k') \\<in> Rk\n  (v, v') \\<in> Rv\n  (lr, lr') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. (RETURN (list_map_pick_remove l),\n     (OP op_map_pick_remove :::\n      \\<langle>Rk, Rv\\<rangle>list_map_rel \\<rightarrow> Rres) $\n     m)\n    \\<in> Rres", "from L'M"], ["proof (chain)\npicking this:\n  (l', m) \\<in> br map_of list_map_invar", "have \n      MKV': \"m k' = Some v'\" and \n      LRR': \"(lr',m|`(-{k'}))\\<in>br map_of list_map_invar\""], ["proof (prove)\nusing this:\n  (l', m) \\<in> br map_of list_map_invar\n\ngoal (1 subgoal):\n 1. m k' = Some v' &&& (lr', m |` (- {k'})) \\<in> br map_of list_map_invar", "by (auto \n        simp: restrict_map_def map_of_eq_None_iff br_def list_map_invar_def\n        intro!: ext\n        intro: sym)"], ["proof (state)\nthis:\n  m k' = Some v'\n  (lr', m |` (- {k'})) \\<in> br map_of list_map_invar\n\ngoal (1 subgoal):\n 1. (RETURN (list_map_pick_remove l),\n     (OP op_map_pick_remove :::\n      \\<langle>Rk, Rv\\<rangle>list_map_rel \\<rightarrow> Rres) $\n     m)\n    \\<in> Rres", "from LRR LRR'"], ["proof (chain)\npicking this:\n  (lr, lr') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n  (lr', m |` (- {k'})) \\<in> br map_of list_map_invar", "have LM: \"(lr,m|`(-{k'}))\\<in>\\<langle>Rk,Rv\\<rangle>list_map_rel\""], ["proof (prove)\nusing this:\n  (lr, lr') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n  (lr', m |` (- {k'})) \\<in> br map_of list_map_invar\n\ngoal (1 subgoal):\n 1. (lr, m |` (- {k'})) \\<in> \\<langle>Rk, Rv\\<rangle>list_map_rel", "unfolding list_map_rel_def"], ["proof (prove)\nusing this:\n  (lr, lr') \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel\n  (lr', m |` (- {k'})) \\<in> br map_of list_map_invar\n\ngoal (1 subgoal):\n 1. (lr, m |` (- {k'}))\n    \\<in> \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel O\n          br map_of list_map_invar", "by auto"], ["proof (state)\nthis:\n  (lr, m |` (- {k'})) \\<in> \\<langle>Rk, Rv\\<rangle>list_map_rel\n\ngoal (1 subgoal):\n 1. (RETURN (list_map_pick_remove l),\n     (OP op_map_pick_remove :::\n      \\<langle>Rk, Rv\\<rangle>list_map_rel \\<rightarrow> Rres) $\n     m)\n    \\<in> Rres", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN (list_map_pick_remove l),\n     (OP op_map_pick_remove :::\n      \\<langle>Rk, Rv\\<rangle>list_map_rel \\<rightarrow> Rres) $\n     m)\n    \\<in> Rres", "apply (simp add: Rres_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN ((k, v), lr),\n     SPEC (\\<lambda>((k, v), m'). m k = Some v \\<and> m' = m |` (- {k})))\n    \\<in> \\<langle>(Rk \\<times>\\<^sub>r Rv) \\<times>\\<^sub>r \\<langle>Rk,\n                   Rv\\<rangle>list_map_rel\\<rangle>nres_rel", "apply (refine_rcg SPEC_refine nres_relI refine_vcg)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x'.\n       (((k, v), lr), x')\n       \\<in> (Rk \\<times>\\<^sub>r Rv) \\<times>\\<^sub>r \\<langle>Rk,\n             Rv\\<rangle>list_map_rel \\<and>\n       (case x' of\n        (x, xa) \\<Rightarrow>\n          (case x of\n           (k, v) \\<Rightarrow>\n             \\<lambda>m'. m k = Some v \\<and> m' = m |` (- {k}))\n           xa)", "using LM KVR MKV'"], ["proof (prove)\nusing this:\n  (lr, m |` (- {k'})) \\<in> \\<langle>Rk, Rv\\<rangle>list_map_rel\n  (k, k') \\<in> Rk\n  (v, v') \\<in> Rv\n  m k' = Some v'\n\ngoal (1 subgoal):\n 1. \\<exists>x'.\n       (((k, v), lr), x')\n       \\<in> (Rk \\<times>\\<^sub>r Rv) \\<times>\\<^sub>r \\<langle>Rk,\n             Rv\\<rangle>list_map_rel \\<and>\n       (case x' of\n        (x, xa) \\<Rightarrow>\n          (case x of\n           (k, v) \\<Rightarrow>\n             \\<lambda>m'. m k = Some v \\<and> m' = m |` (- {k}))\n           xa)", "by auto"], ["proof (state)\nthis:\n  (RETURN (list_map_pick_remove l),\n   (OP op_map_pick_remove :::\n    \\<langle>Rk, Rv\\<rangle>list_map_rel \\<rightarrow> Rres) $\n   m)\n  \\<in> Rres\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}