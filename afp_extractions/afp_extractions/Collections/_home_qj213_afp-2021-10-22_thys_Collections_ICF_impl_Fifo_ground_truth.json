{"file_name": "/home/qj213/afp-2021-10-22/thys/Collections/ICF/impl/Fifo.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Collections", "problem_names": ["lemma rev_tl_rev: \"rev (tl (rev l)) = butlast l\"", "lemma fifo_empty_impl: \"list_empty fifo_\\<alpha> fifo_invar fifo_empty\"", "lemma fifo_isEmpty_impl: \"list_isEmpty fifo_\\<alpha> fifo_invar fifo_isEmpty\"", "lemma fifo_size_impl: \"list_size fifo_\\<alpha> fifo_invar fifo_size\"", "lemma fifo_appendr_impl: \"list_appendr fifo_\\<alpha> fifo_invar fifo_appendr\"", "lemma fifo_appendl_impl: \"list_appendl fifo_\\<alpha> fifo_invar fifo_appendl\"", "lemma fifo_removel_impl: \"list_removel fifo_\\<alpha> fifo_invar fifo_removel\"", "lemma fifo_remover_impl: \"list_remover fifo_\\<alpha> fifo_invar fifo_remover\"", "lemma fifo_leftmost_impl: \"list_leftmost fifo_\\<alpha> fifo_invar fifo_leftmost\"", "lemma fifo_rightmost_impl: \"list_rightmost fifo_\\<alpha> fifo_invar fifo_rightmost\"", "lemma fifo_get_impl: \"list_get fifo_\\<alpha> fifo_invar fifo_get\"", "lemma fifo_set_impl: \"list_set fifo_\\<alpha> fifo_invar fifo_set\""], "translations": [["", "lemma rev_tl_rev: \"rev (tl (rev l)) = butlast l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev (tl (rev l)) = butlast l", "by (induct l) auto"], ["", "(*@impl List\n  @type 'a fifo\n  @abbrv fifo\n  Fifo-Queues implemented by two stacks.\n*)"], ["", "text \\<open>\n  A fifo-queue is implemented by a pair of two lists (stacks). \n  New elements are pushed on the first stack, and elements are popped from \n  the second stack. If the second stack is empty, the first stack is reversed\n  and replaces the second stack.\n\n  If list reversal is implemented efficiently (what is the case in Isabelle/HOL, \n  cf @{thm [source] List.rev_conv_fold})\n  the amortized time per buffer operation is constant.\n\n  Moreover, this fifo implementation also supports efficient push and pop operations.\n\\<close>"], ["", "subsection \\<open>Definitions\\<close>"], ["", "type_synonym 'a fifo = \"'a list \\<times> 'a list\""], ["", "text \"Abstraction of the fifo to a list. The next element to be got is at \n      the head of the list, and new elements are appended at the end of the\n      list\""], ["", "definition fifo_\\<alpha> :: \"'a fifo \\<Rightarrow> 'a list\" \n  where \"fifo_\\<alpha> F == snd F @ rev (fst F)\""], ["", "text \"This fifo implementation has no invariants, any pair of lists is a \n  valid fifo\""], ["", "definition [simp, intro!]: \"fifo_invar x = True\"\n\n\n  \\<comment> \\<open>The empty fifo\\<close>"], ["", "definition fifo_empty :: \"unit \\<Rightarrow> 'a fifo\" \n  where \"fifo_empty == \\<lambda>_::unit. ([],[])\"\n\n  \\<comment> \\<open>True, iff the fifo is empty\\<close>"], ["", "definition fifo_isEmpty :: \"'a fifo \\<Rightarrow> bool\" where \"fifo_isEmpty F == F=([],[])\""], ["", "definition fifo_size :: \"'a fifo \\<Rightarrow> nat\" where \n  \"fifo_size F \\<equiv> length (fst F) + length (snd F)\"\n\n  \\<comment> \\<open>Add an element to the fifo\\<close>"], ["", "definition fifo_appendr :: \"'a \\<Rightarrow> 'a fifo \\<Rightarrow> 'a fifo\" \n  where \"fifo_appendr a F == (a#fst F, snd F)\""], ["", "definition fifo_appendl :: \"'a \\<Rightarrow> 'a fifo \\<Rightarrow> 'a fifo\"\n  where \"fifo_appendl x F == case F of (e,d) \\<Rightarrow> (e,x#d)\"\n\n\\<comment> \\<open>Get an element from the fifo\\<close>"], ["", "definition fifo_remover :: \"'a fifo \\<Rightarrow> ('a fifo \\<times> 'a)\" where \n  \"fifo_remover F ==\n    case fst F of\n      (a#l) \\<Rightarrow> ((l,snd F),a) |\n      [] \\<Rightarrow> let rp=rev (snd F) in\n        ((tl rp,[]),hd rp)\""], ["", "definition fifo_removel :: \"'a fifo \\<Rightarrow> ('a \\<times> 'a fifo)\" where \n  \"fifo_removel F ==\n    case snd F of\n      (a#l) \\<Rightarrow> (a, (fst F, l)) |\n      [] \\<Rightarrow> let rp=rev (fst F) in\n        (hd rp, ([], tl rp))\n\""], ["", "definition fifo_leftmost :: \"'a fifo \\<Rightarrow> 'a\" where\n  \"fifo_leftmost F \\<equiv> case F of (_,x#_) \\<Rightarrow> x | (l,[]) \\<Rightarrow> last l\""], ["", "definition fifo_rightmost :: \"'a fifo \\<Rightarrow> 'a\" where\n  \"fifo_rightmost F \\<equiv> case F of (x#_,_) \\<Rightarrow> x | ([],l) \\<Rightarrow> last l\""], ["", "definition \"fifo_iteratei F \\<equiv> foldli (fifo_\\<alpha> F)\""], ["", "definition \"fifo_rev_iteratei F \\<equiv> foldri (fifo_\\<alpha> F)\""], ["", "definition \"fifo_get F i \\<equiv> \n  let\n    l2 = length (snd F)\n  in\n    if i < l2 then \n      snd F!i \n    else\n      (fst F)!(length (fst F) - Suc (i - l2))\n  \""], ["", "definition \"fifo_set F i a \\<equiv> case F of (f1,f2) \\<Rightarrow>\n  let\n    l2 = length f2\n  in\n    if i < l2 then \n      (f1,f2[i:=a])\n    else\n      (f1[length (fst F) - Suc (i - l2) := a],f2)\""], ["", "subsection \"Correctness\""], ["", "lemma fifo_empty_impl: \"list_empty fifo_\\<alpha> fifo_invar fifo_empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_empty fifo_\\<alpha> fifo_invar fifo_empty", "apply (unfold_locales)"], ["proof (prove)\ngoal (2 subgoals):\n 1. fifo_\\<alpha> (fifo_empty ()) = []\n 2. fifo_invar (fifo_empty ())", "by (auto simp add: fifo_\\<alpha>_def fifo_empty_def)"], ["", "lemma fifo_isEmpty_impl: \"list_isEmpty fifo_\\<alpha> fifo_invar fifo_isEmpty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_isEmpty fifo_\\<alpha> fifo_invar fifo_isEmpty", "apply (unfold_locales)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       fifo_invar s \\<Longrightarrow>\n       fifo_isEmpty s = (fifo_\\<alpha> s = [])", "by (case_tac s) (auto simp add: fifo_isEmpty_def fifo_\\<alpha>_def)"], ["", "lemma fifo_size_impl: \"list_size fifo_\\<alpha> fifo_invar fifo_size\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_size fifo_\\<alpha> fifo_invar fifo_size", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       fifo_invar s \\<Longrightarrow> fifo_size s = length (fifo_\\<alpha> s)", "by (auto simp add: fifo_size_def fifo_\\<alpha>_def)"], ["", "lemma fifo_appendr_impl: \"list_appendr fifo_\\<alpha> fifo_invar fifo_appendr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_appendr fifo_\\<alpha> fifo_invar fifo_appendr", "apply (unfold_locales)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s x.\n       fifo_invar s \\<Longrightarrow>\n       fifo_\\<alpha> (fifo_appendr x s) = fifo_\\<alpha> s @ [x]\n 2. \\<And>s x. fifo_invar s \\<Longrightarrow> fifo_invar (fifo_appendr x s)", "by (auto simp add: fifo_appendr_def fifo_\\<alpha>_def)"], ["", "lemma fifo_appendl_impl: \"list_appendl fifo_\\<alpha> fifo_invar fifo_appendl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_appendl fifo_\\<alpha> fifo_invar fifo_appendl", "apply (unfold_locales)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s x.\n       fifo_invar s \\<Longrightarrow>\n       fifo_\\<alpha> (fifo_appendl x s) = x # fifo_\\<alpha> s\n 2. \\<And>s x. fifo_invar s \\<Longrightarrow> fifo_invar (fifo_appendl x s)", "by (auto simp add: fifo_appendl_def fifo_\\<alpha>_def)"], ["", "lemma fifo_removel_impl: \"list_removel fifo_\\<alpha> fifo_invar fifo_removel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_removel fifo_\\<alpha> fifo_invar fifo_removel", "apply (unfold_locales)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>fifo_invar s; fifo_\\<alpha> s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> fst (fifo_removel s) = hd (fifo_\\<alpha> s)\n 2. \\<And>s.\n       \\<lbrakk>fifo_invar s; fifo_\\<alpha> s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> fifo_\\<alpha> (snd (fifo_removel s)) =\n                         tl (fifo_\\<alpha> s)\n 3. \\<And>s.\n       \\<lbrakk>fifo_invar s; fifo_\\<alpha> s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> fifo_invar (snd (fifo_removel s))", "apply (case_tac s)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s a b.\n       \\<lbrakk>fifo_invar s; fifo_\\<alpha> s \\<noteq> [];\n        s = (a, b)\\<rbrakk>\n       \\<Longrightarrow> fst (fifo_removel s) = hd (fifo_\\<alpha> s)\n 2. \\<And>s.\n       \\<lbrakk>fifo_invar s; fifo_\\<alpha> s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> fifo_\\<alpha> (snd (fifo_removel s)) =\n                         tl (fifo_\\<alpha> s)\n 3. \\<And>s.\n       \\<lbrakk>fifo_invar s; fifo_\\<alpha> s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> fifo_invar (snd (fifo_removel s))", "apply (case_tac b)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s a b.\n       \\<lbrakk>fifo_invar s; fifo_\\<alpha> s \\<noteq> []; s = (a, b);\n        b = []\\<rbrakk>\n       \\<Longrightarrow> fst (fifo_removel s) = hd (fifo_\\<alpha> s)\n 2. \\<And>s a b aa list.\n       \\<lbrakk>fifo_invar s; fifo_\\<alpha> s \\<noteq> []; s = (a, b);\n        b = aa # list\\<rbrakk>\n       \\<Longrightarrow> fst (fifo_removel s) = hd (fifo_\\<alpha> s)\n 3. \\<And>s.\n       \\<lbrakk>fifo_invar s; fifo_\\<alpha> s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> fifo_\\<alpha> (snd (fifo_removel s)) =\n                         tl (fifo_\\<alpha> s)\n 4. \\<And>s.\n       \\<lbrakk>fifo_invar s; fifo_\\<alpha> s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> fifo_invar (snd (fifo_removel s))", "apply (auto simp add: fifo_removel_def fifo_\\<alpha>_def Let_def) [2]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>fifo_invar s; fifo_\\<alpha> s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> fifo_\\<alpha> (snd (fifo_removel s)) =\n                         tl (fifo_\\<alpha> s)\n 2. \\<And>s.\n       \\<lbrakk>fifo_invar s; fifo_\\<alpha> s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> fifo_invar (snd (fifo_removel s))", "apply (case_tac s)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s a b.\n       \\<lbrakk>fifo_invar s; fifo_\\<alpha> s \\<noteq> [];\n        s = (a, b)\\<rbrakk>\n       \\<Longrightarrow> fifo_\\<alpha> (snd (fifo_removel s)) =\n                         tl (fifo_\\<alpha> s)\n 2. \\<And>s.\n       \\<lbrakk>fifo_invar s; fifo_\\<alpha> s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> fifo_invar (snd (fifo_removel s))", "apply (case_tac \"b\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s a b.\n       \\<lbrakk>fifo_invar s; fifo_\\<alpha> s \\<noteq> []; s = (a, b);\n        b = []\\<rbrakk>\n       \\<Longrightarrow> fifo_\\<alpha> (snd (fifo_removel s)) =\n                         tl (fifo_\\<alpha> s)\n 2. \\<And>s a b aa list.\n       \\<lbrakk>fifo_invar s; fifo_\\<alpha> s \\<noteq> []; s = (a, b);\n        b = aa # list\\<rbrakk>\n       \\<Longrightarrow> fifo_\\<alpha> (snd (fifo_removel s)) =\n                         tl (fifo_\\<alpha> s)\n 3. \\<And>s.\n       \\<lbrakk>fifo_invar s; fifo_\\<alpha> s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> fifo_invar (snd (fifo_removel s))", "apply (auto simp add: fifo_removel_def fifo_\\<alpha>_def Let_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fifo_remover_impl: \"list_remover fifo_\\<alpha> fifo_invar fifo_remover\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_remover fifo_\\<alpha> fifo_invar fifo_remover", "apply (unfold_locales)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>fifo_invar s; fifo_\\<alpha> s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> fifo_\\<alpha> (fst (fifo_remover s)) =\n                         butlast (fifo_\\<alpha> s)\n 2. \\<And>s.\n       \\<lbrakk>fifo_invar s; fifo_\\<alpha> s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> snd (fifo_remover s) = last (fifo_\\<alpha> s)\n 3. \\<And>s.\n       \\<lbrakk>fifo_invar s; fifo_\\<alpha> s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> fifo_invar (fst (fifo_remover s))", "unfolding fifo_remover_def fifo_\\<alpha>_def Let_def"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>fifo_invar s; snd s @ rev (fst s) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> snd (fst (case fst s of\n                                   [] \\<Rightarrow>\n                                     ((tl (rev (snd s)), []),\nhd (rev (snd s)))\n                                   | a # l \\<Rightarrow> ((l, snd s), a))) @\n                         rev (fst (fst (case fst s of\n  [] \\<Rightarrow> ((tl (rev (snd s)), []), hd (rev (snd s)))\n  | a # l \\<Rightarrow> ((l, snd s), a)))) =\n                         butlast (snd s @ rev (fst s))\n 2. \\<And>s.\n       \\<lbrakk>fifo_invar s; snd s @ rev (fst s) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> snd (case fst s of\n                              [] \\<Rightarrow>\n                                ((tl (rev (snd s)), []), hd (rev (snd s)))\n                              | a # l \\<Rightarrow> ((l, snd s), a)) =\n                         last (snd s @ rev (fst s))\n 3. \\<And>s.\n       \\<lbrakk>fifo_invar s; snd s @ rev (fst s) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> fifo_invar\n                          (fst (case fst s of\n                                [] \\<Rightarrow>\n                                  ((tl (rev (snd s)), []), hd (rev (snd s)))\n                                | a # l \\<Rightarrow> ((l, snd s), a)))", "by (auto split: list.split simp: hd_rev rev_tl_rev butlast_append)"], ["", "lemma fifo_leftmost_impl: \"list_leftmost fifo_\\<alpha> fifo_invar fifo_leftmost\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_leftmost fifo_\\<alpha> fifo_invar fifo_leftmost", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>fifo_invar s; fifo_\\<alpha> s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> fifo_leftmost s = hd (fifo_\\<alpha> s)", "by (auto simp: fifo_leftmost_def fifo_\\<alpha>_def hd_rev split: list.split)"], ["", "lemma fifo_rightmost_impl: \"list_rightmost fifo_\\<alpha> fifo_invar fifo_rightmost\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_rightmost fifo_\\<alpha> fifo_invar fifo_rightmost", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>fifo_invar s; fifo_\\<alpha> s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> fifo_rightmost s = last (fifo_\\<alpha> s)", "by (auto simp: fifo_rightmost_def fifo_\\<alpha>_def hd_rev split: list.split)"], ["", "lemma fifo_get_impl: \"list_get fifo_\\<alpha> fifo_invar fifo_get\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_get fifo_\\<alpha> fifo_invar fifo_get", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s i.\n       \\<lbrakk>fifo_invar s; i < length (fifo_\\<alpha> s)\\<rbrakk>\n       \\<Longrightarrow> fifo_get s i = fifo_\\<alpha> s ! i", "apply (auto simp: fifo_\\<alpha>_def fifo_get_def Let_def nth_append rev_nth)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fifo_set_impl: \"list_set fifo_\\<alpha> fifo_invar fifo_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_set fifo_\\<alpha> fifo_invar fifo_set", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s i x.\n       \\<lbrakk>fifo_invar s; i < length (fifo_\\<alpha> s)\\<rbrakk>\n       \\<Longrightarrow> fifo_\\<alpha> (fifo_set s i x) = (fifo_\\<alpha> s)\n                         [i := x]\n 2. \\<And>s i x.\n       \\<lbrakk>fifo_invar s; i < length (fifo_\\<alpha> s)\\<rbrakk>\n       \\<Longrightarrow> fifo_invar (fifo_set s i x)", "apply (auto simp: fifo_\\<alpha>_def fifo_set_def Let_def list_update_append\n    rev_update)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition [icf_rec_def]: \"fifo_ops \\<equiv> \\<lparr>\n  list_op_\\<alpha> = fifo_\\<alpha>,\n  list_op_invar = fifo_invar,\n  list_op_empty = fifo_empty,\n  list_op_isEmpty = fifo_isEmpty,\n  list_op_size = fifo_size,\n  list_op_appendl = fifo_appendl,\n  list_op_removel = fifo_removel,\n  list_op_leftmost = fifo_leftmost,\n  list_op_appendr = fifo_appendr,\n  list_op_remover = fifo_remover,\n  list_op_rightmost = fifo_rightmost,\n  list_op_get = fifo_get,\n  list_op_set = fifo_set\n  \\<rparr>\""], ["", "setup Locale_Code.open_block"], ["", "interpretation fifo: StdList fifo_ops"], ["proof (prove)\ngoal (1 subgoal):\n 1. StdList fifo_ops", "apply (rule StdList.intro)"], ["proof (prove)\ngoal (11 subgoals):\n 1. list_empty (list_op_\\<alpha> fifo_ops) (list_op_invar fifo_ops)\n     (list_op_empty fifo_ops)\n 2. list_isEmpty (list_op_\\<alpha> fifo_ops) (list_op_invar fifo_ops)\n     (list_op_isEmpty fifo_ops)\n 3. list_size (list_op_\\<alpha> fifo_ops) (list_op_invar fifo_ops)\n     (list_op_size fifo_ops)\n 4. list_appendl (list_op_\\<alpha> fifo_ops) (list_op_invar fifo_ops)\n     (list_op_appendl fifo_ops)\n 5. list_removel (list_op_\\<alpha> fifo_ops) (list_op_invar fifo_ops)\n     (list_op_removel fifo_ops)\n 6. list_leftmost (list_op_\\<alpha> fifo_ops) (list_op_invar fifo_ops)\n     (list_op_leftmost fifo_ops)\n 7. list_appendr (list_op_\\<alpha> fifo_ops) (list_op_invar fifo_ops)\n     (list_op_appendr fifo_ops)\n 8. list_remover (list_op_\\<alpha> fifo_ops) (list_op_invar fifo_ops)\n     (list_op_remover fifo_ops)\n 9. list_rightmost (list_op_\\<alpha> fifo_ops) (list_op_invar fifo_ops)\n     (list_op_rightmost fifo_ops)\n 10. list_get (list_op_\\<alpha> fifo_ops) (list_op_invar fifo_ops)\n      (list_op_get fifo_ops)\nA total of 11 subgoals...", "apply (simp_all add: icf_rec_unf)"], ["proof (prove)\ngoal (11 subgoals):\n 1. list_empty fifo_\\<alpha> fifo_invar fifo_empty\n 2. list_isEmpty fifo_\\<alpha> fifo_invar fifo_isEmpty\n 3. list_size fifo_\\<alpha> fifo_invar fifo_size\n 4. list_appendl fifo_\\<alpha> fifo_invar fifo_appendl\n 5. list_removel fifo_\\<alpha> fifo_invar fifo_removel\n 6. list_leftmost fifo_\\<alpha> fifo_invar fifo_leftmost\n 7. list_appendr fifo_\\<alpha> fifo_invar fifo_appendr\n 8. list_remover fifo_\\<alpha> fifo_invar fifo_remover\n 9. list_rightmost fifo_\\<alpha> fifo_invar fifo_rightmost\n 10. list_get fifo_\\<alpha> fifo_invar fifo_get\nA total of 11 subgoals...", "apply (rule \n    fifo_empty_impl\n    fifo_isEmpty_impl\n    fifo_size_impl\n    fifo_appendl_impl\n    fifo_removel_impl\n    fifo_leftmost_impl\n    fifo_appendr_impl\n    fifo_remover_impl\n    fifo_rightmost_impl\n    fifo_get_impl\n    fifo_set_impl)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "interpretation fifo: StdList_no_invar fifo_ops"], ["proof (prove)\ngoal (1 subgoal):\n 1. StdList_no_invar fifo_ops", "by unfold_locales (simp add: icf_rec_unf)"], ["", "setup Locale_Code.close_block"], ["", "setup \\<open>ICF_Tools.revert_abbrevs \"fifo\"\\<close>"], ["", "definition test_codegen where \"test_codegen \\<equiv> \n  (\n    fifo.empty,\n    fifo.isEmpty,\n    fifo.size,\n    fifo.appendl,\n    fifo.removel,\n    fifo.leftmost,\n    fifo.appendr,\n    fifo.remover,\n    fifo.rightmost,\n    fifo.get,\n    fifo.set,\n    fifo.iteratei,\n    fifo.rev_iteratei\n  )\""], ["", "export_code test_codegen checking SML"], ["", "end"]]}