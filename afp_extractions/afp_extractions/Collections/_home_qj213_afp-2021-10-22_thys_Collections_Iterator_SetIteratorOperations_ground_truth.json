{"file_name": "/home/qj213/afp-2021-10-22/thys/Collections/Iterator/SetIteratorOperations.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Collections", "problem_names": ["lemma set_iterator_emp_foldli_conv :\n  \"set_iterator_emp = foldli []\"", "lemma set_iterator_genord_emp_correct :\n  \"set_iterator_genord set_iterator_emp {} R\"", "lemma set_iterator_emp_correct :\n  \"set_iterator set_iterator_emp {}\"", "lemma (in linorder) set_iterator_linord_emp_correct :\n  \"set_iterator_linord set_iterator_emp {}\"", "lemma (in linorder) set_iterator_rev_linord_emp_correct :\n  \"set_iterator_rev_linord set_iterator_emp {}\"", "lemma (in linorder) map_iterator_linord_emp_correct :\n  \"map_iterator_linord set_iterator_emp Map.empty\"\n  \"set_iterator_map_linord set_iterator_emp {}\"", "lemma (in linorder) map_iterator_rev_linord_emp_correct :\n  \"map_iterator_rev_linord set_iterator_emp Map.empty\"\n  \"set_iterator_map_rev_linord set_iterator_emp {}\"", "lemma set_iterator_sng_foldli_conv :\n  \"set_iterator_sng x = foldli [x]\"", "lemma set_iterator_genord_sng_correct :\n  \"set_iterator_genord (set_iterator_sng (x::'a)) {x} R\"", "lemma set_iterator_sng_correct :\n  \"set_iterator (set_iterator_sng x) {x}\"", "lemma (in linorder) set_iterator_linord_sng_correct :\n  \"set_iterator_linord (set_iterator_sng x) {x}\"", "lemma (in linorder) set_iterator_rev_linord_sng_correct :\n  \"set_iterator_rev_linord (set_iterator_sng x) {x}\"", "lemma (in linorder) map_iterator_linord_sng_correct :\n  \"map_iterator_linord (set_iterator_sng (k,v)) (Map.empty (k \\<mapsto> v))\"", "lemma (in linorder) map_iterator_rev_linord_sng_correct :\n  \"map_iterator_rev_linord (set_iterator_sng (k,v)) (Map.empty (k \\<mapsto> v))\"", "lemma set_iterator_union_foldli_conv :\n  \"set_iterator_union (foldli as) (foldli bs) = foldli (as @ bs)\"", "lemma set_iterator_genord_union_correct :\n  fixes it_a :: \"('a,'\\<sigma>) set_iterator\"\n  fixes it_b :: \"('a,'\\<sigma>) set_iterator\"\n  fixes R S_a S_b\n  assumes it_a: \"set_iterator_genord it_a S_a R\"\n  assumes it_b: \"set_iterator_genord it_b S_b R\"\n  assumes dist_Sab: \"S_a \\<inter> S_b = {}\"\n  assumes R_OK: \"\\<And>a b. \\<lbrakk>a \\<in> S_a; b \\<in> S_b\\<rbrakk> \\<Longrightarrow> R a b\"\n  shows \"set_iterator_genord (set_iterator_union it_a it_b) (S_a \\<union> S_b) R\"", "lemma set_iterator_union_emp [simp] :\n  \"set_iterator_union (set_iterator_emp) it = it\"\n  \"set_iterator_union it (set_iterator_emp) = it\"", "lemma set_iterator_union_correct :\n  assumes it_a: \"set_iterator it_a S_a\"\n  assumes it_b: \"set_iterator it_b S_b\"\n  assumes dist_Sab: \"S_a \\<inter> S_b = {}\"\n  shows \"set_iterator (set_iterator_union it_a it_b) (S_a \\<union> S_b)\"", "lemma (in linorder) set_iterator_linord_union_correct :\n  assumes it_a: \"set_iterator_linord it_a S_a\"\n  assumes it_b: \"set_iterator_linord it_b S_b\"\n  assumes ord_Sab: \"\\<And>a b. \\<lbrakk>a \\<in> S_a; b \\<in> S_b\\<rbrakk> \\<Longrightarrow> a < b\"\n  shows \"set_iterator_linord (set_iterator_union it_a it_b) (S_a \\<union> S_b)\"", "lemma (in linorder) set_iterator_rev_linord_union_correct :\n  assumes it_a: \"set_iterator_rev_linord it_a S_a\"\n  assumes it_b: \"set_iterator_rev_linord it_b S_b\"\n  assumes ord_Sab: \"\\<And>a b. \\<lbrakk>a \\<in> S_a; b \\<in> S_b\\<rbrakk> \\<Longrightarrow> a > b\"\n  shows \"set_iterator_rev_linord (set_iterator_union it_a it_b) (S_a \\<union> S_b)\"", "lemma (in linorder) map_iterator_linord_union_correct :\n  assumes it_a: \"set_iterator_map_linord it_a S_a\"\n  assumes it_b: \"set_iterator_map_linord it_b S_b\"\n  assumes ord_Sab: \"\\<And>kv kv'. \\<lbrakk>kv \\<in> S_a; kv' \\<in> S_b\\<rbrakk> \\<Longrightarrow> fst kv < fst kv'\"\n  shows \"set_iterator_map_linord (set_iterator_union it_a it_b) (S_a \\<union> S_b)\"", "lemma (in linorder) map_iterator_rev_linord_union_correct :\n  assumes it_a: \"set_iterator_map_rev_linord it_a S_a\"\n  assumes it_b: \"set_iterator_map_rev_linord it_b S_b\"\n  assumes ord_Sab: \"\\<And>kv kv'. \\<lbrakk>kv \\<in> S_a; kv' \\<in> S_b\\<rbrakk> \\<Longrightarrow> fst kv > fst kv'\"\n  shows \"set_iterator_map_rev_linord (set_iterator_union it_a it_b) (S_a \\<union> S_b)\"", "lemma set_iterator_product_foldli_conv: \n  \"set_iterator_product (foldli as) (\\<lambda>a. foldli (bs a)) =\n   foldli (concat (map (\\<lambda>a. map (\\<lambda>b. (a, b)) (bs a)) as))\"", "lemma set_iterator_product_it_b_cong: \nassumes it_a_OK: \"set_iterator it_a S_a\"\n    and it_b_b': \"\\<And>a. a \\<in> S_a \\<Longrightarrow> it_b a = it_b' a\"\nshows \"set_iterator_product it_a it_b =\n       set_iterator_product it_a it_b'\"", "lemma set_iterator_genord_product_correct :\n  fixes it_a :: \"('a,'\\<sigma>) set_iterator\"\n  fixes it_b :: \"'a \\<Rightarrow> ('b,'\\<sigma>) set_iterator\" \n  assumes it_a: \"set_iterator_genord it_a S_a R_a\"\n  assumes it_b: \"\\<And>a. a \\<in> S_a \\<Longrightarrow> set_iterator_genord (it_b a) (S_b a) (R_b a)\"\n  shows \"set_iterator_genord (set_iterator_product it_a it_b) (Sigma S_a S_b) \n             (set_iterator_product_order R_a R_b)\"", "lemma set_iterator_product_correct :\n  assumes it_a: \"set_iterator it_a S_a\"\n  assumes it_b: \"\\<And>a. a \\<in> S_a \\<Longrightarrow> set_iterator (it_b a) (S_b a)\"\n  shows \"set_iterator (set_iterator_product it_a it_b) (Sigma S_a S_b)\"", "lemma set_iterator_image_filter_foldli_conv :\n  \"set_iterator_image_filter g (foldli xs) =\n   foldli (List.map_filter g xs)\"", "lemma set_iterator_genord_image_filter_correct :\n  fixes it :: \"('a,'\\<sigma>) set_iterator\"\n  fixes g :: \"'a \\<Rightarrow> 'b option\"\n  assumes it_OK: \"set_iterator_genord it S R\"\n  assumes g_inj_on: \"inj_on g (S \\<inter> dom g)\"\n  assumes R'_prop: \"\\<And>x y x' y'. \\<lbrakk>x \\<in> S; g x = Some x'; y \\<in> S; g y = Some y'; R x y\\<rbrakk> \\<Longrightarrow> R' x' y'\"\n  shows \"set_iterator_genord (set_iterator_image_filter g it) {y. \\<exists>x. x \\<in> S \\<and> g x = Some y} R'\"", "lemma set_iterator_image_filter_correct :\n  fixes it :: \"('a,'\\<sigma>) set_iterator\"\n  fixes g :: \"'a \\<Rightarrow> 'b option\"\n  assumes it_OK: \"set_iterator it S\"\n  assumes g_inj_on: \"inj_on g (S \\<inter> dom g)\"\n  shows \"set_iterator (set_iterator_image_filter g it) {y. \\<exists>x. x \\<in> S \\<and> g x = Some y}\"", "lemma set_iterator_filter_foldli_conv :\n  \"set_iterator_filter P (foldli xs) = foldli (filter P xs)\"", "lemma set_iterator_filter_alt_def [code] : \n  \"set_iterator_filter P it = (\\<lambda>c f. it c (\\<lambda>(x::'a) (\\<sigma>::'b). if P x then f x \\<sigma> else \\<sigma>))\"", "lemma set_iterator_genord_filter_correct :\n  fixes it :: \"('a,'\\<sigma>) set_iterator\"\n  assumes it_OK: \"set_iterator_genord it S R\"\n  shows \"set_iterator_genord (set_iterator_filter P it) {x. x \\<in> S \\<and> P x} R\"", "lemma set_iterator_filter_correct :\n  assumes it_OK: \"set_iterator it S\"\n  shows \"set_iterator (set_iterator_filter P it) {x. x \\<in> S \\<and> P x}\"", "lemma (in linorder) set_iterator_linord_filter_correct :\n  assumes it_OK: \"set_iterator_linord it S\"\n  shows \"set_iterator_linord (set_iterator_filter P it) {x. x \\<in> S \\<and> P x}\"", "lemma (in linorder) set_iterator_rev_linord_filter_correct :\n  assumes it_OK: \"set_iterator_rev_linord it S\"\n  shows \"set_iterator_rev_linord (set_iterator_filter P it) {x. x \\<in> S \\<and> P x}\"", "lemma set_iterator_image_foldli_conv :\n  \"set_iterator_image g (foldli xs) = foldli (map g xs)\"", "lemma set_iterator_image_alt_def [code] : \n  \"set_iterator_image g it = (\\<lambda>c f. it c (\\<lambda>x. f (g x)))\"", "lemma set_iterator_genord_image_correct :\n  fixes it :: \"('a,'\\<sigma>) set_iterator\"\n  assumes it_OK: \"set_iterator_genord it S R\"\n  assumes g_inj: \"inj_on g S\"\n  assumes R'_prop: \"\\<And>x y. \\<lbrakk>x \\<in> S; y \\<in> S; R x y\\<rbrakk> \\<Longrightarrow> R' (g x) (g y)\"\n  shows \"set_iterator_genord (set_iterator_image g it) (g ` S) R'\"", "lemma set_iterator_image_correct :\n  assumes it_OK: \"set_iterator it S\"\n  assumes g_inj: \"inj_on g S\"\n  assumes S'_OK: \"S' = g ` S\"\n  shows \"set_iterator (set_iterator_image g it) S'\"", "lemma set_iterator_genord_foldli_correct :\n\"distinct xs \\<Longrightarrow> sorted_wrt R xs \\<Longrightarrow> set_iterator_genord (foldli xs) (set xs) R\"", "lemma set_iterator_foldli_correct :\n\"distinct xs \\<Longrightarrow> set_iterator (foldli xs) (set xs)\"", "lemma (in linorder) set_iterator_linord_foldli_correct :\nassumes dist_xs: \"distinct xs\"\nassumes sorted_xs: \"sorted xs\"\nshows \"set_iterator_linord (foldli xs) (set xs)\"", "lemma (in linorder) set_iterator_rev_linord_foldli_correct :\nassumes dist_xs: \"distinct xs\"\nassumes sorted_xs: \"sorted (rev xs)\"\nshows \"set_iterator_rev_linord (foldli xs) (set xs)\"", "lemma map_iterator_genord_foldli_correct :\n\"distinct (map fst xs) \\<Longrightarrow> sorted_wrt R xs \\<Longrightarrow> map_iterator_genord (foldli xs) (map_of xs) R\"", "lemma map_iterator_foldli_correct :\n\"distinct (map fst xs) \\<Longrightarrow> map_iterator (foldli xs) (map_of xs)\"", "lemma (in linorder) map_iterator_linord_foldli_correct :\nassumes dist_xs: \"distinct (map fst xs)\"\nassumes sorted_xs: \"sorted (map fst xs)\"\nshows \"map_iterator_linord (foldli xs) (map_of xs)\"", "lemma (in linorder) map_iterator_rev_linord_foldli_correct :\nassumes dist_xs: \"distinct (map fst xs)\"\nassumes sorted_xs: \"sorted (rev (map fst xs))\"\nshows \"map_iterator_rev_linord (foldli xs) (map_of xs)\"", "lemma set_iterator_genord_foldri_correct :\n\"distinct xs \\<Longrightarrow> sorted_wrt R (rev xs) \\<Longrightarrow> set_iterator_genord (foldri xs) (set xs) R\"", "lemma set_iterator_foldri_correct :\n\"distinct xs \\<Longrightarrow> set_iterator (foldri xs) (set xs)\"", "lemma (in linorder) set_iterator_linord_foldri_correct :\nassumes dist_xs: \"distinct xs\"\nassumes sorted_xs: \"sorted (rev xs)\"\nshows \"set_iterator_linord (foldri xs) (set xs)\"", "lemma (in linorder) set_iterator_rev_linord_foldri_correct :\nassumes dist_xs: \"distinct xs\"\nassumes sorted_xs: \"sorted xs\"\nshows \"set_iterator_rev_linord (foldri xs) (set xs)\"", "lemma map_iterator_genord_foldri_correct :\n\"distinct (map fst xs) \\<Longrightarrow> sorted_wrt R (rev xs) \\<Longrightarrow> map_iterator_genord (foldri xs) (map_of xs) R\"", "lemma map_iterator_foldri_correct :\n\"distinct (map fst xs) \\<Longrightarrow> map_iterator (foldri xs) (map_of xs)\"", "lemma (in linorder) map_iterator_linord_foldri_correct :\nassumes dist_xs: \"distinct (map fst xs)\"\nassumes sorted_xs: \"sorted (rev (map fst xs))\"\nshows \"map_iterator_linord (foldri xs) (map_of xs)\"", "lemma (in linorder) map_iterator_rev_linord_foldri_correct :\nassumes dist_xs: \"distinct (map fst xs)\"\nassumes sorted_xs: \"sorted (map fst xs)\"\nshows \"map_iterator_rev_linord (foldri xs) (map_of xs)\"", "lemma map_iterator_dom_foldli_conv :\n  \"map_iterator_dom (foldli kvs) = foldli (map fst kvs)\"", "lemma map_iterator_genord_dom_correct :\n  assumes it_OK: \"map_iterator_genord it m R\"\n  assumes R'_prop: \"\\<And>k v k' v'. \\<lbrakk>m k = Some v; m k' = Some v'; R (k, v) (k', v')\\<rbrakk> \\<Longrightarrow> R' k k'\"\n  shows \"set_iterator_genord (map_iterator_dom it) (dom m) R'\"", "lemma map_iterator_dom_correct :\n  assumes it_OK: \"map_iterator it m\"\n  shows \"set_iterator (map_iterator_dom it) (dom m)\"", "lemma (in linorder) map_iterator_linord_dom_correct :\n  assumes it_OK: \"map_iterator_linord it m\"\n  shows \"set_iterator_linord (map_iterator_dom it) (dom m)\"", "lemma (in linorder) map_iterator_rev_linord_dom_correct :\n  assumes it_OK: \"map_iterator_rev_linord it m\"\n  shows \"set_iterator_rev_linord (map_iterator_dom it) (dom m)\"", "lemma map_iterator_dom_filter_alt_def [code] :\n  \"map_iterator_dom_filter P it = \n   (\\<lambda>c f. it c (\\<lambda>kv \\<sigma>. if P kv then f (fst kv) \\<sigma> else \\<sigma>))\"", "lemma map_iterator_genord_dom_filter_correct :\n  fixes it :: \"('a \\<times> 'b, '\\<sigma>) set_iterator\"\n  assumes it_OK: \"set_iterator_genord it (map_to_set m) R\"\n  assumes R'_prop: \"\\<And>k1 v1 k2 v2.\n      \\<lbrakk>m k1 = Some v1; P (k1, v1);\n       m k2 = Some v2; P (k2, v2); R (k1, v1) (k2, v2)\\<rbrakk> \\<Longrightarrow> R' k1 k2\"\n  shows \"set_iterator_genord (map_iterator_dom_filter P it) {k . \\<exists>v. m k = Some v \\<and> P (k, v)} R'\"", "lemma map_iterator_dom_filter_correct :\n  assumes it_OK: \"map_iterator it m\"\n  shows \"set_iterator (map_iterator_dom_filter P it) {k. \\<exists>v. m k = Some v \\<and> P (k, v)}\"", "lemma (in linorder) map_iterator_linord_dom_filter_correct :\n  assumes it_OK: \"map_iterator_linord it m\"\n  shows \"set_iterator_linord (map_iterator_dom_filter P it) {k. \\<exists>v. m k = Some v \\<and> P (k, v)}\"", "lemma (in linorder) set_iterator_rev_linord_map_filter_correct :\n  assumes it_OK: \"map_iterator_rev_linord it m\"\n  shows \"set_iterator_rev_linord (map_iterator_dom_filter P it) \n  {k. \\<exists>v. m k = Some v \\<and> P (k, v)}\"", "lemma map_iterator_product_foldli_conv :\n\"map_iterator_product (foldli as) (\\<lambda>a. foldli (bs a)) = \n foldli (concat (map (\\<lambda>(k, v). map (Pair k) (bs v)) as))\"", "lemma map_iterator_product_alt_def [code] :\n  \"map_iterator_product it_a it_b = \n   (\\<lambda>c f. it_a c (\\<lambda>a. it_b (snd a) c (\\<lambda>b. f (fst a, b))))\"", "lemma map_iterator_genord_product_correct :\n  fixes it_a :: \"(('k \\<times> 'v),'\\<sigma>) set_iterator\"\n  fixes it_b :: \"'v \\<Rightarrow> ('e,'\\<sigma>) set_iterator\" \n  fixes S_a S_b R_a R_b m\n  assumes it_a: \"map_iterator_genord it_a m R_a\"\n  assumes it_b: \"\\<And>k v. m k = Some v \\<Longrightarrow> set_iterator_genord (it_b v) (S_b v) (R_b v)\"\n  assumes R'_prop: \"\\<And>k v u k' v' u'.\n       m k = Some v \\<Longrightarrow>\n       u \\<in> S_b v \\<Longrightarrow>\n       m k' = Some v' \\<Longrightarrow>\n       u' \\<in> S_b v' \\<Longrightarrow>\n       if k = k' then R_b v u u'\n       else R_a (k, v) (k', v') \\<Longrightarrow>\n       R_ab (k, u) (k', u')\"\n  shows \"set_iterator_genord (map_iterator_product it_a it_b) \n     {(k, e) . (\\<exists>v. m k = Some v \\<and> e \\<in> S_b v)} R_ab\"", "lemma map_iterator_product_correct :\n  assumes it_a: \"map_iterator it_a m\"\n  assumes it_b: \"\\<And>k v. m k = Some v \\<Longrightarrow> set_iterator (it_b v) (S_b v)\"\n  shows \"set_iterator (map_iterator_product it_a it_b) \n         {(k, e) . (\\<exists>v. m k = Some v \\<and> e \\<in> S_b v)}\"", "lemma map_iterator_key_filter_foldli_conv :\n  \"map_iterator_key_filter P (foldli kvs) =  foldli (filter (\\<lambda>(k, v). P k) kvs)\"", "lemma map_iterator_key_filter_alt_def [code] :\n  \"map_iterator_key_filter P it = (\\<lambda>c f. it c (\\<lambda>x \\<sigma>. if P (fst x) then f x \\<sigma> else \\<sigma>))\"", "lemma map_iterator_genord_key_filter_correct :\n  fixes it :: \"('a \\<times> 'b, '\\<sigma>) set_iterator\"\n  assumes it_OK: \"map_iterator_genord it m R\"\n  shows \"map_iterator_genord (map_iterator_key_filter P it) (m |` {k . P k}) R\"", "lemma map_iterator_key_filter_correct :\n  assumes it_OK: \"map_iterator it m\"\n  shows \"set_iterator (map_iterator_key_filter P it) (map_to_set (m |` {k . P k}))\""], "translations": [["", "lemma set_iterator_emp_foldli_conv :\n  \"set_iterator_emp = foldli []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_emp = foldli []", "by (simp add: fun_eq_iff set_iterator_emp_def)"], ["", "lemma set_iterator_genord_emp_correct :\n  \"set_iterator_genord set_iterator_emp {} R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_genord set_iterator_emp {} R", "apply (rule set_iterator_genord.intro)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>l0.\n       distinct l0 \\<and>\n       {} = set l0 \\<and>\n       sorted_wrt R l0 \\<and> set_iterator_emp = foldli l0", "apply (rule exI[where x=\"[]\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct [] \\<and>\n    {} = set [] \\<and> sorted_wrt R [] \\<and> set_iterator_emp = foldli []", "apply (simp add: set_iterator_emp_foldli_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma set_iterator_emp_correct :\n  \"set_iterator set_iterator_emp {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator set_iterator_emp {}", "using set_iterator_intro [OF set_iterator_genord_emp_correct]"], ["proof (prove)\nusing this:\n  set_iterator set_iterator_emp {}\n\ngoal (1 subgoal):\n 1. set_iterator set_iterator_emp {}", "."], ["", "lemma (in linorder) set_iterator_linord_emp_correct :\n  \"set_iterator_linord set_iterator_emp {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_linord set_iterator_emp {}", "unfolding set_iterator_linord_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_genord set_iterator_emp {} (\\<le>)", "by (fact set_iterator_genord_emp_correct)"], ["", "lemma (in linorder) set_iterator_rev_linord_emp_correct :\n  \"set_iterator_rev_linord set_iterator_emp {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_rev_linord set_iterator_emp {}", "unfolding set_iterator_rev_linord_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_genord set_iterator_emp {} (\\<lambda>x y. y \\<le> x)", "by (fact set_iterator_genord_emp_correct)"], ["", "lemma (in linorder) map_iterator_linord_emp_correct :\n  \"map_iterator_linord set_iterator_emp Map.empty\"\n  \"set_iterator_map_linord set_iterator_emp {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_iterator_linord set_iterator_emp Map.empty &&&\n    set_iterator_map_linord set_iterator_emp {}", "unfolding set_iterator_map_linord_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_iterator_genord set_iterator_emp Map.empty\n     (\\<lambda>(k, uu_) (k', uu_). k \\<le> k') &&&\n    set_iterator_genord set_iterator_emp {}\n     (\\<lambda>(k, uu_) (k', uu_). k \\<le> k')", "by (simp_all add: set_iterator_genord_emp_correct map_to_set_def)"], ["", "lemma (in linorder) map_iterator_rev_linord_emp_correct :\n  \"map_iterator_rev_linord set_iterator_emp Map.empty\"\n  \"set_iterator_map_rev_linord set_iterator_emp {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_iterator_rev_linord set_iterator_emp Map.empty &&&\n    set_iterator_map_rev_linord set_iterator_emp {}", "unfolding set_iterator_map_rev_linord_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_iterator_genord set_iterator_emp Map.empty\n     (\\<lambda>(k, uu_) (k', uu_). k' \\<le> k) &&&\n    set_iterator_genord set_iterator_emp {}\n     (\\<lambda>(k, uu_) (k', uu_). k' \\<le> k)", "by (simp_all add: set_iterator_genord_emp_correct map_to_set_def)"], ["", "subsection\\<open>Singleton Sets\\<close>"], ["", "definition set_iterator_sng :: \"'a \\<Rightarrow> ('a,'\\<sigma>) set_iterator\" where\n  \"set_iterator_sng x c f \\<sigma>0 = (if c \\<sigma>0 then f x \\<sigma>0 else \\<sigma>0)\""], ["", "lemma set_iterator_sng_foldli_conv :\n  \"set_iterator_sng x = foldli [x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_sng x = foldli [x]", "by (simp add: fun_eq_iff set_iterator_sng_def)"], ["", "lemma set_iterator_genord_sng_correct :\n  \"set_iterator_genord (set_iterator_sng (x::'a)) {x} R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_genord (set_iterator_sng x) {x} R", "apply (rule set_iterator_genord.intro)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>l0.\n       distinct l0 \\<and>\n       {x} = set l0 \\<and>\n       sorted_wrt R l0 \\<and> set_iterator_sng x = foldli l0", "apply (rule exI[where x=\"[x]\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct [x] \\<and>\n    {x} = set [x] \\<and>\n    sorted_wrt R [x] \\<and> set_iterator_sng x = foldli [x]", "apply (simp add: set_iterator_sng_foldli_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma set_iterator_sng_correct :\n  \"set_iterator (set_iterator_sng x) {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator (set_iterator_sng x) {x}", "unfolding set_iterator_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_genord (set_iterator_sng x) {x} (\\<lambda>_ _. True)", "by (rule set_iterator_genord_sng_correct)"], ["", "lemma (in linorder) set_iterator_linord_sng_correct :\n  \"set_iterator_linord (set_iterator_sng x) {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_linord (set_iterator_sng x) {x}", "unfolding set_iterator_linord_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_genord (set_iterator_sng x) {x} (\\<le>)", "by (simp add: set_iterator_genord_sng_correct)"], ["", "lemma (in linorder) set_iterator_rev_linord_sng_correct :\n  \"set_iterator_rev_linord (set_iterator_sng x) {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_rev_linord (set_iterator_sng x) {x}", "unfolding set_iterator_rev_linord_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_genord (set_iterator_sng x) {x} (\\<lambda>x y. y \\<le> x)", "by (simp add: set_iterator_genord_sng_correct)"], ["", "lemma (in linorder) map_iterator_linord_sng_correct :\n  \"map_iterator_linord (set_iterator_sng (k,v)) (Map.empty (k \\<mapsto> v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_iterator_linord (set_iterator_sng (k, v)) [k \\<mapsto> v]", "unfolding set_iterator_map_linord_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_iterator_genord (set_iterator_sng (k, v)) [k \\<mapsto> v]\n     (\\<lambda>(k, uu_) (k', uu_). k \\<le> k')", "by (simp add: set_iterator_genord_sng_correct)"], ["", "lemma (in linorder) map_iterator_rev_linord_sng_correct :\n  \"map_iterator_rev_linord (set_iterator_sng (k,v)) (Map.empty (k \\<mapsto> v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_iterator_rev_linord (set_iterator_sng (k, v)) [k \\<mapsto> v]", "unfolding set_iterator_map_rev_linord_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_iterator_genord (set_iterator_sng (k, v)) [k \\<mapsto> v]\n     (\\<lambda>(k, uu_) (k', uu_). k' \\<le> k)", "by (simp add: set_iterator_genord_sng_correct)"], ["", "subsection \\<open>Union\\<close>"], ["", "text \\<open>Iterators over disjoint sets can be combined by first iterating over one and then the\nother set. The result is an iterator over the union of the original sets.\\<close>"], ["", "definition set_iterator_union ::\n    \"('a,'\\<sigma>) set_iterator \\<Rightarrow> ('a, '\\<sigma>) set_iterator \\<Rightarrow> ('a,'\\<sigma>) set_iterator\" where\n  \"set_iterator_union it_a it_b \\<equiv> \\<lambda>c f \\<sigma>0. (it_b c f (it_a c f \\<sigma>0))\""], ["", "lemma set_iterator_union_foldli_conv :\n  \"set_iterator_union (foldli as) (foldli bs) = foldli (as @ bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_union (foldli as) (foldli bs) = foldli (as @ bs)", "by (simp add: fun_eq_iff set_iterator_union_def foldli_append)"], ["", "lemma set_iterator_genord_union_correct :\n  fixes it_a :: \"('a,'\\<sigma>) set_iterator\"\n  fixes it_b :: \"('a,'\\<sigma>) set_iterator\"\n  fixes R S_a S_b\n  assumes it_a: \"set_iterator_genord it_a S_a R\"\n  assumes it_b: \"set_iterator_genord it_b S_b R\"\n  assumes dist_Sab: \"S_a \\<inter> S_b = {}\"\n  assumes R_OK: \"\\<And>a b. \\<lbrakk>a \\<in> S_a; b \\<in> S_b\\<rbrakk> \\<Longrightarrow> R a b\"\n  shows \"set_iterator_genord (set_iterator_union it_a it_b) (S_a \\<union> S_b) R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_genord (set_iterator_union it_a it_b) (S_a \\<union> S_b) R", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set_iterator_genord (set_iterator_union it_a it_b) (S_a \\<union> S_b) R", "from it_a"], ["proof (chain)\npicking this:\n  set_iterator_genord it_a S_a R", "obtain as where \n    dist_as: \"distinct as\" and S_a_eq: \"S_a = set as\" and \n    sorted_as: \"sorted_wrt R as\" and it_a_eq: \"it_a = foldli as\""], ["proof (prove)\nusing this:\n  set_iterator_genord it_a S_a R\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        \\<lbrakk>distinct as; S_a = set as; sorted_wrt R as;\n         it_a = foldli as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding set_iterator_genord_foldli_conv"], ["proof (prove)\nusing this:\n  \\<exists>l0.\n     distinct l0 \\<and>\n     S_a = set l0 \\<and> sorted_wrt R l0 \\<and> it_a = foldli l0\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        \\<lbrakk>distinct as; S_a = set as; sorted_wrt R as;\n         it_a = foldli as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  distinct as\n  S_a = set as\n  sorted_wrt R as\n  it_a = foldli as\n\ngoal (1 subgoal):\n 1. set_iterator_genord (set_iterator_union it_a it_b) (S_a \\<union> S_b) R", "from it_b"], ["proof (chain)\npicking this:\n  set_iterator_genord it_b S_b R", "obtain bs where \n    dist_bs: \"distinct bs\" and S_b_eq: \"S_b = set bs\" and \n    sorted_bs: \"sorted_wrt R bs\" and it_b_eq: \"it_b = foldli bs\""], ["proof (prove)\nusing this:\n  set_iterator_genord it_b S_b R\n\ngoal (1 subgoal):\n 1. (\\<And>bs.\n        \\<lbrakk>distinct bs; S_b = set bs; sorted_wrt R bs;\n         it_b = foldli bs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding set_iterator_genord_foldli_conv"], ["proof (prove)\nusing this:\n  \\<exists>l0.\n     distinct l0 \\<and>\n     S_b = set l0 \\<and> sorted_wrt R l0 \\<and> it_b = foldli l0\n\ngoal (1 subgoal):\n 1. (\\<And>bs.\n        \\<lbrakk>distinct bs; S_b = set bs; sorted_wrt R bs;\n         it_b = foldli bs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  distinct bs\n  S_b = set bs\n  sorted_wrt R bs\n  it_b = foldli bs\n\ngoal (1 subgoal):\n 1. set_iterator_genord (set_iterator_union it_a it_b) (S_a \\<union> S_b) R", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_genord (set_iterator_union it_a it_b) (S_a \\<union> S_b) R", "proof (rule set_iterator_genord_I [of \"as @ bs\"])"], ["proof (state)\ngoal (4 subgoals):\n 1. distinct (as @ bs)\n 2. S_a \\<union> S_b = set (as @ bs)\n 3. sorted_wrt R (as @ bs)\n 4. set_iterator_union it_a it_b = foldli (as @ bs)", "from dist_Sab S_a_eq S_b_eq dist_as dist_bs"], ["proof (chain)\npicking this:\n  S_a \\<inter> S_b = {}\n  S_a = set as\n  S_b = set bs\n  distinct as\n  distinct bs", "show \"distinct (as @ bs)\""], ["proof (prove)\nusing this:\n  S_a \\<inter> S_b = {}\n  S_a = set as\n  S_b = set bs\n  distinct as\n  distinct bs\n\ngoal (1 subgoal):\n 1. distinct (as @ bs)", "by simp"], ["proof (state)\nthis:\n  distinct (as @ bs)\n\ngoal (3 subgoals):\n 1. S_a \\<union> S_b = set (as @ bs)\n 2. sorted_wrt R (as @ bs)\n 3. set_iterator_union it_a it_b = foldli (as @ bs)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. S_a \\<union> S_b = set (as @ bs)\n 2. sorted_wrt R (as @ bs)\n 3. set_iterator_union it_a it_b = foldli (as @ bs)", "from S_a_eq S_b_eq"], ["proof (chain)\npicking this:\n  S_a = set as\n  S_b = set bs", "show \"S_a \\<union> S_b = set (as @ bs)\""], ["proof (prove)\nusing this:\n  S_a = set as\n  S_b = set bs\n\ngoal (1 subgoal):\n 1. S_a \\<union> S_b = set (as @ bs)", "by simp"], ["proof (state)\nthis:\n  S_a \\<union> S_b = set (as @ bs)\n\ngoal (2 subgoals):\n 1. sorted_wrt R (as @ bs)\n 2. set_iterator_union it_a it_b = foldli (as @ bs)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. sorted_wrt R (as @ bs)\n 2. set_iterator_union it_a it_b = foldli (as @ bs)", "from sorted_as sorted_bs R_OK S_a_eq S_b_eq"], ["proof (chain)\npicking this:\n  sorted_wrt R as\n  sorted_wrt R bs\n  \\<lbrakk>?a \\<in> S_a; ?b \\<in> S_b\\<rbrakk> \\<Longrightarrow> R ?a ?b\n  S_a = set as\n  S_b = set bs", "show \"sorted_wrt R (as @ bs)\""], ["proof (prove)\nusing this:\n  sorted_wrt R as\n  sorted_wrt R bs\n  \\<lbrakk>?a \\<in> S_a; ?b \\<in> S_b\\<rbrakk> \\<Longrightarrow> R ?a ?b\n  S_a = set as\n  S_b = set bs\n\ngoal (1 subgoal):\n 1. sorted_wrt R (as @ bs)", "by (simp add: sorted_wrt_append Ball_def)"], ["proof (state)\nthis:\n  sorted_wrt R (as @ bs)\n\ngoal (1 subgoal):\n 1. set_iterator_union it_a it_b = foldli (as @ bs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. set_iterator_union it_a it_b = foldli (as @ bs)", "show \"set_iterator_union it_a it_b = (foldli (as @ bs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_union it_a it_b = foldli (as @ bs)", "unfolding it_a_eq it_b_eq set_iterator_union_foldli_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli (as @ bs) = foldli (as @ bs)", "by simp"], ["proof (state)\nthis:\n  set_iterator_union it_a it_b = foldli (as @ bs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set_iterator_genord (set_iterator_union it_a it_b) (S_a \\<union> S_b) R\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_iterator_union_emp [simp] :\n  \"set_iterator_union (set_iterator_emp) it = it\"\n  \"set_iterator_union it (set_iterator_emp) = it\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_union set_iterator_emp it = it &&&\n    set_iterator_union it set_iterator_emp = it", "unfolding set_iterator_emp_def set_iterator_union_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. it = it &&& it = it", "by simp_all"], ["", "lemma set_iterator_union_correct :\n  assumes it_a: \"set_iterator it_a S_a\"\n  assumes it_b: \"set_iterator it_b S_b\"\n  assumes dist_Sab: \"S_a \\<inter> S_b = {}\"\n  shows \"set_iterator (set_iterator_union it_a it_b) (S_a \\<union> S_b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator (set_iterator_union it_a it_b) (S_a \\<union> S_b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set_iterator (set_iterator_union it_a it_b) (S_a \\<union> S_b)", "note res' = set_iterator_genord_union_correct [OF it_a[unfolded set_iterator_def] \n                                                    it_b[unfolded set_iterator_def] dist_Sab]"], ["proof (state)\nthis:\n  (\\<And>a b.\n      \\<lbrakk>a \\<in> S_a; b \\<in> S_b\\<rbrakk>\n      \\<Longrightarrow> True) \\<Longrightarrow>\n  set_iterator_genord (set_iterator_union it_a it_b) (S_a \\<union> S_b)\n   (\\<lambda>_ _. True)\n\ngoal (1 subgoal):\n 1. set_iterator (set_iterator_union it_a it_b) (S_a \\<union> S_b)", "from set_iterator_intro [OF res']"], ["proof (chain)\npicking this:\n  (\\<And>a b.\n      \\<lbrakk>a \\<in> S_a; b \\<in> S_b\\<rbrakk>\n      \\<Longrightarrow> True) \\<Longrightarrow>\n  set_iterator (set_iterator_union it_a it_b) (S_a \\<union> S_b)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<And>a b.\n      \\<lbrakk>a \\<in> S_a; b \\<in> S_b\\<rbrakk>\n      \\<Longrightarrow> True) \\<Longrightarrow>\n  set_iterator (set_iterator_union it_a it_b) (S_a \\<union> S_b)\n\ngoal (1 subgoal):\n 1. set_iterator (set_iterator_union it_a it_b) (S_a \\<union> S_b)", "by simp"], ["proof (state)\nthis:\n  set_iterator (set_iterator_union it_a it_b) (S_a \\<union> S_b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in linorder) set_iterator_linord_union_correct :\n  assumes it_a: \"set_iterator_linord it_a S_a\"\n  assumes it_b: \"set_iterator_linord it_b S_b\"\n  assumes ord_Sab: \"\\<And>a b. \\<lbrakk>a \\<in> S_a; b \\<in> S_b\\<rbrakk> \\<Longrightarrow> a < b\"\n  shows \"set_iterator_linord (set_iterator_union it_a it_b) (S_a \\<union> S_b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_linord (set_iterator_union it_a it_b) (S_a \\<union> S_b)", "unfolding set_iterator_linord_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_genord (set_iterator_union it_a it_b) (S_a \\<union> S_b)\n     (\\<le>)", "apply (rule_tac set_iterator_genord_union_correct[\n   OF it_a[unfolded set_iterator_linord_def] it_b[unfolded set_iterator_linord_def]])"], ["proof (prove)\ngoal (2 subgoals):\n 1. S_a \\<inter> S_b = {}\n 2. \\<And>a b.\n       \\<lbrakk>a \\<in> S_a; b \\<in> S_b\\<rbrakk>\n       \\<Longrightarrow> a \\<le> b", "apply (insert ord_Sab)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<And>a b.\n        \\<lbrakk>a \\<in> S_a; b \\<in> S_b\\<rbrakk>\n        \\<Longrightarrow> a < b) \\<Longrightarrow>\n    S_a \\<inter> S_b = {}\n 2. \\<And>a b.\n       \\<lbrakk>a \\<in> S_a; b \\<in> S_b;\n        \\<And>a b.\n           \\<lbrakk>a \\<in> S_a; b \\<in> S_b\\<rbrakk>\n           \\<Longrightarrow> a < b\\<rbrakk>\n       \\<Longrightarrow> a \\<le> b", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> S_a; b \\<in> S_b;\n        \\<And>a b.\n           \\<lbrakk>a \\<in> S_a; b \\<in> S_b\\<rbrakk>\n           \\<Longrightarrow> a < b\\<rbrakk>\n       \\<Longrightarrow> a \\<le> b", "apply (metis less_le_not_le ord_Sab)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in linorder) set_iterator_rev_linord_union_correct :\n  assumes it_a: \"set_iterator_rev_linord it_a S_a\"\n  assumes it_b: \"set_iterator_rev_linord it_b S_b\"\n  assumes ord_Sab: \"\\<And>a b. \\<lbrakk>a \\<in> S_a; b \\<in> S_b\\<rbrakk> \\<Longrightarrow> a > b\"\n  shows \"set_iterator_rev_linord (set_iterator_union it_a it_b) (S_a \\<union> S_b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_rev_linord (set_iterator_union it_a it_b)\n     (S_a \\<union> S_b)", "unfolding set_iterator_rev_linord_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_genord (set_iterator_union it_a it_b) (S_a \\<union> S_b)\n     (\\<lambda>x y. y \\<le> x)", "apply (rule_tac set_iterator_genord_union_correct[\n   OF it_a[unfolded set_iterator_rev_linord_def] it_b[unfolded set_iterator_rev_linord_def]])"], ["proof (prove)\ngoal (2 subgoals):\n 1. S_a \\<inter> S_b = {}\n 2. \\<And>a b.\n       \\<lbrakk>a \\<in> S_a; b \\<in> S_b\\<rbrakk>\n       \\<Longrightarrow> b \\<le> a", "apply (insert ord_Sab)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<And>a b.\n        \\<lbrakk>a \\<in> S_a; b \\<in> S_b\\<rbrakk>\n        \\<Longrightarrow> b < a) \\<Longrightarrow>\n    S_a \\<inter> S_b = {}\n 2. \\<And>a b.\n       \\<lbrakk>a \\<in> S_a; b \\<in> S_b;\n        \\<And>a b.\n           \\<lbrakk>a \\<in> S_a; b \\<in> S_b\\<rbrakk>\n           \\<Longrightarrow> b < a\\<rbrakk>\n       \\<Longrightarrow> b \\<le> a", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>a \\<in> S_a; b \\<in> S_b;\n        \\<And>a b.\n           \\<lbrakk>a \\<in> S_a; b \\<in> S_b\\<rbrakk>\n           \\<Longrightarrow> b < a\\<rbrakk>\n       \\<Longrightarrow> b \\<le> a", "apply (metis less_le_not_le ord_Sab)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in linorder) map_iterator_linord_union_correct :\n  assumes it_a: \"set_iterator_map_linord it_a S_a\"\n  assumes it_b: \"set_iterator_map_linord it_b S_b\"\n  assumes ord_Sab: \"\\<And>kv kv'. \\<lbrakk>kv \\<in> S_a; kv' \\<in> S_b\\<rbrakk> \\<Longrightarrow> fst kv < fst kv'\"\n  shows \"set_iterator_map_linord (set_iterator_union it_a it_b) (S_a \\<union> S_b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_map_linord (set_iterator_union it_a it_b)\n     (S_a \\<union> S_b)", "unfolding set_iterator_map_linord_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_genord (set_iterator_union it_a it_b) (S_a \\<union> S_b)\n     (\\<lambda>(k, uu_) (k', uu_). k \\<le> k')", "apply (rule set_iterator_genord_union_correct [OF \n    it_a[unfolded set_iterator_map_linord_def] \n    it_b[unfolded set_iterator_map_linord_def]])"], ["proof (prove)\ngoal (2 subgoals):\n 1. S_a \\<inter> S_b = {}\n 2. \\<And>a b.\n       \\<lbrakk>a \\<in> S_a; b \\<in> S_b\\<rbrakk>\n       \\<Longrightarrow> (case a of\n                          (k, uu_) \\<Rightarrow>\n                            \\<lambda>(k', uu_). k \\<le> k')\n                          b", "apply (insert ord_Sab)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<And>kv kv'.\n        \\<lbrakk>kv \\<in> S_a; kv' \\<in> S_b\\<rbrakk>\n        \\<Longrightarrow> fst kv < fst kv') \\<Longrightarrow>\n    S_a \\<inter> S_b = {}\n 2. \\<And>a b.\n       \\<lbrakk>a \\<in> S_a; b \\<in> S_b;\n        \\<And>kv kv'.\n           \\<lbrakk>kv \\<in> S_a; kv' \\<in> S_b\\<rbrakk>\n           \\<Longrightarrow> fst kv < fst kv'\\<rbrakk>\n       \\<Longrightarrow> (case a of\n                          (k, uu_) \\<Rightarrow>\n                            \\<lambda>(k', uu_). k \\<le> k')\n                          b", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<in> S_a; (aa, ba) \\<in> S_b;\n        \\<And>a b aa ba.\n           \\<lbrakk>(a, b) \\<in> S_a; (aa, ba) \\<in> S_b\\<rbrakk>\n           \\<Longrightarrow> a < aa\\<rbrakk>\n       \\<Longrightarrow> a \\<le> aa", "apply (metis less_le_not_le)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in linorder) map_iterator_rev_linord_union_correct :\n  assumes it_a: \"set_iterator_map_rev_linord it_a S_a\"\n  assumes it_b: \"set_iterator_map_rev_linord it_b S_b\"\n  assumes ord_Sab: \"\\<And>kv kv'. \\<lbrakk>kv \\<in> S_a; kv' \\<in> S_b\\<rbrakk> \\<Longrightarrow> fst kv > fst kv'\"\n  shows \"set_iterator_map_rev_linord (set_iterator_union it_a it_b) (S_a \\<union> S_b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_map_rev_linord (set_iterator_union it_a it_b)\n     (S_a \\<union> S_b)", "unfolding set_iterator_map_rev_linord_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_genord (set_iterator_union it_a it_b) (S_a \\<union> S_b)\n     (\\<lambda>(k, uu_) (k', uu_). k' \\<le> k)", "apply (rule set_iterator_genord_union_correct [OF \n    it_a[unfolded set_iterator_map_rev_linord_def] \n    it_b[unfolded set_iterator_map_rev_linord_def]])"], ["proof (prove)\ngoal (2 subgoals):\n 1. S_a \\<inter> S_b = {}\n 2. \\<And>a b.\n       \\<lbrakk>a \\<in> S_a; b \\<in> S_b\\<rbrakk>\n       \\<Longrightarrow> (case a of\n                          (k, uu_) \\<Rightarrow>\n                            \\<lambda>(k', uu_). k' \\<le> k)\n                          b", "apply (insert ord_Sab)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<And>kv kv'.\n        \\<lbrakk>kv \\<in> S_a; kv' \\<in> S_b\\<rbrakk>\n        \\<Longrightarrow> fst kv' < fst kv) \\<Longrightarrow>\n    S_a \\<inter> S_b = {}\n 2. \\<And>a b.\n       \\<lbrakk>a \\<in> S_a; b \\<in> S_b;\n        \\<And>kv kv'.\n           \\<lbrakk>kv \\<in> S_a; kv' \\<in> S_b\\<rbrakk>\n           \\<Longrightarrow> fst kv' < fst kv\\<rbrakk>\n       \\<Longrightarrow> (case a of\n                          (k, uu_) \\<Rightarrow>\n                            \\<lambda>(k', uu_). k' \\<le> k)\n                          b", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<in> S_a; (aa, ba) \\<in> S_b;\n        \\<And>a b aa ba.\n           \\<lbrakk>(a, b) \\<in> S_a; (aa, ba) \\<in> S_b\\<rbrakk>\n           \\<Longrightarrow> aa < a\\<rbrakk>\n       \\<Longrightarrow> aa \\<le> a", "apply (metis less_le_not_le)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Product\\<close>"], ["", "definition set_iterator_product :: \n    \"('a,'\\<sigma>) set_iterator \\<Rightarrow> ('a \\<Rightarrow> ('b,'\\<sigma>) set_iterator) \\<Rightarrow> ('a \\<times> 'b ,'\\<sigma>) set_iterator\" where\n  \"set_iterator_product it_a it_b \\<equiv> \\<lambda>c f \\<sigma>0.\n    it_a c (\n      \\<lambda>a \\<sigma>. it_b a c (\\<lambda>b \\<sigma>. f (a,b) \\<sigma>) \\<sigma>\n    ) \\<sigma>0\""], ["", "lemma set_iterator_product_foldli_conv: \n  \"set_iterator_product (foldli as) (\\<lambda>a. foldli (bs a)) =\n   foldli (concat (map (\\<lambda>a. map (\\<lambda>b. (a, b)) (bs a)) as))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_product (foldli as) (\\<lambda>a. foldli (bs a)) =\n    foldli (concat (map (\\<lambda>a. map (Pair a) (bs a)) as))", "apply (induct as)"], ["proof (prove)\ngoal (2 subgoals):\n 1. set_iterator_product (foldli []) (\\<lambda>a. foldli (bs a)) =\n    foldli (concat (map (\\<lambda>a. map (Pair a) (bs a)) []))\n 2. \\<And>a as.\n       set_iterator_product (foldli as) (\\<lambda>a. foldli (bs a)) =\n       foldli\n        (concat\n          (map (\\<lambda>a. map (Pair a) (bs a)) as)) \\<Longrightarrow>\n       set_iterator_product (foldli (a # as)) (\\<lambda>a. foldli (bs a)) =\n       foldli (concat (map (\\<lambda>a. map (Pair a) (bs a)) (a # as)))", "apply (simp add: set_iterator_product_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a as.\n       set_iterator_product (foldli as) (\\<lambda>a. foldli (bs a)) =\n       foldli\n        (concat\n          (map (\\<lambda>a. map (Pair a) (bs a)) as)) \\<Longrightarrow>\n       set_iterator_product (foldli (a # as)) (\\<lambda>a. foldli (bs a)) =\n       foldli (concat (map (\\<lambda>a. map (Pair a) (bs a)) (a # as)))", "apply (simp add: set_iterator_product_def foldli_append foldli_map o_def fun_eq_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma set_iterator_product_it_b_cong: \nassumes it_a_OK: \"set_iterator it_a S_a\"\n    and it_b_b': \"\\<And>a. a \\<in> S_a \\<Longrightarrow> it_b a = it_b' a\"\nshows \"set_iterator_product it_a it_b =\n       set_iterator_product it_a it_b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_product it_a it_b = set_iterator_product it_a it_b'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set_iterator_product it_a it_b = set_iterator_product it_a it_b'", "from it_a_OK"], ["proof (chain)\npicking this:\n  set_iterator it_a S_a", "obtain as where \n    dist_as: \"distinct as\" and S_a_eq: \"S_a = set as\" and \n    it_a_eq: \"it_a = foldli as\""], ["proof (prove)\nusing this:\n  set_iterator it_a S_a\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        \\<lbrakk>distinct as; S_a = set as; it_a = foldli as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding set_iterator_foldli_conv"], ["proof (prove)\nusing this:\n  \\<exists>l0. distinct l0 \\<and> S_a = set l0 \\<and> it_a = foldli l0\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        \\<lbrakk>distinct as; S_a = set as; it_a = foldli as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  distinct as\n  S_a = set as\n  it_a = foldli as\n\ngoal (1 subgoal):\n 1. set_iterator_product it_a it_b = set_iterator_product it_a it_b'", "from it_b_b'[unfolded S_a_eq]"], ["proof (chain)\npicking this:\n  ?a \\<in> set as \\<Longrightarrow> it_b ?a = it_b' ?a", "show ?thesis"], ["proof (prove)\nusing this:\n  ?a \\<in> set as \\<Longrightarrow> it_b ?a = it_b' ?a\n\ngoal (1 subgoal):\n 1. set_iterator_product it_a it_b = set_iterator_product it_a it_b'", "unfolding it_a_eq"], ["proof (prove)\nusing this:\n  ?a \\<in> set as \\<Longrightarrow> it_b ?a = it_b' ?a\n\ngoal (1 subgoal):\n 1. set_iterator_product (foldli as) it_b =\n    set_iterator_product (foldli as) it_b'", "by (induct as) \n       (simp_all add: set_iterator_product_def it_b_b' fun_eq_iff)"], ["proof (state)\nthis:\n  set_iterator_product it_a it_b = set_iterator_product it_a it_b'\n\ngoal:\nNo subgoals!", "qed"], ["", "definition set_iterator_product_order ::\n  \"('a \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> ('a \\<Rightarrow> 'b \\<Rightarrow> 'b \\<Rightarrow> bool) \\<Rightarrow>\n   ('a \\<times> 'b) \\<Rightarrow> ('a \\<times> 'b) \\<Rightarrow> bool\" where\n  \"set_iterator_product_order R_a R_b ab ab' \\<longleftrightarrow>\n   (if (fst ab = fst ab') then R_b (fst ab) (snd ab) (snd ab') else\n                               R_a (fst ab) (fst ab'))\""], ["", "lemma set_iterator_genord_product_correct :\n  fixes it_a :: \"('a,'\\<sigma>) set_iterator\"\n  fixes it_b :: \"'a \\<Rightarrow> ('b,'\\<sigma>) set_iterator\" \n  assumes it_a: \"set_iterator_genord it_a S_a R_a\"\n  assumes it_b: \"\\<And>a. a \\<in> S_a \\<Longrightarrow> set_iterator_genord (it_b a) (S_b a) (R_b a)\"\n  shows \"set_iterator_genord (set_iterator_product it_a it_b) (Sigma S_a S_b) \n             (set_iterator_product_order R_a R_b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_genord (set_iterator_product it_a it_b) (Sigma S_a S_b)\n     (set_iterator_product_order R_a R_b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set_iterator_genord (set_iterator_product it_a it_b) (Sigma S_a S_b)\n     (set_iterator_product_order R_a R_b)", "from it_a"], ["proof (chain)\npicking this:\n  set_iterator_genord it_a S_a R_a", "obtain as where \n    dist_as: \"distinct as\" and S_a_eq: \"S_a = set as\" and \n    sorted_as: \"sorted_wrt R_a as\" and it_a_eq: \"it_a = foldli as\""], ["proof (prove)\nusing this:\n  set_iterator_genord it_a S_a R_a\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        \\<lbrakk>distinct as; S_a = set as; sorted_wrt R_a as;\n         it_a = foldli as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding set_iterator_genord_foldli_conv"], ["proof (prove)\nusing this:\n  \\<exists>l0.\n     distinct l0 \\<and>\n     S_a = set l0 \\<and> sorted_wrt R_a l0 \\<and> it_a = foldli l0\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        \\<lbrakk>distinct as; S_a = set as; sorted_wrt R_a as;\n         it_a = foldli as\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  distinct as\n  S_a = set as\n  sorted_wrt R_a as\n  it_a = foldli as\n\ngoal (1 subgoal):\n 1. set_iterator_genord (set_iterator_product it_a it_b) (Sigma S_a S_b)\n     (set_iterator_product_order R_a R_b)", "from it_b"], ["proof (chain)\npicking this:\n  ?a \\<in> S_a \\<Longrightarrow>\n  set_iterator_genord (it_b ?a) (S_b ?a) (R_b ?a)", "obtain bs where \n    dist_bs: \"\\<And>a. a \\<in> set as \\<Longrightarrow> distinct (bs a)\" and S_b_eq: \"\\<And>a. a \\<in> set as \\<Longrightarrow>  S_b a = set (bs a)\" and \n    sorted_bs: \"\\<And>a. a \\<in> set as \\<Longrightarrow> sorted_wrt (R_b a) (bs a)\" and \n    it_b_eq: \"\\<And>a. a \\<in> set as \\<Longrightarrow> it_b a = foldli (bs a)\""], ["proof (prove)\nusing this:\n  ?a \\<in> S_a \\<Longrightarrow>\n  set_iterator_genord (it_b ?a) (S_b ?a) (R_b ?a)\n\ngoal (1 subgoal):\n 1. (\\<And>bs.\n        \\<lbrakk>\\<And>a. a \\<in> set as \\<Longrightarrow> distinct (bs a);\n         \\<And>a. a \\<in> set as \\<Longrightarrow> S_b a = set (bs a);\n         \\<And>a.\n            a \\<in> set as \\<Longrightarrow> sorted_wrt (R_b a) (bs a);\n         \\<And>a.\n            a \\<in> set as \\<Longrightarrow> it_b a = foldli (bs a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding set_iterator_genord_foldli_conv"], ["proof (prove)\nusing this:\n  ?a \\<in> S_a \\<Longrightarrow>\n  \\<exists>l0.\n     distinct l0 \\<and>\n     S_b ?a = set l0 \\<and>\n     sorted_wrt (R_b ?a) l0 \\<and> it_b ?a = foldli l0\n\ngoal (1 subgoal):\n 1. (\\<And>bs.\n        \\<lbrakk>\\<And>a. a \\<in> set as \\<Longrightarrow> distinct (bs a);\n         \\<And>a. a \\<in> set as \\<Longrightarrow> S_b a = set (bs a);\n         \\<And>a.\n            a \\<in> set as \\<Longrightarrow> sorted_wrt (R_b a) (bs a);\n         \\<And>a.\n            a \\<in> set as \\<Longrightarrow> it_b a = foldli (bs a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis S_a_eq)"], ["proof (state)\nthis:\n  ?a \\<in> set as \\<Longrightarrow> distinct (bs ?a)\n  ?a \\<in> set as \\<Longrightarrow> S_b ?a = set (bs ?a)\n  ?a \\<in> set as \\<Longrightarrow> sorted_wrt (R_b ?a) (bs ?a)\n  ?a \\<in> set as \\<Longrightarrow> it_b ?a = foldli (bs ?a)\n\ngoal (1 subgoal):\n 1. set_iterator_genord (set_iterator_product it_a it_b) (Sigma S_a S_b)\n     (set_iterator_product_order R_a R_b)", "let ?abs = \"concat (map (\\<lambda>a. map (\\<lambda>b. (a, b)) (bs a)) as)\""], ["proof (state)\ngoal (1 subgoal):\n 1. set_iterator_genord (set_iterator_product it_a it_b) (Sigma S_a S_b)\n     (set_iterator_product_order R_a R_b)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_genord (set_iterator_product it_a it_b) (Sigma S_a S_b)\n     (set_iterator_product_order R_a R_b)", "proof (rule set_iterator_genord_I[of ?abs])"], ["proof (state)\ngoal (4 subgoals):\n 1. distinct (concat (map (\\<lambda>a. map (Pair a) (bs a)) as))\n 2. Sigma S_a S_b = set (concat (map (\\<lambda>a. map (Pair a) (bs a)) as))\n 3. sorted_wrt (set_iterator_product_order R_a R_b)\n     (concat (map (\\<lambda>a. map (Pair a) (bs a)) as))\n 4. set_iterator_product it_a it_b =\n    foldli (concat (map (\\<lambda>a. map (Pair a) (bs a)) as))", "from set_iterator_product_it_b_cong[of it_a S_a it_b, \n       OF set_iterator_intro[OF it_a] it_b_eq] it_a_eq S_a_eq"], ["proof (chain)\npicking this:\n  (\\<And>a. a \\<in> S_a \\<Longrightarrow> a \\<in> set as) \\<Longrightarrow>\n  set_iterator_product it_a it_b =\n  set_iterator_product it_a (\\<lambda>a. foldli (bs a))\n  it_a = foldli as\n  S_a = set as", "have \"set_iterator_product it_a it_b =\n          set_iterator_product (foldli as) (\\<lambda>a. foldli (bs a))\""], ["proof (prove)\nusing this:\n  (\\<And>a. a \\<in> S_a \\<Longrightarrow> a \\<in> set as) \\<Longrightarrow>\n  set_iterator_product it_a it_b =\n  set_iterator_product it_a (\\<lambda>a. foldli (bs a))\n  it_a = foldli as\n  S_a = set as\n\ngoal (1 subgoal):\n 1. set_iterator_product it_a it_b =\n    set_iterator_product (foldli as) (\\<lambda>a. foldli (bs a))", "by simp"], ["proof (state)\nthis:\n  set_iterator_product it_a it_b =\n  set_iterator_product (foldli as) (\\<lambda>a. foldli (bs a))\n\ngoal (4 subgoals):\n 1. distinct (concat (map (\\<lambda>a. map (Pair a) (bs a)) as))\n 2. Sigma S_a S_b = set (concat (map (\\<lambda>a. map (Pair a) (bs a)) as))\n 3. sorted_wrt (set_iterator_product_order R_a R_b)\n     (concat (map (\\<lambda>a. map (Pair a) (bs a)) as))\n 4. set_iterator_product it_a it_b =\n    foldli (concat (map (\\<lambda>a. map (Pair a) (bs a)) as))", "thus \"set_iterator_product it_a it_b = foldli ?abs\""], ["proof (prove)\nusing this:\n  set_iterator_product it_a it_b =\n  set_iterator_product (foldli as) (\\<lambda>a. foldli (bs a))\n\ngoal (1 subgoal):\n 1. set_iterator_product it_a it_b =\n    foldli (concat (map (\\<lambda>a. map (Pair a) (bs a)) as))", "by (simp add: set_iterator_product_foldli_conv)"], ["proof (state)\nthis:\n  set_iterator_product it_a it_b =\n  foldli (concat (map (\\<lambda>a. map (Pair a) (bs a)) as))\n\ngoal (3 subgoals):\n 1. distinct (concat (map (\\<lambda>a. map (Pair a) (bs a)) as))\n 2. Sigma S_a S_b = set (concat (map (\\<lambda>a. map (Pair a) (bs a)) as))\n 3. sorted_wrt (set_iterator_product_order R_a R_b)\n     (concat (map (\\<lambda>a. map (Pair a) (bs a)) as))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. distinct (concat (map (\\<lambda>a. map (Pair a) (bs a)) as))\n 2. Sigma S_a S_b = set (concat (map (\\<lambda>a. map (Pair a) (bs a)) as))\n 3. sorted_wrt (set_iterator_product_order R_a R_b)\n     (concat (map (\\<lambda>a. map (Pair a) (bs a)) as))", "show \"distinct ?abs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (concat (map (\\<lambda>a. map (Pair a) (bs a)) as))", "using dist_as dist_bs[unfolded S_a_eq]"], ["proof (prove)\nusing this:\n  distinct as\n  ?a \\<in> set as \\<Longrightarrow> distinct (bs ?a)\n\ngoal (1 subgoal):\n 1. distinct (concat (map (\\<lambda>a. map (Pair a) (bs a)) as))", "by (induct as) \n       (simp_all add: distinct_map inj_on_def dist_bs set_eq_iff image_iff)"], ["proof (state)\nthis:\n  distinct (concat (map (\\<lambda>a. map (Pair a) (bs a)) as))\n\ngoal (2 subgoals):\n 1. Sigma S_a S_b = set (concat (map (\\<lambda>a. map (Pair a) (bs a)) as))\n 2. sorted_wrt (set_iterator_product_order R_a R_b)\n     (concat (map (\\<lambda>a. map (Pair a) (bs a)) as))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. Sigma S_a S_b = set (concat (map (\\<lambda>a. map (Pair a) (bs a)) as))\n 2. sorted_wrt (set_iterator_product_order R_a R_b)\n     (concat (map (\\<lambda>a. map (Pair a) (bs a)) as))", "show \"Sigma S_a S_b = set ?abs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sigma S_a S_b = set (concat (map (\\<lambda>a. map (Pair a) (bs a)) as))", "unfolding S_a_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. Sigma (set as) S_b =\n    set (concat (map (\\<lambda>a. map (Pair a) (bs a)) as))", "using S_b_eq"], ["proof (prove)\nusing this:\n  ?a \\<in> set as \\<Longrightarrow> S_b ?a = set (bs ?a)\n\ngoal (1 subgoal):\n 1. Sigma (set as) S_b =\n    set (concat (map (\\<lambda>a. map (Pair a) (bs a)) as))", "by (induct as) auto"], ["proof (state)\nthis:\n  Sigma S_a S_b = set (concat (map (\\<lambda>a. map (Pair a) (bs a)) as))\n\ngoal (1 subgoal):\n 1. sorted_wrt (set_iterator_product_order R_a R_b)\n     (concat (map (\\<lambda>a. map (Pair a) (bs a)) as))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. sorted_wrt (set_iterator_product_order R_a R_b)\n     (concat (map (\\<lambda>a. map (Pair a) (bs a)) as))", "from sorted_as sorted_bs dist_as"], ["proof (chain)\npicking this:\n  sorted_wrt R_a as\n  ?a \\<in> set as \\<Longrightarrow> sorted_wrt (R_b ?a) (bs ?a)\n  distinct as", "show \"sorted_wrt\n           (set_iterator_product_order R_a R_b)\n           (concat (map (\\<lambda>a. map (Pair a) (bs a)) as))\""], ["proof (prove)\nusing this:\n  sorted_wrt R_a as\n  ?a \\<in> set as \\<Longrightarrow> sorted_wrt (R_b ?a) (bs ?a)\n  distinct as\n\ngoal (1 subgoal):\n 1. sorted_wrt (set_iterator_product_order R_a R_b)\n     (concat (map (\\<lambda>a. map (Pair a) (bs a)) as))", "proof (induct as rule: list.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>sorted_wrt R_a [];\n     \\<And>a. a \\<in> set [] \\<Longrightarrow> sorted_wrt (R_b a) (bs a);\n     distinct []\\<rbrakk>\n    \\<Longrightarrow> sorted_wrt (set_iterator_product_order R_a R_b)\n                       (concat (map (\\<lambda>a. map (Pair a) (bs a)) []))\n 2. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>sorted_wrt R_a x2;\n                 \\<And>a.\n                    a \\<in> set x2 \\<Longrightarrow>\n                    sorted_wrt (R_b a) (bs a);\n                 distinct x2\\<rbrakk>\n                \\<Longrightarrow> sorted_wrt\n                                   (set_iterator_product_order R_a R_b)\n                                   (concat\n                                     (map (\\<lambda>a. map (Pair a) (bs a))\n x2));\n        sorted_wrt R_a (x1 # x2);\n        \\<And>a.\n           a \\<in> set (x1 # x2) \\<Longrightarrow>\n           sorted_wrt (R_b a) (bs a);\n        distinct (x1 # x2)\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt (set_iterator_product_order R_a R_b)\n                          (concat\n                            (map (\\<lambda>a. map (Pair a) (bs a))\n                              (x1 # x2)))", "case Nil"], ["proof (state)\nthis:\n  sorted_wrt R_a []\n  ?a \\<in> set [] \\<Longrightarrow> sorted_wrt (R_b ?a) (bs ?a)\n  distinct []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>sorted_wrt R_a [];\n     \\<And>a. a \\<in> set [] \\<Longrightarrow> sorted_wrt (R_b a) (bs a);\n     distinct []\\<rbrakk>\n    \\<Longrightarrow> sorted_wrt (set_iterator_product_order R_a R_b)\n                       (concat (map (\\<lambda>a. map (Pair a) (bs a)) []))\n 2. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>sorted_wrt R_a x2;\n                 \\<And>a.\n                    a \\<in> set x2 \\<Longrightarrow>\n                    sorted_wrt (R_b a) (bs a);\n                 distinct x2\\<rbrakk>\n                \\<Longrightarrow> sorted_wrt\n                                   (set_iterator_product_order R_a R_b)\n                                   (concat\n                                     (map (\\<lambda>a. map (Pair a) (bs a))\n x2));\n        sorted_wrt R_a (x1 # x2);\n        \\<And>a.\n           a \\<in> set (x1 # x2) \\<Longrightarrow>\n           sorted_wrt (R_b a) (bs a);\n        distinct (x1 # x2)\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt (set_iterator_product_order R_a R_b)\n                          (concat\n                            (map (\\<lambda>a. map (Pair a) (bs a))\n                              (x1 # x2)))", "thus ?case"], ["proof (prove)\nusing this:\n  sorted_wrt R_a []\n  ?a \\<in> set [] \\<Longrightarrow> sorted_wrt (R_b ?a) (bs ?a)\n  distinct []\n\ngoal (1 subgoal):\n 1. sorted_wrt (set_iterator_product_order R_a R_b)\n     (concat (map (\\<lambda>a. map (Pair a) (bs a)) []))", "by simp"], ["proof (state)\nthis:\n  sorted_wrt (set_iterator_product_order R_a R_b)\n   (concat (map (\\<lambda>a. map (Pair a) (bs a)) []))\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>sorted_wrt R_a x2;\n                 \\<And>a.\n                    a \\<in> set x2 \\<Longrightarrow>\n                    sorted_wrt (R_b a) (bs a);\n                 distinct x2\\<rbrakk>\n                \\<Longrightarrow> sorted_wrt\n                                   (set_iterator_product_order R_a R_b)\n                                   (concat\n                                     (map (\\<lambda>a. map (Pair a) (bs a))\n x2));\n        sorted_wrt R_a (x1 # x2);\n        \\<And>a.\n           a \\<in> set (x1 # x2) \\<Longrightarrow>\n           sorted_wrt (R_b a) (bs a);\n        distinct (x1 # x2)\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt (set_iterator_product_order R_a R_b)\n                          (concat\n                            (map (\\<lambda>a. map (Pair a) (bs a))\n                              (x1 # x2)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>sorted_wrt R_a x2;\n                 \\<And>a.\n                    a \\<in> set x2 \\<Longrightarrow>\n                    sorted_wrt (R_b a) (bs a);\n                 distinct x2\\<rbrakk>\n                \\<Longrightarrow> sorted_wrt\n                                   (set_iterator_product_order R_a R_b)\n                                   (concat\n                                     (map (\\<lambda>a. map (Pair a) (bs a))\n x2));\n        sorted_wrt R_a (x1 # x2);\n        \\<And>a.\n           a \\<in> set (x1 # x2) \\<Longrightarrow>\n           sorted_wrt (R_b a) (bs a);\n        distinct (x1 # x2)\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt (set_iterator_product_order R_a R_b)\n                          (concat\n                            (map (\\<lambda>a. map (Pair a) (bs a))\n                              (x1 # x2)))", "case (Cons a as)"], ["proof (state)\nthis:\n  \\<lbrakk>sorted_wrt R_a as;\n   \\<And>a. a \\<in> set as \\<Longrightarrow> sorted_wrt (R_b a) (bs a);\n   distinct as\\<rbrakk>\n  \\<Longrightarrow> sorted_wrt (set_iterator_product_order R_a R_b)\n                     (concat (map (\\<lambda>a. map (Pair a) (bs a)) as))\n  sorted_wrt R_a (a # as)\n  ?a \\<in> set (a # as) \\<Longrightarrow> sorted_wrt (R_b ?a) (bs ?a)\n  distinct (a # as)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>sorted_wrt R_a x2;\n                 \\<And>a.\n                    a \\<in> set x2 \\<Longrightarrow>\n                    sorted_wrt (R_b a) (bs a);\n                 distinct x2\\<rbrakk>\n                \\<Longrightarrow> sorted_wrt\n                                   (set_iterator_product_order R_a R_b)\n                                   (concat\n                                     (map (\\<lambda>a. map (Pair a) (bs a))\n x2));\n        sorted_wrt R_a (x1 # x2);\n        \\<And>a.\n           a \\<in> set (x1 # x2) \\<Longrightarrow>\n           sorted_wrt (R_b a) (bs a);\n        distinct (x1 # x2)\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt (set_iterator_product_order R_a R_b)\n                          (concat\n                            (map (\\<lambda>a. map (Pair a) (bs a))\n                              (x1 # x2)))", "from Cons(2)"], ["proof (chain)\npicking this:\n  sorted_wrt R_a (a # as)", "have R_a_as: \"\\<And>a'. a' \\<in> set as \\<Longrightarrow> R_a a a'\" and\n                        sorted_as: \"sorted_wrt R_a as\""], ["proof (prove)\nusing this:\n  sorted_wrt R_a (a # as)\n\ngoal (1 subgoal):\n 1. (\\<And>a'. a' \\<in> set as \\<Longrightarrow> R_a a a') &&&\n    sorted_wrt R_a as", "by simp_all"], ["proof (state)\nthis:\n  ?a' \\<in> set as \\<Longrightarrow> R_a a ?a'\n  sorted_wrt R_a as\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>sorted_wrt R_a x2;\n                 \\<And>a.\n                    a \\<in> set x2 \\<Longrightarrow>\n                    sorted_wrt (R_b a) (bs a);\n                 distinct x2\\<rbrakk>\n                \\<Longrightarrow> sorted_wrt\n                                   (set_iterator_product_order R_a R_b)\n                                   (concat\n                                     (map (\\<lambda>a. map (Pair a) (bs a))\n x2));\n        sorted_wrt R_a (x1 # x2);\n        \\<And>a.\n           a \\<in> set (x1 # x2) \\<Longrightarrow>\n           sorted_wrt (R_b a) (bs a);\n        distinct (x1 # x2)\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt (set_iterator_product_order R_a R_b)\n                          (concat\n                            (map (\\<lambda>a. map (Pair a) (bs a))\n                              (x1 # x2)))", "from Cons(3)"], ["proof (chain)\npicking this:\n  ?a \\<in> set (a # as) \\<Longrightarrow> sorted_wrt (R_b ?a) (bs ?a)", "have sorted_bs_a: \"sorted_wrt (R_b a) (bs a)\" \n                    and sorted_bs_as: \"\\<And>a. a \\<in> set as \\<Longrightarrow> sorted_wrt (R_b a) (bs a)\""], ["proof (prove)\nusing this:\n  ?a \\<in> set (a # as) \\<Longrightarrow> sorted_wrt (R_b ?a) (bs ?a)\n\ngoal (1 subgoal):\n 1. sorted_wrt (R_b a) (bs a) &&&\n    (\\<And>a. a \\<in> set as \\<Longrightarrow> sorted_wrt (R_b a) (bs a))", "by simp_all"], ["proof (state)\nthis:\n  sorted_wrt (R_b a) (bs a)\n  ?a \\<in> set as \\<Longrightarrow> sorted_wrt (R_b ?a) (bs ?a)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>sorted_wrt R_a x2;\n                 \\<And>a.\n                    a \\<in> set x2 \\<Longrightarrow>\n                    sorted_wrt (R_b a) (bs a);\n                 distinct x2\\<rbrakk>\n                \\<Longrightarrow> sorted_wrt\n                                   (set_iterator_product_order R_a R_b)\n                                   (concat\n                                     (map (\\<lambda>a. map (Pair a) (bs a))\n x2));\n        sorted_wrt R_a (x1 # x2);\n        \\<And>a.\n           a \\<in> set (x1 # x2) \\<Longrightarrow>\n           sorted_wrt (R_b a) (bs a);\n        distinct (x1 # x2)\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt (set_iterator_product_order R_a R_b)\n                          (concat\n                            (map (\\<lambda>a. map (Pair a) (bs a))\n                              (x1 # x2)))", "from Cons(4)"], ["proof (chain)\npicking this:\n  distinct (a # as)", "have dist_as: \"distinct as\" and a_nin_as: \"a \\<notin> set as\""], ["proof (prove)\nusing this:\n  distinct (a # as)\n\ngoal (1 subgoal):\n 1. distinct as &&& a \\<notin> set as", "by simp_all"], ["proof (state)\nthis:\n  distinct as\n  a \\<notin> set as\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>sorted_wrt R_a x2;\n                 \\<And>a.\n                    a \\<in> set x2 \\<Longrightarrow>\n                    sorted_wrt (R_b a) (bs a);\n                 distinct x2\\<rbrakk>\n                \\<Longrightarrow> sorted_wrt\n                                   (set_iterator_product_order R_a R_b)\n                                   (concat\n                                     (map (\\<lambda>a. map (Pair a) (bs a))\n x2));\n        sorted_wrt R_a (x1 # x2);\n        \\<And>a.\n           a \\<in> set (x1 # x2) \\<Longrightarrow>\n           sorted_wrt (R_b a) (bs a);\n        distinct (x1 # x2)\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt (set_iterator_product_order R_a R_b)\n                          (concat\n                            (map (\\<lambda>a. map (Pair a) (bs a))\n                              (x1 # x2)))", "note ind_hyp = Cons(1)[OF sorted_as sorted_bs_as dist_as]"], ["proof (state)\nthis:\n  (\\<And>a.\n      a \\<in> set as \\<Longrightarrow> a \\<in> set as) \\<Longrightarrow>\n  sorted_wrt (set_iterator_product_order R_a R_b)\n   (concat (map (\\<lambda>a. map (Pair a) (bs a)) as))\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>sorted_wrt R_a x2;\n                 \\<And>a.\n                    a \\<in> set x2 \\<Longrightarrow>\n                    sorted_wrt (R_b a) (bs a);\n                 distinct x2\\<rbrakk>\n                \\<Longrightarrow> sorted_wrt\n                                   (set_iterator_product_order R_a R_b)\n                                   (concat\n                                     (map (\\<lambda>a. map (Pair a) (bs a))\n x2));\n        sorted_wrt R_a (x1 # x2);\n        \\<And>a.\n           a \\<in> set (x1 # x2) \\<Longrightarrow>\n           sorted_wrt (R_b a) (bs a);\n        distinct (x1 # x2)\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt (set_iterator_product_order R_a R_b)\n                          (concat\n                            (map (\\<lambda>a. map (Pair a) (bs a))\n                              (x1 # x2)))", "define bs_a where \"bs_a = bs a\""], ["proof (state)\nthis:\n  bs_a = bs a\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>sorted_wrt R_a x2;\n                 \\<And>a.\n                    a \\<in> set x2 \\<Longrightarrow>\n                    sorted_wrt (R_b a) (bs a);\n                 distinct x2\\<rbrakk>\n                \\<Longrightarrow> sorted_wrt\n                                   (set_iterator_product_order R_a R_b)\n                                   (concat\n                                     (map (\\<lambda>a. map (Pair a) (bs a))\n x2));\n        sorted_wrt R_a (x1 # x2);\n        \\<And>a.\n           a \\<in> set (x1 # x2) \\<Longrightarrow>\n           sorted_wrt (R_b a) (bs a);\n        distinct (x1 # x2)\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt (set_iterator_product_order R_a R_b)\n                          (concat\n                            (map (\\<lambda>a. map (Pair a) (bs a))\n                              (x1 # x2)))", "from sorted_bs_a"], ["proof (chain)\npicking this:\n  sorted_wrt (R_b a) (bs a)", "have sorted_prod_a : \"sorted_wrt (set_iterator_product_order R_a R_b) (map (Pair a) (bs a))\""], ["proof (prove)\nusing this:\n  sorted_wrt (R_b a) (bs a)\n\ngoal (1 subgoal):\n 1. sorted_wrt (set_iterator_product_order R_a R_b) (map (Pair a) (bs a))", "unfolding bs_a_def[symmetric]"], ["proof (prove)\nusing this:\n  sorted_wrt (R_b a) bs_a\n\ngoal (1 subgoal):\n 1. sorted_wrt (set_iterator_product_order R_a R_b) (map (Pair a) bs_a)", "apply (induct bs_a rule: list.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. sorted_wrt (R_b a) [] \\<Longrightarrow>\n    sorted_wrt (set_iterator_product_order R_a R_b) (map (Pair a) [])\n 2. \\<And>x1 x2.\n       \\<lbrakk>sorted_wrt (R_b a) x2 \\<Longrightarrow>\n                sorted_wrt (set_iterator_product_order R_a R_b)\n                 (map (Pair a) x2);\n        sorted_wrt (R_b a) (x1 # x2)\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt (set_iterator_product_order R_a R_b)\n                          (map (Pair a) (x1 # x2))", "apply (simp_all add: set_iterator_product_order_def Ball_def image_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  sorted_wrt (set_iterator_product_order R_a R_b) (map (Pair a) (bs a))\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>sorted_wrt R_a x2;\n                 \\<And>a.\n                    a \\<in> set x2 \\<Longrightarrow>\n                    sorted_wrt (R_b a) (bs a);\n                 distinct x2\\<rbrakk>\n                \\<Longrightarrow> sorted_wrt\n                                   (set_iterator_product_order R_a R_b)\n                                   (concat\n                                     (map (\\<lambda>a. map (Pair a) (bs a))\n x2));\n        sorted_wrt R_a (x1 # x2);\n        \\<And>a.\n           a \\<in> set (x1 # x2) \\<Longrightarrow>\n           sorted_wrt (R_b a) (bs a);\n        distinct (x1 # x2)\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt (set_iterator_product_order R_a R_b)\n                          (concat\n                            (map (\\<lambda>a. map (Pair a) (bs a))\n                              (x1 # x2)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt (set_iterator_product_order R_a R_b)\n     (concat (map (\\<lambda>a. map (Pair a) (bs a)) (a # as)))", "apply (simp add: sorted_wrt_append ind_hyp sorted_prod_a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (bs a).\n       \\<forall>y\\<in>set as.\n          \\<forall>xa\\<in>set (bs y).\n             set_iterator_product_order R_a R_b (a, x) (y, xa)", "apply (simp add: set_iterator_product_order_def R_a_as a_nin_as)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  sorted_wrt (set_iterator_product_order R_a R_b)\n   (concat (map (\\<lambda>a. map (Pair a) (bs a)) (a # as)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sorted_wrt (set_iterator_product_order R_a R_b)\n   (concat (map (\\<lambda>a. map (Pair a) (bs a)) as))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set_iterator_genord (set_iterator_product it_a it_b) (Sigma S_a S_b)\n   (set_iterator_product_order R_a R_b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_iterator_product_correct :\n  assumes it_a: \"set_iterator it_a S_a\"\n  assumes it_b: \"\\<And>a. a \\<in> S_a \\<Longrightarrow> set_iterator (it_b a) (S_b a)\"\n  shows \"set_iterator (set_iterator_product it_a it_b) (Sigma S_a S_b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator (set_iterator_product it_a it_b) (Sigma S_a S_b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set_iterator (set_iterator_product it_a it_b) (Sigma S_a S_b)", "note res' = set_iterator_genord_product_correct [OF it_a[unfolded set_iterator_def], \n     of it_b S_b \"\\<lambda>_ _ _. True\", OF it_b[unfolded set_iterator_def]]"], ["proof (state)\nthis:\n  (\\<And>a. a \\<in> S_a \\<Longrightarrow> a \\<in> S_a) \\<Longrightarrow>\n  set_iterator_genord (set_iterator_product it_a it_b) (Sigma S_a S_b)\n   (set_iterator_product_order (\\<lambda>_ _. True) (\\<lambda>_ _ _. True))\n\ngoal (1 subgoal):\n 1. set_iterator (set_iterator_product it_a it_b) (Sigma S_a S_b)", "note res = set_iterator_intro [OF res']"], ["proof (state)\nthis:\n  (\\<And>a. a \\<in> S_a \\<Longrightarrow> a \\<in> S_a) \\<Longrightarrow>\n  set_iterator (set_iterator_product it_a it_b) (Sigma S_a S_b)\n\ngoal (1 subgoal):\n 1. set_iterator (set_iterator_product it_a it_b) (Sigma S_a S_b)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<And>a. a \\<in> S_a \\<Longrightarrow> a \\<in> S_a) \\<Longrightarrow>\n  set_iterator (set_iterator_product it_a it_b) (Sigma S_a S_b)\n\ngoal (1 subgoal):\n 1. set_iterator (set_iterator_product it_a it_b) (Sigma S_a S_b)", "by simp"], ["proof (state)\nthis:\n  set_iterator (set_iterator_product it_a it_b) (Sigma S_a S_b)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Filter and Image\\<close>"], ["", "text \\<open>Filtering and applying an injective function on iterators is easily defineable as well.\n  In contrast to sets the function really has to be injective, because an iterator guarentees to\n  visit each element only once.\\<close>"], ["", "definition set_iterator_image_filter ::\n    \"('a \\<Rightarrow> 'b option) \\<Rightarrow> ('a,'\\<sigma>) set_iterator \\<Rightarrow> ('b,'\\<sigma>) set_iterator\" where\n  \"set_iterator_image_filter g it \\<equiv> \\<lambda>c f \\<sigma>0. (it c\n     (\\<lambda>x \\<sigma>. (case (g x) of Some x' \\<Rightarrow> f x' \\<sigma> | None \\<Rightarrow> \\<sigma>)) \\<sigma>0)\""], ["", "lemma set_iterator_image_filter_foldli_conv :\n  \"set_iterator_image_filter g (foldli xs) =\n   foldli (List.map_filter g xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_image_filter g (foldli xs) = foldli (List.map_filter g xs)", "by (induct xs) (auto simp add: List.map_filter_def set_iterator_image_filter_def fun_eq_iff)"], ["", "lemma set_iterator_genord_image_filter_correct :\n  fixes it :: \"('a,'\\<sigma>) set_iterator\"\n  fixes g :: \"'a \\<Rightarrow> 'b option\"\n  assumes it_OK: \"set_iterator_genord it S R\"\n  assumes g_inj_on: \"inj_on g (S \\<inter> dom g)\"\n  assumes R'_prop: \"\\<And>x y x' y'. \\<lbrakk>x \\<in> S; g x = Some x'; y \\<in> S; g y = Some y'; R x y\\<rbrakk> \\<Longrightarrow> R' x' y'\"\n  shows \"set_iterator_genord (set_iterator_image_filter g it) {y. \\<exists>x. x \\<in> S \\<and> g x = Some y} R'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_genord (set_iterator_image_filter g it)\n     {y. \\<exists>x. x \\<in> S \\<and> g x = Some y} R'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set_iterator_genord (set_iterator_image_filter g it)\n     {y. \\<exists>x. x \\<in> S \\<and> g x = Some y} R'", "from it_OK"], ["proof (chain)\npicking this:\n  set_iterator_genord it S R", "obtain xs where \n    dist_xs: \"distinct xs\" and S_eq: \"S = set xs\" and \n    sorted_xs: \"sorted_wrt R xs\" and it_eq: \"it = foldli xs\""], ["proof (prove)\nusing this:\n  set_iterator_genord it S R\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>distinct xs; S = set xs; sorted_wrt R xs;\n         it = foldli xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding set_iterator_genord_foldli_conv"], ["proof (prove)\nusing this:\n  \\<exists>l0.\n     distinct l0 \\<and>\n     S = set l0 \\<and> sorted_wrt R l0 \\<and> it = foldli l0\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>distinct xs; S = set xs; sorted_wrt R xs;\n         it = foldli xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  distinct xs\n  S = set xs\n  sorted_wrt R xs\n  it = foldli xs\n\ngoal (1 subgoal):\n 1. set_iterator_genord (set_iterator_image_filter g it)\n     {y. \\<exists>x. x \\<in> S \\<and> g x = Some y} R'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_genord (set_iterator_image_filter g it)\n     {y. \\<exists>x. x \\<in> S \\<and> g x = Some y} R'", "proof (rule set_iterator_genord_I [of \"List.map_filter g xs\"])"], ["proof (state)\ngoal (4 subgoals):\n 1. distinct (List.map_filter g xs)\n 2. {y. \\<exists>x. x \\<in> S \\<and> g x = Some y} =\n    set (List.map_filter g xs)\n 3. sorted_wrt R' (List.map_filter g xs)\n 4. set_iterator_image_filter g it = foldli (List.map_filter g xs)", "show \"set_iterator_image_filter g it =\n          foldli (List.map_filter g xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_image_filter g it = foldli (List.map_filter g xs)", "unfolding it_eq  set_iterator_image_filter_foldli_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli (List.map_filter g xs) = foldli (List.map_filter g xs)", "by simp"], ["proof (state)\nthis:\n  set_iterator_image_filter g it = foldli (List.map_filter g xs)\n\ngoal (3 subgoals):\n 1. distinct (List.map_filter g xs)\n 2. {y. \\<exists>x. x \\<in> S \\<and> g x = Some y} =\n    set (List.map_filter g xs)\n 3. sorted_wrt R' (List.map_filter g xs)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. distinct (List.map_filter g xs)\n 2. {y. \\<exists>x. x \\<in> S \\<and> g x = Some y} =\n    set (List.map_filter g xs)\n 3. sorted_wrt R' (List.map_filter g xs)", "from dist_xs g_inj_on[unfolded S_eq]"], ["proof (chain)\npicking this:\n  distinct xs\n  inj_on g (set xs \\<inter> dom g)", "show \"distinct (List.map_filter g xs)\""], ["proof (prove)\nusing this:\n  distinct xs\n  inj_on g (set xs \\<inter> dom g)\n\ngoal (1 subgoal):\n 1. distinct (List.map_filter g xs)", "apply (induct xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct []; inj_on g (set [] \\<inter> dom g)\\<rbrakk>\n    \\<Longrightarrow> distinct (List.map_filter g [])\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>distinct xs;\n                 inj_on g (set xs \\<inter> dom g)\\<rbrakk>\n                \\<Longrightarrow> distinct (List.map_filter g xs);\n        distinct (a # xs); inj_on g (set (a # xs) \\<inter> dom g)\\<rbrakk>\n       \\<Longrightarrow> distinct (List.map_filter g (a # xs))", "apply (simp add: List.map_filter_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>distinct xs;\n                 inj_on g (set xs \\<inter> dom g)\\<rbrakk>\n                \\<Longrightarrow> distinct (List.map_filter g xs);\n        distinct (a # xs); inj_on g (set (a # xs) \\<inter> dom g)\\<rbrakk>\n       \\<Longrightarrow> distinct (List.map_filter g (a # xs))", "apply (simp add: List.map_filter_def image_iff inj_on_def Ball_def dom_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct\n                 (map (the \\<circ> g)\n                   (filter (\\<lambda>x. \\<exists>y. g x = Some y) xs));\n        a \\<notin> set xs \\<and> distinct xs;\n        \\<forall>x.\n           (x = a \\<or> x \\<in> set xs) \\<and>\n           (\\<exists>y. g x = Some y) \\<longrightarrow>\n           (\\<forall>xa.\n               (xa = a \\<or> xa \\<in> set xs) \\<and>\n               (\\<exists>y. g xa = Some y) \\<longrightarrow>\n               g x = g xa \\<longrightarrow> x = xa)\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>y. g a = Some y) \\<longrightarrow>\n                         (\\<forall>x.\n                             x \\<in> set xs \\<longrightarrow>\n                             g x = None \\<or> the (g a) \\<noteq> the (g x))", "apply (metis not_Some_eq option.sel)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  distinct (List.map_filter g xs)\n\ngoal (2 subgoals):\n 1. {y. \\<exists>x. x \\<in> S \\<and> g x = Some y} =\n    set (List.map_filter g xs)\n 2. sorted_wrt R' (List.map_filter g xs)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. {y. \\<exists>x. x \\<in> S \\<and> g x = Some y} =\n    set (List.map_filter g xs)\n 2. sorted_wrt R' (List.map_filter g xs)", "show \"{y. \\<exists>x. x \\<in> S \\<and> g x = Some y} =\n          set (List.map_filter g xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {y. \\<exists>x. x \\<in> S \\<and> g x = Some y} =\n    set (List.map_filter g xs)", "unfolding S_eq set_map_filter"], ["proof (prove)\ngoal (1 subgoal):\n 1. {y. \\<exists>x. x \\<in> set xs \\<and> g x = Some y} =\n    {y. \\<exists>x. x \\<in> set xs \\<and> g x = Some y}", "by simp"], ["proof (state)\nthis:\n  {y. \\<exists>x. x \\<in> S \\<and> g x = Some y} =\n  set (List.map_filter g xs)\n\ngoal (1 subgoal):\n 1. sorted_wrt R' (List.map_filter g xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. sorted_wrt R' (List.map_filter g xs)", "from sorted_xs R'_prop[unfolded S_eq]"], ["proof (chain)\npicking this:\n  sorted_wrt R xs\n  \\<lbrakk>?x \\<in> set xs; g ?x = Some ?x'; ?y \\<in> set xs;\n   g ?y = Some ?y'; R ?x ?y\\<rbrakk>\n  \\<Longrightarrow> R' ?x' ?y'", "show \"sorted_wrt R' (List.map_filter g xs)\""], ["proof (prove)\nusing this:\n  sorted_wrt R xs\n  \\<lbrakk>?x \\<in> set xs; g ?x = Some ?x'; ?y \\<in> set xs;\n   g ?y = Some ?y'; R ?x ?y\\<rbrakk>\n  \\<Longrightarrow> R' ?x' ?y'\n\ngoal (1 subgoal):\n 1. sorted_wrt R' (List.map_filter g xs)", "proof (induct xs rule: list.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>sorted_wrt R [];\n     \\<And>x x' y y'.\n        \\<lbrakk>x \\<in> set []; g x = Some x'; y \\<in> set [];\n         g y = Some y'; R x y\\<rbrakk>\n        \\<Longrightarrow> R' x' y'\\<rbrakk>\n    \\<Longrightarrow> sorted_wrt R' (List.map_filter g [])\n 2. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>sorted_wrt R x2;\n                 \\<And>x x' y y'.\n                    \\<lbrakk>x \\<in> set x2; g x = Some x'; y \\<in> set x2;\n                     g y = Some y'; R x y\\<rbrakk>\n                    \\<Longrightarrow> R' x' y'\\<rbrakk>\n                \\<Longrightarrow> sorted_wrt R' (List.map_filter g x2);\n        sorted_wrt R (x1 # x2);\n        \\<And>x x' y y'.\n           \\<lbrakk>x \\<in> set (x1 # x2); g x = Some x';\n            y \\<in> set (x1 # x2); g y = Some y'; R x y\\<rbrakk>\n           \\<Longrightarrow> R' x' y'\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt R' (List.map_filter g (x1 # x2))", "case Nil"], ["proof (state)\nthis:\n  sorted_wrt R []\n  \\<lbrakk>?x \\<in> set []; g ?x = Some ?x'; ?y \\<in> set [];\n   g ?y = Some ?y'; R ?x ?y\\<rbrakk>\n  \\<Longrightarrow> R' ?x' ?y'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>sorted_wrt R [];\n     \\<And>x x' y y'.\n        \\<lbrakk>x \\<in> set []; g x = Some x'; y \\<in> set [];\n         g y = Some y'; R x y\\<rbrakk>\n        \\<Longrightarrow> R' x' y'\\<rbrakk>\n    \\<Longrightarrow> sorted_wrt R' (List.map_filter g [])\n 2. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>sorted_wrt R x2;\n                 \\<And>x x' y y'.\n                    \\<lbrakk>x \\<in> set x2; g x = Some x'; y \\<in> set x2;\n                     g y = Some y'; R x y\\<rbrakk>\n                    \\<Longrightarrow> R' x' y'\\<rbrakk>\n                \\<Longrightarrow> sorted_wrt R' (List.map_filter g x2);\n        sorted_wrt R (x1 # x2);\n        \\<And>x x' y y'.\n           \\<lbrakk>x \\<in> set (x1 # x2); g x = Some x';\n            y \\<in> set (x1 # x2); g y = Some y'; R x y\\<rbrakk>\n           \\<Longrightarrow> R' x' y'\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt R' (List.map_filter g (x1 # x2))", "thus ?case"], ["proof (prove)\nusing this:\n  sorted_wrt R []\n  \\<lbrakk>?x \\<in> set []; g ?x = Some ?x'; ?y \\<in> set [];\n   g ?y = Some ?y'; R ?x ?y\\<rbrakk>\n  \\<Longrightarrow> R' ?x' ?y'\n\ngoal (1 subgoal):\n 1. sorted_wrt R' (List.map_filter g [])", "by (simp add: List.map_filter_simps)"], ["proof (state)\nthis:\n  sorted_wrt R' (List.map_filter g [])\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>sorted_wrt R x2;\n                 \\<And>x x' y y'.\n                    \\<lbrakk>x \\<in> set x2; g x = Some x'; y \\<in> set x2;\n                     g y = Some y'; R x y\\<rbrakk>\n                    \\<Longrightarrow> R' x' y'\\<rbrakk>\n                \\<Longrightarrow> sorted_wrt R' (List.map_filter g x2);\n        sorted_wrt R (x1 # x2);\n        \\<And>x x' y y'.\n           \\<lbrakk>x \\<in> set (x1 # x2); g x = Some x';\n            y \\<in> set (x1 # x2); g y = Some y'; R x y\\<rbrakk>\n           \\<Longrightarrow> R' x' y'\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt R' (List.map_filter g (x1 # x2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>sorted_wrt R x2;\n                 \\<And>x x' y y'.\n                    \\<lbrakk>x \\<in> set x2; g x = Some x'; y \\<in> set x2;\n                     g y = Some y'; R x y\\<rbrakk>\n                    \\<Longrightarrow> R' x' y'\\<rbrakk>\n                \\<Longrightarrow> sorted_wrt R' (List.map_filter g x2);\n        sorted_wrt R (x1 # x2);\n        \\<And>x x' y y'.\n           \\<lbrakk>x \\<in> set (x1 # x2); g x = Some x';\n            y \\<in> set (x1 # x2); g y = Some y'; R x y\\<rbrakk>\n           \\<Longrightarrow> R' x' y'\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt R' (List.map_filter g (x1 # x2))", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>sorted_wrt R xs;\n   \\<And>x x' y y'.\n      \\<lbrakk>x \\<in> set xs; g x = Some x'; y \\<in> set xs; g y = Some y';\n       R x y\\<rbrakk>\n      \\<Longrightarrow> R' x' y'\\<rbrakk>\n  \\<Longrightarrow> sorted_wrt R' (List.map_filter g xs)\n  sorted_wrt R (x # xs)\n  \\<lbrakk>?x \\<in> set (x # xs); g ?x = Some ?x'; ?y \\<in> set (x # xs);\n   g ?y = Some ?y'; R ?x ?y\\<rbrakk>\n  \\<Longrightarrow> R' ?x' ?y'\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>sorted_wrt R x2;\n                 \\<And>x x' y y'.\n                    \\<lbrakk>x \\<in> set x2; g x = Some x'; y \\<in> set x2;\n                     g y = Some y'; R x y\\<rbrakk>\n                    \\<Longrightarrow> R' x' y'\\<rbrakk>\n                \\<Longrightarrow> sorted_wrt R' (List.map_filter g x2);\n        sorted_wrt R (x1 # x2);\n        \\<And>x x' y y'.\n           \\<lbrakk>x \\<in> set (x1 # x2); g x = Some x';\n            y \\<in> set (x1 # x2); g y = Some y'; R x y\\<rbrakk>\n           \\<Longrightarrow> R' x' y'\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt R' (List.map_filter g (x1 # x2))", "note sort_x_xs = Cons(2)"], ["proof (state)\nthis:\n  sorted_wrt R (x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>sorted_wrt R x2;\n                 \\<And>x x' y y'.\n                    \\<lbrakk>x \\<in> set x2; g x = Some x'; y \\<in> set x2;\n                     g y = Some y'; R x y\\<rbrakk>\n                    \\<Longrightarrow> R' x' y'\\<rbrakk>\n                \\<Longrightarrow> sorted_wrt R' (List.map_filter g x2);\n        sorted_wrt R (x1 # x2);\n        \\<And>x x' y y'.\n           \\<lbrakk>x \\<in> set (x1 # x2); g x = Some x';\n            y \\<in> set (x1 # x2); g y = Some y'; R x y\\<rbrakk>\n           \\<Longrightarrow> R' x' y'\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt R' (List.map_filter g (x1 # x2))", "note R'_x_xs = Cons(3)"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> set (x # xs); g ?x = Some ?x'; ?y \\<in> set (x # xs);\n   g ?y = Some ?y'; R ?x ?y\\<rbrakk>\n  \\<Longrightarrow> R' ?x' ?y'\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>sorted_wrt R x2;\n                 \\<And>x x' y y'.\n                    \\<lbrakk>x \\<in> set x2; g x = Some x'; y \\<in> set x2;\n                     g y = Some y'; R x y\\<rbrakk>\n                    \\<Longrightarrow> R' x' y'\\<rbrakk>\n                \\<Longrightarrow> sorted_wrt R' (List.map_filter g x2);\n        sorted_wrt R (x1 # x2);\n        \\<And>x x' y y'.\n           \\<lbrakk>x \\<in> set (x1 # x2); g x = Some x';\n            y \\<in> set (x1 # x2); g y = Some y'; R x y\\<rbrakk>\n           \\<Longrightarrow> R' x' y'\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt R' (List.map_filter g (x1 # x2))", "from Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>sorted_wrt R xs;\n   \\<And>x x' y y'.\n      \\<lbrakk>x \\<in> set xs; g x = Some x'; y \\<in> set xs; g y = Some y';\n       R x y\\<rbrakk>\n      \\<Longrightarrow> R' x' y'\\<rbrakk>\n  \\<Longrightarrow> sorted_wrt R' (List.map_filter g xs)\n  sorted_wrt R (x # xs)\n  \\<lbrakk>?x \\<in> set (x # xs); g ?x = Some ?x'; ?y \\<in> set (x # xs);\n   g ?y = Some ?y'; R ?x ?y\\<rbrakk>\n  \\<Longrightarrow> R' ?x' ?y'", "have ind_hyp: \"sorted_wrt R' (List.map_filter g xs)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>sorted_wrt R xs;\n   \\<And>x x' y y'.\n      \\<lbrakk>x \\<in> set xs; g x = Some x'; y \\<in> set xs; g y = Some y';\n       R x y\\<rbrakk>\n      \\<Longrightarrow> R' x' y'\\<rbrakk>\n  \\<Longrightarrow> sorted_wrt R' (List.map_filter g xs)\n  sorted_wrt R (x # xs)\n  \\<lbrakk>?x \\<in> set (x # xs); g ?x = Some ?x'; ?y \\<in> set (x # xs);\n   g ?y = Some ?y'; R ?x ?y\\<rbrakk>\n  \\<Longrightarrow> R' ?x' ?y'\n\ngoal (1 subgoal):\n 1. sorted_wrt R' (List.map_filter g xs)", "by auto"], ["proof (state)\nthis:\n  sorted_wrt R' (List.map_filter g xs)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<lbrakk>sorted_wrt R x2;\n                 \\<And>x x' y y'.\n                    \\<lbrakk>x \\<in> set x2; g x = Some x'; y \\<in> set x2;\n                     g y = Some y'; R x y\\<rbrakk>\n                    \\<Longrightarrow> R' x' y'\\<rbrakk>\n                \\<Longrightarrow> sorted_wrt R' (List.map_filter g x2);\n        sorted_wrt R (x1 # x2);\n        \\<And>x x' y y'.\n           \\<lbrakk>x \\<in> set (x1 # x2); g x = Some x';\n            y \\<in> set (x1 # x2); g y = Some y'; R x y\\<rbrakk>\n           \\<Longrightarrow> R' x' y'\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt R' (List.map_filter g (x1 # x2))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted_wrt R' (List.map_filter g (x # xs))", "apply (cases \"g x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. g x = None \\<Longrightarrow> sorted_wrt R' (List.map_filter g (x # xs))\n 2. \\<And>a.\n       g x = Some a \\<Longrightarrow>\n       sorted_wrt R' (List.map_filter g (x # xs))", "apply (simp add: List.map_filter_simps ind_hyp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       g x = Some a \\<Longrightarrow>\n       sorted_wrt R' (List.map_filter g (x # xs))", "apply (simp add: List.map_filter_simps set_map_filter Ball_def ind_hyp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       g x = Some a \\<Longrightarrow>\n       \\<forall>x.\n          (\\<exists>xa.\n              xa \\<in> set xs \\<and> g xa = Some x) \\<longrightarrow>\n          R' a x", "apply (insert R'_x_xs[of x] sort_x_xs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>g x = Some a;\n        \\<And>x' y y'.\n           \\<lbrakk>x \\<in> set (x # xs); g x = Some x';\n            y \\<in> set (x # xs); g y = Some y'; R x y\\<rbrakk>\n           \\<Longrightarrow> R' x' y';\n        sorted_wrt R (x # xs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            (\\<exists>xa.\n                                xa \\<in> set xs \\<and>\n                                g xa = Some x) \\<longrightarrow>\n                            R' a x", "apply (simp add: Ball_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>g x = Some a;\n        \\<And>x' y y'.\n           \\<lbrakk>a = x'; y = x \\<or> y \\<in> set xs; g y = Some y';\n            R x y\\<rbrakk>\n           \\<Longrightarrow> R' x' y';\n        (\\<forall>xa. xa \\<in> set xs \\<longrightarrow> R x xa) \\<and>\n        sorted_wrt R xs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            (\\<exists>xa.\n                                xa \\<in> set xs \\<and>\n                                g xa = Some x) \\<longrightarrow>\n                            R' a x", "apply metis"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  sorted_wrt R' (List.map_filter g (x # xs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sorted_wrt R' (List.map_filter g xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set_iterator_genord (set_iterator_image_filter g it)\n   {y. \\<exists>x. x \\<in> S \\<and> g x = Some y} R'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_iterator_image_filter_correct :\n  fixes it :: \"('a,'\\<sigma>) set_iterator\"\n  fixes g :: \"'a \\<Rightarrow> 'b option\"\n  assumes it_OK: \"set_iterator it S\"\n  assumes g_inj_on: \"inj_on g (S \\<inter> dom g)\"\n  shows \"set_iterator (set_iterator_image_filter g it) {y. \\<exists>x. x \\<in> S \\<and> g x = Some y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator (set_iterator_image_filter g it)\n     {y. \\<exists>x. x \\<in> S \\<and> g x = Some y}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set_iterator (set_iterator_image_filter g it)\n     {y. \\<exists>x. x \\<in> S \\<and> g x = Some y}", "note res' = set_iterator_genord_image_filter_correct [OF it_OK[unfolded set_iterator_def], \n     of g \"\\<lambda>_ _. True\"]"], ["proof (state)\nthis:\n  \\<lbrakk>inj_on g (S \\<inter> dom g);\n   \\<And>x y x' y'.\n      \\<lbrakk>x \\<in> S; g x = Some x'; y \\<in> S; g y = Some y';\n       True\\<rbrakk>\n      \\<Longrightarrow> True\\<rbrakk>\n  \\<Longrightarrow> set_iterator_genord (set_iterator_image_filter g it)\n                     {y. \\<exists>x. x \\<in> S \\<and> g x = Some y}\n                     (\\<lambda>_ _. True)\n\ngoal (1 subgoal):\n 1. set_iterator (set_iterator_image_filter g it)\n     {y. \\<exists>x. x \\<in> S \\<and> g x = Some y}", "note res = set_iterator_intro [OF res']"], ["proof (state)\nthis:\n  \\<lbrakk>inj_on g (S \\<inter> dom g);\n   \\<And>x y x' y'.\n      \\<lbrakk>x \\<in> S; g x = Some x'; y \\<in> S; g y = Some y';\n       True\\<rbrakk>\n      \\<Longrightarrow> True\\<rbrakk>\n  \\<Longrightarrow> set_iterator (set_iterator_image_filter g it)\n                     {y. \\<exists>x. x \\<in> S \\<and> g x = Some y}\n\ngoal (1 subgoal):\n 1. set_iterator (set_iterator_image_filter g it)\n     {y. \\<exists>x. x \\<in> S \\<and> g x = Some y}", "with g_inj_on"], ["proof (chain)\npicking this:\n  inj_on g (S \\<inter> dom g)\n  \\<lbrakk>inj_on g (S \\<inter> dom g);\n   \\<And>x y x' y'.\n      \\<lbrakk>x \\<in> S; g x = Some x'; y \\<in> S; g y = Some y';\n       True\\<rbrakk>\n      \\<Longrightarrow> True\\<rbrakk>\n  \\<Longrightarrow> set_iterator (set_iterator_image_filter g it)\n                     {y. \\<exists>x. x \\<in> S \\<and> g x = Some y}", "show ?thesis"], ["proof (prove)\nusing this:\n  inj_on g (S \\<inter> dom g)\n  \\<lbrakk>inj_on g (S \\<inter> dom g);\n   \\<And>x y x' y'.\n      \\<lbrakk>x \\<in> S; g x = Some x'; y \\<in> S; g y = Some y';\n       True\\<rbrakk>\n      \\<Longrightarrow> True\\<rbrakk>\n  \\<Longrightarrow> set_iterator (set_iterator_image_filter g it)\n                     {y. \\<exists>x. x \\<in> S \\<and> g x = Some y}\n\ngoal (1 subgoal):\n 1. set_iterator (set_iterator_image_filter g it)\n     {y. \\<exists>x. x \\<in> S \\<and> g x = Some y}", "by simp"], ["proof (state)\nthis:\n  set_iterator (set_iterator_image_filter g it)\n   {y. \\<exists>x. x \\<in> S \\<and> g x = Some y}\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Special definitions for only filtering or only appling a function are handy.\\<close>"], ["", "definition set_iterator_filter ::\n    \"('a \\<Rightarrow> bool) \\<Rightarrow> ('a,'\\<sigma>) set_iterator \\<Rightarrow> ('a,'\\<sigma>) set_iterator\" where\n  \"set_iterator_filter P \\<equiv> set_iterator_image_filter (\\<lambda>x. if P x then Some x else None)\""], ["", "lemma set_iterator_filter_foldli_conv :\n  \"set_iterator_filter P (foldli xs) = foldli (filter P xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_filter P (foldli xs) = foldli (filter P xs)", "apply (simp add: set_iterator_filter_def set_iterator_image_filter_foldli_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli (List.map_filter (\\<lambda>x. if P x then Some x else None) xs) =\n    foldli (filter P xs)", "apply (rule cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. foldli = foldli\n 2. List.map_filter (\\<lambda>x. if P x then Some x else None) xs =\n    filter P xs", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. List.map_filter (\\<lambda>x. if P x then Some x else None) xs =\n    filter P xs", "apply (induct xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. List.map_filter (\\<lambda>x. if P x then Some x else None) [] =\n    filter P []\n 2. \\<And>a xs.\n       List.map_filter (\\<lambda>x. if P x then Some x else None) xs =\n       filter P xs \\<Longrightarrow>\n       List.map_filter (\\<lambda>x. if P x then Some x else None) (a # xs) =\n       filter P (a # xs)", "apply (simp_all add: List.map_filter_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma set_iterator_filter_alt_def [code] : \n  \"set_iterator_filter P it = (\\<lambda>c f. it c (\\<lambda>(x::'a) (\\<sigma>::'b). if P x then f x \\<sigma> else \\<sigma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_filter P it =\n    (\\<lambda>c f.\n        it c (\\<lambda>x \\<sigma>. if P x then f x \\<sigma> else \\<sigma>))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set_iterator_filter P it =\n    (\\<lambda>c f.\n        it c (\\<lambda>x \\<sigma>. if P x then f x \\<sigma> else \\<sigma>))", "have \"\\<And>f. (\\<lambda>(x::'a) (\\<sigma>::'b).\n             case if P x then Some x else None of None \\<Rightarrow> \\<sigma>\n             | Some x' \\<Rightarrow> f x' \\<sigma>) =\n            (\\<lambda>x \\<sigma>. if P x then f x \\<sigma> else \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       (\\<lambda>x \\<sigma>.\n           case if P x then Some x else None of None \\<Rightarrow> \\<sigma>\n           | Some x' \\<Rightarrow> f x' \\<sigma>) =\n       (\\<lambda>x \\<sigma>. if P x then f x \\<sigma> else \\<sigma>)", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>x \\<sigma>.\n      case if P x then Some x else None of None \\<Rightarrow> \\<sigma>\n      | Some x' \\<Rightarrow> ?f x' \\<sigma>) =\n  (\\<lambda>x \\<sigma>. if P x then ?f x \\<sigma> else \\<sigma>)\n\ngoal (1 subgoal):\n 1. set_iterator_filter P it =\n    (\\<lambda>c f.\n        it c (\\<lambda>x \\<sigma>. if P x then f x \\<sigma> else \\<sigma>))", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>x \\<sigma>.\n      case if P x then Some x else None of None \\<Rightarrow> \\<sigma>\n      | Some x' \\<Rightarrow> ?f x' \\<sigma>) =\n  (\\<lambda>x \\<sigma>. if P x then ?f x \\<sigma> else \\<sigma>)\n\ngoal (1 subgoal):\n 1. set_iterator_filter P it =\n    (\\<lambda>c f.\n        it c (\\<lambda>x \\<sigma>. if P x then f x \\<sigma> else \\<sigma>))", "unfolding set_iterator_filter_def\n              set_iterator_image_filter_def[abs_def]"], ["proof (prove)\nusing this:\n  (\\<lambda>x \\<sigma>.\n      case if P x then Some x else None of None \\<Rightarrow> \\<sigma>\n      | Some x' \\<Rightarrow> ?f x' \\<sigma>) =\n  (\\<lambda>x \\<sigma>. if P x then ?f x \\<sigma> else \\<sigma>)\n\ngoal (1 subgoal):\n 1. (\\<lambda>c f.\n        it c\n         (\\<lambda>x \\<sigma>.\n             case if P x then Some x else None of\n             None \\<Rightarrow> \\<sigma>\n             | Some x' \\<Rightarrow> f x' \\<sigma>)) =\n    (\\<lambda>c f.\n        it c (\\<lambda>x \\<sigma>. if P x then f x \\<sigma> else \\<sigma>))", "by simp"], ["proof (state)\nthis:\n  set_iterator_filter P it =\n  (\\<lambda>c f.\n      it c (\\<lambda>x \\<sigma>. if P x then f x \\<sigma> else \\<sigma>))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_iterator_genord_filter_correct :\n  fixes it :: \"('a,'\\<sigma>) set_iterator\"\n  assumes it_OK: \"set_iterator_genord it S R\"\n  shows \"set_iterator_genord (set_iterator_filter P it) {x. x \\<in> S \\<and> P x} R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_genord (set_iterator_filter P it) {x \\<in> S. P x} R", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set_iterator_genord (set_iterator_filter P it) {x \\<in> S. P x} R", "let ?g = \"\\<lambda>x. if P x then Some x else None\""], ["proof (state)\ngoal (1 subgoal):\n 1. set_iterator_genord (set_iterator_filter P it) {x \\<in> S. P x} R", "have in_dom_g: \"\\<And>x. x \\<in> dom ?g \\<longleftrightarrow> P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. (x \\<in> dom (\\<lambda>x. if P x then Some x else None)) = P x", "unfolding dom_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> {a. (if P a then Some a else None) \\<noteq> None}) = P x", "by auto"], ["proof (state)\nthis:\n  (?x \\<in> dom (\\<lambda>x. if P x then Some x else None)) = P ?x\n\ngoal (1 subgoal):\n 1. set_iterator_genord (set_iterator_filter P it) {x \\<in> S. P x} R", "from set_iterator_genord_image_filter_correct [OF it_OK, of ?g R, folded set_iterator_filter_def]"], ["proof (chain)\npicking this:\n  \\<lbrakk>inj_on (\\<lambda>x. if P x then Some x else None)\n            (S \\<inter> dom (\\<lambda>x. if P x then Some x else None));\n   \\<And>x y x' y'.\n      \\<lbrakk>x \\<in> S; (if P x then Some x else None) = Some x';\n       y \\<in> S; (if P y then Some y else None) = Some y'; R x y\\<rbrakk>\n      \\<Longrightarrow> R x' y'\\<rbrakk>\n  \\<Longrightarrow> set_iterator_genord (set_iterator_filter P it)\n                     {y. \\<exists>x.\n                            x \\<in> S \\<and>\n                            (if P x then Some x else None) = Some y}\n                     R", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>inj_on (\\<lambda>x. if P x then Some x else None)\n            (S \\<inter> dom (\\<lambda>x. if P x then Some x else None));\n   \\<And>x y x' y'.\n      \\<lbrakk>x \\<in> S; (if P x then Some x else None) = Some x';\n       y \\<in> S; (if P y then Some y else None) = Some y'; R x y\\<rbrakk>\n      \\<Longrightarrow> R x' y'\\<rbrakk>\n  \\<Longrightarrow> set_iterator_genord (set_iterator_filter P it)\n                     {y. \\<exists>x.\n                            x \\<in> S \\<and>\n                            (if P x then Some x else None) = Some y}\n                     R\n\ngoal (1 subgoal):\n 1. set_iterator_genord (set_iterator_filter P it) {x \\<in> S. P x} R", "by (simp add: if_split_eq1 inj_on_def Ball_def in_dom_g)"], ["proof (state)\nthis:\n  set_iterator_genord (set_iterator_filter P it) {x \\<in> S. P x} R\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_iterator_filter_correct :\n  assumes it_OK: \"set_iterator it S\"\n  shows \"set_iterator (set_iterator_filter P it) {x. x \\<in> S \\<and> P x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator (set_iterator_filter P it) {x \\<in> S. P x}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set_iterator (set_iterator_filter P it) {x \\<in> S. P x}", "note res' = set_iterator_genord_filter_correct [OF it_OK[unfolded set_iterator_def], \n    of P]"], ["proof (state)\nthis:\n  set_iterator_genord (set_iterator_filter P it) {x \\<in> S. P x}\n   (\\<lambda>_ _. True)\n\ngoal (1 subgoal):\n 1. set_iterator (set_iterator_filter P it) {x \\<in> S. P x}", "note res = set_iterator_intro [OF res']"], ["proof (state)\nthis:\n  set_iterator (set_iterator_filter P it) {x \\<in> S. P x}\n\ngoal (1 subgoal):\n 1. set_iterator (set_iterator_filter P it) {x \\<in> S. P x}", "thus ?thesis"], ["proof (prove)\nusing this:\n  set_iterator (set_iterator_filter P it) {x \\<in> S. P x}\n\ngoal (1 subgoal):\n 1. set_iterator (set_iterator_filter P it) {x \\<in> S. P x}", "by simp"], ["proof (state)\nthis:\n  set_iterator (set_iterator_filter P it) {x \\<in> S. P x}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in linorder) set_iterator_linord_filter_correct :\n  assumes it_OK: \"set_iterator_linord it S\"\n  shows \"set_iterator_linord (set_iterator_filter P it) {x. x \\<in> S \\<and> P x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_linord (set_iterator_filter P it) {x \\<in> S. P x}", "using assms"], ["proof (prove)\nusing this:\n  set_iterator_linord it S\n\ngoal (1 subgoal):\n 1. set_iterator_linord (set_iterator_filter P it) {x \\<in> S. P x}", "unfolding set_iterator_linord_def"], ["proof (prove)\nusing this:\n  set_iterator_genord it S (\\<le>)\n\ngoal (1 subgoal):\n 1. set_iterator_genord (set_iterator_filter P it) {x \\<in> S. P x} (\\<le>)", "by (rule set_iterator_genord_filter_correct)"], ["", "lemma (in linorder) set_iterator_rev_linord_filter_correct :\n  assumes it_OK: \"set_iterator_rev_linord it S\"\n  shows \"set_iterator_rev_linord (set_iterator_filter P it) {x. x \\<in> S \\<and> P x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_rev_linord (set_iterator_filter P it) {x \\<in> S. P x}", "using assms"], ["proof (prove)\nusing this:\n  set_iterator_rev_linord it S\n\ngoal (1 subgoal):\n 1. set_iterator_rev_linord (set_iterator_filter P it) {x \\<in> S. P x}", "unfolding set_iterator_rev_linord_def"], ["proof (prove)\nusing this:\n  set_iterator_genord it S (\\<lambda>x y. y \\<le> x)\n\ngoal (1 subgoal):\n 1. set_iterator_genord (set_iterator_filter P it) {x \\<in> S. P x}\n     (\\<lambda>x y. y \\<le> x)", "by (rule set_iterator_genord_filter_correct)"], ["", "definition set_iterator_image ::\n    \"('a \\<Rightarrow> 'b) \\<Rightarrow> ('a,'\\<sigma>) set_iterator \\<Rightarrow> ('b,'\\<sigma>) set_iterator\" where\n  \"set_iterator_image g \\<equiv> set_iterator_image_filter (\\<lambda>x. Some (g x))\""], ["", "lemma set_iterator_image_foldli_conv :\n  \"set_iterator_image g (foldli xs) = foldli (map g xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_image g (foldli xs) = foldli (map g xs)", "apply (simp add: set_iterator_image_def set_iterator_image_filter_foldli_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli (List.map_filter (\\<lambda>x. Some (g x)) xs) = foldli (map g xs)", "apply (rule cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. foldli = foldli\n 2. List.map_filter (\\<lambda>x. Some (g x)) xs = map g xs", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. List.map_filter (\\<lambda>x. Some (g x)) xs = map g xs", "apply (induct xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. List.map_filter (\\<lambda>x. Some (g x)) [] = map g []\n 2. \\<And>a xs.\n       List.map_filter (\\<lambda>x. Some (g x)) xs =\n       map g xs \\<Longrightarrow>\n       List.map_filter (\\<lambda>x. Some (g x)) (a # xs) = map g (a # xs)", "apply (simp_all add: List.map_filter_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma set_iterator_image_alt_def [code] : \n  \"set_iterator_image g it = (\\<lambda>c f. it c (\\<lambda>x. f (g x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_image g it = (\\<lambda>c f. it c (\\<lambda>x. f (g x)))", "unfolding set_iterator_image_def\n          set_iterator_image_filter_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>c f.\n        it c\n         (\\<lambda>x \\<sigma>.\n             case Some (g x) of None \\<Rightarrow> \\<sigma>\n             | Some x' \\<Rightarrow> f x' \\<sigma>)) =\n    (\\<lambda>c f. it c (\\<lambda>x. f (g x)))", "by simp"], ["", "lemma set_iterator_genord_image_correct :\n  fixes it :: \"('a,'\\<sigma>) set_iterator\"\n  assumes it_OK: \"set_iterator_genord it S R\"\n  assumes g_inj: \"inj_on g S\"\n  assumes R'_prop: \"\\<And>x y. \\<lbrakk>x \\<in> S; y \\<in> S; R x y\\<rbrakk> \\<Longrightarrow> R' (g x) (g y)\"\n  shows \"set_iterator_genord (set_iterator_image g it) (g ` S) R'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_genord (set_iterator_image g it) (g ` S) R'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set_iterator_genord (set_iterator_image g it) (g ` S) R'", "let ?g = \"\\<lambda>x. Some (g x)\""], ["proof (state)\ngoal (1 subgoal):\n 1. set_iterator_genord (set_iterator_image g it) (g ` S) R'", "have set_eq: \"\\<And>S. {y . \\<exists>x. x \\<in> S \\<and> ?g x = Some y} = g ` S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>S. {y. \\<exists>x. x \\<in> S \\<and> Some (g x) = Some y} = g ` S", "by auto"], ["proof (state)\nthis:\n  {y. \\<exists>x. x \\<in> ?S \\<and> Some (g x) = Some y} = g ` ?S\n\ngoal (1 subgoal):\n 1. set_iterator_genord (set_iterator_image g it) (g ` S) R'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_genord (set_iterator_image g it) (g ` S) R'", "apply (rule set_iterator_genord_image_filter_correct [OF it_OK, of ?g R', \n     folded set_iterator_image_def set_eq[symmetric]])"], ["proof (prove)\ngoal (2 subgoals):\n 1. inj_on (\\<lambda>x. Some (g x))\n     (S \\<inter> dom (\\<lambda>x. Some (g x)))\n 2. \\<And>x y x' y'.\n       \\<lbrakk>x \\<in> S; Some (g x) = Some x'; y \\<in> S;\n        Some (g y) = Some y'; R x y\\<rbrakk>\n       \\<Longrightarrow> R' x' y'", "apply (insert g_inj, simp add: inj_on_def) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y x' y'.\n       \\<lbrakk>x \\<in> S; Some (g x) = Some x'; y \\<in> S;\n        Some (g y) = Some y'; R x y\\<rbrakk>\n       \\<Longrightarrow> R' x' y'", "apply (insert R'_prop, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  set_iterator_genord (set_iterator_image g it) (g ` S) R'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_iterator_image_correct :\n  assumes it_OK: \"set_iterator it S\"\n  assumes g_inj: \"inj_on g S\"\n  assumes S'_OK: \"S' = g ` S\"\n  shows \"set_iterator (set_iterator_image g it) S'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator (set_iterator_image g it) S'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set_iterator (set_iterator_image g it) S'", "note res' = set_iterator_genord_image_correct [OF it_OK[unfolded set_iterator_def] g_inj, \n    of \"\\<lambda>_ _. True\"]"], ["proof (state)\nthis:\n  (\\<And>x y.\n      \\<lbrakk>x \\<in> S; y \\<in> S; True\\<rbrakk>\n      \\<Longrightarrow> True) \\<Longrightarrow>\n  set_iterator_genord (set_iterator_image g it) (g ` S) (\\<lambda>_ _. True)\n\ngoal (1 subgoal):\n 1. set_iterator (set_iterator_image g it) S'", "note res = set_iterator_intro [OF res', folded S'_OK]"], ["proof (state)\nthis:\n  (\\<And>x y.\n      \\<lbrakk>x \\<in> S; y \\<in> S; True\\<rbrakk>\n      \\<Longrightarrow> True) \\<Longrightarrow>\n  set_iterator (set_iterator_image g it) S'\n\ngoal (1 subgoal):\n 1. set_iterator (set_iterator_image g it) S'", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      \\<lbrakk>x \\<in> S; y \\<in> S; True\\<rbrakk>\n      \\<Longrightarrow> True) \\<Longrightarrow>\n  set_iterator (set_iterator_image g it) S'\n\ngoal (1 subgoal):\n 1. set_iterator (set_iterator_image g it) S'", "by simp"], ["proof (state)\nthis:\n  set_iterator (set_iterator_image g it) S'\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Construction from list (foldli)\\<close>"], ["", "text \\<open>Iterators correspond by definition to iteration over distinct lists. They fix an order \n in which the elements are visited. Therefore, it is trivial to construct an iterator from a \n distinct list.\\<close>"], ["", "lemma set_iterator_genord_foldli_correct :\n\"distinct xs \\<Longrightarrow> sorted_wrt R xs \\<Longrightarrow> set_iterator_genord (foldli xs) (set xs) R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct xs; sorted_wrt R xs\\<rbrakk>\n    \\<Longrightarrow> set_iterator_genord (foldli xs) (set xs) R", "by (rule set_iterator_genord_I[of xs]) (simp_all)"], ["", "lemma set_iterator_foldli_correct :\n\"distinct xs \\<Longrightarrow> set_iterator (foldli xs) (set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct xs \\<Longrightarrow> set_iterator (foldli xs) (set xs)", "by (rule set_iterator_I[of xs]) (simp_all)"], ["", "lemma (in linorder) set_iterator_linord_foldli_correct :\nassumes dist_xs: \"distinct xs\"\nassumes sorted_xs: \"sorted xs\"\nshows \"set_iterator_linord (foldli xs) (set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_linord (foldli xs) (set xs)", "using assms"], ["proof (prove)\nusing this:\n  distinct xs\n  sorted xs\n\ngoal (1 subgoal):\n 1. set_iterator_linord (foldli xs) (set xs)", "by (rule_tac set_iterator_linord_I[of xs]) (simp_all)"], ["", "lemma (in linorder) set_iterator_rev_linord_foldli_correct :\nassumes dist_xs: \"distinct xs\"\nassumes sorted_xs: \"sorted (rev xs)\"\nshows \"set_iterator_rev_linord (foldli xs) (set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_rev_linord (foldli xs) (set xs)", "using assms"], ["proof (prove)\nusing this:\n  distinct xs\n  sorted (rev xs)\n\ngoal (1 subgoal):\n 1. set_iterator_rev_linord (foldli xs) (set xs)", "by (rule_tac set_iterator_rev_linord_I[of xs]) (simp_all)"], ["", "lemma map_iterator_genord_foldli_correct :\n\"distinct (map fst xs) \\<Longrightarrow> sorted_wrt R xs \\<Longrightarrow> map_iterator_genord (foldli xs) (map_of xs) R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (map fst xs); sorted_wrt R xs\\<rbrakk>\n    \\<Longrightarrow> map_iterator_genord (foldli xs) (map_of xs) R", "by (rule map_iterator_genord_I[of xs]) simp_all"], ["", "lemma map_iterator_foldli_correct :\n\"distinct (map fst xs) \\<Longrightarrow> map_iterator (foldli xs) (map_of xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst xs) \\<Longrightarrow>\n    map_iterator (foldli xs) (map_of xs)", "by (rule map_iterator_I[of xs]) (simp_all)"], ["", "lemma (in linorder) map_iterator_linord_foldli_correct :\nassumes dist_xs: \"distinct (map fst xs)\"\nassumes sorted_xs: \"sorted (map fst xs)\"\nshows \"map_iterator_linord (foldli xs) (map_of xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_iterator_linord (foldli xs) (map_of xs)", "using assms"], ["proof (prove)\nusing this:\n  distinct (map fst xs)\n  sorted (map fst xs)\n\ngoal (1 subgoal):\n 1. map_iterator_linord (foldli xs) (map_of xs)", "by (rule_tac map_iterator_linord_I[of xs]) (simp_all)"], ["", "lemma (in linorder) map_iterator_rev_linord_foldli_correct :\nassumes dist_xs: \"distinct (map fst xs)\"\nassumes sorted_xs: \"sorted (rev (map fst xs))\"\nshows \"map_iterator_rev_linord (foldli xs) (map_of xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_iterator_rev_linord (foldli xs) (map_of xs)", "using assms"], ["proof (prove)\nusing this:\n  distinct (map fst xs)\n  sorted (rev (map fst xs))\n\ngoal (1 subgoal):\n 1. map_iterator_rev_linord (foldli xs) (map_of xs)", "by (rule_tac map_iterator_rev_linord_I[of xs]) (simp_all)"], ["", "subsection \\<open>Construction from list (foldri)\\<close>"], ["", "lemma set_iterator_genord_foldri_correct :\n\"distinct xs \\<Longrightarrow> sorted_wrt R (rev xs) \\<Longrightarrow> set_iterator_genord (foldri xs) (set xs) R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct xs; sorted_wrt R (rev xs)\\<rbrakk>\n    \\<Longrightarrow> set_iterator_genord (foldri xs) (set xs) R", "by (rule set_iterator_genord_I[of \"rev xs\"]) (simp_all add: foldri_def)"], ["", "lemma set_iterator_foldri_correct :\n\"distinct xs \\<Longrightarrow> set_iterator (foldri xs) (set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct xs \\<Longrightarrow> set_iterator (foldri xs) (set xs)", "by (rule set_iterator_I[of \"rev xs\"]) (simp_all add: foldri_def)"], ["", "lemma (in linorder) set_iterator_linord_foldri_correct :\nassumes dist_xs: \"distinct xs\"\nassumes sorted_xs: \"sorted (rev xs)\"\nshows \"set_iterator_linord (foldri xs) (set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_linord (foldri xs) (set xs)", "using assms"], ["proof (prove)\nusing this:\n  distinct xs\n  sorted (rev xs)\n\ngoal (1 subgoal):\n 1. set_iterator_linord (foldri xs) (set xs)", "by (rule_tac set_iterator_linord_I[of \"rev xs\"]) (simp_all add: foldri_def)"], ["", "lemma (in linorder) set_iterator_rev_linord_foldri_correct :\nassumes dist_xs: \"distinct xs\"\nassumes sorted_xs: \"sorted xs\"\nshows \"set_iterator_rev_linord (foldri xs) (set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_rev_linord (foldri xs) (set xs)", "using assms"], ["proof (prove)\nusing this:\n  distinct xs\n  sorted xs\n\ngoal (1 subgoal):\n 1. set_iterator_rev_linord (foldri xs) (set xs)", "by (rule_tac set_iterator_rev_linord_I[of \"rev xs\"]) (simp_all add: foldri_def)"], ["", "lemma map_iterator_genord_foldri_correct :\n\"distinct (map fst xs) \\<Longrightarrow> sorted_wrt R (rev xs) \\<Longrightarrow> map_iterator_genord (foldri xs) (map_of xs) R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (map fst xs); sorted_wrt R (rev xs)\\<rbrakk>\n    \\<Longrightarrow> map_iterator_genord (foldri xs) (map_of xs) R", "by (rule map_iterator_genord_I[of \"rev xs\"]) \n   (simp_all add: rev_map[symmetric] foldri_def)"], ["", "lemma map_iterator_foldri_correct :\n\"distinct (map fst xs) \\<Longrightarrow> map_iterator (foldri xs) (map_of xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst xs) \\<Longrightarrow>\n    map_iterator (foldri xs) (map_of xs)", "by (rule map_iterator_I[of \"rev xs\"]) \n   (simp_all add: rev_map[symmetric] foldri_def)"], ["", "lemma (in linorder) map_iterator_linord_foldri_correct :\nassumes dist_xs: \"distinct (map fst xs)\"\nassumes sorted_xs: \"sorted (rev (map fst xs))\"\nshows \"map_iterator_linord (foldri xs) (map_of xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_iterator_linord (foldri xs) (map_of xs)", "using assms"], ["proof (prove)\nusing this:\n  distinct (map fst xs)\n  sorted (rev (map fst xs))\n\ngoal (1 subgoal):\n 1. map_iterator_linord (foldri xs) (map_of xs)", "by (rule_tac map_iterator_linord_I[of \"rev xs\"]) \n   (simp_all add: rev_map[symmetric] foldri_def)"], ["", "lemma (in linorder) map_iterator_rev_linord_foldri_correct :\nassumes dist_xs: \"distinct (map fst xs)\"\nassumes sorted_xs: \"sorted (map fst xs)\"\nshows \"map_iterator_rev_linord (foldri xs) (map_of xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_iterator_rev_linord (foldri xs) (map_of xs)", "using assms"], ["proof (prove)\nusing this:\n  distinct (map fst xs)\n  sorted (map fst xs)\n\ngoal (1 subgoal):\n 1. map_iterator_rev_linord (foldri xs) (map_of xs)", "by (rule_tac map_iterator_rev_linord_I[of \"rev xs\"]) \n   (simp_all add: rev_map[symmetric] foldri_def)"], ["", "subsection \\<open>Iterators over Maps\\<close>"], ["", "text \\<open>In the following iterator over the key-value pairs of a finite map are called\n iterators over maps. Operations for such iterators are presented.\\<close>"], ["", "subsubsection\\<open>Domain Iterator\\<close>"], ["", "text \\<open>One very simple such operation is iterating over only the keys of the map.\\<close>"], ["", "definition map_iterator_dom where\n  \"map_iterator_dom it = set_iterator_image fst it\""], ["", "lemma map_iterator_dom_foldli_conv :\n  \"map_iterator_dom (foldli kvs) = foldli (map fst kvs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_iterator_dom (foldli kvs) = foldli (map fst kvs)", "unfolding map_iterator_dom_def set_iterator_image_foldli_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli (map fst kvs) = foldli (map fst kvs)", "by simp"], ["", "lemma map_iterator_genord_dom_correct :\n  assumes it_OK: \"map_iterator_genord it m R\"\n  assumes R'_prop: \"\\<And>k v k' v'. \\<lbrakk>m k = Some v; m k' = Some v'; R (k, v) (k', v')\\<rbrakk> \\<Longrightarrow> R' k k'\"\n  shows \"set_iterator_genord (map_iterator_dom it) (dom m) R'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_genord (map_iterator_dom it) (dom m) R'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set_iterator_genord (map_iterator_dom it) (dom m) R'", "have pre1: \"inj_on fst (map_to_set m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on fst (map_to_set m)", "unfolding inj_on_def map_to_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{(k, v). m k = Some v}.\n       \\<forall>y\\<in>{(k, v). m k = Some v}.\n          fst x = fst y \\<longrightarrow> x = y", "by simp"], ["proof (state)\nthis:\n  inj_on fst (map_to_set m)\n\ngoal (1 subgoal):\n 1. set_iterator_genord (map_iterator_dom it) (dom m) R'", "from set_iterator_genord_image_correct[OF it_OK pre1, of R'] R'_prop"], ["proof (chain)\npicking this:\n  (\\<And>x y.\n      \\<lbrakk>x \\<in> map_to_set m; y \\<in> map_to_set m; R x y\\<rbrakk>\n      \\<Longrightarrow> R' (fst x) (fst y)) \\<Longrightarrow>\n  set_iterator_genord (set_iterator_image fst it) (fst ` map_to_set m) R'\n  \\<lbrakk>m ?k = Some ?v; m ?k' = Some ?v'; R (?k, ?v) (?k', ?v')\\<rbrakk>\n  \\<Longrightarrow> R' ?k ?k'", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      \\<lbrakk>x \\<in> map_to_set m; y \\<in> map_to_set m; R x y\\<rbrakk>\n      \\<Longrightarrow> R' (fst x) (fst y)) \\<Longrightarrow>\n  set_iterator_genord (set_iterator_image fst it) (fst ` map_to_set m) R'\n  \\<lbrakk>m ?k = Some ?v; m ?k' = Some ?v'; R (?k, ?v) (?k', ?v')\\<rbrakk>\n  \\<Longrightarrow> R' ?k ?k'\n\ngoal (1 subgoal):\n 1. set_iterator_genord (map_iterator_dom it) (dom m) R'", "unfolding map_iterator_dom_def map_to_set_dom[symmetric]"], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      \\<lbrakk>x \\<in> map_to_set m; y \\<in> map_to_set m; R x y\\<rbrakk>\n      \\<Longrightarrow> R' (fst x) (fst y)) \\<Longrightarrow>\n  set_iterator_genord (set_iterator_image fst it) (dom m) R'\n  \\<lbrakk>m ?k = Some ?v; m ?k' = Some ?v'; R (?k, ?v) (?k', ?v')\\<rbrakk>\n  \\<Longrightarrow> R' ?k ?k'\n\ngoal (1 subgoal):\n 1. set_iterator_genord (set_iterator_image fst it) (dom m) R'", "by (auto simp add: map_to_set_def)"], ["proof (state)\nthis:\n  set_iterator_genord (map_iterator_dom it) (dom m) R'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_iterator_dom_correct :\n  assumes it_OK: \"map_iterator it m\"\n  shows \"set_iterator (map_iterator_dom it) (dom m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator (map_iterator_dom it) (dom m)", "using assms"], ["proof (prove)\nusing this:\n  map_iterator it m\n\ngoal (1 subgoal):\n 1. set_iterator (map_iterator_dom it) (dom m)", "unfolding set_iterator_def"], ["proof (prove)\nusing this:\n  map_iterator_genord it m (\\<lambda>_ _. True)\n\ngoal (1 subgoal):\n 1. set_iterator_genord (map_iterator_dom it) (dom m) (\\<lambda>_ _. True)", "apply (rule_tac map_iterator_genord_dom_correct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. map_iterator_genord it m (\\<lambda>_ _. True) \\<Longrightarrow>\n    map_iterator_genord it m ?R1\n 2. \\<And>k v k' v'.\n       \\<lbrakk>map_iterator_genord it m (\\<lambda>_ _. True); m k = Some v;\n        m k' = Some v'; ?R1 (k, v) (k', v')\\<rbrakk>\n       \\<Longrightarrow> True", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in linorder) map_iterator_linord_dom_correct :\n  assumes it_OK: \"map_iterator_linord it m\"\n  shows \"set_iterator_linord (map_iterator_dom it) (dom m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_linord (map_iterator_dom it) (dom m)", "using assms"], ["proof (prove)\nusing this:\n  map_iterator_linord it m\n\ngoal (1 subgoal):\n 1. set_iterator_linord (map_iterator_dom it) (dom m)", "unfolding set_iterator_linord_def set_iterator_map_linord_def"], ["proof (prove)\nusing this:\n  map_iterator_genord it m (\\<lambda>(k, uu_) (k', uu_). k \\<le> k')\n\ngoal (1 subgoal):\n 1. set_iterator_genord (map_iterator_dom it) (dom m) (\\<le>)", "apply (rule_tac map_iterator_genord_dom_correct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. map_iterator_genord it m\n     (\\<lambda>(k, uu_) (k', uu_). k \\<le> k') \\<Longrightarrow>\n    map_iterator_genord it m ?R1\n 2. \\<And>k v k' v'.\n       \\<lbrakk>map_iterator_genord it m\n                 (\\<lambda>(k, uu_) (k', uu_). k \\<le> k');\n        m k = Some v; m k' = Some v'; ?R1 (k, v) (k', v')\\<rbrakk>\n       \\<Longrightarrow> k \\<le> k'", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k v k' v'.\n       \\<lbrakk>map_iterator_genord it m\n                 (\\<lambda>(k, uu_) (k', uu_). k \\<le> k');\n        m k = Some v; m k' = Some v';\n        (case (k, v) of\n         (k, uu_) \\<Rightarrow> \\<lambda>(k', uu_). k \\<le> k')\n         (k', v')\\<rbrakk>\n       \\<Longrightarrow> k \\<le> k'", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in linorder) map_iterator_rev_linord_dom_correct :\n  assumes it_OK: \"map_iterator_rev_linord it m\"\n  shows \"set_iterator_rev_linord (map_iterator_dom it) (dom m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_rev_linord (map_iterator_dom it) (dom m)", "using assms"], ["proof (prove)\nusing this:\n  map_iterator_rev_linord it m\n\ngoal (1 subgoal):\n 1. set_iterator_rev_linord (map_iterator_dom it) (dom m)", "unfolding set_iterator_rev_linord_def set_iterator_map_rev_linord_def"], ["proof (prove)\nusing this:\n  map_iterator_genord it m (\\<lambda>(k, uu_) (k', uu_). k' \\<le> k)\n\ngoal (1 subgoal):\n 1. set_iterator_genord (map_iterator_dom it) (dom m)\n     (\\<lambda>x y. y \\<le> x)", "apply (rule_tac map_iterator_genord_dom_correct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. map_iterator_genord it m\n     (\\<lambda>(k, uu_) (k', uu_). k' \\<le> k) \\<Longrightarrow>\n    map_iterator_genord it m ?R1\n 2. \\<And>k v k' v'.\n       \\<lbrakk>map_iterator_genord it m\n                 (\\<lambda>(k, uu_) (k', uu_). k' \\<le> k);\n        m k = Some v; m k' = Some v'; ?R1 (k, v) (k', v')\\<rbrakk>\n       \\<Longrightarrow> k' \\<le> k", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k v k' v'.\n       \\<lbrakk>map_iterator_genord it m\n                 (\\<lambda>(k, uu_) (k', uu_). k' \\<le> k);\n        m k = Some v; m k' = Some v';\n        (case (k, v) of\n         (k, uu_) \\<Rightarrow> \\<lambda>(k', uu_). k' \\<le> k)\n         (k', v')\\<rbrakk>\n       \\<Longrightarrow> k' \\<le> k", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection\\<open>Domain Iterator with Filter\\<close>"], ["", "text \\<open>More complex is iterating over only the keys such that the key-value pairs satisfy some\n        property.\\<close>"], ["", "definition map_iterator_dom_filter ::\n    \"('a \\<times> 'b \\<Rightarrow> bool) \\<Rightarrow> ('a \\<times> 'b,'\\<sigma>) set_iterator \\<Rightarrow> ('a,'\\<sigma>) set_iterator\" where\n  \"map_iterator_dom_filter P it \\<equiv> set_iterator_image_filter \n     (\\<lambda>xy. if P xy then Some (fst xy) else None) it\""], ["", "lemma map_iterator_dom_filter_alt_def [code] :\n  \"map_iterator_dom_filter P it = \n   (\\<lambda>c f. it c (\\<lambda>kv \\<sigma>. if P kv then f (fst kv) \\<sigma> else \\<sigma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_iterator_dom_filter P it =\n    (\\<lambda>c f.\n        it c\n         (\\<lambda>kv \\<sigma>.\n             if P kv then f (fst kv) \\<sigma> else \\<sigma>))", "unfolding map_iterator_dom_filter_def set_iterator_image_filter_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>c f.\n        it c\n         (\\<lambda>x \\<sigma>.\n             case if P x then Some (fst x) else None of\n             None \\<Rightarrow> \\<sigma>\n             | Some x' \\<Rightarrow> f x' \\<sigma>)) =\n    (\\<lambda>c f.\n        it c\n         (\\<lambda>kv \\<sigma>.\n             if P kv then f (fst kv) \\<sigma> else \\<sigma>))", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c.\n       (\\<lambda>f.\n           it c\n            (\\<lambda>x \\<sigma>.\n                case if P x then Some (fst x) else None of\n                None \\<Rightarrow> \\<sigma>\n                | Some x' \\<Rightarrow> f x' \\<sigma>)) =\n       (\\<lambda>f.\n           it c\n            (\\<lambda>kv \\<sigma>.\n                if P kv then f (fst kv) \\<sigma> else \\<sigma>))", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c f.\n       it c\n        (\\<lambda>x \\<sigma>.\n            case if P x then Some (fst x) else None of\n            None \\<Rightarrow> \\<sigma>\n            | Some x' \\<Rightarrow> f x' \\<sigma>) =\n       it c\n        (\\<lambda>kv \\<sigma>.\n            if P kv then f (fst kv) \\<sigma> else \\<sigma>)", "apply (rule arg_cong2[where f=\"it\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>c f. c = c\n 2. \\<And>c f.\n       (\\<lambda>x \\<sigma>.\n           case if P x then Some (fst x) else None of\n           None \\<Rightarrow> \\<sigma>\n           | Some x' \\<Rightarrow> f x' \\<sigma>) =\n       (\\<lambda>kv \\<sigma>.\n           if P kv then f (fst kv) \\<sigma> else \\<sigma>)", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c f.\n       (\\<lambda>x \\<sigma>.\n           case if P x then Some (fst x) else None of\n           None \\<Rightarrow> \\<sigma>\n           | Some x' \\<Rightarrow> f x' \\<sigma>) =\n       (\\<lambda>kv \\<sigma>.\n           if P kv then f (fst kv) \\<sigma> else \\<sigma>)", "apply (simp add: fun_eq_iff split: option.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma map_iterator_genord_dom_filter_correct :\n  fixes it :: \"('a \\<times> 'b, '\\<sigma>) set_iterator\"\n  assumes it_OK: \"set_iterator_genord it (map_to_set m) R\"\n  assumes R'_prop: \"\\<And>k1 v1 k2 v2.\n      \\<lbrakk>m k1 = Some v1; P (k1, v1);\n       m k2 = Some v2; P (k2, v2); R (k1, v1) (k2, v2)\\<rbrakk> \\<Longrightarrow> R' k1 k2\"\n  shows \"set_iterator_genord (map_iterator_dom_filter P it) {k . \\<exists>v. m k = Some v \\<and> P (k, v)} R'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_genord (map_iterator_dom_filter P it)\n     {k. \\<exists>v. m k = Some v \\<and> P (k, v)} R'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set_iterator_genord (map_iterator_dom_filter P it)\n     {k. \\<exists>v. m k = Some v \\<and> P (k, v)} R'", "define g where \"g xy = (if P xy then Some (fst xy) else None)\" for xy :: \"'a \\<times> 'b\""], ["proof (state)\nthis:\n  g ?xy = (if P ?xy then Some (fst ?xy) else None)\n\ngoal (1 subgoal):\n 1. set_iterator_genord (map_iterator_dom_filter P it)\n     {k. \\<exists>v. m k = Some v \\<and> P (k, v)} R'", "note set_iterator_genord_image_filter_correct [OF it_OK, of g R']"], ["proof (state)\nthis:\n  \\<lbrakk>inj_on g (map_to_set m \\<inter> dom g);\n   \\<And>x y x' y'.\n      \\<lbrakk>x \\<in> map_to_set m; g x = Some x'; y \\<in> map_to_set m;\n       g y = Some y'; R x y\\<rbrakk>\n      \\<Longrightarrow> R' x' y'\\<rbrakk>\n  \\<Longrightarrow> set_iterator_genord (set_iterator_image_filter g it)\n                     {y. \\<exists>x.\n                            x \\<in> map_to_set m \\<and> g x = Some y}\n                     R'\n\ngoal (1 subgoal):\n 1. set_iterator_genord (map_iterator_dom_filter P it)\n     {k. \\<exists>v. m k = Some v \\<and> P (k, v)} R'", "have g_eq_Some: \"\\<And>kv k. g kv = Some k \\<longleftrightarrow> ((k = fst kv) \\<and> P kv)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>kv k. (g kv = Some k) = (k = fst kv \\<and> P kv)", "unfolding g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>kv k.\n       ((if P kv then Some (fst kv) else None) = Some k) =\n       (k = fst kv \\<and> P kv)", "by (auto split: prod.splits option.splits)"], ["proof (state)\nthis:\n  (g ?kv = Some ?k) = (?k = fst ?kv \\<and> P ?kv)\n\ngoal (1 subgoal):\n 1. set_iterator_genord (map_iterator_dom_filter P it)\n     {k. \\<exists>v. m k = Some v \\<and> P (k, v)} R'", "have \"\\<And>x1 x2 y. x1 \\<in> map_to_set m \\<Longrightarrow> x2 \\<in> map_to_set m \\<Longrightarrow>\n                  g x1 = Some y \\<Longrightarrow> g x2 = Some y \\<Longrightarrow> x1 = x2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 y.\n       \\<lbrakk>x1 \\<in> map_to_set m; x2 \\<in> map_to_set m; g x1 = Some y;\n        g x2 = Some y\\<rbrakk>\n       \\<Longrightarrow> x1 = x2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 y.\n       \\<lbrakk>x1 \\<in> map_to_set m; x2 \\<in> map_to_set m; g x1 = Some y;\n        g x2 = Some y\\<rbrakk>\n       \\<Longrightarrow> x1 = x2", "fix x1 x2 y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 y.\n       \\<lbrakk>x1 \\<in> map_to_set m; x2 \\<in> map_to_set m; g x1 = Some y;\n        g x2 = Some y\\<rbrakk>\n       \\<Longrightarrow> x1 = x2", "assume x1_in: \"x1 \\<in> map_to_set m\"\n       and x2_in: \"x2 \\<in> map_to_set m\"\n       and g1_eq: \"g x1 = Some y\" \n       and g2_eq: \"g x2 = Some y\""], ["proof (state)\nthis:\n  x1 \\<in> map_to_set m\n  x2 \\<in> map_to_set m\n  g x1 = Some y\n  g x2 = Some y\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 y.\n       \\<lbrakk>x1 \\<in> map_to_set m; x2 \\<in> map_to_set m; g x1 = Some y;\n        g x2 = Some y\\<rbrakk>\n       \\<Longrightarrow> x1 = x2", "obtain k1 v1 where x1_eq[simp] : \"x1 = (k1, v1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k1 v1. x1 = (k1, v1) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule prod.exhaust)"], ["proof (state)\nthis:\n  x1 = (k1, v1)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 y.\n       \\<lbrakk>x1 \\<in> map_to_set m; x2 \\<in> map_to_set m; g x1 = Some y;\n        g x2 = Some y\\<rbrakk>\n       \\<Longrightarrow> x1 = x2", "obtain k2 v2 where x2_eq[simp] : \"x2 = (k2, v2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k2 v2. x2 = (k2, v2) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule prod.exhaust)"], ["proof (state)\nthis:\n  x2 = (k2, v2)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 y.\n       \\<lbrakk>x1 \\<in> map_to_set m; x2 \\<in> map_to_set m; g x1 = Some y;\n        g x2 = Some y\\<rbrakk>\n       \\<Longrightarrow> x1 = x2", "from g1_eq g2_eq g_eq_Some"], ["proof (chain)\npicking this:\n  g x1 = Some y\n  g x2 = Some y\n  (g ?kv = Some ?k) = (?k = fst ?kv \\<and> P ?kv)", "have k1_eq: \"k1 = k2\""], ["proof (prove)\nusing this:\n  g x1 = Some y\n  g x2 = Some y\n  (g ?kv = Some ?k) = (?k = fst ?kv \\<and> P ?kv)\n\ngoal (1 subgoal):\n 1. k1 = k2", "by simp"], ["proof (state)\nthis:\n  k1 = k2\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 y.\n       \\<lbrakk>x1 \\<in> map_to_set m; x2 \\<in> map_to_set m; g x1 = Some y;\n        g x2 = Some y\\<rbrakk>\n       \\<Longrightarrow> x1 = x2", "with x1_in x2_in"], ["proof (chain)\npicking this:\n  x1 \\<in> map_to_set m\n  x2 \\<in> map_to_set m\n  k1 = k2", "have v1_eq: \"v1 = v2\""], ["proof (prove)\nusing this:\n  x1 \\<in> map_to_set m\n  x2 \\<in> map_to_set m\n  k1 = k2\n\ngoal (1 subgoal):\n 1. v1 = v2", "unfolding map_to_set_def"], ["proof (prove)\nusing this:\n  x1 \\<in> {(k, v). m k = Some v}\n  x2 \\<in> {(k, v). m k = Some v}\n  k1 = k2\n\ngoal (1 subgoal):\n 1. v1 = v2", "by simp"], ["proof (state)\nthis:\n  v1 = v2\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 y.\n       \\<lbrakk>x1 \\<in> map_to_set m; x2 \\<in> map_to_set m; g x1 = Some y;\n        g x2 = Some y\\<rbrakk>\n       \\<Longrightarrow> x1 = x2", "from k1_eq v1_eq"], ["proof (chain)\npicking this:\n  k1 = k2\n  v1 = v2", "show \"x1 = x2\""], ["proof (prove)\nusing this:\n  k1 = k2\n  v1 = v2\n\ngoal (1 subgoal):\n 1. x1 = x2", "by simp"], ["proof (state)\nthis:\n  x1 = x2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?x1.0 \\<in> map_to_set m; ?x2.0 \\<in> map_to_set m;\n   g ?x1.0 = Some ?y; g ?x2.0 = Some ?y\\<rbrakk>\n  \\<Longrightarrow> ?x1.0 = ?x2.0\n\ngoal (1 subgoal):\n 1. set_iterator_genord (map_iterator_dom_filter P it)\n     {k. \\<exists>v. m k = Some v \\<and> P (k, v)} R'", "hence g_inj_on: \"inj_on g (map_to_set m \\<inter> dom g)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?x1.0 \\<in> map_to_set m; ?x2.0 \\<in> map_to_set m;\n   g ?x1.0 = Some ?y; g ?x2.0 = Some ?y\\<rbrakk>\n  \\<Longrightarrow> ?x1.0 = ?x2.0\n\ngoal (1 subgoal):\n 1. inj_on g (map_to_set m \\<inter> dom g)", "unfolding inj_on_def dom_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x1.0 \\<in> map_to_set m; ?x2.0 \\<in> map_to_set m;\n   g ?x1.0 = Some ?y; g ?x2.0 = Some ?y\\<rbrakk>\n  \\<Longrightarrow> ?x1.0 = ?x2.0\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>map_to_set m \\<inter> {a. g a \\<noteq> None}.\n       \\<forall>y\\<in>map_to_set m \\<inter> {a. g a \\<noteq> None}.\n          g x = g y \\<longrightarrow> x = y", "by auto"], ["proof (state)\nthis:\n  inj_on g (map_to_set m \\<inter> dom g)\n\ngoal (1 subgoal):\n 1. set_iterator_genord (map_iterator_dom_filter P it)\n     {k. \\<exists>v. m k = Some v \\<and> P (k, v)} R'", "have g_eq_Some: \"\\<And>x y. (g x = Some y) \\<longleftrightarrow> (P x \\<and> y = (fst x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. (g x = Some y) = (P x \\<and> y = fst x)", "unfolding g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       ((if P x then Some (fst x) else None) = Some y) =\n       (P x \\<and> y = fst x)", "by auto"], ["proof (state)\nthis:\n  (g ?x = Some ?y) = (P ?x \\<and> ?y = fst ?x)\n\ngoal (1 subgoal):\n 1. set_iterator_genord (map_iterator_dom_filter P it)\n     {k. \\<exists>v. m k = Some v \\<and> P (k, v)} R'", "have \"set_iterator_genord (set_iterator_image_filter g it)\n            {y. \\<exists>x. x \\<in> map_to_set m \\<and> g x = Some y} R'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_genord (set_iterator_image_filter g it)\n     {y. \\<exists>x. x \\<in> map_to_set m \\<and> g x = Some y} R'", "apply (rule set_iterator_genord_image_filter_correct [OF it_OK, of g R', OF g_inj_on])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y x' y'.\n       \\<lbrakk>x \\<in> map_to_set m; g x = Some x'; y \\<in> map_to_set m;\n        g y = Some y'; R x y\\<rbrakk>\n       \\<Longrightarrow> R' x' y'", "apply (insert R'_prop)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y x' y'.\n       \\<lbrakk>x \\<in> map_to_set m; g x = Some x'; y \\<in> map_to_set m;\n        g y = Some y'; R x y;\n        \\<And>k1 v1 k2 v2.\n           \\<lbrakk>m k1 = Some v1; P (k1, v1); m k2 = Some v2; P (k2, v2);\n            R (k1, v1) (k2, v2)\\<rbrakk>\n           \\<Longrightarrow> R' k1 k2\\<rbrakk>\n       \\<Longrightarrow> R' x' y'", "apply (auto simp add: g_eq_Some map_to_set_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  set_iterator_genord (set_iterator_image_filter g it)\n   {y. \\<exists>x. x \\<in> map_to_set m \\<and> g x = Some y} R'\n\ngoal (1 subgoal):\n 1. set_iterator_genord (map_iterator_dom_filter P it)\n     {k. \\<exists>v. m k = Some v \\<and> P (k, v)} R'", "thus ?thesis"], ["proof (prove)\nusing this:\n  set_iterator_genord (set_iterator_image_filter g it)\n   {y. \\<exists>x. x \\<in> map_to_set m \\<and> g x = Some y} R'\n\ngoal (1 subgoal):\n 1. set_iterator_genord (map_iterator_dom_filter P it)\n     {k. \\<exists>v. m k = Some v \\<and> P (k, v)} R'", "unfolding map_iterator_dom_filter_def g_def[symmetric]"], ["proof (prove)\nusing this:\n  set_iterator_genord (set_iterator_image_filter g it)\n   {y. \\<exists>x. x \\<in> map_to_set m \\<and> g x = Some y} R'\n\ngoal (1 subgoal):\n 1. set_iterator_genord (set_iterator_image_filter g it)\n     {k. \\<exists>v. m k = Some v \\<and> P (k, v)} R'", "by (simp add: g_eq_Some map_to_set_def)"], ["proof (state)\nthis:\n  set_iterator_genord (map_iterator_dom_filter P it)\n   {k. \\<exists>v. m k = Some v \\<and> P (k, v)} R'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_iterator_dom_filter_correct :\n  assumes it_OK: \"map_iterator it m\"\n  shows \"set_iterator (map_iterator_dom_filter P it) {k. \\<exists>v. m k = Some v \\<and> P (k, v)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator (map_iterator_dom_filter P it)\n     {k. \\<exists>v. m k = Some v \\<and> P (k, v)}", "using assms"], ["proof (prove)\nusing this:\n  map_iterator it m\n\ngoal (1 subgoal):\n 1. set_iterator (map_iterator_dom_filter P it)\n     {k. \\<exists>v. m k = Some v \\<and> P (k, v)}", "unfolding set_iterator_def"], ["proof (prove)\nusing this:\n  map_iterator_genord it m (\\<lambda>_ _. True)\n\ngoal (1 subgoal):\n 1. set_iterator_genord (map_iterator_dom_filter P it)\n     {k. \\<exists>v. m k = Some v \\<and> P (k, v)} (\\<lambda>_ _. True)", "apply (rule_tac map_iterator_genord_dom_filter_correct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. map_iterator_genord it m (\\<lambda>_ _. True) \\<Longrightarrow>\n    map_iterator_genord it m ?R1\n 2. \\<And>k1 v1 k2 v2.\n       \\<lbrakk>map_iterator_genord it m (\\<lambda>_ _. True);\n        m k1 = Some v1; P (k1, v1); m k2 = Some v2; P (k2, v2);\n        ?R1 (k1, v1) (k2, v2)\\<rbrakk>\n       \\<Longrightarrow> True", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in linorder) map_iterator_linord_dom_filter_correct :\n  assumes it_OK: \"map_iterator_linord it m\"\n  shows \"set_iterator_linord (map_iterator_dom_filter P it) {k. \\<exists>v. m k = Some v \\<and> P (k, v)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_linord (map_iterator_dom_filter P it)\n     {k. \\<exists>v. m k = Some v \\<and> P (k, v)}", "using assms"], ["proof (prove)\nusing this:\n  map_iterator_linord it m\n\ngoal (1 subgoal):\n 1. set_iterator_linord (map_iterator_dom_filter P it)\n     {k. \\<exists>v. m k = Some v \\<and> P (k, v)}", "unfolding set_iterator_map_linord_def set_iterator_linord_def"], ["proof (prove)\nusing this:\n  map_iterator_genord it m (\\<lambda>(k, uu_) (k', uu_). k \\<le> k')\n\ngoal (1 subgoal):\n 1. set_iterator_genord (map_iterator_dom_filter P it)\n     {k. \\<exists>v. m k = Some v \\<and> P (k, v)} (\\<le>)", "apply (rule_tac map_iterator_genord_dom_filter_correct \n  [where R = \"\\<lambda>(k,_) (k',_). k\\<le>k'\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. map_iterator_genord it m\n     (\\<lambda>(k, uu_) (k', uu_). k \\<le> k') \\<Longrightarrow>\n    map_iterator_genord it m (\\<lambda>(k, uu_) (k', uu_). k \\<le> k')\n 2. \\<And>k1 v1 k2 v2.\n       \\<lbrakk>map_iterator_genord it m\n                 (\\<lambda>(k, uu_) (k', uu_). k \\<le> k');\n        m k1 = Some v1; P (k1, v1); m k2 = Some v2; P (k2, v2);\n        (case (k1, v1) of\n         (k, uu_) \\<Rightarrow> \\<lambda>(k', uu_). k \\<le> k')\n         (k2, v2)\\<rbrakk>\n       \\<Longrightarrow> k1 \\<le> k2", "apply (simp_all add: set_iterator_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in linorder) set_iterator_rev_linord_map_filter_correct :\n  assumes it_OK: \"map_iterator_rev_linord it m\"\n  shows \"set_iterator_rev_linord (map_iterator_dom_filter P it) \n  {k. \\<exists>v. m k = Some v \\<and> P (k, v)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_rev_linord (map_iterator_dom_filter P it)\n     {k. \\<exists>v. m k = Some v \\<and> P (k, v)}", "using assms"], ["proof (prove)\nusing this:\n  map_iterator_rev_linord it m\n\ngoal (1 subgoal):\n 1. set_iterator_rev_linord (map_iterator_dom_filter P it)\n     {k. \\<exists>v. m k = Some v \\<and> P (k, v)}", "unfolding set_iterator_map_rev_linord_def set_iterator_rev_linord_def"], ["proof (prove)\nusing this:\n  map_iterator_genord it m (\\<lambda>(k, uu_) (k', uu_). k' \\<le> k)\n\ngoal (1 subgoal):\n 1. set_iterator_genord (map_iterator_dom_filter P it)\n     {k. \\<exists>v. m k = Some v \\<and> P (k, v)} (\\<lambda>x y. y \\<le> x)", "apply (rule_tac map_iterator_genord_dom_filter_correct \n  [where R = \"\\<lambda>(k,_) (k',_). k\\<ge>k'\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. map_iterator_genord it m\n     (\\<lambda>(k, uu_) (k', uu_). k' \\<le> k) \\<Longrightarrow>\n    map_iterator_genord it m (\\<lambda>(k, uu_) (k', uu_). k' \\<le> k)\n 2. \\<And>k1 v1 k2 v2.\n       \\<lbrakk>map_iterator_genord it m\n                 (\\<lambda>(k, uu_) (k', uu_). k' \\<le> k);\n        m k1 = Some v1; P (k1, v1); m k2 = Some v2; P (k2, v2);\n        (case (k1, v1) of\n         (k, uu_) \\<Rightarrow> \\<lambda>(k', uu_). k' \\<le> k)\n         (k2, v2)\\<rbrakk>\n       \\<Longrightarrow> k2 \\<le> k1", "apply (simp_all add: set_iterator_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection\\<open>Product for Maps\\<close>"], ["", "definition map_iterator_product where\n  \"map_iterator_product it_a it_b =\n   set_iterator_image (\\<lambda>kvv'. (fst (fst kvv'), snd kvv')) \n    (set_iterator_product it_a (\\<lambda>kv. it_b (snd kv)))\""], ["", "lemma map_iterator_product_foldli_conv :\n\"map_iterator_product (foldli as) (\\<lambda>a. foldli (bs a)) = \n foldli (concat (map (\\<lambda>(k, v). map (Pair k) (bs v)) as))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_iterator_product (foldli as) (\\<lambda>a. foldli (bs a)) =\n    foldli (concat (map (\\<lambda>(k, v). map (Pair k) (bs v)) as))", "unfolding map_iterator_product_def set_iterator_product_foldli_conv set_iterator_image_foldli_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli\n     (map (\\<lambda>kvv'. (fst (fst kvv'), snd kvv'))\n       (concat (map (\\<lambda>kv. map (Pair kv) (bs (snd kv))) as))) =\n    foldli (concat (map (\\<lambda>(k, v). map (Pair k) (bs v)) as))", "by (simp add: map_concat o_def split_def)"], ["", "lemma map_iterator_product_alt_def [code] :\n  \"map_iterator_product it_a it_b = \n   (\\<lambda>c f. it_a c (\\<lambda>a. it_b (snd a) c (\\<lambda>b. f (fst a, b))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_iterator_product it_a it_b =\n    (\\<lambda>c f.\n        it_a c (\\<lambda>a. it_b (snd a) c (\\<lambda>b. f (fst a, b))))", "unfolding map_iterator_product_def set_iterator_product_def set_iterator_image_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>c f.\n        it_a c\n         (\\<lambda>a.\n             it_b (snd a) c\n              (\\<lambda>b. f (fst (fst (a, b)), snd (a, b))))) =\n    (\\<lambda>c f.\n        it_a c (\\<lambda>a. it_b (snd a) c (\\<lambda>b. f (fst a, b))))", "by simp"], ["", "lemma map_iterator_genord_product_correct :\n  fixes it_a :: \"(('k \\<times> 'v),'\\<sigma>) set_iterator\"\n  fixes it_b :: \"'v \\<Rightarrow> ('e,'\\<sigma>) set_iterator\" \n  fixes S_a S_b R_a R_b m\n  assumes it_a: \"map_iterator_genord it_a m R_a\"\n  assumes it_b: \"\\<And>k v. m k = Some v \\<Longrightarrow> set_iterator_genord (it_b v) (S_b v) (R_b v)\"\n  assumes R'_prop: \"\\<And>k v u k' v' u'.\n       m k = Some v \\<Longrightarrow>\n       u \\<in> S_b v \\<Longrightarrow>\n       m k' = Some v' \\<Longrightarrow>\n       u' \\<in> S_b v' \\<Longrightarrow>\n       if k = k' then R_b v u u'\n       else R_a (k, v) (k', v') \\<Longrightarrow>\n       R_ab (k, u) (k', u')\"\n  shows \"set_iterator_genord (map_iterator_product it_a it_b) \n     {(k, e) . (\\<exists>v. m k = Some v \\<and> e \\<in> S_b v)} R_ab\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_genord (map_iterator_product it_a it_b)\n     {(k, e). \\<exists>v. m k = Some v \\<and> e \\<in> S_b v} R_ab", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set_iterator_genord (map_iterator_product it_a it_b)\n     {(k, e). \\<exists>v. m k = Some v \\<and> e \\<in> S_b v} R_ab", "from it_b"], ["proof (chain)\npicking this:\n  m ?k = Some ?v \\<Longrightarrow>\n  set_iterator_genord (it_b ?v) (S_b ?v) (R_b ?v)", "have it_b': \"\\<And>kv. kv \\<in> map_to_set m \\<Longrightarrow>\n       set_iterator_genord (it_b (snd kv)) (S_b (snd kv)) (R_b (snd kv))\""], ["proof (prove)\nusing this:\n  m ?k = Some ?v \\<Longrightarrow>\n  set_iterator_genord (it_b ?v) (S_b ?v) (R_b ?v)\n\ngoal (1 subgoal):\n 1. \\<And>kv.\n       kv \\<in> map_to_set m \\<Longrightarrow>\n       set_iterator_genord (it_b (snd kv)) (S_b (snd kv)) (R_b (snd kv))", "unfolding map_to_set_def"], ["proof (prove)\nusing this:\n  m ?k = Some ?v \\<Longrightarrow>\n  set_iterator_genord (it_b ?v) (S_b ?v) (R_b ?v)\n\ngoal (1 subgoal):\n 1. \\<And>kv.\n       kv \\<in> {(k, v). m k = Some v} \\<Longrightarrow>\n       set_iterator_genord (it_b (snd kv)) (S_b (snd kv)) (R_b (snd kv))", "by (case_tac kv, simp)"], ["proof (state)\nthis:\n  ?kv \\<in> map_to_set m \\<Longrightarrow>\n  set_iterator_genord (it_b (snd ?kv)) (S_b (snd ?kv)) (R_b (snd ?kv))\n\ngoal (1 subgoal):\n 1. set_iterator_genord (map_iterator_product it_a it_b)\n     {(k, e). \\<exists>v. m k = Some v \\<and> e \\<in> S_b v} R_ab", "have \"(\\<Union>x\\<in>{(k, v). m k = Some v}. \\<Union>y\\<in>S_b (snd x). {(x, y)}) = {((k,v), e) . \n          (m k = Some v) \\<and> e \\<in> S_b v}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>x\\<in>{(k, v). m k = Some v}.\n        \\<Union>y\\<in>S_b (snd x). {(x, y)}) =\n    {((k, v), e). m k = Some v \\<and> e \\<in> S_b v}", "by (auto)"], ["proof (state)\nthis:\n  (\\<Union>x\\<in>{(k, v). m k = Some v}.\n      \\<Union>y\\<in>S_b (snd x). {(x, y)}) =\n  {((k, v), e). m k = Some v \\<and> e \\<in> S_b v}\n\ngoal (1 subgoal):\n 1. set_iterator_genord (map_iterator_product it_a it_b)\n     {(k, e). \\<exists>v. m k = Some v \\<and> e \\<in> S_b v} R_ab", "with set_iterator_genord_product_correct [OF it_a, of \"\\<lambda>kv. it_b (snd kv)\" \n    \"\\<lambda>kv. S_b (snd kv)\" \"\\<lambda>kv. R_b (snd kv)\", OF it_b']"], ["proof (chain)\npicking this:\n  (\\<And>a.\n      a \\<in> map_to_set m \\<Longrightarrow>\n      a \\<in> map_to_set m) \\<Longrightarrow>\n  set_iterator_genord\n   (set_iterator_product it_a (\\<lambda>kv. it_b (snd kv)))\n   (SIGMA kv:map_to_set m. S_b (snd kv))\n   (set_iterator_product_order R_a (\\<lambda>kv. R_b (snd kv)))\n  (\\<Union>x\\<in>{(k, v). m k = Some v}.\n      \\<Union>y\\<in>S_b (snd x). {(x, y)}) =\n  {((k, v), e). m k = Some v \\<and> e \\<in> S_b v}", "have it_ab': \"set_iterator_genord (set_iterator_product it_a (\\<lambda>kv. it_b (snd kv)))\n      {((k,v), e) . (m k = Some v) \\<and> e \\<in> S_b v}\n      (set_iterator_product_order R_a\n        (\\<lambda>kv. R_b (snd kv)))\"\n     (is \"set_iterator_genord ?it_ab' ?S_ab' ?R_ab'\")"], ["proof (prove)\nusing this:\n  (\\<And>a.\n      a \\<in> map_to_set m \\<Longrightarrow>\n      a \\<in> map_to_set m) \\<Longrightarrow>\n  set_iterator_genord\n   (set_iterator_product it_a (\\<lambda>kv. it_b (snd kv)))\n   (SIGMA kv:map_to_set m. S_b (snd kv))\n   (set_iterator_product_order R_a (\\<lambda>kv. R_b (snd kv)))\n  (\\<Union>x\\<in>{(k, v). m k = Some v}.\n      \\<Union>y\\<in>S_b (snd x). {(x, y)}) =\n  {((k, v), e). m k = Some v \\<and> e \\<in> S_b v}\n\ngoal (1 subgoal):\n 1. set_iterator_genord\n     (set_iterator_product it_a (\\<lambda>kv. it_b (snd kv)))\n     {((k, v), e). m k = Some v \\<and> e \\<in> S_b v}\n     (set_iterator_product_order R_a (\\<lambda>kv. R_b (snd kv)))", "unfolding map_to_set_def"], ["proof (prove)\nusing this:\n  (\\<And>a.\n      a \\<in> {(k, v). m k = Some v} \\<Longrightarrow>\n      a \\<in> {(k, v). m k = Some v}) \\<Longrightarrow>\n  set_iterator_genord\n   (set_iterator_product it_a (\\<lambda>kv. it_b (snd kv)))\n   (SIGMA kv:{(k, v). m k = Some v}. S_b (snd kv))\n   (set_iterator_product_order R_a (\\<lambda>kv. R_b (snd kv)))\n  (\\<Union>x\\<in>{(k, v). m k = Some v}.\n      \\<Union>y\\<in>S_b (snd x). {(x, y)}) =\n  {((k, v), e). m k = Some v \\<and> e \\<in> S_b v}\n\ngoal (1 subgoal):\n 1. set_iterator_genord\n     (set_iterator_product it_a (\\<lambda>kv. it_b (snd kv)))\n     {((k, v), e). m k = Some v \\<and> e \\<in> S_b v}\n     (set_iterator_product_order R_a (\\<lambda>kv. R_b (snd kv)))", "by (simp add: Sigma_def)"], ["proof (state)\nthis:\n  set_iterator_genord\n   (set_iterator_product it_a (\\<lambda>kv. it_b (snd kv)))\n   {((k, v), e). m k = Some v \\<and> e \\<in> S_b v}\n   (set_iterator_product_order R_a (\\<lambda>kv. R_b (snd kv)))\n\ngoal (1 subgoal):\n 1. set_iterator_genord (map_iterator_product it_a it_b)\n     {(k, e). \\<exists>v. m k = Some v \\<and> e \\<in> S_b v} R_ab", "let ?g = \"\\<lambda>kvv'. (fst (fst kvv'), snd kvv')\""], ["proof (state)\ngoal (1 subgoal):\n 1. set_iterator_genord (map_iterator_product it_a it_b)\n     {(k, e). \\<exists>v. m k = Some v \\<and> e \\<in> S_b v} R_ab", "have inj_g: \"inj_on ?g ?S_ab'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>kvv'. (fst (fst kvv'), snd kvv'))\n     {((k, v), e). m k = Some v \\<and> e \\<in> S_b v}", "unfolding inj_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{((k, v), e). m k = Some v \\<and> e \\<in> S_b v}.\n       \\<forall>y\\<in>{((k, v), e). m k = Some v \\<and> e \\<in> S_b v}.\n          (fst (fst x), snd x) = (fst (fst y), snd y) \\<longrightarrow>\n          x = y", "by simp"], ["proof (state)\nthis:\n  inj_on (\\<lambda>kvv'. (fst (fst kvv'), snd kvv'))\n   {((k, v), e). m k = Some v \\<and> e \\<in> S_b v}\n\ngoal (1 subgoal):\n 1. set_iterator_genord (map_iterator_product it_a it_b)\n     {(k, e). \\<exists>v. m k = Some v \\<and> e \\<in> S_b v} R_ab", "have R_ab_OK: \"\\<And>x y.\n      x \\<in> {((k, v), e). m k = Some v \\<and> e \\<in> S_b v} \\<Longrightarrow>\n      y \\<in> {((k, v), e). m k = Some v \\<and> e \\<in> S_b v} \\<Longrightarrow>\n      set_iterator_product_order R_a (\\<lambda>kv. R_b (snd kv)) x y \\<Longrightarrow>\n      R_ab (fst (fst x), snd x) (fst (fst y), snd y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {((k, v), e). m k = Some v \\<and> e \\<in> S_b v};\n        y \\<in> {((k, v), e). m k = Some v \\<and> e \\<in> S_b v};\n        set_iterator_product_order R_a (\\<lambda>kv. R_b (snd kv)) x\n         y\\<rbrakk>\n       \\<Longrightarrow> R_ab (fst (fst x), snd x) (fst (fst y), snd y)", "apply (simp add: set_iterator_product_order_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>case x of\n                (x, xa) \\<Rightarrow>\n                  (case x of\n                   (k, v) \\<Rightarrow>\n                     \\<lambda>e. m k = Some v \\<and> e \\<in> S_b v)\n                   xa;\n        case y of\n        (x, xa) \\<Rightarrow>\n          (case x of\n           (k, v) \\<Rightarrow>\n             \\<lambda>e. m k = Some v \\<and> e \\<in> S_b v)\n           xa;\n        if fst x = fst y then R_b (snd (fst x)) (snd x) (snd y)\n        else R_a (fst x) (fst y)\\<rbrakk>\n       \\<Longrightarrow> R_ab (fst (fst x), snd x) (fst (fst y), snd y)", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b ba aa bb bc.\n       \\<lbrakk>if fst ((a, b), ba) = fst ((aa, bb), bc)\n                then R_b (snd (fst ((a, b), ba))) (snd ((a, b), ba))\n                      (snd ((aa, bb), bc))\n                else R_a (fst ((a, b), ba)) (fst ((aa, bb), bc));\n        m a = Some b; ba \\<in> S_b b; m aa = Some bb;\n        bc \\<in> S_b bb\\<rbrakk>\n       \\<Longrightarrow> R_ab (fst (fst ((a, b), ba)), snd ((a, b), ba))\n                          (fst (fst ((aa, bb), bc)), snd ((aa, bb), bc))", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b ba aa bb bc.\n       \\<lbrakk>if a = aa \\<and> b = bb\n                then R_b (snd (fst ((a, b), ba))) (snd ((a, b), ba))\n                      (snd ((aa, bb), bc))\n                else R_a (fst ((a, b), ba)) (fst ((aa, bb), bc));\n        m a = Some b; ba \\<in> S_b b; m aa = Some bb;\n        bc \\<in> S_b bb\\<rbrakk>\n       \\<Longrightarrow> R_ab (a, ba) (aa, bc)", "apply (unfold fst_conv snd_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b ba aa bb bc.\n       \\<lbrakk>if a = aa \\<and> b = bb then R_b b ba bc\n                else R_a (a, b) (aa, bb);\n        m a = Some b; ba \\<in> S_b b; m aa = Some bb;\n        bc \\<in> S_b bb\\<rbrakk>\n       \\<Longrightarrow> R_ab (a, ba) (aa, bc)", "apply (metis R'_prop option.inject)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<lbrakk>?x1 \\<in> {((k, v), e). m k = Some v \\<and> e \\<in> S_b v};\n   ?y1 \\<in> {((k, v), e). m k = Some v \\<and> e \\<in> S_b v};\n   set_iterator_product_order R_a (\\<lambda>kv. R_b (snd kv)) ?x1\n    ?y1\\<rbrakk>\n  \\<Longrightarrow> R_ab (fst (fst ?x1), snd ?x1) (fst (fst ?y1), snd ?y1)\n\ngoal (1 subgoal):\n 1. set_iterator_genord (map_iterator_product it_a it_b)\n     {(k, e). \\<exists>v. m k = Some v \\<and> e \\<in> S_b v} R_ab", "have \"(?g ` {((k, v), e). m k = Some v \\<and> e \\<in> S_b v}) = {(k, e). \\<exists>v. m k = Some v \\<and> e \\<in> S_b v}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>kvv'. (fst (fst kvv'), snd kvv')) `\n    {((k, v), e). m k = Some v \\<and> e \\<in> S_b v} =\n    {(k, e). \\<exists>v. m k = Some v \\<and> e \\<in> S_b v}", "by (simp add: image_iff set_eq_iff)"], ["proof (state)\nthis:\n  (\\<lambda>kvv'. (fst (fst kvv'), snd kvv')) `\n  {((k, v), e). m k = Some v \\<and> e \\<in> S_b v} =\n  {(k, e). \\<exists>v. m k = Some v \\<and> e \\<in> S_b v}\n\ngoal (1 subgoal):\n 1. set_iterator_genord (map_iterator_product it_a it_b)\n     {(k, e). \\<exists>v. m k = Some v \\<and> e \\<in> S_b v} R_ab", "with set_iterator_genord_image_correct [OF it_ab' inj_g, of R_ab, OF R_ab_OK]"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>x y.\n              \\<lbrakk>x \\<in> {((k, v), e).\n                                m k = Some v \\<and> e \\<in> S_b v};\n               y \\<in> {((k, v), e). m k = Some v \\<and> e \\<in> S_b v};\n               set_iterator_product_order R_a (\\<lambda>kv. R_b (snd kv)) x\n                y\\<rbrakk>\n              \\<Longrightarrow> x \\<in> {((k, v), e).\n   m k = Some v \\<and> e \\<in> S_b v};\n   \\<And>x y.\n      \\<lbrakk>x \\<in> {((k, v), e). m k = Some v \\<and> e \\<in> S_b v};\n       y \\<in> {((k, v), e). m k = Some v \\<and> e \\<in> S_b v};\n       set_iterator_product_order R_a (\\<lambda>kv. R_b (snd kv)) x\n        y\\<rbrakk>\n      \\<Longrightarrow> y \\<in> {((k, v), e).\n                                 m k = Some v \\<and> e \\<in> S_b v};\n   \\<And>x y.\n      \\<lbrakk>x \\<in> {((k, v), e). m k = Some v \\<and> e \\<in> S_b v};\n       y \\<in> {((k, v), e). m k = Some v \\<and> e \\<in> S_b v};\n       set_iterator_product_order R_a (\\<lambda>kv. R_b (snd kv)) x\n        y\\<rbrakk>\n      \\<Longrightarrow> set_iterator_product_order R_a\n                         (\\<lambda>kv. R_b (snd kv)) x y\\<rbrakk>\n  \\<Longrightarrow> set_iterator_genord\n                     (set_iterator_image\n                       (\\<lambda>kvv'. (fst (fst kvv'), snd kvv'))\n                       (set_iterator_product it_a\n                         (\\<lambda>kv. it_b (snd kv))))\n                     ((\\<lambda>kvv'. (fst (fst kvv'), snd kvv')) `\n                      {((k, v), e). m k = Some v \\<and> e \\<in> S_b v})\n                     R_ab\n  (\\<lambda>kvv'. (fst (fst kvv'), snd kvv')) `\n  {((k, v), e). m k = Some v \\<and> e \\<in> S_b v} =\n  {(k, e). \\<exists>v. m k = Some v \\<and> e \\<in> S_b v}", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x y.\n              \\<lbrakk>x \\<in> {((k, v), e).\n                                m k = Some v \\<and> e \\<in> S_b v};\n               y \\<in> {((k, v), e). m k = Some v \\<and> e \\<in> S_b v};\n               set_iterator_product_order R_a (\\<lambda>kv. R_b (snd kv)) x\n                y\\<rbrakk>\n              \\<Longrightarrow> x \\<in> {((k, v), e).\n   m k = Some v \\<and> e \\<in> S_b v};\n   \\<And>x y.\n      \\<lbrakk>x \\<in> {((k, v), e). m k = Some v \\<and> e \\<in> S_b v};\n       y \\<in> {((k, v), e). m k = Some v \\<and> e \\<in> S_b v};\n       set_iterator_product_order R_a (\\<lambda>kv. R_b (snd kv)) x\n        y\\<rbrakk>\n      \\<Longrightarrow> y \\<in> {((k, v), e).\n                                 m k = Some v \\<and> e \\<in> S_b v};\n   \\<And>x y.\n      \\<lbrakk>x \\<in> {((k, v), e). m k = Some v \\<and> e \\<in> S_b v};\n       y \\<in> {((k, v), e). m k = Some v \\<and> e \\<in> S_b v};\n       set_iterator_product_order R_a (\\<lambda>kv. R_b (snd kv)) x\n        y\\<rbrakk>\n      \\<Longrightarrow> set_iterator_product_order R_a\n                         (\\<lambda>kv. R_b (snd kv)) x y\\<rbrakk>\n  \\<Longrightarrow> set_iterator_genord\n                     (set_iterator_image\n                       (\\<lambda>kvv'. (fst (fst kvv'), snd kvv'))\n                       (set_iterator_product it_a\n                         (\\<lambda>kv. it_b (snd kv))))\n                     ((\\<lambda>kvv'. (fst (fst kvv'), snd kvv')) `\n                      {((k, v), e). m k = Some v \\<and> e \\<in> S_b v})\n                     R_ab\n  (\\<lambda>kvv'. (fst (fst kvv'), snd kvv')) `\n  {((k, v), e). m k = Some v \\<and> e \\<in> S_b v} =\n  {(k, e). \\<exists>v. m k = Some v \\<and> e \\<in> S_b v}\n\ngoal (1 subgoal):\n 1. set_iterator_genord (map_iterator_product it_a it_b)\n     {(k, e). \\<exists>v. m k = Some v \\<and> e \\<in> S_b v} R_ab", "by (simp add: map_iterator_product_def)"], ["proof (state)\nthis:\n  set_iterator_genord (map_iterator_product it_a it_b)\n   {(k, e). \\<exists>v. m k = Some v \\<and> e \\<in> S_b v} R_ab\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_iterator_product_correct :\n  assumes it_a: \"map_iterator it_a m\"\n  assumes it_b: \"\\<And>k v. m k = Some v \\<Longrightarrow> set_iterator (it_b v) (S_b v)\"\n  shows \"set_iterator (map_iterator_product it_a it_b) \n         {(k, e) . (\\<exists>v. m k = Some v \\<and> e \\<in> S_b v)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator (map_iterator_product it_a it_b)\n     {(k, e). \\<exists>v. m k = Some v \\<and> e \\<in> S_b v}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set_iterator (map_iterator_product it_a it_b)\n     {(k, e). \\<exists>v. m k = Some v \\<and> e \\<in> S_b v}", "note res' = map_iterator_genord_product_correct [OF it_a[unfolded set_iterator_def], \n     of it_b S_b \"\\<lambda>_ _ _. True\"]"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>k v.\n              m k = Some v \\<Longrightarrow>\n              set_iterator_genord (it_b v) (S_b v) (\\<lambda>_ _. True);\n   \\<And>k v u k' v' u'.\n      \\<lbrakk>m k = Some v; u \\<in> S_b v; m k' = Some v'; u' \\<in> S_b v';\n       if k = k' then True else True\\<rbrakk>\n      \\<Longrightarrow> ?R_ab (k, u) (k', u')\\<rbrakk>\n  \\<Longrightarrow> set_iterator_genord (map_iterator_product it_a it_b)\n                     {(k, e). \\<exists>v. m k = Some v \\<and> e \\<in> S_b v}\n                     ?R_ab\n\ngoal (1 subgoal):\n 1. set_iterator (map_iterator_product it_a it_b)\n     {(k, e). \\<exists>v. m k = Some v \\<and> e \\<in> S_b v}", "note res = set_iterator_intro [OF res']"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>k v.\n              m k = Some v \\<Longrightarrow>\n              set_iterator_genord (it_b v) (S_b v) (\\<lambda>_ _. True);\n   \\<And>k v u k' v' u'.\n      \\<lbrakk>m k = Some v; u \\<in> S_b v; m k' = Some v'; u' \\<in> S_b v';\n       if k = k' then True else True\\<rbrakk>\n      \\<Longrightarrow> ?R (k, u) (k', u')\\<rbrakk>\n  \\<Longrightarrow> set_iterator (map_iterator_product it_a it_b)\n                     {(k, e). \\<exists>v. m k = Some v \\<and> e \\<in> S_b v}\n\ngoal (1 subgoal):\n 1. set_iterator (map_iterator_product it_a it_b)\n     {(k, e). \\<exists>v. m k = Some v \\<and> e \\<in> S_b v}", "with it_b"], ["proof (chain)\npicking this:\n  m ?k = Some ?v \\<Longrightarrow> set_iterator (it_b ?v) (S_b ?v)\n  \\<lbrakk>\\<And>k v.\n              m k = Some v \\<Longrightarrow>\n              set_iterator_genord (it_b v) (S_b v) (\\<lambda>_ _. True);\n   \\<And>k v u k' v' u'.\n      \\<lbrakk>m k = Some v; u \\<in> S_b v; m k' = Some v'; u' \\<in> S_b v';\n       if k = k' then True else True\\<rbrakk>\n      \\<Longrightarrow> ?R (k, u) (k', u')\\<rbrakk>\n  \\<Longrightarrow> set_iterator (map_iterator_product it_a it_b)\n                     {(k, e). \\<exists>v. m k = Some v \\<and> e \\<in> S_b v}", "show ?thesis"], ["proof (prove)\nusing this:\n  m ?k = Some ?v \\<Longrightarrow> set_iterator (it_b ?v) (S_b ?v)\n  \\<lbrakk>\\<And>k v.\n              m k = Some v \\<Longrightarrow>\n              set_iterator_genord (it_b v) (S_b v) (\\<lambda>_ _. True);\n   \\<And>k v u k' v' u'.\n      \\<lbrakk>m k = Some v; u \\<in> S_b v; m k' = Some v'; u' \\<in> S_b v';\n       if k = k' then True else True\\<rbrakk>\n      \\<Longrightarrow> ?R (k, u) (k', u')\\<rbrakk>\n  \\<Longrightarrow> set_iterator (map_iterator_product it_a it_b)\n                     {(k, e). \\<exists>v. m k = Some v \\<and> e \\<in> S_b v}\n\ngoal (1 subgoal):\n 1. set_iterator (map_iterator_product it_a it_b)\n     {(k, e). \\<exists>v. m k = Some v \\<and> e \\<in> S_b v}", "unfolding set_iterator_def"], ["proof (prove)\nusing this:\n  m ?k = Some ?v \\<Longrightarrow>\n  set_iterator_genord (it_b ?v) (S_b ?v) (\\<lambda>_ _. True)\n  \\<lbrakk>\\<And>k v.\n              m k = Some v \\<Longrightarrow>\n              set_iterator_genord (it_b v) (S_b v) (\\<lambda>_ _. True);\n   \\<And>k v u k' v' u'.\n      \\<lbrakk>m k = Some v; u \\<in> S_b v; m k' = Some v'; u' \\<in> S_b v';\n       if k = k' then True else True\\<rbrakk>\n      \\<Longrightarrow> ?R (k, u) (k', u')\\<rbrakk>\n  \\<Longrightarrow> set_iterator_genord (map_iterator_product it_a it_b)\n                     {(k, e). \\<exists>v. m k = Some v \\<and> e \\<in> S_b v}\n                     (\\<lambda>_ _. True)\n\ngoal (1 subgoal):\n 1. set_iterator_genord (map_iterator_product it_a it_b)\n     {(k, e). \\<exists>v. m k = Some v \\<and> e \\<in> S_b v}\n     (\\<lambda>_ _. True)", "by simp"], ["proof (state)\nthis:\n  set_iterator (map_iterator_product it_a it_b)\n   {(k, e). \\<exists>v. m k = Some v \\<and> e \\<in> S_b v}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection\\<open>Key Filter\\<close>"], ["", "definition map_iterator_key_filter ::\n    \"('a \\<Rightarrow> bool) \\<Rightarrow> ('a \\<times> 'b,'\\<sigma>) set_iterator \\<Rightarrow> ('a \\<times> 'b,'\\<sigma>) set_iterator\" where\n  \"map_iterator_key_filter P \\<equiv> set_iterator_filter (P \\<circ> fst)\""], ["", "lemma map_iterator_key_filter_foldli_conv :\n  \"map_iterator_key_filter P (foldli kvs) =  foldli (filter (\\<lambda>(k, v). P k) kvs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_iterator_key_filter P (foldli kvs) =\n    foldli (filter (\\<lambda>(k, v). P k) kvs)", "unfolding map_iterator_key_filter_def set_iterator_filter_foldli_conv o_def split_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli (filter (\\<lambda>x. P (fst x)) kvs) =\n    foldli (filter (\\<lambda>p. P (fst p)) kvs)", "by simp"], ["", "lemma map_iterator_key_filter_alt_def [code] :\n  \"map_iterator_key_filter P it = (\\<lambda>c f. it c (\\<lambda>x \\<sigma>. if P (fst x) then f x \\<sigma> else \\<sigma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_iterator_key_filter P it =\n    (\\<lambda>c f.\n        it c\n         (\\<lambda>x \\<sigma>.\n             if P (fst x) then f x \\<sigma> else \\<sigma>))", "unfolding map_iterator_key_filter_def set_iterator_filter_alt_def\n  set_iterator_image_filter_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>c f.\n        it c\n         (\\<lambda>x \\<sigma>.\n             if (P \\<circ> fst) x then f x \\<sigma> else \\<sigma>)) =\n    (\\<lambda>c f.\n        it c\n         (\\<lambda>x \\<sigma>.\n             if P (fst x) then f x \\<sigma> else \\<sigma>))", "by simp"], ["", "lemma map_iterator_genord_key_filter_correct :\n  fixes it :: \"('a \\<times> 'b, '\\<sigma>) set_iterator\"\n  assumes it_OK: \"map_iterator_genord it m R\"\n  shows \"map_iterator_genord (map_iterator_key_filter P it) (m |` {k . P k}) R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_iterator_genord (map_iterator_key_filter P it) (m |` {k. P k}) R", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map_iterator_genord (map_iterator_key_filter P it) (m |` {k. P k}) R", "from set_iterator_genord_filter_correct [OF it_OK, of \"P \\<circ> fst\", \n    folded map_iterator_key_filter_def]"], ["proof (chain)\npicking this:\n  set_iterator_genord (map_iterator_key_filter P it)\n   {x \\<in> map_to_set m. (P \\<circ> fst) x} R", "have step1: \"set_iterator_genord (map_iterator_key_filter P it)\n                  {x \\<in> map_to_set m. (P \\<circ> fst) x} R\""], ["proof (prove)\nusing this:\n  set_iterator_genord (map_iterator_key_filter P it)\n   {x \\<in> map_to_set m. (P \\<circ> fst) x} R\n\ngoal (1 subgoal):\n 1. set_iterator_genord (map_iterator_key_filter P it)\n     {x \\<in> map_to_set m. (P \\<circ> fst) x} R", "by simp"], ["proof (state)\nthis:\n  set_iterator_genord (map_iterator_key_filter P it)\n   {x \\<in> map_to_set m. (P \\<circ> fst) x} R\n\ngoal (1 subgoal):\n 1. map_iterator_genord (map_iterator_key_filter P it) (m |` {k. P k}) R", "have \"{x \\<in> map_to_set m. (P \\<circ> fst) x} = map_to_set (m |` {k . P k})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x \\<in> map_to_set m. (P \\<circ> fst) x} = map_to_set (m |` {k. P k})", "unfolding map_to_set_def restrict_map_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x \\<in> {(k, v). m k = Some v}. (P \\<circ> fst) x} =\n    {(k, v). (if k \\<in> Collect P then m k else None) = Some v}", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  {x \\<in> map_to_set m. (P \\<circ> fst) x} = map_to_set (m |` {k. P k})\n\ngoal (1 subgoal):\n 1. map_iterator_genord (map_iterator_key_filter P it) (m |` {k. P k}) R", "with step1"], ["proof (chain)\npicking this:\n  set_iterator_genord (map_iterator_key_filter P it)\n   {x \\<in> map_to_set m. (P \\<circ> fst) x} R\n  {x \\<in> map_to_set m. (P \\<circ> fst) x} = map_to_set (m |` {k. P k})", "show ?thesis"], ["proof (prove)\nusing this:\n  set_iterator_genord (map_iterator_key_filter P it)\n   {x \\<in> map_to_set m. (P \\<circ> fst) x} R\n  {x \\<in> map_to_set m. (P \\<circ> fst) x} = map_to_set (m |` {k. P k})\n\ngoal (1 subgoal):\n 1. map_iterator_genord (map_iterator_key_filter P it) (m |` {k. P k}) R", "by simp"], ["proof (state)\nthis:\n  map_iterator_genord (map_iterator_key_filter P it) (m |` {k. P k}) R\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_iterator_key_filter_correct :\n  assumes it_OK: \"map_iterator it m\"\n  shows \"set_iterator (map_iterator_key_filter P it) (map_to_set (m |` {k . P k}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_iterator (map_iterator_key_filter P it) (m |` {k. P k})", "using assms"], ["proof (prove)\nusing this:\n  map_iterator it m\n\ngoal (1 subgoal):\n 1. map_iterator (map_iterator_key_filter P it) (m |` {k. P k})", "unfolding set_iterator_def"], ["proof (prove)\nusing this:\n  map_iterator_genord it m (\\<lambda>_ _. True)\n\ngoal (1 subgoal):\n 1. map_iterator_genord (map_iterator_key_filter P it) (m |` Collect P)\n     (\\<lambda>_ _. True)", "apply (rule_tac map_iterator_genord_key_filter_correct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_iterator_genord it m (\\<lambda>_ _. True) \\<Longrightarrow>\n    map_iterator_genord it m (\\<lambda>_ _. True)", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}