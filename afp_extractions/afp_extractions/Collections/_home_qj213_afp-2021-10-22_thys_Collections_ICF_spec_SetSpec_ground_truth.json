{"file_name": "/home/qj213/afp-2021-10-22/thys/Collections/ICF/spec/SetSpec.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Collections", "problem_names": ["lemma isSng_correct_exists1 :\n    \"invar s \\<Longrightarrow> (isSng s \\<longleftrightarrow> (\\<exists>!e. (e \\<in> \\<alpha> s)))\"", "lemma isSng_correct_card :\n    \"invar s \\<Longrightarrow> (isSng s \\<longleftrightarrow> (card (\\<alpha> s) = 1))\"", "lemma iteratei_correct: \"invar S \\<Longrightarrow> set_iterator (iteratei S) (\\<alpha> S)\"", "lemma pi_iteratei[icf_proper_iteratorI]: \n    \"proper_it (iteratei S) (iteratei S)\"", "lemma iteratei_rule_P:\n    \"\\<lbrakk>\n      invar S;\n      I (\\<alpha> S) \\<sigma>0;\n      !!x it \\<sigma>. \\<lbrakk> c \\<sigma>; x \\<in> it; it \\<subseteq> \\<alpha> S; I it \\<sigma> \\<rbrakk> \\<Longrightarrow> I (it - {x}) (f x \\<sigma>);\n      !!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>;\n      !!\\<sigma> it. \\<lbrakk> it \\<subseteq> \\<alpha> S; it \\<noteq> {}; \\<not> c \\<sigma>; I it \\<sigma> \\<rbrakk> \\<Longrightarrow> P \\<sigma>\n    \\<rbrakk> \\<Longrightarrow> P (iteratei S c f \\<sigma>0)\"", "lemma iteratei_rule_insert_P:\n    \"\\<lbrakk>\n      invar S;\n      I {} \\<sigma>0;\n      !!x it \\<sigma>. \\<lbrakk> c \\<sigma>; x \\<in> \\<alpha> S - it; it \\<subseteq> \\<alpha> S; I it \\<sigma> \\<rbrakk> \\<Longrightarrow> I (insert x it) (f x \\<sigma>);\n      !!\\<sigma>. I (\\<alpha> S) \\<sigma> \\<Longrightarrow> P \\<sigma>;\n      !!\\<sigma> it. \\<lbrakk> it \\<subseteq> \\<alpha> S; it \\<noteq> \\<alpha> S; \\<not> c \\<sigma>; I it \\<sigma> \\<rbrakk> \\<Longrightarrow> P \\<sigma>\n    \\<rbrakk> \\<Longrightarrow> P (iteratei S c f \\<sigma>0)\"", "lemma iterate_rule_P:\n    \"\\<lbrakk>\n      invar S;\n      I (\\<alpha> S) \\<sigma>0;\n      !!x it \\<sigma>. \\<lbrakk> x \\<in> it; it \\<subseteq> \\<alpha> S; I it \\<sigma> \\<rbrakk> \\<Longrightarrow> I (it - {x}) (f x \\<sigma>);\n      !!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\n    \\<rbrakk> \\<Longrightarrow> P (iteratei S (\\<lambda>_. True) f \\<sigma>0)\"", "lemma iterate_rule_insert_P:\n    \"\\<lbrakk>\n      invar S;\n      I {} \\<sigma>0;\n      !!x it \\<sigma>. \\<lbrakk> x \\<in> \\<alpha> S - it; it \\<subseteq> \\<alpha> S; I it \\<sigma> \\<rbrakk> \\<Longrightarrow> I (insert x it) (f x \\<sigma>);\n      !!\\<sigma>. I (\\<alpha> S) \\<sigma> \\<Longrightarrow> P \\<sigma>\n    \\<rbrakk> \\<Longrightarrow> P (iteratei S (\\<lambda>_. True) f \\<sigma>0)\"", "lemma image_filter_correct_aux2: \n    \"invar1 s \\<Longrightarrow> \n    \\<alpha>2 (image_filter (\\<lambda>x. if P x then (Some (f x)) else None) s) \n    = f ` {x\\<in>\\<alpha>1 s. P x}\"", "lemmas image_filter_correct = \n    image_filter_correct_aux2 image_filter_correct_aux", "lemma disjoint_witness_None: \"\\<lbrakk>invar1 s1; invar2 s2\\<rbrakk> \n    \\<Longrightarrow> disjoint_witness s1 s2 = None \\<longleftrightarrow> \\<alpha>1 s1 \\<inter> \\<alpha>2 s2 = {}\"", "lemma disjoint_witnessI: \"\\<lbrakk>\n    invar1 s1; \n    invar2 s2; \n    \\<alpha>1 s1 \\<inter> \\<alpha>2 s2 \\<noteq> {}; \n    !!a. \\<lbrakk>disjoint_witness s1 s2 = Some a\\<rbrakk> \\<Longrightarrow> P \n                            \\<rbrakk> \\<Longrightarrow> P\"", "lemma sel_someD:\n    \"\\<lbrakk> invar s; sel s f = Some r; !!x. \\<lbrakk>x\\<in>\\<alpha> s; f x = Some r\\<rbrakk> \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\"", "lemma sel_noneD: \n    \"\\<lbrakk> invar s; sel s f = None; x\\<in>\\<alpha> s \\<rbrakk> \\<Longrightarrow> f x = None\"", "lemma sel'_someD:\n    \"\\<lbrakk> invar s; sel' s P = Some x \\<rbrakk> \\<Longrightarrow> x\\<in>\\<alpha> s \\<and> P x\"", "lemma sel'_noneD: \n    \"\\<lbrakk> invar s; sel' s P = None; x\\<in>\\<alpha> s \\<rbrakk> \\<Longrightarrow> \\<not>P x\"", "lemma iterateoi_correct: \n    \"invar S \\<Longrightarrow> set_iterator_linord (iterateoi S) (\\<alpha> S)\"", "lemma pi_iterateoi[icf_proper_iteratorI]: \n    \"proper_it (iterateoi S) (iterateoi S)\"", "lemma iterateoi_rule_P[case_names minv inv0 inv_pres i_complete i_inter]:\n    assumes MINV: \"invar s\"\n    assumes I0: \"I (\\<alpha> s) \\<sigma>0\"\n    assumes IP: \"!!k it \\<sigma>. \\<lbrakk> \n      c \\<sigma>; \n      k \\<in> it; \n      \\<forall>j\\<in>it. k\\<le>j; \n      \\<forall>j\\<in>\\<alpha> s - it. j\\<le>k; \n      it \\<subseteq> \\<alpha> s; \n      I it \\<sigma> \n    \\<rbrakk> \\<Longrightarrow> I (it - {k}) (f k \\<sigma>)\"\n    assumes IF: \"!!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n    assumes II: \"!!\\<sigma> it. \\<lbrakk> \n      it \\<subseteq> \\<alpha> s; \n      it \\<noteq> {}; \n      \\<not> c \\<sigma>; \n      I it \\<sigma>; \n      \\<forall>k\\<in>it. \\<forall>j\\<in>\\<alpha> s - it. j\\<le>k \n    \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n    shows \"P (iterateoi s c f \\<sigma>0)\"", "lemma iterateo_rule_P[case_names minv inv0 inv_pres i_complete]: \n    assumes MINV: \"invar s\"\n    assumes I0: \"I ((\\<alpha> s)) \\<sigma>0\"\n    assumes IP: \"!!k it \\<sigma>. \\<lbrakk> k \\<in> it; \\<forall>j\\<in>it. k\\<le>j; \n        \\<forall>j\\<in>(\\<alpha> s) - it. j\\<le>k; it \\<subseteq> (\\<alpha> s); I it \\<sigma> \\<rbrakk> \n      \\<Longrightarrow> I (it - {k}) (f k \\<sigma>)\"\n    assumes IF: \"!!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n  shows \"P (iterateo s f \\<sigma>0)\"", "lemma rev_iterateoi_correct: \n    \"invar S \\<Longrightarrow> set_iterator_rev_linord (rev_iterateoi S) (\\<alpha> S)\"", "lemma pi_rev_iterateoi[icf_proper_iteratorI]: \n    \"proper_it (rev_iterateoi S) (rev_iterateoi S)\"", "lemma rev_iterateoi_rule_P[case_names minv inv0 inv_pres i_complete i_inter]:\n    assumes MINV: \"invar s\"\n    assumes I0: \"I ((\\<alpha> s)) \\<sigma>0\"\n    assumes IP: \"!!k it \\<sigma>. \\<lbrakk> \n      c \\<sigma>; \n      k \\<in> it; \n      \\<forall>j\\<in>it. k\\<ge>j; \n      \\<forall>j\\<in>(\\<alpha> s) - it. j\\<ge>k; \n      it \\<subseteq> (\\<alpha> s); \n      I it \\<sigma> \n    \\<rbrakk> \\<Longrightarrow> I (it - {k}) (f k \\<sigma>)\"\n    assumes IF: \"!!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n    assumes II: \"!!\\<sigma> it. \\<lbrakk> \n      it \\<subseteq> (\\<alpha> s); \n      it \\<noteq> {}; \n      \\<not> c \\<sigma>; \n      I it \\<sigma>; \n      \\<forall>k\\<in>it. \\<forall>j\\<in>(\\<alpha> s) - it. j\\<ge>k \n    \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n  shows \"P (rev_iterateoi s c f \\<sigma>0)\"", "lemma reverse_iterateo_rule_P[case_names minv inv0 inv_pres i_complete]:\n    assumes MINV: \"invar s\"\n    assumes I0: \"I ((\\<alpha> s)) \\<sigma>0\"\n    assumes IP: \"!!k it \\<sigma>. \\<lbrakk> \n      k \\<in> it; \n      \\<forall>j\\<in>it. k\\<ge>j; \n      \\<forall>j\\<in> (\\<alpha> s) - it. j\\<ge>k; \n      it \\<subseteq> (\\<alpha> s); \n      I it \\<sigma> \n    \\<rbrakk> \\<Longrightarrow> I (it - {k}) (f k \\<sigma>)\"\n    assumes IF: \"!!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n  shows \"P (rev_iterateo s f \\<sigma>0)\"", "lemma minE: \n     assumes A: \"invar s\" \"x\\<in>\\<alpha> s\" \"P x\"\n     obtains x' where\n     \"min s P = Some x'\" \"x'\\<in>\\<alpha> s\" \"P x'\" \"\\<forall>x\\<in>\\<alpha> s. P x \\<longrightarrow> x' \\<le> x\"", "lemmas minI = min_correct(3)", "lemma min_Some:\n     \"\\<lbrakk> invar s; min s P = Some x \\<rbrakk> \\<Longrightarrow> x\\<in>\\<alpha> s\"\n     \"\\<lbrakk> invar s; min s P = Some x \\<rbrakk> \\<Longrightarrow> P x\"\n     \"\\<lbrakk> invar s; min s P = Some x; x'\\<in>\\<alpha> s; P x'\\<rbrakk> \\<Longrightarrow> x\\<le>x'\"", "lemma min_None:\n     \"\\<lbrakk> invar s; min s P = None \\<rbrakk> \\<Longrightarrow> {x\\<in>\\<alpha> s. P x} = {}\"", "lemma maxE: \n     assumes A: \"invar s\" \"x\\<in>\\<alpha> s\" \"P x\"\n     obtains x' where\n     \"max s P = Some x'\" \"x'\\<in>\\<alpha> s\" \"P x'\" \"\\<forall>x\\<in>\\<alpha> s. P x \\<longrightarrow> x' \\<ge> x\"", "lemmas maxI = max_correct(3)", "lemma max_Some:\n     \"\\<lbrakk> invar s; max s P = Some x \\<rbrakk> \\<Longrightarrow> x\\<in>\\<alpha> s\"\n     \"\\<lbrakk> invar s; max s P = Some x \\<rbrakk> \\<Longrightarrow> P x\"\n     \"\\<lbrakk> invar s; max s P = Some x; x'\\<in>\\<alpha> s; P x'\\<rbrakk> \\<Longrightarrow> x\\<ge>x'\"", "lemma max_None:\n     \"\\<lbrakk> invar s; max s P = None \\<rbrakk> \\<Longrightarrow> {x\\<in>\\<alpha> s. P x} = {}\"", "lemmas correct = \n      empty_correct\n      sng_correct\n      memb_correct\n      ins_correct\n      ins_dj_correct\n      delete_correct\n      isEmpty_correct\n      isSng_correct\n      ball_correct\n      bex_correct\n      size_correct\n      size_abort_correct\n      union_correct\n      union_dj_correct\n      diff_correct\n      filter_correct\n      inter_correct\n      subset_correct\n      equal_correct\n      disjoint_correct\n      disjoint_witness_correct\n      to_list_correct\n      to_set_correct", "lemmas StdSet_intro = StdSet.intro[rem_dup_prems]", "lemmas StdOSet_intro =\n    StdOSet.intro[OF StdSet_intro, rem_dup_prems]"], "translations": [["", "lemma isSng_correct_exists1 :\n    \"invar s \\<Longrightarrow> (isSng s \\<longleftrightarrow> (\\<exists>!e. (e \\<in> \\<alpha> s)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar s \\<Longrightarrow> isSng s = (\\<exists>!e. e \\<in> \\<alpha> s)", "by (auto simp add: isSng_correct)"], ["", "lemma isSng_correct_card :\n    \"invar s \\<Longrightarrow> (isSng s \\<longleftrightarrow> (card (\\<alpha> s) = 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar s \\<Longrightarrow> isSng s = (card (\\<alpha> s) = 1)", "by (auto simp add: isSng_correct card_Suc_eq)"], ["", "end"], ["", "subsection \"Iterators\""], ["", "text \\<open>\n  An iterator applies a\n  function to a state and all the elements of the set.\n  The function is applied in any order. Proofs over the iteration are\n  done by establishing invariants over the iteration.\n  Iterators may have a break-condition, that interrupts the iteration before\n  the last element has been visited.\n\\<close>"], ["", "(* Deprecated *)\n(*\nlocale set_iteratei = finite_set +\n  constrains \\<alpha> :: \"'s \\<Rightarrow> 'x set\"\n  fixes iteratei :: \"'s \\<Rightarrow> ('x, '\\<sigma>) set_iterator\"\n\n  assumes iteratei_rule: \"invar S \\<Longrightarrow> set_iterator (iteratei S) (\\<alpha> S)\"\nbegin\n  lemma iteratei_rule_P:\n    \"\\<lbrakk>\n      invar S;\n      I (\\<alpha> S) \\<sigma>0;\n      !!x it \\<sigma>. \\<lbrakk> c \\<sigma>; x \\<in> it; it \\<subseteq> \\<alpha> S; I it \\<sigma> \\<rbrakk> \\<Longrightarrow> I (it - {x}) (f x \\<sigma>);\n      !!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>;\n      !!\\<sigma> it. \\<lbrakk> it \\<subseteq> \\<alpha> S; it \\<noteq> {}; \\<not> c \\<sigma>; I it \\<sigma> \\<rbrakk> \\<Longrightarrow> P \\<sigma>\n    \\<rbrakk> \\<Longrightarrow> P (iteratei S c f \\<sigma>0)\"\n   apply (rule set_iterator_rule_P [OF iteratei_rule, of S I \\<sigma>0 c f P])\n   apply simp_all\n  done\n\n  lemma iteratei_rule_insert_P:\n    \"\\<lbrakk>\n      invar S;\n      I {} \\<sigma>0;\n      !!x it \\<sigma>. \\<lbrakk> c \\<sigma>; x \\<in> \\<alpha> S - it; it \\<subseteq> \\<alpha> S; I it \\<sigma> \\<rbrakk> \\<Longrightarrow> I (insert x it) (f x \\<sigma>);\n      !!\\<sigma>. I (\\<alpha> S) \\<sigma> \\<Longrightarrow> P \\<sigma>;\n      !!\\<sigma> it. \\<lbrakk> it \\<subseteq> \\<alpha> S; it \\<noteq> \\<alpha> S; \\<not> c \\<sigma>; I it \\<sigma> \\<rbrakk> \\<Longrightarrow> P \\<sigma>\n    \\<rbrakk> \\<Longrightarrow> P (iteratei S c f \\<sigma>0)\"\n    apply (rule set_iterator_rule_insert_P [OF iteratei_rule, of S I \\<sigma>0 c f P])\n    apply simp_all\n  done\n\n  text {* Versions without break condition. *}\n  lemma iterate_rule_P:\n    \"\\<lbrakk>\n      invar S;\n      I (\\<alpha> S) \\<sigma>0;\n      !!x it \\<sigma>. \\<lbrakk> x \\<in> it; it \\<subseteq> \\<alpha> S; I it \\<sigma> \\<rbrakk> \\<Longrightarrow> I (it - {x}) (f x \\<sigma>);\n      !!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\n    \\<rbrakk> \\<Longrightarrow> P (iteratei S (\\<lambda>_. True) f \\<sigma>0)\"\n   apply (rule set_iterator_no_cond_rule_P [OF iteratei_rule, of S I \\<sigma>0 f P])\n   apply simp_all\n  done\n\n  lemma iterate_rule_insert_P:\n    \"\\<lbrakk>\n      invar S;\n      I {} \\<sigma>0;\n      !!x it \\<sigma>. \\<lbrakk> x \\<in> \\<alpha> S - it; it \\<subseteq> \\<alpha> S; I it \\<sigma> \\<rbrakk> \\<Longrightarrow> I (insert x it) (f x \\<sigma>);\n      !!\\<sigma>. I (\\<alpha> S) \\<sigma> \\<Longrightarrow> P \\<sigma>\n    \\<rbrakk> \\<Longrightarrow> P (iteratei S (\\<lambda>_. True) f \\<sigma>0)\"\n    apply (rule set_iterator_no_cond_rule_insert_P [OF iteratei_rule, of S I \\<sigma>0 f P])\n    apply simp_all\n  done\nend\n\nlemma set_iteratei_I :\nassumes \"\\<And>s. invar s \\<Longrightarrow> set_iterator (iti s) (\\<alpha> s)\"\nshows \"set_iteratei \\<alpha> invar iti\"\nproof\n  fix s \n  assume invar_s: \"invar s\"\n  from assms(1)[OF invar_s] show it_OK: \"set_iterator (iti s) (\\<alpha> s)\" .\n  \n  from set_iterator_genord.finite_S0 [OF it_OK[unfolded set_iterator_def]]\n  show \"finite (\\<alpha> s)\" .\nqed\n*)"], ["", "type_synonym ('x,'s) set_list_it\n  = \"'s \\<Rightarrow> ('x,'x list) set_iterator\""], ["", "locale poly_set_iteratei_defs =\n  fixes list_it :: \"'s \\<Rightarrow> ('x,'x list) set_iterator\"\nbegin"], ["", "definition iteratei :: \"'s \\<Rightarrow> ('x,'\\<sigma>) set_iterator\"\n    where \"iteratei S \\<equiv> it_to_it (list_it S)\""], ["", "(*local_setup {* Locale_Code.lc_decl_del @{term iteratei} *}*)"], ["", "abbreviation \"iterate s \\<equiv> iteratei s (\\<lambda>_. True)\""], ["", "end"], ["", "locale poly_set_iteratei =\n  finite_set + poly_set_iteratei_defs list_it\n  for list_it :: \"'s \\<Rightarrow> ('x,'x list) set_iterator\" +\n  constrains \\<alpha> :: \"'s \\<Rightarrow> 'x set\"\n  assumes list_it_correct: \"invar s \\<Longrightarrow> set_iterator (list_it s) (\\<alpha> s)\"\nbegin"], ["", "lemma iteratei_correct: \"invar S \\<Longrightarrow> set_iterator (iteratei S) (\\<alpha> S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar S \\<Longrightarrow> set_iterator (iteratei S) (\\<alpha> S)", "unfolding iteratei_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. invar S \\<Longrightarrow>\n    set_iterator (it_to_it (list_it S)) (\\<alpha> S)", "apply (rule it_to_it_correct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. invar S \\<Longrightarrow> set_iterator (list_it S) (\\<alpha> S)", "by (rule list_it_correct)"], ["", "lemma pi_iteratei[icf_proper_iteratorI]: \n    \"proper_it (iteratei S) (iteratei S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it (iteratei S) (iteratei S)", "unfolding iteratei_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it (it_to_it (list_it S)) (it_to_it (list_it S))", "by (intro icf_proper_iteratorI)"], ["", "lemma iteratei_rule_P:\n    \"\\<lbrakk>\n      invar S;\n      I (\\<alpha> S) \\<sigma>0;\n      !!x it \\<sigma>. \\<lbrakk> c \\<sigma>; x \\<in> it; it \\<subseteq> \\<alpha> S; I it \\<sigma> \\<rbrakk> \\<Longrightarrow> I (it - {x}) (f x \\<sigma>);\n      !!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>;\n      !!\\<sigma> it. \\<lbrakk> it \\<subseteq> \\<alpha> S; it \\<noteq> {}; \\<not> c \\<sigma>; I it \\<sigma> \\<rbrakk> \\<Longrightarrow> P \\<sigma>\n    \\<rbrakk> \\<Longrightarrow> P (iteratei S c f \\<sigma>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar S; I (\\<alpha> S) \\<sigma>0;\n     \\<And>x it \\<sigma>.\n        \\<lbrakk>c \\<sigma>; x \\<in> it; it \\<subseteq> \\<alpha> S;\n         I it \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> I (it - {x}) (f x \\<sigma>);\n     \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>;\n     \\<And>\\<sigma> it.\n        \\<lbrakk>it \\<subseteq> \\<alpha> S; it \\<noteq> {};\n         \\<not> c \\<sigma>; I it \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> P (iteratei S c f \\<sigma>0)", "apply (rule set_iterator_rule_P [OF iteratei_correct, of S I \\<sigma>0 c f P])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>invar S; I (\\<alpha> S) \\<sigma>0;\n     \\<And>x it \\<sigma>.\n        \\<lbrakk>c \\<sigma>; x \\<in> it; it \\<subseteq> \\<alpha> S;\n         I it \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> I (it - {x}) (f x \\<sigma>);\n     \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>;\n     \\<And>\\<sigma> it.\n        \\<lbrakk>it \\<subseteq> \\<alpha> S; it \\<noteq> {};\n         \\<not> c \\<sigma>; I it \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> invar S\n 2. \\<lbrakk>invar S; I (\\<alpha> S) \\<sigma>0;\n     \\<And>x it \\<sigma>.\n        \\<lbrakk>c \\<sigma>; x \\<in> it; it \\<subseteq> \\<alpha> S;\n         I it \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> I (it - {x}) (f x \\<sigma>);\n     \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>;\n     \\<And>\\<sigma> it.\n        \\<lbrakk>it \\<subseteq> \\<alpha> S; it \\<noteq> {};\n         \\<not> c \\<sigma>; I it \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> I (\\<alpha> S) \\<sigma>0\n 3. \\<And>Sa \\<sigma> x.\n       \\<lbrakk>invar S; I (\\<alpha> S) \\<sigma>0;\n        \\<And>x it \\<sigma>.\n           \\<lbrakk>c \\<sigma>; x \\<in> it; it \\<subseteq> \\<alpha> S;\n            I it \\<sigma>\\<rbrakk>\n           \\<Longrightarrow> I (it - {x}) (f x \\<sigma>);\n        \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>;\n        \\<And>\\<sigma> it.\n           \\<lbrakk>it \\<subseteq> \\<alpha> S; it \\<noteq> {};\n            \\<not> c \\<sigma>; I it \\<sigma>\\<rbrakk>\n           \\<Longrightarrow> P \\<sigma>;\n        c \\<sigma>; x \\<in> Sa; I Sa \\<sigma>;\n        Sa \\<subseteq> \\<alpha> S\\<rbrakk>\n       \\<Longrightarrow> I (Sa - {x}) (f x \\<sigma>)\n 4. \\<And>\\<sigma>.\n       \\<lbrakk>invar S; I (\\<alpha> S) \\<sigma>0;\n        \\<And>x it \\<sigma>.\n           \\<lbrakk>c \\<sigma>; x \\<in> it; it \\<subseteq> \\<alpha> S;\n            I it \\<sigma>\\<rbrakk>\n           \\<Longrightarrow> I (it - {x}) (f x \\<sigma>);\n        \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>;\n        \\<And>\\<sigma> it.\n           \\<lbrakk>it \\<subseteq> \\<alpha> S; it \\<noteq> {};\n            \\<not> c \\<sigma>; I it \\<sigma>\\<rbrakk>\n           \\<Longrightarrow> P \\<sigma>;\n        I {} \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>\n 5. \\<And>\\<sigma> Sa.\n       \\<lbrakk>invar S; I (\\<alpha> S) \\<sigma>0;\n        \\<And>x it \\<sigma>.\n           \\<lbrakk>c \\<sigma>; x \\<in> it; it \\<subseteq> \\<alpha> S;\n            I it \\<sigma>\\<rbrakk>\n           \\<Longrightarrow> I (it - {x}) (f x \\<sigma>);\n        \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>;\n        \\<And>\\<sigma> it.\n           \\<lbrakk>it \\<subseteq> \\<alpha> S; it \\<noteq> {};\n            \\<not> c \\<sigma>; I it \\<sigma>\\<rbrakk>\n           \\<Longrightarrow> P \\<sigma>;\n        Sa \\<subseteq> \\<alpha> S; Sa \\<noteq> {}; \\<not> c \\<sigma>;\n        I Sa \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iteratei_rule_insert_P:\n    \"\\<lbrakk>\n      invar S;\n      I {} \\<sigma>0;\n      !!x it \\<sigma>. \\<lbrakk> c \\<sigma>; x \\<in> \\<alpha> S - it; it \\<subseteq> \\<alpha> S; I it \\<sigma> \\<rbrakk> \\<Longrightarrow> I (insert x it) (f x \\<sigma>);\n      !!\\<sigma>. I (\\<alpha> S) \\<sigma> \\<Longrightarrow> P \\<sigma>;\n      !!\\<sigma> it. \\<lbrakk> it \\<subseteq> \\<alpha> S; it \\<noteq> \\<alpha> S; \\<not> c \\<sigma>; I it \\<sigma> \\<rbrakk> \\<Longrightarrow> P \\<sigma>\n    \\<rbrakk> \\<Longrightarrow> P (iteratei S c f \\<sigma>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar S; I {} \\<sigma>0;\n     \\<And>x it \\<sigma>.\n        \\<lbrakk>c \\<sigma>; x \\<in> \\<alpha> S - it;\n         it \\<subseteq> \\<alpha> S; I it \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> I (set_ins x it) (f x \\<sigma>);\n     \\<And>\\<sigma>. I (\\<alpha> S) \\<sigma> \\<Longrightarrow> P \\<sigma>;\n     \\<And>\\<sigma> it.\n        \\<lbrakk>it \\<subseteq> \\<alpha> S; it \\<noteq> \\<alpha> S;\n         \\<not> c \\<sigma>; I it \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> P (iteratei S c f \\<sigma>0)", "apply (rule \n      set_iterator_rule_insert_P[OF iteratei_correct, of S I \\<sigma>0 c f P])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>invar S; I {} \\<sigma>0;\n     \\<And>x it \\<sigma>.\n        \\<lbrakk>c \\<sigma>; x \\<in> \\<alpha> S - it;\n         it \\<subseteq> \\<alpha> S; I it \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> I (set_ins x it) (f x \\<sigma>);\n     \\<And>\\<sigma>. I (\\<alpha> S) \\<sigma> \\<Longrightarrow> P \\<sigma>;\n     \\<And>\\<sigma> it.\n        \\<lbrakk>it \\<subseteq> \\<alpha> S; it \\<noteq> \\<alpha> S;\n         \\<not> c \\<sigma>; I it \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> invar S\n 2. \\<lbrakk>invar S; I {} \\<sigma>0;\n     \\<And>x it \\<sigma>.\n        \\<lbrakk>c \\<sigma>; x \\<in> \\<alpha> S - it;\n         it \\<subseteq> \\<alpha> S; I it \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> I (set_ins x it) (f x \\<sigma>);\n     \\<And>\\<sigma>. I (\\<alpha> S) \\<sigma> \\<Longrightarrow> P \\<sigma>;\n     \\<And>\\<sigma> it.\n        \\<lbrakk>it \\<subseteq> \\<alpha> S; it \\<noteq> \\<alpha> S;\n         \\<not> c \\<sigma>; I it \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> I {} \\<sigma>0\n 3. \\<And>Sa \\<sigma> x.\n       \\<lbrakk>invar S; I {} \\<sigma>0;\n        \\<And>x it \\<sigma>.\n           \\<lbrakk>c \\<sigma>; x \\<in> \\<alpha> S - it;\n            it \\<subseteq> \\<alpha> S; I it \\<sigma>\\<rbrakk>\n           \\<Longrightarrow> I (set_ins x it) (f x \\<sigma>);\n        \\<And>\\<sigma>.\n           I (\\<alpha> S) \\<sigma> \\<Longrightarrow> P \\<sigma>;\n        \\<And>\\<sigma> it.\n           \\<lbrakk>it \\<subseteq> \\<alpha> S; it \\<noteq> \\<alpha> S;\n            \\<not> c \\<sigma>; I it \\<sigma>\\<rbrakk>\n           \\<Longrightarrow> P \\<sigma>;\n        c \\<sigma>; x \\<in> \\<alpha> S - Sa; I Sa \\<sigma>;\n        Sa \\<subseteq> \\<alpha> S\\<rbrakk>\n       \\<Longrightarrow> I (set_ins x Sa) (f x \\<sigma>)\n 4. \\<And>\\<sigma>.\n       \\<lbrakk>invar S; I {} \\<sigma>0;\n        \\<And>x it \\<sigma>.\n           \\<lbrakk>c \\<sigma>; x \\<in> \\<alpha> S - it;\n            it \\<subseteq> \\<alpha> S; I it \\<sigma>\\<rbrakk>\n           \\<Longrightarrow> I (set_ins x it) (f x \\<sigma>);\n        \\<And>\\<sigma>.\n           I (\\<alpha> S) \\<sigma> \\<Longrightarrow> P \\<sigma>;\n        \\<And>\\<sigma> it.\n           \\<lbrakk>it \\<subseteq> \\<alpha> S; it \\<noteq> \\<alpha> S;\n            \\<not> c \\<sigma>; I it \\<sigma>\\<rbrakk>\n           \\<Longrightarrow> P \\<sigma>;\n        I (\\<alpha> S) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>\n 5. \\<And>\\<sigma> Sa.\n       \\<lbrakk>invar S; I {} \\<sigma>0;\n        \\<And>x it \\<sigma>.\n           \\<lbrakk>c \\<sigma>; x \\<in> \\<alpha> S - it;\n            it \\<subseteq> \\<alpha> S; I it \\<sigma>\\<rbrakk>\n           \\<Longrightarrow> I (set_ins x it) (f x \\<sigma>);\n        \\<And>\\<sigma>.\n           I (\\<alpha> S) \\<sigma> \\<Longrightarrow> P \\<sigma>;\n        \\<And>\\<sigma> it.\n           \\<lbrakk>it \\<subseteq> \\<alpha> S; it \\<noteq> \\<alpha> S;\n            \\<not> c \\<sigma>; I it \\<sigma>\\<rbrakk>\n           \\<Longrightarrow> P \\<sigma>;\n        Sa \\<subseteq> \\<alpha> S; Sa \\<noteq> \\<alpha> S;\n        \\<not> c \\<sigma>; I Sa \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Versions without break condition.\\<close>"], ["", "lemma iterate_rule_P:\n    \"\\<lbrakk>\n      invar S;\n      I (\\<alpha> S) \\<sigma>0;\n      !!x it \\<sigma>. \\<lbrakk> x \\<in> it; it \\<subseteq> \\<alpha> S; I it \\<sigma> \\<rbrakk> \\<Longrightarrow> I (it - {x}) (f x \\<sigma>);\n      !!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\n    \\<rbrakk> \\<Longrightarrow> P (iteratei S (\\<lambda>_. True) f \\<sigma>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar S; I (\\<alpha> S) \\<sigma>0;\n     \\<And>x it \\<sigma>.\n        \\<lbrakk>x \\<in> it; it \\<subseteq> \\<alpha> S;\n         I it \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> I (it - {x}) (f x \\<sigma>);\n     \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> P (iterate S f \\<sigma>0)", "apply (rule set_iterator_no_cond_rule_P [OF iteratei_correct, of S I \\<sigma>0 f P])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>invar S; I (\\<alpha> S) \\<sigma>0;\n     \\<And>x it \\<sigma>.\n        \\<lbrakk>x \\<in> it; it \\<subseteq> \\<alpha> S;\n         I it \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> I (it - {x}) (f x \\<sigma>);\n     \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> invar S\n 2. \\<lbrakk>invar S; I (\\<alpha> S) \\<sigma>0;\n     \\<And>x it \\<sigma>.\n        \\<lbrakk>x \\<in> it; it \\<subseteq> \\<alpha> S;\n         I it \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> I (it - {x}) (f x \\<sigma>);\n     \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> I (\\<alpha> S) \\<sigma>0\n 3. \\<And>Sa \\<sigma> x.\n       \\<lbrakk>invar S; I (\\<alpha> S) \\<sigma>0;\n        \\<And>x it \\<sigma>.\n           \\<lbrakk>x \\<in> it; it \\<subseteq> \\<alpha> S;\n            I it \\<sigma>\\<rbrakk>\n           \\<Longrightarrow> I (it - {x}) (f x \\<sigma>);\n        \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>;\n        x \\<in> Sa; I Sa \\<sigma>; Sa \\<subseteq> \\<alpha> S\\<rbrakk>\n       \\<Longrightarrow> I (Sa - {x}) (f x \\<sigma>)\n 4. \\<And>\\<sigma>.\n       \\<lbrakk>invar S; I (\\<alpha> S) \\<sigma>0;\n        \\<And>x it \\<sigma>.\n           \\<lbrakk>x \\<in> it; it \\<subseteq> \\<alpha> S;\n            I it \\<sigma>\\<rbrakk>\n           \\<Longrightarrow> I (it - {x}) (f x \\<sigma>);\n        \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>;\n        I {} \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iterate_rule_insert_P:\n    \"\\<lbrakk>\n      invar S;\n      I {} \\<sigma>0;\n      !!x it \\<sigma>. \\<lbrakk> x \\<in> \\<alpha> S - it; it \\<subseteq> \\<alpha> S; I it \\<sigma> \\<rbrakk> \\<Longrightarrow> I (insert x it) (f x \\<sigma>);\n      !!\\<sigma>. I (\\<alpha> S) \\<sigma> \\<Longrightarrow> P \\<sigma>\n    \\<rbrakk> \\<Longrightarrow> P (iteratei S (\\<lambda>_. True) f \\<sigma>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar S; I {} \\<sigma>0;\n     \\<And>x it \\<sigma>.\n        \\<lbrakk>x \\<in> \\<alpha> S - it; it \\<subseteq> \\<alpha> S;\n         I it \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> I (set_ins x it) (f x \\<sigma>);\n     \\<And>\\<sigma>.\n        I (\\<alpha> S) \\<sigma> \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> P (iterate S f \\<sigma>0)", "apply (rule set_iterator_no_cond_rule_insert_P [OF iteratei_correct, \n      of S I \\<sigma>0 f P])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>invar S; I {} \\<sigma>0;\n     \\<And>x it \\<sigma>.\n        \\<lbrakk>x \\<in> \\<alpha> S - it; it \\<subseteq> \\<alpha> S;\n         I it \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> I (set_ins x it) (f x \\<sigma>);\n     \\<And>\\<sigma>.\n        I (\\<alpha> S) \\<sigma> \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> invar S\n 2. \\<lbrakk>invar S; I {} \\<sigma>0;\n     \\<And>x it \\<sigma>.\n        \\<lbrakk>x \\<in> \\<alpha> S - it; it \\<subseteq> \\<alpha> S;\n         I it \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> I (set_ins x it) (f x \\<sigma>);\n     \\<And>\\<sigma>.\n        I (\\<alpha> S) \\<sigma> \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> I {} \\<sigma>0\n 3. \\<And>Sa \\<sigma> x.\n       \\<lbrakk>invar S; I {} \\<sigma>0;\n        \\<And>x it \\<sigma>.\n           \\<lbrakk>x \\<in> \\<alpha> S - it; it \\<subseteq> \\<alpha> S;\n            I it \\<sigma>\\<rbrakk>\n           \\<Longrightarrow> I (set_ins x it) (f x \\<sigma>);\n        \\<And>\\<sigma>.\n           I (\\<alpha> S) \\<sigma> \\<Longrightarrow> P \\<sigma>;\n        x \\<in> \\<alpha> S - Sa; I Sa \\<sigma>;\n        Sa \\<subseteq> \\<alpha> S\\<rbrakk>\n       \\<Longrightarrow> I (set_ins x Sa) (f x \\<sigma>)\n 4. \\<And>\\<sigma>.\n       \\<lbrakk>invar S; I {} \\<sigma>0;\n        \\<And>x it \\<sigma>.\n           \\<lbrakk>x \\<in> \\<alpha> S - it; it \\<subseteq> \\<alpha> S;\n            I it \\<sigma>\\<rbrakk>\n           \\<Longrightarrow> I (set_ins x it) (f x \\<sigma>);\n        \\<And>\\<sigma>.\n           I (\\<alpha> S) \\<sigma> \\<Longrightarrow> P \\<sigma>;\n        I (\\<alpha> S) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "subsection \"More Set Operations\""], ["", "subsubsection \"Copy\""], ["", "locale set_copy = s1: set \\<alpha>1 invar1 + s2: set \\<alpha>2 invar2\n  for \\<alpha>1 :: \"'s1 \\<Rightarrow> 'a set\" and invar1\n  and \\<alpha>2 :: \"'s2 \\<Rightarrow> 'a set\" and invar2\n  +\n  fixes copy :: \"'s1 \\<Rightarrow> 's2\"\n  assumes copy_correct: \n    \"invar1 s1 \\<Longrightarrow> \\<alpha>2 (copy s1) = \\<alpha>1 s1\"\n    \"invar1 s1 \\<Longrightarrow> invar2 (copy s1)\""], ["", "subsubsection \"Union\""], ["", "locale set_union = s1: set \\<alpha>1 invar1 + s2: set \\<alpha>2 invar2 + s3: set \\<alpha>3 invar3\n  for \\<alpha>1 :: \"'s1 \\<Rightarrow> 'a set\" and invar1\n  and \\<alpha>2 :: \"'s2 \\<Rightarrow> 'a set\" and invar2\n  and \\<alpha>3 :: \"'s3 \\<Rightarrow> 'a set\" and invar3\n  +\n  fixes union :: \"'s1 \\<Rightarrow> 's2 \\<Rightarrow> 's3\"\n  assumes union_correct:\n    \"invar1 s1 \\<Longrightarrow> invar2 s2 \\<Longrightarrow> \\<alpha>3 (union s1 s2) = \\<alpha>1 s1 \\<union> \\<alpha>2 s2\"\n    \"invar1 s1 \\<Longrightarrow> invar2 s2 \\<Longrightarrow> invar3 (union s1 s2)\""], ["", "locale set_union_dj = \n  s1: set \\<alpha>1 invar1 + s2: set \\<alpha>2 invar2 + s3: set \\<alpha>3 invar3\n  for \\<alpha>1 :: \"'s1 \\<Rightarrow> 'a set\" and invar1\n  and \\<alpha>2 :: \"'s2 \\<Rightarrow> 'a set\" and invar2\n  and \\<alpha>3 :: \"'s3 \\<Rightarrow> 'a set\" and invar3\n  +\n  fixes union_dj :: \"'s1 \\<Rightarrow> 's2 \\<Rightarrow> 's3\"\n  assumes union_dj_correct:\n    \"\\<lbrakk>invar1 s1; invar2 s2; \\<alpha>1 s1 \\<inter> \\<alpha>2 s2 = {}\\<rbrakk> \\<Longrightarrow> \\<alpha>3 (union_dj s1 s2) = \\<alpha>1 s1 \\<union> \\<alpha>2 s2\"\n    \"\\<lbrakk>invar1 s1; invar2 s2; \\<alpha>1 s1 \\<inter> \\<alpha>2 s2 = {}\\<rbrakk> \\<Longrightarrow> invar3 (union_dj s1 s2)\""], ["", "locale set_union_list = s1: set \\<alpha>1 invar1 + s2: set \\<alpha>2 invar2\n  for \\<alpha>1 :: \"'s1 \\<Rightarrow> 'a set\" and invar1\n  and \\<alpha>2 :: \"'s2 \\<Rightarrow> 'a set\" and invar2\n  +\n  fixes union_list :: \"'s1 list \\<Rightarrow> 's2\"\n  assumes union_list_correct:\n    \"\\<forall>s1\\<in>set l. invar1 s1 \\<Longrightarrow> \\<alpha>2 (union_list l) = \\<Union>{\\<alpha>1 s1 |s1. s1 \\<in> set l}\"\n    \"\\<forall>s1\\<in>set l. invar1 s1 \\<Longrightarrow> invar2 (union_list l)\""], ["", "subsubsection \"Difference\""], ["", "locale set_diff = s1: set \\<alpha>1 invar1 + s2: set \\<alpha>2 invar2 \n  for \\<alpha>1 :: \"'s1 \\<Rightarrow> 'a set\" and invar1\n  and \\<alpha>2 :: \"'s2 \\<Rightarrow> 'a set\" and invar2\n  +\n  fixes diff :: \"'s1 \\<Rightarrow> 's2 \\<Rightarrow> 's1\"\n  assumes diff_correct:\n    \"invar1 s1 \\<Longrightarrow> invar2 s2 \\<Longrightarrow> \\<alpha>1 (diff s1 s2) = \\<alpha>1 s1 - \\<alpha>2 s2\"\n    \"invar1 s1 \\<Longrightarrow> invar2 s2 \\<Longrightarrow> invar1 (diff s1 s2)\""], ["", "subsubsection \"Intersection\""], ["", "locale set_inter = s1: set \\<alpha>1 invar1 + s2: set \\<alpha>2 invar2 + s3: set \\<alpha>3 invar3\n  for \\<alpha>1 :: \"'s1 \\<Rightarrow> 'a set\" and invar1\n  and \\<alpha>2 :: \"'s2 \\<Rightarrow> 'a set\" and invar2\n  and \\<alpha>3 :: \"'s3 \\<Rightarrow> 'a set\" and invar3\n  +\n  fixes inter :: \"'s1 \\<Rightarrow> 's2 \\<Rightarrow> 's3\"\n  assumes inter_correct:\n    \"invar1 s1 \\<Longrightarrow> invar2 s2 \\<Longrightarrow> \\<alpha>3 (inter s1 s2) = \\<alpha>1 s1 \\<inter> \\<alpha>2 s2\"\n    \"invar1 s1 \\<Longrightarrow> invar2 s2 \\<Longrightarrow> invar3 (inter s1 s2)\""], ["", "subsubsection \"Subset\""], ["", "locale set_subset = s1: set \\<alpha>1 invar1 + s2: set \\<alpha>2 invar2\n  for \\<alpha>1 :: \"'s1 \\<Rightarrow> 'a set\" and invar1\n  and \\<alpha>2 :: \"'s2 \\<Rightarrow> 'a set\" and invar2\n  +\n  fixes subset :: \"'s1 \\<Rightarrow> 's2 \\<Rightarrow> bool\"\n  assumes subset_correct:\n    \"invar1 s1 \\<Longrightarrow> invar2 s2 \\<Longrightarrow> subset s1 s2 \\<longleftrightarrow> \\<alpha>1 s1 \\<subseteq> \\<alpha>2 s2\""], ["", "subsubsection \"Equal\""], ["", "locale set_equal = s1: set \\<alpha>1 invar1 + s2: set \\<alpha>2 invar2\n  for \\<alpha>1 :: \"'s1 \\<Rightarrow> 'a set\" and invar1\n  and \\<alpha>2 :: \"'s2 \\<Rightarrow> 'a set\" and invar2\n  +\n  fixes equal :: \"'s1 \\<Rightarrow> 's2 \\<Rightarrow> bool\"\n  assumes equal_correct:\n    \"invar1 s1 \\<Longrightarrow> invar2 s2 \\<Longrightarrow> equal s1 s2 \\<longleftrightarrow> \\<alpha>1 s1 = \\<alpha>2 s2\""], ["", "subsubsection \"Image and Filter\""], ["", "locale set_image_filter = s1: set \\<alpha>1 invar1 + s2: set \\<alpha>2 invar2\n  for \\<alpha>1 :: \"'s1 \\<Rightarrow> 'a set\" and invar1\n  and \\<alpha>2 :: \"'s2 \\<Rightarrow> 'b set\" and invar2\n  +\n  fixes image_filter :: \"('a \\<Rightarrow> 'b option) \\<Rightarrow> 's1 \\<Rightarrow> 's2\"\n  assumes image_filter_correct_aux:\n    \"invar1 s \\<Longrightarrow> \\<alpha>2 (image_filter f s) = { b . \\<exists>a\\<in>\\<alpha>1 s. f a = Some b }\"\n    \"invar1 s \\<Longrightarrow> invar2 (image_filter f s)\"\nbegin\n  \\<comment> \\<open>This special form will be checked first by the simplifier:\\<close>"], ["", "lemma image_filter_correct_aux2: \n    \"invar1 s \\<Longrightarrow> \n    \\<alpha>2 (image_filter (\\<lambda>x. if P x then (Some (f x)) else None) s) \n    = f ` {x\\<in>\\<alpha>1 s. P x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar1 s \\<Longrightarrow>\n    \\<alpha>2\n     (image_filter (\\<lambda>x. if P x then Some (f x) else None) s) =\n    f ` {x \\<in> \\<alpha>1 s. P x}", "by (auto simp add: image_filter_correct_aux)"], ["", "lemmas image_filter_correct = \n    image_filter_correct_aux2 image_filter_correct_aux"], ["", "end"], ["", "locale set_inj_image_filter = s1: set \\<alpha>1 invar1 + s2: set \\<alpha>2 invar2\n  for \\<alpha>1 :: \"'s1 \\<Rightarrow> 'a set\" and invar1\n  and \\<alpha>2 :: \"'s2 \\<Rightarrow> 'b set\" and invar2\n  +\n  fixes inj_image_filter :: \"('a \\<Rightarrow> 'b option) \\<Rightarrow> 's1 \\<Rightarrow> 's2\"\n  assumes inj_image_filter_correct:\n    \"\\<lbrakk>invar1 s; inj_on f (\\<alpha>1 s \\<inter> dom f)\\<rbrakk> \\<Longrightarrow> \\<alpha>2 (inj_image_filter f s) = { b . \\<exists>a\\<in>\\<alpha>1 s. f a = Some b }\"\n    \"\\<lbrakk>invar1 s; inj_on f (\\<alpha>1 s \\<inter> dom f)\\<rbrakk> \\<Longrightarrow> invar2 (inj_image_filter f s)\""], ["", "subsubsection \"Image\""], ["", "locale set_image = s1: set \\<alpha>1 invar1 + s2: set \\<alpha>2 invar2\n  for \\<alpha>1 :: \"'s1 \\<Rightarrow> 'a set\" and invar1\n  and \\<alpha>2 :: \"'s2 \\<Rightarrow> 'b set\" and invar2\n  +\n  fixes image :: \"('a \\<Rightarrow> 'b) \\<Rightarrow> 's1 \\<Rightarrow> 's2\"\n  assumes image_correct:\n    \"invar1 s \\<Longrightarrow> \\<alpha>2 (image f s) = f`\\<alpha>1 s\"\n    \"invar1 s \\<Longrightarrow> invar2 (image f s)\""], ["", "locale set_inj_image = s1: set \\<alpha>1 invar1 + s2: set \\<alpha>2 invar2\n  for \\<alpha>1 :: \"'s1 \\<Rightarrow> 'a set\" and invar1\n  and \\<alpha>2 :: \"'s2 \\<Rightarrow> 'b set\" and invar2\n  +\n  fixes inj_image :: \"('a \\<Rightarrow> 'b) \\<Rightarrow> 's1 \\<Rightarrow> 's2\"\n  assumes inj_image_correct:\n    \"\\<lbrakk>invar1 s; inj_on f (\\<alpha>1 s)\\<rbrakk> \\<Longrightarrow> \\<alpha>2 (inj_image f s) = f`\\<alpha>1 s\"\n    \"\\<lbrakk>invar1 s; inj_on f (\\<alpha>1 s)\\<rbrakk> \\<Longrightarrow> invar2 (inj_image f s)\""], ["", "subsubsection \"Filter\""], ["", "locale set_filter = s1: set \\<alpha>1 invar1 + s2: set \\<alpha>2 invar2\n  for \\<alpha>1 :: \"'s1 \\<Rightarrow> 'a set\" and invar1\n  and \\<alpha>2 :: \"'s2 \\<Rightarrow> 'a set\" and invar2\n  +\n  fixes filter :: \"('a \\<Rightarrow> bool) \\<Rightarrow> 's1 \\<Rightarrow> 's2\"\n  assumes filter_correct:\n    \"invar1 s \\<Longrightarrow> \\<alpha>2 (filter P s) = {e. e \\<in> \\<alpha>1 s \\<and> P e}\"\n    \"invar1 s \\<Longrightarrow> invar2 (filter P s)\""], ["", "subsubsection \"Union of Set of Sets\""], ["", "locale set_Union_image = \n  s1: set \\<alpha>1 invar1 + s2: set \\<alpha>2 invar2 + s3: set \\<alpha>3 invar3\n  for \\<alpha>1 :: \"'s1 \\<Rightarrow> 'a set\" and invar1\n  and \\<alpha>2 :: \"'s2 \\<Rightarrow> 'b set\" and invar2\n  and \\<alpha>3 :: \"'s3 \\<Rightarrow> 'b set\" and invar3\n  +\n  fixes Union_image :: \"('a \\<Rightarrow> 's2) \\<Rightarrow> 's1 \\<Rightarrow> 's3\"\n  assumes Union_image_correct: \n    \"\\<lbrakk> invar1 s; !!x. x\\<in>\\<alpha>1 s \\<Longrightarrow> invar2 (f x) \\<rbrakk> \\<Longrightarrow> \n      \\<alpha>3 (Union_image f s) = \\<Union>(\\<alpha>2`f`\\<alpha>1 s)\"\n    \"\\<lbrakk> invar1 s; !!x. x\\<in>\\<alpha>1 s \\<Longrightarrow> invar2 (f x) \\<rbrakk> \\<Longrightarrow> invar3 (Union_image f s)\""], ["", "subsubsection \"Disjointness Check\""], ["", "locale set_disjoint = s1: set \\<alpha>1 invar1 + s2: set \\<alpha>2 invar2\n  for \\<alpha>1 :: \"'s1 \\<Rightarrow> 'a set\" and invar1\n  and \\<alpha>2 :: \"'s2 \\<Rightarrow> 'a set\" and invar2\n  +\n  fixes disjoint :: \"'s1 \\<Rightarrow> 's2 \\<Rightarrow> bool\"\n  assumes disjoint_correct:\n    \"invar1 s1 \\<Longrightarrow> invar2 s2 \\<Longrightarrow> disjoint s1 s2 \\<longleftrightarrow> \\<alpha>1 s1 \\<inter> \\<alpha>2 s2 = {}\""], ["", "subsubsection \"Disjointness Check With Witness\""], ["", "locale set_disjoint_witness = s1: set \\<alpha>1 invar1 + s2: set \\<alpha>2 invar2\n  for \\<alpha>1 :: \"'s1 \\<Rightarrow> 'a set\" and invar1\n  and \\<alpha>2 :: \"'s2 \\<Rightarrow> 'a set\" and invar2\n  +\n  fixes disjoint_witness :: \"'s1 \\<Rightarrow> 's2 \\<Rightarrow> 'a option\"\n  assumes disjoint_witness_correct:\n    \"\\<lbrakk>invar1 s1; invar2 s2\\<rbrakk> \n      \\<Longrightarrow> disjoint_witness s1 s2 = None \\<Longrightarrow> \\<alpha>1 s1 \\<inter> \\<alpha>2 s2 = {}\"\n    \"\\<lbrakk>invar1 s1; invar2 s2; disjoint_witness s1 s2 = Some a\\<rbrakk> \n      \\<Longrightarrow> a\\<in>\\<alpha>1 s1 \\<inter> \\<alpha>2 s2\"\nbegin"], ["", "lemma disjoint_witness_None: \"\\<lbrakk>invar1 s1; invar2 s2\\<rbrakk> \n    \\<Longrightarrow> disjoint_witness s1 s2 = None \\<longleftrightarrow> \\<alpha>1 s1 \\<inter> \\<alpha>2 s2 = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar1 s1; invar2 s2\\<rbrakk>\n    \\<Longrightarrow> (disjoint_witness s1 s2 = None) =\n                      (\\<alpha>1 s1 \\<inter> \\<alpha>2 s2 = {})", "by (case_tac \"disjoint_witness s1 s2\")\n       (auto dest: disjoint_witness_correct)"], ["", "lemma disjoint_witnessI: \"\\<lbrakk>\n    invar1 s1; \n    invar2 s2; \n    \\<alpha>1 s1 \\<inter> \\<alpha>2 s2 \\<noteq> {}; \n    !!a. \\<lbrakk>disjoint_witness s1 s2 = Some a\\<rbrakk> \\<Longrightarrow> P \n                            \\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar1 s1; invar2 s2;\n     \\<alpha>1 s1 \\<inter> \\<alpha>2 s2 \\<noteq> {};\n     \\<And>a. disjoint_witness s1 s2 = Some a \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (case_tac \"disjoint_witness s1 s2\")\n       (auto dest: disjoint_witness_correct)"], ["", "end"], ["", "subsubsection \"Selection of Element\""], ["", "locale set_sel = set +\n  constrains \\<alpha> :: \"'s \\<Rightarrow> 'x set\"\n  fixes sel :: \"'s \\<Rightarrow> ('x \\<Rightarrow> 'r option) \\<Rightarrow> 'r option\"\n  assumes selE: \n    \"\\<lbrakk> invar s; x\\<in>\\<alpha> s; f x = Some r; \n       !!x r. \\<lbrakk>sel s f = Some r; x\\<in>\\<alpha> s; f x = Some r \\<rbrakk> \\<Longrightarrow> Q \n     \\<rbrakk> \\<Longrightarrow> Q\"\n  assumes selI: \"\\<lbrakk>invar s; \\<forall>x\\<in>\\<alpha> s. f x = None \\<rbrakk> \\<Longrightarrow> sel s f = None\"\nbegin"], ["", "lemma sel_someD:\n    \"\\<lbrakk> invar s; sel s f = Some r; !!x. \\<lbrakk>x\\<in>\\<alpha> s; f x = Some r\\<rbrakk> \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar s; sel s f = Some r;\n     \\<And>x.\n        \\<lbrakk>x \\<in> \\<alpha> s; f x = Some r\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "apply (cases \"\\<exists>x\\<in>\\<alpha> s. \\<exists>r. f x = Some r\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>invar s; sel s f = Some r;\n     \\<And>x.\n        \\<lbrakk>x \\<in> \\<alpha> s; f x = Some r\\<rbrakk>\n        \\<Longrightarrow> P;\n     \\<exists>x\\<in>\\<alpha> s. \\<exists>r. f x = Some r\\<rbrakk>\n    \\<Longrightarrow> P\n 2. \\<lbrakk>invar s; sel s f = Some r;\n     \\<And>x.\n        \\<lbrakk>x \\<in> \\<alpha> s; f x = Some r\\<rbrakk>\n        \\<Longrightarrow> P;\n     \\<not> (\\<exists>x\\<in>\\<alpha> s. \\<exists>r. f x = Some r)\\<rbrakk>\n    \\<Longrightarrow> P", "apply (safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x ra.\n       \\<lbrakk>invar s; sel s f = Some r;\n        \\<And>x.\n           \\<lbrakk>x \\<in> \\<alpha> s; f x = Some r\\<rbrakk>\n           \\<Longrightarrow> P;\n        x \\<in> \\<alpha> s; f x = Some ra\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<lbrakk>invar s; sel s f = Some r;\n     \\<And>x.\n        \\<lbrakk>x \\<in> \\<alpha> s; f x = Some r\\<rbrakk>\n        \\<Longrightarrow> P;\n     \\<not> (\\<exists>x\\<in>\\<alpha> s. \\<exists>r. f x = Some r)\\<rbrakk>\n    \\<Longrightarrow> P", "apply (erule_tac f=f and x=x in selE)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x ra.\n       \\<lbrakk>sel s f = Some r;\n        \\<And>x.\n           \\<lbrakk>x \\<in> \\<alpha> s; f x = Some r\\<rbrakk>\n           \\<Longrightarrow> P;\n        x \\<in> \\<alpha> s; f x = Some ra\\<rbrakk>\n       \\<Longrightarrow> x \\<in> \\<alpha> s\n 2. \\<And>x ra.\n       \\<lbrakk>sel s f = Some r;\n        \\<And>x.\n           \\<lbrakk>x \\<in> \\<alpha> s; f x = Some r\\<rbrakk>\n           \\<Longrightarrow> P;\n        x \\<in> \\<alpha> s; f x = Some ra\\<rbrakk>\n       \\<Longrightarrow> f x = Some (?r3 x ra)\n 3. \\<And>x ra xa raa.\n       \\<lbrakk>sel s f = Some r;\n        \\<And>x.\n           \\<lbrakk>x \\<in> \\<alpha> s; f x = Some r\\<rbrakk>\n           \\<Longrightarrow> P;\n        x \\<in> \\<alpha> s; f x = Some ra; sel s f = Some raa;\n        xa \\<in> \\<alpha> s; f xa = Some raa\\<rbrakk>\n       \\<Longrightarrow> P\n 4. \\<lbrakk>invar s; sel s f = Some r;\n     \\<And>x.\n        \\<lbrakk>x \\<in> \\<alpha> s; f x = Some r\\<rbrakk>\n        \\<Longrightarrow> P;\n     \\<not> (\\<exists>x\\<in>\\<alpha> s. \\<exists>r. f x = Some r)\\<rbrakk>\n    \\<Longrightarrow> P", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar s; sel s f = Some r;\n     \\<forall>x\\<in>\\<alpha> s. f x = None\\<rbrakk>\n    \\<Longrightarrow> P", "apply (drule (1) selI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sel s f = Some r; \\<forall>x\\<in>\\<alpha> s. f x = None;\n     sel s f = None\\<rbrakk>\n    \\<Longrightarrow> P", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sel_noneD: \n    \"\\<lbrakk> invar s; sel s f = None; x\\<in>\\<alpha> s \\<rbrakk> \\<Longrightarrow> f x = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar s; sel s f = None; x \\<in> \\<alpha> s\\<rbrakk>\n    \\<Longrightarrow> f x = None", "apply (cases \"\\<exists>x\\<in>\\<alpha> s. \\<exists>r. f x = Some r\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>invar s; sel s f = None; x \\<in> \\<alpha> s;\n     \\<exists>x\\<in>\\<alpha> s. \\<exists>r. f x = Some r\\<rbrakk>\n    \\<Longrightarrow> f x = None\n 2. \\<lbrakk>invar s; sel s f = None; x \\<in> \\<alpha> s;\n     \\<not> (\\<exists>x\\<in>\\<alpha> s. \\<exists>r. f x = Some r)\\<rbrakk>\n    \\<Longrightarrow> f x = None", "apply (safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa r.\n       \\<lbrakk>invar s; sel s f = None; x \\<in> \\<alpha> s;\n        xa \\<in> \\<alpha> s; f xa = Some r\\<rbrakk>\n       \\<Longrightarrow> f x = None\n 2. \\<lbrakk>invar s; sel s f = None; x \\<in> \\<alpha> s;\n     \\<not> (\\<exists>x\\<in>\\<alpha> s. \\<exists>r. f x = Some r)\\<rbrakk>\n    \\<Longrightarrow> f x = None", "apply (erule_tac f=f and x=xa in selE)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>xa r.\n       \\<lbrakk>sel s f = None; x \\<in> \\<alpha> s; xa \\<in> \\<alpha> s;\n        f xa = Some r\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> \\<alpha> s\n 2. \\<And>xa r.\n       \\<lbrakk>sel s f = None; x \\<in> \\<alpha> s; xa \\<in> \\<alpha> s;\n        f xa = Some r\\<rbrakk>\n       \\<Longrightarrow> f xa = Some (?r3 xa r)\n 3. \\<And>xa r xaa ra.\n       \\<lbrakk>sel s f = None; x \\<in> \\<alpha> s; xa \\<in> \\<alpha> s;\n        f xa = Some r; sel s f = Some ra; xaa \\<in> \\<alpha> s;\n        f xaa = Some ra\\<rbrakk>\n       \\<Longrightarrow> f x = None\n 4. \\<lbrakk>invar s; sel s f = None; x \\<in> \\<alpha> s;\n     \\<not> (\\<exists>x\\<in>\\<alpha> s. \\<exists>r. f x = Some r)\\<rbrakk>\n    \\<Longrightarrow> f x = None", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end\n\n\\<comment> \\<open>Selection of element (without mapping)\\<close>"], ["", "locale set_sel' = set +\n  constrains \\<alpha> :: \"'s \\<Rightarrow> 'x set\"\n  fixes sel' :: \"'s \\<Rightarrow> ('x \\<Rightarrow> bool) \\<Rightarrow> 'x option\"\n  assumes sel'E: \n    \"\\<lbrakk> invar s; x\\<in>\\<alpha> s; P x; \n       !!x. \\<lbrakk>sel' s P = Some x; x\\<in>\\<alpha> s; P x \\<rbrakk> \\<Longrightarrow> Q \n     \\<rbrakk> \\<Longrightarrow> Q\"\n  assumes sel'I: \"\\<lbrakk>invar s; \\<forall>x\\<in>\\<alpha> s. \\<not> P x \\<rbrakk> \\<Longrightarrow> sel' s P = None\"\nbegin"], ["", "lemma sel'_someD:\n    \"\\<lbrakk> invar s; sel' s P = Some x \\<rbrakk> \\<Longrightarrow> x\\<in>\\<alpha> s \\<and> P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar s; sel' s P = Some x\\<rbrakk>\n    \\<Longrightarrow> x \\<in> \\<alpha> s \\<and> P x", "apply (cases \"\\<exists>x\\<in>\\<alpha> s. P x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>invar s; sel' s P = Some x;\n     \\<exists>x\\<in>\\<alpha> s. P x\\<rbrakk>\n    \\<Longrightarrow> x \\<in> \\<alpha> s \\<and> P x\n 2. \\<lbrakk>invar s; sel' s P = Some x;\n     \\<not> (\\<exists>x\\<in>\\<alpha> s. P x)\\<rbrakk>\n    \\<Longrightarrow> x \\<in> \\<alpha> s \\<and> P x", "apply (safe)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>invar s; sel' s P = Some x; xa \\<in> \\<alpha> s;\n        P xa\\<rbrakk>\n       \\<Longrightarrow> x \\<in> \\<alpha> s\n 2. \\<And>xa.\n       \\<lbrakk>invar s; sel' s P = Some x; xa \\<in> \\<alpha> s;\n        P xa\\<rbrakk>\n       \\<Longrightarrow> P x\n 3. \\<lbrakk>invar s; sel' s P = Some x;\n     \\<not> (\\<exists>x\\<in>\\<alpha> s. P x)\\<rbrakk>\n    \\<Longrightarrow> x \\<in> \\<alpha> s\n 4. \\<lbrakk>invar s; sel' s P = Some x;\n     \\<not> (\\<exists>x\\<in>\\<alpha> s. P x)\\<rbrakk>\n    \\<Longrightarrow> P x", "apply (erule_tac P=P and x=xa in sel'E)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>sel' s P = Some x; xa \\<in> \\<alpha> s; P xa\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> \\<alpha> s\n 2. \\<And>xa.\n       \\<lbrakk>sel' s P = Some x; xa \\<in> \\<alpha> s; P xa\\<rbrakk>\n       \\<Longrightarrow> P xa\n 3. \\<And>xa xaa.\n       \\<lbrakk>sel' s P = Some x; xa \\<in> \\<alpha> s; P xa;\n        sel' s P = Some xaa; xaa \\<in> \\<alpha> s; P xaa\\<rbrakk>\n       \\<Longrightarrow> x \\<in> \\<alpha> s\n 4. \\<And>xa.\n       \\<lbrakk>invar s; sel' s P = Some x; xa \\<in> \\<alpha> s;\n        P xa\\<rbrakk>\n       \\<Longrightarrow> P x\n 5. \\<lbrakk>invar s; sel' s P = Some x;\n     \\<not> (\\<exists>x\\<in>\\<alpha> s. P x)\\<rbrakk>\n    \\<Longrightarrow> x \\<in> \\<alpha> s\n 6. \\<lbrakk>invar s; sel' s P = Some x;\n     \\<not> (\\<exists>x\\<in>\\<alpha> s. P x)\\<rbrakk>\n    \\<Longrightarrow> P x", "apply auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>invar s; sel' s P = Some x; xa \\<in> \\<alpha> s;\n        P xa\\<rbrakk>\n       \\<Longrightarrow> P x\n 2. \\<lbrakk>invar s; sel' s P = Some x;\n     \\<forall>x\\<in>\\<alpha> s. \\<not> P x\\<rbrakk>\n    \\<Longrightarrow> x \\<in> \\<alpha> s\n 3. \\<lbrakk>invar s; sel' s P = Some x;\n     \\<forall>x\\<in>\\<alpha> s. \\<not> P x\\<rbrakk>\n    \\<Longrightarrow> P x", "apply (erule_tac P=P and x=xa in sel'E)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>sel' s P = Some x; xa \\<in> \\<alpha> s; P xa\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> \\<alpha> s\n 2. \\<And>xa.\n       \\<lbrakk>sel' s P = Some x; xa \\<in> \\<alpha> s; P xa\\<rbrakk>\n       \\<Longrightarrow> P xa\n 3. \\<And>xa xaa.\n       \\<lbrakk>sel' s P = Some x; xa \\<in> \\<alpha> s; P xa;\n        sel' s P = Some xaa; xaa \\<in> \\<alpha> s; P xaa\\<rbrakk>\n       \\<Longrightarrow> P x\n 4. \\<lbrakk>invar s; sel' s P = Some x;\n     \\<forall>x\\<in>\\<alpha> s. \\<not> P x\\<rbrakk>\n    \\<Longrightarrow> x \\<in> \\<alpha> s\n 5. \\<lbrakk>invar s; sel' s P = Some x;\n     \\<forall>x\\<in>\\<alpha> s. \\<not> P x\\<rbrakk>\n    \\<Longrightarrow> P x", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>invar s; sel' s P = Some x;\n     \\<forall>x\\<in>\\<alpha> s. \\<not> P x\\<rbrakk>\n    \\<Longrightarrow> x \\<in> \\<alpha> s\n 2. \\<lbrakk>invar s; sel' s P = Some x;\n     \\<forall>x\\<in>\\<alpha> s. \\<not> P x\\<rbrakk>\n    \\<Longrightarrow> P x", "apply (drule (1) sel'I)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>sel' s P = Some x; \\<forall>x\\<in>\\<alpha> s. \\<not> P x;\n     sel' s P = None\\<rbrakk>\n    \\<Longrightarrow> x \\<in> \\<alpha> s\n 2. \\<lbrakk>invar s; sel' s P = Some x;\n     \\<forall>x\\<in>\\<alpha> s. \\<not> P x\\<rbrakk>\n    \\<Longrightarrow> P x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar s; sel' s P = Some x;\n     \\<forall>x\\<in>\\<alpha> s. \\<not> P x\\<rbrakk>\n    \\<Longrightarrow> P x", "apply (drule (1) sel'I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sel' s P = Some x; \\<forall>x\\<in>\\<alpha> s. \\<not> P x;\n     sel' s P = None\\<rbrakk>\n    \\<Longrightarrow> P x", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sel'_noneD: \n    \"\\<lbrakk> invar s; sel' s P = None; x\\<in>\\<alpha> s \\<rbrakk> \\<Longrightarrow> \\<not>P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar s; sel' s P = None; x \\<in> \\<alpha> s\\<rbrakk>\n    \\<Longrightarrow> \\<not> P x", "apply (cases \"\\<exists>x\\<in>\\<alpha> s. P x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>invar s; sel' s P = None; x \\<in> \\<alpha> s;\n     \\<exists>x\\<in>\\<alpha> s. P x\\<rbrakk>\n    \\<Longrightarrow> \\<not> P x\n 2. \\<lbrakk>invar s; sel' s P = None; x \\<in> \\<alpha> s;\n     \\<not> (\\<exists>x\\<in>\\<alpha> s. P x)\\<rbrakk>\n    \\<Longrightarrow> \\<not> P x", "apply (safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>invar s; sel' s P = None; x \\<in> \\<alpha> s;\n        xa \\<in> \\<alpha> s; P xa; P x\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<lbrakk>invar s; sel' s P = None; x \\<in> \\<alpha> s;\n     \\<not> (\\<exists>x\\<in>\\<alpha> s. P x); P x\\<rbrakk>\n    \\<Longrightarrow> False", "apply (erule_tac P=P and x=xa in sel'E)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>sel' s P = None; x \\<in> \\<alpha> s; xa \\<in> \\<alpha> s;\n        P xa; P x\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> \\<alpha> s\n 2. \\<And>xa.\n       \\<lbrakk>sel' s P = None; x \\<in> \\<alpha> s; xa \\<in> \\<alpha> s;\n        P xa; P x\\<rbrakk>\n       \\<Longrightarrow> P xa\n 3. \\<And>xa xaa.\n       \\<lbrakk>sel' s P = None; x \\<in> \\<alpha> s; xa \\<in> \\<alpha> s;\n        P xa; P x; sel' s P = Some xaa; xaa \\<in> \\<alpha> s; P xaa\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<lbrakk>invar s; sel' s P = None; x \\<in> \\<alpha> s;\n     \\<not> (\\<exists>x\\<in>\\<alpha> s. P x); P x\\<rbrakk>\n    \\<Longrightarrow> False", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "subsubsection \"Conversion of Set to List\""], ["", "locale set_to_list = set +\n  constrains \\<alpha> :: \"'s \\<Rightarrow> 'x set\"\n  fixes to_list :: \"'s \\<Rightarrow> 'x list\"\n  assumes to_list_correct: \n    \"invar s \\<Longrightarrow> set (to_list s) = \\<alpha> s\"\n    \"invar s \\<Longrightarrow> distinct (to_list s)\""], ["", "subsubsection \"Conversion of List to Set\""], ["", "locale list_to_set = set +\n  constrains \\<alpha> :: \"'s \\<Rightarrow> 'x set\"\n  fixes to_set :: \"'x list \\<Rightarrow> 's\"\n  assumes to_set_correct:\n    \"\\<alpha> (to_set l) = set l\"\n    \"invar (to_set l)\""], ["", "subsection \"Ordered Sets\""], ["", "locale ordered_set = set \\<alpha> invar \n    for \\<alpha> :: \"'s \\<Rightarrow> ('u::linorder) set\" and invar"], ["", "locale ordered_finite_set = finite_set \\<alpha> invar + ordered_set \\<alpha> invar\n    for \\<alpha> :: \"'s \\<Rightarrow> ('u::linorder) set\" and invar"], ["", "subsubsection \"Ordered Iteration\""], ["", "(* Deprecated *)\n(*  locale set_iterateoi = ordered_finite_set \\<alpha> invar\n    for \\<alpha> :: \"'s \\<Rightarrow> ('u::linorder) set\" and invar\n    +\n    fixes iterateoi :: \"'s \\<Rightarrow> ('u,'\\<sigma>) set_iterator\"\n    assumes iterateoi_rule: \n      \"invar s \\<Longrightarrow> set_iterator_linord (iterateoi s) (\\<alpha> s)\"\n  begin\n    lemma iterateoi_rule_P[case_names minv inv0 inv_pres i_complete i_inter]:\n      assumes MINV: \"invar m\"\n      assumes I0: \"I (\\<alpha> m) \\<sigma>0\"\n      assumes IP: \"!!k it \\<sigma>. \\<lbrakk> \n        c \\<sigma>; \n        k \\<in> it; \n        \\<forall>j\\<in>it. k\\<le>j; \n        \\<forall>j\\<in>\\<alpha> m - it. j\\<le>k; \n        it \\<subseteq> \\<alpha> m; \n        I it \\<sigma> \n      \\<rbrakk> \\<Longrightarrow> I (it - {k}) (f k \\<sigma>)\"\n      assumes IF: \"!!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n      assumes II: \"!!\\<sigma> it. \\<lbrakk> \n        it \\<subseteq> \\<alpha> m; \n        it \\<noteq> {}; \n        \\<not> c \\<sigma>; \n        I it \\<sigma>; \n        \\<forall>k\\<in>it. \\<forall>j\\<in>\\<alpha> m - it. j\\<le>k \n      \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n      shows \"P (iterateoi m c f \\<sigma>0)\"  \n    using set_iterator_linord_rule_P [OF iterateoi_rule, OF MINV, of I \\<sigma>0 c f P,\n       OF I0 _ IF] IP II\n    by simp\n\n    lemma iterateo_rule_P[case_names minv inv0 inv_pres i_complete]: \n      assumes MINV: \"invar m\"\n      assumes I0: \"I ((\\<alpha> m)) \\<sigma>0\"\n      assumes IP: \"!!k it \\<sigma>. \\<lbrakk> k \\<in> it; \\<forall>j\\<in>it. k\\<le>j; \\<forall>j\\<in>(\\<alpha> m) - it. j\\<le>k; it \\<subseteq> (\\<alpha> m); I it \\<sigma> \\<rbrakk> \n                  \\<Longrightarrow> I (it - {k}) (f k \\<sigma>)\"\n      assumes IF: \"!!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n    shows \"P (iterateoi m (\\<lambda>_. True) f \\<sigma>0)\"\n      apply (rule iterateoi_rule_P [where I = I])\n      apply (simp_all add: assms)\n    done\n  end\n\n  lemma set_iterateoi_I :\n  assumes \"\\<And>s. invar s \\<Longrightarrow> set_iterator_linord (itoi s) (\\<alpha> s)\"\n  shows \"set_iterateoi \\<alpha> invar itoi\"\n  proof\n    fix s\n    assume invar_s: \"invar s\"\n    from assms(1)[OF invar_s] show it_OK: \"set_iterator_linord (itoi s) (\\<alpha> s)\" .\n  \n    from set_iterator_genord.finite_S0 [OF it_OK[unfolded set_iterator_linord_def]]\n    show \"finite (\\<alpha> s)\" by simp \n  qed\n\n  (* Deprecated *)\n  locale set_reverse_iterateoi = ordered_finite_set \\<alpha> invar \n    for \\<alpha> :: \"'s \\<Rightarrow> ('u::linorder) set\" and invar\n    +\n    fixes reverse_iterateoi :: \"'s \\<Rightarrow> ('u,'\\<sigma>) set_iterator\"\n    assumes reverse_iterateoi_rule: \"\n      invar m \\<Longrightarrow> set_iterator_rev_linord (reverse_iterateoi m) (\\<alpha> m)\" \n  begin\n    lemma reverse_iterateoi_rule_P[case_names minv inv0 inv_pres i_complete i_inter]:\n      assumes MINV: \"invar m\"\n      assumes I0: \"I ((\\<alpha> m)) \\<sigma>0\"\n      assumes IP: \"!!k it \\<sigma>. \\<lbrakk> \n        c \\<sigma>; \n        k \\<in> it; \n        \\<forall>j\\<in>it. k\\<ge>j; \n        \\<forall>j\\<in>(\\<alpha> m) - it. j\\<ge>k; \n        it \\<subseteq> (\\<alpha> m); \n        I it \\<sigma> \n      \\<rbrakk> \\<Longrightarrow> I (it - {k}) (f k \\<sigma>)\"\n      assumes IF: \"!!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n      assumes II: \"!!\\<sigma> it. \\<lbrakk> \n        it \\<subseteq> (\\<alpha> m); \n        it \\<noteq> {}; \n        \\<not> c \\<sigma>; \n        I it \\<sigma>; \n        \\<forall>k\\<in>it. \\<forall>j\\<in>(\\<alpha> m) - it. j\\<ge>k \n      \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n    shows \"P (reverse_iterateoi m c f \\<sigma>0)\"\n    using set_iterator_rev_linord_rule_P [OF reverse_iterateoi_rule, OF MINV, of I \\<sigma>0 c f P,\n       OF I0 _ IF] IP II\n    by simp\n\n    lemma reverse_iterateo_rule_P[case_names minv inv0 inv_pres i_complete]:\n      assumes MINV: \"invar m\"\n      assumes I0: \"I ((\\<alpha> m)) \\<sigma>0\"\n      assumes IP: \"!!k it \\<sigma>. \\<lbrakk> \n        k \\<in> it; \n        \\<forall>j\\<in>it. k\\<ge>j; \n        \\<forall>j\\<in> (\\<alpha> m) - it. j\\<ge>k; \n        it \\<subseteq> (\\<alpha> m); \n        I it \\<sigma> \n      \\<rbrakk> \\<Longrightarrow> I (it - {k}) (f k \\<sigma>)\"\n      assumes IF: \"!!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n    shows \"P (reverse_iterateoi m (\\<lambda>_. True) f \\<sigma>0)\"\n      apply (rule reverse_iterateoi_rule_P [where I = I])\n      apply (simp_all add: assms)\n    done\n  end\n\n  lemma set_reverse_iterateoi_I :\n  assumes \"\\<And>s. invar s \\<Longrightarrow> set_iterator_rev_linord (itoi s) (\\<alpha> s)\"\n  shows \"set_reverse_iterateoi \\<alpha> invar itoi\"\n  proof\n    fix s\n    assume invar_s: \"invar s\"\n    from assms(1)[OF invar_s] show it_OK: \"set_iterator_rev_linord (itoi s) (\\<alpha> s)\" .\n  \n    from set_iterator_genord.finite_S0 [OF it_OK[unfolded set_iterator_rev_linord_def]]\n    show \"finite (\\<alpha> s)\" by simp \n  qed\n*)"], ["", "locale poly_set_iterateoi_defs =\n  fixes olist_it :: \"'s \\<Rightarrow> ('x,'x list) set_iterator\"\nbegin"], ["", "definition iterateoi :: \"'s \\<Rightarrow> ('x,'\\<sigma>) set_iterator\"\n    where \"iterateoi S \\<equiv> it_to_it (olist_it S)\""], ["", "(*local_setup {* Locale_Code.lc_decl_del @{term iterateoi} *}*)"], ["", "abbreviation \"iterateo s \\<equiv> iterateoi s (\\<lambda>_. True)\""], ["", "end"], ["", "locale poly_set_iterateoi =\n  finite_set \\<alpha> invar + poly_set_iterateoi_defs list_ordered_it\n  for \\<alpha> :: \"'s \\<Rightarrow> 'x::linorder set\" \n  and invar \n  and list_ordered_it :: \"'s \\<Rightarrow> ('x,'x list) set_iterator\" +\n  assumes list_ordered_it_correct: \"invar x \n    \\<Longrightarrow> set_iterator_linord (list_ordered_it x) (\\<alpha> x)\"\nbegin"], ["", "lemma iterateoi_correct: \n    \"invar S \\<Longrightarrow> set_iterator_linord (iterateoi S) (\\<alpha> S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar S \\<Longrightarrow> set_iterator_linord (iterateoi S) (\\<alpha> S)", "unfolding iterateoi_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. invar S \\<Longrightarrow>\n    set_iterator_linord (it_to_it (list_ordered_it S)) (\\<alpha> S)", "apply (rule it_to_it_linord_correct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. invar S \\<Longrightarrow>\n    set_iterator_linord (list_ordered_it S) (\\<alpha> S)", "by (rule list_ordered_it_correct)"], ["", "lemma pi_iterateoi[icf_proper_iteratorI]: \n    \"proper_it (iterateoi S) (iterateoi S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it (iterateoi S) (iterateoi S)", "unfolding iterateoi_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it (it_to_it (list_ordered_it S)) (it_to_it (list_ordered_it S))", "by (intro icf_proper_iteratorI)"], ["", "lemma iterateoi_rule_P[case_names minv inv0 inv_pres i_complete i_inter]:\n    assumes MINV: \"invar s\"\n    assumes I0: \"I (\\<alpha> s) \\<sigma>0\"\n    assumes IP: \"!!k it \\<sigma>. \\<lbrakk> \n      c \\<sigma>; \n      k \\<in> it; \n      \\<forall>j\\<in>it. k\\<le>j; \n      \\<forall>j\\<in>\\<alpha> s - it. j\\<le>k; \n      it \\<subseteq> \\<alpha> s; \n      I it \\<sigma> \n    \\<rbrakk> \\<Longrightarrow> I (it - {k}) (f k \\<sigma>)\"\n    assumes IF: \"!!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n    assumes II: \"!!\\<sigma> it. \\<lbrakk> \n      it \\<subseteq> \\<alpha> s; \n      it \\<noteq> {}; \n      \\<not> c \\<sigma>; \n      I it \\<sigma>; \n      \\<forall>k\\<in>it. \\<forall>j\\<in>\\<alpha> s - it. j\\<le>k \n    \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n    shows \"P (iterateoi s c f \\<sigma>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (iterateoi s c f \\<sigma>0)", "using set_iterator_linord_rule_P [OF iterateoi_correct, \n    OF MINV, of I \\<sigma>0 c f P, OF I0 _ IF] IP II"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>S \\<sigma> x.\n              \\<lbrakk>c \\<sigma>; x \\<in> S; I S \\<sigma>;\n               S \\<subseteq> \\<alpha> s;\n               \\<And>x'.\n                  x' \\<in> \\<alpha> s - S \\<Longrightarrow> x' \\<le> x;\n               \\<And>x'. x' \\<in> S \\<Longrightarrow> x \\<le> x'\\<rbrakk>\n              \\<Longrightarrow> I (S - {x}) (f x \\<sigma>);\n   \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> I {} \\<sigma>;\n   \\<And>\\<sigma> S.\n      \\<lbrakk>S \\<subseteq> \\<alpha> s; S \\<noteq> {};\n       \\<And>x x'.\n          \\<lbrakk>x \\<in> S; x' \\<in> \\<alpha> s - S\\<rbrakk>\n          \\<Longrightarrow> x' \\<le> x;\n       \\<not> c \\<sigma>; I S \\<sigma>\\<rbrakk>\n      \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n  \\<Longrightarrow> P (iterateoi s c f \\<sigma>0)\n  \\<lbrakk>c ?\\<sigma>2; ?k2 \\<in> ?it2; \\<forall>j\\<in>?it2. ?k2 \\<le> j;\n   \\<forall>j\\<in>\\<alpha> s - ?it2. j \\<le> ?k2;\n   ?it2 \\<subseteq> \\<alpha> s; I ?it2 ?\\<sigma>2\\<rbrakk>\n  \\<Longrightarrow> I (?it2 - {?k2}) (f ?k2 ?\\<sigma>2)\n  \\<lbrakk>?it2 \\<subseteq> \\<alpha> s; ?it2 \\<noteq> {};\n   \\<not> c ?\\<sigma>2; I ?it2 ?\\<sigma>2;\n   \\<forall>k\\<in>?it2. \\<forall>j\\<in>\\<alpha> s - ?it2. j \\<le> k\\<rbrakk>\n  \\<Longrightarrow> P ?\\<sigma>2\n\ngoal (1 subgoal):\n 1. P (iterateoi s c f \\<sigma>0)", "by simp"], ["", "lemma iterateo_rule_P[case_names minv inv0 inv_pres i_complete]: \n    assumes MINV: \"invar s\"\n    assumes I0: \"I ((\\<alpha> s)) \\<sigma>0\"\n    assumes IP: \"!!k it \\<sigma>. \\<lbrakk> k \\<in> it; \\<forall>j\\<in>it. k\\<le>j; \n        \\<forall>j\\<in>(\\<alpha> s) - it. j\\<le>k; it \\<subseteq> (\\<alpha> s); I it \\<sigma> \\<rbrakk> \n      \\<Longrightarrow> I (it - {k}) (f k \\<sigma>)\"\n    assumes IF: \"!!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n  shows \"P (iterateo s f \\<sigma>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (iterateo s f \\<sigma>0)", "apply (rule iterateoi_rule_P [where I = I])"], ["proof (prove)\ngoal (5 subgoals):\n 1. invar s\n 2. I (\\<alpha> s) \\<sigma>0\n 3. \\<And>k it \\<sigma>.\n       \\<lbrakk>True; k \\<in> it; \\<forall>j\\<in>it. k \\<le> j;\n        \\<forall>j\\<in>\\<alpha> s - it. j \\<le> k;\n        it \\<subseteq> \\<alpha> s; I it \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I (it - {k}) (f k \\<sigma>)\n 4. \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\n 5. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> \\<alpha> s; it \\<noteq> {}; \\<not> True;\n        I it \\<sigma>;\n        \\<forall>k\\<in>it.\n           \\<forall>j\\<in>\\<alpha> s - it. j \\<le> k\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "apply (simp_all add: assms)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "locale poly_set_rev_iterateoi_defs =\n  fixes list_rev_it :: \"'s \\<Rightarrow> ('x::linorder,'x list) set_iterator\"\nbegin"], ["", "definition rev_iterateoi :: \"'s \\<Rightarrow> ('x,'\\<sigma>) set_iterator\"\n    where \"rev_iterateoi S \\<equiv> it_to_it (list_rev_it S)\""], ["", "(*local_setup {* Locale_Code.lc_decl_del @{term rev_iterateoi} *}*)"], ["", "abbreviation \"rev_iterateo m \\<equiv> rev_iterateoi m (\\<lambda>_. True)\""], ["", "abbreviation \"reverse_iterateoi \\<equiv> rev_iterateoi\""], ["", "abbreviation \"reverse_iterateo \\<equiv> rev_iterateo\""], ["", "end"], ["", "locale poly_set_rev_iterateoi =\n  finite_set \\<alpha> invar + poly_set_rev_iterateoi_defs list_rev_it\n  for \\<alpha> :: \"'s \\<Rightarrow> 'x::linorder set\" \n  and invar\n  and list_rev_it :: \"'s \\<Rightarrow> ('x,'x list) set_iterator\" +\n  assumes list_rev_it_correct: \n    \"invar s \\<Longrightarrow> set_iterator_rev_linord (list_rev_it s) (\\<alpha> s)\"\nbegin"], ["", "lemma rev_iterateoi_correct: \n    \"invar S \\<Longrightarrow> set_iterator_rev_linord (rev_iterateoi S) (\\<alpha> S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar S \\<Longrightarrow>\n    set_iterator_rev_linord (reverse_iterateoi S) (\\<alpha> S)", "unfolding rev_iterateoi_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. invar S \\<Longrightarrow>\n    set_iterator_rev_linord (it_to_it (list_rev_it S)) (\\<alpha> S)", "apply (rule it_to_it_rev_linord_correct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. invar S \\<Longrightarrow>\n    set_iterator_rev_linord (list_rev_it S) (\\<alpha> S)", "by (rule list_rev_it_correct)"], ["", "lemma pi_rev_iterateoi[icf_proper_iteratorI]: \n    \"proper_it (rev_iterateoi S) (rev_iterateoi S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it (reverse_iterateoi S) (reverse_iterateoi S)", "unfolding rev_iterateoi_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it (it_to_it (list_rev_it S)) (it_to_it (list_rev_it S))", "by (intro icf_proper_iteratorI)"], ["", "lemma rev_iterateoi_rule_P[case_names minv inv0 inv_pres i_complete i_inter]:\n    assumes MINV: \"invar s\"\n    assumes I0: \"I ((\\<alpha> s)) \\<sigma>0\"\n    assumes IP: \"!!k it \\<sigma>. \\<lbrakk> \n      c \\<sigma>; \n      k \\<in> it; \n      \\<forall>j\\<in>it. k\\<ge>j; \n      \\<forall>j\\<in>(\\<alpha> s) - it. j\\<ge>k; \n      it \\<subseteq> (\\<alpha> s); \n      I it \\<sigma> \n    \\<rbrakk> \\<Longrightarrow> I (it - {k}) (f k \\<sigma>)\"\n    assumes IF: \"!!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n    assumes II: \"!!\\<sigma> it. \\<lbrakk> \n      it \\<subseteq> (\\<alpha> s); \n      it \\<noteq> {}; \n      \\<not> c \\<sigma>; \n      I it \\<sigma>; \n      \\<forall>k\\<in>it. \\<forall>j\\<in>(\\<alpha> s) - it. j\\<ge>k \n    \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n  shows \"P (rev_iterateoi s c f \\<sigma>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (reverse_iterateoi s c f \\<sigma>0)", "using set_iterator_rev_linord_rule_P [OF rev_iterateoi_correct, \n    OF MINV, of I \\<sigma>0 c f P, OF I0 _ IF] IP II"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>S \\<sigma> x.\n              \\<lbrakk>c \\<sigma>; x \\<in> S; I S \\<sigma>;\n               S \\<subseteq> \\<alpha> s;\n               \\<And>x'.\n                  x' \\<in> \\<alpha> s - S \\<Longrightarrow> x \\<le> x';\n               \\<And>x'. x' \\<in> S \\<Longrightarrow> x' \\<le> x\\<rbrakk>\n              \\<Longrightarrow> I (S - {x}) (f x \\<sigma>);\n   \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> I {} \\<sigma>;\n   \\<And>\\<sigma> S.\n      \\<lbrakk>S \\<subseteq> \\<alpha> s; S \\<noteq> {};\n       \\<And>x x'.\n          \\<lbrakk>x \\<in> S; x' \\<in> \\<alpha> s - S\\<rbrakk>\n          \\<Longrightarrow> x \\<le> x';\n       \\<not> c \\<sigma>; I S \\<sigma>\\<rbrakk>\n      \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n  \\<Longrightarrow> P (reverse_iterateoi s c f \\<sigma>0)\n  \\<lbrakk>c ?\\<sigma>4; ?k4 \\<in> ?it4; \\<forall>j\\<in>?it4. j \\<le> ?k4;\n   \\<forall>j\\<in>\\<alpha> s - ?it4. ?k4 \\<le> j;\n   ?it4 \\<subseteq> \\<alpha> s; I ?it4 ?\\<sigma>4\\<rbrakk>\n  \\<Longrightarrow> I (?it4 - {?k4}) (f ?k4 ?\\<sigma>4)\n  \\<lbrakk>?it4 \\<subseteq> \\<alpha> s; ?it4 \\<noteq> {};\n   \\<not> c ?\\<sigma>4; I ?it4 ?\\<sigma>4;\n   \\<forall>k\\<in>?it4. \\<forall>j\\<in>\\<alpha> s - ?it4. k \\<le> j\\<rbrakk>\n  \\<Longrightarrow> P ?\\<sigma>4\n\ngoal (1 subgoal):\n 1. P (reverse_iterateoi s c f \\<sigma>0)", "by simp"], ["", "lemma reverse_iterateo_rule_P[case_names minv inv0 inv_pres i_complete]:\n    assumes MINV: \"invar s\"\n    assumes I0: \"I ((\\<alpha> s)) \\<sigma>0\"\n    assumes IP: \"!!k it \\<sigma>. \\<lbrakk> \n      k \\<in> it; \n      \\<forall>j\\<in>it. k\\<ge>j; \n      \\<forall>j\\<in> (\\<alpha> s) - it. j\\<ge>k; \n      it \\<subseteq> (\\<alpha> s); \n      I it \\<sigma> \n    \\<rbrakk> \\<Longrightarrow> I (it - {k}) (f k \\<sigma>)\"\n    assumes IF: \"!!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n  shows \"P (rev_iterateo s f \\<sigma>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (reverse_iterateo s f \\<sigma>0)", "apply (rule rev_iterateoi_rule_P [where I = I])"], ["proof (prove)\ngoal (5 subgoals):\n 1. invar s\n 2. I (\\<alpha> s) \\<sigma>0\n 3. \\<And>k it \\<sigma>.\n       \\<lbrakk>True; k \\<in> it; \\<forall>j\\<in>it. j \\<le> k;\n        \\<forall>j\\<in>\\<alpha> s - it. k \\<le> j;\n        it \\<subseteq> \\<alpha> s; I it \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I (it - {k}) (f k \\<sigma>)\n 4. \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\n 5. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> \\<alpha> s; it \\<noteq> {}; \\<not> True;\n        I it \\<sigma>;\n        \\<forall>k\\<in>it.\n           \\<forall>j\\<in>\\<alpha> s - it. k \\<le> j\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "apply (simp_all add: assms)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "subsubsection \"Minimal and Maximal Element\""], ["", "locale set_min = ordered_set +\n    constrains \\<alpha> :: \"'s \\<Rightarrow> 'u::linorder set\"\n    fixes min :: \"'s \\<Rightarrow> ('u \\<Rightarrow> bool) \\<Rightarrow> 'u option\"\n    assumes min_correct:\n      \"\\<lbrakk> invar s; x\\<in>\\<alpha> s; P x \\<rbrakk> \\<Longrightarrow> min s P \\<in> Some ` {x\\<in>\\<alpha> s. P x}\"\n      \"\\<lbrakk> invar s; x\\<in>\\<alpha> s; P x \\<rbrakk> \\<Longrightarrow> (the (min s P)) \\<le> x\"\n      \"\\<lbrakk> invar s; {x\\<in>\\<alpha> s. P x} = {} \\<rbrakk> \\<Longrightarrow> min s P = None\"\n  begin"], ["", "lemma minE: \n     assumes A: \"invar s\" \"x\\<in>\\<alpha> s\" \"P x\"\n     obtains x' where\n     \"min s P = Some x'\" \"x'\\<in>\\<alpha> s\" \"P x'\" \"\\<forall>x\\<in>\\<alpha> s. P x \\<longrightarrow> x' \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x'.\n        \\<lbrakk>min s P = Some x'; x' \\<in> \\<alpha> s; P x';\n         \\<forall>x\\<in>\\<alpha> s.\n            P x \\<longrightarrow> x' \\<le> x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>x'.\n        \\<lbrakk>min s P = Some x'; x' \\<in> \\<alpha> s; P x';\n         \\<forall>x\\<in>\\<alpha> s.\n            P x \\<longrightarrow> x' \\<le> x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from min_correct(1)[of s x P, OF A]"], ["proof (chain)\npicking this:\n  min s P \\<in> Some ` {x \\<in> \\<alpha> s. P x}", "have \n       MIS: \"min s P \\<in> Some ` {x \\<in> \\<alpha> s. P x}\""], ["proof (prove)\nusing this:\n  min s P \\<in> Some ` {x \\<in> \\<alpha> s. P x}\n\ngoal (1 subgoal):\n 1. min s P \\<in> Some ` {x \\<in> \\<alpha> s. P x}", "."], ["proof (state)\nthis:\n  min s P \\<in> Some ` {x \\<in> \\<alpha> s. P x}\n\ngoal (1 subgoal):\n 1. (\\<And>x'.\n        \\<lbrakk>min s P = Some x'; x' \\<in> \\<alpha> s; P x';\n         \\<forall>x\\<in>\\<alpha> s.\n            P x \\<longrightarrow> x' \\<le> x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  min s P \\<in> Some ` {x \\<in> \\<alpha> s. P x}", "obtain x' where KV: \"min s P = Some x'\" \"x'\\<in>\\<alpha> s\" \"P x'\""], ["proof (prove)\nusing this:\n  min s P \\<in> Some ` {x \\<in> \\<alpha> s. P x}\n\ngoal (1 subgoal):\n 1. (\\<And>x'.\n        \\<lbrakk>min s P = Some x'; x' \\<in> \\<alpha> s; P x'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  min s P = Some x'\n  x' \\<in> \\<alpha> s\n  P x'\n\ngoal (1 subgoal):\n 1. (\\<And>x'.\n        \\<lbrakk>min s P = Some x'; x' \\<in> \\<alpha> s; P x';\n         \\<forall>x\\<in>\\<alpha> s.\n            P x \\<longrightarrow> x' \\<le> x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "show thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "apply (rule that[OF KV])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>\\<alpha> s. P x \\<longrightarrow> x' \\<le> x", "apply (clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> \\<alpha> s; P x\\<rbrakk>\n       \\<Longrightarrow> x' \\<le> x", "apply (drule (1) min_correct(2)[OF \\<open>invar s\\<close>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>P x; the (min s P) \\<le> x\\<rbrakk>\n       \\<Longrightarrow> x' \\<le> x", "apply (simp add: KV(1))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas minI = min_correct(3)"], ["", "lemma min_Some:\n     \"\\<lbrakk> invar s; min s P = Some x \\<rbrakk> \\<Longrightarrow> x\\<in>\\<alpha> s\"\n     \"\\<lbrakk> invar s; min s P = Some x \\<rbrakk> \\<Longrightarrow> P x\"\n     \"\\<lbrakk> invar s; min s P = Some x; x'\\<in>\\<alpha> s; P x'\\<rbrakk> \\<Longrightarrow> x\\<le>x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>invar s; min s P = Some x\\<rbrakk>\n     \\<Longrightarrow> x \\<in> \\<alpha> s) &&&\n    (\\<lbrakk>invar s; min s P = Some x\\<rbrakk> \\<Longrightarrow> P x) &&&\n    (\\<lbrakk>invar s; min s P = Some x; x' \\<in> \\<alpha> s; P x'\\<rbrakk>\n     \\<Longrightarrow> x \\<le> x')", "apply -"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>invar s; min s P = Some x\\<rbrakk>\n    \\<Longrightarrow> x \\<in> \\<alpha> s\n 2. \\<lbrakk>invar s; min s P = Some x\\<rbrakk> \\<Longrightarrow> P x\n 3. \\<lbrakk>invar s; min s P = Some x; x' \\<in> \\<alpha> s; P x'\\<rbrakk>\n    \\<Longrightarrow> x \\<le> x'", "apply (cases \"{x \\<in> \\<alpha> s. P x} = {}\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>invar s; min s P = Some x;\n     {x \\<in> \\<alpha> s. P x} = {}\\<rbrakk>\n    \\<Longrightarrow> x \\<in> \\<alpha> s\n 2. \\<lbrakk>invar s; min s P = Some x;\n     {x \\<in> \\<alpha> s. P x} \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> x \\<in> \\<alpha> s\n 3. \\<lbrakk>invar s; min s P = Some x\\<rbrakk> \\<Longrightarrow> P x\n 4. \\<lbrakk>invar s; min s P = Some x; x' \\<in> \\<alpha> s; P x'\\<rbrakk>\n    \\<Longrightarrow> x \\<le> x'", "apply (drule (1) min_correct(3))"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>min s P = Some x; {x \\<in> \\<alpha> s. P x} = {};\n     min s P = None\\<rbrakk>\n    \\<Longrightarrow> x \\<in> \\<alpha> s\n 2. \\<lbrakk>invar s; min s P = Some x;\n     {x \\<in> \\<alpha> s. P x} \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> x \\<in> \\<alpha> s\n 3. \\<lbrakk>invar s; min s P = Some x\\<rbrakk> \\<Longrightarrow> P x\n 4. \\<lbrakk>invar s; min s P = Some x; x' \\<in> \\<alpha> s; P x'\\<rbrakk>\n    \\<Longrightarrow> x \\<le> x'", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>invar s; min s P = Some x;\n     {x \\<in> \\<alpha> s. P x} \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> x \\<in> \\<alpha> s\n 2. \\<lbrakk>invar s; min s P = Some x\\<rbrakk> \\<Longrightarrow> P x\n 3. \\<lbrakk>invar s; min s P = Some x; x' \\<in> \\<alpha> s; P x'\\<rbrakk>\n    \\<Longrightarrow> x \\<le> x'", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>invar s; min s P = Some x;\n     \\<exists>x. x \\<in> \\<alpha> s \\<and> P x\\<rbrakk>\n    \\<Longrightarrow> x \\<in> \\<alpha> s\n 2. \\<lbrakk>invar s; min s P = Some x\\<rbrakk> \\<Longrightarrow> P x\n 3. \\<lbrakk>invar s; min s P = Some x; x' \\<in> \\<alpha> s; P x'\\<rbrakk>\n    \\<Longrightarrow> x \\<le> x'", "apply (erule exE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>invar s; min s P = Some x;\n        xa \\<in> \\<alpha> s \\<and> P xa\\<rbrakk>\n       \\<Longrightarrow> x \\<in> \\<alpha> s\n 2. \\<lbrakk>invar s; min s P = Some x\\<rbrakk> \\<Longrightarrow> P x\n 3. \\<lbrakk>invar s; min s P = Some x; x' \\<in> \\<alpha> s; P x'\\<rbrakk>\n    \\<Longrightarrow> x \\<le> x'", "apply clarify"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>invar s; min s P = Some x; xa \\<in> \\<alpha> s;\n        P xa\\<rbrakk>\n       \\<Longrightarrow> x \\<in> \\<alpha> s\n 2. \\<lbrakk>invar s; min s P = Some x\\<rbrakk> \\<Longrightarrow> P x\n 3. \\<lbrakk>invar s; min s P = Some x; x' \\<in> \\<alpha> s; P x'\\<rbrakk>\n    \\<Longrightarrow> x \\<le> x'", "apply (drule (2) min_correct(1)[of s _ P])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>min s P = Some x; xa \\<in> \\<alpha> s; P xa;\n        min s P \\<in> Some ` {x \\<in> \\<alpha> s. P x}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> \\<alpha> s\n 2. \\<lbrakk>invar s; min s P = Some x\\<rbrakk> \\<Longrightarrow> P x\n 3. \\<lbrakk>invar s; min s P = Some x; x' \\<in> \\<alpha> s; P x'\\<rbrakk>\n    \\<Longrightarrow> x \\<le> x'", "apply auto [1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>invar s; min s P = Some x\\<rbrakk> \\<Longrightarrow> P x\n 2. \\<lbrakk>invar s; min s P = Some x; x' \\<in> \\<alpha> s; P x'\\<rbrakk>\n    \\<Longrightarrow> x \\<le> x'", "apply (cases \"{x \\<in> \\<alpha> s. P x} = {}\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>invar s; min s P = Some x;\n     {x \\<in> \\<alpha> s. P x} = {}\\<rbrakk>\n    \\<Longrightarrow> P x\n 2. \\<lbrakk>invar s; min s P = Some x;\n     {x \\<in> \\<alpha> s. P x} \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> P x\n 3. \\<lbrakk>invar s; min s P = Some x; x' \\<in> \\<alpha> s; P x'\\<rbrakk>\n    \\<Longrightarrow> x \\<le> x'", "apply (drule (1) min_correct(3))"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>min s P = Some x; {x \\<in> \\<alpha> s. P x} = {};\n     min s P = None\\<rbrakk>\n    \\<Longrightarrow> P x\n 2. \\<lbrakk>invar s; min s P = Some x;\n     {x \\<in> \\<alpha> s. P x} \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> P x\n 3. \\<lbrakk>invar s; min s P = Some x; x' \\<in> \\<alpha> s; P x'\\<rbrakk>\n    \\<Longrightarrow> x \\<le> x'", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>invar s; min s P = Some x;\n     {x \\<in> \\<alpha> s. P x} \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> P x\n 2. \\<lbrakk>invar s; min s P = Some x; x' \\<in> \\<alpha> s; P x'\\<rbrakk>\n    \\<Longrightarrow> x \\<le> x'", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>invar s; min s P = Some x;\n     \\<exists>x. x \\<in> \\<alpha> s \\<and> P x\\<rbrakk>\n    \\<Longrightarrow> P x\n 2. \\<lbrakk>invar s; min s P = Some x; x' \\<in> \\<alpha> s; P x'\\<rbrakk>\n    \\<Longrightarrow> x \\<le> x'", "apply (erule exE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>invar s; min s P = Some x;\n        xa \\<in> \\<alpha> s \\<and> P xa\\<rbrakk>\n       \\<Longrightarrow> P x\n 2. \\<lbrakk>invar s; min s P = Some x; x' \\<in> \\<alpha> s; P x'\\<rbrakk>\n    \\<Longrightarrow> x \\<le> x'", "apply clarify"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>invar s; min s P = Some x; xa \\<in> \\<alpha> s;\n        P xa\\<rbrakk>\n       \\<Longrightarrow> P x\n 2. \\<lbrakk>invar s; min s P = Some x; x' \\<in> \\<alpha> s; P x'\\<rbrakk>\n    \\<Longrightarrow> x \\<le> x'", "apply (drule (2) min_correct(1)[of s _ P])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>min s P = Some x; xa \\<in> \\<alpha> s; P xa;\n        min s P \\<in> Some ` {x \\<in> \\<alpha> s. P x}\\<rbrakk>\n       \\<Longrightarrow> P x\n 2. \\<lbrakk>invar s; min s P = Some x; x' \\<in> \\<alpha> s; P x'\\<rbrakk>\n    \\<Longrightarrow> x \\<le> x'", "apply auto [1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar s; min s P = Some x; x' \\<in> \\<alpha> s; P x'\\<rbrakk>\n    \\<Longrightarrow> x \\<le> x'", "apply (drule (2) min_correct(2)[where P=P])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>min s P = Some x; x' \\<in> \\<alpha> s; P x';\n     the (min s P) \\<le> x'\\<rbrakk>\n    \\<Longrightarrow> x \\<le> x'", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma min_None:\n     \"\\<lbrakk> invar s; min s P = None \\<rbrakk> \\<Longrightarrow> {x\\<in>\\<alpha> s. P x} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar s; min s P = None\\<rbrakk>\n    \\<Longrightarrow> {x \\<in> \\<alpha> s. P x} = {}", "apply (cases \"{x\\<in>\\<alpha> s. P x} = {}\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>invar s; min s P = None;\n     {x \\<in> \\<alpha> s. P x} = {}\\<rbrakk>\n    \\<Longrightarrow> {x \\<in> \\<alpha> s. P x} = {}\n 2. \\<lbrakk>invar s; min s P = None;\n     {x \\<in> \\<alpha> s. P x} \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> {x \\<in> \\<alpha> s. P x} = {}", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar s; min s P = None;\n     {x \\<in> \\<alpha> s. P x} \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> {x \\<in> \\<alpha> s. P x} = {}", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar s; min s P = None;\n     \\<exists>x. x \\<in> \\<alpha> s \\<and> P x\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x.\n                         x \\<in> \\<alpha> s \\<longrightarrow> \\<not> P x", "apply (erule exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>invar s; min s P = None;\n        x \\<in> \\<alpha> s \\<and> P x\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            x \\<in> \\<alpha> s \\<longrightarrow> \\<not> P x", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>invar s; min s P = None; x \\<in> \\<alpha> s; P x;\n        xa \\<in> \\<alpha> s; P xa\\<rbrakk>\n       \\<Longrightarrow> False", "apply (drule (2) min_correct(1)[where P=P])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>min s P = None; x \\<in> \\<alpha> s; P x;\n        xa \\<in> \\<alpha> s; P xa;\n        min s P \\<in> Some ` {x \\<in> \\<alpha> s. P x}\\<rbrakk>\n       \\<Longrightarrow> False", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "locale set_max = ordered_set +\n    constrains \\<alpha> :: \"'s \\<Rightarrow> 'u::linorder set\"\n    fixes max :: \"'s \\<Rightarrow> ('u \\<Rightarrow> bool) \\<Rightarrow> 'u option\"\n    assumes max_correct:\n      \"\\<lbrakk> invar s; x\\<in>\\<alpha> s; P x \\<rbrakk> \\<Longrightarrow> max s P \\<in> Some ` {x\\<in>\\<alpha> s. P x}\"\n      \"\\<lbrakk> invar s; x\\<in>\\<alpha> s; P x \\<rbrakk> \\<Longrightarrow> the (max s P) \\<ge> x\"\n      \"\\<lbrakk> invar s; {x\\<in>\\<alpha> s. P x} = {} \\<rbrakk> \\<Longrightarrow> max s P = None\"\n  begin"], ["", "lemma maxE: \n     assumes A: \"invar s\" \"x\\<in>\\<alpha> s\" \"P x\"\n     obtains x' where\n     \"max s P = Some x'\" \"x'\\<in>\\<alpha> s\" \"P x'\" \"\\<forall>x\\<in>\\<alpha> s. P x \\<longrightarrow> x' \\<ge> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x'.\n        \\<lbrakk>max s P = Some x'; x' \\<in> \\<alpha> s; P x';\n         \\<forall>x\\<in>\\<alpha> s.\n            P x \\<longrightarrow> x \\<le> x'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>x'.\n        \\<lbrakk>max s P = Some x'; x' \\<in> \\<alpha> s; P x';\n         \\<forall>x\\<in>\\<alpha> s.\n            P x \\<longrightarrow> x \\<le> x'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from max_correct(1)[where P=P, OF A]"], ["proof (chain)\npicking this:\n  max s P \\<in> Some ` {x \\<in> \\<alpha> s. P x}", "have \n       MIS: \"max s P \\<in> Some ` {x\\<in>\\<alpha> s. P x}\""], ["proof (prove)\nusing this:\n  max s P \\<in> Some ` {x \\<in> \\<alpha> s. P x}\n\ngoal (1 subgoal):\n 1. max s P \\<in> Some ` {x \\<in> \\<alpha> s. P x}", "."], ["proof (state)\nthis:\n  max s P \\<in> Some ` {x \\<in> \\<alpha> s. P x}\n\ngoal (1 subgoal):\n 1. (\\<And>x'.\n        \\<lbrakk>max s P = Some x'; x' \\<in> \\<alpha> s; P x';\n         \\<forall>x\\<in>\\<alpha> s.\n            P x \\<longrightarrow> x \\<le> x'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  max s P \\<in> Some ` {x \\<in> \\<alpha> s. P x}", "obtain x' where KV: \"max s P = Some x'\" \"x'\\<in> \\<alpha> s\" \"P x'\""], ["proof (prove)\nusing this:\n  max s P \\<in> Some ` {x \\<in> \\<alpha> s. P x}\n\ngoal (1 subgoal):\n 1. (\\<And>x'.\n        \\<lbrakk>max s P = Some x'; x' \\<in> \\<alpha> s; P x'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  max s P = Some x'\n  x' \\<in> \\<alpha> s\n  P x'\n\ngoal (1 subgoal):\n 1. (\\<And>x'.\n        \\<lbrakk>max s P = Some x'; x' \\<in> \\<alpha> s; P x';\n         \\<forall>x\\<in>\\<alpha> s.\n            P x \\<longrightarrow> x \\<le> x'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "show thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "apply (rule that[OF KV])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>\\<alpha> s. P x \\<longrightarrow> x \\<le> x'", "apply (clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> \\<alpha> s; P x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> x'", "apply (drule (1) max_correct(2)[OF \\<open>invar s\\<close>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>P x; x \\<le> the (max s P)\\<rbrakk>\n       \\<Longrightarrow> x \\<le> x'", "apply (simp add: KV(1))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas maxI = max_correct(3)"], ["", "lemma max_Some:\n     \"\\<lbrakk> invar s; max s P = Some x \\<rbrakk> \\<Longrightarrow> x\\<in>\\<alpha> s\"\n     \"\\<lbrakk> invar s; max s P = Some x \\<rbrakk> \\<Longrightarrow> P x\"\n     \"\\<lbrakk> invar s; max s P = Some x; x'\\<in>\\<alpha> s; P x'\\<rbrakk> \\<Longrightarrow> x\\<ge>x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>invar s; max s P = Some x\\<rbrakk>\n     \\<Longrightarrow> x \\<in> \\<alpha> s) &&&\n    (\\<lbrakk>invar s; max s P = Some x\\<rbrakk> \\<Longrightarrow> P x) &&&\n    (\\<lbrakk>invar s; max s P = Some x; x' \\<in> \\<alpha> s; P x'\\<rbrakk>\n     \\<Longrightarrow> x' \\<le> x)", "apply -"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>invar s; max s P = Some x\\<rbrakk>\n    \\<Longrightarrow> x \\<in> \\<alpha> s\n 2. \\<lbrakk>invar s; max s P = Some x\\<rbrakk> \\<Longrightarrow> P x\n 3. \\<lbrakk>invar s; max s P = Some x; x' \\<in> \\<alpha> s; P x'\\<rbrakk>\n    \\<Longrightarrow> x' \\<le> x", "apply (cases \"{x\\<in>\\<alpha> s. P x} = {}\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>invar s; max s P = Some x;\n     {x \\<in> \\<alpha> s. P x} = {}\\<rbrakk>\n    \\<Longrightarrow> x \\<in> \\<alpha> s\n 2. \\<lbrakk>invar s; max s P = Some x;\n     {x \\<in> \\<alpha> s. P x} \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> x \\<in> \\<alpha> s\n 3. \\<lbrakk>invar s; max s P = Some x\\<rbrakk> \\<Longrightarrow> P x\n 4. \\<lbrakk>invar s; max s P = Some x; x' \\<in> \\<alpha> s; P x'\\<rbrakk>\n    \\<Longrightarrow> x' \\<le> x", "apply (drule (1) max_correct(3))"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>max s P = Some x; {x \\<in> \\<alpha> s. P x} = {};\n     max s P = None\\<rbrakk>\n    \\<Longrightarrow> x \\<in> \\<alpha> s\n 2. \\<lbrakk>invar s; max s P = Some x;\n     {x \\<in> \\<alpha> s. P x} \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> x \\<in> \\<alpha> s\n 3. \\<lbrakk>invar s; max s P = Some x\\<rbrakk> \\<Longrightarrow> P x\n 4. \\<lbrakk>invar s; max s P = Some x; x' \\<in> \\<alpha> s; P x'\\<rbrakk>\n    \\<Longrightarrow> x' \\<le> x", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>invar s; max s P = Some x;\n     {x \\<in> \\<alpha> s. P x} \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> x \\<in> \\<alpha> s\n 2. \\<lbrakk>invar s; max s P = Some x\\<rbrakk> \\<Longrightarrow> P x\n 3. \\<lbrakk>invar s; max s P = Some x; x' \\<in> \\<alpha> s; P x'\\<rbrakk>\n    \\<Longrightarrow> x' \\<le> x", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>invar s; max s P = Some x;\n     \\<exists>x. x \\<in> \\<alpha> s \\<and> P x\\<rbrakk>\n    \\<Longrightarrow> x \\<in> \\<alpha> s\n 2. \\<lbrakk>invar s; max s P = Some x\\<rbrakk> \\<Longrightarrow> P x\n 3. \\<lbrakk>invar s; max s P = Some x; x' \\<in> \\<alpha> s; P x'\\<rbrakk>\n    \\<Longrightarrow> x' \\<le> x", "apply (erule exE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>invar s; max s P = Some x;\n        xa \\<in> \\<alpha> s \\<and> P xa\\<rbrakk>\n       \\<Longrightarrow> x \\<in> \\<alpha> s\n 2. \\<lbrakk>invar s; max s P = Some x\\<rbrakk> \\<Longrightarrow> P x\n 3. \\<lbrakk>invar s; max s P = Some x; x' \\<in> \\<alpha> s; P x'\\<rbrakk>\n    \\<Longrightarrow> x' \\<le> x", "apply clarify"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>invar s; max s P = Some x; xa \\<in> \\<alpha> s;\n        P xa\\<rbrakk>\n       \\<Longrightarrow> x \\<in> \\<alpha> s\n 2. \\<lbrakk>invar s; max s P = Some x\\<rbrakk> \\<Longrightarrow> P x\n 3. \\<lbrakk>invar s; max s P = Some x; x' \\<in> \\<alpha> s; P x'\\<rbrakk>\n    \\<Longrightarrow> x' \\<le> x", "apply (drule (2) max_correct(1)[of s _ P])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>max s P = Some x; xa \\<in> \\<alpha> s; P xa;\n        max s P \\<in> Some ` {x \\<in> \\<alpha> s. P x}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> \\<alpha> s\n 2. \\<lbrakk>invar s; max s P = Some x\\<rbrakk> \\<Longrightarrow> P x\n 3. \\<lbrakk>invar s; max s P = Some x; x' \\<in> \\<alpha> s; P x'\\<rbrakk>\n    \\<Longrightarrow> x' \\<le> x", "apply auto [1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>invar s; max s P = Some x\\<rbrakk> \\<Longrightarrow> P x\n 2. \\<lbrakk>invar s; max s P = Some x; x' \\<in> \\<alpha> s; P x'\\<rbrakk>\n    \\<Longrightarrow> x' \\<le> x", "apply (cases \"{x\\<in>\\<alpha> s. P x} = {}\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>invar s; max s P = Some x;\n     {x \\<in> \\<alpha> s. P x} = {}\\<rbrakk>\n    \\<Longrightarrow> P x\n 2. \\<lbrakk>invar s; max s P = Some x;\n     {x \\<in> \\<alpha> s. P x} \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> P x\n 3. \\<lbrakk>invar s; max s P = Some x; x' \\<in> \\<alpha> s; P x'\\<rbrakk>\n    \\<Longrightarrow> x' \\<le> x", "apply (drule (1) max_correct(3))"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>max s P = Some x; {x \\<in> \\<alpha> s. P x} = {};\n     max s P = None\\<rbrakk>\n    \\<Longrightarrow> P x\n 2. \\<lbrakk>invar s; max s P = Some x;\n     {x \\<in> \\<alpha> s. P x} \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> P x\n 3. \\<lbrakk>invar s; max s P = Some x; x' \\<in> \\<alpha> s; P x'\\<rbrakk>\n    \\<Longrightarrow> x' \\<le> x", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>invar s; max s P = Some x;\n     {x \\<in> \\<alpha> s. P x} \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> P x\n 2. \\<lbrakk>invar s; max s P = Some x; x' \\<in> \\<alpha> s; P x'\\<rbrakk>\n    \\<Longrightarrow> x' \\<le> x", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>invar s; max s P = Some x;\n     \\<exists>x. x \\<in> \\<alpha> s \\<and> P x\\<rbrakk>\n    \\<Longrightarrow> P x\n 2. \\<lbrakk>invar s; max s P = Some x; x' \\<in> \\<alpha> s; P x'\\<rbrakk>\n    \\<Longrightarrow> x' \\<le> x", "apply (erule exE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>invar s; max s P = Some x;\n        xa \\<in> \\<alpha> s \\<and> P xa\\<rbrakk>\n       \\<Longrightarrow> P x\n 2. \\<lbrakk>invar s; max s P = Some x; x' \\<in> \\<alpha> s; P x'\\<rbrakk>\n    \\<Longrightarrow> x' \\<le> x", "apply clarify"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>invar s; max s P = Some x; xa \\<in> \\<alpha> s;\n        P xa\\<rbrakk>\n       \\<Longrightarrow> P x\n 2. \\<lbrakk>invar s; max s P = Some x; x' \\<in> \\<alpha> s; P x'\\<rbrakk>\n    \\<Longrightarrow> x' \\<le> x", "apply (drule (2) max_correct(1)[of s _ P])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>max s P = Some x; xa \\<in> \\<alpha> s; P xa;\n        max s P \\<in> Some ` {x \\<in> \\<alpha> s. P x}\\<rbrakk>\n       \\<Longrightarrow> P x\n 2. \\<lbrakk>invar s; max s P = Some x; x' \\<in> \\<alpha> s; P x'\\<rbrakk>\n    \\<Longrightarrow> x' \\<le> x", "apply auto [1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar s; max s P = Some x; x' \\<in> \\<alpha> s; P x'\\<rbrakk>\n    \\<Longrightarrow> x' \\<le> x", "apply (drule (1) max_correct(2)[where P=P])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>max s P = Some x; x' \\<in> \\<alpha> s; P x'\\<rbrakk>\n    \\<Longrightarrow> P x'\n 2. \\<lbrakk>max s P = Some x; x' \\<in> \\<alpha> s; P x';\n     x' \\<le> the (max s P)\\<rbrakk>\n    \\<Longrightarrow> x' \\<le> x", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma max_None:\n     \"\\<lbrakk> invar s; max s P = None \\<rbrakk> \\<Longrightarrow> {x\\<in>\\<alpha> s. P x} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar s; max s P = None\\<rbrakk>\n    \\<Longrightarrow> {x \\<in> \\<alpha> s. P x} = {}", "apply (cases \"{x\\<in>\\<alpha> s. P x} = {}\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>invar s; max s P = None;\n     {x \\<in> \\<alpha> s. P x} = {}\\<rbrakk>\n    \\<Longrightarrow> {x \\<in> \\<alpha> s. P x} = {}\n 2. \\<lbrakk>invar s; max s P = None;\n     {x \\<in> \\<alpha> s. P x} \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> {x \\<in> \\<alpha> s. P x} = {}", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar s; max s P = None;\n     {x \\<in> \\<alpha> s. P x} \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> {x \\<in> \\<alpha> s. P x} = {}", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar s; max s P = None;\n     \\<exists>x. x \\<in> \\<alpha> s \\<and> P x\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x.\n                         x \\<in> \\<alpha> s \\<longrightarrow> \\<not> P x", "apply (erule exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>invar s; max s P = None;\n        x \\<in> \\<alpha> s \\<and> P x\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x.\n                            x \\<in> \\<alpha> s \\<longrightarrow> \\<not> P x", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>invar s; max s P = None; x \\<in> \\<alpha> s; P x;\n        xa \\<in> \\<alpha> s; P xa\\<rbrakk>\n       \\<Longrightarrow> False", "apply (drule (1) max_correct(1)[where P=P])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>max s P = None; x \\<in> \\<alpha> s; P x;\n        xa \\<in> \\<alpha> s; P xa\\<rbrakk>\n       \\<Longrightarrow> P x\n 2. \\<And>x xa.\n       \\<lbrakk>max s P = None; x \\<in> \\<alpha> s; P x;\n        xa \\<in> \\<alpha> s; P xa;\n        max s P \\<in> Some ` {x \\<in> \\<alpha> s. P x}\\<rbrakk>\n       \\<Longrightarrow> False", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "subsection \"Conversion to List\""], ["", "locale set_to_sorted_list = ordered_set + \n  constrains \\<alpha> :: \"'s \\<Rightarrow> 'x::linorder set\"\n  fixes to_sorted_list :: \"'s \\<Rightarrow> 'x list\"\n  assumes to_sorted_list_correct: \n    \"invar s \\<Longrightarrow> set (to_sorted_list s) = \\<alpha> s\"\n    \"invar s \\<Longrightarrow> distinct (to_sorted_list s)\"\n    \"invar s \\<Longrightarrow> sorted (to_sorted_list s)\""], ["", "locale set_to_rev_list = ordered_set + \n  constrains \\<alpha> :: \"'s \\<Rightarrow> 'x::linorder set\"\n  fixes to_rev_list :: \"'s \\<Rightarrow> 'x list\"\n  assumes to_rev_list_correct: \n    \"invar s \\<Longrightarrow> set (to_rev_list s) = \\<alpha> s\"\n    \"invar s \\<Longrightarrow> distinct (to_rev_list s)\"\n    \"invar s \\<Longrightarrow> sorted (rev (to_rev_list s))\""], ["", "subsection \"Record Based Interface\""], ["", "record ('x,'s) set_ops = \n    set_op_\\<alpha> :: \"'s \\<Rightarrow> 'x set\"\n    set_op_invar :: \"'s \\<Rightarrow> bool\"\n    set_op_empty :: \"unit \\<Rightarrow> 's\"\n    set_op_memb :: \"'x \\<Rightarrow> 's \\<Rightarrow> bool\"\n    set_op_ins :: \"'x \\<Rightarrow> 's \\<Rightarrow> 's\"\n    set_op_ins_dj :: \"'x \\<Rightarrow> 's \\<Rightarrow> 's\"\n    set_op_delete :: \"'x \\<Rightarrow> 's \\<Rightarrow> 's\"\n    set_op_list_it :: \"('x,'s) set_list_it\"\n    set_op_sng :: \"'x \\<Rightarrow> 's\"\n    set_op_isEmpty :: \"'s \\<Rightarrow> bool\"\n    set_op_isSng :: \"'s \\<Rightarrow> bool\"\n    set_op_ball :: \"'s \\<Rightarrow> ('x \\<Rightarrow> bool) \\<Rightarrow> bool\"\n    set_op_bex :: \"'s \\<Rightarrow> ('x \\<Rightarrow> bool) \\<Rightarrow> bool\"\n    set_op_size :: \"'s \\<Rightarrow> nat\"\n    set_op_size_abort :: \"nat \\<Rightarrow> 's \\<Rightarrow> nat\"\n    set_op_union :: \"'s \\<Rightarrow> 's \\<Rightarrow> 's\"\n    set_op_union_dj :: \"'s \\<Rightarrow> 's \\<Rightarrow> 's\"\n    set_op_diff :: \"'s \\<Rightarrow> 's \\<Rightarrow> 's\"\n    set_op_filter :: \"('x \\<Rightarrow> bool) \\<Rightarrow> 's \\<Rightarrow> 's\"\n    set_op_inter :: \"'s \\<Rightarrow> 's \\<Rightarrow> 's\"\n    set_op_subset :: \"'s \\<Rightarrow> 's \\<Rightarrow> bool\"\n    set_op_equal :: \"'s \\<Rightarrow> 's \\<Rightarrow> bool\"\n    set_op_disjoint :: \"'s \\<Rightarrow> 's \\<Rightarrow> bool\"\n    set_op_disjoint_witness :: \"'s \\<Rightarrow> 's \\<Rightarrow> 'x option\"\n    set_op_sel :: \"'s \\<Rightarrow> ('x \\<Rightarrow> bool) \\<Rightarrow> 'x option\" \\<comment> \\<open>Version without mapping\\<close>\n    set_op_to_list :: \"'s \\<Rightarrow> 'x list\"\n    set_op_from_list :: \"'x list \\<Rightarrow> 's\""], ["", "locale StdSetDefs = \n    poly_set_iteratei_defs \"set_op_list_it ops\"\n    for ops :: \"('x,'s,'more) set_ops_scheme\"\n  begin"], ["", "abbreviation \\<alpha> where \"\\<alpha> == set_op_\\<alpha> ops\""], ["", "abbreviation invar where \"invar == set_op_invar ops\""], ["", "abbreviation empty where \"empty == set_op_empty ops\""], ["", "abbreviation memb where \"memb == set_op_memb ops\""], ["", "abbreviation ins where \"ins == set_op_ins ops\""], ["", "abbreviation ins_dj where \"ins_dj == set_op_ins_dj ops\""], ["", "abbreviation delete where \"delete == set_op_delete ops\""], ["", "abbreviation list_it where \"list_it \\<equiv> set_op_list_it ops\""], ["", "abbreviation sng where \"sng == set_op_sng ops\""], ["", "abbreviation isEmpty where \"isEmpty == set_op_isEmpty ops\""], ["", "abbreviation isSng where \"isSng == set_op_isSng ops\""], ["", "abbreviation ball where \"ball == set_op_ball ops\""], ["", "abbreviation bex where \"bex == set_op_bex ops\""], ["", "abbreviation size where \"size == set_op_size ops\""], ["", "abbreviation size_abort where \"size_abort == set_op_size_abort ops\""], ["", "abbreviation union where \"union == set_op_union ops\""], ["", "abbreviation union_dj where \"union_dj == set_op_union_dj ops\""], ["", "abbreviation diff where \"diff == set_op_diff ops\""], ["", "abbreviation filter where \"filter == set_op_filter ops\""], ["", "abbreviation inter where \"inter == set_op_inter ops\""], ["", "abbreviation subset where \"subset == set_op_subset ops\""], ["", "abbreviation equal where \"equal == set_op_equal ops\""], ["", "abbreviation disjoint where \"disjoint == set_op_disjoint ops\""], ["", "abbreviation disjoint_witness \n      where \"disjoint_witness == set_op_disjoint_witness ops\""], ["", "abbreviation sel where \"sel == set_op_sel ops\""], ["", "abbreviation to_list where \"to_list == set_op_to_list ops\""], ["", "abbreviation from_list where \"from_list == set_op_from_list ops\""], ["", "end"], ["", "locale StdSet = StdSetDefs ops +\n    set \\<alpha> invar +\n    set_empty \\<alpha> invar empty + \n    set_memb \\<alpha> invar memb + \n    set_ins \\<alpha> invar ins + \n    set_ins_dj \\<alpha> invar ins_dj +\n    set_delete \\<alpha> invar delete + \n    poly_set_iteratei \\<alpha> invar list_it +\n    set_sng \\<alpha> invar sng + \n    set_isEmpty \\<alpha> invar isEmpty + \n    set_isSng \\<alpha> invar isSng + \n    set_ball \\<alpha> invar ball + \n    set_bex \\<alpha> invar bex + \n    set_size \\<alpha> invar size + \n    set_size_abort \\<alpha> invar size_abort + \n    set_union \\<alpha> invar \\<alpha> invar \\<alpha> invar union + \n    set_union_dj \\<alpha> invar \\<alpha> invar \\<alpha> invar union_dj + \n    set_diff \\<alpha> invar \\<alpha> invar diff + \n    set_filter \\<alpha> invar \\<alpha> invar filter +  \n    set_inter \\<alpha> invar \\<alpha> invar \\<alpha> invar inter + \n    set_subset \\<alpha> invar \\<alpha> invar subset + \n    set_equal \\<alpha> invar \\<alpha> invar equal + \n    set_disjoint \\<alpha> invar \\<alpha> invar disjoint + \n    set_disjoint_witness \\<alpha> invar \\<alpha> invar disjoint_witness + \n    set_sel' \\<alpha> invar sel + \n    set_to_list \\<alpha> invar to_list + \n    list_to_set \\<alpha> invar from_list\n    for ops :: \"('x,'s,'more) set_ops_scheme\"\n  begin"], ["", "lemmas correct = \n      empty_correct\n      sng_correct\n      memb_correct\n      ins_correct\n      ins_dj_correct\n      delete_correct\n      isEmpty_correct\n      isSng_correct\n      ball_correct\n      bex_correct\n      size_correct\n      size_abort_correct\n      union_correct\n      union_dj_correct\n      diff_correct\n      filter_correct\n      inter_correct\n      subset_correct\n      equal_correct\n      disjoint_correct\n      disjoint_witness_correct\n      to_list_correct\n      to_set_correct"], ["", "end"], ["", "lemmas StdSet_intro = StdSet.intro[rem_dup_prems]"], ["", "locale StdSet_no_invar = StdSet + set_no_invar \\<alpha> invar"], ["", "record ('x,'s) oset_ops = \"('x::linorder,'s) set_ops\" +\n    set_op_ordered_list_it :: \"'s \\<Rightarrow> ('x,'x list) set_iterator\"\n    set_op_rev_list_it :: \"'s \\<Rightarrow> ('x,'x list) set_iterator\"\n    set_op_min :: \"'s \\<Rightarrow> ('x \\<Rightarrow> bool) \\<Rightarrow> 'x option\"\n    set_op_max :: \"'s \\<Rightarrow> ('x \\<Rightarrow> bool) \\<Rightarrow> 'x option\"\n    set_op_to_sorted_list :: \"'s \\<Rightarrow> 'x list\"\n    set_op_to_rev_list :: \"'s \\<Rightarrow> 'x list\""], ["", "locale StdOSetDefs = StdSetDefs ops\n    + poly_set_iterateoi_defs \"set_op_ordered_list_it ops\"\n    + poly_set_rev_iterateoi_defs \"set_op_rev_list_it ops\"\n    for ops :: \"('x::linorder,'s,'more) oset_ops_scheme\"\n  begin"], ["", "abbreviation \"ordered_list_it \\<equiv> set_op_ordered_list_it ops\""], ["", "abbreviation \"rev_list_it \\<equiv> set_op_rev_list_it ops\""], ["", "abbreviation min where \"min == set_op_min ops\""], ["", "abbreviation max where \"max == set_op_max ops\""], ["", "abbreviation to_sorted_list where \n      \"to_sorted_list \\<equiv> set_op_to_sorted_list ops\""], ["", "abbreviation to_rev_list where \"to_rev_list \\<equiv> set_op_to_rev_list ops\""], ["", "end"], ["", "locale StdOSet =\n    StdOSetDefs ops +\n    StdSet ops +\n    poly_set_iterateoi \\<alpha> invar ordered_list_it +\n    poly_set_rev_iterateoi \\<alpha> invar rev_list_it +\n    set_min \\<alpha> invar min +\n    set_max \\<alpha> invar max +\n    set_to_sorted_list \\<alpha> invar to_sorted_list +\n    set_to_rev_list \\<alpha> invar to_rev_list\n    for ops :: \"('x::linorder,'s,'more) oset_ops_scheme\"\n  begin"], ["", "end"], ["", "lemmas StdOSet_intro =\n    StdOSet.intro[OF StdSet_intro, rem_dup_prems]"], ["", "no_notation insert (\"set'_ins\")"], ["", "(*notation member (infixl \"mem\" 55)*)"], ["", "end"]]}