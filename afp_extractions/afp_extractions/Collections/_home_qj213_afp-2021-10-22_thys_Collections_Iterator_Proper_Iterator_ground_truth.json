{"file_name": "/home/qj213/afp-2021-10-22/thys/Collections/Iterator/Proper_Iterator.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Collections", "problem_names": ["lemma proper_itI[intro?]:\n    fixes it :: \"('x,'\\<sigma>1) set_iterator\" \n    and it' :: \"('x,'\\<sigma>2) set_iterator\"\n    assumes \"it=foldli l \\<and> it'=foldli l\"\n    shows \"proper_it it it'\"", "lemma proper_itE:\n    fixes it :: \"('x,'\\<sigma>1) set_iterator\" \n    and it' :: \"('x,'\\<sigma>2) set_iterator\"\n    assumes \"proper_it it it'\"\n    obtains l where \"it=foldli l\" and \"it'=foldli l\"", "lemma proper_it_parE:\n    fixes it :: \"'a \\<Rightarrow> ('x,'\\<sigma>1) set_iterator\" \n    and it' :: \"'a \\<Rightarrow> ('x,'\\<sigma>2) set_iterator\"\n    assumes \"\\<forall>x. proper_it (it x) (it' x)\"\n    obtains f where \"it = (\\<lambda>x. foldli (f x))\" and \"it' = (\\<lambda>x. foldli (f x))\"", "lemma proper_it'I:\n    \"\\<lbrakk>\\<And>s. proper_it (it s) (it' s)\\<rbrakk> \\<Longrightarrow> proper_it' it it'\"", "lemma proper_it'D:\n    \"proper_it' it it' \\<Longrightarrow> proper_it (it s) (it' s)\"", "lemma proper_iterator_trigger: \n    \"proper_it it it' \\<Longrightarrow> proper_it it it'\"\n    \"proper_it' itf itf' \\<Longrightarrow> proper_it' itf itf'\"", "lemma pi_foldli[icf_proper_iteratorI]: \n    \"proper_it (foldli l :: ('a,'\\<sigma>) set_iterator) (foldli l)\"", "lemma pi_foldri[icf_proper_iteratorI]: \n    \"proper_it (foldri l :: ('a,'\\<sigma>) set_iterator) (foldri l)\"", "lemma pi'_foldli[icf_proper_iteratorI]: \n    \"proper_it' (foldli o tsl) (foldli o tsl)\"", "lemma pi'_foldri[icf_proper_iteratorI]: \n    \"proper_it' (foldri o tsl) (foldri o tsl)\"", "lemma pi_emp[icf_proper_iteratorI]: \n    \"proper_it set_iterator_emp set_iterator_emp\"", "lemma pi_sng[icf_proper_iteratorI]:\n    \"proper_it (set_iterator_sng x) (set_iterator_sng x)\"", "lemma pi_union[icf_proper_iteratorI]:\n    assumes PA: \"proper_it it_a it_a'\"\n    assumes PB: \"proper_it it_b it_b'\"\n    shows \"proper_it (set_iterator_union it_a it_b)\n      (set_iterator_union it_a' it_b')\"", "lemma pi_product[icf_proper_iteratorI]:\n    fixes it_a :: \"('a,'\\<sigma>a) set_iterator\"\n    fixes it_b :: \"'a \\<Rightarrow> ('b,'\\<sigma>a) set_iterator\"\n    assumes PA: \"proper_it it_a it_a'\"\n    and PB: \"\\<And>x. proper_it (it_b x) (it_b' x)\"\n    shows \"proper_it (set_iterator_product it_a it_b)\n      (set_iterator_product it_a' it_b')\"", "lemma pi_image_filter[icf_proper_iteratorI]:\n    fixes it :: \"('x,'\\<sigma>1) set_iterator\" \n    and it' :: \"('x,'\\<sigma>2) set_iterator\"\n    and g :: \"'x \\<Rightarrow> 'y option\"\n    assumes P: \"proper_it it it'\"\n    shows \"proper_it (set_iterator_image_filter g it) \n      (set_iterator_image_filter g it')\"", "lemma pi_filter[icf_proper_iteratorI]:\n    assumes P: \"proper_it it it'\"\n    shows \"proper_it (set_iterator_filter P it) \n      (set_iterator_filter P it')\"", "lemma pi_image[icf_proper_iteratorI]:\n    assumes P: \"proper_it it it'\"\n    shows \"proper_it (set_iterator_image g it) \n      (set_iterator_image g it')\"", "lemma pi_dom[icf_proper_iteratorI]:\n    assumes P: \"proper_it it it'\"\n    shows \"proper_it (map_iterator_dom it) \n      (map_iterator_dom it')\"", "lemma set_iterator_product_eq2:\n    assumes \"\\<forall>a\\<in>set la. itb a = itb' a\"\n    shows \"set_iterator_product (foldli la) itb\n    = set_iterator_product (foldli la) itb'\"", "lemma map_it_to_list_genord_correct:\n    assumes A: \"map_iterator_genord (it s) m (\\<lambda>(k,_) (k',_). R k k')\"\n    shows \"map_of (it_to_list it s) = m\n      \\<and> distinct (map fst (it_to_list it s))\n      \\<and> sorted_wrt R ((map fst (it_to_list it s)))\"", "lemma (in linorder) map_it_to_list_linord_correct:\n    assumes A: \"map_iterator_linord (it s) m\"\n    shows \"map_of (it_to_list it s) = m\n      \\<and> distinct (map fst (it_to_list it s))\n      \\<and> sorted ((map fst (it_to_list it s)))\"", "lemma (in linorder) map_it_to_list_rev_linord_correct:\n    assumes A: \"map_iterator_rev_linord (it s) m\"\n    shows \"map_of (it_to_list it s) = m\n      \\<and> distinct (map fst (it_to_list it s))\n      \\<and> sorted (rev (map fst (it_to_list it s)))\""], "translations": [["", "lemma proper_itI[intro?]:\n    fixes it :: \"('x,'\\<sigma>1) set_iterator\" \n    and it' :: \"('x,'\\<sigma>2) set_iterator\"\n    assumes \"it=foldli l \\<and> it'=foldli l\"\n    shows \"proper_it it it'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it it it'", "using assms"], ["proof (prove)\nusing this:\n  it = foldli l \\<and> it' = foldli l\n\ngoal (1 subgoal):\n 1. proper_it it it'", "unfolding proper_it_def"], ["proof (prove)\nusing this:\n  it = foldli l \\<and> it' = foldli l\n\ngoal (1 subgoal):\n 1. \\<exists>l. it = foldli l \\<and> it' = foldli l", "by auto"], ["", "lemma proper_itE:\n    fixes it :: \"('x,'\\<sigma>1) set_iterator\" \n    and it' :: \"('x,'\\<sigma>2) set_iterator\"\n    assumes \"proper_it it it'\"\n    obtains l where \"it=foldli l\" and \"it'=foldli l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>it = foldli l; it' = foldli l\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  proper_it it it'\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>it = foldli l; it' = foldli l\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding proper_it_def"], ["proof (prove)\nusing this:\n  \\<exists>l. it = foldli l \\<and> it' = foldli l\n\ngoal (1 subgoal):\n 1. (\\<And>l.\n        \\<lbrakk>it = foldli l; it' = foldli l\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["", "lemma proper_it_parE:\n    fixes it :: \"'a \\<Rightarrow> ('x,'\\<sigma>1) set_iterator\" \n    and it' :: \"'a \\<Rightarrow> ('x,'\\<sigma>2) set_iterator\"\n    assumes \"\\<forall>x. proper_it (it x) (it' x)\"\n    obtains f where \"it = (\\<lambda>x. foldli (f x))\" and \"it' = (\\<lambda>x. foldli (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>it = (\\<lambda>x. foldli (f x));\n         it' = (\\<lambda>x. foldli (f x))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>x. proper_it (it x) (it' x)\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>it = (\\<lambda>x. foldli (f x));\n         it' = (\\<lambda>x. foldli (f x))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding proper_it_def"], ["proof (prove)\nusing this:\n  \\<forall>x. \\<exists>l. it x = foldli l \\<and> it' x = foldli l\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>it = (\\<lambda>x. foldli (f x));\n         it' = (\\<lambda>x. foldli (f x))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["", "definition \n    proper_it'\n    where \"proper_it' it it' \\<equiv> \\<forall>s. proper_it (it s) (it' s)\""], ["", "lemma proper_it'I:\n    \"\\<lbrakk>\\<And>s. proper_it (it s) (it' s)\\<rbrakk> \\<Longrightarrow> proper_it' it it'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s. proper_it (it s) (it' s)) \\<Longrightarrow> proper_it' it it'", "unfolding proper_it'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s. proper_it (it s) (it' s)) \\<Longrightarrow>\n    \\<forall>s. proper_it (it s) (it' s)", "by blast"], ["", "lemma proper_it'D:\n    \"proper_it' it it' \\<Longrightarrow> proper_it (it s) (it' s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it' it it' \\<Longrightarrow> proper_it (it s) (it' s)", "unfolding proper_it'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s. proper_it (it s) (it' s) \\<Longrightarrow>\n    proper_it (it s) (it' s)", "by blast"], ["", "subsubsection \\<open>Properness Preservation\\<close>"], ["", "ML \\<open>\n    structure Icf_Proper_Iterator = struct\n\n      structure icf_proper_iteratorI = Named_Thms\n        ( val name = @{binding icf_proper_iteratorI_raw}\n          val description = \"ICF (internal): Rules to show properness of iterators\" )\n\n      val get = icf_proper_iteratorI.get\n  \n      fun add_thm thm = icf_proper_iteratorI.add_thm thm\n  \n      val add = Thm.declaration_attribute add_thm\n\n      fun del_thm thm = icf_proper_iteratorI.del_thm thm\n\n      val del = Thm.declaration_attribute del_thm\n\n      val setup = I\n        #> icf_proper_iteratorI.setup\n        #> Attrib.setup @{binding icf_proper_iteratorI} \n          (Attrib.add_del add del) \n          (\"ICF: Rules to show properness of iterators\")\n        #> Global_Theory.add_thms_dynamic (@{binding icf_proper_iteratorI}, \n             get o Context.proof_of\n            )\n        \n  \n    end\n\\<close>"], ["", "setup \\<open>Icf_Proper_Iterator.setup\\<close>"], ["", "lemma proper_iterator_trigger: \n    \"proper_it it it' \\<Longrightarrow> proper_it it it'\"\n    \"proper_it' itf itf' \\<Longrightarrow> proper_it' itf itf'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (proper_it it it' \\<Longrightarrow> proper_it it it') &&&\n    (proper_it' itf itf' \\<Longrightarrow> proper_it' itf itf')", "."], ["", "declaration \\<open>\n    Tagged_Solver.declare_solver @{thms proper_iterator_trigger} \n      @{binding proper_iterator} \"Proper iterator solver\"\n      (fn ctxt => REPEAT_ALL_NEW (resolve_tac ctxt (Icf_Proper_Iterator.get ctxt)))\n\\<close>"], ["", "lemma pi_foldli[icf_proper_iteratorI]: \n    \"proper_it (foldli l :: ('a,'\\<sigma>) set_iterator) (foldli l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it (foldli l) (foldli l)", "unfolding proper_it_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>la. foldli l = foldli la \\<and> foldli l = foldli la", "by auto"], ["", "lemma pi_foldri[icf_proper_iteratorI]: \n    \"proper_it (foldri l :: ('a,'\\<sigma>) set_iterator) (foldri l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it (foldri l) (foldri l)", "unfolding proper_it_def foldri_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>la.\n       foldli (rev l) = foldli la \\<and> foldli (rev l) = foldli la", "by auto"], ["", "lemma pi'_foldli[icf_proper_iteratorI]: \n    \"proper_it' (foldli o tsl) (foldli o tsl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it' (foldli \\<circ> tsl) (foldli \\<circ> tsl)", "apply (clarsimp simp add: proper_it'_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s. proper_it (foldli (tsl s)) (foldli (tsl s))", "apply (tagged_solver)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma pi'_foldri[icf_proper_iteratorI]: \n    \"proper_it' (foldri o tsl) (foldri o tsl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it' (foldri \\<circ> tsl) (foldri \\<circ> tsl)", "apply (clarsimp simp add: proper_it'_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s. proper_it (foldri (tsl s)) (foldri (tsl s))", "apply (tagged_solver)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Iterator combinators preserve properness\\<close>"], ["", "lemma pi_emp[icf_proper_iteratorI]: \n    \"proper_it set_iterator_emp set_iterator_emp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it set_iterator_emp set_iterator_emp", "unfolding proper_it_def set_iterator_emp_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>l.\n       (\\<lambda>c f \\<sigma>0. \\<sigma>0) = foldli l \\<and>\n       (\\<lambda>c f \\<sigma>0. \\<sigma>0) = foldli l", "by (auto intro!: ext exI[where x=\"[]\"])"], ["", "lemma pi_sng[icf_proper_iteratorI]:\n    \"proper_it (set_iterator_sng x) (set_iterator_sng x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it (set_iterator_sng x) (set_iterator_sng x)", "unfolding proper_it_def set_iterator_sng_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>l.\n       (\\<lambda>c f \\<sigma>0.\n           if c \\<sigma>0 then f x \\<sigma>0 else \\<sigma>0) =\n       foldli l \\<and>\n       (\\<lambda>c f \\<sigma>0.\n           if c \\<sigma>0 then f x \\<sigma>0 else \\<sigma>0) =\n       foldli l", "by (auto intro!: ext exI[where x=\"[x]\"])"], ["", "lemma pi_union[icf_proper_iteratorI]:\n    assumes PA: \"proper_it it_a it_a'\"\n    assumes PB: \"proper_it it_b it_b'\"\n    shows \"proper_it (set_iterator_union it_a it_b)\n      (set_iterator_union it_a' it_b')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it (set_iterator_union it_a it_b)\n     (set_iterator_union it_a' it_b')", "unfolding set_iterator_union_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it (\\<lambda>c f \\<sigma>0. it_b c f (it_a c f \\<sigma>0))\n     (\\<lambda>c f \\<sigma>0. it_b' c f (it_a' c f \\<sigma>0))", "apply (rule proper_itE[OF PA])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>it_a = foldli l; it_a' = foldli l\\<rbrakk>\n       \\<Longrightarrow> proper_it\n                          (\\<lambda>c f \\<sigma>0.\n                              it_b c f (it_a c f \\<sigma>0))\n                          (\\<lambda>c f \\<sigma>0.\n                              it_b' c f (it_a' c f \\<sigma>0))", "apply (rule proper_itE[OF PB])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l la.\n       \\<lbrakk>it_a = foldli l; it_a' = foldli l; it_b = foldli la;\n        it_b' = foldli la\\<rbrakk>\n       \\<Longrightarrow> proper_it\n                          (\\<lambda>c f \\<sigma>0.\n                              it_b c f (it_a c f \\<sigma>0))\n                          (\\<lambda>c f \\<sigma>0.\n                              it_b' c f (it_a' c f \\<sigma>0))", "apply (rule_tac l=\"l@la\" in proper_itI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l la.\n       \\<lbrakk>it_a = foldli l; it_a' = foldli l; it_b = foldli la;\n        it_b' = foldli la\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>c f \\<sigma>0.\n                             it_b c f (it_a c f \\<sigma>0)) =\n                         foldli (l @ la) \\<and>\n                         (\\<lambda>c f \\<sigma>0.\n                             it_b' c f (it_a' c f \\<sigma>0)) =\n                         foldli (l @ la)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l la.\n       \\<lbrakk>it_a = foldli l; it_a' = foldli l; it_b = foldli la;\n        it_b' = foldli la\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>c f \\<sigma>0.\n                             foldli la c f (foldli l c f \\<sigma>0)) =\n                         foldli (l @ la) \\<and>\n                         (\\<lambda>c f \\<sigma>0.\n                             foldli la c f (foldli l c f \\<sigma>0)) =\n                         foldli (l @ la)", "apply (intro conjI ext)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l la c f \\<sigma>0.\n       \\<lbrakk>it_a = foldli l; it_a' = foldli l; it_b = foldli la;\n        it_b' = foldli la\\<rbrakk>\n       \\<Longrightarrow> foldli la c f (foldli l c f \\<sigma>0) =\n                         foldli (l @ la) c f \\<sigma>0\n 2. \\<And>l la c f \\<sigma>0.\n       \\<lbrakk>it_a = foldli l; it_a' = foldli l; it_b = foldli la;\n        it_b' = foldli la\\<rbrakk>\n       \\<Longrightarrow> foldli la c f (foldli l c f \\<sigma>0) =\n                         foldli (l @ la) c f \\<sigma>0", "apply (simp_all add: foldli_append)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma pi_product[icf_proper_iteratorI]:\n    fixes it_a :: \"('a,'\\<sigma>a) set_iterator\"\n    fixes it_b :: \"'a \\<Rightarrow> ('b,'\\<sigma>a) set_iterator\"\n    assumes PA: \"proper_it it_a it_a'\"\n    and PB: \"\\<And>x. proper_it (it_b x) (it_b' x)\"\n    shows \"proper_it (set_iterator_product it_a it_b)\n      (set_iterator_product it_a' it_b')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it (set_iterator_product it_a it_b)\n     (set_iterator_product it_a' it_b')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. proper_it (set_iterator_product it_a it_b)\n     (set_iterator_product it_a' it_b')", "from PB"], ["proof (chain)\npicking this:\n  proper_it (it_b ?x) (it_b' ?x)", "have PB': \"\\<forall>x. proper_it (it_b x) (it_b' x)\""], ["proof (prove)\nusing this:\n  proper_it (it_b ?x) (it_b' ?x)\n\ngoal (1 subgoal):\n 1. \\<forall>x. proper_it (it_b x) (it_b' x)", ".."], ["proof (state)\nthis:\n  \\<forall>x. proper_it (it_b x) (it_b' x)\n\ngoal (1 subgoal):\n 1. proper_it (set_iterator_product it_a it_b)\n     (set_iterator_product it_a' it_b')", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it (set_iterator_product it_a it_b)\n     (set_iterator_product it_a' it_b')", "unfolding proper_it_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>l.\n       set_iterator_product it_a it_b = foldli l \\<and>\n       set_iterator_product it_a' it_b' = foldli l", "apply (rule proper_itE[OF PA])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>it_a = foldli l; it_a' = foldli l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            set_iterator_product it_a it_b = foldli l \\<and>\n                            set_iterator_product it_a' it_b' = foldli l", "apply (rule proper_it_parE[OF PB'])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l f.\n       \\<lbrakk>it_a = foldli l; it_a' = foldli l;\n        it_b = (\\<lambda>x. foldli (f x));\n        it_b' = (\\<lambda>x. foldli (f x))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            set_iterator_product it_a it_b = foldli l \\<and>\n                            set_iterator_product it_a' it_b' = foldli l", "apply (auto simp add: set_iterator_product_foldli_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  proper_it (set_iterator_product it_a it_b)\n   (set_iterator_product it_a' it_b')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pi_image_filter[icf_proper_iteratorI]:\n    fixes it :: \"('x,'\\<sigma>1) set_iterator\" \n    and it' :: \"('x,'\\<sigma>2) set_iterator\"\n    and g :: \"'x \\<Rightarrow> 'y option\"\n    assumes P: \"proper_it it it'\"\n    shows \"proper_it (set_iterator_image_filter g it) \n      (set_iterator_image_filter g it')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it (set_iterator_image_filter g it)\n     (set_iterator_image_filter g it')", "unfolding proper_it_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>l.\n       set_iterator_image_filter g it = foldli l \\<and>\n       set_iterator_image_filter g it' = foldli l", "apply (rule proper_itE[OF P])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>it = foldli l; it' = foldli l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            set_iterator_image_filter g it = foldli l \\<and>\n                            set_iterator_image_filter g it' = foldli l", "apply (auto simp: set_iterator_image_filter_foldli_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma pi_filter[icf_proper_iteratorI]:\n    assumes P: \"proper_it it it'\"\n    shows \"proper_it (set_iterator_filter P it) \n      (set_iterator_filter P it')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it (set_iterator_filter P it) (set_iterator_filter P it')", "unfolding proper_it_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>l.\n       set_iterator_filter P it = foldli l \\<and>\n       set_iterator_filter P it' = foldli l", "apply (rule proper_itE[OF P])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>it = foldli l; it' = foldli l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            set_iterator_filter P it = foldli l \\<and>\n                            set_iterator_filter P it' = foldli l", "by (auto simp: set_iterator_filter_foldli_conv)"], ["", "lemma pi_image[icf_proper_iteratorI]:\n    assumes P: \"proper_it it it'\"\n    shows \"proper_it (set_iterator_image g it) \n      (set_iterator_image g it')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it (set_iterator_image g it) (set_iterator_image g it')", "unfolding proper_it_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>l.\n       set_iterator_image g it = foldli l \\<and>\n       set_iterator_image g it' = foldli l", "apply (rule proper_itE[OF P])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>it = foldli l; it' = foldli l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            set_iterator_image g it = foldli l \\<and>\n                            set_iterator_image g it' = foldli l", "by (auto simp: set_iterator_image_foldli_conv)"], ["", "lemma pi_dom[icf_proper_iteratorI]:\n    assumes P: \"proper_it it it'\"\n    shows \"proper_it (map_iterator_dom it) \n      (map_iterator_dom it')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it (map_iterator_dom it) (map_iterator_dom it')", "unfolding proper_it_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>l.\n       map_iterator_dom it = foldli l \\<and> map_iterator_dom it' = foldli l", "apply (rule proper_itE[OF P])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l.\n       \\<lbrakk>it = foldli l; it' = foldli l\\<rbrakk>\n       \\<Longrightarrow> \\<exists>l.\n                            map_iterator_dom it = foldli l \\<and>\n                            map_iterator_dom it' = foldli l", "by (auto simp: map_iterator_dom_foldli_conv)"], ["", "lemma set_iterator_product_eq2:\n    assumes \"\\<forall>a\\<in>set la. itb a = itb' a\"\n    shows \"set_iterator_product (foldli la) itb\n    = set_iterator_product (foldli la) itb'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_product (foldli la) itb =\n    set_iterator_product (foldli la) itb'", "proof (intro ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       set_iterator_product (foldli la) itb x xa xb =\n       set_iterator_product (foldli la) itb' x xa xb", "fix c f \\<sigma>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       set_iterator_product (foldli la) itb x xa xb =\n       set_iterator_product (foldli la) itb' x xa xb", "show \"set_iterator_product (foldli la) itb c f \\<sigma>\n      = set_iterator_product (foldli la) itb' c f \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_product (foldli la) itb c f \\<sigma> =\n    set_iterator_product (foldli la) itb' c f \\<sigma>", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set la. itb a = itb' a\n\ngoal (1 subgoal):\n 1. set_iterator_product (foldli la) itb c f \\<sigma> =\n    set_iterator_product (foldli la) itb' c f \\<sigma>", "unfolding set_iterator_product_def"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>set la. itb a = itb' a\n\ngoal (1 subgoal):\n 1. foldli la c (\\<lambda>a. itb a c (\\<lambda>b. f (a, b))) \\<sigma> =\n    foldli la c (\\<lambda>a. itb' a c (\\<lambda>b. f (a, b))) \\<sigma>", "apply (induct la arbitrary: \\<sigma>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma>.\n       \\<forall>a\\<in>set []. itb a = itb' a \\<Longrightarrow>\n       foldli [] c (\\<lambda>a. itb a c (\\<lambda>b. f (a, b))) \\<sigma> =\n       foldli [] c (\\<lambda>a. itb' a c (\\<lambda>b. f (a, b))) \\<sigma>\n 2. \\<And>a la \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   \\<forall>a\\<in>set la. itb a = itb' a \\<Longrightarrow>\n                   foldli la c (\\<lambda>a. itb a c (\\<lambda>b. f (a, b)))\n                    \\<sigma> =\n                   foldli la c (\\<lambda>a. itb' a c (\\<lambda>b. f (a, b)))\n                    \\<sigma>;\n        \\<forall>a\\<in>set (a # la). itb a = itb' a\\<rbrakk>\n       \\<Longrightarrow> foldli (a # la) c\n                          (\\<lambda>a. itb a c (\\<lambda>b. f (a, b)))\n                          \\<sigma> =\n                         foldli (a # la) c\n                          (\\<lambda>a. itb' a c (\\<lambda>b. f (a, b)))\n                          \\<sigma>", "apply (auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  set_iterator_product (foldli la) itb c f \\<sigma> =\n  set_iterator_product (foldli la) itb' c f \\<sigma>\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Optimizing Folds\\<close>"], ["", "text \\<open>\n    Using an iterator to create a list. The optimizations will\n    match the pattern \\<open>foldli (it_to_list it s)\\<close>\n\\<close>"], ["", "definition \"it_to_list it s \\<equiv> (it s) (\\<lambda>_. True) (\\<lambda>x l. l@[x]) []\""], ["", "lemma map_it_to_list_genord_correct:\n    assumes A: \"map_iterator_genord (it s) m (\\<lambda>(k,_) (k',_). R k k')\"\n    shows \"map_of (it_to_list it s) = m\n      \\<and> distinct (map fst (it_to_list it s))\n      \\<and> sorted_wrt R ((map fst (it_to_list it s)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (it_to_list it s) = m \\<and>\n    distinct (map fst (it_to_list it s)) \\<and>\n    sorted_wrt R (map fst (it_to_list it s))", "unfolding it_to_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (it s (\\<lambda>_. True) (\\<lambda>x l. l @ [x]) []) = m \\<and>\n    distinct\n     (map fst (it s (\\<lambda>_. True) (\\<lambda>x l. l @ [x]) [])) \\<and>\n    sorted_wrt R\n     (map fst (it s (\\<lambda>_. True) (\\<lambda>x l. l @ [x]) []))", "apply (rule map_iterator_genord_rule_insert_P[OF A, where I=\"\n      \\<lambda>it l. map_of l = m |` it \n        \\<and> distinct (map fst l) \n        \\<and> sorted_wrt R ((map fst l))\n      \"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. map_of [] = m |` {} \\<and>\n    distinct (map fst []) \\<and> sorted_wrt R (map fst [])\n 2. \\<And>k v it \\<sigma>.\n       \\<lbrakk>True; k \\<in> dom m - it; m k = Some v;\n        it \\<subseteq> dom m;\n        map_of \\<sigma> = m |` it \\<and>\n        distinct (map fst \\<sigma>) \\<and> sorted_wrt R (map fst \\<sigma>);\n        \\<forall>k' v'.\n           k' \\<in> dom m - it - {k} \\<and> m k' = Some v' \\<longrightarrow>\n           (case (k, v) of\n            (k, uu_) \\<Rightarrow> \\<lambda>(k', uu_). R k k')\n            (k', v');\n        \\<forall>k' v'.\n           k' \\<in> it \\<and> m k' = Some v' \\<longrightarrow>\n           (case (k', v') of\n            (k, uu_) \\<Rightarrow> \\<lambda>(k', uu_). R k k')\n            (k, v)\\<rbrakk>\n       \\<Longrightarrow> map_of (\\<sigma> @ [(k, v)]) =\n                         m |` insert k it \\<and>\n                         distinct (map fst (\\<sigma> @ [(k, v)])) \\<and>\n                         sorted_wrt R (map fst (\\<sigma> @ [(k, v)]))\n 3. \\<And>\\<sigma>.\n       map_of \\<sigma> = m |` dom m \\<and>\n       distinct (map fst \\<sigma>) \\<and>\n       sorted_wrt R (map fst \\<sigma>) \\<Longrightarrow>\n       map_of \\<sigma> = m \\<and>\n       distinct (map fst \\<sigma>) \\<and> sorted_wrt R (map fst \\<sigma>)\n 4. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom m; it \\<noteq> dom m; \\<not> True;\n        map_of \\<sigma> = m |` it \\<and>\n        distinct (map fst \\<sigma>) \\<and> sorted_wrt R (map fst \\<sigma>);\n        \\<forall>k v k' v'.\n           k \\<in> it \\<and>\n           m k = Some v \\<and>\n           k' \\<notin> it \\<and> m k' = Some v' \\<longrightarrow>\n           (case (k, v) of\n            (k, uu_) \\<Rightarrow> \\<lambda>(k', uu_). R k k')\n            (k', v')\\<rbrakk>\n       \\<Longrightarrow> map_of \\<sigma> = m \\<and>\n                         distinct (map fst \\<sigma>) \\<and>\n                         sorted_wrt R (map fst \\<sigma>)", "apply auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>it \\<subseteq> dom m;\n        \\<forall>k'.\n           k' \\<in> dom m \\<and>\n           k' \\<notin> it \\<and>\n           k' \\<noteq> k \\<and>\n           (\\<exists>v'. m k' = Some v') \\<longrightarrow>\n           R k k';\n        \\<forall>k'.\n           k' \\<in> it \\<and>\n           (\\<exists>v'. m k' = Some v') \\<longrightarrow>\n           R k' k;\n        k \\<notin> it; m k = Some v; map_of \\<sigma> = m |` it;\n        distinct (map fst \\<sigma>);\n        sorted_wrt R (map fst \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> (m |` it)(k \\<mapsto> v) = m |` insert k it\n 2. \\<And>it \\<sigma> y a b.\n       \\<lbrakk>m a = Some y; it \\<subseteq> dom m;\n        \\<forall>k'.\n           k' \\<in> dom m \\<and>\n           k' \\<notin> it \\<and>\n           k' \\<noteq> a \\<and>\n           (\\<exists>v'. m k' = Some v') \\<longrightarrow>\n           R a k';\n        \\<forall>k'.\n           k' \\<in> it \\<and>\n           (\\<exists>v'. m k' = Some v') \\<longrightarrow>\n           R k' a;\n        a \\<notin> it; map_of \\<sigma> = m |` it;\n        distinct (map fst \\<sigma>); sorted_wrt R (map fst \\<sigma>);\n        (a, b) \\<in> set \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>k v it \\<sigma>.\n       \\<lbrakk>it \\<subseteq> dom m;\n        \\<forall>k'.\n           k' \\<in> dom m \\<and>\n           k' \\<notin> it \\<and>\n           k' \\<noteq> k \\<and>\n           (\\<exists>v'. m k' = Some v') \\<longrightarrow>\n           R k k';\n        \\<forall>k'.\n           k' \\<in> it \\<and>\n           (\\<exists>v'. m k' = Some v') \\<longrightarrow>\n           R k' k;\n        k \\<notin> it; m k = Some v; map_of \\<sigma> = m |` it;\n        distinct (map fst \\<sigma>);\n        sorted_wrt R (map fst \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt R (map fst \\<sigma> @ [k])", "apply (auto simp: restrict_map_def) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>it \\<sigma> y a b.\n       \\<lbrakk>m a = Some y; it \\<subseteq> dom m;\n        \\<forall>k'.\n           k' \\<in> dom m \\<and>\n           k' \\<notin> it \\<and>\n           k' \\<noteq> a \\<and>\n           (\\<exists>v'. m k' = Some v') \\<longrightarrow>\n           R a k';\n        \\<forall>k'.\n           k' \\<in> it \\<and>\n           (\\<exists>v'. m k' = Some v') \\<longrightarrow>\n           R k' a;\n        a \\<notin> it; map_of \\<sigma> = m |` it;\n        distinct (map fst \\<sigma>); sorted_wrt R (map fst \\<sigma>);\n        (a, b) \\<in> set \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>k v it \\<sigma>.\n       \\<lbrakk>it \\<subseteq> dom m;\n        \\<forall>k'.\n           k' \\<in> dom m \\<and>\n           k' \\<notin> it \\<and>\n           k' \\<noteq> k \\<and>\n           (\\<exists>v'. m k' = Some v') \\<longrightarrow>\n           R k k';\n        \\<forall>k'.\n           k' \\<in> it \\<and>\n           (\\<exists>v'. m k' = Some v') \\<longrightarrow>\n           R k' k;\n        k \\<notin> it; m k = Some v; map_of \\<sigma> = m |` it;\n        distinct (map fst \\<sigma>);\n        sorted_wrt R (map fst \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt R (map fst \\<sigma> @ [k])", "apply (metis Some_eq_map_of_iff restrict_map_eq(2))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>it \\<subseteq> dom m;\n        \\<forall>k'.\n           k' \\<in> dom m \\<and>\n           k' \\<notin> it \\<and>\n           k' \\<noteq> k \\<and>\n           (\\<exists>v'. m k' = Some v') \\<longrightarrow>\n           R k k';\n        \\<forall>k'.\n           k' \\<in> it \\<and>\n           (\\<exists>v'. m k' = Some v') \\<longrightarrow>\n           R k' k;\n        k \\<notin> it; m k = Some v; map_of \\<sigma> = m |` it;\n        distinct (map fst \\<sigma>);\n        sorted_wrt R (map fst \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> sorted_wrt R (map fst \\<sigma> @ [k])", "apply (auto simp add: sorted_wrt_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>k v it \\<sigma> a b.\n       \\<lbrakk>it \\<subseteq> dom m;\n        \\<forall>k'.\n           k' \\<in> dom m \\<and>\n           k' \\<notin> it \\<and>\n           k' \\<noteq> k \\<and>\n           (\\<exists>v'. m k' = Some v') \\<longrightarrow>\n           R k k';\n        \\<forall>k'.\n           k' \\<in> it \\<and>\n           (\\<exists>v'. m k' = Some v') \\<longrightarrow>\n           R k' k;\n        k \\<notin> it; m k = Some v; map_of \\<sigma> = m |` it;\n        distinct (map fst \\<sigma>); sorted_wrt R (map fst \\<sigma>);\n        (a, b) \\<in> set \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> R a k", "by (metis (lifting) restrict_map_eq(2) weak_map_of_SomeI)"], ["", "lemma (in linorder) map_it_to_list_linord_correct:\n    assumes A: \"map_iterator_linord (it s) m\"\n    shows \"map_of (it_to_list it s) = m\n      \\<and> distinct (map fst (it_to_list it s))\n      \\<and> sorted ((map fst (it_to_list it s)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (it_to_list it s) = m \\<and>\n    distinct (map fst (it_to_list it s)) \\<and>\n    sorted (map fst (it_to_list it s))", "using map_it_to_list_genord_correct[where it=it,\n      OF A[unfolded set_iterator_map_linord_def]]"], ["proof (prove)\nusing this:\n  map_of (it_to_list it s) = m \\<and>\n  distinct (map fst (it_to_list it s)) \\<and>\n  sorted_wrt (\\<le>) (map fst (it_to_list it s))\n\ngoal (1 subgoal):\n 1. map_of (it_to_list it s) = m \\<and>\n    distinct (map fst (it_to_list it s)) \\<and>\n    sorted (map fst (it_to_list it s))", "by (simp add: sorted_sorted_wrt)"], ["", "lemma (in linorder) map_it_to_list_rev_linord_correct:\n    assumes A: \"map_iterator_rev_linord (it s) m\"\n    shows \"map_of (it_to_list it s) = m\n      \\<and> distinct (map fst (it_to_list it s))\n      \\<and> sorted (rev (map fst (it_to_list it s)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (it_to_list it s) = m \\<and>\n    distinct (map fst (it_to_list it s)) \\<and>\n    sorted (rev (map fst (it_to_list it s)))", "using map_it_to_list_genord_correct[where it=it,\n      OF A[unfolded set_iterator_map_rev_linord_def]]"], ["proof (prove)\nusing this:\n  map_of (it_to_list it s) = m \\<and>\n  distinct (map fst (it_to_list it s)) \\<and>\n  sorted_wrt (\\<lambda>k k'. k' \\<le> k) (map fst (it_to_list it s))\n\ngoal (1 subgoal):\n 1. map_of (it_to_list it s) = m \\<and>\n    distinct (map fst (it_to_list it s)) \\<and>\n    sorted (rev (map fst (it_to_list it s)))", "by simp"], ["", "end"]]}