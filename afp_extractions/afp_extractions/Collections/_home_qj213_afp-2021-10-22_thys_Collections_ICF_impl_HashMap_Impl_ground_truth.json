{"file_name": "/home/qj213/afp-2021-10-22/thys/Collections/ICF/impl/HashMap_Impl.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Collections", "problem_names": ["lemma ahm_invarI: \"\\<lbrakk> \n  !!hc cm k. \\<lbrakk>m hc = Some cm; k\\<in>dom cm\\<rbrakk> \\<Longrightarrow> hashcode k = hc;\n  !!hc cm. \\<lbrakk> m hc = Some cm \\<rbrakk> \\<Longrightarrow> cm \\<noteq> Map.empty\n  \\<rbrakk> \\<Longrightarrow> ahm_invar m\"", "lemma ahm_invarD: \"\\<lbrakk> ahm_invar m; m hc = Some cm; k\\<in>dom cm \\<rbrakk> \\<Longrightarrow> hashcode k = hc\"", "lemma ahm_invarDne: \"\\<lbrakk> ahm_invar m; m hc = Some cm \\<rbrakk> \\<Longrightarrow> cm \\<noteq> Map.empty\"", "lemma ahm_invar_bucket_not_empty[simp]: \n  \"ahm_invar m \\<Longrightarrow> m hc \\<noteq> Some Map.empty\"", "lemmas ahm_lookup_correct = ahm_lookup_def", "lemma ahm_empty_correct: \n  \"ahm_\\<alpha> ahm_empty = Map.empty\"\n  \"ahm_invar ahm_empty\"", "lemma ahm_update_correct: \n  \"ahm_\\<alpha> (ahm_update k v m) = ahm_\\<alpha> m (k \\<mapsto> v)\"\n  \"ahm_invar m \\<Longrightarrow> ahm_invar (ahm_update k v m)\"", "lemma fun_upd_apply_ne: \"x\\<noteq>y \\<Longrightarrow> (f(x:=v)) y = f y\"", "lemma cancel_one_empty_simp: \"m |` (-{k}) = Map.empty \\<longleftrightarrow> dom m \\<subseteq> {k}\"", "lemma ahm_delete_correct: \n  \"ahm_\\<alpha> (ahm_delete k m) = (ahm_\\<alpha> m) |` (-{k})\"\n  \"ahm_invar m \\<Longrightarrow> ahm_invar (ahm_delete k m)\"", "lemma ahm_isEmpty_correct: \"ahm_invar m \\<Longrightarrow> ahm_isEmpty m \\<longleftrightarrow> ahm_\\<alpha> m = Map.empty\"", "lemmas ahm_correct = ahm_empty_correct ahm_lookup_correct ahm_update_correct \n                     ahm_delete_correct ahm_isEmpty_correct\n\n  \\<comment> \\<open>Bucket entries correspond to map entries\\<close>", "lemma ahm_be_is_e:\n  assumes I: \"ahm_invar m\"\n  assumes A: \"m hc = Some bm\" \"bm k = Some v\"\n  shows \"ahm_\\<alpha> m k = Some v\"", "lemma ahm_e_is_be: \"\\<lbrakk>\n  ahm_\\<alpha> m k = Some v; \n  !!bm. \\<lbrakk>m (hashcode k) = Some bm; bm k = Some v \\<rbrakk> \\<Longrightarrow> P\n  \\<rbrakk> \\<Longrightarrow> P\"", "lemma iteratei_alt_def :\n  \"iteratei m = set_iterator_image snd (\n     set_iterator_product (rm.iteratei m) (\\<lambda>hclm. lm.iteratei (snd hclm)))\"", "lemma rm_map_entry_correct:\n  \"rm.\\<alpha> (rm_map_entry k f m) = (rm.\\<alpha> m)(k := f (rm.\\<alpha> m k))\"", "lemma empty_correct': \n  \"hm_\\<alpha>' (empty ()) = ahm_empty\"\n  \"invar (empty ())\"", "lemma lookup_correct': \n  \"invar m \\<Longrightarrow> lookup k m = ahm_lookup k (hm_\\<alpha>' m)\"", "lemma update_correct': \n  \"invar m \\<Longrightarrow> hm_\\<alpha>' (update k v m) = ahm_update k v (hm_\\<alpha>' m)\"\n  \"invar m \\<Longrightarrow> invar (update k v m)\"", "lemma delete_correct':\n  \"invar m \\<Longrightarrow> hm_\\<alpha>' (delete k m) = ahm_delete k (hm_\\<alpha>' m)\"\n  \"invar m \\<Longrightarrow> invar (delete k m)\"", "lemma isEmpty_correct':\n  \"invar hm \\<Longrightarrow> isEmpty hm \\<longleftrightarrow> ahm_\\<alpha> (hm_\\<alpha>' hm) = Map.empty\"", "lemma iteratei_correct':\n  assumes invar: \"invar hm\"\n  shows \"map_iterator (iteratei hm) (ahm_\\<alpha> (hm_\\<alpha>' hm))\"", "lemmas hm_correct' = empty_correct' lookup_correct' update_correct' \n                     delete_correct' isEmpty_correct' \n                     iteratei_correct'", "lemmas hm_invars = empty_correct'(2) update_correct'(2) \n                   delete_correct'(2)"], "translations": [["", "lemma ahm_invarI: \"\\<lbrakk> \n  !!hc cm k. \\<lbrakk>m hc = Some cm; k\\<in>dom cm\\<rbrakk> \\<Longrightarrow> hashcode k = hc;\n  !!hc cm. \\<lbrakk> m hc = Some cm \\<rbrakk> \\<Longrightarrow> cm \\<noteq> Map.empty\n  \\<rbrakk> \\<Longrightarrow> ahm_invar m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>hc cm k.\n                \\<lbrakk>m hc = Some cm; k \\<in> dom cm\\<rbrakk>\n                \\<Longrightarrow> hashcode k = hc;\n     \\<And>hc cm.\n        m hc = Some cm \\<Longrightarrow> cm \\<noteq> Map.empty\\<rbrakk>\n    \\<Longrightarrow> ahm_invar m", "by (unfold ahm_invar_def) blast"], ["", "lemma ahm_invarD: \"\\<lbrakk> ahm_invar m; m hc = Some cm; k\\<in>dom cm \\<rbrakk> \\<Longrightarrow> hashcode k = hc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ahm_invar m; m hc = Some cm; k \\<in> dom cm\\<rbrakk>\n    \\<Longrightarrow> hashcode k = hc", "by (unfold ahm_invar_def) blast"], ["", "lemma ahm_invarDne: \"\\<lbrakk> ahm_invar m; m hc = Some cm \\<rbrakk> \\<Longrightarrow> cm \\<noteq> Map.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ahm_invar m; m hc = Some cm\\<rbrakk>\n    \\<Longrightarrow> cm \\<noteq> Map.empty", "by (unfold ahm_invar_def) blast"], ["", "lemma ahm_invar_bucket_not_empty[simp]: \n  \"ahm_invar m \\<Longrightarrow> m hc \\<noteq> Some Map.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ahm_invar m \\<Longrightarrow> m hc \\<noteq> Some Map.empty", "by (auto dest: ahm_invarDne)"], ["", "lemmas ahm_lookup_correct = ahm_lookup_def"], ["", "lemma ahm_empty_correct: \n  \"ahm_\\<alpha> ahm_empty = Map.empty\"\n  \"ahm_invar ahm_empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ahm_\\<alpha> ahm_empty = Map.empty &&& ahm_invar ahm_empty", "apply (rule ext)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. ahm_\\<alpha> ahm_empty x = None\n 2. ahm_invar ahm_empty", "apply (unfold ahm_empty_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. ahm_\\<alpha> Map.empty x = None\n 2. ahm_invar Map.empty", "apply (auto simp add: ahm_\\<alpha>_def intro: ahm_invarI split: option.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ahm_update_correct: \n  \"ahm_\\<alpha> (ahm_update k v m) = ahm_\\<alpha> m (k \\<mapsto> v)\"\n  \"ahm_invar m \\<Longrightarrow> ahm_invar (ahm_update k v m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ahm_\\<alpha> (ahm_update k v m) = ahm_\\<alpha> m(k \\<mapsto> v) &&&\n    (ahm_invar m \\<Longrightarrow> ahm_invar (ahm_update k v m))", "apply (rule ext)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       ahm_\\<alpha> (ahm_update k v m) x = (ahm_\\<alpha> m(k \\<mapsto> v)) x\n 2. ahm_invar m \\<Longrightarrow> ahm_invar (ahm_update k v m)", "apply (unfold ahm_update_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       ahm_\\<alpha>\n        (case m (hashcode k) of\n         None \\<Rightarrow> m(hashcode k \\<mapsto> [k \\<mapsto> v])\n         | Some cm \\<Rightarrow> m(hashcode k \\<mapsto> cm(k \\<mapsto> v)))\n        x =\n       (ahm_\\<alpha> m(k \\<mapsto> v)) x\n 2. ahm_invar m \\<Longrightarrow>\n    ahm_invar\n     (case m (hashcode k) of\n      None \\<Rightarrow> m(hashcode k \\<mapsto> [k \\<mapsto> v])\n      | Some cm \\<Rightarrow> m(hashcode k \\<mapsto> cm(k \\<mapsto> v)))", "apply (auto simp add: ahm_\\<alpha>_def split: option.split)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ahm_invar m; m (hashcode k) = None\\<rbrakk>\n    \\<Longrightarrow> ahm_invar (m(hashcode k \\<mapsto> [k \\<mapsto> v]))\n 2. \\<And>x2.\n       \\<lbrakk>ahm_invar m; m (hashcode k) = Some x2\\<rbrakk>\n       \\<Longrightarrow> ahm_invar\n                          (m(hashcode k \\<mapsto> x2(k \\<mapsto> v)))", "apply (rule ahm_invarI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>hc cm ka.\n       \\<lbrakk>ahm_invar m; m (hashcode k) = None;\n        (m(hashcode k \\<mapsto> [k \\<mapsto> v])) hc = Some cm;\n        ka \\<in> dom cm\\<rbrakk>\n       \\<Longrightarrow> hashcode ka = hc\n 2. \\<And>hc cm.\n       \\<lbrakk>ahm_invar m; m (hashcode k) = None;\n        (m(hashcode k \\<mapsto> [k \\<mapsto> v])) hc = Some cm\\<rbrakk>\n       \\<Longrightarrow> cm \\<noteq> Map.empty\n 3. \\<And>x2.\n       \\<lbrakk>ahm_invar m; m (hashcode k) = Some x2\\<rbrakk>\n       \\<Longrightarrow> ahm_invar\n                          (m(hashcode k \\<mapsto> x2(k \\<mapsto> v)))", "apply (auto dest: ahm_invarD ahm_invarDne split: if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>ahm_invar m; m (hashcode k) = Some x2\\<rbrakk>\n       \\<Longrightarrow> ahm_invar\n                          (m(hashcode k \\<mapsto> x2(k \\<mapsto> v)))", "apply (rule ahm_invarI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x2 hc cm ka.\n       \\<lbrakk>ahm_invar m; m (hashcode k) = Some x2;\n        (m(hashcode k \\<mapsto> x2(k \\<mapsto> v))) hc = Some cm;\n        ka \\<in> dom cm\\<rbrakk>\n       \\<Longrightarrow> hashcode ka = hc\n 2. \\<And>x2 hc cm.\n       \\<lbrakk>ahm_invar m; m (hashcode k) = Some x2;\n        (m(hashcode k \\<mapsto> x2(k \\<mapsto> v))) hc = Some cm\\<rbrakk>\n       \\<Longrightarrow> cm \\<noteq> Map.empty", "apply (auto dest: ahm_invarD split: if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2 ka y.\n       \\<lbrakk>ahm_invar m; m (hashcode k) = Some x2; ka \\<noteq> k;\n        x2 ka = Some y\\<rbrakk>\n       \\<Longrightarrow> hashcode ka = hashcode k", "apply (drule (1) ahm_invarD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x2 ka y.\n       \\<lbrakk>m (hashcode k) = Some x2; ka \\<noteq> k;\n        x2 ka = Some y\\<rbrakk>\n       \\<Longrightarrow> ?k208 x2 ka y \\<in> dom x2\n 2. \\<And>x2 ka y.\n       \\<lbrakk>m (hashcode k) = Some x2; ka \\<noteq> k; x2 ka = Some y;\n        hashcode (?k208 x2 ka y) = hashcode k\\<rbrakk>\n       \\<Longrightarrow> hashcode ka = hashcode k", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fun_upd_apply_ne: \"x\\<noteq>y \\<Longrightarrow> (f(x:=v)) y = f y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> (f(x := v)) y = f y", "by simp"], ["", "lemma cancel_one_empty_simp: \"m |` (-{k}) = Map.empty \\<longleftrightarrow> dom m \\<subseteq> {k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (m |` (- {k}) = Map.empty) = (dom m \\<subseteq> {k})", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. m |` (- {k}) = Map.empty \\<Longrightarrow> dom m \\<subseteq> {k}\n 2. dom m \\<subseteq> {k} \\<Longrightarrow> m |` (- {k}) = Map.empty", "assume \"m |` (- {k}) = Map.empty\""], ["proof (state)\nthis:\n  m |` (- {k}) = Map.empty\n\ngoal (2 subgoals):\n 1. m |` (- {k}) = Map.empty \\<Longrightarrow> dom m \\<subseteq> {k}\n 2. dom m \\<subseteq> {k} \\<Longrightarrow> m |` (- {k}) = Map.empty", "hence \"{} = dom (m |` (-{k}))\""], ["proof (prove)\nusing this:\n  m |` (- {k}) = Map.empty\n\ngoal (1 subgoal):\n 1. {} = dom (m |` (- {k}))", "by auto"], ["proof (state)\nthis:\n  {} = dom (m |` (- {k}))\n\ngoal (2 subgoals):\n 1. m |` (- {k}) = Map.empty \\<Longrightarrow> dom m \\<subseteq> {k}\n 2. dom m \\<subseteq> {k} \\<Longrightarrow> m |` (- {k}) = Map.empty", "also"], ["proof (state)\nthis:\n  {} = dom (m |` (- {k}))\n\ngoal (2 subgoals):\n 1. m |` (- {k}) = Map.empty \\<Longrightarrow> dom m \\<subseteq> {k}\n 2. dom m \\<subseteq> {k} \\<Longrightarrow> m |` (- {k}) = Map.empty", "have \"\\<dots> = dom m - {k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (m |` (- {k})) = dom m - {k}", "by auto"], ["proof (state)\nthis:\n  dom (m |` (- {k})) = dom m - {k}\n\ngoal (2 subgoals):\n 1. m |` (- {k}) = Map.empty \\<Longrightarrow> dom m \\<subseteq> {k}\n 2. dom m \\<subseteq> {k} \\<Longrightarrow> m |` (- {k}) = Map.empty", "finally"], ["proof (chain)\npicking this:\n  {} = dom m - {k}", "show \"dom m \\<subseteq> {k}\""], ["proof (prove)\nusing this:\n  {} = dom m - {k}\n\ngoal (1 subgoal):\n 1. dom m \\<subseteq> {k}", "by blast"], ["proof (state)\nthis:\n  dom m \\<subseteq> {k}\n\ngoal (1 subgoal):\n 1. dom m \\<subseteq> {k} \\<Longrightarrow> m |` (- {k}) = Map.empty", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. dom m \\<subseteq> {k} \\<Longrightarrow> m |` (- {k}) = Map.empty", "assume \"dom m \\<subseteq> {k}\""], ["proof (state)\nthis:\n  dom m \\<subseteq> {k}\n\ngoal (1 subgoal):\n 1. dom m \\<subseteq> {k} \\<Longrightarrow> m |` (- {k}) = Map.empty", "hence \"dom m - {k} = {}\""], ["proof (prove)\nusing this:\n  dom m \\<subseteq> {k}\n\ngoal (1 subgoal):\n 1. dom m - {k} = {}", "by auto"], ["proof (state)\nthis:\n  dom m - {k} = {}\n\ngoal (1 subgoal):\n 1. dom m \\<subseteq> {k} \\<Longrightarrow> m |` (- {k}) = Map.empty", "hence \"dom (m |` (-{k})) = {}\""], ["proof (prove)\nusing this:\n  dom m - {k} = {}\n\ngoal (1 subgoal):\n 1. dom (m |` (- {k})) = {}", "by auto"], ["proof (state)\nthis:\n  dom (m |` (- {k})) = {}\n\ngoal (1 subgoal):\n 1. dom m \\<subseteq> {k} \\<Longrightarrow> m |` (- {k}) = Map.empty", "thus \"m |` (-{k}) = Map.empty\""], ["proof (prove)\nusing this:\n  dom (m |` (- {k})) = {}\n\ngoal (1 subgoal):\n 1. m |` (- {k}) = Map.empty", "by blast"], ["proof (state)\nthis:\n  m |` (- {k}) = Map.empty\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ahm_delete_correct: \n  \"ahm_\\<alpha> (ahm_delete k m) = (ahm_\\<alpha> m) |` (-{k})\"\n  \"ahm_invar m \\<Longrightarrow> ahm_invar (ahm_delete k m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ahm_\\<alpha> (ahm_delete k m) = ahm_\\<alpha> m |` (- {k}) &&&\n    (ahm_invar m \\<Longrightarrow> ahm_invar (ahm_delete k m))", "apply (rule ext)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. ahm_\\<alpha> (ahm_delete k m) x = (ahm_\\<alpha> m |` (- {k})) x\n 2. ahm_invar m \\<Longrightarrow> ahm_invar (ahm_delete k m)", "apply (unfold ahm_delete_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       ahm_\\<alpha>\n        (map_entry (hashcode k)\n          (case_option None\n            (\\<lambda>bm.\n                if bm |` (- {k}) = Map.empty then None\n                else Some (bm |` (- {k}))))\n          m)\n        x =\n       (ahm_\\<alpha> m |` (- {k})) x\n 2. ahm_invar m \\<Longrightarrow>\n    ahm_invar\n     (map_entry (hashcode k)\n       (case_option None\n         (\\<lambda>bm.\n             if bm |` (- {k}) = Map.empty then None\n             else Some (bm |` (- {k}))))\n       m)", "apply (auto simp add: ahm_\\<alpha>_def Let_def Map.restrict_map_def \n              split: option.split)[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x x2.\n       \\<lbrakk>(\\<lambda>x. if x = k then None else x2 x) = Map.empty;\n        m (hashcode k) = Some x2; hashcode x = hashcode k;\n        x \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> None = x2 x\n 2. ahm_invar m \\<Longrightarrow>\n    ahm_invar\n     (map_entry (hashcode k)\n       (case_option None\n         (\\<lambda>bm.\n             if bm |` (- {k}) = Map.empty then None\n             else Some (bm |` (- {k}))))\n       m)", "apply (drule_tac x=x in fun_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x x2.\n       \\<lbrakk>m (hashcode k) = Some x2; hashcode x = hashcode k;\n        x \\<noteq> k; (if x = k then None else x2 x) = None\\<rbrakk>\n       \\<Longrightarrow> None = x2 x\n 2. ahm_invar m \\<Longrightarrow>\n    ahm_invar\n     (map_entry (hashcode k)\n       (case_option None\n         (\\<lambda>bm.\n             if bm |` (- {k}) = Map.empty then None\n             else Some (bm |` (- {k}))))\n       m)", "apply (auto)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ahm_invar m \\<Longrightarrow>\n    ahm_invar\n     (map_entry (hashcode k)\n       (case_option None\n         (\\<lambda>bm.\n             if bm |` (- {k}) = Map.empty then None\n             else Some (bm |` (- {k}))))\n       m)", "apply (rule ahm_invarI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>hc cm ka.\n       \\<lbrakk>ahm_invar m;\n        map_entry (hashcode k)\n         (case_option None\n           (\\<lambda>bm.\n               if bm |` (- {k}) = Map.empty then None\n               else Some (bm |` (- {k}))))\n         m hc =\n        Some cm;\n        ka \\<in> dom cm\\<rbrakk>\n       \\<Longrightarrow> hashcode ka = hc\n 2. \\<And>hc cm.\n       \\<lbrakk>ahm_invar m;\n        map_entry (hashcode k)\n         (case_option None\n           (\\<lambda>bm.\n               if bm |` (- {k}) = Map.empty then None\n               else Some (bm |` (- {k}))))\n         m hc =\n        Some cm\\<rbrakk>\n       \\<Longrightarrow> cm \\<noteq> Map.empty", "apply (auto split: if_split_asm option.split_asm dest: ahm_invarD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ka x2 y.\n       \\<lbrakk>ahm_invar m; m (hashcode k) = Some x2;\n        x2 |` (- {k}) \\<noteq> Map.empty;\n        (x2 |` (- {k})) ka = Some y\\<rbrakk>\n       \\<Longrightarrow> hashcode ka = hashcode k", "apply (drule (1) ahm_invarD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ka x2 y.\n       \\<lbrakk>m (hashcode k) = Some x2; x2 |` (- {k}) \\<noteq> Map.empty;\n        (x2 |` (- {k})) ka = Some y\\<rbrakk>\n       \\<Longrightarrow> ?k79 ka x2 y \\<in> dom x2\n 2. \\<And>ka x2 y.\n       \\<lbrakk>m (hashcode k) = Some x2; x2 |` (- {k}) \\<noteq> Map.empty;\n        (x2 |` (- {k})) ka = Some y;\n        hashcode (?k79 ka x2 y) = hashcode k\\<rbrakk>\n       \\<Longrightarrow> hashcode ka = hashcode k", "apply (auto simp add: restrict_map_def split: if_split_asm option.split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ahm_isEmpty_correct: \"ahm_invar m \\<Longrightarrow> ahm_isEmpty m \\<longleftrightarrow> ahm_\\<alpha> m = Map.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ahm_invar m \\<Longrightarrow>\n    ahm_isEmpty m = (ahm_\\<alpha> m = Map.empty)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>ahm_invar m; ahm_isEmpty m\\<rbrakk>\n    \\<Longrightarrow> ahm_\\<alpha> m = Map.empty\n 2. \\<lbrakk>ahm_invar m; ahm_\\<alpha> m = Map.empty\\<rbrakk>\n    \\<Longrightarrow> ahm_isEmpty m", "assume \"ahm_invar m\" \"ahm_isEmpty m\""], ["proof (state)\nthis:\n  ahm_invar m\n  ahm_isEmpty m\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ahm_invar m; ahm_isEmpty m\\<rbrakk>\n    \\<Longrightarrow> ahm_\\<alpha> m = Map.empty\n 2. \\<lbrakk>ahm_invar m; ahm_\\<alpha> m = Map.empty\\<rbrakk>\n    \\<Longrightarrow> ahm_isEmpty m", "thus \"ahm_\\<alpha> m = Map.empty\""], ["proof (prove)\nusing this:\n  ahm_invar m\n  ahm_isEmpty m\n\ngoal (1 subgoal):\n 1. ahm_\\<alpha> m = Map.empty", "by (auto simp add: ahm_isEmpty_def ahm_\\<alpha>_def intro: ext)"], ["proof (state)\nthis:\n  ahm_\\<alpha> m = Map.empty\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ahm_invar m; ahm_\\<alpha> m = Map.empty\\<rbrakk>\n    \\<Longrightarrow> ahm_isEmpty m", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>ahm_invar m; ahm_\\<alpha> m = Map.empty\\<rbrakk>\n    \\<Longrightarrow> ahm_isEmpty m", "assume I: \"ahm_invar m\" \n    and E: \"ahm_\\<alpha> m = Map.empty\""], ["proof (state)\nthis:\n  ahm_invar m\n  ahm_\\<alpha> m = Map.empty\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ahm_invar m; ahm_\\<alpha> m = Map.empty\\<rbrakk>\n    \\<Longrightarrow> ahm_isEmpty m", "show \"ahm_isEmpty m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ahm_isEmpty m", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> ahm_isEmpty m \\<Longrightarrow> False", "assume \"\\<not>ahm_isEmpty m\""], ["proof (state)\nthis:\n  \\<not> ahm_isEmpty m\n\ngoal (1 subgoal):\n 1. \\<not> ahm_isEmpty m \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> ahm_isEmpty m", "obtain hc bm where MHC: \"m hc = Some bm\""], ["proof (prove)\nusing this:\n  \\<not> ahm_isEmpty m\n\ngoal (1 subgoal):\n 1. (\\<And>hc bm. m hc = Some bm \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (unfold ahm_isEmpty_def)\n         (blast elim: nempty_dom dest: domD)"], ["proof (state)\nthis:\n  m hc = Some bm\n\ngoal (1 subgoal):\n 1. \\<not> ahm_isEmpty m \\<Longrightarrow> False", "from ahm_invarDne[OF I, OF MHC]"], ["proof (chain)\npicking this:\n  bm \\<noteq> Map.empty", "obtain k v where\n      BMK: \"bm k = Some v\""], ["proof (prove)\nusing this:\n  bm \\<noteq> Map.empty\n\ngoal (1 subgoal):\n 1. (\\<And>k v. bm k = Some v \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (blast elim: nempty_dom dest: domD)"], ["proof (state)\nthis:\n  bm k = Some v\n\ngoal (1 subgoal):\n 1. \\<not> ahm_isEmpty m \\<Longrightarrow> False", "from ahm_invarD[OF I, OF MHC] BMK"], ["proof (chain)\npicking this:\n  ?k \\<in> dom bm \\<Longrightarrow> hashcode ?k = hc\n  bm k = Some v", "have [simp]: \"hashcode k = hc\""], ["proof (prove)\nusing this:\n  ?k \\<in> dom bm \\<Longrightarrow> hashcode ?k = hc\n  bm k = Some v\n\ngoal (1 subgoal):\n 1. hashcode k = hc", "by auto"], ["proof (state)\nthis:\n  hashcode k = hc\n\ngoal (1 subgoal):\n 1. \\<not> ahm_isEmpty m \\<Longrightarrow> False", "hence \"ahm_\\<alpha> m k = Some v\""], ["proof (prove)\nusing this:\n  hashcode k = hc\n\ngoal (1 subgoal):\n 1. ahm_\\<alpha> m k = Some v", "by (simp add: ahm_\\<alpha>_def MHC BMK)"], ["proof (state)\nthis:\n  ahm_\\<alpha> m k = Some v\n\ngoal (1 subgoal):\n 1. \\<not> ahm_isEmpty m \\<Longrightarrow> False", "with E"], ["proof (chain)\npicking this:\n  ahm_\\<alpha> m = Map.empty\n  ahm_\\<alpha> m k = Some v", "show False"], ["proof (prove)\nusing this:\n  ahm_\\<alpha> m = Map.empty\n  ahm_\\<alpha> m k = Some v\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ahm_isEmpty m\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas ahm_correct = ahm_empty_correct ahm_lookup_correct ahm_update_correct \n                     ahm_delete_correct ahm_isEmpty_correct\n\n  \\<comment> \\<open>Bucket entries correspond to map entries\\<close>"], ["", "lemma ahm_be_is_e:\n  assumes I: \"ahm_invar m\"\n  assumes A: \"m hc = Some bm\" \"bm k = Some v\"\n  shows \"ahm_\\<alpha> m k = Some v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ahm_\\<alpha> m k = Some v", "using A"], ["proof (prove)\nusing this:\n  m hc = Some bm\n  bm k = Some v\n\ngoal (1 subgoal):\n 1. ahm_\\<alpha> m k = Some v", "apply (auto simp add: ahm_\\<alpha>_def split: option.split dest: ahm_invarD[OF I])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>m hc = Some bm; bm k = Some v;\n        m (hashcode k) = Some x2\\<rbrakk>\n       \\<Longrightarrow> x2 k = Some v", "apply (frule ahm_invarD[OF I, where k=k])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>m hc = Some bm; bm k = Some v;\n        m (hashcode k) = Some x2\\<rbrakk>\n       \\<Longrightarrow> k \\<in> dom bm\n 2. \\<And>x2.\n       \\<lbrakk>m hc = Some bm; bm k = Some v; m (hashcode k) = Some x2;\n        hashcode k = hc\\<rbrakk>\n       \\<Longrightarrow> x2 k = Some v", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done\n\n  \\<comment> \\<open>Map entries correspond to bucket entries\\<close>"], ["", "lemma ahm_e_is_be: \"\\<lbrakk>\n  ahm_\\<alpha> m k = Some v; \n  !!bm. \\<lbrakk>m (hashcode k) = Some bm; bm k = Some v \\<rbrakk> \\<Longrightarrow> P\n  \\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ahm_\\<alpha> m k = Some v;\n     \\<And>bm.\n        \\<lbrakk>m (hashcode k) = Some bm; bm k = Some v\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n    \\<Longrightarrow> P", "by (unfold ahm_\\<alpha>_def)\n     (auto split: option.split_asm)"], ["", "subsection \\<open>Concrete Hashmap\\<close>"], ["", "text \\<open>\n  In this section, we define the concrete hashmap that is made from the \n  hashcode map and the bucket map.\n\n  We then show the correctness of the operations w.r.t. the abstract hashmap, and\n  thus, indirectly, w.r.t. the corresponding map.\n\\<close>"], ["", "type_synonym\n  ('k,'v) hm_impl = \"(hashcode, ('k,'v) lm) rm\""], ["", "subsubsection \"Operations\"\n\n  \\<comment> \\<open>Auxiliary function: Apply function to value of an entry\\<close>"], ["", "definition rm_map_entry \n  :: \"hashcode \\<Rightarrow> ('v option \\<Rightarrow> 'v option) \\<Rightarrow> (hashcode, 'v) rm \\<Rightarrow> (hashcode,'v) rm\" \n  where \n  \"rm_map_entry k f m ==\n      case rm.lookup k m of\n        None \\<Rightarrow> (\n          case f None of \n            None \\<Rightarrow> m |\n            Some v \\<Rightarrow> rm.update k v m\n        ) |\n        Some v \\<Rightarrow> (\n          case f (Some v) of\n            None \\<Rightarrow> rm.delete k m |\n            Some v' \\<Rightarrow> rm.update k v' m\n        )\n    \"\n\n  \\<comment> \\<open>Empty hashmap\\<close>"], ["", "definition empty :: \"unit \\<Rightarrow> ('k :: hashable, 'v) hm_impl\" where \"empty == rm.empty\"\n\n  \\<comment> \\<open>Update/insert entry\\<close>"], ["", "definition update :: \"'k::hashable \\<Rightarrow> 'v \\<Rightarrow> ('k,'v) hm_impl \\<Rightarrow> ('k,'v) hm_impl\"\n  where \n  \"update k v m == \n   let hc = hashcode k in\n     case rm.lookup hc m of\n       None \\<Rightarrow> rm.update hc (lm.update k v (lm.empty ())) m |\n       Some bm \\<Rightarrow> rm.update hc (lm.update k v bm) m\" \n\n  \\<comment> \\<open>Lookup value by key\\<close>"], ["", "definition lookup :: \"'k::hashable \\<Rightarrow> ('k,'v) hm_impl \\<Rightarrow> 'v option\" where\n  \"lookup k m ==\n   case rm.lookup (hashcode k) m of\n     None \\<Rightarrow> None |\n     Some lm \\<Rightarrow> lm.lookup k lm\"\n\n  \\<comment> \\<open>Delete entry by key\\<close>"], ["", "definition delete :: \"'k::hashable \\<Rightarrow> ('k,'v) hm_impl \\<Rightarrow> ('k,'v) hm_impl\" where\n  \"delete k m ==\n   rm_map_entry (hashcode k) \n     (\\<lambda>v. case v of \n       None \\<Rightarrow> None | \n       Some lm \\<Rightarrow> (\n         let lm' = lm.delete k lm \n         in  if lm.isEmpty lm' then None else Some lm'\n       )\n     ) m\"\n\n  \\<comment> \\<open>Emptiness check\\<close>"], ["", "definition \"isEmpty == rm.isEmpty\"\n\n  \\<comment> \\<open>Interruptible iterator\\<close>"], ["", "definition \"iteratei m c f \\<sigma>0 ==\n  rm.iteratei m c (\\<lambda>(hc, lm) \\<sigma>. \n    lm.iteratei lm c f \\<sigma>\n  ) \\<sigma>0\""], ["", "lemma iteratei_alt_def :\n  \"iteratei m = set_iterator_image snd (\n     set_iterator_product (rm.iteratei m) (\\<lambda>hclm. lm.iteratei (snd hclm)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iteratei m =\n    set_iterator_image snd\n     (set_iterator_product (rm.iteratei m)\n       (\\<lambda>hclm. lm.iteratei (snd hclm)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. iteratei m =\n    set_iterator_image snd\n     (set_iterator_product (rm.iteratei m)\n       (\\<lambda>hclm. lm.iteratei (snd hclm)))", "have aux: \"\\<And>c f. (\\<lambda>(hc, lm). lm.iteratei lm c f) = (\\<lambda>m. lm.iteratei (snd m) c f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c f.\n       (\\<lambda>(hc, lm). lm.iteratei lm c f) =\n       (\\<lambda>m. lm.iteratei (snd m) c f)", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>(hc, lm). lm.iteratei lm ?c ?f) =\n  (\\<lambda>m. lm.iteratei (snd m) ?c ?f)\n\ngoal (1 subgoal):\n 1. iteratei m =\n    set_iterator_image snd\n     (set_iterator_product (rm.iteratei m)\n       (\\<lambda>hclm. lm.iteratei (snd hclm)))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. iteratei m =\n    set_iterator_image snd\n     (set_iterator_product (rm.iteratei m)\n       (\\<lambda>hclm. lm.iteratei (snd hclm)))", "unfolding set_iterator_product_def set_iterator_image_alt_def \n      iteratei_def[abs_def] aux"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>c f. rm.iteratei m c (\\<lambda>m. lm.iteratei (snd m) c f)) =\n    (\\<lambda>c f.\n        rm.iteratei m c\n         (\\<lambda>a. lm.iteratei (snd a) c (\\<lambda>b. f (snd (a, b)))))", "by (simp add: split_beta)"], ["proof (state)\nthis:\n  iteratei m =\n  set_iterator_image snd\n   (set_iterator_product (rm.iteratei m)\n     (\\<lambda>hclm. lm.iteratei (snd hclm)))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \"Correctness w.r.t. Abstract HashMap\""], ["", "text \\<open>\n  The following lemmas establish the correctness of the operations w.r.t. the \n  abstract hashmap.\n\n  They have the naming scheme op\\_correct', where (is) the name of the \n  operation.\n\\<close>\n\n  \\<comment> \\<open>Abstract concrete hashmap to abstract hashmap\\<close>"], ["", "definition hm_\\<alpha>' where \"hm_\\<alpha>' m == \\<lambda>hc. case rm.\\<alpha> m hc of\n  None \\<Rightarrow> None |\n  Some lm \\<Rightarrow> Some (lm.\\<alpha> lm)\"\n\n  \\<comment> \\<open>Invariant for concrete hashmap: \n    The hashcode-map and bucket-maps satisfy their invariants and\n    the invariant of the corresponding abstract hashmap is satisfied.\\<close>"], ["", "definition \"invar m == ahm_invar (hm_\\<alpha>' m)\""], ["", "lemma rm_map_entry_correct:\n  \"rm.\\<alpha> (rm_map_entry k f m) = (rm.\\<alpha> m)(k := f (rm.\\<alpha> m k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rm.\\<alpha> (rm_map_entry k f m) = map_entry k f (rm.\\<alpha> m)", "apply (auto \n    simp add: rm_map_entry_def rm.delete_correct rm.lookup_correct rm.update_correct \n    split: option.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma empty_correct': \n  \"hm_\\<alpha>' (empty ()) = ahm_empty\"\n  \"invar (empty ())\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hm_\\<alpha>' (HashMap_Impl.empty ()) = ahm_empty &&&\n    invar (HashMap_Impl.empty ())", "by (simp_all add: hm_\\<alpha>'_def empty_def ahm_empty_def rm.correct invar_def ahm_invar_def)"], ["", "lemma lookup_correct': \n  \"invar m \\<Longrightarrow> lookup k m = ahm_lookup k (hm_\\<alpha>' m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar m \\<Longrightarrow> lookup k m = ahm_lookup k (hm_\\<alpha>' m)", "apply (unfold lookup_def invar_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ahm_invar (hm_\\<alpha>' m) \\<Longrightarrow>\n    (case rm.lookup (hashcode k) m of None \\<Rightarrow> None\n     | Some lm \\<Rightarrow> lm.lookup k lm) =\n    ahm_lookup k (hm_\\<alpha>' m)", "apply (auto split: option.split \n              simp add: ahm_lookup_def ahm_\\<alpha>_def hm_\\<alpha>'_def \n                        rm.correct lm.correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma update_correct': \n  \"invar m \\<Longrightarrow> hm_\\<alpha>' (update k v m) = ahm_update k v (hm_\\<alpha>' m)\"\n  \"invar m \\<Longrightarrow> invar (update k v m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (invar m \\<Longrightarrow>\n     hm_\\<alpha>' (update k v m) = ahm_update k v (hm_\\<alpha>' m)) &&&\n    (invar m \\<Longrightarrow> invar (update k v m))", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. invar m \\<Longrightarrow>\n    hm_\\<alpha>' (update k v m) = ahm_update k v (hm_\\<alpha>' m)\n 2. invar m \\<Longrightarrow> invar (update k v m)", "assume \"invar m\""], ["proof (state)\nthis:\n  invar m\n\ngoal (2 subgoals):\n 1. invar m \\<Longrightarrow>\n    hm_\\<alpha>' (update k v m) = ahm_update k v (hm_\\<alpha>' m)\n 2. invar m \\<Longrightarrow> invar (update k v m)", "thus \"hm_\\<alpha>' (update k v m) = ahm_update k v (hm_\\<alpha>' m)\""], ["proof (prove)\nusing this:\n  invar m\n\ngoal (1 subgoal):\n 1. hm_\\<alpha>' (update k v m) = ahm_update k v (hm_\\<alpha>' m)", "apply (unfold invar_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ahm_invar (hm_\\<alpha>' m) \\<Longrightarrow>\n    hm_\\<alpha>' (update k v m) = ahm_update k v (hm_\\<alpha>' m)", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       ahm_invar (hm_\\<alpha>' m) \\<Longrightarrow>\n       hm_\\<alpha>' (update k v m) x = ahm_update k v (hm_\\<alpha>' m) x", "apply (auto simp add: update_def ahm_update_def hm_\\<alpha>'_def Let_def \n                          rm.correct lm.correct \n                split: option.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  hm_\\<alpha>' (update k v m) = ahm_update k v (hm_\\<alpha>' m)\n\ngoal (1 subgoal):\n 1. invar m \\<Longrightarrow> invar (update k v m)", "thus \"invar m \\<Longrightarrow> invar (update k v m)\""], ["proof (prove)\nusing this:\n  hm_\\<alpha>' (update k v m) = ahm_update k v (hm_\\<alpha>' m)\n\ngoal (1 subgoal):\n 1. invar m \\<Longrightarrow> invar (update k v m)", "by (simp add: invar_def ahm_update_correct)"], ["proof (state)\nthis:\n  invar m \\<Longrightarrow> invar (update k v m)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma delete_correct':\n  \"invar m \\<Longrightarrow> hm_\\<alpha>' (delete k m) = ahm_delete k (hm_\\<alpha>' m)\"\n  \"invar m \\<Longrightarrow> invar (delete k m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (invar m \\<Longrightarrow>\n     hm_\\<alpha>' (delete k m) = ahm_delete k (hm_\\<alpha>' m)) &&&\n    (invar m \\<Longrightarrow> invar (delete k m))", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. invar m \\<Longrightarrow>\n    hm_\\<alpha>' (delete k m) = ahm_delete k (hm_\\<alpha>' m)\n 2. invar m \\<Longrightarrow> invar (delete k m)", "assume \"invar m\""], ["proof (state)\nthis:\n  invar m\n\ngoal (2 subgoals):\n 1. invar m \\<Longrightarrow>\n    hm_\\<alpha>' (delete k m) = ahm_delete k (hm_\\<alpha>' m)\n 2. invar m \\<Longrightarrow> invar (delete k m)", "thus \"hm_\\<alpha>' (delete k m) = ahm_delete k (hm_\\<alpha>' m)\""], ["proof (prove)\nusing this:\n  invar m\n\ngoal (1 subgoal):\n 1. hm_\\<alpha>' (delete k m) = ahm_delete k (hm_\\<alpha>' m)", "apply (unfold invar_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ahm_invar (hm_\\<alpha>' m) \\<Longrightarrow>\n    hm_\\<alpha>' (delete k m) = ahm_delete k (hm_\\<alpha>' m)", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       ahm_invar (hm_\\<alpha>' m) \\<Longrightarrow>\n       hm_\\<alpha>' (delete k m) x = ahm_delete k (hm_\\<alpha>' m) x", "apply (auto simp add: delete_def ahm_delete_def hm_\\<alpha>'_def \n                          rm_map_entry_correct\n                          rm.correct lm.correct Let_def \n                split: option.split option.split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  hm_\\<alpha>' (delete k m) = ahm_delete k (hm_\\<alpha>' m)\n\ngoal (1 subgoal):\n 1. invar m \\<Longrightarrow> invar (delete k m)", "thus \"invar (delete k m)\""], ["proof (prove)\nusing this:\n  hm_\\<alpha>' (delete k m) = ahm_delete k (hm_\\<alpha>' m)\n\ngoal (1 subgoal):\n 1. invar (delete k m)", "using \\<open>invar m\\<close>"], ["proof (prove)\nusing this:\n  hm_\\<alpha>' (delete k m) = ahm_delete k (hm_\\<alpha>' m)\n  invar m\n\ngoal (1 subgoal):\n 1. invar (delete k m)", "by (simp add: ahm_delete_correct invar_def)"], ["proof (state)\nthis:\n  invar (delete k m)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma isEmpty_correct':\n  \"invar hm \\<Longrightarrow> isEmpty hm \\<longleftrightarrow> ahm_\\<alpha> (hm_\\<alpha>' hm) = Map.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar hm \\<Longrightarrow>\n    isEmpty hm = (ahm_\\<alpha> (hm_\\<alpha>' hm) = Map.empty)", "apply (simp add: isEmpty_def rm.isEmpty_correct invar_def\n                 ahm_isEmpty_correct[unfolded ahm_isEmpty_def, symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. ahm_invar (hm_\\<alpha>' hm) \\<Longrightarrow>\n    (rm.\\<alpha> hm = Map.empty) = (hm_\\<alpha>' hm = Map.empty)", "by (auto simp add: hm_\\<alpha>'_def ahm_\\<alpha>_def fun_eq_iff split: option.split_asm)"], ["", "(*\nlemma sel_correct':\n  assumes \"invar hm\"\n  shows \"\\<lbrakk> sel hm f = Some r; \\<And>u v. \\<lbrakk> ahm_\\<alpha> (hm_\\<alpha>' hm) u = Some v; f (u, v) = Some r \\<rbrakk> \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\"\n  and \"\\<lbrakk> sel hm f = None; ahm_\\<alpha> (hm_\\<alpha>' hm) u = Some v \\<rbrakk> \\<Longrightarrow> f (u, v) = None\"\nproof -\n  assume sel: \"sel hm f = Some r\"\n    and P: \"\\<And>u v. \\<lbrakk>ahm_\\<alpha> (hm_\\<alpha>' hm) u = Some v; f (u, v) = Some r\\<rbrakk> \\<Longrightarrow> P\"\n  from `invar hm` have IA: \"ahm_invar (hm_\\<alpha>' hm)\" by(simp add: invar_def)\n  from TrueI sel obtain hc lm where \"rm_\\<alpha> hm hc = Some lm\"\n    and \"lm_sel lm f = Some r\"\n    unfolding sel_def by (rule rm.sel_someE) simp\n  from TrueI `lm_sel lm f = Some r`\n  obtain k v where \"lm_\\<alpha> lm k = Some v\" \"f (k, v) = Some r\"\n    by(rule lm.sel_someE)\n  from `rm_\\<alpha> hm hc = Some lm` have \"hm_\\<alpha>' hm hc = Some (lm_\\<alpha> lm)\"\n    by(simp add: hm_\\<alpha>'_def)\n  with IA have \"ahm_\\<alpha> (hm_\\<alpha>' hm) k = Some v\" using `lm_\\<alpha> lm k = Some v`\n    by(rule ahm_be_is_e)\n  thus P using `f (k, v) = Some r` by(rule P)\nnext\n  assume sel: \"sel hm f = None\" \n    and \\<alpha>: \"ahm_\\<alpha> (hm_\\<alpha>' hm) u = Some v\"\n  from `invar hm` have IA: \"ahm_invar (hm_\\<alpha>' hm)\" by(simp add: invar_def)\n  from \\<alpha> obtain lm where \\<alpha>_u: \"hm_\\<alpha>' hm (hashcode u) = Some lm\"\n    and \"lm u = Some v\" by (rule ahm_e_is_be)\n  from \\<alpha>_u obtain lmc where \"rm_\\<alpha> hm (hashcode u) = Some lmc\" \"lm = lm_\\<alpha> lmc\" \n    by(auto simp add: hm_\\<alpha>'_def split: option.split_asm)\n  with `lm u = Some v` have \"lm_\\<alpha> lmc u = Some v\" by simp\n  from sel rm.sel_noneD [OF TrueI _ `rm_\\<alpha> hm (hashcode u) = Some lmc`, \n         of \"(\\<lambda>(hc, lm). lm_sel lm f)\"]\n  have \"lm_sel lmc f = None\" unfolding sel_def by simp  \n  with TrueI show \"f (u, v) = None\" using `lm_\\<alpha> lmc u = Some v` by(rule lm.sel_noneD)\nqed\n*)"], ["", "lemma iteratei_correct':\n  assumes invar: \"invar hm\"\n  shows \"map_iterator (iteratei hm) (ahm_\\<alpha> (hm_\\<alpha>' hm))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_iterator (iteratei hm) (ahm_\\<alpha> (hm_\\<alpha>' hm))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map_iterator (iteratei hm) (ahm_\\<alpha> (hm_\\<alpha>' hm))", "from rm.iteratei_correct"], ["proof (chain)\npicking this:\n  rm.invar ?S \\<Longrightarrow>\n  map_iterator (rm.iteratei ?S) (rm.\\<alpha> ?S)", "have it_rm: \"map_iterator (rm.iteratei hm) (rm.\\<alpha> hm)\""], ["proof (prove)\nusing this:\n  rm.invar ?S \\<Longrightarrow>\n  map_iterator (rm.iteratei ?S) (rm.\\<alpha> ?S)\n\ngoal (1 subgoal):\n 1. map_iterator (rm.iteratei hm) (rm.\\<alpha> hm)", "by simp"], ["proof (state)\nthis:\n  map_iterator (rm.iteratei hm) (rm.\\<alpha> hm)\n\ngoal (1 subgoal):\n 1. map_iterator (iteratei hm) (ahm_\\<alpha> (hm_\\<alpha>' hm))", "from lm.iteratei_correct"], ["proof (chain)\npicking this:\n  lm.invar ?S \\<Longrightarrow>\n  map_iterator (lm.iteratei ?S) (lm.\\<alpha> ?S)", "have it_lm: \"\\<And>lm. map_iterator (lm.iteratei lm) (lm.\\<alpha> lm)\""], ["proof (prove)\nusing this:\n  lm.invar ?S \\<Longrightarrow>\n  map_iterator (lm.iteratei ?S) (lm.\\<alpha> ?S)\n\ngoal (1 subgoal):\n 1. \\<And>lm. map_iterator (lm.iteratei lm) (lm.\\<alpha> lm)", "by simp"], ["proof (state)\nthis:\n  map_iterator (lm.iteratei ?lm1) (lm.\\<alpha> ?lm1)\n\ngoal (1 subgoal):\n 1. map_iterator (iteratei hm) (ahm_\\<alpha> (hm_\\<alpha>' hm))", "from set_iterator_product_correct \n    [OF it_rm, of \"\\<lambda>hclm. lm.iteratei (snd hclm)\"\n     \"\\<lambda>hclm. map_to_set (lm.\\<alpha> (snd hclm))\", OF it_lm]"], ["proof (chain)\npicking this:\n  set_iterator\n   (set_iterator_product (rm.iteratei hm)\n     (\\<lambda>hclm. lm.iteratei (snd hclm)))\n   (SIGMA hclm:map_to_set (rm.\\<alpha> hm).\n       map_to_set (lm.\\<alpha> (snd hclm)))", "have it_prod: \"set_iterator\n         (set_iterator_product (rm.iteratei hm) (\\<lambda>hclm. lm.iteratei (snd hclm)))\n         (SIGMA hclm:map_to_set (rm.\\<alpha> hm). map_to_set (lm.\\<alpha> (snd hclm)))\""], ["proof (prove)\nusing this:\n  set_iterator\n   (set_iterator_product (rm.iteratei hm)\n     (\\<lambda>hclm. lm.iteratei (snd hclm)))\n   (SIGMA hclm:map_to_set (rm.\\<alpha> hm).\n       map_to_set (lm.\\<alpha> (snd hclm)))\n\ngoal (1 subgoal):\n 1. set_iterator\n     (set_iterator_product (rm.iteratei hm)\n       (\\<lambda>hclm. lm.iteratei (snd hclm)))\n     (SIGMA hclm:map_to_set (rm.\\<alpha> hm).\n         map_to_set (lm.\\<alpha> (snd hclm)))", "by simp"], ["proof (state)\nthis:\n  set_iterator\n   (set_iterator_product (rm.iteratei hm)\n     (\\<lambda>hclm. lm.iteratei (snd hclm)))\n   (SIGMA hclm:map_to_set (rm.\\<alpha> hm).\n       map_to_set (lm.\\<alpha> (snd hclm)))\n\ngoal (1 subgoal):\n 1. map_iterator (iteratei hm) (ahm_\\<alpha> (hm_\\<alpha>' hm))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_iterator (iteratei hm) (ahm_\\<alpha> (hm_\\<alpha>' hm))", "unfolding iteratei_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_iterator\n     (set_iterator_image snd\n       (set_iterator_product (rm.iteratei hm)\n         (\\<lambda>hclm. lm.iteratei (snd hclm))))\n     (ahm_\\<alpha> (hm_\\<alpha>' hm))", "proof (rule set_iterator_image_correct[OF it_prod])"], ["proof (state)\ngoal (2 subgoals):\n 1. inj_on snd\n     (SIGMA hclm:map_to_set (rm.\\<alpha> hm).\n         map_to_set (lm.\\<alpha> (snd hclm)))\n 2. map_to_set (ahm_\\<alpha> (hm_\\<alpha>' hm)) =\n    snd `\n    (SIGMA hclm:map_to_set (rm.\\<alpha> hm).\n        map_to_set (lm.\\<alpha> (snd hclm)))", "from invar"], ["proof (chain)\npicking this:\n  invar hm", "show \"inj_on snd\n       (SIGMA hclm:map_to_set (rm.\\<alpha> hm). map_to_set (lm.\\<alpha> (snd hclm)))\""], ["proof (prove)\nusing this:\n  invar hm\n\ngoal (1 subgoal):\n 1. inj_on snd\n     (SIGMA hclm:map_to_set (rm.\\<alpha> hm).\n         map_to_set (lm.\\<alpha> (snd hclm)))", "apply (simp add: inj_on_def invar_def ahm_invar_def hm_\\<alpha>'_def Ball_def \n                       map_to_set_def split: option.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>hc x2.\n                rm.\\<alpha> hm hc = Some x2 \\<longrightarrow>\n                (\\<forall>k.\n                    k \\<in> dom (lm.\\<alpha> x2) \\<longrightarrow>\n                    hashcode k = hc);\n     \\<forall>hc x2.\n        rm.\\<alpha> hm hc = Some x2 \\<longrightarrow>\n        lm.\\<alpha> x2 \\<noteq> Map.empty\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a b aa ba.\n                         rm.\\<alpha> hm a = Some b \\<and>\n                         lm.\\<alpha> b aa = Some ba \\<longrightarrow>\n                         (\\<forall>ab bb.\n                             rm.\\<alpha> hm ab = Some bb \\<and>\n                             lm.\\<alpha> bb aa = Some ba \\<longrightarrow>\n                             a = ab \\<and> b = bb)", "apply (metis domI option.inject)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  inj_on snd\n   (SIGMA hclm:map_to_set (rm.\\<alpha> hm).\n       map_to_set (lm.\\<alpha> (snd hclm)))\n\ngoal (1 subgoal):\n 1. map_to_set (ahm_\\<alpha> (hm_\\<alpha>' hm)) =\n    snd `\n    (SIGMA hclm:map_to_set (rm.\\<alpha> hm).\n        map_to_set (lm.\\<alpha> (snd hclm)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. map_to_set (ahm_\\<alpha> (hm_\\<alpha>' hm)) =\n    snd `\n    (SIGMA hclm:map_to_set (rm.\\<alpha> hm).\n        map_to_set (lm.\\<alpha> (snd hclm)))", "from invar"], ["proof (chain)\npicking this:\n  invar hm", "show \"map_to_set (ahm_\\<alpha> (hm_\\<alpha>' hm)) =\n          snd ` (SIGMA hclm:map_to_set (rm.\\<alpha> hm). map_to_set (lm.\\<alpha> (snd hclm)))\""], ["proof (prove)\nusing this:\n  invar hm\n\ngoal (1 subgoal):\n 1. map_to_set (ahm_\\<alpha> (hm_\\<alpha>' hm)) =\n    snd `\n    (SIGMA hclm:map_to_set (rm.\\<alpha> hm).\n        map_to_set (lm.\\<alpha> (snd hclm)))", "apply (simp add: inj_on_def invar_def ahm_invar_def hm_\\<alpha>'_def Ball_def \n                       map_to_set_def set_eq_iff image_iff split: option.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>hc x2.\n                rm.\\<alpha> hm hc = Some x2 \\<longrightarrow>\n                (\\<forall>k.\n                    k \\<in> dom (lm.\\<alpha> x2) \\<longrightarrow>\n                    hashcode k = hc);\n     \\<forall>hc x2.\n        rm.\\<alpha> hm hc = Some x2 \\<longrightarrow>\n        lm.\\<alpha> x2 \\<noteq> Map.empty\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a b.\n                         (ahm_\\<alpha>\n                           (\\<lambda>hc.\n                               case rm.\\<alpha> hm hc of\n                               None \\<Rightarrow> None\n                               | Some lm \\<Rightarrow>\n                                   Some (lm.\\<alpha> lm))\n                           a =\n                          Some b) =\n                         (\\<exists>aa ba.\n                             rm.\\<alpha> hm aa = Some ba \\<and>\n                             lm.\\<alpha> ba a = Some b)", "apply (auto simp add: dom_def ahm_\\<alpha>_def split: option.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  map_to_set (ahm_\\<alpha> (hm_\\<alpha>' hm)) =\n  snd `\n  (SIGMA hclm:map_to_set (rm.\\<alpha> hm).\n      map_to_set (lm.\\<alpha> (snd hclm)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map_iterator (iteratei hm) (ahm_\\<alpha> (hm_\\<alpha>' hm))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas hm_correct' = empty_correct' lookup_correct' update_correct' \n                     delete_correct' isEmpty_correct' \n                     iteratei_correct'"], ["", "lemmas hm_invars = empty_correct'(2) update_correct'(2) \n                   delete_correct'(2)"], ["", "hide_const (open) empty invar lookup update delete isEmpty iteratei"], ["", "end"]]}