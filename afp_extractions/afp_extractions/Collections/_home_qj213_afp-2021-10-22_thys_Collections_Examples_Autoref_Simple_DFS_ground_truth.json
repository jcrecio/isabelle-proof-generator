{"file_name": "/home/qj213/afp-2021-10-22/thys/Collections/Examples/Autoref/Simple_DFS.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Collections", "problem_names": ["lemmas [autoref_rel_intf] = REL_INTFI[of \"succg_rel\" i_graph]\n  \\<comment> \\<open>Declare \\<open>succg_rel\\<close> to be a relator for graphs.\\<close>", "lemma in_id_succg_rel_iff: \"(s,E)\\<in>\\<langle>Id\\<rangle>succg_rel \\<longleftrightarrow> (\\<forall>v. distinct (s v) \\<and> set (s v) = E``{v})\"  \n  \\<comment> \\<open>Simplification in case of identity refinements for nodes\\<close>", "lemma [autoref_op_pat]: \"E``{v} \\<equiv> op_succ$E$v\"", "lemma refine_succg_succs[autoref_rules]: \n  \"(\\<lambda>succs v. succs v,op_succ)\\<in>\\<langle>R\\<rangle>succg_rel\\<rightarrow>R\\<rightarrow>\\<langle>R\\<rangle>list_set_rel\"\n  \\<comment> \\<open>Declare implementation of successor function to Autoref.\\<close>", "lemma dfs_correct:\n    assumes FIN: \"finite (E\\<^sup>*``{src})\"\n    shows \"dfs \\<le> SPEC (\\<lambda>r. r \\<longleftrightarrow> (src,tgt)\\<in>E\\<^sup>*)\"", "lemma succ_ran_fin:\n  assumes R: \"(succi,E) \\<in> \\<langle>Rv\\<rangle>succg_rel\"\n  assumes \"v\\<in>Range Rv\"\n  shows \"finite (E``{v})\"", "lemma run_ran_aux:\n  assumes R: \"(succi,E) \\<in> \\<langle>Rv\\<rangle>succg_rel\"\n  assumes REACH: \"(src,v)\\<in>E\\<^sup>*\"\n  assumes R0: \"(v0i,src) \\<in> Rv\"\n  shows \"v \\<in> Range Rv\"", "lemma run_ran_fin: \n  assumes R: \"(succi,E) \\<in> \\<langle>Rv\\<rangle>succg_rel\"\n  assumes R0: \"(v0i,src) \\<in> Rv\"\n  shows \"\\<forall>v. (src,v)\\<in>E\\<^sup>* \\<longrightarrow> finite (E``{v})\"", "theorem dfs_code_correct: \n  assumes SUCCI: \"(succi,E)\\<in>\\<langle>Id\\<rangle>succg_rel\"\n  assumes FIN: \"finite (E\\<^sup>*``{src})\"  \n  shows \"dfs_impl succi src tgt \\<longleftrightarrow> (src,tgt)\\<in>E\\<^sup>*\"", "theorem dfs_code2_correct: \n  assumes SUCCI: \"(succi,E)\\<in>\\<langle>Id\\<rangle>succg_rel\"\n  assumes FIN: \"finite (E\\<^sup>*``{src})\"  \n  shows \"dfs_impl2 succi src tgt \\<longleftrightarrow> (src,tgt)\\<in>E\\<^sup>*\"", "theorem dfs_code3_correct: \n  fixes succi and succ :: \"'a::linorder \\<Rightarrow> 'a set\" \n    and Rv :: \"('ai\\<times>'a) set\"\n  assumes V0: \"(v0i,src)\\<in>Rv\"\n  assumes VD: \"(vdi,tgt)\\<in>Rv\"\n  assumes SUCCI: \"(succi,E)\\<in>\\<langle>Rv\\<rangle>succg_rel\"\n  assumes CMP: \"(cmpk, dflt_cmp (\\<le>) (<))\\<in>(Rv\\<rightarrow>Rv\\<rightarrow>Id)\"\n  assumes FIN: \"finite (E\\<^sup>*``{src})\"  \n  shows \"dfs_impl3 cmpk succi v0i vdi \\<longleftrightarrow> (src,tgt)\\<in>E\\<^sup>*\"", "theorem dfs_code3'_correct: \n  fixes succi and succ :: \"'a::linorder \\<Rightarrow> 'a set\" \n    and Rv :: \"('ai\\<times>'a) set\"\n  assumes V0: \"(v0i,src)\\<in>Rv\"\n  assumes VD: \"(vdi,tgt)\\<in>Rv\"\n  assumes SUCCI: \"(succi,E)\\<in>\\<langle>Rv\\<rangle>succg_rel\"\n  assumes CGA: \"eq_linorder cmpk'\"\n  assumes CMP: \"(cmpk, cmpk') \\<in> Rv\\<rightarrow>Rv\\<rightarrow>comp_res_rel\"\n  assumes FIN: \"finite (E\\<^sup>*``{src})\"  \n  shows \"dfs_impl3' cmpk succi v0i vdi \\<longleftrightarrow> (src,tgt)\\<in>E\\<^sup>*\"", "lemma [autoref_op_pat]: \"(u,v)\\<in>E\\<^sup>* \\<equiv> op_reachable$E$u$v\"", "theorem dfs_code3_correct_rl[autoref_rules]: \n    fixes succi and succ :: \"'a::linorder \\<Rightarrow> 'a set\" \n      and Rv :: \"('ai\\<times>'a) set\"\n    assumes V0: \"(v0i,src)\\<in>Rv\"\n    assumes VD: \"(vdi,tgt)\\<in>Rv\"\n    assumes SUCCI: \"(succi,E)\\<in>\\<langle>Rv\\<rangle>succg_rel\"\n    assumes CGA: \"SIDE_GEN_ALGO (eq_linorder cmpk')\"\n    assumes CMP: \"GEN_OP cmpk cmpk' (Rv\\<rightarrow>Rv\\<rightarrow>comp_res_rel)\"\n    assumes FIN: \"SIDE_PRECOND (finite (E\\<^sup>*``{src}))\"  \n    shows \"(dfs_impl3' cmpk succi v0i vdi, \n          (OP op_reachable ::: \\<langle>Rv\\<rangle>succg_rel \\<rightarrow> Rv \\<rightarrow> Rv \\<rightarrow> bool_rel)$E$src$tgt)\n          \\<in> bool_rel\""], "translations": [["", "lemmas [autoref_rel_intf] = REL_INTFI[of \"succg_rel\" i_graph]\n  \\<comment> \\<open>Declare \\<open>succg_rel\\<close> to be a relator for graphs.\\<close>"], ["", "lemma in_id_succg_rel_iff: \"(s,E)\\<in>\\<langle>Id\\<rangle>succg_rel \\<longleftrightarrow> (\\<forall>v. distinct (s v) \\<and> set (s v) = E``{v})\"  \n  \\<comment> \\<open>Simplification in case of identity refinements for nodes\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((s, E) \\<in> \\<langle>Id\\<rangle>succg_rel) =\n    (\\<forall>v. distinct (s v) \\<and> set (s v) = E `` {v})", "unfolding succg_rel_def br_def E_of_succ_def list_set_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((s, E)\n     \\<in> (Id \\<rightarrow>\n            \\<langle>Id\\<rangle>list_rel O\n            {(c, a). a = set c \\<and> distinct c}) O\n           {(c, a). a = {(u, v). v \\<in> c u} \\<and> True}) =\n    (\\<forall>v. distinct (s v) \\<and> set (s v) = E `` {v})", "by (auto; force dest: fun_relD)"], ["", "subsection \\<open>Successor Operation\\<close>"], ["", "definition [simp]: \"op_succ E u \\<equiv> E``{u}\"\n  \\<comment> \\<open>Define the abstract successor operation.\\<close>"], ["", "context begin"], ["", "interpretation autoref_syn"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma [autoref_op_pat]: \"E``{v} \\<equiv> op_succ$E$v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E `` {v} \\<equiv> op_succ $ E $ v", "by simp\n  \\<comment> \\<open>Declare a rewrite rule to operation identification.\\<close>"], ["", "end"], ["", "lemma refine_succg_succs[autoref_rules]: \n  \"(\\<lambda>succs v. succs v,op_succ)\\<in>\\<langle>R\\<rangle>succg_rel\\<rightarrow>R\\<rightarrow>\\<langle>R\\<rangle>list_set_rel\"\n  \\<comment> \\<open>Declare implementation of successor function to Autoref.\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>succs. succs, op_succ)\n    \\<in> \\<langle>R\\<rangle>succg_rel \\<rightarrow>\n          R \\<rightarrow> \\<langle>R\\<rangle>list_set_rel", "apply (intro fun_relI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' aa a'a.\n       \\<lbrakk>(a, a') \\<in> \\<langle>R\\<rangle>succg_rel;\n        (aa, a'a) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (a aa, op_succ a' a'a)\n                         \\<in> \\<langle>R\\<rangle>list_set_rel", "apply (auto simp add: succg_rel_def br_def E_of_succ_def dest: fun_relD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "section \\<open>DFS Algorithm\\<close>"], ["", "text \\<open>\n  We define a simple DFS-algorithm, prove a simple correctness\n  property, and do data refinement to an efficient implementation.\n\\<close>"], ["", "subsection \\<open>Definition\\<close>"], ["", "text \\<open>Recursive DFS-Algorithm. \n  \\<open>E\\<close> is the edge relation of the graph, \\<open>tgt\\<close> the node to \n  search for, and \\<open>src\\<close> the start node.\n  Already explored nodes are \n  stored in \\<open>V\\<close>.\\<close>"], ["", "context \n  fixes E :: \"('v\\<times>'v) set\" and src :: 'v and tgt :: 'v\nbegin"], ["", "definition dfs :: \"bool nres\" where\n    \"dfs \\<equiv> do {\n      (_,r) \\<leftarrow> RECT (\\<lambda>dfs (V,v). \n        if v=tgt then RETURN (V,True)\n        else do {\n          let V = insert v V;\n          FOREACHc (E``{v}) (\\<lambda>(V,brk). \\<not>brk) (\\<lambda>v' (V,brk). \n            if v'\\<notin>V then dfs (V,v') else RETURN (V,False)\n          ) (V,False)\n        }) ({},src);\n      RETURN r\n    }\""], ["", "definition \"reachable \\<equiv> {v. (src,v)\\<in>E\\<^sup>*}\""], ["", "subsection \\<open>Correctness Proof\\<close>"], ["", "lemma dfs_correct:\n    assumes FIN: \"finite (E\\<^sup>*``{src})\"\n    shows \"dfs \\<le> SPEC (\\<lambda>r. r \\<longleftrightarrow> (src,tgt)\\<in>E\\<^sup>*)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "from FIN"], ["proof (chain)\npicking this:\n  finite (E\\<^sup>* `` {src})", "have [simp, intro!]: \"finite reachable\""], ["proof (prove)\nusing this:\n  finite (E\\<^sup>* `` {src})\n\ngoal (1 subgoal):\n 1. finite local.reachable", "unfolding reachable_def"], ["proof (prove)\nusing this:\n  finite (E\\<^sup>* `` {src})\n\ngoal (1 subgoal):\n 1. finite {v. (src, v) \\<in> E\\<^sup>*}", "by (auto simp: Image_def)"], ["proof (state)\nthis:\n  finite local.reachable\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "text \\<open>We first define the (inductive) pre and postconditions for \n      the recursion, and the loop invariant\\<close>"], ["proof (state)\nthis:\n  finite local.reachable\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "define rpre where \"rpre \\<equiv> \\<lambda>S (V,v). \n        v\\<in>reachable - V \n      \\<and> V\\<subseteq>reachable\n      \\<and> S\\<subseteq>V\n      \\<and> tgt\\<notin>V\n      \\<and> E``(V-S) \\<subseteq> V\""], ["proof (state)\nthis:\n  rpre \\<equiv>\n  \\<lambda>S (V, v).\n     v \\<in> local.reachable - V \\<and>\n     V \\<subseteq> local.reachable \\<and>\n     S \\<subseteq> V \\<and> tgt \\<notin> V \\<and> E `` (V - S) \\<subseteq> V\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "define rpost where \"rpost \\<equiv> \\<lambda>S (V,v) (V',r). \n          (r\\<longrightarrow>tgt\\<in>reachable) \n        \\<and> (\\<not>r \\<longrightarrow> \n            tgt\\<notin>V'\n          \\<and> V\\<subseteq>V' \n          \\<and> v\\<in>V'\n          \\<and> V'\\<subseteq>reachable\n          \\<and> E``(V'-S) \\<subseteq> V'\n          )\n      \""], ["proof (state)\nthis:\n  rpost \\<equiv>\n  \\<lambda>S (V, v) (V', r).\n     (r \\<longrightarrow> tgt \\<in> local.reachable) \\<and>\n     (\\<not> r \\<longrightarrow>\n      tgt \\<notin> V' \\<and>\n      V \\<subseteq> V' \\<and>\n      v \\<in> V' \\<and>\n      V' \\<subseteq> local.reachable \\<and> E `` (V' - S) \\<subseteq> V')\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "define fe_inv where \"fe_inv \\<equiv> \\<lambda>S V v it (V',r).\n        (r\\<longrightarrow>tgt\\<in>reachable)\n      \\<and> (\\<not>r \\<longrightarrow> \n          tgt \\<notin> V'\n        \\<and> insert v V\\<subseteq>V'\n        \\<and> E``{v} - it \\<subseteq> V'\n        \\<and> V'\\<subseteq>reachable\n        \\<and> S\\<subseteq>insert v V\n        \\<and> E``(V'-S) \\<subseteq> V' \\<union> it \n        \\<and> E``(V'-insert v S) \\<subseteq> V'\n        )\""], ["proof (state)\nthis:\n  fe_inv \\<equiv>\n  \\<lambda>S V v it (V', r).\n     (r \\<longrightarrow> tgt \\<in> local.reachable) \\<and>\n     (\\<not> r \\<longrightarrow>\n      tgt \\<notin> V' \\<and>\n      insert v V \\<subseteq> V' \\<and>\n      E `` {v} - it \\<subseteq> V' \\<and>\n      V' \\<subseteq> local.reachable \\<and>\n      S \\<subseteq> insert v V \\<and>\n      E `` (V' - S) \\<subseteq> V' \\<union> it \\<and>\n      E `` (V' - insert v S) \\<subseteq> V')\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "text \\<open>Then we prove the verification conditions that our VCG will generate as separate facts.\n      Of course, the workflow is to first let run the VCG, and then extract these facts from \n      its output. This way, we can make explicit the ideas of the proof, and present them separately \n      from the mainly technical VC generation.\n     \\<close>"], ["proof (state)\nthis:\n  fe_inv \\<equiv>\n  \\<lambda>S V v it (V', r).\n     (r \\<longrightarrow> tgt \\<in> local.reachable) \\<and>\n     (\\<not> r \\<longrightarrow>\n      tgt \\<notin> V' \\<and>\n      insert v V \\<subseteq> V' \\<and>\n      E `` {v} - it \\<subseteq> V' \\<and>\n      V' \\<subseteq> local.reachable \\<and>\n      S \\<subseteq> insert v V \\<and>\n      E `` (V' - S) \\<subseteq> V' \\<union> it \\<and>\n      E `` (V' - insert v S) \\<subseteq> V')\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "have vc_pre_initial: \"rpre {} ({}, src)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rpre {} ({}, src)", "by (auto simp: rpre_def reachable_def)"], ["proof (state)\nthis:\n  rpre {} ({}, src)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "{"], ["proof (state)\nthis:\n  rpre {} ({}, src)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "(* Case: Found node *)"], ["proof (state)\nthis:\n  rpre {} ({}, src)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "fix S V"], ["proof (state)\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "assume \"rpre S (V,tgt)\""], ["proof (state)\nthis:\n  rpre S (V, tgt)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "hence \"rpost S (V,tgt) (insert tgt V, True)\""], ["proof (prove)\nusing this:\n  rpre S (V, tgt)\n\ngoal (1 subgoal):\n 1. rpost S (V, tgt) (insert tgt V, True)", "unfolding rpre_def rpost_def"], ["proof (prove)\nusing this:\n  case (V, tgt) of\n  (V, v) \\<Rightarrow>\n    v \\<in> local.reachable - V \\<and>\n    V \\<subseteq> local.reachable \\<and>\n    S \\<subseteq> V \\<and> tgt \\<notin> V \\<and> E `` (V - S) \\<subseteq> V\n\ngoal (1 subgoal):\n 1. (case (V, tgt) of\n     (V, v) \\<Rightarrow>\n       \\<lambda>(V', r).\n          (r \\<longrightarrow> tgt \\<in> local.reachable) \\<and>\n          (\\<not> r \\<longrightarrow>\n           tgt \\<notin> V' \\<and>\n           V \\<subseteq> V' \\<and>\n           v \\<in> V' \\<and>\n           V' \\<subseteq> local.reachable \\<and>\n           E `` (V' - S) \\<subseteq> V'))\n     (insert tgt V, True)", "by auto"], ["proof (state)\nthis:\n  rpost S (V, tgt) (insert tgt V, True)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "}"], ["proof (state)\nthis:\n  rpre ?S2 (?V2, tgt) \\<Longrightarrow>\n  rpost ?S2 (?V2, tgt) (insert tgt ?V2, True)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "note vc_node_found = this"], ["proof (state)\nthis:\n  rpre ?S2 (?V2, tgt) \\<Longrightarrow>\n  rpost ?S2 (?V2, tgt) (insert tgt ?V2, True)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "{"], ["proof (state)\nthis:\n  rpre ?S2 (?V2, tgt) \\<Longrightarrow>\n  rpost ?S2 (?V2, tgt) (insert tgt ?V2, True)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "(* The set of nodes that the foreach loop iterates over is finite *)"], ["proof (state)\nthis:\n  rpre ?S2 (?V2, tgt) \\<Longrightarrow>\n  rpost ?S2 (?V2, tgt) (insert tgt ?V2, True)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "fix S V v"], ["proof (state)\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "assume \"rpre S (V, v)\""], ["proof (state)\nthis:\n  rpre S (V, v)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "hence \"finite (E``{v})\""], ["proof (prove)\nusing this:\n  rpre S (V, v)\n\ngoal (1 subgoal):\n 1. finite (E `` {v})", "unfolding rpre_def reachable_def"], ["proof (prove)\nusing this:\n  case (V, v) of\n  (V, v) \\<Rightarrow>\n    v \\<in> {v. (src, v) \\<in> E\\<^sup>*} - V \\<and>\n    V \\<subseteq> {v. (src, v) \\<in> E\\<^sup>*} \\<and>\n    S \\<subseteq> V \\<and> tgt \\<notin> V \\<and> E `` (V - S) \\<subseteq> V\n\ngoal (1 subgoal):\n 1. finite (E `` {v})", "using FIN"], ["proof (prove)\nusing this:\n  case (V, v) of\n  (V, v) \\<Rightarrow>\n    v \\<in> {v. (src, v) \\<in> E\\<^sup>*} - V \\<and>\n    V \\<subseteq> {v. (src, v) \\<in> E\\<^sup>*} \\<and>\n    S \\<subseteq> V \\<and> tgt \\<notin> V \\<and> E `` (V - S) \\<subseteq> V\n  finite (E\\<^sup>* `` {src})\n\ngoal (1 subgoal):\n 1. finite (E `` {v})", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite (E\\<^sup>* `` {src}); (src, v) \\<in> E\\<^sup>*;\n     v \\<notin> V; V \\<subseteq> {v. (src, v) \\<in> E\\<^sup>*};\n     S \\<subseteq> V; tgt \\<notin> V; E `` (V - S) \\<subseteq> V\\<rbrakk>\n    \\<Longrightarrow> finite (E `` {v})", "by (meson finite_Image_subset finite_reachable_advance r_le_rtrancl)"], ["proof (state)\nthis:\n  finite (E `` {v})\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "}"], ["proof (state)\nthis:\n  rpre ?S2 (?V2, ?v2) \\<Longrightarrow> finite (E `` {?v2})\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "note vc_foreach_finite = this"], ["proof (state)\nthis:\n  rpre ?S2 (?V2, ?v2) \\<Longrightarrow> finite (E `` {?v2})\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "{"], ["proof (state)\nthis:\n  rpre ?S2 (?V2, ?v2) \\<Longrightarrow> finite (E `` {?v2})\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "(* fe_inv initial *)"], ["proof (state)\nthis:\n  rpre ?S2 (?V2, ?v2) \\<Longrightarrow> finite (E `` {?v2})\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "fix S V v"], ["proof (state)\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "assume A: \"v \\<notin> V\" \"v \\<noteq> tgt\"\n        and PRE: \"rpre S (V, v)\""], ["proof (state)\nthis:\n  v \\<notin> V\n  v \\<noteq> tgt\n  rpre S (V, v)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "hence \"fe_inv S V v (E``{v}) (insert v V, False)\""], ["proof (prove)\nusing this:\n  v \\<notin> V\n  v \\<noteq> tgt\n  rpre S (V, v)\n\ngoal (1 subgoal):\n 1. fe_inv S V v (E `` {v}) (insert v V, False)", "unfolding fe_inv_def rpre_def"], ["proof (prove)\nusing this:\n  v \\<notin> V\n  v \\<noteq> tgt\n  case (V, v) of\n  (V, v) \\<Rightarrow>\n    v \\<in> local.reachable - V \\<and>\n    V \\<subseteq> local.reachable \\<and>\n    S \\<subseteq> V \\<and> tgt \\<notin> V \\<and> E `` (V - S) \\<subseteq> V\n\ngoal (1 subgoal):\n 1. case (insert v V, False) of\n    (V', r) \\<Rightarrow>\n      (r \\<longrightarrow> tgt \\<in> local.reachable) \\<and>\n      (\\<not> r \\<longrightarrow>\n       tgt \\<notin> V' \\<and>\n       insert v V \\<subseteq> V' \\<and>\n       E `` {v} - E `` {v} \\<subseteq> V' \\<and>\n       V' \\<subseteq> local.reachable \\<and>\n       S \\<subseteq> insert v V \\<and>\n       E `` (V' - S) \\<subseteq> V' \\<union> E `` {v} \\<and>\n       E `` (V' - insert v S) \\<subseteq> V')", "by (auto simp: )"], ["proof (state)\nthis:\n  fe_inv S V v (E `` {v}) (insert v V, False)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?v2 \\<notin> ?V2; ?v2 \\<noteq> tgt; rpre ?S2 (?V2, ?v2)\\<rbrakk>\n  \\<Longrightarrow> fe_inv ?S2 ?V2 ?v2 (E `` {?v2}) (insert ?v2 ?V2, False)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "note vc_enter_foreach = this"], ["proof (state)\nthis:\n  \\<lbrakk>?v2 \\<notin> ?V2; ?v2 \\<noteq> tgt; rpre ?S2 (?V2, ?v2)\\<rbrakk>\n  \\<Longrightarrow> fe_inv ?S2 ?V2 ?v2 (E `` {?v2}) (insert ?v2 ?V2, False)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?v2 \\<notin> ?V2; ?v2 \\<noteq> tgt; rpre ?S2 (?V2, ?v2)\\<rbrakk>\n  \\<Longrightarrow> fe_inv ?S2 ?V2 ?v2 (E `` {?v2}) (insert ?v2 ?V2, False)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "(* fe_inv ensures rpre *)"], ["proof (state)\nthis:\n  \\<lbrakk>?v2 \\<notin> ?V2; ?v2 \\<noteq> tgt; rpre ?S2 (?V2, ?v2)\\<rbrakk>\n  \\<Longrightarrow> fe_inv ?S2 ?V2 ?v2 (E `` {?v2}) (insert ?v2 ?V2, False)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "fix S V v v' it V'"], ["proof (state)\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "assume A: \"v'\\<notin>V'\" \"v' \\<in> it\" \"it \\<subseteq> E``{v}\"\n        and FEI: \"fe_inv S V v it (V', False)\"\n        and PRE: \"rpre S (V, v)\""], ["proof (state)\nthis:\n  v' \\<notin> V'\n  v' \\<in> it\n  it \\<subseteq> E `` {v}\n  fe_inv S V v it (V', False)\n  rpre S (V, v)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "from A"], ["proof (chain)\npicking this:\n  v' \\<notin> V'\n  v' \\<in> it\n  it \\<subseteq> E `` {v}", "have \"(v,v')\\<in>E\""], ["proof (prove)\nusing this:\n  v' \\<notin> V'\n  v' \\<in> it\n  it \\<subseteq> E `` {v}\n\ngoal (1 subgoal):\n 1. (v, v') \\<in> E", "by auto"], ["proof (state)\nthis:\n  (v, v') \\<in> E\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "moreover"], ["proof (state)\nthis:\n  (v, v') \\<in> E\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "from PRE"], ["proof (chain)\npicking this:\n  rpre S (V, v)", "have \"v \\<in> reachable\""], ["proof (prove)\nusing this:\n  rpre S (V, v)\n\ngoal (1 subgoal):\n 1. v \\<in> local.reachable", "by (auto simp: rpre_def)"], ["proof (state)\nthis:\n  v \\<in> local.reachable\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "hence \"E``{v} \\<subseteq> reachable\""], ["proof (prove)\nusing this:\n  v \\<in> local.reachable\n\ngoal (1 subgoal):\n 1. E `` {v} \\<subseteq> local.reachable", "by (auto simp: reachable_def)"], ["proof (state)\nthis:\n  E `` {v} \\<subseteq> local.reachable\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "ultimately"], ["proof (chain)\npicking this:\n  (v, v') \\<in> E\n  E `` {v} \\<subseteq> local.reachable", "have [simp]: \"v'\\<in>reachable\""], ["proof (prove)\nusing this:\n  (v, v') \\<in> E\n  E `` {v} \\<subseteq> local.reachable\n\ngoal (1 subgoal):\n 1. v' \\<in> local.reachable", "by blast"], ["proof (state)\nthis:\n  v' \\<in> local.reachable\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "from A FEI PRE"], ["proof (chain)\npicking this:\n  v' \\<notin> V'\n  v' \\<in> it\n  it \\<subseteq> E `` {v}\n  fe_inv S V v it (V', False)\n  rpre S (V, v)", "have \"rpre (insert v S) (V', v')\""], ["proof (prove)\nusing this:\n  v' \\<notin> V'\n  v' \\<in> it\n  it \\<subseteq> E `` {v}\n  fe_inv S V v it (V', False)\n  rpre S (V, v)\n\ngoal (1 subgoal):\n 1. rpre (insert v S) (V', v')", "unfolding rpre_def fe_inv_def"], ["proof (prove)\nusing this:\n  v' \\<notin> V'\n  v' \\<in> it\n  it \\<subseteq> E `` {v}\n  case (V', False) of\n  (V', r) \\<Rightarrow>\n    (r \\<longrightarrow> tgt \\<in> local.reachable) \\<and>\n    (\\<not> r \\<longrightarrow>\n     tgt \\<notin> V' \\<and>\n     insert v V \\<subseteq> V' \\<and>\n     E `` {v} - it \\<subseteq> V' \\<and>\n     V' \\<subseteq> local.reachable \\<and>\n     S \\<subseteq> insert v V \\<and>\n     E `` (V' - S) \\<subseteq> V' \\<union> it \\<and>\n     E `` (V' - insert v S) \\<subseteq> V')\n  case (V, v) of\n  (V, v) \\<Rightarrow>\n    v \\<in> local.reachable - V \\<and>\n    V \\<subseteq> local.reachable \\<and>\n    S \\<subseteq> V \\<and> tgt \\<notin> V \\<and> E `` (V - S) \\<subseteq> V\n\ngoal (1 subgoal):\n 1. case (V', v') of\n    (V, va) \\<Rightarrow>\n      va \\<in> local.reachable - V \\<and>\n      V \\<subseteq> local.reachable \\<and>\n      insert v S \\<subseteq> V \\<and>\n      tgt \\<notin> V \\<and> E `` (V - insert v S) \\<subseteq> V", "by auto"], ["proof (state)\nthis:\n  rpre (insert v S) (V', v')\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?v'2 \\<notin> ?V'2; ?v'2 \\<in> ?it2; ?it2 \\<subseteq> E `` {?v2};\n   fe_inv ?S2 ?V2 ?v2 ?it2 (?V'2, False); rpre ?S2 (?V2, ?v2)\\<rbrakk>\n  \\<Longrightarrow> rpre (insert ?v2 ?S2) (?V'2, ?v'2)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "note vc_rec_pre = this"], ["proof (state)\nthis:\n  \\<lbrakk>?v'2 \\<notin> ?V'2; ?v'2 \\<in> ?it2; ?it2 \\<subseteq> E `` {?v2};\n   fe_inv ?S2 ?V2 ?v2 ?it2 (?V'2, False); rpre ?S2 (?V2, ?v2)\\<rbrakk>\n  \\<Longrightarrow> rpre (insert ?v2 ?S2) (?V'2, ?v'2)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?v'2 \\<notin> ?V'2; ?v'2 \\<in> ?it2; ?it2 \\<subseteq> E `` {?v2};\n   fe_inv ?S2 ?V2 ?v2 ?it2 (?V'2, False); rpre ?S2 (?V2, ?v2)\\<rbrakk>\n  \\<Longrightarrow> rpre (insert ?v2 ?S2) (?V'2, ?v'2)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "(* rpost implies fe_inv *)"], ["proof (state)\nthis:\n  \\<lbrakk>?v'2 \\<notin> ?V'2; ?v'2 \\<in> ?it2; ?it2 \\<subseteq> E `` {?v2};\n   fe_inv ?S2 ?V2 ?v2 ?it2 (?V'2, False); rpre ?S2 (?V2, ?v2)\\<rbrakk>\n  \\<Longrightarrow> rpre (insert ?v2 ?S2) (?V'2, ?v'2)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "fix S V V' v v' it Vr''"], ["proof (state)\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "assume \"fe_inv S V v it (V', False)\"\n        and \"rpost (insert v S) (V', v') Vr''\""], ["proof (state)\nthis:\n  fe_inv S V v it (V', False)\n  rpost (insert v S) (V', v') Vr''\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "hence \"fe_inv S V v (it - {v'}) Vr''\""], ["proof (prove)\nusing this:\n  fe_inv S V v it (V', False)\n  rpost (insert v S) (V', v') Vr''\n\ngoal (1 subgoal):\n 1. fe_inv S V v (it - {v'}) Vr''", "unfolding rpre_def rpost_def fe_inv_def"], ["proof (prove)\nusing this:\n  case (V', False) of\n  (V', r) \\<Rightarrow>\n    (r \\<longrightarrow> tgt \\<in> local.reachable) \\<and>\n    (\\<not> r \\<longrightarrow>\n     tgt \\<notin> V' \\<and>\n     insert v V \\<subseteq> V' \\<and>\n     E `` {v} - it \\<subseteq> V' \\<and>\n     V' \\<subseteq> local.reachable \\<and>\n     S \\<subseteq> insert v V \\<and>\n     E `` (V' - S) \\<subseteq> V' \\<union> it \\<and>\n     E `` (V' - insert v S) \\<subseteq> V')\n  (case (V', v') of\n   (V, va) \\<Rightarrow>\n     \\<lambda>(V', r).\n        (r \\<longrightarrow> tgt \\<in> local.reachable) \\<and>\n        (\\<not> r \\<longrightarrow>\n         tgt \\<notin> V' \\<and>\n         V \\<subseteq> V' \\<and>\n         va \\<in> V' \\<and>\n         V' \\<subseteq> local.reachable \\<and>\n         E `` (V' - insert v S) \\<subseteq> V'))\n   Vr''\n\ngoal (1 subgoal):\n 1. case Vr'' of\n    (V', r) \\<Rightarrow>\n      (r \\<longrightarrow> tgt \\<in> local.reachable) \\<and>\n      (\\<not> r \\<longrightarrow>\n       tgt \\<notin> V' \\<and>\n       insert v V \\<subseteq> V' \\<and>\n       E `` {v} - (it - {v'}) \\<subseteq> V' \\<and>\n       V' \\<subseteq> local.reachable \\<and>\n       S \\<subseteq> insert v V \\<and>\n       E `` (V' - S) \\<subseteq> V' \\<union> (it - {v'}) \\<and>\n       E `` (V' - insert v S) \\<subseteq> V')", "by clarsimp (auto; blast)"], ["proof (state)\nthis:\n  fe_inv S V v (it - {v'}) Vr''\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>fe_inv ?S2 ?V2 ?v2 ?it2 (?V'2, False);\n   rpost (insert ?v2 ?S2) (?V'2, ?v'2) ?Vr''2\\<rbrakk>\n  \\<Longrightarrow> fe_inv ?S2 ?V2 ?v2 (?it2 - {?v'2}) ?Vr''2\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "note vc_iterate_foreach = this"], ["proof (state)\nthis:\n  \\<lbrakk>fe_inv ?S2 ?V2 ?v2 ?it2 (?V'2, False);\n   rpost (insert ?v2 ?S2) (?V'2, ?v'2) ?Vr''2\\<rbrakk>\n  \\<Longrightarrow> fe_inv ?S2 ?V2 ?v2 (?it2 - {?v'2}) ?Vr''2\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "{"], ["proof (state)\nthis:\n  \\<lbrakk>fe_inv ?S2 ?V2 ?v2 ?it2 (?V'2, False);\n   rpost (insert ?v2 ?S2) (?V'2, ?v'2) ?Vr''2\\<rbrakk>\n  \\<Longrightarrow> fe_inv ?S2 ?V2 ?v2 (?it2 - {?v'2}) ?Vr''2\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "(* Recursive call in variant relation *)"], ["proof (state)\nthis:\n  \\<lbrakk>fe_inv ?S2 ?V2 ?v2 ?it2 (?V'2, False);\n   rpost (insert ?v2 ?S2) (?V'2, ?v'2) ?Vr''2\\<rbrakk>\n  \\<Longrightarrow> fe_inv ?S2 ?V2 ?v2 (?it2 - {?v'2}) ?Vr''2\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "fix S V V' v it"], ["proof (state)\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "assume \"rpre S (V, v)\"  \n      and \"fe_inv S V v it (V', False)\""], ["proof (state)\nthis:\n  rpre S (V, v)\n  fe_inv S V v it (V', False)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "hence \"(V',V)\\<in>finite_psupset local.reachable\""], ["proof (prove)\nusing this:\n  rpre S (V, v)\n  fe_inv S V v it (V', False)\n\ngoal (1 subgoal):\n 1. (V', V) \\<in> finite_psupset local.reachable", "unfolding fe_inv_def rpre_def"], ["proof (prove)\nusing this:\n  case (V, v) of\n  (V, v) \\<Rightarrow>\n    v \\<in> local.reachable - V \\<and>\n    V \\<subseteq> local.reachable \\<and>\n    S \\<subseteq> V \\<and> tgt \\<notin> V \\<and> E `` (V - S) \\<subseteq> V\n  case (V', False) of\n  (V', r) \\<Rightarrow>\n    (r \\<longrightarrow> tgt \\<in> local.reachable) \\<and>\n    (\\<not> r \\<longrightarrow>\n     tgt \\<notin> V' \\<and>\n     insert v V \\<subseteq> V' \\<and>\n     E `` {v} - it \\<subseteq> V' \\<and>\n     V' \\<subseteq> local.reachable \\<and>\n     S \\<subseteq> insert v V \\<and>\n     E `` (V' - S) \\<subseteq> V' \\<union> it \\<and>\n     E `` (V' - insert v S) \\<subseteq> V')\n\ngoal (1 subgoal):\n 1. (V', V) \\<in> finite_psupset local.reachable", "by (auto simp: finite_psupset_def)"], ["proof (state)\nthis:\n  (V', V) \\<in> finite_psupset local.reachable\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>rpre ?S2 (?V2, ?v2);\n   fe_inv ?S2 ?V2 ?v2 ?it2 (?V'2, False)\\<rbrakk>\n  \\<Longrightarrow> (?V'2, ?V2) \\<in> finite_psupset local.reachable\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "note vc_rec_var = this"], ["proof (state)\nthis:\n  \\<lbrakk>rpre ?S2 (?V2, ?v2);\n   fe_inv ?S2 ?V2 ?v2 ?it2 (?V'2, False)\\<rbrakk>\n  \\<Longrightarrow> (?V'2, ?V2) \\<in> finite_psupset local.reachable\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "{"], ["proof (state)\nthis:\n  \\<lbrakk>rpre ?S2 (?V2, ?v2);\n   fe_inv ?S2 ?V2 ?v2 ?it2 (?V'2, False)\\<rbrakk>\n  \\<Longrightarrow> (?V'2, ?V2) \\<in> finite_psupset local.reachable\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "(* fe_inv preserved if ignoring visitied node*)"], ["proof (state)\nthis:\n  \\<lbrakk>rpre ?S2 (?V2, ?v2);\n   fe_inv ?S2 ?V2 ?v2 ?it2 (?V'2, False)\\<rbrakk>\n  \\<Longrightarrow> (?V'2, ?V2) \\<in> finite_psupset local.reachable\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "fix S V V' v v' it Vr''"], ["proof (state)\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "assume \"fe_inv S V v it (V', False)\"\n        and \"v'\\<in>V'\""], ["proof (state)\nthis:\n  fe_inv S V v it (V', False)\n  v' \\<in> V'\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "hence \"fe_inv S V v (it - {v'}) (V', False)\""], ["proof (prove)\nusing this:\n  fe_inv S V v it (V', False)\n  v' \\<in> V'\n\ngoal (1 subgoal):\n 1. fe_inv S V v (it - {v'}) (V', False)", "unfolding fe_inv_def"], ["proof (prove)\nusing this:\n  case (V', False) of\n  (V', r) \\<Rightarrow>\n    (r \\<longrightarrow> tgt \\<in> local.reachable) \\<and>\n    (\\<not> r \\<longrightarrow>\n     tgt \\<notin> V' \\<and>\n     insert v V \\<subseteq> V' \\<and>\n     E `` {v} - it \\<subseteq> V' \\<and>\n     V' \\<subseteq> local.reachable \\<and>\n     S \\<subseteq> insert v V \\<and>\n     E `` (V' - S) \\<subseteq> V' \\<union> it \\<and>\n     E `` (V' - insert v S) \\<subseteq> V')\n  v' \\<in> V'\n\ngoal (1 subgoal):\n 1. case (V', False) of\n    (V', r) \\<Rightarrow>\n      (r \\<longrightarrow> tgt \\<in> local.reachable) \\<and>\n      (\\<not> r \\<longrightarrow>\n       tgt \\<notin> V' \\<and>\n       insert v V \\<subseteq> V' \\<and>\n       E `` {v} - (it - {v'}) \\<subseteq> V' \\<and>\n       V' \\<subseteq> local.reachable \\<and>\n       S \\<subseteq> insert v V \\<and>\n       E `` (V' - S) \\<subseteq> V' \\<union> (it - {v'}) \\<and>\n       E `` (V' - insert v S) \\<subseteq> V')", "by auto"], ["proof (state)\nthis:\n  fe_inv S V v (it - {v'}) (V', False)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>fe_inv ?S2 ?V2 ?v2 ?it2 (?V'2, False); ?v'2 \\<in> ?V'2\\<rbrakk>\n  \\<Longrightarrow> fe_inv ?S2 ?V2 ?v2 (?it2 - {?v'2}) (?V'2, False)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "note vc_foreach_ignore = this"], ["proof (state)\nthis:\n  \\<lbrakk>fe_inv ?S2 ?V2 ?v2 ?it2 (?V'2, False); ?v'2 \\<in> ?V'2\\<rbrakk>\n  \\<Longrightarrow> fe_inv ?S2 ?V2 ?v2 (?it2 - {?v'2}) (?V'2, False)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "{"], ["proof (state)\nthis:\n  \\<lbrakk>fe_inv ?S2 ?V2 ?v2 ?it2 (?V'2, False); ?v'2 \\<in> ?V'2\\<rbrakk>\n  \\<Longrightarrow> fe_inv ?S2 ?V2 ?v2 (?it2 - {?v'2}) (?V'2, False)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "(* fe_inv (completed) implies rpost *)"], ["proof (state)\nthis:\n  \\<lbrakk>fe_inv ?S2 ?V2 ?v2 ?it2 (?V'2, False); ?v'2 \\<in> ?V'2\\<rbrakk>\n  \\<Longrightarrow> fe_inv ?S2 ?V2 ?v2 (?it2 - {?v'2}) (?V'2, False)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "fix S V v V'"], ["proof (state)\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "assume FEI: \"fe_inv S V v {} (V', False)\""], ["proof (state)\nthis:\n  fe_inv S V v {} (V', False)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "have \"rpost S (V, v) (V', False)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rpost S (V, v) (V', False)", "unfolding rpost_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case (V, v) of\n     (V, v) \\<Rightarrow>\n       \\<lambda>(V', r).\n          (r \\<longrightarrow> tgt \\<in> local.reachable) \\<and>\n          (\\<not> r \\<longrightarrow>\n           tgt \\<notin> V' \\<and>\n           V \\<subseteq> V' \\<and>\n           v \\<in> V' \\<and>\n           V' \\<subseteq> local.reachable \\<and>\n           E `` (V' - S) \\<subseteq> V'))\n     (V', False)", "using FEI"], ["proof (prove)\nusing this:\n  fe_inv S V v {} (V', False)\n\ngoal (1 subgoal):\n 1. (case (V, v) of\n     (V, v) \\<Rightarrow>\n       \\<lambda>(V', r).\n          (r \\<longrightarrow> tgt \\<in> local.reachable) \\<and>\n          (\\<not> r \\<longrightarrow>\n           tgt \\<notin> V' \\<and>\n           V \\<subseteq> V' \\<and>\n           v \\<in> V' \\<and>\n           V' \\<subseteq> local.reachable \\<and>\n           E `` (V' - S) \\<subseteq> V'))\n     (V', False)", "by (auto simp: fe_inv_def) []"], ["proof (state)\nthis:\n  rpost S (V, v) (V', False)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "}"], ["proof (state)\nthis:\n  fe_inv ?S2 ?V2 ?v2 {} (?V'2, False) \\<Longrightarrow>\n  rpost ?S2 (?V2, ?v2) (?V'2, False)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "note vc_foreach_completed_imp_post = this"], ["proof (state)\nthis:\n  fe_inv ?S2 ?V2 ?v2 {} (?V'2, False) \\<Longrightarrow>\n  rpost ?S2 (?V2, ?v2) (?V'2, False)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "{"], ["proof (state)\nthis:\n  fe_inv ?S2 ?V2 ?v2 {} (?V'2, False) \\<Longrightarrow>\n  rpost ?S2 (?V2, ?v2) (?V'2, False)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "(* fe_inv (interrupted) implies rpost *)"], ["proof (state)\nthis:\n  fe_inv ?S2 ?V2 ?v2 {} (?V'2, False) \\<Longrightarrow>\n  rpost ?S2 (?V2, ?v2) (?V'2, False)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "fix S V v V' it"], ["proof (state)\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "assume FEI: \"fe_inv S V v it (V', True)\""], ["proof (state)\nthis:\n  fe_inv S V v it (V', True)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "hence \"rpost S (V, v) (V', True)\""], ["proof (prove)\nusing this:\n  fe_inv S V v it (V', True)\n\ngoal (1 subgoal):\n 1. rpost S (V, v) (V', True)", "by (auto simp add: rpost_def fe_inv_def) []"], ["proof (state)\nthis:\n  rpost S (V, v) (V', True)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "}"], ["proof (state)\nthis:\n  fe_inv ?S2 ?V2 ?v2 ?it2 (?V'2, True) \\<Longrightarrow>\n  rpost ?S2 (?V2, ?v2) (?V'2, True)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "note vc_foreach_interrupted_imp_post = this"], ["proof (state)\nthis:\n  fe_inv ?S2 ?V2 ?v2 ?it2 (?V'2, True) \\<Longrightarrow>\n  rpost ?S2 (?V2, ?v2) (?V'2, True)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "{"], ["proof (state)\nthis:\n  fe_inv ?S2 ?V2 ?v2 ?it2 (?V'2, True) \\<Longrightarrow>\n  rpost ?S2 (?V2, ?v2) (?V'2, True)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "(* The postcondition of the recursion implies our desired specification *)"], ["proof (state)\nthis:\n  fe_inv ?S2 ?V2 ?v2 ?it2 (?V'2, True) \\<Longrightarrow>\n  rpost ?S2 (?V2, ?v2) (?V'2, True)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "fix V r"], ["proof (state)\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "assume \"rpost {} ({}, src) (V, r)\""], ["proof (state)\nthis:\n  rpost {} ({}, src) (V, r)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "hence \"r = ((src, tgt) \\<in> E\\<^sup>*)\""], ["proof (prove)\nusing this:\n  rpost {} ({}, src) (V, r)\n\ngoal (1 subgoal):\n 1. r = ((src, tgt) \\<in> E\\<^sup>*)", "by (auto \n          simp: rpost_def reachable_def \n          dest: Image_closed_trancl \n          intro: rev_ImageI)"], ["proof (state)\nthis:\n  r = ((src, tgt) \\<in> E\\<^sup>*)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "}"], ["proof (state)\nthis:\n  rpost {} ({}, src) (?V2, ?r2) \\<Longrightarrow>\n  ?r2 = ((src, tgt) \\<in> E\\<^sup>*)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "note vc_rpost_imp_spec = this"], ["proof (state)\nthis:\n  rpost {} ({}, src) (?V2, ?r2) \\<Longrightarrow>\n  ?r2 = ((src, tgt) \\<in> E\\<^sup>*)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "text \\<open>The verification condition generation is technical. We invoke the VCG,\n      and discharge the generated VCs. The trivial ones are discharged on the spot, the\n      more complicated ones have been extracted to separate facts, that we use in the proof \n      text below.\n    \\<close>"], ["proof (state)\nthis:\n  rpost {} ({}, src) (?V2, ?r2) \\<Longrightarrow>\n  ?r2 = ((src, tgt) \\<in> E\\<^sup>*)\n\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "unfolding dfs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. REC\\<^sub>T\n     (\\<lambda>dfs (V, v).\n         if v = tgt then RETURN (V, True)\n         else let V = insert v V\n              in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, brk). \\<not> brk)\n                  (\\<lambda>v' (V, brk).\n                      if v' \\<notin> V then dfs (V, v')\n                      else RETURN (V, False))\n                  (V, False))\n     ({}, src) \\<bind>\n    (\\<lambda>(uu_, r). RETURN r)\n    \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "apply (refine_vcg RECT_rule_arb[\n        where \n              pre=rpre and arb=\"{}\"\n          and M=\"\\<lambda>a x. SPEC (rpost a x)\"\n          and V=\"inv_image (finite_psupset reachable) fst\", \n        THEN order_trans\n        ])"], ["proof (prove)\ngoal (5 subgoals):\n 1. wf (inv_image (finite_psupset local.reachable) fst)\n 2. rpre {} ({}, src)\n 3. \\<And>f arb x a b.\n       \\<lbrakk>\\<And>arb' x'.\n                   \\<lbrakk>rpre arb' x';\n                    (x', x)\n                    \\<in> inv_image (finite_psupset local.reachable)\n                           fst\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> SPEC (rpost arb' x');\n        rpre arb x;\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v = tgt then RETURN (V, True)\n             else let V = insert v V\n                  in FOREACH\\<^sub>C (E `` {v})\n                      (\\<lambda>(V, brk). \\<not> brk)\n                      (\\<lambda>v' (V, brk).\n                          if v' \\<notin> V then dfs (V, v')\n                          else RETURN (V, False))\n                      (V, False)) =\n        f;\n        x = (a, b); b = tgt\\<rbrakk>\n       \\<Longrightarrow> rpost arb x (a, True)\n 4. \\<And>f arb x a b.\n       \\<lbrakk>\\<And>arb' x'.\n                   \\<lbrakk>rpre arb' x';\n                    (x', x)\n                    \\<in> inv_image (finite_psupset local.reachable)\n                           fst\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> SPEC (rpost arb' x');\n        rpre arb x;\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v = tgt then RETURN (V, True)\n             else let V = insert v V\n                  in FOREACH\\<^sub>C (E `` {v})\n                      (\\<lambda>(V, brk). \\<not> brk)\n                      (\\<lambda>v' (V, brk).\n                          if v' \\<notin> V then dfs (V, v')\n                          else RETURN (V, False))\n                      (V, False)) =\n        f;\n        x = (a, b); b \\<noteq> tgt\\<rbrakk>\n       \\<Longrightarrow> FOREACH\\<^sub>C (E `` {b})\n                          (\\<lambda>(V, brk). \\<not> brk)\n                          (\\<lambda>v' (V, brk).\n                              if v' \\<notin> V then f (V, v')\n                              else RETURN (V, False))\n                          (insert b a, False)\n                         \\<le> SPEC (rpost arb x)\n 5. \\<And>x a b.\n       \\<lbrakk>rpost {} ({}, src) x; x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> b = ((src, tgt) \\<in> E\\<^sup>*)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (inv_image (finite_psupset local.reachable) fst)", "by blast"], ["proof (prove)\ngoal (4 subgoals):\n 1. rpre {} ({}, src)\n 2. \\<And>f arb x a b.\n       \\<lbrakk>\\<And>arb' x'.\n                   \\<lbrakk>rpre arb' x';\n                    (x', x)\n                    \\<in> inv_image (finite_psupset local.reachable)\n                           fst\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> SPEC (rpost arb' x');\n        rpre arb x;\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v = tgt then RETURN (V, True)\n             else let V = insert v V\n                  in FOREACH\\<^sub>C (E `` {v})\n                      (\\<lambda>(V, brk). \\<not> brk)\n                      (\\<lambda>v' (V, brk).\n                          if v' \\<notin> V then dfs (V, v')\n                          else RETURN (V, False))\n                      (V, False)) =\n        f;\n        x = (a, b); b = tgt\\<rbrakk>\n       \\<Longrightarrow> rpost arb x (a, True)\n 3. \\<And>f arb x a b.\n       \\<lbrakk>\\<And>arb' x'.\n                   \\<lbrakk>rpre arb' x';\n                    (x', x)\n                    \\<in> inv_image (finite_psupset local.reachable)\n                           fst\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> SPEC (rpost arb' x');\n        rpre arb x;\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v = tgt then RETURN (V, True)\n             else let V = insert v V\n                  in FOREACH\\<^sub>C (E `` {v})\n                      (\\<lambda>(V, brk). \\<not> brk)\n                      (\\<lambda>v' (V, brk).\n                          if v' \\<notin> V then dfs (V, v')\n                          else RETURN (V, False))\n                      (V, False)) =\n        f;\n        x = (a, b); b \\<noteq> tgt\\<rbrakk>\n       \\<Longrightarrow> FOREACH\\<^sub>C (E `` {b})\n                          (\\<lambda>(V, brk). \\<not> brk)\n                          (\\<lambda>v' (V, brk).\n                              if v' \\<notin> V then f (V, v')\n                              else RETURN (V, False))\n                          (insert b a, False)\n                         \\<le> SPEC (rpost arb x)\n 4. \\<And>x a b.\n       \\<lbrakk>rpost {} ({}, src) x; x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> b = ((src, tgt) \\<in> E\\<^sup>*)", "(* Well-Foundedness  *)"], ["proof (prove)\ngoal (4 subgoals):\n 1. rpre {} ({}, src)\n 2. \\<And>f arb x a b.\n       \\<lbrakk>\\<And>arb' x'.\n                   \\<lbrakk>rpre arb' x';\n                    (x', x)\n                    \\<in> inv_image (finite_psupset local.reachable)\n                           fst\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> SPEC (rpost arb' x');\n        rpre arb x;\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v = tgt then RETURN (V, True)\n             else let V = insert v V\n                  in FOREACH\\<^sub>C (E `` {v})\n                      (\\<lambda>(V, brk). \\<not> brk)\n                      (\\<lambda>v' (V, brk).\n                          if v' \\<notin> V then dfs (V, v')\n                          else RETURN (V, False))\n                      (V, False)) =\n        f;\n        x = (a, b); b = tgt\\<rbrakk>\n       \\<Longrightarrow> rpost arb x (a, True)\n 3. \\<And>f arb x a b.\n       \\<lbrakk>\\<And>arb' x'.\n                   \\<lbrakk>rpre arb' x';\n                    (x', x)\n                    \\<in> inv_image (finite_psupset local.reachable)\n                           fst\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> SPEC (rpost arb' x');\n        rpre arb x;\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v = tgt then RETURN (V, True)\n             else let V = insert v V\n                  in FOREACH\\<^sub>C (E `` {v})\n                      (\\<lambda>(V, brk). \\<not> brk)\n                      (\\<lambda>v' (V, brk).\n                          if v' \\<notin> V then dfs (V, v')\n                          else RETURN (V, False))\n                      (V, False)) =\n        f;\n        x = (a, b); b \\<noteq> tgt\\<rbrakk>\n       \\<Longrightarrow> FOREACH\\<^sub>C (E `` {b})\n                          (\\<lambda>(V, brk). \\<not> brk)\n                          (\\<lambda>v' (V, brk).\n                              if v' \\<notin> V then f (V, v')\n                              else RETURN (V, False))\n                          (insert b a, False)\n                         \\<le> SPEC (rpost arb x)\n 4. \\<And>x a b.\n       \\<lbrakk>rpost {} ({}, src) x; x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> b = ((src, tgt) \\<in> E\\<^sup>*)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. rpre {} ({}, src)", "by (rule vc_pre_initial)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>f arb x a b.\n       \\<lbrakk>\\<And>arb' x'.\n                   \\<lbrakk>rpre arb' x';\n                    (x', x)\n                    \\<in> inv_image (finite_psupset local.reachable)\n                           fst\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> SPEC (rpost arb' x');\n        rpre arb x;\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v = tgt then RETURN (V, True)\n             else let V = insert v V\n                  in FOREACH\\<^sub>C (E `` {v})\n                      (\\<lambda>(V, brk). \\<not> brk)\n                      (\\<lambda>v' (V, brk).\n                          if v' \\<notin> V then dfs (V, v')\n                          else RETURN (V, False))\n                      (V, False)) =\n        f;\n        x = (a, b); b = tgt\\<rbrakk>\n       \\<Longrightarrow> rpost arb x (a, True)\n 2. \\<And>f arb x a b.\n       \\<lbrakk>\\<And>arb' x'.\n                   \\<lbrakk>rpre arb' x';\n                    (x', x)\n                    \\<in> inv_image (finite_psupset local.reachable)\n                           fst\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> SPEC (rpost arb' x');\n        rpre arb x;\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v = tgt then RETURN (V, True)\n             else let V = insert v V\n                  in FOREACH\\<^sub>C (E `` {v})\n                      (\\<lambda>(V, brk). \\<not> brk)\n                      (\\<lambda>v' (V, brk).\n                          if v' \\<notin> V then dfs (V, v')\n                          else RETURN (V, False))\n                      (V, False)) =\n        f;\n        x = (a, b); b \\<noteq> tgt\\<rbrakk>\n       \\<Longrightarrow> FOREACH\\<^sub>C (E `` {b})\n                          (\\<lambda>(V, brk). \\<not> brk)\n                          (\\<lambda>v' (V, brk).\n                              if v' \\<notin> V then f (V, v')\n                              else RETURN (V, False))\n                          (insert b a, False)\n                         \\<le> SPEC (rpost arb x)\n 3. \\<And>x a b.\n       \\<lbrakk>rpost {} ({}, src) x; x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> b = ((src, tgt) \\<in> E\\<^sup>*)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>arb' x'.\n                \\<lbrakk>rpre arb' x';\n                 (x', x_)\n                 \\<in> inv_image (finite_psupset local.reachable)\n                        fst\\<rbrakk>\n                \\<Longrightarrow> f_ x' \\<le> SPEC (rpost arb' x');\n     rpre arb_ x_;\n     REC\\<^sub>T\n      (\\<lambda>dfs (V, v).\n          if v = tgt then RETURN (V, True)\n          else let V = insert v V\n               in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, brk). \\<not> brk)\n                   (\\<lambda>v' (V, brk).\n                       if v' \\<notin> V then dfs (V, v')\n                       else RETURN (V, False))\n                   (V, False)) =\n     f_;\n     x_ = (a_, b_); b_ = tgt\\<rbrakk>\n    \\<Longrightarrow> rpost arb_ x_ (a_, True)", "by (auto simp add: rpre_def rpost_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f arb x a b.\n       \\<lbrakk>\\<And>arb' x'.\n                   \\<lbrakk>rpre arb' x';\n                    (x', x)\n                    \\<in> inv_image (finite_psupset local.reachable)\n                           fst\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> SPEC (rpost arb' x');\n        rpre arb x;\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v = tgt then RETURN (V, True)\n             else let V = insert v V\n                  in FOREACH\\<^sub>C (E `` {v})\n                      (\\<lambda>(V, brk). \\<not> brk)\n                      (\\<lambda>v' (V, brk).\n                          if v' \\<notin> V then dfs (V, v')\n                          else RETURN (V, False))\n                      (V, False)) =\n        f;\n        x = (a, b); b \\<noteq> tgt\\<rbrakk>\n       \\<Longrightarrow> FOREACH\\<^sub>C (E `` {b})\n                          (\\<lambda>(V, brk). \\<not> brk)\n                          (\\<lambda>v' (V, brk).\n                              if v' \\<notin> V then f (V, v')\n                              else RETURN (V, False))\n                          (insert b a, False)\n                         \\<le> SPEC (rpost arb x)\n 2. \\<And>x a b.\n       \\<lbrakk>rpost {} ({}, src) x; x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> b = ((src, tgt) \\<in> E\\<^sup>*)", "(* Found tgt node *)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f arb x a b.\n       \\<lbrakk>\\<And>arb' x'.\n                   \\<lbrakk>rpre arb' x';\n                    (x', x)\n                    \\<in> inv_image (finite_psupset local.reachable)\n                           fst\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> SPEC (rpost arb' x');\n        rpre arb x;\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v = tgt then RETURN (V, True)\n             else let V = insert v V\n                  in FOREACH\\<^sub>C (E `` {v})\n                      (\\<lambda>(V, brk). \\<not> brk)\n                      (\\<lambda>v' (V, brk).\n                          if v' \\<notin> V then dfs (V, v')\n                          else RETURN (V, False))\n                      (V, False)) =\n        f;\n        x = (a, b); b \\<noteq> tgt\\<rbrakk>\n       \\<Longrightarrow> FOREACH\\<^sub>C (E `` {b})\n                          (\\<lambda>(V, brk). \\<not> brk)\n                          (\\<lambda>v' (V, brk).\n                              if v' \\<notin> V then f (V, v')\n                              else RETURN (V, False))\n                          (insert b a, False)\n                         \\<le> SPEC (rpost arb x)\n 2. \\<And>x a b.\n       \\<lbrakk>rpost {} ({}, src) x; x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> b = ((src, tgt) \\<in> E\\<^sup>*)", "subgoal for f S _ V v"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>arb' x'.\n                \\<lbrakk>rpre arb' x';\n                 (x', x_)\n                 \\<in> inv_image (finite_psupset local.reachable)\n                        fst\\<rbrakk>\n                \\<Longrightarrow> f x' \\<le> SPEC (rpost arb' x');\n     rpre S x_;\n     REC\\<^sub>T\n      (\\<lambda>dfs (V, v).\n          if v = tgt then RETURN (V, True)\n          else let V = insert v V\n               in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, brk). \\<not> brk)\n                   (\\<lambda>v' (V, brk).\n                       if v' \\<notin> V then dfs (V, v')\n                       else RETURN (V, False))\n                   (V, False)) =\n     f;\n     x_ = (V, v); v \\<noteq> tgt\\<rbrakk>\n    \\<Longrightarrow> FOREACH\\<^sub>C (E `` {v})\n                       (\\<lambda>(V, brk). \\<not> brk)\n                       (\\<lambda>v' (V, brk).\n                           if v' \\<notin> V then f (V, v')\n                           else RETURN (V, False))\n                       (insert v V, False)\n                      \\<le> SPEC (rpost S x_)", "(* Entering inner FOREACH loop *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>arb' x'.\n                \\<lbrakk>rpre arb' x';\n                 (x', x_)\n                 \\<in> inv_image (finite_psupset local.reachable)\n                        fst\\<rbrakk>\n                \\<Longrightarrow> f x' \\<le> SPEC (rpost arb' x');\n     rpre S x_;\n     REC\\<^sub>T\n      (\\<lambda>dfs (V, v).\n          if v = tgt then RETURN (V, True)\n          else let V = insert v V\n               in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, brk). \\<not> brk)\n                   (\\<lambda>v' (V, brk).\n                       if v' \\<notin> V then dfs (V, v')\n                       else RETURN (V, False))\n                   (V, False)) =\n     f;\n     x_ = (V, v); v \\<noteq> tgt\\<rbrakk>\n    \\<Longrightarrow> FOREACH\\<^sub>C (E `` {v})\n                       (\\<lambda>(V, brk). \\<not> brk)\n                       (\\<lambda>v' (V, brk).\n                           if v' \\<notin> V then f (V, v')\n                           else RETURN (V, False))\n                       (insert v V, False)\n                      \\<le> SPEC (rpost S x_)", "apply (refine_rcg refine_vcg \n          FOREACHc_rule'[where I=\"fe_inv S V v\" (*for S V*)]\n          )"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<And>arb' x'.\n                \\<lbrakk>rpre arb' x';\n                 (x', x_)\n                 \\<in> inv_image (finite_psupset local.reachable)\n                        fst\\<rbrakk>\n                \\<Longrightarrow> f x' \\<le> SPEC (rpost arb' x');\n     rpre S x_;\n     REC\\<^sub>T\n      (\\<lambda>dfs (V, v).\n          if v = tgt then RETURN (V, True)\n          else let V = insert v V\n               in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, brk). \\<not> brk)\n                   (\\<lambda>v' (V, brk).\n                       if v' \\<notin> V then dfs (V, v')\n                       else RETURN (V, False))\n                   (V, False)) =\n     f;\n     x_ = (V, v); v \\<noteq> tgt\\<rbrakk>\n    \\<Longrightarrow> finite (E `` {v})\n 2. \\<lbrakk>\\<And>arb' x'.\n                \\<lbrakk>rpre arb' x';\n                 (x', x_)\n                 \\<in> inv_image (finite_psupset local.reachable)\n                        fst\\<rbrakk>\n                \\<Longrightarrow> f x' \\<le> SPEC (rpost arb' x');\n     rpre S x_;\n     REC\\<^sub>T\n      (\\<lambda>dfs (V, v).\n          if v = tgt then RETURN (V, True)\n          else let V = insert v V\n               in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, brk). \\<not> brk)\n                   (\\<lambda>v' (V, brk).\n                       if v' \\<notin> V then dfs (V, v')\n                       else RETURN (V, False))\n                   (V, False)) =\n     f;\n     x_ = (V, v); v \\<noteq> tgt\\<rbrakk>\n    \\<Longrightarrow> fe_inv S V v (E `` {v}) (insert v V, False)\n 3. \\<And>xa it \\<sigma> a b.\n       \\<lbrakk>\\<And>arb' x'.\n                   \\<lbrakk>rpre arb' x';\n                    (x', x_)\n                    \\<in> inv_image (finite_psupset local.reachable)\n                           fst\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> SPEC (rpost arb' x');\n        rpre S x_;\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v = tgt then RETURN (V, True)\n             else let V = insert v V\n                  in FOREACH\\<^sub>C (E `` {v})\n                      (\\<lambda>(V, brk). \\<not> brk)\n                      (\\<lambda>v' (V, brk).\n                          if v' \\<notin> V then dfs (V, v')\n                          else RETURN (V, False))\n                      (V, False)) =\n        f;\n        x_ = (V, v); v \\<noteq> tgt; xa \\<in> it; it \\<subseteq> E `` {v};\n        fe_inv S V v it \\<sigma>;\n        case \\<sigma> of (V, brk) \\<Rightarrow> \\<not> brk;\n        \\<sigma> = (a, b); xa \\<notin> a\\<rbrakk>\n       \\<Longrightarrow> f (a, xa) \\<le> SPEC (fe_inv S V v (it - {xa}))\n 4. \\<And>xa it \\<sigma> a b.\n       \\<lbrakk>\\<And>arb' x'.\n                   \\<lbrakk>rpre arb' x';\n                    (x', x_)\n                    \\<in> inv_image (finite_psupset local.reachable)\n                           fst\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> SPEC (rpost arb' x');\n        rpre S x_;\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v = tgt then RETURN (V, True)\n             else let V = insert v V\n                  in FOREACH\\<^sub>C (E `` {v})\n                      (\\<lambda>(V, brk). \\<not> brk)\n                      (\\<lambda>v' (V, brk).\n                          if v' \\<notin> V then dfs (V, v')\n                          else RETURN (V, False))\n                      (V, False)) =\n        f;\n        x_ = (V, v); v \\<noteq> tgt; xa \\<in> it; it \\<subseteq> E `` {v};\n        fe_inv S V v it \\<sigma>;\n        case \\<sigma> of (V, brk) \\<Rightarrow> \\<not> brk;\n        \\<sigma> = (a, b); \\<not> xa \\<notin> a\\<rbrakk>\n       \\<Longrightarrow> fe_inv S V v (it - {xa}) (a, False)\n 5. \\<And>\\<sigma>.\n       \\<lbrakk>\\<And>arb' x'.\n                   \\<lbrakk>rpre arb' x';\n                    (x', x_)\n                    \\<in> inv_image (finite_psupset local.reachable)\n                           fst\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> SPEC (rpost arb' x');\n        rpre S x_;\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v = tgt then RETURN (V, True)\n             else let V = insert v V\n                  in FOREACH\\<^sub>C (E `` {v})\n                      (\\<lambda>(V, brk). \\<not> brk)\n                      (\\<lambda>v' (V, brk).\n                          if v' \\<notin> V then dfs (V, v')\n                          else RETURN (V, False))\n                      (V, False)) =\n        f;\n        x_ = (V, v); v \\<noteq> tgt; fe_inv S V v {} \\<sigma>;\n        case \\<sigma> of (V, brk) \\<Rightarrow> \\<not> brk\\<rbrakk>\n       \\<Longrightarrow> rpost S x_ \\<sigma>\n 6. \\<And>it \\<sigma>.\n       \\<lbrakk>\\<And>arb' x'.\n                   \\<lbrakk>rpre arb' x';\n                    (x', x_)\n                    \\<in> inv_image (finite_psupset local.reachable)\n                           fst\\<rbrakk>\n                   \\<Longrightarrow> f x' \\<le> SPEC (rpost arb' x');\n        rpre S x_;\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v = tgt then RETURN (V, True)\n             else let V = insert v V\n                  in FOREACH\\<^sub>C (E `` {v})\n                      (\\<lambda>(V, brk). \\<not> brk)\n                      (\\<lambda>v' (V, brk).\n                          if v' \\<notin> V then dfs (V, v')\n                          else RETURN (V, False))\n                      (V, False)) =\n        f;\n        x_ = (V, v); v \\<noteq> tgt; it \\<subseteq> E `` {v};\n        fe_inv S V v it \\<sigma>;\n        \\<not> (case \\<sigma> of (V, brk) \\<Rightarrow> \\<not> brk)\\<rbrakk>\n       \\<Longrightarrow> rpost S x_ \\<sigma>", "apply clarsimp_all"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<And>arb' a b.\n                \\<lbrakk>rpre arb' (a, b);\n                 (a, V) \\<in> finite_psupset local.reachable\\<rbrakk>\n                \\<Longrightarrow> REC\\<^sub>T\n                                   (\\<lambda>dfs (V, v).\n if v = tgt then RETURN (V, True)\n else let V = insert v V\n      in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, brk). \\<not> brk)\n          (\\<lambda>v' (V, brk).\n              if v' \\<notin> V then dfs (V, v') else RETURN (V, False))\n          (V, False))\n                                   (a, b)\n                                  \\<le> SPEC (rpost arb' (a, b));\n     rpre S (V, v); x_ = (V, v); v \\<noteq> tgt;\n     f =\n     REC\\<^sub>T\n      (\\<lambda>dfs (V, v).\n          if v = tgt then RETURN (V, True)\n          else let V = insert v V\n               in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, brk). \\<not> brk)\n                   (\\<lambda>v' (V, brk).\n                       if v' \\<notin> V then dfs (V, v')\n                       else RETURN (V, False))\n                   (V, False))\\<rbrakk>\n    \\<Longrightarrow> finite (E `` {v})\n 2. \\<lbrakk>\\<And>arb' a b.\n                \\<lbrakk>rpre arb' (a, b);\n                 (a, V) \\<in> finite_psupset local.reachable\\<rbrakk>\n                \\<Longrightarrow> REC\\<^sub>T\n                                   (\\<lambda>dfs (V, v).\n if v = tgt then RETURN (V, True)\n else let V = insert v V\n      in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, brk). \\<not> brk)\n          (\\<lambda>v' (V, brk).\n              if v' \\<notin> V then dfs (V, v') else RETURN (V, False))\n          (V, False))\n                                   (a, b)\n                                  \\<le> SPEC (rpost arb' (a, b));\n     rpre S (V, v); x_ = (V, v); v \\<noteq> tgt;\n     f =\n     REC\\<^sub>T\n      (\\<lambda>dfs (V, v).\n          if v = tgt then RETURN (V, True)\n          else let V = insert v V\n               in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, brk). \\<not> brk)\n                   (\\<lambda>v' (V, brk).\n                       if v' \\<notin> V then dfs (V, v')\n                       else RETURN (V, False))\n                   (V, False))\\<rbrakk>\n    \\<Longrightarrow> fe_inv S V v (E `` {v}) (insert v V, False)\n 3. \\<And>xa it aa ba.\n       \\<lbrakk>\\<And>arb' a b.\n                   \\<lbrakk>rpre arb' (a, b);\n                    (a, V) \\<in> finite_psupset local.reachable\\<rbrakk>\n                   \\<Longrightarrow> REC\\<^sub>T\n(\\<lambda>dfs (V, v).\n    if v = tgt then RETURN (V, True)\n    else let V = insert v V\n         in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n             (\\<lambda>v' (V, brk).\n                 if v' \\<notin> V then dfs (V, v') else RETURN (V, False))\n             (V, False))\n(a, b)\n                                     \\<le> SPEC (rpost arb' (a, b));\n        rpre S (V, v); x_ = (V, v); v \\<noteq> tgt; xa \\<in> it;\n        it \\<subseteq> E `` {v}; fe_inv S V v it (aa, False); \\<not> ba;\n        xa \\<notin> aa;\n        f =\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v = tgt then RETURN (V, True)\n             else let V = insert v V\n                  in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n                      (\\<lambda>v' (V, brk).\n                          if v' \\<notin> V then dfs (V, v')\n                          else RETURN (V, False))\n                      (V, False))\\<rbrakk>\n       \\<Longrightarrow> REC\\<^sub>T\n                          (\\<lambda>dfs (V, v).\n                              if v = tgt then RETURN (V, True)\n                              else let V = insert v V\n                                   in FOREACH\\<^sub>C (E `` {v})\n (\\<lambda>(V, y). \\<not> y)\n (\\<lambda>v' (V, brk).\n     if v' \\<notin> V then dfs (V, v') else RETURN (V, False))\n (V, False))\n                          (aa, xa)\n                         \\<le> SPEC (fe_inv S V v (it - {xa}))\n 4. \\<And>xa it aa ba.\n       \\<lbrakk>\\<And>arb' a b.\n                   \\<lbrakk>rpre arb' (a, b);\n                    (a, V) \\<in> finite_psupset local.reachable\\<rbrakk>\n                   \\<Longrightarrow> REC\\<^sub>T\n(\\<lambda>dfs (V, v).\n    if v = tgt then RETURN (V, True)\n    else let V = insert v V\n         in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n             (\\<lambda>v' (V, brk).\n                 if v' \\<notin> V then dfs (V, v') else RETURN (V, False))\n             (V, False))\n(a, b)\n                                     \\<le> SPEC (rpost arb' (a, b));\n        rpre S (V, v); x_ = (V, v); v \\<noteq> tgt; xa \\<in> it;\n        it \\<subseteq> E `` {v}; fe_inv S V v it (aa, False); \\<not> ba;\n        xa \\<in> aa;\n        f =\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v = tgt then RETURN (V, True)\n             else let V = insert v V\n                  in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n                      (\\<lambda>v' (V, brk).\n                          if v' \\<notin> V then dfs (V, v')\n                          else RETURN (V, False))\n                      (V, False))\\<rbrakk>\n       \\<Longrightarrow> fe_inv S V v (it - {xa}) (aa, False)\n 5. \\<And>a b.\n       \\<lbrakk>\\<And>arb' a b.\n                   \\<lbrakk>rpre arb' (a, b);\n                    (a, V) \\<in> finite_psupset local.reachable\\<rbrakk>\n                   \\<Longrightarrow> REC\\<^sub>T\n(\\<lambda>dfs (V, v).\n    if v = tgt then RETURN (V, True)\n    else let V = insert v V\n         in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n             (\\<lambda>v' (V, brk).\n                 if v' \\<notin> V then dfs (V, v') else RETURN (V, False))\n             (V, False))\n(a, b)\n                                     \\<le> SPEC (rpost arb' (a, b));\n        rpre S (V, v); x_ = (V, v); v \\<noteq> tgt;\n        fe_inv S V v {} (a, False); \\<not> b;\n        f =\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v = tgt then RETURN (V, True)\n             else let V = insert v V\n                  in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n                      (\\<lambda>v' (V, brk).\n                          if v' \\<notin> V then dfs (V, v')\n                          else RETURN (V, False))\n                      (V, False))\\<rbrakk>\n       \\<Longrightarrow> rpost S (V, v) (a, False)\n 6. \\<And>it a b.\n       \\<lbrakk>\\<And>arb' a b.\n                   \\<lbrakk>rpre arb' (a, b);\n                    (a, V) \\<in> finite_psupset local.reachable\\<rbrakk>\n                   \\<Longrightarrow> REC\\<^sub>T\n(\\<lambda>dfs (V, v).\n    if v = tgt then RETURN (V, True)\n    else let V = insert v V\n         in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n             (\\<lambda>v' (V, brk).\n                 if v' \\<notin> V then dfs (V, v') else RETURN (V, False))\n             (V, False))\n(a, b)\n                                     \\<le> SPEC (rpost arb' (a, b));\n        rpre S (V, v); x_ = (V, v); v \\<noteq> tgt; it \\<subseteq> E `` {v};\n        fe_inv S V v it (a, True);\n        f =\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v = tgt then RETURN (V, True)\n             else let V = insert v V\n                  in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n                      (\\<lambda>v' (V, brk).\n                          if v' \\<notin> V then dfs (V, v')\n                          else RETURN (V, False))\n                      (V, False));\n        \\<not> rpost S (V, v) (a, True); b\\<rbrakk>\n       \\<Longrightarrow> False", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>arb' a b.\n                \\<lbrakk>rpre arb' (a, b);\n                 (a, V) \\<in> finite_psupset local.reachable\\<rbrakk>\n                \\<Longrightarrow> REC\\<^sub>T\n                                   (\\<lambda>dfs (V, v).\n if v = tgt then RETURN (V, True)\n else let V = insert v V\n      in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, brk). \\<not> brk)\n          (\\<lambda>v' (V, brk).\n              if v' \\<notin> V then dfs (V, v') else RETURN (V, False))\n          (V, False))\n                                   (a, b)\n                                  \\<le> SPEC (rpost arb' (a, b));\n     rpre S (V, v); x_ = (V, v); v \\<noteq> tgt;\n     f =\n     REC\\<^sub>T\n      (\\<lambda>dfs (V, v).\n          if v = tgt then RETURN (V, True)\n          else let V = insert v V\n               in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, brk). \\<not> brk)\n                   (\\<lambda>v' (V, brk).\n                       if v' \\<notin> V then dfs (V, v')\n                       else RETURN (V, False))\n                   (V, False))\\<rbrakk>\n    \\<Longrightarrow> finite (E `` {v})", "by (simp add: vc_foreach_finite)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<And>arb' a b.\n                \\<lbrakk>rpre arb' (a, b);\n                 (a, V) \\<in> finite_psupset local.reachable\\<rbrakk>\n                \\<Longrightarrow> REC\\<^sub>T\n                                   (\\<lambda>dfs (V, v).\n if v = tgt then RETURN (V, True)\n else let V = insert v V\n      in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, brk). \\<not> brk)\n          (\\<lambda>v' (V, brk).\n              if v' \\<notin> V then dfs (V, v') else RETURN (V, False))\n          (V, False))\n                                   (a, b)\n                                  \\<le> SPEC (rpost arb' (a, b));\n     rpre S (V, v); x_ = (V, v); v \\<noteq> tgt;\n     f =\n     REC\\<^sub>T\n      (\\<lambda>dfs (V, v).\n          if v = tgt then RETURN (V, True)\n          else let V = insert v V\n               in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, brk). \\<not> brk)\n                   (\\<lambda>v' (V, brk).\n                       if v' \\<notin> V then dfs (V, v')\n                       else RETURN (V, False))\n                   (V, False))\\<rbrakk>\n    \\<Longrightarrow> fe_inv S V v (E `` {v}) (insert v V, False)\n 2. \\<And>xa it aa ba.\n       \\<lbrakk>\\<And>arb' a b.\n                   \\<lbrakk>rpre arb' (a, b);\n                    (a, V) \\<in> finite_psupset local.reachable\\<rbrakk>\n                   \\<Longrightarrow> REC\\<^sub>T\n(\\<lambda>dfs (V, v).\n    if v = tgt then RETURN (V, True)\n    else let V = insert v V\n         in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n             (\\<lambda>v' (V, brk).\n                 if v' \\<notin> V then dfs (V, v') else RETURN (V, False))\n             (V, False))\n(a, b)\n                                     \\<le> SPEC (rpost arb' (a, b));\n        rpre S (V, v); x_ = (V, v); v \\<noteq> tgt; xa \\<in> it;\n        it \\<subseteq> E `` {v}; fe_inv S V v it (aa, False); \\<not> ba;\n        xa \\<notin> aa;\n        f =\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v = tgt then RETURN (V, True)\n             else let V = insert v V\n                  in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n                      (\\<lambda>v' (V, brk).\n                          if v' \\<notin> V then dfs (V, v')\n                          else RETURN (V, False))\n                      (V, False))\\<rbrakk>\n       \\<Longrightarrow> REC\\<^sub>T\n                          (\\<lambda>dfs (V, v).\n                              if v = tgt then RETURN (V, True)\n                              else let V = insert v V\n                                   in FOREACH\\<^sub>C (E `` {v})\n (\\<lambda>(V, y). \\<not> y)\n (\\<lambda>v' (V, brk).\n     if v' \\<notin> V then dfs (V, v') else RETURN (V, False))\n (V, False))\n                          (aa, xa)\n                         \\<le> SPEC (fe_inv S V v (it - {xa}))\n 3. \\<And>xa it aa ba.\n       \\<lbrakk>\\<And>arb' a b.\n                   \\<lbrakk>rpre arb' (a, b);\n                    (a, V) \\<in> finite_psupset local.reachable\\<rbrakk>\n                   \\<Longrightarrow> REC\\<^sub>T\n(\\<lambda>dfs (V, v).\n    if v = tgt then RETURN (V, True)\n    else let V = insert v V\n         in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n             (\\<lambda>v' (V, brk).\n                 if v' \\<notin> V then dfs (V, v') else RETURN (V, False))\n             (V, False))\n(a, b)\n                                     \\<le> SPEC (rpost arb' (a, b));\n        rpre S (V, v); x_ = (V, v); v \\<noteq> tgt; xa \\<in> it;\n        it \\<subseteq> E `` {v}; fe_inv S V v it (aa, False); \\<not> ba;\n        xa \\<in> aa;\n        f =\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v = tgt then RETURN (V, True)\n             else let V = insert v V\n                  in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n                      (\\<lambda>v' (V, brk).\n                          if v' \\<notin> V then dfs (V, v')\n                          else RETURN (V, False))\n                      (V, False))\\<rbrakk>\n       \\<Longrightarrow> fe_inv S V v (it - {xa}) (aa, False)\n 4. \\<And>a b.\n       \\<lbrakk>\\<And>arb' a b.\n                   \\<lbrakk>rpre arb' (a, b);\n                    (a, V) \\<in> finite_psupset local.reachable\\<rbrakk>\n                   \\<Longrightarrow> REC\\<^sub>T\n(\\<lambda>dfs (V, v).\n    if v = tgt then RETURN (V, True)\n    else let V = insert v V\n         in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n             (\\<lambda>v' (V, brk).\n                 if v' \\<notin> V then dfs (V, v') else RETURN (V, False))\n             (V, False))\n(a, b)\n                                     \\<le> SPEC (rpost arb' (a, b));\n        rpre S (V, v); x_ = (V, v); v \\<noteq> tgt;\n        fe_inv S V v {} (a, False); \\<not> b;\n        f =\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v = tgt then RETURN (V, True)\n             else let V = insert v V\n                  in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n                      (\\<lambda>v' (V, brk).\n                          if v' \\<notin> V then dfs (V, v')\n                          else RETURN (V, False))\n                      (V, False))\\<rbrakk>\n       \\<Longrightarrow> rpost S (V, v) (a, False)\n 5. \\<And>it a b.\n       \\<lbrakk>\\<And>arb' a b.\n                   \\<lbrakk>rpre arb' (a, b);\n                    (a, V) \\<in> finite_psupset local.reachable\\<rbrakk>\n                   \\<Longrightarrow> REC\\<^sub>T\n(\\<lambda>dfs (V, v).\n    if v = tgt then RETURN (V, True)\n    else let V = insert v V\n         in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n             (\\<lambda>v' (V, brk).\n                 if v' \\<notin> V then dfs (V, v') else RETURN (V, False))\n             (V, False))\n(a, b)\n                                     \\<le> SPEC (rpost arb' (a, b));\n        rpre S (V, v); x_ = (V, v); v \\<noteq> tgt; it \\<subseteq> E `` {v};\n        fe_inv S V v it (a, True);\n        f =\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v = tgt then RETURN (V, True)\n             else let V = insert v V\n                  in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n                      (\\<lambda>v' (V, brk).\n                          if v' \\<notin> V then dfs (V, v')\n                          else RETURN (V, False))\n                      (V, False));\n        \\<not> rpost S (V, v) (a, True); b\\<rbrakk>\n       \\<Longrightarrow> False", "(* Finiteness of iteration set *)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<And>arb' a b.\n                \\<lbrakk>rpre arb' (a, b);\n                 (a, V) \\<in> finite_psupset local.reachable\\<rbrakk>\n                \\<Longrightarrow> REC\\<^sub>T\n                                   (\\<lambda>dfs (V, v).\n if v = tgt then RETURN (V, True)\n else let V = insert v V\n      in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, brk). \\<not> brk)\n          (\\<lambda>v' (V, brk).\n              if v' \\<notin> V then dfs (V, v') else RETURN (V, False))\n          (V, False))\n                                   (a, b)\n                                  \\<le> SPEC (rpost arb' (a, b));\n     rpre S (V, v); x_ = (V, v); v \\<noteq> tgt;\n     f =\n     REC\\<^sub>T\n      (\\<lambda>dfs (V, v).\n          if v = tgt then RETURN (V, True)\n          else let V = insert v V\n               in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, brk). \\<not> brk)\n                   (\\<lambda>v' (V, brk).\n                       if v' \\<notin> V then dfs (V, v')\n                       else RETURN (V, False))\n                   (V, False))\\<rbrakk>\n    \\<Longrightarrow> fe_inv S V v (E `` {v}) (insert v V, False)\n 2. \\<And>xa it aa ba.\n       \\<lbrakk>\\<And>arb' a b.\n                   \\<lbrakk>rpre arb' (a, b);\n                    (a, V) \\<in> finite_psupset local.reachable\\<rbrakk>\n                   \\<Longrightarrow> REC\\<^sub>T\n(\\<lambda>dfs (V, v).\n    if v = tgt then RETURN (V, True)\n    else let V = insert v V\n         in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n             (\\<lambda>v' (V, brk).\n                 if v' \\<notin> V then dfs (V, v') else RETURN (V, False))\n             (V, False))\n(a, b)\n                                     \\<le> SPEC (rpost arb' (a, b));\n        rpre S (V, v); x_ = (V, v); v \\<noteq> tgt; xa \\<in> it;\n        it \\<subseteq> E `` {v}; fe_inv S V v it (aa, False); \\<not> ba;\n        xa \\<notin> aa;\n        f =\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v = tgt then RETURN (V, True)\n             else let V = insert v V\n                  in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n                      (\\<lambda>v' (V, brk).\n                          if v' \\<notin> V then dfs (V, v')\n                          else RETURN (V, False))\n                      (V, False))\\<rbrakk>\n       \\<Longrightarrow> REC\\<^sub>T\n                          (\\<lambda>dfs (V, v).\n                              if v = tgt then RETURN (V, True)\n                              else let V = insert v V\n                                   in FOREACH\\<^sub>C (E `` {v})\n (\\<lambda>(V, y). \\<not> y)\n (\\<lambda>v' (V, brk).\n     if v' \\<notin> V then dfs (V, v') else RETURN (V, False))\n (V, False))\n                          (aa, xa)\n                         \\<le> SPEC (fe_inv S V v (it - {xa}))\n 3. \\<And>xa it aa ba.\n       \\<lbrakk>\\<And>arb' a b.\n                   \\<lbrakk>rpre arb' (a, b);\n                    (a, V) \\<in> finite_psupset local.reachable\\<rbrakk>\n                   \\<Longrightarrow> REC\\<^sub>T\n(\\<lambda>dfs (V, v).\n    if v = tgt then RETURN (V, True)\n    else let V = insert v V\n         in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n             (\\<lambda>v' (V, brk).\n                 if v' \\<notin> V then dfs (V, v') else RETURN (V, False))\n             (V, False))\n(a, b)\n                                     \\<le> SPEC (rpost arb' (a, b));\n        rpre S (V, v); x_ = (V, v); v \\<noteq> tgt; xa \\<in> it;\n        it \\<subseteq> E `` {v}; fe_inv S V v it (aa, False); \\<not> ba;\n        xa \\<in> aa;\n        f =\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v = tgt then RETURN (V, True)\n             else let V = insert v V\n                  in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n                      (\\<lambda>v' (V, brk).\n                          if v' \\<notin> V then dfs (V, v')\n                          else RETURN (V, False))\n                      (V, False))\\<rbrakk>\n       \\<Longrightarrow> fe_inv S V v (it - {xa}) (aa, False)\n 4. \\<And>a b.\n       \\<lbrakk>\\<And>arb' a b.\n                   \\<lbrakk>rpre arb' (a, b);\n                    (a, V) \\<in> finite_psupset local.reachable\\<rbrakk>\n                   \\<Longrightarrow> REC\\<^sub>T\n(\\<lambda>dfs (V, v).\n    if v = tgt then RETURN (V, True)\n    else let V = insert v V\n         in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n             (\\<lambda>v' (V, brk).\n                 if v' \\<notin> V then dfs (V, v') else RETURN (V, False))\n             (V, False))\n(a, b)\n                                     \\<le> SPEC (rpost arb' (a, b));\n        rpre S (V, v); x_ = (V, v); v \\<noteq> tgt;\n        fe_inv S V v {} (a, False); \\<not> b;\n        f =\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v = tgt then RETURN (V, True)\n             else let V = insert v V\n                  in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n                      (\\<lambda>v' (V, brk).\n                          if v' \\<notin> V then dfs (V, v')\n                          else RETURN (V, False))\n                      (V, False))\\<rbrakk>\n       \\<Longrightarrow> rpost S (V, v) (a, False)\n 5. \\<And>it a b.\n       \\<lbrakk>\\<And>arb' a b.\n                   \\<lbrakk>rpre arb' (a, b);\n                    (a, V) \\<in> finite_psupset local.reachable\\<rbrakk>\n                   \\<Longrightarrow> REC\\<^sub>T\n(\\<lambda>dfs (V, v).\n    if v = tgt then RETURN (V, True)\n    else let V = insert v V\n         in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n             (\\<lambda>v' (V, brk).\n                 if v' \\<notin> V then dfs (V, v') else RETURN (V, False))\n             (V, False))\n(a, b)\n                                     \\<le> SPEC (rpost arb' (a, b));\n        rpre S (V, v); x_ = (V, v); v \\<noteq> tgt; it \\<subseteq> E `` {v};\n        fe_inv S V v it (a, True);\n        f =\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v = tgt then RETURN (V, True)\n             else let V = insert v V\n                  in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n                      (\\<lambda>v' (V, brk).\n                          if v' \\<notin> V then dfs (V, v')\n                          else RETURN (V, False))\n                      (V, False));\n        \\<not> rpost S (V, v) (a, True); b\\<rbrakk>\n       \\<Longrightarrow> False", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>arb' a b.\n                \\<lbrakk>rpre arb' (a, b);\n                 (a, V) \\<in> finite_psupset local.reachable\\<rbrakk>\n                \\<Longrightarrow> REC\\<^sub>T\n                                   (\\<lambda>dfs (V, v).\n if v = tgt then RETURN (V, True)\n else let V = insert v V\n      in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, brk). \\<not> brk)\n          (\\<lambda>v' (V, brk).\n              if v' \\<notin> V then dfs (V, v') else RETURN (V, False))\n          (V, False))\n                                   (a, b)\n                                  \\<le> SPEC (rpost arb' (a, b));\n     rpre S (V, v); x_ = (V, v); v \\<noteq> tgt;\n     f =\n     REC\\<^sub>T\n      (\\<lambda>dfs (V, v).\n          if v = tgt then RETURN (V, True)\n          else let V = insert v V\n               in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, brk). \\<not> brk)\n                   (\\<lambda>v' (V, brk).\n                       if v' \\<notin> V then dfs (V, v')\n                       else RETURN (V, False))\n                   (V, False))\\<rbrakk>\n    \\<Longrightarrow> fe_inv S V v (E `` {v}) (insert v V, False)", "by (rule vc_enter_foreach) (simp add: rpre_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>xa it aa ba.\n       \\<lbrakk>\\<And>arb' a b.\n                   \\<lbrakk>rpre arb' (a, b);\n                    (a, V) \\<in> finite_psupset local.reachable\\<rbrakk>\n                   \\<Longrightarrow> REC\\<^sub>T\n(\\<lambda>dfs (V, v).\n    if v = tgt then RETURN (V, True)\n    else let V = insert v V\n         in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n             (\\<lambda>v' (V, brk).\n                 if v' \\<notin> V then dfs (V, v') else RETURN (V, False))\n             (V, False))\n(a, b)\n                                     \\<le> SPEC (rpost arb' (a, b));\n        rpre S (V, v); x_ = (V, v); v \\<noteq> tgt; xa \\<in> it;\n        it \\<subseteq> E `` {v}; fe_inv S V v it (aa, False); \\<not> ba;\n        xa \\<notin> aa;\n        f =\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v = tgt then RETURN (V, True)\n             else let V = insert v V\n                  in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n                      (\\<lambda>v' (V, brk).\n                          if v' \\<notin> V then dfs (V, v')\n                          else RETURN (V, False))\n                      (V, False))\\<rbrakk>\n       \\<Longrightarrow> REC\\<^sub>T\n                          (\\<lambda>dfs (V, v).\n                              if v = tgt then RETURN (V, True)\n                              else let V = insert v V\n                                   in FOREACH\\<^sub>C (E `` {v})\n (\\<lambda>(V, y). \\<not> y)\n (\\<lambda>v' (V, brk).\n     if v' \\<notin> V then dfs (V, v') else RETURN (V, False))\n (V, False))\n                          (aa, xa)\n                         \\<le> SPEC (fe_inv S V v (it - {xa}))\n 2. \\<And>xa it aa ba.\n       \\<lbrakk>\\<And>arb' a b.\n                   \\<lbrakk>rpre arb' (a, b);\n                    (a, V) \\<in> finite_psupset local.reachable\\<rbrakk>\n                   \\<Longrightarrow> REC\\<^sub>T\n(\\<lambda>dfs (V, v).\n    if v = tgt then RETURN (V, True)\n    else let V = insert v V\n         in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n             (\\<lambda>v' (V, brk).\n                 if v' \\<notin> V then dfs (V, v') else RETURN (V, False))\n             (V, False))\n(a, b)\n                                     \\<le> SPEC (rpost arb' (a, b));\n        rpre S (V, v); x_ = (V, v); v \\<noteq> tgt; xa \\<in> it;\n        it \\<subseteq> E `` {v}; fe_inv S V v it (aa, False); \\<not> ba;\n        xa \\<in> aa;\n        f =\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v = tgt then RETURN (V, True)\n             else let V = insert v V\n                  in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n                      (\\<lambda>v' (V, brk).\n                          if v' \\<notin> V then dfs (V, v')\n                          else RETURN (V, False))\n                      (V, False))\\<rbrakk>\n       \\<Longrightarrow> fe_inv S V v (it - {xa}) (aa, False)\n 3. \\<And>a b.\n       \\<lbrakk>\\<And>arb' a b.\n                   \\<lbrakk>rpre arb' (a, b);\n                    (a, V) \\<in> finite_psupset local.reachable\\<rbrakk>\n                   \\<Longrightarrow> REC\\<^sub>T\n(\\<lambda>dfs (V, v).\n    if v = tgt then RETURN (V, True)\n    else let V = insert v V\n         in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n             (\\<lambda>v' (V, brk).\n                 if v' \\<notin> V then dfs (V, v') else RETURN (V, False))\n             (V, False))\n(a, b)\n                                     \\<le> SPEC (rpost arb' (a, b));\n        rpre S (V, v); x_ = (V, v); v \\<noteq> tgt;\n        fe_inv S V v {} (a, False); \\<not> b;\n        f =\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v = tgt then RETURN (V, True)\n             else let V = insert v V\n                  in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n                      (\\<lambda>v' (V, brk).\n                          if v' \\<notin> V then dfs (V, v')\n                          else RETURN (V, False))\n                      (V, False))\\<rbrakk>\n       \\<Longrightarrow> rpost S (V, v) (a, False)\n 4. \\<And>it a b.\n       \\<lbrakk>\\<And>arb' a b.\n                   \\<lbrakk>rpre arb' (a, b);\n                    (a, V) \\<in> finite_psupset local.reachable\\<rbrakk>\n                   \\<Longrightarrow> REC\\<^sub>T\n(\\<lambda>dfs (V, v).\n    if v = tgt then RETURN (V, True)\n    else let V = insert v V\n         in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n             (\\<lambda>v' (V, brk).\n                 if v' \\<notin> V then dfs (V, v') else RETURN (V, False))\n             (V, False))\n(a, b)\n                                     \\<le> SPEC (rpost arb' (a, b));\n        rpre S (V, v); x_ = (V, v); v \\<noteq> tgt; it \\<subseteq> E `` {v};\n        fe_inv S V v it (a, True);\n        f =\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v = tgt then RETURN (V, True)\n             else let V = insert v V\n                  in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n                      (\\<lambda>v' (V, brk).\n                          if v' \\<notin> V then dfs (V, v')\n                          else RETURN (V, False))\n                      (V, False));\n        \\<not> rpost S (V, v) (a, True); b\\<rbrakk>\n       \\<Longrightarrow> False", "(* Loop invar holds initially*)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>xa it aa ba.\n       \\<lbrakk>\\<And>arb' a b.\n                   \\<lbrakk>rpre arb' (a, b);\n                    (a, V) \\<in> finite_psupset local.reachable\\<rbrakk>\n                   \\<Longrightarrow> REC\\<^sub>T\n(\\<lambda>dfs (V, v).\n    if v = tgt then RETURN (V, True)\n    else let V = insert v V\n         in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n             (\\<lambda>v' (V, brk).\n                 if v' \\<notin> V then dfs (V, v') else RETURN (V, False))\n             (V, False))\n(a, b)\n                                     \\<le> SPEC (rpost arb' (a, b));\n        rpre S (V, v); x_ = (V, v); v \\<noteq> tgt; xa \\<in> it;\n        it \\<subseteq> E `` {v}; fe_inv S V v it (aa, False); \\<not> ba;\n        xa \\<notin> aa;\n        f =\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v = tgt then RETURN (V, True)\n             else let V = insert v V\n                  in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n                      (\\<lambda>v' (V, brk).\n                          if v' \\<notin> V then dfs (V, v')\n                          else RETURN (V, False))\n                      (V, False))\\<rbrakk>\n       \\<Longrightarrow> REC\\<^sub>T\n                          (\\<lambda>dfs (V, v).\n                              if v = tgt then RETURN (V, True)\n                              else let V = insert v V\n                                   in FOREACH\\<^sub>C (E `` {v})\n (\\<lambda>(V, y). \\<not> y)\n (\\<lambda>v' (V, brk).\n     if v' \\<notin> V then dfs (V, v') else RETURN (V, False))\n (V, False))\n                          (aa, xa)\n                         \\<le> SPEC (fe_inv S V v (it - {xa}))\n 2. \\<And>xa it aa ba.\n       \\<lbrakk>\\<And>arb' a b.\n                   \\<lbrakk>rpre arb' (a, b);\n                    (a, V) \\<in> finite_psupset local.reachable\\<rbrakk>\n                   \\<Longrightarrow> REC\\<^sub>T\n(\\<lambda>dfs (V, v).\n    if v = tgt then RETURN (V, True)\n    else let V = insert v V\n         in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n             (\\<lambda>v' (V, brk).\n                 if v' \\<notin> V then dfs (V, v') else RETURN (V, False))\n             (V, False))\n(a, b)\n                                     \\<le> SPEC (rpost arb' (a, b));\n        rpre S (V, v); x_ = (V, v); v \\<noteq> tgt; xa \\<in> it;\n        it \\<subseteq> E `` {v}; fe_inv S V v it (aa, False); \\<not> ba;\n        xa \\<in> aa;\n        f =\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v = tgt then RETURN (V, True)\n             else let V = insert v V\n                  in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n                      (\\<lambda>v' (V, brk).\n                          if v' \\<notin> V then dfs (V, v')\n                          else RETURN (V, False))\n                      (V, False))\\<rbrakk>\n       \\<Longrightarrow> fe_inv S V v (it - {xa}) (aa, False)\n 3. \\<And>a b.\n       \\<lbrakk>\\<And>arb' a b.\n                   \\<lbrakk>rpre arb' (a, b);\n                    (a, V) \\<in> finite_psupset local.reachable\\<rbrakk>\n                   \\<Longrightarrow> REC\\<^sub>T\n(\\<lambda>dfs (V, v).\n    if v = tgt then RETURN (V, True)\n    else let V = insert v V\n         in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n             (\\<lambda>v' (V, brk).\n                 if v' \\<notin> V then dfs (V, v') else RETURN (V, False))\n             (V, False))\n(a, b)\n                                     \\<le> SPEC (rpost arb' (a, b));\n        rpre S (V, v); x_ = (V, v); v \\<noteq> tgt;\n        fe_inv S V v {} (a, False); \\<not> b;\n        f =\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v = tgt then RETURN (V, True)\n             else let V = insert v V\n                  in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n                      (\\<lambda>v' (V, brk).\n                          if v' \\<notin> V then dfs (V, v')\n                          else RETURN (V, False))\n                      (V, False))\\<rbrakk>\n       \\<Longrightarrow> rpost S (V, v) (a, False)\n 4. \\<And>it a b.\n       \\<lbrakk>\\<And>arb' a b.\n                   \\<lbrakk>rpre arb' (a, b);\n                    (a, V) \\<in> finite_psupset local.reachable\\<rbrakk>\n                   \\<Longrightarrow> REC\\<^sub>T\n(\\<lambda>dfs (V, v).\n    if v = tgt then RETURN (V, True)\n    else let V = insert v V\n         in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n             (\\<lambda>v' (V, brk).\n                 if v' \\<notin> V then dfs (V, v') else RETURN (V, False))\n             (V, False))\n(a, b)\n                                     \\<le> SPEC (rpost arb' (a, b));\n        rpre S (V, v); x_ = (V, v); v \\<noteq> tgt; it \\<subseteq> E `` {v};\n        fe_inv S V v it (a, True);\n        f =\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v = tgt then RETURN (V, True)\n             else let V = insert v V\n                  in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n                      (\\<lambda>v' (V, brk).\n                          if v' \\<notin> V then dfs (V, v')\n                          else RETURN (V, False))\n                      (V, False));\n        \\<not> rpost S (V, v) (a, True); b\\<rbrakk>\n       \\<Longrightarrow> False", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>arb' a b.\n                \\<lbrakk>rpre arb' (a, b);\n                 (a, V) \\<in> finite_psupset local.reachable\\<rbrakk>\n                \\<Longrightarrow> REC\\<^sub>T\n                                   (\\<lambda>dfs (V, v).\n if v = tgt then RETURN (V, True)\n else let V = insert v V\n      in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n          (\\<lambda>v' (V, brk).\n              if v' \\<notin> V then dfs (V, v') else RETURN (V, False))\n          (V, False))\n                                   (a, b)\n                                  \\<le> SPEC (rpost arb' (a, b));\n     rpre S (V, v); x_ = (V, v); v \\<noteq> tgt; xa_ \\<in> it_;\n     it_ \\<subseteq> E `` {v}; fe_inv S V v it_ (aa_, False); \\<not> ba_;\n     xa_ \\<notin> aa_;\n     f =\n     REC\\<^sub>T\n      (\\<lambda>dfs (V, v).\n          if v = tgt then RETURN (V, True)\n          else let V = insert v V\n               in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n                   (\\<lambda>v' (V, brk).\n                       if v' \\<notin> V then dfs (V, v')\n                       else RETURN (V, False))\n                   (V, False))\\<rbrakk>\n    \\<Longrightarrow> REC\\<^sub>T\n                       (\\<lambda>dfs (V, v).\n                           if v = tgt then RETURN (V, True)\n                           else let V = insert v V\n                                in FOREACH\\<^sub>C (E `` {v})\n                                    (\\<lambda>(V, y). \\<not> y)\n                                    (\\<lambda>v' (V, brk).\n  if v' \\<notin> V then dfs (V, v') else RETURN (V, False))\n                                    (V, False))\n                       (aa_, xa_)\n                      \\<le> SPEC (fe_inv S V v (it_ - {xa_}))", "(* Loop invar preserved by inner recursion *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>arb' a b.\n                \\<lbrakk>rpre arb' (a, b);\n                 (a, V) \\<in> finite_psupset local.reachable\\<rbrakk>\n                \\<Longrightarrow> REC\\<^sub>T\n                                   (\\<lambda>dfs (V, v).\n if v = tgt then RETURN (V, True)\n else let V = insert v V\n      in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n          (\\<lambda>v' (V, brk).\n              if v' \\<notin> V then dfs (V, v') else RETURN (V, False))\n          (V, False))\n                                   (a, b)\n                                  \\<le> SPEC (rpost arb' (a, b));\n     rpre S (V, v); x_ = (V, v); v \\<noteq> tgt; xa_ \\<in> it_;\n     it_ \\<subseteq> E `` {v}; fe_inv S V v it_ (aa_, False); \\<not> ba_;\n     xa_ \\<notin> aa_;\n     f =\n     REC\\<^sub>T\n      (\\<lambda>dfs (V, v).\n          if v = tgt then RETURN (V, True)\n          else let V = insert v V\n               in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n                   (\\<lambda>v' (V, brk).\n                       if v' \\<notin> V then dfs (V, v')\n                       else RETURN (V, False))\n                   (V, False))\\<rbrakk>\n    \\<Longrightarrow> REC\\<^sub>T\n                       (\\<lambda>dfs (V, v).\n                           if v = tgt then RETURN (V, True)\n                           else let V = insert v V\n                                in FOREACH\\<^sub>C (E `` {v})\n                                    (\\<lambda>(V, y). \\<not> y)\n                                    (\\<lambda>v' (V, brk).\n  if v' \\<notin> V then dfs (V, v') else RETURN (V, False))\n                                    (V, False))\n                       (aa_, xa_)\n                      \\<le> SPEC (fe_inv S V v (it_ - {xa_}))", "apply (rule order_trans, rprems)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>rpre S (V, v); x_ = (V, v); v \\<noteq> tgt; xa_ \\<in> it_;\n     it_ \\<subseteq> E `` {v}; fe_inv S V v it_ (aa_, False); \\<not> ba_;\n     xa_ \\<notin> aa_;\n     f =\n     REC\\<^sub>T\n      (\\<lambda>dfs (V, v).\n          if v = tgt then RETURN (V, True)\n          else let V = insert v V\n               in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n                   (\\<lambda>v' (V, brk).\n                       if v' \\<notin> V then dfs (V, v')\n                       else RETURN (V, False))\n                   (V, False))\\<rbrakk>\n    \\<Longrightarrow> rpre ?arb'4 (aa_, xa_)\n 2. \\<lbrakk>rpre S (V, v); x_ = (V, v); v \\<noteq> tgt; xa_ \\<in> it_;\n     it_ \\<subseteq> E `` {v}; fe_inv S V v it_ (aa_, False); \\<not> ba_;\n     xa_ \\<notin> aa_;\n     f =\n     REC\\<^sub>T\n      (\\<lambda>dfs (V, v).\n          if v = tgt then RETURN (V, True)\n          else let V = insert v V\n               in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n                   (\\<lambda>v' (V, brk).\n                       if v' \\<notin> V then dfs (V, v')\n                       else RETURN (V, False))\n                   (V, False))\\<rbrakk>\n    \\<Longrightarrow> (aa_, V) \\<in> finite_psupset local.reachable\n 3. \\<lbrakk>\\<And>arb' a b.\n                \\<lbrakk>rpre arb' (a, b);\n                 (a, V) \\<in> finite_psupset local.reachable\\<rbrakk>\n                \\<Longrightarrow> REC\\<^sub>T\n                                   (\\<lambda>dfs (V, v).\n if v = tgt then RETURN (V, True)\n else let V = insert v V\n      in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n          (\\<lambda>v' (V, brk).\n              if v' \\<notin> V then dfs (V, v') else RETURN (V, False))\n          (V, False))\n                                   (a, b)\n                                  \\<le> SPEC (rpost arb' (a, b));\n     rpre S (V, v); x_ = (V, v); v \\<noteq> tgt; xa_ \\<in> it_;\n     it_ \\<subseteq> E `` {v}; fe_inv S V v it_ (aa_, False); \\<not> ba_;\n     xa_ \\<notin> aa_;\n     f =\n     REC\\<^sub>T\n      (\\<lambda>dfs (V, v).\n          if v = tgt then RETURN (V, True)\n          else let V = insert v V\n               in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n                   (\\<lambda>v' (V, brk).\n                       if v' \\<notin> V then dfs (V, v')\n                       else RETURN (V, False))\n                   (V, False))\\<rbrakk>\n    \\<Longrightarrow> SPEC (rpost ?arb'4 (aa_, xa_))\n                      \\<le> SPEC (fe_inv S V v (it_ - {xa_}))", "(* Applying recursion induction hypothesis *)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>rpre S (V, v); x_ = (V, v); v \\<noteq> tgt; xa_ \\<in> it_;\n     it_ \\<subseteq> E `` {v}; fe_inv S V v it_ (aa_, False); \\<not> ba_;\n     xa_ \\<notin> aa_;\n     f =\n     REC\\<^sub>T\n      (\\<lambda>dfs (V, v).\n          if v = tgt then RETURN (V, True)\n          else let V = insert v V\n               in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n                   (\\<lambda>v' (V, brk).\n                       if v' \\<notin> V then dfs (V, v')\n                       else RETURN (V, False))\n                   (V, False))\\<rbrakk>\n    \\<Longrightarrow> rpre ?arb'4 (aa_, xa_)\n 2. \\<lbrakk>rpre S (V, v); x_ = (V, v); v \\<noteq> tgt; xa_ \\<in> it_;\n     it_ \\<subseteq> E `` {v}; fe_inv S V v it_ (aa_, False); \\<not> ba_;\n     xa_ \\<notin> aa_;\n     f =\n     REC\\<^sub>T\n      (\\<lambda>dfs (V, v).\n          if v = tgt then RETURN (V, True)\n          else let V = insert v V\n               in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n                   (\\<lambda>v' (V, brk).\n                       if v' \\<notin> V then dfs (V, v')\n                       else RETURN (V, False))\n                   (V, False))\\<rbrakk>\n    \\<Longrightarrow> (aa_, V) \\<in> finite_psupset local.reachable\n 3. \\<lbrakk>\\<And>arb' a b.\n                \\<lbrakk>rpre arb' (a, b);\n                 (a, V) \\<in> finite_psupset local.reachable\\<rbrakk>\n                \\<Longrightarrow> REC\\<^sub>T\n                                   (\\<lambda>dfs (V, v).\n if v = tgt then RETURN (V, True)\n else let V = insert v V\n      in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n          (\\<lambda>v' (V, brk).\n              if v' \\<notin> V then dfs (V, v') else RETURN (V, False))\n          (V, False))\n                                   (a, b)\n                                  \\<le> SPEC (rpost arb' (a, b));\n     rpre S (V, v); x_ = (V, v); v \\<noteq> tgt; xa_ \\<in> it_;\n     it_ \\<subseteq> E `` {v}; fe_inv S V v it_ (aa_, False); \\<not> ba_;\n     xa_ \\<notin> aa_;\n     f =\n     REC\\<^sub>T\n      (\\<lambda>dfs (V, v).\n          if v = tgt then RETURN (V, True)\n          else let V = insert v V\n               in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n                   (\\<lambda>v' (V, brk).\n                       if v' \\<notin> V then dfs (V, v')\n                       else RETURN (V, False))\n                   (V, False))\\<rbrakk>\n    \\<Longrightarrow> SPEC (rpost ?arb'4 (aa_, xa_))\n                      \\<le> SPEC (fe_inv S V v (it_ - {xa_}))", "apply (erule (4) vc_rec_pre; fail)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>rpre S (V, v); x_ = (V, v); v \\<noteq> tgt; xa_ \\<in> it_;\n     it_ \\<subseteq> E `` {v}; fe_inv S V v it_ (aa_, False); \\<not> ba_;\n     xa_ \\<notin> aa_;\n     f =\n     REC\\<^sub>T\n      (\\<lambda>dfs (V, v).\n          if v = tgt then RETURN (V, True)\n          else let V = insert v V\n               in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n                   (\\<lambda>v' (V, brk).\n                       if v' \\<notin> V then dfs (V, v')\n                       else RETURN (V, False))\n                   (V, False))\\<rbrakk>\n    \\<Longrightarrow> (aa_, V) \\<in> finite_psupset local.reachable\n 2. \\<lbrakk>\\<And>arb' a b.\n                \\<lbrakk>rpre arb' (a, b);\n                 (a, V) \\<in> finite_psupset local.reachable\\<rbrakk>\n                \\<Longrightarrow> REC\\<^sub>T\n                                   (\\<lambda>dfs (V, v).\n if v = tgt then RETURN (V, True)\n else let V = insert v V\n      in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n          (\\<lambda>v' (V, brk).\n              if v' \\<notin> V then dfs (V, v') else RETURN (V, False))\n          (V, False))\n                                   (a, b)\n                                  \\<le> SPEC (rpost arb' (a, b));\n     rpre S (V, v); x_ = (V, v); v \\<noteq> tgt; xa_ \\<in> it_;\n     it_ \\<subseteq> E `` {v}; fe_inv S V v it_ (aa_, False); \\<not> ba_;\n     xa_ \\<notin> aa_;\n     f =\n     REC\\<^sub>T\n      (\\<lambda>dfs (V, v).\n          if v = tgt then RETURN (V, True)\n          else let V = insert v V\n               in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n                   (\\<lambda>v' (V, brk).\n                       if v' \\<notin> V then dfs (V, v')\n                       else RETURN (V, False))\n                   (V, False))\\<rbrakk>\n    \\<Longrightarrow> SPEC (rpost (insert v S) (aa_, xa_))\n                      \\<le> SPEC (fe_inv S V v (it_ - {xa_}))", "(* Precondition of inner recursion holds*)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>rpre S (V, v); x_ = (V, v); v \\<noteq> tgt; xa_ \\<in> it_;\n     it_ \\<subseteq> E `` {v}; fe_inv S V v it_ (aa_, False); \\<not> ba_;\n     xa_ \\<notin> aa_;\n     f =\n     REC\\<^sub>T\n      (\\<lambda>dfs (V, v).\n          if v = tgt then RETURN (V, True)\n          else let V = insert v V\n               in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n                   (\\<lambda>v' (V, brk).\n                       if v' \\<notin> V then dfs (V, v')\n                       else RETURN (V, False))\n                   (V, False))\\<rbrakk>\n    \\<Longrightarrow> (aa_, V) \\<in> finite_psupset local.reachable\n 2. \\<lbrakk>\\<And>arb' a b.\n                \\<lbrakk>rpre arb' (a, b);\n                 (a, V) \\<in> finite_psupset local.reachable\\<rbrakk>\n                \\<Longrightarrow> REC\\<^sub>T\n                                   (\\<lambda>dfs (V, v).\n if v = tgt then RETURN (V, True)\n else let V = insert v V\n      in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n          (\\<lambda>v' (V, brk).\n              if v' \\<notin> V then dfs (V, v') else RETURN (V, False))\n          (V, False))\n                                   (a, b)\n                                  \\<le> SPEC (rpost arb' (a, b));\n     rpre S (V, v); x_ = (V, v); v \\<noteq> tgt; xa_ \\<in> it_;\n     it_ \\<subseteq> E `` {v}; fe_inv S V v it_ (aa_, False); \\<not> ba_;\n     xa_ \\<notin> aa_;\n     f =\n     REC\\<^sub>T\n      (\\<lambda>dfs (V, v).\n          if v = tgt then RETURN (V, True)\n          else let V = insert v V\n               in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n                   (\\<lambda>v' (V, brk).\n                       if v' \\<notin> V then dfs (V, v')\n                       else RETURN (V, False))\n                   (V, False))\\<rbrakk>\n    \\<Longrightarrow> SPEC (rpost (insert v S) (aa_, xa_))\n                      \\<le> SPEC (fe_inv S V v (it_ - {xa_}))", "apply (simp add: vc_rec_var; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>arb' a b.\n                \\<lbrakk>rpre arb' (a, b);\n                 (a, V) \\<in> finite_psupset local.reachable\\<rbrakk>\n                \\<Longrightarrow> REC\\<^sub>T\n                                   (\\<lambda>dfs (V, v).\n if v = tgt then RETURN (V, True)\n else let V = insert v V\n      in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n          (\\<lambda>v' (V, brk).\n              if v' \\<notin> V then dfs (V, v') else RETURN (V, False))\n          (V, False))\n                                   (a, b)\n                                  \\<le> SPEC (rpost arb' (a, b));\n     rpre S (V, v); x_ = (V, v); v \\<noteq> tgt; xa_ \\<in> it_;\n     it_ \\<subseteq> E `` {v}; fe_inv S V v it_ (aa_, False); \\<not> ba_;\n     xa_ \\<notin> aa_;\n     f =\n     REC\\<^sub>T\n      (\\<lambda>dfs (V, v).\n          if v = tgt then RETURN (V, True)\n          else let V = insert v V\n               in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n                   (\\<lambda>v' (V, brk).\n                       if v' \\<notin> V then dfs (V, v')\n                       else RETURN (V, False))\n                   (V, False))\\<rbrakk>\n    \\<Longrightarrow> SPEC (rpost (insert v S) (aa_, xa_))\n                      \\<le> SPEC (fe_inv S V v (it_ - {xa_}))", "(* Parameters are smaller wrt termination ordering *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>arb' a b.\n                \\<lbrakk>rpre arb' (a, b);\n                 (a, V) \\<in> finite_psupset local.reachable\\<rbrakk>\n                \\<Longrightarrow> REC\\<^sub>T\n                                   (\\<lambda>dfs (V, v).\n if v = tgt then RETURN (V, True)\n else let V = insert v V\n      in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n          (\\<lambda>v' (V, brk).\n              if v' \\<notin> V then dfs (V, v') else RETURN (V, False))\n          (V, False))\n                                   (a, b)\n                                  \\<le> SPEC (rpost arb' (a, b));\n     rpre S (V, v); x_ = (V, v); v \\<noteq> tgt; xa_ \\<in> it_;\n     it_ \\<subseteq> E `` {v}; fe_inv S V v it_ (aa_, False); \\<not> ba_;\n     xa_ \\<notin> aa_;\n     f =\n     REC\\<^sub>T\n      (\\<lambda>dfs (V, v).\n          if v = tgt then RETURN (V, True)\n          else let V = insert v V\n               in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n                   (\\<lambda>v' (V, brk).\n                       if v' \\<notin> V then dfs (V, v')\n                       else RETURN (V, False))\n                   (V, False))\\<rbrakk>\n    \\<Longrightarrow> SPEC (rpost (insert v S) (aa_, xa_))\n                      \\<le> SPEC (fe_inv S V v (it_ - {xa_}))", "apply (auto simp: vc_iterate_foreach; fail)"], ["proof (prove)\ngoal:\nNo subgoals!", "(* Postcondition of inner rec implies loop invar again  *)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa it aa ba.\n       \\<lbrakk>\\<And>arb' a b.\n                   \\<lbrakk>rpre arb' (a, b);\n                    (a, V) \\<in> finite_psupset local.reachable\\<rbrakk>\n                   \\<Longrightarrow> REC\\<^sub>T\n(\\<lambda>dfs (V, v).\n    if v = tgt then RETURN (V, True)\n    else let V = insert v V\n         in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n             (\\<lambda>v' (V, brk).\n                 if v' \\<notin> V then dfs (V, v') else RETURN (V, False))\n             (V, False))\n(a, b)\n                                     \\<le> SPEC (rpost arb' (a, b));\n        rpre S (V, v); x_ = (V, v); v \\<noteq> tgt; xa \\<in> it;\n        it \\<subseteq> E `` {v}; fe_inv S V v it (aa, False); \\<not> ba;\n        xa \\<in> aa;\n        f =\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v = tgt then RETURN (V, True)\n             else let V = insert v V\n                  in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n                      (\\<lambda>v' (V, brk).\n                          if v' \\<notin> V then dfs (V, v')\n                          else RETURN (V, False))\n                      (V, False))\\<rbrakk>\n       \\<Longrightarrow> fe_inv S V v (it - {xa}) (aa, False)\n 2. \\<And>a b.\n       \\<lbrakk>\\<And>arb' a b.\n                   \\<lbrakk>rpre arb' (a, b);\n                    (a, V) \\<in> finite_psupset local.reachable\\<rbrakk>\n                   \\<Longrightarrow> REC\\<^sub>T\n(\\<lambda>dfs (V, v).\n    if v = tgt then RETURN (V, True)\n    else let V = insert v V\n         in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n             (\\<lambda>v' (V, brk).\n                 if v' \\<notin> V then dfs (V, v') else RETURN (V, False))\n             (V, False))\n(a, b)\n                                     \\<le> SPEC (rpost arb' (a, b));\n        rpre S (V, v); x_ = (V, v); v \\<noteq> tgt;\n        fe_inv S V v {} (a, False); \\<not> b;\n        f =\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v = tgt then RETURN (V, True)\n             else let V = insert v V\n                  in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n                      (\\<lambda>v' (V, brk).\n                          if v' \\<notin> V then dfs (V, v')\n                          else RETURN (V, False))\n                      (V, False))\\<rbrakk>\n       \\<Longrightarrow> rpost S (V, v) (a, False)\n 3. \\<And>it a b.\n       \\<lbrakk>\\<And>arb' a b.\n                   \\<lbrakk>rpre arb' (a, b);\n                    (a, V) \\<in> finite_psupset local.reachable\\<rbrakk>\n                   \\<Longrightarrow> REC\\<^sub>T\n(\\<lambda>dfs (V, v).\n    if v = tgt then RETURN (V, True)\n    else let V = insert v V\n         in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n             (\\<lambda>v' (V, brk).\n                 if v' \\<notin> V then dfs (V, v') else RETURN (V, False))\n             (V, False))\n(a, b)\n                                     \\<le> SPEC (rpost arb' (a, b));\n        rpre S (V, v); x_ = (V, v); v \\<noteq> tgt; it \\<subseteq> E `` {v};\n        fe_inv S V v it (a, True);\n        f =\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v = tgt then RETURN (V, True)\n             else let V = insert v V\n                  in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n                      (\\<lambda>v' (V, brk).\n                          if v' \\<notin> V then dfs (V, v')\n                          else RETURN (V, False))\n                      (V, False));\n        \\<not> rpost S (V, v) (a, True); b\\<rbrakk>\n       \\<Longrightarrow> False", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>arb' a b.\n                \\<lbrakk>rpre arb' (a, b);\n                 (a, V) \\<in> finite_psupset local.reachable\\<rbrakk>\n                \\<Longrightarrow> REC\\<^sub>T\n                                   (\\<lambda>dfs (V, v).\n if v = tgt then RETURN (V, True)\n else let V = insert v V\n      in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n          (\\<lambda>v' (V, brk).\n              if v' \\<notin> V then dfs (V, v') else RETURN (V, False))\n          (V, False))\n                                   (a, b)\n                                  \\<le> SPEC (rpost arb' (a, b));\n     rpre S (V, v); x_ = (V, v); v \\<noteq> tgt; xa_ \\<in> it_;\n     it_ \\<subseteq> E `` {v}; fe_inv S V v it_ (aa_, False); \\<not> ba_;\n     xa_ \\<in> aa_;\n     f =\n     REC\\<^sub>T\n      (\\<lambda>dfs (V, v).\n          if v = tgt then RETURN (V, True)\n          else let V = insert v V\n               in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n                   (\\<lambda>v' (V, brk).\n                       if v' \\<notin> V then dfs (V, v')\n                       else RETURN (V, False))\n                   (V, False))\\<rbrakk>\n    \\<Longrightarrow> fe_inv S V v (it_ - {xa_}) (aa_, False)", "by (rule vc_foreach_ignore; auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>arb' a b.\n                   \\<lbrakk>rpre arb' (a, b);\n                    (a, V) \\<in> finite_psupset local.reachable\\<rbrakk>\n                   \\<Longrightarrow> REC\\<^sub>T\n(\\<lambda>dfs (V, v).\n    if v = tgt then RETURN (V, True)\n    else let V = insert v V\n         in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n             (\\<lambda>v' (V, brk).\n                 if v' \\<notin> V then dfs (V, v') else RETURN (V, False))\n             (V, False))\n(a, b)\n                                     \\<le> SPEC (rpost arb' (a, b));\n        rpre S (V, v); x_ = (V, v); v \\<noteq> tgt;\n        fe_inv S V v {} (a, False); \\<not> b;\n        f =\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v = tgt then RETURN (V, True)\n             else let V = insert v V\n                  in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n                      (\\<lambda>v' (V, brk).\n                          if v' \\<notin> V then dfs (V, v')\n                          else RETURN (V, False))\n                      (V, False))\\<rbrakk>\n       \\<Longrightarrow> rpost S (V, v) (a, False)\n 2. \\<And>it a b.\n       \\<lbrakk>\\<And>arb' a b.\n                   \\<lbrakk>rpre arb' (a, b);\n                    (a, V) \\<in> finite_psupset local.reachable\\<rbrakk>\n                   \\<Longrightarrow> REC\\<^sub>T\n(\\<lambda>dfs (V, v).\n    if v = tgt then RETURN (V, True)\n    else let V = insert v V\n         in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n             (\\<lambda>v' (V, brk).\n                 if v' \\<notin> V then dfs (V, v') else RETURN (V, False))\n             (V, False))\n(a, b)\n                                     \\<le> SPEC (rpost arb' (a, b));\n        rpre S (V, v); x_ = (V, v); v \\<noteq> tgt; it \\<subseteq> E `` {v};\n        fe_inv S V v it (a, True);\n        f =\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v = tgt then RETURN (V, True)\n             else let V = insert v V\n                  in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n                      (\\<lambda>v' (V, brk).\n                          if v' \\<notin> V then dfs (V, v')\n                          else RETURN (V, False))\n                      (V, False));\n        \\<not> rpost S (V, v) (a, True); b\\<rbrakk>\n       \\<Longrightarrow> False", "(* Node already visited: invariant is preserved *)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>arb' a b.\n                   \\<lbrakk>rpre arb' (a, b);\n                    (a, V) \\<in> finite_psupset local.reachable\\<rbrakk>\n                   \\<Longrightarrow> REC\\<^sub>T\n(\\<lambda>dfs (V, v).\n    if v = tgt then RETURN (V, True)\n    else let V = insert v V\n         in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n             (\\<lambda>v' (V, brk).\n                 if v' \\<notin> V then dfs (V, v') else RETURN (V, False))\n             (V, False))\n(a, b)\n                                     \\<le> SPEC (rpost arb' (a, b));\n        rpre S (V, v); x_ = (V, v); v \\<noteq> tgt;\n        fe_inv S V v {} (a, False); \\<not> b;\n        f =\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v = tgt then RETURN (V, True)\n             else let V = insert v V\n                  in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n                      (\\<lambda>v' (V, brk).\n                          if v' \\<notin> V then dfs (V, v')\n                          else RETURN (V, False))\n                      (V, False))\\<rbrakk>\n       \\<Longrightarrow> rpost S (V, v) (a, False)\n 2. \\<And>it a b.\n       \\<lbrakk>\\<And>arb' a b.\n                   \\<lbrakk>rpre arb' (a, b);\n                    (a, V) \\<in> finite_psupset local.reachable\\<rbrakk>\n                   \\<Longrightarrow> REC\\<^sub>T\n(\\<lambda>dfs (V, v).\n    if v = tgt then RETURN (V, True)\n    else let V = insert v V\n         in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n             (\\<lambda>v' (V, brk).\n                 if v' \\<notin> V then dfs (V, v') else RETURN (V, False))\n             (V, False))\n(a, b)\n                                     \\<le> SPEC (rpost arb' (a, b));\n        rpre S (V, v); x_ = (V, v); v \\<noteq> tgt; it \\<subseteq> E `` {v};\n        fe_inv S V v it (a, True);\n        f =\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v = tgt then RETURN (V, True)\n             else let V = insert v V\n                  in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n                      (\\<lambda>v' (V, brk).\n                          if v' \\<notin> V then dfs (V, v')\n                          else RETURN (V, False))\n                      (V, False));\n        \\<not> rpost S (V, v) (a, True); b\\<rbrakk>\n       \\<Longrightarrow> False", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>arb' a b.\n                \\<lbrakk>rpre arb' (a, b);\n                 (a, V) \\<in> finite_psupset local.reachable\\<rbrakk>\n                \\<Longrightarrow> REC\\<^sub>T\n                                   (\\<lambda>dfs (V, v).\n if v = tgt then RETURN (V, True)\n else let V = insert v V\n      in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n          (\\<lambda>v' (V, brk).\n              if v' \\<notin> V then dfs (V, v') else RETURN (V, False))\n          (V, False))\n                                   (a, b)\n                                  \\<le> SPEC (rpost arb' (a, b));\n     rpre S (V, v); x_ = (V, v); v \\<noteq> tgt;\n     fe_inv S V v {} (a_, False); \\<not> b_;\n     f =\n     REC\\<^sub>T\n      (\\<lambda>dfs (V, v).\n          if v = tgt then RETURN (V, True)\n          else let V = insert v V\n               in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n                   (\\<lambda>v' (V, brk).\n                       if v' \\<notin> V then dfs (V, v')\n                       else RETURN (V, False))\n                   (V, False))\\<rbrakk>\n    \\<Longrightarrow> rpost S (V, v) (a_, False)", "by (auto simp: vc_foreach_completed_imp_post)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>it a b.\n       \\<lbrakk>\\<And>arb' a b.\n                   \\<lbrakk>rpre arb' (a, b);\n                    (a, V) \\<in> finite_psupset local.reachable\\<rbrakk>\n                   \\<Longrightarrow> REC\\<^sub>T\n(\\<lambda>dfs (V, v).\n    if v = tgt then RETURN (V, True)\n    else let V = insert v V\n         in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n             (\\<lambda>v' (V, brk).\n                 if v' \\<notin> V then dfs (V, v') else RETURN (V, False))\n             (V, False))\n(a, b)\n                                     \\<le> SPEC (rpost arb' (a, b));\n        rpre S (V, v); x_ = (V, v); v \\<noteq> tgt; it \\<subseteq> E `` {v};\n        fe_inv S V v it (a, True);\n        f =\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v = tgt then RETURN (V, True)\n             else let V = insert v V\n                  in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n                      (\\<lambda>v' (V, brk).\n                          if v' \\<notin> V then dfs (V, v')\n                          else RETURN (V, False))\n                      (V, False));\n        \\<not> rpost S (V, v) (a, True); b\\<rbrakk>\n       \\<Longrightarrow> False", "(* Foreach loop terminated normally: Implies postcondition *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>it a b.\n       \\<lbrakk>\\<And>arb' a b.\n                   \\<lbrakk>rpre arb' (a, b);\n                    (a, V) \\<in> finite_psupset local.reachable\\<rbrakk>\n                   \\<Longrightarrow> REC\\<^sub>T\n(\\<lambda>dfs (V, v).\n    if v = tgt then RETURN (V, True)\n    else let V = insert v V\n         in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n             (\\<lambda>v' (V, brk).\n                 if v' \\<notin> V then dfs (V, v') else RETURN (V, False))\n             (V, False))\n(a, b)\n                                     \\<le> SPEC (rpost arb' (a, b));\n        rpre S (V, v); x_ = (V, v); v \\<noteq> tgt; it \\<subseteq> E `` {v};\n        fe_inv S V v it (a, True);\n        f =\n        REC\\<^sub>T\n         (\\<lambda>dfs (V, v).\n             if v = tgt then RETURN (V, True)\n             else let V = insert v V\n                  in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n                      (\\<lambda>v' (V, brk).\n                          if v' \\<notin> V then dfs (V, v')\n                          else RETURN (V, False))\n                      (V, False));\n        \\<not> rpost S (V, v) (a, True); b\\<rbrakk>\n       \\<Longrightarrow> False", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>arb' a b.\n                \\<lbrakk>rpre arb' (a, b);\n                 (a, V) \\<in> finite_psupset local.reachable\\<rbrakk>\n                \\<Longrightarrow> REC\\<^sub>T\n                                   (\\<lambda>dfs (V, v).\n if v = tgt then RETURN (V, True)\n else let V = insert v V\n      in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n          (\\<lambda>v' (V, brk).\n              if v' \\<notin> V then dfs (V, v') else RETURN (V, False))\n          (V, False))\n                                   (a, b)\n                                  \\<le> SPEC (rpost arb' (a, b));\n     rpre S (V, v); x_ = (V, v); v \\<noteq> tgt; it_ \\<subseteq> E `` {v};\n     fe_inv S V v it_ (a_, True);\n     f =\n     REC\\<^sub>T\n      (\\<lambda>dfs (V, v).\n          if v = tgt then RETURN (V, True)\n          else let V = insert v V\n               in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n                   (\\<lambda>v' (V, brk).\n                       if v' \\<notin> V then dfs (V, v')\n                       else RETURN (V, False))\n                   (V, False));\n     \\<not> rpost S (V, v) (a_, True); b_\\<rbrakk>\n    \\<Longrightarrow> False", "by (auto simp: vc_foreach_interrupted_imp_post)"], ["proof (prove)\ngoal:\nNo subgoals!", "(* Foreach loop interrupted (tgt found): Implies postcondition *)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       \\<lbrakk>rpost {} ({}, src) x; x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> b = ((src, tgt) \\<in> E\\<^sup>*)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>rpost {} ({}, src) x_; x_ = (a_, b_)\\<rbrakk>\n    \\<Longrightarrow> b_ = ((src, tgt) \\<in> E\\<^sup>*)", "by (auto simp add: vc_rpost_imp_spec)"], ["proof (prove)\ngoal:\nNo subgoals!", "(* Postcondition implies our specification *)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  local.dfs \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Data Refinement and Determinization\\<close>"], ["", "text \\<open>\n  Next, we use automatic data refinement and transfer to generate an\n  executable algorithm. We fix the node-type to natural numbers,\n  and the successor-function to return a list-set. \n  The implementation of the visited set is left open, and Autoref's heuristics\n  will choose one (default for nat set: red-black-trees).\n\\<close>"], ["", "text \\<open>In our first example, we use \\<open>autoref_monadic\\<close>, which combines the \n  Autoref tool and the determinization of the Monadic Refinement Framework.\\<close>"], ["", "schematic_goal dfs_impl_refine_aux:\n  fixes succi and E :: \"('a::linorder \\<times> 'a) set\" and tgt src :: 'a\n  assumes [autoref_rules]: \"(succi,E)\\<in>\\<langle>Id\\<rangle>succg_rel\"\n  notes [autoref_rules] = IdI[of src] IdI[of tgt]\n  shows \"RETURN (?f::?'c) \\<le> \\<Down>?R (dfs E src tgt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?f \\<le> \\<Down> ?R (dfs E src tgt)", "unfolding dfs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?f\n    \\<le> \\<Down> ?R\n           (REC\\<^sub>T\n             (\\<lambda>dfs (V, v).\n                 if v = tgt then RETURN (V, True)\n                 else let V = insert v V\n                      in FOREACH\\<^sub>C (E `` {v})\n                          (\\<lambda>(V, brk). \\<not> brk)\n                          (\\<lambda>v' (V, brk).\n                              if v' \\<notin> V then dfs (V, v')\n                              else RETURN (V, False))\n                          (V, False))\n             ({}, src) \\<bind>\n            (\\<lambda>(uu_, r). RETURN r))", "by autoref_monadic"], ["", "text \\<open>We define a new constant from the synthesis result\\<close>"], ["", "concrete_definition dfs_impl for succi src tgt uses dfs_impl_refine_aux"], ["", "text \\<open>Set up code equations for the recursion combinators\\<close>"], ["", "prepare_code_thms dfs_impl_def"], ["", "text \\<open>And export the algorithm to all supported target languages\\<close>"], ["", "export_code dfs_impl in Haskell"], ["", "export_code dfs_impl checking SML OCaml? Haskell? Scala"], ["", "text \\<open>Chaining the refinement theorems, we get correctness arguments that \n  are almost independent of the refinement framework:\\<close>"], ["", "lemma succ_ran_fin:\n  assumes R: \"(succi,E) \\<in> \\<langle>Rv\\<rangle>succg_rel\"\n  assumes \"v\\<in>Range Rv\"\n  shows \"finite (E``{v})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (E `` {v})", "using assms"], ["proof (prove)\nusing this:\n  (succi, E) \\<in> \\<langle>Rv\\<rangle>succg_rel\n  v \\<in> Range Rv\n\ngoal (1 subgoal):\n 1. finite (E `` {v})", "unfolding succg_rel_def br_def E_of_succ_def"], ["proof (prove)\nusing this:\n  (succi, E)\n  \\<in> (Rv \\<rightarrow> \\<langle>Rv\\<rangle>list_set_rel) O\n        {(c, a). a = {(u, v). v \\<in> c u} \\<and> True}\n  v \\<in> Range Rv\n\ngoal (1 subgoal):\n 1. finite (E `` {v})", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a y.\n       \\<lbrakk>(a, v) \\<in> Rv;\n        (succi, y) \\<in> Rv \\<rightarrow> \\<langle>Rv\\<rangle>list_set_rel;\n        E = {(u, v). v \\<in> y u}\\<rbrakk>\n       \\<Longrightarrow> finite (y v)", "apply (drule (1) fun_relD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a y.\n       \\<lbrakk>(a, v) \\<in> Rv; E = {(u, v). v \\<in> y u};\n        (succi a, y v) \\<in> \\<langle>Rv\\<rangle>list_set_rel\\<rbrakk>\n       \\<Longrightarrow> finite (y v)", "using list_set_rel_range[of Rv]"], ["proof (prove)\nusing this:\n  Range (\\<langle>Rv\\<rangle>list_set_rel) =\n  {S. finite S \\<and> S \\<subseteq> Range Rv}\n\ngoal (1 subgoal):\n 1. \\<And>a y.\n       \\<lbrakk>(a, v) \\<in> Rv; E = {(u, v). v \\<in> y u};\n        (succi a, y v) \\<in> \\<langle>Rv\\<rangle>list_set_rel\\<rbrakk>\n       \\<Longrightarrow> finite (y v)", "by auto"], ["", "lemma run_ran_aux:\n  assumes R: \"(succi,E) \\<in> \\<langle>Rv\\<rangle>succg_rel\"\n  assumes REACH: \"(src,v)\\<in>E\\<^sup>*\"\n  assumes R0: \"(v0i,src) \\<in> Rv\"\n  shows \"v \\<in> Range Rv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> Range Rv", "using REACH R0"], ["proof (prove)\nusing this:\n  (src, v) \\<in> E\\<^sup>*\n  (v0i, src) \\<in> Rv\n\ngoal (1 subgoal):\n 1. v \\<in> Range Rv", "proof (induction arbitrary: v0i rule: converse_rtrancl_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v0i. (v0i, v) \\<in> Rv \\<Longrightarrow> v \\<in> Range Rv\n 2. \\<And>y z v0i.\n       \\<lbrakk>(y, z) \\<in> E; (z, v) \\<in> E\\<^sup>*;\n        \\<And>v0i. (v0i, z) \\<in> Rv \\<Longrightarrow> v \\<in> Range Rv;\n        (v0i, y) \\<in> Rv\\<rbrakk>\n       \\<Longrightarrow> v \\<in> Range Rv", "case base"], ["proof (state)\nthis:\n  (v0i, v) \\<in> Rv\n\ngoal (2 subgoals):\n 1. \\<And>v0i. (v0i, v) \\<in> Rv \\<Longrightarrow> v \\<in> Range Rv\n 2. \\<And>y z v0i.\n       \\<lbrakk>(y, z) \\<in> E; (z, v) \\<in> E\\<^sup>*;\n        \\<And>v0i. (v0i, z) \\<in> Rv \\<Longrightarrow> v \\<in> Range Rv;\n        (v0i, y) \\<in> Rv\\<rbrakk>\n       \\<Longrightarrow> v \\<in> Range Rv", "thus ?case"], ["proof (prove)\nusing this:\n  (v0i, v) \\<in> Rv\n\ngoal (1 subgoal):\n 1. v \\<in> Range Rv", "by auto"], ["proof (state)\nthis:\n  v \\<in> Range Rv\n\ngoal (1 subgoal):\n 1. \\<And>y z v0i.\n       \\<lbrakk>(y, z) \\<in> E; (z, v) \\<in> E\\<^sup>*;\n        \\<And>v0i. (v0i, z) \\<in> Rv \\<Longrightarrow> v \\<in> Range Rv;\n        (v0i, y) \\<in> Rv\\<rbrakk>\n       \\<Longrightarrow> v \\<in> Range Rv", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z v0i.\n       \\<lbrakk>(y, z) \\<in> E; (z, v) \\<in> E\\<^sup>*;\n        \\<And>v0i. (v0i, z) \\<in> Rv \\<Longrightarrow> v \\<in> Range Rv;\n        (v0i, y) \\<in> Rv\\<rbrakk>\n       \\<Longrightarrow> v \\<in> Range Rv", "case (step src v')"], ["proof (state)\nthis:\n  (src, v') \\<in> E\n  (v', v) \\<in> E\\<^sup>*\n  (?v0i, v') \\<in> Rv \\<Longrightarrow> v \\<in> Range Rv\n  (v0i, src) \\<in> Rv\n\ngoal (1 subgoal):\n 1. \\<And>y z v0i.\n       \\<lbrakk>(y, z) \\<in> E; (z, v) \\<in> E\\<^sup>*;\n        \\<And>v0i. (v0i, z) \\<in> Rv \\<Longrightarrow> v \\<in> Range Rv;\n        (v0i, y) \\<in> Rv\\<rbrakk>\n       \\<Longrightarrow> v \\<in> Range Rv", "from \\<open>(src, v') \\<in> E\\<close>"], ["proof (chain)\npicking this:\n  (src, v') \\<in> E", "have \"v' \\<in> Range Rv\""], ["proof (prove)\nusing this:\n  (src, v') \\<in> E\n\ngoal (1 subgoal):\n 1. v' \\<in> Range Rv", "using R list_set_rel_range[of Rv]"], ["proof (prove)\nusing this:\n  (src, v') \\<in> E\n  (succi, E) \\<in> \\<langle>Rv\\<rangle>succg_rel\n  Range (\\<langle>Rv\\<rangle>list_set_rel) =\n  {S. finite S \\<and> S \\<subseteq> Range Rv}\n\ngoal (1 subgoal):\n 1. v' \\<in> Range Rv", "apply (clarsimp simp: succg_rel_def br_def E_of_succ_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>Range (\\<langle>Rv\\<rangle>list_set_rel) =\n                {S. finite S \\<and> S \\<subseteq> Range Rv};\n        (succi, y) \\<in> Rv \\<rightarrow> \\<langle>Rv\\<rangle>list_set_rel;\n        E = {(u, v). v \\<in> y u}; v' \\<in> y src\\<rbrakk>\n       \\<Longrightarrow> v' \\<in> Range Rv", "apply (drule fun_relD[OF _ \\<open>(v0i, src) \\<in> Rv\\<close>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>Range (\\<langle>Rv\\<rangle>list_set_rel) =\n                {S. finite S \\<and> S \\<subseteq> Range Rv};\n        E = {(u, v). v \\<in> y u}; v' \\<in> y src;\n        (succi v0i, y src) \\<in> \\<langle>Rv\\<rangle>list_set_rel\\<rbrakk>\n       \\<Longrightarrow> v' \\<in> Range Rv", "by auto"], ["proof (state)\nthis:\n  v' \\<in> Range Rv\n\ngoal (1 subgoal):\n 1. \\<And>y z v0i.\n       \\<lbrakk>(y, z) \\<in> E; (z, v) \\<in> E\\<^sup>*;\n        \\<And>v0i. (v0i, z) \\<in> Rv \\<Longrightarrow> v \\<in> Range Rv;\n        (v0i, y) \\<in> Rv\\<rbrakk>\n       \\<Longrightarrow> v \\<in> Range Rv", "with step.IH"], ["proof (chain)\npicking this:\n  (?v0i, v') \\<in> Rv \\<Longrightarrow> v \\<in> Range Rv\n  v' \\<in> Range Rv", "show ?thesis"], ["proof (prove)\nusing this:\n  (?v0i, v') \\<in> Rv \\<Longrightarrow> v \\<in> Range Rv\n  v' \\<in> Range Rv\n\ngoal (1 subgoal):\n 1. v \\<in> Range Rv", "by blast"], ["proof (state)\nthis:\n  v \\<in> Range Rv\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma run_ran_fin: \n  assumes R: \"(succi,E) \\<in> \\<langle>Rv\\<rangle>succg_rel\"\n  assumes R0: \"(v0i,src) \\<in> Rv\"\n  shows \"\\<forall>v. (src,v)\\<in>E\\<^sup>* \\<longrightarrow> finite (E``{v})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v. (src, v) \\<in> E\\<^sup>* \\<longrightarrow> finite (E `` {v})", "using succ_ran_fin run_ran_aux assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?succi, ?E) \\<in> \\<langle>?Rv\\<rangle>succg_rel;\n   ?v \\<in> Range ?Rv\\<rbrakk>\n  \\<Longrightarrow> finite (?E `` {?v})\n  \\<lbrakk>(?succi, ?E) \\<in> \\<langle>?Rv\\<rangle>succg_rel;\n   (?src, ?v) \\<in> ?E\\<^sup>*; (?v0i, ?src) \\<in> ?Rv\\<rbrakk>\n  \\<Longrightarrow> ?v \\<in> Range ?Rv\n  (succi, E) \\<in> \\<langle>Rv\\<rangle>succg_rel\n  (v0i, src) \\<in> Rv\n\ngoal (1 subgoal):\n 1. \\<forall>v. (src, v) \\<in> E\\<^sup>* \\<longrightarrow> finite (E `` {v})", "by metis"], ["", "text \\<open>Correctness theorem presented in the paper:\\<close>"], ["", "theorem dfs_code_correct: \n  assumes SUCCI: \"(succi,E)\\<in>\\<langle>Id\\<rangle>succg_rel\"\n  assumes FIN: \"finite (E\\<^sup>*``{src})\"  \n  shows \"dfs_impl succi src tgt \\<longleftrightarrow> (src,tgt)\\<in>E\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dfs_impl succi src tgt = ((src, tgt) \\<in> E\\<^sup>*)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dfs_impl succi src tgt = ((src, tgt) \\<in> E\\<^sup>*)", "note dfs_impl.refine[OF SUCCI, of src tgt]"], ["proof (state)\nthis:\n  RETURN (dfs_impl succi src tgt) \\<le> \\<Down> bool_rel (dfs E src tgt)\n\ngoal (1 subgoal):\n 1. dfs_impl succi src tgt = ((src, tgt) \\<in> E\\<^sup>*)", "also"], ["proof (state)\nthis:\n  RETURN (dfs_impl succi src tgt) \\<le> \\<Down> bool_rel (dfs E src tgt)\n\ngoal (1 subgoal):\n 1. dfs_impl succi src tgt = ((src, tgt) \\<in> E\\<^sup>*)", "note dfs_correct[OF FIN]"], ["proof (state)\nthis:\n  dfs E src ?tgt \\<le> SPEC (\\<lambda>r. r = ((src, ?tgt) \\<in> E\\<^sup>*))\n\ngoal (1 subgoal):\n 1. dfs_impl succi src tgt = ((src, tgt) \\<in> E\\<^sup>*)", "finally"], ["proof (chain)\npicking this:\n  RETURN (dfs_impl succi src tgt)\n  \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "show ?thesis"], ["proof (prove)\nusing this:\n  RETURN (dfs_impl succi src tgt)\n  \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))\n\ngoal (1 subgoal):\n 1. dfs_impl succi src tgt = ((src, tgt) \\<in> E\\<^sup>*)", "by (auto simp: split: dres.split)"], ["proof (state)\nthis:\n  dfs_impl succi src tgt = ((src, tgt) \\<in> E\\<^sup>*)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Using only Autoref\\<close>"], ["", "text \\<open>Here we show the result of Autoref, without the determinization phase of\n  the Monadic Refinement Framework: \\<close>"], ["", "schematic_goal \n  fixes succi and E :: \"('a::linorder \\<times> 'a) set\" and tgt src :: 'a\n  assumes [autoref_rules]: \"(succi,E)\\<in>\\<langle>Id\\<rangle>succg_rel\"\n  notes [autoref_rules] = IdI[of src] IdI[of tgt]\n  shows \"(?f::?'c, dfs E src tgt) \\<in> ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?f, dfs E src tgt) \\<in> ?R", "unfolding dfs_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?f,\n     REC\\<^sub>T\n      (\\<lambda>dfs (V, v).\n          if v = tgt then RETURN (V, True)\n          else let V = insert v V\n               in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n                   (\\<lambda>v' (V, brk).\n                       if v' \\<notin> V then dfs (V, v')\n                       else RETURN (V, False))\n                   (V, False))\n      ({}, src) \\<bind>\n     (\\<lambda>(uu_, y). RETURN y))\n    \\<in> ?R", "apply (autoref (trace))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Choosing Different Implementations\\<close>"], ["", "text \\<open>Ad-hoc override of implementation selection heuristics: Using hashset for the visited set\\<close>"], ["", "schematic_goal dfs_impl_refine_aux2:\n  fixes succi and E :: \"(('a::hashable) \\<times> 'a) set\" and tgt src :: 'a\n  assumes [autoref_rules]: \"(succi,E)\\<in>\\<langle>Id\\<rangle>succg_rel\"\n  notes [autoref_rules] = IdI[of src] IdI[of tgt]\n  notes [autoref_tyrel] = ty_REL[where 'a=\"'a set\" and R=\"\\<langle>Id\\<rangle>dflt_ahs_rel\"] \n  shows \"(?f::?'c, dfs E src tgt) \\<in> ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?f, dfs E src tgt) \\<in> ?R", "unfolding dfs_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?f,\n     REC\\<^sub>T\n      (\\<lambda>dfs (V, v).\n          if v = tgt then RETURN (V, True)\n          else let V = insert v V\n               in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n                   (\\<lambda>v' (V, brk).\n                       if v' \\<notin> V then dfs (V, v')\n                       else RETURN (V, False))\n                   (V, False))\n      ({}, src) \\<bind>\n     (\\<lambda>(uu_, y). RETURN y))\n    \\<in> ?R", "apply autoref_monadic"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>We can also leave the type of the nodes and its implementation\n  unspecified. However, we need a comparison operator on nodes\\<close>"], ["", "(* With linorder typeclass on abstract type *)"], ["", "schematic_goal dfs_impl_refine_aux3:\n  fixes succi and E :: \"('a::linorder \\<times> 'a) set\" \n    and Rv :: \"('ai\\<times>'a) set\"\n  assumes [autoref_rules_raw]: \"(cmpk, dflt_cmp (\\<le>) (<))\\<in>(Rv\\<rightarrow>Rv\\<rightarrow>Id)\"\n  notes [autoref_tyrel] = ty_REL[where 'a=\"'a set\" and R=\"\\<langle>Rv\\<rangle>dflt_rs_rel\"]\n  assumes P_REF[autoref_rules]: \n    \"(succi,E)\\<in>\\<langle>Rv\\<rangle>succg_rel\"\n    \"(vdi,tgt::'a)\\<in>Rv\"\n    \"(v0i,src)\\<in>Rv\"\n  shows \"(RETURN (?f::?'c), dfs E src tgt)\\<in>?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN ?f, dfs E src tgt) \\<in> ?R", "unfolding dfs_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN ?f,\n     REC\\<^sub>T\n      (\\<lambda>dfs (V, v).\n          if v = tgt then RETURN (V, True)\n          else let V = insert v V\n               in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n                   (\\<lambda>v' (V, brk).\n                       if v' \\<notin> V then dfs (V, v')\n                       else RETURN (V, False))\n                   (V, False))\n      ({}, src) \\<bind>\n     (\\<lambda>(uu_, y). RETURN y))\n    \\<in> ?R", "by autoref_monadic"], ["", "(* With arbitrary cmpk' operator on abstract type, not forcing a linorder typeclass instance.\n  Useful if there are multiple possible instantiations of a typeclass (eg for product ordering), \n  and one does not want to commit to one.\n*)"], ["", "schematic_goal dfs_impl_refine_aux3':\n  fixes succi and E :: \"('a \\<times> 'a) set\" \n    and Rv :: \"('ai\\<times>'a) set\"\n  assumes [autoref_ga_rules]: \"eq_linorder cmpk'\"\n  assumes [autoref_rules_raw]: \"(cmpk, cmpk')\\<in>(Rv\\<rightarrow>Rv\\<rightarrow>comp_res_rel)\"\n  notes [autoref_tyrel] = ty_REL[where 'a=\"'a set\" and R=\"\\<langle>Rv\\<rangle>map2set_rel (rbt_map_rel (comp2lt cmpk'))\"]\n  assumes P_REF[autoref_rules]: \n    \"(succi,E)\\<in>\\<langle>Rv\\<rangle>succg_rel\"\n    \"(vdi,tgt::'a)\\<in>Rv\"\n    \"(v0i,src)\\<in>Rv\"\n  shows \"(RETURN (?f::?'c), dfs E src tgt)\\<in>?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN ?f, dfs E src tgt) \\<in> ?R", "unfolding dfs_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (RETURN ?f,\n     REC\\<^sub>T\n      (\\<lambda>dfs (V, v).\n          if v = tgt then RETURN (V, True)\n          else let V = insert v V\n               in FOREACH\\<^sub>C (E `` {v}) (\\<lambda>(V, y). \\<not> y)\n                   (\\<lambda>v' (V, brk).\n                       if v' \\<notin> V then dfs (V, v')\n                       else RETURN (V, False))\n                   (V, False))\n      ({}, src) \\<bind>\n     (\\<lambda>(uu_, y). RETURN y))\n    \\<in> ?R", "by autoref_monadic"], ["", "text \\<open>We also generate code for the alternative implementations\\<close>"], ["", "concrete_definition dfs_impl2 for succi src tgt uses dfs_impl_refine_aux2"], ["", "concrete_definition dfs_impl3 for cmpk succi v0i vdi uses dfs_impl_refine_aux3"], ["", "concrete_definition dfs_impl3' for cmpk succi v0i vdi uses dfs_impl_refine_aux3'"], ["", "prepare_code_thms dfs_impl2_def"], ["", "prepare_code_thms dfs_impl3_def"], ["", "prepare_code_thms dfs_impl3'_def"], ["", "export_code dfs_impl dfs_impl2 dfs_impl3 dfs_impl3' checking SML OCaml? Haskell? Scala"], ["", "text \\<open>And we prove the alternative implementations correct \\<close>"], ["", "theorem dfs_code2_correct: \n  assumes SUCCI: \"(succi,E)\\<in>\\<langle>Id\\<rangle>succg_rel\"\n  assumes FIN: \"finite (E\\<^sup>*``{src})\"  \n  shows \"dfs_impl2 succi src tgt \\<longleftrightarrow> (src,tgt)\\<in>E\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dfs_impl2 succi src tgt = ((src, tgt) \\<in> E\\<^sup>*)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dfs_impl2 succi src tgt = ((src, tgt) \\<in> E\\<^sup>*)", "note dfs_impl2.refine[OF SUCCI, of src tgt, THEN nres_relD]"], ["proof (state)\nthis:\n  RETURN (dfs_impl2 succi src tgt) \\<le> \\<Down> bool_rel (dfs E src tgt)\n\ngoal (1 subgoal):\n 1. dfs_impl2 succi src tgt = ((src, tgt) \\<in> E\\<^sup>*)", "also"], ["proof (state)\nthis:\n  RETURN (dfs_impl2 succi src tgt) \\<le> \\<Down> bool_rel (dfs E src tgt)\n\ngoal (1 subgoal):\n 1. dfs_impl2 succi src tgt = ((src, tgt) \\<in> E\\<^sup>*)", "note dfs_correct[OF FIN]"], ["proof (state)\nthis:\n  dfs E src ?tgt \\<le> SPEC (\\<lambda>r. r = ((src, ?tgt) \\<in> E\\<^sup>*))\n\ngoal (1 subgoal):\n 1. dfs_impl2 succi src tgt = ((src, tgt) \\<in> E\\<^sup>*)", "finally"], ["proof (chain)\npicking this:\n  RETURN (dfs_impl2 succi src tgt)\n  \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "show ?thesis"], ["proof (prove)\nusing this:\n  RETURN (dfs_impl2 succi src tgt)\n  \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))\n\ngoal (1 subgoal):\n 1. dfs_impl2 succi src tgt = ((src, tgt) \\<in> E\\<^sup>*)", "by (auto simp: split: dres.split)"], ["proof (state)\nthis:\n  dfs_impl2 succi src tgt = ((src, tgt) \\<in> E\\<^sup>*)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem dfs_code3_correct: \n  fixes succi and succ :: \"'a::linorder \\<Rightarrow> 'a set\" \n    and Rv :: \"('ai\\<times>'a) set\"\n  assumes V0: \"(v0i,src)\\<in>Rv\"\n  assumes VD: \"(vdi,tgt)\\<in>Rv\"\n  assumes SUCCI: \"(succi,E)\\<in>\\<langle>Rv\\<rangle>succg_rel\"\n  assumes CMP: \"(cmpk, dflt_cmp (\\<le>) (<))\\<in>(Rv\\<rightarrow>Rv\\<rightarrow>Id)\"\n  assumes FIN: \"finite (E\\<^sup>*``{src})\"  \n  shows \"dfs_impl3 cmpk succi v0i vdi \\<longleftrightarrow> (src,tgt)\\<in>E\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dfs_impl3 cmpk succi v0i vdi = ((src, tgt) \\<in> E\\<^sup>*)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dfs_impl3 cmpk succi v0i vdi = ((src, tgt) \\<in> E\\<^sup>*)", "note dfs_impl3.refine[OF CMP SUCCI VD V0, THEN nres_relD]"], ["proof (state)\nthis:\n  RETURN (dfs_impl3 cmpk succi v0i vdi)\n  \\<le> \\<Down> bool_rel (dfs E src tgt)\n\ngoal (1 subgoal):\n 1. dfs_impl3 cmpk succi v0i vdi = ((src, tgt) \\<in> E\\<^sup>*)", "also"], ["proof (state)\nthis:\n  RETURN (dfs_impl3 cmpk succi v0i vdi)\n  \\<le> \\<Down> bool_rel (dfs E src tgt)\n\ngoal (1 subgoal):\n 1. dfs_impl3 cmpk succi v0i vdi = ((src, tgt) \\<in> E\\<^sup>*)", "note dfs_correct[OF FIN]"], ["proof (state)\nthis:\n  dfs E src ?tgt \\<le> SPEC (\\<lambda>r. r = ((src, ?tgt) \\<in> E\\<^sup>*))\n\ngoal (1 subgoal):\n 1. dfs_impl3 cmpk succi v0i vdi = ((src, tgt) \\<in> E\\<^sup>*)", "finally"], ["proof (chain)\npicking this:\n  RETURN (dfs_impl3 cmpk succi v0i vdi)\n  \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "show ?thesis"], ["proof (prove)\nusing this:\n  RETURN (dfs_impl3 cmpk succi v0i vdi)\n  \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))\n\ngoal (1 subgoal):\n 1. dfs_impl3 cmpk succi v0i vdi = ((src, tgt) \\<in> E\\<^sup>*)", "by (auto simp: split: dres.split)"], ["proof (state)\nthis:\n  dfs_impl3 cmpk succi v0i vdi = ((src, tgt) \\<in> E\\<^sup>*)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem dfs_code3'_correct: \n  fixes succi and succ :: \"'a::linorder \\<Rightarrow> 'a set\" \n    and Rv :: \"('ai\\<times>'a) set\"\n  assumes V0: \"(v0i,src)\\<in>Rv\"\n  assumes VD: \"(vdi,tgt)\\<in>Rv\"\n  assumes SUCCI: \"(succi,E)\\<in>\\<langle>Rv\\<rangle>succg_rel\"\n  assumes CGA: \"eq_linorder cmpk'\"\n  assumes CMP: \"(cmpk, cmpk') \\<in> Rv\\<rightarrow>Rv\\<rightarrow>comp_res_rel\"\n  assumes FIN: \"finite (E\\<^sup>*``{src})\"  \n  shows \"dfs_impl3' cmpk succi v0i vdi \\<longleftrightarrow> (src,tgt)\\<in>E\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dfs_impl3' cmpk succi v0i vdi = ((src, tgt) \\<in> E\\<^sup>*)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dfs_impl3' cmpk succi v0i vdi = ((src, tgt) \\<in> E\\<^sup>*)", "note dfs_impl3'.refine[OF CGA CMP SUCCI VD V0, THEN nres_relD]"], ["proof (state)\nthis:\n  RETURN (dfs_impl3' cmpk succi v0i vdi)\n  \\<le> \\<Down> bool_rel (dfs E src tgt)\n\ngoal (1 subgoal):\n 1. dfs_impl3' cmpk succi v0i vdi = ((src, tgt) \\<in> E\\<^sup>*)", "also"], ["proof (state)\nthis:\n  RETURN (dfs_impl3' cmpk succi v0i vdi)\n  \\<le> \\<Down> bool_rel (dfs E src tgt)\n\ngoal (1 subgoal):\n 1. dfs_impl3' cmpk succi v0i vdi = ((src, tgt) \\<in> E\\<^sup>*)", "note dfs_correct[OF FIN]"], ["proof (state)\nthis:\n  dfs E src ?tgt \\<le> SPEC (\\<lambda>r. r = ((src, ?tgt) \\<in> E\\<^sup>*))\n\ngoal (1 subgoal):\n 1. dfs_impl3' cmpk succi v0i vdi = ((src, tgt) \\<in> E\\<^sup>*)", "finally"], ["proof (chain)\npicking this:\n  RETURN (dfs_impl3' cmpk succi v0i vdi)\n  \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))", "show ?thesis"], ["proof (prove)\nusing this:\n  RETURN (dfs_impl3' cmpk succi v0i vdi)\n  \\<le> SPEC (\\<lambda>r. r = ((src, tgt) \\<in> E\\<^sup>*))\n\ngoal (1 subgoal):\n 1. dfs_impl3' cmpk succi v0i vdi = ((src, tgt) \\<in> E\\<^sup>*)", "by (auto simp: split: dres.split)"], ["proof (state)\nthis:\n  dfs_impl3' cmpk succi v0i vdi = ((src, tgt) \\<in> E\\<^sup>*)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* Reachability *)"], ["", "definition [simp]: \"op_reachable E u v \\<equiv> (u,v)\\<in>E\\<^sup>*\""], ["", "context begin"], ["", "interpretation autoref_syn"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma [autoref_op_pat]: \"(u,v)\\<in>E\\<^sup>* \\<equiv> op_reachable$E$u$v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, v) \\<in> E\\<^sup>* \\<equiv> op_reachable $ E $ u $ v", "by simp"], ["", "(* We use a quite general setup here, working with any linearly ordered\n    abstract node type, refined by any relation. *)"], ["", "theorem dfs_code3_correct_rl[autoref_rules]: \n    fixes succi and succ :: \"'a::linorder \\<Rightarrow> 'a set\" \n      and Rv :: \"('ai\\<times>'a) set\"\n    assumes V0: \"(v0i,src)\\<in>Rv\"\n    assumes VD: \"(vdi,tgt)\\<in>Rv\"\n    assumes SUCCI: \"(succi,E)\\<in>\\<langle>Rv\\<rangle>succg_rel\"\n    assumes CGA: \"SIDE_GEN_ALGO (eq_linorder cmpk')\"\n    assumes CMP: \"GEN_OP cmpk cmpk' (Rv\\<rightarrow>Rv\\<rightarrow>comp_res_rel)\"\n    assumes FIN: \"SIDE_PRECOND (finite (E\\<^sup>*``{src}))\"  \n    shows \"(dfs_impl3' cmpk succi v0i vdi, \n          (OP op_reachable ::: \\<langle>Rv\\<rangle>succg_rel \\<rightarrow> Rv \\<rightarrow> Rv \\<rightarrow> bool_rel)$E$src$tgt)\n          \\<in> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (dfs_impl3' cmpk succi v0i vdi,\n     (OP op_reachable :::\n      \\<langle>Rv\\<rangle>succg_rel \\<rightarrow>\n      Rv \\<rightarrow> Rv \\<rightarrow> bool_rel) $\n     E $\n     src $\n     tgt)\n    \\<in> bool_rel", "using dfs_code3'_correct[OF V0 VD SUCCI, of cmpk' cmpk] CGA CMP FIN"], ["proof (prove)\nusing this:\n  \\<lbrakk>eq_linorder cmpk';\n   (cmpk, cmpk') \\<in> Rv \\<rightarrow> Rv \\<rightarrow> comp_res_rel;\n   finite (E\\<^sup>* `` {src})\\<rbrakk>\n  \\<Longrightarrow> dfs_impl3' cmpk succi v0i vdi =\n                    ((src, tgt) \\<in> E\\<^sup>*)\n  SIDE_GEN_ALGO (eq_linorder cmpk')\n  GEN_OP cmpk cmpk' (Rv \\<rightarrow> Rv \\<rightarrow> comp_res_rel)\n  SIDE_PRECOND (finite (E\\<^sup>* `` {src}))\n\ngoal (1 subgoal):\n 1. (dfs_impl3' cmpk succi v0i vdi,\n     (OP op_reachable :::\n      \\<langle>Rv\\<rangle>succg_rel \\<rightarrow>\n      Rv \\<rightarrow> Rv \\<rightarrow> bool_rel) $\n     E $\n     src $\n     tgt)\n    \\<in> bool_rel", "unfolding autoref_tag_defs"], ["proof (prove)\nusing this:\n  \\<lbrakk>eq_linorder cmpk';\n   (cmpk, cmpk') \\<in> Rv \\<rightarrow> Rv \\<rightarrow> comp_res_rel;\n   finite (E\\<^sup>* `` {src})\\<rbrakk>\n  \\<Longrightarrow> dfs_impl3' cmpk succi v0i vdi =\n                    ((src, tgt) \\<in> E\\<^sup>*)\n  eq_linorder cmpk'\n  (cmpk, cmpk') \\<in> Rv \\<rightarrow> Rv \\<rightarrow> comp_res_rel\n  finite (E\\<^sup>* `` {src})\n\ngoal (1 subgoal):\n 1. (dfs_impl3' cmpk succi v0i vdi, op_reachable E src tgt) \\<in> bool_rel", "by simp"], ["", "end"], ["", "end"]]}