{"file_name": "/home/qj213/afp-2021-10-22/thys/Collections/ICF/CollectionsV1.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Collections", "problem_names": ["lemma iteratei_rule_P:\n    \"\\<lbrakk>\n      invar S;\n      I (\\<alpha> S) \\<sigma>0;\n      !!x it \\<sigma>. \\<lbrakk> c \\<sigma>; x \\<in> it; it \\<subseteq> \\<alpha> S; I it \\<sigma> \\<rbrakk> \\<Longrightarrow> I (it - {x}) (f x \\<sigma>);\n      !!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>;\n      !!\\<sigma> it. \\<lbrakk> it \\<subseteq> \\<alpha> S; it \\<noteq> {}; \\<not> c \\<sigma>; I it \\<sigma> \\<rbrakk> \\<Longrightarrow> P \\<sigma>\n    \\<rbrakk> \\<Longrightarrow> P (iteratei S c f \\<sigma>0)\"", "lemma iteratei_rule_insert_P:\n    \"\\<lbrakk>\n      invar S;\n      I {} \\<sigma>0;\n      !!x it \\<sigma>. \\<lbrakk> c \\<sigma>; x \\<in> \\<alpha> S - it; it \\<subseteq> \\<alpha> S; I it \\<sigma> \\<rbrakk> \\<Longrightarrow> I (insert x it) (f x \\<sigma>);\n      !!\\<sigma>. I (\\<alpha> S) \\<sigma> \\<Longrightarrow> P \\<sigma>;\n      !!\\<sigma> it. \\<lbrakk> it \\<subseteq> \\<alpha> S; it \\<noteq> \\<alpha> S; \\<not> c \\<sigma>; I it \\<sigma> \\<rbrakk> \\<Longrightarrow> P \\<sigma>\n    \\<rbrakk> \\<Longrightarrow> P (iteratei S c f \\<sigma>0)\"", "lemma iterate_rule_P:\n    \"\\<lbrakk>\n      invar S;\n      I (\\<alpha> S) \\<sigma>0;\n      !!x it \\<sigma>. \\<lbrakk> x \\<in> it; it \\<subseteq> \\<alpha> S; I it \\<sigma> \\<rbrakk> \\<Longrightarrow> I (it - {x}) (f x \\<sigma>);\n      !!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\n    \\<rbrakk> \\<Longrightarrow> P (iteratei S (\\<lambda>_. True) f \\<sigma>0)\"", "lemma iterate_rule_insert_P:\n    \"\\<lbrakk>\n      invar S;\n      I {} \\<sigma>0;\n      !!x it \\<sigma>. \\<lbrakk> x \\<in> \\<alpha> S - it; it \\<subseteq> \\<alpha> S; I it \\<sigma> \\<rbrakk> \\<Longrightarrow> I (insert x it) (f x \\<sigma>);\n      !!\\<sigma>. I (\\<alpha> S) \\<sigma> \\<Longrightarrow> P \\<sigma>\n    \\<rbrakk> \\<Longrightarrow> P (iteratei S (\\<lambda>_. True) f \\<sigma>0)\"", "lemma set_iteratei_I :\nassumes \"\\<And>s. invar s \\<Longrightarrow> set_iterator (iti s) (\\<alpha> s)\"\nshows \"set_iteratei \\<alpha> invar iti\"", "lemma iterateoi_rule_P[case_names minv inv0 inv_pres i_complete i_inter]:\n      assumes MINV: \"invar m\"\n      assumes I0: \"I (\\<alpha> m) \\<sigma>0\"\n      assumes IP: \"!!k it \\<sigma>. \\<lbrakk> \n        c \\<sigma>; \n        k \\<in> it; \n        \\<forall>j\\<in>it. k\\<le>j; \n        \\<forall>j\\<in>\\<alpha> m - it. j\\<le>k; \n        it \\<subseteq> \\<alpha> m; \n        I it \\<sigma> \n      \\<rbrakk> \\<Longrightarrow> I (it - {k}) (f k \\<sigma>)\"\n      assumes IF: \"!!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n      assumes II: \"!!\\<sigma> it. \\<lbrakk> \n        it \\<subseteq> \\<alpha> m; \n        it \\<noteq> {}; \n        \\<not> c \\<sigma>; \n        I it \\<sigma>; \n        \\<forall>k\\<in>it. \\<forall>j\\<in>\\<alpha> m - it. j\\<le>k \n      \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n      shows \"P (iterateoi m c f \\<sigma>0)\"", "lemma iterateo_rule_P[case_names minv inv0 inv_pres i_complete]: \n      assumes MINV: \"invar m\"\n      assumes I0: \"I ((\\<alpha> m)) \\<sigma>0\"\n      assumes IP: \"!!k it \\<sigma>. \\<lbrakk> k \\<in> it; \\<forall>j\\<in>it. k\\<le>j; \\<forall>j\\<in>(\\<alpha> m) - it. j\\<le>k; it \\<subseteq> (\\<alpha> m); I it \\<sigma> \\<rbrakk> \n                  \\<Longrightarrow> I (it - {k}) (f k \\<sigma>)\"\n      assumes IF: \"!!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n    shows \"P (iterateoi m (\\<lambda>_. True) f \\<sigma>0)\"", "lemma set_iterateoi_I :\n  assumes \"\\<And>s. invar s \\<Longrightarrow> set_iterator_linord (itoi s) (\\<alpha> s)\"\n  shows \"set_iterateoi \\<alpha> invar itoi\"", "lemma reverse_iterateoi_rule_P[case_names minv inv0 inv_pres i_complete i_inter]:\n      assumes MINV: \"invar m\"\n      assumes I0: \"I ((\\<alpha> m)) \\<sigma>0\"\n      assumes IP: \"!!k it \\<sigma>. \\<lbrakk> \n        c \\<sigma>; \n        k \\<in> it; \n        \\<forall>j\\<in>it. k\\<ge>j; \n        \\<forall>j\\<in>(\\<alpha> m) - it. j\\<ge>k; \n        it \\<subseteq> (\\<alpha> m); \n        I it \\<sigma> \n      \\<rbrakk> \\<Longrightarrow> I (it - {k}) (f k \\<sigma>)\"\n      assumes IF: \"!!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n      assumes II: \"!!\\<sigma> it. \\<lbrakk> \n        it \\<subseteq> (\\<alpha> m); \n        it \\<noteq> {}; \n        \\<not> c \\<sigma>; \n        I it \\<sigma>; \n        \\<forall>k\\<in>it. \\<forall>j\\<in>(\\<alpha> m) - it. j\\<ge>k \n      \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n    shows \"P (reverse_iterateoi m c f \\<sigma>0)\"", "lemma reverse_iterateo_rule_P[case_names minv inv0 inv_pres i_complete]:\n      assumes MINV: \"invar m\"\n      assumes I0: \"I ((\\<alpha> m)) \\<sigma>0\"\n      assumes IP: \"!!k it \\<sigma>. \\<lbrakk> \n        k \\<in> it; \n        \\<forall>j\\<in>it. k\\<ge>j; \n        \\<forall>j\\<in> (\\<alpha> m) - it. j\\<ge>k; \n        it \\<subseteq> (\\<alpha> m); \n        I it \\<sigma> \n      \\<rbrakk> \\<Longrightarrow> I (it - {k}) (f k \\<sigma>)\"\n      assumes IF: \"!!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n    shows \"P (reverse_iterateoi m (\\<lambda>_. True) f \\<sigma>0)\"", "lemma set_reverse_iterateoi_I :\n  assumes \"\\<And>s. invar s \\<Longrightarrow> set_iterator_rev_linord (itoi s) (\\<alpha> s)\"\n  shows \"set_reverse_iterateoi \\<alpha> invar itoi\"", "lemma (in poly_set_iteratei) v1_iteratei_impl: \n    \"set_iteratei \\<alpha> invar iteratei\"", "lemma (in poly_set_iterateoi) v1_iterateoi_impl: \n    \"set_iterateoi \\<alpha> invar iterateoi\"", "lemma (in poly_set_rev_iterateoi) v1_reverse_iterateoi_impl: \n    \"set_reverse_iterateoi \\<alpha> invar rev_iterateoi\"", "lemma iteratei_rule_P:\n    assumes \"invar m\"\n        and I0: \"I (dom (\\<alpha> m)) \\<sigma>0\"\n        and IP: \"!!k v it \\<sigma>. \\<lbrakk> c \\<sigma>; k \\<in> it; \\<alpha> m k = Some v; it \\<subseteq> dom (\\<alpha> m); I it \\<sigma> \\<rbrakk> \n                    \\<Longrightarrow> I (it - {k}) (f (k, v) \\<sigma>)\"\n        and IF: \"!!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n        and II: \"!!\\<sigma> it. \\<lbrakk> it \\<subseteq> dom (\\<alpha> m); it \\<noteq> {}; \\<not> c \\<sigma>; I it \\<sigma> \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n    shows \"P (iteratei m c f \\<sigma>0)\"", "lemma iteratei_rule_insert_P:\n    assumes  \n      \"invar m\" \n      \"I {} \\<sigma>0\"\n      \"!!k v it \\<sigma>. \\<lbrakk> c \\<sigma>; k \\<in> (dom (\\<alpha> m) - it); \\<alpha> m k = Some v; it \\<subseteq> dom (\\<alpha> m); I it \\<sigma> \\<rbrakk> \n          \\<Longrightarrow> I (insert k it) (f (k, v) \\<sigma>)\"\n      \"!!\\<sigma>. I (dom (\\<alpha> m)) \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n      \"!!\\<sigma> it. \\<lbrakk> it \\<subseteq> dom (\\<alpha> m); it \\<noteq> dom (\\<alpha> m); \n               \\<not> (c \\<sigma>); \n               I it \\<sigma> \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n    shows \"P (iteratei m c f \\<sigma>0)\"", "lemma iterate_rule_P:\n    \"\\<lbrakk>\n      invar m;\n      I (dom (\\<alpha> m)) \\<sigma>0;\n      !!k v it \\<sigma>. \\<lbrakk> k \\<in> it; \\<alpha> m k = Some v; it \\<subseteq> dom (\\<alpha> m); I it \\<sigma> \\<rbrakk> \n                  \\<Longrightarrow> I (it - {k}) (f (k, v) \\<sigma>);\n      !!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\n    \\<rbrakk> \\<Longrightarrow> P (iteratei m (\\<lambda>_. True) f \\<sigma>0)\"", "lemma iterate_rule_insert_P:\n    \"\\<lbrakk>\n      invar m;\n      I {} \\<sigma>0;\n      !!k v it \\<sigma>. \\<lbrakk> k \\<in> (dom (\\<alpha> m) - it); \\<alpha> m k = Some v; it \\<subseteq> dom (\\<alpha> m); I it \\<sigma> \\<rbrakk> \n                  \\<Longrightarrow> I (insert k it) (f (k, v) \\<sigma>);\n      !!\\<sigma>. I (dom (\\<alpha> m)) \\<sigma> \\<Longrightarrow> P \\<sigma>\n    \\<rbrakk> \\<Longrightarrow> P (iteratei m (\\<lambda>_. True) f \\<sigma>0)\"", "lemma map_iteratei_I :\n  assumes \"\\<And>m. invar m \\<Longrightarrow> map_iterator (iti m) (\\<alpha> m)\"\n  shows \"map_iteratei \\<alpha> invar iti\"", "lemma iterateoi_rule_P[case_names minv inv0 inv_pres i_complete i_inter]:\n      assumes MINV: \"invar m\"\n      assumes I0: \"I (dom (\\<alpha> m)) \\<sigma>0\"\n      assumes IP: \"!!k v it \\<sigma>. \\<lbrakk> \n        c \\<sigma>; \n        k \\<in> it; \n        \\<forall>j\\<in>it. k\\<le>j; \n        \\<forall>j\\<in>dom (\\<alpha> m) - it. j\\<le>k; \n        \\<alpha> m k = Some v; \n        it \\<subseteq> dom (\\<alpha> m); \n        I it \\<sigma> \n      \\<rbrakk> \\<Longrightarrow> I (it - {k}) (f (k, v) \\<sigma>)\"\n      assumes IF: \"!!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n      assumes II: \"!!\\<sigma> it. \\<lbrakk> \n        it \\<subseteq> dom (\\<alpha> m); \n        it \\<noteq> {}; \n        \\<not> c \\<sigma>; \n        I it \\<sigma>; \n        \\<forall>k\\<in>it. \\<forall>j\\<in>dom (\\<alpha> m) - it. j\\<le>k \n      \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n      shows \"P (iterateoi m c f \\<sigma>0)\"", "lemma iterateo_rule_P[case_names minv inv0 inv_pres i_complete]: \n      assumes MINV: \"invar m\"\n      assumes I0: \"I (dom (\\<alpha> m)) \\<sigma>0\"\n      assumes IP: \"!!k v it \\<sigma>. \\<lbrakk> k \\<in> it; \\<forall>j\\<in>it. k\\<le>j; \\<forall>j\\<in>dom (\\<alpha> m) - it. j\\<le>k; \\<alpha> m k = Some v; it \\<subseteq> dom (\\<alpha> m); I it \\<sigma> \\<rbrakk> \n                  \\<Longrightarrow> I (it - {k}) (f (k, v) \\<sigma>)\"\n      assumes IF: \"!!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n      shows \"P (iterateoi m (\\<lambda>_. True) f \\<sigma>0)\"", "lemma map_iterateoi_I :\n  assumes \"\\<And>m. invar m \\<Longrightarrow> map_iterator_linord (itoi m) (\\<alpha> m)\"\n  shows \"map_iterateoi \\<alpha> invar itoi\"", "lemma reverse_iterateoi_rule_P[case_names minv inv0 inv_pres i_complete i_inter]:\n      assumes MINV: \"invar m\"\n      assumes I0: \"I (dom (\\<alpha> m)) \\<sigma>0\"\n      assumes IP: \"!!k v it \\<sigma>. \\<lbrakk> \n        c \\<sigma>; \n        k \\<in> it; \n        \\<forall>j\\<in>it. k\\<ge>j; \n        \\<forall>j\\<in>dom (\\<alpha> m) - it. j\\<ge>k; \n        \\<alpha> m k = Some v; \n        it \\<subseteq> dom (\\<alpha> m); \n        I it \\<sigma> \n      \\<rbrakk> \\<Longrightarrow> I (it - {k}) (f (k, v) \\<sigma>)\"\n      assumes IF: \"!!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n      assumes II: \"!!\\<sigma> it. \\<lbrakk> \n        it \\<subseteq> dom (\\<alpha> m); \n        it \\<noteq> {}; \n        \\<not> c \\<sigma>; \n        I it \\<sigma>; \n        \\<forall>k\\<in>it. \\<forall>j\\<in>dom (\\<alpha> m) - it. j\\<ge>k \n      \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n      shows \"P (reverse_iterateoi m c f \\<sigma>0)\"", "lemma reverse_iterateo_rule_P[case_names minv inv0 inv_pres i_complete]:\n      assumes MINV: \"invar m\"\n      assumes I0: \"I (dom (\\<alpha> m)) \\<sigma>0\"\n      assumes IP: \"!!k v it \\<sigma>. \\<lbrakk> \n        k \\<in> it; \n        \\<forall>j\\<in>it. k\\<ge>j; \n        \\<forall>j\\<in>dom (\\<alpha> m) - it. j\\<ge>k; \n        \\<alpha> m k = Some v; \n        it \\<subseteq> dom (\\<alpha> m); \n        I it \\<sigma> \n      \\<rbrakk> \\<Longrightarrow> I (it - {k}) (f (k, v) \\<sigma>)\"\n      assumes IF: \"!!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n      shows \"P (reverse_iterateoi m (\\<lambda>_. True) f \\<sigma>0)\"", "lemma map_reverse_iterateoi_I :\n  assumes \"\\<And>m. invar m \\<Longrightarrow> map_iterator_rev_linord (ritoi m) (\\<alpha> m)\"\n  shows \"map_reverse_iterateoi \\<alpha> invar ritoi\"", "lemma (in poly_map_iteratei) v1_iteratei_impl: \n    \"map_iteratei \\<alpha> invar iteratei\"", "lemma (in poly_map_iterateoi) v1_iterateoi_impl: \n    \"map_iterateoi \\<alpha> invar iterateoi\"", "lemma (in poly_map_rev_iterateoi) v1_reverse_iterateoi_impl: \n    \"map_reverse_iterateoi \\<alpha> invar rev_iterateoi\"", "lemmas hs_correct = hs.correct", "lemmas hm_correct = hm.correct", "lemmas rs_correct = rs.correct", "lemmas rm_correct = rm.correct", "lemmas ls_correct = ls.correct", "lemmas lm_correct = lm.correct", "lemmas lsi_correct = lsi.correct", "lemmas lmi_correct = lmi.correct", "lemmas lsnd_correct = lsnd.correct", "lemmas lss_correct = lss.correct", "lemmas ts_correct = ts.correct", "lemmas tm_correct = tm.correct", "lemmas ias_correct = ias.correct", "lemmas iam_correct = iam.correct", "lemmas ahs_correct = ahs.correct", "lemmas ahm_correct = ahm.correct", "lemmas bino_correct = bino.correct", "lemmas fifo_correct = fifo.correct", "lemmas ft_correct = ft.correct", "lemmas alprioi_correct = alprioi.correct", "lemmas aluprioi_correct = aluprioi.correct", "lemmas skew_correct = skew.correct"], "translations": [["", "lemma iteratei_rule_P:\n    \"\\<lbrakk>\n      invar S;\n      I (\\<alpha> S) \\<sigma>0;\n      !!x it \\<sigma>. \\<lbrakk> c \\<sigma>; x \\<in> it; it \\<subseteq> \\<alpha> S; I it \\<sigma> \\<rbrakk> \\<Longrightarrow> I (it - {x}) (f x \\<sigma>);\n      !!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>;\n      !!\\<sigma> it. \\<lbrakk> it \\<subseteq> \\<alpha> S; it \\<noteq> {}; \\<not> c \\<sigma>; I it \\<sigma> \\<rbrakk> \\<Longrightarrow> P \\<sigma>\n    \\<rbrakk> \\<Longrightarrow> P (iteratei S c f \\<sigma>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar S; I (\\<alpha> S) \\<sigma>0;\n     \\<And>x it \\<sigma>.\n        \\<lbrakk>c \\<sigma>; x \\<in> it; it \\<subseteq> \\<alpha> S;\n         I it \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> I (it - {x}) (f x \\<sigma>);\n     \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>;\n     \\<And>\\<sigma> it.\n        \\<lbrakk>it \\<subseteq> \\<alpha> S; it \\<noteq> {};\n         \\<not> c \\<sigma>; I it \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> P (iteratei S c f \\<sigma>0)", "apply (rule set_iterator_rule_P [OF iteratei_rule, of S I \\<sigma>0 c f P])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>invar S; I (\\<alpha> S) \\<sigma>0;\n     \\<And>x it \\<sigma>.\n        \\<lbrakk>c \\<sigma>; x \\<in> it; it \\<subseteq> \\<alpha> S;\n         I it \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> I (it - {x}) (f x \\<sigma>);\n     \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>;\n     \\<And>\\<sigma> it.\n        \\<lbrakk>it \\<subseteq> \\<alpha> S; it \\<noteq> {};\n         \\<not> c \\<sigma>; I it \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> invar S\n 2. \\<lbrakk>invar S; I (\\<alpha> S) \\<sigma>0;\n     \\<And>x it \\<sigma>.\n        \\<lbrakk>c \\<sigma>; x \\<in> it; it \\<subseteq> \\<alpha> S;\n         I it \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> I (it - {x}) (f x \\<sigma>);\n     \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>;\n     \\<And>\\<sigma> it.\n        \\<lbrakk>it \\<subseteq> \\<alpha> S; it \\<noteq> {};\n         \\<not> c \\<sigma>; I it \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> I (\\<alpha> S) \\<sigma>0\n 3. \\<And>Sa \\<sigma> x.\n       \\<lbrakk>invar S; I (\\<alpha> S) \\<sigma>0;\n        \\<And>x it \\<sigma>.\n           \\<lbrakk>c \\<sigma>; x \\<in> it; it \\<subseteq> \\<alpha> S;\n            I it \\<sigma>\\<rbrakk>\n           \\<Longrightarrow> I (it - {x}) (f x \\<sigma>);\n        \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>;\n        \\<And>\\<sigma> it.\n           \\<lbrakk>it \\<subseteq> \\<alpha> S; it \\<noteq> {};\n            \\<not> c \\<sigma>; I it \\<sigma>\\<rbrakk>\n           \\<Longrightarrow> P \\<sigma>;\n        c \\<sigma>; x \\<in> Sa; I Sa \\<sigma>;\n        Sa \\<subseteq> \\<alpha> S\\<rbrakk>\n       \\<Longrightarrow> I (Sa - {x}) (f x \\<sigma>)\n 4. \\<And>\\<sigma>.\n       \\<lbrakk>invar S; I (\\<alpha> S) \\<sigma>0;\n        \\<And>x it \\<sigma>.\n           \\<lbrakk>c \\<sigma>; x \\<in> it; it \\<subseteq> \\<alpha> S;\n            I it \\<sigma>\\<rbrakk>\n           \\<Longrightarrow> I (it - {x}) (f x \\<sigma>);\n        \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>;\n        \\<And>\\<sigma> it.\n           \\<lbrakk>it \\<subseteq> \\<alpha> S; it \\<noteq> {};\n            \\<not> c \\<sigma>; I it \\<sigma>\\<rbrakk>\n           \\<Longrightarrow> P \\<sigma>;\n        I {} \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>\n 5. \\<And>\\<sigma> Sa.\n       \\<lbrakk>invar S; I (\\<alpha> S) \\<sigma>0;\n        \\<And>x it \\<sigma>.\n           \\<lbrakk>c \\<sigma>; x \\<in> it; it \\<subseteq> \\<alpha> S;\n            I it \\<sigma>\\<rbrakk>\n           \\<Longrightarrow> I (it - {x}) (f x \\<sigma>);\n        \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>;\n        \\<And>\\<sigma> it.\n           \\<lbrakk>it \\<subseteq> \\<alpha> S; it \\<noteq> {};\n            \\<not> c \\<sigma>; I it \\<sigma>\\<rbrakk>\n           \\<Longrightarrow> P \\<sigma>;\n        Sa \\<subseteq> \\<alpha> S; Sa \\<noteq> {}; \\<not> c \\<sigma>;\n        I Sa \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iteratei_rule_insert_P:\n    \"\\<lbrakk>\n      invar S;\n      I {} \\<sigma>0;\n      !!x it \\<sigma>. \\<lbrakk> c \\<sigma>; x \\<in> \\<alpha> S - it; it \\<subseteq> \\<alpha> S; I it \\<sigma> \\<rbrakk> \\<Longrightarrow> I (insert x it) (f x \\<sigma>);\n      !!\\<sigma>. I (\\<alpha> S) \\<sigma> \\<Longrightarrow> P \\<sigma>;\n      !!\\<sigma> it. \\<lbrakk> it \\<subseteq> \\<alpha> S; it \\<noteq> \\<alpha> S; \\<not> c \\<sigma>; I it \\<sigma> \\<rbrakk> \\<Longrightarrow> P \\<sigma>\n    \\<rbrakk> \\<Longrightarrow> P (iteratei S c f \\<sigma>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar S; I {} \\<sigma>0;\n     \\<And>x it \\<sigma>.\n        \\<lbrakk>c \\<sigma>; x \\<in> \\<alpha> S - it;\n         it \\<subseteq> \\<alpha> S; I it \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> I (insert x it) (f x \\<sigma>);\n     \\<And>\\<sigma>. I (\\<alpha> S) \\<sigma> \\<Longrightarrow> P \\<sigma>;\n     \\<And>\\<sigma> it.\n        \\<lbrakk>it \\<subseteq> \\<alpha> S; it \\<noteq> \\<alpha> S;\n         \\<not> c \\<sigma>; I it \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> P (iteratei S c f \\<sigma>0)", "apply (rule set_iterator_rule_insert_P [OF iteratei_rule, of S I \\<sigma>0 c f P])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>invar S; I {} \\<sigma>0;\n     \\<And>x it \\<sigma>.\n        \\<lbrakk>c \\<sigma>; x \\<in> \\<alpha> S - it;\n         it \\<subseteq> \\<alpha> S; I it \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> I (insert x it) (f x \\<sigma>);\n     \\<And>\\<sigma>. I (\\<alpha> S) \\<sigma> \\<Longrightarrow> P \\<sigma>;\n     \\<And>\\<sigma> it.\n        \\<lbrakk>it \\<subseteq> \\<alpha> S; it \\<noteq> \\<alpha> S;\n         \\<not> c \\<sigma>; I it \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> invar S\n 2. \\<lbrakk>invar S; I {} \\<sigma>0;\n     \\<And>x it \\<sigma>.\n        \\<lbrakk>c \\<sigma>; x \\<in> \\<alpha> S - it;\n         it \\<subseteq> \\<alpha> S; I it \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> I (insert x it) (f x \\<sigma>);\n     \\<And>\\<sigma>. I (\\<alpha> S) \\<sigma> \\<Longrightarrow> P \\<sigma>;\n     \\<And>\\<sigma> it.\n        \\<lbrakk>it \\<subseteq> \\<alpha> S; it \\<noteq> \\<alpha> S;\n         \\<not> c \\<sigma>; I it \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> I {} \\<sigma>0\n 3. \\<And>Sa \\<sigma> x.\n       \\<lbrakk>invar S; I {} \\<sigma>0;\n        \\<And>x it \\<sigma>.\n           \\<lbrakk>c \\<sigma>; x \\<in> \\<alpha> S - it;\n            it \\<subseteq> \\<alpha> S; I it \\<sigma>\\<rbrakk>\n           \\<Longrightarrow> I (insert x it) (f x \\<sigma>);\n        \\<And>\\<sigma>.\n           I (\\<alpha> S) \\<sigma> \\<Longrightarrow> P \\<sigma>;\n        \\<And>\\<sigma> it.\n           \\<lbrakk>it \\<subseteq> \\<alpha> S; it \\<noteq> \\<alpha> S;\n            \\<not> c \\<sigma>; I it \\<sigma>\\<rbrakk>\n           \\<Longrightarrow> P \\<sigma>;\n        c \\<sigma>; x \\<in> \\<alpha> S - Sa; I Sa \\<sigma>;\n        Sa \\<subseteq> \\<alpha> S\\<rbrakk>\n       \\<Longrightarrow> I (insert x Sa) (f x \\<sigma>)\n 4. \\<And>\\<sigma>.\n       \\<lbrakk>invar S; I {} \\<sigma>0;\n        \\<And>x it \\<sigma>.\n           \\<lbrakk>c \\<sigma>; x \\<in> \\<alpha> S - it;\n            it \\<subseteq> \\<alpha> S; I it \\<sigma>\\<rbrakk>\n           \\<Longrightarrow> I (insert x it) (f x \\<sigma>);\n        \\<And>\\<sigma>.\n           I (\\<alpha> S) \\<sigma> \\<Longrightarrow> P \\<sigma>;\n        \\<And>\\<sigma> it.\n           \\<lbrakk>it \\<subseteq> \\<alpha> S; it \\<noteq> \\<alpha> S;\n            \\<not> c \\<sigma>; I it \\<sigma>\\<rbrakk>\n           \\<Longrightarrow> P \\<sigma>;\n        I (\\<alpha> S) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>\n 5. \\<And>\\<sigma> Sa.\n       \\<lbrakk>invar S; I {} \\<sigma>0;\n        \\<And>x it \\<sigma>.\n           \\<lbrakk>c \\<sigma>; x \\<in> \\<alpha> S - it;\n            it \\<subseteq> \\<alpha> S; I it \\<sigma>\\<rbrakk>\n           \\<Longrightarrow> I (insert x it) (f x \\<sigma>);\n        \\<And>\\<sigma>.\n           I (\\<alpha> S) \\<sigma> \\<Longrightarrow> P \\<sigma>;\n        \\<And>\\<sigma> it.\n           \\<lbrakk>it \\<subseteq> \\<alpha> S; it \\<noteq> \\<alpha> S;\n            \\<not> c \\<sigma>; I it \\<sigma>\\<rbrakk>\n           \\<Longrightarrow> P \\<sigma>;\n        Sa \\<subseteq> \\<alpha> S; Sa \\<noteq> \\<alpha> S;\n        \\<not> c \\<sigma>; I Sa \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Versions without break condition.\\<close>"], ["", "lemma iterate_rule_P:\n    \"\\<lbrakk>\n      invar S;\n      I (\\<alpha> S) \\<sigma>0;\n      !!x it \\<sigma>. \\<lbrakk> x \\<in> it; it \\<subseteq> \\<alpha> S; I it \\<sigma> \\<rbrakk> \\<Longrightarrow> I (it - {x}) (f x \\<sigma>);\n      !!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\n    \\<rbrakk> \\<Longrightarrow> P (iteratei S (\\<lambda>_. True) f \\<sigma>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar S; I (\\<alpha> S) \\<sigma>0;\n     \\<And>x it \\<sigma>.\n        \\<lbrakk>x \\<in> it; it \\<subseteq> \\<alpha> S;\n         I it \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> I (it - {x}) (f x \\<sigma>);\n     \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> P (iteratei S (\\<lambda>_. True) f \\<sigma>0)", "apply (rule set_iterator_no_cond_rule_P [OF iteratei_rule, of S I \\<sigma>0 f P])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>invar S; I (\\<alpha> S) \\<sigma>0;\n     \\<And>x it \\<sigma>.\n        \\<lbrakk>x \\<in> it; it \\<subseteq> \\<alpha> S;\n         I it \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> I (it - {x}) (f x \\<sigma>);\n     \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> invar S\n 2. \\<lbrakk>invar S; I (\\<alpha> S) \\<sigma>0;\n     \\<And>x it \\<sigma>.\n        \\<lbrakk>x \\<in> it; it \\<subseteq> \\<alpha> S;\n         I it \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> I (it - {x}) (f x \\<sigma>);\n     \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> I (\\<alpha> S) \\<sigma>0\n 3. \\<And>Sa \\<sigma> x.\n       \\<lbrakk>invar S; I (\\<alpha> S) \\<sigma>0;\n        \\<And>x it \\<sigma>.\n           \\<lbrakk>x \\<in> it; it \\<subseteq> \\<alpha> S;\n            I it \\<sigma>\\<rbrakk>\n           \\<Longrightarrow> I (it - {x}) (f x \\<sigma>);\n        \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>;\n        x \\<in> Sa; I Sa \\<sigma>; Sa \\<subseteq> \\<alpha> S\\<rbrakk>\n       \\<Longrightarrow> I (Sa - {x}) (f x \\<sigma>)\n 4. \\<And>\\<sigma>.\n       \\<lbrakk>invar S; I (\\<alpha> S) \\<sigma>0;\n        \\<And>x it \\<sigma>.\n           \\<lbrakk>x \\<in> it; it \\<subseteq> \\<alpha> S;\n            I it \\<sigma>\\<rbrakk>\n           \\<Longrightarrow> I (it - {x}) (f x \\<sigma>);\n        \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>;\n        I {} \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iterate_rule_insert_P:\n    \"\\<lbrakk>\n      invar S;\n      I {} \\<sigma>0;\n      !!x it \\<sigma>. \\<lbrakk> x \\<in> \\<alpha> S - it; it \\<subseteq> \\<alpha> S; I it \\<sigma> \\<rbrakk> \\<Longrightarrow> I (insert x it) (f x \\<sigma>);\n      !!\\<sigma>. I (\\<alpha> S) \\<sigma> \\<Longrightarrow> P \\<sigma>\n    \\<rbrakk> \\<Longrightarrow> P (iteratei S (\\<lambda>_. True) f \\<sigma>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar S; I {} \\<sigma>0;\n     \\<And>x it \\<sigma>.\n        \\<lbrakk>x \\<in> \\<alpha> S - it; it \\<subseteq> \\<alpha> S;\n         I it \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> I (insert x it) (f x \\<sigma>);\n     \\<And>\\<sigma>.\n        I (\\<alpha> S) \\<sigma> \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> P (iteratei S (\\<lambda>_. True) f \\<sigma>0)", "apply (rule set_iterator_no_cond_rule_insert_P [OF iteratei_rule, of S I \\<sigma>0 f P])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>invar S; I {} \\<sigma>0;\n     \\<And>x it \\<sigma>.\n        \\<lbrakk>x \\<in> \\<alpha> S - it; it \\<subseteq> \\<alpha> S;\n         I it \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> I (insert x it) (f x \\<sigma>);\n     \\<And>\\<sigma>.\n        I (\\<alpha> S) \\<sigma> \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> invar S\n 2. \\<lbrakk>invar S; I {} \\<sigma>0;\n     \\<And>x it \\<sigma>.\n        \\<lbrakk>x \\<in> \\<alpha> S - it; it \\<subseteq> \\<alpha> S;\n         I it \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> I (insert x it) (f x \\<sigma>);\n     \\<And>\\<sigma>.\n        I (\\<alpha> S) \\<sigma> \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> I {} \\<sigma>0\n 3. \\<And>Sa \\<sigma> x.\n       \\<lbrakk>invar S; I {} \\<sigma>0;\n        \\<And>x it \\<sigma>.\n           \\<lbrakk>x \\<in> \\<alpha> S - it; it \\<subseteq> \\<alpha> S;\n            I it \\<sigma>\\<rbrakk>\n           \\<Longrightarrow> I (insert x it) (f x \\<sigma>);\n        \\<And>\\<sigma>.\n           I (\\<alpha> S) \\<sigma> \\<Longrightarrow> P \\<sigma>;\n        x \\<in> \\<alpha> S - Sa; I Sa \\<sigma>;\n        Sa \\<subseteq> \\<alpha> S\\<rbrakk>\n       \\<Longrightarrow> I (insert x Sa) (f x \\<sigma>)\n 4. \\<And>\\<sigma>.\n       \\<lbrakk>invar S; I {} \\<sigma>0;\n        \\<And>x it \\<sigma>.\n           \\<lbrakk>x \\<in> \\<alpha> S - it; it \\<subseteq> \\<alpha> S;\n            I it \\<sigma>\\<rbrakk>\n           \\<Longrightarrow> I (insert x it) (f x \\<sigma>);\n        \\<And>\\<sigma>.\n           I (\\<alpha> S) \\<sigma> \\<Longrightarrow> P \\<sigma>;\n        I (\\<alpha> S) \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "lemma set_iteratei_I :\nassumes \"\\<And>s. invar s \\<Longrightarrow> set_iterator (iti s) (\\<alpha> s)\"\nshows \"set_iteratei \\<alpha> invar iti\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iteratei \\<alpha> invar iti", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s. invar s \\<Longrightarrow> finite (\\<alpha> s)\n 2. \\<And>S. invar S \\<Longrightarrow> set_iterator (iti S) (\\<alpha> S)", "fix s"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s. invar s \\<Longrightarrow> finite (\\<alpha> s)\n 2. \\<And>S. invar S \\<Longrightarrow> set_iterator (iti S) (\\<alpha> S)", "assume invar_s: \"invar s\""], ["proof (state)\nthis:\n  invar s\n\ngoal (2 subgoals):\n 1. \\<And>s. invar s \\<Longrightarrow> finite (\\<alpha> s)\n 2. \\<And>S. invar S \\<Longrightarrow> set_iterator (iti S) (\\<alpha> S)", "from assms(1)[OF invar_s]"], ["proof (chain)\npicking this:\n  set_iterator (iti s) (\\<alpha> s)", "show it_OK: \"set_iterator (iti s) (\\<alpha> s)\""], ["proof (prove)\nusing this:\n  set_iterator (iti s) (\\<alpha> s)\n\ngoal (1 subgoal):\n 1. set_iterator (iti s) (\\<alpha> s)", "."], ["proof (state)\nthis:\n  set_iterator (iti s) (\\<alpha> s)\n\ngoal (1 subgoal):\n 1. \\<And>s. invar s \\<Longrightarrow> finite (\\<alpha> s)", "from set_iterator_genord.finite_S0 [OF it_OK[unfolded set_iterator_def]]"], ["proof (chain)\npicking this:\n  finite (\\<alpha> s)", "show \"finite (\\<alpha> s)\""], ["proof (prove)\nusing this:\n  finite (\\<alpha> s)\n\ngoal (1 subgoal):\n 1. finite (\\<alpha> s)", "."], ["proof (state)\nthis:\n  finite (\\<alpha> s)\n\ngoal:\nNo subgoals!", "qed"], ["", "locale set_iterateoi = ordered_finite_set \\<alpha> invar\n    for \\<alpha> :: \"'s \\<Rightarrow> ('u::linorder) set\" and invar\n    +\n    fixes iterateoi :: \"'s \\<Rightarrow> ('u,'\\<sigma>) set_iterator\"\n    assumes iterateoi_rule: \n      \"invar s \\<Longrightarrow> set_iterator_linord (iterateoi s) (\\<alpha> s)\"\n  begin"], ["", "lemma iterateoi_rule_P[case_names minv inv0 inv_pres i_complete i_inter]:\n      assumes MINV: \"invar m\"\n      assumes I0: \"I (\\<alpha> m) \\<sigma>0\"\n      assumes IP: \"!!k it \\<sigma>. \\<lbrakk> \n        c \\<sigma>; \n        k \\<in> it; \n        \\<forall>j\\<in>it. k\\<le>j; \n        \\<forall>j\\<in>\\<alpha> m - it. j\\<le>k; \n        it \\<subseteq> \\<alpha> m; \n        I it \\<sigma> \n      \\<rbrakk> \\<Longrightarrow> I (it - {k}) (f k \\<sigma>)\"\n      assumes IF: \"!!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n      assumes II: \"!!\\<sigma> it. \\<lbrakk> \n        it \\<subseteq> \\<alpha> m; \n        it \\<noteq> {}; \n        \\<not> c \\<sigma>; \n        I it \\<sigma>; \n        \\<forall>k\\<in>it. \\<forall>j\\<in>\\<alpha> m - it. j\\<le>k \n      \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n      shows \"P (iterateoi m c f \\<sigma>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (iterateoi m c f \\<sigma>0)", "using set_iterator_linord_rule_P [OF iterateoi_rule, OF MINV, of I \\<sigma>0 c f P,\n       OF I0 _ IF] IP II"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>S \\<sigma> x.\n              \\<lbrakk>c \\<sigma>; x \\<in> S; I S \\<sigma>;\n               S \\<subseteq> \\<alpha> m;\n               \\<And>x'.\n                  x' \\<in> \\<alpha> m - S \\<Longrightarrow> x' \\<le> x;\n               \\<And>x'. x' \\<in> S \\<Longrightarrow> x \\<le> x'\\<rbrakk>\n              \\<Longrightarrow> I (S - {x}) (f x \\<sigma>);\n   \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> I {} \\<sigma>;\n   \\<And>\\<sigma> S.\n      \\<lbrakk>S \\<subseteq> \\<alpha> m; S \\<noteq> {};\n       \\<And>x x'.\n          \\<lbrakk>x \\<in> S; x' \\<in> \\<alpha> m - S\\<rbrakk>\n          \\<Longrightarrow> x' \\<le> x;\n       \\<not> c \\<sigma>; I S \\<sigma>\\<rbrakk>\n      \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n  \\<Longrightarrow> P (iterateoi m c f \\<sigma>0)\n  \\<lbrakk>c ?\\<sigma>1; ?k1 \\<in> ?it1; \\<forall>j\\<in>?it1. ?k1 \\<le> j;\n   \\<forall>j\\<in>\\<alpha> m - ?it1. j \\<le> ?k1;\n   ?it1 \\<subseteq> \\<alpha> m; I ?it1 ?\\<sigma>1\\<rbrakk>\n  \\<Longrightarrow> I (?it1 - {?k1}) (f ?k1 ?\\<sigma>1)\n  \\<lbrakk>?it1 \\<subseteq> \\<alpha> m; ?it1 \\<noteq> {};\n   \\<not> c ?\\<sigma>1; I ?it1 ?\\<sigma>1;\n   \\<forall>k\\<in>?it1. \\<forall>j\\<in>\\<alpha> m - ?it1. j \\<le> k\\<rbrakk>\n  \\<Longrightarrow> P ?\\<sigma>1\n\ngoal (1 subgoal):\n 1. P (iterateoi m c f \\<sigma>0)", "by simp"], ["", "lemma iterateo_rule_P[case_names minv inv0 inv_pres i_complete]: \n      assumes MINV: \"invar m\"\n      assumes I0: \"I ((\\<alpha> m)) \\<sigma>0\"\n      assumes IP: \"!!k it \\<sigma>. \\<lbrakk> k \\<in> it; \\<forall>j\\<in>it. k\\<le>j; \\<forall>j\\<in>(\\<alpha> m) - it. j\\<le>k; it \\<subseteq> (\\<alpha> m); I it \\<sigma> \\<rbrakk> \n                  \\<Longrightarrow> I (it - {k}) (f k \\<sigma>)\"\n      assumes IF: \"!!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n    shows \"P (iterateoi m (\\<lambda>_. True) f \\<sigma>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (iterateoi m (\\<lambda>_. True) f \\<sigma>0)", "apply (rule iterateoi_rule_P [where I = I])"], ["proof (prove)\ngoal (5 subgoals):\n 1. invar m\n 2. I (\\<alpha> m) \\<sigma>0\n 3. \\<And>k it \\<sigma>.\n       \\<lbrakk>True; k \\<in> it; \\<forall>j\\<in>it. k \\<le> j;\n        \\<forall>j\\<in>\\<alpha> m - it. j \\<le> k;\n        it \\<subseteq> \\<alpha> m; I it \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I (it - {k}) (f k \\<sigma>)\n 4. \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\n 5. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> \\<alpha> m; it \\<noteq> {}; \\<not> True;\n        I it \\<sigma>;\n        \\<forall>k\\<in>it.\n           \\<forall>j\\<in>\\<alpha> m - it. j \\<le> k\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "apply (simp_all add: assms)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "lemma set_iterateoi_I :\n  assumes \"\\<And>s. invar s \\<Longrightarrow> set_iterator_linord (itoi s) (\\<alpha> s)\"\n  shows \"set_iterateoi \\<alpha> invar itoi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterateoi \\<alpha> invar itoi", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s. invar s \\<Longrightarrow> finite (\\<alpha> s)\n 2. \\<And>s.\n       invar s \\<Longrightarrow> set_iterator_linord (itoi s) (\\<alpha> s)", "fix s"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s. invar s \\<Longrightarrow> finite (\\<alpha> s)\n 2. \\<And>s.\n       invar s \\<Longrightarrow> set_iterator_linord (itoi s) (\\<alpha> s)", "assume invar_s: \"invar s\""], ["proof (state)\nthis:\n  invar s\n\ngoal (2 subgoals):\n 1. \\<And>s. invar s \\<Longrightarrow> finite (\\<alpha> s)\n 2. \\<And>s.\n       invar s \\<Longrightarrow> set_iterator_linord (itoi s) (\\<alpha> s)", "from assms(1)[OF invar_s]"], ["proof (chain)\npicking this:\n  set_iterator_linord (itoi s) (\\<alpha> s)", "show it_OK: \"set_iterator_linord (itoi s) (\\<alpha> s)\""], ["proof (prove)\nusing this:\n  set_iterator_linord (itoi s) (\\<alpha> s)\n\ngoal (1 subgoal):\n 1. set_iterator_linord (itoi s) (\\<alpha> s)", "."], ["proof (state)\nthis:\n  set_iterator_linord (itoi s) (\\<alpha> s)\n\ngoal (1 subgoal):\n 1. \\<And>s. invar s \\<Longrightarrow> finite (\\<alpha> s)", "from set_iterator_genord.finite_S0 [OF it_OK[unfolded set_iterator_linord_def]]"], ["proof (chain)\npicking this:\n  finite (\\<alpha> s)", "show \"finite (\\<alpha> s)\""], ["proof (prove)\nusing this:\n  finite (\\<alpha> s)\n\ngoal (1 subgoal):\n 1. finite (\\<alpha> s)", "by simp"], ["proof (state)\nthis:\n  finite (\\<alpha> s)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* Deprecated *)"], ["", "locale set_reverse_iterateoi = ordered_finite_set \\<alpha> invar \n    for \\<alpha> :: \"'s \\<Rightarrow> ('u::linorder) set\" and invar\n    +\n    fixes reverse_iterateoi :: \"'s \\<Rightarrow> ('u,'\\<sigma>) set_iterator\"\n    assumes reverse_iterateoi_rule: \"\n      invar m \\<Longrightarrow> set_iterator_rev_linord (reverse_iterateoi m) (\\<alpha> m)\" \n  begin"], ["", "lemma reverse_iterateoi_rule_P[case_names minv inv0 inv_pres i_complete i_inter]:\n      assumes MINV: \"invar m\"\n      assumes I0: \"I ((\\<alpha> m)) \\<sigma>0\"\n      assumes IP: \"!!k it \\<sigma>. \\<lbrakk> \n        c \\<sigma>; \n        k \\<in> it; \n        \\<forall>j\\<in>it. k\\<ge>j; \n        \\<forall>j\\<in>(\\<alpha> m) - it. j\\<ge>k; \n        it \\<subseteq> (\\<alpha> m); \n        I it \\<sigma> \n      \\<rbrakk> \\<Longrightarrow> I (it - {k}) (f k \\<sigma>)\"\n      assumes IF: \"!!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n      assumes II: \"!!\\<sigma> it. \\<lbrakk> \n        it \\<subseteq> (\\<alpha> m); \n        it \\<noteq> {}; \n        \\<not> c \\<sigma>; \n        I it \\<sigma>; \n        \\<forall>k\\<in>it. \\<forall>j\\<in>(\\<alpha> m) - it. j\\<ge>k \n      \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n    shows \"P (reverse_iterateoi m c f \\<sigma>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (reverse_iterateoi m c f \\<sigma>0)", "using set_iterator_rev_linord_rule_P [OF reverse_iterateoi_rule, OF MINV, of I \\<sigma>0 c f P,\n       OF I0 _ IF] IP II"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>S \\<sigma> x.\n              \\<lbrakk>c \\<sigma>; x \\<in> S; I S \\<sigma>;\n               S \\<subseteq> \\<alpha> m;\n               \\<And>x'.\n                  x' \\<in> \\<alpha> m - S \\<Longrightarrow> x \\<le> x';\n               \\<And>x'. x' \\<in> S \\<Longrightarrow> x' \\<le> x\\<rbrakk>\n              \\<Longrightarrow> I (S - {x}) (f x \\<sigma>);\n   \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> I {} \\<sigma>;\n   \\<And>\\<sigma> S.\n      \\<lbrakk>S \\<subseteq> \\<alpha> m; S \\<noteq> {};\n       \\<And>x x'.\n          \\<lbrakk>x \\<in> S; x' \\<in> \\<alpha> m - S\\<rbrakk>\n          \\<Longrightarrow> x \\<le> x';\n       \\<not> c \\<sigma>; I S \\<sigma>\\<rbrakk>\n      \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n  \\<Longrightarrow> P (reverse_iterateoi m c f \\<sigma>0)\n  \\<lbrakk>c ?\\<sigma>1; ?k1 \\<in> ?it1; \\<forall>j\\<in>?it1. j \\<le> ?k1;\n   \\<forall>j\\<in>\\<alpha> m - ?it1. ?k1 \\<le> j;\n   ?it1 \\<subseteq> \\<alpha> m; I ?it1 ?\\<sigma>1\\<rbrakk>\n  \\<Longrightarrow> I (?it1 - {?k1}) (f ?k1 ?\\<sigma>1)\n  \\<lbrakk>?it1 \\<subseteq> \\<alpha> m; ?it1 \\<noteq> {};\n   \\<not> c ?\\<sigma>1; I ?it1 ?\\<sigma>1;\n   \\<forall>k\\<in>?it1. \\<forall>j\\<in>\\<alpha> m - ?it1. k \\<le> j\\<rbrakk>\n  \\<Longrightarrow> P ?\\<sigma>1\n\ngoal (1 subgoal):\n 1. P (reverse_iterateoi m c f \\<sigma>0)", "by simp"], ["", "lemma reverse_iterateo_rule_P[case_names minv inv0 inv_pres i_complete]:\n      assumes MINV: \"invar m\"\n      assumes I0: \"I ((\\<alpha> m)) \\<sigma>0\"\n      assumes IP: \"!!k it \\<sigma>. \\<lbrakk> \n        k \\<in> it; \n        \\<forall>j\\<in>it. k\\<ge>j; \n        \\<forall>j\\<in> (\\<alpha> m) - it. j\\<ge>k; \n        it \\<subseteq> (\\<alpha> m); \n        I it \\<sigma> \n      \\<rbrakk> \\<Longrightarrow> I (it - {k}) (f k \\<sigma>)\"\n      assumes IF: \"!!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n    shows \"P (reverse_iterateoi m (\\<lambda>_. True) f \\<sigma>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (reverse_iterateoi m (\\<lambda>_. True) f \\<sigma>0)", "apply (rule reverse_iterateoi_rule_P [where I = I])"], ["proof (prove)\ngoal (5 subgoals):\n 1. invar m\n 2. I (\\<alpha> m) \\<sigma>0\n 3. \\<And>k it \\<sigma>.\n       \\<lbrakk>True; k \\<in> it; \\<forall>j\\<in>it. j \\<le> k;\n        \\<forall>j\\<in>\\<alpha> m - it. k \\<le> j;\n        it \\<subseteq> \\<alpha> m; I it \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> I (it - {k}) (f k \\<sigma>)\n 4. \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\n 5. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> \\<alpha> m; it \\<noteq> {}; \\<not> True;\n        I it \\<sigma>;\n        \\<forall>k\\<in>it.\n           \\<forall>j\\<in>\\<alpha> m - it. k \\<le> j\\<rbrakk>\n       \\<Longrightarrow> P \\<sigma>", "apply (simp_all add: assms)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "lemma set_reverse_iterateoi_I :\n  assumes \"\\<And>s. invar s \\<Longrightarrow> set_iterator_rev_linord (itoi s) (\\<alpha> s)\"\n  shows \"set_reverse_iterateoi \\<alpha> invar itoi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_reverse_iterateoi \\<alpha> invar itoi", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s. invar s \\<Longrightarrow> finite (\\<alpha> s)\n 2. \\<And>m.\n       invar m \\<Longrightarrow>\n       set_iterator_rev_linord (itoi m) (\\<alpha> m)", "fix s"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s. invar s \\<Longrightarrow> finite (\\<alpha> s)\n 2. \\<And>m.\n       invar m \\<Longrightarrow>\n       set_iterator_rev_linord (itoi m) (\\<alpha> m)", "assume invar_s: \"invar s\""], ["proof (state)\nthis:\n  invar s\n\ngoal (2 subgoals):\n 1. \\<And>s. invar s \\<Longrightarrow> finite (\\<alpha> s)\n 2. \\<And>m.\n       invar m \\<Longrightarrow>\n       set_iterator_rev_linord (itoi m) (\\<alpha> m)", "from assms(1)[OF invar_s]"], ["proof (chain)\npicking this:\n  set_iterator_rev_linord (itoi s) (\\<alpha> s)", "show it_OK: \"set_iterator_rev_linord (itoi s) (\\<alpha> s)\""], ["proof (prove)\nusing this:\n  set_iterator_rev_linord (itoi s) (\\<alpha> s)\n\ngoal (1 subgoal):\n 1. set_iterator_rev_linord (itoi s) (\\<alpha> s)", "."], ["proof (state)\nthis:\n  set_iterator_rev_linord (itoi s) (\\<alpha> s)\n\ngoal (1 subgoal):\n 1. \\<And>s. invar s \\<Longrightarrow> finite (\\<alpha> s)", "from set_iterator_genord.finite_S0 [OF it_OK[unfolded set_iterator_rev_linord_def]]"], ["proof (chain)\npicking this:\n  finite (\\<alpha> s)", "show \"finite (\\<alpha> s)\""], ["proof (prove)\nusing this:\n  finite (\\<alpha> s)\n\ngoal (1 subgoal):\n 1. finite (\\<alpha> s)", "by simp"], ["proof (state)\nthis:\n  finite (\\<alpha> s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in poly_set_iteratei) v1_iteratei_impl: \n    \"set_iteratei \\<alpha> invar iteratei\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iteratei \\<alpha> invar iteratei", "by unfold_locales (rule iteratei_correct)"], ["", "lemma (in poly_set_iterateoi) v1_iterateoi_impl: \n    \"set_iterateoi \\<alpha> invar iterateoi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterateoi \\<alpha> invar iterateoi", "by unfold_locales (rule iterateoi_correct)"], ["", "lemma (in poly_set_rev_iterateoi) v1_reverse_iterateoi_impl: \n    \"set_reverse_iterateoi \\<alpha> invar rev_iterateoi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_reverse_iterateoi \\<alpha> invar reverse_iterateoi", "by unfold_locales (rule rev_iterateoi_correct)"], ["", "declare (in poly_set_iteratei) v1_iteratei_impl[locale_witness_add]"], ["", "declare (in poly_set_iterateoi) v1_iterateoi_impl[locale_witness_add]"], ["", "declare (in poly_set_rev_iterateoi) \n    v1_reverse_iterateoi_impl[locale_witness_add]"], ["", "(* Commented out, as it causes strange errors of the kind:\n    Type variable \"?'a\" has two distinct sorts\n\n  sublocale poly_set_iteratei < v1_iteratei: set_iteratei \\<alpha> invar iteratei\n    by (rule v1_iteratei_impl)\n  sublocale poly_set_iterateoi < v1_iteratei: set_iterateoi \\<alpha> invar iterateoi\n    by (rule v1_iterateoi_impl)\n  sublocale poly_set_rev_iterateoi \n    < v1_iteratei!: set_reverse_iterateoi \\<alpha> invar rev_iterateoi\n    by (rule v1_reverse_iterateoi_impl)\n    *)"], ["", "subsubsection \"Map\""], ["", "locale map_iteratei = finite_map \\<alpha> invar for \\<alpha> :: \"'s \\<Rightarrow> 'u \\<rightharpoonup> 'v\" and invar +\n  fixes iteratei :: \"'s \\<Rightarrow> ('u \\<times> 'v,'\\<sigma>) set_iterator\"\n\n  assumes iteratei_rule: \"invar m \\<Longrightarrow> map_iterator (iteratei m) (\\<alpha> m)\"\nbegin"], ["", "lemma iteratei_rule_P:\n    assumes \"invar m\"\n        and I0: \"I (dom (\\<alpha> m)) \\<sigma>0\"\n        and IP: \"!!k v it \\<sigma>. \\<lbrakk> c \\<sigma>; k \\<in> it; \\<alpha> m k = Some v; it \\<subseteq> dom (\\<alpha> m); I it \\<sigma> \\<rbrakk> \n                    \\<Longrightarrow> I (it - {k}) (f (k, v) \\<sigma>)\"\n        and IF: \"!!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n        and II: \"!!\\<sigma> it. \\<lbrakk> it \\<subseteq> dom (\\<alpha> m); it \\<noteq> {}; \\<not> c \\<sigma>; I it \\<sigma> \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n    shows \"P (iteratei m c f \\<sigma>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (iteratei m c f \\<sigma>0)", "using map_iterator_rule_P [OF iteratei_rule, of m I \\<sigma>0 c f P]"], ["proof (prove)\nusing this:\n  \\<lbrakk>invar m; I (dom (\\<alpha> m)) \\<sigma>0;\n   \\<And>k v it \\<sigma>.\n      \\<lbrakk>c \\<sigma>; k \\<in> it; \\<alpha> m k = Some v;\n       it \\<subseteq> dom (\\<alpha> m); I it \\<sigma>\\<rbrakk>\n      \\<Longrightarrow> I (it - {k}) (f (k, v) \\<sigma>);\n   \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>;\n   \\<And>\\<sigma> it.\n      \\<lbrakk>it \\<subseteq> dom (\\<alpha> m); it \\<noteq> {};\n       \\<not> c \\<sigma>; I it \\<sigma>\\<rbrakk>\n      \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n  \\<Longrightarrow> P (iteratei m c f \\<sigma>0)\n\ngoal (1 subgoal):\n 1. P (iteratei m c f \\<sigma>0)", "by (simp_all add: assms)"], ["", "lemma iteratei_rule_insert_P:\n    assumes  \n      \"invar m\" \n      \"I {} \\<sigma>0\"\n      \"!!k v it \\<sigma>. \\<lbrakk> c \\<sigma>; k \\<in> (dom (\\<alpha> m) - it); \\<alpha> m k = Some v; it \\<subseteq> dom (\\<alpha> m); I it \\<sigma> \\<rbrakk> \n          \\<Longrightarrow> I (insert k it) (f (k, v) \\<sigma>)\"\n      \"!!\\<sigma>. I (dom (\\<alpha> m)) \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n      \"!!\\<sigma> it. \\<lbrakk> it \\<subseteq> dom (\\<alpha> m); it \\<noteq> dom (\\<alpha> m); \n               \\<not> (c \\<sigma>); \n               I it \\<sigma> \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n    shows \"P (iteratei m c f \\<sigma>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (iteratei m c f \\<sigma>0)", "using map_iterator_rule_insert_P [OF iteratei_rule, of m I \\<sigma>0 c f P]"], ["proof (prove)\nusing this:\n  \\<lbrakk>invar m; I {} \\<sigma>0;\n   \\<And>k v it \\<sigma>.\n      \\<lbrakk>c \\<sigma>; k \\<in> dom (\\<alpha> m) - it;\n       \\<alpha> m k = Some v; it \\<subseteq> dom (\\<alpha> m);\n       I it \\<sigma>\\<rbrakk>\n      \\<Longrightarrow> I (insert k it) (f (k, v) \\<sigma>);\n   \\<And>\\<sigma>.\n      I (dom (\\<alpha> m)) \\<sigma> \\<Longrightarrow> P \\<sigma>;\n   \\<And>\\<sigma> it.\n      \\<lbrakk>it \\<subseteq> dom (\\<alpha> m);\n       it \\<noteq> dom (\\<alpha> m); \\<not> c \\<sigma>;\n       I it \\<sigma>\\<rbrakk>\n      \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n  \\<Longrightarrow> P (iteratei m c f \\<sigma>0)\n\ngoal (1 subgoal):\n 1. P (iteratei m c f \\<sigma>0)", "by (simp_all add: assms)"], ["", "lemma iterate_rule_P:\n    \"\\<lbrakk>\n      invar m;\n      I (dom (\\<alpha> m)) \\<sigma>0;\n      !!k v it \\<sigma>. \\<lbrakk> k \\<in> it; \\<alpha> m k = Some v; it \\<subseteq> dom (\\<alpha> m); I it \\<sigma> \\<rbrakk> \n                  \\<Longrightarrow> I (it - {k}) (f (k, v) \\<sigma>);\n      !!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\n    \\<rbrakk> \\<Longrightarrow> P (iteratei m (\\<lambda>_. True) f \\<sigma>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar m; I (dom (\\<alpha> m)) \\<sigma>0;\n     \\<And>k v it \\<sigma>.\n        \\<lbrakk>k \\<in> it; \\<alpha> m k = Some v;\n         it \\<subseteq> dom (\\<alpha> m); I it \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> I (it - {k}) (f (k, v) \\<sigma>);\n     \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> P (iteratei m (\\<lambda>_. True) f \\<sigma>0)", "using iteratei_rule_P [of m I \\<sigma>0 \"\\<lambda>_. True\" f P]"], ["proof (prove)\nusing this:\n  \\<lbrakk>invar m; I (dom (\\<alpha> m)) \\<sigma>0;\n   \\<And>k v it \\<sigma>.\n      \\<lbrakk>True; k \\<in> it; \\<alpha> m k = Some v;\n       it \\<subseteq> dom (\\<alpha> m); I it \\<sigma>\\<rbrakk>\n      \\<Longrightarrow> I (it - {k}) (f (k, v) \\<sigma>);\n   \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>;\n   \\<And>\\<sigma> it.\n      \\<lbrakk>it \\<subseteq> dom (\\<alpha> m); it \\<noteq> {}; \\<not> True;\n       I it \\<sigma>\\<rbrakk>\n      \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n  \\<Longrightarrow> P (iteratei m (\\<lambda>_. True) f \\<sigma>0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>invar m; I (dom (\\<alpha> m)) \\<sigma>0;\n     \\<And>k v it \\<sigma>.\n        \\<lbrakk>k \\<in> it; \\<alpha> m k = Some v;\n         it \\<subseteq> dom (\\<alpha> m); I it \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> I (it - {k}) (f (k, v) \\<sigma>);\n     \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> P (iteratei m (\\<lambda>_. True) f \\<sigma>0)", "by fast"], ["", "lemma iterate_rule_insert_P:\n    \"\\<lbrakk>\n      invar m;\n      I {} \\<sigma>0;\n      !!k v it \\<sigma>. \\<lbrakk> k \\<in> (dom (\\<alpha> m) - it); \\<alpha> m k = Some v; it \\<subseteq> dom (\\<alpha> m); I it \\<sigma> \\<rbrakk> \n                  \\<Longrightarrow> I (insert k it) (f (k, v) \\<sigma>);\n      !!\\<sigma>. I (dom (\\<alpha> m)) \\<sigma> \\<Longrightarrow> P \\<sigma>\n    \\<rbrakk> \\<Longrightarrow> P (iteratei m (\\<lambda>_. True) f \\<sigma>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar m; I {} \\<sigma>0;\n     \\<And>k v it \\<sigma>.\n        \\<lbrakk>k \\<in> dom (\\<alpha> m) - it; \\<alpha> m k = Some v;\n         it \\<subseteq> dom (\\<alpha> m); I it \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> I (insert k it) (f (k, v) \\<sigma>);\n     \\<And>\\<sigma>.\n        I (dom (\\<alpha> m)) \\<sigma> \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> P (iteratei m (\\<lambda>_. True) f \\<sigma>0)", "using iteratei_rule_insert_P [of m I \\<sigma>0 \"\\<lambda>_. True\" f P]"], ["proof (prove)\nusing this:\n  \\<lbrakk>invar m; I {} \\<sigma>0;\n   \\<And>k v it \\<sigma>.\n      \\<lbrakk>True; k \\<in> dom (\\<alpha> m) - it; \\<alpha> m k = Some v;\n       it \\<subseteq> dom (\\<alpha> m); I it \\<sigma>\\<rbrakk>\n      \\<Longrightarrow> I (insert k it) (f (k, v) \\<sigma>);\n   \\<And>\\<sigma>.\n      I (dom (\\<alpha> m)) \\<sigma> \\<Longrightarrow> P \\<sigma>;\n   \\<And>\\<sigma> it.\n      \\<lbrakk>it \\<subseteq> dom (\\<alpha> m);\n       it \\<noteq> dom (\\<alpha> m); \\<not> True; I it \\<sigma>\\<rbrakk>\n      \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n  \\<Longrightarrow> P (iteratei m (\\<lambda>_. True) f \\<sigma>0)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>invar m; I {} \\<sigma>0;\n     \\<And>k v it \\<sigma>.\n        \\<lbrakk>k \\<in> dom (\\<alpha> m) - it; \\<alpha> m k = Some v;\n         it \\<subseteq> dom (\\<alpha> m); I it \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> I (insert k it) (f (k, v) \\<sigma>);\n     \\<And>\\<sigma>.\n        I (dom (\\<alpha> m)) \\<sigma> \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> P (iteratei m (\\<lambda>_. True) f \\<sigma>0)", "by fast"], ["", "end"], ["", "lemma map_iteratei_I :\n  assumes \"\\<And>m. invar m \\<Longrightarrow> map_iterator (iti m) (\\<alpha> m)\"\n  shows \"map_iteratei \\<alpha> invar iti\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_iteratei \\<alpha> invar iti", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m. invar m \\<Longrightarrow> finite (dom (\\<alpha> m))\n 2. \\<And>m. invar m \\<Longrightarrow> map_iterator (iti m) (\\<alpha> m)", "fix m"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m. invar m \\<Longrightarrow> finite (dom (\\<alpha> m))\n 2. \\<And>m. invar m \\<Longrightarrow> map_iterator (iti m) (\\<alpha> m)", "assume invar_m: \"invar m\""], ["proof (state)\nthis:\n  invar m\n\ngoal (2 subgoals):\n 1. \\<And>m. invar m \\<Longrightarrow> finite (dom (\\<alpha> m))\n 2. \\<And>m. invar m \\<Longrightarrow> map_iterator (iti m) (\\<alpha> m)", "from assms(1)[OF invar_m]"], ["proof (chain)\npicking this:\n  map_iterator (iti m) (\\<alpha> m)", "show it_OK: \"map_iterator (iti m) (\\<alpha> m)\""], ["proof (prove)\nusing this:\n  map_iterator (iti m) (\\<alpha> m)\n\ngoal (1 subgoal):\n 1. map_iterator (iti m) (\\<alpha> m)", "."], ["proof (state)\nthis:\n  map_iterator (iti m) (\\<alpha> m)\n\ngoal (1 subgoal):\n 1. \\<And>m. invar m \\<Longrightarrow> finite (dom (\\<alpha> m))", "from set_iterator_genord.finite_S0 [OF it_OK[unfolded set_iterator_def]]"], ["proof (chain)\npicking this:\n  finite (map_to_set (\\<alpha> m))", "show \"finite (dom (\\<alpha> m))\""], ["proof (prove)\nusing this:\n  finite (map_to_set (\\<alpha> m))\n\ngoal (1 subgoal):\n 1. finite (dom (\\<alpha> m))", "by (simp add: finite_map_to_set)"], ["proof (state)\nthis:\n  finite (dom (\\<alpha> m))\n\ngoal:\nNo subgoals!", "qed"], ["", "locale map_iterateoi = ordered_finite_map \\<alpha> invar\n    for \\<alpha> :: \"'s \\<Rightarrow> ('u::linorder) \\<rightharpoonup> 'v\" and invar\n    +\n    fixes iterateoi :: \"'s \\<Rightarrow> ('u \\<times> 'v,'\\<sigma>) set_iterator\"\n    assumes iterateoi_rule: \"\n      invar m \\<Longrightarrow> map_iterator_linord (iterateoi m) (\\<alpha> m)\"\n  begin"], ["", "lemma iterateoi_rule_P[case_names minv inv0 inv_pres i_complete i_inter]:\n      assumes MINV: \"invar m\"\n      assumes I0: \"I (dom (\\<alpha> m)) \\<sigma>0\"\n      assumes IP: \"!!k v it \\<sigma>. \\<lbrakk> \n        c \\<sigma>; \n        k \\<in> it; \n        \\<forall>j\\<in>it. k\\<le>j; \n        \\<forall>j\\<in>dom (\\<alpha> m) - it. j\\<le>k; \n        \\<alpha> m k = Some v; \n        it \\<subseteq> dom (\\<alpha> m); \n        I it \\<sigma> \n      \\<rbrakk> \\<Longrightarrow> I (it - {k}) (f (k, v) \\<sigma>)\"\n      assumes IF: \"!!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n      assumes II: \"!!\\<sigma> it. \\<lbrakk> \n        it \\<subseteq> dom (\\<alpha> m); \n        it \\<noteq> {}; \n        \\<not> c \\<sigma>; \n        I it \\<sigma>; \n        \\<forall>k\\<in>it. \\<forall>j\\<in>dom (\\<alpha> m) - it. j\\<le>k \n      \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n      shows \"P (iterateoi m c f \\<sigma>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (iterateoi m c f \\<sigma>0)", "using map_iterator_linord_rule_P [OF iterateoi_rule, of m I \\<sigma>0 c f P] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>invar m; I (dom (\\<alpha> m)) \\<sigma>0;\n   \\<And>k v it \\<sigma>.\n      \\<lbrakk>c \\<sigma>; k \\<in> it; \\<alpha> m k = Some v;\n       it \\<subseteq> dom (\\<alpha> m); I it \\<sigma>;\n       \\<And>k'. k' \\<in> it \\<Longrightarrow> k \\<le> k';\n       \\<And>k'.\n          k' \\<in> dom (\\<alpha> m) - it \\<Longrightarrow>\n          k' \\<le> k\\<rbrakk>\n      \\<Longrightarrow> I (it - {k}) (f (k, v) \\<sigma>);\n   \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>;\n   \\<And>\\<sigma> it.\n      \\<lbrakk>it \\<subseteq> dom (\\<alpha> m); it \\<noteq> {};\n       \\<not> c \\<sigma>; I it \\<sigma>;\n       \\<And>k k'.\n          \\<lbrakk>k \\<in> dom (\\<alpha> m) - it; k' \\<in> it\\<rbrakk>\n          \\<Longrightarrow> k \\<le> k'\\<rbrakk>\n      \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n  \\<Longrightarrow> P (iterateoi m c f \\<sigma>0)\n  invar m\n  I (dom (\\<alpha> m)) \\<sigma>0\n  \\<lbrakk>c ?\\<sigma>1; ?k1 \\<in> ?it1; \\<forall>j\\<in>?it1. ?k1 \\<le> j;\n   \\<forall>j\\<in>dom (\\<alpha> m) - ?it1. j \\<le> ?k1;\n   \\<alpha> m ?k1 = Some ?v1; ?it1 \\<subseteq> dom (\\<alpha> m);\n   I ?it1 ?\\<sigma>1\\<rbrakk>\n  \\<Longrightarrow> I (?it1 - {?k1}) (f (?k1, ?v1) ?\\<sigma>1)\n  I {} ?\\<sigma>1 \\<Longrightarrow> P ?\\<sigma>1\n  \\<lbrakk>?it1 \\<subseteq> dom (\\<alpha> m); ?it1 \\<noteq> {};\n   \\<not> c ?\\<sigma>1; I ?it1 ?\\<sigma>1;\n   \\<forall>k\\<in>?it1.\n      \\<forall>j\\<in>dom (\\<alpha> m) - ?it1. j \\<le> k\\<rbrakk>\n  \\<Longrightarrow> P ?\\<sigma>1\n\ngoal (1 subgoal):\n 1. P (iterateoi m c f \\<sigma>0)", "by simp"], ["", "lemma iterateo_rule_P[case_names minv inv0 inv_pres i_complete]: \n      assumes MINV: \"invar m\"\n      assumes I0: \"I (dom (\\<alpha> m)) \\<sigma>0\"\n      assumes IP: \"!!k v it \\<sigma>. \\<lbrakk> k \\<in> it; \\<forall>j\\<in>it. k\\<le>j; \\<forall>j\\<in>dom (\\<alpha> m) - it. j\\<le>k; \\<alpha> m k = Some v; it \\<subseteq> dom (\\<alpha> m); I it \\<sigma> \\<rbrakk> \n                  \\<Longrightarrow> I (it - {k}) (f (k, v) \\<sigma>)\"\n      assumes IF: \"!!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n      shows \"P (iterateoi m (\\<lambda>_. True) f \\<sigma>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (iterateoi m (\\<lambda>_. True) f \\<sigma>0)", "using map_iterator_linord_rule_P [OF iterateoi_rule, of m I \\<sigma>0 \"\\<lambda>_. True\" f P] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>invar m; I (dom (\\<alpha> m)) \\<sigma>0;\n   \\<And>k v it \\<sigma>.\n      \\<lbrakk>True; k \\<in> it; \\<alpha> m k = Some v;\n       it \\<subseteq> dom (\\<alpha> m); I it \\<sigma>;\n       \\<And>k'. k' \\<in> it \\<Longrightarrow> k \\<le> k';\n       \\<And>k'.\n          k' \\<in> dom (\\<alpha> m) - it \\<Longrightarrow>\n          k' \\<le> k\\<rbrakk>\n      \\<Longrightarrow> I (it - {k}) (f (k, v) \\<sigma>);\n   \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>;\n   \\<And>\\<sigma> it.\n      \\<lbrakk>it \\<subseteq> dom (\\<alpha> m); it \\<noteq> {}; \\<not> True;\n       I it \\<sigma>;\n       \\<And>k k'.\n          \\<lbrakk>k \\<in> dom (\\<alpha> m) - it; k' \\<in> it\\<rbrakk>\n          \\<Longrightarrow> k \\<le> k'\\<rbrakk>\n      \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n  \\<Longrightarrow> P (iterateoi m (\\<lambda>_. True) f \\<sigma>0)\n  invar m\n  I (dom (\\<alpha> m)) \\<sigma>0\n  \\<lbrakk>?k1 \\<in> ?it1; \\<forall>j\\<in>?it1. ?k1 \\<le> j;\n   \\<forall>j\\<in>dom (\\<alpha> m) - ?it1. j \\<le> ?k1;\n   \\<alpha> m ?k1 = Some ?v1; ?it1 \\<subseteq> dom (\\<alpha> m);\n   I ?it1 ?\\<sigma>1\\<rbrakk>\n  \\<Longrightarrow> I (?it1 - {?k1}) (f (?k1, ?v1) ?\\<sigma>1)\n  I {} ?\\<sigma>1 \\<Longrightarrow> P ?\\<sigma>1\n\ngoal (1 subgoal):\n 1. P (iterateoi m (\\<lambda>_. True) f \\<sigma>0)", "by simp"], ["", "end"], ["", "lemma map_iterateoi_I :\n  assumes \"\\<And>m. invar m \\<Longrightarrow> map_iterator_linord (itoi m) (\\<alpha> m)\"\n  shows \"map_iterateoi \\<alpha> invar itoi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_iterateoi \\<alpha> invar itoi", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m. invar m \\<Longrightarrow> finite (dom (\\<alpha> m))\n 2. \\<And>m.\n       invar m \\<Longrightarrow> map_iterator_linord (itoi m) (\\<alpha> m)", "fix m"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m. invar m \\<Longrightarrow> finite (dom (\\<alpha> m))\n 2. \\<And>m.\n       invar m \\<Longrightarrow> map_iterator_linord (itoi m) (\\<alpha> m)", "assume invar_m: \"invar m\""], ["proof (state)\nthis:\n  invar m\n\ngoal (2 subgoals):\n 1. \\<And>m. invar m \\<Longrightarrow> finite (dom (\\<alpha> m))\n 2. \\<And>m.\n       invar m \\<Longrightarrow> map_iterator_linord (itoi m) (\\<alpha> m)", "from assms(1)[OF invar_m]"], ["proof (chain)\npicking this:\n  map_iterator_linord (itoi m) (\\<alpha> m)", "show it_OK: \"map_iterator_linord (itoi m) (\\<alpha> m)\""], ["proof (prove)\nusing this:\n  map_iterator_linord (itoi m) (\\<alpha> m)\n\ngoal (1 subgoal):\n 1. map_iterator_linord (itoi m) (\\<alpha> m)", "."], ["proof (state)\nthis:\n  map_iterator_linord (itoi m) (\\<alpha> m)\n\ngoal (1 subgoal):\n 1. \\<And>m. invar m \\<Longrightarrow> finite (dom (\\<alpha> m))", "from set_iterator_genord.finite_S0 [OF it_OK[unfolded set_iterator_map_linord_def]]"], ["proof (chain)\npicking this:\n  finite (map_to_set (\\<alpha> m))", "show \"finite (dom (\\<alpha> m))\""], ["proof (prove)\nusing this:\n  finite (map_to_set (\\<alpha> m))\n\ngoal (1 subgoal):\n 1. finite (dom (\\<alpha> m))", "by (simp add: finite_map_to_set)"], ["proof (state)\nthis:\n  finite (dom (\\<alpha> m))\n\ngoal:\nNo subgoals!", "qed"], ["", "locale map_reverse_iterateoi = ordered_finite_map \\<alpha> invar \n    for \\<alpha> :: \"'s \\<Rightarrow> ('u::linorder) \\<rightharpoonup> 'v\" and invar\n    +\n    fixes reverse_iterateoi :: \"'s \\<Rightarrow> ('u \\<times> 'v,'\\<sigma>) set_iterator\"\n    assumes reverse_iterateoi_rule: \"\n      invar m \\<Longrightarrow> map_iterator_rev_linord (reverse_iterateoi m) (\\<alpha> m)\"\n  begin"], ["", "lemma reverse_iterateoi_rule_P[case_names minv inv0 inv_pres i_complete i_inter]:\n      assumes MINV: \"invar m\"\n      assumes I0: \"I (dom (\\<alpha> m)) \\<sigma>0\"\n      assumes IP: \"!!k v it \\<sigma>. \\<lbrakk> \n        c \\<sigma>; \n        k \\<in> it; \n        \\<forall>j\\<in>it. k\\<ge>j; \n        \\<forall>j\\<in>dom (\\<alpha> m) - it. j\\<ge>k; \n        \\<alpha> m k = Some v; \n        it \\<subseteq> dom (\\<alpha> m); \n        I it \\<sigma> \n      \\<rbrakk> \\<Longrightarrow> I (it - {k}) (f (k, v) \\<sigma>)\"\n      assumes IF: \"!!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n      assumes II: \"!!\\<sigma> it. \\<lbrakk> \n        it \\<subseteq> dom (\\<alpha> m); \n        it \\<noteq> {}; \n        \\<not> c \\<sigma>; \n        I it \\<sigma>; \n        \\<forall>k\\<in>it. \\<forall>j\\<in>dom (\\<alpha> m) - it. j\\<ge>k \n      \\<rbrakk> \\<Longrightarrow> P \\<sigma>\"\n      shows \"P (reverse_iterateoi m c f \\<sigma>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (reverse_iterateoi m c f \\<sigma>0)", "using map_iterator_rev_linord_rule_P [OF reverse_iterateoi_rule, of m I \\<sigma>0 c f P] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>invar m; I (dom (\\<alpha> m)) \\<sigma>0;\n   \\<And>k v it \\<sigma>.\n      \\<lbrakk>c \\<sigma>; k \\<in> it; \\<alpha> m k = Some v;\n       it \\<subseteq> dom (\\<alpha> m); I it \\<sigma>;\n       \\<And>k'. k' \\<in> it \\<Longrightarrow> k' \\<le> k;\n       \\<And>k'.\n          k' \\<in> dom (\\<alpha> m) - it \\<Longrightarrow>\n          k \\<le> k'\\<rbrakk>\n      \\<Longrightarrow> I (it - {k}) (f (k, v) \\<sigma>);\n   \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>;\n   \\<And>\\<sigma> it.\n      \\<lbrakk>it \\<subseteq> dom (\\<alpha> m); it \\<noteq> {};\n       \\<not> c \\<sigma>; I it \\<sigma>;\n       \\<And>k k'.\n          \\<lbrakk>k \\<in> dom (\\<alpha> m) - it; k' \\<in> it\\<rbrakk>\n          \\<Longrightarrow> k' \\<le> k\\<rbrakk>\n      \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n  \\<Longrightarrow> P (reverse_iterateoi m c f \\<sigma>0)\n  invar m\n  I (dom (\\<alpha> m)) \\<sigma>0\n  \\<lbrakk>c ?\\<sigma>1; ?k1 \\<in> ?it1; \\<forall>j\\<in>?it1. j \\<le> ?k1;\n   \\<forall>j\\<in>dom (\\<alpha> m) - ?it1. ?k1 \\<le> j;\n   \\<alpha> m ?k1 = Some ?v1; ?it1 \\<subseteq> dom (\\<alpha> m);\n   I ?it1 ?\\<sigma>1\\<rbrakk>\n  \\<Longrightarrow> I (?it1 - {?k1}) (f (?k1, ?v1) ?\\<sigma>1)\n  I {} ?\\<sigma>1 \\<Longrightarrow> P ?\\<sigma>1\n  \\<lbrakk>?it1 \\<subseteq> dom (\\<alpha> m); ?it1 \\<noteq> {};\n   \\<not> c ?\\<sigma>1; I ?it1 ?\\<sigma>1;\n   \\<forall>k\\<in>?it1.\n      \\<forall>j\\<in>dom (\\<alpha> m) - ?it1. k \\<le> j\\<rbrakk>\n  \\<Longrightarrow> P ?\\<sigma>1\n\ngoal (1 subgoal):\n 1. P (reverse_iterateoi m c f \\<sigma>0)", "by simp"], ["", "lemma reverse_iterateo_rule_P[case_names minv inv0 inv_pres i_complete]:\n      assumes MINV: \"invar m\"\n      assumes I0: \"I (dom (\\<alpha> m)) \\<sigma>0\"\n      assumes IP: \"!!k v it \\<sigma>. \\<lbrakk> \n        k \\<in> it; \n        \\<forall>j\\<in>it. k\\<ge>j; \n        \\<forall>j\\<in>dom (\\<alpha> m) - it. j\\<ge>k; \n        \\<alpha> m k = Some v; \n        it \\<subseteq> dom (\\<alpha> m); \n        I it \\<sigma> \n      \\<rbrakk> \\<Longrightarrow> I (it - {k}) (f (k, v) \\<sigma>)\"\n      assumes IF: \"!!\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>\"\n      shows \"P (reverse_iterateoi m (\\<lambda>_. True) f \\<sigma>0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (reverse_iterateoi m (\\<lambda>_. True) f \\<sigma>0)", "using map_iterator_rev_linord_rule_P[OF reverse_iterateoi_rule, of m I \\<sigma>0 \"\\<lambda>_. True\" f P] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>invar m; I (dom (\\<alpha> m)) \\<sigma>0;\n   \\<And>k v it \\<sigma>.\n      \\<lbrakk>True; k \\<in> it; \\<alpha> m k = Some v;\n       it \\<subseteq> dom (\\<alpha> m); I it \\<sigma>;\n       \\<And>k'. k' \\<in> it \\<Longrightarrow> k' \\<le> k;\n       \\<And>k'.\n          k' \\<in> dom (\\<alpha> m) - it \\<Longrightarrow>\n          k \\<le> k'\\<rbrakk>\n      \\<Longrightarrow> I (it - {k}) (f (k, v) \\<sigma>);\n   \\<And>\\<sigma>. I {} \\<sigma> \\<Longrightarrow> P \\<sigma>;\n   \\<And>\\<sigma> it.\n      \\<lbrakk>it \\<subseteq> dom (\\<alpha> m); it \\<noteq> {}; \\<not> True;\n       I it \\<sigma>;\n       \\<And>k k'.\n          \\<lbrakk>k \\<in> dom (\\<alpha> m) - it; k' \\<in> it\\<rbrakk>\n          \\<Longrightarrow> k' \\<le> k\\<rbrakk>\n      \\<Longrightarrow> P \\<sigma>\\<rbrakk>\n  \\<Longrightarrow> P (reverse_iterateoi m (\\<lambda>_. True) f \\<sigma>0)\n  invar m\n  I (dom (\\<alpha> m)) \\<sigma>0\n  \\<lbrakk>?k1 \\<in> ?it1; \\<forall>j\\<in>?it1. j \\<le> ?k1;\n   \\<forall>j\\<in>dom (\\<alpha> m) - ?it1. ?k1 \\<le> j;\n   \\<alpha> m ?k1 = Some ?v1; ?it1 \\<subseteq> dom (\\<alpha> m);\n   I ?it1 ?\\<sigma>1\\<rbrakk>\n  \\<Longrightarrow> I (?it1 - {?k1}) (f (?k1, ?v1) ?\\<sigma>1)\n  I {} ?\\<sigma>1 \\<Longrightarrow> P ?\\<sigma>1\n\ngoal (1 subgoal):\n 1. P (reverse_iterateoi m (\\<lambda>_. True) f \\<sigma>0)", "by simp"], ["", "end"], ["", "lemma map_reverse_iterateoi_I :\n  assumes \"\\<And>m. invar m \\<Longrightarrow> map_iterator_rev_linord (ritoi m) (\\<alpha> m)\"\n  shows \"map_reverse_iterateoi \\<alpha> invar ritoi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_reverse_iterateoi \\<alpha> invar ritoi", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m. invar m \\<Longrightarrow> finite (dom (\\<alpha> m))\n 2. \\<And>m.\n       invar m \\<Longrightarrow>\n       map_iterator_rev_linord (ritoi m) (\\<alpha> m)", "fix m"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m. invar m \\<Longrightarrow> finite (dom (\\<alpha> m))\n 2. \\<And>m.\n       invar m \\<Longrightarrow>\n       map_iterator_rev_linord (ritoi m) (\\<alpha> m)", "assume invar_m: \"invar m\""], ["proof (state)\nthis:\n  invar m\n\ngoal (2 subgoals):\n 1. \\<And>m. invar m \\<Longrightarrow> finite (dom (\\<alpha> m))\n 2. \\<And>m.\n       invar m \\<Longrightarrow>\n       map_iterator_rev_linord (ritoi m) (\\<alpha> m)", "from assms(1)[OF invar_m]"], ["proof (chain)\npicking this:\n  map_iterator_rev_linord (ritoi m) (\\<alpha> m)", "show it_OK: \"map_iterator_rev_linord (ritoi m) (\\<alpha> m)\""], ["proof (prove)\nusing this:\n  map_iterator_rev_linord (ritoi m) (\\<alpha> m)\n\ngoal (1 subgoal):\n 1. map_iterator_rev_linord (ritoi m) (\\<alpha> m)", "."], ["proof (state)\nthis:\n  map_iterator_rev_linord (ritoi m) (\\<alpha> m)\n\ngoal (1 subgoal):\n 1. \\<And>m. invar m \\<Longrightarrow> finite (dom (\\<alpha> m))", "from set_iterator_genord.finite_S0 [OF it_OK[unfolded set_iterator_map_rev_linord_def]]"], ["proof (chain)\npicking this:\n  finite (map_to_set (\\<alpha> m))", "show \"finite (dom (\\<alpha> m))\""], ["proof (prove)\nusing this:\n  finite (map_to_set (\\<alpha> m))\n\ngoal (1 subgoal):\n 1. finite (dom (\\<alpha> m))", "by (simp add: finite_map_to_set)"], ["proof (state)\nthis:\n  finite (dom (\\<alpha> m))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in poly_map_iteratei) v1_iteratei_impl: \n    \"map_iteratei \\<alpha> invar iteratei\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_iteratei \\<alpha> invar iteratei", "by unfold_locales (rule iteratei_correct)"], ["", "lemma (in poly_map_iterateoi) v1_iterateoi_impl: \n    \"map_iterateoi \\<alpha> invar iterateoi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_iterateoi \\<alpha> invar iterateoi", "by unfold_locales (rule iterateoi_correct)"], ["", "lemma (in poly_map_rev_iterateoi) v1_reverse_iterateoi_impl: \n    \"map_reverse_iterateoi \\<alpha> invar rev_iterateoi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_reverse_iterateoi \\<alpha> invar reverse_iterateoi", "by unfold_locales (rule rev_iterateoi_correct)"], ["", "declare (in poly_map_iteratei) v1_iteratei_impl[locale_witness_add]"], ["", "declare (in poly_map_iterateoi) v1_iterateoi_impl[locale_witness_add]"], ["", "declare (in poly_map_rev_iterateoi) \n    v1_reverse_iterateoi_impl[locale_witness_add]"], ["", "(*\n  sublocale poly_map_iteratei < v1_iteratei: map_iteratei \\<alpha> invar iteratei\n    by (rule v1_iteratei_impl)\n  sublocale poly_map_iterateoi < v1_iteratei: map_iterateoi \\<alpha> invar iterateoi\n    by (rule v1_iterateoi_impl)\n  sublocale poly_map_rev_iterateoi \n    < v1_iteratei!: map_reverse_iterateoi \\<alpha> invar rev_iterateoi\n    by (rule v1_reverse_iterateoi_impl)\n    *)"], ["", "subsection \\<open>Concrete Operation Names\\<close>"], ["", "text \\<open>We define abbreviations to recover the \\<open>xx_op\\<close>-names\\<close>"], ["", "(* TODO: This may take long, as Local_Theory.abbrev seems to be really slow *)"], ["", "local_setup \\<open>let\n    val thy = @{theory}\n    val ctxt = Proof_Context.init_global thy;\n    val pats = [\n    \"hs\",\"hm\",\n    \"rs\",\"rm\",\n    \"ls\",\"lm\",\"lsi\",\"lmi\",\"lsnd\",\"lss\",\n    \"ts\",\"tm\",\n    \"ias\",\"iam\",\n    \"ahs\",\"ahm\",\n    \"bino\",\n    \"fifo\",\n    \"ft\",\n    \"alprioi\",\n    \"aluprioi\",\n    \"skew\"\n    ];\n\n    val {const_space, constants, ...} = Sign.consts_of thy |> Consts.dest\n    val clist = Name_Space.extern_entries true ctxt const_space constants |> map (apfst #1)\n\n    fun abbrevs_for pat = clist\n    |> map_filter (fn (n,_) => case Long_Name.explode n of\n        [_,prefix,opname] =>\n          if prefix = pat then let \n              val aname = prefix ^ \"_\" ^ opname\n              val rhs = Proof_Context.read_term_abbrev ctxt n\n            in SOME (aname,rhs) end\n          else NONE\n      | _ => NONE);\n\n    fun do_abbrevs pat lthy = let\n      val abbrevs = abbrevs_for pat;\n    in \n      case abbrevs of [] => (warning (\"No stuff found for \"^pat); lthy)\n      | _ => let \n        (*val _ = tracing (\"Defining \" ^ pat ^ \"_xxx ...\");*)\n        val lthy = fold (fn (name,rhs) =>\n          Local_Theory.abbrev \n            Syntax.mode_input \n            ((Binding.name name,NoSyn),rhs) #> #2\n        ) abbrevs lthy\n        (*val _ = tracing \"Done\";*)\n      in lthy end\n    end\n  in\n    fold do_abbrevs pats\n  end\n\n\\<close>"], ["", "lemmas hs_correct = hs.correct"], ["", "lemmas hm_correct = hm.correct"], ["", "lemmas rs_correct = rs.correct"], ["", "lemmas rm_correct = rm.correct"], ["", "lemmas ls_correct = ls.correct"], ["", "lemmas lm_correct = lm.correct"], ["", "lemmas lsi_correct = lsi.correct"], ["", "lemmas lmi_correct = lmi.correct"], ["", "lemmas lsnd_correct = lsnd.correct"], ["", "lemmas lss_correct = lss.correct"], ["", "lemmas ts_correct = ts.correct"], ["", "lemmas tm_correct = tm.correct"], ["", "lemmas ias_correct = ias.correct"], ["", "lemmas iam_correct = iam.correct"], ["", "lemmas ahs_correct = ahs.correct"], ["", "lemmas ahm_correct = ahm.correct"], ["", "lemmas bino_correct = bino.correct"], ["", "lemmas fifo_correct = fifo.correct"], ["", "lemmas ft_correct = ft.correct"], ["", "lemmas alprioi_correct = alprioi.correct"], ["", "lemmas aluprioi_correct = aluprioi.correct"], ["", "lemmas skew_correct = skew.correct"], ["", "locale list_enqueue = list_appendr"], ["", "locale list_dequeue = list_removel"], ["", "locale list_push = list_appendl"], ["", "locale list_pop = list_remover"], ["", "locale list_top = list_leftmost"], ["", "locale list_bot = list_rightmost"], ["", "instantiation rbt :: (\"{equal,linorder}\",equal) equal \nbegin"], ["", "(*definition equal_rbt :: \"('a,'b) RBT.rbt \\<Rightarrow> _\" where \"equal_rbt \\<equiv> (=)\"*)"], ["", "definition \"equal_class.equal (r :: ('a, 'b) rbt) r' \n    == RBT.impl_of r = RBT.impl_of r'\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) RBT.rbt, equal_class)", "apply intro_classes"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. equal_class.equal x y = (x = y)", "apply (simp add: equal_rbt_def RBT.impl_of_inject)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "end"]]}