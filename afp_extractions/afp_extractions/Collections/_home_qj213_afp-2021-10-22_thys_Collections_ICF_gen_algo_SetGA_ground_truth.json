{"file_name": "/home/qj213/afp-2021-10-22/thys/Collections/ICF/gen_algo/SetGA.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Collections", "problem_names": ["lemma g_copy_alt: \n    \"g_copy s = iterate_to_set s2.empty s2.ins_dj (s1.iteratei s)\"", "lemma g_copy_impl: \"set_copy s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar g_copy\"", "lemma g_filter_impl: \"set_filter s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar g_filter\"", "lemma g_union_alt: \n    \"g_union s1 s2 = iterate_add_to_set s2 s2.ins (s1.iteratei s1)\"", "lemma g_diff_alt:\n    \"g_diff s1 s2 = iterate_diff_set s1 s1.delete (s2.iteratei s2)\"", "lemma g_union_impl:\n    \"set_union s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar s2.\\<alpha> s2.invar g_union\"", "lemma g_diff_impl:\n    \"set_diff s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar g_diff\"", "lemma g_union_list_impl:\n    shows \"set_union_list s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar g_union_list\"", "lemma g_union_dj_impl:\n    \"set_union_dj s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar s2.\\<alpha> s2.invar g_union_dj\"", "lemma g_disjoint_witness_impl: \n    \"set_disjoint_witness s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar g_disjoint_witness\"", "lemma g_disjoint_impl: \n    \"set_disjoint s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar g_disjoint\"", "lemma g_inter_impl: \"set_inter s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar s3.\\<alpha> s3.invar\n    g_inter\"", "lemma g_image_filter_impl: \n    \"set_image_filter s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar g_image_filter\"", "lemma g_image_alt: \"g_image f s = g_image_filter (Some o f) s\"", "lemma g_image_impl: \"set_image s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar g_image\"", "lemma g_inj_image_filter_impl: \n    \"set_inj_image_filter s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar g_inj_image_filter\"", "lemma g_inj_image_alt: \"g_inj_image f s = g_inj_image_filter (Some o f) s\"", "lemma g_inj_image_impl: \n    \"set_inj_image s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar g_inj_image\"", "lemma g_Union_image_impl:\n    \"set_Union_image s0.\\<alpha> s0.invar s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar g_Union_image\"", "lemmas correct[simp] = \n    empty_correct\n    memb_correct\n    ins_correct\n    ins_dj_correct\n    delete_correct", "lemma g_sng_impl: \"set_sng \\<alpha> invar g_sng\"", "lemma g_ins_dj_impl: \"set_ins_dj \\<alpha> invar ins\"", "lemma g_isEmpty_impl: \"set_isEmpty \\<alpha> invar g_isEmpty\"", "lemma g_sel'_impl: \"set_sel' \\<alpha> invar g_sel'\"", "lemma g_ball_alt: \"g_ball s P = iterate_ball (iteratei s) P\"", "lemma g_bex_alt: \"g_bex s P = iterate_bex (iteratei s) P\"", "lemma g_ball_impl: \"set_ball \\<alpha> invar g_ball\"", "lemma g_bex_impl: \"set_bex \\<alpha> invar g_bex\"", "lemma g_size_alt: \"g_size s = iterate_size (iteratei s)\"", "lemma g_size_abort_alt: \"g_size_abort m s = iterate_size_abort (iteratei s) m\"", "lemma g_size_impl: \"set_size \\<alpha> invar g_size\"", "lemma g_size_abort_impl: \"set_size_abort \\<alpha> invar g_size_abort\"", "lemma g_isSng_alt: \"g_isSng s = iterate_is_sng (iteratei s)\"", "lemma g_isSng_impl: \"set_isSng \\<alpha> invar g_isSng\"", "lemma g_union_impl: \"set_union \\<alpha> invar \\<alpha> invar \\<alpha> invar g_union\"", "lemma g_diff_impl: \"set_diff \\<alpha> invar \\<alpha> invar g_diff\"", "lemma g_subset_impl: \"set_subset \\<alpha> invar \\<alpha> invar g_subset\"", "lemma g_equal_impl: \"set_equal \\<alpha> invar \\<alpha> invar g_equal\"", "lemma g_to_list_impl: \"set_to_list \\<alpha> invar g_to_list\"", "lemma g_from_list_impl: \"list_to_set \\<alpha> invar g_from_list\"", "lemma g_inter_impl: \"set_inter \\<alpha> invar \\<alpha> invar \\<alpha> invar g_inter\"", "lemma g_union_dj_impl: \"set_union_dj \\<alpha> invar \\<alpha> invar \\<alpha> invar g_union_dj\"", "lemma g_filter_impl: \"set_filter \\<alpha> invar \\<alpha> invar g_filter\"", "lemma g_disjoint_witness_impl: \"set_disjoint_witness \n    \\<alpha> invar \\<alpha> invar g_disjoint_witness\"", "lemma g_disjoint_impl: \"set_disjoint \n    \\<alpha> invar \\<alpha> invar g_disjoint\"", "lemma dflt_ops_impl: \"StdSet dflt_ops\"", "lemma g_min_impl: \"set_min \\<alpha> invar g_min\"", "lemma g_max_impl: \"set_max \\<alpha> invar g_max\"", "lemma g_to_sorted_list_impl: \"set_to_sorted_list \\<alpha> invar g_to_sorted_list\"", "lemma g_to_rev_list_impl: \"set_to_rev_list \\<alpha> invar g_to_rev_list\"", "lemma dflt_oops_impl: \"StdOSet dflt_oops\"", "lemma image_filter_cartesian_product_alt:\n    \"image_filter_cartesian_product f s1 s2 ==\n     iterate_to_set s3.empty s3.ins (set_iterator_image_filter f (\n       set_iterator_product (s1.iteratei s1) (\\<lambda>_. s2.iteratei s2)))\"", "lemma image_filter_cartesian_product_correct:\n    fixes f :: \"'x \\<times> 'y \\<rightharpoonup> 'z\"\n    assumes I[simp, intro!]: \"s1.invar s1\" \"s2.invar s2\"\n    shows \"s3.\\<alpha> (image_filter_cartesian_product f s1 s2) \n     = { z | x y z. f (x,y) = Some z \\<and> x\\<in>s1.\\<alpha> s1 \\<and> y\\<in>s2.\\<alpha> s2 }\" (is ?T1)\n    \"s3.invar (image_filter_cartesian_product f s1 s2)\" (is ?T2)", "lemma image_filter_cp_correct:\n    assumes I: \"s1.invar s1\" \"s2.invar s2\"\n    shows \n    \"s3.\\<alpha> (image_filter_cp f P s1 s2) \n     = { f (x, y) | x y. P (x, y) \\<and> x\\<in>s1.\\<alpha> s1 \\<and> y\\<in>s2.\\<alpha> s2 }\" (is ?T1)\n    \"s3.invar (image_filter_cp f P s1 s2)\" (is ?T2)", "lemma inj_image_filter_cartesian_product_alt:\n    \"inj_image_filter_cartesian_product f s1 s2 ==\n     iterate_to_set s3.empty s3.ins_dj (set_iterator_image_filter f (\n       set_iterator_product (s1.iteratei s1) (\\<lambda>_. s2.iteratei s2)))\"", "lemma inj_image_filter_cartesian_product_correct:\n    fixes f :: \"'x \\<times> 'y \\<rightharpoonup> 'z\"\n    assumes I[simp, intro!]: \"s1.invar s1\" \"s2.invar s2\"\n    assumes INJ: \"inj_on f (s1.\\<alpha> s1 \\<times> s2.\\<alpha> s2 \\<inter> dom f)\"\n    shows \"s3.\\<alpha> (inj_image_filter_cartesian_product f s1 s2) \n     = { z | x y z. f (x,y) = Some z \\<and> x\\<in>s1.\\<alpha> s1 \\<and> y\\<in>s2.\\<alpha> s2 }\" (is ?T1)\n    \"s3.invar (inj_image_filter_cartesian_product f s1 s2)\" (is ?T2)", "lemma inj_image_filter_cp_correct:\n    assumes I: \"s1.invar s1\" \"s2.invar s2\"\n    assumes INJ: \"inj_on f {x\\<in>s1.\\<alpha> s1 \\<times> s2.\\<alpha> s2. P x}\"\n    shows \n    \"s3.\\<alpha> (inj_image_filter_cp f P s1 s2) \n     = { f (x, y) | x y. P (x, y) \\<and> x\\<in>s1.\\<alpha> s1 \\<and> y\\<in>s2.\\<alpha> s2 }\" (is ?T1)\n    \"s3.invar (inj_image_filter_cp f P s1 s2)\" (is ?T2)", "lemma cart_alt: \"cart s1 s2 == \n    inj_image_filter_cartesian_product Some s1 s2\"", "lemma cart_correct:\n    assumes I[simp, intro!]: \"s1.invar s1\" \"s2.invar s2\"\n    shows \"s3.\\<alpha> (cart s1 s2) \n           = s1.\\<alpha> s1 \\<times> s2.\\<alpha> s2\" (is ?T1)\n    \"s3.invar (cart s1 s2)\" (is ?T2)", "lemma iflt_image_correct:\n  assumes \"set_image_filter \\<alpha>1 invar1 \\<alpha>2 invar2 iflt\"\n  shows \"set_image \\<alpha>1 invar1 \\<alpha>2 invar2 (iflt_image iflt)\"", "lemma iflt_inj_image_correct:\n  assumes \"set_inj_image_filter \\<alpha>1 invar1 \\<alpha>2 invar2 iflt\"\n  shows \"set_inj_image \\<alpha>1 invar1 \\<alpha>2 invar2 (iflt_inj_image iflt)\"", "lemma iflt_filter_correct:\n  fixes \\<alpha>1 :: \"'s1 \\<Rightarrow> 'a set\"\n  fixes \\<alpha>2 :: \"'s2 \\<Rightarrow> 'a set\"\n  assumes \"set_inj_image_filter \\<alpha>1 invar1 \\<alpha>2 invar2 iflt\"\n  shows \"set_filter \\<alpha>1 invar1 \\<alpha>2 invar2 (iflt_filter iflt)\""], "translations": [["", "lemma g_copy_alt: \n    \"g_copy s = iterate_to_set s2.empty s2.ins_dj (s1.iteratei s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g_copy s = iterate_to_set s2.empty s2.ins_dj (s1.iteratei s)", "unfolding iterate_to_set_alt_def g_copy_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. s1.iterate s s2.ins_dj (s2.empty ()) =\n    s1.iterate s s2.ins_dj (s2.empty ())", ".."], ["", "lemma g_copy_impl: \"set_copy s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar g_copy\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_copy s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar g_copy", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set_copy s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar g_copy", "have LIS: \n      \"set_ins_dj s2.\\<alpha> s2.invar s2.ins_dj\" \n      \"set_empty s2.\\<alpha> s2.invar s2.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_ins_dj s2.\\<alpha> s2.invar s2.ins_dj &&&\n    set_empty s2.\\<alpha> s2.invar s2.empty", "by unfold_locales"], ["proof (state)\nthis:\n  set_ins_dj s2.\\<alpha> s2.invar s2.ins_dj\n  set_empty s2.\\<alpha> s2.invar s2.empty\n\ngoal (1 subgoal):\n 1. set_copy s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar g_copy", "from iterate_to_set_correct[OF LIS s1.iteratei_correct]"], ["proof (chain)\npicking this:\n  s1.invar ?S1 \\<Longrightarrow>\n  s2.\\<alpha> (iterate_to_set s2.empty s2.ins_dj (s1.iteratei ?S1)) =\n  s1.\\<alpha> ?S1 \\<and>\n  s2.invar (iterate_to_set s2.empty s2.ins_dj (s1.iteratei ?S1))", "show ?thesis"], ["proof (prove)\nusing this:\n  s1.invar ?S1 \\<Longrightarrow>\n  s2.\\<alpha> (iterate_to_set s2.empty s2.ins_dj (s1.iteratei ?S1)) =\n  s1.\\<alpha> ?S1 \\<and>\n  s2.invar (iterate_to_set s2.empty s2.ins_dj (s1.iteratei ?S1))\n\ngoal (1 subgoal):\n 1. set_copy s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar g_copy", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s1.\n       \\<lbrakk>\\<And>S.\n                   s1.invar S \\<Longrightarrow>\n                   s2.\\<alpha>\n                    (iterate_to_set s2.empty s2.ins_dj (s1.iteratei S)) =\n                   s1.\\<alpha> S \\<and>\n                   s2.invar\n                    (iterate_to_set s2.empty s2.ins_dj (s1.iteratei S));\n        s1.invar s1\\<rbrakk>\n       \\<Longrightarrow> s2.\\<alpha> (g_copy s1) = s1.\\<alpha> s1\n 2. \\<And>s1.\n       \\<lbrakk>\\<And>S.\n                   s1.invar S \\<Longrightarrow>\n                   s2.\\<alpha>\n                    (iterate_to_set s2.empty s2.ins_dj (s1.iteratei S)) =\n                   s1.\\<alpha> S \\<and>\n                   s2.invar\n                    (iterate_to_set s2.empty s2.ins_dj (s1.iteratei S));\n        s1.invar s1\\<rbrakk>\n       \\<Longrightarrow> s2.invar (g_copy s1)", "unfolding g_copy_alt"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s1.\n       \\<lbrakk>\\<And>S.\n                   s1.invar S \\<Longrightarrow>\n                   s2.\\<alpha>\n                    (iterate_to_set s2.empty s2.ins_dj (s1.iteratei S)) =\n                   s1.\\<alpha> S \\<and>\n                   s2.invar\n                    (iterate_to_set s2.empty s2.ins_dj (s1.iteratei S));\n        s1.invar s1\\<rbrakk>\n       \\<Longrightarrow> s2.\\<alpha>\n                          (iterate_to_set s2.empty s2.ins_dj\n                            (s1.iteratei s1)) =\n                         s1.\\<alpha> s1\n 2. \\<And>s1.\n       \\<lbrakk>\\<And>S.\n                   s1.invar S \\<Longrightarrow>\n                   s2.\\<alpha>\n                    (iterate_to_set s2.empty s2.ins_dj (s1.iteratei S)) =\n                   s1.\\<alpha> S \\<and>\n                   s2.invar\n                    (iterate_to_set s2.empty s2.ins_dj (s1.iteratei S));\n        s1.invar s1\\<rbrakk>\n       \\<Longrightarrow> s2.invar\n                          (iterate_to_set s2.empty s2.ins_dj\n                            (s1.iteratei s1))", "by simp_all"], ["proof (state)\nthis:\n  set_copy s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar g_copy\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma g_filter_impl: \"set_filter s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar g_filter\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_filter s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar g_filter", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s P.\n       s1.invar s \\<Longrightarrow>\n       s2.\\<alpha> (g_filter P s) = {e \\<in> s1.\\<alpha> s. P e}\n 2. \\<And>s P. s1.invar s \\<Longrightarrow> s2.invar (g_filter P s)", "fix s P"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s P.\n       s1.invar s \\<Longrightarrow>\n       s2.\\<alpha> (g_filter P s) = {e \\<in> s1.\\<alpha> s. P e}\n 2. \\<And>s P. s1.invar s \\<Longrightarrow> s2.invar (g_filter P s)", "assume \"s1.invar s\""], ["proof (state)\nthis:\n  s1.invar s\n\ngoal (2 subgoals):\n 1. \\<And>s P.\n       s1.invar s \\<Longrightarrow>\n       s2.\\<alpha> (g_filter P s) = {e \\<in> s1.\\<alpha> s. P e}\n 2. \\<And>s P. s1.invar s \\<Longrightarrow> s2.invar (g_filter P s)", "hence \"s2.\\<alpha> (g_filter P s) = {e \\<in> s1.\\<alpha> s. P e} \\<and>\n      s2.invar (g_filter P s)\" (is \"?G1 \\<and> ?G2\")"], ["proof (prove)\nusing this:\n  s1.invar s\n\ngoal (1 subgoal):\n 1. s2.\\<alpha> (g_filter P s) = {e \\<in> s1.\\<alpha> s. P e} \\<and>\n    s2.invar (g_filter P s)", "unfolding g_filter_def"], ["proof (prove)\nusing this:\n  s1.invar s\n\ngoal (1 subgoal):\n 1. s2.\\<alpha>\n     (s1.iterate s\n       (\\<lambda>x \\<sigma>. if P x then s2.ins_dj x \\<sigma> else \\<sigma>)\n       (s2.empty ())) =\n    {e \\<in> s1.\\<alpha> s. P e} \\<and>\n    s2.invar\n     (s1.iterate s\n       (\\<lambda>x \\<sigma>. if P x then s2.ins_dj x \\<sigma> else \\<sigma>)\n       (s2.empty ()))", "apply (rule_tac I=\"\\<lambda>it \\<sigma>. s2.invar \\<sigma> \\<and> s2.\\<alpha> \\<sigma> = {e \\<in> it. P e}\" \n        in s1.iterate_rule_insert_P)"], ["proof (prove)\ngoal (4 subgoals):\n 1. s1.invar s \\<Longrightarrow> s1.invar s\n 2. s1.invar s \\<Longrightarrow>\n    s2.invar (s2.empty ()) \\<and>\n    s2.\\<alpha> (s2.empty ()) = {e \\<in> {}. P e}\n 3. \\<And>x it \\<sigma>.\n       \\<lbrakk>s1.invar s; x \\<in> s1.\\<alpha> s - it;\n        it \\<subseteq> s1.\\<alpha> s;\n        s2.invar \\<sigma> \\<and>\n        s2.\\<alpha> \\<sigma> = {e \\<in> it. P e}\\<rbrakk>\n       \\<Longrightarrow> s2.invar\n                          (if P x then s2.ins_dj x \\<sigma>\n                           else \\<sigma>) \\<and>\n                         s2.\\<alpha>\n                          (if P x then s2.ins_dj x \\<sigma> else \\<sigma>) =\n                         {e \\<in> insert x it. P e}\n 4. \\<And>\\<sigma>.\n       \\<lbrakk>s1.invar s;\n        s2.invar \\<sigma> \\<and>\n        s2.\\<alpha> \\<sigma> = {e \\<in> s1.\\<alpha> s. P e}\\<rbrakk>\n       \\<Longrightarrow> s2.\\<alpha> \\<sigma> =\n                         {e \\<in> s1.\\<alpha> s. P e} \\<and>\n                         s2.invar \\<sigma>", "by (auto simp add: s2.empty_correct s2.ins_dj_correct)"], ["proof (state)\nthis:\n  s2.\\<alpha> (g_filter P s) = {e \\<in> s1.\\<alpha> s. P e} \\<and>\n  s2.invar (g_filter P s)\n\ngoal (2 subgoals):\n 1. \\<And>s P.\n       s1.invar s \\<Longrightarrow>\n       s2.\\<alpha> (g_filter P s) = {e \\<in> s1.\\<alpha> s. P e}\n 2. \\<And>s P. s1.invar s \\<Longrightarrow> s2.invar (g_filter P s)", "thus ?G1 ?G2"], ["proof (prove)\nusing this:\n  s2.\\<alpha> (g_filter P s) = {e \\<in> s1.\\<alpha> s. P e} \\<and>\n  s2.invar (g_filter P s)\n\ngoal (1 subgoal):\n 1. s2.\\<alpha> (g_filter P s) = {e \\<in> s1.\\<alpha> s. P e} &&&\n    s2.invar (g_filter P s)", "by auto"], ["proof (state)\nthis:\n  s2.\\<alpha> (g_filter P s) = {e \\<in> s1.\\<alpha> s. P e}\n  s2.invar (g_filter P s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma g_union_alt: \n    \"g_union s1 s2 = iterate_add_to_set s2 s2.ins (s1.iteratei s1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g_union s1 s2 = iterate_add_to_set s2 s2.ins (s1.iteratei s1)", "unfolding iterate_add_to_set_def g_union_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. s1.iterate s1 s2.ins s2 = s1.iterate s1 s2.ins s2", ".."], ["", "lemma g_diff_alt:\n    \"g_diff s1 s2 = iterate_diff_set s1 s1.delete (s2.iteratei s2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g_diff s1 s2 = iterate_diff_set s1 s1.delete (s2.iteratei s2)", "unfolding g_diff_def iterate_diff_set_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. s2.iterate s2 s1.delete s1 = s2.iterate s2 s1.delete s1", ".."], ["", "lemma g_union_impl:\n    \"set_union s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar s2.\\<alpha> s2.invar g_union\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_union s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar s2.\\<alpha> s2.invar\n     g_union", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set_union s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar s2.\\<alpha> s2.invar\n     g_union", "have LIS: \"set_ins s2.\\<alpha> s2.invar s2.ins\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_ins s2.\\<alpha> s2.invar s2.ins", "by unfold_locales"], ["proof (state)\nthis:\n  set_ins s2.\\<alpha> s2.invar s2.ins\n\ngoal (1 subgoal):\n 1. set_union s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar s2.\\<alpha> s2.invar\n     g_union", "from iterate_add_to_set_correct[OF LIS _ s1.iteratei_correct]"], ["proof (chain)\npicking this:\n  \\<lbrakk>s2.invar ?s; s1.invar ?S1\\<rbrakk>\n  \\<Longrightarrow> s2.\\<alpha>\n                     (iterate_add_to_set ?s s2.ins (s1.iteratei ?S1)) =\n                    s1.\\<alpha> ?S1 \\<union> s2.\\<alpha> ?s \\<and>\n                    s2.invar\n                     (iterate_add_to_set ?s s2.ins (s1.iteratei ?S1))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>s2.invar ?s; s1.invar ?S1\\<rbrakk>\n  \\<Longrightarrow> s2.\\<alpha>\n                     (iterate_add_to_set ?s s2.ins (s1.iteratei ?S1)) =\n                    s1.\\<alpha> ?S1 \\<union> s2.\\<alpha> ?s \\<and>\n                    s2.invar\n                     (iterate_add_to_set ?s s2.ins (s1.iteratei ?S1))\n\ngoal (1 subgoal):\n 1. set_union s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar s2.\\<alpha> s2.invar\n     g_union", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s1 s2.\n       \\<lbrakk>\\<And>s S.\n                   \\<lbrakk>s2.invar s; s1.invar S\\<rbrakk>\n                   \\<Longrightarrow> s2.\\<alpha>\n(iterate_add_to_set s s2.ins (s1.iteratei S)) =\n                                     s1.\\<alpha> S \\<union>\n                                     s2.\\<alpha> s \\<and>\n                                     s2.invar\n(iterate_add_to_set s s2.ins (s1.iteratei S));\n        s1.invar s1; s2.invar s2\\<rbrakk>\n       \\<Longrightarrow> s2.\\<alpha> (g_union s1 s2) =\n                         s1.\\<alpha> s1 \\<union> s2.\\<alpha> s2\n 2. \\<And>s1 s2.\n       \\<lbrakk>\\<And>s S.\n                   \\<lbrakk>s2.invar s; s1.invar S\\<rbrakk>\n                   \\<Longrightarrow> s2.\\<alpha>\n(iterate_add_to_set s s2.ins (s1.iteratei S)) =\n                                     s1.\\<alpha> S \\<union>\n                                     s2.\\<alpha> s \\<and>\n                                     s2.invar\n(iterate_add_to_set s s2.ins (s1.iteratei S));\n        s1.invar s1; s2.invar s2\\<rbrakk>\n       \\<Longrightarrow> s2.invar (g_union s1 s2)", "unfolding g_union_alt"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s1 s2.\n       \\<lbrakk>\\<And>s S.\n                   \\<lbrakk>s2.invar s; s1.invar S\\<rbrakk>\n                   \\<Longrightarrow> s2.\\<alpha>\n(iterate_add_to_set s s2.ins (s1.iteratei S)) =\n                                     s1.\\<alpha> S \\<union>\n                                     s2.\\<alpha> s \\<and>\n                                     s2.invar\n(iterate_add_to_set s s2.ins (s1.iteratei S));\n        s1.invar s1; s2.invar s2\\<rbrakk>\n       \\<Longrightarrow> s2.\\<alpha>\n                          (iterate_add_to_set s2 s2.ins (s1.iteratei s1)) =\n                         s1.\\<alpha> s1 \\<union> s2.\\<alpha> s2\n 2. \\<And>s1 s2.\n       \\<lbrakk>\\<And>s S.\n                   \\<lbrakk>s2.invar s; s1.invar S\\<rbrakk>\n                   \\<Longrightarrow> s2.\\<alpha>\n(iterate_add_to_set s s2.ins (s1.iteratei S)) =\n                                     s1.\\<alpha> S \\<union>\n                                     s2.\\<alpha> s \\<and>\n                                     s2.invar\n(iterate_add_to_set s s2.ins (s1.iteratei S));\n        s1.invar s1; s2.invar s2\\<rbrakk>\n       \\<Longrightarrow> s2.invar\n                          (iterate_add_to_set s2 s2.ins (s1.iteratei s1))", "by simp_all"], ["proof (state)\nthis:\n  set_union s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar s2.\\<alpha> s2.invar\n   g_union\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma g_diff_impl:\n    \"set_diff s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar g_diff\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_diff s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar g_diff", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set_diff s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar g_diff", "have LIS: \"set_delete s1.\\<alpha> s1.invar s1.delete\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_delete s1.\\<alpha> s1.invar s1.delete", "by unfold_locales"], ["proof (state)\nthis:\n  set_delete s1.\\<alpha> s1.invar s1.delete\n\ngoal (1 subgoal):\n 1. set_diff s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar g_diff", "from iterate_diff_correct[OF LIS _ s2.iteratei_correct]"], ["proof (chain)\npicking this:\n  \\<lbrakk>s1.invar ?s; s2.invar ?S1\\<rbrakk>\n  \\<Longrightarrow> s1.\\<alpha>\n                     (iterate_diff_set ?s s1.delete (s2.iteratei ?S1)) =\n                    s1.\\<alpha> ?s - s2.\\<alpha> ?S1 \\<and>\n                    s1.invar\n                     (iterate_diff_set ?s s1.delete (s2.iteratei ?S1))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>s1.invar ?s; s2.invar ?S1\\<rbrakk>\n  \\<Longrightarrow> s1.\\<alpha>\n                     (iterate_diff_set ?s s1.delete (s2.iteratei ?S1)) =\n                    s1.\\<alpha> ?s - s2.\\<alpha> ?S1 \\<and>\n                    s1.invar\n                     (iterate_diff_set ?s s1.delete (s2.iteratei ?S1))\n\ngoal (1 subgoal):\n 1. set_diff s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar g_diff", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s1 s2.\n       \\<lbrakk>\\<And>s S.\n                   \\<lbrakk>s1.invar s; s2.invar S\\<rbrakk>\n                   \\<Longrightarrow> s1.\\<alpha>\n(iterate_diff_set s s1.delete (s2.iteratei S)) =\n                                     s1.\\<alpha> s - s2.\\<alpha> S \\<and>\n                                     s1.invar\n(iterate_diff_set s s1.delete (s2.iteratei S));\n        s1.invar s1; s2.invar s2\\<rbrakk>\n       \\<Longrightarrow> s1.\\<alpha> (g_diff s1 s2) =\n                         s1.\\<alpha> s1 - s2.\\<alpha> s2\n 2. \\<And>s1 s2.\n       \\<lbrakk>\\<And>s S.\n                   \\<lbrakk>s1.invar s; s2.invar S\\<rbrakk>\n                   \\<Longrightarrow> s1.\\<alpha>\n(iterate_diff_set s s1.delete (s2.iteratei S)) =\n                                     s1.\\<alpha> s - s2.\\<alpha> S \\<and>\n                                     s1.invar\n(iterate_diff_set s s1.delete (s2.iteratei S));\n        s1.invar s1; s2.invar s2\\<rbrakk>\n       \\<Longrightarrow> s1.invar (g_diff s1 s2)", "unfolding g_diff_alt"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s1 s2.\n       \\<lbrakk>\\<And>s S.\n                   \\<lbrakk>s1.invar s; s2.invar S\\<rbrakk>\n                   \\<Longrightarrow> s1.\\<alpha>\n(iterate_diff_set s s1.delete (s2.iteratei S)) =\n                                     s1.\\<alpha> s - s2.\\<alpha> S \\<and>\n                                     s1.invar\n(iterate_diff_set s s1.delete (s2.iteratei S));\n        s1.invar s1; s2.invar s2\\<rbrakk>\n       \\<Longrightarrow> s1.\\<alpha>\n                          (iterate_diff_set s1 s1.delete (s2.iteratei s2)) =\n                         s1.\\<alpha> s1 - s2.\\<alpha> s2\n 2. \\<And>s1 s2.\n       \\<lbrakk>\\<And>s S.\n                   \\<lbrakk>s1.invar s; s2.invar S\\<rbrakk>\n                   \\<Longrightarrow> s1.\\<alpha>\n(iterate_diff_set s s1.delete (s2.iteratei S)) =\n                                     s1.\\<alpha> s - s2.\\<alpha> S \\<and>\n                                     s1.invar\n(iterate_diff_set s s1.delete (s2.iteratei S));\n        s1.invar s1; s2.invar s2\\<rbrakk>\n       \\<Longrightarrow> s1.invar\n                          (iterate_diff_set s1 s1.delete (s2.iteratei s2))", "by simp_all"], ["proof (state)\nthis:\n  set_diff s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar g_diff\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma g_union_list_impl:\n    shows \"set_union_list s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar g_union_list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_union_list s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar g_union_list", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l.\n       Ball (set l) s1.invar \\<Longrightarrow>\n       s2.\\<alpha> (g_union_list l) =\n       \\<Union> {s1.\\<alpha> s1 |s1. s1 \\<in> set l}\n 2. \\<And>l.\n       Ball (set l) s1.invar \\<Longrightarrow> s2.invar (g_union_list l)", "fix l"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l.\n       Ball (set l) s1.invar \\<Longrightarrow>\n       s2.\\<alpha> (g_union_list l) =\n       \\<Union> {s1.\\<alpha> s1 |s1. s1 \\<in> set l}\n 2. \\<And>l.\n       Ball (set l) s1.invar \\<Longrightarrow> s2.invar (g_union_list l)", "note correct = s2.empty_correct set_union.union_correct[OF g_union_impl]"], ["proof (state)\nthis:\n  s2.\\<alpha> (s2.empty ()) = {}\n  s2.invar (s2.empty ())\n  \\<lbrakk>s1.invar ?s1.0; s2.invar ?s2.0\\<rbrakk>\n  \\<Longrightarrow> s2.\\<alpha> (g_union ?s1.0 ?s2.0) =\n                    s1.\\<alpha> ?s1.0 \\<union> s2.\\<alpha> ?s2.0\n  \\<lbrakk>s1.invar ?s1.0; s2.invar ?s2.0\\<rbrakk>\n  \\<Longrightarrow> s2.invar (g_union ?s1.0 ?s2.0)\n\ngoal (2 subgoals):\n 1. \\<And>l.\n       Ball (set l) s1.invar \\<Longrightarrow>\n       s2.\\<alpha> (g_union_list l) =\n       \\<Union> {s1.\\<alpha> s1 |s1. s1 \\<in> set l}\n 2. \\<And>l.\n       Ball (set l) s1.invar \\<Longrightarrow> s2.invar (g_union_list l)", "assume \"\\<forall>s1\\<in>set l. s1.invar s1\""], ["proof (state)\nthis:\n  Ball (set l) s1.invar\n\ngoal (2 subgoals):\n 1. \\<And>l.\n       Ball (set l) s1.invar \\<Longrightarrow>\n       s2.\\<alpha> (g_union_list l) =\n       \\<Union> {s1.\\<alpha> s1 |s1. s1 \\<in> set l}\n 2. \\<And>l.\n       Ball (set l) s1.invar \\<Longrightarrow> s2.invar (g_union_list l)", "hence aux: \"\\<And>s. s2.invar s \\<Longrightarrow>\n           s2.\\<alpha> (foldl (\\<lambda>s s'. g_union s' s) s l) \n           = \\<Union>{s1.\\<alpha> s1 |s1. s1 \\<in> set l} \\<union> s2.\\<alpha> s \\<and>\n           s2.invar (foldl (\\<lambda>s s'. g_union s' s) s l)\""], ["proof (prove)\nusing this:\n  Ball (set l) s1.invar\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       s2.invar s \\<Longrightarrow>\n       s2.\\<alpha> (foldl (\\<lambda>s s'. g_union s' s) s l) =\n       \\<Union> {s1.\\<alpha> s1 |s1. s1 \\<in> set l} \\<union>\n       s2.\\<alpha> s \\<and>\n       s2.invar (foldl (\\<lambda>s s'. g_union s' s) s l)", "by (induct l) (auto simp add: correct)"], ["proof (state)\nthis:\n  s2.invar ?s2 \\<Longrightarrow>\n  s2.\\<alpha> (foldl (\\<lambda>s s'. g_union s' s) ?s2 l) =\n  \\<Union> {s1.\\<alpha> s1 |s1. s1 \\<in> set l} \\<union>\n  s2.\\<alpha> ?s2 \\<and>\n  s2.invar (foldl (\\<lambda>s s'. g_union s' s) ?s2 l)\n\ngoal (2 subgoals):\n 1. \\<And>l.\n       Ball (set l) s1.invar \\<Longrightarrow>\n       s2.\\<alpha> (g_union_list l) =\n       \\<Union> {s1.\\<alpha> s1 |s1. s1 \\<in> set l}\n 2. \\<And>l.\n       Ball (set l) s1.invar \\<Longrightarrow> s2.invar (g_union_list l)", "from aux [of \"s2.empty ()\"]"], ["proof (chain)\npicking this:\n  s2.invar (s2.empty ()) \\<Longrightarrow>\n  s2.\\<alpha> (foldl (\\<lambda>s s'. g_union s' s) (s2.empty ()) l) =\n  \\<Union> {s1.\\<alpha> s1 |s1. s1 \\<in> set l} \\<union>\n  s2.\\<alpha> (s2.empty ()) \\<and>\n  s2.invar (foldl (\\<lambda>s s'. g_union s' s) (s2.empty ()) l)", "show \"s2.\\<alpha> (g_union_list l) = \\<Union>{s1.\\<alpha> s1 |s1. s1 \\<in> set l}\"\n         \"s2.invar (g_union_list l)\""], ["proof (prove)\nusing this:\n  s2.invar (s2.empty ()) \\<Longrightarrow>\n  s2.\\<alpha> (foldl (\\<lambda>s s'. g_union s' s) (s2.empty ()) l) =\n  \\<Union> {s1.\\<alpha> s1 |s1. s1 \\<in> set l} \\<union>\n  s2.\\<alpha> (s2.empty ()) \\<and>\n  s2.invar (foldl (\\<lambda>s s'. g_union s' s) (s2.empty ()) l)\n\ngoal (1 subgoal):\n 1. s2.\\<alpha> (g_union_list l) =\n    \\<Union> {s1.\\<alpha> s1 |s1. s1 \\<in> set l} &&&\n    s2.invar (g_union_list l)", "unfolding g_union_list_def"], ["proof (prove)\nusing this:\n  s2.invar (s2.empty ()) \\<Longrightarrow>\n  s2.\\<alpha> (foldl (\\<lambda>s s'. g_union s' s) (s2.empty ()) l) =\n  \\<Union> {s1.\\<alpha> s1 |s1. s1 \\<in> set l} \\<union>\n  s2.\\<alpha> (s2.empty ()) \\<and>\n  s2.invar (foldl (\\<lambda>s s'. g_union s' s) (s2.empty ()) l)\n\ngoal (1 subgoal):\n 1. s2.\\<alpha> (foldl (\\<lambda>s s'. g_union s' s) (s2.empty ()) l) =\n    \\<Union> {s1.\\<alpha> s1 |s1. s1 \\<in> set l} &&&\n    s2.invar (foldl (\\<lambda>s s'. g_union s' s) (s2.empty ()) l)", "by (simp_all add: correct)"], ["proof (state)\nthis:\n  s2.\\<alpha> (g_union_list l) =\n  \\<Union> {s1.\\<alpha> s1 |s1. s1 \\<in> set l}\n  s2.invar (g_union_list l)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma g_union_dj_impl:\n    \"set_union_dj s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar s2.\\<alpha> s2.invar g_union_dj\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_union_dj s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar s2.\\<alpha>\n     s2.invar g_union_dj", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s1 s2.\n       \\<lbrakk>s1.invar s1; s2.invar s2;\n        s1.\\<alpha> s1 \\<inter> s2.\\<alpha> s2 = {}\\<rbrakk>\n       \\<Longrightarrow> s2.\\<alpha> (g_union_dj s1 s2) =\n                         s1.\\<alpha> s1 \\<union> s2.\\<alpha> s2\n 2. \\<And>s1 s2.\n       \\<lbrakk>s1.invar s1; s2.invar s2;\n        s1.\\<alpha> s1 \\<inter> s2.\\<alpha> s2 = {}\\<rbrakk>\n       \\<Longrightarrow> s2.invar (g_union_dj s1 s2)", "fix s1 s2"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s1 s2.\n       \\<lbrakk>s1.invar s1; s2.invar s2;\n        s1.\\<alpha> s1 \\<inter> s2.\\<alpha> s2 = {}\\<rbrakk>\n       \\<Longrightarrow> s2.\\<alpha> (g_union_dj s1 s2) =\n                         s1.\\<alpha> s1 \\<union> s2.\\<alpha> s2\n 2. \\<And>s1 s2.\n       \\<lbrakk>s1.invar s1; s2.invar s2;\n        s1.\\<alpha> s1 \\<inter> s2.\\<alpha> s2 = {}\\<rbrakk>\n       \\<Longrightarrow> s2.invar (g_union_dj s1 s2)", "assume I: \n      \"s1.invar s1\" \n      \"s2.invar s2\""], ["proof (state)\nthis:\n  s1.invar s1\n  s2.invar s2\n\ngoal (2 subgoals):\n 1. \\<And>s1 s2.\n       \\<lbrakk>s1.invar s1; s2.invar s2;\n        s1.\\<alpha> s1 \\<inter> s2.\\<alpha> s2 = {}\\<rbrakk>\n       \\<Longrightarrow> s2.\\<alpha> (g_union_dj s1 s2) =\n                         s1.\\<alpha> s1 \\<union> s2.\\<alpha> s2\n 2. \\<And>s1 s2.\n       \\<lbrakk>s1.invar s1; s2.invar s2;\n        s1.\\<alpha> s1 \\<inter> s2.\\<alpha> s2 = {}\\<rbrakk>\n       \\<Longrightarrow> s2.invar (g_union_dj s1 s2)", "assume DJ: \"s1.\\<alpha> s1 \\<inter> s2.\\<alpha> s2 = {}\""], ["proof (state)\nthis:\n  s1.\\<alpha> s1 \\<inter> s2.\\<alpha> s2 = {}\n\ngoal (2 subgoals):\n 1. \\<And>s1 s2.\n       \\<lbrakk>s1.invar s1; s2.invar s2;\n        s1.\\<alpha> s1 \\<inter> s2.\\<alpha> s2 = {}\\<rbrakk>\n       \\<Longrightarrow> s2.\\<alpha> (g_union_dj s1 s2) =\n                         s1.\\<alpha> s1 \\<union> s2.\\<alpha> s2\n 2. \\<And>s1 s2.\n       \\<lbrakk>s1.invar s1; s2.invar s2;\n        s1.\\<alpha> s1 \\<inter> s2.\\<alpha> s2 = {}\\<rbrakk>\n       \\<Longrightarrow> s2.invar (g_union_dj s1 s2)", "have \"s2.\\<alpha> (g_union_dj s1 s2) \n      = s1.\\<alpha> s1 \\<union> s2.\\<alpha> s2\n      \\<and> s2.invar (g_union_dj s1 s2)\" (is \"?G1 \\<and> ?G2\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. s2.\\<alpha> (g_union_dj s1 s2) =\n    s1.\\<alpha> s1 \\<union> s2.\\<alpha> s2 \\<and>\n    s2.invar (g_union_dj s1 s2)", "unfolding g_union_dj_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. s2.\\<alpha> (s1.iterate s1 s2.ins_dj s2) =\n    s1.\\<alpha> s1 \\<union> s2.\\<alpha> s2 \\<and>\n    s2.invar (s1.iterate s1 s2.ins_dj s2)", "apply (rule_tac I=\"\\<lambda>it \\<sigma>. s2.invar \\<sigma> \\<and> s2.\\<alpha> \\<sigma> = it \\<union> s2.\\<alpha> s2\" \n        in s1.iterate_rule_insert_P)"], ["proof (prove)\ngoal (4 subgoals):\n 1. s1.invar s1\n 2. s2.invar s2 \\<and> s2.\\<alpha> s2 = {} \\<union> s2.\\<alpha> s2\n 3. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> s1.\\<alpha> s1 - it; it \\<subseteq> s1.\\<alpha> s1;\n        s2.invar \\<sigma> \\<and>\n        s2.\\<alpha> \\<sigma> = it \\<union> s2.\\<alpha> s2\\<rbrakk>\n       \\<Longrightarrow> s2.invar (s2.ins_dj x \\<sigma>) \\<and>\n                         s2.\\<alpha> (s2.ins_dj x \\<sigma>) =\n                         insert x it \\<union> s2.\\<alpha> s2\n 4. \\<And>\\<sigma>.\n       s2.invar \\<sigma> \\<and>\n       s2.\\<alpha> \\<sigma> =\n       s1.\\<alpha> s1 \\<union> s2.\\<alpha> s2 \\<Longrightarrow>\n       s2.\\<alpha> \\<sigma> = s1.\\<alpha> s1 \\<union> s2.\\<alpha> s2 \\<and>\n       s2.invar \\<sigma>", "using DJ"], ["proof (prove)\nusing this:\n  s1.\\<alpha> s1 \\<inter> s2.\\<alpha> s2 = {}\n\ngoal (4 subgoals):\n 1. s1.invar s1\n 2. s2.invar s2 \\<and> s2.\\<alpha> s2 = {} \\<union> s2.\\<alpha> s2\n 3. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> s1.\\<alpha> s1 - it; it \\<subseteq> s1.\\<alpha> s1;\n        s2.invar \\<sigma> \\<and>\n        s2.\\<alpha> \\<sigma> = it \\<union> s2.\\<alpha> s2\\<rbrakk>\n       \\<Longrightarrow> s2.invar (s2.ins_dj x \\<sigma>) \\<and>\n                         s2.\\<alpha> (s2.ins_dj x \\<sigma>) =\n                         insert x it \\<union> s2.\\<alpha> s2\n 4. \\<And>\\<sigma>.\n       s2.invar \\<sigma> \\<and>\n       s2.\\<alpha> \\<sigma> =\n       s1.\\<alpha> s1 \\<union> s2.\\<alpha> s2 \\<Longrightarrow>\n       s2.\\<alpha> \\<sigma> = s1.\\<alpha> s1 \\<union> s2.\\<alpha> s2 \\<and>\n       s2.invar \\<sigma>", "apply (simp_all add: I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> s1.\\<alpha> s1 \\<and> x \\<notin> it;\n        it \\<subseteq> s1.\\<alpha> s1;\n        s2.invar \\<sigma> \\<and>\n        s2.\\<alpha> \\<sigma> = it \\<union> s2.\\<alpha> s2;\n        s1.\\<alpha> s1 \\<inter> s2.\\<alpha> s2 = {}\\<rbrakk>\n       \\<Longrightarrow> s2.invar (s2.ins_dj x \\<sigma>) \\<and>\n                         s2.\\<alpha> (s2.ins_dj x \\<sigma>) =\n                         insert x (it \\<union> s2.\\<alpha> s2)", "apply (subgoal_tac \"x\\<notin>s2.\\<alpha> \\<sigma>\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> s1.\\<alpha> s1 \\<and> x \\<notin> it;\n        it \\<subseteq> s1.\\<alpha> s1;\n        s2.invar \\<sigma> \\<and>\n        s2.\\<alpha> \\<sigma> = it \\<union> s2.\\<alpha> s2;\n        s1.\\<alpha> s1 \\<inter> s2.\\<alpha> s2 = {};\n        x \\<notin> s2.\\<alpha> \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> s2.invar (s2.ins_dj x \\<sigma>) \\<and>\n                         s2.\\<alpha> (s2.ins_dj x \\<sigma>) =\n                         insert x (it \\<union> s2.\\<alpha> s2)\n 2. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> s1.\\<alpha> s1 \\<and> x \\<notin> it;\n        it \\<subseteq> s1.\\<alpha> s1;\n        s2.invar \\<sigma> \\<and>\n        s2.\\<alpha> \\<sigma> = it \\<union> s2.\\<alpha> s2;\n        s1.\\<alpha> s1 \\<inter> s2.\\<alpha> s2 = {}\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> s2.\\<alpha> \\<sigma>", "apply (simp add: s2.ins_dj_correct I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> s1.\\<alpha> s1 \\<and> x \\<notin> it;\n        it \\<subseteq> s1.\\<alpha> s1;\n        s2.invar \\<sigma> \\<and>\n        s2.\\<alpha> \\<sigma> = it \\<union> s2.\\<alpha> s2;\n        s1.\\<alpha> s1 \\<inter> s2.\\<alpha> s2 = {}\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> s2.\\<alpha> \\<sigma>", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  s2.\\<alpha> (g_union_dj s1 s2) =\n  s1.\\<alpha> s1 \\<union> s2.\\<alpha> s2 \\<and>\n  s2.invar (g_union_dj s1 s2)\n\ngoal (2 subgoals):\n 1. \\<And>s1 s2.\n       \\<lbrakk>s1.invar s1; s2.invar s2;\n        s1.\\<alpha> s1 \\<inter> s2.\\<alpha> s2 = {}\\<rbrakk>\n       \\<Longrightarrow> s2.\\<alpha> (g_union_dj s1 s2) =\n                         s1.\\<alpha> s1 \\<union> s2.\\<alpha> s2\n 2. \\<And>s1 s2.\n       \\<lbrakk>s1.invar s1; s2.invar s2;\n        s1.\\<alpha> s1 \\<inter> s2.\\<alpha> s2 = {}\\<rbrakk>\n       \\<Longrightarrow> s2.invar (g_union_dj s1 s2)", "thus ?G1 ?G2"], ["proof (prove)\nusing this:\n  s2.\\<alpha> (g_union_dj s1 s2) =\n  s1.\\<alpha> s1 \\<union> s2.\\<alpha> s2 \\<and>\n  s2.invar (g_union_dj s1 s2)\n\ngoal (1 subgoal):\n 1. s2.\\<alpha> (g_union_dj s1 s2) =\n    s1.\\<alpha> s1 \\<union> s2.\\<alpha> s2 &&&\n    s2.invar (g_union_dj s1 s2)", "by auto"], ["proof (state)\nthis:\n  s2.\\<alpha> (g_union_dj s1 s2) = s1.\\<alpha> s1 \\<union> s2.\\<alpha> s2\n  s2.invar (g_union_dj s1 s2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma g_disjoint_witness_impl: \n    \"set_disjoint_witness s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar g_disjoint_witness\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_disjoint_witness s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar\n     g_disjoint_witness", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set_disjoint_witness s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar\n     g_disjoint_witness", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_disjoint_witness s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar\n     g_disjoint_witness", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s1 s2.\n       \\<lbrakk>s1.invar s1; s2.invar s2;\n        g_disjoint_witness s1 s2 = None\\<rbrakk>\n       \\<Longrightarrow> s1.\\<alpha> s1 \\<inter> s2.\\<alpha> s2 = {}\n 2. \\<And>s1 s2 a.\n       \\<lbrakk>s1.invar s1; s2.invar s2;\n        g_disjoint_witness s1 s2 = Some a\\<rbrakk>\n       \\<Longrightarrow> a \\<in> s1.\\<alpha> s1 \\<inter> s2.\\<alpha> s2", "unfolding g_disjoint_witness_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s1 s2.\n       \\<lbrakk>s1.invar s1; s2.invar s2;\n        s1.sel s1 (\\<lambda>x. s2.memb x s2) = None\\<rbrakk>\n       \\<Longrightarrow> s1.\\<alpha> s1 \\<inter> s2.\\<alpha> s2 = {}\n 2. \\<And>s1 s2 a.\n       \\<lbrakk>s1.invar s1; s2.invar s2;\n        s1.sel s1 (\\<lambda>x. s2.memb x s2) = Some a\\<rbrakk>\n       \\<Longrightarrow> a \\<in> s1.\\<alpha> s1 \\<inter> s2.\\<alpha> s2", "by (auto dest: s1.sel'_noneD s1.sel'_someD simp: s2.memb_correct)"], ["proof (state)\nthis:\n  set_disjoint_witness s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar\n   g_disjoint_witness\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma g_disjoint_impl: \n    \"set_disjoint s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar g_disjoint\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_disjoint s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar g_disjoint", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set_disjoint s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar g_disjoint", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_disjoint s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar g_disjoint", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s1 s2.\n       \\<lbrakk>s1.invar s1; s2.invar s2\\<rbrakk>\n       \\<Longrightarrow> g_disjoint s1 s2 =\n                         (s1.\\<alpha> s1 \\<inter> s2.\\<alpha> s2 = {})", "unfolding g_disjoint_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s1 s2.\n       \\<lbrakk>s1.invar s1; s2.invar s2\\<rbrakk>\n       \\<Longrightarrow> s1.ball s1 (\\<lambda>x. \\<not> s2.memb x s2) =\n                         (s1.\\<alpha> s1 \\<inter> s2.\\<alpha> s2 = {})", "by (auto simp: s2.memb_correct s1.ball_correct)"], ["proof (state)\nthis:\n  set_disjoint s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar g_disjoint\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "sublocale g_set_xx_loc < \n  set_copy s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar g_copy"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_copy s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar g_copy", "by (rule g_copy_impl)"], ["", "sublocale g_set_xx_loc < \n  set_filter s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar g_filter"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_filter s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar g_filter", "by (rule g_filter_impl)"], ["", "sublocale g_set_xx_loc < \n  set_union s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar s2.\\<alpha> s2.invar g_union"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_union s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar s2.\\<alpha> s2.invar\n     g_union", "by (rule g_union_impl)"], ["", "sublocale g_set_xx_loc < \n  set_union_dj s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar s2.\\<alpha> s2.invar g_union_dj"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_union_dj s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar s2.\\<alpha>\n     s2.invar g_union_dj", "by (rule g_union_dj_impl)"], ["", "sublocale g_set_xx_loc < \n  set_diff s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar g_diff"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_diff s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar g_diff", "by (rule g_diff_impl)"], ["", "sublocale g_set_xx_loc < \n  set_disjoint_witness s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar g_disjoint_witness"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_disjoint_witness s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar\n     g_disjoint_witness", "by (rule g_disjoint_witness_impl)"], ["", "sublocale g_set_xx_loc < \n  set_disjoint s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar g_disjoint"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_disjoint s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar g_disjoint", "by (rule g_disjoint_impl)"], ["", "(*sublocale StdBasicSetDefs < g_set_xx: g_set_xx_defs_loc ops ops .\nsublocale StdBasicSet < g_set_xx: g_set_xx_loc ops ops\n  by unfold_locales\n*)"], ["", "locale g_set_xxx_defs_loc =\n  s1: StdSetDefs ops1 +\n  s2: StdSetDefs ops2 +\n  s3: StdSetDefs ops3\n  for ops1 :: \"('x,'s1,'more1) set_ops_scheme\"\n  and ops2 :: \"('x,'s2,'more2) set_ops_scheme\"\n  and ops3 :: \"('x,'s3,'more3) set_ops_scheme\"\nbegin"], ["", "definition \"g_inter s1 s2 \\<equiv>\n    s1.iterate s1 (\\<lambda>x s. if s2.memb x s2 then s3.ins_dj x s else s) \n      (s3.empty ())\""], ["", "end"], ["", "locale g_set_xxx_loc = g_set_xxx_defs_loc ops1 ops2 ops3 +\n  s1: StdSet ops1 +\n  s2: StdSet ops2 +\n  s3: StdSet ops3\n  for ops1 :: \"('x,'s1,'more1) set_ops_scheme\"\n  and ops2 :: \"('x,'s2,'more2) set_ops_scheme\"\n  and ops3 :: \"('x,'s3,'more3) set_ops_scheme\"\nbegin"], ["", "lemma g_inter_impl: \"set_inter s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar s3.\\<alpha> s3.invar\n    g_inter\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_inter s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar s3.\\<alpha> s3.invar\n     g_inter", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s1 s2.\n       \\<lbrakk>s1.invar s1; s2.invar s2\\<rbrakk>\n       \\<Longrightarrow> s3.\\<alpha> (g_inter s1 s2) =\n                         s1.\\<alpha> s1 \\<inter> s2.\\<alpha> s2\n 2. \\<And>s1 s2.\n       \\<lbrakk>s1.invar s1; s2.invar s2\\<rbrakk>\n       \\<Longrightarrow> s3.invar (g_inter s1 s2)", "fix s1 s2"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s1 s2.\n       \\<lbrakk>s1.invar s1; s2.invar s2\\<rbrakk>\n       \\<Longrightarrow> s3.\\<alpha> (g_inter s1 s2) =\n                         s1.\\<alpha> s1 \\<inter> s2.\\<alpha> s2\n 2. \\<And>s1 s2.\n       \\<lbrakk>s1.invar s1; s2.invar s2\\<rbrakk>\n       \\<Longrightarrow> s3.invar (g_inter s1 s2)", "assume I: \n      \"s1.invar s1\" \n      \"s2.invar s2\""], ["proof (state)\nthis:\n  s1.invar s1\n  s2.invar s2\n\ngoal (2 subgoals):\n 1. \\<And>s1 s2.\n       \\<lbrakk>s1.invar s1; s2.invar s2\\<rbrakk>\n       \\<Longrightarrow> s3.\\<alpha> (g_inter s1 s2) =\n                         s1.\\<alpha> s1 \\<inter> s2.\\<alpha> s2\n 2. \\<And>s1 s2.\n       \\<lbrakk>s1.invar s1; s2.invar s2\\<rbrakk>\n       \\<Longrightarrow> s3.invar (g_inter s1 s2)", "have \"s3.\\<alpha> (g_inter s1 s2) = s1.\\<alpha> s1 \\<inter> s2.\\<alpha> s2 \\<and> s3.invar (g_inter s1 s2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s3.\\<alpha> (g_inter s1 s2) =\n    s1.\\<alpha> s1 \\<inter> s2.\\<alpha> s2 \\<and>\n    s3.invar (g_inter s1 s2)", "unfolding g_inter_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. s3.\\<alpha>\n     (s1.iterate s1\n       (\\<lambda>x s. if s2.memb x s2 then s3.ins_dj x s else s)\n       (s3.empty ())) =\n    s1.\\<alpha> s1 \\<inter> s2.\\<alpha> s2 \\<and>\n    s3.invar\n     (s1.iterate s1\n       (\\<lambda>x s. if s2.memb x s2 then s3.ins_dj x s else s)\n       (s3.empty ()))", "apply (rule_tac I=\"\\<lambda>it \\<sigma>. s3.\\<alpha> \\<sigma> = it \\<inter> s2.\\<alpha> s2 \\<and> s3.invar \\<sigma>\" \n        in s1.iterate_rule_insert_P)"], ["proof (prove)\ngoal (4 subgoals):\n 1. s1.invar s1\n 2. s3.\\<alpha> (s3.empty ()) = {} \\<inter> s2.\\<alpha> s2 \\<and>\n    s3.invar (s3.empty ())\n 3. \\<And>x it \\<sigma>.\n       \\<lbrakk>x \\<in> s1.\\<alpha> s1 - it; it \\<subseteq> s1.\\<alpha> s1;\n        s3.\\<alpha> \\<sigma> = it \\<inter> s2.\\<alpha> s2 \\<and>\n        s3.invar \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> s3.\\<alpha>\n                          (if s2.memb x s2 then s3.ins_dj x \\<sigma>\n                           else \\<sigma>) =\n                         insert x it \\<inter> s2.\\<alpha> s2 \\<and>\n                         s3.invar\n                          (if s2.memb x s2 then s3.ins_dj x \\<sigma>\n                           else \\<sigma>)\n 4. \\<And>\\<sigma>.\n       s3.\\<alpha> \\<sigma> = s1.\\<alpha> s1 \\<inter> s2.\\<alpha> s2 \\<and>\n       s3.invar \\<sigma> \\<Longrightarrow>\n       s3.\\<alpha> \\<sigma> = s1.\\<alpha> s1 \\<inter> s2.\\<alpha> s2 \\<and>\n       s3.invar \\<sigma>", "apply (simp_all add: I s3.empty_correct s3.ins_dj_correct s2.memb_correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  s3.\\<alpha> (g_inter s1 s2) =\n  s1.\\<alpha> s1 \\<inter> s2.\\<alpha> s2 \\<and>\n  s3.invar (g_inter s1 s2)\n\ngoal (2 subgoals):\n 1. \\<And>s1 s2.\n       \\<lbrakk>s1.invar s1; s2.invar s2\\<rbrakk>\n       \\<Longrightarrow> s3.\\<alpha> (g_inter s1 s2) =\n                         s1.\\<alpha> s1 \\<inter> s2.\\<alpha> s2\n 2. \\<And>s1 s2.\n       \\<lbrakk>s1.invar s1; s2.invar s2\\<rbrakk>\n       \\<Longrightarrow> s3.invar (g_inter s1 s2)", "thus \"s3.\\<alpha> (g_inter s1 s2) = s1.\\<alpha> s1 \\<inter> s2.\\<alpha> s2\" \n      and \"s3.invar (g_inter s1 s2)\""], ["proof (prove)\nusing this:\n  s3.\\<alpha> (g_inter s1 s2) =\n  s1.\\<alpha> s1 \\<inter> s2.\\<alpha> s2 \\<and>\n  s3.invar (g_inter s1 s2)\n\ngoal (1 subgoal):\n 1. s3.\\<alpha> (g_inter s1 s2) = s1.\\<alpha> s1 \\<inter> s2.\\<alpha> s2 &&&\n    s3.invar (g_inter s1 s2)", "by auto"], ["proof (state)\nthis:\n  s3.\\<alpha> (g_inter s1 s2) = s1.\\<alpha> s1 \\<inter> s2.\\<alpha> s2\n  s3.invar (g_inter s1 s2)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "sublocale g_set_xxx_loc \n  < set_inter s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar s3.\\<alpha> s3.invar g_inter"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_inter s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar s3.\\<alpha> s3.invar\n     g_inter", "by (rule g_inter_impl)"], ["", "(*sublocale StdBasicSetDefs < g_set_xxx: g_set_xxx_defs_loc ops ops ops .\nsublocale StdBasicSet < g_set_xxx: g_set_xxx_loc ops ops ops\n  by unfold_locales\n*)"], ["", "locale g_set_xy_defs_loc = \n  s1: StdSet ops1 + s2: StdSet ops2\n  for ops1 :: \"('x1,'s1,'more1) set_ops_scheme\"\n  and ops2 :: \"('x2,'s2,'more2) set_ops_scheme\"\nbegin"], ["", "definition \"g_image_filter f s \\<equiv> \n    s1.iterate s \n      (\\<lambda>x res. case f x of Some v \\<Rightarrow> s2.ins v res | _ \\<Rightarrow> res) \n      (s2.empty ())\""], ["", "definition \"g_image f s \\<equiv> \n    s1.iterate s (\\<lambda>x res. s2.ins (f x) res) (s2.empty ())\""], ["", "definition \"g_inj_image_filter f s \\<equiv> \n    s1.iterate s \n      (\\<lambda>x res. case f x of Some v \\<Rightarrow> s2.ins_dj v res | _ \\<Rightarrow> res) \n      (s2.empty ())\""], ["", "definition \"g_inj_image f s \\<equiv> \n    s1.iterate s (\\<lambda>x res. s2.ins_dj (f x) res) (s2.empty ())\""], ["", "end"], ["", "locale g_set_xy_loc = g_set_xy_defs_loc ops1 ops2 +\n  s1: StdSet ops1 + s2: StdSet ops2\n  for ops1 :: \"('x1,'s1,'more1) set_ops_scheme\"\n  and ops2 :: \"('x2,'s2,'more2) set_ops_scheme\"\nbegin"], ["", "lemma g_image_filter_impl: \n    \"set_image_filter s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar g_image_filter\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_image_filter s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar\n     g_image_filter", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s f.\n       s1.invar s \\<Longrightarrow>\n       s2.\\<alpha> (g_image_filter f s) =\n       {b. \\<exists>a\\<in>s1.\\<alpha> s. f a = Some b}\n 2. \\<And>s f. s1.invar s \\<Longrightarrow> s2.invar (g_image_filter f s)", "fix f s"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s f.\n       s1.invar s \\<Longrightarrow>\n       s2.\\<alpha> (g_image_filter f s) =\n       {b. \\<exists>a\\<in>s1.\\<alpha> s. f a = Some b}\n 2. \\<And>s f. s1.invar s \\<Longrightarrow> s2.invar (g_image_filter f s)", "assume I: \"s1.invar s\""], ["proof (state)\nthis:\n  s1.invar s\n\ngoal (2 subgoals):\n 1. \\<And>s f.\n       s1.invar s \\<Longrightarrow>\n       s2.\\<alpha> (g_image_filter f s) =\n       {b. \\<exists>a\\<in>s1.\\<alpha> s. f a = Some b}\n 2. \\<And>s f. s1.invar s \\<Longrightarrow> s2.invar (g_image_filter f s)", "have A: \"g_image_filter f s == \n         iterate_to_set s2.empty s2.ins \n           (set_iterator_image_filter f (s1.iteratei s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g_image_filter f s \\<equiv>\n    iterate_to_set s2.empty s2.ins\n     (set_iterator_image_filter f (s1.iteratei s))", "unfolding g_image_filter_def \n        iterate_to_set_alt_def set_iterator_image_filter_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. s1.iterate s\n     (\\<lambda>x res.\n         case f x of None \\<Rightarrow> res\n         | Some v \\<Rightarrow> s2.ins v res)\n     (s2.empty ()) \\<equiv>\n    s1.iterate s\n     (\\<lambda>x \\<sigma>.\n         case f x of None \\<Rightarrow> \\<sigma>\n         | Some x' \\<Rightarrow> s2.ins x' \\<sigma>)\n     (s2.empty ())", "by simp"], ["proof (state)\nthis:\n  g_image_filter f s \\<equiv>\n  iterate_to_set s2.empty s2.ins\n   (set_iterator_image_filter f (s1.iteratei s))\n\ngoal (2 subgoals):\n 1. \\<And>s f.\n       s1.invar s \\<Longrightarrow>\n       s2.\\<alpha> (g_image_filter f s) =\n       {b. \\<exists>a\\<in>s1.\\<alpha> s. f a = Some b}\n 2. \\<And>s f. s1.invar s \\<Longrightarrow> s2.invar (g_image_filter f s)", "have ins: \"set_ins s2.\\<alpha> s2.invar s2.ins\"\n      and emp: \"set_empty s2.\\<alpha> s2.invar s2.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_ins s2.\\<alpha> s2.invar s2.ins &&&\n    set_empty s2.\\<alpha> s2.invar s2.empty", "by unfold_locales"], ["proof (state)\nthis:\n  set_ins s2.\\<alpha> s2.invar s2.ins\n  set_empty s2.\\<alpha> s2.invar s2.empty\n\ngoal (2 subgoals):\n 1. \\<And>s f.\n       s1.invar s \\<Longrightarrow>\n       s2.\\<alpha> (g_image_filter f s) =\n       {b. \\<exists>a\\<in>s1.\\<alpha> s. f a = Some b}\n 2. \\<And>s f. s1.invar s \\<Longrightarrow> s2.invar (g_image_filter f s)", "from iterate_image_filter_to_set_correct[OF ins emp s1.iteratei_correct]"], ["proof (chain)\npicking this:\n  s1.invar ?S1 \\<Longrightarrow>\n  s2.\\<alpha>\n   (iterate_to_set s2.empty s2.ins\n     (set_iterator_image_filter ?f (s1.iteratei ?S1))) =\n  {b. \\<exists>a. a \\<in> s1.\\<alpha> ?S1 \\<and> ?f a = Some b} \\<and>\n  s2.invar\n   (iterate_to_set s2.empty s2.ins\n     (set_iterator_image_filter ?f (s1.iteratei ?S1)))", "show \"s2.\\<alpha> (g_image_filter f s) =\n          {b. \\<exists>a\\<in>s1.\\<alpha> s. f a = Some b}\"\n         \"s2.invar (g_image_filter f s)\""], ["proof (prove)\nusing this:\n  s1.invar ?S1 \\<Longrightarrow>\n  s2.\\<alpha>\n   (iterate_to_set s2.empty s2.ins\n     (set_iterator_image_filter ?f (s1.iteratei ?S1))) =\n  {b. \\<exists>a. a \\<in> s1.\\<alpha> ?S1 \\<and> ?f a = Some b} \\<and>\n  s2.invar\n   (iterate_to_set s2.empty s2.ins\n     (set_iterator_image_filter ?f (s1.iteratei ?S1)))\n\ngoal (1 subgoal):\n 1. s2.\\<alpha> (g_image_filter f s) =\n    {b. \\<exists>a\\<in>s1.\\<alpha> s. f a = Some b} &&&\n    s2.invar (g_image_filter f s)", "unfolding A"], ["proof (prove)\nusing this:\n  s1.invar ?S1 \\<Longrightarrow>\n  s2.\\<alpha>\n   (iterate_to_set s2.empty s2.ins\n     (set_iterator_image_filter ?f (s1.iteratei ?S1))) =\n  {b. \\<exists>a. a \\<in> s1.\\<alpha> ?S1 \\<and> ?f a = Some b} \\<and>\n  s2.invar\n   (iterate_to_set s2.empty s2.ins\n     (set_iterator_image_filter ?f (s1.iteratei ?S1)))\n\ngoal (1 subgoal):\n 1. s2.\\<alpha>\n     (iterate_to_set s2.empty s2.ins\n       (set_iterator_image_filter f (s1.iteratei s))) =\n    {b. \\<exists>a\\<in>s1.\\<alpha> s. f a = Some b} &&&\n    s2.invar\n     (iterate_to_set s2.empty s2.ins\n       (set_iterator_image_filter f (s1.iteratei s)))", "using I"], ["proof (prove)\nusing this:\n  s1.invar ?S1 \\<Longrightarrow>\n  s2.\\<alpha>\n   (iterate_to_set s2.empty s2.ins\n     (set_iterator_image_filter ?f (s1.iteratei ?S1))) =\n  {b. \\<exists>a. a \\<in> s1.\\<alpha> ?S1 \\<and> ?f a = Some b} \\<and>\n  s2.invar\n   (iterate_to_set s2.empty s2.ins\n     (set_iterator_image_filter ?f (s1.iteratei ?S1)))\n  s1.invar s\n\ngoal (1 subgoal):\n 1. s2.\\<alpha>\n     (iterate_to_set s2.empty s2.ins\n       (set_iterator_image_filter f (s1.iteratei s))) =\n    {b. \\<exists>a\\<in>s1.\\<alpha> s. f a = Some b} &&&\n    s2.invar\n     (iterate_to_set s2.empty s2.ins\n       (set_iterator_image_filter f (s1.iteratei s)))", "by auto"], ["proof (state)\nthis:\n  s2.\\<alpha> (g_image_filter f s) =\n  {b. \\<exists>a\\<in>s1.\\<alpha> s. f a = Some b}\n  s2.invar (g_image_filter f s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma g_image_alt: \"g_image f s = g_image_filter (Some o f) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g_image f s = g_image_filter (Some \\<circ> f) s", "unfolding g_image_def g_image_filter_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. s1.iterate s (\\<lambda>x. s2.ins (f x)) (s2.empty ()) =\n    s1.iterate s\n     (\\<lambda>x res.\n         case (Some \\<circ> f) x of None \\<Rightarrow> res\n         | Some v \\<Rightarrow> s2.ins v res)\n     (s2.empty ())", "by auto"], ["", "lemma g_image_impl: \"set_image s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar g_image\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_image s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar g_image", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set_image s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar g_image", "interpret set_image_filter s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar g_image_filter"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_image_filter s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar\n     g_image_filter", "by (rule g_image_filter_impl)"], ["proof (state)\ngoal (1 subgoal):\n 1. set_image s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar g_image", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_image s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar g_image", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s f.\n       s1.invar s \\<Longrightarrow>\n       s2.\\<alpha> (g_image f s) = f ` s1.\\<alpha> s\n 2. \\<And>s f. s1.invar s \\<Longrightarrow> s2.invar (g_image f s)", "unfolding g_image_alt"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s f.\n       s1.invar s \\<Longrightarrow>\n       s2.\\<alpha> (g_image_filter (Some \\<circ> f) s) = f ` s1.\\<alpha> s\n 2. \\<And>s f.\n       s1.invar s \\<Longrightarrow>\n       s2.invar (g_image_filter (Some \\<circ> f) s)", "by (auto simp add: image_filter_correct)"], ["proof (state)\nthis:\n  set_image s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar g_image\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma g_inj_image_filter_impl: \n    \"set_inj_image_filter s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar g_inj_image_filter\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_inj_image_filter s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar\n     g_inj_image_filter", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s f.\n       \\<lbrakk>s1.invar s; inj_on f (s1.\\<alpha> s \\<inter> dom f)\\<rbrakk>\n       \\<Longrightarrow> s2.\\<alpha> (g_inj_image_filter f s) =\n                         {b. \\<exists>a\\<in>s1.\\<alpha> s. f a = Some b}\n 2. \\<And>s f.\n       \\<lbrakk>s1.invar s; inj_on f (s1.\\<alpha> s \\<inter> dom f)\\<rbrakk>\n       \\<Longrightarrow> s2.invar (g_inj_image_filter f s)", "fix f::\"'x1 \\<rightharpoonup> 'x2\" and s"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s f.\n       \\<lbrakk>s1.invar s; inj_on f (s1.\\<alpha> s \\<inter> dom f)\\<rbrakk>\n       \\<Longrightarrow> s2.\\<alpha> (g_inj_image_filter f s) =\n                         {b. \\<exists>a\\<in>s1.\\<alpha> s. f a = Some b}\n 2. \\<And>s f.\n       \\<lbrakk>s1.invar s; inj_on f (s1.\\<alpha> s \\<inter> dom f)\\<rbrakk>\n       \\<Longrightarrow> s2.invar (g_inj_image_filter f s)", "assume I: \"s1.invar s\" and INJ: \"inj_on f (s1.\\<alpha> s \\<inter> dom f)\""], ["proof (state)\nthis:\n  s1.invar s\n  inj_on f (s1.\\<alpha> s \\<inter> dom f)\n\ngoal (2 subgoals):\n 1. \\<And>s f.\n       \\<lbrakk>s1.invar s; inj_on f (s1.\\<alpha> s \\<inter> dom f)\\<rbrakk>\n       \\<Longrightarrow> s2.\\<alpha> (g_inj_image_filter f s) =\n                         {b. \\<exists>a\\<in>s1.\\<alpha> s. f a = Some b}\n 2. \\<And>s f.\n       \\<lbrakk>s1.invar s; inj_on f (s1.\\<alpha> s \\<inter> dom f)\\<rbrakk>\n       \\<Longrightarrow> s2.invar (g_inj_image_filter f s)", "have A: \"g_inj_image_filter f s == \n         iterate_to_set s2.empty s2.ins_dj \n           (set_iterator_image_filter f (s1.iteratei s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g_inj_image_filter f s \\<equiv>\n    iterate_to_set s2.empty s2.ins_dj\n     (set_iterator_image_filter f (s1.iteratei s))", "unfolding g_inj_image_filter_def \n        iterate_to_set_alt_def set_iterator_image_filter_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. s1.iterate s\n     (\\<lambda>x res.\n         case f x of None \\<Rightarrow> res\n         | Some v \\<Rightarrow> s2.ins_dj v res)\n     (s2.empty ()) \\<equiv>\n    s1.iterate s\n     (\\<lambda>x \\<sigma>.\n         case f x of None \\<Rightarrow> \\<sigma>\n         | Some x' \\<Rightarrow> s2.ins_dj x' \\<sigma>)\n     (s2.empty ())", "by simp"], ["proof (state)\nthis:\n  g_inj_image_filter f s \\<equiv>\n  iterate_to_set s2.empty s2.ins_dj\n   (set_iterator_image_filter f (s1.iteratei s))\n\ngoal (2 subgoals):\n 1. \\<And>s f.\n       \\<lbrakk>s1.invar s; inj_on f (s1.\\<alpha> s \\<inter> dom f)\\<rbrakk>\n       \\<Longrightarrow> s2.\\<alpha> (g_inj_image_filter f s) =\n                         {b. \\<exists>a\\<in>s1.\\<alpha> s. f a = Some b}\n 2. \\<And>s f.\n       \\<lbrakk>s1.invar s; inj_on f (s1.\\<alpha> s \\<inter> dom f)\\<rbrakk>\n       \\<Longrightarrow> s2.invar (g_inj_image_filter f s)", "have ins_dj: \"set_ins_dj s2.\\<alpha> s2.invar s2.ins_dj\"\n      and emp: \"set_empty s2.\\<alpha> s2.invar s2.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_ins_dj s2.\\<alpha> s2.invar s2.ins_dj &&&\n    set_empty s2.\\<alpha> s2.invar s2.empty", "by unfold_locales"], ["proof (state)\nthis:\n  set_ins_dj s2.\\<alpha> s2.invar s2.ins_dj\n  set_empty s2.\\<alpha> s2.invar s2.empty\n\ngoal (2 subgoals):\n 1. \\<And>s f.\n       \\<lbrakk>s1.invar s; inj_on f (s1.\\<alpha> s \\<inter> dom f)\\<rbrakk>\n       \\<Longrightarrow> s2.\\<alpha> (g_inj_image_filter f s) =\n                         {b. \\<exists>a\\<in>s1.\\<alpha> s. f a = Some b}\n 2. \\<And>s f.\n       \\<lbrakk>s1.invar s; inj_on f (s1.\\<alpha> s \\<inter> dom f)\\<rbrakk>\n       \\<Longrightarrow> s2.invar (g_inj_image_filter f s)", "from set_iterator_image_filter_correct[OF s1.iteratei_correct[OF I] INJ]"], ["proof (chain)\npicking this:\n  set_iterator (set_iterator_image_filter f (s1.iteratei s))\n   {y. \\<exists>x. x \\<in> s1.\\<alpha> s \\<and> f x = Some y}", "have iti_s1_filter: \"set_iterator \n      (set_iterator_image_filter f (s1.iteratei s))\n      {y. \\<exists>x. x \\<in> s1.\\<alpha> s \\<and> f x = Some y}\""], ["proof (prove)\nusing this:\n  set_iterator (set_iterator_image_filter f (s1.iteratei s))\n   {y. \\<exists>x. x \\<in> s1.\\<alpha> s \\<and> f x = Some y}\n\ngoal (1 subgoal):\n 1. set_iterator (set_iterator_image_filter f (s1.iteratei s))\n     {y. \\<exists>x. x \\<in> s1.\\<alpha> s \\<and> f x = Some y}", "by simp"], ["proof (state)\nthis:\n  set_iterator (set_iterator_image_filter f (s1.iteratei s))\n   {y. \\<exists>x. x \\<in> s1.\\<alpha> s \\<and> f x = Some y}\n\ngoal (2 subgoals):\n 1. \\<And>s f.\n       \\<lbrakk>s1.invar s; inj_on f (s1.\\<alpha> s \\<inter> dom f)\\<rbrakk>\n       \\<Longrightarrow> s2.\\<alpha> (g_inj_image_filter f s) =\n                         {b. \\<exists>a\\<in>s1.\\<alpha> s. f a = Some b}\n 2. \\<And>s f.\n       \\<lbrakk>s1.invar s; inj_on f (s1.\\<alpha> s \\<inter> dom f)\\<rbrakk>\n       \\<Longrightarrow> s2.invar (g_inj_image_filter f s)", "from iterate_to_set_correct[OF ins_dj emp, OF iti_s1_filter]"], ["proof (chain)\npicking this:\n  s2.\\<alpha>\n   (iterate_to_set s2.empty s2.ins_dj\n     (set_iterator_image_filter f (s1.iteratei s))) =\n  {y. \\<exists>x. x \\<in> s1.\\<alpha> s \\<and> f x = Some y} \\<and>\n  s2.invar\n   (iterate_to_set s2.empty s2.ins_dj\n     (set_iterator_image_filter f (s1.iteratei s)))", "show \"s2.\\<alpha> (g_inj_image_filter f s) =\n          {b. \\<exists>a\\<in>s1.\\<alpha> s. f a = Some b}\"\n         \"s2.invar (g_inj_image_filter f s)\""], ["proof (prove)\nusing this:\n  s2.\\<alpha>\n   (iterate_to_set s2.empty s2.ins_dj\n     (set_iterator_image_filter f (s1.iteratei s))) =\n  {y. \\<exists>x. x \\<in> s1.\\<alpha> s \\<and> f x = Some y} \\<and>\n  s2.invar\n   (iterate_to_set s2.empty s2.ins_dj\n     (set_iterator_image_filter f (s1.iteratei s)))\n\ngoal (1 subgoal):\n 1. s2.\\<alpha> (g_inj_image_filter f s) =\n    {b. \\<exists>a\\<in>s1.\\<alpha> s. f a = Some b} &&&\n    s2.invar (g_inj_image_filter f s)", "unfolding A"], ["proof (prove)\nusing this:\n  s2.\\<alpha>\n   (iterate_to_set s2.empty s2.ins_dj\n     (set_iterator_image_filter f (s1.iteratei s))) =\n  {y. \\<exists>x. x \\<in> s1.\\<alpha> s \\<and> f x = Some y} \\<and>\n  s2.invar\n   (iterate_to_set s2.empty s2.ins_dj\n     (set_iterator_image_filter f (s1.iteratei s)))\n\ngoal (1 subgoal):\n 1. s2.\\<alpha>\n     (iterate_to_set s2.empty s2.ins_dj\n       (set_iterator_image_filter f (s1.iteratei s))) =\n    {b. \\<exists>a\\<in>s1.\\<alpha> s. f a = Some b} &&&\n    s2.invar\n     (iterate_to_set s2.empty s2.ins_dj\n       (set_iterator_image_filter f (s1.iteratei s)))", "by auto"], ["proof (state)\nthis:\n  s2.\\<alpha> (g_inj_image_filter f s) =\n  {b. \\<exists>a\\<in>s1.\\<alpha> s. f a = Some b}\n  s2.invar (g_inj_image_filter f s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma g_inj_image_alt: \"g_inj_image f s = g_inj_image_filter (Some o f) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g_inj_image f s = g_inj_image_filter (Some \\<circ> f) s", "unfolding g_inj_image_def g_inj_image_filter_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. s1.iterate s (\\<lambda>x. s2.ins_dj (f x)) (s2.empty ()) =\n    s1.iterate s\n     (\\<lambda>x res.\n         case (Some \\<circ> f) x of None \\<Rightarrow> res\n         | Some v \\<Rightarrow> s2.ins_dj v res)\n     (s2.empty ())", "by auto"], ["", "lemma g_inj_image_impl: \n    \"set_inj_image s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar g_inj_image\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_inj_image s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar g_inj_image", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set_inj_image s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar g_inj_image", "interpret set_inj_image_filter \n      s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar g_inj_image_filter"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_inj_image_filter s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar\n     g_inj_image_filter", "by (rule g_inj_image_filter_impl)"], ["proof (state)\ngoal (1 subgoal):\n 1. set_inj_image s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar g_inj_image", "have AUX: \"\\<And>S f. inj_on f S \\<Longrightarrow> inj_on (Some \\<circ> f) (S \\<inter> dom (Some \\<circ> f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>S f.\n       inj_on f S \\<Longrightarrow>\n       inj_on (Some \\<circ> f) (S \\<inter> dom (Some \\<circ> f))", "by (auto intro!: inj_onI dest: inj_onD)"], ["proof (state)\nthis:\n  inj_on ?f2 ?S2 \\<Longrightarrow>\n  inj_on (Some \\<circ> ?f2) (?S2 \\<inter> dom (Some \\<circ> ?f2))\n\ngoal (1 subgoal):\n 1. set_inj_image s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar g_inj_image", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_inj_image s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar g_inj_image", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s f.\n       \\<lbrakk>s1.invar s; inj_on f (s1.\\<alpha> s)\\<rbrakk>\n       \\<Longrightarrow> s2.\\<alpha> (g_inj_image f s) = f ` s1.\\<alpha> s\n 2. \\<And>s f.\n       \\<lbrakk>s1.invar s; inj_on f (s1.\\<alpha> s)\\<rbrakk>\n       \\<Longrightarrow> s2.invar (g_inj_image f s)", "unfolding g_inj_image_alt"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s f.\n       \\<lbrakk>s1.invar s; inj_on f (s1.\\<alpha> s)\\<rbrakk>\n       \\<Longrightarrow> s2.\\<alpha>\n                          (g_inj_image_filter (Some \\<circ> f) s) =\n                         f ` s1.\\<alpha> s\n 2. \\<And>s f.\n       \\<lbrakk>s1.invar s; inj_on f (s1.\\<alpha> s)\\<rbrakk>\n       \\<Longrightarrow> s2.invar (g_inj_image_filter (Some \\<circ> f) s)", "by (auto simp add: inj_image_filter_correct AUX)"], ["proof (state)\nthis:\n  set_inj_image s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar g_inj_image\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "sublocale g_set_xy_loc < set_image_filter s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar \n  g_image_filter"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_image_filter s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar\n     g_image_filter", "by (rule g_image_filter_impl)"], ["", "sublocale g_set_xy_loc < set_image s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar \n  g_image"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_image s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar g_image", "by (rule g_image_impl)"], ["", "sublocale g_set_xy_loc < set_inj_image s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar \n  g_inj_image"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_inj_image s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar g_inj_image", "by (rule g_inj_image_impl)"], ["", "locale g_set_xyy_defs_loc = \n  s0: StdSetDefs ops0 + \n  g_set_xx_defs_loc ops1 ops2\n  for ops0 :: \"('x0,'s0,'more0) set_ops_scheme\"\n  and ops1 :: \"('x,'s1,'more1) set_ops_scheme\"\n  and ops2 :: \"('x,'s2,'more2) set_ops_scheme\"\nbegin"], ["", "definition g_Union_image\n    :: \"('x0 \\<Rightarrow> 's1) \\<Rightarrow> 's0 \\<Rightarrow> 's2\"\n    where \"g_Union_image f S \n    == s0.iterate S (\\<lambda>x res. g_union (f x) res) (s2.empty ())\""], ["", "end"], ["", "locale g_set_xyy_loc = g_set_xyy_defs_loc ops0 ops1 ops2 +\n  s0: StdSet ops0 + \n  g_set_xx_loc ops1 ops2\n  for ops0 :: \"('x0,'s0,'more0) set_ops_scheme\"\n  and ops1 :: \"('x,'s1,'more1) set_ops_scheme\"\n  and ops2 :: \"('x,'s2,'more2) set_ops_scheme\"\nbegin"], ["", "lemma g_Union_image_impl:\n    \"set_Union_image s0.\\<alpha> s0.invar s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar g_Union_image\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_Union_image s0.\\<alpha> s0.invar s1.\\<alpha> s1.invar s2.\\<alpha>\n     s2.invar g_Union_image", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set_Union_image s0.\\<alpha> s0.invar s1.\\<alpha> s1.invar s2.\\<alpha>\n     s2.invar g_Union_image", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. set_Union_image s0.\\<alpha> s0.invar s1.\\<alpha> s1.invar s2.\\<alpha>\n     s2.invar g_Union_image", "fix s f"], ["proof (state)\ngoal (1 subgoal):\n 1. set_Union_image s0.\\<alpha> s0.invar s1.\\<alpha> s1.invar s2.\\<alpha>\n     s2.invar g_Union_image", "have \"\\<lbrakk>s0.invar s; \\<And>x. x \\<in> s0.\\<alpha> s \\<Longrightarrow> s1.invar (f x)\\<rbrakk> \\<Longrightarrow> \n        s2.\\<alpha> (g_Union_image f s) = \\<Union>(s1.\\<alpha> ` f ` s0.\\<alpha> s) \n        \\<and> s2.invar (g_Union_image f s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s0.invar s;\n     \\<And>x.\n        x \\<in> s0.\\<alpha> s \\<Longrightarrow> s1.invar (f x)\\<rbrakk>\n    \\<Longrightarrow> s2.\\<alpha> (g_Union_image f s) =\n                      \\<Union> (s1.\\<alpha> ` f ` s0.\\<alpha> s) \\<and>\n                      s2.invar (g_Union_image f s)", "apply (unfold g_Union_image_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s0.invar s;\n     \\<And>x.\n        x \\<in> s0.\\<alpha> s \\<Longrightarrow> s1.invar (f x)\\<rbrakk>\n    \\<Longrightarrow> s2.\\<alpha>\n                       (s0.iterate s (\\<lambda>x. g_union (f x))\n                         (s2.empty ())) =\n                      \\<Union> (s1.\\<alpha> ` f ` s0.\\<alpha> s) \\<and>\n                      s2.invar\n                       (s0.iterate s (\\<lambda>x. g_union (f x))\n                         (s2.empty ()))", "apply (rule_tac I=\"\\<lambda>it res. s2.invar res \n          \\<and> s2.\\<alpha> res = \\<Union>(s1.\\<alpha>`f`(s0.\\<alpha> s - it))\" in s0.iterate_rule_P)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>s0.invar s;\n     \\<And>x.\n        x \\<in> s0.\\<alpha> s \\<Longrightarrow> s1.invar (f x)\\<rbrakk>\n    \\<Longrightarrow> s0.invar s\n 2. \\<lbrakk>s0.invar s;\n     \\<And>x.\n        x \\<in> s0.\\<alpha> s \\<Longrightarrow> s1.invar (f x)\\<rbrakk>\n    \\<Longrightarrow> s2.invar (s2.empty ()) \\<and>\n                      s2.\\<alpha> (s2.empty ()) =\n                      \\<Union>\n                       (s1.\\<alpha> ` f ` (s0.\\<alpha> s - s0.\\<alpha> s))\n 3. \\<And>x it \\<sigma>.\n       \\<lbrakk>s0.invar s;\n        \\<And>x. x \\<in> s0.\\<alpha> s \\<Longrightarrow> s1.invar (f x);\n        x \\<in> it; it \\<subseteq> s0.\\<alpha> s;\n        s2.invar \\<sigma> \\<and>\n        s2.\\<alpha> \\<sigma> =\n        \\<Union> (s1.\\<alpha> ` f ` (s0.\\<alpha> s - it))\\<rbrakk>\n       \\<Longrightarrow> s2.invar (g_union (f x) \\<sigma>) \\<and>\n                         s2.\\<alpha> (g_union (f x) \\<sigma>) =\n                         \\<Union>\n                          (s1.\\<alpha> ` f ` (s0.\\<alpha> s - (it - {x})))\n 4. \\<And>\\<sigma>.\n       \\<lbrakk>s0.invar s;\n        \\<And>x. x \\<in> s0.\\<alpha> s \\<Longrightarrow> s1.invar (f x);\n        s2.invar \\<sigma> \\<and>\n        s2.\\<alpha> \\<sigma> =\n        \\<Union> (s1.\\<alpha> ` f ` (s0.\\<alpha> s - {}))\\<rbrakk>\n       \\<Longrightarrow> s2.\\<alpha> \\<sigma> =\n                         \\<Union> (s1.\\<alpha> ` f ` s0.\\<alpha> s) \\<and>\n                         s2.invar \\<sigma>", "apply (fastforce simp add: s2.empty_correct union_correct)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<lbrakk>s0.invar s;\n   \\<And>x. x \\<in> s0.\\<alpha> s \\<Longrightarrow> s1.invar (f x)\\<rbrakk>\n  \\<Longrightarrow> s2.\\<alpha> (g_Union_image f s) =\n                    \\<Union> (s1.\\<alpha> ` f ` s0.\\<alpha> s) \\<and>\n                    s2.invar (g_Union_image f s)\n\ngoal (1 subgoal):\n 1. set_Union_image s0.\\<alpha> s0.invar s1.\\<alpha> s1.invar s2.\\<alpha>\n     s2.invar g_Union_image", "}"], ["proof (state)\nthis:\n  \\<lbrakk>s0.invar ?s4;\n   \\<And>x.\n      x \\<in> s0.\\<alpha> ?s4 \\<Longrightarrow> s1.invar (?f4 x)\\<rbrakk>\n  \\<Longrightarrow> s2.\\<alpha> (g_Union_image ?f4 ?s4) =\n                    \\<Union> (s1.\\<alpha> ` ?f4 ` s0.\\<alpha> ?s4) \\<and>\n                    s2.invar (g_Union_image ?f4 ?s4)\n\ngoal (1 subgoal):\n 1. set_Union_image s0.\\<alpha> s0.invar s1.\\<alpha> s1.invar s2.\\<alpha>\n     s2.invar g_Union_image", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>s0.invar ?s4;\n   \\<And>x.\n      x \\<in> s0.\\<alpha> ?s4 \\<Longrightarrow> s1.invar (?f4 x)\\<rbrakk>\n  \\<Longrightarrow> s2.\\<alpha> (g_Union_image ?f4 ?s4) =\n                    \\<Union> (s1.\\<alpha> ` ?f4 ` s0.\\<alpha> ?s4) \\<and>\n                    s2.invar (g_Union_image ?f4 ?s4)\n\ngoal (1 subgoal):\n 1. set_Union_image s0.\\<alpha> s0.invar s1.\\<alpha> s1.invar s2.\\<alpha>\n     s2.invar g_Union_image", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s f.\n       \\<lbrakk>\\<And>s f.\n                   \\<lbrakk>s0.invar s;\n                    \\<And>x.\n                       x \\<in> s0.\\<alpha> s \\<Longrightarrow>\n                       s1.invar (f x)\\<rbrakk>\n                   \\<Longrightarrow> s2.\\<alpha> (g_Union_image f s) =\n                                     \\<Union>\n(s1.\\<alpha> ` f ` s0.\\<alpha> s) \\<and>\n                                     s2.invar (g_Union_image f s);\n        s0.invar s;\n        \\<And>x.\n           x \\<in> s0.\\<alpha> s \\<Longrightarrow> s1.invar (f x)\\<rbrakk>\n       \\<Longrightarrow> s2.\\<alpha> (g_Union_image f s) =\n                         \\<Union> (s1.\\<alpha> ` f ` s0.\\<alpha> s)\n 2. \\<And>s f.\n       \\<lbrakk>\\<And>s f.\n                   \\<lbrakk>s0.invar s;\n                    \\<And>x.\n                       x \\<in> s0.\\<alpha> s \\<Longrightarrow>\n                       s1.invar (f x)\\<rbrakk>\n                   \\<Longrightarrow> s2.\\<alpha> (g_Union_image f s) =\n                                     \\<Union>\n(s1.\\<alpha> ` f ` s0.\\<alpha> s) \\<and>\n                                     s2.invar (g_Union_image f s);\n        s0.invar s;\n        \\<And>x.\n           x \\<in> s0.\\<alpha> s \\<Longrightarrow> s1.invar (f x)\\<rbrakk>\n       \\<Longrightarrow> s2.invar (g_Union_image f s)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  set_Union_image s0.\\<alpha> s0.invar s1.\\<alpha> s1.invar s2.\\<alpha>\n   s2.invar g_Union_image\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "sublocale g_set_xyy_loc < \n  set_Union_image s0.\\<alpha> s0.invar s1.\\<alpha> s1.invar s2.\\<alpha> s2.invar g_Union_image"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_Union_image s0.\\<alpha> s0.invar s1.\\<alpha> s1.invar s2.\\<alpha>\n     s2.invar g_Union_image", "by (rule g_Union_image_impl)"], ["", "subsection \\<open>Default Set Operations\\<close>"], ["", "record ('x,'s) set_basic_ops = \n  bset_op_\\<alpha> :: \"'s \\<Rightarrow> 'x set\"\n  bset_op_invar :: \"'s \\<Rightarrow> bool\"\n  bset_op_empty :: \"unit \\<Rightarrow> 's\"\n  bset_op_memb :: \"'x \\<Rightarrow> 's \\<Rightarrow> bool\"\n  bset_op_ins :: \"'x \\<Rightarrow> 's \\<Rightarrow> 's\"\n  bset_op_ins_dj :: \"'x \\<Rightarrow> 's \\<Rightarrow> 's\"\n  bset_op_delete :: \"'x \\<Rightarrow> 's \\<Rightarrow> 's\"\n  bset_op_list_it :: \"('x,'s) set_list_it\""], ["", "record ('x,'s) oset_basic_ops = \"('x::linorder,'s) set_basic_ops\" +\n  bset_op_ordered_list_it :: \"'s \\<Rightarrow> ('x,'x list) set_iterator\"\n  bset_op_rev_list_it :: \"'s \\<Rightarrow> ('x,'x list) set_iterator\""], ["", "locale StdBasicSetDefs = \n  poly_set_iteratei_defs \"bset_op_list_it ops\"\n  for ops :: \"('x,'s,'more) set_basic_ops_scheme\"\nbegin"], ["", "abbreviation \\<alpha> where \"\\<alpha> == bset_op_\\<alpha> ops\""], ["", "abbreviation invar where \"invar == bset_op_invar ops\""], ["", "abbreviation empty where \"empty == bset_op_empty ops\""], ["", "abbreviation memb where \"memb == bset_op_memb ops\""], ["", "abbreviation ins where \"ins == bset_op_ins ops\""], ["", "abbreviation ins_dj where \"ins_dj == bset_op_ins_dj ops\""], ["", "abbreviation delete where \"delete == bset_op_delete ops\""], ["", "abbreviation list_it where \"list_it \\<equiv> bset_op_list_it ops\""], ["", "end"], ["", "locale StdBasicOSetDefs = StdBasicSetDefs ops\n  + poly_set_iterateoi_defs \"bset_op_ordered_list_it ops\"\n  + poly_set_rev_iterateoi_defs \"bset_op_rev_list_it ops\"\n  for ops :: \"('x::linorder,'s,'more) oset_basic_ops_scheme\"\nbegin"], ["", "abbreviation \"ordered_list_it \\<equiv> bset_op_ordered_list_it ops\""], ["", "abbreviation \"rev_list_it \\<equiv> bset_op_rev_list_it ops\""], ["", "end"], ["", "locale StdBasicSet = StdBasicSetDefs ops +\n  set \\<alpha> invar +\n  set_empty \\<alpha> invar empty + \n  set_memb \\<alpha> invar memb + \n  set_ins \\<alpha> invar ins + \n  set_ins_dj \\<alpha> invar ins_dj +\n  set_delete \\<alpha> invar delete + \n  poly_set_iteratei \\<alpha> invar list_it\n  for ops :: \"('x,'s,'more) set_basic_ops_scheme\"\nbegin"], ["", "lemmas correct[simp] = \n    empty_correct\n    memb_correct\n    ins_correct\n    ins_dj_correct\n    delete_correct"], ["", "end"], ["", "locale StdBasicOSet =\n  StdBasicOSetDefs ops +\n  StdBasicSet ops +\n  poly_set_iterateoi \\<alpha> invar ordered_list_it +\n  poly_set_rev_iterateoi \\<alpha> invar rev_list_it\n  for ops :: \"('x::linorder,'s,'more) oset_basic_ops_scheme\"\nbegin"], ["", "end"], ["", "context StdBasicSetDefs\nbegin"], ["", "definition \"g_sng x \\<equiv> ins x (empty ())\""], ["", "definition \"g_isEmpty s \\<equiv> iteratei s (\\<lambda>c. c) (\\<lambda>_ _. False) True\""], ["", "definition \"g_sel' s P \\<equiv> iteratei s ((=) None) \n    (\\<lambda>x _. if P x then Some x else None) None\""], ["", "definition \"g_ball s P \\<equiv> iteratei s (\\<lambda>c. c) (\\<lambda>x \\<sigma>. P x) True\""], ["", "definition \"g_bex s P \\<equiv> iteratei s (\\<lambda>c. \\<not>c) (\\<lambda>x \\<sigma>. P x) False\""], ["", "definition \"g_size s \\<equiv> iteratei s (\\<lambda>_. True) (\\<lambda>x n . Suc n) 0\""], ["", "definition \"g_size_abort m s \\<equiv> iteratei s (\\<lambda>\\<sigma>. \\<sigma> < m) (\\<lambda>x. Suc) 0\""], ["", "definition \"g_isSng s \\<equiv> (iteratei s (\\<lambda>\\<sigma>. \\<sigma> < 2) (\\<lambda>x. Suc) 0 = 1)\""], ["", "definition \"g_union s1 s2 \\<equiv> iterate s1 ins s2\""], ["", "definition \"g_diff s1 s2 \\<equiv> iterate s2 delete s1\""], ["", "definition \"g_subset s1 s2 \\<equiv> g_ball s1 (\\<lambda>x. memb x s2)\""], ["", "definition \"g_equal s1 s2 \\<equiv> g_subset s1 s2 \\<and> g_subset s2 s1\""], ["", "definition \"g_to_list s \\<equiv> iterate s (#) []\""], ["", "fun g_from_list_aux where\n    \"g_from_list_aux accs [] = accs\" |\n    \"g_from_list_aux accs (x#l) = g_from_list_aux (ins x accs) l\"\n    \\<comment> \\<open>Tail recursive version\\<close>"], ["", "definition \"g_from_list l == g_from_list_aux (empty ()) l\""], ["", "definition \"g_inter s1 s2 \\<equiv>\n    iterate s1 (\\<lambda>x s. if memb x s2 then ins_dj x s else s) \n      (empty ())\""], ["", "definition \"g_union_dj s1 s2 \\<equiv> iterate s1 ins_dj s2\""], ["", "definition \"g_filter P s \\<equiv> iterate s \n    (\\<lambda>x \\<sigma>. if P x then ins_dj x \\<sigma> else \\<sigma>) \n    (empty ())\""], ["", "definition \"g_disjoint_witness s1 s2 \\<equiv> g_sel' s1 (\\<lambda>x. memb x s2)\""], ["", "definition \"g_disjoint s1 s2 \\<equiv> g_ball s1 (\\<lambda>x. \\<not>memb x s2)\""], ["", "definition dflt_ops\n    where [icf_rec_def]: \"dflt_ops \\<equiv> \\<lparr>\n      set_op_\\<alpha> = \\<alpha>, \n      set_op_invar = invar, \n      set_op_empty = empty, \n      set_op_memb = memb, \n      set_op_ins = ins, \n      set_op_ins_dj = ins_dj, \n      set_op_delete = delete, \n      set_op_list_it = list_it, \n      set_op_sng = g_sng ,\n      set_op_isEmpty = g_isEmpty ,\n      set_op_isSng = g_isSng ,\n      set_op_ball = g_ball ,\n      set_op_bex = g_bex ,\n      set_op_size = g_size ,\n      set_op_size_abort = g_size_abort ,\n      set_op_union = g_union ,\n      set_op_union_dj = g_union_dj ,\n      set_op_diff = g_diff ,\n      set_op_filter = g_filter ,\n      set_op_inter = g_inter ,\n      set_op_subset = g_subset ,\n      set_op_equal = g_equal ,\n      set_op_disjoint = g_disjoint ,\n      set_op_disjoint_witness = g_disjoint_witness ,\n      set_op_sel = g_sel' ,\n      set_op_to_list = g_to_list ,\n      set_op_from_list = g_from_list\n    \\<rparr>\""], ["", "local_setup \\<open>Locale_Code.lc_decl_del @{term dflt_ops}\\<close>"], ["", "end"], ["", "context StdBasicSet\nbegin"], ["", "lemma g_sng_impl: \"set_sng \\<alpha> invar g_sng\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_sng \\<alpha> invar g_sng", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. \\<alpha> (g_sng x) = {x}\n 2. \\<And>x. invar (g_sng x)", "unfolding g_sng_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. \\<alpha> (ins x (local.empty ())) = {x}\n 2. \\<And>x. invar (ins x (local.empty ()))", "apply (auto simp: ins_correct empty_correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma g_ins_dj_impl: \"set_ins_dj \\<alpha> invar ins\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_ins_dj \\<alpha> invar ins", "by unfold_locales (auto simp: ins_correct)"], ["", "lemma g_isEmpty_impl: \"set_isEmpty \\<alpha> invar g_isEmpty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_isEmpty \\<alpha> invar g_isEmpty", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. invar s \\<Longrightarrow> g_isEmpty s = (\\<alpha> s = {})", "fix s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. invar s \\<Longrightarrow> g_isEmpty s = (\\<alpha> s = {})", "assume I: \"invar s\""], ["proof (state)\nthis:\n  invar s\n\ngoal (1 subgoal):\n 1. \\<And>s. invar s \\<Longrightarrow> g_isEmpty s = (\\<alpha> s = {})", "have A: \"g_isEmpty s = iterate_is_empty (iteratei s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g_isEmpty s = iterate_is_empty (iteratei s)", "unfolding g_isEmpty_def iterate_is_empty_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. iteratei s (\\<lambda>c. c) (\\<lambda>_ _. False) True =\n    iteratei s (\\<lambda>b. b) (\\<lambda>_ _. False) True", ".."], ["proof (state)\nthis:\n  g_isEmpty s = iterate_is_empty (iteratei s)\n\ngoal (1 subgoal):\n 1. \\<And>s. invar s \\<Longrightarrow> g_isEmpty s = (\\<alpha> s = {})", "from iterate_is_empty_correct[OF iteratei_correct[OF I]]"], ["proof (chain)\npicking this:\n  iterate_is_empty (iteratei s) = (\\<alpha> s = {})", "show \"g_isEmpty s \\<longleftrightarrow> \\<alpha> s = {}\""], ["proof (prove)\nusing this:\n  iterate_is_empty (iteratei s) = (\\<alpha> s = {})\n\ngoal (1 subgoal):\n 1. g_isEmpty s = (\\<alpha> s = {})", "unfolding A"], ["proof (prove)\nusing this:\n  iterate_is_empty (iteratei s) = (\\<alpha> s = {})\n\ngoal (1 subgoal):\n 1. iterate_is_empty (iteratei s) = (\\<alpha> s = {})", "."], ["proof (state)\nthis:\n  g_isEmpty s = (\\<alpha> s = {})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma g_sel'_impl: \"set_sel' \\<alpha> invar g_sel'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_sel' \\<alpha> invar g_sel'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set_sel' \\<alpha> invar g_sel'", "have A: \"\\<And>s P. g_sel' s P = iterate_sel_no_map (iteratei s) P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s P. g_sel' s P = iterate_sel_no_map (iteratei s) P", "unfolding g_sel'_def iterate_sel_no_map_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s P.\n       iteratei s ((=) None) (\\<lambda>x _. if P x then Some x else None)\n        None =\n       iteratei s (\\<lambda>\\<sigma>. \\<sigma> = None)\n        (\\<lambda>x \\<sigma>. if P x then Some x else None) None", "apply (rule arg_cong[where f=\"iteratei\", THEN cong, THEN cong, THEN cong])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s P. s = s\n 2. \\<And>s P. (=) None = (\\<lambda>\\<sigma>. \\<sigma> = None)\n 3. \\<And>s P.\n       (\\<lambda>x _. if P x then Some x else None) =\n       (\\<lambda>x \\<sigma>. if P x then Some x else None)\n 4. \\<And>s P. None = None", "by auto"], ["proof (state)\nthis:\n  g_sel' ?s2 ?P2 = iterate_sel_no_map (iteratei ?s2) ?P2\n\ngoal (1 subgoal):\n 1. set_sel' \\<alpha> invar g_sel'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_sel' \\<alpha> invar g_sel'", "unfolding set_sel'_def A"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>s x P Q.\n        invar s \\<longrightarrow>\n        x \\<in> \\<alpha> s \\<longrightarrow>\n        P x \\<longrightarrow>\n        (\\<forall>x.\n            iterate_sel_no_map (iteratei s) P = Some x \\<longrightarrow>\n            x \\<in> \\<alpha> s \\<longrightarrow>\n            P x \\<longrightarrow> Q) \\<longrightarrow>\n        Q) \\<and>\n    (\\<forall>s P.\n        invar s \\<longrightarrow>\n        (\\<forall>x\\<in>\\<alpha> s. \\<not> P x) \\<longrightarrow>\n        iterate_sel_no_map (iteratei s) P = None)", "using iterate_sel_no_map_correct[OF iteratei_correct]"], ["proof (prove)\nusing this:\n  invar ?S1 \\<Longrightarrow>\n  (iterate_sel_no_map (iteratei ?S1) ?P = None) =\n  (\\<forall>x\\<in>\\<alpha> ?S1. \\<not> ?P x)\n  \\<lbrakk>invar ?S1;\n   iterate_sel_no_map (iteratei ?S1) ?P = Some ?x\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> \\<alpha> ?S1 \\<and> ?P ?x\n\ngoal (1 subgoal):\n 1. (\\<forall>s x P Q.\n        invar s \\<longrightarrow>\n        x \\<in> \\<alpha> s \\<longrightarrow>\n        P x \\<longrightarrow>\n        (\\<forall>x.\n            iterate_sel_no_map (iteratei s) P = Some x \\<longrightarrow>\n            x \\<in> \\<alpha> s \\<longrightarrow>\n            P x \\<longrightarrow> Q) \\<longrightarrow>\n        Q) \\<and>\n    (\\<forall>s P.\n        invar s \\<longrightarrow>\n        (\\<forall>x\\<in>\\<alpha> s. \\<not> P x) \\<longrightarrow>\n        iterate_sel_no_map (iteratei s) P = None)", "apply (simp add: Bex_def Ball_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>S P.\n                invar S \\<Longrightarrow>\n                (iterate_sel_no_map (iteratei S) P = None) =\n                (\\<forall>x.\n                    x \\<in> \\<alpha> S \\<longrightarrow> \\<not> P x);\n     \\<And>S P x.\n        \\<lbrakk>invar S;\n         iterate_sel_no_map (iteratei S) P = Some x\\<rbrakk>\n        \\<Longrightarrow> x \\<in> \\<alpha> S \\<and> P x\\<rbrakk>\n    \\<Longrightarrow> \\<forall>s.\n                         invar s \\<longrightarrow>\n                         (\\<forall>x.\n                             x \\<in> \\<alpha> s \\<longrightarrow>\n                             (\\<forall>P.\n                                 P x \\<longrightarrow>\n                                 (\\<forall>Q.\n                                     (\\<forall>x.\n   iterate_sel_no_map (iteratei s) P = Some x \\<longrightarrow>\n   P x \\<longrightarrow> Q) \\<longrightarrow>\n                                     Q)))", "apply (metis option.exhaust)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  set_sel' \\<alpha> invar g_sel'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma g_ball_alt: \"g_ball s P = iterate_ball (iteratei s) P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g_ball s P = iterate_ball (iteratei s) P", "unfolding g_ball_def iterate_ball_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. iteratei s (\\<lambda>c. c) (\\<lambda>x \\<sigma>. P x) True =\n    iteratei s id (\\<lambda>x \\<sigma>. P x) True", "by (simp add: id_def)"], ["", "lemma g_bex_alt: \"g_bex s P = iterate_bex (iteratei s) P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g_bex s P = iterate_bex (iteratei s) P", "unfolding g_bex_def iterate_bex_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. iteratei s Not (\\<lambda>x \\<sigma>. P x) False =\n    iteratei s Not (\\<lambda>x \\<sigma>. P x) False", ".."], ["", "lemma g_ball_impl: \"set_ball \\<alpha> invar g_ball\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_ball \\<alpha> invar g_ball", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>S P.\n       invar S \\<Longrightarrow>\n       g_ball S P = (\\<forall>x\\<in>\\<alpha> S. P x)", "unfolding g_ball_alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>S P.\n       invar S \\<Longrightarrow>\n       iterate_ball (iteratei S) P = (\\<forall>x\\<in>\\<alpha> S. P x)", "apply (rule iterate_ball_correct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>S P.\n       invar S \\<Longrightarrow> set_iterator (iteratei S) (\\<alpha> S)", "by (rule iteratei_correct)"], ["", "lemma g_bex_impl: \"set_bex \\<alpha> invar g_bex\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_bex \\<alpha> invar g_bex", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>S P.\n       invar S \\<Longrightarrow>\n       g_bex S P = (\\<exists>x\\<in>\\<alpha> S. P x)", "unfolding g_bex_alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>S P.\n       invar S \\<Longrightarrow>\n       iterate_bex (iteratei S) P = (\\<exists>x\\<in>\\<alpha> S. P x)", "apply (rule iterate_bex_correct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>S P.\n       invar S \\<Longrightarrow> set_iterator (iteratei S) (\\<alpha> S)", "by (rule iteratei_correct)"], ["", "lemma g_size_alt: \"g_size s = iterate_size (iteratei s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g_size s = iterate_size (iteratei s)", "unfolding g_size_def iterate_size_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. iterate s (\\<lambda>x. Suc) 0 = iterate s (\\<lambda>x. Suc) 0", ".."], ["", "lemma g_size_abort_alt: \"g_size_abort m s = iterate_size_abort (iteratei s) m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g_size_abort m s = iterate_size_abort (iteratei s) m", "unfolding g_size_abort_def iterate_size_abort_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. iteratei s (\\<lambda>\\<sigma>. \\<sigma> < m) (\\<lambda>x. Suc) 0 =\n    iteratei s (\\<lambda>\\<sigma>. \\<sigma> < m) (\\<lambda>x. Suc) 0", ".."], ["", "lemma g_size_impl: \"set_size \\<alpha> invar g_size\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_size \\<alpha> invar g_size", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s. invar s \\<Longrightarrow> g_size s = card (\\<alpha> s)", "unfolding g_size_alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       invar s \\<Longrightarrow>\n       iterate_size (iteratei s) = card (\\<alpha> s)", "apply (rule conjunct1[OF iterate_size_correct])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       invar s \\<Longrightarrow> set_iterator (iteratei s) (\\<alpha> s)", "by (rule iteratei_correct)"], ["", "lemma g_size_abort_impl: \"set_size_abort \\<alpha> invar g_size_abort\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_size_abort \\<alpha> invar g_size_abort", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s m.\n       invar s \\<Longrightarrow>\n       g_size_abort m s = min m (card (\\<alpha> s))", "unfolding g_size_abort_alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s m.\n       invar s \\<Longrightarrow>\n       iterate_size_abort (iteratei s) m = min m (card (\\<alpha> s))", "apply (rule conjunct1[OF iterate_size_abort_correct])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s m.\n       invar s \\<Longrightarrow> set_iterator (iteratei s) (\\<alpha> s)", "by (rule iteratei_correct)"], ["", "lemma g_isSng_alt: \"g_isSng s = iterate_is_sng (iteratei s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g_isSng s = iterate_is_sng (iteratei s)", "unfolding g_isSng_def iterate_is_sng_def iterate_size_abort_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (iteratei s (\\<lambda>\\<sigma>. \\<sigma> < 2) (\\<lambda>x. Suc) 0 = 1) =\n    (iteratei s (\\<lambda>\\<sigma>. \\<sigma> < 2) (\\<lambda>x. Suc) 0 = 1)", ".."], ["", "lemma g_isSng_impl: \"set_isSng \\<alpha> invar g_isSng\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_isSng \\<alpha> invar g_isSng", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       invar s \\<Longrightarrow> g_isSng s = (\\<exists>e. \\<alpha> s = {e})", "unfolding g_isSng_alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       invar s \\<Longrightarrow>\n       iterate_is_sng (iteratei s) = (\\<exists>e. \\<alpha> s = {e})", "apply (drule iterate_is_sng_correct[OF iteratei_correct])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       iterate_is_sng (iteratei s) =\n       (card (\\<alpha> s) = 1) \\<Longrightarrow>\n       iterate_is_sng (iteratei s) = (\\<exists>e. \\<alpha> s = {e})", "apply (simp add: card_Suc_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma g_union_impl: \"set_union \\<alpha> invar \\<alpha> invar \\<alpha> invar g_union\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_union \\<alpha> invar \\<alpha> invar \\<alpha> invar g_union", "unfolding g_union_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_union \\<alpha> invar \\<alpha> invar \\<alpha> invar\n     (\\<lambda>s1. iterate s1 ins)", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s1 s2.\n       \\<lbrakk>invar s1; invar s2\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> (iterate s1 ins s2) =\n                         \\<alpha> s1 \\<union> \\<alpha> s2\n 2. \\<And>s1 s2.\n       \\<lbrakk>invar s1; invar s2\\<rbrakk>\n       \\<Longrightarrow> invar (iterate s1 ins s2)", "apply (rule_tac I=\"\\<lambda>it \\<sigma>. invar \\<sigma> \\<and> \\<alpha> \\<sigma> = it \\<union> \\<alpha> s2\" \n      in iterate_rule_insert_P, simp_all)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma g_diff_impl: \"set_diff \\<alpha> invar \\<alpha> invar g_diff\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_diff \\<alpha> invar \\<alpha> invar g_diff", "unfolding g_diff_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_diff \\<alpha> invar \\<alpha> invar\n     (\\<lambda>s1 s2. iterate s2 delete s1)", "apply (unfold_locales)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s1 s2.\n       \\<lbrakk>invar s1; invar s2\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> (iterate s2 delete s1) =\n                         \\<alpha> s1 - \\<alpha> s2\n 2. \\<And>s1 s2.\n       \\<lbrakk>invar s1; invar s2\\<rbrakk>\n       \\<Longrightarrow> invar (iterate s2 delete s1)", "apply (rule_tac I=\"\\<lambda>it \\<sigma>. invar \\<sigma> \\<and> \\<alpha> \\<sigma> = \\<alpha> s1 - it\" \n      in iterate_rule_insert_P, auto)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma g_subset_impl: \"set_subset \\<alpha> invar \\<alpha> invar g_subset\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_subset \\<alpha> invar \\<alpha> invar g_subset", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set_subset \\<alpha> invar \\<alpha> invar g_subset", "interpret set_ball \\<alpha> invar g_ball"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_ball \\<alpha> invar g_ball", "by (rule g_ball_impl)"], ["proof (state)\ngoal (1 subgoal):\n 1. set_subset \\<alpha> invar \\<alpha> invar g_subset", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_subset \\<alpha> invar \\<alpha> invar g_subset", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s1 s2.\n       \\<lbrakk>invar s1; invar s2\\<rbrakk>\n       \\<Longrightarrow> g_subset s1 s2 =\n                         (\\<alpha> s1 \\<subseteq> \\<alpha> s2)", "unfolding g_subset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s1 s2.\n       \\<lbrakk>invar s1; invar s2\\<rbrakk>\n       \\<Longrightarrow> g_ball s1 (\\<lambda>x. memb x s2) =\n                         (\\<alpha> s1 \\<subseteq> \\<alpha> s2)", "by (auto simp add: ball_correct memb_correct)"], ["proof (state)\nthis:\n  set_subset \\<alpha> invar \\<alpha> invar g_subset\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma g_equal_impl: \"set_equal \\<alpha> invar \\<alpha> invar g_equal\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_equal \\<alpha> invar \\<alpha> invar g_equal", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set_equal \\<alpha> invar \\<alpha> invar g_equal", "interpret set_subset \\<alpha> invar \\<alpha> invar g_subset"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_subset \\<alpha> invar \\<alpha> invar g_subset", "by (rule g_subset_impl)"], ["proof (state)\ngoal (1 subgoal):\n 1. set_equal \\<alpha> invar \\<alpha> invar g_equal", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_equal \\<alpha> invar \\<alpha> invar g_equal", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s1 s2.\n       \\<lbrakk>invar s1; invar s2\\<rbrakk>\n       \\<Longrightarrow> g_equal s1 s2 = (\\<alpha> s1 = \\<alpha> s2)", "unfolding g_equal_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s1 s2.\n       \\<lbrakk>invar s1; invar s2\\<rbrakk>\n       \\<Longrightarrow> (g_subset s1 s2 \\<and> g_subset s2 s1) =\n                         (\\<alpha> s1 = \\<alpha> s2)", "by (auto simp add: subset_correct)"], ["proof (state)\nthis:\n  set_equal \\<alpha> invar \\<alpha> invar g_equal\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma g_to_list_impl: \"set_to_list \\<alpha> invar g_to_list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_to_list \\<alpha> invar g_to_list", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s. invar s \\<Longrightarrow> set (g_to_list s) = \\<alpha> s\n 2. \\<And>s. invar s \\<Longrightarrow> distinct (g_to_list s)", "fix s"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s. invar s \\<Longrightarrow> set (g_to_list s) = \\<alpha> s\n 2. \\<And>s. invar s \\<Longrightarrow> distinct (g_to_list s)", "assume I: \"invar s\""], ["proof (state)\nthis:\n  invar s\n\ngoal (2 subgoals):\n 1. \\<And>s. invar s \\<Longrightarrow> set (g_to_list s) = \\<alpha> s\n 2. \\<And>s. invar s \\<Longrightarrow> distinct (g_to_list s)", "have A: \"g_to_list s = iterate_to_list (iteratei s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g_to_list s = iterate_to_list (iteratei s)", "unfolding g_to_list_def iterate_to_list_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. iterate s (#) [] = iterate s (#) []", ".."], ["proof (state)\nthis:\n  g_to_list s = iterate_to_list (iteratei s)\n\ngoal (2 subgoals):\n 1. \\<And>s. invar s \\<Longrightarrow> set (g_to_list s) = \\<alpha> s\n 2. \\<And>s. invar s \\<Longrightarrow> distinct (g_to_list s)", "from iterate_to_list_correct [OF iteratei_correct[OF I]]"], ["proof (chain)\npicking this:\n  set (iterate_to_list (iteratei s)) = \\<alpha> s \\<and>\n  distinct (iterate_to_list (iteratei s))", "show \"set (g_to_list s) = \\<alpha> s\" and \"distinct (g_to_list s)\""], ["proof (prove)\nusing this:\n  set (iterate_to_list (iteratei s)) = \\<alpha> s \\<and>\n  distinct (iterate_to_list (iteratei s))\n\ngoal (1 subgoal):\n 1. set (g_to_list s) = \\<alpha> s &&& distinct (g_to_list s)", "unfolding A"], ["proof (prove)\nusing this:\n  set (iterate_to_list (iteratei s)) = \\<alpha> s \\<and>\n  distinct (iterate_to_list (iteratei s))\n\ngoal (1 subgoal):\n 1. set (iterate_to_list (iteratei s)) = \\<alpha> s &&&\n    distinct (iterate_to_list (iteratei s))", "by auto"], ["proof (state)\nthis:\n  set (g_to_list s) = \\<alpha> s\n  distinct (g_to_list s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma g_from_list_impl: \"list_to_set \\<alpha> invar g_from_list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_to_set \\<alpha> invar g_from_list", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. list_to_set \\<alpha> invar g_from_list", "{ \\<comment> \\<open>Show a generalized lemma\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. list_to_set \\<alpha> invar g_from_list", "fix l accs"], ["proof (state)\ngoal (1 subgoal):\n 1. list_to_set \\<alpha> invar g_from_list", "have \"invar accs \\<Longrightarrow> \\<alpha> (g_from_list_aux accs l) = set l \\<union> \\<alpha> accs \n            \\<and> invar (g_from_list_aux accs l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar accs \\<Longrightarrow>\n    \\<alpha> (g_from_list_aux accs l) = set l \\<union> \\<alpha> accs \\<and>\n    invar (g_from_list_aux accs l)", "by (induct l arbitrary: accs)\n           (auto simp add: ins_correct)"], ["proof (state)\nthis:\n  invar accs \\<Longrightarrow>\n  \\<alpha> (g_from_list_aux accs l) = set l \\<union> \\<alpha> accs \\<and>\n  invar (g_from_list_aux accs l)\n\ngoal (1 subgoal):\n 1. list_to_set \\<alpha> invar g_from_list", "}"], ["proof (state)\nthis:\n  invar ?accs4 \\<Longrightarrow>\n  \\<alpha> (g_from_list_aux ?accs4 ?l4) =\n  set ?l4 \\<union> \\<alpha> ?accs4 \\<and>\n  invar (g_from_list_aux ?accs4 ?l4)\n\ngoal (1 subgoal):\n 1. list_to_set \\<alpha> invar g_from_list", "thus ?thesis"], ["proof (prove)\nusing this:\n  invar ?accs4 \\<Longrightarrow>\n  \\<alpha> (g_from_list_aux ?accs4 ?l4) =\n  set ?l4 \\<union> \\<alpha> ?accs4 \\<and>\n  invar (g_from_list_aux ?accs4 ?l4)\n\ngoal (1 subgoal):\n 1. list_to_set \\<alpha> invar g_from_list", "apply (unfold_locales)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l.\n       (\\<And>accs l.\n           invar accs \\<Longrightarrow>\n           \\<alpha> (g_from_list_aux accs l) =\n           set l \\<union> \\<alpha> accs \\<and>\n           invar (g_from_list_aux accs l)) \\<Longrightarrow>\n       \\<alpha> (g_from_list l) = set l\n 2. \\<And>l.\n       (\\<And>accs l.\n           invar accs \\<Longrightarrow>\n           \\<alpha> (g_from_list_aux accs l) =\n           set l \\<union> \\<alpha> accs \\<and>\n           invar (g_from_list_aux accs l)) \\<Longrightarrow>\n       invar (g_from_list l)", "apply (unfold g_from_list_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l.\n       (\\<And>accs l.\n           invar accs \\<Longrightarrow>\n           \\<alpha> (g_from_list_aux accs l) =\n           set l \\<union> \\<alpha> accs \\<and>\n           invar (g_from_list_aux accs l)) \\<Longrightarrow>\n       \\<alpha> (g_from_list_aux (local.empty ()) l) = set l\n 2. \\<And>l.\n       (\\<And>accs l.\n           invar accs \\<Longrightarrow>\n           \\<alpha> (g_from_list_aux accs l) =\n           set l \\<union> \\<alpha> accs \\<and>\n           invar (g_from_list_aux accs l)) \\<Longrightarrow>\n       invar (g_from_list_aux (local.empty ()) l)", "apply (auto simp add: empty_correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  list_to_set \\<alpha> invar g_from_list\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma g_inter_impl: \"set_inter \\<alpha> invar \\<alpha> invar \\<alpha> invar g_inter\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_inter \\<alpha> invar \\<alpha> invar \\<alpha> invar g_inter", "unfolding g_inter_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_inter \\<alpha> invar \\<alpha> invar \\<alpha> invar\n     (\\<lambda>s1 s2.\n         iterate s1 (\\<lambda>x s. if memb x s2 then ins_dj x s else s)\n          (local.empty ()))", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s1 s2.\n       \\<lbrakk>invar s1; invar s2\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>\n                          (iterate s1\n                            (\\<lambda>x s.\n                                if memb x s2 then ins_dj x s else s)\n                            (local.empty ())) =\n                         \\<alpha> s1 \\<inter> \\<alpha> s2\n 2. \\<And>s1 s2.\n       \\<lbrakk>invar s1; invar s2\\<rbrakk>\n       \\<Longrightarrow> invar\n                          (iterate s1\n                            (\\<lambda>x s.\n                                if memb x s2 then ins_dj x s else s)\n                            (local.empty ()))", "apply (rule_tac I=\"\\<lambda>it \\<sigma>. invar \\<sigma> \\<and> \\<alpha> \\<sigma> = it \\<inter> \\<alpha> s2\" \n      in iterate_rule_insert_P, auto) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s1 s2.\n       \\<lbrakk>invar s1; invar s2\\<rbrakk>\n       \\<Longrightarrow> invar\n                          (iterate s1\n                            (\\<lambda>x s.\n                                if memb x s2 then ins_dj x s else s)\n                            (local.empty ()))", "apply (rule_tac I=\"\\<lambda>it \\<sigma>. invar \\<sigma> \\<and> \\<alpha> \\<sigma> = it \\<inter> \\<alpha> s2\" \n      in iterate_rule_insert_P, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma g_union_dj_impl: \"set_union_dj \\<alpha> invar \\<alpha> invar \\<alpha> invar g_union_dj\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_union_dj \\<alpha> invar \\<alpha> invar \\<alpha> invar g_union_dj", "unfolding g_union_dj_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_union_dj \\<alpha> invar \\<alpha> invar \\<alpha> invar\n     (\\<lambda>s1. iterate s1 ins_dj)", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s1 s2.\n       \\<lbrakk>invar s1; invar s2;\n        \\<alpha> s1 \\<inter> \\<alpha> s2 = {}\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> (iterate s1 ins_dj s2) =\n                         \\<alpha> s1 \\<union> \\<alpha> s2\n 2. \\<And>s1 s2.\n       \\<lbrakk>invar s1; invar s2;\n        \\<alpha> s1 \\<inter> \\<alpha> s2 = {}\\<rbrakk>\n       \\<Longrightarrow> invar (iterate s1 ins_dj s2)", "apply (rule_tac I=\"\\<lambda>it \\<sigma>. invar \\<sigma> \\<and> \\<alpha> \\<sigma> = it \\<union> \\<alpha> s2\" \n      in iterate_rule_insert_P)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>s1 s2.\n       \\<lbrakk>invar s1; invar s2;\n        \\<alpha> s1 \\<inter> \\<alpha> s2 = {}\\<rbrakk>\n       \\<Longrightarrow> invar s1\n 2. \\<And>s1 s2.\n       \\<lbrakk>invar s1; invar s2;\n        \\<alpha> s1 \\<inter> \\<alpha> s2 = {}\\<rbrakk>\n       \\<Longrightarrow> invar s2 \\<and>\n                         \\<alpha> s2 = {} \\<union> \\<alpha> s2\n 3. \\<And>s1 s2 x it \\<sigma>.\n       \\<lbrakk>invar s1; invar s2; \\<alpha> s1 \\<inter> \\<alpha> s2 = {};\n        x \\<in> \\<alpha> s1 - it; it \\<subseteq> \\<alpha> s1;\n        invar \\<sigma> \\<and>\n        \\<alpha> \\<sigma> = it \\<union> \\<alpha> s2\\<rbrakk>\n       \\<Longrightarrow> invar (ins_dj x \\<sigma>) \\<and>\n                         \\<alpha> (ins_dj x \\<sigma>) =\n                         insert x it \\<union> \\<alpha> s2\n 4. \\<And>s1 s2 \\<sigma>.\n       \\<lbrakk>invar s1; invar s2; \\<alpha> s1 \\<inter> \\<alpha> s2 = {};\n        invar \\<sigma> \\<and>\n        \\<alpha> \\<sigma> = \\<alpha> s1 \\<union> \\<alpha> s2\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> \\<sigma> =\n                         \\<alpha> s1 \\<union> \\<alpha> s2\n 5. \\<And>s1 s2.\n       \\<lbrakk>invar s1; invar s2;\n        \\<alpha> s1 \\<inter> \\<alpha> s2 = {}\\<rbrakk>\n       \\<Longrightarrow> invar (iterate s1 ins_dj s2)", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s1 s2.\n       \\<lbrakk>invar s1; invar s2;\n        \\<alpha> s1 \\<inter> \\<alpha> s2 = {}\\<rbrakk>\n       \\<Longrightarrow> invar s2 \\<and>\n                         \\<alpha> s2 = {} \\<union> \\<alpha> s2\n 2. \\<And>s1 s2 x it \\<sigma>.\n       \\<lbrakk>invar s1; invar s2; \\<alpha> s1 \\<inter> \\<alpha> s2 = {};\n        x \\<in> \\<alpha> s1 - it; it \\<subseteq> \\<alpha> s1;\n        invar \\<sigma> \\<and>\n        \\<alpha> \\<sigma> = it \\<union> \\<alpha> s2\\<rbrakk>\n       \\<Longrightarrow> invar (ins_dj x \\<sigma>) \\<and>\n                         \\<alpha> (ins_dj x \\<sigma>) =\n                         insert x it \\<union> \\<alpha> s2\n 3. \\<And>s1 s2 \\<sigma>.\n       \\<lbrakk>invar s1; invar s2; \\<alpha> s1 \\<inter> \\<alpha> s2 = {};\n        invar \\<sigma> \\<and>\n        \\<alpha> \\<sigma> = \\<alpha> s1 \\<union> \\<alpha> s2\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> \\<sigma> =\n                         \\<alpha> s1 \\<union> \\<alpha> s2\n 4. \\<And>s1 s2.\n       \\<lbrakk>invar s1; invar s2;\n        \\<alpha> s1 \\<inter> \\<alpha> s2 = {}\\<rbrakk>\n       \\<Longrightarrow> invar (iterate s1 ins_dj s2)", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s1 s2 x it \\<sigma>.\n       \\<lbrakk>invar s1; invar s2; \\<alpha> s1 \\<inter> \\<alpha> s2 = {};\n        x \\<in> \\<alpha> s1 - it; it \\<subseteq> \\<alpha> s1;\n        invar \\<sigma> \\<and>\n        \\<alpha> \\<sigma> = it \\<union> \\<alpha> s2\\<rbrakk>\n       \\<Longrightarrow> invar (ins_dj x \\<sigma>) \\<and>\n                         \\<alpha> (ins_dj x \\<sigma>) =\n                         insert x it \\<union> \\<alpha> s2\n 2. \\<And>s1 s2 \\<sigma>.\n       \\<lbrakk>invar s1; invar s2; \\<alpha> s1 \\<inter> \\<alpha> s2 = {};\n        invar \\<sigma> \\<and>\n        \\<alpha> \\<sigma> = \\<alpha> s1 \\<union> \\<alpha> s2\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> \\<sigma> =\n                         \\<alpha> s1 \\<union> \\<alpha> s2\n 3. \\<And>s1 s2.\n       \\<lbrakk>invar s1; invar s2;\n        \\<alpha> s1 \\<inter> \\<alpha> s2 = {}\\<rbrakk>\n       \\<Longrightarrow> invar (iterate s1 ins_dj s2)", "apply (subgoal_tac \"x\\<notin>\\<alpha> \\<sigma>\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s1 s2 x it \\<sigma>.\n       \\<lbrakk>invar s1; invar s2; \\<alpha> s1 \\<inter> \\<alpha> s2 = {};\n        x \\<in> \\<alpha> s1 - it; it \\<subseteq> \\<alpha> s1;\n        invar \\<sigma> \\<and> \\<alpha> \\<sigma> = it \\<union> \\<alpha> s2;\n        x \\<notin> \\<alpha> \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> invar (ins_dj x \\<sigma>) \\<and>\n                         \\<alpha> (ins_dj x \\<sigma>) =\n                         insert x it \\<union> \\<alpha> s2\n 2. \\<And>s1 s2 x it \\<sigma>.\n       \\<lbrakk>invar s1; invar s2; \\<alpha> s1 \\<inter> \\<alpha> s2 = {};\n        x \\<in> \\<alpha> s1 - it; it \\<subseteq> \\<alpha> s1;\n        invar \\<sigma> \\<and>\n        \\<alpha> \\<sigma> = it \\<union> \\<alpha> s2\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> \\<alpha> \\<sigma>\n 3. \\<And>s1 s2 \\<sigma>.\n       \\<lbrakk>invar s1; invar s2; \\<alpha> s1 \\<inter> \\<alpha> s2 = {};\n        invar \\<sigma> \\<and>\n        \\<alpha> \\<sigma> = \\<alpha> s1 \\<union> \\<alpha> s2\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> \\<sigma> =\n                         \\<alpha> s1 \\<union> \\<alpha> s2\n 4. \\<And>s1 s2.\n       \\<lbrakk>invar s1; invar s2;\n        \\<alpha> s1 \\<inter> \\<alpha> s2 = {}\\<rbrakk>\n       \\<Longrightarrow> invar (iterate s1 ins_dj s2)", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s1 s2 x it \\<sigma>.\n       \\<lbrakk>invar s1; invar s2; \\<alpha> s1 \\<inter> \\<alpha> s2 = {};\n        x \\<in> \\<alpha> s1 - it; it \\<subseteq> \\<alpha> s1;\n        invar \\<sigma> \\<and>\n        \\<alpha> \\<sigma> = it \\<union> \\<alpha> s2\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> \\<alpha> \\<sigma>\n 2. \\<And>s1 s2 \\<sigma>.\n       \\<lbrakk>invar s1; invar s2; \\<alpha> s1 \\<inter> \\<alpha> s2 = {};\n        invar \\<sigma> \\<and>\n        \\<alpha> \\<sigma> = \\<alpha> s1 \\<union> \\<alpha> s2\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> \\<sigma> =\n                         \\<alpha> s1 \\<union> \\<alpha> s2\n 3. \\<And>s1 s2.\n       \\<lbrakk>invar s1; invar s2;\n        \\<alpha> s1 \\<inter> \\<alpha> s2 = {}\\<rbrakk>\n       \\<Longrightarrow> invar (iterate s1 ins_dj s2)", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s1 s2 \\<sigma>.\n       \\<lbrakk>invar s1; invar s2; \\<alpha> s1 \\<inter> \\<alpha> s2 = {};\n        invar \\<sigma> \\<and>\n        \\<alpha> \\<sigma> = \\<alpha> s1 \\<union> \\<alpha> s2\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> \\<sigma> =\n                         \\<alpha> s1 \\<union> \\<alpha> s2\n 2. \\<And>s1 s2.\n       \\<lbrakk>invar s1; invar s2;\n        \\<alpha> s1 \\<inter> \\<alpha> s2 = {}\\<rbrakk>\n       \\<Longrightarrow> invar (iterate s1 ins_dj s2)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s1 s2.\n       \\<lbrakk>invar s1; invar s2;\n        \\<alpha> s1 \\<inter> \\<alpha> s2 = {}\\<rbrakk>\n       \\<Longrightarrow> invar (iterate s1 ins_dj s2)", "apply (rule_tac I=\"\\<lambda>it \\<sigma>. invar \\<sigma> \\<and> \\<alpha> \\<sigma> = it \\<union> \\<alpha> s2\" \n      in iterate_rule_insert_P)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s1 s2.\n       \\<lbrakk>invar s1; invar s2;\n        \\<alpha> s1 \\<inter> \\<alpha> s2 = {}\\<rbrakk>\n       \\<Longrightarrow> invar s1\n 2. \\<And>s1 s2.\n       \\<lbrakk>invar s1; invar s2;\n        \\<alpha> s1 \\<inter> \\<alpha> s2 = {}\\<rbrakk>\n       \\<Longrightarrow> invar s2 \\<and>\n                         \\<alpha> s2 = {} \\<union> \\<alpha> s2\n 3. \\<And>s1 s2 x it \\<sigma>.\n       \\<lbrakk>invar s1; invar s2; \\<alpha> s1 \\<inter> \\<alpha> s2 = {};\n        x \\<in> \\<alpha> s1 - it; it \\<subseteq> \\<alpha> s1;\n        invar \\<sigma> \\<and>\n        \\<alpha> \\<sigma> = it \\<union> \\<alpha> s2\\<rbrakk>\n       \\<Longrightarrow> invar (ins_dj x \\<sigma>) \\<and>\n                         \\<alpha> (ins_dj x \\<sigma>) =\n                         insert x it \\<union> \\<alpha> s2\n 4. \\<And>s1 s2 \\<sigma>.\n       \\<lbrakk>invar s1; invar s2; \\<alpha> s1 \\<inter> \\<alpha> s2 = {};\n        invar \\<sigma> \\<and>\n        \\<alpha> \\<sigma> = \\<alpha> s1 \\<union> \\<alpha> s2\\<rbrakk>\n       \\<Longrightarrow> invar \\<sigma>", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s1 s2.\n       \\<lbrakk>invar s1; invar s2;\n        \\<alpha> s1 \\<inter> \\<alpha> s2 = {}\\<rbrakk>\n       \\<Longrightarrow> invar s2 \\<and>\n                         \\<alpha> s2 = {} \\<union> \\<alpha> s2\n 2. \\<And>s1 s2 x it \\<sigma>.\n       \\<lbrakk>invar s1; invar s2; \\<alpha> s1 \\<inter> \\<alpha> s2 = {};\n        x \\<in> \\<alpha> s1 - it; it \\<subseteq> \\<alpha> s1;\n        invar \\<sigma> \\<and>\n        \\<alpha> \\<sigma> = it \\<union> \\<alpha> s2\\<rbrakk>\n       \\<Longrightarrow> invar (ins_dj x \\<sigma>) \\<and>\n                         \\<alpha> (ins_dj x \\<sigma>) =\n                         insert x it \\<union> \\<alpha> s2\n 3. \\<And>s1 s2 \\<sigma>.\n       \\<lbrakk>invar s1; invar s2; \\<alpha> s1 \\<inter> \\<alpha> s2 = {};\n        invar \\<sigma> \\<and>\n        \\<alpha> \\<sigma> = \\<alpha> s1 \\<union> \\<alpha> s2\\<rbrakk>\n       \\<Longrightarrow> invar \\<sigma>", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s1 s2 x it \\<sigma>.\n       \\<lbrakk>invar s1; invar s2; \\<alpha> s1 \\<inter> \\<alpha> s2 = {};\n        x \\<in> \\<alpha> s1 - it; it \\<subseteq> \\<alpha> s1;\n        invar \\<sigma> \\<and>\n        \\<alpha> \\<sigma> = it \\<union> \\<alpha> s2\\<rbrakk>\n       \\<Longrightarrow> invar (ins_dj x \\<sigma>) \\<and>\n                         \\<alpha> (ins_dj x \\<sigma>) =\n                         insert x it \\<union> \\<alpha> s2\n 2. \\<And>s1 s2 \\<sigma>.\n       \\<lbrakk>invar s1; invar s2; \\<alpha> s1 \\<inter> \\<alpha> s2 = {};\n        invar \\<sigma> \\<and>\n        \\<alpha> \\<sigma> = \\<alpha> s1 \\<union> \\<alpha> s2\\<rbrakk>\n       \\<Longrightarrow> invar \\<sigma>", "apply (subgoal_tac \"x\\<notin>\\<alpha> \\<sigma>\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s1 s2 x it \\<sigma>.\n       \\<lbrakk>invar s1; invar s2; \\<alpha> s1 \\<inter> \\<alpha> s2 = {};\n        x \\<in> \\<alpha> s1 - it; it \\<subseteq> \\<alpha> s1;\n        invar \\<sigma> \\<and> \\<alpha> \\<sigma> = it \\<union> \\<alpha> s2;\n        x \\<notin> \\<alpha> \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> invar (ins_dj x \\<sigma>) \\<and>\n                         \\<alpha> (ins_dj x \\<sigma>) =\n                         insert x it \\<union> \\<alpha> s2\n 2. \\<And>s1 s2 x it \\<sigma>.\n       \\<lbrakk>invar s1; invar s2; \\<alpha> s1 \\<inter> \\<alpha> s2 = {};\n        x \\<in> \\<alpha> s1 - it; it \\<subseteq> \\<alpha> s1;\n        invar \\<sigma> \\<and>\n        \\<alpha> \\<sigma> = it \\<union> \\<alpha> s2\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> \\<alpha> \\<sigma>\n 3. \\<And>s1 s2 \\<sigma>.\n       \\<lbrakk>invar s1; invar s2; \\<alpha> s1 \\<inter> \\<alpha> s2 = {};\n        invar \\<sigma> \\<and>\n        \\<alpha> \\<sigma> = \\<alpha> s1 \\<union> \\<alpha> s2\\<rbrakk>\n       \\<Longrightarrow> invar \\<sigma>", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s1 s2 x it \\<sigma>.\n       \\<lbrakk>invar s1; invar s2; \\<alpha> s1 \\<inter> \\<alpha> s2 = {};\n        x \\<in> \\<alpha> s1 - it; it \\<subseteq> \\<alpha> s1;\n        invar \\<sigma> \\<and>\n        \\<alpha> \\<sigma> = it \\<union> \\<alpha> s2\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> \\<alpha> \\<sigma>\n 2. \\<And>s1 s2 \\<sigma>.\n       \\<lbrakk>invar s1; invar s2; \\<alpha> s1 \\<inter> \\<alpha> s2 = {};\n        invar \\<sigma> \\<and>\n        \\<alpha> \\<sigma> = \\<alpha> s1 \\<union> \\<alpha> s2\\<rbrakk>\n       \\<Longrightarrow> invar \\<sigma>", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s1 s2 \\<sigma>.\n       \\<lbrakk>invar s1; invar s2; \\<alpha> s1 \\<inter> \\<alpha> s2 = {};\n        invar \\<sigma> \\<and>\n        \\<alpha> \\<sigma> = \\<alpha> s1 \\<union> \\<alpha> s2\\<rbrakk>\n       \\<Longrightarrow> invar \\<sigma>", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma g_filter_impl: \"set_filter \\<alpha> invar \\<alpha> invar g_filter\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_filter \\<alpha> invar \\<alpha> invar g_filter", "unfolding g_filter_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_filter \\<alpha> invar \\<alpha> invar\n     (\\<lambda>P s.\n         iterate s\n          (\\<lambda>x \\<sigma>. if P x then ins_dj x \\<sigma> else \\<sigma>)\n          (local.empty ()))", "apply (unfold_locales)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s P.\n       invar s \\<Longrightarrow>\n       \\<alpha>\n        (iterate s\n          (\\<lambda>x \\<sigma>. if P x then ins_dj x \\<sigma> else \\<sigma>)\n          (local.empty ())) =\n       {e \\<in> \\<alpha> s. P e}\n 2. \\<And>s P.\n       invar s \\<Longrightarrow>\n       invar\n        (iterate s\n          (\\<lambda>x \\<sigma>. if P x then ins_dj x \\<sigma> else \\<sigma>)\n          (local.empty ()))", "apply (rule_tac I=\"\\<lambda>it \\<sigma>. invar \\<sigma> \\<and> \\<alpha> \\<sigma> = it \\<inter> Collect P\" \n      in iterate_rule_insert_P, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s P.\n       invar s \\<Longrightarrow>\n       invar\n        (iterate s\n          (\\<lambda>x \\<sigma>. if P x then ins_dj x \\<sigma> else \\<sigma>)\n          (local.empty ()))", "apply (rule_tac I=\"\\<lambda>it \\<sigma>. invar \\<sigma> \\<and> \\<alpha> \\<sigma> = it \\<inter> Collect P\" \n      in iterate_rule_insert_P, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma g_disjoint_witness_impl: \"set_disjoint_witness \n    \\<alpha> invar \\<alpha> invar g_disjoint_witness\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_disjoint_witness \\<alpha> invar \\<alpha> invar g_disjoint_witness", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set_disjoint_witness \\<alpha> invar \\<alpha> invar g_disjoint_witness", "interpret set_sel' \\<alpha> invar g_sel'"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_sel' \\<alpha> invar g_sel'", "by (rule g_sel'_impl)"], ["proof (state)\ngoal (1 subgoal):\n 1. set_disjoint_witness \\<alpha> invar \\<alpha> invar g_disjoint_witness", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_disjoint_witness \\<alpha> invar \\<alpha> invar g_disjoint_witness", "unfolding g_disjoint_witness_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_disjoint_witness \\<alpha> invar \\<alpha> invar\n     (\\<lambda>s1 s2. g_sel' s1 (\\<lambda>x. memb x s2))", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s1 s2.\n       \\<lbrakk>invar s1; invar s2;\n        g_sel' s1 (\\<lambda>x. memb x s2) = None\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> s1 \\<inter> \\<alpha> s2 = {}\n 2. \\<And>s1 s2 a.\n       \\<lbrakk>invar s1; invar s2;\n        g_sel' s1 (\\<lambda>x. memb x s2) = Some a\\<rbrakk>\n       \\<Longrightarrow> a \\<in> \\<alpha> s1 \\<inter> \\<alpha> s2", "by (auto dest: sel'_noneD sel'_someD simp: memb_correct)"], ["proof (state)\nthis:\n  set_disjoint_witness \\<alpha> invar \\<alpha> invar g_disjoint_witness\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma g_disjoint_impl: \"set_disjoint \n    \\<alpha> invar \\<alpha> invar g_disjoint\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_disjoint \\<alpha> invar \\<alpha> invar g_disjoint", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set_disjoint \\<alpha> invar \\<alpha> invar g_disjoint", "interpret set_ball \\<alpha> invar g_ball"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_ball \\<alpha> invar g_ball", "by (rule g_ball_impl)"], ["proof (state)\ngoal (1 subgoal):\n 1. set_disjoint \\<alpha> invar \\<alpha> invar g_disjoint", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_disjoint \\<alpha> invar \\<alpha> invar g_disjoint", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s1 s2.\n       \\<lbrakk>invar s1; invar s2\\<rbrakk>\n       \\<Longrightarrow> g_disjoint s1 s2 =\n                         (\\<alpha> s1 \\<inter> \\<alpha> s2 = {})", "unfolding g_disjoint_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s1 s2.\n       \\<lbrakk>invar s1; invar s2\\<rbrakk>\n       \\<Longrightarrow> g_ball s1 (\\<lambda>x. \\<not> memb x s2) =\n                         (\\<alpha> s1 \\<inter> \\<alpha> s2 = {})", "by (auto simp: memb_correct ball_correct)"], ["proof (state)\nthis:\n  set_disjoint \\<alpha> invar \\<alpha> invar g_disjoint\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "context StdBasicSet\nbegin"], ["", "lemma dflt_ops_impl: \"StdSet dflt_ops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. StdSet dflt_ops", "apply (rule StdSet_intro)"], ["proof (prove)\ngoal (25 subgoals):\n 1. set_empty (set_op_\\<alpha> dflt_ops) (set_op_invar dflt_ops)\n     (set_op_empty dflt_ops)\n 2. set_memb (set_op_\\<alpha> dflt_ops) (set_op_invar dflt_ops)\n     (set_op_memb dflt_ops)\n 3. set_ins (set_op_\\<alpha> dflt_ops) (set_op_invar dflt_ops)\n     (set_op_ins dflt_ops)\n 4. set_ins_dj (set_op_\\<alpha> dflt_ops) (set_op_invar dflt_ops)\n     (set_op_ins_dj dflt_ops)\n 5. set_delete (set_op_\\<alpha> dflt_ops) (set_op_invar dflt_ops)\n     (set_op_delete dflt_ops)\n 6. poly_set_iteratei (set_op_\\<alpha> dflt_ops) (set_op_invar dflt_ops)\n     (set_op_list_it dflt_ops)\n 7. set_sng (set_op_\\<alpha> dflt_ops) (set_op_invar dflt_ops)\n     (set_op_sng dflt_ops)\n 8. set_isEmpty (set_op_\\<alpha> dflt_ops) (set_op_invar dflt_ops)\n     (set_op_isEmpty dflt_ops)\n 9. set_isSng (set_op_\\<alpha> dflt_ops) (set_op_invar dflt_ops)\n     (set_op_isSng dflt_ops)\n 10. set_ball (set_op_\\<alpha> dflt_ops) (set_op_invar dflt_ops)\n      (set_op_ball dflt_ops)\nA total of 25 subgoals...", "apply icf_locales"], ["proof (prove)\ngoal (19 subgoals):\n 1. set_sng (set_op_\\<alpha> dflt_ops) (set_op_invar dflt_ops)\n     (set_op_sng dflt_ops)\n 2. set_isEmpty (set_op_\\<alpha> dflt_ops) (set_op_invar dflt_ops)\n     (set_op_isEmpty dflt_ops)\n 3. set_isSng (set_op_\\<alpha> dflt_ops) (set_op_invar dflt_ops)\n     (set_op_isSng dflt_ops)\n 4. set_ball (set_op_\\<alpha> dflt_ops) (set_op_invar dflt_ops)\n     (set_op_ball dflt_ops)\n 5. set_bex (set_op_\\<alpha> dflt_ops) (set_op_invar dflt_ops)\n     (set_op_bex dflt_ops)\n 6. set_size (set_op_\\<alpha> dflt_ops) (set_op_invar dflt_ops)\n     (set_op_size dflt_ops)\n 7. set_size_abort (set_op_\\<alpha> dflt_ops) (set_op_invar dflt_ops)\n     (set_op_size_abort dflt_ops)\n 8. set_union (set_op_\\<alpha> dflt_ops) (set_op_invar dflt_ops)\n     (set_op_\\<alpha> dflt_ops) (set_op_invar dflt_ops)\n     (set_op_\\<alpha> dflt_ops) (set_op_invar dflt_ops)\n     (set_op_union dflt_ops)\n 9. set_union_dj (set_op_\\<alpha> dflt_ops) (set_op_invar dflt_ops)\n     (set_op_\\<alpha> dflt_ops) (set_op_invar dflt_ops)\n     (set_op_\\<alpha> dflt_ops) (set_op_invar dflt_ops)\n     (set_op_union_dj dflt_ops)\n 10. set_diff (set_op_\\<alpha> dflt_ops) (set_op_invar dflt_ops)\n      (set_op_\\<alpha> dflt_ops) (set_op_invar dflt_ops)\n      (set_op_diff dflt_ops)\nA total of 19 subgoals...", "apply (simp_all add: icf_rec_unf)"], ["proof (prove)\ngoal (19 subgoals):\n 1. set_sng \\<alpha> invar g_sng\n 2. set_isEmpty \\<alpha> invar g_isEmpty\n 3. set_isSng \\<alpha> invar g_isSng\n 4. set_ball \\<alpha> invar g_ball\n 5. set_bex \\<alpha> invar g_bex\n 6. set_size \\<alpha> invar g_size\n 7. set_size_abort \\<alpha> invar g_size_abort\n 8. set_union \\<alpha> invar \\<alpha> invar \\<alpha> invar g_union\n 9. set_union_dj \\<alpha> invar \\<alpha> invar \\<alpha> invar g_union_dj\n 10. set_diff \\<alpha> invar \\<alpha> invar g_diff\nA total of 19 subgoals...", "apply (rule g_sng_impl g_isEmpty_impl g_isSng_impl g_ball_impl \n      g_bex_impl g_size_impl g_size_abort_impl g_union_impl g_union_dj_impl\n      g_diff_impl g_filter_impl g_inter_impl\n      g_subset_impl g_equal_impl g_disjoint_impl\n      g_disjoint_witness_impl g_sel'_impl g_to_list_impl\n      g_from_list_impl\n    )+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "context StdBasicOSetDefs\nbegin"], ["", "definition \"g_min s P \\<equiv> iterateoi s (\\<lambda>x. x = None) \n    (\\<lambda>x _. if P x then Some x else None) None\""], ["", "definition \"g_max s P \\<equiv> rev_iterateoi s (\\<lambda>x. x = None)\n    (\\<lambda>x _. if P x then Some x else None) None\""], ["", "definition \"g_to_sorted_list s \\<equiv> rev_iterateo s (#) []\""], ["", "definition \"g_to_rev_list s \\<equiv> iterateo s (#) []\""], ["", "definition dflt_oops :: \"('x::linorder,'s) oset_ops\" \n    where [icf_rec_def]:\n    \"dflt_oops \\<equiv> set_ops.extend \n      dflt_ops\n      \\<lparr> \n        set_op_ordered_list_it = ordered_list_it,\n        set_op_rev_list_it = rev_list_it,\n        set_op_min = g_min,\n        set_op_max = g_max,\n        set_op_to_sorted_list = g_to_sorted_list,\n        set_op_to_rev_list = g_to_rev_list\n      \\<rparr>\""], ["", "local_setup \\<open>Locale_Code.lc_decl_del @{term dflt_oops}\\<close>"], ["", "end"], ["", "context StdBasicOSet\nbegin"], ["", "lemma g_min_impl: \"set_min \\<alpha> invar g_min\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_min \\<alpha> invar g_min", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s x P.\n       \\<lbrakk>invar s; x \\<in> \\<alpha> s; P x\\<rbrakk>\n       \\<Longrightarrow> g_min s P \\<in> Some ` {x \\<in> \\<alpha> s. P x}\n 2. \\<And>s x P.\n       \\<lbrakk>invar s; x \\<in> \\<alpha> s; P x\\<rbrakk>\n       \\<Longrightarrow> the (g_min s P) \\<le> x\n 3. \\<And>s P.\n       \\<lbrakk>invar s; {x \\<in> \\<alpha> s. P x} = {}\\<rbrakk>\n       \\<Longrightarrow> g_min s P = None", "fix s P"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s x P.\n       \\<lbrakk>invar s; x \\<in> \\<alpha> s; P x\\<rbrakk>\n       \\<Longrightarrow> g_min s P \\<in> Some ` {x \\<in> \\<alpha> s. P x}\n 2. \\<And>s x P.\n       \\<lbrakk>invar s; x \\<in> \\<alpha> s; P x\\<rbrakk>\n       \\<Longrightarrow> the (g_min s P) \\<le> x\n 3. \\<And>s P.\n       \\<lbrakk>invar s; {x \\<in> \\<alpha> s. P x} = {}\\<rbrakk>\n       \\<Longrightarrow> g_min s P = None", "assume I: \"invar s\""], ["proof (state)\nthis:\n  invar s\n\ngoal (3 subgoals):\n 1. \\<And>s x P.\n       \\<lbrakk>invar s; x \\<in> \\<alpha> s; P x\\<rbrakk>\n       \\<Longrightarrow> g_min s P \\<in> Some ` {x \\<in> \\<alpha> s. P x}\n 2. \\<And>s x P.\n       \\<lbrakk>invar s; x \\<in> \\<alpha> s; P x\\<rbrakk>\n       \\<Longrightarrow> the (g_min s P) \\<le> x\n 3. \\<And>s P.\n       \\<lbrakk>invar s; {x \\<in> \\<alpha> s. P x} = {}\\<rbrakk>\n       \\<Longrightarrow> g_min s P = None", "from iterateoi_correct[OF I]"], ["proof (chain)\npicking this:\n  set_iterator_linord (iterateoi s) (\\<alpha> s)", "have iti': \"set_iterator_linord (iterateoi s) (\\<alpha> s)\""], ["proof (prove)\nusing this:\n  set_iterator_linord (iterateoi s) (\\<alpha> s)\n\ngoal (1 subgoal):\n 1. set_iterator_linord (iterateoi s) (\\<alpha> s)", "by simp"], ["proof (state)\nthis:\n  set_iterator_linord (iterateoi s) (\\<alpha> s)\n\ngoal (3 subgoals):\n 1. \\<And>s x P.\n       \\<lbrakk>invar s; x \\<in> \\<alpha> s; P x\\<rbrakk>\n       \\<Longrightarrow> g_min s P \\<in> Some ` {x \\<in> \\<alpha> s. P x}\n 2. \\<And>s x P.\n       \\<lbrakk>invar s; x \\<in> \\<alpha> s; P x\\<rbrakk>\n       \\<Longrightarrow> the (g_min s P) \\<le> x\n 3. \\<And>s P.\n       \\<lbrakk>invar s; {x \\<in> \\<alpha> s. P x} = {}\\<rbrakk>\n       \\<Longrightarrow> g_min s P = None", "note sel_correct = iterate_sel_no_map_linord_correct[OF iti', of P]"], ["proof (state)\nthis:\n  (iterate_sel_no_map (iterateoi s) P = None) =\n  (\\<forall>x\\<in>\\<alpha> s. \\<not> P x)\n  iterate_sel_no_map (iterateoi s) P = Some ?x \\<Longrightarrow>\n  ?x \\<in> \\<alpha> s \\<and>\n  P ?x \\<and>\n  (\\<forall>x'\\<in>\\<alpha> s. P x' \\<longrightarrow> ?x \\<le> x')\n\ngoal (3 subgoals):\n 1. \\<And>s x P.\n       \\<lbrakk>invar s; x \\<in> \\<alpha> s; P x\\<rbrakk>\n       \\<Longrightarrow> g_min s P \\<in> Some ` {x \\<in> \\<alpha> s. P x}\n 2. \\<And>s x P.\n       \\<lbrakk>invar s; x \\<in> \\<alpha> s; P x\\<rbrakk>\n       \\<Longrightarrow> the (g_min s P) \\<le> x\n 3. \\<And>s P.\n       \\<lbrakk>invar s; {x \\<in> \\<alpha> s. P x} = {}\\<rbrakk>\n       \\<Longrightarrow> g_min s P = None", "have A: \"g_min s P = iterate_sel_no_map (iterateoi s) P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g_min s P = iterate_sel_no_map (iterateoi s) P", "unfolding g_min_def iterate_sel_no_map_def iterate_sel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. iterateoi s (\\<lambda>x. x = None)\n     (\\<lambda>x _. if P x then Some x else None) None =\n    iterateoi s (\\<lambda>\\<sigma>. \\<sigma> = None)\n     (\\<lambda>x \\<sigma>. if P x then Some x else None) None", "by simp"], ["proof (state)\nthis:\n  g_min s P = iterate_sel_no_map (iterateoi s) P\n\ngoal (3 subgoals):\n 1. \\<And>s x P.\n       \\<lbrakk>invar s; x \\<in> \\<alpha> s; P x\\<rbrakk>\n       \\<Longrightarrow> g_min s P \\<in> Some ` {x \\<in> \\<alpha> s. P x}\n 2. \\<And>s x P.\n       \\<lbrakk>invar s; x \\<in> \\<alpha> s; P x\\<rbrakk>\n       \\<Longrightarrow> the (g_min s P) \\<le> x\n 3. \\<And>s P.\n       \\<lbrakk>invar s; {x \\<in> \\<alpha> s. P x} = {}\\<rbrakk>\n       \\<Longrightarrow> g_min s P = None", "{"], ["proof (state)\nthis:\n  g_min s P = iterate_sel_no_map (iterateoi s) P\n\ngoal (3 subgoals):\n 1. \\<And>s x P.\n       \\<lbrakk>invar s; x \\<in> \\<alpha> s; P x\\<rbrakk>\n       \\<Longrightarrow> g_min s P \\<in> Some ` {x \\<in> \\<alpha> s. P x}\n 2. \\<And>s x P.\n       \\<lbrakk>invar s; x \\<in> \\<alpha> s; P x\\<rbrakk>\n       \\<Longrightarrow> the (g_min s P) \\<le> x\n 3. \\<And>s P.\n       \\<lbrakk>invar s; {x \\<in> \\<alpha> s. P x} = {}\\<rbrakk>\n       \\<Longrightarrow> g_min s P = None", "fix x"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s x P.\n       \\<lbrakk>invar s; x \\<in> \\<alpha> s; P x\\<rbrakk>\n       \\<Longrightarrow> g_min s P \\<in> Some ` {x \\<in> \\<alpha> s. P x}\n 2. \\<And>s x P.\n       \\<lbrakk>invar s; x \\<in> \\<alpha> s; P x\\<rbrakk>\n       \\<Longrightarrow> the (g_min s P) \\<le> x\n 3. \\<And>s P.\n       \\<lbrakk>invar s; {x \\<in> \\<alpha> s. P x} = {}\\<rbrakk>\n       \\<Longrightarrow> g_min s P = None", "assume \"x\\<in>\\<alpha> s\" \"P x\""], ["proof (state)\nthis:\n  x \\<in> \\<alpha> s\n  P x\n\ngoal (3 subgoals):\n 1. \\<And>s x P.\n       \\<lbrakk>invar s; x \\<in> \\<alpha> s; P x\\<rbrakk>\n       \\<Longrightarrow> g_min s P \\<in> Some ` {x \\<in> \\<alpha> s. P x}\n 2. \\<And>s x P.\n       \\<lbrakk>invar s; x \\<in> \\<alpha> s; P x\\<rbrakk>\n       \\<Longrightarrow> the (g_min s P) \\<le> x\n 3. \\<And>s P.\n       \\<lbrakk>invar s; {x \\<in> \\<alpha> s. P x} = {}\\<rbrakk>\n       \\<Longrightarrow> g_min s P = None", "with sel_correct"], ["proof (chain)\npicking this:\n  (iterate_sel_no_map (iterateoi s) P = None) =\n  (\\<forall>x\\<in>\\<alpha> s. \\<not> P x)\n  iterate_sel_no_map (iterateoi s) P = Some ?x \\<Longrightarrow>\n  ?x \\<in> \\<alpha> s \\<and>\n  P ?x \\<and>\n  (\\<forall>x'\\<in>\\<alpha> s. P x' \\<longrightarrow> ?x \\<le> x')\n  x \\<in> \\<alpha> s\n  P x", "show \"g_min s P \\<in> Some ` {x\\<in>\\<alpha> s. P x}\" and \"the (g_min s P) \\<le> x\""], ["proof (prove)\nusing this:\n  (iterate_sel_no_map (iterateoi s) P = None) =\n  (\\<forall>x\\<in>\\<alpha> s. \\<not> P x)\n  iterate_sel_no_map (iterateoi s) P = Some ?x \\<Longrightarrow>\n  ?x \\<in> \\<alpha> s \\<and>\n  P ?x \\<and>\n  (\\<forall>x'\\<in>\\<alpha> s. P x' \\<longrightarrow> ?x \\<le> x')\n  x \\<in> \\<alpha> s\n  P x\n\ngoal (1 subgoal):\n 1. g_min s P \\<in> Some ` {x \\<in> \\<alpha> s. P x} &&&\n    the (g_min s P) \\<le> x", "unfolding A"], ["proof (prove)\nusing this:\n  (iterate_sel_no_map (iterateoi s) P = None) =\n  (\\<forall>x\\<in>\\<alpha> s. \\<not> P x)\n  iterate_sel_no_map (iterateoi s) P = Some ?x \\<Longrightarrow>\n  ?x \\<in> \\<alpha> s \\<and>\n  P ?x \\<and>\n  (\\<forall>x'\\<in>\\<alpha> s. P x' \\<longrightarrow> ?x \\<le> x')\n  x \\<in> \\<alpha> s\n  P x\n\ngoal (1 subgoal):\n 1. iterate_sel_no_map (iterateoi s) P\n    \\<in> Some ` {x \\<in> \\<alpha> s. P x} &&&\n    the (iterate_sel_no_map (iterateoi s) P) \\<le> x", "by auto"], ["proof (state)\nthis:\n  g_min s P \\<in> Some ` {x \\<in> \\<alpha> s. P x}\n  the (g_min s P) \\<le> x\n\ngoal (1 subgoal):\n 1. \\<And>s P.\n       \\<lbrakk>invar s; {x \\<in> \\<alpha> s. P x} = {}\\<rbrakk>\n       \\<Longrightarrow> g_min s P = None", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?x7 \\<in> \\<alpha> s; P ?x7\\<rbrakk>\n  \\<Longrightarrow> g_min s P \\<in> Some ` {x \\<in> \\<alpha> s. P x}\n  \\<lbrakk>?x7 \\<in> \\<alpha> s; P ?x7\\<rbrakk>\n  \\<Longrightarrow> the (g_min s P) \\<le> ?x7\n\ngoal (1 subgoal):\n 1. \\<And>s P.\n       \\<lbrakk>invar s; {x \\<in> \\<alpha> s. P x} = {}\\<rbrakk>\n       \\<Longrightarrow> g_min s P = None", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?x7 \\<in> \\<alpha> s; P ?x7\\<rbrakk>\n  \\<Longrightarrow> g_min s P \\<in> Some ` {x \\<in> \\<alpha> s. P x}\n  \\<lbrakk>?x7 \\<in> \\<alpha> s; P ?x7\\<rbrakk>\n  \\<Longrightarrow> the (g_min s P) \\<le> ?x7\n\ngoal (1 subgoal):\n 1. \\<And>s P.\n       \\<lbrakk>invar s; {x \\<in> \\<alpha> s. P x} = {}\\<rbrakk>\n       \\<Longrightarrow> g_min s P = None", "assume \"{x\\<in>\\<alpha> s. P x} = {}\""], ["proof (state)\nthis:\n  {x \\<in> \\<alpha> s. P x} = {}\n\ngoal (1 subgoal):\n 1. \\<And>s P.\n       \\<lbrakk>invar s; {x \\<in> \\<alpha> s. P x} = {}\\<rbrakk>\n       \\<Longrightarrow> g_min s P = None", "with sel_correct"], ["proof (chain)\npicking this:\n  (iterate_sel_no_map (iterateoi s) P = None) =\n  (\\<forall>x\\<in>\\<alpha> s. \\<not> P x)\n  iterate_sel_no_map (iterateoi s) P = Some ?x \\<Longrightarrow>\n  ?x \\<in> \\<alpha> s \\<and>\n  P ?x \\<and>\n  (\\<forall>x'\\<in>\\<alpha> s. P x' \\<longrightarrow> ?x \\<le> x')\n  {x \\<in> \\<alpha> s. P x} = {}", "show \"g_min s P = None\""], ["proof (prove)\nusing this:\n  (iterate_sel_no_map (iterateoi s) P = None) =\n  (\\<forall>x\\<in>\\<alpha> s. \\<not> P x)\n  iterate_sel_no_map (iterateoi s) P = Some ?x \\<Longrightarrow>\n  ?x \\<in> \\<alpha> s \\<and>\n  P ?x \\<and>\n  (\\<forall>x'\\<in>\\<alpha> s. P x' \\<longrightarrow> ?x \\<le> x')\n  {x \\<in> \\<alpha> s. P x} = {}\n\ngoal (1 subgoal):\n 1. g_min s P = None", "unfolding A"], ["proof (prove)\nusing this:\n  (iterate_sel_no_map (iterateoi s) P = None) =\n  (\\<forall>x\\<in>\\<alpha> s. \\<not> P x)\n  iterate_sel_no_map (iterateoi s) P = Some ?x \\<Longrightarrow>\n  ?x \\<in> \\<alpha> s \\<and>\n  P ?x \\<and>\n  (\\<forall>x'\\<in>\\<alpha> s. P x' \\<longrightarrow> ?x \\<le> x')\n  {x \\<in> \\<alpha> s. P x} = {}\n\ngoal (1 subgoal):\n 1. iterate_sel_no_map (iterateoi s) P = None", "by auto"], ["proof (state)\nthis:\n  g_min s P = None\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  {x \\<in> \\<alpha> s. P x} = {} \\<Longrightarrow> g_min s P = None\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma g_max_impl: \"set_max \\<alpha> invar g_max\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_max \\<alpha> invar g_max", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s x P.\n       \\<lbrakk>invar s; x \\<in> \\<alpha> s; P x\\<rbrakk>\n       \\<Longrightarrow> g_max s P \\<in> Some ` {x \\<in> \\<alpha> s. P x}\n 2. \\<And>s x P.\n       \\<lbrakk>invar s; x \\<in> \\<alpha> s; P x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> the (g_max s P)\n 3. \\<And>s P.\n       \\<lbrakk>invar s; {x \\<in> \\<alpha> s. P x} = {}\\<rbrakk>\n       \\<Longrightarrow> g_max s P = None", "fix s P"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s x P.\n       \\<lbrakk>invar s; x \\<in> \\<alpha> s; P x\\<rbrakk>\n       \\<Longrightarrow> g_max s P \\<in> Some ` {x \\<in> \\<alpha> s. P x}\n 2. \\<And>s x P.\n       \\<lbrakk>invar s; x \\<in> \\<alpha> s; P x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> the (g_max s P)\n 3. \\<And>s P.\n       \\<lbrakk>invar s; {x \\<in> \\<alpha> s. P x} = {}\\<rbrakk>\n       \\<Longrightarrow> g_max s P = None", "assume I: \"invar s\""], ["proof (state)\nthis:\n  invar s\n\ngoal (3 subgoals):\n 1. \\<And>s x P.\n       \\<lbrakk>invar s; x \\<in> \\<alpha> s; P x\\<rbrakk>\n       \\<Longrightarrow> g_max s P \\<in> Some ` {x \\<in> \\<alpha> s. P x}\n 2. \\<And>s x P.\n       \\<lbrakk>invar s; x \\<in> \\<alpha> s; P x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> the (g_max s P)\n 3. \\<And>s P.\n       \\<lbrakk>invar s; {x \\<in> \\<alpha> s. P x} = {}\\<rbrakk>\n       \\<Longrightarrow> g_max s P = None", "from rev_iterateoi_correct[OF I]"], ["proof (chain)\npicking this:\n  set_iterator_rev_linord (reverse_iterateoi s) (\\<alpha> s)", "have iti': \"set_iterator_rev_linord (rev_iterateoi s) (\\<alpha> s)\""], ["proof (prove)\nusing this:\n  set_iterator_rev_linord (reverse_iterateoi s) (\\<alpha> s)\n\ngoal (1 subgoal):\n 1. set_iterator_rev_linord (reverse_iterateoi s) (\\<alpha> s)", "by simp"], ["proof (state)\nthis:\n  set_iterator_rev_linord (reverse_iterateoi s) (\\<alpha> s)\n\ngoal (3 subgoals):\n 1. \\<And>s x P.\n       \\<lbrakk>invar s; x \\<in> \\<alpha> s; P x\\<rbrakk>\n       \\<Longrightarrow> g_max s P \\<in> Some ` {x \\<in> \\<alpha> s. P x}\n 2. \\<And>s x P.\n       \\<lbrakk>invar s; x \\<in> \\<alpha> s; P x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> the (g_max s P)\n 3. \\<And>s P.\n       \\<lbrakk>invar s; {x \\<in> \\<alpha> s. P x} = {}\\<rbrakk>\n       \\<Longrightarrow> g_max s P = None", "note sel_correct = iterate_sel_no_map_rev_linord_correct[OF iti', of P]"], ["proof (state)\nthis:\n  (iterate_sel_no_map (reverse_iterateoi s) P = None) =\n  (\\<forall>x\\<in>\\<alpha> s. \\<not> P x)\n  iterate_sel_no_map (reverse_iterateoi s) P = Some ?x \\<Longrightarrow>\n  ?x \\<in> \\<alpha> s \\<and>\n  P ?x \\<and>\n  (\\<forall>x'\\<in>\\<alpha> s. P x' \\<longrightarrow> x' \\<le> ?x)\n\ngoal (3 subgoals):\n 1. \\<And>s x P.\n       \\<lbrakk>invar s; x \\<in> \\<alpha> s; P x\\<rbrakk>\n       \\<Longrightarrow> g_max s P \\<in> Some ` {x \\<in> \\<alpha> s. P x}\n 2. \\<And>s x P.\n       \\<lbrakk>invar s; x \\<in> \\<alpha> s; P x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> the (g_max s P)\n 3. \\<And>s P.\n       \\<lbrakk>invar s; {x \\<in> \\<alpha> s. P x} = {}\\<rbrakk>\n       \\<Longrightarrow> g_max s P = None", "have A: \"g_max s P = iterate_sel_no_map (rev_iterateoi s) P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g_max s P = iterate_sel_no_map (reverse_iterateoi s) P", "unfolding g_max_def iterate_sel_no_map_def iterate_sel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. reverse_iterateoi s (\\<lambda>x. x = None)\n     (\\<lambda>x _. if P x then Some x else None) None =\n    reverse_iterateoi s (\\<lambda>\\<sigma>. \\<sigma> = None)\n     (\\<lambda>x \\<sigma>. if P x then Some x else None) None", "by simp"], ["proof (state)\nthis:\n  g_max s P = iterate_sel_no_map (reverse_iterateoi s) P\n\ngoal (3 subgoals):\n 1. \\<And>s x P.\n       \\<lbrakk>invar s; x \\<in> \\<alpha> s; P x\\<rbrakk>\n       \\<Longrightarrow> g_max s P \\<in> Some ` {x \\<in> \\<alpha> s. P x}\n 2. \\<And>s x P.\n       \\<lbrakk>invar s; x \\<in> \\<alpha> s; P x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> the (g_max s P)\n 3. \\<And>s P.\n       \\<lbrakk>invar s; {x \\<in> \\<alpha> s. P x} = {}\\<rbrakk>\n       \\<Longrightarrow> g_max s P = None", "{"], ["proof (state)\nthis:\n  g_max s P = iterate_sel_no_map (reverse_iterateoi s) P\n\ngoal (3 subgoals):\n 1. \\<And>s x P.\n       \\<lbrakk>invar s; x \\<in> \\<alpha> s; P x\\<rbrakk>\n       \\<Longrightarrow> g_max s P \\<in> Some ` {x \\<in> \\<alpha> s. P x}\n 2. \\<And>s x P.\n       \\<lbrakk>invar s; x \\<in> \\<alpha> s; P x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> the (g_max s P)\n 3. \\<And>s P.\n       \\<lbrakk>invar s; {x \\<in> \\<alpha> s. P x} = {}\\<rbrakk>\n       \\<Longrightarrow> g_max s P = None", "fix x"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s x P.\n       \\<lbrakk>invar s; x \\<in> \\<alpha> s; P x\\<rbrakk>\n       \\<Longrightarrow> g_max s P \\<in> Some ` {x \\<in> \\<alpha> s. P x}\n 2. \\<And>s x P.\n       \\<lbrakk>invar s; x \\<in> \\<alpha> s; P x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> the (g_max s P)\n 3. \\<And>s P.\n       \\<lbrakk>invar s; {x \\<in> \\<alpha> s. P x} = {}\\<rbrakk>\n       \\<Longrightarrow> g_max s P = None", "assume \"x\\<in>\\<alpha> s\" \"P x\""], ["proof (state)\nthis:\n  x \\<in> \\<alpha> s\n  P x\n\ngoal (3 subgoals):\n 1. \\<And>s x P.\n       \\<lbrakk>invar s; x \\<in> \\<alpha> s; P x\\<rbrakk>\n       \\<Longrightarrow> g_max s P \\<in> Some ` {x \\<in> \\<alpha> s. P x}\n 2. \\<And>s x P.\n       \\<lbrakk>invar s; x \\<in> \\<alpha> s; P x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> the (g_max s P)\n 3. \\<And>s P.\n       \\<lbrakk>invar s; {x \\<in> \\<alpha> s. P x} = {}\\<rbrakk>\n       \\<Longrightarrow> g_max s P = None", "with sel_correct"], ["proof (chain)\npicking this:\n  (iterate_sel_no_map (reverse_iterateoi s) P = None) =\n  (\\<forall>x\\<in>\\<alpha> s. \\<not> P x)\n  iterate_sel_no_map (reverse_iterateoi s) P = Some ?x \\<Longrightarrow>\n  ?x \\<in> \\<alpha> s \\<and>\n  P ?x \\<and>\n  (\\<forall>x'\\<in>\\<alpha> s. P x' \\<longrightarrow> x' \\<le> ?x)\n  x \\<in> \\<alpha> s\n  P x", "show \"g_max s P \\<in> Some ` {x\\<in>\\<alpha> s. P x}\" and \"the (g_max s P) \\<ge> x\""], ["proof (prove)\nusing this:\n  (iterate_sel_no_map (reverse_iterateoi s) P = None) =\n  (\\<forall>x\\<in>\\<alpha> s. \\<not> P x)\n  iterate_sel_no_map (reverse_iterateoi s) P = Some ?x \\<Longrightarrow>\n  ?x \\<in> \\<alpha> s \\<and>\n  P ?x \\<and>\n  (\\<forall>x'\\<in>\\<alpha> s. P x' \\<longrightarrow> x' \\<le> ?x)\n  x \\<in> \\<alpha> s\n  P x\n\ngoal (1 subgoal):\n 1. g_max s P \\<in> Some ` {x \\<in> \\<alpha> s. P x} &&&\n    x \\<le> the (g_max s P)", "unfolding A"], ["proof (prove)\nusing this:\n  (iterate_sel_no_map (reverse_iterateoi s) P = None) =\n  (\\<forall>x\\<in>\\<alpha> s. \\<not> P x)\n  iterate_sel_no_map (reverse_iterateoi s) P = Some ?x \\<Longrightarrow>\n  ?x \\<in> \\<alpha> s \\<and>\n  P ?x \\<and>\n  (\\<forall>x'\\<in>\\<alpha> s. P x' \\<longrightarrow> x' \\<le> ?x)\n  x \\<in> \\<alpha> s\n  P x\n\ngoal (1 subgoal):\n 1. iterate_sel_no_map (reverse_iterateoi s) P\n    \\<in> Some ` {x \\<in> \\<alpha> s. P x} &&&\n    x \\<le> the (iterate_sel_no_map (reverse_iterateoi s) P)", "by auto"], ["proof (state)\nthis:\n  g_max s P \\<in> Some ` {x \\<in> \\<alpha> s. P x}\n  x \\<le> the (g_max s P)\n\ngoal (1 subgoal):\n 1. \\<And>s P.\n       \\<lbrakk>invar s; {x \\<in> \\<alpha> s. P x} = {}\\<rbrakk>\n       \\<Longrightarrow> g_max s P = None", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?x7 \\<in> \\<alpha> s; P ?x7\\<rbrakk>\n  \\<Longrightarrow> g_max s P \\<in> Some ` {x \\<in> \\<alpha> s. P x}\n  \\<lbrakk>?x7 \\<in> \\<alpha> s; P ?x7\\<rbrakk>\n  \\<Longrightarrow> ?x7 \\<le> the (g_max s P)\n\ngoal (1 subgoal):\n 1. \\<And>s P.\n       \\<lbrakk>invar s; {x \\<in> \\<alpha> s. P x} = {}\\<rbrakk>\n       \\<Longrightarrow> g_max s P = None", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?x7 \\<in> \\<alpha> s; P ?x7\\<rbrakk>\n  \\<Longrightarrow> g_max s P \\<in> Some ` {x \\<in> \\<alpha> s. P x}\n  \\<lbrakk>?x7 \\<in> \\<alpha> s; P ?x7\\<rbrakk>\n  \\<Longrightarrow> ?x7 \\<le> the (g_max s P)\n\ngoal (1 subgoal):\n 1. \\<And>s P.\n       \\<lbrakk>invar s; {x \\<in> \\<alpha> s. P x} = {}\\<rbrakk>\n       \\<Longrightarrow> g_max s P = None", "assume \"{x\\<in>\\<alpha> s. P x} = {}\""], ["proof (state)\nthis:\n  {x \\<in> \\<alpha> s. P x} = {}\n\ngoal (1 subgoal):\n 1. \\<And>s P.\n       \\<lbrakk>invar s; {x \\<in> \\<alpha> s. P x} = {}\\<rbrakk>\n       \\<Longrightarrow> g_max s P = None", "with sel_correct"], ["proof (chain)\npicking this:\n  (iterate_sel_no_map (reverse_iterateoi s) P = None) =\n  (\\<forall>x\\<in>\\<alpha> s. \\<not> P x)\n  iterate_sel_no_map (reverse_iterateoi s) P = Some ?x \\<Longrightarrow>\n  ?x \\<in> \\<alpha> s \\<and>\n  P ?x \\<and>\n  (\\<forall>x'\\<in>\\<alpha> s. P x' \\<longrightarrow> x' \\<le> ?x)\n  {x \\<in> \\<alpha> s. P x} = {}", "show \"g_max s P = None\""], ["proof (prove)\nusing this:\n  (iterate_sel_no_map (reverse_iterateoi s) P = None) =\n  (\\<forall>x\\<in>\\<alpha> s. \\<not> P x)\n  iterate_sel_no_map (reverse_iterateoi s) P = Some ?x \\<Longrightarrow>\n  ?x \\<in> \\<alpha> s \\<and>\n  P ?x \\<and>\n  (\\<forall>x'\\<in>\\<alpha> s. P x' \\<longrightarrow> x' \\<le> ?x)\n  {x \\<in> \\<alpha> s. P x} = {}\n\ngoal (1 subgoal):\n 1. g_max s P = None", "unfolding A"], ["proof (prove)\nusing this:\n  (iterate_sel_no_map (reverse_iterateoi s) P = None) =\n  (\\<forall>x\\<in>\\<alpha> s. \\<not> P x)\n  iterate_sel_no_map (reverse_iterateoi s) P = Some ?x \\<Longrightarrow>\n  ?x \\<in> \\<alpha> s \\<and>\n  P ?x \\<and>\n  (\\<forall>x'\\<in>\\<alpha> s. P x' \\<longrightarrow> x' \\<le> ?x)\n  {x \\<in> \\<alpha> s. P x} = {}\n\ngoal (1 subgoal):\n 1. iterate_sel_no_map (reverse_iterateoi s) P = None", "by auto"], ["proof (state)\nthis:\n  g_max s P = None\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  {x \\<in> \\<alpha> s. P x} = {} \\<Longrightarrow> g_max s P = None\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma g_to_sorted_list_impl: \"set_to_sorted_list \\<alpha> invar g_to_sorted_list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SetSpec.set_to_sorted_list \\<alpha> invar g_to_sorted_list", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s. invar s \\<Longrightarrow> set (g_to_sorted_list s) = \\<alpha> s\n 2. \\<And>s. invar s \\<Longrightarrow> distinct (g_to_sorted_list s)\n 3. \\<And>s. invar s \\<Longrightarrow> sorted (g_to_sorted_list s)", "fix s"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s. invar s \\<Longrightarrow> set (g_to_sorted_list s) = \\<alpha> s\n 2. \\<And>s. invar s \\<Longrightarrow> distinct (g_to_sorted_list s)\n 3. \\<And>s. invar s \\<Longrightarrow> sorted (g_to_sorted_list s)", "assume I: \"invar s\""], ["proof (state)\nthis:\n  invar s\n\ngoal (3 subgoals):\n 1. \\<And>s. invar s \\<Longrightarrow> set (g_to_sorted_list s) = \\<alpha> s\n 2. \\<And>s. invar s \\<Longrightarrow> distinct (g_to_sorted_list s)\n 3. \\<And>s. invar s \\<Longrightarrow> sorted (g_to_sorted_list s)", "note iti = rev_iterateoi_correct[OF I]"], ["proof (state)\nthis:\n  set_iterator_rev_linord (reverse_iterateoi s) (\\<alpha> s)\n\ngoal (3 subgoals):\n 1. \\<And>s. invar s \\<Longrightarrow> set (g_to_sorted_list s) = \\<alpha> s\n 2. \\<And>s. invar s \\<Longrightarrow> distinct (g_to_sorted_list s)\n 3. \\<And>s. invar s \\<Longrightarrow> sorted (g_to_sorted_list s)", "from iterate_to_list_rev_linord_correct[OF iti]"], ["proof (chain)\npicking this:\n  set (iterate_to_list (reverse_iterateoi s)) = \\<alpha> s \\<and>\n  distinct (iterate_to_list (reverse_iterateoi s)) \\<and>\n  sorted (iterate_to_list (reverse_iterateoi s))", "show \"sorted (g_to_sorted_list s)\" \n         \"distinct (g_to_sorted_list s)\"\n         \"set (g_to_sorted_list s) = \\<alpha> s\""], ["proof (prove)\nusing this:\n  set (iterate_to_list (reverse_iterateoi s)) = \\<alpha> s \\<and>\n  distinct (iterate_to_list (reverse_iterateoi s)) \\<and>\n  sorted (iterate_to_list (reverse_iterateoi s))\n\ngoal (1 subgoal):\n 1. sorted (g_to_sorted_list s) &&&\n    distinct (g_to_sorted_list s) &&& set (g_to_sorted_list s) = \\<alpha> s", "unfolding g_to_sorted_list_def iterate_to_list_def"], ["proof (prove)\nusing this:\n  set (reverse_iterateo s (#) []) = \\<alpha> s \\<and>\n  distinct (reverse_iterateo s (#) []) \\<and>\n  sorted (reverse_iterateo s (#) [])\n\ngoal (1 subgoal):\n 1. sorted (reverse_iterateo s (#) []) &&&\n    distinct (reverse_iterateo s (#) []) &&&\n    set (reverse_iterateo s (#) []) = \\<alpha> s", "by simp_all"], ["proof (state)\nthis:\n  sorted (g_to_sorted_list s)\n  distinct (g_to_sorted_list s)\n  set (g_to_sorted_list s) = \\<alpha> s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma g_to_rev_list_impl: \"set_to_rev_list \\<alpha> invar g_to_rev_list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_to_rev_list \\<alpha> invar g_to_rev_list", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s. invar s \\<Longrightarrow> set (g_to_rev_list s) = \\<alpha> s\n 2. \\<And>s. invar s \\<Longrightarrow> distinct (g_to_rev_list s)\n 3. \\<And>s. invar s \\<Longrightarrow> sorted (rev (g_to_rev_list s))", "fix s"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>s. invar s \\<Longrightarrow> set (g_to_rev_list s) = \\<alpha> s\n 2. \\<And>s. invar s \\<Longrightarrow> distinct (g_to_rev_list s)\n 3. \\<And>s. invar s \\<Longrightarrow> sorted (rev (g_to_rev_list s))", "assume I: \"invar s\""], ["proof (state)\nthis:\n  invar s\n\ngoal (3 subgoals):\n 1. \\<And>s. invar s \\<Longrightarrow> set (g_to_rev_list s) = \\<alpha> s\n 2. \\<And>s. invar s \\<Longrightarrow> distinct (g_to_rev_list s)\n 3. \\<And>s. invar s \\<Longrightarrow> sorted (rev (g_to_rev_list s))", "note iti = iterateoi_correct[OF I]"], ["proof (state)\nthis:\n  set_iterator_linord (iterateoi s) (\\<alpha> s)\n\ngoal (3 subgoals):\n 1. \\<And>s. invar s \\<Longrightarrow> set (g_to_rev_list s) = \\<alpha> s\n 2. \\<And>s. invar s \\<Longrightarrow> distinct (g_to_rev_list s)\n 3. \\<And>s. invar s \\<Longrightarrow> sorted (rev (g_to_rev_list s))", "from iterate_to_list_linord_correct[OF iti]"], ["proof (chain)\npicking this:\n  set (iterate_to_list (iterateoi s)) = \\<alpha> s \\<and>\n  distinct (iterate_to_list (iterateoi s)) \\<and>\n  sorted (rev (iterate_to_list (iterateoi s)))", "show \"sorted (rev (g_to_rev_list s))\" \n         \"distinct (g_to_rev_list s)\"\n         \"set (g_to_rev_list s) = \\<alpha> s\""], ["proof (prove)\nusing this:\n  set (iterate_to_list (iterateoi s)) = \\<alpha> s \\<and>\n  distinct (iterate_to_list (iterateoi s)) \\<and>\n  sorted (rev (iterate_to_list (iterateoi s)))\n\ngoal (1 subgoal):\n 1. sorted (rev (g_to_rev_list s)) &&&\n    distinct (g_to_rev_list s) &&& set (g_to_rev_list s) = \\<alpha> s", "unfolding g_to_rev_list_def iterate_to_list_def"], ["proof (prove)\nusing this:\n  set (iterateo s (#) []) = \\<alpha> s \\<and>\n  distinct (iterateo s (#) []) \\<and> sorted (rev (iterateo s (#) []))\n\ngoal (1 subgoal):\n 1. sorted (rev (iterateo s (#) [])) &&&\n    distinct (iterateo s (#) []) &&& set (iterateo s (#) []) = \\<alpha> s", "by (simp_all)"], ["proof (state)\nthis:\n  sorted (rev (g_to_rev_list s))\n  distinct (g_to_rev_list s)\n  set (g_to_rev_list s) = \\<alpha> s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dflt_oops_impl: \"StdOSet dflt_oops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. StdOSet dflt_oops", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. StdOSet dflt_oops", "interpret aux: StdSet dflt_ops"], ["proof (prove)\ngoal (1 subgoal):\n 1. StdSet dflt_ops", "by (rule dflt_ops_impl)"], ["proof (state)\ngoal (1 subgoal):\n 1. StdOSet dflt_oops", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. StdOSet dflt_oops", "apply (rule StdOSet_intro)"], ["proof (prove)\ngoal (31 subgoals):\n 1. set_empty (set_op_\\<alpha> dflt_oops) (set_op_invar dflt_oops)\n     (set_op_empty dflt_oops)\n 2. set_memb (set_op_\\<alpha> dflt_oops) (set_op_invar dflt_oops)\n     (set_op_memb dflt_oops)\n 3. set_ins (set_op_\\<alpha> dflt_oops) (set_op_invar dflt_oops)\n     (set_op_ins dflt_oops)\n 4. set_ins_dj (set_op_\\<alpha> dflt_oops) (set_op_invar dflt_oops)\n     (set_op_ins_dj dflt_oops)\n 5. set_delete (set_op_\\<alpha> dflt_oops) (set_op_invar dflt_oops)\n     (set_op_delete dflt_oops)\n 6. poly_set_iteratei (set_op_\\<alpha> dflt_oops) (set_op_invar dflt_oops)\n     (set_op_list_it dflt_oops)\n 7. set_sng (set_op_\\<alpha> dflt_oops) (set_op_invar dflt_oops)\n     (set_op_sng dflt_oops)\n 8. set_isEmpty (set_op_\\<alpha> dflt_oops) (set_op_invar dflt_oops)\n     (set_op_isEmpty dflt_oops)\n 9. set_isSng (set_op_\\<alpha> dflt_oops) (set_op_invar dflt_oops)\n     (set_op_isSng dflt_oops)\n 10. set_ball (set_op_\\<alpha> dflt_oops) (set_op_invar dflt_oops)\n      (set_op_ball dflt_oops)\nA total of 31 subgoals...", "apply icf_locales"], ["proof (prove)\ngoal (4 subgoals):\n 1. set_min (set_op_\\<alpha> dflt_oops) (set_op_invar dflt_oops)\n     (set_op_min dflt_oops)\n 2. set_max (set_op_\\<alpha> dflt_oops) (set_op_invar dflt_oops)\n     (set_op_max dflt_oops)\n 3. SetSpec.set_to_sorted_list (set_op_\\<alpha> dflt_oops)\n     (set_op_invar dflt_oops) (set_op_to_sorted_list dflt_oops)\n 4. set_to_rev_list (set_op_\\<alpha> dflt_oops) (set_op_invar dflt_oops)\n     (set_op_to_rev_list dflt_oops)", "apply (simp_all add: icf_rec_unf)"], ["proof (prove)\ngoal (4 subgoals):\n 1. set_min \\<alpha> invar g_min\n 2. set_max \\<alpha> invar g_max\n 3. SetSpec.set_to_sorted_list \\<alpha> invar g_to_sorted_list\n 4. set_to_rev_list \\<alpha> invar g_to_rev_list", "apply (rule g_min_impl)"], ["proof (prove)\ngoal (3 subgoals):\n 1. set_max \\<alpha> invar g_max\n 2. SetSpec.set_to_sorted_list \\<alpha> invar g_to_sorted_list\n 3. set_to_rev_list \\<alpha> invar g_to_rev_list", "apply (rule g_max_impl)"], ["proof (prove)\ngoal (2 subgoals):\n 1. SetSpec.set_to_sorted_list \\<alpha> invar g_to_sorted_list\n 2. set_to_rev_list \\<alpha> invar g_to_rev_list", "apply (rule g_to_sorted_list_impl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_to_rev_list \\<alpha> invar g_to_rev_list", "apply (rule g_to_rev_list_impl)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  StdOSet dflt_oops\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \"More Generic Set Algorithms\""], ["", "text \\<open>\n  These algorithms do not have a function specification in a locale, but\n  their specification is done  ad-hoc in the correctness lemma.\n\\<close>"], ["", "subsubsection \"Image and Filter of Cartesian Product\""], ["", "locale image_filter_cp_defs_loc =\n  s1: StdSetDefs ops1 +\n  s2: StdSetDefs ops2 +\n  s3: StdSetDefs ops3\n  for ops1 :: \"('x,'s1,'more1) set_ops_scheme\"\n  and ops2 :: \"('y,'s2,'more2) set_ops_scheme\"\n  and ops3 :: \"('z,'s3,'more3) set_ops_scheme\"\nbegin"], ["", "definition \"image_filter_cartesian_product f s1 s2 ==\n    s1.iterate s1 (\\<lambda>x res.\n      s2.iterate s2 (\\<lambda>y res.\n        case (f (x, y)) of \n          None \\<Rightarrow> res\n        | Some z \\<Rightarrow> (s3.ins z res)\n      ) res\n    ) (s3.empty ())\""], ["", "lemma image_filter_cartesian_product_alt:\n    \"image_filter_cartesian_product f s1 s2 ==\n     iterate_to_set s3.empty s3.ins (set_iterator_image_filter f (\n       set_iterator_product (s1.iteratei s1) (\\<lambda>_. s2.iteratei s2)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. image_filter_cartesian_product f s1 s2 \\<equiv>\n    iterate_to_set s3.empty s3.ins\n     (set_iterator_image_filter f\n       (set_iterator_product (s1.iteratei s1) (\\<lambda>_. s2.iteratei s2)))", "unfolding image_filter_cartesian_product_def iterate_to_set_alt_def\n      set_iterator_image_filter_def set_iterator_product_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. s1.iterate s1\n     (\\<lambda>x.\n         s2.iterate s2\n          (\\<lambda>y res.\n              case f (x, y) of None \\<Rightarrow> res\n              | Some z \\<Rightarrow> s3.ins z res))\n     (s3.empty ()) \\<equiv>\n    s1.iterate s1\n     (\\<lambda>a.\n         s2.iterate s2\n          (\\<lambda>b \\<sigma>.\n              case f (a, b) of None \\<Rightarrow> \\<sigma>\n              | Some x' \\<Rightarrow> s3.ins x' \\<sigma>))\n     (s3.empty ())", "by simp"], ["", "definition image_filter_cp where\n    \"image_filter_cp f P s1 s2 \\<equiv>\n     image_filter_cartesian_product \n      (\\<lambda>xy. if P xy then Some (f xy) else None) s1 s2\""], ["", "end"], ["", "locale image_filter_cp_loc = image_filter_cp_defs_loc ops1 ops2 ops3 +\n  s1: StdSet ops1 +\n  s2: StdSet ops2 +\n  s3: StdSet ops3\n  for ops1 :: \"('x,'s1,'more1) set_ops_scheme\"\n  and ops2 :: \"('y,'s2,'more2) set_ops_scheme\"\n  and ops3 :: \"('z,'s3,'more3) set_ops_scheme\"\nbegin"], ["", "lemma image_filter_cartesian_product_correct:\n    fixes f :: \"'x \\<times> 'y \\<rightharpoonup> 'z\"\n    assumes I[simp, intro!]: \"s1.invar s1\" \"s2.invar s2\"\n    shows \"s3.\\<alpha> (image_filter_cartesian_product f s1 s2) \n     = { z | x y z. f (x,y) = Some z \\<and> x\\<in>s1.\\<alpha> s1 \\<and> y\\<in>s2.\\<alpha> s2 }\" (is ?T1)\n    \"s3.invar (image_filter_cartesian_product f s1 s2)\" (is ?T2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. s3.\\<alpha> (image_filter_cartesian_product f s1 s2) =\n    {uu_.\n     \\<exists>x y z.\n        uu_ = z \\<and>\n        f (x, y) = Some z \\<and>\n        x \\<in> s1.\\<alpha> s1 \\<and> y \\<in> s2.\\<alpha> s2} &&&\n    s3.invar (image_filter_cartesian_product f s1 s2)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. s3.\\<alpha> (image_filter_cartesian_product f s1 s2) =\n    {uu_.\n     \\<exists>x y z.\n        uu_ = z \\<and>\n        f (x, y) = Some z \\<and>\n        x \\<in> s1.\\<alpha> s1 \\<and> y \\<in> s2.\\<alpha> s2}\n 2. s3.invar (image_filter_cartesian_product f s1 s2)", "from set_iterator_product_correct \n      [OF s1.iteratei_correct[OF I(1)] s2.iteratei_correct[OF I(2)]]"], ["proof (chain)\npicking this:\n  set_iterator\n   (set_iterator_product (s1.iteratei s1) (\\<lambda>a. s2.iteratei s2))\n   (s1.\\<alpha> s1 \\<times> s2.\\<alpha> s2)", "have it_s12: \"set_iterator \n        (set_iterator_product (s1.iteratei s1) (\\<lambda>_. s2.iteratei s2))\n        (s1.\\<alpha> s1 \\<times> s2.\\<alpha> s2)\""], ["proof (prove)\nusing this:\n  set_iterator\n   (set_iterator_product (s1.iteratei s1) (\\<lambda>a. s2.iteratei s2))\n   (s1.\\<alpha> s1 \\<times> s2.\\<alpha> s2)\n\ngoal (1 subgoal):\n 1. set_iterator\n     (set_iterator_product (s1.iteratei s1) (\\<lambda>_. s2.iteratei s2))\n     (s1.\\<alpha> s1 \\<times> s2.\\<alpha> s2)", "by simp"], ["proof (state)\nthis:\n  set_iterator\n   (set_iterator_product (s1.iteratei s1) (\\<lambda>_. s2.iteratei s2))\n   (s1.\\<alpha> s1 \\<times> s2.\\<alpha> s2)\n\ngoal (2 subgoals):\n 1. s3.\\<alpha> (image_filter_cartesian_product f s1 s2) =\n    {uu_.\n     \\<exists>x y z.\n        uu_ = z \\<and>\n        f (x, y) = Some z \\<and>\n        x \\<in> s1.\\<alpha> s1 \\<and> y \\<in> s2.\\<alpha> s2}\n 2. s3.invar (image_filter_cartesian_product f s1 s2)", "have LIS: \n        \"set_ins s3.\\<alpha> s3.invar s3.ins\" \n        \"set_empty s3.\\<alpha> s3.invar s3.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_ins s3.\\<alpha> s3.invar s3.ins &&&\n    set_empty s3.\\<alpha> s3.invar s3.empty", "by unfold_locales"], ["proof (state)\nthis:\n  set_ins s3.\\<alpha> s3.invar s3.ins\n  set_empty s3.\\<alpha> s3.invar s3.empty\n\ngoal (2 subgoals):\n 1. s3.\\<alpha> (image_filter_cartesian_product f s1 s2) =\n    {uu_.\n     \\<exists>x y z.\n        uu_ = z \\<and>\n        f (x, y) = Some z \\<and>\n        x \\<in> s1.\\<alpha> s1 \\<and> y \\<in> s2.\\<alpha> s2}\n 2. s3.invar (image_filter_cartesian_product f s1 s2)", "from iterate_image_filter_to_set_correct[OF LIS it_s12, of f]"], ["proof (chain)\npicking this:\n  s3.\\<alpha>\n   (iterate_to_set s3.empty s3.ins\n     (set_iterator_image_filter f\n       (set_iterator_product (s1.iteratei s1)\n         (\\<lambda>_. s2.iteratei s2)))) =\n  {b. \\<exists>a.\n         a \\<in> s1.\\<alpha> s1 \\<times> s2.\\<alpha> s2 \\<and>\n         f a = Some b} \\<and>\n  s3.invar\n   (iterate_to_set s3.empty s3.ins\n     (set_iterator_image_filter f\n       (set_iterator_product (s1.iteratei s1)\n         (\\<lambda>_. s2.iteratei s2))))", "show ?T1 ?T2"], ["proof (prove)\nusing this:\n  s3.\\<alpha>\n   (iterate_to_set s3.empty s3.ins\n     (set_iterator_image_filter f\n       (set_iterator_product (s1.iteratei s1)\n         (\\<lambda>_. s2.iteratei s2)))) =\n  {b. \\<exists>a.\n         a \\<in> s1.\\<alpha> s1 \\<times> s2.\\<alpha> s2 \\<and>\n         f a = Some b} \\<and>\n  s3.invar\n   (iterate_to_set s3.empty s3.ins\n     (set_iterator_image_filter f\n       (set_iterator_product (s1.iteratei s1)\n         (\\<lambda>_. s2.iteratei s2))))\n\ngoal (1 subgoal):\n 1. s3.\\<alpha> (image_filter_cartesian_product f s1 s2) =\n    {uu_.\n     \\<exists>x y z.\n        uu_ = z \\<and>\n        f (x, y) = Some z \\<and>\n        x \\<in> s1.\\<alpha> s1 \\<and> y \\<in> s2.\\<alpha> s2} &&&\n    s3.invar (image_filter_cartesian_product f s1 s2)", "unfolding image_filter_cartesian_product_alt"], ["proof (prove)\nusing this:\n  s3.\\<alpha>\n   (iterate_to_set s3.empty s3.ins\n     (set_iterator_image_filter f\n       (set_iterator_product (s1.iteratei s1)\n         (\\<lambda>_. s2.iteratei s2)))) =\n  {b. \\<exists>a.\n         a \\<in> s1.\\<alpha> s1 \\<times> s2.\\<alpha> s2 \\<and>\n         f a = Some b} \\<and>\n  s3.invar\n   (iterate_to_set s3.empty s3.ins\n     (set_iterator_image_filter f\n       (set_iterator_product (s1.iteratei s1)\n         (\\<lambda>_. s2.iteratei s2))))\n\ngoal (1 subgoal):\n 1. s3.\\<alpha>\n     (iterate_to_set s3.empty s3.ins\n       (set_iterator_image_filter f\n         (set_iterator_product (s1.iteratei s1)\n           (\\<lambda>_. s2.iteratei s2)))) =\n    {uu_.\n     \\<exists>x y z.\n        uu_ = z \\<and>\n        f (x, y) = Some z \\<and>\n        x \\<in> s1.\\<alpha> s1 \\<and> y \\<in> s2.\\<alpha> s2} &&&\n    s3.invar\n     (iterate_to_set s3.empty s3.ins\n       (set_iterator_image_filter f\n         (set_iterator_product (s1.iteratei s1)\n           (\\<lambda>_. s2.iteratei s2))))", "by auto"], ["proof (state)\nthis:\n  s3.\\<alpha> (image_filter_cartesian_product f s1 s2) =\n  {uu_.\n   \\<exists>x y z.\n      uu_ = z \\<and>\n      f (x, y) = Some z \\<and>\n      x \\<in> s1.\\<alpha> s1 \\<and> y \\<in> s2.\\<alpha> s2}\n  s3.invar (image_filter_cartesian_product f s1 s2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma image_filter_cp_correct:\n    assumes I: \"s1.invar s1\" \"s2.invar s2\"\n    shows \n    \"s3.\\<alpha> (image_filter_cp f P s1 s2) \n     = { f (x, y) | x y. P (x, y) \\<and> x\\<in>s1.\\<alpha> s1 \\<and> y\\<in>s2.\\<alpha> s2 }\" (is ?T1)\n    \"s3.invar (image_filter_cp f P s1 s2)\" (is ?T2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. s3.\\<alpha> (image_filter_cp f P s1 s2) =\n    {f (x, y) |x y.\n     P (x, y) \\<and>\n     x \\<in> s1.\\<alpha> s1 \\<and> y \\<in> s2.\\<alpha> s2} &&&\n    s3.invar (image_filter_cp f P s1 s2)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. s3.\\<alpha> (image_filter_cp f P s1 s2) =\n    {f (x, y) |x y.\n     P (x, y) \\<and> x \\<in> s1.\\<alpha> s1 \\<and> y \\<in> s2.\\<alpha> s2}\n 2. s3.invar (image_filter_cp f P s1 s2)", "from image_filter_cartesian_product_correct [OF I]"], ["proof (chain)\npicking this:\n  s3.\\<alpha> (image_filter_cartesian_product ?f s1 s2) =\n  {uu_.\n   \\<exists>x y z.\n      uu_ = z \\<and>\n      ?f (x, y) = Some z \\<and>\n      x \\<in> s1.\\<alpha> s1 \\<and> y \\<in> s2.\\<alpha> s2}\n  s3.invar (image_filter_cartesian_product ?f s1 s2)", "show \"?T1\" \"?T2\""], ["proof (prove)\nusing this:\n  s3.\\<alpha> (image_filter_cartesian_product ?f s1 s2) =\n  {uu_.\n   \\<exists>x y z.\n      uu_ = z \\<and>\n      ?f (x, y) = Some z \\<and>\n      x \\<in> s1.\\<alpha> s1 \\<and> y \\<in> s2.\\<alpha> s2}\n  s3.invar (image_filter_cartesian_product ?f s1 s2)\n\ngoal (1 subgoal):\n 1. s3.\\<alpha> (image_filter_cp f P s1 s2) =\n    {f (x, y) |x y.\n     P (x, y) \\<and>\n     x \\<in> s1.\\<alpha> s1 \\<and> y \\<in> s2.\\<alpha> s2} &&&\n    s3.invar (image_filter_cp f P s1 s2)", "unfolding image_filter_cp_def"], ["proof (prove)\nusing this:\n  s3.\\<alpha> (image_filter_cartesian_product ?f s1 s2) =\n  {uu_.\n   \\<exists>x y z.\n      uu_ = z \\<and>\n      ?f (x, y) = Some z \\<and>\n      x \\<in> s1.\\<alpha> s1 \\<and> y \\<in> s2.\\<alpha> s2}\n  s3.invar (image_filter_cartesian_product ?f s1 s2)\n\ngoal (1 subgoal):\n 1. s3.\\<alpha>\n     (image_filter_cartesian_product\n       (\\<lambda>xy. if P xy then Some (f xy) else None) s1 s2) =\n    {f (x, y) |x y.\n     P (x, y) \\<and>\n     x \\<in> s1.\\<alpha> s1 \\<and> y \\<in> s2.\\<alpha> s2} &&&\n    s3.invar\n     (image_filter_cartesian_product\n       (\\<lambda>xy. if P xy then Some (f xy) else None) s1 s2)", "by auto"], ["proof (state)\nthis:\n  s3.\\<alpha> (image_filter_cp f P s1 s2) =\n  {f (x, y) |x y.\n   P (x, y) \\<and> x \\<in> s1.\\<alpha> s1 \\<and> y \\<in> s2.\\<alpha> s2}\n  s3.invar (image_filter_cp f P s1 s2)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "locale inj_image_filter_cp_defs_loc =\n  s1: StdSetDefs ops1 +\n  s2: StdSetDefs ops2 +\n  s3: StdSetDefs ops3\n  for ops1 :: \"('x,'s1,'more1) set_ops_scheme\"\n  and ops2 :: \"('y,'s2,'more2) set_ops_scheme\"\n  and ops3 :: \"('z,'s3,'more3) set_ops_scheme\"\nbegin"], ["", "definition \"inj_image_filter_cartesian_product f s1 s2 ==\n    s1.iterate s1 (\\<lambda>x res.\n      s2.iterate s2 (\\<lambda>y res.\n        case (f (x, y)) of \n          None \\<Rightarrow> res\n        | Some z \\<Rightarrow> (s3.ins_dj z res)\n      ) res\n    ) (s3.empty ())\""], ["", "lemma inj_image_filter_cartesian_product_alt:\n    \"inj_image_filter_cartesian_product f s1 s2 ==\n     iterate_to_set s3.empty s3.ins_dj (set_iterator_image_filter f (\n       set_iterator_product (s1.iteratei s1) (\\<lambda>_. s2.iteratei s2)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_image_filter_cartesian_product f s1 s2 \\<equiv>\n    iterate_to_set s3.empty s3.ins_dj\n     (set_iterator_image_filter f\n       (set_iterator_product (s1.iteratei s1) (\\<lambda>_. s2.iteratei s2)))", "unfolding inj_image_filter_cartesian_product_def iterate_to_set_alt_def\n      set_iterator_image_filter_def set_iterator_product_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. s1.iterate s1\n     (\\<lambda>x.\n         s2.iterate s2\n          (\\<lambda>y res.\n              case f (x, y) of None \\<Rightarrow> res\n              | Some z \\<Rightarrow> s3.ins_dj z res))\n     (s3.empty ()) \\<equiv>\n    s1.iterate s1\n     (\\<lambda>a.\n         s2.iterate s2\n          (\\<lambda>b \\<sigma>.\n              case f (a, b) of None \\<Rightarrow> \\<sigma>\n              | Some x' \\<Rightarrow> s3.ins_dj x' \\<sigma>))\n     (s3.empty ())", "by simp"], ["", "definition inj_image_filter_cp where\n    \"inj_image_filter_cp f P s1 s2 \\<equiv>\n     inj_image_filter_cartesian_product \n      (\\<lambda>xy. if P xy then Some (f xy) else None) s1 s2\""], ["", "end"], ["", "locale inj_image_filter_cp_loc = inj_image_filter_cp_defs_loc ops1 ops2 ops3 +\n  s1: StdSet ops1 +\n  s2: StdSet ops2 +\n  s3: StdSet ops3\n  for ops1 :: \"('x,'s1,'more1) set_ops_scheme\"\n  and ops2 :: \"('y,'s2,'more2) set_ops_scheme\"\n  and ops3 :: \"('z,'s3,'more3) set_ops_scheme\"\nbegin"], ["", "lemma inj_image_filter_cartesian_product_correct:\n    fixes f :: \"'x \\<times> 'y \\<rightharpoonup> 'z\"\n    assumes I[simp, intro!]: \"s1.invar s1\" \"s2.invar s2\"\n    assumes INJ: \"inj_on f (s1.\\<alpha> s1 \\<times> s2.\\<alpha> s2 \\<inter> dom f)\"\n    shows \"s3.\\<alpha> (inj_image_filter_cartesian_product f s1 s2) \n     = { z | x y z. f (x,y) = Some z \\<and> x\\<in>s1.\\<alpha> s1 \\<and> y\\<in>s2.\\<alpha> s2 }\" (is ?T1)\n    \"s3.invar (inj_image_filter_cartesian_product f s1 s2)\" (is ?T2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. s3.\\<alpha> (inj_image_filter_cartesian_product f s1 s2) =\n    {uu_.\n     \\<exists>x y z.\n        uu_ = z \\<and>\n        f (x, y) = Some z \\<and>\n        x \\<in> s1.\\<alpha> s1 \\<and> y \\<in> s2.\\<alpha> s2} &&&\n    s3.invar (inj_image_filter_cartesian_product f s1 s2)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. s3.\\<alpha> (inj_image_filter_cartesian_product f s1 s2) =\n    {uu_.\n     \\<exists>x y z.\n        uu_ = z \\<and>\n        f (x, y) = Some z \\<and>\n        x \\<in> s1.\\<alpha> s1 \\<and> y \\<in> s2.\\<alpha> s2}\n 2. s3.invar (inj_image_filter_cartesian_product f s1 s2)", "from set_iterator_product_correct \n      [OF s1.iteratei_correct[OF I(1)] s2.iteratei_correct[OF I(2)]]"], ["proof (chain)\npicking this:\n  set_iterator\n   (set_iterator_product (s1.iteratei s1) (\\<lambda>a. s2.iteratei s2))\n   (s1.\\<alpha> s1 \\<times> s2.\\<alpha> s2)", "have it_s12: \"set_iterator \n        (set_iterator_product (s1.iteratei s1) (\\<lambda>_. s2.iteratei s2))\n        (s1.\\<alpha> s1 \\<times> s2.\\<alpha> s2)\""], ["proof (prove)\nusing this:\n  set_iterator\n   (set_iterator_product (s1.iteratei s1) (\\<lambda>a. s2.iteratei s2))\n   (s1.\\<alpha> s1 \\<times> s2.\\<alpha> s2)\n\ngoal (1 subgoal):\n 1. set_iterator\n     (set_iterator_product (s1.iteratei s1) (\\<lambda>_. s2.iteratei s2))\n     (s1.\\<alpha> s1 \\<times> s2.\\<alpha> s2)", "by simp"], ["proof (state)\nthis:\n  set_iterator\n   (set_iterator_product (s1.iteratei s1) (\\<lambda>_. s2.iteratei s2))\n   (s1.\\<alpha> s1 \\<times> s2.\\<alpha> s2)\n\ngoal (2 subgoals):\n 1. s3.\\<alpha> (inj_image_filter_cartesian_product f s1 s2) =\n    {uu_.\n     \\<exists>x y z.\n        uu_ = z \\<and>\n        f (x, y) = Some z \\<and>\n        x \\<in> s1.\\<alpha> s1 \\<and> y \\<in> s2.\\<alpha> s2}\n 2. s3.invar (inj_image_filter_cartesian_product f s1 s2)", "have LIS: \n        \"set_ins_dj s3.\\<alpha> s3.invar s3.ins_dj\" \n        \"set_empty s3.\\<alpha> s3.invar s3.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_ins_dj s3.\\<alpha> s3.invar s3.ins_dj &&&\n    set_empty s3.\\<alpha> s3.invar s3.empty", "by unfold_locales"], ["proof (state)\nthis:\n  set_ins_dj s3.\\<alpha> s3.invar s3.ins_dj\n  set_empty s3.\\<alpha> s3.invar s3.empty\n\ngoal (2 subgoals):\n 1. s3.\\<alpha> (inj_image_filter_cartesian_product f s1 s2) =\n    {uu_.\n     \\<exists>x y z.\n        uu_ = z \\<and>\n        f (x, y) = Some z \\<and>\n        x \\<in> s1.\\<alpha> s1 \\<and> y \\<in> s2.\\<alpha> s2}\n 2. s3.invar (inj_image_filter_cartesian_product f s1 s2)", "from iterate_inj_image_filter_to_set_correct[OF LIS it_s12 INJ]"], ["proof (chain)\npicking this:\n  s3.\\<alpha>\n   (iterate_to_set s3.empty s3.ins_dj\n     (set_iterator_image_filter f\n       (set_iterator_product (s1.iteratei s1)\n         (\\<lambda>_. s2.iteratei s2)))) =\n  {b. \\<exists>a.\n         a \\<in> s1.\\<alpha> s1 \\<times> s2.\\<alpha> s2 \\<and>\n         f a = Some b} \\<and>\n  s3.invar\n   (iterate_to_set s3.empty s3.ins_dj\n     (set_iterator_image_filter f\n       (set_iterator_product (s1.iteratei s1)\n         (\\<lambda>_. s2.iteratei s2))))", "show ?T1 ?T2"], ["proof (prove)\nusing this:\n  s3.\\<alpha>\n   (iterate_to_set s3.empty s3.ins_dj\n     (set_iterator_image_filter f\n       (set_iterator_product (s1.iteratei s1)\n         (\\<lambda>_. s2.iteratei s2)))) =\n  {b. \\<exists>a.\n         a \\<in> s1.\\<alpha> s1 \\<times> s2.\\<alpha> s2 \\<and>\n         f a = Some b} \\<and>\n  s3.invar\n   (iterate_to_set s3.empty s3.ins_dj\n     (set_iterator_image_filter f\n       (set_iterator_product (s1.iteratei s1)\n         (\\<lambda>_. s2.iteratei s2))))\n\ngoal (1 subgoal):\n 1. s3.\\<alpha> (inj_image_filter_cartesian_product f s1 s2) =\n    {uu_.\n     \\<exists>x y z.\n        uu_ = z \\<and>\n        f (x, y) = Some z \\<and>\n        x \\<in> s1.\\<alpha> s1 \\<and> y \\<in> s2.\\<alpha> s2} &&&\n    s3.invar (inj_image_filter_cartesian_product f s1 s2)", "unfolding inj_image_filter_cartesian_product_alt"], ["proof (prove)\nusing this:\n  s3.\\<alpha>\n   (iterate_to_set s3.empty s3.ins_dj\n     (set_iterator_image_filter f\n       (set_iterator_product (s1.iteratei s1)\n         (\\<lambda>_. s2.iteratei s2)))) =\n  {b. \\<exists>a.\n         a \\<in> s1.\\<alpha> s1 \\<times> s2.\\<alpha> s2 \\<and>\n         f a = Some b} \\<and>\n  s3.invar\n   (iterate_to_set s3.empty s3.ins_dj\n     (set_iterator_image_filter f\n       (set_iterator_product (s1.iteratei s1)\n         (\\<lambda>_. s2.iteratei s2))))\n\ngoal (1 subgoal):\n 1. s3.\\<alpha>\n     (iterate_to_set s3.empty s3.ins_dj\n       (set_iterator_image_filter f\n         (set_iterator_product (s1.iteratei s1)\n           (\\<lambda>_. s2.iteratei s2)))) =\n    {uu_.\n     \\<exists>x y z.\n        uu_ = z \\<and>\n        f (x, y) = Some z \\<and>\n        x \\<in> s1.\\<alpha> s1 \\<and> y \\<in> s2.\\<alpha> s2} &&&\n    s3.invar\n     (iterate_to_set s3.empty s3.ins_dj\n       (set_iterator_image_filter f\n         (set_iterator_product (s1.iteratei s1)\n           (\\<lambda>_. s2.iteratei s2))))", "by auto"], ["proof (state)\nthis:\n  s3.\\<alpha> (inj_image_filter_cartesian_product f s1 s2) =\n  {uu_.\n   \\<exists>x y z.\n      uu_ = z \\<and>\n      f (x, y) = Some z \\<and>\n      x \\<in> s1.\\<alpha> s1 \\<and> y \\<in> s2.\\<alpha> s2}\n  s3.invar (inj_image_filter_cartesian_product f s1 s2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inj_image_filter_cp_correct:\n    assumes I: \"s1.invar s1\" \"s2.invar s2\"\n    assumes INJ: \"inj_on f {x\\<in>s1.\\<alpha> s1 \\<times> s2.\\<alpha> s2. P x}\"\n    shows \n    \"s3.\\<alpha> (inj_image_filter_cp f P s1 s2) \n     = { f (x, y) | x y. P (x, y) \\<and> x\\<in>s1.\\<alpha> s1 \\<and> y\\<in>s2.\\<alpha> s2 }\" (is ?T1)\n    \"s3.invar (inj_image_filter_cp f P s1 s2)\" (is ?T2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. s3.\\<alpha> (inj_image_filter_cp f P s1 s2) =\n    {f (x, y) |x y.\n     P (x, y) \\<and>\n     x \\<in> s1.\\<alpha> s1 \\<and> y \\<in> s2.\\<alpha> s2} &&&\n    s3.invar (inj_image_filter_cp f P s1 s2)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. s3.\\<alpha> (inj_image_filter_cp f P s1 s2) =\n    {f (x, y) |x y.\n     P (x, y) \\<and> x \\<in> s1.\\<alpha> s1 \\<and> y \\<in> s2.\\<alpha> s2}\n 2. s3.invar (inj_image_filter_cp f P s1 s2)", "let ?f = \"\\<lambda>xy. if P xy then Some (f xy) else None\""], ["proof (state)\ngoal (2 subgoals):\n 1. s3.\\<alpha> (inj_image_filter_cp f P s1 s2) =\n    {f (x, y) |x y.\n     P (x, y) \\<and> x \\<in> s1.\\<alpha> s1 \\<and> y \\<in> s2.\\<alpha> s2}\n 2. s3.invar (inj_image_filter_cp f P s1 s2)", "from INJ"], ["proof (chain)\npicking this:\n  inj_on f {x \\<in> s1.\\<alpha> s1 \\<times> s2.\\<alpha> s2. P x}", "have INJ': \"inj_on ?f (s1.\\<alpha> s1 \\<times> s2.\\<alpha> s2 \\<inter> dom ?f)\""], ["proof (prove)\nusing this:\n  inj_on f {x \\<in> s1.\\<alpha> s1 \\<times> s2.\\<alpha> s2. P x}\n\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>xy. if P xy then Some (f xy) else None)\n     (s1.\\<alpha> s1 \\<times> s2.\\<alpha> s2 \\<inter>\n      dom (\\<lambda>xy. if P xy then Some (f xy) else None))", "by (force intro!: inj_onI dest: inj_onD split: if_split_asm)"], ["proof (state)\nthis:\n  inj_on (\\<lambda>xy. if P xy then Some (f xy) else None)\n   (s1.\\<alpha> s1 \\<times> s2.\\<alpha> s2 \\<inter>\n    dom (\\<lambda>xy. if P xy then Some (f xy) else None))\n\ngoal (2 subgoals):\n 1. s3.\\<alpha> (inj_image_filter_cp f P s1 s2) =\n    {f (x, y) |x y.\n     P (x, y) \\<and> x \\<in> s1.\\<alpha> s1 \\<and> y \\<in> s2.\\<alpha> s2}\n 2. s3.invar (inj_image_filter_cp f P s1 s2)", "from inj_image_filter_cartesian_product_correct [OF I INJ']"], ["proof (chain)\npicking this:\n  s3.\\<alpha>\n   (inj_image_filter_cartesian_product\n     (\\<lambda>xy. if P xy then Some (f xy) else None) s1 s2) =\n  {uu_.\n   \\<exists>x y z.\n      uu_ = z \\<and>\n      (if P (x, y) then Some (f (x, y)) else None) = Some z \\<and>\n      x \\<in> s1.\\<alpha> s1 \\<and> y \\<in> s2.\\<alpha> s2}\n  s3.invar\n   (inj_image_filter_cartesian_product\n     (\\<lambda>xy. if P xy then Some (f xy) else None) s1 s2)", "show \"?T1\" \"?T2\""], ["proof (prove)\nusing this:\n  s3.\\<alpha>\n   (inj_image_filter_cartesian_product\n     (\\<lambda>xy. if P xy then Some (f xy) else None) s1 s2) =\n  {uu_.\n   \\<exists>x y z.\n      uu_ = z \\<and>\n      (if P (x, y) then Some (f (x, y)) else None) = Some z \\<and>\n      x \\<in> s1.\\<alpha> s1 \\<and> y \\<in> s2.\\<alpha> s2}\n  s3.invar\n   (inj_image_filter_cartesian_product\n     (\\<lambda>xy. if P xy then Some (f xy) else None) s1 s2)\n\ngoal (1 subgoal):\n 1. s3.\\<alpha> (inj_image_filter_cp f P s1 s2) =\n    {f (x, y) |x y.\n     P (x, y) \\<and>\n     x \\<in> s1.\\<alpha> s1 \\<and> y \\<in> s2.\\<alpha> s2} &&&\n    s3.invar (inj_image_filter_cp f P s1 s2)", "unfolding inj_image_filter_cp_def"], ["proof (prove)\nusing this:\n  s3.\\<alpha>\n   (inj_image_filter_cartesian_product\n     (\\<lambda>xy. if P xy then Some (f xy) else None) s1 s2) =\n  {uu_.\n   \\<exists>x y z.\n      uu_ = z \\<and>\n      (if P (x, y) then Some (f (x, y)) else None) = Some z \\<and>\n      x \\<in> s1.\\<alpha> s1 \\<and> y \\<in> s2.\\<alpha> s2}\n  s3.invar\n   (inj_image_filter_cartesian_product\n     (\\<lambda>xy. if P xy then Some (f xy) else None) s1 s2)\n\ngoal (1 subgoal):\n 1. s3.\\<alpha>\n     (inj_image_filter_cartesian_product\n       (\\<lambda>xy. if P xy then Some (f xy) else None) s1 s2) =\n    {f (x, y) |x y.\n     P (x, y) \\<and>\n     x \\<in> s1.\\<alpha> s1 \\<and> y \\<in> s2.\\<alpha> s2} &&&\n    s3.invar\n     (inj_image_filter_cartesian_product\n       (\\<lambda>xy. if P xy then Some (f xy) else None) s1 s2)", "by auto"], ["proof (state)\nthis:\n  s3.\\<alpha> (inj_image_filter_cp f P s1 s2) =\n  {f (x, y) |x y.\n   P (x, y) \\<and> x \\<in> s1.\\<alpha> s1 \\<and> y \\<in> s2.\\<alpha> s2}\n  s3.invar (inj_image_filter_cp f P s1 s2)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsubsection \"Cartesian Product\""], ["", "locale cart_defs_loc = inj_image_filter_cp_defs_loc ops1 ops2 ops3\n  for ops1 :: \"('x,'s1,'more1) set_ops_scheme\"\n  and ops2 :: \"('y,'s2,'more2) set_ops_scheme\"\n  and ops3 :: \"('x\\<times>'y,'s3,'more3) set_ops_scheme\"\nbegin"], ["", "definition \"cart s1 s2 \\<equiv>\n    s1.iterate s1 \n      (\\<lambda>x. s2.iterate s2 (\\<lambda>y res. s3.ins_dj (x,y) res)) \n      (s3.empty ())\""], ["", "lemma cart_alt: \"cart s1 s2 == \n    inj_image_filter_cartesian_product Some s1 s2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cart s1 s2 \\<equiv> inj_image_filter_cartesian_product Some s1 s2", "unfolding cart_def inj_image_filter_cartesian_product_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. s1.iterate s1 (\\<lambda>x. s2.iterate s2 (\\<lambda>y. s3.ins_dj (x, y)))\n     (s3.empty ()) \\<equiv>\n    s1.iterate s1\n     (\\<lambda>x.\n         s2.iterate s2\n          (\\<lambda>y res.\n              case Some (x, y) of None \\<Rightarrow> res\n              | Some z \\<Rightarrow> s3.ins_dj z res))\n     (s3.empty ())", "by simp"], ["", "end"], ["", "locale cart_loc = cart_defs_loc ops1 ops2 ops3 \n  + inj_image_filter_cp_loc ops1 ops2 ops3\n  for ops1 :: \"('x,'s1,'more1) set_ops_scheme\"\n  and ops2 :: \"('y,'s2,'more2) set_ops_scheme\"\n  and ops3 :: \"('x\\<times>'y,'s3,'more3) set_ops_scheme\"\nbegin"], ["", "lemma cart_correct:\n    assumes I[simp, intro!]: \"s1.invar s1\" \"s2.invar s2\"\n    shows \"s3.\\<alpha> (cart s1 s2) \n           = s1.\\<alpha> s1 \\<times> s2.\\<alpha> s2\" (is ?T1)\n    \"s3.invar (cart s1 s2)\" (is ?T2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. s3.\\<alpha> (cart s1 s2) = s1.\\<alpha> s1 \\<times> s2.\\<alpha> s2 &&&\n    s3.invar (cart s1 s2)", "unfolding cart_alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. s3.\\<alpha> (inj_image_filter_cartesian_product Some s1 s2) =\n    s1.\\<alpha> s1 \\<times> s2.\\<alpha> s2 &&&\n    s3.invar (inj_image_filter_cartesian_product Some s1 s2)", "by (auto simp add: \n      inj_image_filter_cartesian_product_correct[OF I, where f=Some])"], ["", "end"], ["", "subsection \\<open>Generic Algorithms outside basic-set\\<close>"], ["", "text \\<open>\n  In this section, we present some generic algorithms that are not\n  formulated in terms of basic-set. They are useful for setting up \n  some data structures.\n\\<close>"], ["", "subsection \\<open>Image (by image-filter)\\<close>"], ["", "definition \"iflt_image iflt f s == iflt (\\<lambda>x. Some (f x)) s\""], ["", "lemma iflt_image_correct:\n  assumes \"set_image_filter \\<alpha>1 invar1 \\<alpha>2 invar2 iflt\"\n  shows \"set_image \\<alpha>1 invar1 \\<alpha>2 invar2 (iflt_image iflt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_image \\<alpha>1 invar1 \\<alpha>2 invar2 (iflt_image iflt)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set_image \\<alpha>1 invar1 \\<alpha>2 invar2 (iflt_image iflt)", "interpret set_image_filter \\<alpha>1 invar1 \\<alpha>2 invar2 iflt"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_image_filter \\<alpha>1 invar1 \\<alpha>2 invar2 iflt", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. set_image \\<alpha>1 invar1 \\<alpha>2 invar2 (iflt_image iflt)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_image \\<alpha>1 invar1 \\<alpha>2 invar2 (iflt_image iflt)", "apply (unfold_locales)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s f.\n       invar1 s \\<Longrightarrow>\n       \\<alpha>2 (iflt_image iflt f s) = f ` \\<alpha>1 s\n 2. \\<And>s f. invar1 s \\<Longrightarrow> invar2 (iflt_image iflt f s)", "apply (unfold iflt_image_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s f.\n       invar1 s \\<Longrightarrow>\n       \\<alpha>2 (iflt (\\<lambda>x. Some (f x)) s) = f ` \\<alpha>1 s\n 2. \\<And>s f.\n       invar1 s \\<Longrightarrow> invar2 (iflt (\\<lambda>x. Some (f x)) s)", "apply (auto simp add: image_filter_correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  set_image \\<alpha>1 invar1 \\<alpha>2 invar2 (iflt_image iflt)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open>Injective Image-Filter (by image-filter)\\<close>"], ["", "definition [code_unfold]: \"iflt_inj_image = iflt_image\""], ["", "lemma iflt_inj_image_correct:\n  assumes \"set_inj_image_filter \\<alpha>1 invar1 \\<alpha>2 invar2 iflt\"\n  shows \"set_inj_image \\<alpha>1 invar1 \\<alpha>2 invar2 (iflt_inj_image iflt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_inj_image \\<alpha>1 invar1 \\<alpha>2 invar2 (iflt_inj_image iflt)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set_inj_image \\<alpha>1 invar1 \\<alpha>2 invar2 (iflt_inj_image iflt)", "interpret set_inj_image_filter \\<alpha>1 invar1 \\<alpha>2 invar2 iflt"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_inj_image_filter \\<alpha>1 invar1 \\<alpha>2 invar2 iflt", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. set_inj_image \\<alpha>1 invar1 \\<alpha>2 invar2 (iflt_inj_image iflt)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_inj_image \\<alpha>1 invar1 \\<alpha>2 invar2 (iflt_inj_image iflt)", "apply (unfold_locales)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s f.\n       \\<lbrakk>invar1 s; inj_on f (\\<alpha>1 s)\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>2 (iflt_inj_image iflt f s) =\n                         f ` \\<alpha>1 s\n 2. \\<And>s f.\n       \\<lbrakk>invar1 s; inj_on f (\\<alpha>1 s)\\<rbrakk>\n       \\<Longrightarrow> invar2 (iflt_inj_image iflt f s)", "apply (unfold iflt_image_def iflt_inj_image_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s f.\n       \\<lbrakk>invar1 s; inj_on f (\\<alpha>1 s)\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>2 (iflt (\\<lambda>x. Some (f x)) s) =\n                         f ` \\<alpha>1 s\n 2. \\<And>s f.\n       \\<lbrakk>invar1 s; inj_on f (\\<alpha>1 s)\\<rbrakk>\n       \\<Longrightarrow> invar2 (iflt (\\<lambda>x. Some (f x)) s)", "apply (subst inj_image_filter_correct)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s f.\n       \\<lbrakk>invar1 s; inj_on f (\\<alpha>1 s)\\<rbrakk>\n       \\<Longrightarrow> invar1 s\n 2. \\<And>s f.\n       \\<lbrakk>invar1 s; inj_on f (\\<alpha>1 s)\\<rbrakk>\n       \\<Longrightarrow> inj_on (\\<lambda>x. Some (f x))\n                          (\\<alpha>1 s \\<inter>\n                           dom (\\<lambda>x. Some (f x)))\n 3. \\<And>s f.\n       \\<lbrakk>invar1 s; inj_on f (\\<alpha>1 s)\\<rbrakk>\n       \\<Longrightarrow> {b. \\<exists>a\\<in>\\<alpha>1 s.\n                                Some (f a) = Some b} =\n                         f ` \\<alpha>1 s\n 4. \\<And>s f.\n       \\<lbrakk>invar1 s; inj_on f (\\<alpha>1 s)\\<rbrakk>\n       \\<Longrightarrow> invar2 (iflt (\\<lambda>x. Some (f x)) s)", "apply (auto simp add: dom_const intro: inj_onI dest: inj_onD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s f.\n       \\<lbrakk>invar1 s; inj_on f (\\<alpha>1 s)\\<rbrakk>\n       \\<Longrightarrow> invar2 (iflt (\\<lambda>x. Some (f x)) s)", "apply (subst inj_image_filter_correct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s f.\n       \\<lbrakk>invar1 s; inj_on f (\\<alpha>1 s)\\<rbrakk>\n       \\<Longrightarrow> invar1 s\n 2. \\<And>s f.\n       \\<lbrakk>invar1 s; inj_on f (\\<alpha>1 s)\\<rbrakk>\n       \\<Longrightarrow> inj_on (\\<lambda>x. Some (f x))\n                          (\\<alpha>1 s \\<inter>\n                           dom (\\<lambda>x. Some (f x)))\n 3. \\<And>s f.\n       \\<lbrakk>invar1 s; inj_on f (\\<alpha>1 s)\\<rbrakk>\n       \\<Longrightarrow> True", "apply (auto simp add: dom_const intro: inj_onI dest: inj_onD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  set_inj_image \\<alpha>1 invar1 \\<alpha>2 invar2 (iflt_inj_image iflt)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open>Filter (by image-filter)\\<close>"], ["", "definition \"iflt_filter iflt P s == iflt (\\<lambda>x. if P x then Some x else None) s\""], ["", "lemma iflt_filter_correct:\n  fixes \\<alpha>1 :: \"'s1 \\<Rightarrow> 'a set\"\n  fixes \\<alpha>2 :: \"'s2 \\<Rightarrow> 'a set\"\n  assumes \"set_inj_image_filter \\<alpha>1 invar1 \\<alpha>2 invar2 iflt\"\n  shows \"set_filter \\<alpha>1 invar1 \\<alpha>2 invar2 (iflt_filter iflt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_filter \\<alpha>1 invar1 \\<alpha>2 invar2 (iflt_filter iflt)", "proof (rule set_filter.intro)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s P.\n       invar1 s \\<Longrightarrow>\n       \\<alpha>2 (iflt_filter iflt P s) = {e \\<in> \\<alpha>1 s. P e}\n 2. \\<And>s P. invar1 s \\<Longrightarrow> invar2 (iflt_filter iflt P s)", "fix s P"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s P.\n       invar1 s \\<Longrightarrow>\n       \\<alpha>2 (iflt_filter iflt P s) = {e \\<in> \\<alpha>1 s. P e}\n 2. \\<And>s P. invar1 s \\<Longrightarrow> invar2 (iflt_filter iflt P s)", "assume invar_s: \"invar1 s\""], ["proof (state)\nthis:\n  invar1 s\n\ngoal (2 subgoals):\n 1. \\<And>s P.\n       invar1 s \\<Longrightarrow>\n       \\<alpha>2 (iflt_filter iflt P s) = {e \\<in> \\<alpha>1 s. P e}\n 2. \\<And>s P. invar1 s \\<Longrightarrow> invar2 (iflt_filter iflt P s)", "interpret S: set_inj_image_filter \\<alpha>1 invar1 \\<alpha>2 invar2 iflt"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_inj_image_filter \\<alpha>1 invar1 \\<alpha>2 invar2 iflt", "by fact"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s P.\n       invar1 s \\<Longrightarrow>\n       \\<alpha>2 (iflt_filter iflt P s) = {e \\<in> \\<alpha>1 s. P e}\n 2. \\<And>s P. invar1 s \\<Longrightarrow> invar2 (iflt_filter iflt P s)", "let ?f' = \"\\<lambda>x::'a. if P x then Some x else None\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s P.\n       invar1 s \\<Longrightarrow>\n       \\<alpha>2 (iflt_filter iflt P s) = {e \\<in> \\<alpha>1 s. P e}\n 2. \\<And>s P. invar1 s \\<Longrightarrow> invar2 (iflt_filter iflt P s)", "have inj_f': \"inj_on ?f' (\\<alpha>1 s \\<inter> dom ?f')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>x. if P x then Some x else None)\n     (\\<alpha>1 s \\<inter> dom (\\<lambda>x. if P x then Some x else None))", "by (simp add: inj_on_def Ball_def domIff)"], ["proof (state)\nthis:\n  inj_on (\\<lambda>x. if P x then Some x else None)\n   (\\<alpha>1 s \\<inter> dom (\\<lambda>x. if P x then Some x else None))\n\ngoal (2 subgoals):\n 1. \\<And>s P.\n       invar1 s \\<Longrightarrow>\n       \\<alpha>2 (iflt_filter iflt P s) = {e \\<in> \\<alpha>1 s. P e}\n 2. \\<And>s P. invar1 s \\<Longrightarrow> invar2 (iflt_filter iflt P s)", "note correct' = S.inj_image_filter_correct [OF invar_s inj_f',\n    folded iflt_filter_def]"], ["proof (state)\nthis:\n  \\<alpha>2 (iflt_filter iflt P s) =\n  {b. \\<exists>a\\<in>\\<alpha>1 s. (if P a then Some a else None) = Some b}\n  invar2 (iflt_filter iflt P s)\n\ngoal (2 subgoals):\n 1. \\<And>s P.\n       invar1 s \\<Longrightarrow>\n       \\<alpha>2 (iflt_filter iflt P s) = {e \\<in> \\<alpha>1 s. P e}\n 2. \\<And>s P. invar1 s \\<Longrightarrow> invar2 (iflt_filter iflt P s)", "show \"invar2 (iflt_filter iflt P s)\"\n       \"\\<alpha>2 (iflt_filter iflt P s) = {e \\<in> \\<alpha>1 s. P e}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar2 (iflt_filter iflt P s) &&&\n    \\<alpha>2 (iflt_filter iflt P s) = {e \\<in> \\<alpha>1 s. P e}", "by (auto simp add: correct')"], ["proof (state)\nthis:\n  invar2 (iflt_filter iflt P s)\n  \\<alpha>2 (iflt_filter iflt P s) = {e \\<in> \\<alpha>1 s. P e}\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}