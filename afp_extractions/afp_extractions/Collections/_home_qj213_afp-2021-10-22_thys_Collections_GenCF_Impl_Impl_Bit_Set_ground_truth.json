{"file_name": "/home/qj213/afp-2021-10-22/thys/Collections/GenCF/Impl/Impl_Bit_Set.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Collections", "problem_names": ["lemma bs_empty_correct: \"bs_\\<alpha> (bs_empty ()) = {}\"", "lemma bs_isEmpty_correct: \"bs_isEmpty s \\<longleftrightarrow> bs_\\<alpha> s = {}\"", "lemma bs_insert_correct: \"bs_\\<alpha> (bs_insert i s) = insert i (bs_\\<alpha> s)\"", "lemma bs_delete_correct: \"bs_\\<alpha> (bs_delete i s) = (bs_\\<alpha> s) - {i}\"", "lemma bs_mem_correct: \"bs_mem i s \\<longleftrightarrow> i\\<in>bs_\\<alpha> s\"", "lemma bs_eq_correct: \"bs_eq s1 s2 \\<longleftrightarrow> bs_\\<alpha> s1 = bs_\\<alpha> s2\"", "lemma bs_subset_eq_correct: \"bs_subset_eq s1 s2 \\<longleftrightarrow> bs_\\<alpha> s1 \\<subseteq> bs_\\<alpha> s2\"", "lemma bs_disjoint_correct: \"bs_disjoint s1 s2 \\<longleftrightarrow> bs_\\<alpha> s1 \\<inter> bs_\\<alpha> s2 = {}\"", "lemma bs_union_correct: \"bs_\\<alpha> (bs_union s1 s2) = bs_\\<alpha> s1 \\<union> bs_\\<alpha> s2\"", "lemma bs_inter_correct: \"bs_\\<alpha> (bs_inter s1 s2) = bs_\\<alpha> s1 \\<inter> bs_\\<alpha> s2\"", "lemma bs_diff_correct: \"bs_\\<alpha> (bs_diff s1 s2) = bs_\\<alpha> s1 - bs_\\<alpha> s2\"", "lemma bs_UNIV_correct: \"bs_\\<alpha> (bs_UNIV ()) = UNIV\"", "lemma bs_complement_correct: \"bs_\\<alpha> (bs_complement s) = - bs_\\<alpha> s\"", "lemmas bs_correct[simp] = \n    bs_empty_correct\n    bs_isEmpty_correct\n    bs_insert_correct\n    bs_delete_correct\n    bs_mem_correct\n    bs_eq_correct\n    bs_subset_eq_correct\n    bs_disjoint_correct\n    bs_union_correct\n    bs_inter_correct\n    bs_diff_correct\n    bs_UNIV_correct\n    bs_complement_correct", "lemma bs_set_rel_def: \n  \"\\<langle>nat_rel\\<rangle>bs_set_rel \\<equiv> br bs_\\<alpha> (\\<lambda>_. True)\"", "lemmas [autoref_rel_intf] = REL_INTFI[of \"bs_set_rel\" i_set]", "lemma bs_set_rel_sv[relator_props]: \"single_valued (\\<langle>nat_rel\\<rangle>bs_set_rel)\"", "lemma [autoref_rules]: \"(bs_empty (),{})\\<in>\\<langle>nat_rel\\<rangle>bs_set_rel\"", "lemma [autoref_rules]: \"(bs_UNIV (),UNIV)\\<in>\\<langle>nat_rel\\<rangle>bs_set_rel\"", "lemma [autoref_rules]: \"(bs_isEmpty,op_set_isEmpty)\\<in>\\<langle>nat_rel\\<rangle>bs_set_rel \\<rightarrow> bool_rel\"", "lemma [autoref_rules]: \"(bs_insert,insert)\\<in>nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>bs_set_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>bs_set_rel\"", "lemma [autoref_rules]: \"(bs_delete,op_set_delete)\\<in>nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>bs_set_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>bs_set_rel\"", "lemma [autoref_rules]: \"(bs_mem,(\\<in>))\\<in>nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>bs_set_rel \\<rightarrow> bool_rel\"", "lemma [autoref_rules]: \"(bs_eq,(=))\\<in>\\<langle>nat_rel\\<rangle>bs_set_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>bs_set_rel \\<rightarrow> bool_rel\"", "lemma [autoref_rules]: \"(bs_subset_eq,(\\<subseteq>))\\<in>\\<langle>nat_rel\\<rangle>bs_set_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>bs_set_rel \\<rightarrow> bool_rel\"", "lemma [autoref_rules]: \"(bs_union,(\\<union>))\\<in>\\<langle>nat_rel\\<rangle>bs_set_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>bs_set_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>bs_set_rel\"", "lemma [autoref_rules]: \"(bs_inter,(\\<inter>))\\<in>\\<langle>nat_rel\\<rangle>bs_set_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>bs_set_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>bs_set_rel\"", "lemma [autoref_rules]: \"(bs_diff,(-))\\<in>\\<langle>nat_rel\\<rangle>bs_set_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>bs_set_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>bs_set_rel\"", "lemma [autoref_rules]: \"(bs_complement,uminus)\\<in>\\<langle>nat_rel\\<rangle>bs_set_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>bs_set_rel\"", "lemma [autoref_rules]: \"(bs_disjoint,op_set_disjoint)\\<in>\\<langle>nat_rel\\<rangle>bs_set_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>bs_set_rel \\<rightarrow> bool_rel\""], "translations": [["", "lemma bs_empty_correct: \"bs_\\<alpha> (bs_empty ()) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bs_\\<alpha> (bs_empty ()) = {}", "unfolding bs_\\<alpha>_def bs_empty_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {n. bit 0 n} = {}", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. {n. bit 0 n} = {}", "by auto"], ["", "definition bs_isEmpty :: \"bitset \\<Rightarrow> bool\" where \"bs_isEmpty s \\<equiv> s=0\""], ["", "lemma bs_isEmpty_correct: \"bs_isEmpty s \\<longleftrightarrow> bs_\\<alpha> s = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bs_isEmpty s = (bs_\\<alpha> s = {})", "unfolding bs_isEmpty_def bs_\\<alpha>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (s = 0) = ({n. bit s n} = {})", "by transfer (auto simp: bin_eq_iff)"], ["", "term set_bit"], ["", "definition bs_insert :: \"nat \\<Rightarrow> bitset \\<Rightarrow> bitset\" where\n    \"bs_insert i s \\<equiv> set_bit s i True\""], ["", "lemma bs_insert_correct: \"bs_\\<alpha> (bs_insert i s) = insert i (bs_\\<alpha> s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bs_\\<alpha> (bs_insert i s) = insert i (bs_\\<alpha> s)", "unfolding bs_\\<alpha>_def bs_insert_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {n. bit (set_bit_class.set_bit s i True) n} = insert i {n. bit s n}", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s i.\n       Collect (bit (set_bit_class.set_bit s i True)) =\n       insert i (Collect (bit s))", "apply auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s i x.\n       \\<lbrakk>bit (set_bit_class.set_bit s i True) x;\n        x \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> bit s x\n 2. \\<And>s i. bit (set_bit_class.set_bit s i True) i\n 3. \\<And>s i x.\n       bit s x \\<Longrightarrow> bit (set_bit_class.set_bit s i True) x", "apply (metis bin_nth_sc_gen bin_set_conv_OR int_set_bit_True_conv_OR)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s i. bit (set_bit_class.set_bit s i True) i\n 2. \\<And>s i x.\n       bit s x \\<Longrightarrow> bit (set_bit_class.set_bit s i True) x", "apply (metis bin_nth_sc_gen bin_set_conv_OR int_set_bit_True_conv_OR)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s i x.\n       bit s x \\<Longrightarrow> bit (set_bit_class.set_bit s i True) x", "by (metis bin_nth_sc_gen bin_set_conv_OR int_set_bit_True_conv_OR)"], ["", "definition bs_delete :: \"nat \\<Rightarrow> bitset \\<Rightarrow> bitset\" where\n    \"bs_delete i s \\<equiv> set_bit s i False\""], ["", "lemma bs_delete_correct: \"bs_\\<alpha> (bs_delete i s) = (bs_\\<alpha> s) - {i}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bs_\\<alpha> (bs_delete i s) = bs_\\<alpha> s - {i}", "unfolding bs_\\<alpha>_def bs_delete_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {n. bit (set_bit_class.set_bit s i False) n} = {n. bit s n} - {i}", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s i.\n       Collect (bit (set_bit_class.set_bit s i False)) =\n       Collect (bit s) - {i}", "apply auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s i x.\n       bit (set_bit_class.set_bit s i False) x \\<Longrightarrow> bit s x\n 2. \\<And>s i.\n       bit (set_bit_class.set_bit s i False) i \\<Longrightarrow> False\n 3. \\<And>s i x.\n       \\<lbrakk>bit s x; x \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> bit (set_bit_class.set_bit s i False) x", "apply (metis bin_nth_ops(1) int_set_bit_False_conv_NAND)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s i.\n       bit (set_bit_class.set_bit s i False) i \\<Longrightarrow> False\n 2. \\<And>s i x.\n       \\<lbrakk>bit s x; x \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> bit (set_bit_class.set_bit s i False) x", "apply (metis (full_types) bin_nth_sc set_bit_int_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s i x.\n       \\<lbrakk>bit s x; x \\<noteq> i\\<rbrakk>\n       \\<Longrightarrow> bit (set_bit_class.set_bit s i False) x", "by (metis (full_types) bin_nth_sc_gen set_bit_int_def)"], ["", "definition bs_mem :: \"nat \\<Rightarrow> bitset \\<Rightarrow> bool\" where\n    \"bs_mem i s \\<equiv> bit s i\""], ["", "lemma bs_mem_correct: \"bs_mem i s \\<longleftrightarrow> i\\<in>bs_\\<alpha> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bs_mem i s = (i \\<in> bs_\\<alpha> s)", "unfolding bs_mem_def bs_\\<alpha>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. bit s i = (i \\<in> {n. bit s n})", "by transfer auto"], ["", "definition bs_eq :: \"bitset \\<Rightarrow> bitset \\<Rightarrow> bool\" where \n    \"bs_eq s1 s2 \\<equiv> (s1=s2)\""], ["", "lemma bs_eq_correct: \"bs_eq s1 s2 \\<longleftrightarrow> bs_\\<alpha> s1 = bs_\\<alpha> s2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bs_eq s1 s2 = (bs_\\<alpha> s1 = bs_\\<alpha> s2)", "unfolding bs_eq_def bs_\\<alpha>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (s1 = s2) = ({n. bit s1 n} = {n. bit s2 n})", "including integer.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. (s1 = s2) = ({n. bit s1 n} = {n. bit s2 n})", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s1 s2. (s1 = s2) = (Collect (bit s1) = Collect (bit s2))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s1 s2.\n       Collect (bit s1) = Collect (bit s2) \\<Longrightarrow> s1 = s2", "by (metis bin_eqI mem_Collect_eq)"], ["", "definition bs_subset_eq :: \"bitset \\<Rightarrow> bitset \\<Rightarrow> bool\" where\n    \"bs_subset_eq s1 s2 \\<equiv> s1 AND NOT s2 = 0\""], ["", "lemma bs_subset_eq_correct: \"bs_subset_eq s1 s2 \\<longleftrightarrow> bs_\\<alpha> s1 \\<subseteq> bs_\\<alpha> s2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bs_subset_eq s1 s2 = (bs_\\<alpha> s1 \\<subseteq> bs_\\<alpha> s2)", "unfolding bs_\\<alpha>_def bs_subset_eq_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (s1 AND NOT s2 = 0) = ({n. bit s1 n} \\<subseteq> {n. bit s2 n})", "by transfer (auto simp add: bit_eq_iff bin_nth_ops)"], ["", "definition bs_disjoint :: \"bitset \\<Rightarrow> bitset \\<Rightarrow> bool\" where\n    \"bs_disjoint s1 s2 \\<equiv> s1 AND s2 = 0\""], ["", "lemma bs_disjoint_correct: \"bs_disjoint s1 s2 \\<longleftrightarrow> bs_\\<alpha> s1 \\<inter> bs_\\<alpha> s2 = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bs_disjoint s1 s2 = (bs_\\<alpha> s1 \\<inter> bs_\\<alpha> s2 = {})", "unfolding bs_\\<alpha>_def bs_disjoint_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (s1 AND s2 = 0) = ({n. bit s1 n} \\<inter> {n. bit s2 n} = {})", "by transfer (auto simp add: bit_eq_iff bin_nth_ops)"], ["", "definition bs_union :: \"bitset \\<Rightarrow> bitset \\<Rightarrow> bitset\" where\n    \"bs_union s1 s2 = s1 OR s2\""], ["", "lemma bs_union_correct: \"bs_\\<alpha> (bs_union s1 s2) = bs_\\<alpha> s1 \\<union> bs_\\<alpha> s2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bs_\\<alpha> (bs_union s1 s2) = bs_\\<alpha> s1 \\<union> bs_\\<alpha> s2", "unfolding bs_\\<alpha>_def bs_union_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {n. bit (s1 OR s2) n} = {n. bit s1 n} \\<union> {n. bit s2 n}", "by transfer (auto simp: bin_nth_ops)"], ["", "definition bs_inter :: \"bitset \\<Rightarrow> bitset \\<Rightarrow> bitset\" where\n    \"bs_inter s1 s2 = s1 AND s2\""], ["", "lemma bs_inter_correct: \"bs_\\<alpha> (bs_inter s1 s2) = bs_\\<alpha> s1 \\<inter> bs_\\<alpha> s2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bs_\\<alpha> (bs_inter s1 s2) = bs_\\<alpha> s1 \\<inter> bs_\\<alpha> s2", "unfolding bs_\\<alpha>_def bs_inter_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {n. bit (s1 AND s2) n} = {n. bit s1 n} \\<inter> {n. bit s2 n}", "by transfer (auto simp: bin_nth_ops)"], ["", "definition bs_diff :: \"bitset \\<Rightarrow> bitset \\<Rightarrow> bitset\" where\n    \"bs_diff s1 s2 = s1 AND NOT s2\""], ["", "lemma bs_diff_correct: \"bs_\\<alpha> (bs_diff s1 s2) = bs_\\<alpha> s1 - bs_\\<alpha> s2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bs_\\<alpha> (bs_diff s1 s2) = bs_\\<alpha> s1 - bs_\\<alpha> s2", "unfolding bs_\\<alpha>_def bs_diff_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {n. bit (s1 AND NOT s2) n} = {n. bit s1 n} - {n. bit s2 n}", "by transfer (auto simp: bin_nth_ops)"], ["", "definition bs_UNIV :: \"unit \\<Rightarrow> bitset\" where \"bs_UNIV \\<equiv> \\<lambda>_. -1\""], ["", "lemma bs_UNIV_correct: \"bs_\\<alpha> (bs_UNIV ()) = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bs_\\<alpha> (bs_UNIV ()) = UNIV", "unfolding bs_\\<alpha>_def bs_UNIV_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {n. bit (- 1) n} = UNIV", "by transfer (auto)"], ["", "definition bs_complement :: \"bitset \\<Rightarrow> bitset\" where\n    \"bs_complement s = NOT s\""], ["", "lemma bs_complement_correct: \"bs_\\<alpha> (bs_complement s) = - bs_\\<alpha> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bs_\\<alpha> (bs_complement s) = - bs_\\<alpha> s", "unfolding bs_\\<alpha>_def bs_complement_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {n. bit (NOT s) n} = - {n. bit s n}", "by transfer (auto simp: bin_nth_ops)"], ["", "end"], ["", "lemmas bs_correct[simp] = \n    bs_empty_correct\n    bs_isEmpty_correct\n    bs_insert_correct\n    bs_delete_correct\n    bs_mem_correct\n    bs_eq_correct\n    bs_subset_eq_correct\n    bs_disjoint_correct\n    bs_union_correct\n    bs_inter_correct\n    bs_diff_correct\n    bs_UNIV_correct\n    bs_complement_correct"], ["", "subsection \\<open>Autoref Setup\\<close>"], ["", "definition bs_set_rel_def_internal: \n  \"bs_set_rel Rk \\<equiv> \n    if Rk=nat_rel then br bs_\\<alpha> (\\<lambda>_. True) else {}\""], ["", "lemma bs_set_rel_def: \n  \"\\<langle>nat_rel\\<rangle>bs_set_rel \\<equiv> br bs_\\<alpha> (\\<lambda>_. True)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>nat_rel\\<rangle>bs_set_rel \\<equiv>\n    br bs_\\<alpha> (\\<lambda>_. True)", "unfolding bs_set_rel_def_internal relAPP_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. if nat_rel = nat_rel then br bs_\\<alpha> (\\<lambda>_. True)\n    else {} \\<equiv>\n    br bs_\\<alpha> (\\<lambda>_. True)", "by simp"], ["", "lemmas [autoref_rel_intf] = REL_INTFI[of \"bs_set_rel\" i_set]"], ["", "lemma bs_set_rel_sv[relator_props]: \"single_valued (\\<langle>nat_rel\\<rangle>bs_set_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued (\\<langle>nat_rel\\<rangle>bs_set_rel)", "unfolding bs_set_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued (br bs_\\<alpha> (\\<lambda>_. True))", "by auto"], ["", "term bs_empty"], ["", "lemma [autoref_rules]: \"(bs_empty (),{})\\<in>\\<langle>nat_rel\\<rangle>bs_set_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bs_empty (), {}) \\<in> \\<langle>nat_rel\\<rangle>bs_set_rel", "by (auto simp: bs_set_rel_def br_def)"], ["", "lemma [autoref_rules]: \"(bs_UNIV (),UNIV)\\<in>\\<langle>nat_rel\\<rangle>bs_set_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bs_UNIV (), UNIV) \\<in> \\<langle>nat_rel\\<rangle>bs_set_rel", "by (auto simp: bs_set_rel_def br_def)"], ["", "lemma [autoref_rules]: \"(bs_isEmpty,op_set_isEmpty)\\<in>\\<langle>nat_rel\\<rangle>bs_set_rel \\<rightarrow> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bs_isEmpty, op_set_isEmpty)\n    \\<in> \\<langle>nat_rel\\<rangle>bs_set_rel \\<rightarrow> bool_rel", "by (auto simp: bs_set_rel_def br_def)"], ["", "term insert"], ["", "lemma [autoref_rules]: \"(bs_insert,insert)\\<in>nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>bs_set_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>bs_set_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bs_insert, insert)\n    \\<in> nat_rel \\<rightarrow>\n          \\<langle>nat_rel\\<rangle>bs_set_rel \\<rightarrow>\n          \\<langle>nat_rel\\<rangle>bs_set_rel", "by (auto simp: bs_set_rel_def br_def)"], ["", "term op_set_delete"], ["", "lemma [autoref_rules]: \"(bs_delete,op_set_delete)\\<in>nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>bs_set_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>bs_set_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bs_delete, op_set_delete)\n    \\<in> nat_rel \\<rightarrow>\n          \\<langle>nat_rel\\<rangle>bs_set_rel \\<rightarrow>\n          \\<langle>nat_rel\\<rangle>bs_set_rel", "by (auto simp: bs_set_rel_def br_def)"], ["", "lemma [autoref_rules]: \"(bs_mem,(\\<in>))\\<in>nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>bs_set_rel \\<rightarrow> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bs_mem, (\\<in>))\n    \\<in> nat_rel \\<rightarrow>\n          \\<langle>nat_rel\\<rangle>bs_set_rel \\<rightarrow> bool_rel", "by (auto simp: bs_set_rel_def br_def)"], ["", "lemma [autoref_rules]: \"(bs_eq,(=))\\<in>\\<langle>nat_rel\\<rangle>bs_set_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>bs_set_rel \\<rightarrow> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bs_eq, (=))\n    \\<in> \\<langle>nat_rel\\<rangle>bs_set_rel \\<rightarrow>\n          \\<langle>nat_rel\\<rangle>bs_set_rel \\<rightarrow> bool_rel", "by (auto simp: bs_set_rel_def br_def)"], ["", "lemma [autoref_rules]: \"(bs_subset_eq,(\\<subseteq>))\\<in>\\<langle>nat_rel\\<rangle>bs_set_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>bs_set_rel \\<rightarrow> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bs_subset_eq, (\\<subseteq>))\n    \\<in> \\<langle>nat_rel\\<rangle>bs_set_rel \\<rightarrow>\n          \\<langle>nat_rel\\<rangle>bs_set_rel \\<rightarrow> bool_rel", "by (auto simp: bs_set_rel_def br_def)"], ["", "lemma [autoref_rules]: \"(bs_union,(\\<union>))\\<in>\\<langle>nat_rel\\<rangle>bs_set_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>bs_set_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>bs_set_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bs_union, (\\<union>))\n    \\<in> \\<langle>nat_rel\\<rangle>bs_set_rel \\<rightarrow>\n          \\<langle>nat_rel\\<rangle>bs_set_rel \\<rightarrow>\n          \\<langle>nat_rel\\<rangle>bs_set_rel", "by (auto simp: bs_set_rel_def br_def)"], ["", "lemma [autoref_rules]: \"(bs_inter,(\\<inter>))\\<in>\\<langle>nat_rel\\<rangle>bs_set_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>bs_set_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>bs_set_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bs_inter, (\\<inter>))\n    \\<in> \\<langle>nat_rel\\<rangle>bs_set_rel \\<rightarrow>\n          \\<langle>nat_rel\\<rangle>bs_set_rel \\<rightarrow>\n          \\<langle>nat_rel\\<rangle>bs_set_rel", "by (auto simp: bs_set_rel_def br_def)"], ["", "lemma [autoref_rules]: \"(bs_diff,(-))\\<in>\\<langle>nat_rel\\<rangle>bs_set_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>bs_set_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>bs_set_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bs_diff, (-))\n    \\<in> \\<langle>nat_rel\\<rangle>bs_set_rel \\<rightarrow>\n          \\<langle>nat_rel\\<rangle>bs_set_rel \\<rightarrow>\n          \\<langle>nat_rel\\<rangle>bs_set_rel", "by (auto simp: bs_set_rel_def br_def)"], ["", "lemma [autoref_rules]: \"(bs_complement,uminus)\\<in>\\<langle>nat_rel\\<rangle>bs_set_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>bs_set_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bs_complement, uminus)\n    \\<in> \\<langle>nat_rel\\<rangle>bs_set_rel \\<rightarrow>\n          \\<langle>nat_rel\\<rangle>bs_set_rel", "by (auto simp: bs_set_rel_def br_def)"], ["", "lemma [autoref_rules]: \"(bs_disjoint,op_set_disjoint)\\<in>\\<langle>nat_rel\\<rangle>bs_set_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>bs_set_rel \\<rightarrow> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bs_disjoint, op_set_disjoint)\n    \\<in> \\<langle>nat_rel\\<rangle>bs_set_rel \\<rightarrow>\n          \\<langle>nat_rel\\<rangle>bs_set_rel \\<rightarrow> bool_rel", "by (auto simp: bs_set_rel_def br_def)"], ["", "export_code\n    bs_empty\n    bs_isEmpty\n    bs_insert\n    bs_delete\n    bs_mem\n    bs_eq\n    bs_subset_eq\n    bs_disjoint\n    bs_union\n    bs_inter\n    bs_diff\n    bs_UNIV\n    bs_complement\n in SML"], ["", "(*\n\n    TODO: Iterator\n\n  definition \"maxbi s \\<equiv> GREATEST i. s!!i\"\n\n  lemma cmp_BIT_append_conv[simp]: \"i < i BIT b \\<longleftrightarrow> ((i\\<ge>0 \\<and> b=1) \\<or> i>0)\"\n    by (cases b) (auto simp: Bit_B0 Bit_B1)\n\n  lemma BIT_append_cmp_conv[simp]: \"i BIT b < i \\<longleftrightarrow> ((i<0 \\<and> (i=-1 \\<longrightarrow> b=0)))\"\n    by (cases b) (auto simp: Bit_B0 Bit_B1)\n\n  lemma BIT_append_eq[simp]: fixes i :: int shows \"i BIT b = i \\<longleftrightarrow> (i=0 \\<and> b=0) \\<or> (i=-1 \\<and> b=1)\"\n    by (cases b) (auto simp: Bit_B0 Bit_B1)\n\n  lemma int_no_bits_eq_zero[simp]:\n    fixes s::int shows \"(\\<forall>i. \\<not>s!!i) \\<longleftrightarrow> s=0\"\n    apply clarsimp\n    by (metis bin_eqI bin_nth_code(1))\n\n  lemma int_obtain_bit:\n    fixes s::int\n    assumes \"s\\<noteq>0\"\n    obtains i where \"s!!i\"\n    by (metis assms int_no_bits_eq_zero)\n    \n  lemma int_bit_bound:\n    fixes s::int\n    assumes \"s\\<ge>0\" and \"s!!i\"\n    shows \"i \\<le> Bits_Integer.log2 s\"\n  proof (rule ccontr)\n    assume \"\\<not>i\\<le>Bits_Integer.log2 s\"\n    hence \"i>Bits_Integer.log2 s\" by simp\n    hence \"i - 1 \\<ge> Bits_Integer.log2 s\" by simp\n    hence \"s AND bin_mask (i - 1) = s\" by (simp add: int_and_mask `s\\<ge>0`)\n    hence \"\\<not> (s!!i)\"  \n      by clarsimp (metis Nat.diff_le_self bin_nth_mask bin_nth_ops(1) leD)\n    thus False using `s!!i` ..\n  qed\n\n  lemma int_bit_bound':\n    fixes s::int\n    assumes \"s\\<ge>0\" and \"s!!i\"\n    shows \"i < Bits_Integer.log2 s + 1\"\n    using assms int_bit_bound by smt\n\n  lemma int_obtain_bit_pos:\n    fixes s::int\n    assumes \"s>0\"\n    obtains i where \"s!!i\" \"i < Bits_Integer.log2 s + 1\"\n    by (metis assms int_bit_bound' int_no_bits_eq_zero less_imp_le less_irrefl)\n\n  lemma maxbi_set: fixes s::int shows \"s>0 \\<Longrightarrow> s!!maxbi s\"\n    unfolding maxbi_def\n    apply (rule int_obtain_bit_pos, assumption)\n    apply (rule GreatestI_nat, assumption)\n    apply (intro allI impI)\n    apply (rule int_bit_bound'[rotated], assumption)\n    by auto\n\n  lemma maxbi_max: fixes s::int shows \"i>maxbi s \\<Longrightarrow> \\<not> s!!i\"\n    oops\n\n  function get_maxbi :: \"nat \\<Rightarrow> int \\<Rightarrow> nat\" where\n    \"get_maxbi n s = (let\n        b = 1<<n\n      in\n        if b\\<le>s then get_maxbi (n+1) s\n        else n\n    )\"\n    by pat_completeness auto\n\n  termination\n    apply (rule \"termination\"[of \"measure (\\<lambda>(n,s). nat (s + 1 - (1<<n)))\"])\n    apply simp\n    apply auto\n    by (smt bin_mask_ge0 bin_mask_p1_conv_shift)\n\n\n  partial_function (tailrec) \n    bs_iterate_aux :: \"nat \\<Rightarrow> bitset \\<Rightarrow> ('\\<sigma> \\<Rightarrow> bool) \\<Rightarrow> (nat \\<Rightarrow> '\\<sigma> \\<Rightarrow> '\\<sigma>) \\<Rightarrow> '\\<sigma> \\<Rightarrow> '\\<sigma>\"\n    where \"bs_iterate_aux i s c f \\<sigma> = (\n    if s < 1 << i then \\<sigma>\n    else if \\<not>c \\<sigma> then \\<sigma>\n    else if test_bit s i then bs_iterate_aux (i+1) s c f (f i \\<sigma>)\n    else bs_iterate_aux (i+1) s c f \\<sigma>\n  )\"\n\n  definition bs_iteratei :: \"bitset \\<Rightarrow> (nat,'\\<sigma>) set_iterator\" where \n    \"bs_iteratei s = bs_iterate_aux 0 s\"\n\n\n  definition bs_set_rel_def_internal: \n    \"bs_set_rel Rk \\<equiv> \n      if Rk=nat_rel then br bs_\\<alpha> (\\<lambda>_. True) else {}\"\n  lemma bs_set_rel_def: \n    \"\\<langle>nat_rel\\<rangle>bs_set_rel \\<equiv> br bs_\\<alpha> (\\<lambda>_. True)\" \n    unfolding bs_set_rel_def_internal relAPP_def by simp\n\n\n  definition \"bs_to_list \\<equiv> it_to_list bs_iteratei\"\n\n  lemma \"(1::int)<<i = 2^i\"\n    by (simp add: shiftl_int_def)\n\n  lemma \n    fixes s :: int\n    assumes \"s\\<ge>0\"  \n    shows \"s < 1<<i \\<longleftrightarrow> Bits_Integer.log2 s \\<le> i\"\n    using assms\n  proof (induct i arbitrary: s)\n    case 0 thus ?case by auto\n  next\n    case (Suc i)\n    note GE=`0\\<le>s`\n    show ?case proof\n      assume \"s < 1 << Suc i\"\n\n      have \"s \\<le> (s >> 1) BIT 1\"\n\n      hence \"(s >> 1) < (1<<i)\" using GE apply auto\n      with Suc.hyps[of \"s div 2\"]\n\n\n    apply auto\n    \n\n\n  lemma \"distinct (bs_to_list s)\"\n    unfolding bs_to_list_def it_to_list_def bs_iteratei_def[abs_def]\n  proof -\n    {\n      fix l i\n      assume \"distinct l\"\n      show \"distinct (bs_iterate_aux 0 s (\\<lambda>_. True) (\\<lambda>x l. l @ [x]) [])\"\n\n    }\n\n\n    apply auto\n    \n\n\n\n    lemma \"set (bs_to_list s) = bs_\\<alpha> s\"\n\n\n  lemma autoref_iam_is_iterator[autoref_ga_rules]: \n    shows \"is_set_to_list nat_rel bs_set_rel bs_to_list\"\n    unfolding is_set_to_list_def is_set_to_sorted_list_def\n    apply clarsimp\n    unfolding it_to_sorted_list_def\n    apply (refine_rcg refine_vcg)\n    apply (simp_all add: bs_set_rel_def br_def)\n\n  proof (clarsimp)\n\n\n\n  definition \n\n\"iterate s c f \\<sigma> \\<equiv> let\n    i=0;\n    b=0;\n    (_,_,s) = while \n  in\n\n  end\"\n\n\n*)"], ["", "end"]]}