{"file_name": "/home/qj213/afp-2021-10-22/thys/Collections/GenCF/Intf/Intf_Map.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Collections", "problem_names": ["lemma [autoref_op_pat]:\n  \"Map.empty \\<equiv> op_map_empty\"\n  \"(m::'k\\<rightharpoonup>'v) k \\<equiv> op_map_lookup$k$m\"\n  \"m(k\\<mapsto>v) \\<equiv> op_map_update$k$v$m\"\n  \"m |` (-{k}) \\<equiv> op_map_delete$k$m\"\n  \"m |` {k\\<in>dom m. P (k, the (m k))} \\<equiv> op_map_restrict$P$m\"\n\n  \"m=Map.empty \\<equiv> op_map_isEmpty$m\"\n  \"Map.empty=m \\<equiv> op_map_isEmpty$m\"\n  \"dom m = {} \\<equiv> op_map_isEmpty$m\"\n  \"{} = dom m \\<equiv> op_map_isEmpty$m\"\n\n  \"\\<exists>k v. m=[k\\<mapsto>v] \\<equiv> op_map_isSng$m\"\n  \"\\<exists>k v. [k\\<mapsto>v]=m \\<equiv> op_map_isSng$m\"\n  \"\\<exists>k. dom m={k} \\<equiv> op_map_isSng$m\"\n  \"\\<exists>k. {k} = dom m \\<equiv> op_map_isSng$m\"\n  \"1 = card (dom m) \\<equiv> op_map_isSng$m\"\n\n  \"\\<And>P. Ball (map_to_set m) P \\<equiv> op_map_ball$m$P\"\n  \"\\<And>P. Bex (map_to_set m) P \\<equiv> op_map_bex$m$P\"\n\n  \"card (dom m) \\<equiv> op_map_size$m\"\n\n  \"min n (card (dom m)) \\<equiv> op_map_size_abort$n$m\"\n  \"min (card (dom m)) n \\<equiv> op_map_size_abort$n$m\"\n\n  \"\\<And>P. SPEC (\\<lambda>(k,v). m k=Some v \\<and> P k v) \\<equiv> op_map_sel$m$P\"\n  \"\\<And>P. SPEC (\\<lambda>(k,v). P k v \\<and> m k=Some v) \\<equiv> op_map_sel$m$P\"\n\n  \"\\<And>P. SPEC (\\<lambda>(k,v). m k = Some v) \\<equiv> op_map_pick$m\"\n  \"\\<And>P. SPEC (\\<lambda>(k,v). (k,v) \\<in> map_to_set m) \\<equiv> op_map_pick$m\"", "lemma [autoref_op_pat]: \n    \"SPEC (\\<lambda>((k,v),m'). m k = Some v \\<and> m' = m |` (-{k})) \n      \\<equiv> op_map_pick_remove$m\"", "lemma op_map_pick_remove_alt: \"\n    do {((k,v),m) \\<leftarrow> op_map_pick_remove m; f k v m}\n      = (\n    do {\n      (k,v)\\<leftarrow>SPEC (\\<lambda>(k,v). m k = Some v); \n       let m=m |` (-{k});\n       f k v m\n    })\"", "lemma [autoref_op_pat]: \n    \"do {\n      (k,v)\\<leftarrow>SPEC (\\<lambda>(k,v). m k = Some v); \n       let m=m |` (-{k});\n       f k v m\n    } \\<equiv> do {((k,v),m) \\<leftarrow> op_map_pick_remove m; f k v m}\"", "lemma [autoref_itype]:\n  \"op_map_empty ::\\<^sub>i \\<langle>Ik,Iv\\<rangle>\\<^sub>ii_map\"\n  \"op_map_lookup ::\\<^sub>i Ik \\<rightarrow>\\<^sub>i \\<langle>Ik,Iv\\<rangle>\\<^sub>ii_map \\<rightarrow>\\<^sub>i \\<langle>Iv\\<rangle>\\<^sub>ii_option\"\n  \"op_map_update ::\\<^sub>i Ik \\<rightarrow>\\<^sub>i Iv \\<rightarrow>\\<^sub>i \\<langle>Ik,Iv\\<rangle>\\<^sub>ii_map \\<rightarrow>\\<^sub>i \\<langle>Ik,Iv\\<rangle>\\<^sub>ii_map\"\n  \"op_map_delete ::\\<^sub>i Ik \\<rightarrow>\\<^sub>i \\<langle>Ik,Iv\\<rangle>\\<^sub>ii_map \\<rightarrow>\\<^sub>i \\<langle>Ik,Iv\\<rangle>\\<^sub>ii_map\"\n  \"op_map_restrict \n    ::\\<^sub>i (\\<langle>Ik,Iv\\<rangle>\\<^sub>ii_prod \\<rightarrow>\\<^sub>i i_bool) \\<rightarrow>\\<^sub>i \\<langle>Ik,Iv\\<rangle>\\<^sub>ii_map \\<rightarrow>\\<^sub>i \\<langle>Ik,Iv\\<rangle>\\<^sub>ii_map\"\n  \"op_map_isEmpty ::\\<^sub>i \\<langle>Ik,Iv\\<rangle>\\<^sub>ii_map \\<rightarrow>\\<^sub>i i_bool\"\n  \"op_map_isSng ::\\<^sub>i \\<langle>Ik,Iv\\<rangle>\\<^sub>ii_map \\<rightarrow>\\<^sub>i i_bool\"\n  \"op_map_ball ::\\<^sub>i \\<langle>Ik,Iv\\<rangle>\\<^sub>ii_map \\<rightarrow>\\<^sub>i (\\<langle>Ik,Iv\\<rangle>\\<^sub>ii_prod \\<rightarrow>\\<^sub>i i_bool) \\<rightarrow>\\<^sub>i i_bool\"\n  \"op_map_bex ::\\<^sub>i \\<langle>Ik,Iv\\<rangle>\\<^sub>ii_map \\<rightarrow>\\<^sub>i (\\<langle>Ik,Iv\\<rangle>\\<^sub>ii_prod \\<rightarrow>\\<^sub>i i_bool) \\<rightarrow>\\<^sub>i i_bool\"\n  \"op_map_size ::\\<^sub>i \\<langle>Ik,Iv\\<rangle>\\<^sub>ii_map \\<rightarrow>\\<^sub>i i_nat\"\n  \"op_map_size_abort ::\\<^sub>i i_nat \\<rightarrow>\\<^sub>i \\<langle>Ik,Iv\\<rangle>\\<^sub>ii_map \\<rightarrow>\\<^sub>i i_nat\"\n  \"(++) ::\\<^sub>i \\<langle>Ik,Iv\\<rangle>\\<^sub>ii_map \\<rightarrow>\\<^sub>i \\<langle>Ik,Iv\\<rangle>\\<^sub>ii_map \\<rightarrow>\\<^sub>i \\<langle>Ik,Iv\\<rangle>\\<^sub>ii_map\"\n  \"map_of ::\\<^sub>i \\<langle>\\<langle>Ik,Iv\\<rangle>\\<^sub>ii_prod\\<rangle>\\<^sub>ii_list \\<rightarrow>\\<^sub>i \\<langle>Ik,Iv\\<rangle>\\<^sub>ii_map\"\n\n  \"op_map_sel ::\\<^sub>i \\<langle>Ik,Iv\\<rangle>\\<^sub>ii_map \\<rightarrow>\\<^sub>i (Ik \\<rightarrow>\\<^sub>i Iv \\<rightarrow>\\<^sub>i i_bool) \n    \\<rightarrow>\\<^sub>i \\<langle>\\<langle>Ik,Iv\\<rangle>\\<^sub>ii_prod\\<rangle>\\<^sub>ii_nres\"\n  \"op_map_pick ::\\<^sub>i \\<langle>Ik,Iv\\<rangle>\\<^sub>ii_map \\<rightarrow>\\<^sub>i \\<langle>\\<langle>Ik,Iv\\<rangle>\\<^sub>ii_prod\\<rangle>\\<^sub>ii_nres\"\n  \"op_map_pick_remove \n    ::\\<^sub>i \\<langle>Ik,Iv\\<rangle>\\<^sub>ii_map \\<rightarrow>\\<^sub>i \\<langle>\\<langle>\\<langle>Ik,Iv\\<rangle>\\<^sub>ii_prod,\\<langle>Ik,Iv\\<rangle>\\<^sub>ii_map\\<rangle>\\<^sub>ii_prod\\<rangle>\\<^sub>ii_nres\"", "lemma hom_map1[autoref_hom]:\n  \"CONSTRAINT Map.empty (\\<langle>Rk,Rv\\<rangle>Rm)\"\n  \"CONSTRAINT map_of (\\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel \\<rightarrow> \\<langle>Rk,Rv\\<rangle>Rm)\"\n  \"CONSTRAINT (++) (\\<langle>Rk,Rv\\<rangle>Rm \\<rightarrow> \\<langle>Rk,Rv\\<rangle>Rm \\<rightarrow> \\<langle>Rk,Rv\\<rangle>Rm)\"", "lemma hom_map2[autoref_hom]:\n  \"CONSTRAINT op_map_lookup (Rk\\<rightarrow>\\<langle>Rk,Rv\\<rangle>Rm\\<rightarrow>\\<langle>Rv\\<rangle>option_rel)\"\n  \"CONSTRAINT op_map_update (Rk\\<rightarrow>Rv\\<rightarrow>\\<langle>Rk,Rv\\<rangle>Rm\\<rightarrow>\\<langle>Rk,Rv\\<rangle>Rm)\"\n  \"CONSTRAINT op_map_delete (Rk\\<rightarrow>\\<langle>Rk,Rv\\<rangle>Rm\\<rightarrow>\\<langle>Rk,Rv\\<rangle>Rm)\"\n  \"CONSTRAINT op_map_restrict ((\\<langle>Rk,Rv\\<rangle>prod_rel \\<rightarrow> Id) \\<rightarrow> \\<langle>Rk,Rv\\<rangle>Rm \\<rightarrow> \\<langle>Rk,Rv\\<rangle>Rm)\"\n  \"CONSTRAINT op_map_isEmpty (\\<langle>Rk,Rv\\<rangle>Rm\\<rightarrow>Id)\"\n  \"CONSTRAINT op_map_isSng (\\<langle>Rk,Rv\\<rangle>Rm\\<rightarrow>Id)\"\n  \"CONSTRAINT op_map_ball (\\<langle>Rk,Rv\\<rangle>Rm\\<rightarrow>(\\<langle>Rk,Rv\\<rangle>prod_rel\\<rightarrow>Id)\\<rightarrow>Id)\"\n  \"CONSTRAINT op_map_bex (\\<langle>Rk,Rv\\<rangle>Rm\\<rightarrow>(\\<langle>Rk,Rv\\<rangle>prod_rel\\<rightarrow>Id)\\<rightarrow>Id)\"\n  \"CONSTRAINT op_map_size (\\<langle>Rk,Rv\\<rangle>Rm\\<rightarrow>Id)\"\n  \"CONSTRAINT op_map_size_abort (Id\\<rightarrow>\\<langle>Rk,Rv\\<rangle>Rm\\<rightarrow>Id)\"\n\n  \"CONSTRAINT op_map_sel (\\<langle>Rk,Rv\\<rangle>Rm\\<rightarrow>(Rk \\<rightarrow> Rv \\<rightarrow> bool_rel)\\<rightarrow>\\<langle>Rk\\<times>\\<^sub>rRv\\<rangle>nres_rel)\"\n  \"CONSTRAINT op_map_pick (\\<langle>Rk,Rv\\<rangle>Rm \\<rightarrow> \\<langle>Rk\\<times>\\<^sub>rRv\\<rangle>nres_rel)\"\n  \"CONSTRAINT op_map_pick_remove (\\<langle>Rk,Rv\\<rangle>Rm \\<rightarrow> \\<langle>(Rk\\<times>\\<^sub>rRv)\\<times>\\<^sub>r\\<langle>Rk,Rv\\<rangle>Rm\\<rangle>nres_rel)\"", "lemma finite_map_rel_trigger: \"finite_map_rel R \\<Longrightarrow> finite_map_rel R\""], "translations": [["", "lemma [autoref_op_pat]:\n  \"Map.empty \\<equiv> op_map_empty\"\n  \"(m::'k\\<rightharpoonup>'v) k \\<equiv> op_map_lookup$k$m\"\n  \"m(k\\<mapsto>v) \\<equiv> op_map_update$k$v$m\"\n  \"m |` (-{k}) \\<equiv> op_map_delete$k$m\"\n  \"m |` {k\\<in>dom m. P (k, the (m k))} \\<equiv> op_map_restrict$P$m\"\n\n  \"m=Map.empty \\<equiv> op_map_isEmpty$m\"\n  \"Map.empty=m \\<equiv> op_map_isEmpty$m\"\n  \"dom m = {} \\<equiv> op_map_isEmpty$m\"\n  \"{} = dom m \\<equiv> op_map_isEmpty$m\"\n\n  \"\\<exists>k v. m=[k\\<mapsto>v] \\<equiv> op_map_isSng$m\"\n  \"\\<exists>k v. [k\\<mapsto>v]=m \\<equiv> op_map_isSng$m\"\n  \"\\<exists>k. dom m={k} \\<equiv> op_map_isSng$m\"\n  \"\\<exists>k. {k} = dom m \\<equiv> op_map_isSng$m\"\n  \"1 = card (dom m) \\<equiv> op_map_isSng$m\"\n\n  \"\\<And>P. Ball (map_to_set m) P \\<equiv> op_map_ball$m$P\"\n  \"\\<And>P. Bex (map_to_set m) P \\<equiv> op_map_bex$m$P\"\n\n  \"card (dom m) \\<equiv> op_map_size$m\"\n\n  \"min n (card (dom m)) \\<equiv> op_map_size_abort$n$m\"\n  \"min (card (dom m)) n \\<equiv> op_map_size_abort$n$m\"\n\n  \"\\<And>P. SPEC (\\<lambda>(k,v). m k=Some v \\<and> P k v) \\<equiv> op_map_sel$m$P\"\n  \"\\<And>P. SPEC (\\<lambda>(k,v). P k v \\<and> m k=Some v) \\<equiv> op_map_sel$m$P\"\n\n  \"\\<And>P. SPEC (\\<lambda>(k,v). m k = Some v) \\<equiv> op_map_pick$m\"\n  \"\\<And>P. SPEC (\\<lambda>(k,v). (k,v) \\<in> map_to_set m) \\<equiv> op_map_pick$m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((((Map.empty \\<equiv> op_map_empty) &&&\n       m k \\<equiv> op_map_lookup $ k $ m) &&&\n      (m(k \\<mapsto> v) \\<equiv> op_map_update $ k $ v $ m) &&&\n      (m |` (- {k}) \\<equiv> op_map_delete $ k $ m) &&&\n      m |` {k \\<in> dom m. P (k, the (m k))} \\<equiv>\n      op_map_restrict $ P $ m) &&&\n     ((m = Map.empty \\<equiv> op_map_isEmpty $ m) &&&\n      (Map.empty = m \\<equiv> op_map_isEmpty $ m) &&&\n      dom m = {} \\<equiv> op_map_isEmpty $ m) &&&\n     ({} = dom m \\<equiv> op_map_isEmpty $ m) &&&\n     (\\<exists>k v. m = [k \\<mapsto> v] \\<equiv> op_map_isSng $ m) &&&\n     \\<exists>k v. [k \\<mapsto> v] = m \\<equiv> op_map_isSng $ m) &&&\n    (((\\<exists>k. dom m = {k} \\<equiv> op_map_isSng $ m) &&&\n      (\\<exists>k. {k} = dom m \\<equiv> op_map_isSng $ m) &&&\n      1 = card (dom m) \\<equiv> op_map_isSng $ m) &&&\n     (\\<And>P. Ball (map_to_set m) P \\<equiv> op_map_ball $ m $ P) &&&\n     (\\<And>P. Bex (map_to_set m) P \\<equiv> op_map_bex $ m $ P) &&&\n     card (dom m) \\<equiv> op_map_size $ m) &&&\n    ((min n (card (dom m)) \\<equiv> op_map_size_abort $ n $ m) &&&\n     (min (card (dom m)) n \\<equiv> op_map_size_abort $ n $ m) &&&\n     (\\<And>P.\n         SPEC (\\<lambda>(k, v). m k = Some v \\<and> P k v) \\<equiv>\n         op_map_sel $ m $ P)) &&&\n    (\\<And>P.\n        SPEC (\\<lambda>(k, v). P k v \\<and> m k = Some v) \\<equiv>\n        op_map_sel $ m $ P) &&&\n    (\\<And>P.\n        SPEC (\\<lambda>(k, v). m k = Some v) \\<equiv> op_map_pick $ m) &&&\n    (\\<And>P.\n        SPEC (\\<lambda>(k, v). (k, v) \\<in> map_to_set m) \\<equiv>\n        op_map_pick $ m)", "by (auto \n    intro!: eq_reflection ext\n    simp: restrict_map_def dom_eq_singleton_conv card_Suc_eq map_to_set_def\n    dest!: sym[of \"Suc 0\" \"card (dom m)\"] sym[of _ \"dom m\"]\n  )"], ["", "lemma [autoref_op_pat]: \n    \"SPEC (\\<lambda>((k,v),m'). m k = Some v \\<and> m' = m |` (-{k})) \n      \\<equiv> op_map_pick_remove$m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SPEC\n     (\\<lambda>((k, v), m'). m k = Some v \\<and> m' = m |` (- {k})) \\<equiv>\n    op_map_pick_remove $ m", "by simp"], ["", "lemma op_map_pick_remove_alt: \"\n    do {((k,v),m) \\<leftarrow> op_map_pick_remove m; f k v m}\n      = (\n    do {\n      (k,v)\\<leftarrow>SPEC (\\<lambda>(k,v). m k = Some v); \n       let m=m |` (-{k});\n       f k v m\n    })\""], ["proof (prove)\ngoal (1 subgoal):\n 1. op_map_pick_remove m \\<bind> (\\<lambda>((k, v), m). f k v m) =\n    SPEC (\\<lambda>(k, v). m k = Some v) \\<bind>\n    (\\<lambda>(k, v). Let (m |` (- {k})) (f k v))", "unfolding op_map_pick_remove_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. SPEC\n     (\\<lambda>((k, v), m'). m k = Some v \\<and> m' = m |` (- {k})) \\<bind>\n    (\\<lambda>((k, v), m). f k v m) =\n    SPEC (\\<lambda>(k, v). m k = Some v) \\<bind>\n    (\\<lambda>(k, v). Let (m |` (- {k})) (f k v))", "apply (auto simp: pw_eq_iff refine_pw_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma [autoref_op_pat]: \n    \"do {\n      (k,v)\\<leftarrow>SPEC (\\<lambda>(k,v). m k = Some v); \n       let m=m |` (-{k});\n       f k v m\n    } \\<equiv> do {((k,v),m) \\<leftarrow> op_map_pick_remove m; f k v m}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SPEC (\\<lambda>(k, v). m k = Some v) \\<bind>\n    (\\<lambda>(k, v). Let (m |` (- {k})) (f k v)) \\<equiv>\n    op_map_pick_remove m \\<bind> (\\<lambda>((k, v), m). f k v m)", "unfolding op_map_pick_remove_alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. SPEC (\\<lambda>(k, v). m k = Some v) \\<bind>\n    (\\<lambda>(k, v). Let (m |` (- {k})) (f k v)) \\<equiv>\n    SPEC (\\<lambda>(k, v). m k = Some v) \\<bind>\n    (\\<lambda>(k, v). Let (m |` (- {k})) (f k v))", "."], ["", "end"], ["", "lemma [autoref_itype]:\n  \"op_map_empty ::\\<^sub>i \\<langle>Ik,Iv\\<rangle>\\<^sub>ii_map\"\n  \"op_map_lookup ::\\<^sub>i Ik \\<rightarrow>\\<^sub>i \\<langle>Ik,Iv\\<rangle>\\<^sub>ii_map \\<rightarrow>\\<^sub>i \\<langle>Iv\\<rangle>\\<^sub>ii_option\"\n  \"op_map_update ::\\<^sub>i Ik \\<rightarrow>\\<^sub>i Iv \\<rightarrow>\\<^sub>i \\<langle>Ik,Iv\\<rangle>\\<^sub>ii_map \\<rightarrow>\\<^sub>i \\<langle>Ik,Iv\\<rangle>\\<^sub>ii_map\"\n  \"op_map_delete ::\\<^sub>i Ik \\<rightarrow>\\<^sub>i \\<langle>Ik,Iv\\<rangle>\\<^sub>ii_map \\<rightarrow>\\<^sub>i \\<langle>Ik,Iv\\<rangle>\\<^sub>ii_map\"\n  \"op_map_restrict \n    ::\\<^sub>i (\\<langle>Ik,Iv\\<rangle>\\<^sub>ii_prod \\<rightarrow>\\<^sub>i i_bool) \\<rightarrow>\\<^sub>i \\<langle>Ik,Iv\\<rangle>\\<^sub>ii_map \\<rightarrow>\\<^sub>i \\<langle>Ik,Iv\\<rangle>\\<^sub>ii_map\"\n  \"op_map_isEmpty ::\\<^sub>i \\<langle>Ik,Iv\\<rangle>\\<^sub>ii_map \\<rightarrow>\\<^sub>i i_bool\"\n  \"op_map_isSng ::\\<^sub>i \\<langle>Ik,Iv\\<rangle>\\<^sub>ii_map \\<rightarrow>\\<^sub>i i_bool\"\n  \"op_map_ball ::\\<^sub>i \\<langle>Ik,Iv\\<rangle>\\<^sub>ii_map \\<rightarrow>\\<^sub>i (\\<langle>Ik,Iv\\<rangle>\\<^sub>ii_prod \\<rightarrow>\\<^sub>i i_bool) \\<rightarrow>\\<^sub>i i_bool\"\n  \"op_map_bex ::\\<^sub>i \\<langle>Ik,Iv\\<rangle>\\<^sub>ii_map \\<rightarrow>\\<^sub>i (\\<langle>Ik,Iv\\<rangle>\\<^sub>ii_prod \\<rightarrow>\\<^sub>i i_bool) \\<rightarrow>\\<^sub>i i_bool\"\n  \"op_map_size ::\\<^sub>i \\<langle>Ik,Iv\\<rangle>\\<^sub>ii_map \\<rightarrow>\\<^sub>i i_nat\"\n  \"op_map_size_abort ::\\<^sub>i i_nat \\<rightarrow>\\<^sub>i \\<langle>Ik,Iv\\<rangle>\\<^sub>ii_map \\<rightarrow>\\<^sub>i i_nat\"\n  \"(++) ::\\<^sub>i \\<langle>Ik,Iv\\<rangle>\\<^sub>ii_map \\<rightarrow>\\<^sub>i \\<langle>Ik,Iv\\<rangle>\\<^sub>ii_map \\<rightarrow>\\<^sub>i \\<langle>Ik,Iv\\<rangle>\\<^sub>ii_map\"\n  \"map_of ::\\<^sub>i \\<langle>\\<langle>Ik,Iv\\<rangle>\\<^sub>ii_prod\\<rangle>\\<^sub>ii_list \\<rightarrow>\\<^sub>i \\<langle>Ik,Iv\\<rangle>\\<^sub>ii_map\"\n\n  \"op_map_sel ::\\<^sub>i \\<langle>Ik,Iv\\<rangle>\\<^sub>ii_map \\<rightarrow>\\<^sub>i (Ik \\<rightarrow>\\<^sub>i Iv \\<rightarrow>\\<^sub>i i_bool) \n    \\<rightarrow>\\<^sub>i \\<langle>\\<langle>Ik,Iv\\<rangle>\\<^sub>ii_prod\\<rangle>\\<^sub>ii_nres\"\n  \"op_map_pick ::\\<^sub>i \\<langle>Ik,Iv\\<rangle>\\<^sub>ii_map \\<rightarrow>\\<^sub>i \\<langle>\\<langle>Ik,Iv\\<rangle>\\<^sub>ii_prod\\<rangle>\\<^sub>ii_nres\"\n  \"op_map_pick_remove \n    ::\\<^sub>i \\<langle>Ik,Iv\\<rangle>\\<^sub>ii_map \\<rightarrow>\\<^sub>i \\<langle>\\<langle>\\<langle>Ik,Iv\\<rangle>\\<^sub>ii_prod,\\<langle>Ik,Iv\\<rangle>\\<^sub>ii_map\\<rangle>\\<^sub>ii_prod\\<rangle>\\<^sub>ii_nres\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((op_map_empty ::\\<^sub>i \\<langle>Ik, Iv\\<rangle>\\<^sub>ii_map &&&\n       op_map_lookup ::\\<^sub>i\n       Ik \\<rightarrow>\\<^sub>i\n       \\<langle>Ik, Iv\\<rangle>\\<^sub>ii_map \\<rightarrow>\\<^sub>i\n       \\<langle>Iv\\<rangle>\\<^sub>ii_option) &&&\n      op_map_update ::\\<^sub>i\n      Ik \\<rightarrow>\\<^sub>i\n      Iv \\<rightarrow>\\<^sub>i\n      \\<langle>Ik, Iv\\<rangle>\\<^sub>ii_map \\<rightarrow>\\<^sub>i\n      \\<langle>Ik, Iv\\<rangle>\\<^sub>ii_map &&&\n      op_map_delete ::\\<^sub>i\n      Ik \\<rightarrow>\\<^sub>i\n      \\<langle>Ik, Iv\\<rangle>\\<^sub>ii_map \\<rightarrow>\\<^sub>i\n      \\<langle>Ik, Iv\\<rangle>\\<^sub>ii_map) &&&\n     (op_map_restrict ::\\<^sub>i\n      (\\<langle>Ik, Iv\\<rangle>\\<^sub>ii_prod \\<rightarrow>\\<^sub>i\n       i_bool) \\<rightarrow>\\<^sub>i\n      \\<langle>Ik, Iv\\<rangle>\\<^sub>ii_map \\<rightarrow>\\<^sub>i\n      \\<langle>Ik, Iv\\<rangle>\\<^sub>ii_map &&&\n      op_map_isEmpty ::\\<^sub>i\n      \\<langle>Ik, Iv\\<rangle>\\<^sub>ii_map \\<rightarrow>\\<^sub>i\n      i_bool) &&&\n     op_map_isSng ::\\<^sub>i\n     \\<langle>Ik, Iv\\<rangle>\\<^sub>ii_map \\<rightarrow>\\<^sub>i i_bool &&&\n     op_map_ball ::\\<^sub>i\n     \\<langle>Ik, Iv\\<rangle>\\<^sub>ii_map \\<rightarrow>\\<^sub>i\n     (\\<langle>Ik, Iv\\<rangle>\\<^sub>ii_prod \\<rightarrow>\\<^sub>i\n      i_bool) \\<rightarrow>\\<^sub>i\n     i_bool) &&&\n    ((op_map_bex ::\\<^sub>i\n      \\<langle>Ik, Iv\\<rangle>\\<^sub>ii_map \\<rightarrow>\\<^sub>i\n      (\\<langle>Ik, Iv\\<rangle>\\<^sub>ii_prod \\<rightarrow>\\<^sub>i\n       i_bool) \\<rightarrow>\\<^sub>i\n      i_bool &&&\n      op_map_size ::\\<^sub>i\n      \\<langle>Ik, Iv\\<rangle>\\<^sub>ii_map \\<rightarrow>\\<^sub>i i_nat) &&&\n     op_map_size_abort ::\\<^sub>i\n     i_nat \\<rightarrow>\\<^sub>i\n     \\<langle>Ik, Iv\\<rangle>\\<^sub>ii_map \\<rightarrow>\\<^sub>i i_nat &&&\n     (++) ::\\<^sub>i\n     \\<langle>Ik, Iv\\<rangle>\\<^sub>ii_map \\<rightarrow>\\<^sub>i\n     \\<langle>Ik, Iv\\<rangle>\\<^sub>ii_map \\<rightarrow>\\<^sub>i\n     \\<langle>Ik, Iv\\<rangle>\\<^sub>ii_map) &&&\n    (map_of ::\\<^sub>i\n     \\<langle>\\<langle>Ik,\n     Iv\\<rangle>\\<^sub>ii_prod\\<rangle>\\<^sub>ii_list \\<rightarrow>\\<^sub>i\n     \\<langle>Ik, Iv\\<rangle>\\<^sub>ii_map &&&\n     op_map_sel ::\\<^sub>i\n     \\<langle>Ik, Iv\\<rangle>\\<^sub>ii_map \\<rightarrow>\\<^sub>i\n     (Ik \\<rightarrow>\\<^sub>i\n      Iv \\<rightarrow>\\<^sub>i i_bool) \\<rightarrow>\\<^sub>i\n     \\<langle>\\<langle>Ik,\n     Iv\\<rangle>\\<^sub>ii_prod\\<rangle>\\<^sub>ii_nres) &&&\n    op_map_pick ::\\<^sub>i\n    \\<langle>Ik, Iv\\<rangle>\\<^sub>ii_map \\<rightarrow>\\<^sub>i\n    \\<langle>\\<langle>Ik,\n    Iv\\<rangle>\\<^sub>ii_prod\\<rangle>\\<^sub>ii_nres &&&\n    op_map_pick_remove ::\\<^sub>i\n    \\<langle>Ik, Iv\\<rangle>\\<^sub>ii_map \\<rightarrow>\\<^sub>i\n    \\<langle>\\<langle>\\<langle>Ik, Iv\\<rangle>\\<^sub>ii_prod, \\<langle>Ik,\n    Iv\\<rangle>\\<^sub>ii_map\\<rangle>\\<^sub>ii_prod\\<rangle>\\<^sub>ii_nres", "by simp_all"], ["", "lemma hom_map1[autoref_hom]:\n  \"CONSTRAINT Map.empty (\\<langle>Rk,Rv\\<rangle>Rm)\"\n  \"CONSTRAINT map_of (\\<langle>\\<langle>Rk,Rv\\<rangle>prod_rel\\<rangle>list_rel \\<rightarrow> \\<langle>Rk,Rv\\<rangle>Rm)\"\n  \"CONSTRAINT (++) (\\<langle>Rk,Rv\\<rangle>Rm \\<rightarrow> \\<langle>Rk,Rv\\<rangle>Rm \\<rightarrow> \\<langle>Rk,Rv\\<rangle>Rm)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CONSTRAINT Map.empty (\\<langle>Rk, Rv\\<rangle>Rm) &&&\n    CONSTRAINT map_of\n     (\\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>list_rel \\<rightarrow>\n      \\<langle>Rk, Rv\\<rangle>Rm) &&&\n    CONSTRAINT (++)\n     (\\<langle>Rk, Rv\\<rangle>Rm \\<rightarrow>\n      \\<langle>Rk, Rv\\<rangle>Rm \\<rightarrow> \\<langle>Rk, Rv\\<rangle>Rm)", "by simp_all"], ["", "term op_map_restrict"], ["", "lemma hom_map2[autoref_hom]:\n  \"CONSTRAINT op_map_lookup (Rk\\<rightarrow>\\<langle>Rk,Rv\\<rangle>Rm\\<rightarrow>\\<langle>Rv\\<rangle>option_rel)\"\n  \"CONSTRAINT op_map_update (Rk\\<rightarrow>Rv\\<rightarrow>\\<langle>Rk,Rv\\<rangle>Rm\\<rightarrow>\\<langle>Rk,Rv\\<rangle>Rm)\"\n  \"CONSTRAINT op_map_delete (Rk\\<rightarrow>\\<langle>Rk,Rv\\<rangle>Rm\\<rightarrow>\\<langle>Rk,Rv\\<rangle>Rm)\"\n  \"CONSTRAINT op_map_restrict ((\\<langle>Rk,Rv\\<rangle>prod_rel \\<rightarrow> Id) \\<rightarrow> \\<langle>Rk,Rv\\<rangle>Rm \\<rightarrow> \\<langle>Rk,Rv\\<rangle>Rm)\"\n  \"CONSTRAINT op_map_isEmpty (\\<langle>Rk,Rv\\<rangle>Rm\\<rightarrow>Id)\"\n  \"CONSTRAINT op_map_isSng (\\<langle>Rk,Rv\\<rangle>Rm\\<rightarrow>Id)\"\n  \"CONSTRAINT op_map_ball (\\<langle>Rk,Rv\\<rangle>Rm\\<rightarrow>(\\<langle>Rk,Rv\\<rangle>prod_rel\\<rightarrow>Id)\\<rightarrow>Id)\"\n  \"CONSTRAINT op_map_bex (\\<langle>Rk,Rv\\<rangle>Rm\\<rightarrow>(\\<langle>Rk,Rv\\<rangle>prod_rel\\<rightarrow>Id)\\<rightarrow>Id)\"\n  \"CONSTRAINT op_map_size (\\<langle>Rk,Rv\\<rangle>Rm\\<rightarrow>Id)\"\n  \"CONSTRAINT op_map_size_abort (Id\\<rightarrow>\\<langle>Rk,Rv\\<rangle>Rm\\<rightarrow>Id)\"\n\n  \"CONSTRAINT op_map_sel (\\<langle>Rk,Rv\\<rangle>Rm\\<rightarrow>(Rk \\<rightarrow> Rv \\<rightarrow> bool_rel)\\<rightarrow>\\<langle>Rk\\<times>\\<^sub>rRv\\<rangle>nres_rel)\"\n  \"CONSTRAINT op_map_pick (\\<langle>Rk,Rv\\<rangle>Rm \\<rightarrow> \\<langle>Rk\\<times>\\<^sub>rRv\\<rangle>nres_rel)\"\n  \"CONSTRAINT op_map_pick_remove (\\<langle>Rk,Rv\\<rangle>Rm \\<rightarrow> \\<langle>(Rk\\<times>\\<^sub>rRv)\\<times>\\<^sub>r\\<langle>Rk,Rv\\<rangle>Rm\\<rangle>nres_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((CONSTRAINT op_map_lookup\n       (Rk \\<rightarrow>\n        \\<langle>Rk, Rv\\<rangle>Rm \\<rightarrow>\n        \\<langle>Rv\\<rangle>option_rel) &&&\n      CONSTRAINT op_map_update\n       (Rk \\<rightarrow>\n        Rv \\<rightarrow>\n        \\<langle>Rk, Rv\\<rangle>Rm \\<rightarrow> \\<langle>Rk,\n        Rv\\<rangle>Rm) &&&\n      CONSTRAINT op_map_delete\n       (Rk \\<rightarrow>\n        \\<langle>Rk, Rv\\<rangle>Rm \\<rightarrow> \\<langle>Rk,\n        Rv\\<rangle>Rm)) &&&\n     CONSTRAINT op_map_restrict\n      ((Rk \\<times>\\<^sub>r Rv \\<rightarrow> bool_rel) \\<rightarrow>\n       \\<langle>Rk, Rv\\<rangle>Rm \\<rightarrow> \\<langle>Rk,\n       Rv\\<rangle>Rm) &&&\n     CONSTRAINT op_map_isEmpty\n      (\\<langle>Rk, Rv\\<rangle>Rm \\<rightarrow> bool_rel) &&&\n     CONSTRAINT op_map_isSng\n      (\\<langle>Rk, Rv\\<rangle>Rm \\<rightarrow> bool_rel)) &&&\n    (CONSTRAINT op_map_ball\n      (\\<langle>Rk, Rv\\<rangle>Rm \\<rightarrow>\n       (Rk \\<times>\\<^sub>r Rv \\<rightarrow> bool_rel) \\<rightarrow>\n       bool_rel) &&&\n     CONSTRAINT op_map_bex\n      (\\<langle>Rk, Rv\\<rangle>Rm \\<rightarrow>\n       (Rk \\<times>\\<^sub>r Rv \\<rightarrow> bool_rel) \\<rightarrow>\n       bool_rel) &&&\n     CONSTRAINT op_map_size\n      (\\<langle>Rk, Rv\\<rangle>Rm \\<rightarrow> nat_rel)) &&&\n    (CONSTRAINT op_map_size_abort\n      (nat_rel \\<rightarrow>\n       \\<langle>Rk, Rv\\<rangle>Rm \\<rightarrow> nat_rel) &&&\n     CONSTRAINT op_map_sel\n      (\\<langle>Rk, Rv\\<rangle>Rm \\<rightarrow>\n       (Rk \\<rightarrow> Rv \\<rightarrow> bool_rel) \\<rightarrow>\n       \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>nres_rel)) &&&\n    CONSTRAINT op_map_pick\n     (\\<langle>Rk, Rv\\<rangle>Rm \\<rightarrow>\n      \\<langle>Rk \\<times>\\<^sub>r Rv\\<rangle>nres_rel) &&&\n    CONSTRAINT op_map_pick_remove\n     (\\<langle>Rk, Rv\\<rangle>Rm \\<rightarrow>\n      \\<langle>(Rk \\<times>\\<^sub>r Rv) \\<times>\\<^sub>r \\<langle>Rk,\n               Rv\\<rangle>Rm\\<rangle>nres_rel)", "by simp_all"], ["", "definition \"finite_map_rel R \\<equiv> Range R \\<subseteq> Collect (finite \\<circ> dom)\""], ["", "lemma finite_map_rel_trigger: \"finite_map_rel R \\<Longrightarrow> finite_map_rel R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_map_rel R \\<Longrightarrow> finite_map_rel R", "."], ["", "declaration \\<open>Tagged_Solver.add_triggers \n  \"Relators.relator_props_solver\" @{thms finite_map_rel_trigger}\\<close>"], ["", "end"]]}