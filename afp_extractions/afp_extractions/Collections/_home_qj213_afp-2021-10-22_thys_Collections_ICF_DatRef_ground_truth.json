{"file_name": "/home/qj213/afp-2021-10-22/thys/Collections/ICF/DatRef.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Collections", "problem_names": ["lemma initial_abs': \"s\\<in>wa_initial WAC \\<Longrightarrow> \\<alpha> s \\<in> wa_initial WAA\"", "lemma invar_abs': \"s\\<in>wa_invar WAC \\<Longrightarrow> \\<alpha> s \\<in> wa_invar WAA\"", "lemma wa_refine_intro:\n  fixes condc :: \"'C set\" and \n        stepc :: \"('C\\<times>'C) set\" and \n        initialc :: \"'C set\" and \n        invar_addc :: \"'C set\"\n  fixes WAA :: \"'A while_algo\"\n  fixes \\<alpha> :: \"'C \\<Rightarrow> 'A\"\n  assumes \"while_algo WAA\"\n\n  \\<comment> \\<open>The concrete step preserves the concrete part of the invariant\\<close>\n  assumes step_invarc: \n    \"!!s s'. \\<lbrakk> s\\<in>invar_addc; s\\<in>condc; \\<alpha> s \\<in> wa_invar WAA; (s,s')\\<in>stepc \\<rbrakk> \n              \\<Longrightarrow> s'\\<in>invar_addc\"\n  \\<comment> \\<open>The concrete initial states satisfy the concrete part of the invariant\\<close>\n  assumes initial_invarc: \"initialc \\<subseteq> invar_addc\"\n\n  \\<comment> \\<open>Condition implemented correctly\\<close>\n  assumes cond_abs: \n    \"!!s. \\<lbrakk> s\\<in>invar_addc; \\<alpha> s \\<in> wa_invar WAA; s\\<in>condc \\<rbrakk> \\<Longrightarrow> \\<alpha> s \\<in> wa_cond WAA\"\n  \\<comment> \\<open>Step implemented correctly\\<close>\n  assumes step_abs: \n    \"!!s s'. \\<lbrakk> s\\<in>invar_addc; s\\<in>condc; \\<alpha> s \\<in> wa_invar WAA; (s,s')\\<in>stepc \\<rbrakk> \n             \\<Longrightarrow> (\\<alpha> s, \\<alpha> s')\\<in>wa_step WAA\"\n  \\<comment> \\<open>Initial states implemented correctly\\<close>\n  assumes initial_abs: \"\\<alpha> ` initialc \\<subseteq> wa_initial WAA\"\n\n  \\<comment> \\<open>Concrete while-algorithm: The invariant is separated into a concrete and\n      an abstract part\\<close>\n  defines \"WAC == \\<lparr> \n   wa_cond=condc, \n   wa_step=stepc, \n   wa_initial=initialc, \n   wa_invar=(invar_addc \\<inter> {s. \\<alpha> s\\<in> wa_invar WAA}) \\<rparr>\"\n\n  shows \n    \"while_algo WAC \\<and> \n     wa_refine WAC WAA \\<alpha>\" (is \"?T1 \\<and> ?T2\")", "lemma (in wa_refine) wa_intro:\n  \\<comment> \\<open>Concrete part of the invariant\\<close>\n  fixes addi :: \"'C set\"\n  \\<comment> \\<open>The abstract algorithm is well-defined\\<close>\n  assumes \"while_algo WAA\"\n  \\<comment> \\<open>The invariant can be split into concrete and abstract part\\<close>\n  assumes icf: \"wa_invar WAC = addi \\<inter> {s. \\<alpha> s \\<in> wa_invar WAA}\"\n\n  \\<comment> \\<open>The step-relation preserves the concrete part of the invariant\\<close>\n  assumes step_addi: \n    \"!!s s'. \\<lbrakk> s\\<in>addi; s\\<in>wa_cond WAC; \\<alpha> s \\<in> wa_invar WAA; \n               (s,s')\\<in>wa_step WAC \n             \\<rbrakk> \\<Longrightarrow> s'\\<in>addi\"\n\n  \\<comment> \\<open>The initial states satisfy the concrete part of the invariant\\<close>\n  assumes initial_addi: \"wa_initial WAC \\<subseteq> addi\"\n\n  shows \n    \"while_algo WAC\"", "lemma transfer_correctness:\n    assumes A: \"\\<forall>s. s\\<in>wa_invar WAA \\<and> s\\<notin>wa_cond WAA \\<longrightarrow> P s\"\n    shows \"\\<forall>sc. sc\\<in>wa_invar WAC \\<and> sc\\<notin>wa_cond WAC \\<longrightarrow> P (\\<alpha> sc)\"", "lemma wa_ref_refl: \"wa_refine WA WA id\"", "lemma wa_pref_refl: \"wa_precise_refine WA WA id\"", "lemma wa_ref_trans: \n  assumes \"wa_refine WC WB \\<alpha>1\"\n  assumes \"wa_refine WB WA \\<alpha>2\"\n  shows \"wa_refine WC WA (\\<alpha>2\\<circ>\\<alpha>1)\"", "lemma wa_pref_trans: \n  assumes \"wa_precise_refine WC WB \\<alpha>1\"\n  assumes \"wa_precise_refine WB WA \\<alpha>2\"\n  shows \"wa_precise_refine WC WA (\\<alpha>2\\<circ>\\<alpha>1)\"", "lemma is_while_algo: \"while_algo (det_wa_wa WA)\"", "lemma det_while_algo_intro:\n  assumes \"while_algo (det_wa_wa DWA)\" \n  shows \"det_while_algo DWA\"", "theorem dwa_is_wa: \n  \"while_algo (det_wa_wa DWA) \\<longleftrightarrow> det_while_algo DWA\"", "lemma (in det_while_algo) while_proof:\n  assumes inv_imp: \"\\<And>s. \\<lbrakk>s\\<in>dwa_invar WA; \\<not> dwa_cond WA s\\<rbrakk> \\<Longrightarrow> Q s\"\n  shows \"Q loop\"", "lemma (in det_while_algo) while_proof':\n  assumes inv_imp: \n    \"\\<forall>s. s\\<in>wa_invar (det_wa_wa WA) \\<and> s\\<notin>wa_cond (det_wa_wa WA) \\<longrightarrow> Q s\"\n  shows \"Q loop\"", "lemma (in det_while_algo) loop_invar:\n  \"loop \\<in> dwa_invar WA\""], "translations": [["", "lemma initial_abs': \"s\\<in>wa_initial WAC \\<Longrightarrow> \\<alpha> s \\<in> wa_initial WAA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> wa_initial WAC \\<Longrightarrow> \\<alpha> s \\<in> wa_initial WAA", "using initial_abs"], ["proof (prove)\nusing this:\n  \\<alpha> ` wa_initial WAC \\<subseteq> wa_initial WAA\n\ngoal (1 subgoal):\n 1. s \\<in> wa_initial WAC \\<Longrightarrow> \\<alpha> s \\<in> wa_initial WAA", "by auto"], ["", "lemma invar_abs': \"s\\<in>wa_invar WAC \\<Longrightarrow> \\<alpha> s \\<in> wa_invar WAA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> wa_invar WAC \\<Longrightarrow> \\<alpha> s \\<in> wa_invar WAA", "using invar_abs"], ["proof (prove)\nusing this:\n  \\<alpha> ` wa_invar WAC \\<subseteq> wa_invar WAA\n\ngoal (1 subgoal):\n 1. s \\<in> wa_invar WAC \\<Longrightarrow> \\<alpha> s \\<in> wa_invar WAA", "by auto"], ["", "end\n\n\\<comment> \\<open>Given a concrete while-algorithm and a well-defined abstract \n  while-algorithm, this lemma shows refinement and \n  well-definedness of the concrete while-algorithm.\n\n  Assuming well-definedness of the abstract algorithm and refinement,\n  some proof-obligations for well-definedness of the concrete algorithm can be\n  discharged automatically.\n\n  For this purpose, the invariant is split into a concrete and an abstract \n  part. The abstract part claims that the abstraction of a state satisfies \n  the abstract invariant. The concrete part makes some additional claims\n  about a valid concrete state. Then, after having shown refinement, the \n  assumptions that the abstract part of the invariant is preserved, can\n  be discharged automatically.\\<close>"], ["", "lemma wa_refine_intro:\n  fixes condc :: \"'C set\" and \n        stepc :: \"('C\\<times>'C) set\" and \n        initialc :: \"'C set\" and \n        invar_addc :: \"'C set\"\n  fixes WAA :: \"'A while_algo\"\n  fixes \\<alpha> :: \"'C \\<Rightarrow> 'A\"\n  assumes \"while_algo WAA\"\n\n  \\<comment> \\<open>The concrete step preserves the concrete part of the invariant\\<close>\n  assumes step_invarc: \n    \"!!s s'. \\<lbrakk> s\\<in>invar_addc; s\\<in>condc; \\<alpha> s \\<in> wa_invar WAA; (s,s')\\<in>stepc \\<rbrakk> \n              \\<Longrightarrow> s'\\<in>invar_addc\"\n  \\<comment> \\<open>The concrete initial states satisfy the concrete part of the invariant\\<close>\n  assumes initial_invarc: \"initialc \\<subseteq> invar_addc\"\n\n  \\<comment> \\<open>Condition implemented correctly\\<close>\n  assumes cond_abs: \n    \"!!s. \\<lbrakk> s\\<in>invar_addc; \\<alpha> s \\<in> wa_invar WAA; s\\<in>condc \\<rbrakk> \\<Longrightarrow> \\<alpha> s \\<in> wa_cond WAA\"\n  \\<comment> \\<open>Step implemented correctly\\<close>\n  assumes step_abs: \n    \"!!s s'. \\<lbrakk> s\\<in>invar_addc; s\\<in>condc; \\<alpha> s \\<in> wa_invar WAA; (s,s')\\<in>stepc \\<rbrakk> \n             \\<Longrightarrow> (\\<alpha> s, \\<alpha> s')\\<in>wa_step WAA\"\n  \\<comment> \\<open>Initial states implemented correctly\\<close>\n  assumes initial_abs: \"\\<alpha> ` initialc \\<subseteq> wa_initial WAA\"\n\n  \\<comment> \\<open>Concrete while-algorithm: The invariant is separated into a concrete and\n      an abstract part\\<close>\n  defines \"WAC == \\<lparr> \n   wa_cond=condc, \n   wa_step=stepc, \n   wa_initial=initialc, \n   wa_invar=(invar_addc \\<inter> {s. \\<alpha> s\\<in> wa_invar WAA}) \\<rparr>\"\n\n  shows \n    \"while_algo WAC \\<and> \n     wa_refine WAC WAA \\<alpha>\" (is \"?T1 \\<and> ?T2\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. while_algo WAC \\<and> wa_refine WAC WAA \\<alpha>", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. while_algo WAC\n 2. wa_refine WAC WAA \\<alpha>", "interpret waa: while_algo WAA"], ["proof (prove)\ngoal (1 subgoal):\n 1. while_algo WAA", "by fact"], ["proof (state)\ngoal (2 subgoals):\n 1. while_algo WAC\n 2. wa_refine WAC WAA \\<alpha>", "show G1: \"?T1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. while_algo WAC", "apply (unfold_locales)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>s \\<in> wa_invar WAC; s \\<in> wa_cond WAC;\n        (s, s') \\<in> wa_step WAC\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> wa_invar WAC\n 2. wa_initial WAC \\<subseteq> wa_invar WAC\n 3. wf {(s', s).\n        s \\<in> wa_invar WAC \\<and>\n        s \\<in> wa_cond WAC \\<and> (s, s') \\<in> wa_step WAC}", "apply (simp_all add: WAC_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>s \\<in> invar_addc \\<and> \\<alpha> s \\<in> wa_invar WAA;\n        s \\<in> condc; (s, s') \\<in> stepc\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> invar_addc \\<and>\n                         \\<alpha> s' \\<in> wa_invar WAA\n 2. initialc \\<subseteq> invar_addc \\<and>\n    initialc \\<subseteq> {s. \\<alpha> s \\<in> wa_invar WAA}\n 3. wf {(s', s).\n        s \\<in> invar_addc \\<and>\n        \\<alpha> s \\<in> wa_invar WAA \\<and>\n        s \\<in> condc \\<and> (s, s') \\<in> stepc}", "apply safe"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>s \\<in> condc; (s, s') \\<in> stepc; s \\<in> invar_addc;\n        \\<alpha> s \\<in> wa_invar WAA\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> invar_addc\n 2. \\<And>s s'.\n       \\<lbrakk>s \\<in> condc; (s, s') \\<in> stepc; s \\<in> invar_addc;\n        \\<alpha> s \\<in> wa_invar WAA\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> s' \\<in> wa_invar WAA\n 3. \\<And>x. x \\<in> initialc \\<Longrightarrow> x \\<in> invar_addc\n 4. \\<And>x.\n       x \\<in> initialc \\<Longrightarrow> \\<alpha> x \\<in> wa_invar WAA\n 5. wf {(s', s).\n        s \\<in> invar_addc \\<and>\n        \\<alpha> s \\<in> wa_invar WAA \\<and>\n        s \\<in> condc \\<and> (s, s') \\<in> stepc}", "apply (blast intro!: step_invarc)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>s \\<in> condc; (s, s') \\<in> stepc; s \\<in> invar_addc;\n        \\<alpha> s \\<in> wa_invar WAA\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> s' \\<in> wa_invar WAA\n 2. \\<And>x. x \\<in> initialc \\<Longrightarrow> x \\<in> invar_addc\n 3. \\<And>x.\n       x \\<in> initialc \\<Longrightarrow> \\<alpha> x \\<in> wa_invar WAA\n 4. wf {(s', s).\n        s \\<in> invar_addc \\<and>\n        \\<alpha> s \\<in> wa_invar WAA \\<and>\n        s \\<in> condc \\<and> (s, s') \\<in> stepc}", "apply (frule (3) step_abs)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>s \\<in> condc; (s, s') \\<in> stepc; s \\<in> invar_addc;\n        \\<alpha> s \\<in> wa_invar WAA;\n        (\\<alpha> s, \\<alpha> s') \\<in> wa_step WAA\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> s' \\<in> wa_invar WAA\n 2. \\<And>x. x \\<in> initialc \\<Longrightarrow> x \\<in> invar_addc\n 3. \\<And>x.\n       x \\<in> initialc \\<Longrightarrow> \\<alpha> x \\<in> wa_invar WAA\n 4. wf {(s', s).\n        s \\<in> invar_addc \\<and>\n        \\<alpha> s \\<in> wa_invar WAA \\<and>\n        s \\<in> condc \\<and> (s, s') \\<in> stepc}", "apply (frule (2) cond_abs)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>s \\<in> condc; (s, s') \\<in> stepc; s \\<in> invar_addc;\n        \\<alpha> s \\<in> wa_invar WAA;\n        (\\<alpha> s, \\<alpha> s') \\<in> wa_step WAA;\n        \\<alpha> s \\<in> wa_cond WAA\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> s' \\<in> wa_invar WAA\n 2. \\<And>x. x \\<in> initialc \\<Longrightarrow> x \\<in> invar_addc\n 3. \\<And>x.\n       x \\<in> initialc \\<Longrightarrow> \\<alpha> x \\<in> wa_invar WAA\n 4. wf {(s', s).\n        s \\<in> invar_addc \\<and>\n        \\<alpha> s \\<in> wa_invar WAA \\<and>\n        s \\<in> condc \\<and> (s, s') \\<in> stepc}", "apply (erule (2) waa.step_invar)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x. x \\<in> initialc \\<Longrightarrow> x \\<in> invar_addc\n 2. \\<And>x.\n       x \\<in> initialc \\<Longrightarrow> \\<alpha> x \\<in> wa_invar WAA\n 3. wf {(s', s).\n        s \\<in> invar_addc \\<and>\n        \\<alpha> s \\<in> wa_invar WAA \\<and>\n        s \\<in> condc \\<and> (s, s') \\<in> stepc}", "apply (erule rev_subsetD[OF _ initial_invarc])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> initialc \\<Longrightarrow> \\<alpha> x \\<in> wa_invar WAA\n 2. wf {(s', s).\n        s \\<in> invar_addc \\<and>\n        \\<alpha> s \\<in> wa_invar WAA \\<and>\n        s \\<in> condc \\<and> (s, s') \\<in> stepc}", "apply (insert initial_abs waa.initial_invar) [1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> initialc;\n        \\<alpha> ` initialc \\<subseteq> wa_initial WAA;\n        wa_initial WAA \\<subseteq> wa_invar WAA\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> x \\<in> wa_invar WAA\n 2. wf {(s', s).\n        s \\<in> invar_addc \\<and>\n        \\<alpha> s \\<in> wa_invar WAA \\<and>\n        s \\<in> condc \\<and> (s, s') \\<in> stepc}", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf {(s', s).\n        s \\<in> invar_addc \\<and>\n        \\<alpha> s \\<in> wa_invar WAA \\<and>\n        s \\<in> condc \\<and> (s, s') \\<in> stepc}", "apply (rule_tac \n      r=\"inv_image { (s',s). s\\<in>wa_invar WAA \n                     \\<and> s\\<in>wa_cond WAA \n                     \\<and> (s,s')\\<in>wa_step WAA } \\<alpha>\" \n      in wf_subset)"], ["proof (prove)\ngoal (2 subgoals):\n 1. wf (inv_image\n         {(s', s).\n          s \\<in> wa_invar WAA \\<and>\n          s \\<in> wa_cond WAA \\<and> (s, s') \\<in> wa_step WAA}\n         \\<alpha>)\n 2. {(s', s).\n     s \\<in> invar_addc \\<and>\n     \\<alpha> s \\<in> wa_invar WAA \\<and>\n     s \\<in> condc \\<and> (s, s') \\<in> stepc}\n    \\<subseteq> inv_image\n                 {(s', s).\n                  s \\<in> wa_invar WAA \\<and>\n                  s \\<in> wa_cond WAA \\<and> (s, s') \\<in> wa_step WAA}\n                 \\<alpha>", "apply (simp add: waa.step_wf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(s', s).\n     s \\<in> invar_addc \\<and>\n     \\<alpha> s \\<in> wa_invar WAA \\<and>\n     s \\<in> condc \\<and> (s, s') \\<in> stepc}\n    \\<subseteq> inv_image\n                 {(s', s).\n                  s \\<in> wa_invar WAA \\<and>\n                  s \\<in> wa_cond WAA \\<and> (s, s') \\<in> wa_step WAA}\n                 \\<alpha>", "apply (auto simp add: cond_abs step_abs) [1]"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  while_algo WAC\n\ngoal (1 subgoal):\n 1. wa_refine WAC WAA \\<alpha>", "show ?T2"], ["proof (prove)\ngoal (1 subgoal):\n 1. wa_refine WAC WAA \\<alpha>", "apply (unfold_locales)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> wa_invar WAC; s \\<in> wa_cond WAC\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> s \\<in> wa_cond WAA\n 2. \\<And>s s'.\n       \\<lbrakk>s \\<in> wa_invar WAC; s \\<in> wa_cond WAC;\n        (s, s') \\<in> wa_step WAC\\<rbrakk>\n       \\<Longrightarrow> (\\<alpha> s, \\<alpha> s') \\<in> wa_step WAA\n 3. \\<alpha> ` wa_initial WAC \\<subseteq> wa_initial WAA\n 4. \\<alpha> ` wa_invar WAC \\<subseteq> wa_invar WAA", "apply (auto simp add: cond_abs step_abs initial_abs WAC_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  wa_refine WAC WAA \\<alpha>\n\ngoal:\nNo subgoals!", "qed\n\n  \\<comment> \\<open>After refinement has been shown, this lemma transfers\n        the well-definedness property up the refinement chain.\n        Like in @{thm [source] wa_refine_intro}, some proof-obligations can\n        be discharged by assuming refinement and well-definedness of the \n        abstract algorithm.\\<close>"], ["", "lemma (in wa_refine) wa_intro:\n  \\<comment> \\<open>Concrete part of the invariant\\<close>\n  fixes addi :: \"'C set\"\n  \\<comment> \\<open>The abstract algorithm is well-defined\\<close>\n  assumes \"while_algo WAA\"\n  \\<comment> \\<open>The invariant can be split into concrete and abstract part\\<close>\n  assumes icf: \"wa_invar WAC = addi \\<inter> {s. \\<alpha> s \\<in> wa_invar WAA}\"\n\n  \\<comment> \\<open>The step-relation preserves the concrete part of the invariant\\<close>\n  assumes step_addi: \n    \"!!s s'. \\<lbrakk> s\\<in>addi; s\\<in>wa_cond WAC; \\<alpha> s \\<in> wa_invar WAA; \n               (s,s')\\<in>wa_step WAC \n             \\<rbrakk> \\<Longrightarrow> s'\\<in>addi\"\n\n  \\<comment> \\<open>The initial states satisfy the concrete part of the invariant\\<close>\n  assumes initial_addi: \"wa_initial WAC \\<subseteq> addi\"\n\n  shows \n    \"while_algo WAC\""], ["proof (prove)\ngoal (1 subgoal):\n 1. while_algo WAC", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. while_algo WAC", "interpret waa: while_algo WAA"], ["proof (prove)\ngoal (1 subgoal):\n 1. while_algo WAA", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. while_algo WAC", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. while_algo WAC", "apply (unfold_locales)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>s \\<in> wa_invar WAC; s \\<in> wa_cond WAC;\n        (s, s') \\<in> wa_step WAC\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> wa_invar WAC\n 2. wa_initial WAC \\<subseteq> wa_invar WAC\n 3. wf {(s', s).\n        s \\<in> wa_invar WAC \\<and>\n        s \\<in> wa_cond WAC \\<and> (s, s') \\<in> wa_step WAC}", "apply (subst icf)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>s \\<in> wa_invar WAC; s \\<in> wa_cond WAC;\n        (s, s') \\<in> wa_step WAC\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> addi \\<inter>\n                                  {s. \\<alpha> s \\<in> wa_invar WAA}\n 2. wa_initial WAC \\<subseteq> wa_invar WAC\n 3. wf {(s', s).\n        s \\<in> wa_invar WAC \\<and>\n        s \\<in> wa_cond WAC \\<and> (s, s') \\<in> wa_step WAC}", "apply safe"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>s \\<in> wa_invar WAC; s \\<in> wa_cond WAC;\n        (s, s') \\<in> wa_step WAC\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> addi\n 2. \\<And>s s'.\n       \\<lbrakk>s \\<in> wa_invar WAC; s \\<in> wa_cond WAC;\n        (s, s') \\<in> wa_step WAC\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> s' \\<in> wa_invar WAA\n 3. \\<And>x. x \\<in> wa_initial WAC \\<Longrightarrow> x \\<in> wa_invar WAC\n 4. wf {(s', s).\n        s \\<in> wa_invar WAC \\<and>\n        s \\<in> wa_cond WAC \\<and> (s, s') \\<in> wa_step WAC}", "apply (simp only: icf)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>s \\<in> addi \\<inter> {s. \\<alpha> s \\<in> wa_invar WAA};\n        s \\<in> wa_cond WAC; (s, s') \\<in> wa_step WAC\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> addi\n 2. \\<And>s s'.\n       \\<lbrakk>s \\<in> wa_invar WAC; s \\<in> wa_cond WAC;\n        (s, s') \\<in> wa_step WAC\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> s' \\<in> wa_invar WAA\n 3. \\<And>x. x \\<in> wa_initial WAC \\<Longrightarrow> x \\<in> wa_invar WAC\n 4. wf {(s', s).\n        s \\<in> wa_invar WAC \\<and>\n        s \\<in> wa_cond WAC \\<and> (s, s') \\<in> wa_step WAC}", "apply safe"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>s \\<in> wa_cond WAC; (s, s') \\<in> wa_step WAC;\n        s \\<in> addi; \\<alpha> s \\<in> wa_invar WAA\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> addi\n 2. \\<And>s s'.\n       \\<lbrakk>s \\<in> wa_invar WAC; s \\<in> wa_cond WAC;\n        (s, s') \\<in> wa_step WAC\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> s' \\<in> wa_invar WAA\n 3. \\<And>x. x \\<in> wa_initial WAC \\<Longrightarrow> x \\<in> wa_invar WAC\n 4. wf {(s', s).\n        s \\<in> wa_invar WAC \\<and>\n        s \\<in> wa_cond WAC \\<and> (s, s') \\<in> wa_step WAC}", "apply (blast intro!: step_addi)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>s \\<in> wa_invar WAC; s \\<in> wa_cond WAC;\n        (s, s') \\<in> wa_step WAC\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> s' \\<in> wa_invar WAA\n 2. \\<And>x. x \\<in> wa_initial WAC \\<Longrightarrow> x \\<in> wa_invar WAC\n 3. wf {(s', s).\n        s \\<in> wa_invar WAC \\<and>\n        s \\<in> wa_cond WAC \\<and> (s, s') \\<in> wa_step WAC}", "apply (frule (2) step_abs)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>s \\<in> wa_invar WAC; s \\<in> wa_cond WAC;\n        (s, s') \\<in> wa_step WAC;\n        (\\<alpha> s, \\<alpha> s') \\<in> wa_step WAA\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> s' \\<in> wa_invar WAA\n 2. \\<And>x. x \\<in> wa_initial WAC \\<Longrightarrow> x \\<in> wa_invar WAC\n 3. wf {(s', s).\n        s \\<in> wa_invar WAC \\<and>\n        s \\<in> wa_cond WAC \\<and> (s, s') \\<in> wa_step WAC}", "apply (frule (1) cond_abs)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>s \\<in> wa_invar WAC; s \\<in> wa_cond WAC;\n        (s, s') \\<in> wa_step WAC;\n        (\\<alpha> s, \\<alpha> s') \\<in> wa_step WAA;\n        \\<alpha> s \\<in> wa_cond WAA\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> s' \\<in> wa_invar WAA\n 2. \\<And>x. x \\<in> wa_initial WAC \\<Longrightarrow> x \\<in> wa_invar WAC\n 3. wf {(s', s).\n        s \\<in> wa_invar WAC \\<and>\n        s \\<in> wa_cond WAC \\<and> (s, s') \\<in> wa_step WAC}", "apply (simp only: icf)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>s \\<in> addi \\<inter> {s. \\<alpha> s \\<in> wa_invar WAA};\n        s \\<in> wa_cond WAC; (s, s') \\<in> wa_step WAC;\n        (\\<alpha> s, \\<alpha> s') \\<in> wa_step WAA;\n        \\<alpha> s \\<in> wa_cond WAA\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> s' \\<in> wa_invar WAA\n 2. \\<And>x. x \\<in> wa_initial WAC \\<Longrightarrow> x \\<in> wa_invar WAC\n 3. wf {(s', s).\n        s \\<in> wa_invar WAC \\<and>\n        s \\<in> wa_cond WAC \\<and> (s, s') \\<in> wa_step WAC}", "apply clarify"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>s \\<in> wa_cond WAC; (s, s') \\<in> wa_step WAC;\n        (\\<alpha> s, \\<alpha> s') \\<in> wa_step WAA;\n        \\<alpha> s \\<in> wa_cond WAA; s \\<in> addi;\n        \\<alpha> s \\<in> wa_invar WAA\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> s' \\<in> wa_invar WAA\n 2. \\<And>x. x \\<in> wa_initial WAC \\<Longrightarrow> x \\<in> wa_invar WAC\n 3. wf {(s', s).\n        s \\<in> wa_invar WAC \\<and>\n        s \\<in> wa_cond WAC \\<and> (s, s') \\<in> wa_step WAC}", "apply (erule (2) waa.step_invar)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> wa_initial WAC \\<Longrightarrow> x \\<in> wa_invar WAC\n 2. wf {(s', s).\n        s \\<in> wa_invar WAC \\<and>\n        s \\<in> wa_cond WAC \\<and> (s, s') \\<in> wa_step WAC}", "apply (simp add: icf)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> wa_initial WAC \\<Longrightarrow>\n       x \\<in> addi \\<and> \\<alpha> x \\<in> wa_invar WAA\n 2. wf {(s', s).\n        s \\<in> wa_invar WAC \\<and>\n        s \\<in> wa_cond WAC \\<and> (s, s') \\<in> wa_step WAC}", "apply (rule conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x. x \\<in> wa_initial WAC \\<Longrightarrow> x \\<in> addi\n 2. \\<And>x.\n       x \\<in> wa_initial WAC \\<Longrightarrow>\n       \\<alpha> x \\<in> wa_invar WAA\n 3. wf {(s', s).\n        s \\<in> wa_invar WAC \\<and>\n        s \\<in> wa_cond WAC \\<and> (s, s') \\<in> wa_step WAC}", "apply (erule rev_subsetD[OF _ initial_addi])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> wa_initial WAC \\<Longrightarrow>\n       \\<alpha> x \\<in> wa_invar WAA\n 2. wf {(s', s).\n        s \\<in> wa_invar WAC \\<and>\n        s \\<in> wa_cond WAC \\<and> (s, s') \\<in> wa_step WAC}", "apply (insert initial_abs waa.initial_invar) [1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> wa_initial WAC;\n        \\<alpha> ` wa_initial WAC \\<subseteq> wa_initial WAA;\n        wa_initial WAA \\<subseteq> wa_invar WAA\\<rbrakk>\n       \\<Longrightarrow> \\<alpha> x \\<in> wa_invar WAA\n 2. wf {(s', s).\n        s \\<in> wa_invar WAC \\<and>\n        s \\<in> wa_cond WAC \\<and> (s, s') \\<in> wa_step WAC}", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf {(s', s).\n        s \\<in> wa_invar WAC \\<and>\n        s \\<in> wa_cond WAC \\<and> (s, s') \\<in> wa_step WAC}", "apply (rule_tac \n      r=\"inv_image { (s',s). s\\<in>wa_invar WAA \n                    \\<and> s\\<in>wa_cond WAA \n                    \\<and> (s,s')\\<in>wa_step WAA } \\<alpha>\" \n      in wf_subset)"], ["proof (prove)\ngoal (2 subgoals):\n 1. wf (inv_image\n         {(s', s).\n          s \\<in> wa_invar WAA \\<and>\n          s \\<in> wa_cond WAA \\<and> (s, s') \\<in> wa_step WAA}\n         \\<alpha>)\n 2. {(s', s).\n     s \\<in> wa_invar WAC \\<and>\n     s \\<in> wa_cond WAC \\<and> (s, s') \\<in> wa_step WAC}\n    \\<subseteq> inv_image\n                 {(s', s).\n                  s \\<in> wa_invar WAA \\<and>\n                  s \\<in> wa_cond WAA \\<and> (s, s') \\<in> wa_step WAA}\n                 \\<alpha>", "apply (simp add: waa.step_wf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(s', s).\n     s \\<in> wa_invar WAC \\<and>\n     s \\<in> wa_cond WAC \\<and> (s, s') \\<in> wa_step WAC}\n    \\<subseteq> inv_image\n                 {(s', s).\n                  s \\<in> wa_invar WAA \\<and>\n                  s \\<in> wa_cond WAA \\<and> (s, s') \\<in> wa_step WAA}\n                 \\<alpha>", "apply (auto simp add: cond_abs step_abs icf) [1]"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  while_algo WAC\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  A special case of refinement occurs, if the concrete condition implements the\n  abstract condition precisely. In this case, the concrete algorithm will run \n  as long as the abstract one that it is simulated by. This allows to \n  transfer properties of the result from the abstract algorithm to the \n  concrete one.\n\\<close>\n\n\\<comment> \\<open>Precise refinement\\<close>"], ["", "locale wa_precise_refine = wa_refine +\n  constrains \\<alpha> :: \"'C \\<Rightarrow> 'A\"\n  assumes cond_precise: \n    \"\\<forall>s. s\\<in>wa_invar WAC \\<and> \\<alpha> s\\<in>wa_cond WAA \\<longrightarrow> s\\<in>wa_cond WAC\"\nbegin\n  \\<comment> \\<open>Transfer correctness property\\<close>"], ["", "lemma transfer_correctness:\n    assumes A: \"\\<forall>s. s\\<in>wa_invar WAA \\<and> s\\<notin>wa_cond WAA \\<longrightarrow> P s\"\n    shows \"\\<forall>sc. sc\\<in>wa_invar WAC \\<and> sc\\<notin>wa_cond WAC \\<longrightarrow> P (\\<alpha> sc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>sc.\n       sc \\<in> wa_invar WAC \\<and>\n       sc \\<notin> wa_cond WAC \\<longrightarrow>\n       P (\\<alpha> sc)", "using A cond_abs invar_abs cond_precise"], ["proof (prove)\nusing this:\n  \\<forall>s.\n     s \\<in> wa_invar WAA \\<and> s \\<notin> wa_cond WAA \\<longrightarrow>\n     P s\n  \\<lbrakk>?s \\<in> wa_invar WAC; ?s \\<in> wa_cond WAC\\<rbrakk>\n  \\<Longrightarrow> \\<alpha> ?s \\<in> wa_cond WAA\n  \\<alpha> ` wa_invar WAC \\<subseteq> wa_invar WAA\n  \\<forall>s.\n     s \\<in> wa_invar WAC \\<and>\n     \\<alpha> s \\<in> wa_cond WAA \\<longrightarrow>\n     s \\<in> wa_cond WAC\n\ngoal (1 subgoal):\n 1. \\<forall>sc.\n       sc \\<in> wa_invar WAC \\<and>\n       sc \\<notin> wa_cond WAC \\<longrightarrow>\n       P (\\<alpha> sc)", "by blast"], ["", "end"], ["", "text \\<open>Refinement as well as precise refinement is reflexive and transitive\\<close>"], ["", "lemma wa_ref_refl: \"wa_refine WA WA id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wa_refine WA WA id", "by (unfold_locales) auto"], ["", "lemma wa_pref_refl: \"wa_precise_refine WA WA id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wa_precise_refine WA WA id", "by (unfold_locales) auto"], ["", "lemma wa_ref_trans: \n  assumes \"wa_refine WC WB \\<alpha>1\"\n  assumes \"wa_refine WB WA \\<alpha>2\"\n  shows \"wa_refine WC WA (\\<alpha>2\\<circ>\\<alpha>1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wa_refine WC WA (\\<alpha>2 \\<circ> \\<alpha>1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wa_refine WC WA (\\<alpha>2 \\<circ> \\<alpha>1)", "interpret r1: wa_refine WC WB \\<alpha>1"], ["proof (prove)\ngoal (1 subgoal):\n 1. wa_refine WC WB \\<alpha>1", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. wa_refine WC WA (\\<alpha>2 \\<circ> \\<alpha>1)", "interpret r2: wa_refine WB WA \\<alpha>2"], ["proof (prove)\ngoal (1 subgoal):\n 1. wa_refine WB WA \\<alpha>2", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. wa_refine WC WA (\\<alpha>2 \\<circ> \\<alpha>1)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. wa_refine WC WA (\\<alpha>2 \\<circ> \\<alpha>1)", "(* Cool, everything by auto! *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wa_refine WC WA (\\<alpha>2 \\<circ> \\<alpha>1)", "apply unfold_locales"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> wa_invar WC; s \\<in> wa_cond WC\\<rbrakk>\n       \\<Longrightarrow> (\\<alpha>2 \\<circ> \\<alpha>1) s \\<in> wa_cond WA\n 2. \\<And>s s'.\n       \\<lbrakk>s \\<in> wa_invar WC; s \\<in> wa_cond WC;\n        (s, s') \\<in> wa_step WC\\<rbrakk>\n       \\<Longrightarrow> ((\\<alpha>2 \\<circ> \\<alpha>1) s,\n                          (\\<alpha>2 \\<circ> \\<alpha>1) s')\n                         \\<in> wa_step WA\n 3. (\\<alpha>2 \\<circ> \\<alpha>1) ` wa_initial WC \\<subseteq> wa_initial WA\n 4. (\\<alpha>2 \\<circ> \\<alpha>1) ` wa_invar WC \\<subseteq> wa_invar WA", "apply (auto simp add: \n      r1.invar_abs' r2.invar_abs'\n      r1.cond_abs r2.cond_abs\n      r1.step_abs r2.step_abs\n      r1.initial_abs' r2.initial_abs')"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  wa_refine WC WA (\\<alpha>2 \\<circ> \\<alpha>1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wa_pref_trans: \n  assumes \"wa_precise_refine WC WB \\<alpha>1\"\n  assumes \"wa_precise_refine WB WA \\<alpha>2\"\n  shows \"wa_precise_refine WC WA (\\<alpha>2\\<circ>\\<alpha>1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wa_precise_refine WC WA (\\<alpha>2 \\<circ> \\<alpha>1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wa_precise_refine WC WA (\\<alpha>2 \\<circ> \\<alpha>1)", "interpret r1: wa_precise_refine WC WB \\<alpha>1"], ["proof (prove)\ngoal (1 subgoal):\n 1. wa_precise_refine WC WB \\<alpha>1", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. wa_precise_refine WC WA (\\<alpha>2 \\<circ> \\<alpha>1)", "interpret r2: wa_precise_refine WB WA \\<alpha>2"], ["proof (prove)\ngoal (1 subgoal):\n 1. wa_precise_refine WB WA \\<alpha>2", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. wa_precise_refine WC WA (\\<alpha>2 \\<circ> \\<alpha>1)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. wa_precise_refine WC WA (\\<alpha>2 \\<circ> \\<alpha>1)", "apply intro_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. wa_refine WC WA (\\<alpha>2 \\<circ> \\<alpha>1)\n 2. wa_precise_refine_axioms WC WA (\\<alpha>2 \\<circ> \\<alpha>1)", "apply (rule wa_ref_trans)"], ["proof (prove)\ngoal (3 subgoals):\n 1. wa_refine WC ?WB1 \\<alpha>1\n 2. wa_refine ?WB1 WA \\<alpha>2\n 3. wa_precise_refine_axioms WC WA (\\<alpha>2 \\<circ> \\<alpha>1)", "apply (unfold_locales)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s.\n       s \\<in> wa_invar WC \\<and>\n       (\\<alpha>2 \\<circ> \\<alpha>1) s \\<in> wa_cond WA \\<longrightarrow>\n       s \\<in> wa_cond WC", "apply (auto simp add: r1.invar_abs' r2.invar_abs' \n                          r1.cond_precise r2.cond_precise)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  wa_precise_refine WC WA (\\<alpha>2 \\<circ> \\<alpha>1)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  A well-defined while-algorithm is {\\em deterministic}, iff\n  the step relation is a function and there is just one \n  initial state. Such an algorithm is suitable for direct implementation \n  by the while-combinator.\n\n  For deterministic while-algorithm, an own record is defined, as well as a\n  function that maps it to the corresponding record for non-deterministic\n  while algorithms. This makes sense as the step-relation may then be modeled\n  as a function, and the initial state may be modeled as a single state rather \n  than a (singleton) set of states.\n\\<close>"], ["", "record 'S det_while_algo =\n  \\<comment> \\<open>Termination condition\\<close>\n  dwa_cond :: \"'S \\<Rightarrow> bool\"\n  \\<comment> \\<open>Step function\\<close>\n  dwa_step :: \"'S \\<Rightarrow> 'S\"\n  \\<comment> \\<open>Initial state\\<close>\n  dwa_initial :: \"'S\"\n  \\<comment> \\<open>Invariant\\<close>\n  dwa_invar :: \"'S set\"\n  \n  \\<comment> \\<open>Maps the record for deterministic while-algo to the corresponding record for\n      the non-deterministic one\\<close>"], ["", "definition \"det_wa_wa DWA == \\<lparr> \n  wa_cond={s. dwa_cond DWA s}, \n  wa_step={(s,dwa_step DWA s) | s. True}, \n  wa_initial={dwa_initial DWA},\n  wa_invar = dwa_invar DWA\\<rparr>\"\n\n  \\<comment> \\<open>Conditions for a deterministic while-algorithm\\<close>"], ["", "locale det_while_algo = \n  fixes WA :: \"'S det_while_algo\"\n  \\<comment> \\<open>The step preserves the invariant\\<close>\n  assumes step_invar: \n    \"\\<lbrakk> s\\<in>dwa_invar WA; dwa_cond WA s \\<rbrakk> \\<Longrightarrow> dwa_step WA s \\<in> dwa_invar WA\"\n  \\<comment> \\<open>The initial state satisfies the invariant\\<close>\n  assumes initial_invar: \"dwa_initial WA \\<in> dwa_invar WA\"\n  \\<comment> \\<open>The relation made up by the step-function is well-founded.\\<close>\n  assumes step_wf: \n    \"wf { (dwa_step WA s,s) | s. s\\<in>dwa_invar WA \\<and> dwa_cond WA s }\"\n\nbegin"], ["", "lemma is_while_algo: \"while_algo (det_wa_wa WA)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. while_algo (det_wa_wa WA)", "apply (unfold_locales)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>s \\<in> wa_invar (det_wa_wa WA);\n        s \\<in> wa_cond (det_wa_wa WA);\n        (s, s') \\<in> wa_step (det_wa_wa WA)\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> wa_invar (det_wa_wa WA)\n 2. wa_initial (det_wa_wa WA) \\<subseteq> wa_invar (det_wa_wa WA)\n 3. wf {(s', s).\n        s \\<in> wa_invar (det_wa_wa WA) \\<and>\n        s \\<in> wa_cond (det_wa_wa WA) \\<and>\n        (s, s') \\<in> wa_step (det_wa_wa WA)}", "apply (auto simp add: det_wa_wa_def step_invar initial_invar)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf {(s', s).\n        s \\<in> dwa_invar WA \\<and> dwa_cond WA s \\<and> s' = dwa_step WA s}", "apply (insert step_wf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf {(dwa_step WA s, s) |s.\n        s \\<in> dwa_invar WA \\<and> dwa_cond WA s} \\<Longrightarrow>\n    wf {(s', s).\n        s \\<in> dwa_invar WA \\<and> dwa_cond WA s \\<and> s' = dwa_step WA s}", "apply (erule_tac P=wf in back_subst)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(dwa_step WA s, s) |s. s \\<in> dwa_invar WA \\<and> dwa_cond WA s} =\n    {(s', s).\n     s \\<in> dwa_invar WA \\<and> dwa_cond WA s \\<and> s' = dwa_step WA s}", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "lemma det_while_algo_intro:\n  assumes \"while_algo (det_wa_wa DWA)\" \n  shows \"det_while_algo DWA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. det_while_algo DWA", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. det_while_algo DWA", "interpret while_algo \"(det_wa_wa DWA)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. while_algo (det_wa_wa DWA)", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. det_while_algo DWA", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. det_while_algo DWA", "using step_invar initial_invar step_wf"], ["proof (prove)\nusing this:\n  \\<lbrakk>?s \\<in> wa_invar (det_wa_wa DWA);\n   ?s \\<in> wa_cond (det_wa_wa DWA);\n   (?s, ?s') \\<in> wa_step (det_wa_wa DWA)\\<rbrakk>\n  \\<Longrightarrow> ?s' \\<in> wa_invar (det_wa_wa DWA)\n  wa_initial (det_wa_wa DWA) \\<subseteq> wa_invar (det_wa_wa DWA)\n  wf {(s', s).\n      s \\<in> wa_invar (det_wa_wa DWA) \\<and>\n      s \\<in> wa_cond (det_wa_wa DWA) \\<and>\n      (s, s') \\<in> wa_step (det_wa_wa DWA)}\n\ngoal (1 subgoal):\n 1. det_while_algo DWA", "apply (unfold_locales)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>\\<And>s s'.\n                   \\<lbrakk>s \\<in> wa_invar (det_wa_wa DWA);\n                    s \\<in> wa_cond (det_wa_wa DWA);\n                    (s, s') \\<in> wa_step (det_wa_wa DWA)\\<rbrakk>\n                   \\<Longrightarrow> s' \\<in> wa_invar (det_wa_wa DWA);\n        wa_initial (det_wa_wa DWA) \\<subseteq> wa_invar (det_wa_wa DWA);\n        wf {(s', s).\n            s \\<in> wa_invar (det_wa_wa DWA) \\<and>\n            s \\<in> wa_cond (det_wa_wa DWA) \\<and>\n            (s, s') \\<in> wa_step (det_wa_wa DWA)};\n        s \\<in> dwa_invar DWA; dwa_cond DWA s\\<rbrakk>\n       \\<Longrightarrow> dwa_step DWA s \\<in> dwa_invar DWA\n 2. \\<lbrakk>\\<And>s s'.\n                \\<lbrakk>s \\<in> wa_invar (det_wa_wa DWA);\n                 s \\<in> wa_cond (det_wa_wa DWA);\n                 (s, s') \\<in> wa_step (det_wa_wa DWA)\\<rbrakk>\n                \\<Longrightarrow> s' \\<in> wa_invar (det_wa_wa DWA);\n     wa_initial (det_wa_wa DWA) \\<subseteq> wa_invar (det_wa_wa DWA);\n     wf {(s', s).\n         s \\<in> wa_invar (det_wa_wa DWA) \\<and>\n         s \\<in> wa_cond (det_wa_wa DWA) \\<and>\n         (s, s') \\<in> wa_step (det_wa_wa DWA)}\\<rbrakk>\n    \\<Longrightarrow> dwa_initial DWA \\<in> dwa_invar DWA\n 3. \\<lbrakk>\\<And>s s'.\n                \\<lbrakk>s \\<in> wa_invar (det_wa_wa DWA);\n                 s \\<in> wa_cond (det_wa_wa DWA);\n                 (s, s') \\<in> wa_step (det_wa_wa DWA)\\<rbrakk>\n                \\<Longrightarrow> s' \\<in> wa_invar (det_wa_wa DWA);\n     wa_initial (det_wa_wa DWA) \\<subseteq> wa_invar (det_wa_wa DWA);\n     wf {(s', s).\n         s \\<in> wa_invar (det_wa_wa DWA) \\<and>\n         s \\<in> wa_cond (det_wa_wa DWA) \\<and>\n         (s, s') \\<in> wa_step (det_wa_wa DWA)}\\<rbrakk>\n    \\<Longrightarrow> wf {(dwa_step DWA s, s) |s.\n                          s \\<in> dwa_invar DWA \\<and> dwa_cond DWA s}", "apply (unfold det_wa_wa_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>\\<And>s s'.\n                   \\<lbrakk>s \\<in> wa_invar\n                                     \\<lparr>wa_cond = {s. dwa_cond DWA s},\n  wa_step = {(s, dwa_step DWA s) |s. True}, wa_initial = {dwa_initial DWA},\n  wa_invar = dwa_invar DWA\\<rparr>;\n                    s \\<in> wa_cond\n                             \\<lparr>wa_cond = {s. dwa_cond DWA s},\n                                wa_step = {(s, dwa_step DWA s) |s. True},\n                                wa_initial = {dwa_initial DWA},\n                                wa_invar = dwa_invar DWA\\<rparr>;\n                    (s, s')\n                    \\<in> wa_step\n                           \\<lparr>wa_cond = {s. dwa_cond DWA s},\n                              wa_step = {(s, dwa_step DWA s) |s. True},\n                              wa_initial = {dwa_initial DWA},\n                              wa_invar = dwa_invar DWA\\<rparr>\\<rbrakk>\n                   \\<Longrightarrow> s' \\<in> wa_invar\n         \\<lparr>wa_cond = {s. dwa_cond DWA s},\n            wa_step = {(s, dwa_step DWA s) |s. True},\n            wa_initial = {dwa_initial DWA},\n            wa_invar = dwa_invar DWA\\<rparr>;\n        wa_initial\n         \\<lparr>wa_cond = {s. dwa_cond DWA s},\n            wa_step = {(s, dwa_step DWA s) |s. True},\n            wa_initial = {dwa_initial DWA}, wa_invar = dwa_invar DWA\\<rparr>\n        \\<subseteq> wa_invar\n                     \\<lparr>wa_cond = {s. dwa_cond DWA s},\n                        wa_step = {(s, dwa_step DWA s) |s. True},\n                        wa_initial = {dwa_initial DWA},\n                        wa_invar = dwa_invar DWA\\<rparr>;\n        wf {(s', s).\n            s \\<in> wa_invar\n                     \\<lparr>wa_cond = {s. dwa_cond DWA s},\n                        wa_step = {(s, dwa_step DWA s) |s. True},\n                        wa_initial = {dwa_initial DWA},\n                        wa_invar = dwa_invar DWA\\<rparr> \\<and>\n            s \\<in> wa_cond\n                     \\<lparr>wa_cond = {s. dwa_cond DWA s},\n                        wa_step = {(s, dwa_step DWA s) |s. True},\n                        wa_initial = {dwa_initial DWA},\n                        wa_invar = dwa_invar DWA\\<rparr> \\<and>\n            (s, s')\n            \\<in> wa_step\n                   \\<lparr>wa_cond = {s. dwa_cond DWA s},\n                      wa_step = {(s, dwa_step DWA s) |s. True},\n                      wa_initial = {dwa_initial DWA},\n                      wa_invar = dwa_invar DWA\\<rparr>};\n        s \\<in> dwa_invar DWA; dwa_cond DWA s\\<rbrakk>\n       \\<Longrightarrow> dwa_step DWA s \\<in> dwa_invar DWA\n 2. \\<lbrakk>\\<And>s s'.\n                \\<lbrakk>s \\<in> wa_invar\n                                  \\<lparr>wa_cond = {s. dwa_cond DWA s},\n                                     wa_step =\n {(s, dwa_step DWA s) |s. True},\n                                     wa_initial = {dwa_initial DWA},\n                                     wa_invar = dwa_invar DWA\\<rparr>;\n                 s \\<in> wa_cond\n                          \\<lparr>wa_cond = {s. dwa_cond DWA s},\n                             wa_step = {(s, dwa_step DWA s) |s. True},\n                             wa_initial = {dwa_initial DWA},\n                             wa_invar = dwa_invar DWA\\<rparr>;\n                 (s, s')\n                 \\<in> wa_step\n                        \\<lparr>wa_cond = {s. dwa_cond DWA s},\n                           wa_step = {(s, dwa_step DWA s) |s. True},\n                           wa_initial = {dwa_initial DWA},\n                           wa_invar = dwa_invar DWA\\<rparr>\\<rbrakk>\n                \\<Longrightarrow> s' \\<in> wa_invar\n      \\<lparr>wa_cond = {s. dwa_cond DWA s},\n         wa_step = {(s, dwa_step DWA s) |s. True},\n         wa_initial = {dwa_initial DWA}, wa_invar = dwa_invar DWA\\<rparr>;\n     wa_initial\n      \\<lparr>wa_cond = {s. dwa_cond DWA s},\n         wa_step = {(s, dwa_step DWA s) |s. True},\n         wa_initial = {dwa_initial DWA}, wa_invar = dwa_invar DWA\\<rparr>\n     \\<subseteq> wa_invar\n                  \\<lparr>wa_cond = {s. dwa_cond DWA s},\n                     wa_step = {(s, dwa_step DWA s) |s. True},\n                     wa_initial = {dwa_initial DWA},\n                     wa_invar = dwa_invar DWA\\<rparr>;\n     wf {(s', s).\n         s \\<in> wa_invar\n                  \\<lparr>wa_cond = {s. dwa_cond DWA s},\n                     wa_step = {(s, dwa_step DWA s) |s. True},\n                     wa_initial = {dwa_initial DWA},\n                     wa_invar = dwa_invar DWA\\<rparr> \\<and>\n         s \\<in> wa_cond\n                  \\<lparr>wa_cond = {s. dwa_cond DWA s},\n                     wa_step = {(s, dwa_step DWA s) |s. True},\n                     wa_initial = {dwa_initial DWA},\n                     wa_invar = dwa_invar DWA\\<rparr> \\<and>\n         (s, s')\n         \\<in> wa_step\n                \\<lparr>wa_cond = {s. dwa_cond DWA s},\n                   wa_step = {(s, dwa_step DWA s) |s. True},\n                   wa_initial = {dwa_initial DWA},\n                   wa_invar = dwa_invar DWA\\<rparr>}\\<rbrakk>\n    \\<Longrightarrow> dwa_initial DWA \\<in> dwa_invar DWA\n 3. \\<lbrakk>\\<And>s s'.\n                \\<lbrakk>s \\<in> wa_invar\n                                  \\<lparr>wa_cond = {s. dwa_cond DWA s},\n                                     wa_step =\n {(s, dwa_step DWA s) |s. True},\n                                     wa_initial = {dwa_initial DWA},\n                                     wa_invar = dwa_invar DWA\\<rparr>;\n                 s \\<in> wa_cond\n                          \\<lparr>wa_cond = {s. dwa_cond DWA s},\n                             wa_step = {(s, dwa_step DWA s) |s. True},\n                             wa_initial = {dwa_initial DWA},\n                             wa_invar = dwa_invar DWA\\<rparr>;\n                 (s, s')\n                 \\<in> wa_step\n                        \\<lparr>wa_cond = {s. dwa_cond DWA s},\n                           wa_step = {(s, dwa_step DWA s) |s. True},\n                           wa_initial = {dwa_initial DWA},\n                           wa_invar = dwa_invar DWA\\<rparr>\\<rbrakk>\n                \\<Longrightarrow> s' \\<in> wa_invar\n      \\<lparr>wa_cond = {s. dwa_cond DWA s},\n         wa_step = {(s, dwa_step DWA s) |s. True},\n         wa_initial = {dwa_initial DWA}, wa_invar = dwa_invar DWA\\<rparr>;\n     wa_initial\n      \\<lparr>wa_cond = {s. dwa_cond DWA s},\n         wa_step = {(s, dwa_step DWA s) |s. True},\n         wa_initial = {dwa_initial DWA}, wa_invar = dwa_invar DWA\\<rparr>\n     \\<subseteq> wa_invar\n                  \\<lparr>wa_cond = {s. dwa_cond DWA s},\n                     wa_step = {(s, dwa_step DWA s) |s. True},\n                     wa_initial = {dwa_initial DWA},\n                     wa_invar = dwa_invar DWA\\<rparr>;\n     wf {(s', s).\n         s \\<in> wa_invar\n                  \\<lparr>wa_cond = {s. dwa_cond DWA s},\n                     wa_step = {(s, dwa_step DWA s) |s. True},\n                     wa_initial = {dwa_initial DWA},\n                     wa_invar = dwa_invar DWA\\<rparr> \\<and>\n         s \\<in> wa_cond\n                  \\<lparr>wa_cond = {s. dwa_cond DWA s},\n                     wa_step = {(s, dwa_step DWA s) |s. True},\n                     wa_initial = {dwa_initial DWA},\n                     wa_invar = dwa_invar DWA\\<rparr> \\<and>\n         (s, s')\n         \\<in> wa_step\n                \\<lparr>wa_cond = {s. dwa_cond DWA s},\n                   wa_step = {(s, dwa_step DWA s) |s. True},\n                   wa_initial = {dwa_initial DWA},\n                   wa_invar = dwa_invar DWA\\<rparr>}\\<rbrakk>\n    \\<Longrightarrow> wf {(dwa_step DWA s, s) |s.\n                          s \\<in> dwa_invar DWA \\<and> dwa_cond DWA s}", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>s s'.\n                \\<lbrakk>s \\<in> dwa_invar DWA; dwa_cond DWA s;\n                 s' = dwa_step DWA s\\<rbrakk>\n                \\<Longrightarrow> dwa_step DWA s \\<in> dwa_invar DWA;\n     dwa_initial DWA \\<in> dwa_invar DWA;\n     wf {(s', s).\n         s \\<in> dwa_invar DWA \\<and>\n         dwa_cond DWA s \\<and> s' = dwa_step DWA s}\\<rbrakk>\n    \\<Longrightarrow> wf {(dwa_step DWA s, s) |s.\n                          s \\<in> dwa_invar DWA \\<and> dwa_cond DWA s}", "apply (erule_tac P=wf in back_subst)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>s s'.\n                \\<lbrakk>s \\<in> dwa_invar DWA; dwa_cond DWA s;\n                 s' = dwa_step DWA s\\<rbrakk>\n                \\<Longrightarrow> dwa_step DWA s \\<in> dwa_invar DWA;\n     dwa_initial DWA \\<in> dwa_invar DWA\\<rbrakk>\n    \\<Longrightarrow> {(s', s).\n                       s \\<in> dwa_invar DWA \\<and>\n                       dwa_cond DWA s \\<and> s' = dwa_step DWA s} =\n                      {(dwa_step DWA s, s) |s.\n                       s \\<in> dwa_invar DWA \\<and> dwa_cond DWA s}", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  det_while_algo DWA\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open>A deterministic while-algorithm is well-defined, if and only if the \n    corresponding non-deterministic while-algorithm is well-defined\\<close>"], ["", "theorem dwa_is_wa: \n  \"while_algo (det_wa_wa DWA) \\<longleftrightarrow> det_while_algo DWA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. while_algo (det_wa_wa DWA) = det_while_algo DWA", "using det_while_algo_intro det_while_algo.is_while_algo"], ["proof (prove)\nusing this:\n  while_algo (det_wa_wa ?DWA) \\<Longrightarrow> det_while_algo ?DWA\n  det_while_algo ?WA \\<Longrightarrow> while_algo (det_wa_wa ?WA)\n\ngoal (1 subgoal):\n 1. while_algo (det_wa_wa DWA) = det_while_algo DWA", "by auto"], ["", "definition (in det_while_algo) \n  \"loop == (while (dwa_cond WA) (dwa_step WA) (dwa_initial WA))\"\n\n\\<comment> \\<open>Proof rule for deterministic while loops\\<close>"], ["", "lemma (in det_while_algo) while_proof:\n  assumes inv_imp: \"\\<And>s. \\<lbrakk>s\\<in>dwa_invar WA; \\<not> dwa_cond WA s\\<rbrakk> \\<Longrightarrow> Q s\"\n  shows \"Q loop\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q loop", "apply (unfold loop_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Q (while (dwa_cond WA) (dwa_step WA) (dwa_initial WA))", "apply (rule_tac P=\"\\<lambda>x. x\\<in>dwa_invar WA\" and \n                  r=\"{ (dwa_step WA s,s) | s. s\\<in>dwa_invar WA \\<and> dwa_cond WA s }\" \n                  in while_rule)"], ["proof (prove)\ngoal (5 subgoals):\n 1. dwa_initial WA \\<in> dwa_invar WA\n 2. \\<And>s.\n       \\<lbrakk>s \\<in> dwa_invar WA; dwa_cond WA s\\<rbrakk>\n       \\<Longrightarrow> dwa_step WA s \\<in> dwa_invar WA\n 3. \\<And>s.\n       \\<lbrakk>s \\<in> dwa_invar WA; \\<not> dwa_cond WA s\\<rbrakk>\n       \\<Longrightarrow> Q s\n 4. wf {(dwa_step WA s, s) |s. s \\<in> dwa_invar WA \\<and> dwa_cond WA s}\n 5. \\<And>s.\n       \\<lbrakk>s \\<in> dwa_invar WA; dwa_cond WA s\\<rbrakk>\n       \\<Longrightarrow> (dwa_step WA s, s)\n                         \\<in> {(dwa_step WA s, s) |s.\n                                s \\<in> dwa_invar WA \\<and> dwa_cond WA s}", "apply (simp_all add: step_invar initial_invar step_wf inv_imp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done\n\n  \\<comment> \\<open>This version is useful when using transferred correctness lemmas\\<close>"], ["", "lemma (in det_while_algo) while_proof':\n  assumes inv_imp: \n    \"\\<forall>s. s\\<in>wa_invar (det_wa_wa WA) \\<and> s\\<notin>wa_cond (det_wa_wa WA) \\<longrightarrow> Q s\"\n  shows \"Q loop\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q loop", "using inv_imp"], ["proof (prove)\nusing this:\n  \\<forall>s.\n     s \\<in> wa_invar (det_wa_wa WA) \\<and>\n     s \\<notin> wa_cond (det_wa_wa WA) \\<longrightarrow>\n     Q s\n\ngoal (1 subgoal):\n 1. Q loop", "apply (simp add: det_wa_wa_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s.\n       s \\<in> dwa_invar WA \\<and> \\<not> dwa_cond WA s \\<longrightarrow>\n       Q s \\<Longrightarrow>\n    Q loop", "apply (blast intro: while_proof)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in det_while_algo) loop_invar:\n  \"loop \\<in> dwa_invar WA\""], ["proof (prove)\ngoal (1 subgoal):\n 1. loop \\<in> dwa_invar WA", "by (rule while_proof) simp"], ["", "end"]]}