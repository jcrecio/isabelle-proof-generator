{"file_name": "/home/qj213/afp-2021-10-22/thys/Collections/ICF/tools/Record_Intf.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Collections", "problem_names": ["lemma icf_rec_def_rule: \"\\<lbrakk>sel B = x; A\\<equiv>B \\<rbrakk> \\<Longrightarrow> sel A = x \""], "translations": [["", "lemma icf_rec_def_rule: \"\\<lbrakk>sel B = x; A\\<equiv>B \\<rbrakk> \\<Longrightarrow> sel A = x \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sel B = x; A \\<equiv> B\\<rbrakk> \\<Longrightarrow> sel A = x", "by auto"], ["", "ML_val Context.mapping"], ["", "ML \\<open>\nsignature RECORD_INTF = sig\n  val get_unf_ss: Context.generic -> simpset\n  val get_unf_thms: Context.generic -> thm list\n\n  val add_unf_thms: thm list -> Context.generic -> Context.generic\n  val add_unf_thms_global: thm list -> theory -> theory\n\n  val icf_rec_def: thm -> Context.generic -> Context.generic\n  val icf_rec_def_attr: attribute context_parser\n\n  val icf_locales_tac: Proof.context -> tactic\n\n  val setup: theory -> theory\nend;\n\nstructure Record_Intf: RECORD_INTF = struct\n  open ICF_Tools;\n\n  structure Data = Generic_Data\n  (\n    type T = simpset;\n    val empty = HOL_basic_ss (*addsimprocs \n      [Record.simproc, Record.upd_simproc]*);\n    val extend = I;\n    val merge = Raw_Simplifier.merge_ss;\n  );\n\n  structure CppSS = Oc_Simpset (\n    val prio = 2;\n    val name = \"Record_Intf\";\n  );\n\n  fun get_unf_ss context = Data.get context\n  val get_unf_thms = Data.get #> Raw_Simplifier.dest_ss #> #simps #> map #2\n\n  fun add_unf_thms thms context = let\n    val ctxt = Context.proof_of context\n    fun add ss = simpset_of (put_simpset ss ctxt addsimps thms)\n  in\n    context \n    |> Data.map add\n    |> Context.mapping (CppSS.map add) I\n  end\n\n  fun add_unf_thms_global thms = Context.theory_map (add_unf_thms thms);\n  \n  (* Gather select_conv-, defs- and simps-theorems for given type *)\n  fun gather_conv_thms ctxt typ = let\n    val thy = Proof_Context.theory_of ctxt\n    val infos = Record.dest_recTs typ \n      |> map fst |> map Long_Name.qualifier |> map (Record.the_info thy);\n    val cs = map #select_convs infos |> flat |> map (Thm.transfer thy);\n    val ds = map #defs infos @ map #simps infos |> flat \n      |> map (Thm.transfer thy);\n  in (cs,ds) end\n\n  (* Gather select_conv theorems type of constant defined by def_thm *)\n  fun gather_conv_thms_dt ctxt def_thm =\n    def_thm |> Thm.prop_of |> Logic.dest_equals |> fst \n    |> fastype_of |> gather_conv_thms ctxt;\n\n  (* Generate code-unfold theorems for definition\n    and remove definition from\n    code equations. *)\n\n  local\n    fun unf_thms_of def_thm context = let\n      val ctxt = Context.proof_of context;\n      \n      val def_thm = norm_def_thm def_thm;\n\n      val (conv_thms, simp_thms) = gather_conv_thms_dt ctxt def_thm;\n      val ss = put_simpset (get_unf_ss context) ctxt addsimps simp_thms\n      (*val simp_thms = icf_rec_unf.get ctxt @ simp_thms;*)\n\n      val unf_thms = conv_thms \n        |> map (\n          chead_of_thm \n          #> inst_meta_cong ctxt\n          #> (fn thm => thm OF [def_thm])\n          #> simplify ss\n        )\n        |> filter (not o Thm.is_reflexive);\n\n    in unf_thms end;\n\n  in\n    fun icf_rec_def def_thm context =\n      let\n        val unf_thms = unf_thms_of def_thm context;\n        val eqn_heads = the_list (try (fst o dest_Const o fst o strip_comb o fst o Logic.dest_equals\n          o Thm.plain_prop_of o Local_Defs.meta_rewrite_rule (Context.proof_of context)) def_thm)\n      in\n        context\n        |> add_unf_thms unf_thms \n        |> not (null eqn_heads) ? Context.mapping (fold Code.declare_aborting_global eqn_heads) I\n      end;\n  \n  end\n\n  val icf_rec_def_attr : attribute context_parser = \n    Scan.succeed (Thm.declaration_attribute icf_rec_def);\n\n\n  fun icf_locales_tac ctxt = let\n    val ss = put_simpset (get_unf_ss (Context.Proof ctxt)) ctxt\n    val wits = Locale.get_witnesses ctxt\n    val thms = map (simplify ss) wits;\n  in ALLGOALS (TRY o (simp_tac ss THEN' resolve_tac ctxt thms)) end\n\n\n  fun setup_simprocs thy = let\n    val ctxt = Proof_Context.init_global thy\n    val ss = put_simpset HOL_basic_ss ctxt\n      addsimprocs [Record.simproc, Record.upd_simproc]\n      |> simpset_of\n\n  in\n    Data.map (K ss) (Context.Theory thy) |> Context.the_theory\n  end\n\n\n  val setup = Global_Theory.add_thms_dynamic \n    (@{binding icf_rec_unf}, get_unf_thms)\n  #> CppSS.setup\n  #> setup_simprocs;\n\n\nend;\n\\<close>"], ["", "setup \\<open>Record_Intf.setup\\<close>"], ["", "text \\<open>\n  Sets up unfolding for an operation record definition.\n  New operation record definitions should be declared as \n  \\<open>[icf_rec_def]\\<close>.\n\\<close>"], ["", "attribute_setup icf_rec_def = \\<open>Record_Intf.icf_rec_def_attr\\<close> \n  \"ICF: Setup unfolding for record definition\""], ["", "method_setup icf_locales = \\<open>\n  Scan.succeed (fn ctxt => SIMPLE_METHOD (Record_Intf.icf_locales_tac ctxt))\n\\<close> \"ICF: Normalize records and discharge locale subgoals\""], ["", "end"]]}