{"file_name": "/home/qj213/afp-2021-10-22/thys/Collections/GenCF/Impl/Impl_Uv_Set.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Collections", "problem_names": ["lemma lookup_append[simp]: \"lookup n (w1@w2 :: 'a::len word list)\n    \\<longleftrightarrow> (\n      if n < LENGTH('a) * length w1 then\n        lookup n w1\n      else lookup (n - LENGTH('a) * length w1) w2)\"", "lemma lookup_zeroes[simp]: \"lookup i (replicate n (0::'a::len word)) = False\"", "lemma lookup_out_of_bound:\n    fixes uv :: \"'a::len word list\"\n    assumes \"\\<not> i < LENGTH('a::len) * length uv\"\n    shows \"\\<not> lookup i uv\"", "lemma lookup_single_bit[simp]: \"lookup i ((single_bit n)::'a::len word list) \\<longleftrightarrow> i = n\"", "lemma set_bit_lookup[simp]: \"lookup i (set_bit j ws) \\<longleftrightarrow> (lookup i ws \\<or> i=j)\"", "lemma reset_bit_lookup[simp]: \"lookup i (reset_bit j ws) \\<longleftrightarrow> (lookup i ws \\<and> i\\<noteq>j)\"", "lemma binary_lookup:\n    assumes \"is_strict_bin_op_impl f g\"\n    shows \"lookup i (binary g ws vs) \\<longleftrightarrow> f (lookup i ws) (lookup i vs)\"", "lemma memb_correct: \"lookup i ws \\<longleftrightarrow> i\\<in>\\<alpha> ws\"", "lemma empty_correct: \"\\<alpha> empty = {}\"", "lemma single_bit_correct: \"\\<alpha> (single_bit n) = {n}\"", "lemma insert_correct: \"\\<alpha> (set_bit i ws) = Set.insert i (\\<alpha> ws)\"", "lemma delete_correct: \"\\<alpha> (reset_bit i ws) = (\\<alpha> ws) - {i}\"", "lemma binary_correct:\n    assumes \"is_strict_bin_op_impl f g\"\n    shows \"\\<alpha> (binary g ws vs) = { i . f (i\\<in>\\<alpha> ws) (i\\<in>\\<alpha> vs) }\"", "lemma union_lookup[simp]:\n    fixes vs :: \"'a::len word list\"\n    shows \"lookup i (union vs ws) \\<longleftrightarrow> lookup i vs \\<or> lookup i ws\"", "lemma union_correct: \"\\<alpha> (union ws vs) = \\<alpha> ws \\<union> \\<alpha> vs\"", "lemma inter_lookup[simp]:\n    fixes vs :: \"'a::len word list\"\n    shows \"lookup i (inter vs ws) \\<longleftrightarrow> lookup i vs \\<and> lookup i ws\"", "lemma inter_correct: \"\\<alpha> (inter ws vs) = \\<alpha> ws \\<inter> \\<alpha> vs\"", "lemma diff_lookup[simp]:\n    fixes vs :: \"'a::len word list\"\n    shows \"lookup i (diff vs ws) \\<longleftrightarrow> lookup i vs - lookup i ws\"", "lemma diff_correct: \"\\<alpha> (diff ws vs) = \\<alpha> ws - \\<alpha> vs\"", "lemma zeroes_lookup: \"zeroes ws \\<longleftrightarrow> (\\<forall>i. \\<not>lookup i ws)\"", "lemma isEmpty_correct: \"zeroes ws \\<longleftrightarrow> \\<alpha> ws = {}\"", "lemma equal_lookup:\n    fixes vs ws :: \"'a::len word list\"\n    shows \"equal vs ws \\<longleftrightarrow> (\\<forall>i. lookup i vs = lookup i ws)\"", "lemma equal_correct: \"equal vs ws \\<longleftrightarrow> \\<alpha> vs = \\<alpha> ws\"", "lemma subseteq_lookup:\n    fixes vs ws :: \"'a::len word list\"\n    shows \"subseteq vs ws \\<longleftrightarrow> (\\<forall>i. lookup i vs \\<longrightarrow> lookup i ws)\"", "lemma subseteq_correct: \"subseteq vs ws \\<longleftrightarrow> \\<alpha> vs \\<subseteq> \\<alpha> ws\"", "lemma subset_lookup:\n    fixes vs ws :: \"'a::len word list\"\n    shows \"subset vs ws \\<longleftrightarrow> ((\\<forall>i. lookup i vs \\<longrightarrow> lookup i ws)\n      \\<and> (\\<exists>i. \\<not>lookup i vs \\<and> lookup i ws))\"", "lemma subset_correct: \"subset vs ws \\<longleftrightarrow> \\<alpha> vs \\<subset> \\<alpha> ws\"", "lemma disjoint_lookup:\n    fixes vs ws :: \"'a::len word list\"\n    shows \"disjoint vs ws \\<longleftrightarrow> (\\<forall>i. \\<not>(lookup i vs \\<and> lookup i ws))\"", "lemma disjoint_correct: \"disjoint vs ws \\<longleftrightarrow> \\<alpha> vs \\<inter> \\<alpha> ws = {}\"", "lemmas uv_memb_correct = memb_correct[where 'a=dflt_size, Transfer.transferred]", "lemmas uv_empty_correct = empty_correct[where 'a=dflt_size, Transfer.transferred]", "lemmas uv_single_bit_correct = single_bit_correct[where 'a=dflt_size, Transfer.transferred]", "lemmas uv_insert_correct = insert_correct[where 'a=dflt_size, Transfer.transferred]", "lemmas uv_delete_correct = delete_correct[where 'a=dflt_size, Transfer.transferred]", "lemmas uv_union_correct = union_correct[where 'a=dflt_size, Transfer.transferred]", "lemmas uv_inter_correct = inter_correct[where 'a=dflt_size, Transfer.transferred]", "lemmas uv_diff_correct = diff_correct[where 'a=dflt_size, Transfer.transferred]", "lemmas uv_isEmpty_correct = isEmpty_correct[where 'a=dflt_size, Transfer.transferred]", "lemmas uv_equal_correct = equal_correct[where 'a=dflt_size, Transfer.transferred]", "lemmas uv_subseteq_correct = subseteq_correct[where 'a=dflt_size, Transfer.transferred]", "lemmas uv_subset_correct = subset_correct[where 'a=dflt_size, Transfer.transferred]", "lemmas uv_disjoint_correct = disjoint_correct[where 'a=dflt_size, Transfer.transferred]", "lemmas [where 'a=dflt_size, Transfer.transferred, code] =\n    lookup.simps\n    empty_def\n    single_bit.simps\n    set_bit.simps\n    reset_bit.simps\n    union.simps\n    inter.simps\n    diff.simps\n    zeroes.simps\n    equal.simps\n    subseteq.simps\n    subset.simps\n    disjoint.simps", "lemma uv_set_rel_def:\n    \"\\<langle>nat_rel\\<rangle>uv_set_rel \\<equiv> br uv_\\<alpha> (\\<lambda>_. True)\"", "lemmas [autoref_rel_intf] = REL_INTFI[of \"uv_set_rel\" i_set]", "lemma uv_set_rel_sv[relator_props]: \"single_valued (\\<langle>nat_rel\\<rangle>uv_set_rel)\"", "lemma uv_autoref[autoref_rules,param]:\n    \"(uv_lookup,(\\<in>)) \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>uv_set_rel \\<rightarrow> bool_rel\"\n    \"(uv_empty,{}) \\<in> \\<langle>nat_rel\\<rangle>uv_set_rel\"\n    \"(uv_set_bit,insert) \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>uv_set_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>uv_set_rel\"\n    \"(uv_reset_bit,op_set_delete) \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>uv_set_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>uv_set_rel\"\n    \"(uv_union,(\\<union>)) \\<in> \\<langle>nat_rel\\<rangle>uv_set_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>uv_set_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>uv_set_rel\"\n    \"(uv_inter,(\\<inter>)) \\<in> \\<langle>nat_rel\\<rangle>uv_set_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>uv_set_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>uv_set_rel\"\n    \"(uv_diff,(-)) \\<in> \\<langle>nat_rel\\<rangle>uv_set_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>uv_set_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>uv_set_rel\"\n    \"(uv_zeroes,op_set_isEmpty) \\<in> \\<langle>nat_rel\\<rangle>uv_set_rel \\<rightarrow> bool_rel\"\n    \"(uv_equal,(=)) \\<in> \\<langle>nat_rel\\<rangle>uv_set_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>uv_set_rel \\<rightarrow> bool_rel\"\n    \"(uv_subseteq,(\\<subseteq>)) \\<in> \\<langle>nat_rel\\<rangle>uv_set_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>uv_set_rel \\<rightarrow> bool_rel\"\n    \"(uv_subset,(\\<subset>)) \\<in> \\<langle>nat_rel\\<rangle>uv_set_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>uv_set_rel \\<rightarrow> bool_rel\"\n    \"(uv_disjoint,op_set_disjoint) \\<in> \\<langle>nat_rel\\<rangle>uv_set_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>uv_set_rel \\<rightarrow> bool_rel\""], "translations": [["", "lemma lookup_append[simp]: \"lookup n (w1@w2 :: 'a::len word list)\n    \\<longleftrightarrow> (\n      if n < LENGTH('a) * length w1 then\n        lookup n w1\n      else lookup (n - LENGTH('a) * length w1) w2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup n (w1 @ w2) =\n    (if n < LENGTH('a) * length w1 then lookup n w1\n     else lookup (n - LENGTH('a) * length w1) w2)", "by (induction w1 arbitrary: n) auto"], ["", "lemma lookup_zeroes[simp]: \"lookup i (replicate n (0::'a::len word)) = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup i (replicate n 0) = False", "by (induction n arbitrary: i) auto"], ["", "lemma lookup_out_of_bound:\n    fixes uv :: \"'a::len word list\"\n    assumes \"\\<not> i < LENGTH('a::len) * length uv\"\n    shows \"\\<not> lookup i uv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> lookup i uv", "using assms"], ["proof (prove)\nusing this:\n  \\<not> i < LENGTH('a) * length uv\n\ngoal (1 subgoal):\n 1. \\<not> lookup i uv", "by (induction uv arbitrary: i) auto"], ["", "subsubsection \\<open>Empty\\<close>"], ["", "definition empty :: \"'a::len word list\" where \"empty = []\""], ["", "subsubsection \\<open>Set and Reset Bit\\<close>"], ["", "function single_bit :: \"nat \\<Rightarrow> ('a::len) word list\"\n    where \"single_bit n = (\n      if (n<LENGTH('a)) then\n        [set_bit 0 n True]\n      else 0#single_bit (n-LENGTH('a)))\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x. (\\<And>n. x = n \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>n na.\n       n = na \\<Longrightarrow>\n       (if n < LENGTH('a) then [set_bit_class.set_bit 0 n True]\n        else 0 # single_bit_sumC (n - LENGTH('a))) =\n       (if na < LENGTH('a) then [set_bit_class.set_bit 0 na True]\n        else 0 # single_bit_sumC (na - LENGTH('a)))", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All (single_bit_dom TYPE('a))", "apply (relation \"measure id\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. wf (measure id)\n 2. \\<And>n.\n       \\<not> n < LENGTH('a) \\<Longrightarrow>\n       (n - LENGTH('a), n) \\<in> measure id", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<not> n < LENGTH('a) \\<Longrightarrow>\n       (n - LENGTH('a), n) \\<in> measure id", "apply (simp add: not_less less_diff_conv2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "declare single_bit.simps[simp del]"], ["", "lemma lookup_single_bit[simp]: \"lookup i ((single_bit n)::'a::len word list) \\<longleftrightarrow> i = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup i (single_bit n) = (i = n)", "apply (induction n arbitrary: i rule: single_bit.induct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n i.\n       (\\<And>i.\n           \\<not> n < LENGTH(?'a2) \\<Longrightarrow>\n           lookup i (single_bit (n - LENGTH(?'a2))) =\n           (i = n - LENGTH(?'a2))) \\<Longrightarrow>\n       lookup i (single_bit n) = (i = n)", "apply (subst single_bit.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n i.\n       (\\<And>i.\n           \\<not> n < LENGTH(?'a2) \\<Longrightarrow>\n           lookup i (single_bit (n - LENGTH(?'a2))) =\n           (i = n - LENGTH(?'a2))) \\<Longrightarrow>\n       lookup i\n        (if n < LENGTH('a) then [set_bit_class.set_bit 0 n True]\n         else 0 # single_bit (n - LENGTH('a))) =\n       (i = n)", "apply (auto simp: bin_nth_sc_gen)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "primrec set_bit :: \"nat \\<Rightarrow> 'a::len word list \\<Rightarrow> 'a::len word list\" where\n    \"set_bit i [] = single_bit i\"\n  | \"set_bit i (w#ws) = (\n      if i<LENGTH('a) then\n        Bit_Operations.set_bit i w # ws\n      else\n        w # set_bit (i - LENGTH('a)) ws)\""], ["", "lemma set_bit_lookup[simp]: \"lookup i (set_bit j ws) \\<longleftrightarrow> (lookup i ws \\<or> i=j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup i (Impl_Uv_Set.set_bit j ws) = (lookup i ws \\<or> i = j)", "apply (induction ws arbitrary: i j)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i j.\n       lookup i (Impl_Uv_Set.set_bit j []) = (lookup i [] \\<or> i = j)\n 2. \\<And>a ws i j.\n       (\\<And>i j.\n           lookup i (Impl_Uv_Set.set_bit j ws) =\n           (lookup i ws \\<or> i = j)) \\<Longrightarrow>\n       lookup i (Impl_Uv_Set.set_bit j (a # ws)) =\n       (lookup i (a # ws) \\<or> i = j)", "apply (auto simp add: test_bit_eq_bit word_size ring_bit_operations_class.bit_set_bit_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "primrec reset_bit :: \"nat \\<Rightarrow> 'a::len word list \\<Rightarrow> 'a::len word list\" where\n    \"reset_bit i [] = []\"\n  | \"reset_bit i (w#ws) = (\n      if i<LENGTH('a) then\n        unset_bit i w # ws\n      else\n        w # reset_bit (i - LENGTH('a)) ws)\""], ["", "lemma reset_bit_lookup[simp]: \"lookup i (reset_bit j ws) \\<longleftrightarrow> (lookup i ws \\<and> i\\<noteq>j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup i (reset_bit j ws) = (lookup i ws \\<and> i \\<noteq> j)", "apply (induction ws arbitrary: i j)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i j. lookup i (reset_bit j []) = (lookup i [] \\<and> i \\<noteq> j)\n 2. \\<And>a ws i j.\n       (\\<And>i j.\n           lookup i (reset_bit j ws) =\n           (lookup i ws \\<and> i \\<noteq> j)) \\<Longrightarrow>\n       lookup i (reset_bit j (a # ws)) =\n       (lookup i (a # ws) \\<and> i \\<noteq> j)", "apply (auto simp: test_bit_eq_bit word_size bit_unset_bit_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Binary Operations\\<close>"], ["", "definition\n    is_bin_op_impl\n    :: \"(bool\\<Rightarrow>bool\\<Rightarrow>bool) \\<Rightarrow> ('a::len word \\<Rightarrow> 'a::len word \\<Rightarrow> 'a::len word) \\<Rightarrow> bool\"\n    where \"is_bin_op_impl f g \\<equiv>\n    (\\<forall>w v.  \\<forall>i<LENGTH('a). test_bit (g w v) i \\<longleftrightarrow> f (test_bit w i) (test_bit v i))\""], ["", "definition \"is_strict_bin_op_impl f g \\<equiv> is_bin_op_impl f g \\<and> f False False = False\""], ["", "fun binary :: \"('a::len word \\<Rightarrow> 'a::len word \\<Rightarrow> 'a::len word)\n    \\<Rightarrow> 'a::len word list \\<Rightarrow> 'a::len word list \\<Rightarrow> 'a::len word list\"\n    where\n    \"binary f [] [] = []\"\n  | \"binary f [] (w#ws) = f 0 w # binary f [] ws\"\n  | \"binary f (v#vs) [] = f v 0 # binary f vs []\"\n  | \"binary f (v#vs) (w#ws) = f v w # binary f vs ws\""], ["", "lemma binary_lookup:\n    assumes \"is_strict_bin_op_impl f g\"\n    shows \"lookup i (binary g ws vs) \\<longleftrightarrow> f (lookup i ws) (lookup i vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup i (binary g ws vs) = f (lookup i ws) (lookup i vs)", "using assms"], ["proof (prove)\nusing this:\n  is_strict_bin_op_impl f g\n\ngoal (1 subgoal):\n 1. lookup i (binary g ws vs) = f (lookup i ws) (lookup i vs)", "apply (induction g ws vs arbitrary: i rule: binary.induct)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>fa i.\n       is_strict_bin_op_impl f fa \\<Longrightarrow>\n       lookup i (binary fa [] []) = f (lookup i []) (lookup i [])\n 2. \\<And>fa w ws i.\n       \\<lbrakk>\\<And>i.\n                   is_strict_bin_op_impl f fa \\<Longrightarrow>\n                   lookup i (binary fa [] ws) =\n                   f (lookup i []) (lookup i ws);\n        is_strict_bin_op_impl f fa\\<rbrakk>\n       \\<Longrightarrow> lookup i (binary fa [] (w # ws)) =\n                         f (lookup i []) (lookup i (w # ws))\n 3. \\<And>fa v vs i.\n       \\<lbrakk>\\<And>i.\n                   is_strict_bin_op_impl f fa \\<Longrightarrow>\n                   lookup i (binary fa vs []) =\n                   f (lookup i vs) (lookup i []);\n        is_strict_bin_op_impl f fa\\<rbrakk>\n       \\<Longrightarrow> lookup i (binary fa (v # vs) []) =\n                         f (lookup i (v # vs)) (lookup i [])\n 4. \\<And>fa v vs w ws i.\n       \\<lbrakk>\\<And>i.\n                   is_strict_bin_op_impl f fa \\<Longrightarrow>\n                   lookup i (binary fa vs ws) =\n                   f (lookup i vs) (lookup i ws);\n        is_strict_bin_op_impl f fa\\<rbrakk>\n       \\<Longrightarrow> lookup i (binary fa (v # vs) (w # ws)) =\n                         f (lookup i (v # vs)) (lookup i (w # ws))", "apply (auto simp: is_strict_bin_op_impl_def is_bin_op_impl_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Abstraction to Sets of Naturals\\<close>"], ["", "definition \"\\<alpha> uv \\<equiv> {n. lookup n uv}\""], ["", "lemma memb_correct: \"lookup i ws \\<longleftrightarrow> i\\<in>\\<alpha> ws\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup i ws = (i \\<in> \\<alpha> ws)", "by (auto simp: \\<alpha>_def)"], ["", "lemma empty_correct: \"\\<alpha> empty = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> Impl_Uv_Set.empty = {}", "by (simp add: \\<alpha>_def empty_def)"], ["", "lemma single_bit_correct: \"\\<alpha> (single_bit n) = {n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (single_bit n) = {n}", "by (simp add: \\<alpha>_def)"], ["", "lemma insert_correct: \"\\<alpha> (set_bit i ws) = Set.insert i (\\<alpha> ws)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (Impl_Uv_Set.set_bit i ws) = insert i (\\<alpha> ws)", "by (auto simp add: \\<alpha>_def)"], ["", "lemma delete_correct: \"\\<alpha> (reset_bit i ws) = (\\<alpha> ws) - {i}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (reset_bit i ws) = \\<alpha> ws - {i}", "by (auto simp add: \\<alpha>_def)"], ["", "lemma binary_correct:\n    assumes \"is_strict_bin_op_impl f g\"\n    shows \"\\<alpha> (binary g ws vs) = { i . f (i\\<in>\\<alpha> ws) (i\\<in>\\<alpha> vs) }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (binary g ws vs) =\n    {i. f (i \\<in> \\<alpha> ws) (i \\<in> \\<alpha> vs)}", "unfolding \\<alpha>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {n. lookup n (binary g ws vs)} =\n    {i. f (i \\<in> {n. lookup n ws}) (i \\<in> {n. lookup n vs})}", "by (auto simp add: binary_lookup[OF assms])"], ["", "fun union :: \"'a::len word list \\<Rightarrow> 'a::len word list \\<Rightarrow> 'a::len word list\"\n    where\n    \"union [] ws = ws\"\n  | \"union vs [] = vs\"\n  | \"union (v#vs) (w#ws) = (v OR w) # union vs ws\""], ["", "lemma union_lookup[simp]:\n    fixes vs :: \"'a::len word list\"\n    shows \"lookup i (union vs ws) \\<longleftrightarrow> lookup i vs \\<or> lookup i ws\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup i (Impl_Uv_Set.union vs ws) = (lookup i vs \\<or> lookup i ws)", "apply (induction vs ws arbitrary: i rule: union.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ws i.\n       lookup i (Impl_Uv_Set.union [] ws) = (lookup i [] \\<or> lookup i ws)\n 2. \\<And>v va i.\n       lookup i (Impl_Uv_Set.union (v # va) []) =\n       (lookup i (v # va) \\<or> lookup i [])\n 3. \\<And>v vs w ws i.\n       (\\<And>i.\n           lookup i (Impl_Uv_Set.union vs ws) =\n           (lookup i vs \\<or> lookup i ws)) \\<Longrightarrow>\n       lookup i (Impl_Uv_Set.union (v # vs) (w # ws)) =\n       (lookup i (v # vs) \\<or> lookup i (w # ws))", "apply (auto simp: word_ao_nth)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma union_correct: \"\\<alpha> (union ws vs) = \\<alpha> ws \\<union> \\<alpha> vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (Impl_Uv_Set.union ws vs) = \\<alpha> ws \\<union> \\<alpha> vs", "by (auto simp add: \\<alpha>_def)"], ["", "fun inter :: \"'a::len word list \\<Rightarrow> 'a::len word list \\<Rightarrow> 'a::len word list\"\n    where\n    \"inter [] ws = []\"\n  | \"inter vs [] = []\"\n  | \"inter (v#vs) (w#ws) = (v AND w) # inter vs ws\""], ["", "lemma inter_lookup[simp]:\n    fixes vs :: \"'a::len word list\"\n    shows \"lookup i (inter vs ws) \\<longleftrightarrow> lookup i vs \\<and> lookup i ws\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup i (Impl_Uv_Set.inter vs ws) = (lookup i vs \\<and> lookup i ws)", "apply (induction vs ws arbitrary: i rule: inter.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ws i.\n       lookup i (Impl_Uv_Set.inter [] ws) = (lookup i [] \\<and> lookup i ws)\n 2. \\<And>v va i.\n       lookup i (Impl_Uv_Set.inter (v # va) []) =\n       (lookup i (v # va) \\<and> lookup i [])\n 3. \\<And>v vs w ws i.\n       (\\<And>i.\n           lookup i (Impl_Uv_Set.inter vs ws) =\n           (lookup i vs \\<and> lookup i ws)) \\<Longrightarrow>\n       lookup i (Impl_Uv_Set.inter (v # vs) (w # ws)) =\n       (lookup i (v # vs) \\<and> lookup i (w # ws))", "apply (auto simp: word_ao_nth)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma inter_correct: \"\\<alpha> (inter ws vs) = \\<alpha> ws \\<inter> \\<alpha> vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (Impl_Uv_Set.inter ws vs) = \\<alpha> ws \\<inter> \\<alpha> vs", "by (auto simp add: \\<alpha>_def)"], ["", "fun diff :: \"'a::len word list \\<Rightarrow> 'a::len word list \\<Rightarrow> 'a::len word list\"\n    where\n    \"diff [] ws = []\"\n  | \"diff vs [] = vs\"\n  | \"diff (v#vs) (w#ws) = (v AND NOT w) # diff vs ws\""], ["", "lemma diff_lookup[simp]:\n    fixes vs :: \"'a::len word list\"\n    shows \"lookup i (diff vs ws) \\<longleftrightarrow> lookup i vs - lookup i ws\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup i (diff vs ws) = lookup i vs - lookup i ws", "apply (induction vs ws arbitrary: i rule: diff.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ws i. lookup i (diff [] ws) = lookup i [] - lookup i ws\n 2. \\<And>v va i.\n       lookup i (diff (v # va) []) = lookup i (v # va) - lookup i []\n 3. \\<And>v vs w ws i.\n       (\\<And>i.\n           lookup i (diff vs ws) =\n           lookup i vs - lookup i ws) \\<Longrightarrow>\n       lookup i (diff (v # vs) (w # ws)) =\n       lookup i (v # vs) - lookup i (w # ws)", "apply (auto simp: word_ops_nth_size word_size)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma diff_correct: \"\\<alpha> (diff ws vs) = \\<alpha> ws - \\<alpha> vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (diff ws vs) = \\<alpha> ws - \\<alpha> vs", "by (auto simp add: \\<alpha>_def)"], ["", "fun zeroes :: \"'a::len word list \\<Rightarrow> bool\" where\n    \"zeroes [] \\<longleftrightarrow> True\"\n  | \"zeroes (w#ws) \\<longleftrightarrow> w=0 \\<and> zeroes ws\""], ["", "lemma zeroes_lookup: \"zeroes ws \\<longleftrightarrow> (\\<forall>i. \\<not>lookup i ws)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zeroes ws = (\\<forall>i. \\<not> lookup i ws)", "apply (induction ws)"], ["proof (prove)\ngoal (2 subgoals):\n 1. zeroes [] = (\\<forall>i. \\<not> lookup i [])\n 2. \\<And>a ws.\n       zeroes ws = (\\<forall>i. \\<not> lookup i ws) \\<Longrightarrow>\n       zeroes (a # ws) = (\\<forall>i. \\<not> lookup i (a # ws))", "apply (auto simp: word_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ws i ia.\n       \\<lbrakk>\\<not> zeroes ws; lookup i ws;\n        \\<forall>i.\n           (i < LENGTH('a) \\<longrightarrow> \\<not> a !! i) \\<and>\n           (\\<not> i < LENGTH('a) \\<longrightarrow>\n            \\<not> lookup (i - LENGTH('a)) ws);\n        lookup ia ws\\<rbrakk>\n       \\<Longrightarrow> False", "by (metis diff_add_inverse2 not_add_less2)"], ["", "lemma isEmpty_correct: \"zeroes ws \\<longleftrightarrow> \\<alpha> ws = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zeroes ws = (\\<alpha> ws = {})", "by (auto simp: zeroes_lookup \\<alpha>_def)"], ["", "fun equal :: \"'a::len word list \\<Rightarrow> 'a::len word list \\<Rightarrow> bool\" where\n    \"equal [] [] \\<longleftrightarrow> True\"\n  | \"equal [] ws \\<longleftrightarrow> zeroes ws\"\n  | \"equal vs [] \\<longleftrightarrow> zeroes vs\"\n  | \"equal (v#vs) (w#ws) \\<longleftrightarrow> v=w \\<and> equal vs ws\""], ["", "lemma equal_lookup:\n    fixes vs ws :: \"'a::len word list\"\n    shows \"equal vs ws \\<longleftrightarrow> (\\<forall>i. lookup i vs = lookup i ws)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equal vs ws = (\\<forall>i. lookup i vs = lookup i ws)", "proof (induction vs ws rule: equal.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. equal [] [] = (\\<forall>i. lookup i [] = lookup i [])\n 2. \\<And>v va.\n       equal [] (v # va) = (\\<forall>i. lookup i [] = lookup i (v # va))\n 3. \\<And>v va.\n       equal (v # va) [] = (\\<forall>i. lookup i (v # va) = lookup i [])\n 4. \\<And>v vs w ws.\n       equal vs ws =\n       (\\<forall>i. lookup i vs = lookup i ws) \\<Longrightarrow>\n       equal (v # vs) (w # ws) =\n       (\\<forall>i. lookup i (v # vs) = lookup i (w # ws))", "fix v w and vs ws :: \"'a::len word list\""], ["proof (state)\ngoal (4 subgoals):\n 1. equal [] [] = (\\<forall>i. lookup i [] = lookup i [])\n 2. \\<And>v va.\n       equal [] (v # va) = (\\<forall>i. lookup i [] = lookup i (v # va))\n 3. \\<And>v va.\n       equal (v # va) [] = (\\<forall>i. lookup i (v # va) = lookup i [])\n 4. \\<And>v vs w ws.\n       equal vs ws =\n       (\\<forall>i. lookup i vs = lookup i ws) \\<Longrightarrow>\n       equal (v # vs) (w # ws) =\n       (\\<forall>i. lookup i (v # vs) = lookup i (w # ws))", "assume IH: \"equal vs ws = (\\<forall>i. lookup i vs = lookup i ws)\""], ["proof (state)\nthis:\n  equal vs ws = (\\<forall>i. lookup i vs = lookup i ws)\n\ngoal (4 subgoals):\n 1. equal [] [] = (\\<forall>i. lookup i [] = lookup i [])\n 2. \\<And>v va.\n       equal [] (v # va) = (\\<forall>i. lookup i [] = lookup i (v # va))\n 3. \\<And>v va.\n       equal (v # va) [] = (\\<forall>i. lookup i (v # va) = lookup i [])\n 4. \\<And>v vs w ws.\n       equal vs ws =\n       (\\<forall>i. lookup i vs = lookup i ws) \\<Longrightarrow>\n       equal (v # vs) (w # ws) =\n       (\\<forall>i. lookup i (v # vs) = lookup i (w # ws))", "show \"equal (v # vs) (w # ws) = (\\<forall>i. lookup i (v # vs) = lookup i (w # ws))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equal (v # vs) (w # ws) =\n    (\\<forall>i. lookup i (v # vs) = lookup i (w # ws))", "proof (rule iffI, rule allI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       equal (v # vs) (w # ws) \\<Longrightarrow>\n       lookup i (v # vs) = lookup i (w # ws)\n 2. \\<forall>i. lookup i (v # vs) = lookup i (w # ws) \\<Longrightarrow>\n    equal (v # vs) (w # ws)", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       equal (v # vs) (w # ws) \\<Longrightarrow>\n       lookup i (v # vs) = lookup i (w # ws)\n 2. \\<forall>i. lookup i (v # vs) = lookup i (w # ws) \\<Longrightarrow>\n    equal (v # vs) (w # ws)", "assume \"equal (v#vs) (w#ws)\""], ["proof (state)\nthis:\n  equal (v # vs) (w # ws)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       equal (v # vs) (w # ws) \\<Longrightarrow>\n       lookup i (v # vs) = lookup i (w # ws)\n 2. \\<forall>i. lookup i (v # vs) = lookup i (w # ws) \\<Longrightarrow>\n    equal (v # vs) (w # ws)", "thus \"lookup i (v # vs) = lookup i (w # ws)\""], ["proof (prove)\nusing this:\n  equal (v # vs) (w # ws)\n\ngoal (1 subgoal):\n 1. lookup i (v # vs) = lookup i (w # ws)", "by (auto simp: IH)"], ["proof (state)\nthis:\n  lookup i (v # vs) = lookup i (w # ws)\n\ngoal (1 subgoal):\n 1. \\<forall>i. lookup i (v # vs) = lookup i (w # ws) \\<Longrightarrow>\n    equal (v # vs) (w # ws)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>i. lookup i (v # vs) = lookup i (w # ws) \\<Longrightarrow>\n    equal (v # vs) (w # ws)", "assume \"\\<forall>i. lookup i (v # vs) = lookup i (w # ws)\""], ["proof (state)\nthis:\n  \\<forall>i. lookup i (v # vs) = lookup i (w # ws)\n\ngoal (1 subgoal):\n 1. \\<forall>i. lookup i (v # vs) = lookup i (w # ws) \\<Longrightarrow>\n    equal (v # vs) (w # ws)", "thus \"equal (v # vs) (w # ws)\""], ["proof (prove)\nusing this:\n  \\<forall>i. lookup i (v # vs) = lookup i (w # ws)\n\ngoal (1 subgoal):\n 1. equal (v # vs) (w # ws)", "apply (auto simp: word_eq_iff IH)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>i.\n                   (if i < LENGTH('a) then v !! i\n                    else lookup (i - LENGTH('a)) vs) =\n                   (if i < LENGTH('a) then w !! i\n                    else lookup (i - LENGTH('a)) ws);\n        n < LENGTH('a); v !! n\\<rbrakk>\n       \\<Longrightarrow> w !! n\n 2. \\<And>n.\n       \\<lbrakk>\\<forall>i.\n                   (if i < LENGTH('a) then v !! i\n                    else lookup (i - LENGTH('a)) vs) =\n                   (if i < LENGTH('a) then w !! i\n                    else lookup (i - LENGTH('a)) ws);\n        n < LENGTH('a); w !! n\\<rbrakk>\n       \\<Longrightarrow> v !! n\n 3. \\<And>i.\n       \\<lbrakk>\\<forall>i.\n                   (if i < LENGTH('a) then v !! i\n                    else lookup (i - LENGTH('a)) vs) =\n                   (if i < LENGTH('a) then w !! i\n                    else lookup (i - LENGTH('a)) ws);\n        lookup i vs\\<rbrakk>\n       \\<Longrightarrow> lookup i ws\n 4. \\<And>i.\n       \\<lbrakk>\\<forall>i.\n                   (if i < LENGTH('a) then v !! i\n                    else lookup (i - LENGTH('a)) vs) =\n                   (if i < LENGTH('a) then w !! i\n                    else lookup (i - LENGTH('a)) ws);\n        lookup i ws\\<rbrakk>\n       \\<Longrightarrow> lookup i vs", "apply metis"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>i.\n                   (if i < LENGTH('a) then v !! i\n                    else lookup (i - LENGTH('a)) vs) =\n                   (if i < LENGTH('a) then w !! i\n                    else lookup (i - LENGTH('a)) ws);\n        n < LENGTH('a); w !! n\\<rbrakk>\n       \\<Longrightarrow> v !! n\n 2. \\<And>i.\n       \\<lbrakk>\\<forall>i.\n                   (if i < LENGTH('a) then v !! i\n                    else lookup (i - LENGTH('a)) vs) =\n                   (if i < LENGTH('a) then w !! i\n                    else lookup (i - LENGTH('a)) ws);\n        lookup i vs\\<rbrakk>\n       \\<Longrightarrow> lookup i ws\n 3. \\<And>i.\n       \\<lbrakk>\\<forall>i.\n                   (if i < LENGTH('a) then v !! i\n                    else lookup (i - LENGTH('a)) vs) =\n                   (if i < LENGTH('a) then w !! i\n                    else lookup (i - LENGTH('a)) ws);\n        lookup i ws\\<rbrakk>\n       \\<Longrightarrow> lookup i vs", "apply metis"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>\\<forall>i.\n                   (if i < LENGTH('a) then v !! i\n                    else lookup (i - LENGTH('a)) vs) =\n                   (if i < LENGTH('a) then w !! i\n                    else lookup (i - LENGTH('a)) ws);\n        lookup i vs\\<rbrakk>\n       \\<Longrightarrow> lookup i ws\n 2. \\<And>i.\n       \\<lbrakk>\\<forall>i.\n                   (if i < LENGTH('a) then v !! i\n                    else lookup (i - LENGTH('a)) vs) =\n                   (if i < LENGTH('a) then w !! i\n                    else lookup (i - LENGTH('a)) ws);\n        lookup i ws\\<rbrakk>\n       \\<Longrightarrow> lookup i vs", "apply (drule_tac x=\"i + LENGTH('a)\" in spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>lookup i vs;\n        (if i + LENGTH('a) < LENGTH('a) then v !! (i + LENGTH('a))\n         else lookup (i + LENGTH('a) - LENGTH('a)) vs) =\n        (if i + LENGTH('a) < LENGTH('a) then w !! (i + LENGTH('a))\n         else lookup (i + LENGTH('a) - LENGTH('a)) ws)\\<rbrakk>\n       \\<Longrightarrow> lookup i ws\n 2. \\<And>i.\n       \\<lbrakk>\\<forall>i.\n                   (if i < LENGTH('a) then v !! i\n                    else lookup (i - LENGTH('a)) vs) =\n                   (if i < LENGTH('a) then w !! i\n                    else lookup (i - LENGTH('a)) ws);\n        lookup i ws\\<rbrakk>\n       \\<Longrightarrow> lookup i vs", "apply auto []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<forall>i.\n                   (if i < LENGTH('a) then v !! i\n                    else lookup (i - LENGTH('a)) vs) =\n                   (if i < LENGTH('a) then w !! i\n                    else lookup (i - LENGTH('a)) ws);\n        lookup i ws\\<rbrakk>\n       \\<Longrightarrow> lookup i vs", "apply (drule_tac x=\"i + LENGTH('a)\" in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>lookup i ws;\n        (if i + LENGTH('a) < LENGTH('a) then v !! (i + LENGTH('a))\n         else lookup (i + LENGTH('a) - LENGTH('a)) vs) =\n        (if i + LENGTH('a) < LENGTH('a) then w !! (i + LENGTH('a))\n         else lookup (i + LENGTH('a) - LENGTH('a)) ws)\\<rbrakk>\n       \\<Longrightarrow> lookup i vs", "apply auto []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  equal (v # vs) (w # ws)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  equal (v # vs) (w # ws) =\n  (\\<forall>i. lookup i (v # vs) = lookup i (w # ws))\n\ngoal (3 subgoals):\n 1. equal [] [] = (\\<forall>i. lookup i [] = lookup i [])\n 2. \\<And>v va.\n       equal [] (v # va) = (\\<forall>i. lookup i [] = lookup i (v # va))\n 3. \\<And>v va.\n       equal (v # va) [] = (\\<forall>i. lookup i (v # va) = lookup i [])", "qed (auto simp: zeroes_lookup)"], ["", "lemma equal_correct: \"equal vs ws \\<longleftrightarrow> \\<alpha> vs = \\<alpha> ws\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equal vs ws = (\\<alpha> vs = \\<alpha> ws)", "by (auto simp: \\<alpha>_def equal_lookup)"], ["", "fun subseteq :: \"'a::len word list \\<Rightarrow> 'a::len word list \\<Rightarrow> bool\" where\n    \"subseteq [] ws \\<longleftrightarrow> True\"\n  | \"subseteq vs [] \\<longleftrightarrow> zeroes vs\"\n  | \"subseteq (v#vs) (w#ws) \\<longleftrightarrow> (v AND NOT w = 0) \\<and> subseteq vs ws\""], ["", "lemma subseteq_lookup:\n    fixes vs ws :: \"'a::len word list\"\n    shows \"subseteq vs ws \\<longleftrightarrow> (\\<forall>i. lookup i vs \\<longrightarrow> lookup i ws)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subseteq vs ws = (\\<forall>i. lookup i vs \\<longrightarrow> lookup i ws)", "apply (induction vs ws rule: subseteq.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ws.\n       subseteq [] ws =\n       (\\<forall>i. lookup i [] \\<longrightarrow> lookup i ws)\n 2. \\<And>v va.\n       subseteq (v # va) [] =\n       (\\<forall>i. lookup i (v # va) \\<longrightarrow> lookup i [])\n 3. \\<And>v vs w ws.\n       subseteq vs ws =\n       (\\<forall>i.\n           lookup i vs \\<longrightarrow> lookup i ws) \\<Longrightarrow>\n       subseteq (v # vs) (w # ws) =\n       (\\<forall>i. lookup i (v # vs) \\<longrightarrow> lookup i (w # ws))", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v va.\n       subseteq (v # va) [] =\n       (\\<forall>i. lookup i (v # va) \\<longrightarrow> lookup i [])\n 2. \\<And>v vs w ws.\n       subseteq vs ws =\n       (\\<forall>i.\n           lookup i vs \\<longrightarrow> lookup i ws) \\<Longrightarrow>\n       subseteq (v # vs) (w # ws) =\n       (\\<forall>i. lookup i (v # vs) \\<longrightarrow> lookup i (w # ws))", "apply (auto simp: zeroes_lookup) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v vs w ws.\n       subseteq vs ws =\n       (\\<forall>i.\n           lookup i vs \\<longrightarrow> lookup i ws) \\<Longrightarrow>\n       subseteq (v # vs) (w # ws) =\n       (\\<forall>i. lookup i (v # vs) \\<longrightarrow> lookup i (w # ws))", "apply (auto simp: word_ops_nth_size word_size word_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v vs w ws i ia.\n       \\<lbrakk>\\<not> subseteq vs ws; lookup i vs; \\<not> lookup i ws;\n        \\<forall>i.\n           (i < LENGTH('a) \\<longrightarrow>\n            v !! i \\<longrightarrow> w !! i) \\<and>\n           (\\<not> i < LENGTH('a) \\<longrightarrow>\n            lookup (i - LENGTH('a)) vs \\<longrightarrow>\n            lookup (i - LENGTH('a)) ws);\n        lookup ia vs\\<rbrakk>\n       \\<Longrightarrow> lookup ia ws", "by (metis diff_add_inverse2 not_add_less2)"], ["", "lemma subseteq_correct: \"subseteq vs ws \\<longleftrightarrow> \\<alpha> vs \\<subseteq> \\<alpha> ws\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subseteq vs ws = (\\<alpha> vs \\<subseteq> \\<alpha> ws)", "by (auto simp: \\<alpha>_def subseteq_lookup)"], ["", "fun subset :: \"'a::len word list \\<Rightarrow> 'a::len word list \\<Rightarrow> bool\" where\n    \"subset [] ws \\<longleftrightarrow> \\<not>zeroes ws\"\n  | \"subset vs [] \\<longleftrightarrow> False\"\n  | \"subset (v#vs) (w#ws) \\<longleftrightarrow> (if v=w then subset vs ws else subseteq (v#vs) (w#ws))\""], ["", "lemma subset_lookup:\n    fixes vs ws :: \"'a::len word list\"\n    shows \"subset vs ws \\<longleftrightarrow> ((\\<forall>i. lookup i vs \\<longrightarrow> lookup i ws)\n      \\<and> (\\<exists>i. \\<not>lookup i vs \\<and> lookup i ws))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Impl_Uv_Set.subset vs ws =\n    ((\\<forall>i. lookup i vs \\<longrightarrow> lookup i ws) \\<and>\n     (\\<exists>i. \\<not> lookup i vs \\<and> lookup i ws))", "apply (induction vs ws rule: subset.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ws.\n       Impl_Uv_Set.subset [] ws =\n       ((\\<forall>i. lookup i [] \\<longrightarrow> lookup i ws) \\<and>\n        (\\<exists>i. \\<not> lookup i [] \\<and> lookup i ws))\n 2. \\<And>v va.\n       Impl_Uv_Set.subset (v # va) [] =\n       ((\\<forall>i. lookup i (v # va) \\<longrightarrow> lookup i []) \\<and>\n        (\\<exists>i. \\<not> lookup i (v # va) \\<and> lookup i []))\n 3. \\<And>v vs w ws.\n       (v = w \\<Longrightarrow>\n        Impl_Uv_Set.subset vs ws =\n        ((\\<forall>i. lookup i vs \\<longrightarrow> lookup i ws) \\<and>\n         (\\<exists>i.\n             \\<not> lookup i vs \\<and> lookup i ws))) \\<Longrightarrow>\n       Impl_Uv_Set.subset (v # vs) (w # ws) =\n       ((\\<forall>i.\n            lookup i (v # vs) \\<longrightarrow> lookup i (w # ws)) \\<and>\n        (\\<exists>i. \\<not> lookup i (v # vs) \\<and> lookup i (w # ws)))", "apply (simp add: zeroes_lookup)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v va.\n       Impl_Uv_Set.subset (v # va) [] =\n       ((\\<forall>i. lookup i (v # va) \\<longrightarrow> lookup i []) \\<and>\n        (\\<exists>i. \\<not> lookup i (v # va) \\<and> lookup i []))\n 2. \\<And>v vs w ws.\n       (v = w \\<Longrightarrow>\n        Impl_Uv_Set.subset vs ws =\n        ((\\<forall>i. lookup i vs \\<longrightarrow> lookup i ws) \\<and>\n         (\\<exists>i.\n             \\<not> lookup i vs \\<and> lookup i ws))) \\<Longrightarrow>\n       Impl_Uv_Set.subset (v # vs) (w # ws) =\n       ((\\<forall>i.\n            lookup i (v # vs) \\<longrightarrow> lookup i (w # ws)) \\<and>\n        (\\<exists>i. \\<not> lookup i (v # vs) \\<and> lookup i (w # ws)))", "apply (simp add: zeroes_lookup) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v vs w ws.\n       (v = w \\<Longrightarrow>\n        Impl_Uv_Set.subset vs ws =\n        ((\\<forall>i. lookup i vs \\<longrightarrow> lookup i ws) \\<and>\n         (\\<exists>i.\n             \\<not> lookup i vs \\<and> lookup i ws))) \\<Longrightarrow>\n       Impl_Uv_Set.subset (v # vs) (w # ws) =\n       ((\\<forall>i.\n            lookup i (v # vs) \\<longrightarrow> lookup i (w # ws)) \\<and>\n        (\\<exists>i. \\<not> lookup i (v # vs) \\<and> lookup i (w # ws)))", "apply (simp del: subseteq_correct add: subseteq_lookup)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v vs w ws.\n       (v = w \\<Longrightarrow>\n        Impl_Uv_Set.subset vs ws =\n        ((\\<forall>i. lookup i vs \\<longrightarrow> lookup i ws) \\<and>\n         (\\<exists>i.\n             \\<not> lookup i vs \\<and> lookup i ws))) \\<Longrightarrow>\n       (v = w \\<longrightarrow>\n        ((\\<forall>i. lookup i vs \\<longrightarrow> lookup i ws) \\<and>\n         (\\<exists>i. \\<not> lookup i vs \\<and> lookup i ws)) =\n        ((\\<forall>i.\n             \\<not> i < LENGTH('a) \\<longrightarrow>\n             lookup (i - LENGTH('a)) vs \\<longrightarrow>\n             lookup (i - LENGTH('a)) ws) \\<and>\n         (\\<exists>i.\n             \\<not> i < LENGTH('a) \\<and>\n             \\<not> lookup (i - LENGTH('a)) vs \\<and>\n             lookup (i - LENGTH('a)) ws))) \\<and>\n       (v \\<noteq> w \\<longrightarrow>\n        (\\<forall>i.\n            (i < LENGTH('a) \\<longrightarrow>\n             v !! i \\<longrightarrow> w !! i) \\<and>\n            (\\<not> i < LENGTH('a) \\<longrightarrow>\n             lookup (i - LENGTH('a)) vs \\<longrightarrow>\n             lookup (i - LENGTH('a)) ws)) =\n        ((\\<forall>i.\n             (i < LENGTH('a) \\<longrightarrow>\n              v !! i \\<longrightarrow> w !! i) \\<and>\n             (\\<not> i < LENGTH('a) \\<longrightarrow>\n              lookup (i - LENGTH('a)) vs \\<longrightarrow>\n              lookup (i - LENGTH('a)) ws)) \\<and>\n         (\\<exists>i.\n             (i < LENGTH('a) \\<longrightarrow>\n              \\<not> v !! i \\<and> w !! i) \\<and>\n             (\\<not> i < LENGTH('a) \\<longrightarrow>\n              \\<not> lookup (i - LENGTH('a)) vs \\<and>\n              lookup (i - LENGTH('a)) ws))))", "apply safe"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>v vs w ws i ia.\n       \\<lbrakk>w = w \\<Longrightarrow>\n                Impl_Uv_Set.subset vs ws =\n                ((\\<forall>i.\n                     lookup i vs \\<longrightarrow> lookup i ws) \\<and>\n                 (\\<exists>i. \\<not> lookup i vs \\<and> lookup i ws));\n        \\<forall>i. lookup i vs \\<longrightarrow> lookup i ws;\n        \\<not> lookup i vs; lookup i ws; \\<not> ia < LENGTH('a);\n        lookup (ia - LENGTH('a)) vs\\<rbrakk>\n       \\<Longrightarrow> lookup (ia - LENGTH('a)) ws\n 2. \\<And>v vs w ws i.\n       \\<lbrakk>w = w \\<Longrightarrow>\n                Impl_Uv_Set.subset vs ws =\n                ((\\<forall>i.\n                     lookup i vs \\<longrightarrow> lookup i ws) \\<and>\n                 (\\<exists>i. \\<not> lookup i vs \\<and> lookup i ws));\n        \\<forall>i. lookup i vs \\<longrightarrow> lookup i ws;\n        \\<not> lookup i vs; lookup i ws\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            \\<not> i < LENGTH('a) \\<and>\n                            \\<not> lookup (i - LENGTH('a)) vs \\<and>\n                            lookup (i - LENGTH('a)) ws\n 3. \\<And>v vs w ws i ia.\n       \\<lbrakk>w = w \\<Longrightarrow>\n                Impl_Uv_Set.subset vs ws =\n                ((\\<forall>i.\n                     lookup i vs \\<longrightarrow> lookup i ws) \\<and>\n                 (\\<exists>i. \\<not> lookup i vs \\<and> lookup i ws));\n        \\<forall>i.\n           \\<not> i < LENGTH('a) \\<longrightarrow>\n           lookup (i - LENGTH('a)) vs \\<longrightarrow>\n           lookup (i - LENGTH('a)) ws;\n        \\<not> i < LENGTH('a); \\<not> lookup (i - LENGTH('a)) vs;\n        lookup (i - LENGTH('a)) ws; lookup ia vs\\<rbrakk>\n       \\<Longrightarrow> lookup ia ws\n 4. \\<And>v vs w ws i.\n       \\<lbrakk>w = w \\<Longrightarrow>\n                Impl_Uv_Set.subset vs ws =\n                ((\\<forall>i.\n                     lookup i vs \\<longrightarrow> lookup i ws) \\<and>\n                 (\\<exists>i. \\<not> lookup i vs \\<and> lookup i ws));\n        \\<forall>i.\n           \\<not> i < LENGTH('a) \\<longrightarrow>\n           lookup (i - LENGTH('a)) vs \\<longrightarrow>\n           lookup (i - LENGTH('a)) ws;\n        \\<not> i < LENGTH('a); \\<not> lookup (i - LENGTH('a)) vs;\n        lookup (i - LENGTH('a)) ws\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i. \\<not> lookup i vs \\<and> lookup i ws\n 5. \\<And>v vs w ws.\n       \\<lbrakk>v = w \\<Longrightarrow>\n                Impl_Uv_Set.subset vs ws =\n                ((\\<forall>i.\n                     lookup i vs \\<longrightarrow> lookup i ws) \\<and>\n                 (\\<exists>i. \\<not> lookup i vs \\<and> lookup i ws));\n        v \\<noteq> w;\n        \\<forall>i.\n           (i < LENGTH('a) \\<longrightarrow>\n            v !! i \\<longrightarrow> w !! i) \\<and>\n           (\\<not> i < LENGTH('a) \\<longrightarrow>\n            lookup (i - LENGTH('a)) vs \\<longrightarrow>\n            lookup (i - LENGTH('a)) ws)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            (i < LENGTH('a) \\<longrightarrow>\n                             \\<not> v !! i \\<and> w !! i) \\<and>\n                            (\\<not> i < LENGTH('a) \\<longrightarrow>\n                             \\<not> lookup (i - LENGTH('a)) vs \\<and>\n                             lookup (i - LENGTH('a)) ws)\n 6. \\<And>v vs w ws i ia.\n       \\<lbrakk>v = w \\<Longrightarrow>\n                Impl_Uv_Set.subset vs ws =\n                ((\\<forall>i.\n                     lookup i vs \\<longrightarrow> lookup i ws) \\<and>\n                 (\\<exists>i. \\<not> lookup i vs \\<and> lookup i ws));\n        v \\<noteq> w;\n        \\<forall>i.\n           (i < LENGTH('a) \\<longrightarrow>\n            v !! i \\<longrightarrow> w !! i) \\<and>\n           (\\<not> i < LENGTH('a) \\<longrightarrow>\n            lookup (i - LENGTH('a)) vs \\<longrightarrow>\n            lookup (i - LENGTH('a)) ws);\n        \\<not> ia < LENGTH('a); \\<not> lookup (ia - LENGTH('a)) vs;\n        lookup (ia - LENGTH('a)) ws; i < LENGTH('a); v !! i\\<rbrakk>\n       \\<Longrightarrow> w !! i\n 7. \\<And>v vs w ws i ia.\n       \\<lbrakk>v = w \\<Longrightarrow>\n                Impl_Uv_Set.subset vs ws =\n                ((\\<forall>i.\n                     lookup i vs \\<longrightarrow> lookup i ws) \\<and>\n                 (\\<exists>i. \\<not> lookup i vs \\<and> lookup i ws));\n        v \\<noteq> w;\n        \\<forall>i.\n           (i < LENGTH('a) \\<longrightarrow>\n            v !! i \\<longrightarrow> w !! i) \\<and>\n           (\\<not> i < LENGTH('a) \\<longrightarrow>\n            lookup (i - LENGTH('a)) vs \\<longrightarrow>\n            lookup (i - LENGTH('a)) ws);\n        \\<not> ia < LENGTH('a); \\<not> lookup (ia - LENGTH('a)) vs;\n        lookup (ia - LENGTH('a)) ws; \\<not> i < LENGTH('a);\n        lookup (i - LENGTH('a)) vs\\<rbrakk>\n       \\<Longrightarrow> lookup (i - LENGTH('a)) ws\n 8. \\<And>v vs w ws i ia.\n       \\<lbrakk>v = w \\<Longrightarrow>\n                Impl_Uv_Set.subset vs ws =\n                ((\\<forall>i.\n                     lookup i vs \\<longrightarrow> lookup i ws) \\<and>\n                 (\\<exists>i. \\<not> lookup i vs \\<and> lookup i ws));\n        v \\<noteq> w;\n        \\<forall>i.\n           (i < LENGTH('a) \\<longrightarrow>\n            v !! i \\<longrightarrow> w !! i) \\<and>\n           (\\<not> i < LENGTH('a) \\<longrightarrow>\n            lookup (i - LENGTH('a)) vs \\<longrightarrow>\n            lookup (i - LENGTH('a)) ws);\n        \\<not> v !! ia; w !! ia; ia < LENGTH('a); \\<not> False;\n        i < LENGTH('a); v !! i\\<rbrakk>\n       \\<Longrightarrow> w !! i\n 9. \\<And>v vs w ws i ia.\n       \\<lbrakk>v = w \\<Longrightarrow>\n                Impl_Uv_Set.subset vs ws =\n                ((\\<forall>i.\n                     lookup i vs \\<longrightarrow> lookup i ws) \\<and>\n                 (\\<exists>i. \\<not> lookup i vs \\<and> lookup i ws));\n        v \\<noteq> w;\n        \\<forall>i.\n           (i < LENGTH('a) \\<longrightarrow>\n            v !! i \\<longrightarrow> w !! i) \\<and>\n           (\\<not> i < LENGTH('a) \\<longrightarrow>\n            lookup (i - LENGTH('a)) vs \\<longrightarrow>\n            lookup (i - LENGTH('a)) ws);\n        \\<not> v !! ia; w !! ia; ia < LENGTH('a); \\<not> False;\n        \\<not> i < LENGTH('a); lookup (i - LENGTH('a)) vs\\<rbrakk>\n       \\<Longrightarrow> lookup (i - LENGTH('a)) ws\n 10. \\<And>v vs w ws i ia.\n        \\<lbrakk>v = w \\<Longrightarrow>\n                 Impl_Uv_Set.subset vs ws =\n                 ((\\<forall>i.\n                      lookup i vs \\<longrightarrow> lookup i ws) \\<and>\n                  (\\<exists>i. \\<not> lookup i vs \\<and> lookup i ws));\n         v \\<noteq> w;\n         \\<forall>i.\n            (i < LENGTH('a) \\<longrightarrow>\n             v !! i \\<longrightarrow> w !! i) \\<and>\n            (\\<not> i < LENGTH('a) \\<longrightarrow>\n             lookup (i - LENGTH('a)) vs \\<longrightarrow>\n             lookup (i - LENGTH('a)) ws);\n         \\<not> v !! ia; w !! ia; \\<not> lookup (ia - LENGTH('a)) vs;\n         lookup (ia - LENGTH('a)) ws; i < LENGTH('a); v !! i\\<rbrakk>\n        \\<Longrightarrow> w !! i\nA total of 11 subgoals...", "apply simp_all"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>vs ws i.\n       \\<lbrakk>Impl_Uv_Set.subset vs ws =\n                (\\<exists>i. \\<not> lookup i vs \\<and> lookup i ws);\n        \\<forall>i. lookup i vs \\<longrightarrow> lookup i ws;\n        \\<not> lookup i vs; lookup i ws\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            \\<not> i < LENGTH('a) \\<and>\n                            \\<not> lookup (i - LENGTH('a)) vs \\<and>\n                            lookup (i - LENGTH('a)) ws\n 2. \\<And>vs ws i ia.\n       \\<lbrakk>Impl_Uv_Set.subset vs ws =\n                ((\\<forall>i.\n                     lookup i vs \\<longrightarrow> lookup i ws) \\<and>\n                 (\\<exists>i. \\<not> lookup i vs \\<and> lookup i ws));\n        \\<forall>i.\n           \\<not> i < LENGTH('a) \\<longrightarrow>\n           lookup (i - LENGTH('a)) vs \\<longrightarrow>\n           lookup (i - LENGTH('a)) ws;\n        \\<not> i < LENGTH('a); \\<not> lookup (i - LENGTH('a)) vs;\n        lookup (i - LENGTH('a)) ws; lookup ia vs\\<rbrakk>\n       \\<Longrightarrow> lookup ia ws\n 3. \\<And>vs ws i.\n       \\<lbrakk>Impl_Uv_Set.subset vs ws =\n                ((\\<forall>i.\n                     lookup i vs \\<longrightarrow> lookup i ws) \\<and>\n                 (\\<exists>i. \\<not> lookup i vs \\<and> lookup i ws));\n        \\<forall>i.\n           \\<not> i < LENGTH('a) \\<longrightarrow>\n           lookup (i - LENGTH('a)) vs \\<longrightarrow>\n           lookup (i - LENGTH('a)) ws;\n        \\<not> i < LENGTH('a); \\<not> lookup (i - LENGTH('a)) vs;\n        lookup (i - LENGTH('a)) ws\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i. \\<not> lookup i vs \\<and> lookup i ws\n 4. \\<And>v vs w ws.\n       \\<lbrakk>v \\<noteq> w;\n        \\<forall>i.\n           (i < LENGTH('a) \\<longrightarrow>\n            v !! i \\<longrightarrow> w !! i) \\<and>\n           (\\<not> i < LENGTH('a) \\<longrightarrow>\n            lookup (i - LENGTH('a)) vs \\<longrightarrow>\n            lookup (i - LENGTH('a)) ws)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i.\n                            (i < LENGTH('a) \\<longrightarrow>\n                             \\<not> v !! i \\<and> w !! i) \\<and>\n                            (\\<not> i < LENGTH('a) \\<longrightarrow>\n                             \\<not> lookup (i - LENGTH('a)) vs \\<and>\n                             lookup (i - LENGTH('a)) ws)", "apply (auto simp: word_ops_nth_size word_size word_eq_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma subset_correct: \"subset vs ws \\<longleftrightarrow> \\<alpha> vs \\<subset> \\<alpha> ws\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Impl_Uv_Set.subset vs ws = (\\<alpha> vs \\<subset> \\<alpha> ws)", "by (auto simp: \\<alpha>_def subset_lookup)"], ["", "fun disjoint :: \"'a::len word list \\<Rightarrow> 'a::len word list \\<Rightarrow> bool\" where\n    \"disjoint [] ws \\<longleftrightarrow> True\"\n  | \"disjoint vs [] \\<longleftrightarrow> True\"\n  | \"disjoint (v#vs) (w#ws) \\<longleftrightarrow> (v AND w = 0) \\<and> disjoint vs ws\""], ["", "lemma disjoint_lookup:\n    fixes vs ws :: \"'a::len word list\"\n    shows \"disjoint vs ws \\<longleftrightarrow> (\\<forall>i. \\<not>(lookup i vs \\<and> lookup i ws))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. disjoint vs ws = (\\<forall>i. \\<not> (lookup i vs \\<and> lookup i ws))", "apply (induction vs ws rule: disjoint.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ws.\n       disjoint [] ws =\n       (\\<forall>i. \\<not> (lookup i [] \\<and> lookup i ws))\n 2. \\<And>v va.\n       disjoint (v # va) [] =\n       (\\<forall>i. \\<not> (lookup i (v # va) \\<and> lookup i []))\n 3. \\<And>v vs w ws.\n       disjoint vs ws =\n       (\\<forall>i.\n           \\<not> (lookup i vs \\<and> lookup i ws)) \\<Longrightarrow>\n       disjoint (v # vs) (w # ws) =\n       (\\<forall>i. \\<not> (lookup i (v # vs) \\<and> lookup i (w # ws)))", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>v va.\n       disjoint (v # va) [] =\n       (\\<forall>i. \\<not> (lookup i (v # va) \\<and> lookup i []))\n 2. \\<And>v vs w ws.\n       disjoint vs ws =\n       (\\<forall>i.\n           \\<not> (lookup i vs \\<and> lookup i ws)) \\<Longrightarrow>\n       disjoint (v # vs) (w # ws) =\n       (\\<forall>i. \\<not> (lookup i (v # vs) \\<and> lookup i (w # ws)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v vs w ws.\n       disjoint vs ws =\n       (\\<forall>i.\n           \\<not> (lookup i vs \\<and> lookup i ws)) \\<Longrightarrow>\n       disjoint (v # vs) (w # ws) =\n       (\\<forall>i. \\<not> (lookup i (v # vs) \\<and> lookup i (w # ws)))", "apply (auto simp: word_ops_nth_size word_size word_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v vs w ws i ia.\n       \\<lbrakk>\\<not> disjoint vs ws; lookup i vs; lookup i ws;\n        \\<forall>i.\n           (i < LENGTH('a) \\<longrightarrow>\n            v !! i \\<longrightarrow> \\<not> w !! i) \\<and>\n           (\\<not> i < LENGTH('a) \\<longrightarrow>\n            lookup (i - LENGTH('a)) vs \\<longrightarrow>\n            \\<not> lookup (i - LENGTH('a)) ws);\n        lookup ia vs; lookup ia ws\\<rbrakk>\n       \\<Longrightarrow> False", "by (metis diff_add_inverse2 not_add_less2)"], ["", "lemma disjoint_correct: \"disjoint vs ws \\<longleftrightarrow> \\<alpha> vs \\<inter> \\<alpha> ws = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. disjoint vs ws = (\\<alpha> vs \\<inter> \\<alpha> ws = {})", "by (auto simp: \\<alpha>_def disjoint_lookup)"], ["", "subsection \\<open>Lifting to Uint\\<close>"], ["", "type_synonym uint_vector = \"uint list\""], ["", "lift_definition uv_\\<alpha> :: \"uint_vector \\<Rightarrow> nat set\" is \\<alpha>"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition uv_lookup :: \"nat \\<Rightarrow> uint_vector \\<Rightarrow> bool\" is lookup"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition uv_empty :: \"uint_vector\" is empty"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition uv_single_bit :: \"nat \\<Rightarrow> uint_vector\" is single_bit"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition uv_set_bit :: \"nat \\<Rightarrow> uint_vector \\<Rightarrow> uint_vector\" is set_bit"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition uv_reset_bit :: \"nat \\<Rightarrow> uint_vector \\<Rightarrow> uint_vector\" is reset_bit"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition uv_union :: \"uint_vector \\<Rightarrow> uint_vector \\<Rightarrow> uint_vector\" is union"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition uv_inter :: \"uint_vector \\<Rightarrow> uint_vector \\<Rightarrow> uint_vector\" is inter"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition uv_diff :: \"uint_vector \\<Rightarrow> uint_vector \\<Rightarrow> uint_vector\" is diff"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition uv_zeroes :: \"uint_vector \\<Rightarrow> bool\" is zeroes"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition uv_equal :: \"uint_vector \\<Rightarrow> uint_vector \\<Rightarrow> bool\" is equal"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition uv_subseteq :: \"uint_vector \\<Rightarrow> uint_vector \\<Rightarrow> bool\" is subseteq"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition uv_subset :: \"uint_vector \\<Rightarrow> uint_vector \\<Rightarrow> bool\" is subset"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition uv_disjoint :: \"uint_vector \\<Rightarrow> uint_vector \\<Rightarrow> bool\" is disjoint"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemmas uv_memb_correct = memb_correct[where 'a=dflt_size, Transfer.transferred]"], ["", "lemmas uv_empty_correct = empty_correct[where 'a=dflt_size, Transfer.transferred]"], ["", "lemmas uv_single_bit_correct = single_bit_correct[where 'a=dflt_size, Transfer.transferred]"], ["", "lemmas uv_insert_correct = insert_correct[where 'a=dflt_size, Transfer.transferred]"], ["", "lemmas uv_delete_correct = delete_correct[where 'a=dflt_size, Transfer.transferred]"], ["", "lemmas uv_union_correct = union_correct[where 'a=dflt_size, Transfer.transferred]"], ["", "lemmas uv_inter_correct = inter_correct[where 'a=dflt_size, Transfer.transferred]"], ["", "lemmas uv_diff_correct = diff_correct[where 'a=dflt_size, Transfer.transferred]"], ["", "lemmas uv_isEmpty_correct = isEmpty_correct[where 'a=dflt_size, Transfer.transferred]"], ["", "lemmas uv_equal_correct = equal_correct[where 'a=dflt_size, Transfer.transferred]"], ["", "lemmas uv_subseteq_correct = subseteq_correct[where 'a=dflt_size, Transfer.transferred]"], ["", "lemmas uv_subset_correct = subset_correct[where 'a=dflt_size, Transfer.transferred]"], ["", "lemmas uv_disjoint_correct = disjoint_correct[where 'a=dflt_size, Transfer.transferred]"], ["", "lemmas [where 'a=dflt_size, Transfer.transferred, code] =\n    lookup.simps\n    empty_def\n    single_bit.simps\n    set_bit.simps\n    reset_bit.simps\n    union.simps\n    inter.simps\n    diff.simps\n    zeroes.simps\n    equal.simps\n    subseteq.simps\n    subset.simps\n    disjoint.simps"], ["", "hide_const (open) \\<alpha> lookup empty single_bit set_bit reset_bit union inter diff zeroes\n    equal subseteq subset disjoint"], ["", "subsection \\<open>Autoref Setup\\<close>"], ["", "definition uv_set_rel_def_internal:\n    \"uv_set_rel Rk \\<equiv>\n      if Rk=nat_rel then br uv_\\<alpha> (\\<lambda>_. True) else {}\""], ["", "lemma uv_set_rel_def:\n    \"\\<langle>nat_rel\\<rangle>uv_set_rel \\<equiv> br uv_\\<alpha> (\\<lambda>_. True)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>nat_rel\\<rangle>uv_set_rel \\<equiv>\n    br uv_\\<alpha> (\\<lambda>_. True)", "unfolding uv_set_rel_def_internal relAPP_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. if nat_rel = nat_rel then br uv_\\<alpha> (\\<lambda>_. True)\n    else {} \\<equiv>\n    br uv_\\<alpha> (\\<lambda>_. True)", "by simp"], ["", "lemmas [autoref_rel_intf] = REL_INTFI[of \"uv_set_rel\" i_set]"], ["", "lemma uv_set_rel_sv[relator_props]: \"single_valued (\\<langle>nat_rel\\<rangle>uv_set_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued (\\<langle>nat_rel\\<rangle>uv_set_rel)", "unfolding uv_set_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued (br uv_\\<alpha> (\\<lambda>_. True))", "by auto"], ["", "lemma uv_autoref[autoref_rules,param]:\n    \"(uv_lookup,(\\<in>)) \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>uv_set_rel \\<rightarrow> bool_rel\"\n    \"(uv_empty,{}) \\<in> \\<langle>nat_rel\\<rangle>uv_set_rel\"\n    \"(uv_set_bit,insert) \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>uv_set_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>uv_set_rel\"\n    \"(uv_reset_bit,op_set_delete) \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>uv_set_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>uv_set_rel\"\n    \"(uv_union,(\\<union>)) \\<in> \\<langle>nat_rel\\<rangle>uv_set_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>uv_set_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>uv_set_rel\"\n    \"(uv_inter,(\\<inter>)) \\<in> \\<langle>nat_rel\\<rangle>uv_set_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>uv_set_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>uv_set_rel\"\n    \"(uv_diff,(-)) \\<in> \\<langle>nat_rel\\<rangle>uv_set_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>uv_set_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>uv_set_rel\"\n    \"(uv_zeroes,op_set_isEmpty) \\<in> \\<langle>nat_rel\\<rangle>uv_set_rel \\<rightarrow> bool_rel\"\n    \"(uv_equal,(=)) \\<in> \\<langle>nat_rel\\<rangle>uv_set_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>uv_set_rel \\<rightarrow> bool_rel\"\n    \"(uv_subseteq,(\\<subseteq>)) \\<in> \\<langle>nat_rel\\<rangle>uv_set_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>uv_set_rel \\<rightarrow> bool_rel\"\n    \"(uv_subset,(\\<subset>)) \\<in> \\<langle>nat_rel\\<rangle>uv_set_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>uv_set_rel \\<rightarrow> bool_rel\"\n    \"(uv_disjoint,op_set_disjoint) \\<in> \\<langle>nat_rel\\<rangle>uv_set_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>uv_set_rel \\<rightarrow> bool_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((uv_lookup, (\\<in>))\n      \\<in> nat_rel \\<rightarrow>\n            \\<langle>nat_rel\\<rangle>uv_set_rel \\<rightarrow> bool_rel &&&\n      (uv_empty, {}) \\<in> \\<langle>nat_rel\\<rangle>uv_set_rel &&&\n      (uv_set_bit, insert)\n      \\<in> nat_rel \\<rightarrow>\n            \\<langle>nat_rel\\<rangle>uv_set_rel \\<rightarrow>\n            \\<langle>nat_rel\\<rangle>uv_set_rel) &&&\n     (uv_reset_bit, op_set_delete)\n     \\<in> nat_rel \\<rightarrow>\n           \\<langle>nat_rel\\<rangle>uv_set_rel \\<rightarrow>\n           \\<langle>nat_rel\\<rangle>uv_set_rel &&&\n     (uv_union, (\\<union>))\n     \\<in> \\<langle>nat_rel\\<rangle>uv_set_rel \\<rightarrow>\n           \\<langle>nat_rel\\<rangle>uv_set_rel \\<rightarrow>\n           \\<langle>nat_rel\\<rangle>uv_set_rel &&&\n     (uv_inter, (\\<inter>))\n     \\<in> \\<langle>nat_rel\\<rangle>uv_set_rel \\<rightarrow>\n           \\<langle>nat_rel\\<rangle>uv_set_rel \\<rightarrow>\n           \\<langle>nat_rel\\<rangle>uv_set_rel) &&&\n    ((uv_diff, (-))\n     \\<in> \\<langle>nat_rel\\<rangle>uv_set_rel \\<rightarrow>\n           \\<langle>nat_rel\\<rangle>uv_set_rel \\<rightarrow>\n           \\<langle>nat_rel\\<rangle>uv_set_rel &&&\n     (uv_zeroes, op_set_isEmpty)\n     \\<in> \\<langle>nat_rel\\<rangle>uv_set_rel \\<rightarrow> bool_rel &&&\n     (uv_equal, (=))\n     \\<in> \\<langle>nat_rel\\<rangle>uv_set_rel \\<rightarrow>\n           \\<langle>nat_rel\\<rangle>uv_set_rel \\<rightarrow> bool_rel) &&&\n    (uv_subseteq, (\\<subseteq>))\n    \\<in> \\<langle>nat_rel\\<rangle>uv_set_rel \\<rightarrow>\n          \\<langle>nat_rel\\<rangle>uv_set_rel \\<rightarrow> bool_rel &&&\n    (uv_subset, (\\<subset>))\n    \\<in> \\<langle>nat_rel\\<rangle>uv_set_rel \\<rightarrow>\n          \\<langle>nat_rel\\<rangle>uv_set_rel \\<rightarrow> bool_rel &&&\n    (uv_disjoint, op_set_disjoint)\n    \\<in> \\<langle>nat_rel\\<rangle>uv_set_rel \\<rightarrow>\n          \\<langle>nat_rel\\<rangle>uv_set_rel \\<rightarrow> bool_rel", "by (auto\n      simp: uv_set_rel_def br_def\n      simp: uv_memb_correct uv_empty_correct uv_insert_correct uv_delete_correct\n      simp: uv_union_correct uv_inter_correct uv_diff_correct uv_isEmpty_correct\n      simp: uv_equal_correct uv_subseteq_correct uv_subset_correct uv_disjoint_correct)"], ["", "export_code\n    uv_lookup\n    uv_empty\n    uv_single_bit\n    uv_set_bit\n    uv_reset_bit\n    uv_union\n    uv_inter\n    uv_diff\n    uv_zeroes\n    uv_equal\n    uv_subseteq\n    uv_subset\n    uv_disjoint\n  checking SML Scala Haskell? OCaml?"], ["", "end"]]}