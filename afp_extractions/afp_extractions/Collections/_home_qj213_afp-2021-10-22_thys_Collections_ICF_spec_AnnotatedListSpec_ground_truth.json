{"file_name": "/home/qj213/afp-2021-10-22/thys/Collections/ICF/spec/AnnotatedListSpec.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Collections", "problem_names": ["lemma splitsE:\n    assumes \n    invar: \"invar s\" and\n    mono: \"\\<forall>a b. p a \\<longrightarrow> p (a + b)\" and\n    init_ff: \"\\<not> p i\" and\n    sum_tt: \"p (i + sum_list (map snd (\\<alpha> s)))\"\n    obtains l e a r where\n    \"(splits p i s) = (l, (e,a), r)\"\n    \"(\\<alpha> s) = (\\<alpha> l) @ (e,a) # (\\<alpha> r)\"\n    \"\\<not> p (i + sum_list (map snd (\\<alpha> l)))\"\n    \"p (i + sum_list (map snd (\\<alpha> l)) + a)\"\n    \"invar l\"\n    \"invar r\"", "lemmas correct =\n    empty_correct \n    isEmpty_correct\n    count_correct\n    consl_correct\n    consr_correct\n    head_correct\n    tail_correct\n    headR_correct\n    tailR_correct\n    app_correct\n    annot_correct      \n    foldl_correct\n    foldr_correct"], "translations": [["", "lemma splitsE:\n    assumes \n    invar: \"invar s\" and\n    mono: \"\\<forall>a b. p a \\<longrightarrow> p (a + b)\" and\n    init_ff: \"\\<not> p i\" and\n    sum_tt: \"p (i + sum_list (map snd (\\<alpha> s)))\"\n    obtains l e a r where\n    \"(splits p i s) = (l, (e,a), r)\"\n    \"(\\<alpha> s) = (\\<alpha> l) @ (e,a) # (\\<alpha> r)\"\n    \"\\<not> p (i + sum_list (map snd (\\<alpha> l)))\"\n    \"p (i + sum_list (map snd (\\<alpha> l)) + a)\"\n    \"invar l\"\n    \"invar r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l e a r.\n        \\<lbrakk>splits p i s = (l, (e, a), r);\n         \\<alpha> s = \\<alpha> l @ (e, a) # \\<alpha> r;\n         \\<not> p (i + sum_list (map snd (\\<alpha> l)));\n         p (i + sum_list (map snd (\\<alpha> l)) + a); invar l;\n         invar r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  invar s\n  \\<forall>a b. p a \\<longrightarrow> p (a + b)\n  \\<not> p i\n  p (i + sum_list (map snd (\\<alpha> s)))\n\ngoal (1 subgoal):\n 1. (\\<And>l e a r.\n        \\<lbrakk>splits p i s = (l, (e, a), r);\n         \\<alpha> s = \\<alpha> l @ (e, a) # \\<alpha> r;\n         \\<not> p (i + sum_list (map snd (\\<alpha> l)));\n         p (i + sum_list (map snd (\\<alpha> l)) + a); invar l;\n         invar r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (cases \"splits p i s\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>\\<And>l e a r.\n                   \\<lbrakk>splits p i s = (l, (e, a), r);\n                    \\<alpha> s = \\<alpha> l @ (e, a) # \\<alpha> r;\n                    \\<not> p (i + sum_list (map snd (\\<alpha> l)));\n                    p (i + sum_list (map snd (\\<alpha> l)) + a); invar l;\n                    invar r\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        invar s; \\<forall>a b. p a \\<longrightarrow> p (a + b); \\<not> p i;\n        p (i + sum_list (map snd (\\<alpha> s)));\n        splits p i s = (a, b, c)\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (case_tac b)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c aa ba.\n       \\<lbrakk>\\<And>l e a r.\n                   \\<lbrakk>splits p i s = (l, (e, a), r);\n                    \\<alpha> s = \\<alpha> l @ (e, a) # \\<alpha> r;\n                    \\<not> p (i + sum_list (map snd (\\<alpha> l)));\n                    p (i + sum_list (map snd (\\<alpha> l)) + a); invar l;\n                    invar r\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        invar s; \\<forall>a b. p a \\<longrightarrow> p (a + b); \\<not> p i;\n        p (i + sum_list (map snd (\\<alpha> s))); splits p i s = (a, b, c);\n        b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (drule_tac i = i and p = p \n      and l = a and r = c and e = aa and a = ba in  splits_correct)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a b c aa ba.\n       \\<lbrakk>\\<And>l e a r.\n                   \\<lbrakk>splits p i s = (l, (e, a), r);\n                    \\<alpha> s = \\<alpha> l @ (e, a) # \\<alpha> r;\n                    \\<not> p (i + sum_list (map snd (\\<alpha> l)));\n                    p (i + sum_list (map snd (\\<alpha> l)) + a); invar l;\n                    invar r\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<forall>a b. p a \\<longrightarrow> p (a + b); \\<not> p i;\n        p (i + sum_list (map snd (\\<alpha> s))); splits p i s = (a, b, c);\n        b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a b. p a \\<longrightarrow> p (a + b)\n 2. \\<And>a b c aa ba.\n       \\<lbrakk>\\<And>l e a r.\n                   \\<lbrakk>splits p i s = (l, (e, a), r);\n                    \\<alpha> s = \\<alpha> l @ (e, a) # \\<alpha> r;\n                    \\<not> p (i + sum_list (map snd (\\<alpha> l)));\n                    p (i + sum_list (map snd (\\<alpha> l)) + a); invar l;\n                    invar r\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<forall>a b. p a \\<longrightarrow> p (a + b); \\<not> p i;\n        p (i + sum_list (map snd (\\<alpha> s))); splits p i s = (a, b, c);\n        b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> \\<not> p i\n 3. \\<And>a b c aa ba.\n       \\<lbrakk>\\<And>l e a r.\n                   \\<lbrakk>splits p i s = (l, (e, a), r);\n                    \\<alpha> s = \\<alpha> l @ (e, a) # \\<alpha> r;\n                    \\<not> p (i + sum_list (map snd (\\<alpha> l)));\n                    p (i + sum_list (map snd (\\<alpha> l)) + a); invar l;\n                    invar r\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<forall>a b. p a \\<longrightarrow> p (a + b); \\<not> p i;\n        p (i + sum_list (map snd (\\<alpha> s))); splits p i s = (a, b, c);\n        b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> p (i + sum_list (map snd (\\<alpha> s)))\n 4. \\<And>a b c aa ba.\n       \\<lbrakk>\\<And>l e a r.\n                   \\<lbrakk>splits p i s = (l, (e, a), r);\n                    \\<alpha> s = \\<alpha> l @ (e, a) # \\<alpha> r;\n                    \\<not> p (i + sum_list (map snd (\\<alpha> l)));\n                    p (i + sum_list (map snd (\\<alpha> l)) + a); invar l;\n                    invar r\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<forall>a b. p a \\<longrightarrow> p (a + b); \\<not> p i;\n        p (i + sum_list (map snd (\\<alpha> s))); splits p i s = (a, b, c);\n        b = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> splits p i s = (a, (aa, ba), c)\n 5. \\<And>a b c aa ba.\n       \\<lbrakk>\\<And>l e a r.\n                   \\<lbrakk>splits p i s = (l, (e, a), r);\n                    \\<alpha> s = \\<alpha> l @ (e, a) # \\<alpha> r;\n                    \\<not> p (i + sum_list (map snd (\\<alpha> l)));\n                    p (i + sum_list (map snd (\\<alpha> l)) + a); invar l;\n                    invar r\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<forall>a b. p a \\<longrightarrow> p (a + b); \\<not> p i;\n        p (i + sum_list (map snd (\\<alpha> s))); splits p i s = (a, b, c);\n        b = (aa, ba);\n        \\<alpha> s = \\<alpha> a @ (aa, ba) # \\<alpha> c \\<and>\n        \\<not> p (i + sum_list (map snd (\\<alpha> a))) \\<and>\n        p (i + sum_list (map snd (\\<alpha> a)) + ba) \\<and>\n        invar a \\<and> invar c\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "subsection \"Record Based Interface\""], ["", "record ('e,'a,'s) alist_ops =\n  alist_op_\\<alpha> ::\"'s \\<Rightarrow> ('e \\<times> 'a::monoid_add) list\"\n  alist_op_invar :: \"'s \\<Rightarrow> bool\"\n  alist_op_empty :: \"unit \\<Rightarrow> 's\"\n  alist_op_isEmpty :: \"'s \\<Rightarrow> bool\"\n  alist_op_count :: \"'s \\<Rightarrow> nat\"\n  alist_op_consl :: \"'e \\<Rightarrow> 'a \\<Rightarrow> 's \\<Rightarrow> 's\"\n  alist_op_consr :: \"'s \\<Rightarrow> 'e \\<Rightarrow> 'a \\<Rightarrow> 's\"\n  alist_op_head :: \"'s \\<Rightarrow> ('e \\<times> 'a)\"\n  alist_op_tail :: \"'s \\<Rightarrow> 's\"\n  alist_op_headR :: \"'s \\<Rightarrow> ('e \\<times> 'a)\"\n  alist_op_tailR :: \"'s \\<Rightarrow> 's\"\n  alist_op_app :: \"'s \\<Rightarrow> 's \\<Rightarrow> 's\"\n  alist_op_annot :: \"'s \\<Rightarrow> 'a\"\n  alist_op_splits :: \"('a \\<Rightarrow> bool) \\<Rightarrow> 'a \\<Rightarrow> 's \\<Rightarrow> ('s \\<times> ('e \\<times> 'a) \\<times> 's)\""], ["", "locale StdALDefs = poly_al_fold \"alist_op_\\<alpha> ops\" \"alist_op_invar ops\"\n  for ops :: \"('e,'a::monoid_add,'s,'more) alist_ops_scheme\"\nbegin"], ["", "abbreviation \\<alpha> where \"\\<alpha> == alist_op_\\<alpha> ops\""], ["", "abbreviation invar where \"invar == alist_op_invar ops \""], ["", "abbreviation empty where \"empty == alist_op_empty ops \""], ["", "abbreviation isEmpty where \"isEmpty == alist_op_isEmpty ops \""], ["", "abbreviation count where \"count == alist_op_count ops\""], ["", "abbreviation consl where \"consl == alist_op_consl ops \""], ["", "abbreviation consr where \"consr == alist_op_consr ops \""], ["", "abbreviation head where \"head == alist_op_head ops \""], ["", "abbreviation tail where \"tail == alist_op_tail ops \""], ["", "abbreviation headR where \"headR == alist_op_headR ops \""], ["", "abbreviation tailR where \"tailR == alist_op_tailR ops \""], ["", "abbreviation app where \"app == alist_op_app ops \""], ["", "abbreviation annot where \"annot == alist_op_annot ops \""], ["", "abbreviation splits where \"splits == alist_op_splits ops \""], ["", "end"], ["", "locale StdAL = StdALDefs ops +\n  al \\<alpha> invar +\n  al_empty \\<alpha> invar empty +\n  al_isEmpty \\<alpha> invar isEmpty +\n  al_count \\<alpha> invar count +\n  al_consl \\<alpha> invar consl +\n  al_consr \\<alpha> invar consr +\n  al_head \\<alpha> invar head +\n  al_tail \\<alpha> invar tail +\n  al_headR \\<alpha> invar headR +\n  al_tailR \\<alpha> invar tailR +\n  al_app \\<alpha> invar app +\n  al_annot \\<alpha> invar annot +\n  al_splits \\<alpha> invar splits\n  for ops\nbegin"], ["", "lemmas correct =\n    empty_correct \n    isEmpty_correct\n    count_correct\n    consl_correct\n    consr_correct\n    head_correct\n    tail_correct\n    headR_correct\n    tailR_correct\n    app_correct\n    annot_correct      \n    foldl_correct\n    foldr_correct"], ["", "end"], ["", "locale StdAL_no_invar = StdAL + al_no_invar \\<alpha> invar"], ["", "end"]]}