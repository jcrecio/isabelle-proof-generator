{"file_name": "/home/qj213/afp-2021-10-22/thys/Collections/Examples/ICF/Exploration.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Collections", "problem_names": ["theorem sse_term:\n  assumes finite[simp, intro!]: \"finite (R\\<^sup>*``\\<Sigma>i)\"\n  shows \"wf (sse_term_rel \\<Sigma>i R)\"", "lemma sse_invar_initial: \"(sse_initial \\<Sigma>i) \\<in> sse_invar \\<Sigma>i R\"", "theorem sse_invar_final: \n  \"\\<forall>S. S\\<in>wa_invar (sse_algo \\<Sigma>i R) \\<and> S\\<notin>wa_cond (sse_algo \\<Sigma>i R) \n    \\<longrightarrow> fst S = R\\<^sup>*``\\<Sigma>i\"", "lemma sse_invar_step: \"\\<lbrakk>S\\<in>sse_invar \\<Sigma>i R; (S,S')\\<in>sse_step R\\<rbrakk> \n  \\<Longrightarrow> S'\\<in>sse_invar \\<Sigma>i R\"\n  \\<comment> \\<open>Split the goal by the invariant:\\<close>", "theorem sse_while_algo: \"finite (R\\<^sup>*``\\<Sigma>i) \\<Longrightarrow> while_algo (sse_algo \\<Sigma>i R)\"", "theorem dfs_pref_sse: \n  \"wa_precise_refine (dfs_algo \\<Sigma>i R) (sse_algo \\<Sigma>i R) dfs_\\<alpha>\"", "theorem dfs_while_algo:\n  assumes finite[simp, intro!]: \"finite (R\\<^sup>*``\\<Sigma>i)\"\n  shows \"while_algo (dfs_algo \\<Sigma>i R)\"", "lemmas dfs_invar_final = \n  wa_precise_refine.transfer_correctness[OF dfs_pref_sse sse_invar_final]"], "translations": [["", "theorem sse_term:\n  assumes finite[simp, intro!]: \"finite (R\\<^sup>*``\\<Sigma>i)\"\n  shows \"wf (sse_term_rel \\<Sigma>i R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (sse_term_rel \\<Sigma>i R)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wf (sse_term_rel \\<Sigma>i R)", "have \"wf (({(\\<Sigma>',\\<Sigma>). \\<Sigma> \\<subset> \\<Sigma>' \\<and> \\<Sigma>' \\<subseteq> (R\\<^sup>*``\\<Sigma>i)}) <*lex*> finite_psubset)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf ({(\\<Sigma>', \\<Sigma>).\n         \\<Sigma> \\<subset> \\<Sigma>' \\<and>\n         \\<Sigma>' \\<subseteq> R\\<^sup>* `` \\<Sigma>i} <*lex*>\n        finite_psubset)", "by (auto intro: wf_bounded_supset)"], ["proof (state)\nthis:\n  wf ({(\\<Sigma>', \\<Sigma>).\n       \\<Sigma> \\<subset> \\<Sigma>' \\<and>\n       \\<Sigma>' \\<subseteq> R\\<^sup>* `` \\<Sigma>i} <*lex*>\n      finite_psubset)\n\ngoal (1 subgoal):\n 1. wf (sse_term_rel \\<Sigma>i R)", "moreover"], ["proof (state)\nthis:\n  wf ({(\\<Sigma>', \\<Sigma>).\n       \\<Sigma> \\<subset> \\<Sigma>' \\<and>\n       \\<Sigma>' \\<subseteq> R\\<^sup>* `` \\<Sigma>i} <*lex*>\n      finite_psubset)\n\ngoal (1 subgoal):\n 1. wf (sse_term_rel \\<Sigma>i R)", "have \"sse_term_rel \\<Sigma>i R \\<subseteq> \\<dots>\" (is \"_ \\<subseteq> ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. sse_term_rel \\<Sigma>i R\n    \\<subseteq> {(\\<Sigma>', \\<Sigma>).\n                 \\<Sigma> \\<subset> \\<Sigma>' \\<and>\n                 \\<Sigma>' \\<subseteq> R\\<^sup>* `` \\<Sigma>i} <*lex*>\n                finite_psubset", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> sse_term_rel \\<Sigma>i R \\<Longrightarrow>\n       x \\<in> {(\\<Sigma>', \\<Sigma>).\n                \\<Sigma> \\<subset> \\<Sigma>' \\<and>\n                \\<Sigma>' \\<subseteq> R\\<^sup>* `` \\<Sigma>i} <*lex*>\n               finite_psubset", "fix S"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> sse_term_rel \\<Sigma>i R \\<Longrightarrow>\n       x \\<in> {(\\<Sigma>', \\<Sigma>).\n                \\<Sigma> \\<subset> \\<Sigma>' \\<and>\n                \\<Sigma>' \\<subseteq> R\\<^sup>* `` \\<Sigma>i} <*lex*>\n               finite_psubset", "assume A: \"S\\<in>sse_term_rel \\<Sigma>i R\""], ["proof (state)\nthis:\n  S \\<in> sse_term_rel \\<Sigma>i R\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> sse_term_rel \\<Sigma>i R \\<Longrightarrow>\n       x \\<in> {(\\<Sigma>', \\<Sigma>).\n                \\<Sigma> \\<subset> \\<Sigma>' \\<and>\n                \\<Sigma>' \\<subseteq> R\\<^sup>* `` \\<Sigma>i} <*lex*>\n               finite_psubset", "obtain \\<Sigma> W \\<Sigma>' W' \\<sigma> where\n      [simp]: \"S=((\\<Sigma>',W'),(\\<Sigma>,W))\" and\n      S: \"(\\<Sigma>,W) \\<in> sse_invar \\<Sigma>i R\"\n         \"\\<sigma>\\<in>W\"\n         \"\\<Sigma>' = \\<Sigma> \\<union> R``{\\<sigma>}\"\n         \"W' = (W-{\\<sigma>}) \\<union> (R``{\\<sigma>} - \\<Sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<Sigma>' W' \\<Sigma> W \\<sigma>.\n        \\<lbrakk>S = ((\\<Sigma>', W'), \\<Sigma>, W);\n         (\\<Sigma>, W) \\<in> sse_invar \\<Sigma>i R; \\<sigma> \\<in> W;\n         \\<Sigma>' = \\<Sigma> \\<union> R `` {\\<sigma>};\n         W' = W - {\\<sigma>} \\<union> (R `` {\\<sigma>} - \\<Sigma>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>\\<Sigma>' W' \\<Sigma> W \\<sigma>.\n        \\<lbrakk>S = ((\\<Sigma>', W'), \\<Sigma>, W);\n         (\\<Sigma>, W) \\<in> sse_invar \\<Sigma>i R; \\<sigma> \\<in> W;\n         \\<Sigma>' = \\<Sigma> \\<union> R `` {\\<sigma>};\n         W' = W - {\\<sigma>} \\<union> (R `` {\\<sigma>} - \\<Sigma>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain \\<Sigma> W \\<Sigma>' W' where SF[simp]: \"S=((\\<Sigma>',W'),(\\<Sigma>,W))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<Sigma>' W' \\<Sigma> W.\n        S = ((\\<Sigma>', W'), \\<Sigma>, W) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases S) force"], ["proof (state)\nthis:\n  S = ((\\<Sigma>', W'), \\<Sigma>, W)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Sigma>' W' \\<Sigma> W \\<sigma>.\n        \\<lbrakk>S = ((\\<Sigma>', W'), \\<Sigma>, W);\n         (\\<Sigma>, W) \\<in> sse_invar \\<Sigma>i R; \\<sigma> \\<in> W;\n         \\<Sigma>' = \\<Sigma> \\<union> R `` {\\<sigma>};\n         W' = W - {\\<sigma>} \\<union> (R `` {\\<sigma>} - \\<Sigma>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from A"], ["proof (chain)\npicking this:\n  S \\<in> sse_term_rel \\<Sigma>i R", "have R: \"(\\<Sigma>,W) \\<in> sse_invar \\<Sigma>i R\" \"((\\<Sigma>,W),(\\<Sigma>',W'))\\<in>sse_step R\""], ["proof (prove)\nusing this:\n  S \\<in> sse_term_rel \\<Sigma>i R\n\ngoal (1 subgoal):\n 1. (\\<Sigma>, W) \\<in> sse_invar \\<Sigma>i R &&&\n    ((\\<Sigma>, W), \\<Sigma>', W') \\<in> sse_step R", "by (auto simp add: sse_term_rel_def)"], ["proof (state)\nthis:\n  (\\<Sigma>, W) \\<in> sse_invar \\<Sigma>i R\n  ((\\<Sigma>, W), \\<Sigma>', W') \\<in> sse_step R\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Sigma>' W' \\<Sigma> W \\<sigma>.\n        \\<lbrakk>S = ((\\<Sigma>', W'), \\<Sigma>, W);\n         (\\<Sigma>, W) \\<in> sse_invar \\<Sigma>i R; \\<sigma> \\<in> W;\n         \\<Sigma>' = \\<Sigma> \\<union> R `` {\\<sigma>};\n         W' = W - {\\<sigma>} \\<union> (R `` {\\<sigma>} - \\<Sigma>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from sse_step.cases[OF R(2)]"], ["proof (chain)\npicking this:\n  (\\<And>\\<sigma> Wa \\<Sigma>'' \\<Sigma>''' W'a.\n      \\<lbrakk>\\<Sigma> = \\<Sigma>'''; W = Wa; \\<Sigma>' = \\<Sigma>'';\n       W' = W'a; \\<sigma> \\<in> Wa;\n       \\<Sigma>'' = \\<Sigma>''' \\<union> R `` {\\<sigma>};\n       W'a =\n       Wa - {\\<sigma>} \\<union> (R `` {\\<sigma>} - \\<Sigma>''')\\<rbrakk>\n      \\<Longrightarrow> ?P) \\<Longrightarrow>\n  ?P", "obtain \\<sigma> where S:\n        \"\\<sigma>\\<in>W\"\n        \"\\<Sigma>' = \\<Sigma> \\<union> R``{\\<sigma>}\"\n        \"W' = (W-{\\<sigma>}) \\<union> (R``{\\<sigma>} - \\<Sigma>)\""], ["proof (prove)\nusing this:\n  (\\<And>\\<sigma> Wa \\<Sigma>'' \\<Sigma>''' W'a.\n      \\<lbrakk>\\<Sigma> = \\<Sigma>'''; W = Wa; \\<Sigma>' = \\<Sigma>'';\n       W' = W'a; \\<sigma> \\<in> Wa;\n       \\<Sigma>'' = \\<Sigma>''' \\<union> R `` {\\<sigma>};\n       W'a =\n       Wa - {\\<sigma>} \\<union> (R `` {\\<sigma>} - \\<Sigma>''')\\<rbrakk>\n      \\<Longrightarrow> ?P) \\<Longrightarrow>\n  ?P\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>.\n        \\<lbrakk>\\<sigma> \\<in> W;\n         \\<Sigma>' = \\<Sigma> \\<union> R `` {\\<sigma>};\n         W' = W - {\\<sigma>} \\<union> (R `` {\\<sigma>} - \\<Sigma>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  \\<sigma> \\<in> W\n  \\<Sigma>' = \\<Sigma> \\<union> R `` {\\<sigma>}\n  W' = W - {\\<sigma>} \\<union> (R `` {\\<sigma>} - \\<Sigma>)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<Sigma>' W' \\<Sigma> W \\<sigma>.\n        \\<lbrakk>S = ((\\<Sigma>', W'), \\<Sigma>, W);\n         (\\<Sigma>, W) \\<in> sse_invar \\<Sigma>i R; \\<sigma> \\<in> W;\n         \\<Sigma>' = \\<Sigma> \\<union> R `` {\\<sigma>};\n         W' = W - {\\<sigma>} \\<union> (R `` {\\<sigma>} - \\<Sigma>)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<sigma> \\<in> W\n  \\<Sigma>' = \\<Sigma> \\<union> R `` {\\<sigma>}\n  W' = W - {\\<sigma>} \\<union> (R `` {\\<sigma>} - \\<Sigma>)\n\ngoal (1 subgoal):\n 1. thesis", "by (rule_tac that[OF SF R(1) S])"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  S = ((\\<Sigma>', W'), \\<Sigma>, W)\n  (\\<Sigma>, W) \\<in> sse_invar \\<Sigma>i R\n  \\<sigma> \\<in> W\n  \\<Sigma>' = \\<Sigma> \\<union> R `` {\\<sigma>}\n  W' = W - {\\<sigma>} \\<union> (R `` {\\<sigma>} - \\<Sigma>)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> sse_term_rel \\<Sigma>i R \\<Longrightarrow>\n       x \\<in> {(\\<Sigma>', \\<Sigma>).\n                \\<Sigma> \\<subset> \\<Sigma>' \\<and>\n                \\<Sigma>' \\<subseteq> R\\<^sup>* `` \\<Sigma>i} <*lex*>\n               finite_psubset", "from S(1)"], ["proof (chain)\npicking this:\n  (\\<Sigma>, W) \\<in> sse_invar \\<Sigma>i R", "have \n      [simp, intro!]: \"finite \\<Sigma>\" \"finite W\" and\n      WSS: \"W\\<subseteq>\\<Sigma>\" and\n      SSS: \"\\<Sigma>\\<subseteq>R\\<^sup>*``\\<Sigma>i\""], ["proof (prove)\nusing this:\n  (\\<Sigma>, W) \\<in> sse_invar \\<Sigma>i R\n\ngoal (1 subgoal):\n 1. (finite \\<Sigma> &&& finite W) &&&\n    W \\<subseteq> \\<Sigma> &&& \\<Sigma> \\<subseteq> R\\<^sup>* `` \\<Sigma>i", "by (auto simp add: sse_invar_def intro: finite_subset)"], ["proof (state)\nthis:\n  finite \\<Sigma>\n  finite W\n  W \\<subseteq> \\<Sigma>\n  \\<Sigma> \\<subseteq> R\\<^sup>* `` \\<Sigma>i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> sse_term_rel \\<Sigma>i R \\<Longrightarrow>\n       x \\<in> {(\\<Sigma>', \\<Sigma>).\n                \\<Sigma> \\<subset> \\<Sigma>' \\<and>\n                \\<Sigma>' \\<subseteq> R\\<^sup>* `` \\<Sigma>i} <*lex*>\n               finite_psubset", "show \"S\\<in>?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<in> {(\\<Sigma>', \\<Sigma>).\n             \\<Sigma> \\<subset> \\<Sigma>' \\<and>\n             \\<Sigma>' \\<subseteq> R\\<^sup>* `` \\<Sigma>i} <*lex*>\n            finite_psubset", "proof (cases \"R``{\\<sigma>} \\<subseteq> \\<Sigma>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. R `` {\\<sigma>} \\<subseteq> \\<Sigma> \\<Longrightarrow>\n    S \\<in> {(\\<Sigma>', \\<Sigma>).\n             \\<Sigma> \\<subset> \\<Sigma>' \\<and>\n             \\<Sigma>' \\<subseteq> R\\<^sup>* `` \\<Sigma>i} <*lex*>\n            finite_psubset\n 2. \\<not> R `` {\\<sigma>} \\<subseteq> \\<Sigma> \\<Longrightarrow>\n    S \\<in> {(\\<Sigma>', \\<Sigma>).\n             \\<Sigma> \\<subset> \\<Sigma>' \\<and>\n             \\<Sigma>' \\<subseteq> R\\<^sup>* `` \\<Sigma>i} <*lex*>\n            finite_psubset", "case True"], ["proof (state)\nthis:\n  R `` {\\<sigma>} \\<subseteq> \\<Sigma>\n\ngoal (2 subgoals):\n 1. R `` {\\<sigma>} \\<subseteq> \\<Sigma> \\<Longrightarrow>\n    S \\<in> {(\\<Sigma>', \\<Sigma>).\n             \\<Sigma> \\<subset> \\<Sigma>' \\<and>\n             \\<Sigma>' \\<subseteq> R\\<^sup>* `` \\<Sigma>i} <*lex*>\n            finite_psubset\n 2. \\<not> R `` {\\<sigma>} \\<subseteq> \\<Sigma> \\<Longrightarrow>\n    S \\<in> {(\\<Sigma>', \\<Sigma>).\n             \\<Sigma> \\<subset> \\<Sigma>' \\<and>\n             \\<Sigma>' \\<subseteq> R\\<^sup>* `` \\<Sigma>i} <*lex*>\n            finite_psubset", "with S"], ["proof (chain)\npicking this:\n  (\\<Sigma>, W) \\<in> sse_invar \\<Sigma>i R\n  \\<sigma> \\<in> W\n  \\<Sigma>' = \\<Sigma> \\<union> R `` {\\<sigma>}\n  W' = W - {\\<sigma>} \\<union> (R `` {\\<sigma>} - \\<Sigma>)\n  R `` {\\<sigma>} \\<subseteq> \\<Sigma>", "have \"\\<Sigma>'=\\<Sigma>\" \"W' \\<subset> W\""], ["proof (prove)\nusing this:\n  (\\<Sigma>, W) \\<in> sse_invar \\<Sigma>i R\n  \\<sigma> \\<in> W\n  \\<Sigma>' = \\<Sigma> \\<union> R `` {\\<sigma>}\n  W' = W - {\\<sigma>} \\<union> (R `` {\\<sigma>} - \\<Sigma>)\n  R `` {\\<sigma>} \\<subseteq> \\<Sigma>\n\ngoal (1 subgoal):\n 1. \\<Sigma>' = \\<Sigma> &&& W' \\<subset> W", "by auto"], ["proof (state)\nthis:\n  \\<Sigma>' = \\<Sigma>\n  W' \\<subset> W\n\ngoal (2 subgoals):\n 1. R `` {\\<sigma>} \\<subseteq> \\<Sigma> \\<Longrightarrow>\n    S \\<in> {(\\<Sigma>', \\<Sigma>).\n             \\<Sigma> \\<subset> \\<Sigma>' \\<and>\n             \\<Sigma>' \\<subseteq> R\\<^sup>* `` \\<Sigma>i} <*lex*>\n            finite_psubset\n 2. \\<not> R `` {\\<sigma>} \\<subseteq> \\<Sigma> \\<Longrightarrow>\n    S \\<in> {(\\<Sigma>', \\<Sigma>).\n             \\<Sigma> \\<subset> \\<Sigma>' \\<and>\n             \\<Sigma>' \\<subseteq> R\\<^sup>* `` \\<Sigma>i} <*lex*>\n            finite_psubset", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<Sigma>' = \\<Sigma>\n  W' \\<subset> W\n\ngoal (1 subgoal):\n 1. S \\<in> {(\\<Sigma>', \\<Sigma>).\n             \\<Sigma> \\<subset> \\<Sigma>' \\<and>\n             \\<Sigma>' \\<subseteq> R\\<^sup>* `` \\<Sigma>i} <*lex*>\n            finite_psubset", "by (simp)"], ["proof (state)\nthis:\n  S \\<in> {(\\<Sigma>', \\<Sigma>).\n           \\<Sigma> \\<subset> \\<Sigma>' \\<and>\n           \\<Sigma>' \\<subseteq> R\\<^sup>* `` \\<Sigma>i} <*lex*>\n          finite_psubset\n\ngoal (1 subgoal):\n 1. \\<not> R `` {\\<sigma>} \\<subseteq> \\<Sigma> \\<Longrightarrow>\n    S \\<in> {(\\<Sigma>', \\<Sigma>).\n             \\<Sigma> \\<subset> \\<Sigma>' \\<and>\n             \\<Sigma>' \\<subseteq> R\\<^sup>* `` \\<Sigma>i} <*lex*>\n            finite_psubset", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> R `` {\\<sigma>} \\<subseteq> \\<Sigma> \\<Longrightarrow>\n    S \\<in> {(\\<Sigma>', \\<Sigma>).\n             \\<Sigma> \\<subset> \\<Sigma>' \\<and>\n             \\<Sigma>' \\<subseteq> R\\<^sup>* `` \\<Sigma>i} <*lex*>\n            finite_psubset", "case False"], ["proof (state)\nthis:\n  \\<not> R `` {\\<sigma>} \\<subseteq> \\<Sigma>\n\ngoal (1 subgoal):\n 1. \\<not> R `` {\\<sigma>} \\<subseteq> \\<Sigma> \\<Longrightarrow>\n    S \\<in> {(\\<Sigma>', \\<Sigma>).\n             \\<Sigma> \\<subset> \\<Sigma>' \\<and>\n             \\<Sigma>' \\<subseteq> R\\<^sup>* `` \\<Sigma>i} <*lex*>\n            finite_psubset", "with S"], ["proof (chain)\npicking this:\n  (\\<Sigma>, W) \\<in> sse_invar \\<Sigma>i R\n  \\<sigma> \\<in> W\n  \\<Sigma>' = \\<Sigma> \\<union> R `` {\\<sigma>}\n  W' = W - {\\<sigma>} \\<union> (R `` {\\<sigma>} - \\<Sigma>)\n  \\<not> R `` {\\<sigma>} \\<subseteq> \\<Sigma>", "have \"\\<Sigma>' \\<supset> \\<Sigma>\""], ["proof (prove)\nusing this:\n  (\\<Sigma>, W) \\<in> sse_invar \\<Sigma>i R\n  \\<sigma> \\<in> W\n  \\<Sigma>' = \\<Sigma> \\<union> R `` {\\<sigma>}\n  W' = W - {\\<sigma>} \\<union> (R `` {\\<sigma>} - \\<Sigma>)\n  \\<not> R `` {\\<sigma>} \\<subseteq> \\<Sigma>\n\ngoal (1 subgoal):\n 1. \\<Sigma> \\<subset> \\<Sigma>'", "by auto"], ["proof (state)\nthis:\n  \\<Sigma> \\<subset> \\<Sigma>'\n\ngoal (1 subgoal):\n 1. \\<not> R `` {\\<sigma>} \\<subseteq> \\<Sigma> \\<Longrightarrow>\n    S \\<in> {(\\<Sigma>', \\<Sigma>).\n             \\<Sigma> \\<subset> \\<Sigma>' \\<and>\n             \\<Sigma>' \\<subseteq> R\\<^sup>* `` \\<Sigma>i} <*lex*>\n            finite_psubset", "moreover"], ["proof (state)\nthis:\n  \\<Sigma> \\<subset> \\<Sigma>'\n\ngoal (1 subgoal):\n 1. \\<not> R `` {\\<sigma>} \\<subseteq> \\<Sigma> \\<Longrightarrow>\n    S \\<in> {(\\<Sigma>', \\<Sigma>).\n             \\<Sigma> \\<subset> \\<Sigma>' \\<and>\n             \\<Sigma>' \\<subseteq> R\\<^sup>* `` \\<Sigma>i} <*lex*>\n            finite_psubset", "from S(2) WSS SSS"], ["proof (chain)\npicking this:\n  \\<sigma> \\<in> W\n  W \\<subseteq> \\<Sigma>\n  \\<Sigma> \\<subseteq> R\\<^sup>* `` \\<Sigma>i", "have \"\\<sigma>\\<in>R\\<^sup>*``\\<Sigma>i\""], ["proof (prove)\nusing this:\n  \\<sigma> \\<in> W\n  W \\<subseteq> \\<Sigma>\n  \\<Sigma> \\<subseteq> R\\<^sup>* `` \\<Sigma>i\n\ngoal (1 subgoal):\n 1. \\<sigma> \\<in> R\\<^sup>* `` \\<Sigma>i", "by auto"], ["proof (state)\nthis:\n  \\<sigma> \\<in> R\\<^sup>* `` \\<Sigma>i\n\ngoal (1 subgoal):\n 1. \\<not> R `` {\\<sigma>} \\<subseteq> \\<Sigma> \\<Longrightarrow>\n    S \\<in> {(\\<Sigma>', \\<Sigma>).\n             \\<Sigma> \\<subset> \\<Sigma>' \\<and>\n             \\<Sigma>' \\<subseteq> R\\<^sup>* `` \\<Sigma>i} <*lex*>\n            finite_psubset", "hence \"R``{\\<sigma>} \\<subseteq> R\\<^sup>*``\\<Sigma>i\""], ["proof (prove)\nusing this:\n  \\<sigma> \\<in> R\\<^sup>* `` \\<Sigma>i\n\ngoal (1 subgoal):\n 1. R `` {\\<sigma>} \\<subseteq> R\\<^sup>* `` \\<Sigma>i", "by (auto intro: rtrancl_into_rtrancl)"], ["proof (state)\nthis:\n  R `` {\\<sigma>} \\<subseteq> R\\<^sup>* `` \\<Sigma>i\n\ngoal (1 subgoal):\n 1. \\<not> R `` {\\<sigma>} \\<subseteq> \\<Sigma> \\<Longrightarrow>\n    S \\<in> {(\\<Sigma>', \\<Sigma>).\n             \\<Sigma> \\<subset> \\<Sigma>' \\<and>\n             \\<Sigma>' \\<subseteq> R\\<^sup>* `` \\<Sigma>i} <*lex*>\n            finite_psubset", "with S(3) SSS"], ["proof (chain)\npicking this:\n  \\<Sigma>' = \\<Sigma> \\<union> R `` {\\<sigma>}\n  \\<Sigma> \\<subseteq> R\\<^sup>* `` \\<Sigma>i\n  R `` {\\<sigma>} \\<subseteq> R\\<^sup>* `` \\<Sigma>i", "have \"\\<Sigma>' \\<subseteq> R\\<^sup>*``\\<Sigma>i\""], ["proof (prove)\nusing this:\n  \\<Sigma>' = \\<Sigma> \\<union> R `` {\\<sigma>}\n  \\<Sigma> \\<subseteq> R\\<^sup>* `` \\<Sigma>i\n  R `` {\\<sigma>} \\<subseteq> R\\<^sup>* `` \\<Sigma>i\n\ngoal (1 subgoal):\n 1. \\<Sigma>' \\<subseteq> R\\<^sup>* `` \\<Sigma>i", "by auto"], ["proof (state)\nthis:\n  \\<Sigma>' \\<subseteq> R\\<^sup>* `` \\<Sigma>i\n\ngoal (1 subgoal):\n 1. \\<not> R `` {\\<sigma>} \\<subseteq> \\<Sigma> \\<Longrightarrow>\n    S \\<in> {(\\<Sigma>', \\<Sigma>).\n             \\<Sigma> \\<subset> \\<Sigma>' \\<and>\n             \\<Sigma>' \\<subseteq> R\\<^sup>* `` \\<Sigma>i} <*lex*>\n            finite_psubset", "ultimately"], ["proof (chain)\npicking this:\n  \\<Sigma> \\<subset> \\<Sigma>'\n  \\<Sigma>' \\<subseteq> R\\<^sup>* `` \\<Sigma>i", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Sigma> \\<subset> \\<Sigma>'\n  \\<Sigma>' \\<subseteq> R\\<^sup>* `` \\<Sigma>i\n\ngoal (1 subgoal):\n 1. S \\<in> {(\\<Sigma>', \\<Sigma>).\n             \\<Sigma> \\<subset> \\<Sigma>' \\<and>\n             \\<Sigma>' \\<subseteq> R\\<^sup>* `` \\<Sigma>i} <*lex*>\n            finite_psubset", "by force"], ["proof (state)\nthis:\n  S \\<in> {(\\<Sigma>', \\<Sigma>).\n           \\<Sigma> \\<subset> \\<Sigma>' \\<and>\n           \\<Sigma>' \\<subseteq> R\\<^sup>* `` \\<Sigma>i} <*lex*>\n          finite_psubset\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  S \\<in> {(\\<Sigma>', \\<Sigma>).\n           \\<Sigma> \\<subset> \\<Sigma>' \\<and>\n           \\<Sigma>' \\<subseteq> R\\<^sup>* `` \\<Sigma>i} <*lex*>\n          finite_psubset\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sse_term_rel \\<Sigma>i R\n  \\<subseteq> {(\\<Sigma>', \\<Sigma>).\n               \\<Sigma> \\<subset> \\<Sigma>' \\<and>\n               \\<Sigma>' \\<subseteq> R\\<^sup>* `` \\<Sigma>i} <*lex*>\n              finite_psubset\n\ngoal (1 subgoal):\n 1. wf (sse_term_rel \\<Sigma>i R)", "ultimately"], ["proof (chain)\npicking this:\n  wf ({(\\<Sigma>', \\<Sigma>).\n       \\<Sigma> \\<subset> \\<Sigma>' \\<and>\n       \\<Sigma>' \\<subseteq> R\\<^sup>* `` \\<Sigma>i} <*lex*>\n      finite_psubset)\n  sse_term_rel \\<Sigma>i R\n  \\<subseteq> {(\\<Sigma>', \\<Sigma>).\n               \\<Sigma> \\<subset> \\<Sigma>' \\<and>\n               \\<Sigma>' \\<subseteq> R\\<^sup>* `` \\<Sigma>i} <*lex*>\n              finite_psubset", "show ?thesis"], ["proof (prove)\nusing this:\n  wf ({(\\<Sigma>', \\<Sigma>).\n       \\<Sigma> \\<subset> \\<Sigma>' \\<and>\n       \\<Sigma>' \\<subseteq> R\\<^sup>* `` \\<Sigma>i} <*lex*>\n      finite_psubset)\n  sse_term_rel \\<Sigma>i R\n  \\<subseteq> {(\\<Sigma>', \\<Sigma>).\n               \\<Sigma> \\<subset> \\<Sigma>' \\<and>\n               \\<Sigma>' \\<subseteq> R\\<^sup>* `` \\<Sigma>i} <*lex*>\n              finite_psubset\n\ngoal (1 subgoal):\n 1. wf (sse_term_rel \\<Sigma>i R)", "by (auto intro: wf_subset)"], ["proof (state)\nthis:\n  wf (sse_term_rel \\<Sigma>i R)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sse_invar_initial: \"(sse_initial \\<Sigma>i) \\<in> sse_invar \\<Sigma>i R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sse_initial \\<Sigma>i \\<in> sse_invar \\<Sigma>i R", "by (unfold sse_invar_def sse_initial_def)\n     (auto elim: rtrancl_last_touch)\n\n  \\<comment> \\<open>Correctness theorem: If the loop terminates, the discovered states are\n       exactly the reachable states\\<close>"], ["", "theorem sse_invar_final: \n  \"\\<forall>S. S\\<in>wa_invar (sse_algo \\<Sigma>i R) \\<and> S\\<notin>wa_cond (sse_algo \\<Sigma>i R) \n    \\<longrightarrow> fst S = R\\<^sup>*``\\<Sigma>i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>S.\n       S \\<in> wa_invar (sse_algo \\<Sigma>i R) \\<and>\n       S \\<notin> wa_cond (sse_algo \\<Sigma>i R) \\<longrightarrow>\n       fst S = R\\<^sup>* `` \\<Sigma>i", "by (intro allI, case_tac S)\n     (auto simp add: sse_invar_def sse_cond_def sse_algo_def)"], ["", "lemma sse_invar_step: \"\\<lbrakk>S\\<in>sse_invar \\<Sigma>i R; (S,S')\\<in>sse_step R\\<rbrakk> \n  \\<Longrightarrow> S'\\<in>sse_invar \\<Sigma>i R\"\n  \\<comment> \\<open>Split the goal by the invariant:\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S \\<in> sse_invar \\<Sigma>i R;\n     (S, S') \\<in> sse_step R\\<rbrakk>\n    \\<Longrightarrow> S' \\<in> sse_invar \\<Sigma>i R", "apply (cases S, cases S')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>S \\<in> sse_invar \\<Sigma>i R; (S, S') \\<in> sse_step R;\n        S = (a, b); S' = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> sse_invar \\<Sigma>i R", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<in> sse_invar \\<Sigma>i R;\n        ((a, b), aa, ba) \\<in> sse_step R; S = (a, b);\n        S' = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> (aa, ba) \\<in> sse_invar \\<Sigma>i R", "apply (erule sse_step.cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba \\<sigma> W \\<Sigma>' \\<Sigma> W'.\n       \\<lbrakk>(a, b) \\<in> sse_invar \\<Sigma>i R; S = (a, b);\n        S' = (aa, ba); a = \\<Sigma>; b = W; aa = \\<Sigma>'; ba = W';\n        \\<sigma> \\<in> W; \\<Sigma>' = \\<Sigma> \\<union> R `` {\\<sigma>};\n        W' = W - {\\<sigma>} \\<union> (R `` {\\<sigma>} - \\<Sigma>)\\<rbrakk>\n       \\<Longrightarrow> (aa, ba) \\<in> sse_invar \\<Sigma>i R", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> W \\<Sigma>.\n       \\<lbrakk>(\\<Sigma>, W) \\<in> sse_invar \\<Sigma>i R;\n        S = (\\<Sigma>, W);\n        S' =\n        (\\<Sigma> \\<union> R `` {\\<sigma>},\n         W - {\\<sigma>} \\<union> (R `` {\\<sigma>} - \\<Sigma>));\n        \\<sigma> \\<in> W\\<rbrakk>\n       \\<Longrightarrow> (\\<Sigma> \\<union> R `` {\\<sigma>},\n                          W - {\\<sigma>} \\<union>\n                          (R `` {\\<sigma>} - \\<Sigma>))\n                         \\<in> sse_invar \\<Sigma>i R", "apply (subst sse_invar_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> W \\<Sigma>.\n       \\<lbrakk>(\\<Sigma>, W) \\<in> sse_invar \\<Sigma>i R;\n        S = (\\<Sigma>, W);\n        S' =\n        (\\<Sigma> \\<union> R `` {\\<sigma>},\n         W - {\\<sigma>} \\<union> (R `` {\\<sigma>} - \\<Sigma>));\n        \\<sigma> \\<in> W\\<rbrakk>\n       \\<Longrightarrow> (\\<Sigma> \\<union> R `` {\\<sigma>},\n                          W - {\\<sigma>} \\<union>\n                          (R `` {\\<sigma>} - \\<Sigma>))\n                         \\<in> {(\\<Sigma>, W).\n                                W \\<subseteq> \\<Sigma> \\<and>\n                                \\<Sigma>\n                                \\<subseteq> R\\<^sup>* `` \\<Sigma>i \\<and>\n                                (\\<forall>\\<sigma>\n    \\<in>R\\<^sup>* `` \\<Sigma>i - \\<Sigma>.\n                                    \\<exists>\\<sigma>h\\<in>W.\n (\\<sigma>h, \\<sigma>) \\<in> (R - UNIV \\<times> \\<Sigma>)\\<^sup>*)}", "apply (simp add: Let_def split_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> W \\<Sigma>.\n       \\<lbrakk>(\\<Sigma>, W) \\<in> sse_invar \\<Sigma>i R;\n        S = (\\<Sigma>, W);\n        S' =\n        (\\<Sigma> \\<union> R `` {\\<sigma>},\n         W - {\\<sigma>} \\<union> (R `` {\\<sigma>} - \\<Sigma>));\n        \\<sigma> \\<in> W\\<rbrakk>\n       \\<Longrightarrow> W - {\\<sigma>}\n                         \\<subseteq> \\<Sigma> \\<union>\n                                     R `` {\\<sigma>} \\<and>\n                         R `` {\\<sigma>} - \\<Sigma>\n                         \\<subseteq> \\<Sigma> \\<union>\n                                     R `` {\\<sigma>} \\<and>\n                         \\<Sigma> \\<subseteq> R\\<^sup>* `` \\<Sigma>i \\<and>\n                         R `` {\\<sigma>}\n                         \\<subseteq> R\\<^sup>* `` \\<Sigma>i \\<and>\n                         (\\<forall>\\<sigma>'\n                                   \\<in>R\\<^sup>* `` \\<Sigma>i -\n  (\\<Sigma> \\<union> R `` {\\<sigma>}).\n                             \\<exists>\\<sigma>h\n\\<in>W - {\\<sigma>} \\<union> (R `` {\\<sigma>} - \\<Sigma>).\n                                (\\<sigma>h, \\<sigma>')\n                                \\<in> (R -\n UNIV \\<times> (\\<Sigma> \\<union> R `` {\\<sigma>}))\\<^sup>*)", "apply (intro conjI)\n  \\<comment> \\<open>Solve the easy parts automatically\\<close>"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>\\<sigma> W \\<Sigma>.\n       \\<lbrakk>(\\<Sigma>, W) \\<in> sse_invar \\<Sigma>i R;\n        S = (\\<Sigma>, W);\n        S' =\n        (\\<Sigma> \\<union> R `` {\\<sigma>},\n         W - {\\<sigma>} \\<union> (R `` {\\<sigma>} - \\<Sigma>));\n        \\<sigma> \\<in> W\\<rbrakk>\n       \\<Longrightarrow> W - {\\<sigma>}\n                         \\<subseteq> \\<Sigma> \\<union> R `` {\\<sigma>}\n 2. \\<And>\\<sigma> W \\<Sigma>.\n       \\<lbrakk>(\\<Sigma>, W) \\<in> sse_invar \\<Sigma>i R;\n        S = (\\<Sigma>, W);\n        S' =\n        (\\<Sigma> \\<union> R `` {\\<sigma>},\n         W - {\\<sigma>} \\<union> (R `` {\\<sigma>} - \\<Sigma>));\n        \\<sigma> \\<in> W\\<rbrakk>\n       \\<Longrightarrow> R `` {\\<sigma>} - \\<Sigma>\n                         \\<subseteq> \\<Sigma> \\<union> R `` {\\<sigma>}\n 3. \\<And>\\<sigma> W \\<Sigma>.\n       \\<lbrakk>(\\<Sigma>, W) \\<in> sse_invar \\<Sigma>i R;\n        S = (\\<Sigma>, W);\n        S' =\n        (\\<Sigma> \\<union> R `` {\\<sigma>},\n         W - {\\<sigma>} \\<union> (R `` {\\<sigma>} - \\<Sigma>));\n        \\<sigma> \\<in> W\\<rbrakk>\n       \\<Longrightarrow> \\<Sigma> \\<subseteq> R\\<^sup>* `` \\<Sigma>i\n 4. \\<And>\\<sigma> W \\<Sigma>.\n       \\<lbrakk>(\\<Sigma>, W) \\<in> sse_invar \\<Sigma>i R;\n        S = (\\<Sigma>, W);\n        S' =\n        (\\<Sigma> \\<union> R `` {\\<sigma>},\n         W - {\\<sigma>} \\<union> (R `` {\\<sigma>} - \\<Sigma>));\n        \\<sigma> \\<in> W\\<rbrakk>\n       \\<Longrightarrow> R `` {\\<sigma>} \\<subseteq> R\\<^sup>* `` \\<Sigma>i\n 5. \\<And>\\<sigma> W \\<Sigma>.\n       \\<lbrakk>(\\<Sigma>, W) \\<in> sse_invar \\<Sigma>i R;\n        S = (\\<Sigma>, W);\n        S' =\n        (\\<Sigma> \\<union> R `` {\\<sigma>},\n         W - {\\<sigma>} \\<union> (R `` {\\<sigma>} - \\<Sigma>));\n        \\<sigma> \\<in> W\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<sigma>'\n                                  \\<in>R\\<^sup>* `` \\<Sigma>i -\n (\\<Sigma> \\<union> R `` {\\<sigma>}).\n                            \\<exists>\\<sigma>h\n                                     \\<in>W - {\\<sigma>} \\<union>\n    (R `` {\\<sigma>} - \\<Sigma>).\n                               (\\<sigma>h, \\<sigma>')\n                               \\<in> (R -\nUNIV \\<times> (\\<Sigma> \\<union> R `` {\\<sigma>}))\\<^sup>*", "apply (auto simp add: sse_invar_def) [3]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma> W \\<Sigma>.\n       \\<lbrakk>(\\<Sigma>, W) \\<in> sse_invar \\<Sigma>i R;\n        S = (\\<Sigma>, W);\n        S' =\n        (\\<Sigma> \\<union> R `` {\\<sigma>},\n         W - {\\<sigma>} \\<union> (R `` {\\<sigma>} - \\<Sigma>));\n        \\<sigma> \\<in> W\\<rbrakk>\n       \\<Longrightarrow> R `` {\\<sigma>} \\<subseteq> R\\<^sup>* `` \\<Sigma>i\n 2. \\<And>\\<sigma> W \\<Sigma>.\n       \\<lbrakk>(\\<Sigma>, W) \\<in> sse_invar \\<Sigma>i R;\n        S = (\\<Sigma>, W);\n        S' =\n        (\\<Sigma> \\<union> R `` {\\<sigma>},\n         W - {\\<sigma>} \\<union> (R `` {\\<sigma>} - \\<Sigma>));\n        \\<sigma> \\<in> W\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<sigma>'\n                                  \\<in>R\\<^sup>* `` \\<Sigma>i -\n (\\<Sigma> \\<union> R `` {\\<sigma>}).\n                            \\<exists>\\<sigma>h\n                                     \\<in>W - {\\<sigma>} \\<union>\n    (R `` {\\<sigma>} - \\<Sigma>).\n                               (\\<sigma>h, \\<sigma>')\n                               \\<in> (R -\nUNIV \\<times> (\\<Sigma> \\<union> R `` {\\<sigma>}))\\<^sup>*", "apply (force simp add: sse_invar_def \n               dest: rtrancl_into_rtrancl) [1]\n  \\<comment> \\<open>Tackle the complex part (last part of the invariant) in Isar\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> W \\<Sigma>.\n       \\<lbrakk>(\\<Sigma>, W) \\<in> sse_invar \\<Sigma>i R;\n        S = (\\<Sigma>, W);\n        S' =\n        (\\<Sigma> \\<union> R `` {\\<sigma>},\n         W - {\\<sigma>} \\<union> (R `` {\\<sigma>} - \\<Sigma>));\n        \\<sigma> \\<in> W\\<rbrakk>\n       \\<Longrightarrow> \\<forall>\\<sigma>'\n                                  \\<in>R\\<^sup>* `` \\<Sigma>i -\n (\\<Sigma> \\<union> R `` {\\<sigma>}).\n                            \\<exists>\\<sigma>h\n                                     \\<in>W - {\\<sigma>} \\<union>\n    (R `` {\\<sigma>} - \\<Sigma>).\n                               (\\<sigma>h, \\<sigma>')\n                               \\<in> (R -\nUNIV \\<times> (\\<Sigma> \\<union> R `` {\\<sigma>}))\\<^sup>*", "proof (intro ballI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> W \\<Sigma> \\<sigma>'.\n       \\<lbrakk>(\\<Sigma>, W) \\<in> sse_invar \\<Sigma>i R;\n        S = (\\<Sigma>, W);\n        S' =\n        (\\<Sigma> \\<union> R `` {\\<sigma>},\n         W - {\\<sigma>} \\<union> (R `` {\\<sigma>} - \\<Sigma>));\n        \\<sigma> \\<in> W;\n        \\<sigma>'\n        \\<in> R\\<^sup>* `` \\<Sigma>i -\n              (\\<Sigma> \\<union> R `` {\\<sigma>})\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>h\n                                  \\<in>W - {\\<sigma>} \\<union>\n (R `` {\\<sigma>} - \\<Sigma>).\n                            (\\<sigma>h, \\<sigma>')\n                            \\<in> (R -\n                                   UNIV \\<times>\n                                   (\\<Sigma> \\<union>\n                                    R `` {\\<sigma>}))\\<^sup>*", "fix \\<sigma> W \\<Sigma> \\<sigma>'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> W \\<Sigma> \\<sigma>'.\n       \\<lbrakk>(\\<Sigma>, W) \\<in> sse_invar \\<Sigma>i R;\n        S = (\\<Sigma>, W);\n        S' =\n        (\\<Sigma> \\<union> R `` {\\<sigma>},\n         W - {\\<sigma>} \\<union> (R `` {\\<sigma>} - \\<Sigma>));\n        \\<sigma> \\<in> W;\n        \\<sigma>'\n        \\<in> R\\<^sup>* `` \\<Sigma>i -\n              (\\<Sigma> \\<union> R `` {\\<sigma>})\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>h\n                                  \\<in>W - {\\<sigma>} \\<union>\n (R `` {\\<sigma>} - \\<Sigma>).\n                            (\\<sigma>h, \\<sigma>')\n                            \\<in> (R -\n                                   UNIV \\<times>\n                                   (\\<Sigma> \\<union>\n                                    R `` {\\<sigma>}))\\<^sup>*", "assume A: \n    \"(\\<Sigma>,W)\\<in>sse_invar \\<Sigma>i R\"\n    \"\\<sigma>\\<in>W\"\n    \"\\<sigma>'\\<in>R\\<^sup>* `` \\<Sigma>i - (\\<Sigma> \\<union> R `` {\\<sigma>})\"\n    \\<comment> \\<open>Using the invariant of the original state, we obtain\n        a state in the original workset and a path not touching\n        the originally discovered states\\<close>"], ["proof (state)\nthis:\n  (\\<Sigma>, W) \\<in> sse_invar \\<Sigma>i R\n  \\<sigma> \\<in> W\n  \\<sigma>'\n  \\<in> R\\<^sup>* `` \\<Sigma>i - (\\<Sigma> \\<union> R `` {\\<sigma>})\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> W \\<Sigma> \\<sigma>'.\n       \\<lbrakk>(\\<Sigma>, W) \\<in> sse_invar \\<Sigma>i R;\n        S = (\\<Sigma>, W);\n        S' =\n        (\\<Sigma> \\<union> R `` {\\<sigma>},\n         W - {\\<sigma>} \\<union> (R `` {\\<sigma>} - \\<Sigma>));\n        \\<sigma> \\<in> W;\n        \\<sigma>'\n        \\<in> R\\<^sup>* `` \\<Sigma>i -\n              (\\<Sigma> \\<union> R `` {\\<sigma>})\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>h\n                                  \\<in>W - {\\<sigma>} \\<union>\n (R `` {\\<sigma>} - \\<Sigma>).\n                            (\\<sigma>h, \\<sigma>')\n                            \\<in> (R -\n                                   UNIV \\<times>\n                                   (\\<Sigma> \\<union>\n                                    R `` {\\<sigma>}))\\<^sup>*", "from A(3)"], ["proof (chain)\npicking this:\n  \\<sigma>'\n  \\<in> R\\<^sup>* `` \\<Sigma>i - (\\<Sigma> \\<union> R `` {\\<sigma>})", "have \"\\<sigma>' \\<in> R\\<^sup>* `` \\<Sigma>i - \\<Sigma>\""], ["proof (prove)\nusing this:\n  \\<sigma>'\n  \\<in> R\\<^sup>* `` \\<Sigma>i - (\\<Sigma> \\<union> R `` {\\<sigma>})\n\ngoal (1 subgoal):\n 1. \\<sigma>' \\<in> R\\<^sup>* `` \\<Sigma>i - \\<Sigma>", "by auto"], ["proof (state)\nthis:\n  \\<sigma>' \\<in> R\\<^sup>* `` \\<Sigma>i - \\<Sigma>\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> W \\<Sigma> \\<sigma>'.\n       \\<lbrakk>(\\<Sigma>, W) \\<in> sse_invar \\<Sigma>i R;\n        S = (\\<Sigma>, W);\n        S' =\n        (\\<Sigma> \\<union> R `` {\\<sigma>},\n         W - {\\<sigma>} \\<union> (R `` {\\<sigma>} - \\<Sigma>));\n        \\<sigma> \\<in> W;\n        \\<sigma>'\n        \\<in> R\\<^sup>* `` \\<Sigma>i -\n              (\\<Sigma> \\<union> R `` {\\<sigma>})\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>h\n                                  \\<in>W - {\\<sigma>} \\<union>\n (R `` {\\<sigma>} - \\<Sigma>).\n                            (\\<sigma>h, \\<sigma>')\n                            \\<in> (R -\n                                   UNIV \\<times>\n                                   (\\<Sigma> \\<union>\n                                    R `` {\\<sigma>}))\\<^sup>*", "with A(1)"], ["proof (chain)\npicking this:\n  (\\<Sigma>, W) \\<in> sse_invar \\<Sigma>i R\n  \\<sigma>' \\<in> R\\<^sup>* `` \\<Sigma>i - \\<Sigma>", "obtain \\<sigma>h where IP: \n    \"\\<sigma>h\\<in>W\" \n    \"(\\<sigma>h,\\<sigma>')\\<in>(R - (UNIV \\<times> \\<Sigma>))\\<^sup>*\" \n  and SS:\n    \"W\\<subseteq>\\<Sigma>\"\n    \"\\<Sigma>\\<subseteq>R\\<^sup>* `` \\<Sigma>i\""], ["proof (prove)\nusing this:\n  (\\<Sigma>, W) \\<in> sse_invar \\<Sigma>i R\n  \\<sigma>' \\<in> R\\<^sup>* `` \\<Sigma>i - \\<Sigma>\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>h.\n        \\<lbrakk>\\<sigma>h \\<in> W;\n         (\\<sigma>h, \\<sigma>') \\<in> (R - UNIV \\<times> \\<Sigma>)\\<^sup>*;\n         W \\<subseteq> \\<Sigma>;\n         \\<Sigma> \\<subseteq> R\\<^sup>* `` \\<Sigma>i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (unfold sse_invar_def) force\n\n  \\<comment> \\<open>We now make a case distinction, whether the obtained path contains\n      states from @{term \"post \\<sigma>\"} or not:\\<close>"], ["proof (state)\nthis:\n  \\<sigma>h \\<in> W\n  (\\<sigma>h, \\<sigma>') \\<in> (R - UNIV \\<times> \\<Sigma>)\\<^sup>*\n  W \\<subseteq> \\<Sigma>\n  \\<Sigma> \\<subseteq> R\\<^sup>* `` \\<Sigma>i\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> W \\<Sigma> \\<sigma>'.\n       \\<lbrakk>(\\<Sigma>, W) \\<in> sse_invar \\<Sigma>i R;\n        S = (\\<Sigma>, W);\n        S' =\n        (\\<Sigma> \\<union> R `` {\\<sigma>},\n         W - {\\<sigma>} \\<union> (R `` {\\<sigma>} - \\<Sigma>));\n        \\<sigma> \\<in> W;\n        \\<sigma>'\n        \\<in> R\\<^sup>* `` \\<Sigma>i -\n              (\\<Sigma> \\<union> R `` {\\<sigma>})\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>h\n                                  \\<in>W - {\\<sigma>} \\<union>\n (R `` {\\<sigma>} - \\<Sigma>).\n                            (\\<sigma>h, \\<sigma>')\n                            \\<in> (R -\n                                   UNIV \\<times>\n                                   (\\<Sigma> \\<union>\n                                    R `` {\\<sigma>}))\\<^sup>*", "from IP(2)"], ["proof (chain)\npicking this:\n  (\\<sigma>h, \\<sigma>') \\<in> (R - UNIV \\<times> \\<Sigma>)\\<^sup>*", "show \"\\<exists>\\<sigma>h\\<in>W - {\\<sigma>} \\<union> (R `` {\\<sigma>} - \\<Sigma>). \n                     (\\<sigma>h, \\<sigma>') \\<in> (R - UNIV \\<times> (\\<Sigma> \\<union> R `` {\\<sigma>}))\\<^sup>*\""], ["proof (prove)\nusing this:\n  (\\<sigma>h, \\<sigma>') \\<in> (R - UNIV \\<times> \\<Sigma>)\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>h\n             \\<in>W - {\\<sigma>} \\<union> (R `` {\\<sigma>} - \\<Sigma>).\n       (\\<sigma>h, \\<sigma>')\n       \\<in> (R - UNIV \\<times> (\\<Sigma> \\<union> R `` {\\<sigma>}))\\<^sup>*", "proof (cases rule: rtrancl_last_visit[where S=\"R `` {\\<sigma>}\"])"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<sigma>h, \\<sigma>')\n    \\<in> (R - UNIV \\<times> \\<Sigma> -\n           UNIV \\<times> R `` {\\<sigma>})\\<^sup>* \\<Longrightarrow>\n    \\<exists>\\<sigma>h\n             \\<in>W - {\\<sigma>} \\<union> (R `` {\\<sigma>} - \\<Sigma>).\n       (\\<sigma>h, \\<sigma>')\n       \\<in> (R - UNIV \\<times> (\\<Sigma> \\<union> R `` {\\<sigma>}))\\<^sup>*\n 2. \\<And>qt.\n       \\<lbrakk>qt \\<in> R `` {\\<sigma>};\n        (\\<sigma>h, qt) \\<in> (R - UNIV \\<times> \\<Sigma>)\\<^sup>+;\n        (qt, \\<sigma>')\n        \\<in> (R - UNIV \\<times> \\<Sigma> -\n               UNIV \\<times> R `` {\\<sigma>})\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>h\n                                  \\<in>W - {\\<sigma>} \\<union>\n (R `` {\\<sigma>} - \\<Sigma>).\n                            (\\<sigma>h, \\<sigma>')\n                            \\<in> (R -\n                                   UNIV \\<times>\n                                   (\\<Sigma> \\<union>\n                                    R `` {\\<sigma>}))\\<^sup>*", "case no_visit\n    \\<comment> \\<open>In the case that the obtained path contains no states from \n          @{term \"post \\<sigma>\"}, we can take it.\\<close>"], ["proof (state)\nthis:\n  (\\<sigma>h, \\<sigma>')\n  \\<in> (R - UNIV \\<times> \\<Sigma> - UNIV \\<times> R `` {\\<sigma>})\\<^sup>*\n\ngoal (2 subgoals):\n 1. (\\<sigma>h, \\<sigma>')\n    \\<in> (R - UNIV \\<times> \\<Sigma> -\n           UNIV \\<times> R `` {\\<sigma>})\\<^sup>* \\<Longrightarrow>\n    \\<exists>\\<sigma>h\n             \\<in>W - {\\<sigma>} \\<union> (R `` {\\<sigma>} - \\<Sigma>).\n       (\\<sigma>h, \\<sigma>')\n       \\<in> (R - UNIV \\<times> (\\<Sigma> \\<union> R `` {\\<sigma>}))\\<^sup>*\n 2. \\<And>qt.\n       \\<lbrakk>qt \\<in> R `` {\\<sigma>};\n        (\\<sigma>h, qt) \\<in> (R - UNIV \\<times> \\<Sigma>)\\<^sup>+;\n        (qt, \\<sigma>')\n        \\<in> (R - UNIV \\<times> \\<Sigma> -\n               UNIV \\<times> R `` {\\<sigma>})\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>h\n                                  \\<in>W - {\\<sigma>} \\<union>\n (R `` {\\<sigma>} - \\<Sigma>).\n                            (\\<sigma>h, \\<sigma>')\n                            \\<in> (R -\n                                   UNIV \\<times>\n                                   (\\<Sigma> \\<union>\n                                    R `` {\\<sigma>}))\\<^sup>*", "hence G1: \"(\\<sigma>h,\\<sigma>')\\<in>(R- (UNIV \\<times> (\\<Sigma>\\<union>R `` {\\<sigma>})))\\<^sup>*\""], ["proof (prove)\nusing this:\n  (\\<sigma>h, \\<sigma>')\n  \\<in> (R - UNIV \\<times> \\<Sigma> - UNIV \\<times> R `` {\\<sigma>})\\<^sup>*\n\ngoal (1 subgoal):\n 1. (\\<sigma>h, \\<sigma>')\n    \\<in> (R - UNIV \\<times> (\\<Sigma> \\<union> R `` {\\<sigma>}))\\<^sup>*", "by (simp add: set_diff_diff_left Sigma_Un_distrib2)"], ["proof (state)\nthis:\n  (\\<sigma>h, \\<sigma>')\n  \\<in> (R - UNIV \\<times> (\\<Sigma> \\<union> R `` {\\<sigma>}))\\<^sup>*\n\ngoal (2 subgoals):\n 1. (\\<sigma>h, \\<sigma>')\n    \\<in> (R - UNIV \\<times> \\<Sigma> -\n           UNIV \\<times> R `` {\\<sigma>})\\<^sup>* \\<Longrightarrow>\n    \\<exists>\\<sigma>h\n             \\<in>W - {\\<sigma>} \\<union> (R `` {\\<sigma>} - \\<Sigma>).\n       (\\<sigma>h, \\<sigma>')\n       \\<in> (R - UNIV \\<times> (\\<Sigma> \\<union> R `` {\\<sigma>}))\\<^sup>*\n 2. \\<And>qt.\n       \\<lbrakk>qt \\<in> R `` {\\<sigma>};\n        (\\<sigma>h, qt) \\<in> (R - UNIV \\<times> \\<Sigma>)\\<^sup>+;\n        (qt, \\<sigma>')\n        \\<in> (R - UNIV \\<times> \\<Sigma> -\n               UNIV \\<times> R `` {\\<sigma>})\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>h\n                                  \\<in>W - {\\<sigma>} \\<union>\n (R `` {\\<sigma>} - \\<Sigma>).\n                            (\\<sigma>h, \\<sigma>')\n                            \\<in> (R -\n                                   UNIV \\<times>\n                                   (\\<Sigma> \\<union>\n                                    R `` {\\<sigma>}))\\<^sup>*", "moreover"], ["proof (state)\nthis:\n  (\\<sigma>h, \\<sigma>')\n  \\<in> (R - UNIV \\<times> (\\<Sigma> \\<union> R `` {\\<sigma>}))\\<^sup>*\n\ngoal (2 subgoals):\n 1. (\\<sigma>h, \\<sigma>')\n    \\<in> (R - UNIV \\<times> \\<Sigma> -\n           UNIV \\<times> R `` {\\<sigma>})\\<^sup>* \\<Longrightarrow>\n    \\<exists>\\<sigma>h\n             \\<in>W - {\\<sigma>} \\<union> (R `` {\\<sigma>} - \\<Sigma>).\n       (\\<sigma>h, \\<sigma>')\n       \\<in> (R - UNIV \\<times> (\\<Sigma> \\<union> R `` {\\<sigma>}))\\<^sup>*\n 2. \\<And>qt.\n       \\<lbrakk>qt \\<in> R `` {\\<sigma>};\n        (\\<sigma>h, qt) \\<in> (R - UNIV \\<times> \\<Sigma>)\\<^sup>+;\n        (qt, \\<sigma>')\n        \\<in> (R - UNIV \\<times> \\<Sigma> -\n               UNIV \\<times> R `` {\\<sigma>})\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>h\n                                  \\<in>W - {\\<sigma>} \\<union>\n (R `` {\\<sigma>} - \\<Sigma>).\n                            (\\<sigma>h, \\<sigma>')\n                            \\<in> (R -\n                                   UNIV \\<times>\n                                   (\\<Sigma> \\<union>\n                                    R `` {\\<sigma>}))\\<^sup>*", "have \"\\<sigma>h \\<noteq> \\<sigma>\" \n      \\<comment> \\<open>We may exclude the case that our obtained path started at \n            @{text \\<sigma>}, as all successors of @{text \\<sigma>} are \n            in @{term \"R `` {\\<sigma>}\"}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma>h \\<noteq> \\<sigma>", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<sigma>h = \\<sigma> \\<Longrightarrow> False", "assume [simp]: \"\\<sigma>h=\\<sigma>\""], ["proof (state)\nthis:\n  \\<sigma>h = \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<sigma>h = \\<sigma> \\<Longrightarrow> False", "from A SS"], ["proof (chain)\npicking this:\n  (\\<Sigma>, W) \\<in> sse_invar \\<Sigma>i R\n  \\<sigma> \\<in> W\n  \\<sigma>'\n  \\<in> R\\<^sup>* `` \\<Sigma>i - (\\<Sigma> \\<union> R `` {\\<sigma>})\n  W \\<subseteq> \\<Sigma>\n  \\<Sigma> \\<subseteq> R\\<^sup>* `` \\<Sigma>i", "have \"\\<sigma>\\<noteq>\\<sigma>'\""], ["proof (prove)\nusing this:\n  (\\<Sigma>, W) \\<in> sse_invar \\<Sigma>i R\n  \\<sigma> \\<in> W\n  \\<sigma>'\n  \\<in> R\\<^sup>* `` \\<Sigma>i - (\\<Sigma> \\<union> R `` {\\<sigma>})\n  W \\<subseteq> \\<Sigma>\n  \\<Sigma> \\<subseteq> R\\<^sup>* `` \\<Sigma>i\n\ngoal (1 subgoal):\n 1. \\<sigma> \\<noteq> \\<sigma>'", "by auto"], ["proof (state)\nthis:\n  \\<sigma> \\<noteq> \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<sigma>h = \\<sigma> \\<Longrightarrow> False", "with G1"], ["proof (chain)\npicking this:\n  (\\<sigma>h, \\<sigma>')\n  \\<in> (R - UNIV \\<times> (\\<Sigma> \\<union> R `` {\\<sigma>}))\\<^sup>*\n  \\<sigma> \\<noteq> \\<sigma>'", "show False"], ["proof (prove)\nusing this:\n  (\\<sigma>h, \\<sigma>')\n  \\<in> (R - UNIV \\<times> (\\<Sigma> \\<union> R `` {\\<sigma>}))\\<^sup>*\n  \\<sigma> \\<noteq> \\<sigma>'\n\ngoal (1 subgoal):\n 1. False", "by (auto simp add: elim: converse_rtranclE)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<sigma>h \\<noteq> \\<sigma>\n\ngoal (2 subgoals):\n 1. (\\<sigma>h, \\<sigma>')\n    \\<in> (R - UNIV \\<times> \\<Sigma> -\n           UNIV \\<times> R `` {\\<sigma>})\\<^sup>* \\<Longrightarrow>\n    \\<exists>\\<sigma>h\n             \\<in>W - {\\<sigma>} \\<union> (R `` {\\<sigma>} - \\<Sigma>).\n       (\\<sigma>h, \\<sigma>')\n       \\<in> (R - UNIV \\<times> (\\<Sigma> \\<union> R `` {\\<sigma>}))\\<^sup>*\n 2. \\<And>qt.\n       \\<lbrakk>qt \\<in> R `` {\\<sigma>};\n        (\\<sigma>h, qt) \\<in> (R - UNIV \\<times> \\<Sigma>)\\<^sup>+;\n        (qt, \\<sigma>')\n        \\<in> (R - UNIV \\<times> \\<Sigma> -\n               UNIV \\<times> R `` {\\<sigma>})\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>h\n                                  \\<in>W - {\\<sigma>} \\<union>\n (R `` {\\<sigma>} - \\<Sigma>).\n                            (\\<sigma>h, \\<sigma>')\n                            \\<in> (R -\n                                   UNIV \\<times>\n                                   (\\<Sigma> \\<union>\n                                    R `` {\\<sigma>}))\\<^sup>*", "ultimately"], ["proof (chain)\npicking this:\n  (\\<sigma>h, \\<sigma>')\n  \\<in> (R - UNIV \\<times> (\\<Sigma> \\<union> R `` {\\<sigma>}))\\<^sup>*\n  \\<sigma>h \\<noteq> \\<sigma>", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<sigma>h, \\<sigma>')\n  \\<in> (R - UNIV \\<times> (\\<Sigma> \\<union> R `` {\\<sigma>}))\\<^sup>*\n  \\<sigma>h \\<noteq> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>h\n             \\<in>W - {\\<sigma>} \\<union> (R `` {\\<sigma>} - \\<Sigma>).\n       (\\<sigma>h, \\<sigma>')\n       \\<in> (R - UNIV \\<times> (\\<Sigma> \\<union> R `` {\\<sigma>}))\\<^sup>*", "using IP(1)"], ["proof (prove)\nusing this:\n  (\\<sigma>h, \\<sigma>')\n  \\<in> (R - UNIV \\<times> (\\<Sigma> \\<union> R `` {\\<sigma>}))\\<^sup>*\n  \\<sigma>h \\<noteq> \\<sigma>\n  \\<sigma>h \\<in> W\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>h\n             \\<in>W - {\\<sigma>} \\<union> (R `` {\\<sigma>} - \\<Sigma>).\n       (\\<sigma>h, \\<sigma>')\n       \\<in> (R - UNIV \\<times> (\\<Sigma> \\<union> R `` {\\<sigma>}))\\<^sup>*", "by auto"], ["proof (state)\nthis:\n  \\<exists>\\<sigma>h\n           \\<in>W - {\\<sigma>} \\<union> (R `` {\\<sigma>} - \\<Sigma>).\n     (\\<sigma>h, \\<sigma>')\n     \\<in> (R - UNIV \\<times> (\\<Sigma> \\<union> R `` {\\<sigma>}))\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>qt.\n       \\<lbrakk>qt \\<in> R `` {\\<sigma>};\n        (\\<sigma>h, qt) \\<in> (R - UNIV \\<times> \\<Sigma>)\\<^sup>+;\n        (qt, \\<sigma>')\n        \\<in> (R - UNIV \\<times> \\<Sigma> -\n               UNIV \\<times> R `` {\\<sigma>})\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>h\n                                  \\<in>W - {\\<sigma>} \\<union>\n (R `` {\\<sigma>} - \\<Sigma>).\n                            (\\<sigma>h, \\<sigma>')\n                            \\<in> (R -\n                                   UNIV \\<times>\n                                   (\\<Sigma> \\<union>\n                                    R `` {\\<sigma>}))\\<^sup>*", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>qt.\n       \\<lbrakk>qt \\<in> R `` {\\<sigma>};\n        (\\<sigma>h, qt) \\<in> (R - UNIV \\<times> \\<Sigma>)\\<^sup>+;\n        (qt, \\<sigma>')\n        \\<in> (R - UNIV \\<times> \\<Sigma> -\n               UNIV \\<times> R `` {\\<sigma>})\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>h\n                                  \\<in>W - {\\<sigma>} \\<union>\n (R `` {\\<sigma>} - \\<Sigma>).\n                            (\\<sigma>h, \\<sigma>')\n                            \\<in> (R -\n                                   UNIV \\<times>\n                                   (\\<Sigma> \\<union>\n                                    R `` {\\<sigma>}))\\<^sup>*", "case (last_visit_point \\<sigma>t)\n    \\<comment> \\<open>If the obtained path contains a state from @{text \"R `` {\\<sigma>}\"}, \n          we simply pick the last one:\\<close>"], ["proof (state)\nthis:\n  \\<sigma>t \\<in> R `` {\\<sigma>}\n  (\\<sigma>h, \\<sigma>t) \\<in> (R - UNIV \\<times> \\<Sigma>)\\<^sup>+\n  (\\<sigma>t, \\<sigma>')\n  \\<in> (R - UNIV \\<times> \\<Sigma> - UNIV \\<times> R `` {\\<sigma>})\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>qt.\n       \\<lbrakk>qt \\<in> R `` {\\<sigma>};\n        (\\<sigma>h, qt) \\<in> (R - UNIV \\<times> \\<Sigma>)\\<^sup>+;\n        (qt, \\<sigma>')\n        \\<in> (R - UNIV \\<times> \\<Sigma> -\n               UNIV \\<times> R `` {\\<sigma>})\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>h\n                                  \\<in>W - {\\<sigma>} \\<union>\n (R `` {\\<sigma>} - \\<Sigma>).\n                            (\\<sigma>h, \\<sigma>')\n                            \\<in> (R -\n                                   UNIV \\<times>\n                                   (\\<Sigma> \\<union>\n                                    R `` {\\<sigma>}))\\<^sup>*", "hence \"(\\<sigma>t,\\<sigma>')\\<in>(R- (UNIV \\<times> (\\<Sigma>\\<union>R `` {\\<sigma>})))\\<^sup>*\""], ["proof (prove)\nusing this:\n  \\<sigma>t \\<in> R `` {\\<sigma>}\n  (\\<sigma>h, \\<sigma>t) \\<in> (R - UNIV \\<times> \\<Sigma>)\\<^sup>+\n  (\\<sigma>t, \\<sigma>')\n  \\<in> (R - UNIV \\<times> \\<Sigma> - UNIV \\<times> R `` {\\<sigma>})\\<^sup>*\n\ngoal (1 subgoal):\n 1. (\\<sigma>t, \\<sigma>')\n    \\<in> (R - UNIV \\<times> (\\<Sigma> \\<union> R `` {\\<sigma>}))\\<^sup>*", "by (simp add: set_diff_diff_left Sigma_Un_distrib2)"], ["proof (state)\nthis:\n  (\\<sigma>t, \\<sigma>')\n  \\<in> (R - UNIV \\<times> (\\<Sigma> \\<union> R `` {\\<sigma>}))\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>qt.\n       \\<lbrakk>qt \\<in> R `` {\\<sigma>};\n        (\\<sigma>h, qt) \\<in> (R - UNIV \\<times> \\<Sigma>)\\<^sup>+;\n        (qt, \\<sigma>')\n        \\<in> (R - UNIV \\<times> \\<Sigma> -\n               UNIV \\<times> R `` {\\<sigma>})\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>h\n                                  \\<in>W - {\\<sigma>} \\<union>\n (R `` {\\<sigma>} - \\<Sigma>).\n                            (\\<sigma>h, \\<sigma>')\n                            \\<in> (R -\n                                   UNIV \\<times>\n                                   (\\<Sigma> \\<union>\n                                    R `` {\\<sigma>}))\\<^sup>*", "moreover"], ["proof (state)\nthis:\n  (\\<sigma>t, \\<sigma>')\n  \\<in> (R - UNIV \\<times> (\\<Sigma> \\<union> R `` {\\<sigma>}))\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>qt.\n       \\<lbrakk>qt \\<in> R `` {\\<sigma>};\n        (\\<sigma>h, qt) \\<in> (R - UNIV \\<times> \\<Sigma>)\\<^sup>+;\n        (qt, \\<sigma>')\n        \\<in> (R - UNIV \\<times> \\<Sigma> -\n               UNIV \\<times> R `` {\\<sigma>})\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>h\n                                  \\<in>W - {\\<sigma>} \\<union>\n (R `` {\\<sigma>} - \\<Sigma>).\n                            (\\<sigma>h, \\<sigma>')\n                            \\<in> (R -\n                                   UNIV \\<times>\n                                   (\\<Sigma> \\<union>\n                                    R `` {\\<sigma>}))\\<^sup>*", "from last_visit_point(2)"], ["proof (chain)\npicking this:\n  (\\<sigma>h, \\<sigma>t) \\<in> (R - UNIV \\<times> \\<Sigma>)\\<^sup>+", "have \"\\<sigma>t\\<notin>\\<Sigma>\""], ["proof (prove)\nusing this:\n  (\\<sigma>h, \\<sigma>t) \\<in> (R - UNIV \\<times> \\<Sigma>)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<sigma>t \\<notin> \\<Sigma>", "by (auto elim: trancl.cases)"], ["proof (state)\nthis:\n  \\<sigma>t \\<notin> \\<Sigma>\n\ngoal (1 subgoal):\n 1. \\<And>qt.\n       \\<lbrakk>qt \\<in> R `` {\\<sigma>};\n        (\\<sigma>h, qt) \\<in> (R - UNIV \\<times> \\<Sigma>)\\<^sup>+;\n        (qt, \\<sigma>')\n        \\<in> (R - UNIV \\<times> \\<Sigma> -\n               UNIV \\<times> R `` {\\<sigma>})\\<^sup>*\\<rbrakk>\n       \\<Longrightarrow> \\<exists>\\<sigma>h\n                                  \\<in>W - {\\<sigma>} \\<union>\n (R `` {\\<sigma>} - \\<Sigma>).\n                            (\\<sigma>h, \\<sigma>')\n                            \\<in> (R -\n                                   UNIV \\<times>\n                                   (\\<Sigma> \\<union>\n                                    R `` {\\<sigma>}))\\<^sup>*", "ultimately"], ["proof (chain)\npicking this:\n  (\\<sigma>t, \\<sigma>')\n  \\<in> (R - UNIV \\<times> (\\<Sigma> \\<union> R `` {\\<sigma>}))\\<^sup>*\n  \\<sigma>t \\<notin> \\<Sigma>", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<sigma>t, \\<sigma>')\n  \\<in> (R - UNIV \\<times> (\\<Sigma> \\<union> R `` {\\<sigma>}))\\<^sup>*\n  \\<sigma>t \\<notin> \\<Sigma>\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>h\n             \\<in>W - {\\<sigma>} \\<union> (R `` {\\<sigma>} - \\<Sigma>).\n       (\\<sigma>h, \\<sigma>')\n       \\<in> (R - UNIV \\<times> (\\<Sigma> \\<union> R `` {\\<sigma>}))\\<^sup>*", "using last_visit_point(1)"], ["proof (prove)\nusing this:\n  (\\<sigma>t, \\<sigma>')\n  \\<in> (R - UNIV \\<times> (\\<Sigma> \\<union> R `` {\\<sigma>}))\\<^sup>*\n  \\<sigma>t \\<notin> \\<Sigma>\n  \\<sigma>t \\<in> R `` {\\<sigma>}\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>h\n             \\<in>W - {\\<sigma>} \\<union> (R `` {\\<sigma>} - \\<Sigma>).\n       (\\<sigma>h, \\<sigma>')\n       \\<in> (R - UNIV \\<times> (\\<Sigma> \\<union> R `` {\\<sigma>}))\\<^sup>*", "by auto"], ["proof (state)\nthis:\n  \\<exists>\\<sigma>h\n           \\<in>W - {\\<sigma>} \\<union> (R `` {\\<sigma>} - \\<Sigma>).\n     (\\<sigma>h, \\<sigma>')\n     \\<in> (R - UNIV \\<times> (\\<Sigma> \\<union> R `` {\\<sigma>}))\\<^sup>*\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>\\<sigma>h\n           \\<in>W - {\\<sigma>} \\<union> (R `` {\\<sigma>} - \\<Sigma>).\n     (\\<sigma>h, \\<sigma>')\n     \\<in> (R - UNIV \\<times> (\\<Sigma> \\<union> R `` {\\<sigma>}))\\<^sup>*\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open>The sse-algorithm is a well-defined while-algorithm\\<close>"], ["", "theorem sse_while_algo: \"finite (R\\<^sup>*``\\<Sigma>i) \\<Longrightarrow> while_algo (sse_algo \\<Sigma>i R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (R\\<^sup>* `` \\<Sigma>i) \\<Longrightarrow>\n    while_algo (sse_algo \\<Sigma>i R)", "apply unfold_locales"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>finite (R\\<^sup>* `` \\<Sigma>i);\n        s \\<in> wa_invar (sse_algo \\<Sigma>i R);\n        s \\<in> wa_cond (sse_algo \\<Sigma>i R);\n        (s, s') \\<in> wa_step (sse_algo \\<Sigma>i R)\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> wa_invar (sse_algo \\<Sigma>i R)\n 2. finite (R\\<^sup>* `` \\<Sigma>i) \\<Longrightarrow>\n    wa_initial (sse_algo \\<Sigma>i R)\n    \\<subseteq> wa_invar (sse_algo \\<Sigma>i R)\n 3. finite (R\\<^sup>* `` \\<Sigma>i) \\<Longrightarrow>\n    wf {(s', s).\n        s \\<in> wa_invar (sse_algo \\<Sigma>i R) \\<and>\n        s \\<in> wa_cond (sse_algo \\<Sigma>i R) \\<and>\n        (s, s') \\<in> wa_step (sse_algo \\<Sigma>i R)}", "apply (auto simp add: sse_algo_def intro: sse_invar_step sse_invar_initial)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (R\\<^sup>* `` \\<Sigma>i) \\<Longrightarrow>\n    wf {(s', s).\n        s \\<in> sse_invar \\<Sigma>i R \\<and>\n        s \\<in> sse_cond \\<and> (s, s') \\<in> sse_step R}", "apply (drule sse_term)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (sse_term_rel \\<Sigma>i R) \\<Longrightarrow>\n    wf {(s', s).\n        s \\<in> sse_invar \\<Sigma>i R \\<and>\n        s \\<in> sse_cond \\<and> (s, s') \\<in> sse_step R}", "apply (erule_tac wf_subset)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(s', s).\n     s \\<in> sse_invar \\<Sigma>i R \\<and>\n     s \\<in> sse_cond \\<and> (s, s') \\<in> sse_step R}\n    \\<subseteq> sse_term_rel \\<Sigma>i R", "apply (unfold sse_term_rel_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(s', s).\n     s \\<in> sse_invar \\<Sigma>i R \\<and>\n     s \\<in> sse_cond \\<and> (s, s') \\<in> sse_step R}\n    \\<subseteq> {(\\<sigma>', \\<sigma>).\n                 \\<sigma> \\<in> sse_invar \\<Sigma>i R \\<and>\n                 (\\<sigma>, \\<sigma>') \\<in> sse_step R}", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \"Depth First Search\""], ["", "text_raw \\<open>\\label{sec:sse:dfs}\\<close>"], ["", "text \\<open>\n  In this section, the generic state space exploration algorithm is refined\n  to a DFS-algorithm, that uses a stack to implement the workset.\n\\<close>"], ["", "type_synonym '\\<Sigma> dfs_state = \"'\\<Sigma> set \\<times> '\\<Sigma> list\""], ["", "definition dfs_\\<alpha> :: \"'\\<Sigma> dfs_state \\<Rightarrow> '\\<Sigma> sse_state\" \n  where \"dfs_\\<alpha> S == let (\\<Sigma>,W)=S in (\\<Sigma>,set W)\""], ["", "definition dfs_invar_add :: \"'\\<Sigma> dfs_state set\"\n  where \"dfs_invar_add == {(\\<Sigma>,W). distinct W}\""], ["", "definition \"dfs_invar \\<Sigma>i R == dfs_invar_add \\<inter> { s. dfs_\\<alpha> s \\<in> sse_invar \\<Sigma>i R }\""], ["", "inductive_set dfs_initial :: \"'\\<Sigma> set \\<Rightarrow> '\\<Sigma> dfs_state set\" for \\<Sigma>i\n  where \"\\<lbrakk> distinct W; set W = \\<Sigma>i\\<rbrakk> \\<Longrightarrow> (\\<Sigma>i,W)\\<in>dfs_initial \\<Sigma>i\""], ["", "inductive_set dfs_step :: \"('\\<Sigma>\\<times>'\\<Sigma>) set \\<Rightarrow> ('\\<Sigma> dfs_state \\<times>'\\<Sigma> dfs_state) set\" \n  for R where\n  \"\\<lbrakk> W=\\<sigma>#Wtl;\n     distinct Wn;\n     set Wn = R``{\\<sigma>} - \\<Sigma>;\n     W' = Wn@Wtl;\n     \\<Sigma>' = R``{\\<sigma>} \\<union> \\<Sigma>\n  \\<rbrakk> \\<Longrightarrow> ((\\<Sigma>,W),(\\<Sigma>',W'))\\<in>dfs_step R\""], ["", "definition dfs_cond :: \"'\\<Sigma> dfs_state set\" \n  where \"dfs_cond == { (\\<Sigma>,W). W\\<noteq>[]}\""], ["", "definition \"dfs_algo \\<Sigma>i R == \\<lparr> \n  wa_cond = dfs_cond, \n  wa_step = dfs_step R, \n  wa_initial = dfs_initial \\<Sigma>i, \n  wa_invar = dfs_invar \\<Sigma>i R \\<rparr>\"\n\n  \\<comment> \\<open>The DFS-algorithm refines the state-space exploration algorithm\\<close>"], ["", "theorem dfs_pref_sse: \n  \"wa_precise_refine (dfs_algo \\<Sigma>i R) (sse_algo \\<Sigma>i R) dfs_\\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wa_precise_refine (dfs_algo \\<Sigma>i R) (sse_algo \\<Sigma>i R)\n     dfs_\\<alpha>", "apply (unfold_locales)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>s \\<in> wa_invar (dfs_algo \\<Sigma>i R);\n        s \\<in> wa_cond (dfs_algo \\<Sigma>i R)\\<rbrakk>\n       \\<Longrightarrow> dfs_\\<alpha> s \\<in> wa_cond (sse_algo \\<Sigma>i R)\n 2. \\<And>s s'.\n       \\<lbrakk>s \\<in> wa_invar (dfs_algo \\<Sigma>i R);\n        s \\<in> wa_cond (dfs_algo \\<Sigma>i R);\n        (s, s') \\<in> wa_step (dfs_algo \\<Sigma>i R)\\<rbrakk>\n       \\<Longrightarrow> (dfs_\\<alpha> s, dfs_\\<alpha> s')\n                         \\<in> wa_step (sse_algo \\<Sigma>i R)\n 3. dfs_\\<alpha> ` wa_initial (dfs_algo \\<Sigma>i R)\n    \\<subseteq> wa_initial (sse_algo \\<Sigma>i R)\n 4. dfs_\\<alpha> ` wa_invar (dfs_algo \\<Sigma>i R)\n    \\<subseteq> wa_invar (sse_algo \\<Sigma>i R)\n 5. \\<forall>s.\n       s \\<in> wa_invar (dfs_algo \\<Sigma>i R) \\<and>\n       dfs_\\<alpha> s \\<in> wa_cond (sse_algo \\<Sigma>i R) \\<longrightarrow>\n       s \\<in> wa_cond (dfs_algo \\<Sigma>i R)", "apply (auto simp add: dfs_algo_def sse_algo_def dfs_cond_def sse_cond_def \n                        dfs_\\<alpha>_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<in> dfs_invar \\<Sigma>i R; b \\<noteq> [];\n        ((a, b), aa, ba) \\<in> dfs_step R\\<rbrakk>\n       \\<Longrightarrow> ((a, set b), aa, set ba) \\<in> sse_step R\n 2. \\<And>aa ba.\n       (aa, ba) \\<in> dfs_initial \\<Sigma>i \\<Longrightarrow>\n       (aa, set ba) = sse_initial \\<Sigma>i\n 3. \\<And>aa ba.\n       (aa, ba) \\<in> dfs_invar \\<Sigma>i R \\<Longrightarrow>\n       (aa, set ba) \\<in> sse_invar \\<Sigma>i R", "apply (erule dfs_step.cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b aa ba W \\<sigma> Wtl Wn \\<Sigma> W' \\<Sigma>'.\n       \\<lbrakk>(a, b) \\<in> dfs_invar \\<Sigma>i R; b \\<noteq> [];\n        a = \\<Sigma>; b = W; aa = \\<Sigma>'; ba = W'; W = \\<sigma> # Wtl;\n        distinct Wn; set Wn = R `` {\\<sigma>} - \\<Sigma>; W' = Wn @ Wtl;\n        \\<Sigma>' = R `` {\\<sigma>} \\<union> \\<Sigma>\\<rbrakk>\n       \\<Longrightarrow> ((a, set b), aa, set ba) \\<in> sse_step R\n 2. \\<And>aa ba.\n       (aa, ba) \\<in> dfs_initial \\<Sigma>i \\<Longrightarrow>\n       (aa, set ba) = sse_initial \\<Sigma>i\n 3. \\<And>aa ba.\n       (aa, ba) \\<in> dfs_invar \\<Sigma>i R \\<Longrightarrow>\n       (aa, set ba) \\<in> sse_invar \\<Sigma>i R", "apply (rule_tac \\<sigma>=\\<sigma> in sse_step.intros)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a b aa ba W \\<sigma> Wtl Wn \\<Sigma> W' \\<Sigma>'.\n       \\<lbrakk>(a, b) \\<in> dfs_invar \\<Sigma>i R; b \\<noteq> [];\n        a = \\<Sigma>; b = W; aa = \\<Sigma>'; ba = W'; W = \\<sigma> # Wtl;\n        distinct Wn; set Wn = R `` {\\<sigma>} - \\<Sigma>; W' = Wn @ Wtl;\n        \\<Sigma>' = R `` {\\<sigma>} \\<union> \\<Sigma>\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> \\<in> set b\n 2. \\<And>a b aa ba W \\<sigma> Wtl Wn \\<Sigma> W' \\<Sigma>'.\n       \\<lbrakk>(a, b) \\<in> dfs_invar \\<Sigma>i R; b \\<noteq> [];\n        a = \\<Sigma>; b = W; aa = \\<Sigma>'; ba = W'; W = \\<sigma> # Wtl;\n        distinct Wn; set Wn = R `` {\\<sigma>} - \\<Sigma>; W' = Wn @ Wtl;\n        \\<Sigma>' = R `` {\\<sigma>} \\<union> \\<Sigma>\\<rbrakk>\n       \\<Longrightarrow> aa = a \\<union> R `` {\\<sigma>}\n 3. \\<And>a b aa ba W \\<sigma> Wtl Wn \\<Sigma> W' \\<Sigma>'.\n       \\<lbrakk>(a, b) \\<in> dfs_invar \\<Sigma>i R; b \\<noteq> [];\n        a = \\<Sigma>; b = W; aa = \\<Sigma>'; ba = W'; W = \\<sigma> # Wtl;\n        distinct Wn; set Wn = R `` {\\<sigma>} - \\<Sigma>; W' = Wn @ Wtl;\n        \\<Sigma>' = R `` {\\<sigma>} \\<union> \\<Sigma>\\<rbrakk>\n       \\<Longrightarrow> set ba =\n                         set b - {\\<sigma>} \\<union> (R `` {\\<sigma>} - a)\n 4. \\<And>aa ba.\n       (aa, ba) \\<in> dfs_initial \\<Sigma>i \\<Longrightarrow>\n       (aa, set ba) = sse_initial \\<Sigma>i\n 5. \\<And>aa ba.\n       (aa, ba) \\<in> dfs_invar \\<Sigma>i R \\<Longrightarrow>\n       (aa, set ba) \\<in> sse_invar \\<Sigma>i R", "apply (auto simp add: dfs_invar_def sse_invar_def dfs_invar_add_def \n                        sse_initial_def dfs_\\<alpha>_def \n              elim: dfs_initial.cases)"], ["proof (prove)\ngoal:\nNo subgoals!", "done\n\n  \\<comment> \\<open>The DFS-algorithm is a well-defined while-algorithm\\<close>"], ["", "theorem dfs_while_algo:\n  assumes finite[simp, intro!]: \"finite (R\\<^sup>*``\\<Sigma>i)\"\n  shows \"while_algo (dfs_algo \\<Sigma>i R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. while_algo (dfs_algo \\<Sigma>i R)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. while_algo (dfs_algo \\<Sigma>i R)", "interpret wa_precise_refine \"(dfs_algo \\<Sigma>i R)\" \"(sse_algo \\<Sigma>i R)\" dfs_\\<alpha>"], ["proof (prove)\ngoal (1 subgoal):\n 1. wa_precise_refine (dfs_algo \\<Sigma>i R) (sse_algo \\<Sigma>i R)\n     dfs_\\<alpha>", "using dfs_pref_sse"], ["proof (prove)\nusing this:\n  wa_precise_refine (dfs_algo ?\\<Sigma>i ?R) (sse_algo ?\\<Sigma>i ?R)\n   dfs_\\<alpha>\n\ngoal (1 subgoal):\n 1. wa_precise_refine (dfs_algo \\<Sigma>i R) (sse_algo \\<Sigma>i R)\n     dfs_\\<alpha>", "."], ["proof (state)\ngoal (1 subgoal):\n 1. while_algo (dfs_algo \\<Sigma>i R)", "have [simp]: \"wa_invar (sse_algo \\<Sigma>i R) = sse_invar \\<Sigma>i R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wa_invar (sse_algo \\<Sigma>i R) = sse_invar \\<Sigma>i R", "by (simp add: sse_algo_def)"], ["proof (state)\nthis:\n  wa_invar (sse_algo \\<Sigma>i R) = sse_invar \\<Sigma>i R\n\ngoal (1 subgoal):\n 1. while_algo (dfs_algo \\<Sigma>i R)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. while_algo (dfs_algo \\<Sigma>i R)", "apply (rule wa_intro)"], ["proof (prove)\ngoal (4 subgoals):\n 1. while_algo (sse_algo \\<Sigma>i R)\n 2. wa_invar (dfs_algo \\<Sigma>i R) =\n    ?addi \\<inter> {s. dfs_\\<alpha> s \\<in> wa_invar (sse_algo \\<Sigma>i R)}\n 3. \\<And>s s'.\n       \\<lbrakk>s \\<in> ?addi; s \\<in> wa_cond (dfs_algo \\<Sigma>i R);\n        dfs_\\<alpha> s \\<in> wa_invar (sse_algo \\<Sigma>i R);\n        (s, s') \\<in> wa_step (dfs_algo \\<Sigma>i R)\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> ?addi\n 4. wa_initial (dfs_algo \\<Sigma>i R) \\<subseteq> ?addi", "apply (simp add: sse_while_algo)"], ["proof (prove)\ngoal (3 subgoals):\n 1. wa_invar (dfs_algo \\<Sigma>i R) =\n    ?addi \\<inter> {s. dfs_\\<alpha> s \\<in> wa_invar (sse_algo \\<Sigma>i R)}\n 2. \\<And>s s'.\n       \\<lbrakk>s \\<in> ?addi; s \\<in> wa_cond (dfs_algo \\<Sigma>i R);\n        dfs_\\<alpha> s \\<in> wa_invar (sse_algo \\<Sigma>i R);\n        (s, s') \\<in> wa_step (dfs_algo \\<Sigma>i R)\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> ?addi\n 3. wa_initial (dfs_algo \\<Sigma>i R) \\<subseteq> ?addi", "apply (simp add: dfs_invar_def dfs_algo_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>s \\<in> dfs_invar_add;\n        s \\<in> wa_cond (dfs_algo \\<Sigma>i R);\n        dfs_\\<alpha> s \\<in> wa_invar (sse_algo \\<Sigma>i R);\n        (s, s') \\<in> wa_step (dfs_algo \\<Sigma>i R)\\<rbrakk>\n       \\<Longrightarrow> s' \\<in> dfs_invar_add\n 2. wa_initial (dfs_algo \\<Sigma>i R) \\<subseteq> dfs_invar_add", "apply (auto simp add: dfs_invar_add_def dfs_algo_def dfs_\\<alpha>_def \n                          dfs_cond_def sse_invar_def \n                elim!: dfs_step.cases) [1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. wa_initial (dfs_algo \\<Sigma>i R) \\<subseteq> dfs_invar_add", "apply (auto simp add: dfs_invar_add_def dfs_algo_def \n                elim: dfs_initial.cases) [1]"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  while_algo (dfs_algo \\<Sigma>i R)\n\ngoal:\nNo subgoals!", "qed\n\n  \\<comment> \\<open>The result of the DFS-algorithm is correct\\<close>"], ["", "lemmas dfs_invar_final = \n  wa_precise_refine.transfer_correctness[OF dfs_pref_sse sse_invar_final]"], ["", "end"]]}