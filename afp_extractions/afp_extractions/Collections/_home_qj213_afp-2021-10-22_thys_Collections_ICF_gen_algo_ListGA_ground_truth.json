{"file_name": "/home/qj213/afp-2021-10-22/thys/Collections/ICF/gen_algo/ListGA.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Collections", "problem_names": ["lemma idx_iteratei_aux_simps[simp]:\n    \"i=0 \\<Longrightarrow> idx_iteratei_aux sz i l c f \\<sigma> = \\<sigma>\"\n    \"\\<not>c \\<sigma> \\<Longrightarrow> idx_iteratei_aux sz i l c f \\<sigma> = \\<sigma>\"\n    \"\\<lbrakk>i\\<noteq>0; c \\<sigma>\\<rbrakk> \\<Longrightarrow> idx_iteratei_aux sz i l c f \\<sigma> = idx_iteratei_aux sz (i - 1) l c f (f (get l (sz-i)) \\<sigma>)\"", "lemma idx_iteratei_correct:\n    shows \"idx_iteratei s = foldli (\\<alpha> s)\"", "lemmas idx_iteratei_unfold[code_unfold] = idx_iteratei_correct[symmetric]", "lemma idx_reverse_iteratei_aux_simps[simp]:\n    \"i=0 \\<Longrightarrow> idx_reverse_iteratei_aux sz i l c f \\<sigma> = \\<sigma>\"\n    \"\\<not>c \\<sigma> \\<Longrightarrow> idx_reverse_iteratei_aux sz i l c f \\<sigma> = \\<sigma>\"\n    \"\\<lbrakk>i\\<noteq>0; c \\<sigma>\\<rbrakk> \\<Longrightarrow> idx_reverse_iteratei_aux sz i l c f \\<sigma> \n    = idx_reverse_iteratei_aux sz (i - 1) l c f (f (get l (i - 1)) \\<sigma>)\"", "lemma idx_reverse_iteratei_correct:\n    shows \"idx_reverse_iteratei s = foldri (\\<alpha> s)\"", "lemmas idx_reverse_iteratei_unfold[code_unfold] \n    = idx_reverse_iteratei_correct[symmetric]", "lemma it_size_impl: shows \"list_size \\<alpha> invar it_size\"", "lemma rev_it_size_impl:\n    shows \"list_size \\<alpha> invar rev_it_size\"", "lemma it_get_correct:\n    shows \"list_get \\<alpha> invar it_get\""], "translations": [["", "lemma idx_iteratei_aux_simps[simp]:\n    \"i=0 \\<Longrightarrow> idx_iteratei_aux sz i l c f \\<sigma> = \\<sigma>\"\n    \"\\<not>c \\<sigma> \\<Longrightarrow> idx_iteratei_aux sz i l c f \\<sigma> = \\<sigma>\"\n    \"\\<lbrakk>i\\<noteq>0; c \\<sigma>\\<rbrakk> \\<Longrightarrow> idx_iteratei_aux sz i l c f \\<sigma> = idx_iteratei_aux sz (i - 1) l c f (f (get l (sz-i)) \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (i = 0 \\<Longrightarrow>\n     local.idx_iteratei_aux sz i l c f \\<sigma> = \\<sigma>) &&&\n    (\\<not> c \\<sigma> \\<Longrightarrow>\n     local.idx_iteratei_aux sz i l c f \\<sigma> = \\<sigma>) &&&\n    (\\<lbrakk>i \\<noteq> 0; c \\<sigma>\\<rbrakk>\n     \\<Longrightarrow> local.idx_iteratei_aux sz i l c f \\<sigma> =\n                       local.idx_iteratei_aux sz (i - 1) l c f\n                        (f (get l (sz - i)) \\<sigma>))", "apply -"], ["proof (prove)\ngoal (3 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    local.idx_iteratei_aux sz i l c f \\<sigma> = \\<sigma>\n 2. \\<not> c \\<sigma> \\<Longrightarrow>\n    local.idx_iteratei_aux sz i l c f \\<sigma> = \\<sigma>\n 3. \\<lbrakk>i \\<noteq> 0; c \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> local.idx_iteratei_aux sz i l c f \\<sigma> =\n                      local.idx_iteratei_aux sz (i - 1) l c f\n                       (f (get l (sz - i)) \\<sigma>)", "apply (subst idx_iteratei_aux.simps, simp)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition idx_iteratei where \n    \"idx_iteratei l c f \\<sigma> \\<equiv> idx_iteratei_aux (size l) (size l) l c f \\<sigma>\""], ["", "lemma idx_iteratei_correct:\n    shows \"idx_iteratei s = foldli (\\<alpha> s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.idx_iteratei s = foldli (\\<alpha> s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. local.idx_iteratei s = foldli (\\<alpha> s)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. local.idx_iteratei s = foldli (\\<alpha> s)", "fix n l"], ["proof (state)\ngoal (1 subgoal):\n 1. local.idx_iteratei s = foldli (\\<alpha> s)", "assume A: \"Suc n \\<le> length l\""], ["proof (state)\nthis:\n  Suc n \\<le> length l\n\ngoal (1 subgoal):\n 1. local.idx_iteratei s = foldli (\\<alpha> s)", "hence B: \"length l - Suc n < length l\""], ["proof (prove)\nusing this:\n  Suc n \\<le> length l\n\ngoal (1 subgoal):\n 1. length l - Suc n < length l", "by simp"], ["proof (state)\nthis:\n  length l - Suc n < length l\n\ngoal (1 subgoal):\n 1. local.idx_iteratei s = foldli (\\<alpha> s)", "from A"], ["proof (chain)\npicking this:\n  Suc n \\<le> length l", "have [simp]: \"Suc (length l - Suc n) = length l - n\""], ["proof (prove)\nusing this:\n  Suc n \\<le> length l\n\ngoal (1 subgoal):\n 1. Suc (length l - Suc n) = length l - n", "by simp"], ["proof (state)\nthis:\n  Suc (length l - Suc n) = length l - n\n\ngoal (1 subgoal):\n 1. local.idx_iteratei s = foldli (\\<alpha> s)", "from Cons_nth_drop_Suc[OF B, simplified]"], ["proof (chain)\npicking this:\n  l ! (length l - Suc n) # drop (length l - n) l = drop (length l - Suc n) l", "have \n        \"drop (length l - Suc n) l = l!(length l - Suc n)#drop (length l - n) l\""], ["proof (prove)\nusing this:\n  l ! (length l - Suc n) # drop (length l - n) l = drop (length l - Suc n) l\n\ngoal (1 subgoal):\n 1. drop (length l - Suc n) l =\n    l ! (length l - Suc n) # drop (length l - n) l", "by simp"], ["proof (state)\nthis:\n  drop (length l - Suc n) l = l ! (length l - Suc n) # drop (length l - n) l\n\ngoal (1 subgoal):\n 1. local.idx_iteratei s = foldli (\\<alpha> s)", "}"], ["proof (state)\nthis:\n  Suc ?n8 \\<le> length ?l8 \\<Longrightarrow>\n  drop (length ?l8 - Suc ?n8) ?l8 =\n  ?l8 ! (length ?l8 - Suc ?n8) # drop (length ?l8 - ?n8) ?l8\n\ngoal (1 subgoal):\n 1. local.idx_iteratei s = foldli (\\<alpha> s)", "note drop_aux=this"], ["proof (state)\nthis:\n  Suc ?n8 \\<le> length ?l8 \\<Longrightarrow>\n  drop (length ?l8 - Suc ?n8) ?l8 =\n  ?l8 ! (length ?l8 - Suc ?n8) # drop (length ?l8 - ?n8) ?l8\n\ngoal (1 subgoal):\n 1. local.idx_iteratei s = foldli (\\<alpha> s)", "{"], ["proof (state)\nthis:\n  Suc ?n8 \\<le> length ?l8 \\<Longrightarrow>\n  drop (length ?l8 - Suc ?n8) ?l8 =\n  ?l8 ! (length ?l8 - Suc ?n8) # drop (length ?l8 - ?n8) ?l8\n\ngoal (1 subgoal):\n 1. local.idx_iteratei s = foldli (\\<alpha> s)", "fix s c f \\<sigma> i"], ["proof (state)\ngoal (1 subgoal):\n 1. local.idx_iteratei s = foldli (\\<alpha> s)", "assume \"invar s\" \"i\\<le>size s\""], ["proof (state)\nthis:\n  invar s\n  i \\<le> size s\n\ngoal (1 subgoal):\n 1. local.idx_iteratei s = foldli (\\<alpha> s)", "hence \"idx_iteratei_aux (size s) i s c f \\<sigma> \n        = foldli (drop (size s - i) (\\<alpha> s)) c f \\<sigma>\""], ["proof (prove)\nusing this:\n  invar s\n  i \\<le> size s\n\ngoal (1 subgoal):\n 1. local.idx_iteratei_aux (size s) i s c f \\<sigma> =\n    foldli (drop (size s - i) (\\<alpha> s)) c f \\<sigma>", "proof (induct i arbitrary: \\<sigma>)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma>.\n       \\<lbrakk>invar s; 0 \\<le> size s\\<rbrakk>\n       \\<Longrightarrow> local.idx_iteratei_aux (size s) 0 s c f \\<sigma> =\n                         foldli (drop (size s - 0) (\\<alpha> s)) c f\n                          \\<sigma>\n 2. \\<And>i \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   \\<lbrakk>invar s; i \\<le> size s\\<rbrakk>\n                   \\<Longrightarrow> local.idx_iteratei_aux (size s) i s c f\n\\<sigma> =\n                                     foldli (drop (size s - i) (\\<alpha> s))\nc f \\<sigma>;\n        invar s; Suc i \\<le> size s\\<rbrakk>\n       \\<Longrightarrow> local.idx_iteratei_aux (size s) (Suc i) s c f\n                          \\<sigma> =\n                         foldli (drop (size s - Suc i) (\\<alpha> s)) c f\n                          \\<sigma>", "case 0"], ["proof (state)\nthis:\n  invar s\n  0 \\<le> size s\n\ngoal (2 subgoals):\n 1. \\<And>\\<sigma>.\n       \\<lbrakk>invar s; 0 \\<le> size s\\<rbrakk>\n       \\<Longrightarrow> local.idx_iteratei_aux (size s) 0 s c f \\<sigma> =\n                         foldli (drop (size s - 0) (\\<alpha> s)) c f\n                          \\<sigma>\n 2. \\<And>i \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   \\<lbrakk>invar s; i \\<le> size s\\<rbrakk>\n                   \\<Longrightarrow> local.idx_iteratei_aux (size s) i s c f\n\\<sigma> =\n                                     foldli (drop (size s - i) (\\<alpha> s))\nc f \\<sigma>;\n        invar s; Suc i \\<le> size s\\<rbrakk>\n       \\<Longrightarrow> local.idx_iteratei_aux (size s) (Suc i) s c f\n                          \\<sigma> =\n                         foldli (drop (size s - Suc i) (\\<alpha> s)) c f\n                          \\<sigma>", "with size_correct[of s]"], ["proof (chain)\npicking this:\n  invar s \\<Longrightarrow> size s = length (\\<alpha> s)\n  invar s\n  0 \\<le> size s", "show ?case"], ["proof (prove)\nusing this:\n  invar s \\<Longrightarrow> size s = length (\\<alpha> s)\n  invar s\n  0 \\<le> size s\n\ngoal (1 subgoal):\n 1. local.idx_iteratei_aux (size s) 0 s c f \\<sigma> =\n    foldli (drop (size s - 0) (\\<alpha> s)) c f \\<sigma>", "by simp"], ["proof (state)\nthis:\n  local.idx_iteratei_aux (size s) 0 s c f \\<sigma> =\n  foldli (drop (size s - 0) (\\<alpha> s)) c f \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>i \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   \\<lbrakk>invar s; i \\<le> size s\\<rbrakk>\n                   \\<Longrightarrow> local.idx_iteratei_aux (size s) i s c f\n\\<sigma> =\n                                     foldli (drop (size s - i) (\\<alpha> s))\nc f \\<sigma>;\n        invar s; Suc i \\<le> size s\\<rbrakk>\n       \\<Longrightarrow> local.idx_iteratei_aux (size s) (Suc i) s c f\n                          \\<sigma> =\n                         foldli (drop (size s - Suc i) (\\<alpha> s)) c f\n                          \\<sigma>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   \\<lbrakk>invar s; i \\<le> size s\\<rbrakk>\n                   \\<Longrightarrow> local.idx_iteratei_aux (size s) i s c f\n\\<sigma> =\n                                     foldli (drop (size s - i) (\\<alpha> s))\nc f \\<sigma>;\n        invar s; Suc i \\<le> size s\\<rbrakk>\n       \\<Longrightarrow> local.idx_iteratei_aux (size s) (Suc i) s c f\n                          \\<sigma> =\n                         foldli (drop (size s - Suc i) (\\<alpha> s)) c f\n                          \\<sigma>", "case (Suc n)"], ["proof (state)\nthis:\n  \\<lbrakk>invar s; n \\<le> size s\\<rbrakk>\n  \\<Longrightarrow> local.idx_iteratei_aux (size s) n s c f ?\\<sigma>6 =\n                    foldli (drop (size s - n) (\\<alpha> s)) c f ?\\<sigma>6\n  invar s\n  Suc n \\<le> size s\n\ngoal (1 subgoal):\n 1. \\<And>i \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   \\<lbrakk>invar s; i \\<le> size s\\<rbrakk>\n                   \\<Longrightarrow> local.idx_iteratei_aux (size s) i s c f\n\\<sigma> =\n                                     foldli (drop (size s - i) (\\<alpha> s))\nc f \\<sigma>;\n        invar s; Suc i \\<le> size s\\<rbrakk>\n       \\<Longrightarrow> local.idx_iteratei_aux (size s) (Suc i) s c f\n                          \\<sigma> =\n                         foldli (drop (size s - Suc i) (\\<alpha> s)) c f\n                          \\<sigma>", "note [simp, intro!] = Suc.prems(1)"], ["proof (state)\nthis:\n  invar s\n\ngoal (1 subgoal):\n 1. \\<And>i \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   \\<lbrakk>invar s; i \\<le> size s\\<rbrakk>\n                   \\<Longrightarrow> local.idx_iteratei_aux (size s) i s c f\n\\<sigma> =\n                                     foldli (drop (size s - i) (\\<alpha> s))\nc f \\<sigma>;\n        invar s; Suc i \\<le> size s\\<rbrakk>\n       \\<Longrightarrow> local.idx_iteratei_aux (size s) (Suc i) s c f\n                          \\<sigma> =\n                         foldli (drop (size s - Suc i) (\\<alpha> s)) c f\n                          \\<sigma>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.idx_iteratei_aux (size s) (Suc n) s c f \\<sigma> =\n    foldli (drop (size s - Suc n) (\\<alpha> s)) c f \\<sigma>", "proof (cases \"c \\<sigma>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. c \\<sigma> \\<Longrightarrow>\n    local.idx_iteratei_aux (size s) (Suc n) s c f \\<sigma> =\n    foldli (drop (size s - Suc n) (\\<alpha> s)) c f \\<sigma>\n 2. \\<not> c \\<sigma> \\<Longrightarrow>\n    local.idx_iteratei_aux (size s) (Suc n) s c f \\<sigma> =\n    foldli (drop (size s - Suc n) (\\<alpha> s)) c f \\<sigma>", "case False"], ["proof (state)\nthis:\n  \\<not> c \\<sigma>\n\ngoal (2 subgoals):\n 1. c \\<sigma> \\<Longrightarrow>\n    local.idx_iteratei_aux (size s) (Suc n) s c f \\<sigma> =\n    foldli (drop (size s - Suc n) (\\<alpha> s)) c f \\<sigma>\n 2. \\<not> c \\<sigma> \\<Longrightarrow>\n    local.idx_iteratei_aux (size s) (Suc n) s c f \\<sigma> =\n    foldli (drop (size s - Suc n) (\\<alpha> s)) c f \\<sigma>", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> c \\<sigma>\n\ngoal (1 subgoal):\n 1. local.idx_iteratei_aux (size s) (Suc n) s c f \\<sigma> =\n    foldli (drop (size s - Suc n) (\\<alpha> s)) c f \\<sigma>", "by simp"], ["proof (state)\nthis:\n  local.idx_iteratei_aux (size s) (Suc n) s c f \\<sigma> =\n  foldli (drop (size s - Suc n) (\\<alpha> s)) c f \\<sigma>\n\ngoal (1 subgoal):\n 1. c \\<sigma> \\<Longrightarrow>\n    local.idx_iteratei_aux (size s) (Suc n) s c f \\<sigma> =\n    foldli (drop (size s - Suc n) (\\<alpha> s)) c f \\<sigma>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. c \\<sigma> \\<Longrightarrow>\n    local.idx_iteratei_aux (size s) (Suc n) s c f \\<sigma> =\n    foldli (drop (size s - Suc n) (\\<alpha> s)) c f \\<sigma>", "case [simp, intro!]: True"], ["proof (state)\nthis:\n  c \\<sigma>\n\ngoal (1 subgoal):\n 1. c \\<sigma> \\<Longrightarrow>\n    local.idx_iteratei_aux (size s) (Suc n) s c f \\<sigma> =\n    foldli (drop (size s - Suc n) (\\<alpha> s)) c f \\<sigma>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.idx_iteratei_aux (size s) (Suc n) s c f \\<sigma> =\n    foldli (drop (size s - Suc n) (\\<alpha> s)) c f \\<sigma>", "using Suc"], ["proof (prove)\nusing this:\n  \\<lbrakk>invar s; n \\<le> size s\\<rbrakk>\n  \\<Longrightarrow> local.idx_iteratei_aux (size s) n s c f ?\\<sigma>6 =\n                    foldli (drop (size s - n) (\\<alpha> s)) c f ?\\<sigma>6\n  invar s\n  Suc n \\<le> size s\n\ngoal (1 subgoal):\n 1. local.idx_iteratei_aux (size s) (Suc n) s c f \\<sigma> =\n    foldli (drop (size s - Suc n) (\\<alpha> s)) c f \\<sigma>", "by (simp add: get_correct size_correct drop_aux)"], ["proof (state)\nthis:\n  local.idx_iteratei_aux (size s) (Suc n) s c f \\<sigma> =\n  foldli (drop (size s - Suc n) (\\<alpha> s)) c f \\<sigma>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  local.idx_iteratei_aux (size s) (Suc n) s c f \\<sigma> =\n  foldli (drop (size s - Suc n) (\\<alpha> s)) c f \\<sigma>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  local.idx_iteratei_aux (size s) i s c f \\<sigma> =\n  foldli (drop (size s - i) (\\<alpha> s)) c f \\<sigma>\n\ngoal (1 subgoal):\n 1. local.idx_iteratei s = foldli (\\<alpha> s)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>invar ?sa8; ?i8 \\<le> size ?sa8\\<rbrakk>\n  \\<Longrightarrow> local.idx_iteratei_aux (size ?sa8) ?i8 ?sa8 ?c8 ?f8\n                     ?\\<sigma>8 =\n                    foldli (drop (size ?sa8 - ?i8) (\\<alpha> ?sa8)) ?c8 ?f8\n                     ?\\<sigma>8\n\ngoal (1 subgoal):\n 1. local.idx_iteratei s = foldli (\\<alpha> s)", "note aux=this"], ["proof (state)\nthis:\n  \\<lbrakk>invar ?sa8; ?i8 \\<le> size ?sa8\\<rbrakk>\n  \\<Longrightarrow> local.idx_iteratei_aux (size ?sa8) ?i8 ?sa8 ?c8 ?f8\n                     ?\\<sigma>8 =\n                    foldli (drop (size ?sa8 - ?i8) (\\<alpha> ?sa8)) ?c8 ?f8\n                     ?\\<sigma>8\n\ngoal (1 subgoal):\n 1. local.idx_iteratei s = foldli (\\<alpha> s)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.idx_iteratei s = foldli (\\<alpha> s)", "unfolding idx_iteratei_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.idx_iteratei_aux (size s) (size s) s = foldli (\\<alpha> s)", "by (auto simp add: fun_eq_iff aux[of _ \"size s\", simplified])"], ["proof (state)\nthis:\n  local.idx_iteratei s = foldli (\\<alpha> s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas idx_iteratei_unfold[code_unfold] = idx_iteratei_correct[symmetric]"], ["", "subsubsection \\<open>reverse\\_iteratei (by get, size)\\<close>"], ["", "fun idx_reverse_iteratei_aux \n    :: \"nat \\<Rightarrow> nat \\<Rightarrow> 's \\<Rightarrow> ('\\<sigma>\\<Rightarrow>bool) \\<Rightarrow> ('a \\<Rightarrow>'\\<sigma> \\<Rightarrow> '\\<sigma>) \\<Rightarrow> '\\<sigma> \\<Rightarrow> '\\<sigma>\"\n    where\n    \"idx_reverse_iteratei_aux sz i l c f \\<sigma> = (\n      if i=0 \\<or> \\<not> c \\<sigma> then \\<sigma>\n      else idx_reverse_iteratei_aux sz (i - 1) l c f (f (get l (i - 1)) \\<sigma>)\n    )\""], ["", "declare idx_reverse_iteratei_aux.simps[simp del]"], ["", "lemma idx_reverse_iteratei_aux_simps[simp]:\n    \"i=0 \\<Longrightarrow> idx_reverse_iteratei_aux sz i l c f \\<sigma> = \\<sigma>\"\n    \"\\<not>c \\<sigma> \\<Longrightarrow> idx_reverse_iteratei_aux sz i l c f \\<sigma> = \\<sigma>\"\n    \"\\<lbrakk>i\\<noteq>0; c \\<sigma>\\<rbrakk> \\<Longrightarrow> idx_reverse_iteratei_aux sz i l c f \\<sigma> \n    = idx_reverse_iteratei_aux sz (i - 1) l c f (f (get l (i - 1)) \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (i = 0 \\<Longrightarrow>\n     idx_reverse_iteratei_aux sz i l c f \\<sigma> = \\<sigma>) &&&\n    (\\<not> c \\<sigma> \\<Longrightarrow>\n     idx_reverse_iteratei_aux sz i l c f \\<sigma> = \\<sigma>) &&&\n    (\\<lbrakk>i \\<noteq> 0; c \\<sigma>\\<rbrakk>\n     \\<Longrightarrow> idx_reverse_iteratei_aux sz i l c f \\<sigma> =\n                       idx_reverse_iteratei_aux sz (i - 1) l c f\n                        (f (get l (i - 1)) \\<sigma>))", "by (subst idx_reverse_iteratei_aux.simps, simp)+"], ["", "definition \"idx_reverse_iteratei l c f \\<sigma> \n    == idx_reverse_iteratei_aux (size l) (size l) l c f \\<sigma>\""], ["", "lemma idx_reverse_iteratei_correct:\n    shows \"idx_reverse_iteratei s = foldri (\\<alpha> s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. idx_reverse_iteratei s = foldri (\\<alpha> s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. idx_reverse_iteratei s = foldri (\\<alpha> s)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. idx_reverse_iteratei s = foldri (\\<alpha> s)", "fix s c f \\<sigma> i"], ["proof (state)\ngoal (1 subgoal):\n 1. idx_reverse_iteratei s = foldri (\\<alpha> s)", "assume \"invar s\" \"i\\<le>size s\""], ["proof (state)\nthis:\n  invar s\n  i \\<le> size s\n\ngoal (1 subgoal):\n 1. idx_reverse_iteratei s = foldri (\\<alpha> s)", "hence \"idx_reverse_iteratei_aux (size s) i s c f \\<sigma> \n        = foldri (take i (\\<alpha> s)) c f \\<sigma>\""], ["proof (prove)\nusing this:\n  invar s\n  i \\<le> size s\n\ngoal (1 subgoal):\n 1. idx_reverse_iteratei_aux (size s) i s c f \\<sigma> =\n    foldri (take i (\\<alpha> s)) c f \\<sigma>", "proof (induct i arbitrary: \\<sigma>)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma>.\n       \\<lbrakk>invar s; 0 \\<le> size s\\<rbrakk>\n       \\<Longrightarrow> idx_reverse_iteratei_aux (size s) 0 s c f\n                          \\<sigma> =\n                         foldri (take 0 (\\<alpha> s)) c f \\<sigma>\n 2. \\<And>i \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   \\<lbrakk>invar s; i \\<le> size s\\<rbrakk>\n                   \\<Longrightarrow> idx_reverse_iteratei_aux (size s) i s c\nf \\<sigma> =\n                                     foldri (take i (\\<alpha> s)) c f\n\\<sigma>;\n        invar s; Suc i \\<le> size s\\<rbrakk>\n       \\<Longrightarrow> idx_reverse_iteratei_aux (size s) (Suc i) s c f\n                          \\<sigma> =\n                         foldri (take (Suc i) (\\<alpha> s)) c f \\<sigma>", "case 0"], ["proof (state)\nthis:\n  invar s\n  0 \\<le> size s\n\ngoal (2 subgoals):\n 1. \\<And>\\<sigma>.\n       \\<lbrakk>invar s; 0 \\<le> size s\\<rbrakk>\n       \\<Longrightarrow> idx_reverse_iteratei_aux (size s) 0 s c f\n                          \\<sigma> =\n                         foldri (take 0 (\\<alpha> s)) c f \\<sigma>\n 2. \\<And>i \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   \\<lbrakk>invar s; i \\<le> size s\\<rbrakk>\n                   \\<Longrightarrow> idx_reverse_iteratei_aux (size s) i s c\nf \\<sigma> =\n                                     foldri (take i (\\<alpha> s)) c f\n\\<sigma>;\n        invar s; Suc i \\<le> size s\\<rbrakk>\n       \\<Longrightarrow> idx_reverse_iteratei_aux (size s) (Suc i) s c f\n                          \\<sigma> =\n                         foldri (take (Suc i) (\\<alpha> s)) c f \\<sigma>", "with size_correct[of s]"], ["proof (chain)\npicking this:\n  invar s \\<Longrightarrow> size s = length (\\<alpha> s)\n  invar s\n  0 \\<le> size s", "show ?case"], ["proof (prove)\nusing this:\n  invar s \\<Longrightarrow> size s = length (\\<alpha> s)\n  invar s\n  0 \\<le> size s\n\ngoal (1 subgoal):\n 1. idx_reverse_iteratei_aux (size s) 0 s c f \\<sigma> =\n    foldri (take 0 (\\<alpha> s)) c f \\<sigma>", "by simp"], ["proof (state)\nthis:\n  idx_reverse_iteratei_aux (size s) 0 s c f \\<sigma> =\n  foldri (take 0 (\\<alpha> s)) c f \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>i \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   \\<lbrakk>invar s; i \\<le> size s\\<rbrakk>\n                   \\<Longrightarrow> idx_reverse_iteratei_aux (size s) i s c\nf \\<sigma> =\n                                     foldri (take i (\\<alpha> s)) c f\n\\<sigma>;\n        invar s; Suc i \\<le> size s\\<rbrakk>\n       \\<Longrightarrow> idx_reverse_iteratei_aux (size s) (Suc i) s c f\n                          \\<sigma> =\n                         foldri (take (Suc i) (\\<alpha> s)) c f \\<sigma>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   \\<lbrakk>invar s; i \\<le> size s\\<rbrakk>\n                   \\<Longrightarrow> idx_reverse_iteratei_aux (size s) i s c\nf \\<sigma> =\n                                     foldri (take i (\\<alpha> s)) c f\n\\<sigma>;\n        invar s; Suc i \\<le> size s\\<rbrakk>\n       \\<Longrightarrow> idx_reverse_iteratei_aux (size s) (Suc i) s c f\n                          \\<sigma> =\n                         foldri (take (Suc i) (\\<alpha> s)) c f \\<sigma>", "case (Suc n)"], ["proof (state)\nthis:\n  \\<lbrakk>invar s; n \\<le> size s\\<rbrakk>\n  \\<Longrightarrow> idx_reverse_iteratei_aux (size s) n s c f ?\\<sigma>12 =\n                    foldri (take n (\\<alpha> s)) c f ?\\<sigma>12\n  invar s\n  Suc n \\<le> size s\n\ngoal (1 subgoal):\n 1. \\<And>i \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   \\<lbrakk>invar s; i \\<le> size s\\<rbrakk>\n                   \\<Longrightarrow> idx_reverse_iteratei_aux (size s) i s c\nf \\<sigma> =\n                                     foldri (take i (\\<alpha> s)) c f\n\\<sigma>;\n        invar s; Suc i \\<le> size s\\<rbrakk>\n       \\<Longrightarrow> idx_reverse_iteratei_aux (size s) (Suc i) s c f\n                          \\<sigma> =\n                         foldri (take (Suc i) (\\<alpha> s)) c f \\<sigma>", "note [simp, intro!] = Suc.prems(1)"], ["proof (state)\nthis:\n  invar s\n\ngoal (1 subgoal):\n 1. \\<And>i \\<sigma>.\n       \\<lbrakk>\\<And>\\<sigma>.\n                   \\<lbrakk>invar s; i \\<le> size s\\<rbrakk>\n                   \\<Longrightarrow> idx_reverse_iteratei_aux (size s) i s c\nf \\<sigma> =\n                                     foldri (take i (\\<alpha> s)) c f\n\\<sigma>;\n        invar s; Suc i \\<le> size s\\<rbrakk>\n       \\<Longrightarrow> idx_reverse_iteratei_aux (size s) (Suc i) s c f\n                          \\<sigma> =\n                         foldri (take (Suc i) (\\<alpha> s)) c f \\<sigma>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. idx_reverse_iteratei_aux (size s) (Suc n) s c f \\<sigma> =\n    foldri (take (Suc n) (\\<alpha> s)) c f \\<sigma>", "proof (cases \"c \\<sigma>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. c \\<sigma> \\<Longrightarrow>\n    idx_reverse_iteratei_aux (size s) (Suc n) s c f \\<sigma> =\n    foldri (take (Suc n) (\\<alpha> s)) c f \\<sigma>\n 2. \\<not> c \\<sigma> \\<Longrightarrow>\n    idx_reverse_iteratei_aux (size s) (Suc n) s c f \\<sigma> =\n    foldri (take (Suc n) (\\<alpha> s)) c f \\<sigma>", "case False"], ["proof (state)\nthis:\n  \\<not> c \\<sigma>\n\ngoal (2 subgoals):\n 1. c \\<sigma> \\<Longrightarrow>\n    idx_reverse_iteratei_aux (size s) (Suc n) s c f \\<sigma> =\n    foldri (take (Suc n) (\\<alpha> s)) c f \\<sigma>\n 2. \\<not> c \\<sigma> \\<Longrightarrow>\n    idx_reverse_iteratei_aux (size s) (Suc n) s c f \\<sigma> =\n    foldri (take (Suc n) (\\<alpha> s)) c f \\<sigma>", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> c \\<sigma>\n\ngoal (1 subgoal):\n 1. idx_reverse_iteratei_aux (size s) (Suc n) s c f \\<sigma> =\n    foldri (take (Suc n) (\\<alpha> s)) c f \\<sigma>", "by simp"], ["proof (state)\nthis:\n  idx_reverse_iteratei_aux (size s) (Suc n) s c f \\<sigma> =\n  foldri (take (Suc n) (\\<alpha> s)) c f \\<sigma>\n\ngoal (1 subgoal):\n 1. c \\<sigma> \\<Longrightarrow>\n    idx_reverse_iteratei_aux (size s) (Suc n) s c f \\<sigma> =\n    foldri (take (Suc n) (\\<alpha> s)) c f \\<sigma>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. c \\<sigma> \\<Longrightarrow>\n    idx_reverse_iteratei_aux (size s) (Suc n) s c f \\<sigma> =\n    foldri (take (Suc n) (\\<alpha> s)) c f \\<sigma>", "case [simp, intro!]: True"], ["proof (state)\nthis:\n  c \\<sigma>\n\ngoal (1 subgoal):\n 1. c \\<sigma> \\<Longrightarrow>\n    idx_reverse_iteratei_aux (size s) (Suc n) s c f \\<sigma> =\n    foldri (take (Suc n) (\\<alpha> s)) c f \\<sigma>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. idx_reverse_iteratei_aux (size s) (Suc n) s c f \\<sigma> =\n    foldri (take (Suc n) (\\<alpha> s)) c f \\<sigma>", "using Suc"], ["proof (prove)\nusing this:\n  \\<lbrakk>invar s; n \\<le> size s\\<rbrakk>\n  \\<Longrightarrow> idx_reverse_iteratei_aux (size s) n s c f ?\\<sigma>12 =\n                    foldri (take n (\\<alpha> s)) c f ?\\<sigma>12\n  invar s\n  Suc n \\<le> size s\n\ngoal (1 subgoal):\n 1. idx_reverse_iteratei_aux (size s) (Suc n) s c f \\<sigma> =\n    foldri (take (Suc n) (\\<alpha> s)) c f \\<sigma>", "by (simp add: get_correct size_correct take_Suc_conv_app_nth)"], ["proof (state)\nthis:\n  idx_reverse_iteratei_aux (size s) (Suc n) s c f \\<sigma> =\n  foldri (take (Suc n) (\\<alpha> s)) c f \\<sigma>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  idx_reverse_iteratei_aux (size s) (Suc n) s c f \\<sigma> =\n  foldri (take (Suc n) (\\<alpha> s)) c f \\<sigma>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  idx_reverse_iteratei_aux (size s) i s c f \\<sigma> =\n  foldri (take i (\\<alpha> s)) c f \\<sigma>\n\ngoal (1 subgoal):\n 1. idx_reverse_iteratei s = foldri (\\<alpha> s)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>invar ?sa14; ?i14 \\<le> size ?sa14\\<rbrakk>\n  \\<Longrightarrow> idx_reverse_iteratei_aux (size ?sa14) ?i14 ?sa14 ?c14\n                     ?f14 ?\\<sigma>14 =\n                    foldri (take ?i14 (\\<alpha> ?sa14)) ?c14 ?f14\n                     ?\\<sigma>14\n\ngoal (1 subgoal):\n 1. idx_reverse_iteratei s = foldri (\\<alpha> s)", "note aux=this"], ["proof (state)\nthis:\n  \\<lbrakk>invar ?sa14; ?i14 \\<le> size ?sa14\\<rbrakk>\n  \\<Longrightarrow> idx_reverse_iteratei_aux (size ?sa14) ?i14 ?sa14 ?c14\n                     ?f14 ?\\<sigma>14 =\n                    foldri (take ?i14 (\\<alpha> ?sa14)) ?c14 ?f14\n                     ?\\<sigma>14\n\ngoal (1 subgoal):\n 1. idx_reverse_iteratei s = foldri (\\<alpha> s)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. idx_reverse_iteratei s = foldri (\\<alpha> s)", "unfolding idx_reverse_iteratei_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. idx_reverse_iteratei_aux (size s) (size s) s = foldri (\\<alpha> s)", "apply (simp add: fun_eq_iff aux[of _ \"size s\", simplified])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x xa xb.\n       foldri (take (size s) (\\<alpha> s)) x xa xb =\n       foldri (\\<alpha> s) x xa xb", "apply (simp add: size_correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  idx_reverse_iteratei s = foldri (\\<alpha> s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas idx_reverse_iteratei_unfold[code_unfold] \n    = idx_reverse_iteratei_correct[symmetric]"], ["", "end"], ["", "subsection \\<open>Size (by iterator)\\<close>"], ["", "locale it_size_loc = poly_list_iteratei +\n  constrains \\<alpha> :: \"'s \\<Rightarrow> 'a list\"\nbegin"], ["", "definition it_size :: \"'s \\<Rightarrow> nat\"\n    where \"it_size l == iterate l (\\<lambda>x res. Suc res) (0::nat)\""], ["", "lemma it_size_impl: shows \"list_size \\<alpha> invar it_size\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_size \\<alpha> invar it_size", "apply (unfold_locales)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s. invar s \\<Longrightarrow> it_size s = length (\\<alpha> s)", "apply (unfold it_size_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       invar s \\<Longrightarrow>\n       iterate s (\\<lambda>x. Suc) 0 = length (\\<alpha> s)", "apply (simp add: iterate_correct foldli_foldl)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "subsubsection \\<open>Size (by reverse\\_iterator)\\<close>"], ["", "locale rev_it_size_loc = poly_list_rev_iteratei +\n  constrains \\<alpha> :: \"'s \\<Rightarrow> 'a list\"\nbegin"], ["", "definition rev_it_size :: \"'s \\<Rightarrow> nat\"\n    where \"rev_it_size l == rev_iterate l (\\<lambda>x res. Suc res) (0::nat)\""], ["", "lemma rev_it_size_impl:\n    shows \"list_size \\<alpha> invar rev_it_size\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_size \\<alpha> invar rev_it_size", "apply (unfold_locales)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s. invar s \\<Longrightarrow> rev_it_size s = length (\\<alpha> s)", "apply (unfold rev_it_size_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       invar s \\<Longrightarrow>\n       rev_iterate s (\\<lambda>x. Suc) 0 = length (\\<alpha> s)", "apply (simp add: rev_iterate_correct foldri_foldr)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "subsection \\<open>Get (by iteratori)\\<close>"], ["", "locale it_get_loc = poly_list_iteratei + \n  constrains \\<alpha> :: \"'s \\<Rightarrow> 'a list\"\nbegin"], ["", "definition it_get:: \"'s \\<Rightarrow> nat \\<Rightarrow> 'a\" \n    where \"it_get s i \\<equiv> \n      the (snd (iteratei s\n                (\\<lambda>(i,x). x=None) \n                (\\<lambda>x (i,_). if i=0 then (0,Some x) else (i - 1,None)) \n                (i,None)))\""], ["", "lemma it_get_correct:\n    shows \"list_get \\<alpha> invar it_get\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_get \\<alpha> invar it_get", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s i.\n       \\<lbrakk>invar s; i < length (\\<alpha> s)\\<rbrakk>\n       \\<Longrightarrow> it_get s i = \\<alpha> s ! i", "fix s i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s i.\n       \\<lbrakk>invar s; i < length (\\<alpha> s)\\<rbrakk>\n       \\<Longrightarrow> it_get s i = \\<alpha> s ! i", "assume \"invar s\" \"i < length (\\<alpha> s)\""], ["proof (state)\nthis:\n  invar s\n  i < length (\\<alpha> s)\n\ngoal (1 subgoal):\n 1. \\<And>s i.\n       \\<lbrakk>invar s; i < length (\\<alpha> s)\\<rbrakk>\n       \\<Longrightarrow> it_get s i = \\<alpha> s ! i", "define l where \"l = \\<alpha> s\""], ["proof (state)\nthis:\n  l = \\<alpha> s\n\ngoal (1 subgoal):\n 1. \\<And>s i.\n       \\<lbrakk>invar s; i < length (\\<alpha> s)\\<rbrakk>\n       \\<Longrightarrow> it_get s i = \\<alpha> s ! i", "from \\<open>i < length (\\<alpha> s)\\<close>"], ["proof (chain)\npicking this:\n  i < length (\\<alpha> s)", "show \"it_get s i = \\<alpha> s ! i\""], ["proof (prove)\nusing this:\n  i < length (\\<alpha> s)\n\ngoal (1 subgoal):\n 1. it_get s i = \\<alpha> s ! i", "unfolding it_get_def iteratei_correct l_def[symmetric]"], ["proof (prove)\nusing this:\n  i < length l\n\ngoal (1 subgoal):\n 1. the (snd (foldli l (\\<lambda>(i, x). x = None)\n               (\\<lambda>x (i, uu_).\n                   if i = 0 then (0, Some x) else (i - 1, None))\n               (i, None))) =\n    l ! i", "proof (induct i arbitrary: l)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>l.\n       0 < length l \\<Longrightarrow>\n       the (snd (foldli l (\\<lambda>(i, x). x = None)\n                  (\\<lambda>x (i, uu_).\n                      if i = 0 then (0, Some x) else (i - 1, None))\n                  (0, None))) =\n       l ! 0\n 2. \\<And>i l.\n       \\<lbrakk>\\<And>l.\n                   i < length l \\<Longrightarrow>\n                   the (snd (foldli l (\\<lambda>(i, x). x = None)\n                              (\\<lambda>x (i, uu_).\n                                  if i = 0 then (0, Some x)\n                                  else (i - 1, None))\n                              (i, None))) =\n                   l ! i;\n        Suc i < length l\\<rbrakk>\n       \\<Longrightarrow> the (snd (foldli l (\\<lambda>(i, x). x = None)\n                                    (\\<lambda>x (i, uu_).\n  if i = 0 then (0, Some x) else (i - 1, None))\n                                    (Suc i, None))) =\n                         l ! Suc i", "case 0"], ["proof (state)\nthis:\n  0 < length l\n\ngoal (2 subgoals):\n 1. \\<And>l.\n       0 < length l \\<Longrightarrow>\n       the (snd (foldli l (\\<lambda>(i, x). x = None)\n                  (\\<lambda>x (i, uu_).\n                      if i = 0 then (0, Some x) else (i - 1, None))\n                  (0, None))) =\n       l ! 0\n 2. \\<And>i l.\n       \\<lbrakk>\\<And>l.\n                   i < length l \\<Longrightarrow>\n                   the (snd (foldli l (\\<lambda>(i, x). x = None)\n                              (\\<lambda>x (i, uu_).\n                                  if i = 0 then (0, Some x)\n                                  else (i - 1, None))\n                              (i, None))) =\n                   l ! i;\n        Suc i < length l\\<rbrakk>\n       \\<Longrightarrow> the (snd (foldli l (\\<lambda>(i, x). x = None)\n                                    (\\<lambda>x (i, uu_).\n  if i = 0 then (0, Some x) else (i - 1, None))\n                                    (Suc i, None))) =\n                         l ! Suc i", "then"], ["proof (chain)\npicking this:\n  0 < length l", "obtain x xs where l_eq[simp]: \"l = x # xs\""], ["proof (prove)\nusing this:\n  0 < length l\n\ngoal (1 subgoal):\n 1. (\\<And>x xs. l = x # xs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases l, auto)"], ["proof (state)\nthis:\n  l = x # xs\n\ngoal (2 subgoals):\n 1. \\<And>l.\n       0 < length l \\<Longrightarrow>\n       the (snd (foldli l (\\<lambda>(i, x). x = None)\n                  (\\<lambda>x (i, uu_).\n                      if i = 0 then (0, Some x) else (i - 1, None))\n                  (0, None))) =\n       l ! 0\n 2. \\<And>i l.\n       \\<lbrakk>\\<And>l.\n                   i < length l \\<Longrightarrow>\n                   the (snd (foldli l (\\<lambda>(i, x). x = None)\n                              (\\<lambda>x (i, uu_).\n                                  if i = 0 then (0, Some x)\n                                  else (i - 1, None))\n                              (i, None))) =\n                   l ! i;\n        Suc i < length l\\<rbrakk>\n       \\<Longrightarrow> the (snd (foldli l (\\<lambda>(i, x). x = None)\n                                    (\\<lambda>x (i, uu_).\n  if i = 0 then (0, Some x) else (i - 1, None))\n                                    (Suc i, None))) =\n                         l ! Suc i", "thus ?case"], ["proof (prove)\nusing this:\n  l = x # xs\n\ngoal (1 subgoal):\n 1. the (snd (foldli l (\\<lambda>a. case a of (i, x) \\<Rightarrow> x = None)\n               (\\<lambda>x a.\n                   case a of\n                   (i, uu_) \\<Rightarrow>\n                     if i = 0 then (0, Some x) else (i - 1, None))\n               (0, None))) =\n    l ! 0", "by simp"], ["proof (state)\nthis:\n  the (snd (foldli l (\\<lambda>a. case a of (i, x) \\<Rightarrow> x = None)\n             (\\<lambda>x a.\n                 case a of\n                 (i, uu_) \\<Rightarrow>\n                   if i = 0 then (0, Some x) else (i - 1, None))\n             (0, None))) =\n  l ! 0\n\ngoal (1 subgoal):\n 1. \\<And>i l.\n       \\<lbrakk>\\<And>l.\n                   i < length l \\<Longrightarrow>\n                   the (snd (foldli l (\\<lambda>(i, x). x = None)\n                              (\\<lambda>x (i, uu_).\n                                  if i = 0 then (0, Some x)\n                                  else (i - 1, None))\n                              (i, None))) =\n                   l ! i;\n        Suc i < length l\\<rbrakk>\n       \\<Longrightarrow> the (snd (foldli l (\\<lambda>(i, x). x = None)\n                                    (\\<lambda>x (i, uu_).\n  if i = 0 then (0, Some x) else (i - 1, None))\n                                    (Suc i, None))) =\n                         l ! Suc i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i l.\n       \\<lbrakk>\\<And>l.\n                   i < length l \\<Longrightarrow>\n                   the (snd (foldli l (\\<lambda>(i, x). x = None)\n                              (\\<lambda>x (i, uu_).\n                                  if i = 0 then (0, Some x)\n                                  else (i - 1, None))\n                              (i, None))) =\n                   l ! i;\n        Suc i < length l\\<rbrakk>\n       \\<Longrightarrow> the (snd (foldli l (\\<lambda>(i, x). x = None)\n                                    (\\<lambda>x (i, uu_).\n  if i = 0 then (0, Some x) else (i - 1, None))\n                                    (Suc i, None))) =\n                         l ! Suc i", "case (Suc i)"], ["proof (state)\nthis:\n  i < length ?l2 \\<Longrightarrow>\n  the (snd (foldli ?l2 (\\<lambda>a. case a of (i, x) \\<Rightarrow> x = None)\n             (\\<lambda>x a.\n                 case a of\n                 (i, uu_) \\<Rightarrow>\n                   if i = 0 then (0, Some x) else (i - 1, None))\n             (i, None))) =\n  ?l2 ! i\n  Suc i < length l\n\ngoal (1 subgoal):\n 1. \\<And>i l.\n       \\<lbrakk>\\<And>l.\n                   i < length l \\<Longrightarrow>\n                   the (snd (foldli l (\\<lambda>(i, x). x = None)\n                              (\\<lambda>x (i, uu_).\n                                  if i = 0 then (0, Some x)\n                                  else (i - 1, None))\n                              (i, None))) =\n                   l ! i;\n        Suc i < length l\\<rbrakk>\n       \\<Longrightarrow> the (snd (foldli l (\\<lambda>(i, x). x = None)\n                                    (\\<lambda>x (i, uu_).\n  if i = 0 then (0, Some x) else (i - 1, None))\n                                    (Suc i, None))) =\n                         l ! Suc i", "note ind_hyp = Suc(1)"], ["proof (state)\nthis:\n  i < length ?l2 \\<Longrightarrow>\n  the (snd (foldli ?l2 (\\<lambda>a. case a of (i, x) \\<Rightarrow> x = None)\n             (\\<lambda>x a.\n                 case a of\n                 (i, uu_) \\<Rightarrow>\n                   if i = 0 then (0, Some x) else (i - 1, None))\n             (i, None))) =\n  ?l2 ! i\n\ngoal (1 subgoal):\n 1. \\<And>i l.\n       \\<lbrakk>\\<And>l.\n                   i < length l \\<Longrightarrow>\n                   the (snd (foldli l (\\<lambda>(i, x). x = None)\n                              (\\<lambda>x (i, uu_).\n                                  if i = 0 then (0, Some x)\n                                  else (i - 1, None))\n                              (i, None))) =\n                   l ! i;\n        Suc i < length l\\<rbrakk>\n       \\<Longrightarrow> the (snd (foldli l (\\<lambda>(i, x). x = None)\n                                    (\\<lambda>x (i, uu_).\n  if i = 0 then (0, Some x) else (i - 1, None))\n                                    (Suc i, None))) =\n                         l ! Suc i", "note Suc_i_le = Suc(2)"], ["proof (state)\nthis:\n  Suc i < length l\n\ngoal (1 subgoal):\n 1. \\<And>i l.\n       \\<lbrakk>\\<And>l.\n                   i < length l \\<Longrightarrow>\n                   the (snd (foldli l (\\<lambda>(i, x). x = None)\n                              (\\<lambda>x (i, uu_).\n                                  if i = 0 then (0, Some x)\n                                  else (i - 1, None))\n                              (i, None))) =\n                   l ! i;\n        Suc i < length l\\<rbrakk>\n       \\<Longrightarrow> the (snd (foldli l (\\<lambda>(i, x). x = None)\n                                    (\\<lambda>x (i, uu_).\n  if i = 0 then (0, Some x) else (i - 1, None))\n                                    (Suc i, None))) =\n                         l ! Suc i", "from Suc_i_le"], ["proof (chain)\npicking this:\n  Suc i < length l", "obtain x xs \n        where l_eq[simp]: \"l = x # xs\""], ["proof (prove)\nusing this:\n  Suc i < length l\n\ngoal (1 subgoal):\n 1. (\\<And>x xs. l = x # xs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases l, auto)"], ["proof (state)\nthis:\n  l = x # xs\n\ngoal (1 subgoal):\n 1. \\<And>i l.\n       \\<lbrakk>\\<And>l.\n                   i < length l \\<Longrightarrow>\n                   the (snd (foldli l (\\<lambda>(i, x). x = None)\n                              (\\<lambda>x (i, uu_).\n                                  if i = 0 then (0, Some x)\n                                  else (i - 1, None))\n                              (i, None))) =\n                   l ! i;\n        Suc i < length l\\<rbrakk>\n       \\<Longrightarrow> the (snd (foldli l (\\<lambda>(i, x). x = None)\n                                    (\\<lambda>x (i, uu_).\n  if i = 0 then (0, Some x) else (i - 1, None))\n                                    (Suc i, None))) =\n                         l ! Suc i", "from ind_hyp [of xs] Suc_i_le"], ["proof (chain)\npicking this:\n  i < length xs \\<Longrightarrow>\n  the (snd (foldli xs (\\<lambda>a. case a of (i, x) \\<Rightarrow> x = None)\n             (\\<lambda>x a.\n                 case a of\n                 (i, uu_) \\<Rightarrow>\n                   if i = 0 then (0, Some x) else (i - 1, None))\n             (i, None))) =\n  xs ! i\n  Suc i < length l", "show ?case"], ["proof (prove)\nusing this:\n  i < length xs \\<Longrightarrow>\n  the (snd (foldli xs (\\<lambda>a. case a of (i, x) \\<Rightarrow> x = None)\n             (\\<lambda>x a.\n                 case a of\n                 (i, uu_) \\<Rightarrow>\n                   if i = 0 then (0, Some x) else (i - 1, None))\n             (i, None))) =\n  xs ! i\n  Suc i < length l\n\ngoal (1 subgoal):\n 1. the (snd (foldli l (\\<lambda>a. case a of (i, x) \\<Rightarrow> x = None)\n               (\\<lambda>x a.\n                   case a of\n                   (i, uu_) \\<Rightarrow>\n                     if i = 0 then (0, Some x) else (i - 1, None))\n               (Suc i, None))) =\n    l ! Suc i", "by simp"], ["proof (state)\nthis:\n  the (snd (foldli l (\\<lambda>a. case a of (i, x) \\<Rightarrow> x = None)\n             (\\<lambda>x a.\n                 case a of\n                 (i, uu_) \\<Rightarrow>\n                   if i = 0 then (0, Some x) else (i - 1, None))\n             (Suc i, None))) =\n  l ! Suc i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  it_get s i = \\<alpha> s ! i\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}