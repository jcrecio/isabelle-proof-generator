{"file_name": "/home/qj213/afp-2021-10-22/thys/Collections/ICF/impl/ArrayMapImpl.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Collections", "problem_names": ["lemma [code]: \"iam_\\<alpha> a i \\<equiv> array_get_oo None a i\"", "lemma incr_correct: \"\\<not> idx < l \\<Longrightarrow> idx < l + iam_increment l idx\"", "lemma [code]: \"iam_update k v a \\<equiv> array_set_oo \n    (\\<lambda>_. array_set \n           (array_grow a (iam_increment (array_length a) k) None) k (Some v))\n    a k (Some v)\n    \"", "lemma [code]: \"iam_delete k a \\<equiv> array_set_oo (\\<lambda>_. a) a k None\"", "lemma iam_iterateoi_aux_csimps:\n    \"i \\<ge> len \\<Longrightarrow> iam_iterateoi_aux i len a c f \\<sigma> = \\<sigma>\"\n    \"\\<not> c \\<sigma> \\<Longrightarrow> iam_iterateoi_aux i len a c f \\<sigma> = \\<sigma>\"\n    \"\\<lbrakk> i< len; c \\<sigma> \\<rbrakk> \\<Longrightarrow> iam_iterateoi_aux i len a c f \\<sigma> = \n      (case array_get a i of\n        None \\<Rightarrow> iam_iterateoi_aux (i + 1) len a c f \\<sigma>\n      | Some x \\<Rightarrow> iam_iterateoi_aux (i + 1) len a c f (f (i,x) \\<sigma>))\"", "lemma iam_empty_impl: \"map_empty iam_\\<alpha> iam_invar iam_empty\"", "lemma iam_lookup_impl: \"map_lookup iam_\\<alpha> iam_invar iam_lookup\"", "lemma array_get_set_iff: \"i<array_length a \\<Longrightarrow> \n    array_get (array_set a i x) j = (if i=j then x else array_get a j)\"", "lemma iam_update_impl: \"map_update iam_\\<alpha> iam_invar iam_update\"", "lemma iam_update_dj_impl: \"map_update_dj iam_\\<alpha> iam_invar iam_update_dj\"", "lemma iam_delete_impl: \"map_delete iam_\\<alpha> iam_invar iam_delete\"", "lemma iam_rev_iterateoi_aux_foldli_conv :\n    \"iam_rev_iterateoi_aux n a =\n     foldli (List.map_filter (\\<lambda>n. map_option (\\<lambda>v. (n, v)) (array_get a n)) (rev [0..<n]))\"", "lemma iam_rev_iterateoi_foldli_conv :\n    \"iam_rev_iterateoi a =\n     foldli (List.map_filter \n       (\\<lambda>n. map_option (\\<lambda>v. (n, v)) (array_get a n)) \n       (rev [0..<(array_length a)]))\"", "lemma iam_rev_iterateoi_correct : \n  fixes m::\"'a option array\"\n  defines \"kvs \\<equiv> List.map_filter \n    (\\<lambda>n. map_option (\\<lambda>v. (n, v)) (array_get m n)) (rev [0..<(array_length m)])\"\n  shows \"map_iterator_rev_linord (iam_rev_iterateoi m) (iam_\\<alpha> m)\"", "lemma iam_rev_iterateoi_impl: \n    \"poly_map_rev_iterateoi iam_\\<alpha> iam_invar iam_rev_iterateoi\"", "lemma iam_iteratei_impl: \n    \"poly_map_iteratei iam_\\<alpha> iam_invar iam_rev_iterateoi\"", "lemma iam_iterateoi_aux_foldli_conv :\n    \"iam_iterateoi_aux n (array_length a) a c f \\<sigma> =\n     foldli (List.map_filter (\\<lambda>n. map_option (\\<lambda>v. (n, v)) (array_get a n)) \n       ([n..<array_length a])) c f \\<sigma>\"", "lemma iam_iterateoi_foldli_conv :\n    \"iam_iterateoi a =\n     foldli (List.map_filter \n       (\\<lambda>n. map_option (\\<lambda>v. (n, v)) (array_get a n)) \n       ([0..<(array_length a)]))\"", "lemmas [simp] = map_filter_simps", "lemma map_filter_append[simp]: \"List.map_filter f (la@lb) \n    = List.map_filter f la @ List.map_filter f lb\"", "lemma iam_iterateoi_correct: \n  fixes m::\"'a option array\"\n  defines \"kvs \\<equiv> List.map_filter \n    (\\<lambda>n. map_option (\\<lambda>v. (n, v)) (array_get m n)) ([0..<(array_length m)])\"\n  shows \"map_iterator_linord (iam_iterateoi m) (iam_\\<alpha> m)\"", "lemma iam_iterateoi_impl: \n    \"poly_map_iterateoi iam_\\<alpha> iam_invar iam_iterateoi\"", "lemma pi_iam[proper_it]: \n    \"proper_it' iam_iterateoi iam_iterateoi\"", "lemma pi_iam_rev[proper_it]: \n    \"proper_it' iam_rev_iterateoi iam_rev_iterateoi\""], "translations": [["", "lemma [code]: \"iam_\\<alpha> a i \\<equiv> array_get_oo None a i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iam_\\<alpha> a i \\<equiv> array_get_oo None a i", "unfolding iam_\\<alpha>_def array_get_oo_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. if i < array_length a then array_get a i else None \\<equiv>\n    if i < array_length a then array_get a i else None", "."], ["", "abbreviation (input) iam_invar :: \"'v iam \\<Rightarrow> bool\" \n    where \"iam_invar \\<equiv> \\<lambda>_. True\""], ["", "definition iam_empty :: \"unit \\<Rightarrow> 'v iam\" \n    where \"iam_empty \\<equiv> \\<lambda>_::unit. array_of_list []\""], ["", "definition iam_lookup :: \"nat \\<Rightarrow> 'v iam \\<rightharpoonup> 'v\"\n    where [code_unfold]: \"iam_lookup k a \\<equiv> iam_\\<alpha> a k\""], ["", "definition \"iam_increment (l::nat) idx \\<equiv> \n    max (idx + 1 - l) (2 * l + 3)\""], ["", "lemma incr_correct: \"\\<not> idx < l \\<Longrightarrow> idx < l + iam_increment l idx\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> idx < l \\<Longrightarrow> idx < l + iam_increment l idx", "unfolding iam_increment_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> idx < l \\<Longrightarrow> idx < l + max (idx + 1 - l) (2 * l + 3)", "by auto"], ["", "definition iam_update :: \"nat \\<Rightarrow> 'v \\<Rightarrow> 'v iam \\<Rightarrow> 'v iam\"\n    where \"iam_update k v a \\<equiv> let\n    l = array_length a;\n    a = if k < l then a else array_grow a (iam_increment l k) None\n  in\n    array_set a k (Some v)\n    \""], ["", "lemma [code]: \"iam_update k v a \\<equiv> array_set_oo \n    (\\<lambda>_. array_set \n           (array_grow a (iam_increment (array_length a) k) None) k (Some v))\n    a k (Some v)\n    \""], ["proof (prove)\ngoal (1 subgoal):\n 1. iam_update k v a \\<equiv>\n    array_set_oo\n     (\\<lambda>_.\n         array_set (array_grow a (iam_increment (array_length a) k) None) k\n          (Some v))\n     a k (Some v)", "unfolding iam_update_def array_set_oo_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. let l = array_length a;\n        a = if k < l then a else array_grow a (iam_increment l k) None\n    in array_set a k (Some v) \\<equiv>\n    if k < array_length a then array_set a k (Some v)\n    else array_set (array_grow a (iam_increment (array_length a) k) None) k\n          (Some v)", "apply (rule eq_reflection)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let l = array_length a;\n         a = if k < l then a else array_grow a (iam_increment l k) None\n     in array_set a k (Some v)) =\n    (if k < array_length a then array_set a k (Some v)\n     else array_set (array_grow a (iam_increment (array_length a) k) None) k\n           (Some v))", "apply (auto simp add: Let_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition \"iam_update_dj \\<equiv> iam_update\""], ["", "definition iam_delete :: \"nat \\<Rightarrow> 'v iam \\<Rightarrow> 'v iam\"\n    where \"iam_delete k a \\<equiv> \n    if k<array_length a then array_set a k None else a\""], ["", "lemma [code]: \"iam_delete k a \\<equiv> array_set_oo (\\<lambda>_. a) a k None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iam_delete k a \\<equiv> array_set_oo (\\<lambda>_. a) a k None", "unfolding iam_delete_def array_set_oo_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. if k < array_length a then array_set a k None else a \\<equiv>\n    if k < array_length a then array_set a k None else a", "by auto"], ["", "fun iam_rev_iterateoi_aux \n    :: \"nat \\<Rightarrow> ('v iam) \\<Rightarrow> ('\\<sigma>\\<Rightarrow>bool) \\<Rightarrow> (nat \\<times> 'v\\<Rightarrow>'\\<sigma>\\<Rightarrow>'\\<sigma>) \\<Rightarrow> '\\<sigma> \\<Rightarrow> '\\<sigma>\" \n    where\n      \"iam_rev_iterateoi_aux 0 a c f \\<sigma> = \\<sigma>\"\n    | \"iam_rev_iterateoi_aux i a c f \\<sigma> = (\n        if c \\<sigma> then   \n          iam_rev_iterateoi_aux (i - 1) a c f (\n            case array_get a (i - 1) of None \\<Rightarrow> \\<sigma> | Some x \\<Rightarrow> f (i - 1, x) \\<sigma>\n          )\n        else \\<sigma>)\""], ["", "definition iam_rev_iterateoi :: \"'v iam \\<Rightarrow> (nat \\<times> 'v,'\\<sigma>) set_iterator\" where \n    \"iam_rev_iterateoi a \\<equiv> iam_rev_iterateoi_aux (array_length a) a\""], ["", "function iam_iterateoi_aux \n    :: \"nat \\<Rightarrow> nat \\<Rightarrow> ('v iam) \\<Rightarrow> ('\\<sigma>\\<Rightarrow>bool) \\<Rightarrow> (nat \\<times> 'v\\<Rightarrow>'\\<sigma>\\<Rightarrow>'\\<sigma>) \\<Rightarrow> '\\<sigma> \\<Rightarrow> '\\<sigma>\" \n    where\n      \"iam_iterateoi_aux i len a c f \\<sigma> =\n        (if i \\<ge> len \\<or> \\<not> c \\<sigma> then \\<sigma> else let\n            \\<sigma>' = (case array_get a i of \n              None \\<Rightarrow> \\<sigma> \n            | Some x \\<Rightarrow> f (i,x) \\<sigma>)\n          in iam_iterateoi_aux (i + 1) len a c f \\<sigma>')\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>i len a c f \\<sigma>.\n           x = (i, len, a, c, f, \\<sigma>) \\<Longrightarrow>\n           P) \\<Longrightarrow>\n       P\n 2. \\<And>i len a c f \\<sigma> ia lena aa ca fa \\<sigma>'.\n       (i, len, a, c, f, \\<sigma>) =\n       (ia, lena, aa, ca, fa, \\<sigma>') \\<Longrightarrow>\n       (if len \\<le> i \\<or> \\<not> c \\<sigma> then \\<sigma>\n        else let x5 = case array_get a i of None \\<Rightarrow> \\<sigma>\n                      | Some x \\<Rightarrow> f (i, x) \\<sigma>\n             in iam_iterateoi_aux_sumC (i + 1, len, a, c, f, x5)) =\n       (if lena \\<le> ia \\<or> \\<not> ca \\<sigma>' then \\<sigma>'\n        else let x5 = case array_get aa ia of None \\<Rightarrow> \\<sigma>'\n                      | Some x \\<Rightarrow> fa (ia, x) \\<sigma>'\n             in iam_iterateoi_aux_sumC (ia + 1, lena, aa, ca, fa, x5))", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All iam_iterateoi_aux_dom", "by (relation \"measure (\\<lambda>(i,l,_). l - i)\") auto"], ["", "declare iam_iterateoi_aux.simps[simp del]"], ["", "lemma iam_iterateoi_aux_csimps:\n    \"i \\<ge> len \\<Longrightarrow> iam_iterateoi_aux i len a c f \\<sigma> = \\<sigma>\"\n    \"\\<not> c \\<sigma> \\<Longrightarrow> iam_iterateoi_aux i len a c f \\<sigma> = \\<sigma>\"\n    \"\\<lbrakk> i< len; c \\<sigma> \\<rbrakk> \\<Longrightarrow> iam_iterateoi_aux i len a c f \\<sigma> = \n      (case array_get a i of\n        None \\<Rightarrow> iam_iterateoi_aux (i + 1) len a c f \\<sigma>\n      | Some x \\<Rightarrow> iam_iterateoi_aux (i + 1) len a c f (f (i,x) \\<sigma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (len \\<le> i \\<Longrightarrow>\n     iam_iterateoi_aux i len a c f \\<sigma> = \\<sigma>) &&&\n    (\\<not> c \\<sigma> \\<Longrightarrow>\n     iam_iterateoi_aux i len a c f \\<sigma> = \\<sigma>) &&&\n    (\\<lbrakk>i < len; c \\<sigma>\\<rbrakk>\n     \\<Longrightarrow> iam_iterateoi_aux i len a c f \\<sigma> =\n                       (case array_get a i of\n                        None \\<Rightarrow>\n                          iam_iterateoi_aux (i + 1) len a c f \\<sigma>\n                        | Some x \\<Rightarrow>\n                            iam_iterateoi_aux (i + 1) len a c f\n                             (f (i, x) \\<sigma>)))", "apply (subst iam_iterateoi_aux.simps, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<not> c \\<sigma> \\<Longrightarrow>\n    iam_iterateoi_aux i len a c f \\<sigma> = \\<sigma>\n 2. \\<lbrakk>i < len; c \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> iam_iterateoi_aux i len a c f \\<sigma> =\n                      (case array_get a i of\n                       None \\<Rightarrow>\n                         iam_iterateoi_aux (i + 1) len a c f \\<sigma>\n                       | Some x \\<Rightarrow>\n                           iam_iterateoi_aux (i + 1) len a c f\n                            (f (i, x) \\<sigma>))", "apply (subst iam_iterateoi_aux.simps, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < len; c \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> iam_iterateoi_aux i len a c f \\<sigma> =\n                      (case array_get a i of\n                       None \\<Rightarrow>\n                         iam_iterateoi_aux (i + 1) len a c f \\<sigma>\n                       | Some x \\<Rightarrow>\n                           iam_iterateoi_aux (i + 1) len a c f\n                            (f (i, x) \\<sigma>))", "apply (subst iam_iterateoi_aux.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < len; c \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> (if len \\<le> i \\<or> \\<not> c \\<sigma> then \\<sigma>\n                       else Let (case array_get a i of\n                                 None \\<Rightarrow> \\<sigma>\n                                 | Some x \\<Rightarrow> f (i, x) \\<sigma>)\n                             (iam_iterateoi_aux (i + 1) len a c f)) =\n                      (case array_get a i of\n                       None \\<Rightarrow>\n                         iam_iterateoi_aux (i + 1) len a c f \\<sigma>\n                       | Some x \\<Rightarrow>\n                           iam_iterateoi_aux (i + 1) len a c f\n                            (f (i, x) \\<sigma>))", "apply (auto split: option.split_asm option.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition iam_iterateoi :: \"'v iam \\<Rightarrow> (nat \\<times> 'v,'\\<sigma>) set_iterator\" where \n    \"iam_iterateoi a = iam_iterateoi_aux 0 (array_length a) a\""], ["", "lemma iam_empty_impl: \"map_empty iam_\\<alpha> iam_invar iam_empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_empty iam_\\<alpha> (\\<lambda>_. True) iam_empty", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. iam_\\<alpha> (iam_empty ()) = Map.empty\n 2. True", "unfolding iam_\\<alpha>_def[abs_def] iam_empty_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<lambda>i.\n        if i < array_length (array_of_list [])\n        then array_get (array_of_list []) i else None) =\n    Map.empty\n 2. True", "by auto"], ["", "lemma iam_lookup_impl: \"map_lookup iam_\\<alpha> iam_invar iam_lookup\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_lookup iam_\\<alpha> (\\<lambda>_. True) iam_lookup", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m k. True \\<Longrightarrow> iam_lookup k m = iam_\\<alpha> m k", "unfolding iam_\\<alpha>_def[abs_def] iam_lookup_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m k.\n       True \\<Longrightarrow>\n       (if k < array_length m then array_get m k else None) =\n       (if k < array_length m then array_get m k else None)", "by auto"], ["", "lemma array_get_set_iff: \"i<array_length a \\<Longrightarrow> \n    array_get (array_set a i x) j = (if i=j then x else array_get a j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < array_length a \\<Longrightarrow>\n    array_get (array_set a i x) j = (if i = j then x else array_get a j)", "by (auto simp: array_get_array_set_other)"], ["", "lemma iam_update_impl: \"map_update iam_\\<alpha> iam_invar iam_update\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_update iam_\\<alpha> (\\<lambda>_. True) iam_update", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m k v.\n       True \\<Longrightarrow>\n       iam_\\<alpha> (iam_update k v m) = iam_\\<alpha> m(k \\<mapsto> v)\n 2. \\<And>m k v. True \\<Longrightarrow> True", "unfolding iam_\\<alpha>_def[abs_def] iam_update_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m k v.\n       True \\<Longrightarrow>\n       (\\<lambda>i.\n           if i < array_length\n                   (let l = array_length m;\n                        a = if k < l then m\n                            else array_grow m (iam_increment l k) None\n                    in array_set a k (Some v))\n           then array_get\n                 (let l = array_length m;\n                      a = if k < l then m\n                          else array_grow m (iam_increment l k) None\n                  in array_set a k (Some v))\n                 i\n           else None) =\n       (\\<lambda>i. if i < array_length m then array_get m i else None)(k \n       \\<mapsto> v)\n 2. \\<And>m k v. True \\<Longrightarrow> True", "apply (rule ext)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m k v i.\n       True \\<Longrightarrow>\n       (if i < array_length\n                (let l = array_length m;\n                     a = if k < l then m\n                         else array_grow m (iam_increment l k) None\n                 in array_set a k (Some v))\n        then array_get\n              (let l = array_length m;\n                   a = if k < l then m\n                       else array_grow m (iam_increment l k) None\n               in array_set a k (Some v))\n              i\n        else None) =\n       ((\\<lambda>i. if i < array_length m then array_get m i else None)(k \n        \\<mapsto> v))\n        i\n 2. \\<And>m k v. True \\<Longrightarrow> True", "apply (auto simp: Let_def array_get_set_iff incr_correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iam_update_dj_impl: \"map_update_dj iam_\\<alpha> iam_invar iam_update_dj\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_update_dj iam_\\<alpha> (\\<lambda>_. True) iam_update_dj", "apply (unfold iam_update_dj_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_update_dj iam_\\<alpha> (\\<lambda>_. True) iam_update", "apply (rule update_dj_by_update)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_update iam_\\<alpha> (\\<lambda>_. True) iam_update", "apply (rule iam_update_impl)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iam_delete_impl: \"map_delete iam_\\<alpha> iam_invar iam_delete\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_delete iam_\\<alpha> (\\<lambda>_. True) iam_delete", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m k.\n       True \\<Longrightarrow>\n       iam_\\<alpha> (iam_delete k m) = iam_\\<alpha> m |` (- {k})\n 2. \\<And>m k. True \\<Longrightarrow> True", "unfolding iam_\\<alpha>_def[abs_def] iam_delete_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m k.\n       True \\<Longrightarrow>\n       (\\<lambda>i.\n           if i < array_length\n                   (if k < array_length m then array_set m k None else m)\n           then array_get\n                 (if k < array_length m then array_set m k None else m) i\n           else None) =\n       (\\<lambda>i. if i < array_length m then array_get m i else None) |`\n       (- {k})\n 2. \\<And>m k. True \\<Longrightarrow> True", "apply (rule ext)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m k i.\n       True \\<Longrightarrow>\n       (if i < array_length\n                (if k < array_length m then array_set m k None else m)\n        then array_get\n              (if k < array_length m then array_set m k None else m) i\n        else None) =\n       ((\\<lambda>i. if i < array_length m then array_get m i else None) |`\n        (- {k}))\n        i\n 2. \\<And>m k. True \\<Longrightarrow> True", "apply (auto simp: Let_def array_get_set_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iam_rev_iterateoi_aux_foldli_conv :\n    \"iam_rev_iterateoi_aux n a =\n     foldli (List.map_filter (\\<lambda>n. map_option (\\<lambda>v. (n, v)) (array_get a n)) (rev [0..<n]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iam_rev_iterateoi_aux n a =\n    foldli\n     (List.map_filter (\\<lambda>n. map_option (Pair n) (array_get a n))\n       (rev [0..<n]))", "by (induct n) (auto simp add: List.map_filter_def fun_eq_iff)"], ["", "lemma iam_rev_iterateoi_foldli_conv :\n    \"iam_rev_iterateoi a =\n     foldli (List.map_filter \n       (\\<lambda>n. map_option (\\<lambda>v. (n, v)) (array_get a n)) \n       (rev [0..<(array_length a)]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iam_rev_iterateoi a =\n    foldli\n     (List.map_filter (\\<lambda>n. map_option (Pair n) (array_get a n))\n       (rev [0..<array_length a]))", "unfolding iam_rev_iterateoi_def iam_rev_iterateoi_aux_foldli_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli\n     (List.map_filter (\\<lambda>n. map_option (Pair n) (array_get a n))\n       (rev [0..<array_length a])) =\n    foldli\n     (List.map_filter (\\<lambda>n. map_option (Pair n) (array_get a n))\n       (rev [0..<array_length a]))", "by simp"], ["", "lemma iam_rev_iterateoi_correct : \n  fixes m::\"'a option array\"\n  defines \"kvs \\<equiv> List.map_filter \n    (\\<lambda>n. map_option (\\<lambda>v. (n, v)) (array_get m n)) (rev [0..<(array_length m)])\"\n  shows \"map_iterator_rev_linord (iam_rev_iterateoi m) (iam_\\<alpha> m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_iterator_rev_linord (iam_rev_iterateoi m) (iam_\\<alpha> m)", "proof (rule map_iterator_rev_linord_I [of kvs])"], ["proof (state)\ngoal (4 subgoals):\n 1. distinct (map fst kvs)\n 2. iam_\\<alpha> m = map_of kvs\n 3. sorted (rev (map fst kvs))\n 4. iam_rev_iterateoi m = foldli kvs", "show \"iam_rev_iterateoi m = foldli kvs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iam_rev_iterateoi m = foldli kvs", "unfolding iam_rev_iterateoi_foldli_conv kvs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli\n     (List.map_filter (\\<lambda>n. map_option (Pair n) (array_get m n))\n       (rev [0..<array_length m])) =\n    foldli\n     (List.map_filter (\\<lambda>n. map_option (Pair n) (array_get m n))\n       (rev [0..<array_length m]))", "by simp"], ["proof (state)\nthis:\n  iam_rev_iterateoi m = foldli kvs\n\ngoal (3 subgoals):\n 1. distinct (map fst kvs)\n 2. iam_\\<alpha> m = map_of kvs\n 3. sorted (rev (map fst kvs))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. distinct (map fst kvs)\n 2. iam_\\<alpha> m = map_of kvs\n 3. sorted (rev (map fst kvs))", "define al where \"al = array_length m\""], ["proof (state)\nthis:\n  al = array_length m\n\ngoal (3 subgoals):\n 1. distinct (map fst kvs)\n 2. iam_\\<alpha> m = map_of kvs\n 3. sorted (rev (map fst kvs))", "show dist_kvs: \"distinct (map fst kvs)\" and \"sorted (rev (map fst kvs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst kvs) &&& sorted (rev (map fst kvs))", "unfolding kvs_def al_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     (map fst\n       (List.map_filter (\\<lambda>n. map_option (Pair n) (array_get m n))\n         (rev [0..<al]))) &&&\n    sorted\n     (rev (map fst\n            (List.map_filter\n              (\\<lambda>n. map_option (Pair n) (array_get m n))\n              (rev [0..<al]))))", "apply (induct al)"], ["proof (prove)\ngoal (4 subgoals):\n 1. distinct\n     (map fst\n       (List.map_filter (\\<lambda>n. map_option (Pair n) (array_get m n))\n         (rev [0..<0])))\n 2. sorted\n     (rev (map fst\n            (List.map_filter\n              (\\<lambda>n. map_option (Pair n) (array_get m n))\n              (rev [0..<0]))))\n 3. \\<And>al.\n       \\<lbrakk>distinct\n                 (map fst\n                   (List.map_filter\n                     (\\<lambda>n. map_option (Pair n) (array_get m n))\n                     (rev [0..<al])));\n        sorted\n         (rev (map fst\n                (List.map_filter\n                  (\\<lambda>n. map_option (Pair n) (array_get m n))\n                  (rev [0..<al]))))\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map fst\n                            (List.map_filter\n                              (\\<lambda>n.\n                                  map_option (Pair n) (array_get m n))\n                              (rev [0..<Suc al])))\n 4. \\<And>al.\n       \\<lbrakk>distinct\n                 (map fst\n                   (List.map_filter\n                     (\\<lambda>n. map_option (Pair n) (array_get m n))\n                     (rev [0..<al])));\n        sorted\n         (rev (map fst\n                (List.map_filter\n                  (\\<lambda>n. map_option (Pair n) (array_get m n))\n                  (rev [0..<al]))))\\<rbrakk>\n       \\<Longrightarrow> sorted\n                          (rev (map fst\n                                 (List.map_filter\n                                   (\\<lambda>n.\n map_option (Pair n) (array_get m n))\n                                   (rev [0..<Suc al]))))", "apply (simp_all \n        add: List.map_filter_simps set_map_filter image_iff sorted_append\n        split: option.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  distinct (map fst kvs)\n  sorted (rev (map fst kvs))\n\ngoal (1 subgoal):\n 1. iam_\\<alpha> m = map_of kvs", "from dist_kvs"], ["proof (chain)\npicking this:\n  distinct (map fst kvs)", "have \"\\<And>i. map_of kvs i = iam_\\<alpha> m i\""], ["proof (prove)\nusing this:\n  distinct (map fst kvs)\n\ngoal (1 subgoal):\n 1. \\<And>i. map_of kvs i = iam_\\<alpha> m i", "unfolding kvs_def"], ["proof (prove)\nusing this:\n  distinct\n   (map fst\n     (List.map_filter (\\<lambda>n. map_option (Pair n) (array_get m n))\n       (rev [0..<array_length m])))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       map_of\n        (List.map_filter (\\<lambda>n. map_option (Pair n) (array_get m n))\n          (rev [0..<array_length m]))\n        i =\n       iam_\\<alpha> m i", "apply (case_tac \"array_get m i\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>distinct\n                 (map fst\n                   (List.map_filter\n                     (\\<lambda>n. map_option (Pair n) (array_get m n))\n                     (rev [0..<array_length m])));\n        array_get m i = None\\<rbrakk>\n       \\<Longrightarrow> map_of\n                          (List.map_filter\n                            (\\<lambda>n.\n                                map_option (Pair n) (array_get m n))\n                            (rev [0..<array_length m]))\n                          i =\n                         iam_\\<alpha> m i\n 2. \\<And>i a.\n       \\<lbrakk>distinct\n                 (map fst\n                   (List.map_filter\n                     (\\<lambda>n. map_option (Pair n) (array_get m n))\n                     (rev [0..<array_length m])));\n        array_get m i = Some a\\<rbrakk>\n       \\<Longrightarrow> map_of\n                          (List.map_filter\n                            (\\<lambda>n.\n                                map_option (Pair n) (array_get m n))\n                            (rev [0..<array_length m]))\n                          i =\n                         iam_\\<alpha> m i", "apply (simp_all \n        add: iam_\\<alpha>_def map_of_eq_None_iff set_map_filter image_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  map_of kvs ?i = iam_\\<alpha> m ?i\n\ngoal (1 subgoal):\n 1. iam_\\<alpha> m = map_of kvs", "thus \"iam_\\<alpha> m = map_of kvs\""], ["proof (prove)\nusing this:\n  map_of kvs ?i = iam_\\<alpha> m ?i\n\ngoal (1 subgoal):\n 1. iam_\\<alpha> m = map_of kvs", "by auto"], ["proof (state)\nthis:\n  iam_\\<alpha> m = map_of kvs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma iam_rev_iterateoi_impl: \n    \"poly_map_rev_iterateoi iam_\\<alpha> iam_invar iam_rev_iterateoi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_map_rev_iterateoi iam_\\<alpha> (\\<lambda>_. True) iam_rev_iterateoi", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m. True \\<Longrightarrow> finite (dom (iam_\\<alpha> m))\n 2. \\<And>m.\n       True \\<Longrightarrow>\n       map_iterator_rev_linord (iam_rev_iterateoi m) (iam_\\<alpha> m)", "apply (simp add: iam_\\<alpha>_def[abs_def] dom_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m.\n       True \\<Longrightarrow>\n       map_iterator_rev_linord (iam_rev_iterateoi m) (iam_\\<alpha> m)", "apply (simp add: iam_rev_iterateoi_correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iam_iteratei_impl: \n    \"poly_map_iteratei iam_\\<alpha> iam_invar iam_rev_iterateoi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_map_iteratei iam_\\<alpha> (\\<lambda>_. True) iam_rev_iterateoi", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_map_iteratei iam_\\<alpha> (\\<lambda>_. True) iam_rev_iterateoi", "interpret aux: poly_map_rev_iterateoi iam_\\<alpha> iam_invar iam_rev_iterateoi"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_map_rev_iterateoi iam_\\<alpha> (\\<lambda>_. True) iam_rev_iterateoi", "by (rule iam_rev_iterateoi_impl)"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_map_iteratei iam_\\<alpha> (\\<lambda>_. True) iam_rev_iterateoi", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_map_iteratei iam_\\<alpha> (\\<lambda>_. True) iam_rev_iterateoi", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m.\n       True \\<Longrightarrow>\n       map_iterator (iam_rev_iterateoi m) (iam_\\<alpha> m)", "apply (rule map_rev_iterator_linord_is_it)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m.\n       True \\<Longrightarrow>\n       map_iterator_rev_linord (iam_rev_iterateoi m) (iam_\\<alpha> m)", "by (rule aux.list_rev_it_correct)"], ["proof (state)\nthis:\n  poly_map_iteratei iam_\\<alpha> (\\<lambda>_. True) iam_rev_iterateoi\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma iam_iterateoi_aux_foldli_conv :\n    \"iam_iterateoi_aux n (array_length a) a c f \\<sigma> =\n     foldli (List.map_filter (\\<lambda>n. map_option (\\<lambda>v. (n, v)) (array_get a n)) \n       ([n..<array_length a])) c f \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iam_iterateoi_aux n (array_length a) a c f \\<sigma> =\n    foldli\n     (List.map_filter (\\<lambda>n. map_option (Pair n) (array_get a n))\n       [n..<array_length a])\n     c f \\<sigma>", "thm iam_iterateoi_aux.induct"], ["proof (prove)\ngoal (1 subgoal):\n 1. iam_iterateoi_aux n (array_length a) a c f \\<sigma> =\n    foldli\n     (List.map_filter (\\<lambda>n. map_option (Pair n) (array_get a n))\n       [n..<array_length a])\n     c f \\<sigma>", "apply (induct n \"array_length a\" a c f \\<sigma> rule: iam_iterateoi_aux.induct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i a c f \\<sigma>.\n       (\\<And>x.\n           \\<lbrakk>\\<not> (array_length a \\<le> i \\<or> \\<not> c \\<sigma>);\n            x =\n            (case array_get a i of None \\<Rightarrow> \\<sigma>\n             | Some x \\<Rightarrow> f (i, x) \\<sigma>)\\<rbrakk>\n           \\<Longrightarrow> iam_iterateoi_aux (i + 1) (array_length a) a c\n                              f x =\n                             foldli\n                              (List.map_filter\n                                (\\<lambda>n.\n                                    map_option (Pair n) (array_get a n))\n                                [i + 1..<array_length a])\n                              c f x) \\<Longrightarrow>\n       iam_iterateoi_aux i (array_length a) a c f \\<sigma> =\n       foldli\n        (List.map_filter (\\<lambda>n. map_option (Pair n) (array_get a n))\n          [i..<array_length a])\n        c f \\<sigma>", "apply (subst iam_iterateoi_aux.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i a c f \\<sigma>.\n       (\\<And>x.\n           \\<lbrakk>\\<not> (array_length a \\<le> i \\<or> \\<not> c \\<sigma>);\n            x =\n            (case array_get a i of None \\<Rightarrow> \\<sigma>\n             | Some x \\<Rightarrow> f (i, x) \\<sigma>)\\<rbrakk>\n           \\<Longrightarrow> iam_iterateoi_aux (i + 1) (array_length a) a c\n                              f x =\n                             foldli\n                              (List.map_filter\n                                (\\<lambda>n.\n                                    map_option (Pair n) (array_get a n))\n                                [i + 1..<array_length a])\n                              c f x) \\<Longrightarrow>\n       (if array_length a \\<le> i \\<or> \\<not> c \\<sigma> then \\<sigma>\n        else Let (case array_get a i of None \\<Rightarrow> \\<sigma>\n                  | Some x \\<Rightarrow> f (i, x) \\<sigma>)\n              (iam_iterateoi_aux (i + 1) (array_length a) a c f)) =\n       foldli\n        (List.map_filter (\\<lambda>n. map_option (Pair n) (array_get a n))\n          [i..<array_length a])\n        c f \\<sigma>", "apply (auto split: option.split simp: map_filter_simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i a c f \\<sigma>.\n       \\<lbrakk>iam_iterateoi_aux (Suc i) (array_length a) a c f \\<sigma> =\n                foldli\n                 (List.map_filter\n                   (\\<lambda>n. map_option (Pair n) (array_get a n))\n                   [Suc i..<array_length a])\n                 c f \\<sigma>;\n        array_get a i = None; \\<not> array_length a \\<le> i;\n        c \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> foldli\n                          (List.map_filter\n                            (\\<lambda>n.\n                                map_option (Pair n) (array_get a n))\n                            [Suc i..<array_length a])\n                          c f \\<sigma> =\n                         foldli\n                          (List.map_filter\n                            (\\<lambda>n.\n                                map_option (Pair n) (array_get a n))\n                            [i..<array_length a])\n                          c f \\<sigma>\n 2. \\<And>i a c f \\<sigma> x2.\n       \\<lbrakk>iam_iterateoi_aux (Suc i) (array_length a) a c f\n                 (f (i, x2) \\<sigma>) =\n                foldli\n                 (List.map_filter\n                   (\\<lambda>n. map_option (Pair n) (array_get a n))\n                   [Suc i..<array_length a])\n                 c f (f (i, x2) \\<sigma>);\n        array_get a i = Some x2; \\<not> array_length a \\<le> i;\n        c \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> foldli\n                          (List.map_filter\n                            (\\<lambda>n.\n                                map_option (Pair n) (array_get a n))\n                            [Suc i..<array_length a])\n                          c f (f (i, x2) \\<sigma>) =\n                         foldli\n                          (List.map_filter\n                            (\\<lambda>n.\n                                map_option (Pair n) (array_get a n))\n                            [i..<array_length a])\n                          c f \\<sigma>", "apply (subst (2) upt_conv_Cons)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i a c f \\<sigma>.\n       \\<lbrakk>iam_iterateoi_aux (Suc i) (array_length a) a c f \\<sigma> =\n                foldli\n                 (List.map_filter\n                   (\\<lambda>n. map_option (Pair n) (array_get a n))\n                   [Suc i..<array_length a])\n                 c f \\<sigma>;\n        array_get a i = None; \\<not> array_length a \\<le> i;\n        c \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> i < array_length a\n 2. \\<And>i a c f \\<sigma>.\n       \\<lbrakk>iam_iterateoi_aux (Suc i) (array_length a) a c f \\<sigma> =\n                foldli\n                 (List.map_filter\n                   (\\<lambda>n. map_option (Pair n) (array_get a n))\n                   [Suc i..<array_length a])\n                 c f \\<sigma>;\n        array_get a i = None; \\<not> array_length a \\<le> i;\n        c \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> foldli\n                          (List.map_filter\n                            (\\<lambda>n.\n                                map_option (Pair n) (array_get a n))\n                            [Suc i..<array_length a])\n                          c f \\<sigma> =\n                         foldli\n                          (List.map_filter\n                            (\\<lambda>n.\n                                map_option (Pair n) (array_get a n))\n                            (i # [Suc i..<array_length a]))\n                          c f \\<sigma>\n 3. \\<And>i a c f \\<sigma> x2.\n       \\<lbrakk>iam_iterateoi_aux (Suc i) (array_length a) a c f\n                 (f (i, x2) \\<sigma>) =\n                foldli\n                 (List.map_filter\n                   (\\<lambda>n. map_option (Pair n) (array_get a n))\n                   [Suc i..<array_length a])\n                 c f (f (i, x2) \\<sigma>);\n        array_get a i = Some x2; \\<not> array_length a \\<le> i;\n        c \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> foldli\n                          (List.map_filter\n                            (\\<lambda>n.\n                                map_option (Pair n) (array_get a n))\n                            [Suc i..<array_length a])\n                          c f (f (i, x2) \\<sigma>) =\n                         foldli\n                          (List.map_filter\n                            (\\<lambda>n.\n                                map_option (Pair n) (array_get a n))\n                            [i..<array_length a])\n                          c f \\<sigma>", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i a c f \\<sigma>.\n       \\<lbrakk>iam_iterateoi_aux (Suc i) (array_length a) a c f \\<sigma> =\n                foldli\n                 (List.map_filter\n                   (\\<lambda>n. map_option (Pair n) (array_get a n))\n                   [Suc i..<array_length a])\n                 c f \\<sigma>;\n        array_get a i = None; \\<not> array_length a \\<le> i;\n        c \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> foldli\n                          (List.map_filter\n                            (\\<lambda>n.\n                                map_option (Pair n) (array_get a n))\n                            [Suc i..<array_length a])\n                          c f \\<sigma> =\n                         foldli\n                          (List.map_filter\n                            (\\<lambda>n.\n                                map_option (Pair n) (array_get a n))\n                            (i # [Suc i..<array_length a]))\n                          c f \\<sigma>\n 2. \\<And>i a c f \\<sigma> x2.\n       \\<lbrakk>iam_iterateoi_aux (Suc i) (array_length a) a c f\n                 (f (i, x2) \\<sigma>) =\n                foldli\n                 (List.map_filter\n                   (\\<lambda>n. map_option (Pair n) (array_get a n))\n                   [Suc i..<array_length a])\n                 c f (f (i, x2) \\<sigma>);\n        array_get a i = Some x2; \\<not> array_length a \\<le> i;\n        c \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> foldli\n                          (List.map_filter\n                            (\\<lambda>n.\n                                map_option (Pair n) (array_get a n))\n                            [Suc i..<array_length a])\n                          c f (f (i, x2) \\<sigma>) =\n                         foldli\n                          (List.map_filter\n                            (\\<lambda>n.\n                                map_option (Pair n) (array_get a n))\n                            [i..<array_length a])\n                          c f \\<sigma>", "apply (simp add: map_filter_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i a c f \\<sigma> x2.\n       \\<lbrakk>iam_iterateoi_aux (Suc i) (array_length a) a c f\n                 (f (i, x2) \\<sigma>) =\n                foldli\n                 (List.map_filter\n                   (\\<lambda>n. map_option (Pair n) (array_get a n))\n                   [Suc i..<array_length a])\n                 c f (f (i, x2) \\<sigma>);\n        array_get a i = Some x2; \\<not> array_length a \\<le> i;\n        c \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> foldli\n                          (List.map_filter\n                            (\\<lambda>n.\n                                map_option (Pair n) (array_get a n))\n                            [Suc i..<array_length a])\n                          c f (f (i, x2) \\<sigma>) =\n                         foldli\n                          (List.map_filter\n                            (\\<lambda>n.\n                                map_option (Pair n) (array_get a n))\n                            [i..<array_length a])\n                          c f \\<sigma>", "apply (subst (2) upt_conv_Cons)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i a c f \\<sigma> x2.\n       \\<lbrakk>iam_iterateoi_aux (Suc i) (array_length a) a c f\n                 (f (i, x2) \\<sigma>) =\n                foldli\n                 (List.map_filter\n                   (\\<lambda>n. map_option (Pair n) (array_get a n))\n                   [Suc i..<array_length a])\n                 c f (f (i, x2) \\<sigma>);\n        array_get a i = Some x2; \\<not> array_length a \\<le> i;\n        c \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> i < array_length a\n 2. \\<And>i a c f \\<sigma> x2.\n       \\<lbrakk>iam_iterateoi_aux (Suc i) (array_length a) a c f\n                 (f (i, x2) \\<sigma>) =\n                foldli\n                 (List.map_filter\n                   (\\<lambda>n. map_option (Pair n) (array_get a n))\n                   [Suc i..<array_length a])\n                 c f (f (i, x2) \\<sigma>);\n        array_get a i = Some x2; \\<not> array_length a \\<le> i;\n        c \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> foldli\n                          (List.map_filter\n                            (\\<lambda>n.\n                                map_option (Pair n) (array_get a n))\n                            [Suc i..<array_length a])\n                          c f (f (i, x2) \\<sigma>) =\n                         foldli\n                          (List.map_filter\n                            (\\<lambda>n.\n                                map_option (Pair n) (array_get a n))\n                            (i # [Suc i..<array_length a]))\n                          c f \\<sigma>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i a c f \\<sigma> x2.\n       \\<lbrakk>iam_iterateoi_aux (Suc i) (array_length a) a c f\n                 (f (i, x2) \\<sigma>) =\n                foldli\n                 (List.map_filter\n                   (\\<lambda>n. map_option (Pair n) (array_get a n))\n                   [Suc i..<array_length a])\n                 c f (f (i, x2) \\<sigma>);\n        array_get a i = Some x2; \\<not> array_length a \\<le> i;\n        c \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> foldli\n                          (List.map_filter\n                            (\\<lambda>n.\n                                map_option (Pair n) (array_get a n))\n                            [Suc i..<array_length a])\n                          c f (f (i, x2) \\<sigma>) =\n                         foldli\n                          (List.map_filter\n                            (\\<lambda>n.\n                                map_option (Pair n) (array_get a n))\n                            (i # [Suc i..<array_length a]))\n                          c f \\<sigma>", "apply (simp add: map_filter_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma iam_iterateoi_foldli_conv :\n    \"iam_iterateoi a =\n     foldli (List.map_filter \n       (\\<lambda>n. map_option (\\<lambda>v. (n, v)) (array_get a n)) \n       ([0..<(array_length a)]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iam_iterateoi a =\n    foldli\n     (List.map_filter (\\<lambda>n. map_option (Pair n) (array_get a n))\n       [0..<array_length a])", "apply (intro ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       iam_iterateoi a x xa xb =\n       foldli\n        (List.map_filter (\\<lambda>n. map_option (Pair n) (array_get a n))\n          [0..<array_length a])\n        x xa xb", "unfolding iam_iterateoi_def iam_iterateoi_aux_foldli_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       foldli\n        (List.map_filter (\\<lambda>n. map_option (Pair n) (array_get a n))\n          [0..<array_length a])\n        x xa xb =\n       foldli\n        (List.map_filter (\\<lambda>n. map_option (Pair n) (array_get a n))\n          [0..<array_length a])\n        x xa xb", "by simp"], ["", "(* TODO: Move to Misc *)"], ["", "lemmas [simp] = map_filter_simps"], ["", "lemma map_filter_append[simp]: \"List.map_filter f (la@lb) \n    = List.map_filter f la @ List.map_filter f lb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. List.map_filter f (la @ lb) =\n    List.map_filter f la @ List.map_filter f lb", "by (induct la) (auto split: option.split)"], ["", "lemma iam_iterateoi_correct: \n  fixes m::\"'a option array\"\n  defines \"kvs \\<equiv> List.map_filter \n    (\\<lambda>n. map_option (\\<lambda>v. (n, v)) (array_get m n)) ([0..<(array_length m)])\"\n  shows \"map_iterator_linord (iam_iterateoi m) (iam_\\<alpha> m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_iterator_linord (iam_iterateoi m) (iam_\\<alpha> m)", "proof (rule map_iterator_linord_I [of kvs])"], ["proof (state)\ngoal (4 subgoals):\n 1. distinct (map fst kvs)\n 2. iam_\\<alpha> m = map_of kvs\n 3. sorted (map fst kvs)\n 4. iam_iterateoi m = foldli kvs", "show \"iam_iterateoi m = foldli kvs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iam_iterateoi m = foldli kvs", "unfolding iam_iterateoi_foldli_conv kvs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli\n     (List.map_filter (\\<lambda>n. map_option (Pair n) (array_get m n))\n       [0..<array_length m]) =\n    foldli\n     (List.map_filter (\\<lambda>n. map_option (Pair n) (array_get m n))\n       [0..<array_length m])", "by simp"], ["proof (state)\nthis:\n  iam_iterateoi m = foldli kvs\n\ngoal (3 subgoals):\n 1. distinct (map fst kvs)\n 2. iam_\\<alpha> m = map_of kvs\n 3. sorted (map fst kvs)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. distinct (map fst kvs)\n 2. iam_\\<alpha> m = map_of kvs\n 3. sorted (map fst kvs)", "define al where \"al = array_length m\""], ["proof (state)\nthis:\n  al = array_length m\n\ngoal (3 subgoals):\n 1. distinct (map fst kvs)\n 2. iam_\\<alpha> m = map_of kvs\n 3. sorted (map fst kvs)", "show dist_kvs: \"distinct (map fst kvs)\" and \"sorted (map fst kvs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst kvs) &&& sorted (map fst kvs)", "unfolding kvs_def al_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     (map fst\n       (List.map_filter (\\<lambda>n. map_option (Pair n) (array_get m n))\n         [0..<al])) &&&\n    sorted\n     (map fst\n       (List.map_filter (\\<lambda>n. map_option (Pair n) (array_get m n))\n         [0..<al]))", "apply (induct al)"], ["proof (prove)\ngoal (4 subgoals):\n 1. distinct\n     (map fst\n       (List.map_filter (\\<lambda>n. map_option (Pair n) (array_get m n))\n         [0..<0]))\n 2. sorted\n     (map fst\n       (List.map_filter (\\<lambda>n. map_option (Pair n) (array_get m n))\n         [0..<0]))\n 3. \\<And>al.\n       \\<lbrakk>distinct\n                 (map fst\n                   (List.map_filter\n                     (\\<lambda>n. map_option (Pair n) (array_get m n))\n                     [0..<al]));\n        sorted\n         (map fst\n           (List.map_filter\n             (\\<lambda>n. map_option (Pair n) (array_get m n))\n             [0..<al]))\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map fst\n                            (List.map_filter\n                              (\\<lambda>n.\n                                  map_option (Pair n) (array_get m n))\n                              [0..<Suc al]))\n 4. \\<And>al.\n       \\<lbrakk>distinct\n                 (map fst\n                   (List.map_filter\n                     (\\<lambda>n. map_option (Pair n) (array_get m n))\n                     [0..<al]));\n        sorted\n         (map fst\n           (List.map_filter\n             (\\<lambda>n. map_option (Pair n) (array_get m n))\n             [0..<al]))\\<rbrakk>\n       \\<Longrightarrow> sorted\n                          (map fst\n                            (List.map_filter\n                              (\\<lambda>n.\n                                  map_option (Pair n) (array_get m n))\n                              [0..<Suc al]))", "apply (simp_all \n        add: set_map_filter image_iff sorted_append\n        split: option.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  distinct (map fst kvs)\n  sorted (map fst kvs)\n\ngoal (1 subgoal):\n 1. iam_\\<alpha> m = map_of kvs", "from dist_kvs"], ["proof (chain)\npicking this:\n  distinct (map fst kvs)", "have \"\\<And>i. map_of kvs i = iam_\\<alpha> m i\""], ["proof (prove)\nusing this:\n  distinct (map fst kvs)\n\ngoal (1 subgoal):\n 1. \\<And>i. map_of kvs i = iam_\\<alpha> m i", "unfolding kvs_def"], ["proof (prove)\nusing this:\n  distinct\n   (map fst\n     (List.map_filter (\\<lambda>n. map_option (Pair n) (array_get m n))\n       [0..<array_length m]))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       map_of\n        (List.map_filter (\\<lambda>n. map_option (Pair n) (array_get m n))\n          [0..<array_length m])\n        i =\n       iam_\\<alpha> m i", "apply (case_tac \"array_get m i\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>distinct\n                 (map fst\n                   (List.map_filter\n                     (\\<lambda>n. map_option (Pair n) (array_get m n))\n                     [0..<array_length m]));\n        array_get m i = None\\<rbrakk>\n       \\<Longrightarrow> map_of\n                          (List.map_filter\n                            (\\<lambda>n.\n                                map_option (Pair n) (array_get m n))\n                            [0..<array_length m])\n                          i =\n                         iam_\\<alpha> m i\n 2. \\<And>i a.\n       \\<lbrakk>distinct\n                 (map fst\n                   (List.map_filter\n                     (\\<lambda>n. map_option (Pair n) (array_get m n))\n                     [0..<array_length m]));\n        array_get m i = Some a\\<rbrakk>\n       \\<Longrightarrow> map_of\n                          (List.map_filter\n                            (\\<lambda>n.\n                                map_option (Pair n) (array_get m n))\n                            [0..<array_length m])\n                          i =\n                         iam_\\<alpha> m i", "apply (simp_all \n        add: iam_\\<alpha>_def map_of_eq_None_iff set_map_filter image_iff)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  map_of kvs ?i = iam_\\<alpha> m ?i\n\ngoal (1 subgoal):\n 1. iam_\\<alpha> m = map_of kvs", "thus \"iam_\\<alpha> m = map_of kvs\""], ["proof (prove)\nusing this:\n  map_of kvs ?i = iam_\\<alpha> m ?i\n\ngoal (1 subgoal):\n 1. iam_\\<alpha> m = map_of kvs", "by auto"], ["proof (state)\nthis:\n  iam_\\<alpha> m = map_of kvs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma iam_iterateoi_impl: \n    \"poly_map_iterateoi iam_\\<alpha> iam_invar iam_iterateoi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_map_iterateoi iam_\\<alpha> (\\<lambda>_. True) iam_iterateoi", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m. True \\<Longrightarrow> finite (dom (iam_\\<alpha> m))\n 2. \\<And>m.\n       True \\<Longrightarrow>\n       map_iterator_linord (iam_iterateoi m) (iam_\\<alpha> m)", "apply (simp add: iam_\\<alpha>_def[abs_def] dom_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m.\n       True \\<Longrightarrow>\n       map_iterator_linord (iam_iterateoi m) (iam_\\<alpha> m)", "apply (simp add: iam_iterateoi_correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition iam_basic_ops :: \"(nat,'a,'a iam) omap_basic_ops\"\n    where [icf_rec_def]: \"iam_basic_ops \\<equiv> \\<lparr>\n    bmap_op_\\<alpha> = iam_\\<alpha>,\n    bmap_op_invar = \\<lambda>_. True,\n    bmap_op_empty = iam_empty,\n    bmap_op_lookup = iam_lookup,\n    bmap_op_update = iam_update,\n    bmap_op_update_dj = iam_update_dj,\n    bmap_op_delete = iam_delete,\n    bmap_op_list_it = iam_rev_iterateoi,\n    bmap_op_ordered_list_it = iam_iterateoi,\n    bmap_op_rev_list_it = iam_rev_iterateoi\n    \\<rparr>\""], ["", "setup Locale_Code.open_block"], ["", "interpretation iam_basic: StdBasicOMap iam_basic_ops"], ["proof (prove)\ngoal (1 subgoal):\n 1. StdBasicOMap iam_basic_ops", "apply (rule StdBasicOMap.intro)"], ["proof (prove)\ngoal (3 subgoals):\n 1. StdBasicMap iam_basic_ops\n 2. poly_map_iterateoi (bmap_op_\\<alpha> iam_basic_ops)\n     (bmap_op_invar iam_basic_ops) (bmap_op_ordered_list_it iam_basic_ops)\n 3. poly_map_rev_iterateoi (bmap_op_\\<alpha> iam_basic_ops)\n     (bmap_op_invar iam_basic_ops) (bmap_op_rev_list_it iam_basic_ops)", "apply (rule StdBasicMap.intro)"], ["proof (prove)\ngoal (8 subgoals):\n 1. map_empty (bmap_op_\\<alpha> iam_basic_ops) (bmap_op_invar iam_basic_ops)\n     (bmap_op_empty iam_basic_ops)\n 2. map_lookup (bmap_op_\\<alpha> iam_basic_ops)\n     (bmap_op_invar iam_basic_ops) (bmap_op_lookup iam_basic_ops)\n 3. map_update (bmap_op_\\<alpha> iam_basic_ops)\n     (bmap_op_invar iam_basic_ops) (bmap_op_update iam_basic_ops)\n 4. map_update_dj (bmap_op_\\<alpha> iam_basic_ops)\n     (bmap_op_invar iam_basic_ops) (bmap_op_update_dj iam_basic_ops)\n 5. map_delete (bmap_op_\\<alpha> iam_basic_ops)\n     (bmap_op_invar iam_basic_ops) (bmap_op_delete iam_basic_ops)\n 6. poly_map_iteratei (bmap_op_\\<alpha> iam_basic_ops)\n     (bmap_op_invar iam_basic_ops) (bmap_op_list_it iam_basic_ops)\n 7. poly_map_iterateoi (bmap_op_\\<alpha> iam_basic_ops)\n     (bmap_op_invar iam_basic_ops) (bmap_op_ordered_list_it iam_basic_ops)\n 8. poly_map_rev_iterateoi (bmap_op_\\<alpha> iam_basic_ops)\n     (bmap_op_invar iam_basic_ops) (bmap_op_rev_list_it iam_basic_ops)", "apply (simp_all add: icf_rec_unf)"], ["proof (prove)\ngoal (8 subgoals):\n 1. map_empty iam_\\<alpha> (\\<lambda>_. True) iam_empty\n 2. map_lookup iam_\\<alpha> (\\<lambda>_. True) iam_lookup\n 3. map_update iam_\\<alpha> (\\<lambda>_. True) iam_update\n 4. map_update_dj iam_\\<alpha> (\\<lambda>_. True) iam_update_dj\n 5. map_delete iam_\\<alpha> (\\<lambda>_. True) iam_delete\n 6. poly_map_iteratei iam_\\<alpha> (\\<lambda>_. True) iam_rev_iterateoi\n 7. poly_map_iterateoi iam_\\<alpha> (\\<lambda>_. True) iam_iterateoi\n 8. poly_map_rev_iterateoi iam_\\<alpha> (\\<lambda>_. True) iam_rev_iterateoi", "apply (rule iam_empty_impl iam_lookup_impl iam_update_impl\n      iam_update_dj_impl iam_delete_impl iam_iteratei_impl\n      iam_iterateoi_impl iam_rev_iterateoi_impl)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "setup Locale_Code.close_block"], ["", "definition [icf_rec_def]: \"iam_ops \\<equiv> iam_basic.dflt_oops\""], ["", "setup Locale_Code.open_block"], ["", "interpretation iam: StdOMap iam_ops"], ["proof (prove)\ngoal (1 subgoal):\n 1. StdOMap iam_ops", "unfolding iam_ops_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. StdOMap iam_basic.dflt_oops", "by (rule iam_basic.dflt_oops_impl)"], ["", "interpretation iam: StdMap_no_invar iam_ops"], ["proof (prove)\ngoal (1 subgoal):\n 1. StdMap_no_invar iam_ops", "by unfold_locales (simp add: icf_rec_unf)"], ["", "setup Locale_Code.close_block"], ["", "setup \\<open>ICF_Tools.revert_abbrevs \"iam\"\\<close>"], ["", "lemma pi_iam[proper_it]: \n    \"proper_it' iam_iterateoi iam_iterateoi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it' iam_iterateoi iam_iterateoi", "apply (rule proper_it'I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s. proper_it (iam_iterateoi s) (iam_iterateoi s)", "unfolding iam_iterateoi_foldli_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       proper_it\n        (foldli\n          (List.map_filter (\\<lambda>n. map_option (Pair n) (array_get s n))\n            [0..<array_length s]))\n        (foldli\n          (List.map_filter (\\<lambda>n. map_option (Pair n) (array_get s n))\n            [0..<array_length s]))", "by (rule icf_proper_iteratorI)"], ["", "lemma pi_iam_rev[proper_it]: \n    \"proper_it' iam_rev_iterateoi iam_rev_iterateoi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it' iam_rev_iterateoi iam_rev_iterateoi", "apply (rule proper_it'I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s. proper_it (iam_rev_iterateoi s) (iam_rev_iterateoi s)", "unfolding iam_rev_iterateoi_foldli_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       proper_it\n        (foldli\n          (List.map_filter (\\<lambda>n. map_option (Pair n) (array_get s n))\n            (rev [0..<array_length s])))\n        (foldli\n          (List.map_filter (\\<lambda>n. map_option (Pair n) (array_get s n))\n            (rev [0..<array_length s])))", "by (rule icf_proper_iteratorI)"], ["", "interpretation pi_iam: proper_it_loc iam_iterateoi iam_iterateoi"], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it_loc iam_iterateoi iam_iterateoi", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it' iam_iterateoi iam_iterateoi", "by (rule pi_iam)"], ["", "interpretation pi_iam_rev: proper_it_loc iam_rev_iterateoi iam_rev_iterateoi"], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it_loc iam_rev_iterateoi iam_rev_iterateoi", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it' iam_rev_iterateoi iam_rev_iterateoi", "by (rule pi_iam_rev)"], ["", "text \\<open>Code generator test\\<close>"], ["", "definition \"test_codegen \\<equiv> (\n  iam.add ,\n  iam.add_dj ,\n  iam.ball ,\n  iam.bex ,\n  iam.delete ,\n  iam.empty ,\n  iam.isEmpty ,\n  iam.isSng ,\n  iam.iterate ,\n  iam.iteratei ,\n  iam.iterateo ,\n  iam.iterateoi ,\n  iam.list_it ,\n  iam.lookup ,\n  iam.max ,\n  iam.min ,\n  iam.restrict ,\n  iam.rev_iterateo ,\n  iam.rev_iterateoi ,\n  iam.rev_list_it ,\n  iam.reverse_iterateo ,\n  iam.reverse_iterateoi ,\n  iam.sel ,\n  iam.size ,\n  iam.size_abort ,\n  iam.sng ,\n  iam.to_list ,\n  iam.to_map ,\n  iam.to_rev_list ,\n  iam.to_sorted_list ,\n  iam.update ,\n  iam.update_dj)\""], ["", "export_code test_codegen checking SML"], ["", "end"]]}