{"file_name": "/home/qj213/afp-2021-10-22/thys/Collections/ICF/impl/FTAnnotatedListImpl.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Collections", "problem_names": ["lemmas ft_defs =\n  ft_\\<alpha>_def\n  ft_empty_def\n  ft_isEmpty_def\n  ft_count_def\n  ft_consl_def\n  ft_consr_def\n  ft_head_def\n  ft_tail_def\n  ft_headR_def\n  ft_tailR_def\n  ft_foldl_def\n  ft_foldr_def\n  ft_app_def\n  ft_annot_def\n  ft_splits_def", "lemma ft_empty_impl: \"al_empty ft_\\<alpha> ft_invar ft_empty\"", "lemma ft_consl_impl: \"al_consl ft_\\<alpha> ft_invar ft_consl\"", "lemma ft_consr_impl: \"al_consr ft_\\<alpha> ft_invar ft_consr\"", "lemma ft_isEmpty_impl: \"al_isEmpty ft_\\<alpha> ft_invar ft_isEmpty\"", "lemma ft_count_impl: \"al_count ft_\\<alpha> ft_invar ft_count\"", "lemma ft_head_impl: \"al_head ft_\\<alpha> ft_invar ft_head\"", "lemma ft_tail_impl: \"al_tail ft_\\<alpha> ft_invar ft_tail\"", "lemma ft_headR_impl: \"al_headR ft_\\<alpha> ft_invar ft_headR\"", "lemma ft_tailR_impl: \"al_tailR ft_\\<alpha> ft_invar ft_tailR\"", "lemma ft_foldl_impl: \"al_foldl ft_\\<alpha> ft_invar ft_foldl\"", "lemma ft_foldr_impl: \"al_foldr ft_\\<alpha> ft_invar ft_foldr\"", "lemma ft_foldl_cunfold[code_unfold]:\n  \"List.foldl f \\<sigma> (ft_\\<alpha> t) = ft_foldl f \\<sigma> t\"", "lemma ft_foldr_cunfold[code_unfold]:\n  \"List.foldr f (ft_\\<alpha> t) \\<sigma> = ft_foldr f t \\<sigma>\"", "lemma ft_app_impl: \"al_app ft_\\<alpha> ft_invar ft_app\"", "lemma ft_annot_impl: \"al_annot ft_\\<alpha> ft_invar ft_annot\"", "lemma ft_splits_impl: \"al_splits ft_\\<alpha> ft_invar ft_splits\""], "translations": [["", "lemmas ft_defs =\n  ft_\\<alpha>_def\n  ft_empty_def\n  ft_isEmpty_def\n  ft_count_def\n  ft_consl_def\n  ft_consr_def\n  ft_head_def\n  ft_tail_def\n  ft_headR_def\n  ft_tailR_def\n  ft_foldl_def\n  ft_foldr_def\n  ft_app_def\n  ft_annot_def\n  ft_splits_def"], ["", "lemma ft_empty_impl: \"al_empty ft_\\<alpha> ft_invar ft_empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. al_empty ft_\\<alpha> (\\<lambda>_. True) ft_empty", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. True\n 2. ft_\\<alpha> (ft_empty ()) = []", "apply (auto simp add: ft_defs FingerTree.empty_correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ft_consl_impl: \"al_consl ft_\\<alpha> ft_invar ft_consl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. al_consl ft_\\<alpha> (\\<lambda>_. True) ft_consl", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s e a. True \\<Longrightarrow> True\n 2. \\<And>s e a.\n       True \\<Longrightarrow>\n       ft_\\<alpha> (ft_consl e a s) = (e, a) # ft_\\<alpha> s", "apply (auto simp add: ft_defs FingerTree.lcons_correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ft_consr_impl: \"al_consr ft_\\<alpha> ft_invar ft_consr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. al_consr ft_\\<alpha> (\\<lambda>_. True) ft_consr", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s e a. True \\<Longrightarrow> True\n 2. \\<And>s e a.\n       True \\<Longrightarrow>\n       ft_\\<alpha> (ft_consr s e a) = ft_\\<alpha> s @ [(e, a)]", "apply (auto simp add: ft_defs FingerTree.rcons_correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ft_isEmpty_impl: \"al_isEmpty ft_\\<alpha> ft_invar ft_isEmpty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. al_isEmpty ft_\\<alpha> (\\<lambda>_. True) ft_isEmpty", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s. True \\<Longrightarrow> ft_isEmpty s = (ft_\\<alpha> s = [])", "apply (auto simp add: ft_defs FingerTree.isEmpty_correct FingerTree.empty_correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ft_count_impl: \"al_count ft_\\<alpha> ft_invar ft_count\""], ["proof (prove)\ngoal (1 subgoal):\n 1. al_count ft_\\<alpha> (\\<lambda>_. True) ft_count", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s. True \\<Longrightarrow> ft_count s = length (ft_\\<alpha> s)", "apply (auto simp add: ft_defs FingerTree.count_correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ft_head_impl: \"al_head ft_\\<alpha> ft_invar ft_head\""], ["proof (prove)\ngoal (1 subgoal):\n 1. al_head ft_\\<alpha> (\\<lambda>_. True) ft_head", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>True; ft_\\<alpha> s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> ft_head s = hd (ft_\\<alpha> s)", "apply (auto simp add: ft_defs FingerTree.head_correct FingerTree.empty_correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ft_tail_impl: \"al_tail ft_\\<alpha> ft_invar ft_tail\""], ["proof (prove)\ngoal (1 subgoal):\n 1. al_tail ft_\\<alpha> (\\<lambda>_. True) ft_tail", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>True; ft_\\<alpha> s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> ft_\\<alpha> (ft_tail s) = tl (ft_\\<alpha> s)\n 2. \\<And>s.\n       \\<lbrakk>True; ft_\\<alpha> s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> True", "apply (auto simp add: ft_defs FingerTree.tail_correct FingerTree.empty_correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ft_headR_impl: \"al_headR ft_\\<alpha> ft_invar ft_headR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. al_headR ft_\\<alpha> (\\<lambda>_. True) ft_headR", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>True; ft_\\<alpha> s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> ft_headR s = last (ft_\\<alpha> s)", "apply (auto simp add: ft_defs FingerTree.headR_correct FingerTree.empty_correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ft_tailR_impl: \"al_tailR ft_\\<alpha> ft_invar ft_tailR\""], ["proof (prove)\ngoal (1 subgoal):\n 1. al_tailR ft_\\<alpha> (\\<lambda>_. True) ft_tailR", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>True; ft_\\<alpha> s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> ft_\\<alpha> (ft_tailR s) = butlast (ft_\\<alpha> s)\n 2. \\<And>s.\n       \\<lbrakk>True; ft_\\<alpha> s \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> True", "apply (auto simp add: ft_defs FingerTree.tailR_correct FingerTree.empty_correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ft_foldl_impl: \"al_foldl ft_\\<alpha> ft_invar ft_foldl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. al_foldl ft_\\<alpha> (\\<lambda>_. True) ft_foldl", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s f \\<sigma>.\n       True \\<Longrightarrow>\n       ft_foldl f \\<sigma> s = foldl f \\<sigma> (ft_\\<alpha> s)", "apply (auto simp add: ft_defs FingerTree.foldl_correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ft_foldr_impl: \"al_foldr ft_\\<alpha> ft_invar ft_foldr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. al_foldr ft_\\<alpha> (\\<lambda>_. True) ft_foldr", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s f \\<sigma>.\n       True \\<Longrightarrow>\n       ft_foldr f s \\<sigma> = foldr f (ft_\\<alpha> s) \\<sigma>", "apply (auto simp add: ft_defs FingerTree.foldr_correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ft_foldl_cunfold[code_unfold]:\n  \"List.foldl f \\<sigma> (ft_\\<alpha> t) = ft_foldl f \\<sigma> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl f \\<sigma> (ft_\\<alpha> t) = ft_foldl f \\<sigma> t", "apply (auto simp add: ft_defs FingerTree.foldl_correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ft_foldr_cunfold[code_unfold]:\n  \"List.foldr f (ft_\\<alpha> t) \\<sigma> = ft_foldr f t \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr f (ft_\\<alpha> t) \\<sigma> = ft_foldr f t \\<sigma>", "apply (auto simp add: ft_defs FingerTree.foldr_correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ft_app_impl: \"al_app ft_\\<alpha> ft_invar ft_app\""], ["proof (prove)\ngoal (1 subgoal):\n 1. al_app ft_\\<alpha> (\\<lambda>_. True) ft_app", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s'.\n       \\<lbrakk>True; True\\<rbrakk>\n       \\<Longrightarrow> ft_\\<alpha> (ft_app s s') =\n                         ft_\\<alpha> s @ ft_\\<alpha> s'\n 2. \\<And>s s'. \\<lbrakk>True; True\\<rbrakk> \\<Longrightarrow> True", "apply (auto simp add: ft_defs FingerTree.app_correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ft_annot_impl: \"al_annot ft_\\<alpha> ft_invar ft_annot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. al_annot ft_\\<alpha> (\\<lambda>_. True) ft_annot", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       True \\<Longrightarrow>\n       ft_annot s = sum_list (map snd (ft_\\<alpha> s))", "apply (auto simp add: ft_defs FingerTree.annot_correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma ft_splits_impl: \"al_splits ft_\\<alpha> ft_invar ft_splits\""], ["proof (prove)\ngoal (1 subgoal):\n 1. al_splits ft_\\<alpha> (\\<lambda>_. True) ft_splits", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s p i l e a r.\n       \\<lbrakk>True; \\<forall>a b. p a \\<longrightarrow> p (a + b);\n        \\<not> p i; p (i + sum_list (map snd (ft_\\<alpha> s)));\n        ft_splits p i s = (l, (e, a), r)\\<rbrakk>\n       \\<Longrightarrow> ft_\\<alpha> s =\n                         ft_\\<alpha> l @ (e, a) # ft_\\<alpha> r \\<and>\n                         \\<not> p (i +\n                                   sum_list\n                                    (map snd (ft_\\<alpha> l))) \\<and>\n                         p (i + sum_list (map snd (ft_\\<alpha> l)) +\n                            a) \\<and>\n                         True \\<and> True", "apply (unfold ft_defs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s p i l e a r.\n       \\<lbrakk>True; \\<forall>a b. p a \\<longrightarrow> p (a + b);\n        \\<not> p i; p (i + sum_list (map snd (FingerTree.toList s)));\n        FingerTree.splitTree p i s = (l, (e, a), r)\\<rbrakk>\n       \\<Longrightarrow> FingerTree.toList s =\n                         FingerTree.toList l @\n                         (e, a) # FingerTree.toList r \\<and>\n                         \\<not> p (i +\n                                   sum_list\n                                    (map snd (FingerTree.toList l))) \\<and>\n                         p (i + sum_list (map snd (FingerTree.toList l)) +\n                            a) \\<and>\n                         True \\<and> True", "apply (simp only: FingerTree.annot_correct[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s p i l e a r.\n       \\<lbrakk>True; \\<forall>a b. p a \\<longrightarrow> p (a + b);\n        \\<not> p i; p (i + FingerTree.annot s);\n        FingerTree.splitTree p i s = (l, (e, a), r)\\<rbrakk>\n       \\<Longrightarrow> FingerTree.toList s =\n                         FingerTree.toList l @\n                         (e, a) # FingerTree.toList r \\<and>\n                         \\<not> p (i + FingerTree.annot l) \\<and>\n                         p (i + FingerTree.annot l + a) \\<and>\n                         True \\<and> True", "apply (frule (3) FingerTree.splitTree_correct(1))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s p i l e a r.\n       \\<lbrakk>True; \\<forall>a b. p a \\<longrightarrow> p (a + b);\n        \\<not> p i; p (i + FingerTree.annot s);\n        FingerTree.splitTree p i s = (l, (e, a), r);\n        FingerTree.toList s =\n        FingerTree.toList l @ (e, a) # FingerTree.toList r\\<rbrakk>\n       \\<Longrightarrow> FingerTree.toList s =\n                         FingerTree.toList l @\n                         (e, a) # FingerTree.toList r \\<and>\n                         \\<not> p (i + FingerTree.annot l) \\<and>\n                         p (i + FingerTree.annot l + a) \\<and>\n                         True \\<and> True", "apply (frule (3) FingerTree.splitTree_correct(2))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s p i l e a r.\n       \\<lbrakk>True; \\<forall>a b. p a \\<longrightarrow> p (a + b);\n        \\<not> p i; p (i + FingerTree.annot s);\n        FingerTree.splitTree p i s = (l, (e, a), r);\n        FingerTree.toList s =\n        FingerTree.toList l @ (e, a) # FingerTree.toList r;\n        \\<not> p (i + FingerTree.annot l)\\<rbrakk>\n       \\<Longrightarrow> FingerTree.toList s =\n                         FingerTree.toList l @\n                         (e, a) # FingerTree.toList r \\<and>\n                         \\<not> p (i + FingerTree.annot l) \\<and>\n                         p (i + FingerTree.annot l + a) \\<and>\n                         True \\<and> True", "apply (frule (3) FingerTree.splitTree_correct(3))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s p i l e a r.\n       \\<lbrakk>True; \\<forall>a b. p a \\<longrightarrow> p (a + b);\n        \\<not> p i; p (i + FingerTree.annot s);\n        FingerTree.splitTree p i s = (l, (e, a), r);\n        FingerTree.toList s =\n        FingerTree.toList l @ (e, a) # FingerTree.toList r;\n        \\<not> p (i + FingerTree.annot l);\n        p (i + FingerTree.annot l + a)\\<rbrakk>\n       \\<Longrightarrow> FingerTree.toList s =\n                         FingerTree.toList l @\n                         (e, a) # FingerTree.toList r \\<and>\n                         \\<not> p (i + FingerTree.annot l) \\<and>\n                         p (i + FingerTree.annot l + a) \\<and>\n                         True \\<and> True", "apply (simp only: FingerTree.annot_correct[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s p i l e a r.\n       \\<lbrakk>True; \\<forall>a b. p a \\<longrightarrow> p (a + b);\n        \\<not> p i; p (i + FingerTree.annot s);\n        FingerTree.splitTree p i s = (l, (e, a), r);\n        FingerTree.toList s =\n        FingerTree.toList l @ (e, a) # FingerTree.toList r;\n        \\<not> p (i + FingerTree.annot l);\n        p (i + FingerTree.annot l + a)\\<rbrakk>\n       \\<Longrightarrow> FingerTree.toList l @\n                         (e, a) # FingerTree.toList r =\n                         FingerTree.toList l @\n                         (e, a) # FingerTree.toList r \\<and>\n                         \\<not> False \\<and> True \\<and> True \\<and> True", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \"Record Based Implementation\""], ["", "definition [icf_rec_def]: \"ft_ops = \\<lparr>\n  alist_op_\\<alpha> = ft_\\<alpha>,\n  alist_op_invar = ft_invar,\n  alist_op_empty = ft_empty,\n  alist_op_isEmpty = ft_isEmpty,\n  alist_op_count = ft_count,\n  alist_op_consl = ft_consl,\n  alist_op_consr = ft_consr,\n  alist_op_head = ft_head,\n  alist_op_tail = ft_tail,\n  alist_op_headR = ft_headR,\n  alist_op_tailR = ft_tailR,\n  alist_op_app = ft_app,\n  alist_op_annot = ft_annot,\n  alist_op_splits = ft_splits\n  \\<rparr>\""], ["", "setup Locale_Code.open_block"], ["", "interpretation ft: StdAL ft_ops"], ["proof (prove)\ngoal (1 subgoal):\n 1. StdAL ft_ops", "apply (rule StdAL.intro)"], ["proof (prove)\ngoal (12 subgoals):\n 1. al_empty (alist_op_\\<alpha> ft_ops) (alist_op_invar ft_ops)\n     (alist_op_empty ft_ops)\n 2. al_isEmpty (alist_op_\\<alpha> ft_ops) (alist_op_invar ft_ops)\n     (alist_op_isEmpty ft_ops)\n 3. al_count (alist_op_\\<alpha> ft_ops) (alist_op_invar ft_ops)\n     (alist_op_count ft_ops)\n 4. al_consl (alist_op_\\<alpha> ft_ops) (alist_op_invar ft_ops)\n     (alist_op_consl ft_ops)\n 5. al_consr (alist_op_\\<alpha> ft_ops) (alist_op_invar ft_ops)\n     (alist_op_consr ft_ops)\n 6. al_head (alist_op_\\<alpha> ft_ops) (alist_op_invar ft_ops)\n     (alist_op_head ft_ops)\n 7. al_tail (alist_op_\\<alpha> ft_ops) (alist_op_invar ft_ops)\n     (alist_op_tail ft_ops)\n 8. al_headR (alist_op_\\<alpha> ft_ops) (alist_op_invar ft_ops)\n     (alist_op_headR ft_ops)\n 9. al_tailR (alist_op_\\<alpha> ft_ops) (alist_op_invar ft_ops)\n     (alist_op_tailR ft_ops)\n 10. al_app (alist_op_\\<alpha> ft_ops) (alist_op_invar ft_ops)\n      (alist_op_app ft_ops)\nA total of 12 subgoals...", "apply (simp_all add: icf_rec_unf)"], ["proof (prove)\ngoal (12 subgoals):\n 1. al_empty ft_\\<alpha> (\\<lambda>_. True) ft_empty\n 2. al_isEmpty ft_\\<alpha> (\\<lambda>_. True) ft_isEmpty\n 3. al_count ft_\\<alpha> (\\<lambda>_. True) ft_count\n 4. al_consl ft_\\<alpha> (\\<lambda>_. True) ft_consl\n 5. al_consr ft_\\<alpha> (\\<lambda>_. True) ft_consr\n 6. al_head ft_\\<alpha> (\\<lambda>_. True) ft_head\n 7. al_tail ft_\\<alpha> (\\<lambda>_. True) ft_tail\n 8. al_headR ft_\\<alpha> (\\<lambda>_. True) ft_headR\n 9. al_tailR ft_\\<alpha> (\\<lambda>_. True) ft_tailR\n 10. al_app ft_\\<alpha> (\\<lambda>_. True) ft_app\nA total of 12 subgoals...", "apply (rule \n    ft_empty_impl\n    ft_consl_impl\n    ft_consr_impl\n    ft_isEmpty_impl\n    ft_count_impl\n    ft_head_impl\n    ft_tail_impl\n    ft_headR_impl\n    ft_tailR_impl\n    ft_foldl_impl\n    ft_foldr_impl\n    ft_app_impl\n    ft_annot_impl\n    ft_splits_impl\n  )+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "interpretation ft: StdAL_no_invar ft_ops"], ["proof (prove)\ngoal (1 subgoal):\n 1. StdAL_no_invar ft_ops", "by (unfold_locales) (simp add: icf_rec_unf)"], ["", "setup Locale_Code.close_block"], ["", "setup \\<open>ICF_Tools.revert_abbrevs \"ft\"\\<close>"], ["", "definition \"test_codegen \\<equiv> (\n  ft.empty,\n  ft.isEmpty,\n  ft.count,\n  ft.consl,\n  ft.consr,\n  ft.head,\n  ft.tail,\n  ft.headR,\n  ft.tailR,\n  ft.app,\n  ft.annot,\n  ft.splits,\n  ft.foldl,\n  ft.foldr\n)\""], ["", "export_code test_codegen checking SML"], ["", "end"]]}