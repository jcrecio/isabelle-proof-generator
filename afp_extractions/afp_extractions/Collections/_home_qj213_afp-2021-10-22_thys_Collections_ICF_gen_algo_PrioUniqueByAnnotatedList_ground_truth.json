{"file_name": "/home/qj213/afp-2021-10-22/thys/Collections/ICF/gen_algo/PrioUniqueByAnnotatedList.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Collections", "problem_names": ["lemma p_min_re_neut[simp]: \"p_min a Infty = a\"", "lemma p_min_le_neut[simp]: \"p_min Infty a = a\"", "lemma p_min_asso: \"p_min (p_min a b) c = p_min a (p_min b c)\"", "lemma lp_mono: \"class.monoid_add p_min Infty\"", "lemma p_less_le_not_le : \"p_less x y \\<longleftrightarrow> p_less_eq x y \\<and> \\<not> (p_less_eq y x)\"", "lemma p_order_refl : \"p_less_eq x x\"", "lemma p_le_inf : \"p_less_eq Infty x \\<Longrightarrow> x = Infty\"", "lemma p_order_trans : \"\\<lbrakk>p_less_eq x y; p_less_eq y z\\<rbrakk> \\<Longrightarrow> p_less_eq x z\"", "lemma p_linear2 : \"p_less_eq x y \\<or> p_less_eq y x\"", "lemmas aluprio_defs =\naluprio_invar_def\naluprio_\\<alpha>_def\naluprio_empty_def\naluprio_isEmpty_def\naluprio_insert_def\naluprio_pop_def\naluprio_prio_def", "lemma p_linear: \"(x::('e, 'a::linorder) LP) \\<le> y \\<or> y \\<le> x\"", "lemma e_less_eq_mon1: \"e_less_eq e x \\<Longrightarrow> e_less_eq e (x + y)\"", "lemma e_less_eq_mon2: \"e_less_eq e y \\<Longrightarrow> e_less_eq e (x + y)\"", "lemmas e_less_eq_mon = \n  e_less_eq_mon1\n  e_less_eq_mon2", "lemma p_less_eq_mon:\n  \"(x::('e::linorder,'a::linorder) LP) \\<le> z \\<Longrightarrow> (x + y) \\<le> z\"", "lemma p_less_eq_lem1:\n  \"\\<lbrakk>\\<not> (x::('e::linorder,'a::linorder) LP) \\<le> z;\n  (x + y) \\<le> z\\<rbrakk>\n  \\<Longrightarrow> y \\<le> z \"", "lemma infadd: \"x \\<noteq> Infty \\<Longrightarrow>x + y \\<noteq> Infty\"", "lemma e_less_eq_sum_list: \n  \"\\<lbrakk>\\<not> e_less_eq e (sum_list xs)\\<rbrakk> \\<Longrightarrow> \\<forall>x \\<in> set xs. \\<not> e_less_eq e x\"", "lemma e_less_eq_p_unwrap: \n  \"\\<lbrakk>x \\<noteq> Infty;\\<not> e_less_eq e x\\<rbrakk> \\<Longrightarrow> fst (p_unwrap x) < e\"", "lemma e_less_eq_refl :\n  \"b \\<noteq> Infty \\<Longrightarrow> e_less_eq (fst (p_unwrap b)) b\"", "lemma e_less_eq_sum_list2:\n  assumes \n  \"\\<forall>x\\<in>set (\\<alpha>s). snd x \\<noteq> Infty\"\n  \"((), b) \\<in> set (\\<alpha>s)\"\n  shows \"e_less_eq (fst (p_unwrap b)) (sum_list (map snd (\\<alpha>s)))\"", "lemma e_less_eq_lem1:\n  \"\\<lbrakk>\\<not> e_less_eq e a;e_less_eq e (a + b)\\<rbrakk> \\<Longrightarrow> e_less_eq e b\"", "lemma p_unwrap_less_sum: \"snd (p_unwrap ((LP e aa) + b)) \\<le> aa\"", "lemma  sum_list_less_elems: \"\\<forall>x\\<in>set xs. snd x \\<noteq> Infty \\<Longrightarrow>\n  \\<forall>y\\<in>set (map snd (map p_unwrap (map snd xs))).\n              snd (p_unwrap (sum_list (map snd xs))) \\<le> y\"", "lemma distinct_sortet_list_app:\n  \"\\<lbrakk>sorted xs; distinct xs; xs = as @ b # cs\\<rbrakk>\n  \\<Longrightarrow> \\<forall> x\\<in> set cs. b < x\"", "lemma distinct_sorted_list_lem1:\n  assumes \n  \"sorted xs\"\n  \"sorted ys\"\n  \"distinct xs\"\n  \"distinct ys\"\n  \" \\<forall> x \\<in> set xs. x < e\"\n  \" \\<forall> y \\<in> set ys. e < y\"\n  shows \n  \"sorted (xs @ e # ys)\"\n  \"distinct (xs @ e # ys)\"", "lemma distinct_sorted_list_lem2:\n  assumes \n  \"sorted xs\"\n  \"sorted ys\"\n  \"distinct xs\"\n  \"distinct ys\"\n  \"e < e'\"  \n  \" \\<forall> x \\<in> set xs. x < e\"\n  \" \\<forall> y \\<in> set ys. e' < y\"\n  shows \n  \"sorted (xs @ e # e' # ys)\"\n  \"distinct (xs @ e # e' # ys)\"", "lemma map_of_distinct_upd:\n  \"x \\<notin> set (map fst xs) \\<Longrightarrow> [x \\<mapsto> y] ++ map_of xs = (map_of xs) (x \\<mapsto> y)\"", "lemma map_of_distinct_upd2:\n  assumes \"x \\<notin> set(map fst xs)\"\n  \"x \\<notin> set (map fst ys)\"\n  shows \"map_of (xs @ (x,y) # ys) = (map_of (xs @ ys))(x \\<mapsto> y)\"", "lemma map_of_distinct_upd3:\n  assumes \"x \\<notin> set(map fst xs)\"\n  \"x \\<notin> set (map fst ys)\"\n  shows \"map_of (xs @ (x,y) # ys) = (map_of (xs @ (x,y') # ys))(x \\<mapsto> y)\"", "lemma map_of_distinct_upd4:\n  assumes \"x \\<notin> set(map fst xs)\"\n  \"x \\<notin> set (map fst ys)\"\n  shows \"map_of (xs @ ys) = (map_of (xs @ (x,y) # ys))(x := None)\"", "lemma map_of_distinct_lookup:\n  assumes \"x \\<notin> set(map fst xs)\"\n  \"x \\<notin> set (map fst ys)\"\n  shows \"map_of (xs @ (x,y) # ys) x = Some y\"", "lemma ran_distinct: \n  assumes dist: \"distinct (map fst al)\" \n  shows \"ran (map_of al) = snd ` set al\"", "lemma aluprio_finite_correct: \"uprio_finite (aluprio_\\<alpha> \\<alpha>) (aluprio_invar \\<alpha> invar)\"", "lemma aluprio_empty_correct:\n  assumes \"al_empty \\<alpha> invar empt\"\n  shows \"uprio_empty (aluprio_\\<alpha> \\<alpha>) (aluprio_invar \\<alpha> invar) (aluprio_empty empt)\"", "lemma aluprio_isEmpty_correct: \n  assumes \"al_isEmpty \\<alpha> invar isEmpty\"\n  shows \"uprio_isEmpty (aluprio_\\<alpha> \\<alpha>) (aluprio_invar \\<alpha> invar) (aluprio_isEmpty isEmpty)\"", "lemma annot_inf: \n  assumes A: \"invar s\" \"\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty\" \"al_annot \\<alpha> invar annot\"\n  shows \"annot s = Infty \\<longleftrightarrow> \\<alpha> s = [] \"", "lemma e_less_eq_annot: \n  \n  assumes \"al_annot \\<alpha> invar annot\" \n   \"invar s\" \"\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty\" \"\\<not> e_less_eq e (annot s)\"\n  shows \"\\<forall>x \\<in> set (map (fst \\<circ> (p_unwrap \\<circ> snd)) (\\<alpha> s)). x < e\"", "lemma aluprio_insert_correct: \n  assumes \n  \"al_splits \\<alpha> invar splits\"\n  \"al_annot \\<alpha> invar annot\"\n  \"al_isEmpty \\<alpha> invar isEmpty\"\n  \"al_app \\<alpha> invar app\"\n  \"al_consr \\<alpha> invar consr\"\n  shows \n  \"uprio_insert (aluprio_\\<alpha> \\<alpha>) (aluprio_invar \\<alpha> invar) \n    (aluprio_insert splits annot isEmpty app consr)\"", "lemma aluprio_prio_correct: \n  assumes \n  \"al_splits \\<alpha> invar splits\"\n  \"al_annot \\<alpha> invar annot\"\n  \"al_isEmpty \\<alpha> invar isEmpty\"\n  shows \n  \"uprio_prio (aluprio_\\<alpha> \\<alpha>) (aluprio_invar \\<alpha> invar) (aluprio_prio splits annot isEmpty)\"", "lemma aluprio_pop_correct: \n  assumes \"al_splits \\<alpha> invar splits\"\n  \"al_annot \\<alpha> invar annot\"\n  \"al_app \\<alpha> invar app\"\n  shows \n  \"uprio_pop (aluprio_\\<alpha> \\<alpha>) (aluprio_invar \\<alpha> invar) (aluprio_pop splits annot app)\"", "lemmas aluprio_correct =\n  aluprio_finite_correct\n  aluprio_empty_correct\n  aluprio_isEmpty_correct\n  aluprio_insert_correct\n  aluprio_pop_correct\n  aluprio_prio_correct", "lemma aluprio_ops_impl: \"StdUprio aluprio_ops\""], "translations": [["", "lemma p_min_re_neut[simp]: \"p_min a Infty = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p_min a Infty = a", "by (induct a) auto"], ["", "lemma p_min_le_neut[simp]: \"p_min Infty a = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p_min Infty a = a", "by (induct a) auto"], ["", "lemma p_min_asso: \"p_min (p_min a b) c = p_min a (p_min b c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p_min (p_min a b) c = p_min a (p_min b c)", "apply(induct a b  rule: p_min.induct )"], ["proof (prove)\ngoal (4 subgoals):\n 1. p_min (p_min Infty Infty) c = p_min Infty (p_min Infty c)\n 2. \\<And>e a.\n       p_min (p_min Infty (LP e a)) c = p_min Infty (p_min (LP e a) c)\n 3. \\<And>e a.\n       p_min (p_min (LP e a) Infty) c = p_min (LP e a) (p_min Infty c)\n 4. \\<And>e1 a e2 b.\n       p_min (p_min (LP e1 a) (LP e2 b)) c =\n       p_min (LP e1 a) (p_min (LP e2 b) c)", "apply (auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>e1 a e2 b.\n       p_min (LP (max e1 e2) (min a b)) c =\n       p_min (LP e1 a) (p_min (LP e2 b) c)", "apply (induct c)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>e1 a e2 b.\n       p_min (LP (max e1 e2) (min a b)) Infty =\n       p_min (LP e1 a) (p_min (LP e2 b) Infty)\n 2. \\<And>x1 x2 e1 a e2 b.\n       p_min (LP (max e1 e2) (min a b)) (LP x1 x2) =\n       p_min (LP e1 a) (p_min (LP e2 b) (LP x1 x2))", "apply (auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 e1 e2. max (max e1 e2) x1 = max e1 (max e2 x1)\n 2. \\<And>x2 a b. min (min a b) x2 = min a (min b x2)", "apply (metis max.assoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2 a b. min (min a b) x2 = min a (min b x2)", "apply (metis min.assoc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma lp_mono: \"class.monoid_add p_min Infty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. class.monoid_add p_min Infty", "by  unfold_locales  (auto simp add: p_min_asso)"], ["", "instantiation LP :: (linorder,linorder) monoid_add\nbegin"], ["", "definition zero_def: \"0 == Infty\""], ["", "definition plus_def: \"a+b == p_min a b\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) LP, monoid_add_class)", "by \n  intro_classes \n(auto simp add: p_min_asso zero_def plus_def)"], ["", "end"], ["", "fun p_less_eq :: \"('e, 'a::linorder) LP \\<Rightarrow> ('e, 'a) LP \\<Rightarrow> bool\" where\n  \"p_less_eq (LP e a) (LP f b) = (a \\<le> b)\"|\n  \"p_less_eq  _ Infty = True\"|\n  \"p_less_eq Infty (LP e a) = False\""], ["", "fun p_less :: \"('e, 'a::linorder) LP \\<Rightarrow> ('e, 'a) LP \\<Rightarrow> bool\" where\n  \"p_less (LP e a) (LP f b) = (a < b)\"|\n  \"p_less (LP e a) Infty = True\"|\n  \"p_less Infty _ = False\""], ["", "lemma p_less_le_not_le : \"p_less x y \\<longleftrightarrow> p_less_eq x y \\<and> \\<not> (p_less_eq y x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p_less x y = (p_less_eq x y \\<and> \\<not> p_less_eq y x)", "by (induct x y rule: p_less.induct) auto"], ["", "lemma p_order_refl : \"p_less_eq x x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p_less_eq x x", "by (induct x) auto"], ["", "lemma p_le_inf : \"p_less_eq Infty x \\<Longrightarrow> x = Infty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p_less_eq Infty x \\<Longrightarrow> x = Infty", "by (induct x) auto"], ["", "lemma p_order_trans : \"\\<lbrakk>p_less_eq x y; p_less_eq y z\\<rbrakk> \\<Longrightarrow> p_less_eq x z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p_less_eq x y; p_less_eq y z\\<rbrakk>\n    \\<Longrightarrow> p_less_eq x z", "apply (induct y z rule: p_less.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>e a f b.\n       \\<lbrakk>p_less_eq x (LP e a); p_less_eq (LP e a) (LP f b)\\<rbrakk>\n       \\<Longrightarrow> p_less_eq x (LP f b)\n 2. \\<And>e a.\n       \\<lbrakk>p_less_eq x (LP e a); p_less_eq (LP e a) Infty\\<rbrakk>\n       \\<Longrightarrow> p_less_eq x Infty\n 3. \\<And>uu_.\n       \\<lbrakk>p_less_eq x Infty; p_less_eq Infty uu_\\<rbrakk>\n       \\<Longrightarrow> p_less_eq x uu_", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>e a f b.\n       \\<lbrakk>p_less_eq x (LP e a); a \\<le> b\\<rbrakk>\n       \\<Longrightarrow> p_less_eq x (LP f b)\n 2. \\<And>uu_. p_less_eq Infty uu_ \\<Longrightarrow> p_less_eq x uu_", "apply (induct x)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>e a f b.\n       \\<lbrakk>p_less_eq Infty (LP e a); a \\<le> b\\<rbrakk>\n       \\<Longrightarrow> p_less_eq Infty (LP f b)\n 2. \\<And>x1 x2 e a f b.\n       \\<lbrakk>p_less_eq (LP x1 x2) (LP e a); a \\<le> b\\<rbrakk>\n       \\<Longrightarrow> p_less_eq (LP x1 x2) (LP f b)\n 3. \\<And>uu_. p_less_eq Infty uu_ \\<Longrightarrow> p_less_eq x uu_", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>uu_. p_less_eq Infty uu_ \\<Longrightarrow> p_less_eq x uu_", "apply (cases x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>uu_.\n       \\<lbrakk>p_less_eq Infty uu_; x = Infty\\<rbrakk>\n       \\<Longrightarrow> p_less_eq x uu_\n 2. \\<And>uu_ x21 x22.\n       \\<lbrakk>p_less_eq Infty uu_; x = LP x21 x22\\<rbrakk>\n       \\<Longrightarrow> p_less_eq x uu_", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>uu_ x21 x22.\n       \\<lbrakk>p_less_eq Infty uu_; x = LP x21 x22\\<rbrakk>\n       \\<Longrightarrow> p_less_eq (LP x21 x22) uu_", "apply(induct x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>uu_ x21 x22.\n       \\<lbrakk>p_less_eq Infty uu_; Infty = LP x21 x22\\<rbrakk>\n       \\<Longrightarrow> p_less_eq (LP x21 x22) uu_\n 2. \\<And>x1 x2 uu_ x21 x22.\n       \\<lbrakk>p_less_eq Infty uu_; LP x1 x2 = LP x21 x22\\<rbrakk>\n       \\<Longrightarrow> p_less_eq (LP x21 x22) uu_", "apply (auto simp add: p_le_inf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2 uu_ x21.\n       p_less_eq Infty uu_ \\<Longrightarrow> p_less_eq (LP x21 x2) uu_", "apply (metis p_le_inf p_less_eq.simps(2))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma p_linear2 : \"p_less_eq x y \\<or> p_less_eq y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p_less_eq x y \\<or> p_less_eq y x", "apply (induct x y rule: p_less_eq.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>e a f b.\n       p_less_eq (LP e a) (LP f b) \\<or> p_less_eq (LP f b) (LP e a)\n 2. \\<And>uu_. p_less_eq uu_ Infty \\<or> p_less_eq Infty uu_\n 3. \\<And>e a. p_less_eq Infty (LP e a) \\<or> p_less_eq (LP e a) Infty", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "instantiation LP :: (type, linorder) preorder\nbegin"], ["", "definition plesseq_def: \"less_eq = p_less_eq\""], ["", "definition pless_def: \"less = p_less\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) LP, preorder_class)", "apply (intro_classes)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z", "apply (simp only: p_less_le_not_le pless_def plesseq_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x. x \\<le> x\n 2. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z", "apply (simp only: p_order_refl plesseq_def pless_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z", "apply (simp only: plesseq_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>p_less_eq x y; p_less_eq y z\\<rbrakk>\n       \\<Longrightarrow> p_less_eq x z", "apply (metis p_order_trans)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "subsubsection \"Operations\""], ["", "definition aluprio_\\<alpha> :: \"('s \\<Rightarrow> (unit \\<times> ('e::linorder,'a::linorder) LP) list) \n  \\<Rightarrow> 's \\<Rightarrow> ('e::linorder \\<rightharpoonup>  'a::linorder)\"\n  where \n  \"aluprio_\\<alpha> \\<alpha> ft == (map_of (map p_unwrap (map snd (\\<alpha> ft))))\""], ["", "definition aluprio_invar :: \"('s \\<Rightarrow> (unit \\<times> ('c::linorder, 'd::linorder) LP) list)\n  \\<Rightarrow> ('s \\<Rightarrow> bool) \\<Rightarrow> 's \\<Rightarrow> bool\" \n  where\n  \"aluprio_invar \\<alpha> invar ft == \n     invar ft \n     \\<and> (\\<forall> x\\<in>set (\\<alpha> ft). snd x\\<noteq>Infty) \n     \\<and> sorted (map fst (map p_unwrap (map snd (\\<alpha> ft)))) \n     \\<and> distinct (map fst (map p_unwrap (map snd (\\<alpha> ft)))) \""], ["", "definition aluprio_empty  where \n  \"aluprio_empty empt = empt\""], ["", "definition aluprio_isEmpty  where \n  \"aluprio_isEmpty isEmpty = isEmpty\""], ["", "definition aluprio_insert :: \n  \"((('e::linorder,'a::linorder) LP \\<Rightarrow> bool) \n  \\<Rightarrow> ('e,'a) LP \\<Rightarrow> 's \\<Rightarrow> ('s \\<times> (unit \\<times> ('e,'a) LP) \\<times> 's)) \n    \\<Rightarrow> ('s \\<Rightarrow> ('e,'a) LP) \n      \\<Rightarrow> ('s \\<Rightarrow> bool)\n        \\<Rightarrow> ('s \\<Rightarrow> 's \\<Rightarrow> 's) \n          \\<Rightarrow> ('s \\<Rightarrow> unit \\<Rightarrow> ('e,'a) LP \\<Rightarrow> 's)\n            \\<Rightarrow> 's \\<Rightarrow> 'e \\<Rightarrow> 'a \\<Rightarrow> 's\" \n  where\n  \"\n  aluprio_insert splits annot isEmpty app consr s e a = \n    (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s \n    then\n      (let (l, (_,lp) , r) = splits (e_less_eq e) Infty s in \n        (if e < fst (p_unwrap lp)\n        then \n          app (consr (consr l () (LP e a))  () lp) r\n        else \n          app (consr l () (LP e a)) r  ))\n    else \n      consr s () (LP e a))\n  \""], ["", "definition aluprio_pop :: \"((('e::linorder,'a::linorder) LP \\<Rightarrow> bool) \\<Rightarrow> ('e,'a) LP\n  \\<Rightarrow> 's \\<Rightarrow> ('s \\<times> (unit \\<times> ('e,'a) LP) \\<times> 's)) \n    \\<Rightarrow> ('s \\<Rightarrow> ('e,'a) LP) \n      \\<Rightarrow> ('s \\<Rightarrow> 's \\<Rightarrow> 's) \n        \\<Rightarrow> 's \n          \\<Rightarrow> 'e \\<times>'a \\<times>'s\" \n  where\n  \"aluprio_pop splits annot app s = \n    (let (l, (_,lp) , r) = splits (\\<lambda> x. x \\<le> (annot s)) Infty s \n    in \n      (case lp of \n        (LP e a) \\<Rightarrow> \n          (e, a, app l r) ))\""], ["", "definition aluprio_prio :: \n  \"((('e::linorder,'a::linorder) LP \\<Rightarrow> bool) \\<Rightarrow> ('e,'a) LP \\<Rightarrow> 's \n  \\<Rightarrow> ('s \\<times> (unit \\<times> ('e,'a) LP) \\<times> 's)) \n    \\<Rightarrow> ('s \\<Rightarrow> ('e,'a) LP) \n      \\<Rightarrow> ('s \\<Rightarrow> bool)\n        \\<Rightarrow> 's \\<Rightarrow> 'e \\<Rightarrow> 'a option\" \n  where\n  \"\n  aluprio_prio splits annot isEmpty s e = \n    (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s \n    then\n      (let (l, (_,lp) , r) = splits (e_less_eq e) Infty s in \n        (if e = fst (p_unwrap lp)\n        then \n          Some (snd (p_unwrap lp))\n        else\n          None))\n    else \n      None)\n  \""], ["", "lemmas aluprio_defs =\naluprio_invar_def\naluprio_\\<alpha>_def\naluprio_empty_def\naluprio_isEmpty_def\naluprio_insert_def\naluprio_pop_def\naluprio_prio_def"], ["", "subsection \"Correctness\""], ["", "subsubsection \"Auxiliary Lemmas\""], ["", "lemma p_linear: \"(x::('e, 'a::linorder) LP) \\<le> y \\<or> y \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<or> y \\<le> x", "by (unfold plesseq_def) (simp only: p_linear2)"], ["", "lemma e_less_eq_mon1: \"e_less_eq e x \\<Longrightarrow> e_less_eq e (x + y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e_less_eq e x \\<Longrightarrow> e_less_eq e (x + y)", "apply (cases x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>e_less_eq e x; x = Infty\\<rbrakk>\n    \\<Longrightarrow> e_less_eq e (x + y)\n 2. \\<And>x21 x22.\n       \\<lbrakk>e_less_eq e x; x = LP x21 x22\\<rbrakk>\n       \\<Longrightarrow> e_less_eq e (x + y)", "apply (auto simp add: plus_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>e \\<le> x21; x = LP x21 x22\\<rbrakk>\n       \\<Longrightarrow> e_less_eq e (p_min (LP x21 x22) y)", "apply (cases y)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>e \\<le> x21; x = LP x21 x22; y = Infty\\<rbrakk>\n       \\<Longrightarrow> e_less_eq e (p_min (LP x21 x22) y)\n 2. \\<And>x21 x22 x21a x22a.\n       \\<lbrakk>e \\<le> x21; x = LP x21 x22; y = LP x21a x22a\\<rbrakk>\n       \\<Longrightarrow> e_less_eq e (p_min (LP x21 x22) y)", "apply (auto simp add: max.coboundedI1)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma e_less_eq_mon2: \"e_less_eq e y \\<Longrightarrow> e_less_eq e (x + y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e_less_eq e y \\<Longrightarrow> e_less_eq e (x + y)", "apply (cases x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>e_less_eq e y; x = Infty\\<rbrakk>\n    \\<Longrightarrow> e_less_eq e (x + y)\n 2. \\<And>x21 x22.\n       \\<lbrakk>e_less_eq e y; x = LP x21 x22\\<rbrakk>\n       \\<Longrightarrow> e_less_eq e (x + y)", "apply (auto simp add: plus_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>e_less_eq e y; x = LP x21 x22\\<rbrakk>\n       \\<Longrightarrow> e_less_eq e (p_min (LP x21 x22) y)", "apply (cases y)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>e_less_eq e y; x = LP x21 x22; y = Infty\\<rbrakk>\n       \\<Longrightarrow> e_less_eq e (p_min (LP x21 x22) y)\n 2. \\<And>x21 x22 x21a x22a.\n       \\<lbrakk>e_less_eq e y; x = LP x21 x22; y = LP x21a x22a\\<rbrakk>\n       \\<Longrightarrow> e_less_eq e (p_min (LP x21 x22) y)", "apply (auto simp add: max.coboundedI2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas e_less_eq_mon = \n  e_less_eq_mon1\n  e_less_eq_mon2"], ["", "lemma p_less_eq_mon:\n  \"(x::('e::linorder,'a::linorder) LP) \\<le> z \\<Longrightarrow> (x + y) \\<le> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> z \\<Longrightarrow> x + y \\<le> z", "apply(cases y)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<le> z; y = Infty\\<rbrakk> \\<Longrightarrow> x + y \\<le> z\n 2. \\<And>x21 x22.\n       \\<lbrakk>x \\<le> z; y = LP x21 x22\\<rbrakk>\n       \\<Longrightarrow> x + y \\<le> z", "apply(auto simp add: plus_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>x \\<le> z; y = LP x21 x22\\<rbrakk>\n       \\<Longrightarrow> p_min x (LP x21 x22) \\<le> z", "apply (cases x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>x \\<le> z; y = LP x21 x22; x = Infty\\<rbrakk>\n       \\<Longrightarrow> p_min x (LP x21 x22) \\<le> z\n 2. \\<And>x21 x22 x21a x22a.\n       \\<lbrakk>x \\<le> z; y = LP x21 x22; x = LP x21a x22a\\<rbrakk>\n       \\<Longrightarrow> p_min x (LP x21 x22) \\<le> z", "apply (cases z)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>x \\<le> z; y = LP x21 x22; x = Infty; z = Infty\\<rbrakk>\n       \\<Longrightarrow> p_min x (LP x21 x22) \\<le> z\n 2. \\<And>x21 x22 x21a x22a.\n       \\<lbrakk>x \\<le> z; y = LP x21 x22; x = Infty;\n        z = LP x21a x22a\\<rbrakk>\n       \\<Longrightarrow> p_min x (LP x21 x22) \\<le> z\n 3. \\<And>x21 x22 x21a x22a.\n       \\<lbrakk>x \\<le> z; y = LP x21 x22; x = LP x21a x22a\\<rbrakk>\n       \\<Longrightarrow> p_min x (LP x21 x22) \\<le> z", "apply (auto simp add: plesseq_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x21a x22a.\n       \\<lbrakk>p_less_eq (LP x21a x22a) z; y = LP x21 x22;\n        x = LP x21a x22a\\<rbrakk>\n       \\<Longrightarrow> p_less_eq (LP (max x21a x21) (min x22a x22)) z", "apply (cases z)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x21 x22 x21a x22a.\n       \\<lbrakk>p_less_eq (LP x21a x22a) z; y = LP x21 x22;\n        x = LP x21a x22a; z = Infty\\<rbrakk>\n       \\<Longrightarrow> p_less_eq (LP (max x21a x21) (min x22a x22)) z\n 2. \\<And>x21 x22 x21a x22a x21b x22b.\n       \\<lbrakk>p_less_eq (LP x21a x22a) z; y = LP x21 x22;\n        x = LP x21a x22a; z = LP x21b x22b\\<rbrakk>\n       \\<Longrightarrow> p_less_eq (LP (max x21a x21) (min x22a x22)) z", "apply (auto simp add: min.coboundedI1)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma p_less_eq_lem1:\n  \"\\<lbrakk>\\<not> (x::('e::linorder,'a::linorder) LP) \\<le> z;\n  (x + y) \\<le> z\\<rbrakk>\n  \\<Longrightarrow> y \\<le> z \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> x \\<le> z; x + y \\<le> z\\<rbrakk>\n    \\<Longrightarrow> y \\<le> z", "apply (cases x,auto simp add: plus_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<not> LP x21 x22 \\<le> z; p_min (LP x21 x22) y \\<le> z;\n        x = LP x21 x22\\<rbrakk>\n       \\<Longrightarrow> y \\<le> z", "apply (cases y, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x21a x22a.\n       \\<lbrakk>\\<not> LP x21 x22 \\<le> z;\n        LP (max x21 x21a) (min x22 x22a) \\<le> z; x = LP x21 x22;\n        y = LP x21a x22a\\<rbrakk>\n       \\<Longrightarrow> LP x21a x22a \\<le> z", "apply (cases z, auto simp add: plesseq_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x21a x22a x21b x22b.\n       \\<lbrakk>\\<not> x22 \\<le> x22b; min x22 x22a \\<le> x22b;\n        x = LP x21 x22; y = LP x21a x22a; z = LP x21b x22b\\<rbrakk>\n       \\<Longrightarrow> x22a \\<le> x22b", "apply (metis min_le_iff_disj)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma infadd: \"x \\<noteq> Infty \\<Longrightarrow>x + y \\<noteq> Infty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> Infty \\<Longrightarrow> x + y \\<noteq> Infty", "apply (unfold plus_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> Infty \\<Longrightarrow> p_min x y \\<noteq> Infty", "apply (induct x y rule: p_min.induct)"], ["proof (prove)\ngoal (4 subgoals):\n 1. Infty \\<noteq> Infty \\<Longrightarrow> p_min Infty Infty \\<noteq> Infty\n 2. \\<And>e a.\n       Infty \\<noteq> Infty \\<Longrightarrow>\n       p_min Infty (LP e a) \\<noteq> Infty\n 3. \\<And>e a.\n       LP e a \\<noteq> Infty \\<Longrightarrow>\n       p_min (LP e a) Infty \\<noteq> Infty\n 4. \\<And>e1 a e2 b.\n       LP e1 a \\<noteq> Infty \\<Longrightarrow>\n       p_min (LP e1 a) (LP e2 b) \\<noteq> Infty", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma e_less_eq_sum_list: \n  \"\\<lbrakk>\\<not> e_less_eq e (sum_list xs)\\<rbrakk> \\<Longrightarrow> \\<forall>x \\<in> set xs. \\<not> e_less_eq e x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> e_less_eq e (sum_list xs) \\<Longrightarrow>\n    \\<forall>x\\<in>set xs. \\<not> e_less_eq e x", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> e_less_eq e (sum_list []) \\<Longrightarrow>\n    \\<forall>x\\<in>set []. \\<not> e_less_eq e x\n 2. \\<And>a xs.\n       \\<lbrakk>\\<not> e_less_eq e (sum_list xs) \\<Longrightarrow>\n                \\<forall>x\\<in>set xs. \\<not> e_less_eq e x;\n        \\<not> e_less_eq e (sum_list (a # xs))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>set (a # xs). \\<not> e_less_eq e x", "case Nil"], ["proof (state)\nthis:\n  \\<not> e_less_eq e (sum_list [])\n\ngoal (2 subgoals):\n 1. \\<not> e_less_eq e (sum_list []) \\<Longrightarrow>\n    \\<forall>x\\<in>set []. \\<not> e_less_eq e x\n 2. \\<And>a xs.\n       \\<lbrakk>\\<not> e_less_eq e (sum_list xs) \\<Longrightarrow>\n                \\<forall>x\\<in>set xs. \\<not> e_less_eq e x;\n        \\<not> e_less_eq e (sum_list (a # xs))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>set (a # xs). \\<not> e_less_eq e x", "thus ?case"], ["proof (prove)\nusing this:\n  \\<not> e_less_eq e (sum_list [])\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set []. \\<not> e_less_eq e x", "by simp"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set []. \\<not> e_less_eq e x\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<not> e_less_eq e (sum_list xs) \\<Longrightarrow>\n                \\<forall>x\\<in>set xs. \\<not> e_less_eq e x;\n        \\<not> e_less_eq e (sum_list (a # xs))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>set (a # xs). \\<not> e_less_eq e x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<not> e_less_eq e (sum_list xs) \\<Longrightarrow>\n                \\<forall>x\\<in>set xs. \\<not> e_less_eq e x;\n        \\<not> e_less_eq e (sum_list (a # xs))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>set (a # xs). \\<not> e_less_eq e x", "case (Cons a xs)"], ["proof (state)\nthis:\n  \\<not> e_less_eq e (sum_list xs) \\<Longrightarrow>\n  \\<forall>x\\<in>set xs. \\<not> e_less_eq e x\n  \\<not> e_less_eq e (sum_list (a # xs))\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<not> e_less_eq e (sum_list xs) \\<Longrightarrow>\n                \\<forall>x\\<in>set xs. \\<not> e_less_eq e x;\n        \\<not> e_less_eq e (sum_list (a # xs))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>set (a # xs). \\<not> e_less_eq e x", "hence \"\\<not> e_less_eq e (sum_list xs)\""], ["proof (prove)\nusing this:\n  \\<not> e_less_eq e (sum_list xs) \\<Longrightarrow>\n  \\<forall>x\\<in>set xs. \\<not> e_less_eq e x\n  \\<not> e_less_eq e (sum_list (a # xs))\n\ngoal (1 subgoal):\n 1. \\<not> e_less_eq e (sum_list xs)", "by (auto simp add: e_less_eq_mon)"], ["proof (state)\nthis:\n  \\<not> e_less_eq e (sum_list xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<not> e_less_eq e (sum_list xs) \\<Longrightarrow>\n                \\<forall>x\\<in>set xs. \\<not> e_less_eq e x;\n        \\<not> e_less_eq e (sum_list (a # xs))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>set (a # xs). \\<not> e_less_eq e x", "hence v1: \"\\<forall>x\\<in>set xs. \\<not> e_less_eq e x\""], ["proof (prove)\nusing this:\n  \\<not> e_less_eq e (sum_list xs)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set xs. \\<not> e_less_eq e x", "using Cons.hyps"], ["proof (prove)\nusing this:\n  \\<not> e_less_eq e (sum_list xs)\n  \\<not> e_less_eq e (sum_list xs) \\<Longrightarrow>\n  \\<forall>x\\<in>set xs. \\<not> e_less_eq e x\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set xs. \\<not> e_less_eq e x", "by simp"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set xs. \\<not> e_less_eq e x\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<not> e_less_eq e (sum_list xs) \\<Longrightarrow>\n                \\<forall>x\\<in>set xs. \\<not> e_less_eq e x;\n        \\<not> e_less_eq e (sum_list (a # xs))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>set (a # xs). \\<not> e_less_eq e x", "from Cons.prems"], ["proof (chain)\npicking this:\n  \\<not> e_less_eq e (sum_list (a # xs))", "have \"\\<not> e_less_eq e a\""], ["proof (prove)\nusing this:\n  \\<not> e_less_eq e (sum_list (a # xs))\n\ngoal (1 subgoal):\n 1. \\<not> e_less_eq e a", "by (auto simp add: e_less_eq_mon)"], ["proof (state)\nthis:\n  \\<not> e_less_eq e a\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<not> e_less_eq e (sum_list xs) \\<Longrightarrow>\n                \\<forall>x\\<in>set xs. \\<not> e_less_eq e x;\n        \\<not> e_less_eq e (sum_list (a # xs))\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>set (a # xs). \\<not> e_less_eq e x", "with v1"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>set xs. \\<not> e_less_eq e x\n  \\<not> e_less_eq e a", "show \"\\<forall>x\\<in>set (a#xs). \\<not> e_less_eq e x\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set xs. \\<not> e_less_eq e x\n  \\<not> e_less_eq e a\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (a # xs). \\<not> e_less_eq e x", "by simp"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (a # xs). \\<not> e_less_eq e x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma e_less_eq_p_unwrap: \n  \"\\<lbrakk>x \\<noteq> Infty;\\<not> e_less_eq e x\\<rbrakk> \\<Longrightarrow> fst (p_unwrap x) < e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> Infty; \\<not> e_less_eq e x\\<rbrakk>\n    \\<Longrightarrow> fst (p_unwrap x) < e", "by (cases x) auto"], ["", "lemma e_less_eq_refl :\n  \"b \\<noteq> Infty \\<Longrightarrow> e_less_eq (fst (p_unwrap b)) b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<noteq> Infty \\<Longrightarrow> e_less_eq (fst (p_unwrap b)) b", "by (cases b) auto"], ["", "lemma e_less_eq_sum_list2:\n  assumes \n  \"\\<forall>x\\<in>set (\\<alpha>s). snd x \\<noteq> Infty\"\n  \"((), b) \\<in> set (\\<alpha>s)\"\n  shows \"e_less_eq (fst (p_unwrap b)) (sum_list (map snd (\\<alpha>s)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e_less_eq (fst (p_unwrap b)) (sum_list (map snd \\<alpha>s))", "apply(insert assms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>set \\<alpha>s. snd x \\<noteq> Infty;\n     ((), b) \\<in> set \\<alpha>s\\<rbrakk>\n    \\<Longrightarrow> e_less_eq (fst (p_unwrap b))\n                       (sum_list (map snd \\<alpha>s))", "apply (induct \"\\<alpha>s\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>x\\<in>set []. snd x \\<noteq> Infty;\n     ((), b) \\<in> set []\\<rbrakk>\n    \\<Longrightarrow> e_less_eq (fst (p_unwrap b)) (sum_list (map snd []))\n 2. \\<And>a \\<alpha>s.\n       \\<lbrakk>\\<lbrakk>\\<forall>x\\<in>set \\<alpha>s. snd x \\<noteq> Infty;\n                 ((), b) \\<in> set \\<alpha>s\\<rbrakk>\n                \\<Longrightarrow> e_less_eq (fst (p_unwrap b))\n                                   (sum_list (map snd \\<alpha>s));\n        \\<forall>x\\<in>set (a # \\<alpha>s). snd x \\<noteq> Infty;\n        ((), b) \\<in> set (a # \\<alpha>s)\\<rbrakk>\n       \\<Longrightarrow> e_less_eq (fst (p_unwrap b))\n                          (sum_list (map snd (a # \\<alpha>s)))", "apply (auto simp add: zero_def e_less_eq_mon e_less_eq_refl)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma e_less_eq_lem1:\n  \"\\<lbrakk>\\<not> e_less_eq e a;e_less_eq e (a + b)\\<rbrakk> \\<Longrightarrow> e_less_eq e b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> e_less_eq e a; e_less_eq e (a + b)\\<rbrakk>\n    \\<Longrightarrow> e_less_eq e b", "apply (auto simp add: plus_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> e_less_eq e a; e_less_eq e (p_min a b)\\<rbrakk>\n    \\<Longrightarrow> e_less_eq e b", "apply (cases a)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> e_less_eq e a; e_less_eq e (p_min a b);\n     a = Infty\\<rbrakk>\n    \\<Longrightarrow> e_less_eq e b\n 2. \\<And>x21 x22.\n       \\<lbrakk>\\<not> e_less_eq e a; e_less_eq e (p_min a b);\n        a = LP x21 x22\\<rbrakk>\n       \\<Longrightarrow> e_less_eq e b", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<not> e \\<le> x21; e_less_eq e (p_min (LP x21 x22) b);\n        a = LP x21 x22\\<rbrakk>\n       \\<Longrightarrow> e_less_eq e b", "apply (cases b)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<not> e \\<le> x21; e_less_eq e (p_min (LP x21 x22) b);\n        a = LP x21 x22; b = Infty\\<rbrakk>\n       \\<Longrightarrow> e_less_eq e b\n 2. \\<And>x21 x22 x21a x22a.\n       \\<lbrakk>\\<not> e \\<le> x21; e_less_eq e (p_min (LP x21 x22) b);\n        a = LP x21 x22; b = LP x21a x22a\\<rbrakk>\n       \\<Longrightarrow> e_less_eq e b", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x21a x22a.\n       \\<lbrakk>\\<not> e \\<le> x21; e \\<le> max x21 x21a; a = LP x21 x22;\n        b = LP x21a x22a\\<rbrakk>\n       \\<Longrightarrow> e \\<le> x21a", "apply (metis le_max_iff_disj)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma p_unwrap_less_sum: \"snd (p_unwrap ((LP e aa) + b)) \\<le> aa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (p_unwrap (LP e aa + b)) \\<le> aa", "apply (cases b)"], ["proof (prove)\ngoal (2 subgoals):\n 1. b = Infty \\<Longrightarrow> snd (p_unwrap (LP e aa + b)) \\<le> aa\n 2. \\<And>x21 x22.\n       b = LP x21 x22 \\<Longrightarrow>\n       snd (p_unwrap (LP e aa + b)) \\<le> aa", "apply (auto simp add: plus_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma  sum_list_less_elems: \"\\<forall>x\\<in>set xs. snd x \\<noteq> Infty \\<Longrightarrow>\n  \\<forall>y\\<in>set (map snd (map p_unwrap (map snd xs))).\n              snd (p_unwrap (sum_list (map snd xs))) \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set xs. snd x \\<noteq> Infty \\<Longrightarrow>\n    \\<forall>y\\<in>set (map snd (map p_unwrap (map snd xs))).\n       snd (p_unwrap (sum_list (map snd xs))) \\<le> y", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>set []. snd x \\<noteq> Infty \\<Longrightarrow>\n    Ball (set (map snd (map p_unwrap (map snd []))))\n     ((\\<le>) (snd (p_unwrap (sum_list (map snd [])))))\n 2. \\<And>a xs.\n       \\<lbrakk>\\<forall>x\\<in>set xs.\n                   snd x \\<noteq> Infty \\<Longrightarrow>\n                Ball (set (map snd (map p_unwrap (map snd xs))))\n                 ((\\<le>) (snd (p_unwrap (sum_list (map snd xs)))));\n        \\<forall>x\\<in>set (a # xs). snd x \\<noteq> Infty\\<rbrakk>\n       \\<Longrightarrow> Ball\n                          (set (map snd (map p_unwrap (map snd (a # xs)))))\n                          ((\\<le>)\n                            (snd (p_unwrap (sum_list (map snd (a # xs))))))", "case Nil"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set []. snd x \\<noteq> Infty\n\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>set []. snd x \\<noteq> Infty \\<Longrightarrow>\n    Ball (set (map snd (map p_unwrap (map snd []))))\n     ((\\<le>) (snd (p_unwrap (sum_list (map snd [])))))\n 2. \\<And>a xs.\n       \\<lbrakk>\\<forall>x\\<in>set xs.\n                   snd x \\<noteq> Infty \\<Longrightarrow>\n                Ball (set (map snd (map p_unwrap (map snd xs))))\n                 ((\\<le>) (snd (p_unwrap (sum_list (map snd xs)))));\n        \\<forall>x\\<in>set (a # xs). snd x \\<noteq> Infty\\<rbrakk>\n       \\<Longrightarrow> Ball\n                          (set (map snd (map p_unwrap (map snd (a # xs)))))\n                          ((\\<le>)\n                            (snd (p_unwrap (sum_list (map snd (a # xs))))))", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set []. snd x \\<noteq> Infty\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set (map snd (map p_unwrap (map snd []))).\n       snd (p_unwrap (sum_list (map snd []))) \\<le> a", "by simp"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set (map snd (map p_unwrap (map snd []))).\n     snd (p_unwrap (sum_list (map snd []))) \\<le> a\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<forall>x\\<in>set xs.\n                   snd x \\<noteq> Infty \\<Longrightarrow>\n                Ball (set (map snd (map p_unwrap (map snd xs))))\n                 ((\\<le>) (snd (p_unwrap (sum_list (map snd xs)))));\n        \\<forall>x\\<in>set (a # xs). snd x \\<noteq> Infty\\<rbrakk>\n       \\<Longrightarrow> Ball\n                          (set (map snd (map p_unwrap (map snd (a # xs)))))\n                          ((\\<le>)\n                            (snd (p_unwrap (sum_list (map snd (a # xs))))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<forall>x\\<in>set xs.\n                   snd x \\<noteq> Infty \\<Longrightarrow>\n                Ball (set (map snd (map p_unwrap (map snd xs))))\n                 ((\\<le>) (snd (p_unwrap (sum_list (map snd xs)))));\n        \\<forall>x\\<in>set (a # xs). snd x \\<noteq> Infty\\<rbrakk>\n       \\<Longrightarrow> Ball\n                          (set (map snd (map p_unwrap (map snd (a # xs)))))\n                          ((\\<le>)\n                            (snd (p_unwrap (sum_list (map snd (a # xs))))))", "case (Cons a as)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set as. snd x \\<noteq> Infty \\<Longrightarrow>\n  \\<forall>a\\<in>set (map snd (map p_unwrap (map snd as))).\n     snd (p_unwrap (sum_list (map snd as))) \\<le> a\n  \\<forall>x\\<in>set (a # as). snd x \\<noteq> Infty\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<forall>x\\<in>set xs.\n                   snd x \\<noteq> Infty \\<Longrightarrow>\n                Ball (set (map snd (map p_unwrap (map snd xs))))\n                 ((\\<le>) (snd (p_unwrap (sum_list (map snd xs)))));\n        \\<forall>x\\<in>set (a # xs). snd x \\<noteq> Infty\\<rbrakk>\n       \\<Longrightarrow> Ball\n                          (set (map snd (map p_unwrap (map snd (a # xs)))))\n                          ((\\<le>)\n                            (snd (p_unwrap (sum_list (map snd (a # xs))))))", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set as. snd x \\<noteq> Infty \\<Longrightarrow>\n  \\<forall>a\\<in>set (map snd (map p_unwrap (map snd as))).\n     snd (p_unwrap (sum_list (map snd as))) \\<le> a\n  \\<forall>x\\<in>set (a # as). snd x \\<noteq> Infty\n\ngoal (1 subgoal):\n 1. \\<forall>b\\<in>set (map snd (map p_unwrap (map snd (a # as)))).\n       snd (p_unwrap (sum_list (map snd (a # as)))) \\<le> b", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>x\\<in>set as.\n                snd (p_unwrap (sum_list (map snd as)))\n                \\<le> snd (p_unwrap (snd x));\n     snd a \\<noteq> Infty;\n     \\<forall>x\\<in>set as. snd x \\<noteq> Infty\\<rbrakk>\n    \\<Longrightarrow> snd (p_unwrap (snd a + sum_list (map snd as)))\n                      \\<le> snd (p_unwrap (snd a))\n 2. \\<And>aa b.\n       \\<lbrakk>\\<forall>x\\<in>set as.\n                   snd (p_unwrap (sum_list (map snd as)))\n                   \\<le> snd (p_unwrap (snd x));\n        snd a \\<noteq> Infty; \\<forall>x\\<in>set as. snd x \\<noteq> Infty;\n        (aa, b) \\<in> set as\\<rbrakk>\n       \\<Longrightarrow> snd (p_unwrap (snd a + sum_list (map snd as)))\n                         \\<le> snd (p_unwrap b)", "apply (cases \"(snd a)\" rule: p_unwrap.cases)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>e aa.\n       \\<lbrakk>\\<forall>x\\<in>set as.\n                   snd (p_unwrap (sum_list (map snd as)))\n                   \\<le> snd (p_unwrap (snd x));\n        snd a \\<noteq> Infty; \\<forall>x\\<in>set as. snd x \\<noteq> Infty;\n        snd a = LP e aa\\<rbrakk>\n       \\<Longrightarrow> snd (p_unwrap (snd a + sum_list (map snd as)))\n                         \\<le> snd (p_unwrap (snd a))\n 2. \\<lbrakk>\\<forall>x\\<in>set as.\n                snd (p_unwrap (sum_list (map snd as)))\n                \\<le> snd (p_unwrap (snd x));\n     snd a \\<noteq> Infty; \\<forall>x\\<in>set as. snd x \\<noteq> Infty;\n     snd a = Infty\\<rbrakk>\n    \\<Longrightarrow> snd (p_unwrap (snd a + sum_list (map snd as)))\n                      \\<le> snd (p_unwrap (snd a))\n 3. \\<And>aa b.\n       \\<lbrakk>\\<forall>x\\<in>set as.\n                   snd (p_unwrap (sum_list (map snd as)))\n                   \\<le> snd (p_unwrap (snd x));\n        snd a \\<noteq> Infty; \\<forall>x\\<in>set as. snd x \\<noteq> Infty;\n        (aa, b) \\<in> set as\\<rbrakk>\n       \\<Longrightarrow> snd (p_unwrap (snd a + sum_list (map snd as)))\n                         \\<le> snd (p_unwrap b)", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>e aa.\n       \\<lbrakk>\\<forall>x\\<in>set as.\n                   snd (p_unwrap (sum_list (map snd as)))\n                   \\<le> snd (p_unwrap (snd x));\n        \\<forall>x\\<in>set as. snd x \\<noteq> Infty;\n        snd a = LP e aa\\<rbrakk>\n       \\<Longrightarrow> snd (p_unwrap (LP e aa + sum_list (map snd as)))\n                         \\<le> aa\n 2. \\<And>aa b.\n       \\<lbrakk>\\<forall>x\\<in>set as.\n                   snd (p_unwrap (sum_list (map snd as)))\n                   \\<le> snd (p_unwrap (snd x));\n        snd a \\<noteq> Infty; \\<forall>x\\<in>set as. snd x \\<noteq> Infty;\n        (aa, b) \\<in> set as\\<rbrakk>\n       \\<Longrightarrow> snd (p_unwrap (snd a + sum_list (map snd as)))\n                         \\<le> snd (p_unwrap b)", "apply (cases \"sum_list (map snd as)\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>e aa.\n       \\<lbrakk>\\<forall>x\\<in>set as.\n                   snd (p_unwrap (sum_list (map snd as)))\n                   \\<le> snd (p_unwrap (snd x));\n        \\<forall>x\\<in>set as. snd x \\<noteq> Infty; snd a = LP e aa;\n        sum_list (map snd as) = Infty\\<rbrakk>\n       \\<Longrightarrow> snd (p_unwrap (LP e aa + sum_list (map snd as)))\n                         \\<le> aa\n 2. \\<And>e aa x21 x22.\n       \\<lbrakk>\\<forall>x\\<in>set as.\n                   snd (p_unwrap (sum_list (map snd as)))\n                   \\<le> snd (p_unwrap (snd x));\n        \\<forall>x\\<in>set as. snd x \\<noteq> Infty; snd a = LP e aa;\n        sum_list (map snd as) = LP x21 x22\\<rbrakk>\n       \\<Longrightarrow> snd (p_unwrap (LP e aa + sum_list (map snd as)))\n                         \\<le> aa\n 3. \\<And>aa b.\n       \\<lbrakk>\\<forall>x\\<in>set as.\n                   snd (p_unwrap (sum_list (map snd as)))\n                   \\<le> snd (p_unwrap (snd x));\n        snd a \\<noteq> Infty; \\<forall>x\\<in>set as. snd x \\<noteq> Infty;\n        (aa, b) \\<in> set as\\<rbrakk>\n       \\<Longrightarrow> snd (p_unwrap (snd a + sum_list (map snd as)))\n                         \\<le> snd (p_unwrap b)", "apply auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>e aa.\n       \\<lbrakk>\\<forall>x\\<in>set as.\n                   snd (p_unwrap Infty) \\<le> snd (p_unwrap (snd x));\n        \\<forall>x\\<in>set as. snd x \\<noteq> Infty; snd a = LP e aa;\n        sum_list (map snd as) = Infty\\<rbrakk>\n       \\<Longrightarrow> snd (p_unwrap (LP e aa + Infty)) \\<le> aa\n 2. \\<And>e aa x21 x22.\n       \\<lbrakk>\\<forall>x\\<in>set as. x22 \\<le> snd (p_unwrap (snd x));\n        \\<forall>x\\<in>set as. snd x \\<noteq> Infty; snd a = LP e aa;\n        sum_list (map snd as) = LP x21 x22\\<rbrakk>\n       \\<Longrightarrow> snd (p_unwrap (LP e aa + LP x21 x22)) \\<le> aa\n 3. \\<And>aa b.\n       \\<lbrakk>\\<forall>x\\<in>set as.\n                   snd (p_unwrap (sum_list (map snd as)))\n                   \\<le> snd (p_unwrap (snd x));\n        snd a \\<noteq> Infty; \\<forall>x\\<in>set as. snd x \\<noteq> Infty;\n        (aa, b) \\<in> set as\\<rbrakk>\n       \\<Longrightarrow> snd (p_unwrap (snd a + sum_list (map snd as)))\n                         \\<le> snd (p_unwrap b)", "apply (metis linorder_linear p_min_re_neut p_unwrap.simps \n        plus_def[abs_def] snd_eqD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>e aa x21 x22.\n       \\<lbrakk>\\<forall>x\\<in>set as. x22 \\<le> snd (p_unwrap (snd x));\n        \\<forall>x\\<in>set as. snd x \\<noteq> Infty; snd a = LP e aa;\n        sum_list (map snd as) = LP x21 x22\\<rbrakk>\n       \\<Longrightarrow> snd (p_unwrap (LP e aa + LP x21 x22)) \\<le> aa\n 2. \\<And>aa b.\n       \\<lbrakk>\\<forall>x\\<in>set as.\n                   snd (p_unwrap (sum_list (map snd as)))\n                   \\<le> snd (p_unwrap (snd x));\n        snd a \\<noteq> Infty; \\<forall>x\\<in>set as. snd x \\<noteq> Infty;\n        (aa, b) \\<in> set as\\<rbrakk>\n       \\<Longrightarrow> snd (p_unwrap (snd a + sum_list (map snd as)))\n                         \\<le> snd (p_unwrap b)", "apply (auto simp add: p_unwrap_less_sum)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>\\<forall>x\\<in>set as.\n                   snd (p_unwrap (sum_list (map snd as)))\n                   \\<le> snd (p_unwrap (snd x));\n        snd a \\<noteq> Infty; \\<forall>x\\<in>set as. snd x \\<noteq> Infty;\n        (aa, b) \\<in> set as\\<rbrakk>\n       \\<Longrightarrow> snd (p_unwrap (snd a + sum_list (map snd as)))\n                         \\<le> snd (p_unwrap b)", "apply (unfold plus_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>\\<forall>x\\<in>set as.\n                   snd (p_unwrap (sum_list (map snd as)))\n                   \\<le> snd (p_unwrap (snd x));\n        snd a \\<noteq> Infty; \\<forall>x\\<in>set as. snd x \\<noteq> Infty;\n        (aa, b) \\<in> set as\\<rbrakk>\n       \\<Longrightarrow> snd (p_unwrap\n                               (p_min (snd a) (sum_list (map snd as))))\n                         \\<le> snd (p_unwrap b)", "apply (cases \"(snd a, sum_list (map snd as))\" rule: p_min.cases)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>aa b.\n       \\<lbrakk>\\<forall>x\\<in>set as.\n                   snd (p_unwrap (sum_list (map snd as)))\n                   \\<le> snd (p_unwrap (snd x));\n        snd a \\<noteq> Infty; \\<forall>x\\<in>set as. snd x \\<noteq> Infty;\n        (aa, b) \\<in> set as;\n        (snd a, sum_list (map snd as)) = (Infty, Infty)\\<rbrakk>\n       \\<Longrightarrow> snd (p_unwrap\n                               (p_min (snd a) (sum_list (map snd as))))\n                         \\<le> snd (p_unwrap b)\n 2. \\<And>aa b e aaa.\n       \\<lbrakk>\\<forall>x\\<in>set as.\n                   snd (p_unwrap (sum_list (map snd as)))\n                   \\<le> snd (p_unwrap (snd x));\n        snd a \\<noteq> Infty; \\<forall>x\\<in>set as. snd x \\<noteq> Infty;\n        (aa, b) \\<in> set as;\n        (snd a, sum_list (map snd as)) = (Infty, LP e aaa)\\<rbrakk>\n       \\<Longrightarrow> snd (p_unwrap\n                               (p_min (snd a) (sum_list (map snd as))))\n                         \\<le> snd (p_unwrap b)\n 3. \\<And>aa b e aaa.\n       \\<lbrakk>\\<forall>x\\<in>set as.\n                   snd (p_unwrap (sum_list (map snd as)))\n                   \\<le> snd (p_unwrap (snd x));\n        snd a \\<noteq> Infty; \\<forall>x\\<in>set as. snd x \\<noteq> Infty;\n        (aa, b) \\<in> set as;\n        (snd a, sum_list (map snd as)) = (LP e aaa, Infty)\\<rbrakk>\n       \\<Longrightarrow> snd (p_unwrap\n                               (p_min (snd a) (sum_list (map snd as))))\n                         \\<le> snd (p_unwrap b)\n 4. \\<And>aa b e1 aaa e2 ba.\n       \\<lbrakk>\\<forall>x\\<in>set as.\n                   snd (p_unwrap (sum_list (map snd as)))\n                   \\<le> snd (p_unwrap (snd x));\n        snd a \\<noteq> Infty; \\<forall>x\\<in>set as. snd x \\<noteq> Infty;\n        (aa, b) \\<in> set as;\n        (snd a, sum_list (map snd as)) = (LP e1 aaa, LP e2 ba)\\<rbrakk>\n       \\<Longrightarrow> snd (p_unwrap\n                               (p_min (snd a) (sum_list (map snd as))))\n                         \\<le> snd (p_unwrap b)", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b e aaa.\n       \\<lbrakk>\\<forall>x\\<in>set as.\n                   snd (p_unwrap Infty) \\<le> snd (p_unwrap (snd x));\n        \\<forall>x\\<in>set as. snd x \\<noteq> Infty; (aa, b) \\<in> set as;\n        snd a = LP e aaa; sum_list (map snd as) = Infty\\<rbrakk>\n       \\<Longrightarrow> aaa \\<le> snd (p_unwrap b)\n 2. \\<And>aa b e1 aaa e2 ba.\n       \\<lbrakk>\\<forall>x\\<in>set as. ba \\<le> snd (p_unwrap (snd x));\n        \\<forall>x\\<in>set as. snd x \\<noteq> Infty; (aa, b) \\<in> set as;\n        snd a = LP e1 aaa; sum_list (map snd as) = LP e2 ba\\<rbrakk>\n       \\<Longrightarrow> min aaa ba \\<le> snd (p_unwrap b)", "apply (cases \"map snd as\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>aa b e aaa.\n       \\<lbrakk>\\<forall>x\\<in>set as.\n                   snd (p_unwrap Infty) \\<le> snd (p_unwrap (snd x));\n        \\<forall>x\\<in>set as. snd x \\<noteq> Infty; (aa, b) \\<in> set as;\n        snd a = LP e aaa; sum_list (map snd as) = Infty;\n        map snd as = []\\<rbrakk>\n       \\<Longrightarrow> aaa \\<le> snd (p_unwrap b)\n 2. \\<And>aa b e aaa ab list.\n       \\<lbrakk>\\<forall>x\\<in>set as.\n                   snd (p_unwrap Infty) \\<le> snd (p_unwrap (snd x));\n        \\<forall>x\\<in>set as. snd x \\<noteq> Infty; (aa, b) \\<in> set as;\n        snd a = LP e aaa; sum_list (map snd as) = Infty;\n        map snd as = ab # list\\<rbrakk>\n       \\<Longrightarrow> aaa \\<le> snd (p_unwrap b)\n 3. \\<And>aa b e1 aaa e2 ba.\n       \\<lbrakk>\\<forall>x\\<in>set as. ba \\<le> snd (p_unwrap (snd x));\n        \\<forall>x\\<in>set as. snd x \\<noteq> Infty; (aa, b) \\<in> set as;\n        snd a = LP e1 aaa; sum_list (map snd as) = LP e2 ba\\<rbrakk>\n       \\<Longrightarrow> min aaa ba \\<le> snd (p_unwrap b)", "apply (auto simp add: infadd)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b e1 aaa e2 ba.\n       \\<lbrakk>\\<forall>x\\<in>set as. ba \\<le> snd (p_unwrap (snd x));\n        \\<forall>x\\<in>set as. snd x \\<noteq> Infty; (aa, b) \\<in> set as;\n        snd a = LP e1 aaa; sum_list (map snd as) = LP e2 ba\\<rbrakk>\n       \\<Longrightarrow> min aaa ba \\<le> snd (p_unwrap b)", "apply (metis min.coboundedI2 snd_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>b\\<in>set (map snd (map p_unwrap (map snd (a # as)))).\n     snd (p_unwrap (sum_list (map snd (a # as)))) \\<le> b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma distinct_sortet_list_app:\n  \"\\<lbrakk>sorted xs; distinct xs; xs = as @ b # cs\\<rbrakk>\n  \\<Longrightarrow> \\<forall> x\\<in> set cs. b < x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted xs; distinct xs; xs = as @ b # cs\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>set cs. b < x", "by (metis distinct.simps(2) distinct_append \n    antisym_conv2 sorted.simps(2) sorted_append)"], ["", "lemma distinct_sorted_list_lem1:\n  assumes \n  \"sorted xs\"\n  \"sorted ys\"\n  \"distinct xs\"\n  \"distinct ys\"\n  \" \\<forall> x \\<in> set xs. x < e\"\n  \" \\<forall> y \\<in> set ys. e < y\"\n  shows \n  \"sorted (xs @ e # ys)\"\n  \"distinct (xs @ e # ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted (xs @ e # ys) &&& distinct (xs @ e # ys)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. sorted (xs @ e # ys)\n 2. distinct (xs @ e # ys)", "from assms (5,6)"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>set xs. x < e\n  \\<forall>y\\<in>set ys. e < y", "have \"\\<forall>x\\<in>set xs. \\<forall>y\\<in>set ys. x \\<le> y\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set xs. x < e\n  \\<forall>y\\<in>set ys. e < y\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set xs. \\<forall>y\\<in>set ys. x \\<le> y", "by force"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set xs. \\<forall>y\\<in>set ys. x \\<le> y\n\ngoal (2 subgoals):\n 1. sorted (xs @ e # ys)\n 2. distinct (xs @ e # ys)", "thus \"sorted (xs @ e # ys)\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set xs. \\<forall>y\\<in>set ys. x \\<le> y\n\ngoal (1 subgoal):\n 1. sorted (xs @ e # ys)", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set xs. \\<forall>y\\<in>set ys. x \\<le> y\n  sorted xs\n  sorted ys\n  distinct xs\n  distinct ys\n  \\<forall>x\\<in>set xs. x < e\n  \\<forall>y\\<in>set ys. e < y\n\ngoal (1 subgoal):\n 1. sorted (xs @ e # ys)", "by (auto simp add: sorted_append)"], ["proof (state)\nthis:\n  sorted (xs @ e # ys)\n\ngoal (1 subgoal):\n 1. distinct (xs @ e # ys)", "have \"set xs \\<inter> set ys = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs \\<inter> set ys = {}", "using assms (5,6)"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set xs. x < e\n  \\<forall>y\\<in>set ys. e < y\n\ngoal (1 subgoal):\n 1. set xs \\<inter> set ys = {}", "by force"], ["proof (state)\nthis:\n  set xs \\<inter> set ys = {}\n\ngoal (1 subgoal):\n 1. distinct (xs @ e # ys)", "thus \"distinct (xs @ e # ys)\""], ["proof (prove)\nusing this:\n  set xs \\<inter> set ys = {}\n\ngoal (1 subgoal):\n 1. distinct (xs @ e # ys)", "using assms"], ["proof (prove)\nusing this:\n  set xs \\<inter> set ys = {}\n  sorted xs\n  sorted ys\n  distinct xs\n  distinct ys\n  \\<forall>x\\<in>set xs. x < e\n  \\<forall>y\\<in>set ys. e < y\n\ngoal (1 subgoal):\n 1. distinct (xs @ e # ys)", "by (auto)"], ["proof (state)\nthis:\n  distinct (xs @ e # ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma distinct_sorted_list_lem2:\n  assumes \n  \"sorted xs\"\n  \"sorted ys\"\n  \"distinct xs\"\n  \"distinct ys\"\n  \"e < e'\"  \n  \" \\<forall> x \\<in> set xs. x < e\"\n  \" \\<forall> y \\<in> set ys. e' < y\"\n  shows \n  \"sorted (xs @ e # e' # ys)\"\n  \"distinct (xs @ e # e' # ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted (xs @ e # e' # ys) &&& distinct (xs @ e # e' # ys)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. sorted (xs @ e # e' # ys)\n 2. distinct (xs @ e # e' # ys)", "have \"sorted (e' # ys)\"\n    \"distinct (e' # ys)\"\n    \"\\<forall> y \\<in> set (e' # ys). e < y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted (e' # ys) &&&\n    distinct (e' # ys) &&& \\<forall>y\\<in>set (e' # ys). e < y", "using assms(2,4,5,7)"], ["proof (prove)\nusing this:\n  sorted ys\n  distinct ys\n  e < e'\n  \\<forall>y\\<in>set ys. e' < y\n\ngoal (1 subgoal):\n 1. sorted (e' # ys) &&&\n    distinct (e' # ys) &&& \\<forall>y\\<in>set (e' # ys). e < y", "by (auto)"], ["proof (state)\nthis:\n  sorted (e' # ys)\n  distinct (e' # ys)\n  \\<forall>y\\<in>set (e' # ys). e < y\n\ngoal (2 subgoals):\n 1. sorted (xs @ e # e' # ys)\n 2. distinct (xs @ e # e' # ys)", "thus \"sorted (xs @ e # e' # ys)\"\n  \"distinct (xs @ e # e' # ys)\""], ["proof (prove)\nusing this:\n  sorted (e' # ys)\n  distinct (e' # ys)\n  \\<forall>y\\<in>set (e' # ys). e < y\n\ngoal (1 subgoal):\n 1. sorted (xs @ e # e' # ys) &&& distinct (xs @ e # e' # ys)", "using assms(1,3,6) distinct_sorted_list_lem1[of xs \"e' # ys\" e]"], ["proof (prove)\nusing this:\n  sorted (e' # ys)\n  distinct (e' # ys)\n  \\<forall>y\\<in>set (e' # ys). e < y\n  sorted xs\n  distinct xs\n  \\<forall>x\\<in>set xs. x < e\n  \\<lbrakk>sorted xs; sorted (e' # ys); distinct xs; distinct (e' # ys);\n   \\<forall>x\\<in>set xs. x < e;\n   \\<forall>y\\<in>set (e' # ys). e < y\\<rbrakk>\n  \\<Longrightarrow> sorted (xs @ e # e' # ys)\n  \\<lbrakk>sorted xs; sorted (e' # ys); distinct xs; distinct (e' # ys);\n   \\<forall>x\\<in>set xs. x < e;\n   \\<forall>y\\<in>set (e' # ys). e < y\\<rbrakk>\n  \\<Longrightarrow> distinct (xs @ e # e' # ys)\n\ngoal (1 subgoal):\n 1. sorted (xs @ e # e' # ys) &&& distinct (xs @ e # e' # ys)", "by auto"], ["proof (state)\nthis:\n  sorted (xs @ e # e' # ys)\n  distinct (xs @ e # e' # ys)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_of_distinct_upd:\n  \"x \\<notin> set (map fst xs) \\<Longrightarrow> [x \\<mapsto> y] ++ map_of xs = (map_of xs) (x \\<mapsto> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> set (map fst xs) \\<Longrightarrow>\n    [x \\<mapsto> y] ++ map_of xs = map_of xs(x \\<mapsto> y)", "by (induct xs) (auto simp add: fun_upd_twist)"], ["", "lemma map_of_distinct_upd2:\n  assumes \"x \\<notin> set(map fst xs)\"\n  \"x \\<notin> set (map fst ys)\"\n  shows \"map_of (xs @ (x,y) # ys) = (map_of (xs @ ys))(x \\<mapsto> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (xs @ (x, y) # ys) = map_of (xs @ ys)(x \\<mapsto> y)", "apply(insert assms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> set (map fst xs);\n     x \\<notin> set (map fst ys)\\<rbrakk>\n    \\<Longrightarrow> map_of (xs @ (x, y) # ys) = map_of (xs @ ys)(x \n                      \\<mapsto> y)", "apply(induct xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<notin> set (map fst []);\n     x \\<notin> set (map fst ys)\\<rbrakk>\n    \\<Longrightarrow> map_of ([] @ (x, y) # ys) = map_of ([] @ ys)(x \n                      \\<mapsto> y)\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> set (map fst xs);\n                 x \\<notin> set (map fst ys)\\<rbrakk>\n                \\<Longrightarrow> map_of (xs @ (x, y) # ys) =\n                                  map_of (xs @ ys)(x \\<mapsto> y);\n        x \\<notin> set (map fst (a # xs));\n        x \\<notin> set (map fst ys)\\<rbrakk>\n       \\<Longrightarrow> map_of ((a # xs) @ (x, y) # ys) =\n                         map_of ((a # xs) @ ys)(x \\<mapsto> y)", "apply (auto intro: ext)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma map_of_distinct_upd3:\n  assumes \"x \\<notin> set(map fst xs)\"\n  \"x \\<notin> set (map fst ys)\"\n  shows \"map_of (xs @ (x,y) # ys) = (map_of (xs @ (x,y') # ys))(x \\<mapsto> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (xs @ (x, y) # ys) = map_of (xs @ (x, y') # ys)(x \\<mapsto> y)", "apply(insert assms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> set (map fst xs);\n     x \\<notin> set (map fst ys)\\<rbrakk>\n    \\<Longrightarrow> map_of (xs @ (x, y) # ys) = map_of (xs @ (x, y') # ys)\n                      (x \\<mapsto> y)", "apply(induct xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<notin> set (map fst []);\n     x \\<notin> set (map fst ys)\\<rbrakk>\n    \\<Longrightarrow> map_of ([] @ (x, y) # ys) = map_of ([] @ (x, y') # ys)\n                      (x \\<mapsto> y)\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> set (map fst xs);\n                 x \\<notin> set (map fst ys)\\<rbrakk>\n                \\<Longrightarrow> map_of (xs @ (x, y) # ys) =\n                                  map_of (xs @ (x, y') # ys)(x \\<mapsto> y);\n        x \\<notin> set (map fst (a # xs));\n        x \\<notin> set (map fst ys)\\<rbrakk>\n       \\<Longrightarrow> map_of ((a # xs) @ (x, y) # ys) =\n                         map_of ((a # xs) @ (x, y') # ys)(x \\<mapsto> y)", "apply (auto intro: ext)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma map_of_distinct_upd4:\n  assumes \"x \\<notin> set(map fst xs)\"\n  \"x \\<notin> set (map fst ys)\"\n  shows \"map_of (xs @ ys) = (map_of (xs @ (x,y) # ys))(x := None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (xs @ ys) = (map_of (xs @ (x, y) # ys))(x := None)", "apply(insert assms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> set (map fst xs);\n     x \\<notin> set (map fst ys)\\<rbrakk>\n    \\<Longrightarrow> map_of (xs @ ys) = (map_of (xs @ (x, y) # ys))\n                      (x := None)", "apply(induct xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<notin> set (map fst []);\n     x \\<notin> set (map fst ys)\\<rbrakk>\n    \\<Longrightarrow> map_of ([] @ ys) = (map_of ([] @ (x, y) # ys))\n                      (x := None)\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> set (map fst xs);\n                 x \\<notin> set (map fst ys)\\<rbrakk>\n                \\<Longrightarrow> map_of (xs @ ys) =\n                                  (map_of (xs @ (x, y) # ys))(x := None);\n        x \\<notin> set (map fst (a # xs));\n        x \\<notin> set (map fst ys)\\<rbrakk>\n       \\<Longrightarrow> map_of ((a # xs) @ ys) =\n                         (map_of ((a # xs) @ (x, y) # ys))(x := None)", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<notin> fst ` set ys \\<Longrightarrow>\n    map_of ys = (map_of ys)(x := None)\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> set (map fst xs);\n                 x \\<notin> set (map fst ys)\\<rbrakk>\n                \\<Longrightarrow> map_of (xs @ ys) =\n                                  (map_of (xs @ (x, y) # ys))(x := None);\n        x \\<notin> set (map fst (a # xs));\n        x \\<notin> set (map fst ys)\\<rbrakk>\n       \\<Longrightarrow> map_of ((a # xs) @ ys) =\n                         (map_of ((a # xs) @ (x, y) # ys))(x := None)", "apply (metis dom_map_of_conv_image_fst fun_upd_None_restrict \n    restrict_complement_singleton_eq restrict_map_self)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>x \\<notin> set (map fst xs);\n                 x \\<notin> set (map fst ys)\\<rbrakk>\n                \\<Longrightarrow> map_of (xs @ ys) =\n                                  (map_of (xs @ (x, y) # ys))(x := None);\n        x \\<notin> set (map fst (a # xs));\n        x \\<notin> set (map fst ys)\\<rbrakk>\n       \\<Longrightarrow> map_of ((a # xs) @ ys) =\n                         (map_of ((a # xs) @ (x, y) # ys))(x := None)", "apply (auto simp add: map_of_eq_None_iff) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma map_of_distinct_lookup:\n  assumes \"x \\<notin> set(map fst xs)\"\n  \"x \\<notin> set (map fst ys)\"\n  shows \"map_of (xs @ (x,y) # ys) x = Some y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (xs @ (x, y) # ys) x = Some y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map_of (xs @ (x, y) # ys) x = Some y", "have \"map_of (xs @ (x,y) # ys) = (map_of (xs @ ys)) (x \\<mapsto> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (xs @ (x, y) # ys) = map_of (xs @ ys)(x \\<mapsto> y)", "using assms map_of_distinct_upd2"], ["proof (prove)\nusing this:\n  x \\<notin> set (map fst xs)\n  x \\<notin> set (map fst ys)\n  \\<lbrakk>?x \\<notin> set (map fst ?xs);\n   ?x \\<notin> set (map fst ?ys)\\<rbrakk>\n  \\<Longrightarrow> map_of (?xs @ (?x, ?y) # ?ys) = map_of (?xs @ ?ys)(?x \n                    \\<mapsto> ?y)\n\ngoal (1 subgoal):\n 1. map_of (xs @ (x, y) # ys) = map_of (xs @ ys)(x \\<mapsto> y)", "by simp"], ["proof (state)\nthis:\n  map_of (xs @ (x, y) # ys) = map_of (xs @ ys)(x \\<mapsto> y)\n\ngoal (1 subgoal):\n 1. map_of (xs @ (x, y) # ys) x = Some y", "thus ?thesis"], ["proof (prove)\nusing this:\n  map_of (xs @ (x, y) # ys) = map_of (xs @ ys)(x \\<mapsto> y)\n\ngoal (1 subgoal):\n 1. map_of (xs @ (x, y) # ys) x = Some y", "by simp"], ["proof (state)\nthis:\n  map_of (xs @ (x, y) # ys) x = Some y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ran_distinct: \n  assumes dist: \"distinct (map fst al)\" \n  shows \"ran (map_of al) = snd ` set al\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ran (map_of al) = snd ` set al", "using assms"], ["proof (prove)\nusing this:\n  distinct (map fst al)\n\ngoal (1 subgoal):\n 1. ran (map_of al) = snd ` set al", "proof (induct al)"], ["proof (state)\ngoal (2 subgoals):\n 1. distinct (map fst []) \\<Longrightarrow> ran (map_of []) = snd ` set []\n 2. \\<And>a al.\n       \\<lbrakk>distinct (map fst al) \\<Longrightarrow>\n                ran (map_of al) = snd ` set al;\n        distinct (map fst (a # al))\\<rbrakk>\n       \\<Longrightarrow> ran (map_of (a # al)) = snd ` set (a # al)", "case Nil"], ["proof (state)\nthis:\n  distinct (map fst [])\n\ngoal (2 subgoals):\n 1. distinct (map fst []) \\<Longrightarrow> ran (map_of []) = snd ` set []\n 2. \\<And>a al.\n       \\<lbrakk>distinct (map fst al) \\<Longrightarrow>\n                ran (map_of al) = snd ` set al;\n        distinct (map fst (a # al))\\<rbrakk>\n       \\<Longrightarrow> ran (map_of (a # al)) = snd ` set (a # al)", "then"], ["proof (chain)\npicking this:\n  distinct (map fst [])", "show ?case"], ["proof (prove)\nusing this:\n  distinct (map fst [])\n\ngoal (1 subgoal):\n 1. ran (map_of []) = snd ` set []", "by simp"], ["proof (state)\nthis:\n  ran (map_of []) = snd ` set []\n\ngoal (1 subgoal):\n 1. \\<And>a al.\n       \\<lbrakk>distinct (map fst al) \\<Longrightarrow>\n                ran (map_of al) = snd ` set al;\n        distinct (map fst (a # al))\\<rbrakk>\n       \\<Longrightarrow> ran (map_of (a # al)) = snd ` set (a # al)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a al.\n       \\<lbrakk>distinct (map fst al) \\<Longrightarrow>\n                ran (map_of al) = snd ` set al;\n        distinct (map fst (a # al))\\<rbrakk>\n       \\<Longrightarrow> ran (map_of (a # al)) = snd ` set (a # al)", "case (Cons kv al)"], ["proof (state)\nthis:\n  distinct (map fst al) \\<Longrightarrow> ran (map_of al) = snd ` set al\n  distinct (map fst (kv # al))\n\ngoal (1 subgoal):\n 1. \\<And>a al.\n       \\<lbrakk>distinct (map fst al) \\<Longrightarrow>\n                ran (map_of al) = snd ` set al;\n        distinct (map fst (a # al))\\<rbrakk>\n       \\<Longrightarrow> ran (map_of (a # al)) = snd ` set (a # al)", "then"], ["proof (chain)\npicking this:\n  distinct (map fst al) \\<Longrightarrow> ran (map_of al) = snd ` set al\n  distinct (map fst (kv # al))", "have \"ran (map_of al) = snd ` set al\""], ["proof (prove)\nusing this:\n  distinct (map fst al) \\<Longrightarrow> ran (map_of al) = snd ` set al\n  distinct (map fst (kv # al))\n\ngoal (1 subgoal):\n 1. ran (map_of al) = snd ` set al", "by simp"], ["proof (state)\nthis:\n  ran (map_of al) = snd ` set al\n\ngoal (1 subgoal):\n 1. \\<And>a al.\n       \\<lbrakk>distinct (map fst al) \\<Longrightarrow>\n                ran (map_of al) = snd ` set al;\n        distinct (map fst (a # al))\\<rbrakk>\n       \\<Longrightarrow> ran (map_of (a # al)) = snd ` set (a # al)", "moreover"], ["proof (state)\nthis:\n  ran (map_of al) = snd ` set al\n\ngoal (1 subgoal):\n 1. \\<And>a al.\n       \\<lbrakk>distinct (map fst al) \\<Longrightarrow>\n                ran (map_of al) = snd ` set al;\n        distinct (map fst (a # al))\\<rbrakk>\n       \\<Longrightarrow> ran (map_of (a # al)) = snd ` set (a # al)", "from Cons.prems"], ["proof (chain)\npicking this:\n  distinct (map fst (kv # al))", "have \"map_of al (fst kv) = None\""], ["proof (prove)\nusing this:\n  distinct (map fst (kv # al))\n\ngoal (1 subgoal):\n 1. map_of al (fst kv) = None", "by (simp add: map_of_eq_None_iff)"], ["proof (state)\nthis:\n  map_of al (fst kv) = None\n\ngoal (1 subgoal):\n 1. \\<And>a al.\n       \\<lbrakk>distinct (map fst al) \\<Longrightarrow>\n                ran (map_of al) = snd ` set al;\n        distinct (map fst (a # al))\\<rbrakk>\n       \\<Longrightarrow> ran (map_of (a # al)) = snd ` set (a # al)", "ultimately"], ["proof (chain)\npicking this:\n  ran (map_of al) = snd ` set al\n  map_of al (fst kv) = None", "show ?case"], ["proof (prove)\nusing this:\n  ran (map_of al) = snd ` set al\n  map_of al (fst kv) = None\n\ngoal (1 subgoal):\n 1. ran (map_of (kv # al)) = snd ` set (kv # al)", "by (simp only: map_of.simps ran_map_upd) simp"], ["proof (state)\nthis:\n  ran (map_of (kv # al)) = snd ` set (kv # al)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \"Finite\""], ["", "lemma aluprio_finite_correct: \"uprio_finite (aluprio_\\<alpha> \\<alpha>) (aluprio_invar \\<alpha> invar)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uprio_finite (aluprio_\\<alpha> \\<alpha>) (aluprio_invar \\<alpha> invar)", "by(unfold_locales) (simp add: aluprio_defs finite_dom_map_of)"], ["", "subsubsection \"Empty\""], ["", "lemma aluprio_empty_correct:\n  assumes \"al_empty \\<alpha> invar empt\"\n  shows \"uprio_empty (aluprio_\\<alpha> \\<alpha>) (aluprio_invar \\<alpha> invar) (aluprio_empty empt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uprio_empty (aluprio_\\<alpha> \\<alpha>) (aluprio_invar \\<alpha> invar)\n     (aluprio_empty empt)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. uprio_empty (aluprio_\\<alpha> \\<alpha>) (aluprio_invar \\<alpha> invar)\n     (aluprio_empty empt)", "interpret al_empty \\<alpha> invar empt"], ["proof (prove)\ngoal (1 subgoal):\n 1. al_empty \\<alpha> invar empt", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. uprio_empty (aluprio_\\<alpha> \\<alpha>) (aluprio_invar \\<alpha> invar)\n     (aluprio_empty empt)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. uprio_empty (aluprio_\\<alpha> \\<alpha>) (aluprio_invar \\<alpha> invar)\n     (aluprio_empty empt)", "apply (unfold_locales)"], ["proof (prove)\ngoal (2 subgoals):\n 1. aluprio_invar \\<alpha> invar (aluprio_empty empt ())\n 2. aluprio_\\<alpha> \\<alpha> (aluprio_empty empt ()) = Map.empty", "apply (auto simp add: empty_correct aluprio_defs)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  uprio_empty (aluprio_\\<alpha> \\<alpha>) (aluprio_invar \\<alpha> invar)\n   (aluprio_empty empt)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \"Is Empty\""], ["", "lemma aluprio_isEmpty_correct: \n  assumes \"al_isEmpty \\<alpha> invar isEmpty\"\n  shows \"uprio_isEmpty (aluprio_\\<alpha> \\<alpha>) (aluprio_invar \\<alpha> invar) (aluprio_isEmpty isEmpty)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uprio_isEmpty (aluprio_\\<alpha> \\<alpha>) (aluprio_invar \\<alpha> invar)\n     (aluprio_isEmpty isEmpty)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. uprio_isEmpty (aluprio_\\<alpha> \\<alpha>) (aluprio_invar \\<alpha> invar)\n     (aluprio_isEmpty isEmpty)", "interpret al_isEmpty \\<alpha> invar isEmpty"], ["proof (prove)\ngoal (1 subgoal):\n 1. al_isEmpty \\<alpha> invar isEmpty", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. uprio_isEmpty (aluprio_\\<alpha> \\<alpha>) (aluprio_invar \\<alpha> invar)\n     (aluprio_isEmpty isEmpty)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. uprio_isEmpty (aluprio_\\<alpha> \\<alpha>) (aluprio_invar \\<alpha> invar)\n     (aluprio_isEmpty isEmpty)", "apply (unfold_locales)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       aluprio_invar \\<alpha> invar s \\<Longrightarrow>\n       aluprio_isEmpty isEmpty s = (aluprio_\\<alpha> \\<alpha> s = Map.empty)", "apply (auto simp add: aluprio_defs isEmpty_correct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  uprio_isEmpty (aluprio_\\<alpha> \\<alpha>) (aluprio_invar \\<alpha> invar)\n   (aluprio_isEmpty isEmpty)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \"Insert\""], ["", "lemma annot_inf: \n  assumes A: \"invar s\" \"\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty\" \"al_annot \\<alpha> invar annot\"\n  shows \"annot s = Infty \\<longleftrightarrow> \\<alpha> s = [] \""], ["proof (prove)\ngoal (1 subgoal):\n 1. (annot s = Infty) = (\\<alpha> s = [])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (annot s = Infty) = (\\<alpha> s = [])", "from A"], ["proof (chain)\npicking this:\n  invar s\n  \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty\n  al_annot \\<alpha> invar annot", "have invs: \"invar s\""], ["proof (prove)\nusing this:\n  invar s\n  \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty\n  al_annot \\<alpha> invar annot\n\ngoal (1 subgoal):\n 1. invar s", "by (simp add: aluprio_defs)"], ["proof (state)\nthis:\n  invar s\n\ngoal (1 subgoal):\n 1. (annot s = Infty) = (\\<alpha> s = [])", "interpret al_annot \\<alpha> invar annot"], ["proof (prove)\ngoal (1 subgoal):\n 1. al_annot \\<alpha> invar annot", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. (annot s = Infty) = (\\<alpha> s = [])", "show \"annot s = Infty \\<longleftrightarrow> \\<alpha> s = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (annot s = Infty) = (\\<alpha> s = [])", "proof (cases \"\\<alpha> s = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<alpha> s = [] \\<Longrightarrow> (annot s = Infty) = (\\<alpha> s = [])\n 2. \\<alpha> s \\<noteq> [] \\<Longrightarrow>\n    (annot s = Infty) = (\\<alpha> s = [])", "case True"], ["proof (state)\nthis:\n  \\<alpha> s = []\n\ngoal (2 subgoals):\n 1. \\<alpha> s = [] \\<Longrightarrow> (annot s = Infty) = (\\<alpha> s = [])\n 2. \\<alpha> s \\<noteq> [] \\<Longrightarrow>\n    (annot s = Infty) = (\\<alpha> s = [])", "hence \"map snd (\\<alpha> s) = []\""], ["proof (prove)\nusing this:\n  \\<alpha> s = []\n\ngoal (1 subgoal):\n 1. map snd (\\<alpha> s) = []", "by simp"], ["proof (state)\nthis:\n  map snd (\\<alpha> s) = []\n\ngoal (2 subgoals):\n 1. \\<alpha> s = [] \\<Longrightarrow> (annot s = Infty) = (\\<alpha> s = [])\n 2. \\<alpha> s \\<noteq> [] \\<Longrightarrow>\n    (annot s = Infty) = (\\<alpha> s = [])", "hence \"sum_list (map snd (\\<alpha> s)) = Infty\""], ["proof (prove)\nusing this:\n  map snd (\\<alpha> s) = []\n\ngoal (1 subgoal):\n 1. sum_list (map snd (\\<alpha> s)) = Infty", "by (auto simp add: zero_def)"], ["proof (state)\nthis:\n  sum_list (map snd (\\<alpha> s)) = Infty\n\ngoal (2 subgoals):\n 1. \\<alpha> s = [] \\<Longrightarrow> (annot s = Infty) = (\\<alpha> s = [])\n 2. \\<alpha> s \\<noteq> [] \\<Longrightarrow>\n    (annot s = Infty) = (\\<alpha> s = [])", "with invs"], ["proof (chain)\npicking this:\n  invar s\n  sum_list (map snd (\\<alpha> s)) = Infty", "have  \"annot s = Infty\""], ["proof (prove)\nusing this:\n  invar s\n  sum_list (map snd (\\<alpha> s)) = Infty\n\ngoal (1 subgoal):\n 1. annot s = Infty", "by (auto simp add: annot_correct)"], ["proof (state)\nthis:\n  annot s = Infty\n\ngoal (2 subgoals):\n 1. \\<alpha> s = [] \\<Longrightarrow> (annot s = Infty) = (\\<alpha> s = [])\n 2. \\<alpha> s \\<noteq> [] \\<Longrightarrow>\n    (annot s = Infty) = (\\<alpha> s = [])", "with True"], ["proof (chain)\npicking this:\n  \\<alpha> s = []\n  annot s = Infty", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<alpha> s = []\n  annot s = Infty\n\ngoal (1 subgoal):\n 1. (annot s = Infty) = (\\<alpha> s = [])", "by simp"], ["proof (state)\nthis:\n  (annot s = Infty) = (\\<alpha> s = [])\n\ngoal (1 subgoal):\n 1. \\<alpha> s \\<noteq> [] \\<Longrightarrow>\n    (annot s = Infty) = (\\<alpha> s = [])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<alpha> s \\<noteq> [] \\<Longrightarrow>\n    (annot s = Infty) = (\\<alpha> s = [])", "case False"], ["proof (state)\nthis:\n  \\<alpha> s \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<alpha> s \\<noteq> [] \\<Longrightarrow>\n    (annot s = Infty) = (\\<alpha> s = [])", "hence \" \\<exists>x xs. (\\<alpha> s) = x # xs\""], ["proof (prove)\nusing this:\n  \\<alpha> s \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<exists>x xs. \\<alpha> s = x # xs", "by (cases \"\\<alpha> s\") auto"], ["proof (state)\nthis:\n  \\<exists>x xs. \\<alpha> s = x # xs\n\ngoal (1 subgoal):\n 1. \\<alpha> s \\<noteq> [] \\<Longrightarrow>\n    (annot s = Infty) = (\\<alpha> s = [])", "from this"], ["proof (chain)\npicking this:\n  \\<exists>x xs. \\<alpha> s = x # xs", "obtain x xs where [simp]: \"(\\<alpha> s) = x # xs\""], ["proof (prove)\nusing this:\n  \\<exists>x xs. \\<alpha> s = x # xs\n\ngoal (1 subgoal):\n 1. (\\<And>x xs.\n        \\<alpha> s = x # xs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<alpha> s = x # xs\n\ngoal (1 subgoal):\n 1. \\<alpha> s \\<noteq> [] \\<Longrightarrow>\n    (annot s = Infty) = (\\<alpha> s = [])", "from this assms(2)"], ["proof (chain)\npicking this:\n  \\<alpha> s = x # xs\n  \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty", "have \"snd x \\<noteq> Infty\""], ["proof (prove)\nusing this:\n  \\<alpha> s = x # xs\n  \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty\n\ngoal (1 subgoal):\n 1. snd x \\<noteq> Infty", "by (auto simp add: aluprio_defs)"], ["proof (state)\nthis:\n  snd x \\<noteq> Infty\n\ngoal (1 subgoal):\n 1. \\<alpha> s \\<noteq> [] \\<Longrightarrow>\n    (annot s = Infty) = (\\<alpha> s = [])", "hence \"sum_list (map snd (\\<alpha> s)) \\<noteq> Infty\""], ["proof (prove)\nusing this:\n  snd x \\<noteq> Infty\n\ngoal (1 subgoal):\n 1. sum_list (map snd (\\<alpha> s)) \\<noteq> Infty", "by (auto simp add: infadd)"], ["proof (state)\nthis:\n  sum_list (map snd (\\<alpha> s)) \\<noteq> Infty\n\ngoal (1 subgoal):\n 1. \\<alpha> s \\<noteq> [] \\<Longrightarrow>\n    (annot s = Infty) = (\\<alpha> s = [])", "thus ?thesis"], ["proof (prove)\nusing this:\n  sum_list (map snd (\\<alpha> s)) \\<noteq> Infty\n\ngoal (1 subgoal):\n 1. (annot s = Infty) = (\\<alpha> s = [])", "using annot_correct invs False"], ["proof (prove)\nusing this:\n  sum_list (map snd (\\<alpha> s)) \\<noteq> Infty\n  invar ?s \\<Longrightarrow> annot ?s = sum_list (map snd (\\<alpha> ?s))\n  invar s\n  \\<alpha> s \\<noteq> []\n\ngoal (1 subgoal):\n 1. (annot s = Infty) = (\\<alpha> s = [])", "by simp"], ["proof (state)\nthis:\n  (annot s = Infty) = (\\<alpha> s = [])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (annot s = Infty) = (\\<alpha> s = [])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma e_less_eq_annot: \n  \n  assumes \"al_annot \\<alpha> invar annot\" \n   \"invar s\" \"\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty\" \"\\<not> e_less_eq e (annot s)\"\n  shows \"\\<forall>x \\<in> set (map (fst \\<circ> (p_unwrap \\<circ> snd)) (\\<alpha> s)). x < e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap\n                              snd)\n                         (\\<alpha> s)).\n       x < e", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap\n                              snd)\n                         (\\<alpha> s)).\n       x < e", "interpret al_annot \\<alpha> invar annot"], ["proof (prove)\ngoal (1 subgoal):\n 1. al_annot \\<alpha> invar annot", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap\n                              snd)\n                         (\\<alpha> s)).\n       x < e", "from assms(2)"], ["proof (chain)\npicking this:\n  invar s", "have \"annot s = sum_list (map snd (\\<alpha> s))\""], ["proof (prove)\nusing this:\n  invar s\n\ngoal (1 subgoal):\n 1. annot s = sum_list (map snd (\\<alpha> s))", "by (auto simp add: annot_correct)"], ["proof (state)\nthis:\n  annot s = sum_list (map snd (\\<alpha> s))\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap\n                              snd)\n                         (\\<alpha> s)).\n       x < e", "with assms(4)"], ["proof (chain)\npicking this:\n  \\<not> e_less_eq e (annot s)\n  annot s = sum_list (map snd (\\<alpha> s))", "have \n    \"\\<forall>x \\<in> set (map snd (\\<alpha> s)). \\<not> e_less_eq e x\""], ["proof (prove)\nusing this:\n  \\<not> e_less_eq e (annot s)\n  annot s = sum_list (map snd (\\<alpha> s))\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (map snd (\\<alpha> s)). \\<not> e_less_eq e x", "by (metis e_less_eq_sum_list)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (map snd (\\<alpha> s)). \\<not> e_less_eq e x\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap\n                              snd)\n                         (\\<alpha> s)).\n       x < e", "with assms(3)"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty\n  \\<forall>x\\<in>set (map snd (\\<alpha> s)). \\<not> e_less_eq e x", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty\n  \\<forall>x\\<in>set (map snd (\\<alpha> s)). \\<not> e_less_eq e x\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap\n                              snd)\n                         (\\<alpha> s)).\n       x < e", "by (auto simp add: e_less_eq_p_unwrap)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap\n                            snd)\n                       (\\<alpha> s)).\n     x < e\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma aluprio_insert_correct: \n  assumes \n  \"al_splits \\<alpha> invar splits\"\n  \"al_annot \\<alpha> invar annot\"\n  \"al_isEmpty \\<alpha> invar isEmpty\"\n  \"al_app \\<alpha> invar app\"\n  \"al_consr \\<alpha> invar consr\"\n  shows \n  \"uprio_insert (aluprio_\\<alpha> \\<alpha>) (aluprio_invar \\<alpha> invar) \n    (aluprio_insert splits annot isEmpty app consr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uprio_insert (aluprio_\\<alpha> \\<alpha>) (aluprio_invar \\<alpha> invar)\n     (aluprio_insert splits annot isEmpty app consr)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. uprio_insert (aluprio_\\<alpha> \\<alpha>) (aluprio_invar \\<alpha> invar)\n     (aluprio_insert splits annot isEmpty app consr)", "interpret al_splits \\<alpha> invar splits"], ["proof (prove)\ngoal (1 subgoal):\n 1. al_splits \\<alpha> invar splits", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. uprio_insert (aluprio_\\<alpha> \\<alpha>) (aluprio_invar \\<alpha> invar)\n     (aluprio_insert splits annot isEmpty app consr)", "interpret al_annot \\<alpha> invar annot"], ["proof (prove)\ngoal (1 subgoal):\n 1. al_annot \\<alpha> invar annot", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. uprio_insert (aluprio_\\<alpha> \\<alpha>) (aluprio_invar \\<alpha> invar)\n     (aluprio_insert splits annot isEmpty app consr)", "interpret al_isEmpty \\<alpha> invar isEmpty"], ["proof (prove)\ngoal (1 subgoal):\n 1. al_isEmpty \\<alpha> invar isEmpty", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. uprio_insert (aluprio_\\<alpha> \\<alpha>) (aluprio_invar \\<alpha> invar)\n     (aluprio_insert splits annot isEmpty app consr)", "interpret al_app \\<alpha> invar app"], ["proof (prove)\ngoal (1 subgoal):\n 1. al_app \\<alpha> invar app", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. uprio_insert (aluprio_\\<alpha> \\<alpha>) (aluprio_invar \\<alpha> invar)\n     (aluprio_insert splits annot isEmpty app consr)", "interpret al_consr \\<alpha> invar consr"], ["proof (prove)\ngoal (1 subgoal):\n 1. al_consr \\<alpha> invar consr", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. uprio_insert (aluprio_\\<alpha> \\<alpha>) (aluprio_invar \\<alpha> invar)\n     (aluprio_insert splits annot isEmpty app consr)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. uprio_insert (aluprio_\\<alpha> \\<alpha>) (aluprio_invar \\<alpha> invar)\n     (aluprio_insert splits annot isEmpty app consr)", "proof (unfold_locales, unfold aluprio_defs, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s e a.\n       invar s \\<and>\n       (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n       sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n       distinct\n        (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<Longrightarrow>\n       invar\n        (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n         then let (l, (uu_, lp), r) = splits (e_less_eq e) Infty s\n              in if e < fst (p_unwrap lp)\n                 then app (consr (consr l () (LP e a)) () lp) r\n                 else app (consr l () (LP e a)) r\n         else consr s () (LP e a)) \\<and>\n       (\\<forall>x\\<in>set (\\<alpha>\n                             (if e_less_eq e (annot s) \\<and>\n                                 \\<not> isEmpty s\n                              then let (l, (uu_, lp), r) =\n   splits (e_less_eq e) Infty s\n                                   in if e < fst (p_unwrap lp)\nthen app (consr (consr l () (LP e a)) () lp) r\nelse app (consr l () (LP e a)) r\n                              else consr s () (LP e a))).\n           snd x \\<noteq> Infty) \\<and>\n       sorted\n        (map fst\n          (map p_unwrap\n            (map snd\n              (\\<alpha>\n                (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n                 then let (l, (uu_, lp), r) = splits (e_less_eq e) Infty s\n                      in if e < fst (p_unwrap lp)\n                         then app (consr (consr l () (LP e a)) () lp) r\n                         else app (consr l () (LP e a)) r\n                 else consr s () (LP e a)))))) \\<and>\n       distinct\n        (map fst\n          (map p_unwrap\n            (map snd\n              (\\<alpha>\n                (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n                 then let (l, (uu_, lp), r) = splits (e_less_eq e) Infty s\n                      in if e < fst (p_unwrap lp)\n                         then app (consr (consr l () (LP e a)) () lp) r\n                         else app (consr l () (LP e a)) r\n                 else consr s () (LP e a))))))\n 2. \\<And>s e a.\n       invar s \\<and>\n       (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n       sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n       distinct\n        (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<Longrightarrow>\n       map_of\n        (map p_unwrap\n          (map snd\n            (\\<alpha>\n              (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n               then let (l, (uu_, lp), r) = splits (e_less_eq e) Infty s\n                    in if e < fst (p_unwrap lp)\n                       then app (consr (consr l () (LP e a)) () lp) r\n                       else app (consr l () (LP e a)) r\n               else consr s () (LP e a))))) =\n       map_of (map p_unwrap (map snd (\\<alpha> s)))(e \\<mapsto> a)", "case g1asms: (1 s e a)"], ["proof (state)\nthis:\n  invar s \\<and>\n  (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n  sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n  distinct (map fst (map p_unwrap (map snd (\\<alpha> s))))\n\ngoal (2 subgoals):\n 1. \\<And>s e a.\n       invar s \\<and>\n       (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n       sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n       distinct\n        (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<Longrightarrow>\n       invar\n        (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n         then let (l, (uu_, lp), r) = splits (e_less_eq e) Infty s\n              in if e < fst (p_unwrap lp)\n                 then app (consr (consr l () (LP e a)) () lp) r\n                 else app (consr l () (LP e a)) r\n         else consr s () (LP e a)) \\<and>\n       (\\<forall>x\\<in>set (\\<alpha>\n                             (if e_less_eq e (annot s) \\<and>\n                                 \\<not> isEmpty s\n                              then let (l, (uu_, lp), r) =\n   splits (e_less_eq e) Infty s\n                                   in if e < fst (p_unwrap lp)\nthen app (consr (consr l () (LP e a)) () lp) r\nelse app (consr l () (LP e a)) r\n                              else consr s () (LP e a))).\n           snd x \\<noteq> Infty) \\<and>\n       sorted\n        (map fst\n          (map p_unwrap\n            (map snd\n              (\\<alpha>\n                (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n                 then let (l, (uu_, lp), r) = splits (e_less_eq e) Infty s\n                      in if e < fst (p_unwrap lp)\n                         then app (consr (consr l () (LP e a)) () lp) r\n                         else app (consr l () (LP e a)) r\n                 else consr s () (LP e a)))))) \\<and>\n       distinct\n        (map fst\n          (map p_unwrap\n            (map snd\n              (\\<alpha>\n                (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n                 then let (l, (uu_, lp), r) = splits (e_less_eq e) Infty s\n                      in if e < fst (p_unwrap lp)\n                         then app (consr (consr l () (LP e a)) () lp) r\n                         else app (consr l () (LP e a)) r\n                 else consr s () (LP e a))))))\n 2. \\<And>s e a.\n       invar s \\<and>\n       (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n       sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n       distinct\n        (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<Longrightarrow>\n       map_of\n        (map p_unwrap\n          (map snd\n            (\\<alpha>\n              (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n               then let (l, (uu_, lp), r) = splits (e_less_eq e) Infty s\n                    in if e < fst (p_unwrap lp)\n                       then app (consr (consr l () (LP e a)) () lp) r\n                       else app (consr l () (LP e a)) r\n               else consr s () (LP e a))))) =\n       map_of (map p_unwrap (map snd (\\<alpha> s)))(e \\<mapsto> a)", "thus ?case"], ["proof (prove)\nusing this:\n  invar s \\<and>\n  (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n  sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n  distinct (map fst (map p_unwrap (map snd (\\<alpha> s))))\n\ngoal (1 subgoal):\n 1. invar\n     (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n      then let (l, (uu_, lp), r) = splits (e_less_eq e) Infty s\n           in if e < fst (p_unwrap lp)\n              then app (consr (consr l () (LP e a)) () lp) r\n              else app (consr l () (LP e a)) r\n      else consr s () (LP e a)) \\<and>\n    (\\<forall>x\\<in>set (\\<alpha>\n                          (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n                           then let (l, (uu_, lp), r) =\nsplits (e_less_eq e) Infty s\n                                in if e < fst (p_unwrap lp)\n                                   then app\n   (consr (consr l () (LP e a)) () lp) r\n                                   else app (consr l () (LP e a)) r\n                           else consr s () (LP e a))).\n        snd x \\<noteq> Infty) \\<and>\n    sorted\n     (map fst\n       (map p_unwrap\n         (map snd\n           (\\<alpha>\n             (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n              then let (l, (uu_, lp), r) = splits (e_less_eq e) Infty s\n                   in if e < fst (p_unwrap lp)\n                      then app (consr (consr l () (LP e a)) () lp) r\n                      else app (consr l () (LP e a)) r\n              else consr s () (LP e a)))))) \\<and>\n    distinct\n     (map fst\n       (map p_unwrap\n         (map snd\n           (\\<alpha>\n             (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n              then let (l, (uu_, lp), r) = splits (e_less_eq e) Infty s\n                   in if e < fst (p_unwrap lp)\n                      then app (consr (consr l () (LP e a)) () lp) r\n                      else app (consr l () (LP e a)) r\n              else consr s () (LP e a))))))", "proof (cases \"e_less_eq e (annot s) \\<and> \\<not> isEmpty s\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>invar s \\<and>\n             (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n             sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n             distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s\\<rbrakk>\n    \\<Longrightarrow> invar\n                       (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n                        then let (l, (uu_, lp), r) =\n                                   splits (e_less_eq e) Infty s\n                             in if e < fst (p_unwrap lp)\n                                then app (consr (consr l () (LP e a)) () lp)\nr\n                                else app (consr l () (LP e a)) r\n                        else consr s () (LP e a)) \\<and>\n                      (\\<forall>x\\<in>set\n (\\<alpha>\n   (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n    then let (l, (uu_, lp), r) = splits (e_less_eq e) Infty s\n         in if e < fst (p_unwrap lp)\n            then app (consr (consr l () (LP e a)) () lp) r\n            else app (consr l () (LP e a)) r\n    else consr s () (LP e a))).\n                          snd x \\<noteq> Infty) \\<and>\n                      sorted\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (if e_less_eq e (annot s) \\<and>\n                                   \\<not> isEmpty s\n                                then let (l, (uu_, lp), r) =\n     splits (e_less_eq e) Infty s\n                                     in if e < fst (p_unwrap lp)\n  then app (consr (consr l () (LP e a)) () lp) r\n  else app (consr l () (LP e a)) r\n                                else consr s () (LP e a)))))) \\<and>\n                      distinct\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (if e_less_eq e (annot s) \\<and>\n                                   \\<not> isEmpty s\n                                then let (l, (uu_, lp), r) =\n     splits (e_less_eq e) Infty s\n                                     in if e < fst (p_unwrap lp)\n  then app (consr (consr l () (LP e a)) () lp) r\n  else app (consr l () (LP e a)) r\n                                else consr s () (LP e a))))))\n 2. \\<lbrakk>invar s \\<and>\n             (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n             sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n             distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     \\<not> (e_less_eq e (annot s) \\<and> \\<not> isEmpty s)\\<rbrakk>\n    \\<Longrightarrow> invar\n                       (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n                        then let (l, (uu_, lp), r) =\n                                   splits (e_less_eq e) Infty s\n                             in if e < fst (p_unwrap lp)\n                                then app (consr (consr l () (LP e a)) () lp)\nr\n                                else app (consr l () (LP e a)) r\n                        else consr s () (LP e a)) \\<and>\n                      (\\<forall>x\\<in>set\n (\\<alpha>\n   (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n    then let (l, (uu_, lp), r) = splits (e_less_eq e) Infty s\n         in if e < fst (p_unwrap lp)\n            then app (consr (consr l () (LP e a)) () lp) r\n            else app (consr l () (LP e a)) r\n    else consr s () (LP e a))).\n                          snd x \\<noteq> Infty) \\<and>\n                      sorted\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (if e_less_eq e (annot s) \\<and>\n                                   \\<not> isEmpty s\n                                then let (l, (uu_, lp), r) =\n     splits (e_less_eq e) Infty s\n                                     in if e < fst (p_unwrap lp)\n  then app (consr (consr l () (LP e a)) () lp) r\n  else app (consr l () (LP e a)) r\n                                else consr s () (LP e a)))))) \\<and>\n                      distinct\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (if e_less_eq e (annot s) \\<and>\n                                   \\<not> isEmpty s\n                                then let (l, (uu_, lp), r) =\n     splits (e_less_eq e) Infty s\n                                     in if e < fst (p_unwrap lp)\n  then app (consr (consr l () (LP e a)) () lp) r\n  else app (consr l () (LP e a)) r\n                                else consr s () (LP e a))))))", "case False"], ["proof (state)\nthis:\n  \\<not> (e_less_eq e (annot s) \\<and> \\<not> isEmpty s)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>invar s \\<and>\n             (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n             sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n             distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s\\<rbrakk>\n    \\<Longrightarrow> invar\n                       (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n                        then let (l, (uu_, lp), r) =\n                                   splits (e_less_eq e) Infty s\n                             in if e < fst (p_unwrap lp)\n                                then app (consr (consr l () (LP e a)) () lp)\nr\n                                else app (consr l () (LP e a)) r\n                        else consr s () (LP e a)) \\<and>\n                      (\\<forall>x\\<in>set\n (\\<alpha>\n   (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n    then let (l, (uu_, lp), r) = splits (e_less_eq e) Infty s\n         in if e < fst (p_unwrap lp)\n            then app (consr (consr l () (LP e a)) () lp) r\n            else app (consr l () (LP e a)) r\n    else consr s () (LP e a))).\n                          snd x \\<noteq> Infty) \\<and>\n                      sorted\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (if e_less_eq e (annot s) \\<and>\n                                   \\<not> isEmpty s\n                                then let (l, (uu_, lp), r) =\n     splits (e_less_eq e) Infty s\n                                     in if e < fst (p_unwrap lp)\n  then app (consr (consr l () (LP e a)) () lp) r\n  else app (consr l () (LP e a)) r\n                                else consr s () (LP e a)))))) \\<and>\n                      distinct\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (if e_less_eq e (annot s) \\<and>\n                                   \\<not> isEmpty s\n                                then let (l, (uu_, lp), r) =\n     splits (e_less_eq e) Infty s\n                                     in if e < fst (p_unwrap lp)\n  then app (consr (consr l () (LP e a)) () lp) r\n  else app (consr l () (LP e a)) r\n                                else consr s () (LP e a))))))\n 2. \\<lbrakk>invar s \\<and>\n             (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n             sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n             distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     \\<not> (e_less_eq e (annot s) \\<and> \\<not> isEmpty s)\\<rbrakk>\n    \\<Longrightarrow> invar\n                       (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n                        then let (l, (uu_, lp), r) =\n                                   splits (e_less_eq e) Infty s\n                             in if e < fst (p_unwrap lp)\n                                then app (consr (consr l () (LP e a)) () lp)\nr\n                                else app (consr l () (LP e a)) r\n                        else consr s () (LP e a)) \\<and>\n                      (\\<forall>x\\<in>set\n (\\<alpha>\n   (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n    then let (l, (uu_, lp), r) = splits (e_less_eq e) Infty s\n         in if e < fst (p_unwrap lp)\n            then app (consr (consr l () (LP e a)) () lp) r\n            else app (consr l () (LP e a)) r\n    else consr s () (LP e a))).\n                          snd x \\<noteq> Infty) \\<and>\n                      sorted\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (if e_less_eq e (annot s) \\<and>\n                                   \\<not> isEmpty s\n                                then let (l, (uu_, lp), r) =\n     splits (e_less_eq e) Infty s\n                                     in if e < fst (p_unwrap lp)\n  then app (consr (consr l () (LP e a)) () lp) r\n  else app (consr l () (LP e a)) r\n                                else consr s () (LP e a)))))) \\<and>\n                      distinct\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (if e_less_eq e (annot s) \\<and>\n                                   \\<not> isEmpty s\n                                then let (l, (uu_, lp), r) =\n     splits (e_less_eq e) Infty s\n                                     in if e < fst (p_unwrap lp)\n  then app (consr (consr l () (LP e a)) () lp) r\n  else app (consr l () (LP e a)) r\n                                else consr s () (LP e a))))))", "with g1asms"], ["proof (chain)\npicking this:\n  invar s \\<and>\n  (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n  sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n  distinct (map fst (map p_unwrap (map snd (\\<alpha> s))))\n  \\<not> (e_less_eq e (annot s) \\<and> \\<not> isEmpty s)", "show  ?thesis"], ["proof (prove)\nusing this:\n  invar s \\<and>\n  (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n  sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n  distinct (map fst (map p_unwrap (map snd (\\<alpha> s))))\n  \\<not> (e_less_eq e (annot s) \\<and> \\<not> isEmpty s)\n\ngoal (1 subgoal):\n 1. invar\n     (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n      then let (l, (uu_, lp), r) = splits (e_less_eq e) Infty s\n           in if e < fst (p_unwrap lp)\n              then app (consr (consr l () (LP e a)) () lp) r\n              else app (consr l () (LP e a)) r\n      else consr s () (LP e a)) \\<and>\n    (\\<forall>x\\<in>set (\\<alpha>\n                          (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n                           then let (l, (uu_, lp), r) =\nsplits (e_less_eq e) Infty s\n                                in if e < fst (p_unwrap lp)\n                                   then app\n   (consr (consr l () (LP e a)) () lp) r\n                                   else app (consr l () (LP e a)) r\n                           else consr s () (LP e a))).\n        snd x \\<noteq> Infty) \\<and>\n    sorted\n     (map fst\n       (map p_unwrap\n         (map snd\n           (\\<alpha>\n             (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n              then let (l, (uu_, lp), r) = splits (e_less_eq e) Infty s\n                   in if e < fst (p_unwrap lp)\n                      then app (consr (consr l () (LP e a)) () lp) r\n                      else app (consr l () (LP e a)) r\n              else consr s () (LP e a)))))) \\<and>\n    distinct\n     (map fst\n       (map p_unwrap\n         (map snd\n           (\\<alpha>\n             (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n              then let (l, (uu_, lp), r) = splits (e_less_eq e) Infty s\n                   in if e < fst (p_unwrap lp)\n                      then app (consr (consr l () (LP e a)) () lp) r\n                      else app (consr l () (LP e a)) r\n              else consr s () (LP e a))))))", "apply (auto simp add: consr_correct )"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>invar s; \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty;\n     sorted\n      (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n        (\\<alpha> s));\n     distinct\n      (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n        (\\<alpha> s));\n     \\<not> e_less_eq e (annot s)\\<rbrakk>\n    \\<Longrightarrow> sorted\n                       (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap\n                              snd)\n                         (\\<alpha> s) @\n                        [e])\n 2. \\<And>b.\n       \\<lbrakk>invar s;\n        \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty;\n        sorted\n         (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n           (\\<alpha> s));\n        distinct\n         (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n           (\\<alpha> s));\n        \\<not> e_less_eq (fst (p_unwrap b)) (annot s);\n        ((), b) \\<in> set (\\<alpha> s); e = fst (p_unwrap b)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<lbrakk>invar s; \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty;\n     sorted\n      (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n        (\\<alpha> s));\n     distinct\n      (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n        (\\<alpha> s));\n     isEmpty s\\<rbrakk>\n    \\<Longrightarrow> sorted\n                       (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap\n                              snd)\n                         (\\<alpha> s) @\n                        [e])\n 4. \\<And>b.\n       \\<lbrakk>invar s;\n        \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty;\n        sorted\n         (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n           (\\<alpha> s));\n        distinct\n         (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n           (\\<alpha> s));\n        isEmpty s; e = fst (p_unwrap b);\n        ((), b) \\<in> set (\\<alpha> s)\\<rbrakk>\n       \\<Longrightarrow> False", "proof goal_cases"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>invar s; \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty;\n     sorted\n      (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n        (\\<alpha> s));\n     distinct\n      (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n        (\\<alpha> s));\n     \\<not> e_less_eq e (annot s)\\<rbrakk>\n    \\<Longrightarrow> sorted\n                       (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap\n                              snd)\n                         (\\<alpha> s) @\n                        [e])\n 2. \\<And>b.\n       \\<lbrakk>invar s;\n        \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty;\n        sorted\n         (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n           (\\<alpha> s));\n        distinct\n         (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n           (\\<alpha> s));\n        \\<not> e_less_eq (fst (p_unwrap b)) (annot s);\n        ((), b) \\<in> set (\\<alpha> s); e = fst (p_unwrap b)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<lbrakk>invar s; \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty;\n     sorted\n      (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n        (\\<alpha> s));\n     distinct\n      (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n        (\\<alpha> s));\n     isEmpty s\\<rbrakk>\n    \\<Longrightarrow> sorted\n                       (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap\n                              snd)\n                         (\\<alpha> s) @\n                        [e])\n 4. \\<And>b.\n       \\<lbrakk>invar s;\n        \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty;\n        sorted\n         (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n           (\\<alpha> s));\n        distinct\n         (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n           (\\<alpha> s));\n        isEmpty s; e = fst (p_unwrap b);\n        ((), b) \\<in> set (\\<alpha> s)\\<rbrakk>\n       \\<Longrightarrow> False", "case prems: 1"], ["proof (state)\nthis:\n  invar s\n  \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty\n  sorted\n   (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd) (\\<alpha> s))\n  distinct\n   (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd) (\\<alpha> s))\n  \\<not> e_less_eq e (annot s)\n\ngoal (4 subgoals):\n 1. \\<lbrakk>invar s; \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty;\n     sorted\n      (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n        (\\<alpha> s));\n     distinct\n      (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n        (\\<alpha> s));\n     \\<not> e_less_eq e (annot s)\\<rbrakk>\n    \\<Longrightarrow> sorted\n                       (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap\n                              snd)\n                         (\\<alpha> s) @\n                        [e])\n 2. \\<And>b.\n       \\<lbrakk>invar s;\n        \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty;\n        sorted\n         (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n           (\\<alpha> s));\n        distinct\n         (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n           (\\<alpha> s));\n        \\<not> e_less_eq (fst (p_unwrap b)) (annot s);\n        ((), b) \\<in> set (\\<alpha> s); e = fst (p_unwrap b)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<lbrakk>invar s; \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty;\n     sorted\n      (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n        (\\<alpha> s));\n     distinct\n      (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n        (\\<alpha> s));\n     isEmpty s\\<rbrakk>\n    \\<Longrightarrow> sorted\n                       (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap\n                              snd)\n                         (\\<alpha> s) @\n                        [e])\n 4. \\<And>b.\n       \\<lbrakk>invar s;\n        \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty;\n        sorted\n         (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n           (\\<alpha> s));\n        distinct\n         (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n           (\\<alpha> s));\n        isEmpty s; e = fst (p_unwrap b);\n        ((), b) \\<in> set (\\<alpha> s)\\<rbrakk>\n       \\<Longrightarrow> False", "with assms(2)"], ["proof (chain)\npicking this:\n  al_annot \\<alpha> invar annot\n  invar s\n  \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty\n  sorted\n   (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd) (\\<alpha> s))\n  distinct\n   (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd) (\\<alpha> s))\n  \\<not> e_less_eq e (annot s)", "have  \n          \"\\<forall>x \\<in> set (map (fst \\<circ> (p_unwrap \\<circ> snd)) (\\<alpha> s)). x < e\""], ["proof (prove)\nusing this:\n  al_annot \\<alpha> invar annot\n  invar s\n  \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty\n  sorted\n   (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd) (\\<alpha> s))\n  distinct\n   (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd) (\\<alpha> s))\n  \\<not> e_less_eq e (annot s)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap\n                              snd)\n                         (\\<alpha> s)).\n       x < e", "by (simp add: e_less_eq_annot)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap\n                            snd)\n                       (\\<alpha> s)).\n     x < e\n\ngoal (4 subgoals):\n 1. \\<lbrakk>invar s; \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty;\n     sorted\n      (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n        (\\<alpha> s));\n     distinct\n      (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n        (\\<alpha> s));\n     \\<not> e_less_eq e (annot s)\\<rbrakk>\n    \\<Longrightarrow> sorted\n                       (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap\n                              snd)\n                         (\\<alpha> s) @\n                        [e])\n 2. \\<And>b.\n       \\<lbrakk>invar s;\n        \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty;\n        sorted\n         (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n           (\\<alpha> s));\n        distinct\n         (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n           (\\<alpha> s));\n        \\<not> e_less_eq (fst (p_unwrap b)) (annot s);\n        ((), b) \\<in> set (\\<alpha> s); e = fst (p_unwrap b)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<lbrakk>invar s; \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty;\n     sorted\n      (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n        (\\<alpha> s));\n     distinct\n      (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n        (\\<alpha> s));\n     isEmpty s\\<rbrakk>\n    \\<Longrightarrow> sorted\n                       (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap\n                              snd)\n                         (\\<alpha> s) @\n                        [e])\n 4. \\<And>b.\n       \\<lbrakk>invar s;\n        \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty;\n        sorted\n         (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n           (\\<alpha> s));\n        distinct\n         (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n           (\\<alpha> s));\n        isEmpty s; e = fst (p_unwrap b);\n        ((), b) \\<in> set (\\<alpha> s)\\<rbrakk>\n       \\<Longrightarrow> False", "with prems(3)"], ["proof (chain)\npicking this:\n  sorted\n   (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd) (\\<alpha> s))\n  \\<forall>x\\<in>set (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap\n                            snd)\n                       (\\<alpha> s)).\n     x < e", "show ?case"], ["proof (prove)\nusing this:\n  sorted\n   (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd) (\\<alpha> s))\n  \\<forall>x\\<in>set (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap\n                            snd)\n                       (\\<alpha> s)).\n     x < e\n\ngoal (1 subgoal):\n 1. sorted\n     (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n       (\\<alpha> s) @\n      [e])", "by(auto simp add: sorted_append)"], ["proof (state)\nthis:\n  sorted\n   (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd) (\\<alpha> s) @\n    [e])\n\ngoal (3 subgoals):\n 1. \\<And>b.\n       \\<lbrakk>invar s;\n        \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty;\n        sorted\n         (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n           (\\<alpha> s));\n        distinct\n         (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n           (\\<alpha> s));\n        \\<not> e_less_eq (fst (p_unwrap b)) (annot s);\n        ((), b) \\<in> set (\\<alpha> s); e = fst (p_unwrap b)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<lbrakk>invar s; \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty;\n     sorted\n      (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n        (\\<alpha> s));\n     distinct\n      (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n        (\\<alpha> s));\n     isEmpty s\\<rbrakk>\n    \\<Longrightarrow> sorted\n                       (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap\n                              snd)\n                         (\\<alpha> s) @\n                        [e])\n 3. \\<And>b.\n       \\<lbrakk>invar s;\n        \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty;\n        sorted\n         (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n           (\\<alpha> s));\n        distinct\n         (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n           (\\<alpha> s));\n        isEmpty s; e = fst (p_unwrap b);\n        ((), b) \\<in> set (\\<alpha> s)\\<rbrakk>\n       \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>b.\n       \\<lbrakk>invar s;\n        \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty;\n        sorted\n         (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n           (\\<alpha> s));\n        distinct\n         (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n           (\\<alpha> s));\n        \\<not> e_less_eq (fst (p_unwrap b)) (annot s);\n        ((), b) \\<in> set (\\<alpha> s); e = fst (p_unwrap b)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<lbrakk>invar s; \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty;\n     sorted\n      (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n        (\\<alpha> s));\n     distinct\n      (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n        (\\<alpha> s));\n     isEmpty s\\<rbrakk>\n    \\<Longrightarrow> sorted\n                       (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap\n                              snd)\n                         (\\<alpha> s) @\n                        [e])\n 3. \\<And>b.\n       \\<lbrakk>invar s;\n        \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty;\n        sorted\n         (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n           (\\<alpha> s));\n        distinct\n         (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n           (\\<alpha> s));\n        isEmpty s; e = fst (p_unwrap b);\n        ((), b) \\<in> set (\\<alpha> s)\\<rbrakk>\n       \\<Longrightarrow> False", "case prems: 2"], ["proof (state)\nthis:\n  invar s\n  \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty\n  sorted\n   (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd) (\\<alpha> s))\n  distinct\n   (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd) (\\<alpha> s))\n  \\<not> e_less_eq (fst (p_unwrap b_)) (annot s)\n  ((), b_) \\<in> set (\\<alpha> s)\n  e = fst (p_unwrap b_)\n\ngoal (3 subgoals):\n 1. \\<And>b.\n       \\<lbrakk>invar s;\n        \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty;\n        sorted\n         (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n           (\\<alpha> s));\n        distinct\n         (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n           (\\<alpha> s));\n        \\<not> e_less_eq (fst (p_unwrap b)) (annot s);\n        ((), b) \\<in> set (\\<alpha> s); e = fst (p_unwrap b)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<lbrakk>invar s; \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty;\n     sorted\n      (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n        (\\<alpha> s));\n     distinct\n      (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n        (\\<alpha> s));\n     isEmpty s\\<rbrakk>\n    \\<Longrightarrow> sorted\n                       (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap\n                              snd)\n                         (\\<alpha> s) @\n                        [e])\n 3. \\<And>b.\n       \\<lbrakk>invar s;\n        \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty;\n        sorted\n         (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n           (\\<alpha> s));\n        distinct\n         (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n           (\\<alpha> s));\n        isEmpty s; e = fst (p_unwrap b);\n        ((), b) \\<in> set (\\<alpha> s)\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"annot s = sum_list (map snd (\\<alpha> s))\""], ["proof (prove)\nusing this:\n  invar s\n  \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty\n  sorted\n   (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd) (\\<alpha> s))\n  distinct\n   (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd) (\\<alpha> s))\n  \\<not> e_less_eq (fst (p_unwrap b_)) (annot s)\n  ((), b_) \\<in> set (\\<alpha> s)\n  e = fst (p_unwrap b_)\n\ngoal (1 subgoal):\n 1. annot s = sum_list (map snd (\\<alpha> s))", "by (simp add: annot_correct)"], ["proof (state)\nthis:\n  annot s = sum_list (map snd (\\<alpha> s))\n\ngoal (3 subgoals):\n 1. \\<And>b.\n       \\<lbrakk>invar s;\n        \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty;\n        sorted\n         (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n           (\\<alpha> s));\n        distinct\n         (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n           (\\<alpha> s));\n        \\<not> e_less_eq (fst (p_unwrap b)) (annot s);\n        ((), b) \\<in> set (\\<alpha> s); e = fst (p_unwrap b)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<lbrakk>invar s; \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty;\n     sorted\n      (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n        (\\<alpha> s));\n     distinct\n      (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n        (\\<alpha> s));\n     isEmpty s\\<rbrakk>\n    \\<Longrightarrow> sorted\n                       (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap\n                              snd)\n                         (\\<alpha> s) @\n                        [e])\n 3. \\<And>b.\n       \\<lbrakk>invar s;\n        \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty;\n        sorted\n         (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n           (\\<alpha> s));\n        distinct\n         (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n           (\\<alpha> s));\n        isEmpty s; e = fst (p_unwrap b);\n        ((), b) \\<in> set (\\<alpha> s)\\<rbrakk>\n       \\<Longrightarrow> False", "with prems"], ["proof (chain)\npicking this:\n  invar s\n  \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty\n  sorted\n   (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd) (\\<alpha> s))\n  distinct\n   (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd) (\\<alpha> s))\n  \\<not> e_less_eq (fst (p_unwrap b_)) (annot s)\n  ((), b_) \\<in> set (\\<alpha> s)\n  e = fst (p_unwrap b_)\n  annot s = sum_list (map snd (\\<alpha> s))", "show ?case"], ["proof (prove)\nusing this:\n  invar s\n  \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty\n  sorted\n   (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd) (\\<alpha> s))\n  distinct\n   (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd) (\\<alpha> s))\n  \\<not> e_less_eq (fst (p_unwrap b_)) (annot s)\n  ((), b_) \\<in> set (\\<alpha> s)\n  e = fst (p_unwrap b_)\n  annot s = sum_list (map snd (\\<alpha> s))\n\ngoal (1 subgoal):\n 1. False", "by (auto simp add: e_less_eq_sum_list2)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<lbrakk>invar s; \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty;\n     sorted\n      (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n        (\\<alpha> s));\n     distinct\n      (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n        (\\<alpha> s));\n     isEmpty s\\<rbrakk>\n    \\<Longrightarrow> sorted\n                       (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap\n                              snd)\n                         (\\<alpha> s) @\n                        [e])\n 2. \\<And>b.\n       \\<lbrakk>invar s;\n        \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty;\n        sorted\n         (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n           (\\<alpha> s));\n        distinct\n         (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n           (\\<alpha> s));\n        isEmpty s; e = fst (p_unwrap b);\n        ((), b) \\<in> set (\\<alpha> s)\\<rbrakk>\n       \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>invar s; \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty;\n     sorted\n      (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n        (\\<alpha> s));\n     distinct\n      (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n        (\\<alpha> s));\n     isEmpty s\\<rbrakk>\n    \\<Longrightarrow> sorted\n                       (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap\n                              snd)\n                         (\\<alpha> s) @\n                        [e])\n 2. \\<And>b.\n       \\<lbrakk>invar s;\n        \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty;\n        sorted\n         (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n           (\\<alpha> s));\n        distinct\n         (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n           (\\<alpha> s));\n        isEmpty s; e = fst (p_unwrap b);\n        ((), b) \\<in> set (\\<alpha> s)\\<rbrakk>\n       \\<Longrightarrow> False", "case prems: 3"], ["proof (state)\nthis:\n  invar s\n  \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty\n  sorted\n   (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd) (\\<alpha> s))\n  distinct\n   (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd) (\\<alpha> s))\n  isEmpty s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>invar s; \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty;\n     sorted\n      (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n        (\\<alpha> s));\n     distinct\n      (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n        (\\<alpha> s));\n     isEmpty s\\<rbrakk>\n    \\<Longrightarrow> sorted\n                       (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap\n                              snd)\n                         (\\<alpha> s) @\n                        [e])\n 2. \\<And>b.\n       \\<lbrakk>invar s;\n        \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty;\n        sorted\n         (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n           (\\<alpha> s));\n        distinct\n         (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n           (\\<alpha> s));\n        isEmpty s; e = fst (p_unwrap b);\n        ((), b) \\<in> set (\\<alpha> s)\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"\\<alpha> s = []\""], ["proof (prove)\nusing this:\n  invar s\n  \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty\n  sorted\n   (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd) (\\<alpha> s))\n  distinct\n   (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd) (\\<alpha> s))\n  isEmpty s\n\ngoal (1 subgoal):\n 1. \\<alpha> s = []", "by (auto simp add: isEmpty_correct)"], ["proof (state)\nthis:\n  \\<alpha> s = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>invar s; \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty;\n     sorted\n      (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n        (\\<alpha> s));\n     distinct\n      (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n        (\\<alpha> s));\n     isEmpty s\\<rbrakk>\n    \\<Longrightarrow> sorted\n                       (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap\n                              snd)\n                         (\\<alpha> s) @\n                        [e])\n 2. \\<And>b.\n       \\<lbrakk>invar s;\n        \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty;\n        sorted\n         (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n           (\\<alpha> s));\n        distinct\n         (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n           (\\<alpha> s));\n        isEmpty s; e = fst (p_unwrap b);\n        ((), b) \\<in> set (\\<alpha> s)\\<rbrakk>\n       \\<Longrightarrow> False", "thus ?case"], ["proof (prove)\nusing this:\n  \\<alpha> s = []\n\ngoal (1 subgoal):\n 1. sorted\n     (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n       (\\<alpha> s) @\n      [e])", "by simp"], ["proof (state)\nthis:\n  sorted\n   (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd) (\\<alpha> s) @\n    [e])\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>invar s;\n        \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty;\n        sorted\n         (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n           (\\<alpha> s));\n        distinct\n         (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n           (\\<alpha> s));\n        isEmpty s; e = fst (p_unwrap b);\n        ((), b) \\<in> set (\\<alpha> s)\\<rbrakk>\n       \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>invar s;\n        \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty;\n        sorted\n         (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n           (\\<alpha> s));\n        distinct\n         (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n           (\\<alpha> s));\n        isEmpty s; e = fst (p_unwrap b);\n        ((), b) \\<in> set (\\<alpha> s)\\<rbrakk>\n       \\<Longrightarrow> False", "case prems: 4"], ["proof (state)\nthis:\n  invar s\n  \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty\n  sorted\n   (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd) (\\<alpha> s))\n  distinct\n   (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd) (\\<alpha> s))\n  isEmpty s\n  e = fst (p_unwrap b_)\n  ((), b_) \\<in> set (\\<alpha> s)\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>invar s;\n        \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty;\n        sorted\n         (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n           (\\<alpha> s));\n        distinct\n         (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n           (\\<alpha> s));\n        isEmpty s; e = fst (p_unwrap b);\n        ((), b) \\<in> set (\\<alpha> s)\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"\\<alpha> s = []\""], ["proof (prove)\nusing this:\n  invar s\n  \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty\n  sorted\n   (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd) (\\<alpha> s))\n  distinct\n   (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd) (\\<alpha> s))\n  isEmpty s\n  e = fst (p_unwrap b_)\n  ((), b_) \\<in> set (\\<alpha> s)\n\ngoal (1 subgoal):\n 1. \\<alpha> s = []", "by (auto simp add: isEmpty_correct)"], ["proof (state)\nthis:\n  \\<alpha> s = []\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>invar s;\n        \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty;\n        sorted\n         (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n           (\\<alpha> s));\n        distinct\n         (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n           (\\<alpha> s));\n        isEmpty s; e = fst (p_unwrap b);\n        ((), b) \\<in> set (\\<alpha> s)\\<rbrakk>\n       \\<Longrightarrow> False", "with prems"], ["proof (chain)\npicking this:\n  invar s\n  \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty\n  sorted\n   (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd) (\\<alpha> s))\n  distinct\n   (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd) (\\<alpha> s))\n  isEmpty s\n  e = fst (p_unwrap b_)\n  ((), b_) \\<in> set (\\<alpha> s)\n  \\<alpha> s = []", "show ?case"], ["proof (prove)\nusing this:\n  invar s\n  \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty\n  sorted\n   (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd) (\\<alpha> s))\n  distinct\n   (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd) (\\<alpha> s))\n  isEmpty s\n  e = fst (p_unwrap b_)\n  ((), b_) \\<in> set (\\<alpha> s)\n  \\<alpha> s = []\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  invar\n   (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n    then let (l, (uu_, lp), r) = splits (e_less_eq e) Infty s\n         in if e < fst (p_unwrap lp)\n            then app (consr (consr l () (LP e a)) () lp) r\n            else app (consr l () (LP e a)) r\n    else consr s () (LP e a)) \\<and>\n  (\\<forall>x\\<in>set (\\<alpha>\n                        (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n                         then let (l, (uu_, lp), r) =\n                                    splits (e_less_eq e) Infty s\n                              in if e < fst (p_unwrap lp)\n                                 then app\n (consr (consr l () (LP e a)) () lp) r\n                                 else app (consr l () (LP e a)) r\n                         else consr s () (LP e a))).\n      snd x \\<noteq> Infty) \\<and>\n  sorted\n   (map fst\n     (map p_unwrap\n       (map snd\n         (\\<alpha>\n           (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n            then let (l, (uu_, lp), r) = splits (e_less_eq e) Infty s\n                 in if e < fst (p_unwrap lp)\n                    then app (consr (consr l () (LP e a)) () lp) r\n                    else app (consr l () (LP e a)) r\n            else consr s () (LP e a)))))) \\<and>\n  distinct\n   (map fst\n     (map p_unwrap\n       (map snd\n         (\\<alpha>\n           (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n            then let (l, (uu_, lp), r) = splits (e_less_eq e) Infty s\n                 in if e < fst (p_unwrap lp)\n                    then app (consr (consr l () (LP e a)) () lp) r\n                    else app (consr l () (LP e a)) r\n            else consr s () (LP e a))))))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>invar s \\<and>\n             (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n             sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n             distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s\\<rbrakk>\n    \\<Longrightarrow> invar\n                       (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n                        then let (l, (uu_, lp), r) =\n                                   splits (e_less_eq e) Infty s\n                             in if e < fst (p_unwrap lp)\n                                then app (consr (consr l () (LP e a)) () lp)\nr\n                                else app (consr l () (LP e a)) r\n                        else consr s () (LP e a)) \\<and>\n                      (\\<forall>x\\<in>set\n (\\<alpha>\n   (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n    then let (l, (uu_, lp), r) = splits (e_less_eq e) Infty s\n         in if e < fst (p_unwrap lp)\n            then app (consr (consr l () (LP e a)) () lp) r\n            else app (consr l () (LP e a)) r\n    else consr s () (LP e a))).\n                          snd x \\<noteq> Infty) \\<and>\n                      sorted\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (if e_less_eq e (annot s) \\<and>\n                                   \\<not> isEmpty s\n                                then let (l, (uu_, lp), r) =\n     splits (e_less_eq e) Infty s\n                                     in if e < fst (p_unwrap lp)\n  then app (consr (consr l () (LP e a)) () lp) r\n  else app (consr l () (LP e a)) r\n                                else consr s () (LP e a)))))) \\<and>\n                      distinct\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (if e_less_eq e (annot s) \\<and>\n                                   \\<not> isEmpty s\n                                then let (l, (uu_, lp), r) =\n     splits (e_less_eq e) Infty s\n                                     in if e < fst (p_unwrap lp)\n  then app (consr (consr l () (LP e a)) () lp) r\n  else app (consr l () (LP e a)) r\n                                else consr s () (LP e a))))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar s \\<and>\n             (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n             sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n             distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s\\<rbrakk>\n    \\<Longrightarrow> invar\n                       (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n                        then let (l, (uu_, lp), r) =\n                                   splits (e_less_eq e) Infty s\n                             in if e < fst (p_unwrap lp)\n                                then app (consr (consr l () (LP e a)) () lp)\nr\n                                else app (consr l () (LP e a)) r\n                        else consr s () (LP e a)) \\<and>\n                      (\\<forall>x\\<in>set\n (\\<alpha>\n   (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n    then let (l, (uu_, lp), r) = splits (e_less_eq e) Infty s\n         in if e < fst (p_unwrap lp)\n            then app (consr (consr l () (LP e a)) () lp) r\n            else app (consr l () (LP e a)) r\n    else consr s () (LP e a))).\n                          snd x \\<noteq> Infty) \\<and>\n                      sorted\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (if e_less_eq e (annot s) \\<and>\n                                   \\<not> isEmpty s\n                                then let (l, (uu_, lp), r) =\n     splits (e_less_eq e) Infty s\n                                     in if e < fst (p_unwrap lp)\n  then app (consr (consr l () (LP e a)) () lp) r\n  else app (consr l () (LP e a)) r\n                                else consr s () (LP e a)))))) \\<and>\n                      distinct\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (if e_less_eq e (annot s) \\<and>\n                                   \\<not> isEmpty s\n                                then let (l, (uu_, lp), r) =\n     splits (e_less_eq e) Infty s\n                                     in if e < fst (p_unwrap lp)\n  then app (consr (consr l () (LP e a)) () lp) r\n  else app (consr l () (LP e a)) r\n                                else consr s () (LP e a))))))", "case True"], ["proof (state)\nthis:\n  e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>invar s \\<and>\n             (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n             sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n             distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s\\<rbrakk>\n    \\<Longrightarrow> invar\n                       (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n                        then let (l, (uu_, lp), r) =\n                                   splits (e_less_eq e) Infty s\n                             in if e < fst (p_unwrap lp)\n                                then app (consr (consr l () (LP e a)) () lp)\nr\n                                else app (consr l () (LP e a)) r\n                        else consr s () (LP e a)) \\<and>\n                      (\\<forall>x\\<in>set\n (\\<alpha>\n   (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n    then let (l, (uu_, lp), r) = splits (e_less_eq e) Infty s\n         in if e < fst (p_unwrap lp)\n            then app (consr (consr l () (LP e a)) () lp) r\n            else app (consr l () (LP e a)) r\n    else consr s () (LP e a))).\n                          snd x \\<noteq> Infty) \\<and>\n                      sorted\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (if e_less_eq e (annot s) \\<and>\n                                   \\<not> isEmpty s\n                                then let (l, (uu_, lp), r) =\n     splits (e_less_eq e) Infty s\n                                     in if e < fst (p_unwrap lp)\n  then app (consr (consr l () (LP e a)) () lp) r\n  else app (consr l () (LP e a)) r\n                                else consr s () (LP e a)))))) \\<and>\n                      distinct\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (if e_less_eq e (annot s) \\<and>\n                                   \\<not> isEmpty s\n                                then let (l, (uu_, lp), r) =\n     splits (e_less_eq e) Infty s\n                                     in if e < fst (p_unwrap lp)\n  then app (consr (consr l () (LP e a)) () lp) r\n  else app (consr l () (LP e a)) r\n                                else consr s () (LP e a))))))", "note T1 = this"], ["proof (state)\nthis:\n  e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>invar s \\<and>\n             (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n             sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n             distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s\\<rbrakk>\n    \\<Longrightarrow> invar\n                       (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n                        then let (l, (uu_, lp), r) =\n                                   splits (e_less_eq e) Infty s\n                             in if e < fst (p_unwrap lp)\n                                then app (consr (consr l () (LP e a)) () lp)\nr\n                                else app (consr l () (LP e a)) r\n                        else consr s () (LP e a)) \\<and>\n                      (\\<forall>x\\<in>set\n (\\<alpha>\n   (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n    then let (l, (uu_, lp), r) = splits (e_less_eq e) Infty s\n         in if e < fst (p_unwrap lp)\n            then app (consr (consr l () (LP e a)) () lp) r\n            else app (consr l () (LP e a)) r\n    else consr s () (LP e a))).\n                          snd x \\<noteq> Infty) \\<and>\n                      sorted\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (if e_less_eq e (annot s) \\<and>\n                                   \\<not> isEmpty s\n                                then let (l, (uu_, lp), r) =\n     splits (e_less_eq e) Infty s\n                                     in if e < fst (p_unwrap lp)\n  then app (consr (consr l () (LP e a)) () lp) r\n  else app (consr l () (LP e a)) r\n                                else consr s () (LP e a)))))) \\<and>\n                      distinct\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (if e_less_eq e (annot s) \\<and>\n                                   \\<not> isEmpty s\n                                then let (l, (uu_, lp), r) =\n     splits (e_less_eq e) Infty s\n                                     in if e < fst (p_unwrap lp)\n  then app (consr (consr l () (LP e a)) () lp) r\n  else app (consr l () (LP e a)) r\n                                else consr s () (LP e a))))))", "obtain l uu lp r where \n        l_lp_r: \"(splits (e_less_eq e) Infty s) = (l, ((), lp), r) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l lp r.\n        splits (e_less_eq e) Infty s = (l, ((), lp), r) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"splits (e_less_eq e) Infty s\", auto)"], ["proof (state)\nthis:\n  splits (e_less_eq e) Infty s = (l, ((), lp), r)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>invar s \\<and>\n             (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n             sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n             distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s\\<rbrakk>\n    \\<Longrightarrow> invar\n                       (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n                        then let (l, (uu_, lp), r) =\n                                   splits (e_less_eq e) Infty s\n                             in if e < fst (p_unwrap lp)\n                                then app (consr (consr l () (LP e a)) () lp)\nr\n                                else app (consr l () (LP e a)) r\n                        else consr s () (LP e a)) \\<and>\n                      (\\<forall>x\\<in>set\n (\\<alpha>\n   (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n    then let (l, (uu_, lp), r) = splits (e_less_eq e) Infty s\n         in if e < fst (p_unwrap lp)\n            then app (consr (consr l () (LP e a)) () lp) r\n            else app (consr l () (LP e a)) r\n    else consr s () (LP e a))).\n                          snd x \\<noteq> Infty) \\<and>\n                      sorted\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (if e_less_eq e (annot s) \\<and>\n                                   \\<not> isEmpty s\n                                then let (l, (uu_, lp), r) =\n     splits (e_less_eq e) Infty s\n                                     in if e < fst (p_unwrap lp)\n  then app (consr (consr l () (LP e a)) () lp) r\n  else app (consr l () (LP e a)) r\n                                else consr s () (LP e a)))))) \\<and>\n                      distinct\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (if e_less_eq e (annot s) \\<and>\n                                   \\<not> isEmpty s\n                                then let (l, (uu_, lp), r) =\n     splits (e_less_eq e) Infty s\n                                     in if e < fst (p_unwrap lp)\n  then app (consr (consr l () (LP e a)) () lp) r\n  else app (consr l () (LP e a)) r\n                                else consr s () (LP e a))))))", "note v2 = splits_correct[of s \"e_less_eq e\" Infty l \"()\" lp r]"], ["proof (state)\nthis:\n  \\<lbrakk>invar s;\n   \\<forall>a b. e_less_eq e a \\<longrightarrow> e_less_eq e (a + b);\n   \\<not> e_less_eq e Infty;\n   e_less_eq e (Infty + sum_list (map snd (\\<alpha> s)));\n   splits (e_less_eq e) Infty s = (l, ((), lp), r)\\<rbrakk>\n  \\<Longrightarrow> \\<alpha> s = \\<alpha> l @ ((), lp) # \\<alpha> r \\<and>\n                    \\<not> e_less_eq e\n                            (Infty + sum_list (map snd (\\<alpha> l))) \\<and>\n                    e_less_eq e\n                     (Infty + sum_list (map snd (\\<alpha> l)) + lp) \\<and>\n                    invar l \\<and> invar r\n\ngoal (1 subgoal):\n 1. \\<lbrakk>invar s \\<and>\n             (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n             sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n             distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s\\<rbrakk>\n    \\<Longrightarrow> invar\n                       (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n                        then let (l, (uu_, lp), r) =\n                                   splits (e_less_eq e) Infty s\n                             in if e < fst (p_unwrap lp)\n                                then app (consr (consr l () (LP e a)) () lp)\nr\n                                else app (consr l () (LP e a)) r\n                        else consr s () (LP e a)) \\<and>\n                      (\\<forall>x\\<in>set\n (\\<alpha>\n   (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n    then let (l, (uu_, lp), r) = splits (e_less_eq e) Infty s\n         in if e < fst (p_unwrap lp)\n            then app (consr (consr l () (LP e a)) () lp) r\n            else app (consr l () (LP e a)) r\n    else consr s () (LP e a))).\n                          snd x \\<noteq> Infty) \\<and>\n                      sorted\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (if e_less_eq e (annot s) \\<and>\n                                   \\<not> isEmpty s\n                                then let (l, (uu_, lp), r) =\n     splits (e_less_eq e) Infty s\n                                     in if e < fst (p_unwrap lp)\n  then app (consr (consr l () (LP e a)) () lp) r\n  else app (consr l () (LP e a)) r\n                                else consr s () (LP e a)))))) \\<and>\n                      distinct\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (if e_less_eq e (annot s) \\<and>\n                                   \\<not> isEmpty s\n                                then let (l, (uu_, lp), r) =\n     splits (e_less_eq e) Infty s\n                                     in if e < fst (p_unwrap lp)\n  then app (consr (consr l () (LP e a)) () lp) r\n  else app (consr l () (LP e a)) r\n                                else consr s () (LP e a))))))", "have \n        v3: \"invar s\" \n        \"\\<not> e_less_eq e Infty\"\n        \"e_less_eq e (Infty + sum_list (map snd (\\<alpha> s)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar s &&&\n    \\<not> e_less_eq e Infty &&&\n    e_less_eq e (Infty + sum_list (map snd (\\<alpha> s)))", "using T1 g1asms annot_correct"], ["proof (prove)\nusing this:\n  e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n  invar s \\<and>\n  (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n  sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n  distinct (map fst (map p_unwrap (map snd (\\<alpha> s))))\n  invar ?s \\<Longrightarrow> annot ?s = sum_list (map snd (\\<alpha> ?s))\n\ngoal (1 subgoal):\n 1. invar s &&&\n    \\<not> e_less_eq e Infty &&&\n    e_less_eq e (Infty + sum_list (map snd (\\<alpha> s)))", "by (auto simp add: plus_def)"], ["proof (state)\nthis:\n  invar s\n  \\<not> e_less_eq e Infty\n  e_less_eq e (Infty + sum_list (map snd (\\<alpha> s)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>invar s \\<and>\n             (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n             sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n             distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s\\<rbrakk>\n    \\<Longrightarrow> invar\n                       (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n                        then let (l, (uu_, lp), r) =\n                                   splits (e_less_eq e) Infty s\n                             in if e < fst (p_unwrap lp)\n                                then app (consr (consr l () (LP e a)) () lp)\nr\n                                else app (consr l () (LP e a)) r\n                        else consr s () (LP e a)) \\<and>\n                      (\\<forall>x\\<in>set\n (\\<alpha>\n   (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n    then let (l, (uu_, lp), r) = splits (e_less_eq e) Infty s\n         in if e < fst (p_unwrap lp)\n            then app (consr (consr l () (LP e a)) () lp) r\n            else app (consr l () (LP e a)) r\n    else consr s () (LP e a))).\n                          snd x \\<noteq> Infty) \\<and>\n                      sorted\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (if e_less_eq e (annot s) \\<and>\n                                   \\<not> isEmpty s\n                                then let (l, (uu_, lp), r) =\n     splits (e_less_eq e) Infty s\n                                     in if e < fst (p_unwrap lp)\n  then app (consr (consr l () (LP e a)) () lp) r\n  else app (consr l () (LP e a)) r\n                                else consr s () (LP e a)))))) \\<and>\n                      distinct\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (if e_less_eq e (annot s) \\<and>\n                                   \\<not> isEmpty s\n                                then let (l, (uu_, lp), r) =\n     splits (e_less_eq e) Infty s\n                                     in if e < fst (p_unwrap lp)\n  then app (consr (consr l () (LP e a)) () lp) r\n  else app (consr l () (LP e a)) r\n                                else consr s () (LP e a))))))", "have \n        v4: \"\\<alpha> s = \\<alpha> l @ ((), lp) # \\<alpha> r\"  \n        \"\\<not> e_less_eq e (Infty + sum_list (map snd (\\<alpha> l)))\"\n        \"e_less_eq e (Infty + sum_list (map snd (\\<alpha> l)) + lp)\"\n        \"invar l\"\n        \"invar r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<alpha> s = \\<alpha> l @ ((), lp) # \\<alpha> r &&&\n     \\<not> e_less_eq e (Infty + sum_list (map snd (\\<alpha> l)))) &&&\n    e_less_eq e (Infty + sum_list (map snd (\\<alpha> l)) + lp) &&&\n    invar l &&& invar r", "using v2[OF v3(1) _ v3(2) v3(3) l_lp_r] e_less_eq_mon(1)"], ["proof (prove)\nusing this:\n  \\<forall>a b.\n     e_less_eq e a \\<longrightarrow> e_less_eq e (a + b) \\<Longrightarrow>\n  \\<alpha> s = \\<alpha> l @ ((), lp) # \\<alpha> r \\<and>\n  \\<not> e_less_eq e (Infty + sum_list (map snd (\\<alpha> l))) \\<and>\n  e_less_eq e (Infty + sum_list (map snd (\\<alpha> l)) + lp) \\<and>\n  invar l \\<and> invar r\n  e_less_eq ?e ?x \\<Longrightarrow> e_less_eq ?e (?x + ?y)\n\ngoal (1 subgoal):\n 1. (\\<alpha> s = \\<alpha> l @ ((), lp) # \\<alpha> r &&&\n     \\<not> e_less_eq e (Infty + sum_list (map snd (\\<alpha> l)))) &&&\n    e_less_eq e (Infty + sum_list (map snd (\\<alpha> l)) + lp) &&&\n    invar l &&& invar r", "by auto"], ["proof (state)\nthis:\n  \\<alpha> s = \\<alpha> l @ ((), lp) # \\<alpha> r\n  \\<not> e_less_eq e (Infty + sum_list (map snd (\\<alpha> l)))\n  e_less_eq e (Infty + sum_list (map snd (\\<alpha> l)) + lp)\n  invar l\n  invar r\n\ngoal (1 subgoal):\n 1. \\<lbrakk>invar s \\<and>\n             (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n             sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n             distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s\\<rbrakk>\n    \\<Longrightarrow> invar\n                       (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n                        then let (l, (uu_, lp), r) =\n                                   splits (e_less_eq e) Infty s\n                             in if e < fst (p_unwrap lp)\n                                then app (consr (consr l () (LP e a)) () lp)\nr\n                                else app (consr l () (LP e a)) r\n                        else consr s () (LP e a)) \\<and>\n                      (\\<forall>x\\<in>set\n (\\<alpha>\n   (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n    then let (l, (uu_, lp), r) = splits (e_less_eq e) Infty s\n         in if e < fst (p_unwrap lp)\n            then app (consr (consr l () (LP e a)) () lp) r\n            else app (consr l () (LP e a)) r\n    else consr s () (LP e a))).\n                          snd x \\<noteq> Infty) \\<and>\n                      sorted\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (if e_less_eq e (annot s) \\<and>\n                                   \\<not> isEmpty s\n                                then let (l, (uu_, lp), r) =\n     splits (e_less_eq e) Infty s\n                                     in if e < fst (p_unwrap lp)\n  then app (consr (consr l () (LP e a)) () lp) r\n  else app (consr l () (LP e a)) r\n                                else consr s () (LP e a)))))) \\<and>\n                      distinct\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (if e_less_eq e (annot s) \\<and>\n                                   \\<not> isEmpty s\n                                then let (l, (uu_, lp), r) =\n     splits (e_less_eq e) Infty s\n                                     in if e < fst (p_unwrap lp)\n  then app (consr (consr l () (LP e a)) () lp) r\n  else app (consr l () (LP e a)) r\n                                else consr s () (LP e a))))))", "hence v5: \"e_less_eq e lp\""], ["proof (prove)\nusing this:\n  \\<alpha> s = \\<alpha> l @ ((), lp) # \\<alpha> r\n  \\<not> e_less_eq e (Infty + sum_list (map snd (\\<alpha> l)))\n  e_less_eq e (Infty + sum_list (map snd (\\<alpha> l)) + lp)\n  invar l\n  invar r\n\ngoal (1 subgoal):\n 1. e_less_eq e lp", "by (metis e_less_eq_lem1)"], ["proof (state)\nthis:\n  e_less_eq e lp\n\ngoal (1 subgoal):\n 1. \\<lbrakk>invar s \\<and>\n             (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n             sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n             distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s\\<rbrakk>\n    \\<Longrightarrow> invar\n                       (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n                        then let (l, (uu_, lp), r) =\n                                   splits (e_less_eq e) Infty s\n                             in if e < fst (p_unwrap lp)\n                                then app (consr (consr l () (LP e a)) () lp)\nr\n                                else app (consr l () (LP e a)) r\n                        else consr s () (LP e a)) \\<and>\n                      (\\<forall>x\\<in>set\n (\\<alpha>\n   (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n    then let (l, (uu_, lp), r) = splits (e_less_eq e) Infty s\n         in if e < fst (p_unwrap lp)\n            then app (consr (consr l () (LP e a)) () lp) r\n            else app (consr l () (LP e a)) r\n    else consr s () (LP e a))).\n                          snd x \\<noteq> Infty) \\<and>\n                      sorted\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (if e_less_eq e (annot s) \\<and>\n                                   \\<not> isEmpty s\n                                then let (l, (uu_, lp), r) =\n     splits (e_less_eq e) Infty s\n                                     in if e < fst (p_unwrap lp)\n  then app (consr (consr l () (LP e a)) () lp) r\n  else app (consr l () (LP e a)) r\n                                else consr s () (LP e a)))))) \\<and>\n                      distinct\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (if e_less_eq e (annot s) \\<and>\n                                   \\<not> isEmpty s\n                                then let (l, (uu_, lp), r) =\n     splits (e_less_eq e) Infty s\n                                     in if e < fst (p_unwrap lp)\n  then app (consr (consr l () (LP e a)) () lp) r\n  else app (consr l () (LP e a)) r\n                                else consr s () (LP e a))))))", "hence v6: \"e \\<le> (fst (p_unwrap lp))\""], ["proof (prove)\nusing this:\n  e_less_eq e lp\n\ngoal (1 subgoal):\n 1. e \\<le> fst (p_unwrap lp)", "by (cases lp) auto"], ["proof (state)\nthis:\n  e \\<le> fst (p_unwrap lp)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>invar s \\<and>\n             (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n             sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n             distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s\\<rbrakk>\n    \\<Longrightarrow> invar\n                       (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n                        then let (l, (uu_, lp), r) =\n                                   splits (e_less_eq e) Infty s\n                             in if e < fst (p_unwrap lp)\n                                then app (consr (consr l () (LP e a)) () lp)\nr\n                                else app (consr l () (LP e a)) r\n                        else consr s () (LP e a)) \\<and>\n                      (\\<forall>x\\<in>set\n (\\<alpha>\n   (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n    then let (l, (uu_, lp), r) = splits (e_less_eq e) Infty s\n         in if e < fst (p_unwrap lp)\n            then app (consr (consr l () (LP e a)) () lp) r\n            else app (consr l () (LP e a)) r\n    else consr s () (LP e a))).\n                          snd x \\<noteq> Infty) \\<and>\n                      sorted\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (if e_less_eq e (annot s) \\<and>\n                                   \\<not> isEmpty s\n                                then let (l, (uu_, lp), r) =\n     splits (e_less_eq e) Infty s\n                                     in if e < fst (p_unwrap lp)\n  then app (consr (consr l () (LP e a)) () lp) r\n  else app (consr l () (LP e a)) r\n                                else consr s () (LP e a)))))) \\<and>\n                      distinct\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (if e_less_eq e (annot s) \\<and>\n                                   \\<not> isEmpty s\n                                then let (l, (uu_, lp), r) =\n     splits (e_less_eq e) Infty s\n                                     in if e < fst (p_unwrap lp)\n  then app (consr (consr l () (LP e a)) () lp) r\n  else app (consr l () (LP e a)) r\n                                else consr s () (LP e a))))))", "have \"(Infty + sum_list (map snd (\\<alpha> l))) = (annot l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Infty + sum_list (map snd (\\<alpha> l)) = annot l", "by (metis add_0_left annot_correct v4(4) zero_def)"], ["proof (state)\nthis:\n  Infty + sum_list (map snd (\\<alpha> l)) = annot l\n\ngoal (1 subgoal):\n 1. \\<lbrakk>invar s \\<and>\n             (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n             sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n             distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s\\<rbrakk>\n    \\<Longrightarrow> invar\n                       (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n                        then let (l, (uu_, lp), r) =\n                                   splits (e_less_eq e) Infty s\n                             in if e < fst (p_unwrap lp)\n                                then app (consr (consr l () (LP e a)) () lp)\nr\n                                else app (consr l () (LP e a)) r\n                        else consr s () (LP e a)) \\<and>\n                      (\\<forall>x\\<in>set\n (\\<alpha>\n   (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n    then let (l, (uu_, lp), r) = splits (e_less_eq e) Infty s\n         in if e < fst (p_unwrap lp)\n            then app (consr (consr l () (LP e a)) () lp) r\n            else app (consr l () (LP e a)) r\n    else consr s () (LP e a))).\n                          snd x \\<noteq> Infty) \\<and>\n                      sorted\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (if e_less_eq e (annot s) \\<and>\n                                   \\<not> isEmpty s\n                                then let (l, (uu_, lp), r) =\n     splits (e_less_eq e) Infty s\n                                     in if e < fst (p_unwrap lp)\n  then app (consr (consr l () (LP e a)) () lp) r\n  else app (consr l () (LP e a)) r\n                                else consr s () (LP e a)))))) \\<and>\n                      distinct\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (if e_less_eq e (annot s) \\<and>\n                                   \\<not> isEmpty s\n                                then let (l, (uu_, lp), r) =\n     splits (e_less_eq e) Infty s\n                                     in if e < fst (p_unwrap lp)\n  then app (consr (consr l () (LP e a)) () lp) r\n  else app (consr l () (LP e a)) r\n                                else consr s () (LP e a))))))", "hence v7:\"\\<not> e_less_eq e (annot l)\""], ["proof (prove)\nusing this:\n  Infty + sum_list (map snd (\\<alpha> l)) = annot l\n\ngoal (1 subgoal):\n 1. \\<not> e_less_eq e (annot l)", "using v4(2)"], ["proof (prove)\nusing this:\n  Infty + sum_list (map snd (\\<alpha> l)) = annot l\n  \\<not> e_less_eq e (Infty + sum_list (map snd (\\<alpha> l)))\n\ngoal (1 subgoal):\n 1. \\<not> e_less_eq e (annot l)", "by simp"], ["proof (state)\nthis:\n  \\<not> e_less_eq e (annot l)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>invar s \\<and>\n             (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n             sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n             distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s\\<rbrakk>\n    \\<Longrightarrow> invar\n                       (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n                        then let (l, (uu_, lp), r) =\n                                   splits (e_less_eq e) Infty s\n                             in if e < fst (p_unwrap lp)\n                                then app (consr (consr l () (LP e a)) () lp)\nr\n                                else app (consr l () (LP e a)) r\n                        else consr s () (LP e a)) \\<and>\n                      (\\<forall>x\\<in>set\n (\\<alpha>\n   (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n    then let (l, (uu_, lp), r) = splits (e_less_eq e) Infty s\n         in if e < fst (p_unwrap lp)\n            then app (consr (consr l () (LP e a)) () lp) r\n            else app (consr l () (LP e a)) r\n    else consr s () (LP e a))).\n                          snd x \\<noteq> Infty) \\<and>\n                      sorted\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (if e_less_eq e (annot s) \\<and>\n                                   \\<not> isEmpty s\n                                then let (l, (uu_, lp), r) =\n     splits (e_less_eq e) Infty s\n                                     in if e < fst (p_unwrap lp)\n  then app (consr (consr l () (LP e a)) () lp) r\n  else app (consr l () (LP e a)) r\n                                else consr s () (LP e a)))))) \\<and>\n                      distinct\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (if e_less_eq e (annot s) \\<and>\n                                   \\<not> isEmpty s\n                                then let (l, (uu_, lp), r) =\n     splits (e_less_eq e) Infty s\n                                     in if e < fst (p_unwrap lp)\n  then app (consr (consr l () (LP e a)) () lp) r\n  else app (consr l () (LP e a)) r\n                                else consr s () (LP e a))))))", "have \"\\<forall>x\\<in>set (\\<alpha> l). snd x \\<noteq> Infty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (\\<alpha> l). snd x \\<noteq> Infty", "using g1asms v4(1)"], ["proof (prove)\nusing this:\n  invar s \\<and>\n  (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n  sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n  distinct (map fst (map p_unwrap (map snd (\\<alpha> s))))\n  \\<alpha> s = \\<alpha> l @ ((), lp) # \\<alpha> r\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (\\<alpha> l). snd x \\<noteq> Infty", "by simp"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (\\<alpha> l). snd x \\<noteq> Infty\n\ngoal (1 subgoal):\n 1. \\<lbrakk>invar s \\<and>\n             (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n             sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n             distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s\\<rbrakk>\n    \\<Longrightarrow> invar\n                       (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n                        then let (l, (uu_, lp), r) =\n                                   splits (e_less_eq e) Infty s\n                             in if e < fst (p_unwrap lp)\n                                then app (consr (consr l () (LP e a)) () lp)\nr\n                                else app (consr l () (LP e a)) r\n                        else consr s () (LP e a)) \\<and>\n                      (\\<forall>x\\<in>set\n (\\<alpha>\n   (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n    then let (l, (uu_, lp), r) = splits (e_less_eq e) Infty s\n         in if e < fst (p_unwrap lp)\n            then app (consr (consr l () (LP e a)) () lp) r\n            else app (consr l () (LP e a)) r\n    else consr s () (LP e a))).\n                          snd x \\<noteq> Infty) \\<and>\n                      sorted\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (if e_less_eq e (annot s) \\<and>\n                                   \\<not> isEmpty s\n                                then let (l, (uu_, lp), r) =\n     splits (e_less_eq e) Infty s\n                                     in if e < fst (p_unwrap lp)\n  then app (consr (consr l () (LP e a)) () lp) r\n  else app (consr l () (LP e a)) r\n                                else consr s () (LP e a)))))) \\<and>\n                      distinct\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (if e_less_eq e (annot s) \\<and>\n                                   \\<not> isEmpty s\n                                then let (l, (uu_, lp), r) =\n     splits (e_less_eq e) Infty s\n                                     in if e < fst (p_unwrap lp)\n  then app (consr (consr l () (LP e a)) () lp) r\n  else app (consr l () (LP e a)) r\n                                else consr s () (LP e a))))))", "hence v7: \"\\<forall>x \\<in> set (map (fst \\<circ> (p_unwrap \\<circ> snd)) (\\<alpha> l)). x < e\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set (\\<alpha> l). snd x \\<noteq> Infty\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap\n                              snd)\n                         (\\<alpha> l)).\n       x < e", "using v4(4) v7 assms(2)"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set (\\<alpha> l). snd x \\<noteq> Infty\n  invar l\n  \\<not> e_less_eq e (annot l)\n  al_annot \\<alpha> invar annot\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap\n                              snd)\n                         (\\<alpha> l)).\n       x < e", "by(simp add: e_less_eq_annot)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap\n                            snd)\n                       (\\<alpha> l)).\n     x < e\n\ngoal (1 subgoal):\n 1. \\<lbrakk>invar s \\<and>\n             (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n             sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n             distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s\\<rbrakk>\n    \\<Longrightarrow> invar\n                       (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n                        then let (l, (uu_, lp), r) =\n                                   splits (e_less_eq e) Infty s\n                             in if e < fst (p_unwrap lp)\n                                then app (consr (consr l () (LP e a)) () lp)\nr\n                                else app (consr l () (LP e a)) r\n                        else consr s () (LP e a)) \\<and>\n                      (\\<forall>x\\<in>set\n (\\<alpha>\n   (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n    then let (l, (uu_, lp), r) = splits (e_less_eq e) Infty s\n         in if e < fst (p_unwrap lp)\n            then app (consr (consr l () (LP e a)) () lp) r\n            else app (consr l () (LP e a)) r\n    else consr s () (LP e a))).\n                          snd x \\<noteq> Infty) \\<and>\n                      sorted\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (if e_less_eq e (annot s) \\<and>\n                                   \\<not> isEmpty s\n                                then let (l, (uu_, lp), r) =\n     splits (e_less_eq e) Infty s\n                                     in if e < fst (p_unwrap lp)\n  then app (consr (consr l () (LP e a)) () lp) r\n  else app (consr l () (LP e a)) r\n                                else consr s () (LP e a)))))) \\<and>\n                      distinct\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (if e_less_eq e (annot s) \\<and>\n                                   \\<not> isEmpty s\n                                then let (l, (uu_, lp), r) =\n     splits (e_less_eq e) Infty s\n                                     in if e < fst (p_unwrap lp)\n  then app (consr (consr l () (LP e a)) () lp) r\n  else app (consr l () (LP e a)) r\n                                else consr s () (LP e a))))))", "have v8:\"map fst (map p_unwrap (map snd (\\<alpha> s))) = \n        map fst (map p_unwrap (map snd (\\<alpha> l))) @ fst(p_unwrap lp) #\n        map fst (map p_unwrap (map snd (\\<alpha> r)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map fst (map p_unwrap (map snd (\\<alpha> s))) =\n    map fst (map p_unwrap (map snd (\\<alpha> l))) @\n    fst (p_unwrap lp) # map fst (map p_unwrap (map snd (\\<alpha> r)))", "using v4(1)"], ["proof (prove)\nusing this:\n  \\<alpha> s = \\<alpha> l @ ((), lp) # \\<alpha> r\n\ngoal (1 subgoal):\n 1. map fst (map p_unwrap (map snd (\\<alpha> s))) =\n    map fst (map p_unwrap (map snd (\\<alpha> l))) @\n    fst (p_unwrap lp) # map fst (map p_unwrap (map snd (\\<alpha> r)))", "by simp"], ["proof (state)\nthis:\n  map fst (map p_unwrap (map snd (\\<alpha> s))) =\n  map fst (map p_unwrap (map snd (\\<alpha> l))) @\n  fst (p_unwrap lp) # map fst (map p_unwrap (map snd (\\<alpha> r)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>invar s \\<and>\n             (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n             sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n             distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s\\<rbrakk>\n    \\<Longrightarrow> invar\n                       (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n                        then let (l, (uu_, lp), r) =\n                                   splits (e_less_eq e) Infty s\n                             in if e < fst (p_unwrap lp)\n                                then app (consr (consr l () (LP e a)) () lp)\nr\n                                else app (consr l () (LP e a)) r\n                        else consr s () (LP e a)) \\<and>\n                      (\\<forall>x\\<in>set\n (\\<alpha>\n   (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n    then let (l, (uu_, lp), r) = splits (e_less_eq e) Infty s\n         in if e < fst (p_unwrap lp)\n            then app (consr (consr l () (LP e a)) () lp) r\n            else app (consr l () (LP e a)) r\n    else consr s () (LP e a))).\n                          snd x \\<noteq> Infty) \\<and>\n                      sorted\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (if e_less_eq e (annot s) \\<and>\n                                   \\<not> isEmpty s\n                                then let (l, (uu_, lp), r) =\n     splits (e_less_eq e) Infty s\n                                     in if e < fst (p_unwrap lp)\n  then app (consr (consr l () (LP e a)) () lp) r\n  else app (consr l () (LP e a)) r\n                                else consr s () (LP e a)))))) \\<and>\n                      distinct\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (if e_less_eq e (annot s) \\<and>\n                                   \\<not> isEmpty s\n                                then let (l, (uu_, lp), r) =\n     splits (e_less_eq e) Infty s\n                                     in if e < fst (p_unwrap lp)\n  then app (consr (consr l () (LP e a)) () lp) r\n  else app (consr l () (LP e a)) r\n                                else consr s () (LP e a))))))", "note distinct_sortet_list_app[of \"map fst (map p_unwrap (map snd (\\<alpha> s)))\"\n        \"map fst (map p_unwrap (map snd (\\<alpha> l)))\" \"fst(p_unwrap lp)\" \n        \"map fst (map p_unwrap (map snd (\\<alpha> r)))\"]"], ["proof (state)\nthis:\n  \\<lbrakk>sorted (map fst (map p_unwrap (map snd (\\<alpha> s))));\n   distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n   map fst (map p_unwrap (map snd (\\<alpha> s))) =\n   map fst (map p_unwrap (map snd (\\<alpha> l))) @\n   fst (p_unwrap lp) #\n   map fst (map p_unwrap (map snd (\\<alpha> r)))\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x\\<in>set (map fst\n   (map p_unwrap (map snd (\\<alpha> r)))).\n                       fst (p_unwrap lp) < x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>invar s \\<and>\n             (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n             sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n             distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s\\<rbrakk>\n    \\<Longrightarrow> invar\n                       (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n                        then let (l, (uu_, lp), r) =\n                                   splits (e_less_eq e) Infty s\n                             in if e < fst (p_unwrap lp)\n                                then app (consr (consr l () (LP e a)) () lp)\nr\n                                else app (consr l () (LP e a)) r\n                        else consr s () (LP e a)) \\<and>\n                      (\\<forall>x\\<in>set\n (\\<alpha>\n   (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n    then let (l, (uu_, lp), r) = splits (e_less_eq e) Infty s\n         in if e < fst (p_unwrap lp)\n            then app (consr (consr l () (LP e a)) () lp) r\n            else app (consr l () (LP e a)) r\n    else consr s () (LP e a))).\n                          snd x \\<noteq> Infty) \\<and>\n                      sorted\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (if e_less_eq e (annot s) \\<and>\n                                   \\<not> isEmpty s\n                                then let (l, (uu_, lp), r) =\n     splits (e_less_eq e) Infty s\n                                     in if e < fst (p_unwrap lp)\n  then app (consr (consr l () (LP e a)) () lp) r\n  else app (consr l () (LP e a)) r\n                                else consr s () (LP e a)))))) \\<and>\n                      distinct\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (if e_less_eq e (annot s) \\<and>\n                                   \\<not> isEmpty s\n                                then let (l, (uu_, lp), r) =\n     splits (e_less_eq e) Infty s\n                                     in if e < fst (p_unwrap lp)\n  then app (consr (consr l () (LP e a)) () lp) r\n  else app (consr l () (LP e a)) r\n                                else consr s () (LP e a))))))", "hence v9: \n        \"\\<forall> x\\<in>set (map (fst \\<circ> (p_unwrap \\<circ> snd)) (\\<alpha> r)). fst(p_unwrap lp) < x\""], ["proof (prove)\nusing this:\n  \\<lbrakk>sorted (map fst (map p_unwrap (map snd (\\<alpha> s))));\n   distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n   map fst (map p_unwrap (map snd (\\<alpha> s))) =\n   map fst (map p_unwrap (map snd (\\<alpha> l))) @\n   fst (p_unwrap lp) #\n   map fst (map p_unwrap (map snd (\\<alpha> r)))\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x\\<in>set (map fst\n   (map p_unwrap (map snd (\\<alpha> r)))).\n                       fst (p_unwrap lp) < x\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap\n                              snd)\n                         (\\<alpha> r)).\n       fst (p_unwrap lp) < x", "using v4(1) g1asms v8"], ["proof (prove)\nusing this:\n  \\<lbrakk>sorted (map fst (map p_unwrap (map snd (\\<alpha> s))));\n   distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n   map fst (map p_unwrap (map snd (\\<alpha> s))) =\n   map fst (map p_unwrap (map snd (\\<alpha> l))) @\n   fst (p_unwrap lp) #\n   map fst (map p_unwrap (map snd (\\<alpha> r)))\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x\\<in>set (map fst\n   (map p_unwrap (map snd (\\<alpha> r)))).\n                       fst (p_unwrap lp) < x\n  \\<alpha> s = \\<alpha> l @ ((), lp) # \\<alpha> r\n  invar s \\<and>\n  (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n  sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n  distinct (map fst (map p_unwrap (map snd (\\<alpha> s))))\n  map fst (map p_unwrap (map snd (\\<alpha> s))) =\n  map fst (map p_unwrap (map snd (\\<alpha> l))) @\n  fst (p_unwrap lp) # map fst (map p_unwrap (map snd (\\<alpha> r)))\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap\n                              snd)\n                         (\\<alpha> r)).\n       fst (p_unwrap lp) < x", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap\n                            snd)\n                       (\\<alpha> r)).\n     fst (p_unwrap lp) < x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>invar s \\<and>\n             (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n             sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n             distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s\\<rbrakk>\n    \\<Longrightarrow> invar\n                       (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n                        then let (l, (uu_, lp), r) =\n                                   splits (e_less_eq e) Infty s\n                             in if e < fst (p_unwrap lp)\n                                then app (consr (consr l () (LP e a)) () lp)\nr\n                                else app (consr l () (LP e a)) r\n                        else consr s () (LP e a)) \\<and>\n                      (\\<forall>x\\<in>set\n (\\<alpha>\n   (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n    then let (l, (uu_, lp), r) = splits (e_less_eq e) Infty s\n         in if e < fst (p_unwrap lp)\n            then app (consr (consr l () (LP e a)) () lp) r\n            else app (consr l () (LP e a)) r\n    else consr s () (LP e a))).\n                          snd x \\<noteq> Infty) \\<and>\n                      sorted\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (if e_less_eq e (annot s) \\<and>\n                                   \\<not> isEmpty s\n                                then let (l, (uu_, lp), r) =\n     splits (e_less_eq e) Infty s\n                                     in if e < fst (p_unwrap lp)\n  then app (consr (consr l () (LP e a)) () lp) r\n  else app (consr l () (LP e a)) r\n                                else consr s () (LP e a)))))) \\<and>\n                      distinct\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (if e_less_eq e (annot s) \\<and>\n                                   \\<not> isEmpty s\n                                then let (l, (uu_, lp), r) =\n     splits (e_less_eq e) Infty s\n                                     in if e < fst (p_unwrap lp)\n  then app (consr (consr l () (LP e a)) () lp) r\n  else app (consr l () (LP e a)) r\n                                else consr s () (LP e a))))))", "have v10: \n        \"sorted (map fst (map p_unwrap (map snd (\\<alpha> l))))\"\n        \"distinct (map fst (map p_unwrap (map snd (\\<alpha> l))))\"\n        \"sorted (map fst (map p_unwrap (map snd (\\<alpha> r))))\"\n        \"distinct (map fst (map p_unwrap (map snd (\\<alpha> l))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sorted (map fst (map p_unwrap (map snd (\\<alpha> l)))) &&&\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> l))))) &&&\n    sorted (map fst (map p_unwrap (map snd (\\<alpha> r)))) &&&\n    distinct (map fst (map p_unwrap (map snd (\\<alpha> l))))", "using g1asms v8"], ["proof (prove)\nusing this:\n  invar s \\<and>\n  (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n  sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n  distinct (map fst (map p_unwrap (map snd (\\<alpha> s))))\n  map fst (map p_unwrap (map snd (\\<alpha> s))) =\n  map fst (map p_unwrap (map snd (\\<alpha> l))) @\n  fst (p_unwrap lp) # map fst (map p_unwrap (map snd (\\<alpha> r)))\n\ngoal (1 subgoal):\n 1. (sorted (map fst (map p_unwrap (map snd (\\<alpha> l)))) &&&\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> l))))) &&&\n    sorted (map fst (map p_unwrap (map snd (\\<alpha> r)))) &&&\n    distinct (map fst (map p_unwrap (map snd (\\<alpha> l))))", "by (auto simp add: sorted_append)"], ["proof (state)\nthis:\n  sorted (map fst (map p_unwrap (map snd (\\<alpha> l))))\n  distinct (map fst (map p_unwrap (map snd (\\<alpha> l))))\n  sorted (map fst (map p_unwrap (map snd (\\<alpha> r))))\n  distinct (map fst (map p_unwrap (map snd (\\<alpha> l))))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>invar s \\<and>\n             (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n             sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n             distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s\\<rbrakk>\n    \\<Longrightarrow> invar\n                       (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n                        then let (l, (uu_, lp), r) =\n                                   splits (e_less_eq e) Infty s\n                             in if e < fst (p_unwrap lp)\n                                then app (consr (consr l () (LP e a)) () lp)\nr\n                                else app (consr l () (LP e a)) r\n                        else consr s () (LP e a)) \\<and>\n                      (\\<forall>x\\<in>set\n (\\<alpha>\n   (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n    then let (l, (uu_, lp), r) = splits (e_less_eq e) Infty s\n         in if e < fst (p_unwrap lp)\n            then app (consr (consr l () (LP e a)) () lp) r\n            else app (consr l () (LP e a)) r\n    else consr s () (LP e a))).\n                          snd x \\<noteq> Infty) \\<and>\n                      sorted\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (if e_less_eq e (annot s) \\<and>\n                                   \\<not> isEmpty s\n                                then let (l, (uu_, lp), r) =\n     splits (e_less_eq e) Infty s\n                                     in if e < fst (p_unwrap lp)\n  then app (consr (consr l () (LP e a)) () lp) r\n  else app (consr l () (LP e a)) r\n                                else consr s () (LP e a)))))) \\<and>\n                      distinct\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (if e_less_eq e (annot s) \\<and>\n                                   \\<not> isEmpty s\n                                then let (l, (uu_, lp), r) =\n     splits (e_less_eq e) Infty s\n                                     in if e < fst (p_unwrap lp)\n  then app (consr (consr l () (LP e a)) () lp) r\n  else app (consr l () (LP e a)) r\n                                else consr s () (LP e a))))))", "from l_lp_r T1 g1asms"], ["proof (chain)\npicking this:\n  splits (e_less_eq e) Infty s = (l, ((), lp), r)\n  e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n  invar s \\<and>\n  (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n  sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n  distinct (map fst (map p_unwrap (map snd (\\<alpha> s))))", "show ?thesis"], ["proof (prove)\nusing this:\n  splits (e_less_eq e) Infty s = (l, ((), lp), r)\n  e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n  invar s \\<and>\n  (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n  sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n  distinct (map fst (map p_unwrap (map snd (\\<alpha> s))))\n\ngoal (1 subgoal):\n 1. invar\n     (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n      then let (l, (uu_, lp), r) = splits (e_less_eq e) Infty s\n           in if e < fst (p_unwrap lp)\n              then app (consr (consr l () (LP e a)) () lp) r\n              else app (consr l () (LP e a)) r\n      else consr s () (LP e a)) \\<and>\n    (\\<forall>x\\<in>set (\\<alpha>\n                          (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n                           then let (l, (uu_, lp), r) =\nsplits (e_less_eq e) Infty s\n                                in if e < fst (p_unwrap lp)\n                                   then app\n   (consr (consr l () (LP e a)) () lp) r\n                                   else app (consr l () (LP e a)) r\n                           else consr s () (LP e a))).\n        snd x \\<noteq> Infty) \\<and>\n    sorted\n     (map fst\n       (map p_unwrap\n         (map snd\n           (\\<alpha>\n             (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n              then let (l, (uu_, lp), r) = splits (e_less_eq e) Infty s\n                   in if e < fst (p_unwrap lp)\n                      then app (consr (consr l () (LP e a)) () lp) r\n                      else app (consr l () (LP e a)) r\n              else consr s () (LP e a)))))) \\<and>\n    distinct\n     (map fst\n       (map p_unwrap\n         (map snd\n           (\\<alpha>\n             (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n              then let (l, (uu_, lp), r) = splits (e_less_eq e) Infty s\n                   in if e < fst (p_unwrap lp)\n                      then app (consr (consr l () (LP e a)) () lp) r\n                      else app (consr l () (LP e a)) r\n              else consr s () (LP e a))))))", "proof (fold aluprio_insert_def, cases \"e < fst (p_unwrap lp)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     e < fst (p_unwrap lp)\\<rbrakk>\n    \\<Longrightarrow> invar\n                       (aluprio_insert splits annot isEmpty app consr s e\n                         a) \\<and>\n                      (\\<forall>x\\<in>set\n (\\<alpha> (aluprio_insert splits annot isEmpty app consr s e a)).\n                          snd x \\<noteq> Infty) \\<and>\n                      sorted\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (aluprio_insert splits annot isEmpty app\n                                 consr s e a))))) \\<and>\n                      distinct\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (aluprio_insert splits annot isEmpty app\n                                 consr s e a)))))\n 2. \\<lbrakk>splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     \\<not> e < fst (p_unwrap lp)\\<rbrakk>\n    \\<Longrightarrow> invar\n                       (aluprio_insert splits annot isEmpty app consr s e\n                         a) \\<and>\n                      (\\<forall>x\\<in>set\n (\\<alpha> (aluprio_insert splits annot isEmpty app consr s e a)).\n                          snd x \\<noteq> Infty) \\<and>\n                      sorted\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (aluprio_insert splits annot isEmpty app\n                                 consr s e a))))) \\<and>\n                      distinct\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (aluprio_insert splits annot isEmpty app\n                                 consr s e a)))))", "case True"], ["proof (state)\nthis:\n  e < fst (p_unwrap lp)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     e < fst (p_unwrap lp)\\<rbrakk>\n    \\<Longrightarrow> invar\n                       (aluprio_insert splits annot isEmpty app consr s e\n                         a) \\<and>\n                      (\\<forall>x\\<in>set\n (\\<alpha> (aluprio_insert splits annot isEmpty app consr s e a)).\n                          snd x \\<noteq> Infty) \\<and>\n                      sorted\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (aluprio_insert splits annot isEmpty app\n                                 consr s e a))))) \\<and>\n                      distinct\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (aluprio_insert splits annot isEmpty app\n                                 consr s e a)))))\n 2. \\<lbrakk>splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     \\<not> e < fst (p_unwrap lp)\\<rbrakk>\n    \\<Longrightarrow> invar\n                       (aluprio_insert splits annot isEmpty app consr s e\n                         a) \\<and>\n                      (\\<forall>x\\<in>set\n (\\<alpha> (aluprio_insert splits annot isEmpty app consr s e a)).\n                          snd x \\<noteq> Infty) \\<and>\n                      sorted\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (aluprio_insert splits annot isEmpty app\n                                 consr s e a))))) \\<and>\n                      distinct\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (aluprio_insert splits annot isEmpty app\n                                 consr s e a)))))", "hence v11: \n          \"aluprio_insert splits annot isEmpty app consr s e a \n            = app (consr (consr l () (LP e a)) () lp) r\""], ["proof (prove)\nusing this:\n  e < fst (p_unwrap lp)\n\ngoal (1 subgoal):\n 1. aluprio_insert splits annot isEmpty app consr s e a =\n    app (consr (consr l () (LP e a)) () lp) r", "using l_lp_r T1"], ["proof (prove)\nusing this:\n  e < fst (p_unwrap lp)\n  splits (e_less_eq e) Infty s = (l, ((), lp), r)\n  e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n\ngoal (1 subgoal):\n 1. aluprio_insert splits annot isEmpty app consr s e a =\n    app (consr (consr l () (LP e a)) () lp) r", "by (auto simp add: aluprio_defs)"], ["proof (state)\nthis:\n  aluprio_insert splits annot isEmpty app consr s e a =\n  app (consr (consr l () (LP e a)) () lp) r\n\ngoal (2 subgoals):\n 1. \\<lbrakk>splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     e < fst (p_unwrap lp)\\<rbrakk>\n    \\<Longrightarrow> invar\n                       (aluprio_insert splits annot isEmpty app consr s e\n                         a) \\<and>\n                      (\\<forall>x\\<in>set\n (\\<alpha> (aluprio_insert splits annot isEmpty app consr s e a)).\n                          snd x \\<noteq> Infty) \\<and>\n                      sorted\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (aluprio_insert splits annot isEmpty app\n                                 consr s e a))))) \\<and>\n                      distinct\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (aluprio_insert splits annot isEmpty app\n                                 consr s e a)))))\n 2. \\<lbrakk>splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     \\<not> e < fst (p_unwrap lp)\\<rbrakk>\n    \\<Longrightarrow> invar\n                       (aluprio_insert splits annot isEmpty app consr s e\n                         a) \\<and>\n                      (\\<forall>x\\<in>set\n (\\<alpha> (aluprio_insert splits annot isEmpty app consr s e a)).\n                          snd x \\<noteq> Infty) \\<and>\n                      sorted\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (aluprio_insert splits annot isEmpty app\n                                 consr s e a))))) \\<and>\n                      distinct\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (aluprio_insert splits annot isEmpty app\n                                 consr s e a)))))", "have  v12: \"invar (app (consr (consr l () (LP e a)) () lp) r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar (app (consr (consr l () (LP e a)) () lp) r)", "using v4(4,5)"], ["proof (prove)\nusing this:\n  invar l\n  invar r\n\ngoal (1 subgoal):\n 1. invar (app (consr (consr l () (LP e a)) () lp) r)", "by (auto simp add: app_correct consr_correct)"], ["proof (state)\nthis:\n  invar (app (consr (consr l () (LP e a)) () lp) r)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     e < fst (p_unwrap lp)\\<rbrakk>\n    \\<Longrightarrow> invar\n                       (aluprio_insert splits annot isEmpty app consr s e\n                         a) \\<and>\n                      (\\<forall>x\\<in>set\n (\\<alpha> (aluprio_insert splits annot isEmpty app consr s e a)).\n                          snd x \\<noteq> Infty) \\<and>\n                      sorted\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (aluprio_insert splits annot isEmpty app\n                                 consr s e a))))) \\<and>\n                      distinct\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (aluprio_insert splits annot isEmpty app\n                                 consr s e a)))))\n 2. \\<lbrakk>splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     \\<not> e < fst (p_unwrap lp)\\<rbrakk>\n    \\<Longrightarrow> invar\n                       (aluprio_insert splits annot isEmpty app consr s e\n                         a) \\<and>\n                      (\\<forall>x\\<in>set\n (\\<alpha> (aluprio_insert splits annot isEmpty app consr s e a)).\n                          snd x \\<noteq> Infty) \\<and>\n                      sorted\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (aluprio_insert splits annot isEmpty app\n                                 consr s e a))))) \\<and>\n                      distinct\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (aluprio_insert splits annot isEmpty app\n                                 consr s e a)))))", "have v13: \n          \"\\<alpha> (app (consr (consr l () (LP e a)) () lp) r) \n            = \\<alpha> l @ ((),(LP e a)) # ((), lp) # \\<alpha> r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (app (consr (consr l () (LP e a)) () lp) r) =\n    \\<alpha> l @ ((), LP e a) # ((), lp) # \\<alpha> r", "using v4(4,5)"], ["proof (prove)\nusing this:\n  invar l\n  invar r\n\ngoal (1 subgoal):\n 1. \\<alpha> (app (consr (consr l () (LP e a)) () lp) r) =\n    \\<alpha> l @ ((), LP e a) # ((), lp) # \\<alpha> r", "by (auto simp add: app_correct consr_correct)"], ["proof (state)\nthis:\n  \\<alpha> (app (consr (consr l () (LP e a)) () lp) r) =\n  \\<alpha> l @ ((), LP e a) # ((), lp) # \\<alpha> r\n\ngoal (2 subgoals):\n 1. \\<lbrakk>splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     e < fst (p_unwrap lp)\\<rbrakk>\n    \\<Longrightarrow> invar\n                       (aluprio_insert splits annot isEmpty app consr s e\n                         a) \\<and>\n                      (\\<forall>x\\<in>set\n (\\<alpha> (aluprio_insert splits annot isEmpty app consr s e a)).\n                          snd x \\<noteq> Infty) \\<and>\n                      sorted\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (aluprio_insert splits annot isEmpty app\n                                 consr s e a))))) \\<and>\n                      distinct\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (aluprio_insert splits annot isEmpty app\n                                 consr s e a)))))\n 2. \\<lbrakk>splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     \\<not> e < fst (p_unwrap lp)\\<rbrakk>\n    \\<Longrightarrow> invar\n                       (aluprio_insert splits annot isEmpty app consr s e\n                         a) \\<and>\n                      (\\<forall>x\\<in>set\n (\\<alpha> (aluprio_insert splits annot isEmpty app consr s e a)).\n                          snd x \\<noteq> Infty) \\<and>\n                      sorted\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (aluprio_insert splits annot isEmpty app\n                                 consr s e a))))) \\<and>\n                      distinct\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (aluprio_insert splits annot isEmpty app\n                                 consr s e a)))))", "hence v14: \n          \"(\\<forall>x\\<in>set (\\<alpha> (app (consr (consr l () (LP e a)) () lp) r)). \n             snd x \\<noteq> Infty)\""], ["proof (prove)\nusing this:\n  \\<alpha> (app (consr (consr l () (LP e a)) () lp) r) =\n  \\<alpha> l @ ((), LP e a) # ((), lp) # \\<alpha> r\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (\\<alpha>\n                         (app (consr (consr l () (LP e a)) () lp) r)).\n       snd x \\<noteq> Infty", "using g1asms v4(1)"], ["proof (prove)\nusing this:\n  \\<alpha> (app (consr (consr l () (LP e a)) () lp) r) =\n  \\<alpha> l @ ((), LP e a) # ((), lp) # \\<alpha> r\n  invar s \\<and>\n  (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n  sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n  distinct (map fst (map p_unwrap (map snd (\\<alpha> s))))\n  \\<alpha> s = \\<alpha> l @ ((), lp) # \\<alpha> r\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (\\<alpha>\n                         (app (consr (consr l () (LP e a)) () lp) r)).\n       snd x \\<noteq> Infty", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (\\<alpha> (app (consr (consr l () (LP e a)) () lp) r)).\n     snd x \\<noteq> Infty\n\ngoal (2 subgoals):\n 1. \\<lbrakk>splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     e < fst (p_unwrap lp)\\<rbrakk>\n    \\<Longrightarrow> invar\n                       (aluprio_insert splits annot isEmpty app consr s e\n                         a) \\<and>\n                      (\\<forall>x\\<in>set\n (\\<alpha> (aluprio_insert splits annot isEmpty app consr s e a)).\n                          snd x \\<noteq> Infty) \\<and>\n                      sorted\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (aluprio_insert splits annot isEmpty app\n                                 consr s e a))))) \\<and>\n                      distinct\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (aluprio_insert splits annot isEmpty app\n                                 consr s e a)))))\n 2. \\<lbrakk>splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     \\<not> e < fst (p_unwrap lp)\\<rbrakk>\n    \\<Longrightarrow> invar\n                       (aluprio_insert splits annot isEmpty app consr s e\n                         a) \\<and>\n                      (\\<forall>x\\<in>set\n (\\<alpha> (aluprio_insert splits annot isEmpty app consr s e a)).\n                          snd x \\<noteq> Infty) \\<and>\n                      sorted\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (aluprio_insert splits annot isEmpty app\n                                 consr s e a))))) \\<and>\n                      distinct\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (aluprio_insert splits annot isEmpty app\n                                 consr s e a)))))", "have v15: \"e = fst(p_unwrap (LP e a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e = fst (p_unwrap (LP e a))", "by simp"], ["proof (state)\nthis:\n  e = fst (p_unwrap (LP e a))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     e < fst (p_unwrap lp)\\<rbrakk>\n    \\<Longrightarrow> invar\n                       (aluprio_insert splits annot isEmpty app consr s e\n                         a) \\<and>\n                      (\\<forall>x\\<in>set\n (\\<alpha> (aluprio_insert splits annot isEmpty app consr s e a)).\n                          snd x \\<noteq> Infty) \\<and>\n                      sorted\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (aluprio_insert splits annot isEmpty app\n                                 consr s e a))))) \\<and>\n                      distinct\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (aluprio_insert splits annot isEmpty app\n                                 consr s e a)))))\n 2. \\<lbrakk>splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     \\<not> e < fst (p_unwrap lp)\\<rbrakk>\n    \\<Longrightarrow> invar\n                       (aluprio_insert splits annot isEmpty app consr s e\n                         a) \\<and>\n                      (\\<forall>x\\<in>set\n (\\<alpha> (aluprio_insert splits annot isEmpty app consr s e a)).\n                          snd x \\<noteq> Infty) \\<and>\n                      sorted\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (aluprio_insert splits annot isEmpty app\n                                 consr s e a))))) \\<and>\n                      distinct\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (aluprio_insert splits annot isEmpty app\n                                 consr s e a)))))", "hence v16: \n          \"sorted (map fst (map p_unwrap \n             (map snd (\\<alpha> l @ ((),(LP e a)) # ((), lp) # \\<alpha> r))))\"              \n          \"distinct (map fst (map p_unwrap \n             (map snd (\\<alpha> l @ ((),(LP e a)) # ((), lp) # \\<alpha> r))))\""], ["proof (prove)\nusing this:\n  e = fst (p_unwrap (LP e a))\n\ngoal (1 subgoal):\n 1. sorted\n     (map fst\n       (map p_unwrap\n         (map snd (\\<alpha> l @ ((), LP e a) # ((), lp) # \\<alpha> r)))) &&&\n    distinct\n     (map fst\n       (map p_unwrap\n         (map snd (\\<alpha> l @ ((), LP e a) # ((), lp) # \\<alpha> r))))", "using v10(1,3) v7 True v9 v4(1) g1asms distinct_sorted_list_lem2"], ["proof (prove)\nusing this:\n  e = fst (p_unwrap (LP e a))\n  sorted (map fst (map p_unwrap (map snd (\\<alpha> l))))\n  sorted (map fst (map p_unwrap (map snd (\\<alpha> r))))\n  \\<forall>x\\<in>set (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap\n                            snd)\n                       (\\<alpha> l)).\n     x < e\n  e < fst (p_unwrap lp)\n  \\<forall>x\\<in>set (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap\n                            snd)\n                       (\\<alpha> r)).\n     fst (p_unwrap lp) < x\n  \\<alpha> s = \\<alpha> l @ ((), lp) # \\<alpha> r\n  invar s \\<and>\n  (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n  sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n  distinct (map fst (map p_unwrap (map snd (\\<alpha> s))))\n  \\<lbrakk>sorted ?xs; sorted ?ys; distinct ?xs; distinct ?ys; ?e < ?e';\n   \\<forall>x\\<in>set ?xs. x < ?e; \\<forall>y\\<in>set ?ys. ?e' < y\\<rbrakk>\n  \\<Longrightarrow> sorted (?xs @ ?e # ?e' # ?ys)\n  \\<lbrakk>sorted ?xs; sorted ?ys; distinct ?xs; distinct ?ys; ?e < ?e';\n   \\<forall>x\\<in>set ?xs. x < ?e; \\<forall>y\\<in>set ?ys. ?e' < y\\<rbrakk>\n  \\<Longrightarrow> distinct (?xs @ ?e # ?e' # ?ys)\n\ngoal (1 subgoal):\n 1. sorted\n     (map fst\n       (map p_unwrap\n         (map snd (\\<alpha> l @ ((), LP e a) # ((), lp) # \\<alpha> r)))) &&&\n    distinct\n     (map fst\n       (map p_unwrap\n         (map snd (\\<alpha> l @ ((), LP e a) # ((), lp) # \\<alpha> r))))", "by (auto simp add: sorted_append)"], ["proof (state)\nthis:\n  sorted\n   (map fst\n     (map p_unwrap\n       (map snd (\\<alpha> l @ ((), LP e a) # ((), lp) # \\<alpha> r))))\n  distinct\n   (map fst\n     (map p_unwrap\n       (map snd (\\<alpha> l @ ((), LP e a) # ((), lp) # \\<alpha> r))))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     e < fst (p_unwrap lp)\\<rbrakk>\n    \\<Longrightarrow> invar\n                       (aluprio_insert splits annot isEmpty app consr s e\n                         a) \\<and>\n                      (\\<forall>x\\<in>set\n (\\<alpha> (aluprio_insert splits annot isEmpty app consr s e a)).\n                          snd x \\<noteq> Infty) \\<and>\n                      sorted\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (aluprio_insert splits annot isEmpty app\n                                 consr s e a))))) \\<and>\n                      distinct\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (aluprio_insert splits annot isEmpty app\n                                 consr s e a)))))\n 2. \\<lbrakk>splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     \\<not> e < fst (p_unwrap lp)\\<rbrakk>\n    \\<Longrightarrow> invar\n                       (aluprio_insert splits annot isEmpty app consr s e\n                         a) \\<and>\n                      (\\<forall>x\\<in>set\n (\\<alpha> (aluprio_insert splits annot isEmpty app consr s e a)).\n                          snd x \\<noteq> Infty) \\<and>\n                      sorted\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (aluprio_insert splits annot isEmpty app\n                                 consr s e a))))) \\<and>\n                      distinct\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (aluprio_insert splits annot isEmpty app\n                                 consr s e a)))))", "thus \"invar (aluprio_insert splits annot isEmpty app consr s e a) \\<and>\n          (\\<forall>x\\<in>set (\\<alpha> (aluprio_insert splits annot isEmpty app consr s e a)). \n             snd x \\<noteq> Infty) \\<and>\n          sorted (map fst (map p_unwrap (map snd (\\<alpha> \n             (aluprio_insert splits annot isEmpty app consr s e a))))) \\<and> \n          distinct (map fst (map p_unwrap (map snd (\\<alpha> \n             (aluprio_insert splits annot isEmpty app consr s e a)))))\""], ["proof (prove)\nusing this:\n  sorted\n   (map fst\n     (map p_unwrap\n       (map snd (\\<alpha> l @ ((), LP e a) # ((), lp) # \\<alpha> r))))\n  distinct\n   (map fst\n     (map p_unwrap\n       (map snd (\\<alpha> l @ ((), LP e a) # ((), lp) # \\<alpha> r))))\n\ngoal (1 subgoal):\n 1. invar (aluprio_insert splits annot isEmpty app consr s e a) \\<and>\n    (\\<forall>x\\<in>set (\\<alpha>\n                          (aluprio_insert splits annot isEmpty app consr s e\n                            a)).\n        snd x \\<noteq> Infty) \\<and>\n    sorted\n     (map fst\n       (map p_unwrap\n         (map snd\n           (\\<alpha>\n             (aluprio_insert splits annot isEmpty app consr s e\n               a))))) \\<and>\n    distinct\n     (map fst\n       (map p_unwrap\n         (map snd\n           (\\<alpha>\n             (aluprio_insert splits annot isEmpty app consr s e a)))))", "using v11 v12 v13 v14"], ["proof (prove)\nusing this:\n  sorted\n   (map fst\n     (map p_unwrap\n       (map snd (\\<alpha> l @ ((), LP e a) # ((), lp) # \\<alpha> r))))\n  distinct\n   (map fst\n     (map p_unwrap\n       (map snd (\\<alpha> l @ ((), LP e a) # ((), lp) # \\<alpha> r))))\n  aluprio_insert splits annot isEmpty app consr s e a =\n  app (consr (consr l () (LP e a)) () lp) r\n  invar (app (consr (consr l () (LP e a)) () lp) r)\n  \\<alpha> (app (consr (consr l () (LP e a)) () lp) r) =\n  \\<alpha> l @ ((), LP e a) # ((), lp) # \\<alpha> r\n  \\<forall>x\\<in>set (\\<alpha> (app (consr (consr l () (LP e a)) () lp) r)).\n     snd x \\<noteq> Infty\n\ngoal (1 subgoal):\n 1. invar (aluprio_insert splits annot isEmpty app consr s e a) \\<and>\n    (\\<forall>x\\<in>set (\\<alpha>\n                          (aluprio_insert splits annot isEmpty app consr s e\n                            a)).\n        snd x \\<noteq> Infty) \\<and>\n    sorted\n     (map fst\n       (map p_unwrap\n         (map snd\n           (\\<alpha>\n             (aluprio_insert splits annot isEmpty app consr s e\n               a))))) \\<and>\n    distinct\n     (map fst\n       (map p_unwrap\n         (map snd\n           (\\<alpha>\n             (aluprio_insert splits annot isEmpty app consr s e a)))))", "by simp"], ["proof (state)\nthis:\n  invar (aluprio_insert splits annot isEmpty app consr s e a) \\<and>\n  (\\<forall>x\\<in>set (\\<alpha>\n                        (aluprio_insert splits annot isEmpty app consr s e\n                          a)).\n      snd x \\<noteq> Infty) \\<and>\n  sorted\n   (map fst\n     (map p_unwrap\n       (map snd\n         (\\<alpha>\n           (aluprio_insert splits annot isEmpty app consr s e a))))) \\<and>\n  distinct\n   (map fst\n     (map p_unwrap\n       (map snd\n         (\\<alpha> (aluprio_insert splits annot isEmpty app consr s e a)))))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     \\<not> e < fst (p_unwrap lp)\\<rbrakk>\n    \\<Longrightarrow> invar\n                       (aluprio_insert splits annot isEmpty app consr s e\n                         a) \\<and>\n                      (\\<forall>x\\<in>set\n (\\<alpha> (aluprio_insert splits annot isEmpty app consr s e a)).\n                          snd x \\<noteq> Infty) \\<and>\n                      sorted\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (aluprio_insert splits annot isEmpty app\n                                 consr s e a))))) \\<and>\n                      distinct\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (aluprio_insert splits annot isEmpty app\n                                 consr s e a)))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     \\<not> e < fst (p_unwrap lp)\\<rbrakk>\n    \\<Longrightarrow> invar\n                       (aluprio_insert splits annot isEmpty app consr s e\n                         a) \\<and>\n                      (\\<forall>x\\<in>set\n (\\<alpha> (aluprio_insert splits annot isEmpty app consr s e a)).\n                          snd x \\<noteq> Infty) \\<and>\n                      sorted\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (aluprio_insert splits annot isEmpty app\n                                 consr s e a))))) \\<and>\n                      distinct\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (aluprio_insert splits annot isEmpty app\n                                 consr s e a)))))", "case False"], ["proof (state)\nthis:\n  \\<not> e < fst (p_unwrap lp)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     \\<not> e < fst (p_unwrap lp)\\<rbrakk>\n    \\<Longrightarrow> invar\n                       (aluprio_insert splits annot isEmpty app consr s e\n                         a) \\<and>\n                      (\\<forall>x\\<in>set\n (\\<alpha> (aluprio_insert splits annot isEmpty app consr s e a)).\n                          snd x \\<noteq> Infty) \\<and>\n                      sorted\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (aluprio_insert splits annot isEmpty app\n                                 consr s e a))))) \\<and>\n                      distinct\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (aluprio_insert splits annot isEmpty app\n                                 consr s e a)))))", "hence v11: \n          \"aluprio_insert splits annot isEmpty app consr s e a \n             = app (consr l () (LP e a)) r\""], ["proof (prove)\nusing this:\n  \\<not> e < fst (p_unwrap lp)\n\ngoal (1 subgoal):\n 1. aluprio_insert splits annot isEmpty app consr s e a =\n    app (consr l () (LP e a)) r", "using l_lp_r T1"], ["proof (prove)\nusing this:\n  \\<not> e < fst (p_unwrap lp)\n  splits (e_less_eq e) Infty s = (l, ((), lp), r)\n  e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n\ngoal (1 subgoal):\n 1. aluprio_insert splits annot isEmpty app consr s e a =\n    app (consr l () (LP e a)) r", "by (auto simp add: aluprio_defs)"], ["proof (state)\nthis:\n  aluprio_insert splits annot isEmpty app consr s e a =\n  app (consr l () (LP e a)) r\n\ngoal (1 subgoal):\n 1. \\<lbrakk>splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     \\<not> e < fst (p_unwrap lp)\\<rbrakk>\n    \\<Longrightarrow> invar\n                       (aluprio_insert splits annot isEmpty app consr s e\n                         a) \\<and>\n                      (\\<forall>x\\<in>set\n (\\<alpha> (aluprio_insert splits annot isEmpty app consr s e a)).\n                          snd x \\<noteq> Infty) \\<and>\n                      sorted\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (aluprio_insert splits annot isEmpty app\n                                 consr s e a))))) \\<and>\n                      distinct\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (aluprio_insert splits annot isEmpty app\n                                 consr s e a)))))", "have  v12: \"invar (app (consr l () (LP e a)) r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar (app (consr l () (LP e a)) r)", "using v4(4,5)"], ["proof (prove)\nusing this:\n  invar l\n  invar r\n\ngoal (1 subgoal):\n 1. invar (app (consr l () (LP e a)) r)", "by (auto simp add: app_correct consr_correct)"], ["proof (state)\nthis:\n  invar (app (consr l () (LP e a)) r)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     \\<not> e < fst (p_unwrap lp)\\<rbrakk>\n    \\<Longrightarrow> invar\n                       (aluprio_insert splits annot isEmpty app consr s e\n                         a) \\<and>\n                      (\\<forall>x\\<in>set\n (\\<alpha> (aluprio_insert splits annot isEmpty app consr s e a)).\n                          snd x \\<noteq> Infty) \\<and>\n                      sorted\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (aluprio_insert splits annot isEmpty app\n                                 consr s e a))))) \\<and>\n                      distinct\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (aluprio_insert splits annot isEmpty app\n                                 consr s e a)))))", "have v13: \"\\<alpha> (app (consr l () (LP e a)) r) = \\<alpha> l @ ((),(LP e a)) # \\<alpha> r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (app (consr l () (LP e a)) r) =\n    \\<alpha> l @ ((), LP e a) # \\<alpha> r", "using v4(4,5)"], ["proof (prove)\nusing this:\n  invar l\n  invar r\n\ngoal (1 subgoal):\n 1. \\<alpha> (app (consr l () (LP e a)) r) =\n    \\<alpha> l @ ((), LP e a) # \\<alpha> r", "by (auto simp add: app_correct consr_correct)"], ["proof (state)\nthis:\n  \\<alpha> (app (consr l () (LP e a)) r) =\n  \\<alpha> l @ ((), LP e a) # \\<alpha> r\n\ngoal (1 subgoal):\n 1. \\<lbrakk>splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     \\<not> e < fst (p_unwrap lp)\\<rbrakk>\n    \\<Longrightarrow> invar\n                       (aluprio_insert splits annot isEmpty app consr s e\n                         a) \\<and>\n                      (\\<forall>x\\<in>set\n (\\<alpha> (aluprio_insert splits annot isEmpty app consr s e a)).\n                          snd x \\<noteq> Infty) \\<and>\n                      sorted\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (aluprio_insert splits annot isEmpty app\n                                 consr s e a))))) \\<and>\n                      distinct\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (aluprio_insert splits annot isEmpty app\n                                 consr s e a)))))", "hence v14: \"(\\<forall>x\\<in>set (\\<alpha> (app (consr l () (LP e a)) r)). snd x \\<noteq> Infty)\""], ["proof (prove)\nusing this:\n  \\<alpha> (app (consr l () (LP e a)) r) =\n  \\<alpha> l @ ((), LP e a) # \\<alpha> r\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (\\<alpha> (app (consr l () (LP e a)) r)).\n       snd x \\<noteq> Infty", "using g1asms v4(1)"], ["proof (prove)\nusing this:\n  \\<alpha> (app (consr l () (LP e a)) r) =\n  \\<alpha> l @ ((), LP e a) # \\<alpha> r\n  invar s \\<and>\n  (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n  sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n  distinct (map fst (map p_unwrap (map snd (\\<alpha> s))))\n  \\<alpha> s = \\<alpha> l @ ((), lp) # \\<alpha> r\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (\\<alpha> (app (consr l () (LP e a)) r)).\n       snd x \\<noteq> Infty", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (\\<alpha> (app (consr l () (LP e a)) r)).\n     snd x \\<noteq> Infty\n\ngoal (1 subgoal):\n 1. \\<lbrakk>splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     \\<not> e < fst (p_unwrap lp)\\<rbrakk>\n    \\<Longrightarrow> invar\n                       (aluprio_insert splits annot isEmpty app consr s e\n                         a) \\<and>\n                      (\\<forall>x\\<in>set\n (\\<alpha> (aluprio_insert splits annot isEmpty app consr s e a)).\n                          snd x \\<noteq> Infty) \\<and>\n                      sorted\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (aluprio_insert splits annot isEmpty app\n                                 consr s e a))))) \\<and>\n                      distinct\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (aluprio_insert splits annot isEmpty app\n                                 consr s e a)))))", "have v15: \"e = fst(p_unwrap (LP e a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e = fst (p_unwrap (LP e a))", "by simp"], ["proof (state)\nthis:\n  e = fst (p_unwrap (LP e a))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     \\<not> e < fst (p_unwrap lp)\\<rbrakk>\n    \\<Longrightarrow> invar\n                       (aluprio_insert splits annot isEmpty app consr s e\n                         a) \\<and>\n                      (\\<forall>x\\<in>set\n (\\<alpha> (aluprio_insert splits annot isEmpty app consr s e a)).\n                          snd x \\<noteq> Infty) \\<and>\n                      sorted\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (aluprio_insert splits annot isEmpty app\n                                 consr s e a))))) \\<and>\n                      distinct\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (aluprio_insert splits annot isEmpty app\n                                 consr s e a)))))", "have v16: \"e = fst(p_unwrap lp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e = fst (p_unwrap lp)", "using False v5"], ["proof (prove)\nusing this:\n  \\<not> e < fst (p_unwrap lp)\n  e_less_eq e lp\n\ngoal (1 subgoal):\n 1. e = fst (p_unwrap lp)", "by (cases lp) auto"], ["proof (state)\nthis:\n  e = fst (p_unwrap lp)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     \\<not> e < fst (p_unwrap lp)\\<rbrakk>\n    \\<Longrightarrow> invar\n                       (aluprio_insert splits annot isEmpty app consr s e\n                         a) \\<and>\n                      (\\<forall>x\\<in>set\n (\\<alpha> (aluprio_insert splits annot isEmpty app consr s e a)).\n                          snd x \\<noteq> Infty) \\<and>\n                      sorted\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (aluprio_insert splits annot isEmpty app\n                                 consr s e a))))) \\<and>\n                      distinct\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (aluprio_insert splits annot isEmpty app\n                                 consr s e a)))))", "hence v17: \n          \"sorted (map fst (map p_unwrap \n            (map snd (\\<alpha> l @ ((),(LP e a)) # \\<alpha> r))))\"              \n          \"distinct (map fst (map p_unwrap \n            (map snd (\\<alpha> l @ ((),(LP e a)) # \\<alpha> r))))\""], ["proof (prove)\nusing this:\n  e = fst (p_unwrap lp)\n\ngoal (1 subgoal):\n 1. sorted\n     (map fst\n       (map p_unwrap\n         (map snd (\\<alpha> l @ ((), LP e a) # \\<alpha> r)))) &&&\n    distinct\n     (map fst\n       (map p_unwrap (map snd (\\<alpha> l @ ((), LP e a) # \\<alpha> r))))", "using v16 v15 v10(1,3) v7 True v9 v4(1) \n            g1asms distinct_sorted_list_lem1"], ["proof (prove)\nusing this:\n  e = fst (p_unwrap lp)\n  e = fst (p_unwrap lp)\n  e = fst (p_unwrap (LP e a))\n  sorted (map fst (map p_unwrap (map snd (\\<alpha> l))))\n  sorted (map fst (map p_unwrap (map snd (\\<alpha> r))))\n  \\<forall>x\\<in>set (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap\n                            snd)\n                       (\\<alpha> l)).\n     x < e\n  e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n  \\<forall>x\\<in>set (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap\n                            snd)\n                       (\\<alpha> r)).\n     fst (p_unwrap lp) < x\n  \\<alpha> s = \\<alpha> l @ ((), lp) # \\<alpha> r\n  invar s \\<and>\n  (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n  sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n  distinct (map fst (map p_unwrap (map snd (\\<alpha> s))))\n  \\<lbrakk>sorted ?xs; sorted ?ys; distinct ?xs; distinct ?ys;\n   \\<forall>x\\<in>set ?xs. x < ?e; \\<forall>y\\<in>set ?ys. ?e < y\\<rbrakk>\n  \\<Longrightarrow> sorted (?xs @ ?e # ?ys)\n  \\<lbrakk>sorted ?xs; sorted ?ys; distinct ?xs; distinct ?ys;\n   \\<forall>x\\<in>set ?xs. x < ?e; \\<forall>y\\<in>set ?ys. ?e < y\\<rbrakk>\n  \\<Longrightarrow> distinct (?xs @ ?e # ?ys)\n\ngoal (1 subgoal):\n 1. sorted\n     (map fst\n       (map p_unwrap\n         (map snd (\\<alpha> l @ ((), LP e a) # \\<alpha> r)))) &&&\n    distinct\n     (map fst\n       (map p_unwrap (map snd (\\<alpha> l @ ((), LP e a) # \\<alpha> r))))", "by (auto simp add: sorted_append)"], ["proof (state)\nthis:\n  sorted\n   (map fst\n     (map p_unwrap (map snd (\\<alpha> l @ ((), LP e a) # \\<alpha> r))))\n  distinct\n   (map fst\n     (map p_unwrap (map snd (\\<alpha> l @ ((), LP e a) # \\<alpha> r))))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     \\<not> e < fst (p_unwrap lp)\\<rbrakk>\n    \\<Longrightarrow> invar\n                       (aluprio_insert splits annot isEmpty app consr s e\n                         a) \\<and>\n                      (\\<forall>x\\<in>set\n (\\<alpha> (aluprio_insert splits annot isEmpty app consr s e a)).\n                          snd x \\<noteq> Infty) \\<and>\n                      sorted\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (aluprio_insert splits annot isEmpty app\n                                 consr s e a))))) \\<and>\n                      distinct\n                       (map fst\n                         (map p_unwrap\n                           (map snd\n                             (\\<alpha>\n                               (aluprio_insert splits annot isEmpty app\n                                 consr s e a)))))", "thus \"invar (aluprio_insert splits annot isEmpty app consr s e a) \\<and>\n          (\\<forall>x\\<in>set (\\<alpha> (aluprio_insert splits annot isEmpty app consr s e a)). \n            snd x \\<noteq> Infty) \\<and>\n          sorted (map fst (map p_unwrap (map snd (\\<alpha> \n            (aluprio_insert splits annot isEmpty app consr s e a))))) \\<and> \n          distinct (map fst (map p_unwrap (map snd (\\<alpha> \n            (aluprio_insert splits annot isEmpty app consr s e a)))))\""], ["proof (prove)\nusing this:\n  sorted\n   (map fst\n     (map p_unwrap (map snd (\\<alpha> l @ ((), LP e a) # \\<alpha> r))))\n  distinct\n   (map fst\n     (map p_unwrap (map snd (\\<alpha> l @ ((), LP e a) # \\<alpha> r))))\n\ngoal (1 subgoal):\n 1. invar (aluprio_insert splits annot isEmpty app consr s e a) \\<and>\n    (\\<forall>x\\<in>set (\\<alpha>\n                          (aluprio_insert splits annot isEmpty app consr s e\n                            a)).\n        snd x \\<noteq> Infty) \\<and>\n    sorted\n     (map fst\n       (map p_unwrap\n         (map snd\n           (\\<alpha>\n             (aluprio_insert splits annot isEmpty app consr s e\n               a))))) \\<and>\n    distinct\n     (map fst\n       (map p_unwrap\n         (map snd\n           (\\<alpha>\n             (aluprio_insert splits annot isEmpty app consr s e a)))))", "using v11 v12 v13 v14"], ["proof (prove)\nusing this:\n  sorted\n   (map fst\n     (map p_unwrap (map snd (\\<alpha> l @ ((), LP e a) # \\<alpha> r))))\n  distinct\n   (map fst\n     (map p_unwrap (map snd (\\<alpha> l @ ((), LP e a) # \\<alpha> r))))\n  aluprio_insert splits annot isEmpty app consr s e a =\n  app (consr l () (LP e a)) r\n  invar (app (consr l () (LP e a)) r)\n  \\<alpha> (app (consr l () (LP e a)) r) =\n  \\<alpha> l @ ((), LP e a) # \\<alpha> r\n  \\<forall>x\\<in>set (\\<alpha> (app (consr l () (LP e a)) r)).\n     snd x \\<noteq> Infty\n\ngoal (1 subgoal):\n 1. invar (aluprio_insert splits annot isEmpty app consr s e a) \\<and>\n    (\\<forall>x\\<in>set (\\<alpha>\n                          (aluprio_insert splits annot isEmpty app consr s e\n                            a)).\n        snd x \\<noteq> Infty) \\<and>\n    sorted\n     (map fst\n       (map p_unwrap\n         (map snd\n           (\\<alpha>\n             (aluprio_insert splits annot isEmpty app consr s e\n               a))))) \\<and>\n    distinct\n     (map fst\n       (map p_unwrap\n         (map snd\n           (\\<alpha>\n             (aluprio_insert splits annot isEmpty app consr s e a)))))", "by simp"], ["proof (state)\nthis:\n  invar (aluprio_insert splits annot isEmpty app consr s e a) \\<and>\n  (\\<forall>x\\<in>set (\\<alpha>\n                        (aluprio_insert splits annot isEmpty app consr s e\n                          a)).\n      snd x \\<noteq> Infty) \\<and>\n  sorted\n   (map fst\n     (map p_unwrap\n       (map snd\n         (\\<alpha>\n           (aluprio_insert splits annot isEmpty app consr s e a))))) \\<and>\n  distinct\n   (map fst\n     (map p_unwrap\n       (map snd\n         (\\<alpha> (aluprio_insert splits annot isEmpty app consr s e a)))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  invar\n   (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n    then let (l, (uu_, lp), r) = splits (e_less_eq e) Infty s\n         in if e < fst (p_unwrap lp)\n            then app (consr (consr l () (LP e a)) () lp) r\n            else app (consr l () (LP e a)) r\n    else consr s () (LP e a)) \\<and>\n  (\\<forall>x\\<in>set (\\<alpha>\n                        (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n                         then let (l, (uu_, lp), r) =\n                                    splits (e_less_eq e) Infty s\n                              in if e < fst (p_unwrap lp)\n                                 then app\n (consr (consr l () (LP e a)) () lp) r\n                                 else app (consr l () (LP e a)) r\n                         else consr s () (LP e a))).\n      snd x \\<noteq> Infty) \\<and>\n  sorted\n   (map fst\n     (map p_unwrap\n       (map snd\n         (\\<alpha>\n           (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n            then let (l, (uu_, lp), r) = splits (e_less_eq e) Infty s\n                 in if e < fst (p_unwrap lp)\n                    then app (consr (consr l () (LP e a)) () lp) r\n                    else app (consr l () (LP e a)) r\n            else consr s () (LP e a)))))) \\<and>\n  distinct\n   (map fst\n     (map p_unwrap\n       (map snd\n         (\\<alpha>\n           (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n            then let (l, (uu_, lp), r) = splits (e_less_eq e) Infty s\n                 in if e < fst (p_unwrap lp)\n                    then app (consr (consr l () (LP e a)) () lp) r\n                    else app (consr l () (LP e a)) r\n            else consr s () (LP e a))))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  invar\n   (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n    then let (l, (uu_, lp), r) = splits (e_less_eq e) Infty s\n         in if e < fst (p_unwrap lp)\n            then app (consr (consr l () (LP e a)) () lp) r\n            else app (consr l () (LP e a)) r\n    else consr s () (LP e a)) \\<and>\n  (\\<forall>x\\<in>set (\\<alpha>\n                        (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n                         then let (l, (uu_, lp), r) =\n                                    splits (e_less_eq e) Infty s\n                              in if e < fst (p_unwrap lp)\n                                 then app\n (consr (consr l () (LP e a)) () lp) r\n                                 else app (consr l () (LP e a)) r\n                         else consr s () (LP e a))).\n      snd x \\<noteq> Infty) \\<and>\n  sorted\n   (map fst\n     (map p_unwrap\n       (map snd\n         (\\<alpha>\n           (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n            then let (l, (uu_, lp), r) = splits (e_less_eq e) Infty s\n                 in if e < fst (p_unwrap lp)\n                    then app (consr (consr l () (LP e a)) () lp) r\n                    else app (consr l () (LP e a)) r\n            else consr s () (LP e a)))))) \\<and>\n  distinct\n   (map fst\n     (map p_unwrap\n       (map snd\n         (\\<alpha>\n           (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n            then let (l, (uu_, lp), r) = splits (e_less_eq e) Infty s\n                 in if e < fst (p_unwrap lp)\n                    then app (consr (consr l () (LP e a)) () lp) r\n                    else app (consr l () (LP e a)) r\n            else consr s () (LP e a))))))\n\ngoal (1 subgoal):\n 1. \\<And>s e a.\n       invar s \\<and>\n       (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n       sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n       distinct\n        (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<Longrightarrow>\n       map_of\n        (map p_unwrap\n          (map snd\n            (\\<alpha>\n              (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n               then let (l, (uu_, lp), r) = splits (e_less_eq e) Infty s\n                    in if e < fst (p_unwrap lp)\n                       then app (consr (consr l () (LP e a)) () lp) r\n                       else app (consr l () (LP e a)) r\n               else consr s () (LP e a))))) =\n       map_of (map p_unwrap (map snd (\\<alpha> s)))(e \\<mapsto> a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s e a.\n       invar s \\<and>\n       (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n       sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n       distinct\n        (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<Longrightarrow>\n       map_of\n        (map p_unwrap\n          (map snd\n            (\\<alpha>\n              (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n               then let (l, (uu_, lp), r) = splits (e_less_eq e) Infty s\n                    in if e < fst (p_unwrap lp)\n                       then app (consr (consr l () (LP e a)) () lp) r\n                       else app (consr l () (LP e a)) r\n               else consr s () (LP e a))))) =\n       map_of (map p_unwrap (map snd (\\<alpha> s)))(e \\<mapsto> a)", "case g1asms: (2 s e a)"], ["proof (state)\nthis:\n  invar s \\<and>\n  (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n  sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n  distinct (map fst (map p_unwrap (map snd (\\<alpha> s))))\n\ngoal (1 subgoal):\n 1. \\<And>s e a.\n       invar s \\<and>\n       (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n       sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n       distinct\n        (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<Longrightarrow>\n       map_of\n        (map p_unwrap\n          (map snd\n            (\\<alpha>\n              (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n               then let (l, (uu_, lp), r) = splits (e_less_eq e) Infty s\n                    in if e < fst (p_unwrap lp)\n                       then app (consr (consr l () (LP e a)) () lp) r\n                       else app (consr l () (LP e a)) r\n               else consr s () (LP e a))))) =\n       map_of (map p_unwrap (map snd (\\<alpha> s)))(e \\<mapsto> a)", "thus ?case"], ["proof (prove)\nusing this:\n  invar s \\<and>\n  (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n  sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n  distinct (map fst (map p_unwrap (map snd (\\<alpha> s))))\n\ngoal (1 subgoal):\n 1. map_of\n     (map p_unwrap\n       (map snd\n         (\\<alpha>\n           (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n            then let (l, (uu_, lp), r) = splits (e_less_eq e) Infty s\n                 in if e < fst (p_unwrap lp)\n                    then app (consr (consr l () (LP e a)) () lp) r\n                    else app (consr l () (LP e a)) r\n            else consr s () (LP e a))))) =\n    map_of (map p_unwrap (map snd (\\<alpha> s)))(e \\<mapsto> a)", "proof (cases \"e_less_eq e (annot s) \\<and> \\<not> isEmpty s\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>invar s \\<and>\n             (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n             sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n             distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s\\<rbrakk>\n    \\<Longrightarrow> map_of\n                       (map p_unwrap\n                         (map snd\n                           (\\<alpha>\n                             (if e_less_eq e (annot s) \\<and>\n                                 \\<not> isEmpty s\n                              then let (l, (uu_, lp), r) =\n   splits (e_less_eq e) Infty s\n                                   in if e < fst (p_unwrap lp)\nthen app (consr (consr l () (LP e a)) () lp) r\nelse app (consr l () (LP e a)) r\n                              else consr s () (LP e a))))) =\n                      map_of (map p_unwrap (map snd (\\<alpha> s)))(e \n                      \\<mapsto> a)\n 2. \\<lbrakk>invar s \\<and>\n             (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n             sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n             distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     \\<not> (e_less_eq e (annot s) \\<and> \\<not> isEmpty s)\\<rbrakk>\n    \\<Longrightarrow> map_of\n                       (map p_unwrap\n                         (map snd\n                           (\\<alpha>\n                             (if e_less_eq e (annot s) \\<and>\n                                 \\<not> isEmpty s\n                              then let (l, (uu_, lp), r) =\n   splits (e_less_eq e) Infty s\n                                   in if e < fst (p_unwrap lp)\nthen app (consr (consr l () (LP e a)) () lp) r\nelse app (consr l () (LP e a)) r\n                              else consr s () (LP e a))))) =\n                      map_of (map p_unwrap (map snd (\\<alpha> s)))(e \n                      \\<mapsto> a)", "case False"], ["proof (state)\nthis:\n  \\<not> (e_less_eq e (annot s) \\<and> \\<not> isEmpty s)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>invar s \\<and>\n             (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n             sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n             distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s\\<rbrakk>\n    \\<Longrightarrow> map_of\n                       (map p_unwrap\n                         (map snd\n                           (\\<alpha>\n                             (if e_less_eq e (annot s) \\<and>\n                                 \\<not> isEmpty s\n                              then let (l, (uu_, lp), r) =\n   splits (e_less_eq e) Infty s\n                                   in if e < fst (p_unwrap lp)\nthen app (consr (consr l () (LP e a)) () lp) r\nelse app (consr l () (LP e a)) r\n                              else consr s () (LP e a))))) =\n                      map_of (map p_unwrap (map snd (\\<alpha> s)))(e \n                      \\<mapsto> a)\n 2. \\<lbrakk>invar s \\<and>\n             (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n             sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n             distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     \\<not> (e_less_eq e (annot s) \\<and> \\<not> isEmpty s)\\<rbrakk>\n    \\<Longrightarrow> map_of\n                       (map p_unwrap\n                         (map snd\n                           (\\<alpha>\n                             (if e_less_eq e (annot s) \\<and>\n                                 \\<not> isEmpty s\n                              then let (l, (uu_, lp), r) =\n   splits (e_less_eq e) Infty s\n                                   in if e < fst (p_unwrap lp)\nthen app (consr (consr l () (LP e a)) () lp) r\nelse app (consr l () (LP e a)) r\n                              else consr s () (LP e a))))) =\n                      map_of (map p_unwrap (map snd (\\<alpha> s)))(e \n                      \\<mapsto> a)", "with g1asms"], ["proof (chain)\npicking this:\n  invar s \\<and>\n  (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n  sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n  distinct (map fst (map p_unwrap (map snd (\\<alpha> s))))\n  \\<not> (e_less_eq e (annot s) \\<and> \\<not> isEmpty s)", "show  ?thesis"], ["proof (prove)\nusing this:\n  invar s \\<and>\n  (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n  sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n  distinct (map fst (map p_unwrap (map snd (\\<alpha> s))))\n  \\<not> (e_less_eq e (annot s) \\<and> \\<not> isEmpty s)\n\ngoal (1 subgoal):\n 1. map_of\n     (map p_unwrap\n       (map snd\n         (\\<alpha>\n           (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n            then let (l, (uu_, lp), r) = splits (e_less_eq e) Infty s\n                 in if e < fst (p_unwrap lp)\n                    then app (consr (consr l () (LP e a)) () lp) r\n                    else app (consr l () (LP e a)) r\n            else consr s () (LP e a))))) =\n    map_of (map p_unwrap (map snd (\\<alpha> s)))(e \\<mapsto> a)", "apply (auto simp add: consr_correct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>invar s; \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty;\n     sorted\n      (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n        (\\<alpha> s));\n     distinct\n      (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n        (\\<alpha> s));\n     \\<not> e_less_eq e (annot s)\\<rbrakk>\n    \\<Longrightarrow> [e \\<mapsto> a] ++\n                      map_of (map (p_unwrap \\<circ> snd) (\\<alpha> s)) =\n                      map_of (map (p_unwrap \\<circ> snd) (\\<alpha> s))(e \n                      \\<mapsto> a)\n 2. \\<lbrakk>invar s; \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty;\n     sorted\n      (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n        (\\<alpha> s));\n     distinct\n      (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n        (\\<alpha> s));\n     isEmpty s\\<rbrakk>\n    \\<Longrightarrow> [e \\<mapsto> a] ++\n                      map_of (map (p_unwrap \\<circ> snd) (\\<alpha> s)) =\n                      map_of (map (p_unwrap \\<circ> snd) (\\<alpha> s))(e \n                      \\<mapsto> a)", "proof goal_cases"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>invar s; \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty;\n     sorted\n      (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n        (\\<alpha> s));\n     distinct\n      (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n        (\\<alpha> s));\n     \\<not> e_less_eq e (annot s)\\<rbrakk>\n    \\<Longrightarrow> [e \\<mapsto> a] ++\n                      map_of (map (p_unwrap \\<circ> snd) (\\<alpha> s)) =\n                      map_of (map (p_unwrap \\<circ> snd) (\\<alpha> s))(e \n                      \\<mapsto> a)\n 2. \\<lbrakk>invar s; \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty;\n     sorted\n      (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n        (\\<alpha> s));\n     distinct\n      (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n        (\\<alpha> s));\n     isEmpty s\\<rbrakk>\n    \\<Longrightarrow> [e \\<mapsto> a] ++\n                      map_of (map (p_unwrap \\<circ> snd) (\\<alpha> s)) =\n                      map_of (map (p_unwrap \\<circ> snd) (\\<alpha> s))(e \n                      \\<mapsto> a)", "case prems: 1"], ["proof (state)\nthis:\n  invar s\n  \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty\n  sorted\n   (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd) (\\<alpha> s))\n  distinct\n   (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd) (\\<alpha> s))\n  \\<not> e_less_eq e (annot s)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>invar s; \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty;\n     sorted\n      (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n        (\\<alpha> s));\n     distinct\n      (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n        (\\<alpha> s));\n     \\<not> e_less_eq e (annot s)\\<rbrakk>\n    \\<Longrightarrow> [e \\<mapsto> a] ++\n                      map_of (map (p_unwrap \\<circ> snd) (\\<alpha> s)) =\n                      map_of (map (p_unwrap \\<circ> snd) (\\<alpha> s))(e \n                      \\<mapsto> a)\n 2. \\<lbrakk>invar s; \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty;\n     sorted\n      (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n        (\\<alpha> s));\n     distinct\n      (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n        (\\<alpha> s));\n     isEmpty s\\<rbrakk>\n    \\<Longrightarrow> [e \\<mapsto> a] ++\n                      map_of (map (p_unwrap \\<circ> snd) (\\<alpha> s)) =\n                      map_of (map (p_unwrap \\<circ> snd) (\\<alpha> s))(e \n                      \\<mapsto> a)", "with assms(2)"], ["proof (chain)\npicking this:\n  al_annot \\<alpha> invar annot\n  invar s\n  \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty\n  sorted\n   (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd) (\\<alpha> s))\n  distinct\n   (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd) (\\<alpha> s))\n  \\<not> e_less_eq e (annot s)", "have  \n          \"\\<forall>x \\<in> set (map (fst \\<circ> (p_unwrap \\<circ> snd)) (\\<alpha> s)). x < e\""], ["proof (prove)\nusing this:\n  al_annot \\<alpha> invar annot\n  invar s\n  \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty\n  sorted\n   (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd) (\\<alpha> s))\n  distinct\n   (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd) (\\<alpha> s))\n  \\<not> e_less_eq e (annot s)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap\n                              snd)\n                         (\\<alpha> s)).\n       x < e", "by (simp add: e_less_eq_annot)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap\n                            snd)\n                       (\\<alpha> s)).\n     x < e\n\ngoal (2 subgoals):\n 1. \\<lbrakk>invar s; \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty;\n     sorted\n      (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n        (\\<alpha> s));\n     distinct\n      (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n        (\\<alpha> s));\n     \\<not> e_less_eq e (annot s)\\<rbrakk>\n    \\<Longrightarrow> [e \\<mapsto> a] ++\n                      map_of (map (p_unwrap \\<circ> snd) (\\<alpha> s)) =\n                      map_of (map (p_unwrap \\<circ> snd) (\\<alpha> s))(e \n                      \\<mapsto> a)\n 2. \\<lbrakk>invar s; \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty;\n     sorted\n      (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n        (\\<alpha> s));\n     distinct\n      (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n        (\\<alpha> s));\n     isEmpty s\\<rbrakk>\n    \\<Longrightarrow> [e \\<mapsto> a] ++\n                      map_of (map (p_unwrap \\<circ> snd) (\\<alpha> s)) =\n                      map_of (map (p_unwrap \\<circ> snd) (\\<alpha> s))(e \n                      \\<mapsto> a)", "hence \"e \\<notin> set (map fst ((map (p_unwrap \\<circ> snd)) (\\<alpha> s)))\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap\n                            snd)\n                       (\\<alpha> s)).\n     x < e\n\ngoal (1 subgoal):\n 1. e \\<notin> set (map fst (map (p_unwrap \\<circ> snd) (\\<alpha> s)))", "by auto"], ["proof (state)\nthis:\n  e \\<notin> set (map fst (map (p_unwrap \\<circ> snd) (\\<alpha> s)))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>invar s; \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty;\n     sorted\n      (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n        (\\<alpha> s));\n     distinct\n      (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n        (\\<alpha> s));\n     \\<not> e_less_eq e (annot s)\\<rbrakk>\n    \\<Longrightarrow> [e \\<mapsto> a] ++\n                      map_of (map (p_unwrap \\<circ> snd) (\\<alpha> s)) =\n                      map_of (map (p_unwrap \\<circ> snd) (\\<alpha> s))(e \n                      \\<mapsto> a)\n 2. \\<lbrakk>invar s; \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty;\n     sorted\n      (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n        (\\<alpha> s));\n     distinct\n      (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n        (\\<alpha> s));\n     isEmpty s\\<rbrakk>\n    \\<Longrightarrow> [e \\<mapsto> a] ++\n                      map_of (map (p_unwrap \\<circ> snd) (\\<alpha> s)) =\n                      map_of (map (p_unwrap \\<circ> snd) (\\<alpha> s))(e \n                      \\<mapsto> a)", "thus ?case"], ["proof (prove)\nusing this:\n  e \\<notin> set (map fst (map (p_unwrap \\<circ> snd) (\\<alpha> s)))\n\ngoal (1 subgoal):\n 1. [e \\<mapsto> a] ++ map_of (map (p_unwrap \\<circ> snd) (\\<alpha> s)) =\n    map_of (map (p_unwrap \\<circ> snd) (\\<alpha> s))(e \\<mapsto> a)", "by (auto simp add: map_of_distinct_upd)"], ["proof (state)\nthis:\n  [e \\<mapsto> a] ++ map_of (map (p_unwrap \\<circ> snd) (\\<alpha> s)) =\n  map_of (map (p_unwrap \\<circ> snd) (\\<alpha> s))(e \\<mapsto> a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>invar s; \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty;\n     sorted\n      (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n        (\\<alpha> s));\n     distinct\n      (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n        (\\<alpha> s));\n     isEmpty s\\<rbrakk>\n    \\<Longrightarrow> [e \\<mapsto> a] ++\n                      map_of (map (p_unwrap \\<circ> snd) (\\<alpha> s)) =\n                      map_of (map (p_unwrap \\<circ> snd) (\\<alpha> s))(e \n                      \\<mapsto> a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar s; \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty;\n     sorted\n      (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n        (\\<alpha> s));\n     distinct\n      (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n        (\\<alpha> s));\n     isEmpty s\\<rbrakk>\n    \\<Longrightarrow> [e \\<mapsto> a] ++\n                      map_of (map (p_unwrap \\<circ> snd) (\\<alpha> s)) =\n                      map_of (map (p_unwrap \\<circ> snd) (\\<alpha> s))(e \n                      \\<mapsto> a)", "case prems: 2"], ["proof (state)\nthis:\n  invar s\n  \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty\n  sorted\n   (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd) (\\<alpha> s))\n  distinct\n   (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd) (\\<alpha> s))\n  isEmpty s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>invar s; \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty;\n     sorted\n      (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n        (\\<alpha> s));\n     distinct\n      (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n        (\\<alpha> s));\n     isEmpty s\\<rbrakk>\n    \\<Longrightarrow> [e \\<mapsto> a] ++\n                      map_of (map (p_unwrap \\<circ> snd) (\\<alpha> s)) =\n                      map_of (map (p_unwrap \\<circ> snd) (\\<alpha> s))(e \n                      \\<mapsto> a)", "hence \"\\<alpha> s = []\""], ["proof (prove)\nusing this:\n  invar s\n  \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty\n  sorted\n   (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd) (\\<alpha> s))\n  distinct\n   (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd) (\\<alpha> s))\n  isEmpty s\n\ngoal (1 subgoal):\n 1. \\<alpha> s = []", "by (auto simp add: isEmpty_correct)"], ["proof (state)\nthis:\n  \\<alpha> s = []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>invar s; \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty;\n     sorted\n      (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n        (\\<alpha> s));\n     distinct\n      (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n        (\\<alpha> s));\n     isEmpty s\\<rbrakk>\n    \\<Longrightarrow> [e \\<mapsto> a] ++\n                      map_of (map (p_unwrap \\<circ> snd) (\\<alpha> s)) =\n                      map_of (map (p_unwrap \\<circ> snd) (\\<alpha> s))(e \n                      \\<mapsto> a)", "thus ?case"], ["proof (prove)\nusing this:\n  \\<alpha> s = []\n\ngoal (1 subgoal):\n 1. [e \\<mapsto> a] ++ map_of (map (p_unwrap \\<circ> snd) (\\<alpha> s)) =\n    map_of (map (p_unwrap \\<circ> snd) (\\<alpha> s))(e \\<mapsto> a)", "by simp"], ["proof (state)\nthis:\n  [e \\<mapsto> a] ++ map_of (map (p_unwrap \\<circ> snd) (\\<alpha> s)) =\n  map_of (map (p_unwrap \\<circ> snd) (\\<alpha> s))(e \\<mapsto> a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map_of\n   (map p_unwrap\n     (map snd\n       (\\<alpha>\n         (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n          then let (l, (uu_, lp), r) = splits (e_less_eq e) Infty s\n               in if e < fst (p_unwrap lp)\n                  then app (consr (consr l () (LP e a)) () lp) r\n                  else app (consr l () (LP e a)) r\n          else consr s () (LP e a))))) =\n  map_of (map p_unwrap (map snd (\\<alpha> s)))(e \\<mapsto> a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>invar s \\<and>\n             (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n             sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n             distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s\\<rbrakk>\n    \\<Longrightarrow> map_of\n                       (map p_unwrap\n                         (map snd\n                           (\\<alpha>\n                             (if e_less_eq e (annot s) \\<and>\n                                 \\<not> isEmpty s\n                              then let (l, (uu_, lp), r) =\n   splits (e_less_eq e) Infty s\n                                   in if e < fst (p_unwrap lp)\nthen app (consr (consr l () (LP e a)) () lp) r\nelse app (consr l () (LP e a)) r\n                              else consr s () (LP e a))))) =\n                      map_of (map p_unwrap (map snd (\\<alpha> s)))(e \n                      \\<mapsto> a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>invar s \\<and>\n             (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n             sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n             distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s\\<rbrakk>\n    \\<Longrightarrow> map_of\n                       (map p_unwrap\n                         (map snd\n                           (\\<alpha>\n                             (if e_less_eq e (annot s) \\<and>\n                                 \\<not> isEmpty s\n                              then let (l, (uu_, lp), r) =\n   splits (e_less_eq e) Infty s\n                                   in if e < fst (p_unwrap lp)\nthen app (consr (consr l () (LP e a)) () lp) r\nelse app (consr l () (LP e a)) r\n                              else consr s () (LP e a))))) =\n                      map_of (map p_unwrap (map snd (\\<alpha> s)))(e \n                      \\<mapsto> a)", "case True"], ["proof (state)\nthis:\n  e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>invar s \\<and>\n             (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n             sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n             distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s\\<rbrakk>\n    \\<Longrightarrow> map_of\n                       (map p_unwrap\n                         (map snd\n                           (\\<alpha>\n                             (if e_less_eq e (annot s) \\<and>\n                                 \\<not> isEmpty s\n                              then let (l, (uu_, lp), r) =\n   splits (e_less_eq e) Infty s\n                                   in if e < fst (p_unwrap lp)\nthen app (consr (consr l () (LP e a)) () lp) r\nelse app (consr l () (LP e a)) r\n                              else consr s () (LP e a))))) =\n                      map_of (map p_unwrap (map snd (\\<alpha> s)))(e \n                      \\<mapsto> a)", "note T1 = this"], ["proof (state)\nthis:\n  e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>invar s \\<and>\n             (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n             sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n             distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s\\<rbrakk>\n    \\<Longrightarrow> map_of\n                       (map p_unwrap\n                         (map snd\n                           (\\<alpha>\n                             (if e_less_eq e (annot s) \\<and>\n                                 \\<not> isEmpty s\n                              then let (l, (uu_, lp), r) =\n   splits (e_less_eq e) Infty s\n                                   in if e < fst (p_unwrap lp)\nthen app (consr (consr l () (LP e a)) () lp) r\nelse app (consr l () (LP e a)) r\n                              else consr s () (LP e a))))) =\n                      map_of (map p_unwrap (map snd (\\<alpha> s)))(e \n                      \\<mapsto> a)", "obtain l lp r where \n        l_lp_r: \"(splits (e_less_eq e) Infty s) = (l, ((), lp), r) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l lp r.\n        splits (e_less_eq e) Infty s = (l, ((), lp), r) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"splits (e_less_eq e) Infty s\", auto)"], ["proof (state)\nthis:\n  splits (e_less_eq e) Infty s = (l, ((), lp), r)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>invar s \\<and>\n             (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n             sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n             distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s\\<rbrakk>\n    \\<Longrightarrow> map_of\n                       (map p_unwrap\n                         (map snd\n                           (\\<alpha>\n                             (if e_less_eq e (annot s) \\<and>\n                                 \\<not> isEmpty s\n                              then let (l, (uu_, lp), r) =\n   splits (e_less_eq e) Infty s\n                                   in if e < fst (p_unwrap lp)\nthen app (consr (consr l () (LP e a)) () lp) r\nelse app (consr l () (LP e a)) r\n                              else consr s () (LP e a))))) =\n                      map_of (map p_unwrap (map snd (\\<alpha> s)))(e \n                      \\<mapsto> a)", "note v2 = splits_correct[of s \"e_less_eq e\" Infty l \"()\" lp r]"], ["proof (state)\nthis:\n  \\<lbrakk>invar s;\n   \\<forall>a b. e_less_eq e a \\<longrightarrow> e_less_eq e (a + b);\n   \\<not> e_less_eq e Infty;\n   e_less_eq e (Infty + sum_list (map snd (\\<alpha> s)));\n   splits (e_less_eq e) Infty s = (l, ((), lp), r)\\<rbrakk>\n  \\<Longrightarrow> \\<alpha> s = \\<alpha> l @ ((), lp) # \\<alpha> r \\<and>\n                    \\<not> e_less_eq e\n                            (Infty + sum_list (map snd (\\<alpha> l))) \\<and>\n                    e_less_eq e\n                     (Infty + sum_list (map snd (\\<alpha> l)) + lp) \\<and>\n                    invar l \\<and> invar r\n\ngoal (1 subgoal):\n 1. \\<lbrakk>invar s \\<and>\n             (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n             sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n             distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s\\<rbrakk>\n    \\<Longrightarrow> map_of\n                       (map p_unwrap\n                         (map snd\n                           (\\<alpha>\n                             (if e_less_eq e (annot s) \\<and>\n                                 \\<not> isEmpty s\n                              then let (l, (uu_, lp), r) =\n   splits (e_less_eq e) Infty s\n                                   in if e < fst (p_unwrap lp)\nthen app (consr (consr l () (LP e a)) () lp) r\nelse app (consr l () (LP e a)) r\n                              else consr s () (LP e a))))) =\n                      map_of (map p_unwrap (map snd (\\<alpha> s)))(e \n                      \\<mapsto> a)", "have \n        v3: \"invar s\" \n        \"\\<not> e_less_eq e Infty\"\n        \"e_less_eq e (Infty + sum_list (map snd (\\<alpha> s)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar s &&&\n    \\<not> e_less_eq e Infty &&&\n    e_less_eq e (Infty + sum_list (map snd (\\<alpha> s)))", "using T1 g1asms annot_correct"], ["proof (prove)\nusing this:\n  e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n  invar s \\<and>\n  (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n  sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n  distinct (map fst (map p_unwrap (map snd (\\<alpha> s))))\n  invar ?s \\<Longrightarrow> annot ?s = sum_list (map snd (\\<alpha> ?s))\n\ngoal (1 subgoal):\n 1. invar s &&&\n    \\<not> e_less_eq e Infty &&&\n    e_less_eq e (Infty + sum_list (map snd (\\<alpha> s)))", "by (auto simp add: plus_def)"], ["proof (state)\nthis:\n  invar s\n  \\<not> e_less_eq e Infty\n  e_less_eq e (Infty + sum_list (map snd (\\<alpha> s)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>invar s \\<and>\n             (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n             sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n             distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s\\<rbrakk>\n    \\<Longrightarrow> map_of\n                       (map p_unwrap\n                         (map snd\n                           (\\<alpha>\n                             (if e_less_eq e (annot s) \\<and>\n                                 \\<not> isEmpty s\n                              then let (l, (uu_, lp), r) =\n   splits (e_less_eq e) Infty s\n                                   in if e < fst (p_unwrap lp)\nthen app (consr (consr l () (LP e a)) () lp) r\nelse app (consr l () (LP e a)) r\n                              else consr s () (LP e a))))) =\n                      map_of (map p_unwrap (map snd (\\<alpha> s)))(e \n                      \\<mapsto> a)", "have \n        v4: \"\\<alpha> s = \\<alpha> l @ ((), lp) # \\<alpha> r\"  \n        \"\\<not> e_less_eq e (Infty + sum_list (map snd (\\<alpha> l)))\"\n        \"e_less_eq e (Infty + sum_list (map snd (\\<alpha> l)) + lp)\"\n        \"invar l\"\n        \"invar r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<alpha> s = \\<alpha> l @ ((), lp) # \\<alpha> r &&&\n     \\<not> e_less_eq e (Infty + sum_list (map snd (\\<alpha> l)))) &&&\n    e_less_eq e (Infty + sum_list (map snd (\\<alpha> l)) + lp) &&&\n    invar l &&& invar r", "using v2[OF v3(1) _ v3(2) v3(3) l_lp_r] e_less_eq_mon(1)"], ["proof (prove)\nusing this:\n  \\<forall>a b.\n     e_less_eq e a \\<longrightarrow> e_less_eq e (a + b) \\<Longrightarrow>\n  \\<alpha> s = \\<alpha> l @ ((), lp) # \\<alpha> r \\<and>\n  \\<not> e_less_eq e (Infty + sum_list (map snd (\\<alpha> l))) \\<and>\n  e_less_eq e (Infty + sum_list (map snd (\\<alpha> l)) + lp) \\<and>\n  invar l \\<and> invar r\n  e_less_eq ?e ?x \\<Longrightarrow> e_less_eq ?e (?x + ?y)\n\ngoal (1 subgoal):\n 1. (\\<alpha> s = \\<alpha> l @ ((), lp) # \\<alpha> r &&&\n     \\<not> e_less_eq e (Infty + sum_list (map snd (\\<alpha> l)))) &&&\n    e_less_eq e (Infty + sum_list (map snd (\\<alpha> l)) + lp) &&&\n    invar l &&& invar r", "by auto"], ["proof (state)\nthis:\n  \\<alpha> s = \\<alpha> l @ ((), lp) # \\<alpha> r\n  \\<not> e_less_eq e (Infty + sum_list (map snd (\\<alpha> l)))\n  e_less_eq e (Infty + sum_list (map snd (\\<alpha> l)) + lp)\n  invar l\n  invar r\n\ngoal (1 subgoal):\n 1. \\<lbrakk>invar s \\<and>\n             (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n             sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n             distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s\\<rbrakk>\n    \\<Longrightarrow> map_of\n                       (map p_unwrap\n                         (map snd\n                           (\\<alpha>\n                             (if e_less_eq e (annot s) \\<and>\n                                 \\<not> isEmpty s\n                              then let (l, (uu_, lp), r) =\n   splits (e_less_eq e) Infty s\n                                   in if e < fst (p_unwrap lp)\nthen app (consr (consr l () (LP e a)) () lp) r\nelse app (consr l () (LP e a)) r\n                              else consr s () (LP e a))))) =\n                      map_of (map p_unwrap (map snd (\\<alpha> s)))(e \n                      \\<mapsto> a)", "hence v5: \"e_less_eq e lp\""], ["proof (prove)\nusing this:\n  \\<alpha> s = \\<alpha> l @ ((), lp) # \\<alpha> r\n  \\<not> e_less_eq e (Infty + sum_list (map snd (\\<alpha> l)))\n  e_less_eq e (Infty + sum_list (map snd (\\<alpha> l)) + lp)\n  invar l\n  invar r\n\ngoal (1 subgoal):\n 1. e_less_eq e lp", "by (metis e_less_eq_lem1)"], ["proof (state)\nthis:\n  e_less_eq e lp\n\ngoal (1 subgoal):\n 1. \\<lbrakk>invar s \\<and>\n             (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n             sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n             distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s\\<rbrakk>\n    \\<Longrightarrow> map_of\n                       (map p_unwrap\n                         (map snd\n                           (\\<alpha>\n                             (if e_less_eq e (annot s) \\<and>\n                                 \\<not> isEmpty s\n                              then let (l, (uu_, lp), r) =\n   splits (e_less_eq e) Infty s\n                                   in if e < fst (p_unwrap lp)\nthen app (consr (consr l () (LP e a)) () lp) r\nelse app (consr l () (LP e a)) r\n                              else consr s () (LP e a))))) =\n                      map_of (map p_unwrap (map snd (\\<alpha> s)))(e \n                      \\<mapsto> a)", "hence v6: \"e \\<le> (fst (p_unwrap lp))\""], ["proof (prove)\nusing this:\n  e_less_eq e lp\n\ngoal (1 subgoal):\n 1. e \\<le> fst (p_unwrap lp)", "by (cases lp) auto"], ["proof (state)\nthis:\n  e \\<le> fst (p_unwrap lp)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>invar s \\<and>\n             (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n             sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n             distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s\\<rbrakk>\n    \\<Longrightarrow> map_of\n                       (map p_unwrap\n                         (map snd\n                           (\\<alpha>\n                             (if e_less_eq e (annot s) \\<and>\n                                 \\<not> isEmpty s\n                              then let (l, (uu_, lp), r) =\n   splits (e_less_eq e) Infty s\n                                   in if e < fst (p_unwrap lp)\nthen app (consr (consr l () (LP e a)) () lp) r\nelse app (consr l () (LP e a)) r\n                              else consr s () (LP e a))))) =\n                      map_of (map p_unwrap (map snd (\\<alpha> s)))(e \n                      \\<mapsto> a)", "have \"(Infty + sum_list (map snd (\\<alpha> l))) = (annot l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Infty + sum_list (map snd (\\<alpha> l)) = annot l", "by (metis add_0_left annot_correct v4(4) zero_def)"], ["proof (state)\nthis:\n  Infty + sum_list (map snd (\\<alpha> l)) = annot l\n\ngoal (1 subgoal):\n 1. \\<lbrakk>invar s \\<and>\n             (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n             sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n             distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s\\<rbrakk>\n    \\<Longrightarrow> map_of\n                       (map p_unwrap\n                         (map snd\n                           (\\<alpha>\n                             (if e_less_eq e (annot s) \\<and>\n                                 \\<not> isEmpty s\n                              then let (l, (uu_, lp), r) =\n   splits (e_less_eq e) Infty s\n                                   in if e < fst (p_unwrap lp)\nthen app (consr (consr l () (LP e a)) () lp) r\nelse app (consr l () (LP e a)) r\n                              else consr s () (LP e a))))) =\n                      map_of (map p_unwrap (map snd (\\<alpha> s)))(e \n                      \\<mapsto> a)", "hence v7:\"\\<not> e_less_eq e (annot l)\""], ["proof (prove)\nusing this:\n  Infty + sum_list (map snd (\\<alpha> l)) = annot l\n\ngoal (1 subgoal):\n 1. \\<not> e_less_eq e (annot l)", "using v4(2)"], ["proof (prove)\nusing this:\n  Infty + sum_list (map snd (\\<alpha> l)) = annot l\n  \\<not> e_less_eq e (Infty + sum_list (map snd (\\<alpha> l)))\n\ngoal (1 subgoal):\n 1. \\<not> e_less_eq e (annot l)", "by simp"], ["proof (state)\nthis:\n  \\<not> e_less_eq e (annot l)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>invar s \\<and>\n             (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n             sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n             distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s\\<rbrakk>\n    \\<Longrightarrow> map_of\n                       (map p_unwrap\n                         (map snd\n                           (\\<alpha>\n                             (if e_less_eq e (annot s) \\<and>\n                                 \\<not> isEmpty s\n                              then let (l, (uu_, lp), r) =\n   splits (e_less_eq e) Infty s\n                                   in if e < fst (p_unwrap lp)\nthen app (consr (consr l () (LP e a)) () lp) r\nelse app (consr l () (LP e a)) r\n                              else consr s () (LP e a))))) =\n                      map_of (map p_unwrap (map snd (\\<alpha> s)))(e \n                      \\<mapsto> a)", "have \"\\<forall>x\\<in>set (\\<alpha> l). snd x \\<noteq> Infty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (\\<alpha> l). snd x \\<noteq> Infty", "using g1asms v4(1)"], ["proof (prove)\nusing this:\n  invar s \\<and>\n  (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n  sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n  distinct (map fst (map p_unwrap (map snd (\\<alpha> s))))\n  \\<alpha> s = \\<alpha> l @ ((), lp) # \\<alpha> r\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (\\<alpha> l). snd x \\<noteq> Infty", "by simp"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (\\<alpha> l). snd x \\<noteq> Infty\n\ngoal (1 subgoal):\n 1. \\<lbrakk>invar s \\<and>\n             (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n             sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n             distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s\\<rbrakk>\n    \\<Longrightarrow> map_of\n                       (map p_unwrap\n                         (map snd\n                           (\\<alpha>\n                             (if e_less_eq e (annot s) \\<and>\n                                 \\<not> isEmpty s\n                              then let (l, (uu_, lp), r) =\n   splits (e_less_eq e) Infty s\n                                   in if e < fst (p_unwrap lp)\nthen app (consr (consr l () (LP e a)) () lp) r\nelse app (consr l () (LP e a)) r\n                              else consr s () (LP e a))))) =\n                      map_of (map p_unwrap (map snd (\\<alpha> s)))(e \n                      \\<mapsto> a)", "hence v7: \"\\<forall>x \\<in> set (map (fst \\<circ> (p_unwrap \\<circ> snd)) (\\<alpha> l)). x < e\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set (\\<alpha> l). snd x \\<noteq> Infty\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap\n                              snd)\n                         (\\<alpha> l)).\n       x < e", "using v4(4) v7 assms(2)"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set (\\<alpha> l). snd x \\<noteq> Infty\n  invar l\n  \\<not> e_less_eq e (annot l)\n  al_annot \\<alpha> invar annot\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap\n                              snd)\n                         (\\<alpha> l)).\n       x < e", "by(simp add: e_less_eq_annot)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap\n                            snd)\n                       (\\<alpha> l)).\n     x < e\n\ngoal (1 subgoal):\n 1. \\<lbrakk>invar s \\<and>\n             (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n             sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n             distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s\\<rbrakk>\n    \\<Longrightarrow> map_of\n                       (map p_unwrap\n                         (map snd\n                           (\\<alpha>\n                             (if e_less_eq e (annot s) \\<and>\n                                 \\<not> isEmpty s\n                              then let (l, (uu_, lp), r) =\n   splits (e_less_eq e) Infty s\n                                   in if e < fst (p_unwrap lp)\nthen app (consr (consr l () (LP e a)) () lp) r\nelse app (consr l () (LP e a)) r\n                              else consr s () (LP e a))))) =\n                      map_of (map p_unwrap (map snd (\\<alpha> s)))(e \n                      \\<mapsto> a)", "have v8:\"map fst (map p_unwrap (map snd (\\<alpha> s))) = \n        map fst (map p_unwrap (map snd (\\<alpha> l))) @ fst(p_unwrap lp) #\n        map fst (map p_unwrap (map snd (\\<alpha> r)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map fst (map p_unwrap (map snd (\\<alpha> s))) =\n    map fst (map p_unwrap (map snd (\\<alpha> l))) @\n    fst (p_unwrap lp) # map fst (map p_unwrap (map snd (\\<alpha> r)))", "using v4(1)"], ["proof (prove)\nusing this:\n  \\<alpha> s = \\<alpha> l @ ((), lp) # \\<alpha> r\n\ngoal (1 subgoal):\n 1. map fst (map p_unwrap (map snd (\\<alpha> s))) =\n    map fst (map p_unwrap (map snd (\\<alpha> l))) @\n    fst (p_unwrap lp) # map fst (map p_unwrap (map snd (\\<alpha> r)))", "by simp"], ["proof (state)\nthis:\n  map fst (map p_unwrap (map snd (\\<alpha> s))) =\n  map fst (map p_unwrap (map snd (\\<alpha> l))) @\n  fst (p_unwrap lp) # map fst (map p_unwrap (map snd (\\<alpha> r)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>invar s \\<and>\n             (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n             sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n             distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s\\<rbrakk>\n    \\<Longrightarrow> map_of\n                       (map p_unwrap\n                         (map snd\n                           (\\<alpha>\n                             (if e_less_eq e (annot s) \\<and>\n                                 \\<not> isEmpty s\n                              then let (l, (uu_, lp), r) =\n   splits (e_less_eq e) Infty s\n                                   in if e < fst (p_unwrap lp)\nthen app (consr (consr l () (LP e a)) () lp) r\nelse app (consr l () (LP e a)) r\n                              else consr s () (LP e a))))) =\n                      map_of (map p_unwrap (map snd (\\<alpha> s)))(e \n                      \\<mapsto> a)", "note distinct_sortet_list_app[of \"map fst (map p_unwrap (map snd (\\<alpha> s)))\"\n        \"map fst (map p_unwrap (map snd (\\<alpha> l)))\" \"fst(p_unwrap lp)\" \n        \"map fst (map p_unwrap (map snd (\\<alpha> r)))\"]"], ["proof (state)\nthis:\n  \\<lbrakk>sorted (map fst (map p_unwrap (map snd (\\<alpha> s))));\n   distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n   map fst (map p_unwrap (map snd (\\<alpha> s))) =\n   map fst (map p_unwrap (map snd (\\<alpha> l))) @\n   fst (p_unwrap lp) #\n   map fst (map p_unwrap (map snd (\\<alpha> r)))\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x\\<in>set (map fst\n   (map p_unwrap (map snd (\\<alpha> r)))).\n                       fst (p_unwrap lp) < x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>invar s \\<and>\n             (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n             sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n             distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s\\<rbrakk>\n    \\<Longrightarrow> map_of\n                       (map p_unwrap\n                         (map snd\n                           (\\<alpha>\n                             (if e_less_eq e (annot s) \\<and>\n                                 \\<not> isEmpty s\n                              then let (l, (uu_, lp), r) =\n   splits (e_less_eq e) Infty s\n                                   in if e < fst (p_unwrap lp)\nthen app (consr (consr l () (LP e a)) () lp) r\nelse app (consr l () (LP e a)) r\n                              else consr s () (LP e a))))) =\n                      map_of (map p_unwrap (map snd (\\<alpha> s)))(e \n                      \\<mapsto> a)", "hence v9: \"\n        \\<forall> x\\<in>set (map (fst \\<circ> (p_unwrap \\<circ> snd)) (\\<alpha> r)). fst(p_unwrap lp) < x\""], ["proof (prove)\nusing this:\n  \\<lbrakk>sorted (map fst (map p_unwrap (map snd (\\<alpha> s))));\n   distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n   map fst (map p_unwrap (map snd (\\<alpha> s))) =\n   map fst (map p_unwrap (map snd (\\<alpha> l))) @\n   fst (p_unwrap lp) #\n   map fst (map p_unwrap (map snd (\\<alpha> r)))\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x\\<in>set (map fst\n   (map p_unwrap (map snd (\\<alpha> r)))).\n                       fst (p_unwrap lp) < x\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap\n                              snd)\n                         (\\<alpha> r)).\n       fst (p_unwrap lp) < x", "using v4(1) g1asms v8"], ["proof (prove)\nusing this:\n  \\<lbrakk>sorted (map fst (map p_unwrap (map snd (\\<alpha> s))));\n   distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n   map fst (map p_unwrap (map snd (\\<alpha> s))) =\n   map fst (map p_unwrap (map snd (\\<alpha> l))) @\n   fst (p_unwrap lp) #\n   map fst (map p_unwrap (map snd (\\<alpha> r)))\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x\\<in>set (map fst\n   (map p_unwrap (map snd (\\<alpha> r)))).\n                       fst (p_unwrap lp) < x\n  \\<alpha> s = \\<alpha> l @ ((), lp) # \\<alpha> r\n  invar s \\<and>\n  (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n  sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n  distinct (map fst (map p_unwrap (map snd (\\<alpha> s))))\n  map fst (map p_unwrap (map snd (\\<alpha> s))) =\n  map fst (map p_unwrap (map snd (\\<alpha> l))) @\n  fst (p_unwrap lp) # map fst (map p_unwrap (map snd (\\<alpha> r)))\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap\n                              snd)\n                         (\\<alpha> r)).\n       fst (p_unwrap lp) < x", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap\n                            snd)\n                       (\\<alpha> r)).\n     fst (p_unwrap lp) < x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>invar s \\<and>\n             (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n             sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n             distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s\\<rbrakk>\n    \\<Longrightarrow> map_of\n                       (map p_unwrap\n                         (map snd\n                           (\\<alpha>\n                             (if e_less_eq e (annot s) \\<and>\n                                 \\<not> isEmpty s\n                              then let (l, (uu_, lp), r) =\n   splits (e_less_eq e) Infty s\n                                   in if e < fst (p_unwrap lp)\nthen app (consr (consr l () (LP e a)) () lp) r\nelse app (consr l () (LP e a)) r\n                              else consr s () (LP e a))))) =\n                      map_of (map p_unwrap (map snd (\\<alpha> s)))(e \n                      \\<mapsto> a)", "hence v10: \" \\<forall> x\\<in>set (map (fst \\<circ> (p_unwrap \\<circ> snd)) (\\<alpha> r)). e < x\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap\n                            snd)\n                       (\\<alpha> r)).\n     fst (p_unwrap lp) < x\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap\n                              snd)\n                         (\\<alpha> r)).\n       e < x", "using v6"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap\n                            snd)\n                       (\\<alpha> r)).\n     fst (p_unwrap lp) < x\n  e \\<le> fst (p_unwrap lp)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap\n                              snd)\n                         (\\<alpha> r)).\n       e < x", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap\n                            snd)\n                       (\\<alpha> r)).\n     e < x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>invar s \\<and>\n             (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n             sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n             distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s\\<rbrakk>\n    \\<Longrightarrow> map_of\n                       (map p_unwrap\n                         (map snd\n                           (\\<alpha>\n                             (if e_less_eq e (annot s) \\<and>\n                                 \\<not> isEmpty s\n                              then let (l, (uu_, lp), r) =\n   splits (e_less_eq e) Infty s\n                                   in if e < fst (p_unwrap lp)\nthen app (consr (consr l () (LP e a)) () lp) r\nelse app (consr l () (LP e a)) r\n                              else consr s () (LP e a))))) =\n                      map_of (map p_unwrap (map snd (\\<alpha> s)))(e \n                      \\<mapsto> a)", "have v11: \n        \"e \\<notin> set (map fst (map p_unwrap (map snd (\\<alpha> l))))\"\n        \"e \\<notin> set (map fst (map p_unwrap (map snd (\\<alpha> r))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e \\<notin> set (map fst (map p_unwrap (map snd (\\<alpha> l)))) &&&\n    e \\<notin> set (map fst (map p_unwrap (map snd (\\<alpha> r))))", "using v7 v10 v8 g1asms"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap\n                            snd)\n                       (\\<alpha> l)).\n     x < e\n  \\<forall>x\\<in>set (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap\n                            snd)\n                       (\\<alpha> r)).\n     e < x\n  map fst (map p_unwrap (map snd (\\<alpha> s))) =\n  map fst (map p_unwrap (map snd (\\<alpha> l))) @\n  fst (p_unwrap lp) # map fst (map p_unwrap (map snd (\\<alpha> r)))\n  invar s \\<and>\n  (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n  sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n  distinct (map fst (map p_unwrap (map snd (\\<alpha> s))))\n\ngoal (1 subgoal):\n 1. e \\<notin> set (map fst (map p_unwrap (map snd (\\<alpha> l)))) &&&\n    e \\<notin> set (map fst (map p_unwrap (map snd (\\<alpha> r))))", "by auto"], ["proof (state)\nthis:\n  e \\<notin> set (map fst (map p_unwrap (map snd (\\<alpha> l))))\n  e \\<notin> set (map fst (map p_unwrap (map snd (\\<alpha> r))))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>invar s \\<and>\n             (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n             sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n             distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s\\<rbrakk>\n    \\<Longrightarrow> map_of\n                       (map p_unwrap\n                         (map snd\n                           (\\<alpha>\n                             (if e_less_eq e (annot s) \\<and>\n                                 \\<not> isEmpty s\n                              then let (l, (uu_, lp), r) =\n   splits (e_less_eq e) Infty s\n                                   in if e < fst (p_unwrap lp)\nthen app (consr (consr l () (LP e a)) () lp) r\nelse app (consr l () (LP e a)) r\n                              else consr s () (LP e a))))) =\n                      map_of (map p_unwrap (map snd (\\<alpha> s)))(e \n                      \\<mapsto> a)", "from l_lp_r T1 g1asms"], ["proof (chain)\npicking this:\n  splits (e_less_eq e) Infty s = (l, ((), lp), r)\n  e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n  invar s \\<and>\n  (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n  sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n  distinct (map fst (map p_unwrap (map snd (\\<alpha> s))))", "show ?thesis"], ["proof (prove)\nusing this:\n  splits (e_less_eq e) Infty s = (l, ((), lp), r)\n  e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n  invar s \\<and>\n  (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n  sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n  distinct (map fst (map p_unwrap (map snd (\\<alpha> s))))\n\ngoal (1 subgoal):\n 1. map_of\n     (map p_unwrap\n       (map snd\n         (\\<alpha>\n           (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n            then let (l, (uu_, lp), r) = splits (e_less_eq e) Infty s\n                 in if e < fst (p_unwrap lp)\n                    then app (consr (consr l () (LP e a)) () lp) r\n                    else app (consr l () (LP e a)) r\n            else consr s () (LP e a))))) =\n    map_of (map p_unwrap (map snd (\\<alpha> s)))(e \\<mapsto> a)", "proof (fold aluprio_insert_def, cases \"e < fst (p_unwrap lp)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     e < fst (p_unwrap lp)\\<rbrakk>\n    \\<Longrightarrow> map_of\n                       (map p_unwrap\n                         (map snd\n                           (\\<alpha>\n                             (aluprio_insert splits annot isEmpty app consr\n                               s e a)))) =\n                      map_of (map p_unwrap (map snd (\\<alpha> s)))(e \n                      \\<mapsto> a)\n 2. \\<lbrakk>splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     \\<not> e < fst (p_unwrap lp)\\<rbrakk>\n    \\<Longrightarrow> map_of\n                       (map p_unwrap\n                         (map snd\n                           (\\<alpha>\n                             (aluprio_insert splits annot isEmpty app consr\n                               s e a)))) =\n                      map_of (map p_unwrap (map snd (\\<alpha> s)))(e \n                      \\<mapsto> a)", "case True"], ["proof (state)\nthis:\n  e < fst (p_unwrap lp)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     e < fst (p_unwrap lp)\\<rbrakk>\n    \\<Longrightarrow> map_of\n                       (map p_unwrap\n                         (map snd\n                           (\\<alpha>\n                             (aluprio_insert splits annot isEmpty app consr\n                               s e a)))) =\n                      map_of (map p_unwrap (map snd (\\<alpha> s)))(e \n                      \\<mapsto> a)\n 2. \\<lbrakk>splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     \\<not> e < fst (p_unwrap lp)\\<rbrakk>\n    \\<Longrightarrow> map_of\n                       (map p_unwrap\n                         (map snd\n                           (\\<alpha>\n                             (aluprio_insert splits annot isEmpty app consr\n                               s e a)))) =\n                      map_of (map p_unwrap (map snd (\\<alpha> s)))(e \n                      \\<mapsto> a)", "hence v12: \n          \"aluprio_insert splits annot isEmpty app consr s e a \n            = app (consr (consr l () (LP e a)) () lp) r\""], ["proof (prove)\nusing this:\n  e < fst (p_unwrap lp)\n\ngoal (1 subgoal):\n 1. aluprio_insert splits annot isEmpty app consr s e a =\n    app (consr (consr l () (LP e a)) () lp) r", "using l_lp_r T1"], ["proof (prove)\nusing this:\n  e < fst (p_unwrap lp)\n  splits (e_less_eq e) Infty s = (l, ((), lp), r)\n  e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n\ngoal (1 subgoal):\n 1. aluprio_insert splits annot isEmpty app consr s e a =\n    app (consr (consr l () (LP e a)) () lp) r", "by (auto simp add: aluprio_defs)"], ["proof (state)\nthis:\n  aluprio_insert splits annot isEmpty app consr s e a =\n  app (consr (consr l () (LP e a)) () lp) r\n\ngoal (2 subgoals):\n 1. \\<lbrakk>splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     e < fst (p_unwrap lp)\\<rbrakk>\n    \\<Longrightarrow> map_of\n                       (map p_unwrap\n                         (map snd\n                           (\\<alpha>\n                             (aluprio_insert splits annot isEmpty app consr\n                               s e a)))) =\n                      map_of (map p_unwrap (map snd (\\<alpha> s)))(e \n                      \\<mapsto> a)\n 2. \\<lbrakk>splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     \\<not> e < fst (p_unwrap lp)\\<rbrakk>\n    \\<Longrightarrow> map_of\n                       (map p_unwrap\n                         (map snd\n                           (\\<alpha>\n                             (aluprio_insert splits annot isEmpty app consr\n                               s e a)))) =\n                      map_of (map p_unwrap (map snd (\\<alpha> s)))(e \n                      \\<mapsto> a)", "have v13: \n          \"\\<alpha> (app (consr (consr l () (LP e a)) () lp) r) \n            = \\<alpha> l @ ((),(LP e a)) # ((), lp) # \\<alpha> r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (app (consr (consr l () (LP e a)) () lp) r) =\n    \\<alpha> l @ ((), LP e a) # ((), lp) # \\<alpha> r", "using v4(4,5)"], ["proof (prove)\nusing this:\n  invar l\n  invar r\n\ngoal (1 subgoal):\n 1. \\<alpha> (app (consr (consr l () (LP e a)) () lp) r) =\n    \\<alpha> l @ ((), LP e a) # ((), lp) # \\<alpha> r", "by (auto simp add: app_correct consr_correct)"], ["proof (state)\nthis:\n  \\<alpha> (app (consr (consr l () (LP e a)) () lp) r) =\n  \\<alpha> l @ ((), LP e a) # ((), lp) # \\<alpha> r\n\ngoal (2 subgoals):\n 1. \\<lbrakk>splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     e < fst (p_unwrap lp)\\<rbrakk>\n    \\<Longrightarrow> map_of\n                       (map p_unwrap\n                         (map snd\n                           (\\<alpha>\n                             (aluprio_insert splits annot isEmpty app consr\n                               s e a)))) =\n                      map_of (map p_unwrap (map snd (\\<alpha> s)))(e \n                      \\<mapsto> a)\n 2. \\<lbrakk>splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     \\<not> e < fst (p_unwrap lp)\\<rbrakk>\n    \\<Longrightarrow> map_of\n                       (map p_unwrap\n                         (map snd\n                           (\\<alpha>\n                             (aluprio_insert splits annot isEmpty app consr\n                               s e a)))) =\n                      map_of (map p_unwrap (map snd (\\<alpha> s)))(e \n                      \\<mapsto> a)", "have v14: \"e = fst(p_unwrap (LP e a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e = fst (p_unwrap (LP e a))", "by simp"], ["proof (state)\nthis:\n  e = fst (p_unwrap (LP e a))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     e < fst (p_unwrap lp)\\<rbrakk>\n    \\<Longrightarrow> map_of\n                       (map p_unwrap\n                         (map snd\n                           (\\<alpha>\n                             (aluprio_insert splits annot isEmpty app consr\n                               s e a)))) =\n                      map_of (map p_unwrap (map snd (\\<alpha> s)))(e \n                      \\<mapsto> a)\n 2. \\<lbrakk>splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     \\<not> e < fst (p_unwrap lp)\\<rbrakk>\n    \\<Longrightarrow> map_of\n                       (map p_unwrap\n                         (map snd\n                           (\\<alpha>\n                             (aluprio_insert splits annot isEmpty app consr\n                               s e a)))) =\n                      map_of (map p_unwrap (map snd (\\<alpha> s)))(e \n                      \\<mapsto> a)", "have v15: \"e \\<notin> set (map fst (map p_unwrap (map snd(((),lp)#\\<alpha> r))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e \\<notin> set (map fst\n                     (map p_unwrap (map snd (((), lp) # \\<alpha> r))))", "using v11(2) True"], ["proof (prove)\nusing this:\n  e \\<notin> set (map fst (map p_unwrap (map snd (\\<alpha> r))))\n  e < fst (p_unwrap lp)\n\ngoal (1 subgoal):\n 1. e \\<notin> set (map fst\n                     (map p_unwrap (map snd (((), lp) # \\<alpha> r))))", "by auto"], ["proof (state)\nthis:\n  e \\<notin> set (map fst (map p_unwrap (map snd (((), lp) # \\<alpha> r))))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     e < fst (p_unwrap lp)\\<rbrakk>\n    \\<Longrightarrow> map_of\n                       (map p_unwrap\n                         (map snd\n                           (\\<alpha>\n                             (aluprio_insert splits annot isEmpty app consr\n                               s e a)))) =\n                      map_of (map p_unwrap (map snd (\\<alpha> s)))(e \n                      \\<mapsto> a)\n 2. \\<lbrakk>splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     \\<not> e < fst (p_unwrap lp)\\<rbrakk>\n    \\<Longrightarrow> map_of\n                       (map p_unwrap\n                         (map snd\n                           (\\<alpha>\n                             (aluprio_insert splits annot isEmpty app consr\n                               s e a)))) =\n                      map_of (map p_unwrap (map snd (\\<alpha> s)))(e \n                      \\<mapsto> a)", "note map_of_distinct_upd2[OF v11(1) v15]"], ["proof (state)\nthis:\n  map_of\n   (map p_unwrap (map snd (\\<alpha> l)) @\n    (e, ?y) # map p_unwrap (map snd (((), lp) # \\<alpha> r))) =\n  map_of\n   (map p_unwrap (map snd (\\<alpha> l)) @\n    map p_unwrap (map snd (((), lp) # \\<alpha> r)))\n  (e \\<mapsto> ?y)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     e < fst (p_unwrap lp)\\<rbrakk>\n    \\<Longrightarrow> map_of\n                       (map p_unwrap\n                         (map snd\n                           (\\<alpha>\n                             (aluprio_insert splits annot isEmpty app consr\n                               s e a)))) =\n                      map_of (map p_unwrap (map snd (\\<alpha> s)))(e \n                      \\<mapsto> a)\n 2. \\<lbrakk>splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     \\<not> e < fst (p_unwrap lp)\\<rbrakk>\n    \\<Longrightarrow> map_of\n                       (map p_unwrap\n                         (map snd\n                           (\\<alpha>\n                             (aluprio_insert splits annot isEmpty app consr\n                               s e a)))) =\n                      map_of (map p_unwrap (map snd (\\<alpha> s)))(e \n                      \\<mapsto> a)", "thus \n          \"map_of (map p_unwrap (map snd (\\<alpha> \n              (aluprio_insert splits annot isEmpty app consr s e a)))) \n            = map_of (map p_unwrap (map snd (\\<alpha> s)))(e \\<mapsto> a)\""], ["proof (prove)\nusing this:\n  map_of\n   (map p_unwrap (map snd (\\<alpha> l)) @\n    (e, ?y) # map p_unwrap (map snd (((), lp) # \\<alpha> r))) =\n  map_of\n   (map p_unwrap (map snd (\\<alpha> l)) @\n    map p_unwrap (map snd (((), lp) # \\<alpha> r)))\n  (e \\<mapsto> ?y)\n\ngoal (1 subgoal):\n 1. map_of\n     (map p_unwrap\n       (map snd\n         (\\<alpha>\n           (aluprio_insert splits annot isEmpty app consr s e a)))) =\n    map_of (map p_unwrap (map snd (\\<alpha> s)))(e \\<mapsto> a)", "using v12 v13 v4(1)"], ["proof (prove)\nusing this:\n  map_of\n   (map p_unwrap (map snd (\\<alpha> l)) @\n    (e, ?y) # map p_unwrap (map snd (((), lp) # \\<alpha> r))) =\n  map_of\n   (map p_unwrap (map snd (\\<alpha> l)) @\n    map p_unwrap (map snd (((), lp) # \\<alpha> r)))\n  (e \\<mapsto> ?y)\n  aluprio_insert splits annot isEmpty app consr s e a =\n  app (consr (consr l () (LP e a)) () lp) r\n  \\<alpha> (app (consr (consr l () (LP e a)) () lp) r) =\n  \\<alpha> l @ ((), LP e a) # ((), lp) # \\<alpha> r\n  \\<alpha> s = \\<alpha> l @ ((), lp) # \\<alpha> r\n\ngoal (1 subgoal):\n 1. map_of\n     (map p_unwrap\n       (map snd\n         (\\<alpha>\n           (aluprio_insert splits annot isEmpty app consr s e a)))) =\n    map_of (map p_unwrap (map snd (\\<alpha> s)))(e \\<mapsto> a)", "by simp"], ["proof (state)\nthis:\n  map_of\n   (map p_unwrap\n     (map snd\n       (\\<alpha> (aluprio_insert splits annot isEmpty app consr s e a)))) =\n  map_of (map p_unwrap (map snd (\\<alpha> s)))(e \\<mapsto> a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     \\<not> e < fst (p_unwrap lp)\\<rbrakk>\n    \\<Longrightarrow> map_of\n                       (map p_unwrap\n                         (map snd\n                           (\\<alpha>\n                             (aluprio_insert splits annot isEmpty app consr\n                               s e a)))) =\n                      map_of (map p_unwrap (map snd (\\<alpha> s)))(e \n                      \\<mapsto> a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     \\<not> e < fst (p_unwrap lp)\\<rbrakk>\n    \\<Longrightarrow> map_of\n                       (map p_unwrap\n                         (map snd\n                           (\\<alpha>\n                             (aluprio_insert splits annot isEmpty app consr\n                               s e a)))) =\n                      map_of (map p_unwrap (map snd (\\<alpha> s)))(e \n                      \\<mapsto> a)", "case False"], ["proof (state)\nthis:\n  \\<not> e < fst (p_unwrap lp)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     \\<not> e < fst (p_unwrap lp)\\<rbrakk>\n    \\<Longrightarrow> map_of\n                       (map p_unwrap\n                         (map snd\n                           (\\<alpha>\n                             (aluprio_insert splits annot isEmpty app consr\n                               s e a)))) =\n                      map_of (map p_unwrap (map snd (\\<alpha> s)))(e \n                      \\<mapsto> a)", "hence v12: \n          \"aluprio_insert splits annot isEmpty app consr s e a \n            = app (consr l () (LP e a)) r\""], ["proof (prove)\nusing this:\n  \\<not> e < fst (p_unwrap lp)\n\ngoal (1 subgoal):\n 1. aluprio_insert splits annot isEmpty app consr s e a =\n    app (consr l () (LP e a)) r", "using l_lp_r T1"], ["proof (prove)\nusing this:\n  \\<not> e < fst (p_unwrap lp)\n  splits (e_less_eq e) Infty s = (l, ((), lp), r)\n  e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n\ngoal (1 subgoal):\n 1. aluprio_insert splits annot isEmpty app consr s e a =\n    app (consr l () (LP e a)) r", "by (auto simp add: aluprio_defs)"], ["proof (state)\nthis:\n  aluprio_insert splits annot isEmpty app consr s e a =\n  app (consr l () (LP e a)) r\n\ngoal (1 subgoal):\n 1. \\<lbrakk>splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     \\<not> e < fst (p_unwrap lp)\\<rbrakk>\n    \\<Longrightarrow> map_of\n                       (map p_unwrap\n                         (map snd\n                           (\\<alpha>\n                             (aluprio_insert splits annot isEmpty app consr\n                               s e a)))) =\n                      map_of (map p_unwrap (map snd (\\<alpha> s)))(e \n                      \\<mapsto> a)", "have v13: \n          \"\\<alpha> (app (consr l () (LP e a)) r) = \\<alpha> l @ ((),(LP e a)) # \\<alpha> r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> (app (consr l () (LP e a)) r) =\n    \\<alpha> l @ ((), LP e a) # \\<alpha> r", "using v4(4,5)"], ["proof (prove)\nusing this:\n  invar l\n  invar r\n\ngoal (1 subgoal):\n 1. \\<alpha> (app (consr l () (LP e a)) r) =\n    \\<alpha> l @ ((), LP e a) # \\<alpha> r", "by (auto simp add: app_correct consr_correct)"], ["proof (state)\nthis:\n  \\<alpha> (app (consr l () (LP e a)) r) =\n  \\<alpha> l @ ((), LP e a) # \\<alpha> r\n\ngoal (1 subgoal):\n 1. \\<lbrakk>splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     \\<not> e < fst (p_unwrap lp)\\<rbrakk>\n    \\<Longrightarrow> map_of\n                       (map p_unwrap\n                         (map snd\n                           (\\<alpha>\n                             (aluprio_insert splits annot isEmpty app consr\n                               s e a)))) =\n                      map_of (map p_unwrap (map snd (\\<alpha> s)))(e \n                      \\<mapsto> a)", "have v14: \"e = fst(p_unwrap lp)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e = fst (p_unwrap lp)", "using False v5"], ["proof (prove)\nusing this:\n  \\<not> e < fst (p_unwrap lp)\n  e_less_eq e lp\n\ngoal (1 subgoal):\n 1. e = fst (p_unwrap lp)", "by (cases lp) auto"], ["proof (state)\nthis:\n  e = fst (p_unwrap lp)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     \\<not> e < fst (p_unwrap lp)\\<rbrakk>\n    \\<Longrightarrow> map_of\n                       (map p_unwrap\n                         (map snd\n                           (\\<alpha>\n                             (aluprio_insert splits annot isEmpty app consr\n                               s e a)))) =\n                      map_of (map p_unwrap (map snd (\\<alpha> s)))(e \n                      \\<mapsto> a)", "note v15 = map_of_distinct_upd3[OF v11(1) v11(2)]"], ["proof (state)\nthis:\n  map_of\n   (map p_unwrap (map snd (\\<alpha> l)) @\n    (e, ?y) # map p_unwrap (map snd (\\<alpha> r))) =\n  map_of\n   (map p_unwrap (map snd (\\<alpha> l)) @\n    (e, ?y') # map p_unwrap (map snd (\\<alpha> r)))\n  (e \\<mapsto> ?y)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     \\<not> e < fst (p_unwrap lp)\\<rbrakk>\n    \\<Longrightarrow> map_of\n                       (map p_unwrap\n                         (map snd\n                           (\\<alpha>\n                             (aluprio_insert splits annot isEmpty app consr\n                               s e a)))) =\n                      map_of (map p_unwrap (map snd (\\<alpha> s)))(e \n                      \\<mapsto> a)", "have v16:\"(map p_unwrap (map snd (\\<alpha> s))) = \n          (map p_unwrap (map snd (\\<alpha> l))) @ (e,snd(p_unwrap lp)) #\n          (map p_unwrap (map snd (\\<alpha> r)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map p_unwrap (map snd (\\<alpha> s)) =\n    map p_unwrap (map snd (\\<alpha> l)) @\n    (e, snd (p_unwrap lp)) # map p_unwrap (map snd (\\<alpha> r))", "using v4(1) v14"], ["proof (prove)\nusing this:\n  \\<alpha> s = \\<alpha> l @ ((), lp) # \\<alpha> r\n  e = fst (p_unwrap lp)\n\ngoal (1 subgoal):\n 1. map p_unwrap (map snd (\\<alpha> s)) =\n    map p_unwrap (map snd (\\<alpha> l)) @\n    (e, snd (p_unwrap lp)) # map p_unwrap (map snd (\\<alpha> r))", "by simp"], ["proof (state)\nthis:\n  map p_unwrap (map snd (\\<alpha> s)) =\n  map p_unwrap (map snd (\\<alpha> l)) @\n  (e, snd (p_unwrap lp)) # map p_unwrap (map snd (\\<alpha> r))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     \\<not> e < fst (p_unwrap lp)\\<rbrakk>\n    \\<Longrightarrow> map_of\n                       (map p_unwrap\n                         (map snd\n                           (\\<alpha>\n                             (aluprio_insert splits annot isEmpty app consr\n                               s e a)))) =\n                      map_of (map p_unwrap (map snd (\\<alpha> s)))(e \n                      \\<mapsto> a)", "note v15[of a \"snd(p_unwrap lp)\"]"], ["proof (state)\nthis:\n  map_of\n   (map p_unwrap (map snd (\\<alpha> l)) @\n    (e, a) # map p_unwrap (map snd (\\<alpha> r))) =\n  map_of\n   (map p_unwrap (map snd (\\<alpha> l)) @\n    (e, snd (p_unwrap lp)) # map p_unwrap (map snd (\\<alpha> r)))\n  (e \\<mapsto> a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s;\n     invar s \\<and>\n     (\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) \\<and>\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) \\<and>\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     \\<not> e < fst (p_unwrap lp)\\<rbrakk>\n    \\<Longrightarrow> map_of\n                       (map p_unwrap\n                         (map snd\n                           (\\<alpha>\n                             (aluprio_insert splits annot isEmpty app consr\n                               s e a)))) =\n                      map_of (map p_unwrap (map snd (\\<alpha> s)))(e \n                      \\<mapsto> a)", "thus \n          \"map_of (map p_unwrap (map snd (\\<alpha> \n              (aluprio_insert splits annot isEmpty app consr s e a)))) \n            = map_of (map p_unwrap (map snd (\\<alpha> s)))(e \\<mapsto> a)\""], ["proof (prove)\nusing this:\n  map_of\n   (map p_unwrap (map snd (\\<alpha> l)) @\n    (e, a) # map p_unwrap (map snd (\\<alpha> r))) =\n  map_of\n   (map p_unwrap (map snd (\\<alpha> l)) @\n    (e, snd (p_unwrap lp)) # map p_unwrap (map snd (\\<alpha> r)))\n  (e \\<mapsto> a)\n\ngoal (1 subgoal):\n 1. map_of\n     (map p_unwrap\n       (map snd\n         (\\<alpha>\n           (aluprio_insert splits annot isEmpty app consr s e a)))) =\n    map_of (map p_unwrap (map snd (\\<alpha> s)))(e \\<mapsto> a)", "using v12 v13 v16"], ["proof (prove)\nusing this:\n  map_of\n   (map p_unwrap (map snd (\\<alpha> l)) @\n    (e, a) # map p_unwrap (map snd (\\<alpha> r))) =\n  map_of\n   (map p_unwrap (map snd (\\<alpha> l)) @\n    (e, snd (p_unwrap lp)) # map p_unwrap (map snd (\\<alpha> r)))\n  (e \\<mapsto> a)\n  aluprio_insert splits annot isEmpty app consr s e a =\n  app (consr l () (LP e a)) r\n  \\<alpha> (app (consr l () (LP e a)) r) =\n  \\<alpha> l @ ((), LP e a) # \\<alpha> r\n  map p_unwrap (map snd (\\<alpha> s)) =\n  map p_unwrap (map snd (\\<alpha> l)) @\n  (e, snd (p_unwrap lp)) # map p_unwrap (map snd (\\<alpha> r))\n\ngoal (1 subgoal):\n 1. map_of\n     (map p_unwrap\n       (map snd\n         (\\<alpha>\n           (aluprio_insert splits annot isEmpty app consr s e a)))) =\n    map_of (map p_unwrap (map snd (\\<alpha> s)))(e \\<mapsto> a)", "by simp"], ["proof (state)\nthis:\n  map_of\n   (map p_unwrap\n     (map snd\n       (\\<alpha> (aluprio_insert splits annot isEmpty app consr s e a)))) =\n  map_of (map p_unwrap (map snd (\\<alpha> s)))(e \\<mapsto> a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map_of\n   (map p_unwrap\n     (map snd\n       (\\<alpha>\n         (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n          then let (l, (uu_, lp), r) = splits (e_less_eq e) Infty s\n               in if e < fst (p_unwrap lp)\n                  then app (consr (consr l () (LP e a)) () lp) r\n                  else app (consr l () (LP e a)) r\n          else consr s () (LP e a))))) =\n  map_of (map p_unwrap (map snd (\\<alpha> s)))(e \\<mapsto> a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map_of\n   (map p_unwrap\n     (map snd\n       (\\<alpha>\n         (if e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n          then let (l, (uu_, lp), r) = splits (e_less_eq e) Infty s\n               in if e < fst (p_unwrap lp)\n                  then app (consr (consr l () (LP e a)) () lp) r\n                  else app (consr l () (LP e a)) r\n          else consr s () (LP e a))))) =\n  map_of (map p_unwrap (map snd (\\<alpha> s)))(e \\<mapsto> a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  uprio_insert (aluprio_\\<alpha> \\<alpha>) (aluprio_invar \\<alpha> invar)\n   (aluprio_insert splits annot isEmpty app consr)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \"Prio\""], ["", "lemma aluprio_prio_correct: \n  assumes \n  \"al_splits \\<alpha> invar splits\"\n  \"al_annot \\<alpha> invar annot\"\n  \"al_isEmpty \\<alpha> invar isEmpty\"\n  shows \n  \"uprio_prio (aluprio_\\<alpha> \\<alpha>) (aluprio_invar \\<alpha> invar) (aluprio_prio splits annot isEmpty)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uprio_prio (aluprio_\\<alpha> \\<alpha>) (aluprio_invar \\<alpha> invar)\n     (aluprio_prio splits annot isEmpty)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. uprio_prio (aluprio_\\<alpha> \\<alpha>) (aluprio_invar \\<alpha> invar)\n     (aluprio_prio splits annot isEmpty)", "interpret al_splits \\<alpha> invar splits"], ["proof (prove)\ngoal (1 subgoal):\n 1. al_splits \\<alpha> invar splits", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. uprio_prio (aluprio_\\<alpha> \\<alpha>) (aluprio_invar \\<alpha> invar)\n     (aluprio_prio splits annot isEmpty)", "interpret al_annot \\<alpha> invar annot"], ["proof (prove)\ngoal (1 subgoal):\n 1. al_annot \\<alpha> invar annot", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. uprio_prio (aluprio_\\<alpha> \\<alpha>) (aluprio_invar \\<alpha> invar)\n     (aluprio_prio splits annot isEmpty)", "interpret al_isEmpty \\<alpha> invar isEmpty"], ["proof (prove)\ngoal (1 subgoal):\n 1. al_isEmpty \\<alpha> invar isEmpty", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. uprio_prio (aluprio_\\<alpha> \\<alpha>) (aluprio_invar \\<alpha> invar)\n     (aluprio_prio splits annot isEmpty)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. uprio_prio (aluprio_\\<alpha> \\<alpha>) (aluprio_invar \\<alpha> invar)\n     (aluprio_prio splits annot isEmpty)", "proof (unfold_locales)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s e.\n       aluprio_invar \\<alpha> invar s \\<Longrightarrow>\n       aluprio_prio splits annot isEmpty s e = aluprio_\\<alpha> \\<alpha> s e", "fix s e"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s e.\n       aluprio_invar \\<alpha> invar s \\<Longrightarrow>\n       aluprio_prio splits annot isEmpty s e = aluprio_\\<alpha> \\<alpha> s e", "assume inv1: \"aluprio_invar \\<alpha> invar s\""], ["proof (state)\nthis:\n  aluprio_invar \\<alpha> invar s\n\ngoal (1 subgoal):\n 1. \\<And>s e.\n       aluprio_invar \\<alpha> invar s \\<Longrightarrow>\n       aluprio_prio splits annot isEmpty s e = aluprio_\\<alpha> \\<alpha> s e", "hence sinv: \"invar s\" \n      \"(\\<forall> x\\<in>set (\\<alpha> s). snd x\\<noteq>Infty)\"\n      \"sorted (map fst (map p_unwrap (map snd (\\<alpha> s))))\" \n      \"distinct (map fst (map p_unwrap (map snd (\\<alpha> s))))\""], ["proof (prove)\nusing this:\n  aluprio_invar \\<alpha> invar s\n\ngoal (1 subgoal):\n 1. (invar s &&& \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) &&&\n    sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) &&&\n    distinct (map fst (map p_unwrap (map snd (\\<alpha> s))))", "by (auto simp add: aluprio_defs)"], ["proof (state)\nthis:\n  invar s\n  \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty\n  sorted (map fst (map p_unwrap (map snd (\\<alpha> s))))\n  distinct (map fst (map p_unwrap (map snd (\\<alpha> s))))\n\ngoal (1 subgoal):\n 1. \\<And>s e.\n       aluprio_invar \\<alpha> invar s \\<Longrightarrow>\n       aluprio_prio splits annot isEmpty s e = aluprio_\\<alpha> \\<alpha> s e", "show \"aluprio_prio splits annot isEmpty s e = aluprio_\\<alpha> \\<alpha> s e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aluprio_prio splits annot isEmpty s e = aluprio_\\<alpha> \\<alpha> s e", "proof(cases \"e_less_eq e (annot s) \\<and> \\<not> isEmpty s\")"], ["proof (state)\ngoal (2 subgoals):\n 1. e_less_eq e (annot s) \\<and> \\<not> isEmpty s \\<Longrightarrow>\n    aluprio_prio splits annot isEmpty s e = aluprio_\\<alpha> \\<alpha> s e\n 2. \\<not> (e_less_eq e (annot s) \\<and> \\<not> isEmpty s) \\<Longrightarrow>\n    aluprio_prio splits annot isEmpty s e = aluprio_\\<alpha> \\<alpha> s e", "case False"], ["proof (state)\nthis:\n  \\<not> (e_less_eq e (annot s) \\<and> \\<not> isEmpty s)\n\ngoal (2 subgoals):\n 1. e_less_eq e (annot s) \\<and> \\<not> isEmpty s \\<Longrightarrow>\n    aluprio_prio splits annot isEmpty s e = aluprio_\\<alpha> \\<alpha> s e\n 2. \\<not> (e_less_eq e (annot s) \\<and> \\<not> isEmpty s) \\<Longrightarrow>\n    aluprio_prio splits annot isEmpty s e = aluprio_\\<alpha> \\<alpha> s e", "note F1 = this"], ["proof (state)\nthis:\n  \\<not> (e_less_eq e (annot s) \\<and> \\<not> isEmpty s)\n\ngoal (2 subgoals):\n 1. e_less_eq e (annot s) \\<and> \\<not> isEmpty s \\<Longrightarrow>\n    aluprio_prio splits annot isEmpty s e = aluprio_\\<alpha> \\<alpha> s e\n 2. \\<not> (e_less_eq e (annot s) \\<and> \\<not> isEmpty s) \\<Longrightarrow>\n    aluprio_prio splits annot isEmpty s e = aluprio_\\<alpha> \\<alpha> s e", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (e_less_eq e (annot s) \\<and> \\<not> isEmpty s)\n\ngoal (1 subgoal):\n 1. aluprio_prio splits annot isEmpty s e = aluprio_\\<alpha> \\<alpha> s e", "proof(cases \"isEmpty s\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> (e_less_eq e (annot s) \\<and> \\<not> isEmpty s);\n     isEmpty s\\<rbrakk>\n    \\<Longrightarrow> aluprio_prio splits annot isEmpty s e =\n                      aluprio_\\<alpha> \\<alpha> s e\n 2. \\<lbrakk>\\<not> (e_less_eq e (annot s) \\<and> \\<not> isEmpty s);\n     \\<not> isEmpty s\\<rbrakk>\n    \\<Longrightarrow> aluprio_prio splits annot isEmpty s e =\n                      aluprio_\\<alpha> \\<alpha> s e", "case True"], ["proof (state)\nthis:\n  isEmpty s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> (e_less_eq e (annot s) \\<and> \\<not> isEmpty s);\n     isEmpty s\\<rbrakk>\n    \\<Longrightarrow> aluprio_prio splits annot isEmpty s e =\n                      aluprio_\\<alpha> \\<alpha> s e\n 2. \\<lbrakk>\\<not> (e_less_eq e (annot s) \\<and> \\<not> isEmpty s);\n     \\<not> isEmpty s\\<rbrakk>\n    \\<Longrightarrow> aluprio_prio splits annot isEmpty s e =\n                      aluprio_\\<alpha> \\<alpha> s e", "hence \"\\<alpha> s = []\""], ["proof (prove)\nusing this:\n  isEmpty s\n\ngoal (1 subgoal):\n 1. \\<alpha> s = []", "using sinv isEmpty_correct"], ["proof (prove)\nusing this:\n  isEmpty s\n  invar s\n  \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty\n  sorted (map fst (map p_unwrap (map snd (\\<alpha> s))))\n  distinct (map fst (map p_unwrap (map snd (\\<alpha> s))))\n  invar ?s \\<Longrightarrow> isEmpty ?s = (\\<alpha> ?s = [])\n\ngoal (1 subgoal):\n 1. \\<alpha> s = []", "by simp"], ["proof (state)\nthis:\n  \\<alpha> s = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> (e_less_eq e (annot s) \\<and> \\<not> isEmpty s);\n     isEmpty s\\<rbrakk>\n    \\<Longrightarrow> aluprio_prio splits annot isEmpty s e =\n                      aluprio_\\<alpha> \\<alpha> s e\n 2. \\<lbrakk>\\<not> (e_less_eq e (annot s) \\<and> \\<not> isEmpty s);\n     \\<not> isEmpty s\\<rbrakk>\n    \\<Longrightarrow> aluprio_prio splits annot isEmpty s e =\n                      aluprio_\\<alpha> \\<alpha> s e", "hence \"aluprio_\\<alpha> \\<alpha> s = Map.empty\""], ["proof (prove)\nusing this:\n  \\<alpha> s = []\n\ngoal (1 subgoal):\n 1. aluprio_\\<alpha> \\<alpha> s = Map.empty", "by (simp add:aluprio_defs)"], ["proof (state)\nthis:\n  aluprio_\\<alpha> \\<alpha> s = Map.empty\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> (e_less_eq e (annot s) \\<and> \\<not> isEmpty s);\n     isEmpty s\\<rbrakk>\n    \\<Longrightarrow> aluprio_prio splits annot isEmpty s e =\n                      aluprio_\\<alpha> \\<alpha> s e\n 2. \\<lbrakk>\\<not> (e_less_eq e (annot s) \\<and> \\<not> isEmpty s);\n     \\<not> isEmpty s\\<rbrakk>\n    \\<Longrightarrow> aluprio_prio splits annot isEmpty s e =\n                      aluprio_\\<alpha> \\<alpha> s e", "hence \"aluprio_\\<alpha> \\<alpha> s e = None\""], ["proof (prove)\nusing this:\n  aluprio_\\<alpha> \\<alpha> s = Map.empty\n\ngoal (1 subgoal):\n 1. aluprio_\\<alpha> \\<alpha> s e = None", "by simp"], ["proof (state)\nthis:\n  aluprio_\\<alpha> \\<alpha> s e = None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> (e_less_eq e (annot s) \\<and> \\<not> isEmpty s);\n     isEmpty s\\<rbrakk>\n    \\<Longrightarrow> aluprio_prio splits annot isEmpty s e =\n                      aluprio_\\<alpha> \\<alpha> s e\n 2. \\<lbrakk>\\<not> (e_less_eq e (annot s) \\<and> \\<not> isEmpty s);\n     \\<not> isEmpty s\\<rbrakk>\n    \\<Longrightarrow> aluprio_prio splits annot isEmpty s e =\n                      aluprio_\\<alpha> \\<alpha> s e", "thus \"aluprio_prio splits annot isEmpty s e = aluprio_\\<alpha> \\<alpha> s e\""], ["proof (prove)\nusing this:\n  aluprio_\\<alpha> \\<alpha> s e = None\n\ngoal (1 subgoal):\n 1. aluprio_prio splits annot isEmpty s e = aluprio_\\<alpha> \\<alpha> s e", "using F1"], ["proof (prove)\nusing this:\n  aluprio_\\<alpha> \\<alpha> s e = None\n  \\<not> (e_less_eq e (annot s) \\<and> \\<not> isEmpty s)\n\ngoal (1 subgoal):\n 1. aluprio_prio splits annot isEmpty s e = aluprio_\\<alpha> \\<alpha> s e", "by (auto simp add: aluprio_defs)"], ["proof (state)\nthis:\n  aluprio_prio splits annot isEmpty s e = aluprio_\\<alpha> \\<alpha> s e\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> (e_less_eq e (annot s) \\<and> \\<not> isEmpty s);\n     \\<not> isEmpty s\\<rbrakk>\n    \\<Longrightarrow> aluprio_prio splits annot isEmpty s e =\n                      aluprio_\\<alpha> \\<alpha> s e", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> (e_less_eq e (annot s) \\<and> \\<not> isEmpty s);\n     \\<not> isEmpty s\\<rbrakk>\n    \\<Longrightarrow> aluprio_prio splits annot isEmpty s e =\n                      aluprio_\\<alpha> \\<alpha> s e", "case False"], ["proof (state)\nthis:\n  \\<not> isEmpty s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> (e_less_eq e (annot s) \\<and> \\<not> isEmpty s);\n     \\<not> isEmpty s\\<rbrakk>\n    \\<Longrightarrow> aluprio_prio splits annot isEmpty s e =\n                      aluprio_\\<alpha> \\<alpha> s e", "hence v3:\"\\<not> e_less_eq e (annot s)\""], ["proof (prove)\nusing this:\n  \\<not> isEmpty s\n\ngoal (1 subgoal):\n 1. \\<not> e_less_eq e (annot s)", "using F1"], ["proof (prove)\nusing this:\n  \\<not> isEmpty s\n  \\<not> (e_less_eq e (annot s) \\<and> \\<not> isEmpty s)\n\ngoal (1 subgoal):\n 1. \\<not> e_less_eq e (annot s)", "by simp"], ["proof (state)\nthis:\n  \\<not> e_less_eq e (annot s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> (e_less_eq e (annot s) \\<and> \\<not> isEmpty s);\n     \\<not> isEmpty s\\<rbrakk>\n    \\<Longrightarrow> aluprio_prio splits annot isEmpty s e =\n                      aluprio_\\<alpha> \\<alpha> s e", "note v4=e_less_eq_annot[OF assms(2)]"], ["proof (state)\nthis:\n  \\<lbrakk>invar ?s; \\<forall>x\\<in>set (\\<alpha> ?s). snd x \\<noteq> Infty;\n   \\<not> e_less_eq ?e (annot ?s)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x\\<in>set (map\n   ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd) (\\<alpha> ?s)).\n                       x < ?e\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> (e_less_eq e (annot s) \\<and> \\<not> isEmpty s);\n     \\<not> isEmpty s\\<rbrakk>\n    \\<Longrightarrow> aluprio_prio splits annot isEmpty s e =\n                      aluprio_\\<alpha> \\<alpha> s e", "note v4[OF sinv(1) sinv(2) v3]"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap\n                            snd)\n                       (\\<alpha> s)).\n     x < e\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> (e_less_eq e (annot s) \\<and> \\<not> isEmpty s);\n     \\<not> isEmpty s\\<rbrakk>\n    \\<Longrightarrow> aluprio_prio splits annot isEmpty s e =\n                      aluprio_\\<alpha> \\<alpha> s e", "hence v5:\"e\\<notin>set (map (fst \\<circ> (p_unwrap \\<circ> snd)) (\\<alpha> s))\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap\n                            snd)\n                       (\\<alpha> s)).\n     x < e\n\ngoal (1 subgoal):\n 1. e \\<notin> set (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n                     (\\<alpha> s))", "by auto"], ["proof (state)\nthis:\n  e \\<notin> set (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n                   (\\<alpha> s))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> (e_less_eq e (annot s) \\<and> \\<not> isEmpty s);\n     \\<not> isEmpty s\\<rbrakk>\n    \\<Longrightarrow> aluprio_prio splits annot isEmpty s e =\n                      aluprio_\\<alpha> \\<alpha> s e", "hence \"map_of (map (p_unwrap \\<circ> snd) (\\<alpha> s)) e = None\""], ["proof (prove)\nusing this:\n  e \\<notin> set (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n                   (\\<alpha> s))\n\ngoal (1 subgoal):\n 1. map_of (map (p_unwrap \\<circ> snd) (\\<alpha> s)) e = None", "using map_of_eq_None_iff"], ["proof (prove)\nusing this:\n  e \\<notin> set (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap snd)\n                   (\\<alpha> s))\n  (map_of ?xys ?x = None) = (?x \\<notin> fst ` set ?xys)\n\ngoal (1 subgoal):\n 1. map_of (map (p_unwrap \\<circ> snd) (\\<alpha> s)) e = None", "by (metis map_map map_of_eq_None_iff set_map v5)"], ["proof (state)\nthis:\n  map_of (map (p_unwrap \\<circ> snd) (\\<alpha> s)) e = None\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> (e_less_eq e (annot s) \\<and> \\<not> isEmpty s);\n     \\<not> isEmpty s\\<rbrakk>\n    \\<Longrightarrow> aluprio_prio splits annot isEmpty s e =\n                      aluprio_\\<alpha> \\<alpha> s e", "thus \"aluprio_prio splits annot isEmpty s e = aluprio_\\<alpha> \\<alpha> s e\""], ["proof (prove)\nusing this:\n  map_of (map (p_unwrap \\<circ> snd) (\\<alpha> s)) e = None\n\ngoal (1 subgoal):\n 1. aluprio_prio splits annot isEmpty s e = aluprio_\\<alpha> \\<alpha> s e", "using F1"], ["proof (prove)\nusing this:\n  map_of (map (p_unwrap \\<circ> snd) (\\<alpha> s)) e = None\n  \\<not> (e_less_eq e (annot s) \\<and> \\<not> isEmpty s)\n\ngoal (1 subgoal):\n 1. aluprio_prio splits annot isEmpty s e = aluprio_\\<alpha> \\<alpha> s e", "by (auto simp add: aluprio_defs)"], ["proof (state)\nthis:\n  aluprio_prio splits annot isEmpty s e = aluprio_\\<alpha> \\<alpha> s e\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  aluprio_prio splits annot isEmpty s e = aluprio_\\<alpha> \\<alpha> s e\n\ngoal (1 subgoal):\n 1. e_less_eq e (annot s) \\<and> \\<not> isEmpty s \\<Longrightarrow>\n    aluprio_prio splits annot isEmpty s e = aluprio_\\<alpha> \\<alpha> s e", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. e_less_eq e (annot s) \\<and> \\<not> isEmpty s \\<Longrightarrow>\n    aluprio_prio splits annot isEmpty s e = aluprio_\\<alpha> \\<alpha> s e", "case True"], ["proof (state)\nthis:\n  e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n\ngoal (1 subgoal):\n 1. e_less_eq e (annot s) \\<and> \\<not> isEmpty s \\<Longrightarrow>\n    aluprio_prio splits annot isEmpty s e = aluprio_\\<alpha> \\<alpha> s e", "note T1 = this"], ["proof (state)\nthis:\n  e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n\ngoal (1 subgoal):\n 1. e_less_eq e (annot s) \\<and> \\<not> isEmpty s \\<Longrightarrow>\n    aluprio_prio splits annot isEmpty s e = aluprio_\\<alpha> \\<alpha> s e", "obtain l uu lp r where \n        l_lp_r: \"(splits (e_less_eq e) Infty s) = (l, ((), lp), r) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l lp r.\n        splits (e_less_eq e) Infty s = (l, ((), lp), r) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"splits (e_less_eq e) Infty s\", auto)"], ["proof (state)\nthis:\n  splits (e_less_eq e) Infty s = (l, ((), lp), r)\n\ngoal (1 subgoal):\n 1. e_less_eq e (annot s) \\<and> \\<not> isEmpty s \\<Longrightarrow>\n    aluprio_prio splits annot isEmpty s e = aluprio_\\<alpha> \\<alpha> s e", "note v2 = splits_correct[of s \"e_less_eq e\" Infty l \"()\" lp r]"], ["proof (state)\nthis:\n  \\<lbrakk>invar s;\n   \\<forall>a b. e_less_eq e a \\<longrightarrow> e_less_eq e (a + b);\n   \\<not> e_less_eq e Infty;\n   e_less_eq e (Infty + sum_list (map snd (\\<alpha> s)));\n   splits (e_less_eq e) Infty s = (l, ((), lp), r)\\<rbrakk>\n  \\<Longrightarrow> \\<alpha> s = \\<alpha> l @ ((), lp) # \\<alpha> r \\<and>\n                    \\<not> e_less_eq e\n                            (Infty + sum_list (map snd (\\<alpha> l))) \\<and>\n                    e_less_eq e\n                     (Infty + sum_list (map snd (\\<alpha> l)) + lp) \\<and>\n                    invar l \\<and> invar r\n\ngoal (1 subgoal):\n 1. e_less_eq e (annot s) \\<and> \\<not> isEmpty s \\<Longrightarrow>\n    aluprio_prio splits annot isEmpty s e = aluprio_\\<alpha> \\<alpha> s e", "have \n        v3: \"invar s\" \n        \"\\<not> e_less_eq e Infty\"\n        \"e_less_eq e (Infty + sum_list (map snd (\\<alpha> s)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar s &&&\n    \\<not> e_less_eq e Infty &&&\n    e_less_eq e (Infty + sum_list (map snd (\\<alpha> s)))", "using T1 sinv annot_correct"], ["proof (prove)\nusing this:\n  e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n  invar s\n  \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty\n  sorted (map fst (map p_unwrap (map snd (\\<alpha> s))))\n  distinct (map fst (map p_unwrap (map snd (\\<alpha> s))))\n  invar ?s \\<Longrightarrow> annot ?s = sum_list (map snd (\\<alpha> ?s))\n\ngoal (1 subgoal):\n 1. invar s &&&\n    \\<not> e_less_eq e Infty &&&\n    e_less_eq e (Infty + sum_list (map snd (\\<alpha> s)))", "by (auto simp add: plus_def)"], ["proof (state)\nthis:\n  invar s\n  \\<not> e_less_eq e Infty\n  e_less_eq e (Infty + sum_list (map snd (\\<alpha> s)))\n\ngoal (1 subgoal):\n 1. e_less_eq e (annot s) \\<and> \\<not> isEmpty s \\<Longrightarrow>\n    aluprio_prio splits annot isEmpty s e = aluprio_\\<alpha> \\<alpha> s e", "have \n        v4: \"\\<alpha> s = \\<alpha> l @ ((), lp) # \\<alpha> r\"  \n        \"\\<not> e_less_eq e (Infty + sum_list (map snd (\\<alpha> l)))\"\n        \"e_less_eq e (Infty + sum_list (map snd (\\<alpha> l)) + lp)\"\n        \"invar l\"\n        \"invar r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<alpha> s = \\<alpha> l @ ((), lp) # \\<alpha> r &&&\n     \\<not> e_less_eq e (Infty + sum_list (map snd (\\<alpha> l)))) &&&\n    e_less_eq e (Infty + sum_list (map snd (\\<alpha> l)) + lp) &&&\n    invar l &&& invar r", "using v2[OF v3(1) _ v3(2) v3(3) l_lp_r] e_less_eq_mon(1)"], ["proof (prove)\nusing this:\n  \\<forall>a b.\n     e_less_eq e a \\<longrightarrow> e_less_eq e (a + b) \\<Longrightarrow>\n  \\<alpha> s = \\<alpha> l @ ((), lp) # \\<alpha> r \\<and>\n  \\<not> e_less_eq e (Infty + sum_list (map snd (\\<alpha> l))) \\<and>\n  e_less_eq e (Infty + sum_list (map snd (\\<alpha> l)) + lp) \\<and>\n  invar l \\<and> invar r\n  e_less_eq ?e ?x \\<Longrightarrow> e_less_eq ?e (?x + ?y)\n\ngoal (1 subgoal):\n 1. (\\<alpha> s = \\<alpha> l @ ((), lp) # \\<alpha> r &&&\n     \\<not> e_less_eq e (Infty + sum_list (map snd (\\<alpha> l)))) &&&\n    e_less_eq e (Infty + sum_list (map snd (\\<alpha> l)) + lp) &&&\n    invar l &&& invar r", "by auto"], ["proof (state)\nthis:\n  \\<alpha> s = \\<alpha> l @ ((), lp) # \\<alpha> r\n  \\<not> e_less_eq e (Infty + sum_list (map snd (\\<alpha> l)))\n  e_less_eq e (Infty + sum_list (map snd (\\<alpha> l)) + lp)\n  invar l\n  invar r\n\ngoal (1 subgoal):\n 1. e_less_eq e (annot s) \\<and> \\<not> isEmpty s \\<Longrightarrow>\n    aluprio_prio splits annot isEmpty s e = aluprio_\\<alpha> \\<alpha> s e", "hence v5: \"e_less_eq e lp\""], ["proof (prove)\nusing this:\n  \\<alpha> s = \\<alpha> l @ ((), lp) # \\<alpha> r\n  \\<not> e_less_eq e (Infty + sum_list (map snd (\\<alpha> l)))\n  e_less_eq e (Infty + sum_list (map snd (\\<alpha> l)) + lp)\n  invar l\n  invar r\n\ngoal (1 subgoal):\n 1. e_less_eq e lp", "by (metis e_less_eq_lem1)"], ["proof (state)\nthis:\n  e_less_eq e lp\n\ngoal (1 subgoal):\n 1. e_less_eq e (annot s) \\<and> \\<not> isEmpty s \\<Longrightarrow>\n    aluprio_prio splits annot isEmpty s e = aluprio_\\<alpha> \\<alpha> s e", "hence v6: \"e \\<le> (fst (p_unwrap lp))\""], ["proof (prove)\nusing this:\n  e_less_eq e lp\n\ngoal (1 subgoal):\n 1. e \\<le> fst (p_unwrap lp)", "by (cases lp) auto"], ["proof (state)\nthis:\n  e \\<le> fst (p_unwrap lp)\n\ngoal (1 subgoal):\n 1. e_less_eq e (annot s) \\<and> \\<not> isEmpty s \\<Longrightarrow>\n    aluprio_prio splits annot isEmpty s e = aluprio_\\<alpha> \\<alpha> s e", "have \"(Infty + sum_list (map snd (\\<alpha> l))) = (annot l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Infty + sum_list (map snd (\\<alpha> l)) = annot l", "by (metis add_0_left annot_correct v4(4) zero_def)"], ["proof (state)\nthis:\n  Infty + sum_list (map snd (\\<alpha> l)) = annot l\n\ngoal (1 subgoal):\n 1. e_less_eq e (annot s) \\<and> \\<not> isEmpty s \\<Longrightarrow>\n    aluprio_prio splits annot isEmpty s e = aluprio_\\<alpha> \\<alpha> s e", "hence v7:\"\\<not> e_less_eq e (annot l)\""], ["proof (prove)\nusing this:\n  Infty + sum_list (map snd (\\<alpha> l)) = annot l\n\ngoal (1 subgoal):\n 1. \\<not> e_less_eq e (annot l)", "using v4(2)"], ["proof (prove)\nusing this:\n  Infty + sum_list (map snd (\\<alpha> l)) = annot l\n  \\<not> e_less_eq e (Infty + sum_list (map snd (\\<alpha> l)))\n\ngoal (1 subgoal):\n 1. \\<not> e_less_eq e (annot l)", "by simp"], ["proof (state)\nthis:\n  \\<not> e_less_eq e (annot l)\n\ngoal (1 subgoal):\n 1. e_less_eq e (annot s) \\<and> \\<not> isEmpty s \\<Longrightarrow>\n    aluprio_prio splits annot isEmpty s e = aluprio_\\<alpha> \\<alpha> s e", "have \"\\<forall>x\\<in>set (\\<alpha> l). snd x \\<noteq> Infty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (\\<alpha> l). snd x \\<noteq> Infty", "using sinv v4(1)"], ["proof (prove)\nusing this:\n  invar s\n  \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty\n  sorted (map fst (map p_unwrap (map snd (\\<alpha> s))))\n  distinct (map fst (map p_unwrap (map snd (\\<alpha> s))))\n  \\<alpha> s = \\<alpha> l @ ((), lp) # \\<alpha> r\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (\\<alpha> l). snd x \\<noteq> Infty", "by simp"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (\\<alpha> l). snd x \\<noteq> Infty\n\ngoal (1 subgoal):\n 1. e_less_eq e (annot s) \\<and> \\<not> isEmpty s \\<Longrightarrow>\n    aluprio_prio splits annot isEmpty s e = aluprio_\\<alpha> \\<alpha> s e", "hence v7: \"\\<forall>x \\<in> set (map (fst \\<circ> (p_unwrap \\<circ> snd)) (\\<alpha> l)). x < e\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set (\\<alpha> l). snd x \\<noteq> Infty\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap\n                              snd)\n                         (\\<alpha> l)).\n       x < e", "using v4(4) v7 assms(2)"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set (\\<alpha> l). snd x \\<noteq> Infty\n  invar l\n  \\<not> e_less_eq e (annot l)\n  al_annot \\<alpha> invar annot\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap\n                              snd)\n                         (\\<alpha> l)).\n       x < e", "by(simp add: e_less_eq_annot)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap\n                            snd)\n                       (\\<alpha> l)).\n     x < e\n\ngoal (1 subgoal):\n 1. e_less_eq e (annot s) \\<and> \\<not> isEmpty s \\<Longrightarrow>\n    aluprio_prio splits annot isEmpty s e = aluprio_\\<alpha> \\<alpha> s e", "have v8:\"map fst (map p_unwrap (map snd (\\<alpha> s))) = \n        map fst (map p_unwrap (map snd (\\<alpha> l))) @ fst(p_unwrap lp) #\n        map fst (map p_unwrap (map snd (\\<alpha> r)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map fst (map p_unwrap (map snd (\\<alpha> s))) =\n    map fst (map p_unwrap (map snd (\\<alpha> l))) @\n    fst (p_unwrap lp) # map fst (map p_unwrap (map snd (\\<alpha> r)))", "using v4(1)"], ["proof (prove)\nusing this:\n  \\<alpha> s = \\<alpha> l @ ((), lp) # \\<alpha> r\n\ngoal (1 subgoal):\n 1. map fst (map p_unwrap (map snd (\\<alpha> s))) =\n    map fst (map p_unwrap (map snd (\\<alpha> l))) @\n    fst (p_unwrap lp) # map fst (map p_unwrap (map snd (\\<alpha> r)))", "by simp"], ["proof (state)\nthis:\n  map fst (map p_unwrap (map snd (\\<alpha> s))) =\n  map fst (map p_unwrap (map snd (\\<alpha> l))) @\n  fst (p_unwrap lp) # map fst (map p_unwrap (map snd (\\<alpha> r)))\n\ngoal (1 subgoal):\n 1. e_less_eq e (annot s) \\<and> \\<not> isEmpty s \\<Longrightarrow>\n    aluprio_prio splits annot isEmpty s e = aluprio_\\<alpha> \\<alpha> s e", "note distinct_sortet_list_app[of \"map fst (map p_unwrap (map snd (\\<alpha> s)))\"\n        \"map fst (map p_unwrap (map snd (\\<alpha> l)))\" \"fst(p_unwrap lp)\" \n        \"map fst (map p_unwrap (map snd (\\<alpha> r)))\"]"], ["proof (state)\nthis:\n  \\<lbrakk>sorted (map fst (map p_unwrap (map snd (\\<alpha> s))));\n   distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n   map fst (map p_unwrap (map snd (\\<alpha> s))) =\n   map fst (map p_unwrap (map snd (\\<alpha> l))) @\n   fst (p_unwrap lp) #\n   map fst (map p_unwrap (map snd (\\<alpha> r)))\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x\\<in>set (map fst\n   (map p_unwrap (map snd (\\<alpha> r)))).\n                       fst (p_unwrap lp) < x\n\ngoal (1 subgoal):\n 1. e_less_eq e (annot s) \\<and> \\<not> isEmpty s \\<Longrightarrow>\n    aluprio_prio splits annot isEmpty s e = aluprio_\\<alpha> \\<alpha> s e", "hence v9: \n        \"\\<forall> x\\<in>set (map (fst \\<circ> (p_unwrap \\<circ> snd)) (\\<alpha> r)). fst(p_unwrap lp) < x\""], ["proof (prove)\nusing this:\n  \\<lbrakk>sorted (map fst (map p_unwrap (map snd (\\<alpha> s))));\n   distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n   map fst (map p_unwrap (map snd (\\<alpha> s))) =\n   map fst (map p_unwrap (map snd (\\<alpha> l))) @\n   fst (p_unwrap lp) #\n   map fst (map p_unwrap (map snd (\\<alpha> r)))\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x\\<in>set (map fst\n   (map p_unwrap (map snd (\\<alpha> r)))).\n                       fst (p_unwrap lp) < x\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap\n                              snd)\n                         (\\<alpha> r)).\n       fst (p_unwrap lp) < x", "using v4(1) sinv v8"], ["proof (prove)\nusing this:\n  \\<lbrakk>sorted (map fst (map p_unwrap (map snd (\\<alpha> s))));\n   distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n   map fst (map p_unwrap (map snd (\\<alpha> s))) =\n   map fst (map p_unwrap (map snd (\\<alpha> l))) @\n   fst (p_unwrap lp) #\n   map fst (map p_unwrap (map snd (\\<alpha> r)))\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x\\<in>set (map fst\n   (map p_unwrap (map snd (\\<alpha> r)))).\n                       fst (p_unwrap lp) < x\n  \\<alpha> s = \\<alpha> l @ ((), lp) # \\<alpha> r\n  invar s\n  \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty\n  sorted (map fst (map p_unwrap (map snd (\\<alpha> s))))\n  distinct (map fst (map p_unwrap (map snd (\\<alpha> s))))\n  map fst (map p_unwrap (map snd (\\<alpha> s))) =\n  map fst (map p_unwrap (map snd (\\<alpha> l))) @\n  fst (p_unwrap lp) # map fst (map p_unwrap (map snd (\\<alpha> r)))\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap\n                              snd)\n                         (\\<alpha> r)).\n       fst (p_unwrap lp) < x", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap\n                            snd)\n                       (\\<alpha> r)).\n     fst (p_unwrap lp) < x\n\ngoal (1 subgoal):\n 1. e_less_eq e (annot s) \\<and> \\<not> isEmpty s \\<Longrightarrow>\n    aluprio_prio splits annot isEmpty s e = aluprio_\\<alpha> \\<alpha> s e", "hence v10: \" \\<forall> x\\<in>set (map (fst \\<circ> (p_unwrap \\<circ> snd)) (\\<alpha> r)). e < x\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap\n                            snd)\n                       (\\<alpha> r)).\n     fst (p_unwrap lp) < x\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap\n                              snd)\n                         (\\<alpha> r)).\n       e < x", "using v6"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap\n                            snd)\n                       (\\<alpha> r)).\n     fst (p_unwrap lp) < x\n  e \\<le> fst (p_unwrap lp)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap\n                              snd)\n                         (\\<alpha> r)).\n       e < x", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap\n                            snd)\n                       (\\<alpha> r)).\n     e < x\n\ngoal (1 subgoal):\n 1. e_less_eq e (annot s) \\<and> \\<not> isEmpty s \\<Longrightarrow>\n    aluprio_prio splits annot isEmpty s e = aluprio_\\<alpha> \\<alpha> s e", "have v11: \n        \"e \\<notin> set (map fst (map p_unwrap (map snd (\\<alpha> l))))\"\n        \"e \\<notin> set (map fst (map p_unwrap (map snd (\\<alpha> r))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e \\<notin> set (map fst (map p_unwrap (map snd (\\<alpha> l)))) &&&\n    e \\<notin> set (map fst (map p_unwrap (map snd (\\<alpha> r))))", "using v7 v10 v8 sinv"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap\n                            snd)\n                       (\\<alpha> l)).\n     x < e\n  \\<forall>x\\<in>set (map ((fst \\<circ>\\<circ>\\<circ> (\\<circ>)) p_unwrap\n                            snd)\n                       (\\<alpha> r)).\n     e < x\n  map fst (map p_unwrap (map snd (\\<alpha> s))) =\n  map fst (map p_unwrap (map snd (\\<alpha> l))) @\n  fst (p_unwrap lp) # map fst (map p_unwrap (map snd (\\<alpha> r)))\n  invar s\n  \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty\n  sorted (map fst (map p_unwrap (map snd (\\<alpha> s))))\n  distinct (map fst (map p_unwrap (map snd (\\<alpha> s))))\n\ngoal (1 subgoal):\n 1. e \\<notin> set (map fst (map p_unwrap (map snd (\\<alpha> l)))) &&&\n    e \\<notin> set (map fst (map p_unwrap (map snd (\\<alpha> r))))", "by auto"], ["proof (state)\nthis:\n  e \\<notin> set (map fst (map p_unwrap (map snd (\\<alpha> l))))\n  e \\<notin> set (map fst (map p_unwrap (map snd (\\<alpha> r))))\n\ngoal (1 subgoal):\n 1. e_less_eq e (annot s) \\<and> \\<not> isEmpty s \\<Longrightarrow>\n    aluprio_prio splits annot isEmpty s e = aluprio_\\<alpha> \\<alpha> s e", "from l_lp_r T1 sinv"], ["proof (chain)\npicking this:\n  splits (e_less_eq e) Infty s = (l, ((), lp), r)\n  e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n  invar s\n  \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty\n  sorted (map fst (map p_unwrap (map snd (\\<alpha> s))))\n  distinct (map fst (map p_unwrap (map snd (\\<alpha> s))))", "show ?thesis"], ["proof (prove)\nusing this:\n  splits (e_less_eq e) Infty s = (l, ((), lp), r)\n  e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n  invar s\n  \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty\n  sorted (map fst (map p_unwrap (map snd (\\<alpha> s))))\n  distinct (map fst (map p_unwrap (map snd (\\<alpha> s))))\n\ngoal (1 subgoal):\n 1. aluprio_prio splits annot isEmpty s e = aluprio_\\<alpha> \\<alpha> s e", "proof (cases \"e = fst (p_unwrap lp)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s; invar s;\n     \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty;\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     e = fst (p_unwrap lp)\\<rbrakk>\n    \\<Longrightarrow> aluprio_prio splits annot isEmpty s e =\n                      aluprio_\\<alpha> \\<alpha> s e\n 2. \\<lbrakk>splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s; invar s;\n     \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty;\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     e \\<noteq> fst (p_unwrap lp)\\<rbrakk>\n    \\<Longrightarrow> aluprio_prio splits annot isEmpty s e =\n                      aluprio_\\<alpha> \\<alpha> s e", "case False"], ["proof (state)\nthis:\n  e \\<noteq> fst (p_unwrap lp)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s; invar s;\n     \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty;\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     e = fst (p_unwrap lp)\\<rbrakk>\n    \\<Longrightarrow> aluprio_prio splits annot isEmpty s e =\n                      aluprio_\\<alpha> \\<alpha> s e\n 2. \\<lbrakk>splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s; invar s;\n     \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty;\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     e \\<noteq> fst (p_unwrap lp)\\<rbrakk>\n    \\<Longrightarrow> aluprio_prio splits annot isEmpty s e =\n                      aluprio_\\<alpha> \\<alpha> s e", "have v12: \"e \\<notin> set (map fst (map p_unwrap (map snd(\\<alpha> s))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e \\<notin> set (map fst (map p_unwrap (map snd (\\<alpha> s))))", "using v11 False v4(1)"], ["proof (prove)\nusing this:\n  e \\<notin> set (map fst (map p_unwrap (map snd (\\<alpha> l))))\n  e \\<notin> set (map fst (map p_unwrap (map snd (\\<alpha> r))))\n  e \\<noteq> fst (p_unwrap lp)\n  \\<alpha> s = \\<alpha> l @ ((), lp) # \\<alpha> r\n\ngoal (1 subgoal):\n 1. e \\<notin> set (map fst (map p_unwrap (map snd (\\<alpha> s))))", "by auto"], ["proof (state)\nthis:\n  e \\<notin> set (map fst (map p_unwrap (map snd (\\<alpha> s))))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s; invar s;\n     \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty;\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     e = fst (p_unwrap lp)\\<rbrakk>\n    \\<Longrightarrow> aluprio_prio splits annot isEmpty s e =\n                      aluprio_\\<alpha> \\<alpha> s e\n 2. \\<lbrakk>splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s; invar s;\n     \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty;\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     e \\<noteq> fst (p_unwrap lp)\\<rbrakk>\n    \\<Longrightarrow> aluprio_prio splits annot isEmpty s e =\n                      aluprio_\\<alpha> \\<alpha> s e", "hence \"map_of (map (p_unwrap \\<circ> snd) (\\<alpha> s)) e = None\""], ["proof (prove)\nusing this:\n  e \\<notin> set (map fst (map p_unwrap (map snd (\\<alpha> s))))\n\ngoal (1 subgoal):\n 1. map_of (map (p_unwrap \\<circ> snd) (\\<alpha> s)) e = None", "using map_of_eq_None_iff"], ["proof (prove)\nusing this:\n  e \\<notin> set (map fst (map p_unwrap (map snd (\\<alpha> s))))\n  (map_of ?xys ?x = None) = (?x \\<notin> fst ` set ?xys)\n\ngoal (1 subgoal):\n 1. map_of (map (p_unwrap \\<circ> snd) (\\<alpha> s)) e = None", "by (metis map_map map_of_eq_None_iff set_map v12)"], ["proof (state)\nthis:\n  map_of (map (p_unwrap \\<circ> snd) (\\<alpha> s)) e = None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s; invar s;\n     \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty;\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     e = fst (p_unwrap lp)\\<rbrakk>\n    \\<Longrightarrow> aluprio_prio splits annot isEmpty s e =\n                      aluprio_\\<alpha> \\<alpha> s e\n 2. \\<lbrakk>splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s; invar s;\n     \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty;\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     e \\<noteq> fst (p_unwrap lp)\\<rbrakk>\n    \\<Longrightarrow> aluprio_prio splits annot isEmpty s e =\n                      aluprio_\\<alpha> \\<alpha> s e", "thus ?thesis"], ["proof (prove)\nusing this:\n  map_of (map (p_unwrap \\<circ> snd) (\\<alpha> s)) e = None\n\ngoal (1 subgoal):\n 1. aluprio_prio splits annot isEmpty s e = aluprio_\\<alpha> \\<alpha> s e", "using T1 False l_lp_r"], ["proof (prove)\nusing this:\n  map_of (map (p_unwrap \\<circ> snd) (\\<alpha> s)) e = None\n  e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n  e \\<noteq> fst (p_unwrap lp)\n  splits (e_less_eq e) Infty s = (l, ((), lp), r)\n\ngoal (1 subgoal):\n 1. aluprio_prio splits annot isEmpty s e = aluprio_\\<alpha> \\<alpha> s e", "by (auto simp add: aluprio_defs)"], ["proof (state)\nthis:\n  aluprio_prio splits annot isEmpty s e = aluprio_\\<alpha> \\<alpha> s e\n\ngoal (1 subgoal):\n 1. \\<lbrakk>splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s; invar s;\n     \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty;\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     e = fst (p_unwrap lp)\\<rbrakk>\n    \\<Longrightarrow> aluprio_prio splits annot isEmpty s e =\n                      aluprio_\\<alpha> \\<alpha> s e", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s; invar s;\n     \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty;\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     e = fst (p_unwrap lp)\\<rbrakk>\n    \\<Longrightarrow> aluprio_prio splits annot isEmpty s e =\n                      aluprio_\\<alpha> \\<alpha> s e", "case True"], ["proof (state)\nthis:\n  e = fst (p_unwrap lp)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s; invar s;\n     \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty;\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     e = fst (p_unwrap lp)\\<rbrakk>\n    \\<Longrightarrow> aluprio_prio splits annot isEmpty s e =\n                      aluprio_\\<alpha> \\<alpha> s e", "have v12: \"map (p_unwrap \\<circ> snd) (\\<alpha> s) = \n          map p_unwrap (map snd (\\<alpha> l)) @ (e,snd (p_unwrap lp)) #\n          map p_unwrap (map snd (\\<alpha> r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (p_unwrap \\<circ> snd) (\\<alpha> s) =\n    map p_unwrap (map snd (\\<alpha> l)) @\n    (e, snd (p_unwrap lp)) # map p_unwrap (map snd (\\<alpha> r))", "using v4(1) True"], ["proof (prove)\nusing this:\n  \\<alpha> s = \\<alpha> l @ ((), lp) # \\<alpha> r\n  e = fst (p_unwrap lp)\n\ngoal (1 subgoal):\n 1. map (p_unwrap \\<circ> snd) (\\<alpha> s) =\n    map p_unwrap (map snd (\\<alpha> l)) @\n    (e, snd (p_unwrap lp)) # map p_unwrap (map snd (\\<alpha> r))", "by simp"], ["proof (state)\nthis:\n  map (p_unwrap \\<circ> snd) (\\<alpha> s) =\n  map p_unwrap (map snd (\\<alpha> l)) @\n  (e, snd (p_unwrap lp)) # map p_unwrap (map snd (\\<alpha> r))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s; invar s;\n     \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty;\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     e = fst (p_unwrap lp)\\<rbrakk>\n    \\<Longrightarrow> aluprio_prio splits annot isEmpty s e =\n                      aluprio_\\<alpha> \\<alpha> s e", "note map_of_distinct_lookup[OF v11]"], ["proof (state)\nthis:\n  map_of\n   (map p_unwrap (map snd (\\<alpha> l)) @\n    (e, ?y) # map p_unwrap (map snd (\\<alpha> r)))\n   e =\n  Some ?y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s; invar s;\n     \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty;\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     e = fst (p_unwrap lp)\\<rbrakk>\n    \\<Longrightarrow> aluprio_prio splits annot isEmpty s e =\n                      aluprio_\\<alpha> \\<alpha> s e", "hence\n          \"map_of (map (p_unwrap \\<circ> snd) (\\<alpha> s)) e = Some (snd (p_unwrap lp))\""], ["proof (prove)\nusing this:\n  map_of\n   (map p_unwrap (map snd (\\<alpha> l)) @\n    (e, ?y) # map p_unwrap (map snd (\\<alpha> r)))\n   e =\n  Some ?y\n\ngoal (1 subgoal):\n 1. map_of (map (p_unwrap \\<circ> snd) (\\<alpha> s)) e =\n    Some (snd (p_unwrap lp))", "using v12"], ["proof (prove)\nusing this:\n  map_of\n   (map p_unwrap (map snd (\\<alpha> l)) @\n    (e, ?y) # map p_unwrap (map snd (\\<alpha> r)))\n   e =\n  Some ?y\n  map (p_unwrap \\<circ> snd) (\\<alpha> s) =\n  map p_unwrap (map snd (\\<alpha> l)) @\n  (e, snd (p_unwrap lp)) # map p_unwrap (map snd (\\<alpha> r))\n\ngoal (1 subgoal):\n 1. map_of (map (p_unwrap \\<circ> snd) (\\<alpha> s)) e =\n    Some (snd (p_unwrap lp))", "by simp"], ["proof (state)\nthis:\n  map_of (map (p_unwrap \\<circ> snd) (\\<alpha> s)) e =\n  Some (snd (p_unwrap lp))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>splits (e_less_eq e) Infty s = (l, ((), lp), r);\n     e_less_eq e (annot s) \\<and> \\<not> isEmpty s; invar s;\n     \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty;\n     sorted (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     distinct (map fst (map p_unwrap (map snd (\\<alpha> s))));\n     e = fst (p_unwrap lp)\\<rbrakk>\n    \\<Longrightarrow> aluprio_prio splits annot isEmpty s e =\n                      aluprio_\\<alpha> \\<alpha> s e", "thus ?thesis"], ["proof (prove)\nusing this:\n  map_of (map (p_unwrap \\<circ> snd) (\\<alpha> s)) e =\n  Some (snd (p_unwrap lp))\n\ngoal (1 subgoal):\n 1. aluprio_prio splits annot isEmpty s e = aluprio_\\<alpha> \\<alpha> s e", "using T1 True l_lp_r"], ["proof (prove)\nusing this:\n  map_of (map (p_unwrap \\<circ> snd) (\\<alpha> s)) e =\n  Some (snd (p_unwrap lp))\n  e_less_eq e (annot s) \\<and> \\<not> isEmpty s\n  e = fst (p_unwrap lp)\n  splits (e_less_eq e) Infty s = (l, ((), lp), r)\n\ngoal (1 subgoal):\n 1. aluprio_prio splits annot isEmpty s e = aluprio_\\<alpha> \\<alpha> s e", "by (auto simp add: aluprio_defs)"], ["proof (state)\nthis:\n  aluprio_prio splits annot isEmpty s e = aluprio_\\<alpha> \\<alpha> s e\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  aluprio_prio splits annot isEmpty s e = aluprio_\\<alpha> \\<alpha> s e\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  aluprio_prio splits annot isEmpty s e = aluprio_\\<alpha> \\<alpha> s e\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  uprio_prio (aluprio_\\<alpha> \\<alpha>) (aluprio_invar \\<alpha> invar)\n   (aluprio_prio splits annot isEmpty)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \"Pop\""], ["", "lemma aluprio_pop_correct: \n  assumes \"al_splits \\<alpha> invar splits\"\n  \"al_annot \\<alpha> invar annot\"\n  \"al_app \\<alpha> invar app\"\n  shows \n  \"uprio_pop (aluprio_\\<alpha> \\<alpha>) (aluprio_invar \\<alpha> invar) (aluprio_pop splits annot app)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uprio_pop (aluprio_\\<alpha> \\<alpha>) (aluprio_invar \\<alpha> invar)\n     (aluprio_pop splits annot app)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. uprio_pop (aluprio_\\<alpha> \\<alpha>) (aluprio_invar \\<alpha> invar)\n     (aluprio_pop splits annot app)", "interpret al_splits \\<alpha> invar splits"], ["proof (prove)\ngoal (1 subgoal):\n 1. al_splits \\<alpha> invar splits", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. uprio_pop (aluprio_\\<alpha> \\<alpha>) (aluprio_invar \\<alpha> invar)\n     (aluprio_pop splits annot app)", "interpret al_annot \\<alpha> invar annot"], ["proof (prove)\ngoal (1 subgoal):\n 1. al_annot \\<alpha> invar annot", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. uprio_pop (aluprio_\\<alpha> \\<alpha>) (aluprio_invar \\<alpha> invar)\n     (aluprio_pop splits annot app)", "interpret al_app \\<alpha> invar app"], ["proof (prove)\ngoal (1 subgoal):\n 1. al_app \\<alpha> invar app", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. uprio_pop (aluprio_\\<alpha> \\<alpha>) (aluprio_invar \\<alpha> invar)\n     (aluprio_pop splits annot app)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. uprio_pop (aluprio_\\<alpha> \\<alpha>) (aluprio_invar \\<alpha> invar)\n     (aluprio_pop splits annot app)", "proof (unfold_locales)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s e a s'.\n       \\<lbrakk>aluprio_invar \\<alpha> invar s;\n        aluprio_\\<alpha> \\<alpha> s \\<noteq> Map.empty;\n        aluprio_pop splits annot app s = (e, a, s')\\<rbrakk>\n       \\<Longrightarrow> aluprio_invar \\<alpha> invar s' \\<and>\n                         aluprio_\\<alpha> \\<alpha> s' =\n                         (aluprio_\\<alpha> \\<alpha> s)(e := None) \\<and>\n                         aluprio_\\<alpha> \\<alpha> s e = Some a \\<and>\n                         (\\<forall>y\\<in>ran (aluprio_\\<alpha> \\<alpha> s).\n                             a \\<le> y)", "fix s e a s'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s e a s'.\n       \\<lbrakk>aluprio_invar \\<alpha> invar s;\n        aluprio_\\<alpha> \\<alpha> s \\<noteq> Map.empty;\n        aluprio_pop splits annot app s = (e, a, s')\\<rbrakk>\n       \\<Longrightarrow> aluprio_invar \\<alpha> invar s' \\<and>\n                         aluprio_\\<alpha> \\<alpha> s' =\n                         (aluprio_\\<alpha> \\<alpha> s)(e := None) \\<and>\n                         aluprio_\\<alpha> \\<alpha> s e = Some a \\<and>\n                         (\\<forall>y\\<in>ran (aluprio_\\<alpha> \\<alpha> s).\n                             a \\<le> y)", "assume A: \"aluprio_invar \\<alpha> invar s\" \n      \"aluprio_\\<alpha> \\<alpha> s \\<noteq> Map.empty\" \n      \"aluprio_pop splits annot app s = (e, a, s')\""], ["proof (state)\nthis:\n  aluprio_invar \\<alpha> invar s\n  aluprio_\\<alpha> \\<alpha> s \\<noteq> Map.empty\n  aluprio_pop splits annot app s = (e, a, s')\n\ngoal (1 subgoal):\n 1. \\<And>s e a s'.\n       \\<lbrakk>aluprio_invar \\<alpha> invar s;\n        aluprio_\\<alpha> \\<alpha> s \\<noteq> Map.empty;\n        aluprio_pop splits annot app s = (e, a, s')\\<rbrakk>\n       \\<Longrightarrow> aluprio_invar \\<alpha> invar s' \\<and>\n                         aluprio_\\<alpha> \\<alpha> s' =\n                         (aluprio_\\<alpha> \\<alpha> s)(e := None) \\<and>\n                         aluprio_\\<alpha> \\<alpha> s e = Some a \\<and>\n                         (\\<forall>y\\<in>ran (aluprio_\\<alpha> \\<alpha> s).\n                             a \\<le> y)", "hence v1: \"\\<alpha> s \\<noteq> []\""], ["proof (prove)\nusing this:\n  aluprio_invar \\<alpha> invar s\n  aluprio_\\<alpha> \\<alpha> s \\<noteq> Map.empty\n  aluprio_pop splits annot app s = (e, a, s')\n\ngoal (1 subgoal):\n 1. \\<alpha> s \\<noteq> []", "by (auto simp add: aluprio_defs)"], ["proof (state)\nthis:\n  \\<alpha> s \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>s e a s'.\n       \\<lbrakk>aluprio_invar \\<alpha> invar s;\n        aluprio_\\<alpha> \\<alpha> s \\<noteq> Map.empty;\n        aluprio_pop splits annot app s = (e, a, s')\\<rbrakk>\n       \\<Longrightarrow> aluprio_invar \\<alpha> invar s' \\<and>\n                         aluprio_\\<alpha> \\<alpha> s' =\n                         (aluprio_\\<alpha> \\<alpha> s)(e := None) \\<and>\n                         aluprio_\\<alpha> \\<alpha> s e = Some a \\<and>\n                         (\\<forall>y\\<in>ran (aluprio_\\<alpha> \\<alpha> s).\n                             a \\<le> y)", "obtain l lp r where\n      l_lp_r: \"splits (\\<lambda> x. x\\<le>annot s) Infty s = (l,((),lp),r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l lp r.\n        splits (\\<lambda>x. x \\<le> annot s) Infty s =\n        (l, ((), lp), r) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"splits (\\<lambda> x. x\\<le>annot s) Infty s\", auto)"], ["proof (state)\nthis:\n  splits (\\<lambda>x. x \\<le> annot s) Infty s = (l, ((), lp), r)\n\ngoal (1 subgoal):\n 1. \\<And>s e a s'.\n       \\<lbrakk>aluprio_invar \\<alpha> invar s;\n        aluprio_\\<alpha> \\<alpha> s \\<noteq> Map.empty;\n        aluprio_pop splits annot app s = (e, a, s')\\<rbrakk>\n       \\<Longrightarrow> aluprio_invar \\<alpha> invar s' \\<and>\n                         aluprio_\\<alpha> \\<alpha> s' =\n                         (aluprio_\\<alpha> \\<alpha> s)(e := None) \\<and>\n                         aluprio_\\<alpha> \\<alpha> s e = Some a \\<and>\n                         (\\<forall>y\\<in>ran (aluprio_\\<alpha> \\<alpha> s).\n                             a \\<le> y)", "have invs:\n      \"invar s\" \n      \"(\\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty)\"\n      \"sorted (map fst (map p_unwrap (map snd (\\<alpha> s))))\"\n      \"distinct (map fst (map p_unwrap (map snd (\\<alpha> s))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (invar s &&& \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) &&&\n    sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) &&&\n    distinct (map fst (map p_unwrap (map snd (\\<alpha> s))))", "using A"], ["proof (prove)\nusing this:\n  aluprio_invar \\<alpha> invar s\n  aluprio_\\<alpha> \\<alpha> s \\<noteq> Map.empty\n  aluprio_pop splits annot app s = (e, a, s')\n\ngoal (1 subgoal):\n 1. (invar s &&& \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty) &&&\n    sorted (map fst (map p_unwrap (map snd (\\<alpha> s)))) &&&\n    distinct (map fst (map p_unwrap (map snd (\\<alpha> s))))", "by (auto simp add:aluprio_defs)"], ["proof (state)\nthis:\n  invar s\n  \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty\n  sorted (map fst (map p_unwrap (map snd (\\<alpha> s))))\n  distinct (map fst (map p_unwrap (map snd (\\<alpha> s))))\n\ngoal (1 subgoal):\n 1. \\<And>s e a s'.\n       \\<lbrakk>aluprio_invar \\<alpha> invar s;\n        aluprio_\\<alpha> \\<alpha> s \\<noteq> Map.empty;\n        aluprio_pop splits annot app s = (e, a, s')\\<rbrakk>\n       \\<Longrightarrow> aluprio_invar \\<alpha> invar s' \\<and>\n                         aluprio_\\<alpha> \\<alpha> s' =\n                         (aluprio_\\<alpha> \\<alpha> s)(e := None) \\<and>\n                         aluprio_\\<alpha> \\<alpha> s e = Some a \\<and>\n                         (\\<forall>y\\<in>ran (aluprio_\\<alpha> \\<alpha> s).\n                             a \\<le> y)", "note a1 = annot_inf[of invar s \\<alpha> annot]"], ["proof (state)\nthis:\n  \\<lbrakk>invar s; \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty;\n   al_annot \\<alpha> invar annot\\<rbrakk>\n  \\<Longrightarrow> (annot s = Infty) = (\\<alpha> s = [])\n\ngoal (1 subgoal):\n 1. \\<And>s e a s'.\n       \\<lbrakk>aluprio_invar \\<alpha> invar s;\n        aluprio_\\<alpha> \\<alpha> s \\<noteq> Map.empty;\n        aluprio_pop splits annot app s = (e, a, s')\\<rbrakk>\n       \\<Longrightarrow> aluprio_invar \\<alpha> invar s' \\<and>\n                         aluprio_\\<alpha> \\<alpha> s' =\n                         (aluprio_\\<alpha> \\<alpha> s)(e := None) \\<and>\n                         aluprio_\\<alpha> \\<alpha> s e = Some a \\<and>\n                         (\\<forall>y\\<in>ran (aluprio_\\<alpha> \\<alpha> s).\n                             a \\<le> y)", "note a1[OF invs(1) invs(2) assms(2)]"], ["proof (state)\nthis:\n  (annot s = Infty) = (\\<alpha> s = [])\n\ngoal (1 subgoal):\n 1. \\<And>s e a s'.\n       \\<lbrakk>aluprio_invar \\<alpha> invar s;\n        aluprio_\\<alpha> \\<alpha> s \\<noteq> Map.empty;\n        aluprio_pop splits annot app s = (e, a, s')\\<rbrakk>\n       \\<Longrightarrow> aluprio_invar \\<alpha> invar s' \\<and>\n                         aluprio_\\<alpha> \\<alpha> s' =\n                         (aluprio_\\<alpha> \\<alpha> s)(e := None) \\<and>\n                         aluprio_\\<alpha> \\<alpha> s e = Some a \\<and>\n                         (\\<forall>y\\<in>ran (aluprio_\\<alpha> \\<alpha> s).\n                             a \\<le> y)", "hence v2: \"annot s \\<noteq> Infty\""], ["proof (prove)\nusing this:\n  (annot s = Infty) = (\\<alpha> s = [])\n\ngoal (1 subgoal):\n 1. annot s \\<noteq> Infty", "using v1"], ["proof (prove)\nusing this:\n  (annot s = Infty) = (\\<alpha> s = [])\n  \\<alpha> s \\<noteq> []\n\ngoal (1 subgoal):\n 1. annot s \\<noteq> Infty", "by simp"], ["proof (state)\nthis:\n  annot s \\<noteq> Infty\n\ngoal (1 subgoal):\n 1. \\<And>s e a s'.\n       \\<lbrakk>aluprio_invar \\<alpha> invar s;\n        aluprio_\\<alpha> \\<alpha> s \\<noteq> Map.empty;\n        aluprio_pop splits annot app s = (e, a, s')\\<rbrakk>\n       \\<Longrightarrow> aluprio_invar \\<alpha> invar s' \\<and>\n                         aluprio_\\<alpha> \\<alpha> s' =\n                         (aluprio_\\<alpha> \\<alpha> s)(e := None) \\<and>\n                         aluprio_\\<alpha> \\<alpha> s e = Some a \\<and>\n                         (\\<forall>y\\<in>ran (aluprio_\\<alpha> \\<alpha> s).\n                             a \\<le> y)", "hence v3:\n      \"\\<not> Infty \\<le> annot s\""], ["proof (prove)\nusing this:\n  annot s \\<noteq> Infty\n\ngoal (1 subgoal):\n 1. \\<not> Infty \\<le> annot s", "by(cases \"annot s\") (auto simp add: plesseq_def)"], ["proof (state)\nthis:\n  \\<not> Infty \\<le> annot s\n\ngoal (1 subgoal):\n 1. \\<And>s e a s'.\n       \\<lbrakk>aluprio_invar \\<alpha> invar s;\n        aluprio_\\<alpha> \\<alpha> s \\<noteq> Map.empty;\n        aluprio_pop splits annot app s = (e, a, s')\\<rbrakk>\n       \\<Longrightarrow> aluprio_invar \\<alpha> invar s' \\<and>\n                         aluprio_\\<alpha> \\<alpha> s' =\n                         (aluprio_\\<alpha> \\<alpha> s)(e := None) \\<and>\n                         aluprio_\\<alpha> \\<alpha> s e = Some a \\<and>\n                         (\\<forall>y\\<in>ran (aluprio_\\<alpha> \\<alpha> s).\n                             a \\<le> y)", "have v4: \"annot s = sum_list (map snd (\\<alpha> s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. annot s = sum_list (map snd (\\<alpha> s))", "by (auto simp add: annot_correct invs(1))"], ["proof (state)\nthis:\n  annot s = sum_list (map snd (\\<alpha> s))\n\ngoal (1 subgoal):\n 1. \\<And>s e a s'.\n       \\<lbrakk>aluprio_invar \\<alpha> invar s;\n        aluprio_\\<alpha> \\<alpha> s \\<noteq> Map.empty;\n        aluprio_pop splits annot app s = (e, a, s')\\<rbrakk>\n       \\<Longrightarrow> aluprio_invar \\<alpha> invar s' \\<and>\n                         aluprio_\\<alpha> \\<alpha> s' =\n                         (aluprio_\\<alpha> \\<alpha> s)(e := None) \\<and>\n                         aluprio_\\<alpha> \\<alpha> s e = Some a \\<and>\n                         (\\<forall>y\\<in>ran (aluprio_\\<alpha> \\<alpha> s).\n                             a \\<le> y)", "hence \n      v5:\n      \"(Infty + sum_list (map snd (\\<alpha> s))) \\<le> annot s\""], ["proof (prove)\nusing this:\n  annot s = sum_list (map snd (\\<alpha> s))\n\ngoal (1 subgoal):\n 1. Infty + sum_list (map snd (\\<alpha> s)) \\<le> annot s", "by (auto simp add: plus_def)"], ["proof (state)\nthis:\n  Infty + sum_list (map snd (\\<alpha> s)) \\<le> annot s\n\ngoal (1 subgoal):\n 1. \\<And>s e a s'.\n       \\<lbrakk>aluprio_invar \\<alpha> invar s;\n        aluprio_\\<alpha> \\<alpha> s \\<noteq> Map.empty;\n        aluprio_pop splits annot app s = (e, a, s')\\<rbrakk>\n       \\<Longrightarrow> aluprio_invar \\<alpha> invar s' \\<and>\n                         aluprio_\\<alpha> \\<alpha> s' =\n                         (aluprio_\\<alpha> \\<alpha> s)(e := None) \\<and>\n                         aluprio_\\<alpha> \\<alpha> s e = Some a \\<and>\n                         (\\<forall>y\\<in>ran (aluprio_\\<alpha> \\<alpha> s).\n                             a \\<le> y)", "note p_mon = p_less_eq_mon[of _ \"annot s\"]"], ["proof (state)\nthis:\n  ?x \\<le> annot s \\<Longrightarrow> ?x + ?y \\<le> annot s\n\ngoal (1 subgoal):\n 1. \\<And>s e a s'.\n       \\<lbrakk>aluprio_invar \\<alpha> invar s;\n        aluprio_\\<alpha> \\<alpha> s \\<noteq> Map.empty;\n        aluprio_pop splits annot app s = (e, a, s')\\<rbrakk>\n       \\<Longrightarrow> aluprio_invar \\<alpha> invar s' \\<and>\n                         aluprio_\\<alpha> \\<alpha> s' =\n                         (aluprio_\\<alpha> \\<alpha> s)(e := None) \\<and>\n                         aluprio_\\<alpha> \\<alpha> s e = Some a \\<and>\n                         (\\<forall>y\\<in>ran (aluprio_\\<alpha> \\<alpha> s).\n                             a \\<le> y)", "note v6 = splits_correct[OF invs(1)]"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>a b. ?p a \\<longrightarrow> ?p (a + b); \\<not> ?p ?i;\n   ?p (?i + sum_list (map snd (\\<alpha> s)));\n   splits ?p ?i s = (?l, (?e, ?a), ?r)\\<rbrakk>\n  \\<Longrightarrow> \\<alpha> s = \\<alpha> ?l @ (?e, ?a) # \\<alpha> ?r \\<and>\n                    \\<not> ?p (?i + sum_list (map snd (\\<alpha> ?l))) \\<and>\n                    ?p (?i + sum_list (map snd (\\<alpha> ?l)) + ?a) \\<and>\n                    invar ?l \\<and> invar ?r\n\ngoal (1 subgoal):\n 1. \\<And>s e a s'.\n       \\<lbrakk>aluprio_invar \\<alpha> invar s;\n        aluprio_\\<alpha> \\<alpha> s \\<noteq> Map.empty;\n        aluprio_pop splits annot app s = (e, a, s')\\<rbrakk>\n       \\<Longrightarrow> aluprio_invar \\<alpha> invar s' \\<and>\n                         aluprio_\\<alpha> \\<alpha> s' =\n                         (aluprio_\\<alpha> \\<alpha> s)(e := None) \\<and>\n                         aluprio_\\<alpha> \\<alpha> s e = Some a \\<and>\n                         (\\<forall>y\\<in>ran (aluprio_\\<alpha> \\<alpha> s).\n                             a \\<le> y)", "note v7 = v6[of \"\\<lambda> x. x \\<le> annot s\"]"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>a b.\n              a \\<le> annot s \\<longrightarrow> a + b \\<le> annot s;\n   \\<not> ?i \\<le> annot s;\n   ?i + sum_list (map snd (\\<alpha> s)) \\<le> annot s;\n   splits (\\<lambda>x. x \\<le> annot s) ?i s = (?l, (?e, ?a), ?r)\\<rbrakk>\n  \\<Longrightarrow> \\<alpha> s = \\<alpha> ?l @ (?e, ?a) # \\<alpha> ?r \\<and>\n                    \\<not> ?i + sum_list (map snd (\\<alpha> ?l))\n                           \\<le> annot s \\<and>\n                    ?i + sum_list (map snd (\\<alpha> ?l)) + ?a\n                    \\<le> annot s \\<and>\n                    invar ?l \\<and> invar ?r\n\ngoal (1 subgoal):\n 1. \\<And>s e a s'.\n       \\<lbrakk>aluprio_invar \\<alpha> invar s;\n        aluprio_\\<alpha> \\<alpha> s \\<noteq> Map.empty;\n        aluprio_pop splits annot app s = (e, a, s')\\<rbrakk>\n       \\<Longrightarrow> aluprio_invar \\<alpha> invar s' \\<and>\n                         aluprio_\\<alpha> \\<alpha> s' =\n                         (aluprio_\\<alpha> \\<alpha> s)(e := None) \\<and>\n                         aluprio_\\<alpha> \\<alpha> s e = Some a \\<and>\n                         (\\<forall>y\\<in>ran (aluprio_\\<alpha> \\<alpha> s).\n                             a \\<le> y)", "note v7[OF _ v3 v5 l_lp_r] p_mon"], ["proof (state)\nthis:\n  \\<forall>a b.\n     a \\<le> annot s \\<longrightarrow> a + b \\<le> annot s \\<Longrightarrow>\n  \\<alpha> s = \\<alpha> l @ ((), lp) # \\<alpha> r \\<and>\n  \\<not> Infty + sum_list (map snd (\\<alpha> l)) \\<le> annot s \\<and>\n  Infty + sum_list (map snd (\\<alpha> l)) + lp \\<le> annot s \\<and>\n  invar l \\<and> invar r\n  ?x \\<le> annot s \\<Longrightarrow> ?x + ?y \\<le> annot s\n\ngoal (1 subgoal):\n 1. \\<And>s e a s'.\n       \\<lbrakk>aluprio_invar \\<alpha> invar s;\n        aluprio_\\<alpha> \\<alpha> s \\<noteq> Map.empty;\n        aluprio_pop splits annot app s = (e, a, s')\\<rbrakk>\n       \\<Longrightarrow> aluprio_invar \\<alpha> invar s' \\<and>\n                         aluprio_\\<alpha> \\<alpha> s' =\n                         (aluprio_\\<alpha> \\<alpha> s)(e := None) \\<and>\n                         aluprio_\\<alpha> \\<alpha> s e = Some a \\<and>\n                         (\\<forall>y\\<in>ran (aluprio_\\<alpha> \\<alpha> s).\n                             a \\<le> y)", "hence v8: \n      \" \\<alpha> s = \\<alpha> l @ ((), lp) # \\<alpha> r\"\n      \"\\<not> Infty + sum_list (map snd (\\<alpha> l)) \\<le> annot s\"\n      \"Infty + sum_list (map snd (\\<alpha> l)) + lp \\<le> annot s\"\n      \"invar l\"\n      \"invar r\""], ["proof (prove)\nusing this:\n  \\<forall>a b.\n     a \\<le> annot s \\<longrightarrow> a + b \\<le> annot s \\<Longrightarrow>\n  \\<alpha> s = \\<alpha> l @ ((), lp) # \\<alpha> r \\<and>\n  \\<not> Infty + sum_list (map snd (\\<alpha> l)) \\<le> annot s \\<and>\n  Infty + sum_list (map snd (\\<alpha> l)) + lp \\<le> annot s \\<and>\n  invar l \\<and> invar r\n  ?x \\<le> annot s \\<Longrightarrow> ?x + ?y \\<le> annot s\n\ngoal (1 subgoal):\n 1. (\\<alpha> s = \\<alpha> l @ ((), lp) # \\<alpha> r &&&\n     \\<not> Infty + sum_list (map snd (\\<alpha> l)) \\<le> annot s) &&&\n    Infty + sum_list (map snd (\\<alpha> l)) + lp \\<le> annot s &&&\n    invar l &&& invar r", "by auto"], ["proof (state)\nthis:\n  \\<alpha> s = \\<alpha> l @ ((), lp) # \\<alpha> r\n  \\<not> Infty + sum_list (map snd (\\<alpha> l)) \\<le> annot s\n  Infty + sum_list (map snd (\\<alpha> l)) + lp \\<le> annot s\n  invar l\n  invar r\n\ngoal (1 subgoal):\n 1. \\<And>s e a s'.\n       \\<lbrakk>aluprio_invar \\<alpha> invar s;\n        aluprio_\\<alpha> \\<alpha> s \\<noteq> Map.empty;\n        aluprio_pop splits annot app s = (e, a, s')\\<rbrakk>\n       \\<Longrightarrow> aluprio_invar \\<alpha> invar s' \\<and>\n                         aluprio_\\<alpha> \\<alpha> s' =\n                         (aluprio_\\<alpha> \\<alpha> s)(e := None) \\<and>\n                         aluprio_\\<alpha> \\<alpha> s e = Some a \\<and>\n                         (\\<forall>y\\<in>ran (aluprio_\\<alpha> \\<alpha> s).\n                             a \\<le> y)", "hence v9: \"lp \\<noteq> Infty\""], ["proof (prove)\nusing this:\n  \\<alpha> s = \\<alpha> l @ ((), lp) # \\<alpha> r\n  \\<not> Infty + sum_list (map snd (\\<alpha> l)) \\<le> annot s\n  Infty + sum_list (map snd (\\<alpha> l)) + lp \\<le> annot s\n  invar l\n  invar r\n\ngoal (1 subgoal):\n 1. lp \\<noteq> Infty", "using invs(2)"], ["proof (prove)\nusing this:\n  \\<alpha> s = \\<alpha> l @ ((), lp) # \\<alpha> r\n  \\<not> Infty + sum_list (map snd (\\<alpha> l)) \\<le> annot s\n  Infty + sum_list (map snd (\\<alpha> l)) + lp \\<le> annot s\n  invar l\n  invar r\n  \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty\n\ngoal (1 subgoal):\n 1. lp \\<noteq> Infty", "by auto"], ["proof (state)\nthis:\n  lp \\<noteq> Infty\n\ngoal (1 subgoal):\n 1. \\<And>s e a s'.\n       \\<lbrakk>aluprio_invar \\<alpha> invar s;\n        aluprio_\\<alpha> \\<alpha> s \\<noteq> Map.empty;\n        aluprio_pop splits annot app s = (e, a, s')\\<rbrakk>\n       \\<Longrightarrow> aluprio_invar \\<alpha> invar s' \\<and>\n                         aluprio_\\<alpha> \\<alpha> s' =\n                         (aluprio_\\<alpha> \\<alpha> s)(e := None) \\<and>\n                         aluprio_\\<alpha> \\<alpha> s e = Some a \\<and>\n                         (\\<forall>y\\<in>ran (aluprio_\\<alpha> \\<alpha> s).\n                             a \\<le> y)", "hence v10: \n      \"s' = app l r\" \n      \"(e,a) = p_unwrap lp\""], ["proof (prove)\nusing this:\n  lp \\<noteq> Infty\n\ngoal (1 subgoal):\n 1. s' = app l r &&& (e, a) = p_unwrap lp", "using l_lp_r A(3)"], ["proof (prove)\nusing this:\n  lp \\<noteq> Infty\n  splits (\\<lambda>x. x \\<le> annot s) Infty s = (l, ((), lp), r)\n  aluprio_pop splits annot app s = (e, a, s')\n\ngoal (1 subgoal):\n 1. s' = app l r &&& (e, a) = p_unwrap lp", "apply (auto simp add: aluprio_defs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>lp \\<noteq> Infty;\n     splits (\\<lambda>x. x \\<le> annot s) Infty s = (l, ((), lp), r);\n     (case lp of LP e a \\<Rightarrow> (e, a, app l r)) = (e, a, s')\\<rbrakk>\n    \\<Longrightarrow> s' = app l r\n 2. \\<lbrakk>lp \\<noteq> Infty;\n     splits (\\<lambda>x. x \\<le> annot s) Infty s = (l, ((), lp), r);\n     (case lp of LP e a \\<Rightarrow> (e, a, app l r)) = (e, a, s')\\<rbrakk>\n    \\<Longrightarrow> (e, a) = p_unwrap lp", "apply (cases lp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>lp \\<noteq> Infty;\n     splits (\\<lambda>x. x \\<le> annot s) Infty s = (l, ((), lp), r);\n     (case lp of LP e a \\<Rightarrow> (e, a, app l r)) = (e, a, s');\n     lp = Infty\\<rbrakk>\n    \\<Longrightarrow> s' = app l r\n 2. \\<And>x21 x22.\n       \\<lbrakk>lp \\<noteq> Infty;\n        splits (\\<lambda>x. x \\<le> annot s) Infty s = (l, ((), lp), r);\n        (case lp of LP e a \\<Rightarrow> (e, a, app l r)) = (e, a, s');\n        lp = LP x21 x22\\<rbrakk>\n       \\<Longrightarrow> s' = app l r\n 3. \\<lbrakk>lp \\<noteq> Infty;\n     splits (\\<lambda>x. x \\<le> annot s) Infty s = (l, ((), lp), r);\n     (case lp of LP e a \\<Rightarrow> (e, a, app l r)) = (e, a, s')\\<rbrakk>\n    \\<Longrightarrow> (e, a) = p_unwrap lp", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lp \\<noteq> Infty;\n     splits (\\<lambda>x. x \\<le> annot s) Infty s = (l, ((), lp), r);\n     (case lp of LP e a \\<Rightarrow> (e, a, app l r)) = (e, a, s')\\<rbrakk>\n    \\<Longrightarrow> (e, a) = p_unwrap lp", "apply (cases lp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>lp \\<noteq> Infty;\n     splits (\\<lambda>x. x \\<le> annot s) Infty s = (l, ((), lp), r);\n     (case lp of LP e a \\<Rightarrow> (e, a, app l r)) = (e, a, s');\n     lp = Infty\\<rbrakk>\n    \\<Longrightarrow> (e, a) = p_unwrap lp\n 2. \\<And>x21 x22.\n       \\<lbrakk>lp \\<noteq> Infty;\n        splits (\\<lambda>x. x \\<le> annot s) Infty s = (l, ((), lp), r);\n        (case lp of LP e a \\<Rightarrow> (e, a, app l r)) = (e, a, s');\n        lp = LP x21 x22\\<rbrakk>\n       \\<Longrightarrow> (e, a) = p_unwrap lp", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  s' = app l r\n  (e, a) = p_unwrap lp\n\ngoal (1 subgoal):\n 1. \\<And>s e a s'.\n       \\<lbrakk>aluprio_invar \\<alpha> invar s;\n        aluprio_\\<alpha> \\<alpha> s \\<noteq> Map.empty;\n        aluprio_pop splits annot app s = (e, a, s')\\<rbrakk>\n       \\<Longrightarrow> aluprio_invar \\<alpha> invar s' \\<and>\n                         aluprio_\\<alpha> \\<alpha> s' =\n                         (aluprio_\\<alpha> \\<alpha> s)(e := None) \\<and>\n                         aluprio_\\<alpha> \\<alpha> s e = Some a \\<and>\n                         (\\<forall>y\\<in>ran (aluprio_\\<alpha> \\<alpha> s).\n                             a \\<le> y)", "have \"lp \\<le> annot s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lp \\<le> annot s", "using v8(2,3) p_less_eq_lem1"], ["proof (prove)\nusing this:\n  \\<not> Infty + sum_list (map snd (\\<alpha> l)) \\<le> annot s\n  Infty + sum_list (map snd (\\<alpha> l)) + lp \\<le> annot s\n  \\<lbrakk>\\<not> ?x \\<le> ?z; ?x + ?y \\<le> ?z\\<rbrakk>\n  \\<Longrightarrow> ?y \\<le> ?z\n\ngoal (1 subgoal):\n 1. lp \\<le> annot s", "by auto"], ["proof (state)\nthis:\n  lp \\<le> annot s\n\ngoal (1 subgoal):\n 1. \\<And>s e a s'.\n       \\<lbrakk>aluprio_invar \\<alpha> invar s;\n        aluprio_\\<alpha> \\<alpha> s \\<noteq> Map.empty;\n        aluprio_pop splits annot app s = (e, a, s')\\<rbrakk>\n       \\<Longrightarrow> aluprio_invar \\<alpha> invar s' \\<and>\n                         aluprio_\\<alpha> \\<alpha> s' =\n                         (aluprio_\\<alpha> \\<alpha> s)(e := None) \\<and>\n                         aluprio_\\<alpha> \\<alpha> s e = Some a \\<and>\n                         (\\<forall>y\\<in>ran (aluprio_\\<alpha> \\<alpha> s).\n                             a \\<le> y)", "hence v11: \"a \\<le> snd (p_unwrap (annot s))\""], ["proof (prove)\nusing this:\n  lp \\<le> annot s\n\ngoal (1 subgoal):\n 1. a \\<le> snd (p_unwrap (annot s))", "using v10(2) v2 v9"], ["proof (prove)\nusing this:\n  lp \\<le> annot s\n  (e, a) = p_unwrap lp\n  annot s \\<noteq> Infty\n  lp \\<noteq> Infty\n\ngoal (1 subgoal):\n 1. a \\<le> snd (p_unwrap (annot s))", "apply (cases \"annot s\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>lp \\<le> annot s; (e, a) = p_unwrap lp; annot s \\<noteq> Infty;\n     lp \\<noteq> Infty; annot s = Infty\\<rbrakk>\n    \\<Longrightarrow> a \\<le> snd (p_unwrap (annot s))\n 2. \\<And>x21 x22.\n       \\<lbrakk>lp \\<le> annot s; (e, a) = p_unwrap lp;\n        annot s \\<noteq> Infty; lp \\<noteq> Infty;\n        annot s = LP x21 x22\\<rbrakk>\n       \\<Longrightarrow> a \\<le> snd (p_unwrap (annot s))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       \\<lbrakk>lp \\<le> LP x21 x22; (e, a) = p_unwrap lp;\n        lp \\<noteq> Infty; annot s = LP x21 x22\\<rbrakk>\n       \\<Longrightarrow> a \\<le> x22", "apply (cases lp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>lp \\<le> LP x21 x22; (e, a) = p_unwrap lp;\n        lp \\<noteq> Infty; annot s = LP x21 x22; lp = Infty\\<rbrakk>\n       \\<Longrightarrow> a \\<le> x22\n 2. \\<And>x21 x22 x21a x22a.\n       \\<lbrakk>lp \\<le> LP x21 x22; (e, a) = p_unwrap lp;\n        lp \\<noteq> Infty; annot s = LP x21 x22; lp = LP x21a x22a\\<rbrakk>\n       \\<Longrightarrow> a \\<le> x22", "apply (auto simp add: plesseq_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  a \\<le> snd (p_unwrap (annot s))\n\ngoal (1 subgoal):\n 1. \\<And>s e a s'.\n       \\<lbrakk>aluprio_invar \\<alpha> invar s;\n        aluprio_\\<alpha> \\<alpha> s \\<noteq> Map.empty;\n        aluprio_pop splits annot app s = (e, a, s')\\<rbrakk>\n       \\<Longrightarrow> aluprio_invar \\<alpha> invar s' \\<and>\n                         aluprio_\\<alpha> \\<alpha> s' =\n                         (aluprio_\\<alpha> \\<alpha> s)(e := None) \\<and>\n                         aluprio_\\<alpha> \\<alpha> s e = Some a \\<and>\n                         (\\<forall>y\\<in>ran (aluprio_\\<alpha> \\<alpha> s).\n                             a \\<le> y)", "note sum_list_less_elems[OF invs(2)]"], ["proof (state)\nthis:\n  \\<forall>y\\<in>set (map snd (map p_unwrap (map snd (\\<alpha> s)))).\n     snd (p_unwrap (sum_list (map snd (\\<alpha> s)))) \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>s e a s'.\n       \\<lbrakk>aluprio_invar \\<alpha> invar s;\n        aluprio_\\<alpha> \\<alpha> s \\<noteq> Map.empty;\n        aluprio_pop splits annot app s = (e, a, s')\\<rbrakk>\n       \\<Longrightarrow> aluprio_invar \\<alpha> invar s' \\<and>\n                         aluprio_\\<alpha> \\<alpha> s' =\n                         (aluprio_\\<alpha> \\<alpha> s)(e := None) \\<and>\n                         aluprio_\\<alpha> \\<alpha> s e = Some a \\<and>\n                         (\\<forall>y\\<in>ran (aluprio_\\<alpha> \\<alpha> s).\n                             a \\<le> y)", "hence v12: \"\\<forall>y\\<in>set (map snd (map p_unwrap (map snd (\\<alpha> s)))). a \\<le> y\""], ["proof (prove)\nusing this:\n  \\<forall>y\\<in>set (map snd (map p_unwrap (map snd (\\<alpha> s)))).\n     snd (p_unwrap (sum_list (map snd (\\<alpha> s)))) \\<le> y\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>set (map snd (map p_unwrap (map snd (\\<alpha> s)))).\n       a \\<le> y", "using v4 v11"], ["proof (prove)\nusing this:\n  \\<forall>y\\<in>set (map snd (map p_unwrap (map snd (\\<alpha> s)))).\n     snd (p_unwrap (sum_list (map snd (\\<alpha> s)))) \\<le> y\n  annot s = sum_list (map snd (\\<alpha> s))\n  a \\<le> snd (p_unwrap (annot s))\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>set (map snd (map p_unwrap (map snd (\\<alpha> s)))).\n       a \\<le> y", "by auto"], ["proof (state)\nthis:\n  \\<forall>y\\<in>set (map snd (map p_unwrap (map snd (\\<alpha> s)))).\n     a \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>s e a s'.\n       \\<lbrakk>aluprio_invar \\<alpha> invar s;\n        aluprio_\\<alpha> \\<alpha> s \\<noteq> Map.empty;\n        aluprio_pop splits annot app s = (e, a, s')\\<rbrakk>\n       \\<Longrightarrow> aluprio_invar \\<alpha> invar s' \\<and>\n                         aluprio_\\<alpha> \\<alpha> s' =\n                         (aluprio_\\<alpha> \\<alpha> s)(e := None) \\<and>\n                         aluprio_\\<alpha> \\<alpha> s e = Some a \\<and>\n                         (\\<forall>y\\<in>ran (aluprio_\\<alpha> \\<alpha> s).\n                             a \\<le> y)", "have \"ran (aluprio_\\<alpha> \\<alpha> s) = set (map snd (map p_unwrap (map snd (\\<alpha> s))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ran (aluprio_\\<alpha> \\<alpha> s) =\n    set (map snd (map p_unwrap (map snd (\\<alpha> s))))", "using ran_distinct[OF invs(4)]"], ["proof (prove)\nusing this:\n  ran (map_of (map p_unwrap (map snd (\\<alpha> s)))) =\n  snd ` set (map p_unwrap (map snd (\\<alpha> s)))\n\ngoal (1 subgoal):\n 1. ran (aluprio_\\<alpha> \\<alpha> s) =\n    set (map snd (map p_unwrap (map snd (\\<alpha> s))))", "apply (unfold aluprio_defs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ran (map_of (map p_unwrap (map snd (\\<alpha> s)))) =\n    snd ` set (map p_unwrap (map snd (\\<alpha> s))) \\<Longrightarrow>\n    ran (map_of (map p_unwrap (map snd (\\<alpha> s)))) =\n    set (map snd (map p_unwrap (map snd (\\<alpha> s))))", "apply (simp only: set_map)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ran (aluprio_\\<alpha> \\<alpha> s) =\n  set (map snd (map p_unwrap (map snd (\\<alpha> s))))\n\ngoal (1 subgoal):\n 1. \\<And>s e a s'.\n       \\<lbrakk>aluprio_invar \\<alpha> invar s;\n        aluprio_\\<alpha> \\<alpha> s \\<noteq> Map.empty;\n        aluprio_pop splits annot app s = (e, a, s')\\<rbrakk>\n       \\<Longrightarrow> aluprio_invar \\<alpha> invar s' \\<and>\n                         aluprio_\\<alpha> \\<alpha> s' =\n                         (aluprio_\\<alpha> \\<alpha> s)(e := None) \\<and>\n                         aluprio_\\<alpha> \\<alpha> s e = Some a \\<and>\n                         (\\<forall>y\\<in>ran (aluprio_\\<alpha> \\<alpha> s).\n                             a \\<le> y)", "hence ziel1: \"\\<forall>y\\<in>ran (aluprio_\\<alpha> \\<alpha> s). a \\<le> y\""], ["proof (prove)\nusing this:\n  ran (aluprio_\\<alpha> \\<alpha> s) =\n  set (map snd (map p_unwrap (map snd (\\<alpha> s))))\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>ran (aluprio_\\<alpha> \\<alpha> s). a \\<le> y", "using v12"], ["proof (prove)\nusing this:\n  ran (aluprio_\\<alpha> \\<alpha> s) =\n  set (map snd (map p_unwrap (map snd (\\<alpha> s))))\n  \\<forall>y\\<in>set (map snd (map p_unwrap (map snd (\\<alpha> s)))).\n     a \\<le> y\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>ran (aluprio_\\<alpha> \\<alpha> s). a \\<le> y", "by simp"], ["proof (state)\nthis:\n  \\<forall>y\\<in>ran (aluprio_\\<alpha> \\<alpha> s). a \\<le> y\n\ngoal (1 subgoal):\n 1. \\<And>s e a s'.\n       \\<lbrakk>aluprio_invar \\<alpha> invar s;\n        aluprio_\\<alpha> \\<alpha> s \\<noteq> Map.empty;\n        aluprio_pop splits annot app s = (e, a, s')\\<rbrakk>\n       \\<Longrightarrow> aluprio_invar \\<alpha> invar s' \\<and>\n                         aluprio_\\<alpha> \\<alpha> s' =\n                         (aluprio_\\<alpha> \\<alpha> s)(e := None) \\<and>\n                         aluprio_\\<alpha> \\<alpha> s e = Some a \\<and>\n                         (\\<forall>y\\<in>ran (aluprio_\\<alpha> \\<alpha> s).\n                             a \\<le> y)", "have v13:\n      \"map p_unwrap (map snd (\\<alpha> s)) \n        = map p_unwrap (map  snd (\\<alpha> l)) @ (e,a) # map p_unwrap (map snd (\\<alpha> r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map p_unwrap (map snd (\\<alpha> s)) =\n    map p_unwrap (map snd (\\<alpha> l)) @\n    (e, a) # map p_unwrap (map snd (\\<alpha> r))", "using v8(1) v10"], ["proof (prove)\nusing this:\n  \\<alpha> s = \\<alpha> l @ ((), lp) # \\<alpha> r\n  s' = app l r\n  (e, a) = p_unwrap lp\n\ngoal (1 subgoal):\n 1. map p_unwrap (map snd (\\<alpha> s)) =\n    map p_unwrap (map snd (\\<alpha> l)) @\n    (e, a) # map p_unwrap (map snd (\\<alpha> r))", "by auto"], ["proof (state)\nthis:\n  map p_unwrap (map snd (\\<alpha> s)) =\n  map p_unwrap (map snd (\\<alpha> l)) @\n  (e, a) # map p_unwrap (map snd (\\<alpha> r))\n\ngoal (1 subgoal):\n 1. \\<And>s e a s'.\n       \\<lbrakk>aluprio_invar \\<alpha> invar s;\n        aluprio_\\<alpha> \\<alpha> s \\<noteq> Map.empty;\n        aluprio_pop splits annot app s = (e, a, s')\\<rbrakk>\n       \\<Longrightarrow> aluprio_invar \\<alpha> invar s' \\<and>\n                         aluprio_\\<alpha> \\<alpha> s' =\n                         (aluprio_\\<alpha> \\<alpha> s)(e := None) \\<and>\n                         aluprio_\\<alpha> \\<alpha> s e = Some a \\<and>\n                         (\\<forall>y\\<in>ran (aluprio_\\<alpha> \\<alpha> s).\n                             a \\<le> y)", "hence v14:\n      \"map fst (map p_unwrap (map snd (\\<alpha> s))) \n         = map fst (map p_unwrap (map snd (\\<alpha> l))) @ e \n             # map fst (map p_unwrap (map snd (\\<alpha> r)))\""], ["proof (prove)\nusing this:\n  map p_unwrap (map snd (\\<alpha> s)) =\n  map p_unwrap (map snd (\\<alpha> l)) @\n  (e, a) # map p_unwrap (map snd (\\<alpha> r))\n\ngoal (1 subgoal):\n 1. map fst (map p_unwrap (map snd (\\<alpha> s))) =\n    map fst (map p_unwrap (map snd (\\<alpha> l))) @\n    e # map fst (map p_unwrap (map snd (\\<alpha> r)))", "by auto"], ["proof (state)\nthis:\n  map fst (map p_unwrap (map snd (\\<alpha> s))) =\n  map fst (map p_unwrap (map snd (\\<alpha> l))) @\n  e # map fst (map p_unwrap (map snd (\\<alpha> r)))\n\ngoal (1 subgoal):\n 1. \\<And>s e a s'.\n       \\<lbrakk>aluprio_invar \\<alpha> invar s;\n        aluprio_\\<alpha> \\<alpha> s \\<noteq> Map.empty;\n        aluprio_pop splits annot app s = (e, a, s')\\<rbrakk>\n       \\<Longrightarrow> aluprio_invar \\<alpha> invar s' \\<and>\n                         aluprio_\\<alpha> \\<alpha> s' =\n                         (aluprio_\\<alpha> \\<alpha> s)(e := None) \\<and>\n                         aluprio_\\<alpha> \\<alpha> s e = Some a \\<and>\n                         (\\<forall>y\\<in>ran (aluprio_\\<alpha> \\<alpha> s).\n                             a \\<le> y)", "hence v15: \n      \"e \\<notin> set (map fst (map p_unwrap (map snd (\\<alpha> l))))\"\n      \"e \\<notin> set (map fst (map p_unwrap (map snd (\\<alpha> r))))\""], ["proof (prove)\nusing this:\n  map fst (map p_unwrap (map snd (\\<alpha> s))) =\n  map fst (map p_unwrap (map snd (\\<alpha> l))) @\n  e # map fst (map p_unwrap (map snd (\\<alpha> r)))\n\ngoal (1 subgoal):\n 1. e \\<notin> set (map fst (map p_unwrap (map snd (\\<alpha> l)))) &&&\n    e \\<notin> set (map fst (map p_unwrap (map snd (\\<alpha> r))))", "using invs(4)"], ["proof (prove)\nusing this:\n  map fst (map p_unwrap (map snd (\\<alpha> s))) =\n  map fst (map p_unwrap (map snd (\\<alpha> l))) @\n  e # map fst (map p_unwrap (map snd (\\<alpha> r)))\n  distinct (map fst (map p_unwrap (map snd (\\<alpha> s))))\n\ngoal (1 subgoal):\n 1. e \\<notin> set (map fst (map p_unwrap (map snd (\\<alpha> l)))) &&&\n    e \\<notin> set (map fst (map p_unwrap (map snd (\\<alpha> r))))", "by auto"], ["proof (state)\nthis:\n  e \\<notin> set (map fst (map p_unwrap (map snd (\\<alpha> l))))\n  e \\<notin> set (map fst (map p_unwrap (map snd (\\<alpha> r))))\n\ngoal (1 subgoal):\n 1. \\<And>s e a s'.\n       \\<lbrakk>aluprio_invar \\<alpha> invar s;\n        aluprio_\\<alpha> \\<alpha> s \\<noteq> Map.empty;\n        aluprio_pop splits annot app s = (e, a, s')\\<rbrakk>\n       \\<Longrightarrow> aluprio_invar \\<alpha> invar s' \\<and>\n                         aluprio_\\<alpha> \\<alpha> s' =\n                         (aluprio_\\<alpha> \\<alpha> s)(e := None) \\<and>\n                         aluprio_\\<alpha> \\<alpha> s e = Some a \\<and>\n                         (\\<forall>y\\<in>ran (aluprio_\\<alpha> \\<alpha> s).\n                             a \\<le> y)", "note map_of_distinct_lookup[OF v15]"], ["proof (state)\nthis:\n  map_of\n   (map p_unwrap (map snd (\\<alpha> l)) @\n    (e, ?y) # map p_unwrap (map snd (\\<alpha> r)))\n   e =\n  Some ?y\n\ngoal (1 subgoal):\n 1. \\<And>s e a s'.\n       \\<lbrakk>aluprio_invar \\<alpha> invar s;\n        aluprio_\\<alpha> \\<alpha> s \\<noteq> Map.empty;\n        aluprio_pop splits annot app s = (e, a, s')\\<rbrakk>\n       \\<Longrightarrow> aluprio_invar \\<alpha> invar s' \\<and>\n                         aluprio_\\<alpha> \\<alpha> s' =\n                         (aluprio_\\<alpha> \\<alpha> s)(e := None) \\<and>\n                         aluprio_\\<alpha> \\<alpha> s e = Some a \\<and>\n                         (\\<forall>y\\<in>ran (aluprio_\\<alpha> \\<alpha> s).\n                             a \\<le> y)", "note this[of a]"], ["proof (state)\nthis:\n  map_of\n   (map p_unwrap (map snd (\\<alpha> l)) @\n    (e, a) # map p_unwrap (map snd (\\<alpha> r)))\n   e =\n  Some a\n\ngoal (1 subgoal):\n 1. \\<And>s e a s'.\n       \\<lbrakk>aluprio_invar \\<alpha> invar s;\n        aluprio_\\<alpha> \\<alpha> s \\<noteq> Map.empty;\n        aluprio_pop splits annot app s = (e, a, s')\\<rbrakk>\n       \\<Longrightarrow> aluprio_invar \\<alpha> invar s' \\<and>\n                         aluprio_\\<alpha> \\<alpha> s' =\n                         (aluprio_\\<alpha> \\<alpha> s)(e := None) \\<and>\n                         aluprio_\\<alpha> \\<alpha> s e = Some a \\<and>\n                         (\\<forall>y\\<in>ran (aluprio_\\<alpha> \\<alpha> s).\n                             a \\<le> y)", "hence ziel2: \"aluprio_\\<alpha> \\<alpha> s e = Some a\""], ["proof (prove)\nusing this:\n  map_of\n   (map p_unwrap (map snd (\\<alpha> l)) @\n    (e, a) # map p_unwrap (map snd (\\<alpha> r)))\n   e =\n  Some a\n\ngoal (1 subgoal):\n 1. aluprio_\\<alpha> \\<alpha> s e = Some a", "using  v13"], ["proof (prove)\nusing this:\n  map_of\n   (map p_unwrap (map snd (\\<alpha> l)) @\n    (e, a) # map p_unwrap (map snd (\\<alpha> r)))\n   e =\n  Some a\n  map p_unwrap (map snd (\\<alpha> s)) =\n  map p_unwrap (map snd (\\<alpha> l)) @\n  (e, a) # map p_unwrap (map snd (\\<alpha> r))\n\ngoal (1 subgoal):\n 1. aluprio_\\<alpha> \\<alpha> s e = Some a", "by (unfold aluprio_defs, auto)"], ["proof (state)\nthis:\n  aluprio_\\<alpha> \\<alpha> s e = Some a\n\ngoal (1 subgoal):\n 1. \\<And>s e a s'.\n       \\<lbrakk>aluprio_invar \\<alpha> invar s;\n        aluprio_\\<alpha> \\<alpha> s \\<noteq> Map.empty;\n        aluprio_pop splits annot app s = (e, a, s')\\<rbrakk>\n       \\<Longrightarrow> aluprio_invar \\<alpha> invar s' \\<and>\n                         aluprio_\\<alpha> \\<alpha> s' =\n                         (aluprio_\\<alpha> \\<alpha> s)(e := None) \\<and>\n                         aluprio_\\<alpha> \\<alpha> s e = Some a \\<and>\n                         (\\<forall>y\\<in>ran (aluprio_\\<alpha> \\<alpha> s).\n                             a \\<le> y)", "have v16: \n      \"\\<alpha> s' = \\<alpha> l @ \\<alpha> r\" \n      \"invar s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> s' = \\<alpha> l @ \\<alpha> r &&& invar s'", "using v8(4,5) app_correct v10"], ["proof (prove)\nusing this:\n  invar l\n  invar r\n  \\<lbrakk>invar ?s; invar ?s'\\<rbrakk>\n  \\<Longrightarrow> \\<alpha> (app ?s ?s') = \\<alpha> ?s @ \\<alpha> ?s'\n  \\<lbrakk>invar ?s; invar ?s'\\<rbrakk> \\<Longrightarrow> invar (app ?s ?s')\n  s' = app l r\n  (e, a) = p_unwrap lp\n\ngoal (1 subgoal):\n 1. \\<alpha> s' = \\<alpha> l @ \\<alpha> r &&& invar s'", "by auto"], ["proof (state)\nthis:\n  \\<alpha> s' = \\<alpha> l @ \\<alpha> r\n  invar s'\n\ngoal (1 subgoal):\n 1. \\<And>s e a s'.\n       \\<lbrakk>aluprio_invar \\<alpha> invar s;\n        aluprio_\\<alpha> \\<alpha> s \\<noteq> Map.empty;\n        aluprio_pop splits annot app s = (e, a, s')\\<rbrakk>\n       \\<Longrightarrow> aluprio_invar \\<alpha> invar s' \\<and>\n                         aluprio_\\<alpha> \\<alpha> s' =\n                         (aluprio_\\<alpha> \\<alpha> s)(e := None) \\<and>\n                         aluprio_\\<alpha> \\<alpha> s e = Some a \\<and>\n                         (\\<forall>y\\<in>ran (aluprio_\\<alpha> \\<alpha> s).\n                             a \\<le> y)", "note map_of_distinct_upd4[OF v15]"], ["proof (state)\nthis:\n  map_of\n   (map p_unwrap (map snd (\\<alpha> l)) @\n    map p_unwrap (map snd (\\<alpha> r))) =\n  (map_of\n    (map p_unwrap (map snd (\\<alpha> l)) @\n     (e, ?y) # map p_unwrap (map snd (\\<alpha> r))))\n  (e := None)\n\ngoal (1 subgoal):\n 1. \\<And>s e a s'.\n       \\<lbrakk>aluprio_invar \\<alpha> invar s;\n        aluprio_\\<alpha> \\<alpha> s \\<noteq> Map.empty;\n        aluprio_pop splits annot app s = (e, a, s')\\<rbrakk>\n       \\<Longrightarrow> aluprio_invar \\<alpha> invar s' \\<and>\n                         aluprio_\\<alpha> \\<alpha> s' =\n                         (aluprio_\\<alpha> \\<alpha> s)(e := None) \\<and>\n                         aluprio_\\<alpha> \\<alpha> s e = Some a \\<and>\n                         (\\<forall>y\\<in>ran (aluprio_\\<alpha> \\<alpha> s).\n                             a \\<le> y)", "note this[of a]"], ["proof (state)\nthis:\n  map_of\n   (map p_unwrap (map snd (\\<alpha> l)) @\n    map p_unwrap (map snd (\\<alpha> r))) =\n  (map_of\n    (map p_unwrap (map snd (\\<alpha> l)) @\n     (e, a) # map p_unwrap (map snd (\\<alpha> r))))\n  (e := None)\n\ngoal (1 subgoal):\n 1. \\<And>s e a s'.\n       \\<lbrakk>aluprio_invar \\<alpha> invar s;\n        aluprio_\\<alpha> \\<alpha> s \\<noteq> Map.empty;\n        aluprio_pop splits annot app s = (e, a, s')\\<rbrakk>\n       \\<Longrightarrow> aluprio_invar \\<alpha> invar s' \\<and>\n                         aluprio_\\<alpha> \\<alpha> s' =\n                         (aluprio_\\<alpha> \\<alpha> s)(e := None) \\<and>\n                         aluprio_\\<alpha> \\<alpha> s e = Some a \\<and>\n                         (\\<forall>y\\<in>ran (aluprio_\\<alpha> \\<alpha> s).\n                             a \\<le> y)", "hence \n      ziel3: \"aluprio_\\<alpha> \\<alpha> s' = (aluprio_\\<alpha> \\<alpha> s)(e := None)\""], ["proof (prove)\nusing this:\n  map_of\n   (map p_unwrap (map snd (\\<alpha> l)) @\n    map p_unwrap (map snd (\\<alpha> r))) =\n  (map_of\n    (map p_unwrap (map snd (\\<alpha> l)) @\n     (e, a) # map p_unwrap (map snd (\\<alpha> r))))\n  (e := None)\n\ngoal (1 subgoal):\n 1. aluprio_\\<alpha> \\<alpha> s' = (aluprio_\\<alpha> \\<alpha> s)(e := None)", "unfolding aluprio_defs"], ["proof (prove)\nusing this:\n  map_of\n   (map p_unwrap (map snd (\\<alpha> l)) @\n    map p_unwrap (map snd (\\<alpha> r))) =\n  (map_of\n    (map p_unwrap (map snd (\\<alpha> l)) @\n     (e, a) # map p_unwrap (map snd (\\<alpha> r))))\n  (e := None)\n\ngoal (1 subgoal):\n 1. map_of (map p_unwrap (map snd (\\<alpha> s'))) =\n    (map_of (map p_unwrap (map snd (\\<alpha> s))))(e := None)", "using v16(1) v13"], ["proof (prove)\nusing this:\n  map_of\n   (map p_unwrap (map snd (\\<alpha> l)) @\n    map p_unwrap (map snd (\\<alpha> r))) =\n  (map_of\n    (map p_unwrap (map snd (\\<alpha> l)) @\n     (e, a) # map p_unwrap (map snd (\\<alpha> r))))\n  (e := None)\n  \\<alpha> s' = \\<alpha> l @ \\<alpha> r\n  map p_unwrap (map snd (\\<alpha> s)) =\n  map p_unwrap (map snd (\\<alpha> l)) @\n  (e, a) # map p_unwrap (map snd (\\<alpha> r))\n\ngoal (1 subgoal):\n 1. map_of (map p_unwrap (map snd (\\<alpha> s'))) =\n    (map_of (map p_unwrap (map snd (\\<alpha> s))))(e := None)", "by auto"], ["proof (state)\nthis:\n  aluprio_\\<alpha> \\<alpha> s' = (aluprio_\\<alpha> \\<alpha> s)(e := None)\n\ngoal (1 subgoal):\n 1. \\<And>s e a s'.\n       \\<lbrakk>aluprio_invar \\<alpha> invar s;\n        aluprio_\\<alpha> \\<alpha> s \\<noteq> Map.empty;\n        aluprio_pop splits annot app s = (e, a, s')\\<rbrakk>\n       \\<Longrightarrow> aluprio_invar \\<alpha> invar s' \\<and>\n                         aluprio_\\<alpha> \\<alpha> s' =\n                         (aluprio_\\<alpha> \\<alpha> s)(e := None) \\<and>\n                         aluprio_\\<alpha> \\<alpha> s e = Some a \\<and>\n                         (\\<forall>y\\<in>ran (aluprio_\\<alpha> \\<alpha> s).\n                             a \\<le> y)", "have ziel4: \"aluprio_invar \\<alpha> invar s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aluprio_invar \\<alpha> invar s'", "using v16 v8(1) invs(2,3,4)"], ["proof (prove)\nusing this:\n  \\<alpha> s' = \\<alpha> l @ \\<alpha> r\n  invar s'\n  \\<alpha> s = \\<alpha> l @ ((), lp) # \\<alpha> r\n  \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty\n  sorted (map fst (map p_unwrap (map snd (\\<alpha> s))))\n  distinct (map fst (map p_unwrap (map snd (\\<alpha> s))))\n\ngoal (1 subgoal):\n 1. aluprio_invar \\<alpha> invar s'", "unfolding aluprio_defs"], ["proof (prove)\nusing this:\n  \\<alpha> s' = \\<alpha> l @ \\<alpha> r\n  invar s'\n  \\<alpha> s = \\<alpha> l @ ((), lp) # \\<alpha> r\n  \\<forall>x\\<in>set (\\<alpha> s). snd x \\<noteq> Infty\n  sorted (map fst (map p_unwrap (map snd (\\<alpha> s))))\n  distinct (map fst (map p_unwrap (map snd (\\<alpha> s))))\n\ngoal (1 subgoal):\n 1. invar s' \\<and>\n    (\\<forall>x\\<in>set (\\<alpha> s'). snd x \\<noteq> Infty) \\<and>\n    sorted (map fst (map p_unwrap (map snd (\\<alpha> s')))) \\<and>\n    distinct (map fst (map p_unwrap (map snd (\\<alpha> s'))))", "by (auto simp add: sorted_append)"], ["proof (state)\nthis:\n  aluprio_invar \\<alpha> invar s'\n\ngoal (1 subgoal):\n 1. \\<And>s e a s'.\n       \\<lbrakk>aluprio_invar \\<alpha> invar s;\n        aluprio_\\<alpha> \\<alpha> s \\<noteq> Map.empty;\n        aluprio_pop splits annot app s = (e, a, s')\\<rbrakk>\n       \\<Longrightarrow> aluprio_invar \\<alpha> invar s' \\<and>\n                         aluprio_\\<alpha> \\<alpha> s' =\n                         (aluprio_\\<alpha> \\<alpha> s)(e := None) \\<and>\n                         aluprio_\\<alpha> \\<alpha> s e = Some a \\<and>\n                         (\\<forall>y\\<in>ran (aluprio_\\<alpha> \\<alpha> s).\n                             a \\<le> y)", "show \"aluprio_invar \\<alpha> invar s' \\<and>\n          aluprio_\\<alpha> \\<alpha> s' = (aluprio_\\<alpha> \\<alpha> s)(e := None) \\<and>\n          aluprio_\\<alpha> \\<alpha> s e = Some a \\<and> (\\<forall>y\\<in>ran (aluprio_\\<alpha> \\<alpha> s). a \\<le> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. aluprio_invar \\<alpha> invar s' \\<and>\n    aluprio_\\<alpha> \\<alpha> s' = (aluprio_\\<alpha> \\<alpha> s)\n    (e := None) \\<and>\n    aluprio_\\<alpha> \\<alpha> s e = Some a \\<and>\n    (\\<forall>y\\<in>ran (aluprio_\\<alpha> \\<alpha> s). a \\<le> y)", "using ziel1 ziel2 ziel3 ziel4"], ["proof (prove)\nusing this:\n  \\<forall>y\\<in>ran (aluprio_\\<alpha> \\<alpha> s). a \\<le> y\n  aluprio_\\<alpha> \\<alpha> s e = Some a\n  aluprio_\\<alpha> \\<alpha> s' = (aluprio_\\<alpha> \\<alpha> s)(e := None)\n  aluprio_invar \\<alpha> invar s'\n\ngoal (1 subgoal):\n 1. aluprio_invar \\<alpha> invar s' \\<and>\n    aluprio_\\<alpha> \\<alpha> s' = (aluprio_\\<alpha> \\<alpha> s)\n    (e := None) \\<and>\n    aluprio_\\<alpha> \\<alpha> s e = Some a \\<and>\n    (\\<forall>y\\<in>ran (aluprio_\\<alpha> \\<alpha> s). a \\<le> y)", "by simp"], ["proof (state)\nthis:\n  aluprio_invar \\<alpha> invar s' \\<and>\n  aluprio_\\<alpha> \\<alpha> s' = (aluprio_\\<alpha> \\<alpha> s)\n  (e := None) \\<and>\n  aluprio_\\<alpha> \\<alpha> s e = Some a \\<and>\n  (\\<forall>y\\<in>ran (aluprio_\\<alpha> \\<alpha> s). a \\<le> y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  uprio_pop (aluprio_\\<alpha> \\<alpha>) (aluprio_invar \\<alpha> invar)\n   (aluprio_pop splits annot app)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas aluprio_correct =\n  aluprio_finite_correct\n  aluprio_empty_correct\n  aluprio_isEmpty_correct\n  aluprio_insert_correct\n  aluprio_pop_correct\n  aluprio_prio_correct"], ["", "locale aluprio_defs = StdALDefs ops \n  for ops :: \"(unit,('e::linorder,'a::linorder) LP,'s) alist_ops\"\nbegin"], ["", "definition [icf_rec_def]: \"aluprio_ops \\<equiv> \\<lparr>\n    upr_\\<alpha> = aluprio_\\<alpha> \\<alpha>,\n    upr_invar = aluprio_invar \\<alpha> invar,\n    upr_empty = aluprio_empty empty,\n    upr_isEmpty = aluprio_isEmpty isEmpty,\n    upr_insert = aluprio_insert splits annot isEmpty app consr,\n    upr_pop = aluprio_pop splits annot app,\n    upr_prio = aluprio_prio splits annot isEmpty\n    \\<rparr>\""], ["", "end"], ["", "locale aluprio = aluprio_defs ops + StdAL ops \n  for ops :: \"(unit,('e::linorder,'a::linorder) LP,'s) alist_ops\"\nbegin"], ["", "lemma aluprio_ops_impl: \"StdUprio aluprio_ops\""], ["proof (prove)\ngoal (1 subgoal):\n 1. StdUprio aluprio_ops", "apply (rule StdUprio.intro)"], ["proof (prove)\ngoal (6 subgoals):\n 1. uprio_finite (upr_\\<alpha> aluprio_ops) (upr_invar aluprio_ops)\n 2. uprio_empty (upr_\\<alpha> aluprio_ops) (upr_invar aluprio_ops)\n     (upr_empty aluprio_ops)\n 3. uprio_isEmpty (upr_\\<alpha> aluprio_ops) (upr_invar aluprio_ops)\n     (upr_isEmpty aluprio_ops)\n 4. uprio_insert (upr_\\<alpha> aluprio_ops) (upr_invar aluprio_ops)\n     (upr_insert aluprio_ops)\n 5. uprio_pop (upr_\\<alpha> aluprio_ops) (upr_invar aluprio_ops)\n     (upr_pop aluprio_ops)\n 6. uprio_prio (upr_\\<alpha> aluprio_ops) (upr_invar aluprio_ops)\n     (upr_prio aluprio_ops)", "apply (simp_all add: icf_rec_unf)"], ["proof (prove)\ngoal (6 subgoals):\n 1. uprio_finite (aluprio_\\<alpha> \\<alpha>) (aluprio_invar \\<alpha> invar)\n 2. uprio_empty (aluprio_\\<alpha> \\<alpha>) (aluprio_invar \\<alpha> invar)\n     (aluprio_empty local.empty)\n 3. uprio_isEmpty (aluprio_\\<alpha> \\<alpha>) (aluprio_invar \\<alpha> invar)\n     (aluprio_isEmpty isEmpty)\n 4. uprio_insert (aluprio_\\<alpha> \\<alpha>) (aluprio_invar \\<alpha> invar)\n     (aluprio_insert splits annot isEmpty app consr)\n 5. uprio_pop (aluprio_\\<alpha> \\<alpha>) (aluprio_invar \\<alpha> invar)\n     (aluprio_pop splits annot app)\n 6. uprio_prio (aluprio_\\<alpha> \\<alpha>) (aluprio_invar \\<alpha> invar)\n     (aluprio_prio splits annot isEmpty)", "apply (rule aluprio_correct)"], ["proof (prove)\ngoal (5 subgoals):\n 1. uprio_empty (aluprio_\\<alpha> \\<alpha>) (aluprio_invar \\<alpha> invar)\n     (aluprio_empty local.empty)\n 2. uprio_isEmpty (aluprio_\\<alpha> \\<alpha>) (aluprio_invar \\<alpha> invar)\n     (aluprio_isEmpty isEmpty)\n 3. uprio_insert (aluprio_\\<alpha> \\<alpha>) (aluprio_invar \\<alpha> invar)\n     (aluprio_insert splits annot isEmpty app consr)\n 4. uprio_pop (aluprio_\\<alpha> \\<alpha>) (aluprio_invar \\<alpha> invar)\n     (aluprio_pop splits annot app)\n 5. uprio_prio (aluprio_\\<alpha> \\<alpha>) (aluprio_invar \\<alpha> invar)\n     (aluprio_prio splits annot isEmpty)", "apply (rule aluprio_correct, unfold_locales) []"], ["proof (prove)\ngoal (4 subgoals):\n 1. uprio_isEmpty (aluprio_\\<alpha> \\<alpha>) (aluprio_invar \\<alpha> invar)\n     (aluprio_isEmpty isEmpty)\n 2. uprio_insert (aluprio_\\<alpha> \\<alpha>) (aluprio_invar \\<alpha> invar)\n     (aluprio_insert splits annot isEmpty app consr)\n 3. uprio_pop (aluprio_\\<alpha> \\<alpha>) (aluprio_invar \\<alpha> invar)\n     (aluprio_pop splits annot app)\n 4. uprio_prio (aluprio_\\<alpha> \\<alpha>) (aluprio_invar \\<alpha> invar)\n     (aluprio_prio splits annot isEmpty)", "apply (rule aluprio_correct, unfold_locales) []"], ["proof (prove)\ngoal (3 subgoals):\n 1. uprio_insert (aluprio_\\<alpha> \\<alpha>) (aluprio_invar \\<alpha> invar)\n     (aluprio_insert splits annot isEmpty app consr)\n 2. uprio_pop (aluprio_\\<alpha> \\<alpha>) (aluprio_invar \\<alpha> invar)\n     (aluprio_pop splits annot app)\n 3. uprio_prio (aluprio_\\<alpha> \\<alpha>) (aluprio_invar \\<alpha> invar)\n     (aluprio_prio splits annot isEmpty)", "apply (rule aluprio_correct, unfold_locales) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. uprio_pop (aluprio_\\<alpha> \\<alpha>) (aluprio_invar \\<alpha> invar)\n     (aluprio_pop splits annot app)\n 2. uprio_prio (aluprio_\\<alpha> \\<alpha>) (aluprio_invar \\<alpha> invar)\n     (aluprio_prio splits annot isEmpty)", "apply (rule aluprio_correct, unfold_locales) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. uprio_prio (aluprio_\\<alpha> \\<alpha>) (aluprio_invar \\<alpha> invar)\n     (aluprio_prio splits annot isEmpty)", "apply (rule aluprio_correct, unfold_locales) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "end"]]}