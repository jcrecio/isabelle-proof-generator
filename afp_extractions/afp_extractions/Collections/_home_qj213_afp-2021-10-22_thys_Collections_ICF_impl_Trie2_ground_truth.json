{"file_name": "/home/qj213/afp-2021-10-22/thys/Collections/ICF/impl/Trie2.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Collections", "problem_names": ["lemma rev_rev_image: \"rev ` rev ` A = A\"", "lemma invar_trie_impl_of [simp, intro]: \"invar_trie (impl_of t)\"", "lemma Trie_impl_of [code abstype]: \"Trie (impl_of t) = t\"", "lemma iteratei_code[code] :\n  \"iteratei t c f = Trie_Impl.iteratei (impl_of t) c (\\<lambda>(ks, v). f (rev ks, v))\"", "lemma impl_of_empty [code abstract]: \"impl_of empty = empty_trie\"", "lemma impl_of_update [code abstract]: \"impl_of (update ks v t) = update_trie ks v (impl_of t)\"", "lemma impl_of_delete [code abstract]: \"impl_of (delete ks t) = delete_trie ks (impl_of t)\"", "lemma lookup_empty [simp]: \"lookup empty = Map.empty\"", "lemma lookup_update [simp]: \"lookup (update ks v t) = (lookup t)(ks \\<mapsto> v)\"", "lemma lookup_delete [simp]: \"lookup (delete ks t) = (lookup t)(ks := None)\"", "lemma isEmpty_lookup: \"isEmpty t \\<longleftrightarrow> lookup t = Map.empty\"", "lemma finite_dom_lookup: \"finite (dom (lookup t))\"", "lemma iteratei_correct:\n  \"map_iterator (iteratei m) (lookup m)\""], "translations": [["", "lemma rev_rev_image: \"rev ` rev ` A = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev ` rev ` A = A", "by(auto intro: rev_image_eqI[where x=\"rev y\" for y])"], ["", "(*>*)"], ["", "subsection \\<open>Abstract type definition\\<close>"], ["", "typedef ('key, 'val) trie = \n  \"{t :: ('key, 'val) Trie.trie. invar_trie t}\"\n  morphisms impl_of Trie"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {t. invar_trie t}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. ?x \\<in> {t. invar_trie t}", "show \"empty_trie \\<in> ?trie\""], ["proof (prove)\ngoal (1 subgoal):\n 1. empty_trie \\<in> {t. invar_trie t}", "by(simp)"], ["proof (state)\nthis:\n  empty_trie \\<in> {t. invar_trie t}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma invar_trie_impl_of [simp, intro]: \"invar_trie (impl_of t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invar_trie (impl_of t)", "using impl_of[of t]"], ["proof (prove)\nusing this:\n  impl_of t \\<in> {t. invar_trie t}\n\ngoal (1 subgoal):\n 1. invar_trie (impl_of t)", "by simp"], ["", "lemma Trie_impl_of [code abstype]: \"Trie (impl_of t) = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Trie2.trie.Trie (impl_of t) = t", "by(rule impl_of_inverse)"], ["", "subsection \\<open>Primitive operations\\<close>"], ["", "definition empty :: \"('key, 'val) trie\"\nwhere \"empty = Trie (empty_trie)\""], ["", "definition update :: \"'key list \\<Rightarrow> 'val \\<Rightarrow> ('key, 'val) trie \\<Rightarrow> ('key, 'val) trie\"\nwhere \"update ks v t = Trie (update_trie ks v (impl_of t))\""], ["", "definition delete :: \"'key list \\<Rightarrow> ('key, 'val) trie \\<Rightarrow> ('key, 'val) trie\"\nwhere \"delete ks t = Trie (delete_trie ks (impl_of t))\""], ["", "definition lookup :: \"('key, 'val) trie \\<Rightarrow> 'key list \\<Rightarrow> 'val option\"\nwhere \"lookup t = lookup_trie (impl_of t)\""], ["", "definition isEmpty :: \"('key, 'val) trie \\<Rightarrow> bool\"\nwhere \"isEmpty t = is_empty_trie (impl_of t)\""], ["", "definition iteratei :: \"('key, 'val) trie \\<Rightarrow> ('key list \\<times> 'val, '\\<sigma>) set_iterator\"\nwhere \"iteratei t = set_iterator_image trie_reverse_key (Trie_Impl.iteratei (impl_of t))\""], ["", "lemma iteratei_code[code] :\n  \"iteratei t c f = Trie_Impl.iteratei (impl_of t) c (\\<lambda>(ks, v). f (rev ks, v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iteratei t c f =\n    Trie_Impl.iteratei (impl_of t) c (\\<lambda>(ks, v). f (rev ks, v))", "unfolding iteratei_def set_iterator_image_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Trie_Impl.iteratei (impl_of t) c (\\<lambda>x. f (trie_reverse_key x)) =\n    Trie_Impl.iteratei (impl_of t) c (\\<lambda>(ks, v). f (rev ks, v))", "apply (subgoal_tac \"(\\<lambda>x. f (trie_reverse_key x)) = (\\<lambda>(ks, v). f (rev ks, v))\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<lambda>x. f (trie_reverse_key x)) =\n    (\\<lambda>(ks, v). f (rev ks, v)) \\<Longrightarrow>\n    Trie_Impl.iteratei (impl_of t) c (\\<lambda>x. f (trie_reverse_key x)) =\n    Trie_Impl.iteratei (impl_of t) c (\\<lambda>(ks, v). f (rev ks, v))\n 2. (\\<lambda>x. f (trie_reverse_key x)) = (\\<lambda>(ks, v). f (rev ks, v))", "apply (auto simp add: trie_reverse_key_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma impl_of_empty [code abstract]: \"impl_of empty = empty_trie\""], ["proof (prove)\ngoal (1 subgoal):\n 1. impl_of Trie2.empty = empty_trie", "by(simp add: empty_def Trie_inverse)"], ["", "lemma impl_of_update [code abstract]: \"impl_of (update ks v t) = update_trie ks v (impl_of t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. impl_of (update ks v t) = update_trie ks v (impl_of t)", "by(simp add: update_def Trie_inverse invar_trie_update)"], ["", "lemma impl_of_delete [code abstract]: \"impl_of (delete ks t) = delete_trie ks (impl_of t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. impl_of (delete ks t) = delete_trie ks (impl_of t)", "by(simp add: delete_def Trie_inverse invar_trie_delete)"], ["", "subsection \\<open>Correctness of primitive operations\\<close>"], ["", "lemma lookup_empty [simp]: \"lookup empty = Map.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup Trie2.empty = Map.empty", "by(simp add: lookup_def empty_def Trie_inverse)"], ["", "lemma lookup_update [simp]: \"lookup (update ks v t) = (lookup t)(ks \\<mapsto> v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (update ks v t) = lookup t(ks \\<mapsto> v)", "by(simp add: lookup_def update_def Trie_inverse invar_trie_update lookup_update')"], ["", "lemma lookup_delete [simp]: \"lookup (delete ks t) = (lookup t)(ks := None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (delete ks t) = (lookup t)(ks := None)", "by(simp add: lookup_def delete_def Trie_inverse invar_trie_delete lookup_delete')"], ["", "lemma isEmpty_lookup: \"isEmpty t \\<longleftrightarrow> lookup t = Map.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isEmpty t = (lookup t = Map.empty)", "by(simp add: isEmpty_def lookup_def is_empty_lookup_empty)"], ["", "lemma finite_dom_lookup: \"finite (dom (lookup t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (dom (lookup t))", "by(simp add: lookup_def finite_dom_lookup)"], ["", "lemma iteratei_correct:\n  \"map_iterator (iteratei m) (lookup m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_iterator (iteratei m) (lookup m)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map_iterator (iteratei m) (lookup m)", "note it_base = Trie_Impl.trie_iteratei_correct [of \"impl_of m\"]"], ["proof (state)\nthis:\n  invar_trie (impl_of m) \\<Longrightarrow>\n  set_iterator (Trie_Impl.iteratei (impl_of m))\n   (trie_reverse_key ` map_to_set (lookup_trie (impl_of m)))\n\ngoal (1 subgoal):\n 1. map_iterator (iteratei m) (lookup m)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_iterator (iteratei m) (lookup m)", "unfolding iteratei_def lookup_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_iterator\n     (set_iterator_image trie_reverse_key (Trie_Impl.iteratei (impl_of m)))\n     (lookup_trie (impl_of m))", "apply (rule set_iterator_image_correct [OF it_base])"], ["proof (prove)\ngoal (3 subgoals):\n 1. invar_trie (impl_of m)\n 2. inj_on trie_reverse_key\n     (trie_reverse_key ` map_to_set (lookup_trie (impl_of m)))\n 3. map_to_set (lookup_trie (impl_of m)) =\n    trie_reverse_key `\n    trie_reverse_key ` map_to_set (lookup_trie (impl_of m))", "apply (simp_all add: set_eq_iff image_iff inj_on_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  map_iterator (iteratei m) (lookup m)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Type classes\\<close>"], ["", "instantiation trie :: (equal, equal) equal begin"], ["", "definition \"equal_class.equal (t :: ('a, 'b) trie) t' = (impl_of t = impl_of t')\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) trie, equal_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. equal_class.equal x y = (x = y)", "qed(simp add: equal_trie_def impl_of_inject)"], ["", "end"], ["", "hide_const (open) empty lookup update delete iteratei isEmpty"], ["", "end"]]}