{"file_name": "/home/qj213/afp-2021-10-22/thys/Collections/ICF/impl/ArrayHashMap_Impl.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Collections", "problem_names": ["lemma hm_grow_gt_1 [iff]:\n  \"Suc 0 < hm_grow hm\"", "lemma bucket_ok_Nil [simp]: \"bucket_ok len h [] = True\"", "lemma bucket_okD:\n  \"\\<lbrakk> bucket_ok len h xs; (k, v) \\<in> set xs \\<rbrakk>\n  \\<Longrightarrow> bounded_hashcode_nat len k = h\"", "lemma bucket_okI:\n  \"(\\<And>k. k \\<in> fst ` set kvs \\<Longrightarrow> bounded_hashcode_nat len k = h) \\<Longrightarrow> bucket_ok len h kvs\"", "lemma ahm_invar_auxE:\n  assumes \"ahm_invar_aux n a\"\n  obtains \"\\<forall>h. h < array_length a \\<longrightarrow> bucket_ok (array_length a) h (array_get a h) \\<and> distinct (map fst (array_get a h))\"\n  and \"n = array_foldl (\\<lambda>_ n kvs. n + length kvs) 0 a\" and \"array_length a > 1\"", "lemma ahm_invar_auxI:\n  \"\\<lbrakk> \\<And>h. h < array_length a \\<Longrightarrow> bucket_ok (array_length a) h (array_get a h);\n     \\<And>h. h < array_length a \\<Longrightarrow> distinct (map fst (array_get a h));\n     n = array_foldl (\\<lambda>_ n kvs. n + length kvs) 0 a; array_length a > 1 \\<rbrakk>\n  \\<Longrightarrow> ahm_invar_aux n a\"", "lemma ahm_invar_distinct_fst_concatD:\n  assumes inv: \"ahm_invar_aux n (Array xs)\"\n  shows \"distinct (map fst (concat xs))\"", "lemma finite_dom_ahm_\\<alpha>_aux:\n  assumes \"ahm_invar_aux n a\"\n  shows \"finite (dom (ahm_\\<alpha>_aux a))\"", "lemma ahm_\\<alpha>_aux_conv_map_of_concat:\n  assumes inv: \"ahm_invar_aux n (Array xs)\"\n  shows \"ahm_\\<alpha>_aux (Array xs) = map_of (concat xs)\"", "lemma ahm_invar_aux_card_dom_ahm_\\<alpha>_auxD:\n  assumes inv: \"ahm_invar_aux n a\"\n  shows \"card (dom (ahm_\\<alpha>_aux a)) = n\"", "lemma finite_dom_ahm_\\<alpha>:\n  \"ahm_invar hm \\<Longrightarrow> finite (dom (ahm_\\<alpha> hm))\"", "lemma finite_map_ahm_\\<alpha>_aux:\n  \"finite_map ahm_\\<alpha>_aux (ahm_invar_aux n)\"", "lemma finite_map_ahm_\\<alpha>:\n  \"finite_map ahm_\\<alpha> ahm_invar\"", "lemma ahm_invar_aux_new_array:\n  assumes \"n > 1\"\n  shows \"ahm_invar_aux 0 (new_array [] n)\"", "lemma ahm_invar_new_hashmap_with:\n  \"n > 1 \\<Longrightarrow> ahm_invar (new_hashmap_with n)\"", "lemma ahm_\\<alpha>_new_hashmap_with:\n  \"n > 1 \\<Longrightarrow> ahm_\\<alpha> (new_hashmap_with n) = Map.empty\"", "lemma ahm_invar_ahm_empty [simp]: \"ahm_invar (ahm_empty ())\"", "lemma ahm_empty_correct [simp]: \"ahm_\\<alpha> (ahm_empty ()) = Map.empty\"", "lemma ahm_empty_impl: \"map_empty ahm_\\<alpha> ahm_invar ahm_empty\"", "lemma ahm_lookup_impl: \"map_lookup ahm_\\<alpha> ahm_invar ahm_lookup\"", "lemma ahm_iteratei_aux_impl:\n  assumes invar_m: \"ahm_invar_aux n m\"\n  shows \"map_iterator (ahm_iteratei_aux m) (ahm_\\<alpha>_aux m)\"", "lemma ahm_iteratei_correct:\n  assumes invar_hm: \"ahm_invar hm\"\n  shows \"map_iterator (ahm_iteratei hm) (ahm_\\<alpha> hm)\"", "lemma ahm_iteratei_aux_code [code]:\n  \"ahm_iteratei_aux a c f \\<sigma> = a_idx_it.idx_iteratei a c (\\<lambda>x. foldli x c f) \\<sigma>\"", "lemma array_length_ahm_rehash_aux':\n  \"array_length (ahm_rehash_aux' n kv a) = array_length a\"", "lemma ahm_rehash_aux'_preserves_ahm_invar_aux:\n  assumes inv: \"ahm_invar_aux n a\"\n  and fresh: \"k \\<notin> fst ` set (array_get a (bounded_hashcode_nat (array_length a) k))\"\n  shows \"ahm_invar_aux (Suc n) (ahm_rehash_aux' (array_length a) (k, v) a)\"\n  (is \"ahm_invar_aux _ ?a\")", "lemma ahm_rehash_aux_correct:\n  fixes a :: \"(('key :: hashable) \\<times> 'val) list array\"\n  assumes inv: \"ahm_invar_aux n a\"\n  and \"sz > 1\"\n  shows \"ahm_invar_aux n (ahm_rehash_aux a sz)\" (is \"?thesis1\")\n  and \"ahm_\\<alpha>_aux (ahm_rehash_aux a sz) = ahm_\\<alpha>_aux a\" (is \"?thesis2\")", "lemma ahm_rehash_correct:\n  fixes hm :: \"('key :: hashable, 'val) hashmap\"\n  assumes inv: \"ahm_invar hm\"\n  and \"sz > 1\"\n  shows \"ahm_invar (ahm_rehash hm sz)\" \"ahm_\\<alpha> (ahm_rehash hm sz) = ahm_\\<alpha> hm\"", "lemma ahm_update_aux_correct:\n  assumes inv: \"ahm_invar hm\"\n  shows \"ahm_invar (ahm_update_aux hm k v)\" (is ?thesis1)\n  and \"ahm_\\<alpha> (ahm_update_aux hm k v) = (ahm_\\<alpha> hm)(k \\<mapsto> v)\" (is ?thesis2)", "lemma ahm_update_correct:\n  assumes inv: \"ahm_invar hm\"\n  shows \"ahm_invar (ahm_update k v hm)\"\n  and \"ahm_\\<alpha> (ahm_update k v hm) = (ahm_\\<alpha> hm)(k \\<mapsto> v)\"", "lemma ahm_update_impl:\n  \"map_update ahm_\\<alpha> ahm_invar ahm_update\"", "lemma ahm_delete_correct:\n  assumes inv: \"ahm_invar hm\"\n  shows \"ahm_invar (ahm_delete k hm)\" (is \"?thesis1\")\n  and \"ahm_\\<alpha> (ahm_delete k hm) = (ahm_\\<alpha> hm) |` (- {k})\" (is \"?thesis2\")", "lemma ahm_delete_impl:\n  \"map_delete ahm_\\<alpha> ahm_invar ahm_delete\""], "translations": [["", "lemma hm_grow_gt_1 [iff]:\n  \"Suc 0 < hm_grow hm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc 0 < hm_grow hm", "by(cases hm)(simp)"], ["", "lemma bucket_ok_Nil [simp]: \"bucket_ok len h [] = True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bucket_ok len h [] = True", "by(simp add: bucket_ok_def)"], ["", "lemma bucket_okD:\n  \"\\<lbrakk> bucket_ok len h xs; (k, v) \\<in> set xs \\<rbrakk>\n  \\<Longrightarrow> bounded_hashcode_nat len k = h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bucket_ok len h xs; (k, v) \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> bounded_hashcode_nat len k = h", "by(auto simp add: bucket_ok_def)"], ["", "lemma bucket_okI:\n  \"(\\<And>k. k \\<in> fst ` set kvs \\<Longrightarrow> bounded_hashcode_nat len k = h) \\<Longrightarrow> bucket_ok len h kvs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k.\n        k \\<in> fst ` set kvs \\<Longrightarrow>\n        bounded_hashcode_nat len k = h) \\<Longrightarrow>\n    bucket_ok len h kvs", "by(simp add: bucket_ok_def)"], ["", "subsection \\<open>@{term ahm_invar}\\<close>"], ["", "lemma ahm_invar_auxE:\n  assumes \"ahm_invar_aux n a\"\n  obtains \"\\<forall>h. h < array_length a \\<longrightarrow> bucket_ok (array_length a) h (array_get a h) \\<and> distinct (map fst (array_get a h))\"\n  and \"n = array_foldl (\\<lambda>_ n kvs. n + length kvs) 0 a\" and \"array_length a > 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>\\<forall>h<array_length a.\n                 bucket_ok (array_length a) h (array_get a h) \\<and>\n                 distinct (map fst (array_get a h));\n      n = array_foldl (\\<lambda>_ n kvs. n + length kvs) 0 a;\n      1 < array_length a\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  ahm_invar_aux n a\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>\\<forall>h<array_length a.\n                 bucket_ok (array_length a) h (array_get a h) \\<and>\n                 distinct (map fst (array_get a h));\n      n = array_foldl (\\<lambda>_ n kvs. n + length kvs) 0 a;\n      1 < array_length a\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding ahm_invar_aux_def"], ["proof (prove)\nusing this:\n  (\\<forall>h<array_length a.\n      bucket_ok (array_length a) h (array_get a h) \\<and>\n      distinct (map fst (array_get a h))) \\<and>\n  array_foldl (\\<lambda>_ n kvs. n + length kvs) 0 a = n \\<and>\n  1 < array_length a\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>\\<forall>h<array_length a.\n                 bucket_ok (array_length a) h (array_get a h) \\<and>\n                 distinct (map fst (array_get a h));\n      n = array_foldl (\\<lambda>_ n kvs. n + length kvs) 0 a;\n      1 < array_length a\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["", "lemma ahm_invar_auxI:\n  \"\\<lbrakk> \\<And>h. h < array_length a \\<Longrightarrow> bucket_ok (array_length a) h (array_get a h);\n     \\<And>h. h < array_length a \\<Longrightarrow> distinct (map fst (array_get a h));\n     n = array_foldl (\\<lambda>_ n kvs. n + length kvs) 0 a; array_length a > 1 \\<rbrakk>\n  \\<Longrightarrow> ahm_invar_aux n a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>h.\n                h < array_length a \\<Longrightarrow>\n                bucket_ok (array_length a) h (array_get a h);\n     \\<And>h.\n        h < array_length a \\<Longrightarrow>\n        distinct (map fst (array_get a h));\n     n = array_foldl (\\<lambda>_ n kvs. n + length kvs) 0 a;\n     1 < array_length a\\<rbrakk>\n    \\<Longrightarrow> ahm_invar_aux n a", "unfolding ahm_invar_aux_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>h.\n                h < array_length a \\<Longrightarrow>\n                bucket_ok (array_length a) h (array_get a h);\n     \\<And>h.\n        h < array_length a \\<Longrightarrow>\n        distinct (map fst (array_get a h));\n     n = array_foldl (\\<lambda>_ n kvs. n + length kvs) 0 a;\n     1 < array_length a\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>h<array_length a.\n                          bucket_ok (array_length a) h\n                           (array_get a h) \\<and>\n                          distinct (map fst (array_get a h))) \\<and>\n                      array_foldl (\\<lambda>_ n kvs. n + length kvs) 0 a =\n                      n \\<and>\n                      1 < array_length a", "by blast"], ["", "lemma ahm_invar_distinct_fst_concatD:\n  assumes inv: \"ahm_invar_aux n (Array xs)\"\n  shows \"distinct (map fst (concat xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst (concat xs))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. distinct (map fst (concat xs))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. distinct (map fst (concat xs))", "fix h"], ["proof (state)\ngoal (1 subgoal):\n 1. distinct (map fst (concat xs))", "assume \"h < length xs\""], ["proof (state)\nthis:\n  h < length xs\n\ngoal (1 subgoal):\n 1. distinct (map fst (concat xs))", "with inv"], ["proof (chain)\npicking this:\n  ahm_invar_aux n (Array xs)\n  h < length xs", "have \"bucket_ok (length xs) h (xs ! h)\" \"distinct (map fst (xs ! h))\""], ["proof (prove)\nusing this:\n  ahm_invar_aux n (Array xs)\n  h < length xs\n\ngoal (1 subgoal):\n 1. bucket_ok (length xs) h (xs ! h) &&& distinct (map fst (xs ! h))", "by(simp_all add: ahm_invar_aux_def)"], ["proof (state)\nthis:\n  bucket_ok (length xs) h (xs ! h)\n  distinct (map fst (xs ! h))\n\ngoal (1 subgoal):\n 1. distinct (map fst (concat xs))", "}"], ["proof (state)\nthis:\n  ?h2 < length xs \\<Longrightarrow> bucket_ok (length xs) ?h2 (xs ! ?h2)\n  ?h2 < length xs \\<Longrightarrow> distinct (map fst (xs ! ?h2))\n\ngoal (1 subgoal):\n 1. distinct (map fst (concat xs))", "note no_junk = this"], ["proof (state)\nthis:\n  ?h2 < length xs \\<Longrightarrow> bucket_ok (length xs) ?h2 (xs ! ?h2)\n  ?h2 < length xs \\<Longrightarrow> distinct (map fst (xs ! ?h2))\n\ngoal (1 subgoal):\n 1. distinct (map fst (concat xs))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst (concat xs))", "unfolding map_concat"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (concat (map (map fst) xs))", "proof(rule distinct_concat')"], ["proof (state)\ngoal (3 subgoals):\n 1. distinct (filter (\\<lambda>ys. ys \\<noteq> []) (map (map fst) xs))\n 2. \\<And>ys. ys \\<in> set (map (map fst) xs) \\<Longrightarrow> distinct ys\n 3. \\<And>ys zs.\n       \\<lbrakk>ys \\<in> set (map (map fst) xs);\n        zs \\<in> set (map (map fst) xs); ys \\<noteq> zs\\<rbrakk>\n       \\<Longrightarrow> set ys \\<inter> set zs = {}", "have \"distinct [x\\<leftarrow>xs . x \\<noteq> []]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (filter (\\<lambda>x. x \\<noteq> []) xs)", "unfolding distinct_conv_nth"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length (filter (\\<lambda>x. x \\<noteq> []) xs).\n       \\<forall>j<length (filter (\\<lambda>x. x \\<noteq> []) xs).\n          i \\<noteq> j \\<longrightarrow>\n          filter (\\<lambda>x. x \\<noteq> []) xs ! i \\<noteq>\n          filter (\\<lambda>x. x \\<noteq> []) xs ! j", "proof(intro allI ballI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length (filter (\\<lambda>x. x \\<noteq> []) xs);\n        j < length (filter (\\<lambda>x. x \\<noteq> []) xs);\n        i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> filter (\\<lambda>x. x \\<noteq> []) xs ! i \\<noteq>\n                         filter (\\<lambda>x. x \\<noteq> []) xs ! j", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length (filter (\\<lambda>x. x \\<noteq> []) xs);\n        j < length (filter (\\<lambda>x. x \\<noteq> []) xs);\n        i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> filter (\\<lambda>x. x \\<noteq> []) xs ! i \\<noteq>\n                         filter (\\<lambda>x. x \\<noteq> []) xs ! j", "assume \"i < length [x\\<leftarrow>xs . x \\<noteq> []]\" \"j < length [x\\<leftarrow>xs . x \\<noteq> []]\" \"i \\<noteq> j\""], ["proof (state)\nthis:\n  i < length (filter (\\<lambda>x. x \\<noteq> []) xs)\n  j < length (filter (\\<lambda>x. x \\<noteq> []) xs)\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length (filter (\\<lambda>x. x \\<noteq> []) xs);\n        j < length (filter (\\<lambda>x. x \\<noteq> []) xs);\n        i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> filter (\\<lambda>x. x \\<noteq> []) xs ! i \\<noteq>\n                         filter (\\<lambda>x. x \\<noteq> []) xs ! j", "from filter_nth_ex_nth[OF \\<open>i < length [x\\<leftarrow>xs . x \\<noteq> []]\\<close>]"], ["proof (chain)\npicking this:\n  \\<exists>m\\<ge>i.\n     m < length xs \\<and>\n     filter (\\<lambda>x. x \\<noteq> []) xs ! i = xs ! m \\<and>\n     filter (\\<lambda>x. x \\<noteq> []) (take m xs) =\n     take i (filter (\\<lambda>x. x \\<noteq> []) xs)", "obtain i' where \"i' \\<ge> i\" \"i' < length xs\" and ith: \"[x\\<leftarrow>xs . x \\<noteq> []] ! i = xs ! i'\" \n        and eqi: \"[x\\<leftarrow>take i' xs . x \\<noteq> []] = take i [x\\<leftarrow>xs . x \\<noteq> []]\""], ["proof (prove)\nusing this:\n  \\<exists>m\\<ge>i.\n     m < length xs \\<and>\n     filter (\\<lambda>x. x \\<noteq> []) xs ! i = xs ! m \\<and>\n     filter (\\<lambda>x. x \\<noteq> []) (take m xs) =\n     take i (filter (\\<lambda>x. x \\<noteq> []) xs)\n\ngoal (1 subgoal):\n 1. (\\<And>i'.\n        \\<lbrakk>i \\<le> i'; i' < length xs;\n         filter (\\<lambda>x. x \\<noteq> []) xs ! i = xs ! i';\n         filter (\\<lambda>x. x \\<noteq> []) (take i' xs) =\n         take i (filter (\\<lambda>x. x \\<noteq> []) xs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  i \\<le> i'\n  i' < length xs\n  filter (\\<lambda>x. x \\<noteq> []) xs ! i = xs ! i'\n  filter (\\<lambda>x. x \\<noteq> []) (take i' xs) =\n  take i (filter (\\<lambda>x. x \\<noteq> []) xs)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length (filter (\\<lambda>x. x \\<noteq> []) xs);\n        j < length (filter (\\<lambda>x. x \\<noteq> []) xs);\n        i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> filter (\\<lambda>x. x \\<noteq> []) xs ! i \\<noteq>\n                         filter (\\<lambda>x. x \\<noteq> []) xs ! j", "from filter_nth_ex_nth[OF \\<open>j < length [x\\<leftarrow>xs . x \\<noteq> []]\\<close>]"], ["proof (chain)\npicking this:\n  \\<exists>m\\<ge>j.\n     m < length xs \\<and>\n     filter (\\<lambda>x. x \\<noteq> []) xs ! j = xs ! m \\<and>\n     filter (\\<lambda>x. x \\<noteq> []) (take m xs) =\n     take j (filter (\\<lambda>x. x \\<noteq> []) xs)", "obtain j' where \"j' \\<ge> j\" \"j' < length xs\" and jth: \"[x\\<leftarrow>xs . x \\<noteq> []] ! j = xs ! j'\"\n        and eqj: \"[x\\<leftarrow>take j' xs . x \\<noteq> []] = take j [x\\<leftarrow>xs . x \\<noteq> []]\""], ["proof (prove)\nusing this:\n  \\<exists>m\\<ge>j.\n     m < length xs \\<and>\n     filter (\\<lambda>x. x \\<noteq> []) xs ! j = xs ! m \\<and>\n     filter (\\<lambda>x. x \\<noteq> []) (take m xs) =\n     take j (filter (\\<lambda>x. x \\<noteq> []) xs)\n\ngoal (1 subgoal):\n 1. (\\<And>j'.\n        \\<lbrakk>j \\<le> j'; j' < length xs;\n         filter (\\<lambda>x. x \\<noteq> []) xs ! j = xs ! j';\n         filter (\\<lambda>x. x \\<noteq> []) (take j' xs) =\n         take j (filter (\\<lambda>x. x \\<noteq> []) xs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  j \\<le> j'\n  j' < length xs\n  filter (\\<lambda>x. x \\<noteq> []) xs ! j = xs ! j'\n  filter (\\<lambda>x. x \\<noteq> []) (take j' xs) =\n  take j (filter (\\<lambda>x. x \\<noteq> []) xs)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i < length (filter (\\<lambda>x. x \\<noteq> []) xs);\n        j < length (filter (\\<lambda>x. x \\<noteq> []) xs);\n        i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> filter (\\<lambda>x. x \\<noteq> []) xs ! i \\<noteq>\n                         filter (\\<lambda>x. x \\<noteq> []) xs ! j", "show \"[x\\<leftarrow>xs . x \\<noteq> []] ! i \\<noteq> [x\\<leftarrow>xs . x \\<noteq> []] ! j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. x \\<noteq> []) xs ! i \\<noteq>\n    filter (\\<lambda>x. x \\<noteq> []) xs ! j", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. x \\<noteq> []) xs ! i =\n    filter (\\<lambda>x. x \\<noteq> []) xs ! j \\<Longrightarrow>\n    False", "assume \"[x\\<leftarrow>xs . x \\<noteq> []] ! i = [x\\<leftarrow>xs . x \\<noteq> []] ! j\""], ["proof (state)\nthis:\n  filter (\\<lambda>x. x \\<noteq> []) xs ! i =\n  filter (\\<lambda>x. x \\<noteq> []) xs ! j\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. x \\<noteq> []) xs ! i =\n    filter (\\<lambda>x. x \\<noteq> []) xs ! j \\<Longrightarrow>\n    False", "hence eq: \"xs ! i' = xs ! j'\""], ["proof (prove)\nusing this:\n  filter (\\<lambda>x. x \\<noteq> []) xs ! i =\n  filter (\\<lambda>x. x \\<noteq> []) xs ! j\n\ngoal (1 subgoal):\n 1. xs ! i' = xs ! j'", "using ith jth"], ["proof (prove)\nusing this:\n  filter (\\<lambda>x. x \\<noteq> []) xs ! i =\n  filter (\\<lambda>x. x \\<noteq> []) xs ! j\n  filter (\\<lambda>x. x \\<noteq> []) xs ! i = xs ! i'\n  filter (\\<lambda>x. x \\<noteq> []) xs ! j = xs ! j'\n\ngoal (1 subgoal):\n 1. xs ! i' = xs ! j'", "by simp"], ["proof (state)\nthis:\n  xs ! i' = xs ! j'\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. x \\<noteq> []) xs ! i =\n    filter (\\<lambda>x. x \\<noteq> []) xs ! j \\<Longrightarrow>\n    False", "from \\<open>i < length [x\\<leftarrow>xs . x \\<noteq> []]\\<close>"], ["proof (chain)\npicking this:\n  i < length (filter (\\<lambda>x. x \\<noteq> []) xs)", "have \"[x\\<leftarrow>xs . x \\<noteq> []] ! i \\<in> set [x\\<leftarrow>xs . x \\<noteq> []]\""], ["proof (prove)\nusing this:\n  i < length (filter (\\<lambda>x. x \\<noteq> []) xs)\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. x \\<noteq> []) xs ! i\n    \\<in> set (filter (\\<lambda>x. x \\<noteq> []) xs)", "by(rule nth_mem)"], ["proof (state)\nthis:\n  filter (\\<lambda>x. x \\<noteq> []) xs ! i\n  \\<in> set (filter (\\<lambda>x. x \\<noteq> []) xs)\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. x \\<noteq> []) xs ! i =\n    filter (\\<lambda>x. x \\<noteq> []) xs ! j \\<Longrightarrow>\n    False", "with ith"], ["proof (chain)\npicking this:\n  filter (\\<lambda>x. x \\<noteq> []) xs ! i = xs ! i'\n  filter (\\<lambda>x. x \\<noteq> []) xs ! i\n  \\<in> set (filter (\\<lambda>x. x \\<noteq> []) xs)", "have \"xs ! i' \\<noteq> []\""], ["proof (prove)\nusing this:\n  filter (\\<lambda>x. x \\<noteq> []) xs ! i = xs ! i'\n  filter (\\<lambda>x. x \\<noteq> []) xs ! i\n  \\<in> set (filter (\\<lambda>x. x \\<noteq> []) xs)\n\ngoal (1 subgoal):\n 1. xs ! i' \\<noteq> []", "by simp"], ["proof (state)\nthis:\n  xs ! i' \\<noteq> []\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. x \\<noteq> []) xs ! i =\n    filter (\\<lambda>x. x \\<noteq> []) xs ! j \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  xs ! i' \\<noteq> []", "obtain kv where \"kv \\<in> set (xs ! i')\""], ["proof (prove)\nusing this:\n  xs ! i' \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>kv.\n        kv \\<in> set (xs ! i') \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce simp add: neq_Nil_conv)"], ["proof (state)\nthis:\n  kv \\<in> set (xs ! i')\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. x \\<noteq> []) xs ! i =\n    filter (\\<lambda>x. x \\<noteq> []) xs ! j \\<Longrightarrow>\n    False", "with no_junk[OF \\<open>i' < length xs\\<close>]"], ["proof (chain)\npicking this:\n  bucket_ok (length xs) i' (xs ! i')\n  distinct (map fst (xs ! i'))\n  kv \\<in> set (xs ! i')", "have \"bounded_hashcode_nat (length xs) (fst kv) = i'\""], ["proof (prove)\nusing this:\n  bucket_ok (length xs) i' (xs ! i')\n  distinct (map fst (xs ! i'))\n  kv \\<in> set (xs ! i')\n\ngoal (1 subgoal):\n 1. bounded_hashcode_nat (length xs) (fst kv) = i'", "by(simp add: bucket_ok_def)"], ["proof (state)\nthis:\n  bounded_hashcode_nat (length xs) (fst kv) = i'\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. x \\<noteq> []) xs ! i =\n    filter (\\<lambda>x. x \\<noteq> []) xs ! j \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  bounded_hashcode_nat (length xs) (fst kv) = i'\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. x \\<noteq> []) xs ! i =\n    filter (\\<lambda>x. x \\<noteq> []) xs ! j \\<Longrightarrow>\n    False", "from eq \\<open>kv \\<in> set (xs ! i')\\<close>"], ["proof (chain)\npicking this:\n  xs ! i' = xs ! j'\n  kv \\<in> set (xs ! i')", "have \"kv \\<in> set (xs ! j')\""], ["proof (prove)\nusing this:\n  xs ! i' = xs ! j'\n  kv \\<in> set (xs ! i')\n\ngoal (1 subgoal):\n 1. kv \\<in> set (xs ! j')", "by simp"], ["proof (state)\nthis:\n  kv \\<in> set (xs ! j')\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. x \\<noteq> []) xs ! i =\n    filter (\\<lambda>x. x \\<noteq> []) xs ! j \\<Longrightarrow>\n    False", "with no_junk[OF \\<open>j' < length xs\\<close>]"], ["proof (chain)\npicking this:\n  bucket_ok (length xs) j' (xs ! j')\n  distinct (map fst (xs ! j'))\n  kv \\<in> set (xs ! j')", "have \"bounded_hashcode_nat (length xs) (fst kv) = j'\""], ["proof (prove)\nusing this:\n  bucket_ok (length xs) j' (xs ! j')\n  distinct (map fst (xs ! j'))\n  kv \\<in> set (xs ! j')\n\ngoal (1 subgoal):\n 1. bounded_hashcode_nat (length xs) (fst kv) = j'", "by(simp add: bucket_ok_def)"], ["proof (state)\nthis:\n  bounded_hashcode_nat (length xs) (fst kv) = j'\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. x \\<noteq> []) xs ! i =\n    filter (\\<lambda>x. x \\<noteq> []) xs ! j \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  bounded_hashcode_nat (length xs) (fst kv) = i'\n  bounded_hashcode_nat (length xs) (fst kv) = j'", "have [simp]: \"i' = j'\""], ["proof (prove)\nusing this:\n  bounded_hashcode_nat (length xs) (fst kv) = i'\n  bounded_hashcode_nat (length xs) (fst kv) = j'\n\ngoal (1 subgoal):\n 1. i' = j'", "by simp"], ["proof (state)\nthis:\n  i' = j'\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. x \\<noteq> []) xs ! i =\n    filter (\\<lambda>x. x \\<noteq> []) xs ! j \\<Longrightarrow>\n    False", "from \\<open>i < length [x\\<leftarrow>xs . x \\<noteq> []]\\<close>"], ["proof (chain)\npicking this:\n  i < length (filter (\\<lambda>x. x \\<noteq> []) xs)", "have \"i = length (take i [x\\<leftarrow>xs . x \\<noteq> []])\""], ["proof (prove)\nusing this:\n  i < length (filter (\\<lambda>x. x \\<noteq> []) xs)\n\ngoal (1 subgoal):\n 1. i = length (take i (filter (\\<lambda>x. x \\<noteq> []) xs))", "by simp"], ["proof (state)\nthis:\n  i = length (take i (filter (\\<lambda>x. x \\<noteq> []) xs))\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. x \\<noteq> []) xs ! i =\n    filter (\\<lambda>x. x \\<noteq> []) xs ! j \\<Longrightarrow>\n    False", "also"], ["proof (state)\nthis:\n  i = length (take i (filter (\\<lambda>x. x \\<noteq> []) xs))\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. x \\<noteq> []) xs ! i =\n    filter (\\<lambda>x. x \\<noteq> []) xs ! j \\<Longrightarrow>\n    False", "from eqi eqj"], ["proof (chain)\npicking this:\n  filter (\\<lambda>x. x \\<noteq> []) (take i' xs) =\n  take i (filter (\\<lambda>x. x \\<noteq> []) xs)\n  filter (\\<lambda>x. x \\<noteq> []) (take j' xs) =\n  take j (filter (\\<lambda>x. x \\<noteq> []) xs)", "have \"take i [x\\<leftarrow>xs . x \\<noteq> []] = take j [x\\<leftarrow>xs . x \\<noteq> []]\""], ["proof (prove)\nusing this:\n  filter (\\<lambda>x. x \\<noteq> []) (take i' xs) =\n  take i (filter (\\<lambda>x. x \\<noteq> []) xs)\n  filter (\\<lambda>x. x \\<noteq> []) (take j' xs) =\n  take j (filter (\\<lambda>x. x \\<noteq> []) xs)\n\ngoal (1 subgoal):\n 1. take i (filter (\\<lambda>x. x \\<noteq> []) xs) =\n    take j (filter (\\<lambda>x. x \\<noteq> []) xs)", "by simp"], ["proof (state)\nthis:\n  take i (filter (\\<lambda>x. x \\<noteq> []) xs) =\n  take j (filter (\\<lambda>x. x \\<noteq> []) xs)\n\ngoal (1 subgoal):\n 1. filter (\\<lambda>x. x \\<noteq> []) xs ! i =\n    filter (\\<lambda>x. x \\<noteq> []) xs ! j \\<Longrightarrow>\n    False", "finally"], ["proof (chain)\npicking this:\n  i = length (take j (filter (\\<lambda>x. x \\<noteq> []) xs))", "show False"], ["proof (prove)\nusing this:\n  i = length (take j (filter (\\<lambda>x. x \\<noteq> []) xs))\n\ngoal (1 subgoal):\n 1. False", "using \\<open>i \\<noteq> j\\<close> \\<open>j < length [x\\<leftarrow>xs . x \\<noteq> []]\\<close>"], ["proof (prove)\nusing this:\n  i = length (take j (filter (\\<lambda>x. x \\<noteq> []) xs))\n  i \\<noteq> j\n  j < length (filter (\\<lambda>x. x \\<noteq> []) xs)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  filter (\\<lambda>x. x \\<noteq> []) xs ! i \\<noteq>\n  filter (\\<lambda>x. x \\<noteq> []) xs ! j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  distinct (filter (\\<lambda>x. x \\<noteq> []) xs)\n\ngoal (3 subgoals):\n 1. distinct (filter (\\<lambda>ys. ys \\<noteq> []) (map (map fst) xs))\n 2. \\<And>ys. ys \\<in> set (map (map fst) xs) \\<Longrightarrow> distinct ys\n 3. \\<And>ys zs.\n       \\<lbrakk>ys \\<in> set (map (map fst) xs);\n        zs \\<in> set (map (map fst) xs); ys \\<noteq> zs\\<rbrakk>\n       \\<Longrightarrow> set ys \\<inter> set zs = {}", "moreover"], ["proof (state)\nthis:\n  distinct (filter (\\<lambda>x. x \\<noteq> []) xs)\n\ngoal (3 subgoals):\n 1. distinct (filter (\\<lambda>ys. ys \\<noteq> []) (map (map fst) xs))\n 2. \\<And>ys. ys \\<in> set (map (map fst) xs) \\<Longrightarrow> distinct ys\n 3. \\<And>ys zs.\n       \\<lbrakk>ys \\<in> set (map (map fst) xs);\n        zs \\<in> set (map (map fst) xs); ys \\<noteq> zs\\<rbrakk>\n       \\<Longrightarrow> set ys \\<inter> set zs = {}", "have \"inj_on (map fst) {x \\<in> set xs. x \\<noteq> []}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (map fst) {x \\<in> set xs. x \\<noteq> []}", "proof(rule inj_onI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {x \\<in> set xs. x \\<noteq> []};\n        y \\<in> {x \\<in> set xs. x \\<noteq> []};\n        map fst x = map fst y\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {x \\<in> set xs. x \\<noteq> []};\n        y \\<in> {x \\<in> set xs. x \\<noteq> []};\n        map fst x = map fst y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume \"x \\<in> {x \\<in> set xs. x \\<noteq> []}\" \"y \\<in> {x \\<in> set xs. x \\<noteq> []}\" \"map fst x = map fst y\""], ["proof (state)\nthis:\n  x \\<in> {x \\<in> set xs. x \\<noteq> []}\n  y \\<in> {x \\<in> set xs. x \\<noteq> []}\n  map fst x = map fst y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {x \\<in> set xs. x \\<noteq> []};\n        y \\<in> {x \\<in> set xs. x \\<noteq> []};\n        map fst x = map fst y\\<rbrakk>\n       \\<Longrightarrow> x = y", "hence \"x \\<in> set xs\" \"y \\<in> set xs\" \"x \\<noteq> []\" \"y \\<noteq> []\""], ["proof (prove)\nusing this:\n  x \\<in> {x \\<in> set xs. x \\<noteq> []}\n  y \\<in> {x \\<in> set xs. x \\<noteq> []}\n  map fst x = map fst y\n\ngoal (1 subgoal):\n 1. (x \\<in> set xs &&& y \\<in> set xs) &&& x \\<noteq> [] &&& y \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  x \\<in> set xs\n  y \\<in> set xs\n  x \\<noteq> []\n  y \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {x \\<in> set xs. x \\<noteq> []};\n        y \\<in> {x \\<in> set xs. x \\<noteq> []};\n        map fst x = map fst y\\<rbrakk>\n       \\<Longrightarrow> x = y", "from \\<open>x \\<in> set xs\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> set xs", "obtain i where \"xs ! i = x\" \"i < length xs\""], ["proof (prove)\nusing this:\n  x \\<in> set xs\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>xs ! i = x; i < length xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding set_conv_nth"], ["proof (prove)\nusing this:\n  x \\<in> {xs ! i |i. i < length xs}\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>xs ! i = x; i < length xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  xs ! i = x\n  i < length xs\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {x \\<in> set xs. x \\<noteq> []};\n        y \\<in> {x \\<in> set xs. x \\<noteq> []};\n        map fst x = map fst y\\<rbrakk>\n       \\<Longrightarrow> x = y", "from \\<open>y \\<in> set xs\\<close>"], ["proof (chain)\npicking this:\n  y \\<in> set xs", "obtain j where \"xs ! j = y\" \"j < length xs\""], ["proof (prove)\nusing this:\n  y \\<in> set xs\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>xs ! j = y; j < length xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding set_conv_nth"], ["proof (prove)\nusing this:\n  y \\<in> {xs ! i |i. i < length xs}\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>xs ! j = y; j < length xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  xs ! j = y\n  j < length xs\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {x \\<in> set xs. x \\<noteq> []};\n        y \\<in> {x \\<in> set xs. x \\<noteq> []};\n        map fst x = map fst y\\<rbrakk>\n       \\<Longrightarrow> x = y", "from \\<open>x \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  x \\<noteq> []", "obtain k v x' where \"x = (k, v) # x'\""], ["proof (prove)\nusing this:\n  x \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>k v x'.\n        x = (k, v) # x' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases x) auto"], ["proof (state)\nthis:\n  x = (k, v) # x'\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {x \\<in> set xs. x \\<noteq> []};\n        y \\<in> {x \\<in> set xs. x \\<noteq> []};\n        map fst x = map fst y\\<rbrakk>\n       \\<Longrightarrow> x = y", "with no_junk[OF \\<open>i < length xs\\<close>] \\<open>xs ! i = x\\<close>"], ["proof (chain)\npicking this:\n  bucket_ok (length xs) i (xs ! i)\n  distinct (map fst (xs ! i))\n  xs ! i = x\n  x = (k, v) # x'", "have \"bounded_hashcode_nat (length xs) k = i\""], ["proof (prove)\nusing this:\n  bucket_ok (length xs) i (xs ! i)\n  distinct (map fst (xs ! i))\n  xs ! i = x\n  x = (k, v) # x'\n\ngoal (1 subgoal):\n 1. bounded_hashcode_nat (length xs) k = i", "by(auto simp add: bucket_ok_def)"], ["proof (state)\nthis:\n  bounded_hashcode_nat (length xs) k = i\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {x \\<in> set xs. x \\<noteq> []};\n        y \\<in> {x \\<in> set xs. x \\<noteq> []};\n        map fst x = map fst y\\<rbrakk>\n       \\<Longrightarrow> x = y", "moreover"], ["proof (state)\nthis:\n  bounded_hashcode_nat (length xs) k = i\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {x \\<in> set xs. x \\<noteq> []};\n        y \\<in> {x \\<in> set xs. x \\<noteq> []};\n        map fst x = map fst y\\<rbrakk>\n       \\<Longrightarrow> x = y", "from \\<open>map fst x = map fst y\\<close> \\<open>x = (k, v) # x'\\<close>"], ["proof (chain)\npicking this:\n  map fst x = map fst y\n  x = (k, v) # x'", "obtain v' where \"(k, v') \\<in> set y\""], ["proof (prove)\nusing this:\n  map fst x = map fst y\n  x = (k, v) # x'\n\ngoal (1 subgoal):\n 1. (\\<And>v'.\n        (k, v') \\<in> set y \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  (k, v') \\<in> set y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {x \\<in> set xs. x \\<noteq> []};\n        y \\<in> {x \\<in> set xs. x \\<noteq> []};\n        map fst x = map fst y\\<rbrakk>\n       \\<Longrightarrow> x = y", "with no_junk[OF \\<open>j < length xs\\<close>] \\<open>xs ! j = y\\<close>"], ["proof (chain)\npicking this:\n  bucket_ok (length xs) j (xs ! j)\n  distinct (map fst (xs ! j))\n  xs ! j = y\n  (k, v') \\<in> set y", "have \"bounded_hashcode_nat (length xs) k = j\""], ["proof (prove)\nusing this:\n  bucket_ok (length xs) j (xs ! j)\n  distinct (map fst (xs ! j))\n  xs ! j = y\n  (k, v') \\<in> set y\n\ngoal (1 subgoal):\n 1. bounded_hashcode_nat (length xs) k = j", "by(auto simp add: bucket_ok_def)"], ["proof (state)\nthis:\n  bounded_hashcode_nat (length xs) k = j\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {x \\<in> set xs. x \\<noteq> []};\n        y \\<in> {x \\<in> set xs. x \\<noteq> []};\n        map fst x = map fst y\\<rbrakk>\n       \\<Longrightarrow> x = y", "ultimately"], ["proof (chain)\npicking this:\n  bounded_hashcode_nat (length xs) k = i\n  bounded_hashcode_nat (length xs) k = j", "have \"i = j\""], ["proof (prove)\nusing this:\n  bounded_hashcode_nat (length xs) k = i\n  bounded_hashcode_nat (length xs) k = j\n\ngoal (1 subgoal):\n 1. i = j", "by simp"], ["proof (state)\nthis:\n  i = j\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {x \\<in> set xs. x \\<noteq> []};\n        y \\<in> {x \\<in> set xs. x \\<noteq> []};\n        map fst x = map fst y\\<rbrakk>\n       \\<Longrightarrow> x = y", "with \\<open>xs ! i = x\\<close> \\<open>xs ! j = y\\<close>"], ["proof (chain)\npicking this:\n  xs ! i = x\n  xs ! j = y\n  i = j", "show \"x = y\""], ["proof (prove)\nusing this:\n  xs ! i = x\n  xs ! j = y\n  i = j\n\ngoal (1 subgoal):\n 1. x = y", "by simp"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inj_on (map fst) {x \\<in> set xs. x \\<noteq> []}\n\ngoal (3 subgoals):\n 1. distinct (filter (\\<lambda>ys. ys \\<noteq> []) (map (map fst) xs))\n 2. \\<And>ys. ys \\<in> set (map (map fst) xs) \\<Longrightarrow> distinct ys\n 3. \\<And>ys zs.\n       \\<lbrakk>ys \\<in> set (map (map fst) xs);\n        zs \\<in> set (map (map fst) xs); ys \\<noteq> zs\\<rbrakk>\n       \\<Longrightarrow> set ys \\<inter> set zs = {}", "ultimately"], ["proof (chain)\npicking this:\n  distinct (filter (\\<lambda>x. x \\<noteq> []) xs)\n  inj_on (map fst) {x \\<in> set xs. x \\<noteq> []}", "show \"distinct [ys\\<leftarrow>map (map fst) xs . ys \\<noteq> []]\""], ["proof (prove)\nusing this:\n  distinct (filter (\\<lambda>x. x \\<noteq> []) xs)\n  inj_on (map fst) {x \\<in> set xs. x \\<noteq> []}\n\ngoal (1 subgoal):\n 1. distinct (filter (\\<lambda>ys. ys \\<noteq> []) (map (map fst) xs))", "by(simp add: filter_map o_def distinct_map)"], ["proof (state)\nthis:\n  distinct (filter (\\<lambda>ys. ys \\<noteq> []) (map (map fst) xs))\n\ngoal (2 subgoals):\n 1. \\<And>ys. ys \\<in> set (map (map fst) xs) \\<Longrightarrow> distinct ys\n 2. \\<And>ys zs.\n       \\<lbrakk>ys \\<in> set (map (map fst) xs);\n        zs \\<in> set (map (map fst) xs); ys \\<noteq> zs\\<rbrakk>\n       \\<Longrightarrow> set ys \\<inter> set zs = {}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys. ys \\<in> set (map (map fst) xs) \\<Longrightarrow> distinct ys\n 2. \\<And>ys zs.\n       \\<lbrakk>ys \\<in> set (map (map fst) xs);\n        zs \\<in> set (map (map fst) xs); ys \\<noteq> zs\\<rbrakk>\n       \\<Longrightarrow> set ys \\<inter> set zs = {}", "fix ys"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys. ys \\<in> set (map (map fst) xs) \\<Longrightarrow> distinct ys\n 2. \\<And>ys zs.\n       \\<lbrakk>ys \\<in> set (map (map fst) xs);\n        zs \\<in> set (map (map fst) xs); ys \\<noteq> zs\\<rbrakk>\n       \\<Longrightarrow> set ys \\<inter> set zs = {}", "assume \"ys \\<in> set (map (map fst) xs)\""], ["proof (state)\nthis:\n  ys \\<in> set (map (map fst) xs)\n\ngoal (2 subgoals):\n 1. \\<And>ys. ys \\<in> set (map (map fst) xs) \\<Longrightarrow> distinct ys\n 2. \\<And>ys zs.\n       \\<lbrakk>ys \\<in> set (map (map fst) xs);\n        zs \\<in> set (map (map fst) xs); ys \\<noteq> zs\\<rbrakk>\n       \\<Longrightarrow> set ys \\<inter> set zs = {}", "thus \"distinct ys\""], ["proof (prove)\nusing this:\n  ys \\<in> set (map (map fst) xs)\n\ngoal (1 subgoal):\n 1. distinct ys", "by(clarsimp simp add: set_conv_nth)(rule no_junk)"], ["proof (state)\nthis:\n  distinct ys\n\ngoal (1 subgoal):\n 1. \\<And>ys zs.\n       \\<lbrakk>ys \\<in> set (map (map fst) xs);\n        zs \\<in> set (map (map fst) xs); ys \\<noteq> zs\\<rbrakk>\n       \\<Longrightarrow> set ys \\<inter> set zs = {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys zs.\n       \\<lbrakk>ys \\<in> set (map (map fst) xs);\n        zs \\<in> set (map (map fst) xs); ys \\<noteq> zs\\<rbrakk>\n       \\<Longrightarrow> set ys \\<inter> set zs = {}", "fix ys zs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ys zs.\n       \\<lbrakk>ys \\<in> set (map (map fst) xs);\n        zs \\<in> set (map (map fst) xs); ys \\<noteq> zs\\<rbrakk>\n       \\<Longrightarrow> set ys \\<inter> set zs = {}", "assume \"ys \\<in> set (map (map fst) xs)\" \"zs \\<in> set (map (map fst) xs)\" \"ys \\<noteq> zs\""], ["proof (state)\nthis:\n  ys \\<in> set (map (map fst) xs)\n  zs \\<in> set (map (map fst) xs)\n  ys \\<noteq> zs\n\ngoal (1 subgoal):\n 1. \\<And>ys zs.\n       \\<lbrakk>ys \\<in> set (map (map fst) xs);\n        zs \\<in> set (map (map fst) xs); ys \\<noteq> zs\\<rbrakk>\n       \\<Longrightarrow> set ys \\<inter> set zs = {}", "then"], ["proof (chain)\npicking this:\n  ys \\<in> set (map (map fst) xs)\n  zs \\<in> set (map (map fst) xs)\n  ys \\<noteq> zs", "obtain ys' zs' where [simp]: \"ys = map fst ys'\" \"zs = map fst zs'\" \n      and \"ys' \\<in> set xs\" \"zs' \\<in> set xs\""], ["proof (prove)\nusing this:\n  ys \\<in> set (map (map fst) xs)\n  zs \\<in> set (map (map fst) xs)\n  ys \\<noteq> zs\n\ngoal (1 subgoal):\n 1. (\\<And>ys' zs'.\n        \\<lbrakk>ys = map fst ys'; zs = map fst zs'; ys' \\<in> set xs;\n         zs' \\<in> set xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ys = map fst ys'\n  zs = map fst zs'\n  ys' \\<in> set xs\n  zs' \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<And>ys zs.\n       \\<lbrakk>ys \\<in> set (map (map fst) xs);\n        zs \\<in> set (map (map fst) xs); ys \\<noteq> zs\\<rbrakk>\n       \\<Longrightarrow> set ys \\<inter> set zs = {}", "have \"fst ` set ys' \\<inter> fst ` set zs' = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst ` set ys' \\<inter> fst ` set zs' = {}", "proof(rule equals0I)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> fst ` set ys' \\<inter> fst ` set zs' \\<Longrightarrow> False", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> fst ` set ys' \\<inter> fst ` set zs' \\<Longrightarrow> False", "assume \"k \\<in> fst ` set ys' \\<inter> fst ` set zs'\""], ["proof (state)\nthis:\n  k \\<in> fst ` set ys' \\<inter> fst ` set zs'\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> fst ` set ys' \\<inter> fst ` set zs' \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  k \\<in> fst ` set ys' \\<inter> fst ` set zs'", "obtain v v' where \"(k, v) \\<in> set ys'\" \"(k, v') \\<in> set zs'\""], ["proof (prove)\nusing this:\n  k \\<in> fst ` set ys' \\<inter> fst ` set zs'\n\ngoal (1 subgoal):\n 1. (\\<And>v v'.\n        \\<lbrakk>(k, v) \\<in> set ys'; (k, v') \\<in> set zs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto)"], ["proof (state)\nthis:\n  (k, v) \\<in> set ys'\n  (k, v') \\<in> set zs'\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> fst ` set ys' \\<inter> fst ` set zs' \\<Longrightarrow> False", "from \\<open>ys' \\<in> set xs\\<close>"], ["proof (chain)\npicking this:\n  ys' \\<in> set xs", "obtain i where \"xs ! i = ys'\" \"i < length xs\""], ["proof (prove)\nusing this:\n  ys' \\<in> set xs\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>xs ! i = ys'; i < length xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding set_conv_nth"], ["proof (prove)\nusing this:\n  ys' \\<in> {xs ! i |i. i < length xs}\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>xs ! i = ys'; i < length xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  xs ! i = ys'\n  i < length xs\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> fst ` set ys' \\<inter> fst ` set zs' \\<Longrightarrow> False", "with \\<open>(k, v) \\<in> set ys'\\<close>"], ["proof (chain)\npicking this:\n  (k, v) \\<in> set ys'\n  xs ! i = ys'\n  i < length xs", "have \"bounded_hashcode_nat (length xs) k = i\""], ["proof (prove)\nusing this:\n  (k, v) \\<in> set ys'\n  xs ! i = ys'\n  i < length xs\n\ngoal (1 subgoal):\n 1. bounded_hashcode_nat (length xs) k = i", "by(auto dest: no_junk bucket_okD)"], ["proof (state)\nthis:\n  bounded_hashcode_nat (length xs) k = i\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> fst ` set ys' \\<inter> fst ` set zs' \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  bounded_hashcode_nat (length xs) k = i\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> fst ` set ys' \\<inter> fst ` set zs' \\<Longrightarrow> False", "from \\<open>zs' \\<in> set xs\\<close>"], ["proof (chain)\npicking this:\n  zs' \\<in> set xs", "obtain j where \"xs ! j = zs'\" \"j < length xs\""], ["proof (prove)\nusing this:\n  zs' \\<in> set xs\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>xs ! j = zs'; j < length xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding set_conv_nth"], ["proof (prove)\nusing this:\n  zs' \\<in> {xs ! i |i. i < length xs}\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>xs ! j = zs'; j < length xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  xs ! j = zs'\n  j < length xs\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> fst ` set ys' \\<inter> fst ` set zs' \\<Longrightarrow> False", "with \\<open>(k, v') \\<in> set zs'\\<close>"], ["proof (chain)\npicking this:\n  (k, v') \\<in> set zs'\n  xs ! j = zs'\n  j < length xs", "have \"bounded_hashcode_nat (length xs) k = j\""], ["proof (prove)\nusing this:\n  (k, v') \\<in> set zs'\n  xs ! j = zs'\n  j < length xs\n\ngoal (1 subgoal):\n 1. bounded_hashcode_nat (length xs) k = j", "by(auto dest: no_junk bucket_okD)"], ["proof (state)\nthis:\n  bounded_hashcode_nat (length xs) k = j\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> fst ` set ys' \\<inter> fst ` set zs' \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  bounded_hashcode_nat (length xs) k = i\n  bounded_hashcode_nat (length xs) k = j", "have \"i = j\""], ["proof (prove)\nusing this:\n  bounded_hashcode_nat (length xs) k = i\n  bounded_hashcode_nat (length xs) k = j\n\ngoal (1 subgoal):\n 1. i = j", "by simp"], ["proof (state)\nthis:\n  i = j\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> fst ` set ys' \\<inter> fst ` set zs' \\<Longrightarrow> False", "with \\<open>xs ! i = ys'\\<close> \\<open>xs ! j = zs'\\<close>"], ["proof (chain)\npicking this:\n  xs ! i = ys'\n  xs ! j = zs'\n  i = j", "have \"ys' = zs'\""], ["proof (prove)\nusing this:\n  xs ! i = ys'\n  xs ! j = zs'\n  i = j\n\ngoal (1 subgoal):\n 1. ys' = zs'", "by simp"], ["proof (state)\nthis:\n  ys' = zs'\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> fst ` set ys' \\<inter> fst ` set zs' \\<Longrightarrow> False", "with \\<open>ys \\<noteq> zs\\<close>"], ["proof (chain)\npicking this:\n  ys \\<noteq> zs\n  ys' = zs'", "show False"], ["proof (prove)\nusing this:\n  ys \\<noteq> zs\n  ys' = zs'\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fst ` set ys' \\<inter> fst ` set zs' = {}\n\ngoal (1 subgoal):\n 1. \\<And>ys zs.\n       \\<lbrakk>ys \\<in> set (map (map fst) xs);\n        zs \\<in> set (map (map fst) xs); ys \\<noteq> zs\\<rbrakk>\n       \\<Longrightarrow> set ys \\<inter> set zs = {}", "thus \"set ys \\<inter> set zs = {}\""], ["proof (prove)\nusing this:\n  fst ` set ys' \\<inter> fst ` set zs' = {}\n\ngoal (1 subgoal):\n 1. set ys \\<inter> set zs = {}", "by simp"], ["proof (state)\nthis:\n  set ys \\<inter> set zs = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  distinct (map fst (concat xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>@{term \"ahm_\\<alpha>\"}\\<close>"], ["", "lemma finite_dom_ahm_\\<alpha>_aux:\n  assumes \"ahm_invar_aux n a\"\n  shows \"finite (dom (ahm_\\<alpha>_aux a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (dom (ahm_\\<alpha>_aux a))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (dom (ahm_\\<alpha>_aux a))", "have \"dom (ahm_\\<alpha>_aux a) \\<subseteq> (\\<Union>h \\<in> range (bounded_hashcode_nat (array_length a) :: 'a \\<Rightarrow> nat). dom (map_of (array_get a h)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (ahm_\\<alpha>_aux a)\n    \\<subseteq> (\\<Union>h\\<in>range\n                                (bounded_hashcode_nat (array_length a)).\n                    dom (map_of (array_get a h)))", "by(force simp add: dom_map_of_conv_image_fst ahm_\\<alpha>_aux_def dest: map_of_SomeD)"], ["proof (state)\nthis:\n  dom (ahm_\\<alpha>_aux a)\n  \\<subseteq> (\\<Union>h\\<in>range (bounded_hashcode_nat (array_length a)).\n                  dom (map_of (array_get a h)))\n\ngoal (1 subgoal):\n 1. finite (dom (ahm_\\<alpha>_aux a))", "moreover"], ["proof (state)\nthis:\n  dom (ahm_\\<alpha>_aux a)\n  \\<subseteq> (\\<Union>h\\<in>range (bounded_hashcode_nat (array_length a)).\n                  dom (map_of (array_get a h)))\n\ngoal (1 subgoal):\n 1. finite (dom (ahm_\\<alpha>_aux a))", "have \"finite \\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (\\<Union>h\\<in>range (bounded_hashcode_nat (array_length a)).\n         dom (map_of (array_get a h)))", "proof(rule finite_UN_I)"], ["proof (state)\ngoal (2 subgoals):\n 1. finite (range (bounded_hashcode_nat (array_length a)))\n 2. \\<And>h.\n       h \\<in> range\n                (bounded_hashcode_nat (array_length a)) \\<Longrightarrow>\n       finite (dom (map_of (array_get a h)))", "from \\<open>ahm_invar_aux n a\\<close>"], ["proof (chain)\npicking this:\n  ahm_invar_aux n a", "have \"array_length a > 1\""], ["proof (prove)\nusing this:\n  ahm_invar_aux n a\n\ngoal (1 subgoal):\n 1. 1 < array_length a", "by(simp add: ahm_invar_aux_def)"], ["proof (state)\nthis:\n  1 < array_length a\n\ngoal (2 subgoals):\n 1. finite (range (bounded_hashcode_nat (array_length a)))\n 2. \\<And>h.\n       h \\<in> range\n                (bounded_hashcode_nat (array_length a)) \\<Longrightarrow>\n       finite (dom (map_of (array_get a h)))", "hence \"range (bounded_hashcode_nat (array_length a) :: 'a \\<Rightarrow> nat) \\<subseteq> {0..<array_length a}\""], ["proof (prove)\nusing this:\n  1 < array_length a\n\ngoal (1 subgoal):\n 1. range (bounded_hashcode_nat (array_length a))\n    \\<subseteq> {0..<array_length a}", "by(auto simp add: bounded_hashcode_nat_bounds)"], ["proof (state)\nthis:\n  range (bounded_hashcode_nat (array_length a))\n  \\<subseteq> {0..<array_length a}\n\ngoal (2 subgoals):\n 1. finite (range (bounded_hashcode_nat (array_length a)))\n 2. \\<And>h.\n       h \\<in> range\n                (bounded_hashcode_nat (array_length a)) \\<Longrightarrow>\n       finite (dom (map_of (array_get a h)))", "thus \"finite (range (bounded_hashcode_nat (array_length a) :: 'a \\<Rightarrow> nat))\""], ["proof (prove)\nusing this:\n  range (bounded_hashcode_nat (array_length a))\n  \\<subseteq> {0..<array_length a}\n\ngoal (1 subgoal):\n 1. finite (range (bounded_hashcode_nat (array_length a)))", "by(rule finite_subset) simp"], ["proof (state)\nthis:\n  finite (range (bounded_hashcode_nat (array_length a)))\n\ngoal (1 subgoal):\n 1. \\<And>h.\n       h \\<in> range\n                (bounded_hashcode_nat (array_length a)) \\<Longrightarrow>\n       finite (dom (map_of (array_get a h)))", "qed(rule finite_dom_map_of)"], ["proof (state)\nthis:\n  finite\n   (\\<Union>h\\<in>range (bounded_hashcode_nat (array_length a)).\n       dom (map_of (array_get a h)))\n\ngoal (1 subgoal):\n 1. finite (dom (ahm_\\<alpha>_aux a))", "ultimately"], ["proof (chain)\npicking this:\n  dom (ahm_\\<alpha>_aux a)\n  \\<subseteq> (\\<Union>h\\<in>range (bounded_hashcode_nat (array_length a)).\n                  dom (map_of (array_get a h)))\n  finite\n   (\\<Union>h\\<in>range (bounded_hashcode_nat (array_length a)).\n       dom (map_of (array_get a h)))", "show ?thesis"], ["proof (prove)\nusing this:\n  dom (ahm_\\<alpha>_aux a)\n  \\<subseteq> (\\<Union>h\\<in>range (bounded_hashcode_nat (array_length a)).\n                  dom (map_of (array_get a h)))\n  finite\n   (\\<Union>h\\<in>range (bounded_hashcode_nat (array_length a)).\n       dom (map_of (array_get a h)))\n\ngoal (1 subgoal):\n 1. finite (dom (ahm_\\<alpha>_aux a))", "by(rule finite_subset)"], ["proof (state)\nthis:\n  finite (dom (ahm_\\<alpha>_aux a))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ahm_\\<alpha>_aux_conv_map_of_concat:\n  assumes inv: \"ahm_invar_aux n (Array xs)\"\n  shows \"ahm_\\<alpha>_aux (Array xs) = map_of (concat xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ahm_\\<alpha>_aux (Array xs) = map_of (concat xs)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. ahm_\\<alpha>_aux (Array xs) x = map_of (concat xs) x", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. ahm_\\<alpha>_aux (Array xs) x = map_of (concat xs) x", "show \"ahm_\\<alpha>_aux (Array xs) k = map_of (concat xs) k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ahm_\\<alpha>_aux (Array xs) k = map_of (concat xs) k", "proof(cases \"map_of (concat xs) k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. map_of (concat xs) k = None \\<Longrightarrow>\n    ahm_\\<alpha>_aux (Array xs) k = map_of (concat xs) k\n 2. \\<And>a.\n       map_of (concat xs) k = Some a \\<Longrightarrow>\n       ahm_\\<alpha>_aux (Array xs) k = map_of (concat xs) k", "case None"], ["proof (state)\nthis:\n  map_of (concat xs) k = None\n\ngoal (2 subgoals):\n 1. map_of (concat xs) k = None \\<Longrightarrow>\n    ahm_\\<alpha>_aux (Array xs) k = map_of (concat xs) k\n 2. \\<And>a.\n       map_of (concat xs) k = Some a \\<Longrightarrow>\n       ahm_\\<alpha>_aux (Array xs) k = map_of (concat xs) k", "hence \"k \\<notin> fst ` set (concat xs)\""], ["proof (prove)\nusing this:\n  map_of (concat xs) k = None\n\ngoal (1 subgoal):\n 1. k \\<notin> fst ` set (concat xs)", "by(simp add: map_of_eq_None_iff)"], ["proof (state)\nthis:\n  k \\<notin> fst ` set (concat xs)\n\ngoal (2 subgoals):\n 1. map_of (concat xs) k = None \\<Longrightarrow>\n    ahm_\\<alpha>_aux (Array xs) k = map_of (concat xs) k\n 2. \\<And>a.\n       map_of (concat xs) k = Some a \\<Longrightarrow>\n       ahm_\\<alpha>_aux (Array xs) k = map_of (concat xs) k", "hence \"k \\<notin> fst ` set (xs ! bounded_hashcode_nat (length xs) k)\""], ["proof (prove)\nusing this:\n  k \\<notin> fst ` set (concat xs)\n\ngoal (1 subgoal):\n 1. k \\<notin> fst ` set (xs ! bounded_hashcode_nat (length xs) k)", "proof(rule contrapos_nn)"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<in> fst `\n            set (xs ! bounded_hashcode_nat (length xs) k) \\<Longrightarrow>\n    k \\<in> fst ` set (concat xs)", "assume \"k \\<in> fst ` set (xs ! bounded_hashcode_nat (length xs) k)\""], ["proof (state)\nthis:\n  k \\<in> fst ` set (xs ! bounded_hashcode_nat (length xs) k)\n\ngoal (1 subgoal):\n 1. k \\<in> fst `\n            set (xs ! bounded_hashcode_nat (length xs) k) \\<Longrightarrow>\n    k \\<in> fst ` set (concat xs)", "then"], ["proof (chain)\npicking this:\n  k \\<in> fst ` set (xs ! bounded_hashcode_nat (length xs) k)", "obtain v where \"(k, v) \\<in> set (xs ! bounded_hashcode_nat (length xs) k)\""], ["proof (prove)\nusing this:\n  k \\<in> fst ` set (xs ! bounded_hashcode_nat (length xs) k)\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        (k, v)\n        \\<in> set (xs !\n                   bounded_hashcode_nat (length xs) k) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (k, v) \\<in> set (xs ! bounded_hashcode_nat (length xs) k)\n\ngoal (1 subgoal):\n 1. k \\<in> fst `\n            set (xs ! bounded_hashcode_nat (length xs) k) \\<Longrightarrow>\n    k \\<in> fst ` set (concat xs)", "moreover"], ["proof (state)\nthis:\n  (k, v) \\<in> set (xs ! bounded_hashcode_nat (length xs) k)\n\ngoal (1 subgoal):\n 1. k \\<in> fst `\n            set (xs ! bounded_hashcode_nat (length xs) k) \\<Longrightarrow>\n    k \\<in> fst ` set (concat xs)", "from inv"], ["proof (chain)\npicking this:\n  ahm_invar_aux n (Array xs)", "have \"bounded_hashcode_nat (length xs) k < length xs\""], ["proof (prove)\nusing this:\n  ahm_invar_aux n (Array xs)\n\ngoal (1 subgoal):\n 1. bounded_hashcode_nat (length xs) k < length xs", "by(simp add: bounded_hashcode_nat_bounds ahm_invar_aux_def)"], ["proof (state)\nthis:\n  bounded_hashcode_nat (length xs) k < length xs\n\ngoal (1 subgoal):\n 1. k \\<in> fst `\n            set (xs ! bounded_hashcode_nat (length xs) k) \\<Longrightarrow>\n    k \\<in> fst ` set (concat xs)", "ultimately"], ["proof (chain)\npicking this:\n  (k, v) \\<in> set (xs ! bounded_hashcode_nat (length xs) k)\n  bounded_hashcode_nat (length xs) k < length xs", "show \"k \\<in> fst ` set (concat xs)\""], ["proof (prove)\nusing this:\n  (k, v) \\<in> set (xs ! bounded_hashcode_nat (length xs) k)\n  bounded_hashcode_nat (length xs) k < length xs\n\ngoal (1 subgoal):\n 1. k \\<in> fst ` set (concat xs)", "by(force intro: rev_image_eqI)"], ["proof (state)\nthis:\n  k \\<in> fst ` set (concat xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  k \\<notin> fst ` set (xs ! bounded_hashcode_nat (length xs) k)\n\ngoal (2 subgoals):\n 1. map_of (concat xs) k = None \\<Longrightarrow>\n    ahm_\\<alpha>_aux (Array xs) k = map_of (concat xs) k\n 2. \\<And>a.\n       map_of (concat xs) k = Some a \\<Longrightarrow>\n       ahm_\\<alpha>_aux (Array xs) k = map_of (concat xs) k", "thus ?thesis"], ["proof (prove)\nusing this:\n  k \\<notin> fst ` set (xs ! bounded_hashcode_nat (length xs) k)\n\ngoal (1 subgoal):\n 1. ahm_\\<alpha>_aux (Array xs) k = map_of (concat xs) k", "unfolding None"], ["proof (prove)\nusing this:\n  k \\<notin> fst ` set (xs ! bounded_hashcode_nat (length xs) k)\n\ngoal (1 subgoal):\n 1. ahm_\\<alpha>_aux (Array xs) k = None", "by(simp add: map_of_eq_None_iff)"], ["proof (state)\nthis:\n  ahm_\\<alpha>_aux (Array xs) k = map_of (concat xs) k\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       map_of (concat xs) k = Some a \\<Longrightarrow>\n       ahm_\\<alpha>_aux (Array xs) k = map_of (concat xs) k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       map_of (concat xs) k = Some a \\<Longrightarrow>\n       ahm_\\<alpha>_aux (Array xs) k = map_of (concat xs) k", "case (Some v)"], ["proof (state)\nthis:\n  map_of (concat xs) k = Some v\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       map_of (concat xs) k = Some a \\<Longrightarrow>\n       ahm_\\<alpha>_aux (Array xs) k = map_of (concat xs) k", "hence \"(k, v) \\<in> set (concat xs)\""], ["proof (prove)\nusing this:\n  map_of (concat xs) k = Some v\n\ngoal (1 subgoal):\n 1. (k, v) \\<in> set (concat xs)", "by(rule map_of_SomeD)"], ["proof (state)\nthis:\n  (k, v) \\<in> set (concat xs)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       map_of (concat xs) k = Some a \\<Longrightarrow>\n       ahm_\\<alpha>_aux (Array xs) k = map_of (concat xs) k", "then"], ["proof (chain)\npicking this:\n  (k, v) \\<in> set (concat xs)", "obtain ys where \"ys \\<in> set xs\" \"(k, v) \\<in> set ys\""], ["proof (prove)\nusing this:\n  (k, v) \\<in> set (concat xs)\n\ngoal (1 subgoal):\n 1. (\\<And>ys.\n        \\<lbrakk>ys \\<in> set xs; (k, v) \\<in> set ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding set_concat"], ["proof (prove)\nusing this:\n  (k, v) \\<in> \\<Union> (set ` set xs)\n\ngoal (1 subgoal):\n 1. (\\<And>ys.\n        \\<lbrakk>ys \\<in> set xs; (k, v) \\<in> set ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ys \\<in> set xs\n  (k, v) \\<in> set ys\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       map_of (concat xs) k = Some a \\<Longrightarrow>\n       ahm_\\<alpha>_aux (Array xs) k = map_of (concat xs) k", "from \\<open>ys \\<in> set xs\\<close>"], ["proof (chain)\npicking this:\n  ys \\<in> set xs", "obtain i j where \"i < length xs\" \"xs ! i = ys\""], ["proof (prove)\nusing this:\n  ys \\<in> set xs\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length xs; xs ! i = ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding set_conv_nth"], ["proof (prove)\nusing this:\n  ys \\<in> {xs ! i |i. i < length xs}\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length xs; xs ! i = ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i < length xs\n  xs ! i = ys\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       map_of (concat xs) k = Some a \\<Longrightarrow>\n       ahm_\\<alpha>_aux (Array xs) k = map_of (concat xs) k", "with inv \\<open>(k, v) \\<in> set ys\\<close>"], ["proof (chain)\npicking this:\n  ahm_invar_aux n (Array xs)\n  (k, v) \\<in> set ys\n  i < length xs\n  xs ! i = ys", "show ?thesis"], ["proof (prove)\nusing this:\n  ahm_invar_aux n (Array xs)\n  (k, v) \\<in> set ys\n  i < length xs\n  xs ! i = ys\n\ngoal (1 subgoal):\n 1. ahm_\\<alpha>_aux (Array xs) k = map_of (concat xs) k", "unfolding Some"], ["proof (prove)\nusing this:\n  ahm_invar_aux n (Array xs)\n  (k, v) \\<in> set ys\n  i < length xs\n  xs ! i = ys\n\ngoal (1 subgoal):\n 1. ahm_\\<alpha>_aux (Array xs) k = Some v", "by(force dest: bucket_okD simp add: ahm_invar_aux_def)"], ["proof (state)\nthis:\n  ahm_\\<alpha>_aux (Array xs) k = map_of (concat xs) k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ahm_\\<alpha>_aux (Array xs) k = map_of (concat xs) k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ahm_invar_aux_card_dom_ahm_\\<alpha>_auxD:\n  assumes inv: \"ahm_invar_aux n a\"\n  shows \"card (dom (ahm_\\<alpha>_aux a)) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (dom (ahm_\\<alpha>_aux a)) = n", "proof(cases a)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       a = Array x \\<Longrightarrow> card (dom (ahm_\\<alpha>_aux a)) = n", "case [simp]: (Array xs)"], ["proof (state)\nthis:\n  a = Array xs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       a = Array x \\<Longrightarrow> card (dom (ahm_\\<alpha>_aux a)) = n", "from inv"], ["proof (chain)\npicking this:\n  ahm_invar_aux n a", "have \"card (dom (ahm_\\<alpha>_aux (Array xs))) = card (dom (map_of (concat xs)))\""], ["proof (prove)\nusing this:\n  ahm_invar_aux n a\n\ngoal (1 subgoal):\n 1. card (dom (ahm_\\<alpha>_aux (Array xs))) =\n    card (dom (map_of (concat xs)))", "by(simp add: ahm_\\<alpha>_aux_conv_map_of_concat)"], ["proof (state)\nthis:\n  card (dom (ahm_\\<alpha>_aux (Array xs))) = card (dom (map_of (concat xs)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       a = Array x \\<Longrightarrow> card (dom (ahm_\\<alpha>_aux a)) = n", "also"], ["proof (state)\nthis:\n  card (dom (ahm_\\<alpha>_aux (Array xs))) = card (dom (map_of (concat xs)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       a = Array x \\<Longrightarrow> card (dom (ahm_\\<alpha>_aux a)) = n", "from inv"], ["proof (chain)\npicking this:\n  ahm_invar_aux n a", "have \"distinct (map fst (concat xs))\""], ["proof (prove)\nusing this:\n  ahm_invar_aux n a\n\ngoal (1 subgoal):\n 1. distinct (map fst (concat xs))", "by(simp add: ahm_invar_distinct_fst_concatD)"], ["proof (state)\nthis:\n  distinct (map fst (concat xs))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       a = Array x \\<Longrightarrow> card (dom (ahm_\\<alpha>_aux a)) = n", "hence \"card (dom (map_of (concat xs))) = length (concat xs)\""], ["proof (prove)\nusing this:\n  distinct (map fst (concat xs))\n\ngoal (1 subgoal):\n 1. card (dom (map_of (concat xs))) = length (concat xs)", "by(rule card_dom_map_of)"], ["proof (state)\nthis:\n  card (dom (map_of (concat xs))) = length (concat xs)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       a = Array x \\<Longrightarrow> card (dom (ahm_\\<alpha>_aux a)) = n", "also"], ["proof (state)\nthis:\n  card (dom (map_of (concat xs))) = length (concat xs)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       a = Array x \\<Longrightarrow> card (dom (ahm_\\<alpha>_aux a)) = n", "have \"length (concat xs) = foldl (+) 0 (map length xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (concat xs) = foldl (+) 0 (map length xs)", "by (simp add: length_concat foldl_conv_fold add.commute fold_plus_sum_list_rev)"], ["proof (state)\nthis:\n  length (concat xs) = foldl (+) 0 (map length xs)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       a = Array x \\<Longrightarrow> card (dom (ahm_\\<alpha>_aux a)) = n", "also"], ["proof (state)\nthis:\n  length (concat xs) = foldl (+) 0 (map length xs)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       a = Array x \\<Longrightarrow> card (dom (ahm_\\<alpha>_aux a)) = n", "from inv"], ["proof (chain)\npicking this:\n  ahm_invar_aux n a", "have \"\\<dots> = n\""], ["proof (prove)\nusing this:\n  ahm_invar_aux n a\n\ngoal (1 subgoal):\n 1. foldl (+) 0 (map length xs) = n", "unfolding foldl_map"], ["proof (prove)\nusing this:\n  ahm_invar_aux n a\n\ngoal (1 subgoal):\n 1. foldl (\\<lambda>a x. a + length x) 0 xs = n", "by(simp add: ahm_invar_aux_def array_foldl_foldl)"], ["proof (state)\nthis:\n  foldl (+) 0 (map length xs) = n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       a = Array x \\<Longrightarrow> card (dom (ahm_\\<alpha>_aux a)) = n", "finally"], ["proof (chain)\npicking this:\n  card (dom (ahm_\\<alpha>_aux (Array xs))) = n", "show ?thesis"], ["proof (prove)\nusing this:\n  card (dom (ahm_\\<alpha>_aux (Array xs))) = n\n\ngoal (1 subgoal):\n 1. card (dom (ahm_\\<alpha>_aux a)) = n", "by(simp)"], ["proof (state)\nthis:\n  card (dom (ahm_\\<alpha>_aux a)) = n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_dom_ahm_\\<alpha>:\n  \"ahm_invar hm \\<Longrightarrow> finite (dom (ahm_\\<alpha> hm))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ahm_invar hm \\<Longrightarrow> finite (dom (ahm_\\<alpha> hm))", "by(cases hm)(auto intro: finite_dom_ahm_\\<alpha>_aux)"], ["", "lemma finite_map_ahm_\\<alpha>_aux:\n  \"finite_map ahm_\\<alpha>_aux (ahm_invar_aux n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_map ahm_\\<alpha>_aux (ahm_invar_aux n)", "by(unfold_locales)(rule finite_dom_ahm_\\<alpha>_aux)"], ["", "lemma finite_map_ahm_\\<alpha>:\n  \"finite_map ahm_\\<alpha> ahm_invar\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_map ahm_\\<alpha> ahm_invar", "by(unfold_locales)(rule finite_dom_ahm_\\<alpha>)"], ["", "subsection \\<open>@{term ahm_empty}\\<close>"], ["", "lemma ahm_invar_aux_new_array:\n  assumes \"n > 1\"\n  shows \"ahm_invar_aux 0 (new_array [] n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ahm_invar_aux 0 (new_array [] n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ahm_invar_aux 0 (new_array [] n)", "have \"foldl (\\<lambda>b (k, v). b + length v) 0 (zip [0..<n] (replicate n [])) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (\\<lambda>b (k, v). b + length v) 0\n     (zip [0..<n] (replicate n [])) =\n    0", "by(induct n)(simp_all add: replicate_Suc_conv_snoc del: replicate_Suc)"], ["proof (state)\nthis:\n  foldl (\\<lambda>b (k, v). b + length v) 0 (zip [0..<n] (replicate n [])) =\n  0\n\ngoal (1 subgoal):\n 1. ahm_invar_aux 0 (new_array [] n)", "with assms"], ["proof (chain)\npicking this:\n  1 < n\n  foldl (\\<lambda>b (k, v). b + length v) 0 (zip [0..<n] (replicate n [])) =\n  0", "show ?thesis"], ["proof (prove)\nusing this:\n  1 < n\n  foldl (\\<lambda>b (k, v). b + length v) 0 (zip [0..<n] (replicate n [])) =\n  0\n\ngoal (1 subgoal):\n 1. ahm_invar_aux 0 (new_array [] n)", "by(simp add: ahm_invar_aux_def array_foldl_new_array)"], ["proof (state)\nthis:\n  ahm_invar_aux 0 (new_array [] n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ahm_invar_new_hashmap_with:\n  \"n > 1 \\<Longrightarrow> ahm_invar (new_hashmap_with n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < n \\<Longrightarrow> ahm_invar (new_hashmap_with n)", "by(auto simp add: ahm_invar_def new_hashmap_with_def intro: ahm_invar_aux_new_array)"], ["", "lemma ahm_\\<alpha>_new_hashmap_with:\n  \"n > 1 \\<Longrightarrow> ahm_\\<alpha> (new_hashmap_with n) = Map.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < n \\<Longrightarrow> ahm_\\<alpha> (new_hashmap_with n) = Map.empty", "by(simp add: new_hashmap_with_def bounded_hashcode_nat_bounds fun_eq_iff)"], ["", "lemma ahm_invar_ahm_empty [simp]: \"ahm_invar (ahm_empty ())\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ahm_invar (ahm_empty ())", "using def_hashmap_size[where ?'a = 'a]"], ["proof (prove)\nusing this:\n  1 < def_hashmap_size TYPE('a)\n\ngoal (1 subgoal):\n 1. ahm_invar (ahm_empty ())", "by(auto intro: ahm_invar_new_hashmap_with simp add: ahm_empty_def)"], ["", "lemma ahm_empty_correct [simp]: \"ahm_\\<alpha> (ahm_empty ()) = Map.empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ahm_\\<alpha> (ahm_empty ()) = Map.empty", "using def_hashmap_size[where ?'a = 'a]"], ["proof (prove)\nusing this:\n  1 < def_hashmap_size TYPE('a)\n\ngoal (1 subgoal):\n 1. ahm_\\<alpha> (ahm_empty ()) = Map.empty", "by(auto intro: ahm_\\<alpha>_new_hashmap_with simp add: ahm_empty_def)"], ["", "lemma ahm_empty_impl: \"map_empty ahm_\\<alpha> ahm_invar ahm_empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_empty ahm_\\<alpha> ahm_invar ahm_empty", "by(unfold_locales)(auto)"], ["", "subsection \\<open>@{term \"ahm_lookup\"}\\<close>"], ["", "lemma ahm_lookup_impl: \"map_lookup ahm_\\<alpha> ahm_invar ahm_lookup\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_lookup ahm_\\<alpha> ahm_invar ahm_lookup", "by(unfold_locales)(simp add: ahm_lookup_def)"], ["", "subsection \\<open>@{term \"ahm_iteratei\"}\\<close>"], ["", "lemma ahm_iteratei_aux_impl:\n  assumes invar_m: \"ahm_invar_aux n m\"\n  shows \"map_iterator (ahm_iteratei_aux m) (ahm_\\<alpha>_aux m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_iterator (ahm_iteratei_aux m) (ahm_\\<alpha>_aux m)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map_iterator (ahm_iteratei_aux m) (ahm_\\<alpha>_aux m)", "obtain ms where m_eq[simp]: \"m = Array ms\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ms. m = Array ms \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases m)"], ["proof (state)\nthis:\n  m = Array ms\n\ngoal (1 subgoal):\n 1. map_iterator (ahm_iteratei_aux m) (ahm_\\<alpha>_aux m)", "from ahm_invar_distinct_fst_concatD[of n ms] invar_m"], ["proof (chain)\npicking this:\n  ahm_invar_aux n (Array ms) \\<Longrightarrow>\n  distinct (map fst (concat ms))\n  ahm_invar_aux n m", "have dist: \"distinct (map fst (concat ms))\""], ["proof (prove)\nusing this:\n  ahm_invar_aux n (Array ms) \\<Longrightarrow>\n  distinct (map fst (concat ms))\n  ahm_invar_aux n m\n\ngoal (1 subgoal):\n 1. distinct (map fst (concat ms))", "by simp"], ["proof (state)\nthis:\n  distinct (map fst (concat ms))\n\ngoal (1 subgoal):\n 1. map_iterator (ahm_iteratei_aux m) (ahm_\\<alpha>_aux m)", "show \"map_iterator (ahm_iteratei_aux m) (ahm_\\<alpha>_aux m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_iterator (ahm_iteratei_aux m) (ahm_\\<alpha>_aux m)", "using  set_iterator_foldli_correct[of \"concat ms\"] dist"], ["proof (prove)\nusing this:\n  distinct (concat ms) \\<Longrightarrow>\n  set_iterator (foldli (concat ms)) (set (concat ms))\n  distinct (map fst (concat ms))\n\ngoal (1 subgoal):\n 1. map_iterator (ahm_iteratei_aux m) (ahm_\\<alpha>_aux m)", "by (simp add: ahm_\\<alpha>_aux_conv_map_of_concat[OF invar_m[unfolded m_eq]]\n                  ahm_iteratei_aux_def map_to_set_map_of[OF dist] distinct_map)"], ["proof (state)\nthis:\n  map_iterator (ahm_iteratei_aux m) (ahm_\\<alpha>_aux m)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ahm_iteratei_correct:\n  assumes invar_hm: \"ahm_invar hm\"\n  shows \"map_iterator (ahm_iteratei hm) (ahm_\\<alpha> hm)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_iterator (ahm_iteratei hm) (ahm_\\<alpha> hm)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map_iterator (ahm_iteratei hm) (ahm_\\<alpha> hm)", "obtain A n where hm_eq [simp]: \"hm = HashMap A n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>A n. hm = HashMap A n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases hm)"], ["proof (state)\nthis:\n  hm = HashMap A n\n\ngoal (1 subgoal):\n 1. map_iterator (ahm_iteratei hm) (ahm_\\<alpha> hm)", "from ahm_iteratei_aux_impl[of n A] invar_hm"], ["proof (chain)\npicking this:\n  ahm_invar_aux n A \\<Longrightarrow>\n  map_iterator (ahm_iteratei_aux A) (ahm_\\<alpha>_aux A)\n  ahm_invar hm", "show map_it: \"map_iterator (ahm_iteratei hm) (ahm_\\<alpha> hm)\""], ["proof (prove)\nusing this:\n  ahm_invar_aux n A \\<Longrightarrow>\n  map_iterator (ahm_iteratei_aux A) (ahm_\\<alpha>_aux A)\n  ahm_invar hm\n\ngoal (1 subgoal):\n 1. map_iterator (ahm_iteratei hm) (ahm_\\<alpha> hm)", "by simp"], ["proof (state)\nthis:\n  map_iterator (ahm_iteratei hm) (ahm_\\<alpha> hm)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ahm_iteratei_aux_code [code]:\n  \"ahm_iteratei_aux a c f \\<sigma> = a_idx_it.idx_iteratei a c (\\<lambda>x. foldli x c f) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ahm_iteratei_aux a c f \\<sigma> =\n    a_idx_it.idx_iteratei a c (\\<lambda>x. foldli x c f) \\<sigma>", "proof(cases a)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       a = Array x \\<Longrightarrow>\n       ahm_iteratei_aux a c f \\<sigma> =\n       a_idx_it.idx_iteratei a c (\\<lambda>x. foldli x c f) \\<sigma>", "case [simp]: (Array xs)"], ["proof (state)\nthis:\n  a = Array xs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       a = Array x \\<Longrightarrow>\n       ahm_iteratei_aux a c f \\<sigma> =\n       a_idx_it.idx_iteratei a c (\\<lambda>x. foldli x c f) \\<sigma>", "have \"ahm_iteratei_aux a c f \\<sigma> = foldli (concat xs) c f \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ahm_iteratei_aux a c f \\<sigma> = foldli (concat xs) c f \\<sigma>", "by simp"], ["proof (state)\nthis:\n  ahm_iteratei_aux a c f \\<sigma> = foldli (concat xs) c f \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       a = Array x \\<Longrightarrow>\n       ahm_iteratei_aux a c f \\<sigma> =\n       a_idx_it.idx_iteratei a c (\\<lambda>x. foldli x c f) \\<sigma>", "also"], ["proof (state)\nthis:\n  ahm_iteratei_aux a c f \\<sigma> = foldli (concat xs) c f \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       a = Array x \\<Longrightarrow>\n       ahm_iteratei_aux a c f \\<sigma> =\n       a_idx_it.idx_iteratei a c (\\<lambda>x. foldli x c f) \\<sigma>", "have \"\\<dots> = foldli xs c (\\<lambda>x. foldli x c f) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli (concat xs) c f \\<sigma> =\n    foldli xs c (\\<lambda>x. foldli x c f) \\<sigma>", "by (simp add: foldli_concat)"], ["proof (state)\nthis:\n  foldli (concat xs) c f \\<sigma> =\n  foldli xs c (\\<lambda>x. foldli x c f) \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       a = Array x \\<Longrightarrow>\n       ahm_iteratei_aux a c f \\<sigma> =\n       a_idx_it.idx_iteratei a c (\\<lambda>x. foldli x c f) \\<sigma>", "thm a_idx_it.idx_iteratei_correct"], ["proof (state)\nthis:\n  foldli (concat xs) c f \\<sigma> =\n  foldli xs c (\\<lambda>x. foldli x c f) \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       a = Array x \\<Longrightarrow>\n       ahm_iteratei_aux a c f \\<sigma> =\n       a_idx_it.idx_iteratei a c (\\<lambda>x. foldli x c f) \\<sigma>", "also"], ["proof (state)\nthis:\n  foldli (concat xs) c f \\<sigma> =\n  foldli xs c (\\<lambda>x. foldli x c f) \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       a = Array x \\<Longrightarrow>\n       ahm_iteratei_aux a c f \\<sigma> =\n       a_idx_it.idx_iteratei a c (\\<lambda>x. foldli x c f) \\<sigma>", "have \"\\<dots> = a_idx_it.idx_iteratei a c (\\<lambda>x. foldli x c f) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldli xs c (\\<lambda>x. foldli x c f) \\<sigma> =\n    a_idx_it.idx_iteratei a c (\\<lambda>x. foldli x c f) \\<sigma>", "by (simp add: a_idx_it.idx_iteratei_correct)"], ["proof (state)\nthis:\n  foldli xs c (\\<lambda>x. foldli x c f) \\<sigma> =\n  a_idx_it.idx_iteratei a c (\\<lambda>x. foldli x c f) \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       a = Array x \\<Longrightarrow>\n       ahm_iteratei_aux a c f \\<sigma> =\n       a_idx_it.idx_iteratei a c (\\<lambda>x. foldli x c f) \\<sigma>", "finally"], ["proof (chain)\npicking this:\n  ahm_iteratei_aux a c f \\<sigma> =\n  a_idx_it.idx_iteratei a c (\\<lambda>x. foldli x c f) \\<sigma>", "show ?thesis"], ["proof (prove)\nusing this:\n  ahm_iteratei_aux a c f \\<sigma> =\n  a_idx_it.idx_iteratei a c (\\<lambda>x. foldli x c f) \\<sigma>\n\ngoal (1 subgoal):\n 1. ahm_iteratei_aux a c f \\<sigma> =\n    a_idx_it.idx_iteratei a c (\\<lambda>x. foldli x c f) \\<sigma>", "."], ["proof (state)\nthis:\n  ahm_iteratei_aux a c f \\<sigma> =\n  a_idx_it.idx_iteratei a c (\\<lambda>x. foldli x c f) \\<sigma>\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>@{term \"ahm_rehash\"}\\<close>"], ["", "lemma array_length_ahm_rehash_aux':\n  \"array_length (ahm_rehash_aux' n kv a) = array_length a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. array_length (ahm_rehash_aux' n kv a) = array_length a", "by(simp add: ahm_rehash_aux'_def Let_def)"], ["", "lemma ahm_rehash_aux'_preserves_ahm_invar_aux:\n  assumes inv: \"ahm_invar_aux n a\"\n  and fresh: \"k \\<notin> fst ` set (array_get a (bounded_hashcode_nat (array_length a) k))\"\n  shows \"ahm_invar_aux (Suc n) (ahm_rehash_aux' (array_length a) (k, v) a)\"\n  (is \"ahm_invar_aux _ ?a\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. ahm_invar_aux (Suc n) (ahm_rehash_aux' (array_length a) (k, v) a)", "proof(rule ahm_invar_auxI)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>h.\n       h < array_length\n            (ahm_rehash_aux' (array_length a) (k, v) a) \\<Longrightarrow>\n       bucket_ok (array_length (ahm_rehash_aux' (array_length a) (k, v) a))\n        h (array_get (ahm_rehash_aux' (array_length a) (k, v) a) h)\n 2. \\<And>h.\n       h < array_length\n            (ahm_rehash_aux' (array_length a) (k, v) a) \\<Longrightarrow>\n       distinct\n        (map fst (array_get (ahm_rehash_aux' (array_length a) (k, v) a) h))\n 3. Suc n =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (ahm_rehash_aux' (array_length a) (k, v) a)\n 4. 1 < array_length (ahm_rehash_aux' (array_length a) (k, v) a)", "fix h"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>h.\n       h < array_length\n            (ahm_rehash_aux' (array_length a) (k, v) a) \\<Longrightarrow>\n       bucket_ok (array_length (ahm_rehash_aux' (array_length a) (k, v) a))\n        h (array_get (ahm_rehash_aux' (array_length a) (k, v) a) h)\n 2. \\<And>h.\n       h < array_length\n            (ahm_rehash_aux' (array_length a) (k, v) a) \\<Longrightarrow>\n       distinct\n        (map fst (array_get (ahm_rehash_aux' (array_length a) (k, v) a) h))\n 3. Suc n =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (ahm_rehash_aux' (array_length a) (k, v) a)\n 4. 1 < array_length (ahm_rehash_aux' (array_length a) (k, v) a)", "assume \"h < array_length ?a\""], ["proof (state)\nthis:\n  h < array_length (ahm_rehash_aux' (array_length a) (k, v) a)\n\ngoal (4 subgoals):\n 1. \\<And>h.\n       h < array_length\n            (ahm_rehash_aux' (array_length a) (k, v) a) \\<Longrightarrow>\n       bucket_ok (array_length (ahm_rehash_aux' (array_length a) (k, v) a))\n        h (array_get (ahm_rehash_aux' (array_length a) (k, v) a) h)\n 2. \\<And>h.\n       h < array_length\n            (ahm_rehash_aux' (array_length a) (k, v) a) \\<Longrightarrow>\n       distinct\n        (map fst (array_get (ahm_rehash_aux' (array_length a) (k, v) a) h))\n 3. Suc n =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (ahm_rehash_aux' (array_length a) (k, v) a)\n 4. 1 < array_length (ahm_rehash_aux' (array_length a) (k, v) a)", "hence hlen: \"h < array_length a\""], ["proof (prove)\nusing this:\n  h < array_length (ahm_rehash_aux' (array_length a) (k, v) a)\n\ngoal (1 subgoal):\n 1. h < array_length a", "by(simp add: array_length_ahm_rehash_aux')"], ["proof (state)\nthis:\n  h < array_length a\n\ngoal (4 subgoals):\n 1. \\<And>h.\n       h < array_length\n            (ahm_rehash_aux' (array_length a) (k, v) a) \\<Longrightarrow>\n       bucket_ok (array_length (ahm_rehash_aux' (array_length a) (k, v) a))\n        h (array_get (ahm_rehash_aux' (array_length a) (k, v) a) h)\n 2. \\<And>h.\n       h < array_length\n            (ahm_rehash_aux' (array_length a) (k, v) a) \\<Longrightarrow>\n       distinct\n        (map fst (array_get (ahm_rehash_aux' (array_length a) (k, v) a) h))\n 3. Suc n =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (ahm_rehash_aux' (array_length a) (k, v) a)\n 4. 1 < array_length (ahm_rehash_aux' (array_length a) (k, v) a)", "with inv"], ["proof (chain)\npicking this:\n  ahm_invar_aux n a\n  h < array_length a", "have bucket: \"bucket_ok (array_length a) h (array_get a h)\"\n    and dist: \"distinct (map fst (array_get a h))\""], ["proof (prove)\nusing this:\n  ahm_invar_aux n a\n  h < array_length a\n\ngoal (1 subgoal):\n 1. bucket_ok (array_length a) h (array_get a h) &&&\n    distinct (map fst (array_get a h))", "by(auto elim: ahm_invar_auxE)"], ["proof (state)\nthis:\n  bucket_ok (array_length a) h (array_get a h)\n  distinct (map fst (array_get a h))\n\ngoal (4 subgoals):\n 1. \\<And>h.\n       h < array_length\n            (ahm_rehash_aux' (array_length a) (k, v) a) \\<Longrightarrow>\n       bucket_ok (array_length (ahm_rehash_aux' (array_length a) (k, v) a))\n        h (array_get (ahm_rehash_aux' (array_length a) (k, v) a) h)\n 2. \\<And>h.\n       h < array_length\n            (ahm_rehash_aux' (array_length a) (k, v) a) \\<Longrightarrow>\n       distinct\n        (map fst (array_get (ahm_rehash_aux' (array_length a) (k, v) a) h))\n 3. Suc n =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (ahm_rehash_aux' (array_length a) (k, v) a)\n 4. 1 < array_length (ahm_rehash_aux' (array_length a) (k, v) a)", "let ?h = \"bounded_hashcode_nat (array_length a) k\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>h.\n       h < array_length\n            (ahm_rehash_aux' (array_length a) (k, v) a) \\<Longrightarrow>\n       bucket_ok (array_length (ahm_rehash_aux' (array_length a) (k, v) a))\n        h (array_get (ahm_rehash_aux' (array_length a) (k, v) a) h)\n 2. \\<And>h.\n       h < array_length\n            (ahm_rehash_aux' (array_length a) (k, v) a) \\<Longrightarrow>\n       distinct\n        (map fst (array_get (ahm_rehash_aux' (array_length a) (k, v) a) h))\n 3. Suc n =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (ahm_rehash_aux' (array_length a) (k, v) a)\n 4. 1 < array_length (ahm_rehash_aux' (array_length a) (k, v) a)", "from hlen bucket"], ["proof (chain)\npicking this:\n  h < array_length a\n  bucket_ok (array_length a) h (array_get a h)", "show \"bucket_ok (array_length ?a) h (array_get ?a h)\""], ["proof (prove)\nusing this:\n  h < array_length a\n  bucket_ok (array_length a) h (array_get a h)\n\ngoal (1 subgoal):\n 1. bucket_ok (array_length (ahm_rehash_aux' (array_length a) (k, v) a)) h\n     (array_get (ahm_rehash_aux' (array_length a) (k, v) a) h)", "by(cases \"h = ?h\")(auto simp add: ahm_rehash_aux'_def Let_def array_length_ahm_rehash_aux' array_get_array_set_other dest: bucket_okD intro!: bucket_okI)"], ["proof (state)\nthis:\n  bucket_ok (array_length (ahm_rehash_aux' (array_length a) (k, v) a)) h\n   (array_get (ahm_rehash_aux' (array_length a) (k, v) a) h)\n\ngoal (3 subgoals):\n 1. \\<And>h.\n       h < array_length\n            (ahm_rehash_aux' (array_length a) (k, v) a) \\<Longrightarrow>\n       distinct\n        (map fst (array_get (ahm_rehash_aux' (array_length a) (k, v) a) h))\n 2. Suc n =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (ahm_rehash_aux' (array_length a) (k, v) a)\n 3. 1 < array_length (ahm_rehash_aux' (array_length a) (k, v) a)", "from dist hlen fresh"], ["proof (chain)\npicking this:\n  distinct (map fst (array_get a h))\n  h < array_length a\n  k \\<notin> fst `\n             set (array_get a (bounded_hashcode_nat (array_length a) k))", "show \"distinct (map fst (array_get ?a h))\""], ["proof (prove)\nusing this:\n  distinct (map fst (array_get a h))\n  h < array_length a\n  k \\<notin> fst `\n             set (array_get a (bounded_hashcode_nat (array_length a) k))\n\ngoal (1 subgoal):\n 1. distinct\n     (map fst (array_get (ahm_rehash_aux' (array_length a) (k, v) a) h))", "by(cases \"h = ?h\")(auto simp add: ahm_rehash_aux'_def Let_def array_get_array_set_other)"], ["proof (state)\nthis:\n  distinct\n   (map fst (array_get (ahm_rehash_aux' (array_length a) (k, v) a) h))\n\ngoal (2 subgoals):\n 1. Suc n =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (ahm_rehash_aux' (array_length a) (k, v) a)\n 2. 1 < array_length (ahm_rehash_aux' (array_length a) (k, v) a)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. Suc n =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (ahm_rehash_aux' (array_length a) (k, v) a)\n 2. 1 < array_length (ahm_rehash_aux' (array_length a) (k, v) a)", "let ?f = \"\\<lambda>n kvs. n + length kvs\""], ["proof (state)\ngoal (2 subgoals):\n 1. Suc n =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (ahm_rehash_aux' (array_length a) (k, v) a)\n 2. 1 < array_length (ahm_rehash_aux' (array_length a) (k, v) a)", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. Suc n =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (ahm_rehash_aux' (array_length a) (k, v) a)\n 2. 1 < array_length (ahm_rehash_aux' (array_length a) (k, v) a)", "fix n :: nat and xs :: \"('a \\<times> 'b) list list\""], ["proof (state)\ngoal (2 subgoals):\n 1. Suc n =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (ahm_rehash_aux' (array_length a) (k, v) a)\n 2. 1 < array_length (ahm_rehash_aux' (array_length a) (k, v) a)", "have \"foldl ?f n xs = n + foldl ?f 0 xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (\\<lambda>n kvs. n + length kvs) n xs =\n    n + foldl (\\<lambda>n kvs. n + length kvs) 0 xs", "by(induct xs arbitrary:  rule: rev_induct) simp_all"], ["proof (state)\nthis:\n  foldl (\\<lambda>n kvs. n + length kvs) n xs =\n  n + foldl (\\<lambda>n kvs. n + length kvs) 0 xs\n\ngoal (2 subgoals):\n 1. Suc n =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (ahm_rehash_aux' (array_length a) (k, v) a)\n 2. 1 < array_length (ahm_rehash_aux' (array_length a) (k, v) a)", "}"], ["proof (state)\nthis:\n  foldl (\\<lambda>n kvs. n + length kvs) ?na3 ?xs3 =\n  ?na3 + foldl (\\<lambda>n kvs. n + length kvs) 0 ?xs3\n\ngoal (2 subgoals):\n 1. Suc n =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (ahm_rehash_aux' (array_length a) (k, v) a)\n 2. 1 < array_length (ahm_rehash_aux' (array_length a) (k, v) a)", "note fold = this"], ["proof (state)\nthis:\n  foldl (\\<lambda>n kvs. n + length kvs) ?na3 ?xs3 =\n  ?na3 + foldl (\\<lambda>n kvs. n + length kvs) 0 ?xs3\n\ngoal (2 subgoals):\n 1. Suc n =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (ahm_rehash_aux' (array_length a) (k, v) a)\n 2. 1 < array_length (ahm_rehash_aux' (array_length a) (k, v) a)", "let ?h = \"bounded_hashcode_nat (array_length a) k\""], ["proof (state)\ngoal (2 subgoals):\n 1. Suc n =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (ahm_rehash_aux' (array_length a) (k, v) a)\n 2. 1 < array_length (ahm_rehash_aux' (array_length a) (k, v) a)", "obtain xs where a [simp]: \"a = Array xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs. a = Array xs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases a)"], ["proof (state)\nthis:\n  a = Array xs\n\ngoal (2 subgoals):\n 1. Suc n =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (ahm_rehash_aux' (array_length a) (k, v) a)\n 2. 1 < array_length (ahm_rehash_aux' (array_length a) (k, v) a)", "from inv"], ["proof (chain)\npicking this:\n  ahm_invar_aux n a", "have [simp]: \"bounded_hashcode_nat (length xs) k < length xs\""], ["proof (prove)\nusing this:\n  ahm_invar_aux n a\n\ngoal (1 subgoal):\n 1. bounded_hashcode_nat (length xs) k < length xs", "by(simp add: ahm_invar_aux_def bounded_hashcode_nat_bounds)"], ["proof (state)\nthis:\n  bounded_hashcode_nat (length xs) k < length xs\n\ngoal (2 subgoals):\n 1. Suc n =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (ahm_rehash_aux' (array_length a) (k, v) a)\n 2. 1 < array_length (ahm_rehash_aux' (array_length a) (k, v) a)", "have xs: \"xs = take ?h xs @ (xs ! ?h) # drop (Suc ?h) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs =\n    take (bounded_hashcode_nat (array_length a) k) xs @\n    xs ! bounded_hashcode_nat (array_length a) k #\n    drop (Suc (bounded_hashcode_nat (array_length a) k)) xs", "by(simp add: Cons_nth_drop_Suc)"], ["proof (state)\nthis:\n  xs =\n  take (bounded_hashcode_nat (array_length a) k) xs @\n  xs ! bounded_hashcode_nat (array_length a) k #\n  drop (Suc (bounded_hashcode_nat (array_length a) k)) xs\n\ngoal (2 subgoals):\n 1. Suc n =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (ahm_rehash_aux' (array_length a) (k, v) a)\n 2. 1 < array_length (ahm_rehash_aux' (array_length a) (k, v) a)", "from inv"], ["proof (chain)\npicking this:\n  ahm_invar_aux n a", "have \"n = array_foldl (\\<lambda>_ n kvs. n + length kvs) 0 a\""], ["proof (prove)\nusing this:\n  ahm_invar_aux n a\n\ngoal (1 subgoal):\n 1. n = array_foldl (\\<lambda>_ n kvs. n + length kvs) 0 a", "by(auto elim: ahm_invar_auxE)"], ["proof (state)\nthis:\n  n = array_foldl (\\<lambda>_ n kvs. n + length kvs) 0 a\n\ngoal (2 subgoals):\n 1. Suc n =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (ahm_rehash_aux' (array_length a) (k, v) a)\n 2. 1 < array_length (ahm_rehash_aux' (array_length a) (k, v) a)", "hence \"n = foldl ?f 0 (take ?h xs) + length (xs ! ?h) + foldl ?f 0 (drop (Suc ?h) xs)\""], ["proof (prove)\nusing this:\n  n = array_foldl (\\<lambda>_ n kvs. n + length kvs) 0 a\n\ngoal (1 subgoal):\n 1. n =\n    foldl (\\<lambda>n kvs. n + length kvs) 0\n     (take (bounded_hashcode_nat (array_length a) k) xs) +\n    length (xs ! bounded_hashcode_nat (array_length a) k) +\n    foldl (\\<lambda>n kvs. n + length kvs) 0\n     (drop (Suc (bounded_hashcode_nat (array_length a) k)) xs)", "by(simp add: array_foldl_foldl)(subst xs, simp, subst (1 2 3 4) fold, simp)"], ["proof (state)\nthis:\n  n =\n  foldl (\\<lambda>n kvs. n + length kvs) 0\n   (take (bounded_hashcode_nat (array_length a) k) xs) +\n  length (xs ! bounded_hashcode_nat (array_length a) k) +\n  foldl (\\<lambda>n kvs. n + length kvs) 0\n   (drop (Suc (bounded_hashcode_nat (array_length a) k)) xs)\n\ngoal (2 subgoals):\n 1. Suc n =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (ahm_rehash_aux' (array_length a) (k, v) a)\n 2. 1 < array_length (ahm_rehash_aux' (array_length a) (k, v) a)", "thus \"Suc n = array_foldl (\\<lambda>_ n kvs. n + length kvs) 0 ?a\""], ["proof (prove)\nusing this:\n  n =\n  foldl (\\<lambda>n kvs. n + length kvs) 0\n   (take (bounded_hashcode_nat (array_length a) k) xs) +\n  length (xs ! bounded_hashcode_nat (array_length a) k) +\n  foldl (\\<lambda>n kvs. n + length kvs) 0\n   (drop (Suc (bounded_hashcode_nat (array_length a) k)) xs)\n\ngoal (1 subgoal):\n 1. Suc n =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (ahm_rehash_aux' (array_length a) (k, v) a)", "by(simp add: ahm_rehash_aux'_def Let_def array_foldl_foldl foldl_list_update)(subst (1 2 3 4) fold, simp)"], ["proof (state)\nthis:\n  Suc n =\n  array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n   (ahm_rehash_aux' (array_length a) (k, v) a)\n\ngoal (1 subgoal):\n 1. 1 < array_length (ahm_rehash_aux' (array_length a) (k, v) a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 1 < array_length (ahm_rehash_aux' (array_length a) (k, v) a)", "from inv"], ["proof (chain)\npicking this:\n  ahm_invar_aux n a", "have \"1 < array_length a\""], ["proof (prove)\nusing this:\n  ahm_invar_aux n a\n\ngoal (1 subgoal):\n 1. 1 < array_length a", "by(auto elim: ahm_invar_auxE)"], ["proof (state)\nthis:\n  1 < array_length a\n\ngoal (1 subgoal):\n 1. 1 < array_length (ahm_rehash_aux' (array_length a) (k, v) a)", "thus \"1 < array_length ?a\""], ["proof (prove)\nusing this:\n  1 < array_length a\n\ngoal (1 subgoal):\n 1. 1 < array_length (ahm_rehash_aux' (array_length a) (k, v) a)", "by(simp add: array_length_ahm_rehash_aux')"], ["proof (state)\nthis:\n  1 < array_length (ahm_rehash_aux' (array_length a) (k, v) a)\n\ngoal:\nNo subgoals!", "qed"], ["", "declare [[coercion_enabled = false]]"], ["", "lemma ahm_rehash_aux_correct:\n  fixes a :: \"(('key :: hashable) \\<times> 'val) list array\"\n  assumes inv: \"ahm_invar_aux n a\"\n  and \"sz > 1\"\n  shows \"ahm_invar_aux n (ahm_rehash_aux a sz)\" (is \"?thesis1\")\n  and \"ahm_\\<alpha>_aux (ahm_rehash_aux a sz) = ahm_\\<alpha>_aux a\" (is \"?thesis2\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. ahm_invar_aux n (ahm_rehash_aux a sz) &&&\n    ahm_\\<alpha>_aux (ahm_rehash_aux a sz) = ahm_\\<alpha>_aux a", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. ahm_invar_aux n (ahm_rehash_aux a sz)\n 2. ahm_\\<alpha>_aux (ahm_rehash_aux a sz) = ahm_\\<alpha>_aux a", "(*interpret ahm: map_iterator \"ahm_\\<alpha>_aux\" \"ahm_invar_aux n\" \"ahm_iteratei_aux\"\n    by(rule ahm_iteratei_aux_impl)*)"], ["proof (state)\ngoal (2 subgoals):\n 1. ahm_invar_aux n (ahm_rehash_aux a sz)\n 2. ahm_\\<alpha>_aux (ahm_rehash_aux a sz) = ahm_\\<alpha>_aux a", "let ?a = \"ahm_rehash_aux a sz\""], ["proof (state)\ngoal (2 subgoals):\n 1. ahm_invar_aux n (ahm_rehash_aux a sz)\n 2. ahm_\\<alpha>_aux (ahm_rehash_aux a sz) = ahm_\\<alpha>_aux a", "let ?I = \"\\<lambda>it a'. ahm_invar_aux (n - card it) a' \\<and> array_length a' = sz \\<and> (\\<forall>k. if k \\<in> it then ahm_\\<alpha>_aux a' k = None else ahm_\\<alpha>_aux a' k = ahm_\\<alpha>_aux a k)\""], ["proof (state)\ngoal (2 subgoals):\n 1. ahm_invar_aux n (ahm_rehash_aux a sz)\n 2. ahm_\\<alpha>_aux (ahm_rehash_aux a sz) = ahm_\\<alpha>_aux a", "have \"?I {} ?a \\<or> (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a). it \\<noteq> {} \\<and> \\<not> True \\<and> ?I it ?a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ahm_invar_aux (n - card {}) (ahm_rehash_aux a sz) \\<and>\n    array_length (ahm_rehash_aux a sz) = sz \\<and>\n    (\\<forall>k.\n        if k \\<in> {} then ahm_\\<alpha>_aux (ahm_rehash_aux a sz) k = None\n        else ahm_\\<alpha>_aux (ahm_rehash_aux a sz) k =\n             ahm_\\<alpha>_aux a k) \\<or>\n    (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n        it \\<noteq> {} \\<and>\n        \\<not> True \\<and>\n        ahm_invar_aux (n - card it) (ahm_rehash_aux a sz) \\<and>\n        array_length (ahm_rehash_aux a sz) = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it\n            then ahm_\\<alpha>_aux (ahm_rehash_aux a sz) k = None\n            else ahm_\\<alpha>_aux (ahm_rehash_aux a sz) k =\n                 ahm_\\<alpha>_aux a k))", "unfolding ahm_rehash_aux_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ahm_invar_aux (n - card {})\n     (ahm_iteratei_aux a (\\<lambda>x. True) (ahm_rehash_aux' sz)\n       (new_array [] sz)) \\<and>\n    array_length\n     (ahm_iteratei_aux a (\\<lambda>x. True) (ahm_rehash_aux' sz)\n       (new_array [] sz)) =\n    sz \\<and>\n    (\\<forall>k.\n        if k \\<in> {}\n        then ahm_\\<alpha>_aux\n              (ahm_iteratei_aux a (\\<lambda>x. True) (ahm_rehash_aux' sz)\n                (new_array [] sz))\n              k =\n             None\n        else ahm_\\<alpha>_aux\n              (ahm_iteratei_aux a (\\<lambda>x. True) (ahm_rehash_aux' sz)\n                (new_array [] sz))\n              k =\n             ahm_\\<alpha>_aux a k) \\<or>\n    (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n        it \\<noteq> {} \\<and>\n        \\<not> True \\<and>\n        ahm_invar_aux (n - card it)\n         (ahm_iteratei_aux a (\\<lambda>x. True) (ahm_rehash_aux' sz)\n           (new_array [] sz)) \\<and>\n        array_length\n         (ahm_iteratei_aux a (\\<lambda>x. True) (ahm_rehash_aux' sz)\n           (new_array [] sz)) =\n        sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it\n            then ahm_\\<alpha>_aux\n                  (ahm_iteratei_aux a (\\<lambda>x. True)\n                    (ahm_rehash_aux' sz) (new_array [] sz))\n                  k =\n                 None\n            else ahm_\\<alpha>_aux\n                  (ahm_iteratei_aux a (\\<lambda>x. True)\n                    (ahm_rehash_aux' sz) (new_array [] sz))\n                  k =\n                 ahm_\\<alpha>_aux a k))", "proof (rule map_iterator_rule_P[OF ahm_iteratei_aux_impl[OF inv], where\n      c = \"\\<lambda>_. True\" and f=\"ahm_rehash_aux' sz\" and ?\\<sigma>0.0 = \"new_array [] sz\"\n      and I=\"?I\"]\n    )"], ["proof (state)\ngoal (4 subgoals):\n 1. ahm_invar_aux (n - card (dom (ahm_\\<alpha>_aux a)))\n     (new_array [] sz) \\<and>\n    array_length (new_array [] sz) = sz \\<and>\n    (\\<forall>k.\n        if k \\<in> dom (ahm_\\<alpha>_aux a)\n        then ahm_\\<alpha>_aux (new_array [] sz) k = None\n        else ahm_\\<alpha>_aux (new_array [] sz) k = ahm_\\<alpha>_aux a k)\n 2. \\<And>k v it \\<sigma>.\n       \\<lbrakk>True; k \\<in> it; ahm_\\<alpha>_aux a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux a);\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card (it - {k}))\n                          (ahm_rehash_aux' sz (k, v) \\<sigma>) \\<and>\n                         array_length (ahm_rehash_aux' sz (k, v) \\<sigma>) =\n                         sz \\<and>\n                         (\\<forall>ka.\n                             if ka \\<in> it - {k}\n                             then ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  None\n                             else ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  ahm_\\<alpha>_aux a ka)\n 3. \\<And>\\<sigma>.\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k =\n                ahm_\\<alpha>_aux a k) \\<Longrightarrow>\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k) \\<or>\n       (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n           it \\<noteq> {} \\<and>\n           \\<not> True \\<and>\n           ahm_invar_aux (n - card it) \\<sigma> \\<and>\n           array_length \\<sigma> = sz \\<and>\n           (\\<forall>k.\n               if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n               else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k))\n 4. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom (ahm_\\<alpha>_aux a); it \\<noteq> {};\n        \\<not> True;\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n                         array_length \\<sigma> = sz \\<and>\n                         (\\<forall>k.\n                             if k \\<in> {}\n                             then ahm_\\<alpha>_aux \\<sigma> k = None\n                             else ahm_\\<alpha>_aux \\<sigma> k =\n                                  ahm_\\<alpha>_aux a k) \\<or>\n                         (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n                             it \\<noteq> {} \\<and>\n                             \\<not> True \\<and>\n                             ahm_invar_aux (n - card it) \\<sigma> \\<and>\n                             array_length \\<sigma> = sz \\<and>\n                             (\\<forall>k.\n                                 if k \\<in> it\n                                 then ahm_\\<alpha>_aux \\<sigma> k = None\n                                 else ahm_\\<alpha>_aux \\<sigma> k =\nahm_\\<alpha>_aux a k))", "from inv"], ["proof (chain)\npicking this:\n  ahm_invar_aux n a", "have \"card (dom (ahm_\\<alpha>_aux a)) = n\""], ["proof (prove)\nusing this:\n  ahm_invar_aux n a\n\ngoal (1 subgoal):\n 1. card (dom (ahm_\\<alpha>_aux a)) = n", "by(rule ahm_invar_aux_card_dom_ahm_\\<alpha>_auxD)"], ["proof (state)\nthis:\n  card (dom (ahm_\\<alpha>_aux a)) = n\n\ngoal (4 subgoals):\n 1. ahm_invar_aux (n - card (dom (ahm_\\<alpha>_aux a)))\n     (new_array [] sz) \\<and>\n    array_length (new_array [] sz) = sz \\<and>\n    (\\<forall>k.\n        if k \\<in> dom (ahm_\\<alpha>_aux a)\n        then ahm_\\<alpha>_aux (new_array [] sz) k = None\n        else ahm_\\<alpha>_aux (new_array [] sz) k = ahm_\\<alpha>_aux a k)\n 2. \\<And>k v it \\<sigma>.\n       \\<lbrakk>True; k \\<in> it; ahm_\\<alpha>_aux a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux a);\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card (it - {k}))\n                          (ahm_rehash_aux' sz (k, v) \\<sigma>) \\<and>\n                         array_length (ahm_rehash_aux' sz (k, v) \\<sigma>) =\n                         sz \\<and>\n                         (\\<forall>ka.\n                             if ka \\<in> it - {k}\n                             then ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  None\n                             else ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  ahm_\\<alpha>_aux a ka)\n 3. \\<And>\\<sigma>.\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k =\n                ahm_\\<alpha>_aux a k) \\<Longrightarrow>\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k) \\<or>\n       (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n           it \\<noteq> {} \\<and>\n           \\<not> True \\<and>\n           ahm_invar_aux (n - card it) \\<sigma> \\<and>\n           array_length \\<sigma> = sz \\<and>\n           (\\<forall>k.\n               if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n               else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k))\n 4. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom (ahm_\\<alpha>_aux a); it \\<noteq> {};\n        \\<not> True;\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n                         array_length \\<sigma> = sz \\<and>\n                         (\\<forall>k.\n                             if k \\<in> {}\n                             then ahm_\\<alpha>_aux \\<sigma> k = None\n                             else ahm_\\<alpha>_aux \\<sigma> k =\n                                  ahm_\\<alpha>_aux a k) \\<or>\n                         (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n                             it \\<noteq> {} \\<and>\n                             \\<not> True \\<and>\n                             ahm_invar_aux (n - card it) \\<sigma> \\<and>\n                             array_length \\<sigma> = sz \\<and>\n                             (\\<forall>k.\n                                 if k \\<in> it\n                                 then ahm_\\<alpha>_aux \\<sigma> k = None\n                                 else ahm_\\<alpha>_aux \\<sigma> k =\nahm_\\<alpha>_aux a k))", "moreover"], ["proof (state)\nthis:\n  card (dom (ahm_\\<alpha>_aux a)) = n\n\ngoal (4 subgoals):\n 1. ahm_invar_aux (n - card (dom (ahm_\\<alpha>_aux a)))\n     (new_array [] sz) \\<and>\n    array_length (new_array [] sz) = sz \\<and>\n    (\\<forall>k.\n        if k \\<in> dom (ahm_\\<alpha>_aux a)\n        then ahm_\\<alpha>_aux (new_array [] sz) k = None\n        else ahm_\\<alpha>_aux (new_array [] sz) k = ahm_\\<alpha>_aux a k)\n 2. \\<And>k v it \\<sigma>.\n       \\<lbrakk>True; k \\<in> it; ahm_\\<alpha>_aux a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux a);\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card (it - {k}))\n                          (ahm_rehash_aux' sz (k, v) \\<sigma>) \\<and>\n                         array_length (ahm_rehash_aux' sz (k, v) \\<sigma>) =\n                         sz \\<and>\n                         (\\<forall>ka.\n                             if ka \\<in> it - {k}\n                             then ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  None\n                             else ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  ahm_\\<alpha>_aux a ka)\n 3. \\<And>\\<sigma>.\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k =\n                ahm_\\<alpha>_aux a k) \\<Longrightarrow>\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k) \\<or>\n       (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n           it \\<noteq> {} \\<and>\n           \\<not> True \\<and>\n           ahm_invar_aux (n - card it) \\<sigma> \\<and>\n           array_length \\<sigma> = sz \\<and>\n           (\\<forall>k.\n               if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n               else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k))\n 4. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom (ahm_\\<alpha>_aux a); it \\<noteq> {};\n        \\<not> True;\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n                         array_length \\<sigma> = sz \\<and>\n                         (\\<forall>k.\n                             if k \\<in> {}\n                             then ahm_\\<alpha>_aux \\<sigma> k = None\n                             else ahm_\\<alpha>_aux \\<sigma> k =\n                                  ahm_\\<alpha>_aux a k) \\<or>\n                         (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n                             it \\<noteq> {} \\<and>\n                             \\<not> True \\<and>\n                             ahm_invar_aux (n - card it) \\<sigma> \\<and>\n                             array_length \\<sigma> = sz \\<and>\n                             (\\<forall>k.\n                                 if k \\<in> it\n                                 then ahm_\\<alpha>_aux \\<sigma> k = None\n                                 else ahm_\\<alpha>_aux \\<sigma> k =\nahm_\\<alpha>_aux a k))", "from \\<open>1 < sz\\<close>"], ["proof (chain)\npicking this:\n  1 < sz", "have \"ahm_invar_aux 0 (new_array ([] :: ('key \\<times> 'val) list) sz)\""], ["proof (prove)\nusing this:\n  1 < sz\n\ngoal (1 subgoal):\n 1. ahm_invar_aux 0 (new_array [] sz)", "by(rule ahm_invar_aux_new_array)"], ["proof (state)\nthis:\n  ahm_invar_aux 0 (new_array [] sz)\n\ngoal (4 subgoals):\n 1. ahm_invar_aux (n - card (dom (ahm_\\<alpha>_aux a)))\n     (new_array [] sz) \\<and>\n    array_length (new_array [] sz) = sz \\<and>\n    (\\<forall>k.\n        if k \\<in> dom (ahm_\\<alpha>_aux a)\n        then ahm_\\<alpha>_aux (new_array [] sz) k = None\n        else ahm_\\<alpha>_aux (new_array [] sz) k = ahm_\\<alpha>_aux a k)\n 2. \\<And>k v it \\<sigma>.\n       \\<lbrakk>True; k \\<in> it; ahm_\\<alpha>_aux a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux a);\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card (it - {k}))\n                          (ahm_rehash_aux' sz (k, v) \\<sigma>) \\<and>\n                         array_length (ahm_rehash_aux' sz (k, v) \\<sigma>) =\n                         sz \\<and>\n                         (\\<forall>ka.\n                             if ka \\<in> it - {k}\n                             then ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  None\n                             else ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  ahm_\\<alpha>_aux a ka)\n 3. \\<And>\\<sigma>.\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k =\n                ahm_\\<alpha>_aux a k) \\<Longrightarrow>\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k) \\<or>\n       (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n           it \\<noteq> {} \\<and>\n           \\<not> True \\<and>\n           ahm_invar_aux (n - card it) \\<sigma> \\<and>\n           array_length \\<sigma> = sz \\<and>\n           (\\<forall>k.\n               if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n               else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k))\n 4. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom (ahm_\\<alpha>_aux a); it \\<noteq> {};\n        \\<not> True;\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n                         array_length \\<sigma> = sz \\<and>\n                         (\\<forall>k.\n                             if k \\<in> {}\n                             then ahm_\\<alpha>_aux \\<sigma> k = None\n                             else ahm_\\<alpha>_aux \\<sigma> k =\n                                  ahm_\\<alpha>_aux a k) \\<or>\n                         (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n                             it \\<noteq> {} \\<and>\n                             \\<not> True \\<and>\n                             ahm_invar_aux (n - card it) \\<sigma> \\<and>\n                             array_length \\<sigma> = sz \\<and>\n                             (\\<forall>k.\n                                 if k \\<in> it\n                                 then ahm_\\<alpha>_aux \\<sigma> k = None\n                                 else ahm_\\<alpha>_aux \\<sigma> k =\nahm_\\<alpha>_aux a k))", "moreover"], ["proof (state)\nthis:\n  ahm_invar_aux 0 (new_array [] sz)\n\ngoal (4 subgoals):\n 1. ahm_invar_aux (n - card (dom (ahm_\\<alpha>_aux a)))\n     (new_array [] sz) \\<and>\n    array_length (new_array [] sz) = sz \\<and>\n    (\\<forall>k.\n        if k \\<in> dom (ahm_\\<alpha>_aux a)\n        then ahm_\\<alpha>_aux (new_array [] sz) k = None\n        else ahm_\\<alpha>_aux (new_array [] sz) k = ahm_\\<alpha>_aux a k)\n 2. \\<And>k v it \\<sigma>.\n       \\<lbrakk>True; k \\<in> it; ahm_\\<alpha>_aux a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux a);\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card (it - {k}))\n                          (ahm_rehash_aux' sz (k, v) \\<sigma>) \\<and>\n                         array_length (ahm_rehash_aux' sz (k, v) \\<sigma>) =\n                         sz \\<and>\n                         (\\<forall>ka.\n                             if ka \\<in> it - {k}\n                             then ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  None\n                             else ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  ahm_\\<alpha>_aux a ka)\n 3. \\<And>\\<sigma>.\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k =\n                ahm_\\<alpha>_aux a k) \\<Longrightarrow>\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k) \\<or>\n       (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n           it \\<noteq> {} \\<and>\n           \\<not> True \\<and>\n           ahm_invar_aux (n - card it) \\<sigma> \\<and>\n           array_length \\<sigma> = sz \\<and>\n           (\\<forall>k.\n               if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n               else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k))\n 4. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom (ahm_\\<alpha>_aux a); it \\<noteq> {};\n        \\<not> True;\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n                         array_length \\<sigma> = sz \\<and>\n                         (\\<forall>k.\n                             if k \\<in> {}\n                             then ahm_\\<alpha>_aux \\<sigma> k = None\n                             else ahm_\\<alpha>_aux \\<sigma> k =\n                                  ahm_\\<alpha>_aux a k) \\<or>\n                         (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n                             it \\<noteq> {} \\<and>\n                             \\<not> True \\<and>\n                             ahm_invar_aux (n - card it) \\<sigma> \\<and>\n                             array_length \\<sigma> = sz \\<and>\n                             (\\<forall>k.\n                                 if k \\<in> it\n                                 then ahm_\\<alpha>_aux \\<sigma> k = None\n                                 else ahm_\\<alpha>_aux \\<sigma> k =\nahm_\\<alpha>_aux a k))", "{"], ["proof (state)\nthis:\n  ahm_invar_aux 0 (new_array [] sz)\n\ngoal (4 subgoals):\n 1. ahm_invar_aux (n - card (dom (ahm_\\<alpha>_aux a)))\n     (new_array [] sz) \\<and>\n    array_length (new_array [] sz) = sz \\<and>\n    (\\<forall>k.\n        if k \\<in> dom (ahm_\\<alpha>_aux a)\n        then ahm_\\<alpha>_aux (new_array [] sz) k = None\n        else ahm_\\<alpha>_aux (new_array [] sz) k = ahm_\\<alpha>_aux a k)\n 2. \\<And>k v it \\<sigma>.\n       \\<lbrakk>True; k \\<in> it; ahm_\\<alpha>_aux a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux a);\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card (it - {k}))\n                          (ahm_rehash_aux' sz (k, v) \\<sigma>) \\<and>\n                         array_length (ahm_rehash_aux' sz (k, v) \\<sigma>) =\n                         sz \\<and>\n                         (\\<forall>ka.\n                             if ka \\<in> it - {k}\n                             then ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  None\n                             else ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  ahm_\\<alpha>_aux a ka)\n 3. \\<And>\\<sigma>.\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k =\n                ahm_\\<alpha>_aux a k) \\<Longrightarrow>\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k) \\<or>\n       (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n           it \\<noteq> {} \\<and>\n           \\<not> True \\<and>\n           ahm_invar_aux (n - card it) \\<sigma> \\<and>\n           array_length \\<sigma> = sz \\<and>\n           (\\<forall>k.\n               if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n               else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k))\n 4. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom (ahm_\\<alpha>_aux a); it \\<noteq> {};\n        \\<not> True;\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n                         array_length \\<sigma> = sz \\<and>\n                         (\\<forall>k.\n                             if k \\<in> {}\n                             then ahm_\\<alpha>_aux \\<sigma> k = None\n                             else ahm_\\<alpha>_aux \\<sigma> k =\n                                  ahm_\\<alpha>_aux a k) \\<or>\n                         (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n                             it \\<noteq> {} \\<and>\n                             \\<not> True \\<and>\n                             ahm_invar_aux (n - card it) \\<sigma> \\<and>\n                             array_length \\<sigma> = sz \\<and>\n                             (\\<forall>k.\n                                 if k \\<in> it\n                                 then ahm_\\<alpha>_aux \\<sigma> k = None\n                                 else ahm_\\<alpha>_aux \\<sigma> k =\nahm_\\<alpha>_aux a k))", "fix k"], ["proof (state)\ngoal (4 subgoals):\n 1. ahm_invar_aux (n - card (dom (ahm_\\<alpha>_aux a)))\n     (new_array [] sz) \\<and>\n    array_length (new_array [] sz) = sz \\<and>\n    (\\<forall>k.\n        if k \\<in> dom (ahm_\\<alpha>_aux a)\n        then ahm_\\<alpha>_aux (new_array [] sz) k = None\n        else ahm_\\<alpha>_aux (new_array [] sz) k = ahm_\\<alpha>_aux a k)\n 2. \\<And>k v it \\<sigma>.\n       \\<lbrakk>True; k \\<in> it; ahm_\\<alpha>_aux a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux a);\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card (it - {k}))\n                          (ahm_rehash_aux' sz (k, v) \\<sigma>) \\<and>\n                         array_length (ahm_rehash_aux' sz (k, v) \\<sigma>) =\n                         sz \\<and>\n                         (\\<forall>ka.\n                             if ka \\<in> it - {k}\n                             then ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  None\n                             else ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  ahm_\\<alpha>_aux a ka)\n 3. \\<And>\\<sigma>.\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k =\n                ahm_\\<alpha>_aux a k) \\<Longrightarrow>\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k) \\<or>\n       (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n           it \\<noteq> {} \\<and>\n           \\<not> True \\<and>\n           ahm_invar_aux (n - card it) \\<sigma> \\<and>\n           array_length \\<sigma> = sz \\<and>\n           (\\<forall>k.\n               if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n               else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k))\n 4. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom (ahm_\\<alpha>_aux a); it \\<noteq> {};\n        \\<not> True;\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n                         array_length \\<sigma> = sz \\<and>\n                         (\\<forall>k.\n                             if k \\<in> {}\n                             then ahm_\\<alpha>_aux \\<sigma> k = None\n                             else ahm_\\<alpha>_aux \\<sigma> k =\n                                  ahm_\\<alpha>_aux a k) \\<or>\n                         (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n                             it \\<noteq> {} \\<and>\n                             \\<not> True \\<and>\n                             ahm_invar_aux (n - card it) \\<sigma> \\<and>\n                             array_length \\<sigma> = sz \\<and>\n                             (\\<forall>k.\n                                 if k \\<in> it\n                                 then ahm_\\<alpha>_aux \\<sigma> k = None\n                                 else ahm_\\<alpha>_aux \\<sigma> k =\nahm_\\<alpha>_aux a k))", "assume \"k \\<notin> dom (ahm_\\<alpha>_aux a)\""], ["proof (state)\nthis:\n  k \\<notin> dom (ahm_\\<alpha>_aux a)\n\ngoal (4 subgoals):\n 1. ahm_invar_aux (n - card (dom (ahm_\\<alpha>_aux a)))\n     (new_array [] sz) \\<and>\n    array_length (new_array [] sz) = sz \\<and>\n    (\\<forall>k.\n        if k \\<in> dom (ahm_\\<alpha>_aux a)\n        then ahm_\\<alpha>_aux (new_array [] sz) k = None\n        else ahm_\\<alpha>_aux (new_array [] sz) k = ahm_\\<alpha>_aux a k)\n 2. \\<And>k v it \\<sigma>.\n       \\<lbrakk>True; k \\<in> it; ahm_\\<alpha>_aux a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux a);\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card (it - {k}))\n                          (ahm_rehash_aux' sz (k, v) \\<sigma>) \\<and>\n                         array_length (ahm_rehash_aux' sz (k, v) \\<sigma>) =\n                         sz \\<and>\n                         (\\<forall>ka.\n                             if ka \\<in> it - {k}\n                             then ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  None\n                             else ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  ahm_\\<alpha>_aux a ka)\n 3. \\<And>\\<sigma>.\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k =\n                ahm_\\<alpha>_aux a k) \\<Longrightarrow>\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k) \\<or>\n       (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n           it \\<noteq> {} \\<and>\n           \\<not> True \\<and>\n           ahm_invar_aux (n - card it) \\<sigma> \\<and>\n           array_length \\<sigma> = sz \\<and>\n           (\\<forall>k.\n               if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n               else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k))\n 4. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom (ahm_\\<alpha>_aux a); it \\<noteq> {};\n        \\<not> True;\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n                         array_length \\<sigma> = sz \\<and>\n                         (\\<forall>k.\n                             if k \\<in> {}\n                             then ahm_\\<alpha>_aux \\<sigma> k = None\n                             else ahm_\\<alpha>_aux \\<sigma> k =\n                                  ahm_\\<alpha>_aux a k) \\<or>\n                         (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n                             it \\<noteq> {} \\<and>\n                             \\<not> True \\<and>\n                             ahm_invar_aux (n - card it) \\<sigma> \\<and>\n                             array_length \\<sigma> = sz \\<and>\n                             (\\<forall>k.\n                                 if k \\<in> it\n                                 then ahm_\\<alpha>_aux \\<sigma> k = None\n                                 else ahm_\\<alpha>_aux \\<sigma> k =\nahm_\\<alpha>_aux a k))", "hence \"ahm_\\<alpha>_aux a k = None\""], ["proof (prove)\nusing this:\n  k \\<notin> dom (ahm_\\<alpha>_aux a)\n\ngoal (1 subgoal):\n 1. ahm_\\<alpha>_aux a k = None", "by auto"], ["proof (state)\nthis:\n  ahm_\\<alpha>_aux a k = None\n\ngoal (4 subgoals):\n 1. ahm_invar_aux (n - card (dom (ahm_\\<alpha>_aux a)))\n     (new_array [] sz) \\<and>\n    array_length (new_array [] sz) = sz \\<and>\n    (\\<forall>k.\n        if k \\<in> dom (ahm_\\<alpha>_aux a)\n        then ahm_\\<alpha>_aux (new_array [] sz) k = None\n        else ahm_\\<alpha>_aux (new_array [] sz) k = ahm_\\<alpha>_aux a k)\n 2. \\<And>k v it \\<sigma>.\n       \\<lbrakk>True; k \\<in> it; ahm_\\<alpha>_aux a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux a);\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card (it - {k}))\n                          (ahm_rehash_aux' sz (k, v) \\<sigma>) \\<and>\n                         array_length (ahm_rehash_aux' sz (k, v) \\<sigma>) =\n                         sz \\<and>\n                         (\\<forall>ka.\n                             if ka \\<in> it - {k}\n                             then ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  None\n                             else ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  ahm_\\<alpha>_aux a ka)\n 3. \\<And>\\<sigma>.\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k =\n                ahm_\\<alpha>_aux a k) \\<Longrightarrow>\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k) \\<or>\n       (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n           it \\<noteq> {} \\<and>\n           \\<not> True \\<and>\n           ahm_invar_aux (n - card it) \\<sigma> \\<and>\n           array_length \\<sigma> = sz \\<and>\n           (\\<forall>k.\n               if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n               else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k))\n 4. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom (ahm_\\<alpha>_aux a); it \\<noteq> {};\n        \\<not> True;\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n                         array_length \\<sigma> = sz \\<and>\n                         (\\<forall>k.\n                             if k \\<in> {}\n                             then ahm_\\<alpha>_aux \\<sigma> k = None\n                             else ahm_\\<alpha>_aux \\<sigma> k =\n                                  ahm_\\<alpha>_aux a k) \\<or>\n                         (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n                             it \\<noteq> {} \\<and>\n                             \\<not> True \\<and>\n                             ahm_invar_aux (n - card it) \\<sigma> \\<and>\n                             array_length \\<sigma> = sz \\<and>\n                             (\\<forall>k.\n                                 if k \\<in> it\n                                 then ahm_\\<alpha>_aux \\<sigma> k = None\n                                 else ahm_\\<alpha>_aux \\<sigma> k =\nahm_\\<alpha>_aux a k))", "moreover"], ["proof (state)\nthis:\n  ahm_\\<alpha>_aux a k = None\n\ngoal (4 subgoals):\n 1. ahm_invar_aux (n - card (dom (ahm_\\<alpha>_aux a)))\n     (new_array [] sz) \\<and>\n    array_length (new_array [] sz) = sz \\<and>\n    (\\<forall>k.\n        if k \\<in> dom (ahm_\\<alpha>_aux a)\n        then ahm_\\<alpha>_aux (new_array [] sz) k = None\n        else ahm_\\<alpha>_aux (new_array [] sz) k = ahm_\\<alpha>_aux a k)\n 2. \\<And>k v it \\<sigma>.\n       \\<lbrakk>True; k \\<in> it; ahm_\\<alpha>_aux a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux a);\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card (it - {k}))\n                          (ahm_rehash_aux' sz (k, v) \\<sigma>) \\<and>\n                         array_length (ahm_rehash_aux' sz (k, v) \\<sigma>) =\n                         sz \\<and>\n                         (\\<forall>ka.\n                             if ka \\<in> it - {k}\n                             then ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  None\n                             else ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  ahm_\\<alpha>_aux a ka)\n 3. \\<And>\\<sigma>.\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k =\n                ahm_\\<alpha>_aux a k) \\<Longrightarrow>\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k) \\<or>\n       (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n           it \\<noteq> {} \\<and>\n           \\<not> True \\<and>\n           ahm_invar_aux (n - card it) \\<sigma> \\<and>\n           array_length \\<sigma> = sz \\<and>\n           (\\<forall>k.\n               if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n               else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k))\n 4. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom (ahm_\\<alpha>_aux a); it \\<noteq> {};\n        \\<not> True;\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n                         array_length \\<sigma> = sz \\<and>\n                         (\\<forall>k.\n                             if k \\<in> {}\n                             then ahm_\\<alpha>_aux \\<sigma> k = None\n                             else ahm_\\<alpha>_aux \\<sigma> k =\n                                  ahm_\\<alpha>_aux a k) \\<or>\n                         (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n                             it \\<noteq> {} \\<and>\n                             \\<not> True \\<and>\n                             ahm_invar_aux (n - card it) \\<sigma> \\<and>\n                             array_length \\<sigma> = sz \\<and>\n                             (\\<forall>k.\n                                 if k \\<in> it\n                                 then ahm_\\<alpha>_aux \\<sigma> k = None\n                                 else ahm_\\<alpha>_aux \\<sigma> k =\nahm_\\<alpha>_aux a k))", "have \"bounded_hashcode_nat sz k < sz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_hashcode_nat sz k < sz", "using \\<open>1 < sz\\<close>"], ["proof (prove)\nusing this:\n  1 < sz\n\ngoal (1 subgoal):\n 1. bounded_hashcode_nat sz k < sz", "by(simp add: bounded_hashcode_nat_bounds)"], ["proof (state)\nthis:\n  bounded_hashcode_nat sz k < sz\n\ngoal (4 subgoals):\n 1. ahm_invar_aux (n - card (dom (ahm_\\<alpha>_aux a)))\n     (new_array [] sz) \\<and>\n    array_length (new_array [] sz) = sz \\<and>\n    (\\<forall>k.\n        if k \\<in> dom (ahm_\\<alpha>_aux a)\n        then ahm_\\<alpha>_aux (new_array [] sz) k = None\n        else ahm_\\<alpha>_aux (new_array [] sz) k = ahm_\\<alpha>_aux a k)\n 2. \\<And>k v it \\<sigma>.\n       \\<lbrakk>True; k \\<in> it; ahm_\\<alpha>_aux a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux a);\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card (it - {k}))\n                          (ahm_rehash_aux' sz (k, v) \\<sigma>) \\<and>\n                         array_length (ahm_rehash_aux' sz (k, v) \\<sigma>) =\n                         sz \\<and>\n                         (\\<forall>ka.\n                             if ka \\<in> it - {k}\n                             then ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  None\n                             else ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  ahm_\\<alpha>_aux a ka)\n 3. \\<And>\\<sigma>.\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k =\n                ahm_\\<alpha>_aux a k) \\<Longrightarrow>\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k) \\<or>\n       (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n           it \\<noteq> {} \\<and>\n           \\<not> True \\<and>\n           ahm_invar_aux (n - card it) \\<sigma> \\<and>\n           array_length \\<sigma> = sz \\<and>\n           (\\<forall>k.\n               if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n               else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k))\n 4. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom (ahm_\\<alpha>_aux a); it \\<noteq> {};\n        \\<not> True;\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n                         array_length \\<sigma> = sz \\<and>\n                         (\\<forall>k.\n                             if k \\<in> {}\n                             then ahm_\\<alpha>_aux \\<sigma> k = None\n                             else ahm_\\<alpha>_aux \\<sigma> k =\n                                  ahm_\\<alpha>_aux a k) \\<or>\n                         (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n                             it \\<noteq> {} \\<and>\n                             \\<not> True \\<and>\n                             ahm_invar_aux (n - card it) \\<sigma> \\<and>\n                             array_length \\<sigma> = sz \\<and>\n                             (\\<forall>k.\n                                 if k \\<in> it\n                                 then ahm_\\<alpha>_aux \\<sigma> k = None\n                                 else ahm_\\<alpha>_aux \\<sigma> k =\nahm_\\<alpha>_aux a k))", "ultimately"], ["proof (chain)\npicking this:\n  ahm_\\<alpha>_aux a k = None\n  bounded_hashcode_nat sz k < sz", "have \"ahm_\\<alpha>_aux (new_array [] sz) k = ahm_\\<alpha>_aux a k\""], ["proof (prove)\nusing this:\n  ahm_\\<alpha>_aux a k = None\n  bounded_hashcode_nat sz k < sz\n\ngoal (1 subgoal):\n 1. ahm_\\<alpha>_aux (new_array [] sz) k = ahm_\\<alpha>_aux a k", "by simp"], ["proof (state)\nthis:\n  ahm_\\<alpha>_aux (new_array [] sz) k = ahm_\\<alpha>_aux a k\n\ngoal (4 subgoals):\n 1. ahm_invar_aux (n - card (dom (ahm_\\<alpha>_aux a)))\n     (new_array [] sz) \\<and>\n    array_length (new_array [] sz) = sz \\<and>\n    (\\<forall>k.\n        if k \\<in> dom (ahm_\\<alpha>_aux a)\n        then ahm_\\<alpha>_aux (new_array [] sz) k = None\n        else ahm_\\<alpha>_aux (new_array [] sz) k = ahm_\\<alpha>_aux a k)\n 2. \\<And>k v it \\<sigma>.\n       \\<lbrakk>True; k \\<in> it; ahm_\\<alpha>_aux a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux a);\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card (it - {k}))\n                          (ahm_rehash_aux' sz (k, v) \\<sigma>) \\<and>\n                         array_length (ahm_rehash_aux' sz (k, v) \\<sigma>) =\n                         sz \\<and>\n                         (\\<forall>ka.\n                             if ka \\<in> it - {k}\n                             then ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  None\n                             else ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  ahm_\\<alpha>_aux a ka)\n 3. \\<And>\\<sigma>.\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k =\n                ahm_\\<alpha>_aux a k) \\<Longrightarrow>\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k) \\<or>\n       (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n           it \\<noteq> {} \\<and>\n           \\<not> True \\<and>\n           ahm_invar_aux (n - card it) \\<sigma> \\<and>\n           array_length \\<sigma> = sz \\<and>\n           (\\<forall>k.\n               if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n               else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k))\n 4. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom (ahm_\\<alpha>_aux a); it \\<noteq> {};\n        \\<not> True;\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n                         array_length \\<sigma> = sz \\<and>\n                         (\\<forall>k.\n                             if k \\<in> {}\n                             then ahm_\\<alpha>_aux \\<sigma> k = None\n                             else ahm_\\<alpha>_aux \\<sigma> k =\n                                  ahm_\\<alpha>_aux a k) \\<or>\n                         (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n                             it \\<noteq> {} \\<and>\n                             \\<not> True \\<and>\n                             ahm_invar_aux (n - card it) \\<sigma> \\<and>\n                             array_length \\<sigma> = sz \\<and>\n                             (\\<forall>k.\n                                 if k \\<in> it\n                                 then ahm_\\<alpha>_aux \\<sigma> k = None\n                                 else ahm_\\<alpha>_aux \\<sigma> k =\nahm_\\<alpha>_aux a k))", "}"], ["proof (state)\nthis:\n  ?k2 \\<notin> dom (ahm_\\<alpha>_aux a) \\<Longrightarrow>\n  ahm_\\<alpha>_aux (new_array [] sz) ?k2 = ahm_\\<alpha>_aux a ?k2\n\ngoal (4 subgoals):\n 1. ahm_invar_aux (n - card (dom (ahm_\\<alpha>_aux a)))\n     (new_array [] sz) \\<and>\n    array_length (new_array [] sz) = sz \\<and>\n    (\\<forall>k.\n        if k \\<in> dom (ahm_\\<alpha>_aux a)\n        then ahm_\\<alpha>_aux (new_array [] sz) k = None\n        else ahm_\\<alpha>_aux (new_array [] sz) k = ahm_\\<alpha>_aux a k)\n 2. \\<And>k v it \\<sigma>.\n       \\<lbrakk>True; k \\<in> it; ahm_\\<alpha>_aux a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux a);\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card (it - {k}))\n                          (ahm_rehash_aux' sz (k, v) \\<sigma>) \\<and>\n                         array_length (ahm_rehash_aux' sz (k, v) \\<sigma>) =\n                         sz \\<and>\n                         (\\<forall>ka.\n                             if ka \\<in> it - {k}\n                             then ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  None\n                             else ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  ahm_\\<alpha>_aux a ka)\n 3. \\<And>\\<sigma>.\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k =\n                ahm_\\<alpha>_aux a k) \\<Longrightarrow>\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k) \\<or>\n       (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n           it \\<noteq> {} \\<and>\n           \\<not> True \\<and>\n           ahm_invar_aux (n - card it) \\<sigma> \\<and>\n           array_length \\<sigma> = sz \\<and>\n           (\\<forall>k.\n               if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n               else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k))\n 4. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom (ahm_\\<alpha>_aux a); it \\<noteq> {};\n        \\<not> True;\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n                         array_length \\<sigma> = sz \\<and>\n                         (\\<forall>k.\n                             if k \\<in> {}\n                             then ahm_\\<alpha>_aux \\<sigma> k = None\n                             else ahm_\\<alpha>_aux \\<sigma> k =\n                                  ahm_\\<alpha>_aux a k) \\<or>\n                         (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n                             it \\<noteq> {} \\<and>\n                             \\<not> True \\<and>\n                             ahm_invar_aux (n - card it) \\<sigma> \\<and>\n                             array_length \\<sigma> = sz \\<and>\n                             (\\<forall>k.\n                                 if k \\<in> it\n                                 then ahm_\\<alpha>_aux \\<sigma> k = None\n                                 else ahm_\\<alpha>_aux \\<sigma> k =\nahm_\\<alpha>_aux a k))", "ultimately"], ["proof (chain)\npicking this:\n  card (dom (ahm_\\<alpha>_aux a)) = n\n  ahm_invar_aux 0 (new_array [] sz)\n  ?k2 \\<notin> dom (ahm_\\<alpha>_aux a) \\<Longrightarrow>\n  ahm_\\<alpha>_aux (new_array [] sz) ?k2 = ahm_\\<alpha>_aux a ?k2", "show \"?I (dom (ahm_\\<alpha>_aux a)) (new_array [] sz)\""], ["proof (prove)\nusing this:\n  card (dom (ahm_\\<alpha>_aux a)) = n\n  ahm_invar_aux 0 (new_array [] sz)\n  ?k2 \\<notin> dom (ahm_\\<alpha>_aux a) \\<Longrightarrow>\n  ahm_\\<alpha>_aux (new_array [] sz) ?k2 = ahm_\\<alpha>_aux a ?k2\n\ngoal (1 subgoal):\n 1. ahm_invar_aux (n - card (dom (ahm_\\<alpha>_aux a)))\n     (new_array [] sz) \\<and>\n    array_length (new_array [] sz) = sz \\<and>\n    (\\<forall>k.\n        if k \\<in> dom (ahm_\\<alpha>_aux a)\n        then ahm_\\<alpha>_aux (new_array [] sz) k = None\n        else ahm_\\<alpha>_aux (new_array [] sz) k = ahm_\\<alpha>_aux a k)", "by(auto simp add: bounded_hashcode_nat_bounds[OF \\<open>1 < sz\\<close>])"], ["proof (state)\nthis:\n  ahm_invar_aux (n - card (dom (ahm_\\<alpha>_aux a)))\n   (new_array [] sz) \\<and>\n  array_length (new_array [] sz) = sz \\<and>\n  (\\<forall>k.\n      if k \\<in> dom (ahm_\\<alpha>_aux a)\n      then ahm_\\<alpha>_aux (new_array [] sz) k = None\n      else ahm_\\<alpha>_aux (new_array [] sz) k = ahm_\\<alpha>_aux a k)\n\ngoal (3 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>True; k \\<in> it; ahm_\\<alpha>_aux a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux a);\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card (it - {k}))\n                          (ahm_rehash_aux' sz (k, v) \\<sigma>) \\<and>\n                         array_length (ahm_rehash_aux' sz (k, v) \\<sigma>) =\n                         sz \\<and>\n                         (\\<forall>ka.\n                             if ka \\<in> it - {k}\n                             then ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  None\n                             else ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  ahm_\\<alpha>_aux a ka)\n 2. \\<And>\\<sigma>.\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k =\n                ahm_\\<alpha>_aux a k) \\<Longrightarrow>\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k) \\<or>\n       (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n           it \\<noteq> {} \\<and>\n           \\<not> True \\<and>\n           ahm_invar_aux (n - card it) \\<sigma> \\<and>\n           array_length \\<sigma> = sz \\<and>\n           (\\<forall>k.\n               if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n               else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k))\n 3. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom (ahm_\\<alpha>_aux a); it \\<noteq> {};\n        \\<not> True;\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n                         array_length \\<sigma> = sz \\<and>\n                         (\\<forall>k.\n                             if k \\<in> {}\n                             then ahm_\\<alpha>_aux \\<sigma> k = None\n                             else ahm_\\<alpha>_aux \\<sigma> k =\n                                  ahm_\\<alpha>_aux a k) \\<or>\n                         (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n                             it \\<noteq> {} \\<and>\n                             \\<not> True \\<and>\n                             ahm_invar_aux (n - card it) \\<sigma> \\<and>\n                             array_length \\<sigma> = sz \\<and>\n                             (\\<forall>k.\n                                 if k \\<in> it\n                                 then ahm_\\<alpha>_aux \\<sigma> k = None\n                                 else ahm_\\<alpha>_aux \\<sigma> k =\nahm_\\<alpha>_aux a k))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>True; k \\<in> it; ahm_\\<alpha>_aux a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux a);\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card (it - {k}))\n                          (ahm_rehash_aux' sz (k, v) \\<sigma>) \\<and>\n                         array_length (ahm_rehash_aux' sz (k, v) \\<sigma>) =\n                         sz \\<and>\n                         (\\<forall>ka.\n                             if ka \\<in> it - {k}\n                             then ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  None\n                             else ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  ahm_\\<alpha>_aux a ka)\n 2. \\<And>\\<sigma>.\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k =\n                ahm_\\<alpha>_aux a k) \\<Longrightarrow>\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k) \\<or>\n       (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n           it \\<noteq> {} \\<and>\n           \\<not> True \\<and>\n           ahm_invar_aux (n - card it) \\<sigma> \\<and>\n           array_length \\<sigma> = sz \\<and>\n           (\\<forall>k.\n               if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n               else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k))\n 3. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom (ahm_\\<alpha>_aux a); it \\<noteq> {};\n        \\<not> True;\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n                         array_length \\<sigma> = sz \\<and>\n                         (\\<forall>k.\n                             if k \\<in> {}\n                             then ahm_\\<alpha>_aux \\<sigma> k = None\n                             else ahm_\\<alpha>_aux \\<sigma> k =\n                                  ahm_\\<alpha>_aux a k) \\<or>\n                         (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n                             it \\<noteq> {} \\<and>\n                             \\<not> True \\<and>\n                             ahm_invar_aux (n - card it) \\<sigma> \\<and>\n                             array_length \\<sigma> = sz \\<and>\n                             (\\<forall>k.\n                                 if k \\<in> it\n                                 then ahm_\\<alpha>_aux \\<sigma> k = None\n                                 else ahm_\\<alpha>_aux \\<sigma> k =\nahm_\\<alpha>_aux a k))", "fix k :: 'key\n      and v :: 'val\n      and it a'"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>True; k \\<in> it; ahm_\\<alpha>_aux a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux a);\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card (it - {k}))\n                          (ahm_rehash_aux' sz (k, v) \\<sigma>) \\<and>\n                         array_length (ahm_rehash_aux' sz (k, v) \\<sigma>) =\n                         sz \\<and>\n                         (\\<forall>ka.\n                             if ka \\<in> it - {k}\n                             then ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  None\n                             else ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  ahm_\\<alpha>_aux a ka)\n 2. \\<And>\\<sigma>.\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k =\n                ahm_\\<alpha>_aux a k) \\<Longrightarrow>\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k) \\<or>\n       (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n           it \\<noteq> {} \\<and>\n           \\<not> True \\<and>\n           ahm_invar_aux (n - card it) \\<sigma> \\<and>\n           array_length \\<sigma> = sz \\<and>\n           (\\<forall>k.\n               if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n               else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k))\n 3. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom (ahm_\\<alpha>_aux a); it \\<noteq> {};\n        \\<not> True;\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n                         array_length \\<sigma> = sz \\<and>\n                         (\\<forall>k.\n                             if k \\<in> {}\n                             then ahm_\\<alpha>_aux \\<sigma> k = None\n                             else ahm_\\<alpha>_aux \\<sigma> k =\n                                  ahm_\\<alpha>_aux a k) \\<or>\n                         (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n                             it \\<noteq> {} \\<and>\n                             \\<not> True \\<and>\n                             ahm_invar_aux (n - card it) \\<sigma> \\<and>\n                             array_length \\<sigma> = sz \\<and>\n                             (\\<forall>k.\n                                 if k \\<in> it\n                                 then ahm_\\<alpha>_aux \\<sigma> k = None\n                                 else ahm_\\<alpha>_aux \\<sigma> k =\nahm_\\<alpha>_aux a k))", "assume \"k \\<in> it\" \"ahm_\\<alpha>_aux a k = Some v\" \n      and it_sub: \"it \\<subseteq> dom (ahm_\\<alpha>_aux a)\"\n      and I: \"?I it a'\""], ["proof (state)\nthis:\n  k \\<in> it\n  ahm_\\<alpha>_aux a k = Some v\n  it \\<subseteq> dom (ahm_\\<alpha>_aux a)\n  ahm_invar_aux (n - card it) a' \\<and>\n  array_length a' = sz \\<and>\n  (\\<forall>k.\n      if k \\<in> it then ahm_\\<alpha>_aux a' k = None\n      else ahm_\\<alpha>_aux a' k = ahm_\\<alpha>_aux a k)\n\ngoal (3 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>True; k \\<in> it; ahm_\\<alpha>_aux a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux a);\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card (it - {k}))\n                          (ahm_rehash_aux' sz (k, v) \\<sigma>) \\<and>\n                         array_length (ahm_rehash_aux' sz (k, v) \\<sigma>) =\n                         sz \\<and>\n                         (\\<forall>ka.\n                             if ka \\<in> it - {k}\n                             then ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  None\n                             else ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  ahm_\\<alpha>_aux a ka)\n 2. \\<And>\\<sigma>.\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k =\n                ahm_\\<alpha>_aux a k) \\<Longrightarrow>\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k) \\<or>\n       (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n           it \\<noteq> {} \\<and>\n           \\<not> True \\<and>\n           ahm_invar_aux (n - card it) \\<sigma> \\<and>\n           array_length \\<sigma> = sz \\<and>\n           (\\<forall>k.\n               if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n               else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k))\n 3. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom (ahm_\\<alpha>_aux a); it \\<noteq> {};\n        \\<not> True;\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n                         array_length \\<sigma> = sz \\<and>\n                         (\\<forall>k.\n                             if k \\<in> {}\n                             then ahm_\\<alpha>_aux \\<sigma> k = None\n                             else ahm_\\<alpha>_aux \\<sigma> k =\n                                  ahm_\\<alpha>_aux a k) \\<or>\n                         (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n                             it \\<noteq> {} \\<and>\n                             \\<not> True \\<and>\n                             ahm_invar_aux (n - card it) \\<sigma> \\<and>\n                             array_length \\<sigma> = sz \\<and>\n                             (\\<forall>k.\n                                 if k \\<in> it\n                                 then ahm_\\<alpha>_aux \\<sigma> k = None\n                                 else ahm_\\<alpha>_aux \\<sigma> k =\nahm_\\<alpha>_aux a k))", "from I"], ["proof (chain)\npicking this:\n  ahm_invar_aux (n - card it) a' \\<and>\n  array_length a' = sz \\<and>\n  (\\<forall>k.\n      if k \\<in> it then ahm_\\<alpha>_aux a' k = None\n      else ahm_\\<alpha>_aux a' k = ahm_\\<alpha>_aux a k)", "have inv': \"ahm_invar_aux (n - card it) a'\" \n      and a'_eq_a: \"\\<And>k. k \\<notin> it \\<Longrightarrow> ahm_\\<alpha>_aux a' k = ahm_\\<alpha>_aux a k\" \n      and a'_None: \"\\<And>k. k \\<in> it \\<Longrightarrow> ahm_\\<alpha>_aux a' k = None\"\n      and [simp]: \"sz = array_length a'\""], ["proof (prove)\nusing this:\n  ahm_invar_aux (n - card it) a' \\<and>\n  array_length a' = sz \\<and>\n  (\\<forall>k.\n      if k \\<in> it then ahm_\\<alpha>_aux a' k = None\n      else ahm_\\<alpha>_aux a' k = ahm_\\<alpha>_aux a k)\n\ngoal (1 subgoal):\n 1. (ahm_invar_aux (n - card it) a' &&&\n     (\\<And>k.\n         k \\<notin> it \\<Longrightarrow>\n         ahm_\\<alpha>_aux a' k = ahm_\\<alpha>_aux a k)) &&&\n    (\\<And>k. k \\<in> it \\<Longrightarrow> ahm_\\<alpha>_aux a' k = None) &&&\n    sz = array_length a'", "by(auto split: if_split_asm)"], ["proof (state)\nthis:\n  ahm_invar_aux (n - card it) a'\n  ?k \\<notin> it \\<Longrightarrow>\n  ahm_\\<alpha>_aux a' ?k = ahm_\\<alpha>_aux a ?k\n  ?k \\<in> it \\<Longrightarrow> ahm_\\<alpha>_aux a' ?k = None\n  sz = array_length a'\n\ngoal (3 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>True; k \\<in> it; ahm_\\<alpha>_aux a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux a);\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card (it - {k}))\n                          (ahm_rehash_aux' sz (k, v) \\<sigma>) \\<and>\n                         array_length (ahm_rehash_aux' sz (k, v) \\<sigma>) =\n                         sz \\<and>\n                         (\\<forall>ka.\n                             if ka \\<in> it - {k}\n                             then ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  None\n                             else ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  ahm_\\<alpha>_aux a ka)\n 2. \\<And>\\<sigma>.\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k =\n                ahm_\\<alpha>_aux a k) \\<Longrightarrow>\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k) \\<or>\n       (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n           it \\<noteq> {} \\<and>\n           \\<not> True \\<and>\n           ahm_invar_aux (n - card it) \\<sigma> \\<and>\n           array_length \\<sigma> = sz \\<and>\n           (\\<forall>k.\n               if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n               else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k))\n 3. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom (ahm_\\<alpha>_aux a); it \\<noteq> {};\n        \\<not> True;\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n                         array_length \\<sigma> = sz \\<and>\n                         (\\<forall>k.\n                             if k \\<in> {}\n                             then ahm_\\<alpha>_aux \\<sigma> k = None\n                             else ahm_\\<alpha>_aux \\<sigma> k =\n                                  ahm_\\<alpha>_aux a k) \\<or>\n                         (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n                             it \\<noteq> {} \\<and>\n                             \\<not> True \\<and>\n                             ahm_invar_aux (n - card it) \\<sigma> \\<and>\n                             array_length \\<sigma> = sz \\<and>\n                             (\\<forall>k.\n                                 if k \\<in> it\n                                 then ahm_\\<alpha>_aux \\<sigma> k = None\n                                 else ahm_\\<alpha>_aux \\<sigma> k =\nahm_\\<alpha>_aux a k))", "from it_sub finite_dom_ahm_\\<alpha>_aux[OF inv]"], ["proof (chain)\npicking this:\n  it \\<subseteq> dom (ahm_\\<alpha>_aux a)\n  finite (dom (ahm_\\<alpha>_aux a))", "have \"finite it\""], ["proof (prove)\nusing this:\n  it \\<subseteq> dom (ahm_\\<alpha>_aux a)\n  finite (dom (ahm_\\<alpha>_aux a))\n\ngoal (1 subgoal):\n 1. finite it", "by(rule finite_subset)"], ["proof (state)\nthis:\n  finite it\n\ngoal (3 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>True; k \\<in> it; ahm_\\<alpha>_aux a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux a);\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card (it - {k}))\n                          (ahm_rehash_aux' sz (k, v) \\<sigma>) \\<and>\n                         array_length (ahm_rehash_aux' sz (k, v) \\<sigma>) =\n                         sz \\<and>\n                         (\\<forall>ka.\n                             if ka \\<in> it - {k}\n                             then ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  None\n                             else ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  ahm_\\<alpha>_aux a ka)\n 2. \\<And>\\<sigma>.\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k =\n                ahm_\\<alpha>_aux a k) \\<Longrightarrow>\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k) \\<or>\n       (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n           it \\<noteq> {} \\<and>\n           \\<not> True \\<and>\n           ahm_invar_aux (n - card it) \\<sigma> \\<and>\n           array_length \\<sigma> = sz \\<and>\n           (\\<forall>k.\n               if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n               else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k))\n 3. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom (ahm_\\<alpha>_aux a); it \\<noteq> {};\n        \\<not> True;\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n                         array_length \\<sigma> = sz \\<and>\n                         (\\<forall>k.\n                             if k \\<in> {}\n                             then ahm_\\<alpha>_aux \\<sigma> k = None\n                             else ahm_\\<alpha>_aux \\<sigma> k =\n                                  ahm_\\<alpha>_aux a k) \\<or>\n                         (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n                             it \\<noteq> {} \\<and>\n                             \\<not> True \\<and>\n                             ahm_invar_aux (n - card it) \\<sigma> \\<and>\n                             array_length \\<sigma> = sz \\<and>\n                             (\\<forall>k.\n                                 if k \\<in> it\n                                 then ahm_\\<alpha>_aux \\<sigma> k = None\n                                 else ahm_\\<alpha>_aux \\<sigma> k =\nahm_\\<alpha>_aux a k))", "moreover"], ["proof (state)\nthis:\n  finite it\n\ngoal (3 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>True; k \\<in> it; ahm_\\<alpha>_aux a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux a);\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card (it - {k}))\n                          (ahm_rehash_aux' sz (k, v) \\<sigma>) \\<and>\n                         array_length (ahm_rehash_aux' sz (k, v) \\<sigma>) =\n                         sz \\<and>\n                         (\\<forall>ka.\n                             if ka \\<in> it - {k}\n                             then ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  None\n                             else ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  ahm_\\<alpha>_aux a ka)\n 2. \\<And>\\<sigma>.\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k =\n                ahm_\\<alpha>_aux a k) \\<Longrightarrow>\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k) \\<or>\n       (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n           it \\<noteq> {} \\<and>\n           \\<not> True \\<and>\n           ahm_invar_aux (n - card it) \\<sigma> \\<and>\n           array_length \\<sigma> = sz \\<and>\n           (\\<forall>k.\n               if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n               else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k))\n 3. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom (ahm_\\<alpha>_aux a); it \\<noteq> {};\n        \\<not> True;\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n                         array_length \\<sigma> = sz \\<and>\n                         (\\<forall>k.\n                             if k \\<in> {}\n                             then ahm_\\<alpha>_aux \\<sigma> k = None\n                             else ahm_\\<alpha>_aux \\<sigma> k =\n                                  ahm_\\<alpha>_aux a k) \\<or>\n                         (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n                             it \\<noteq> {} \\<and>\n                             \\<not> True \\<and>\n                             ahm_invar_aux (n - card it) \\<sigma> \\<and>\n                             array_length \\<sigma> = sz \\<and>\n                             (\\<forall>k.\n                                 if k \\<in> it\n                                 then ahm_\\<alpha>_aux \\<sigma> k = None\n                                 else ahm_\\<alpha>_aux \\<sigma> k =\nahm_\\<alpha>_aux a k))", "with \\<open>k \\<in> it\\<close>"], ["proof (chain)\npicking this:\n  k \\<in> it\n  finite it", "have \"card it > 0\""], ["proof (prove)\nusing this:\n  k \\<in> it\n  finite it\n\ngoal (1 subgoal):\n 1. 0 < card it", "by(auto simp add: card_gt_0_iff)"], ["proof (state)\nthis:\n  0 < card it\n\ngoal (3 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>True; k \\<in> it; ahm_\\<alpha>_aux a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux a);\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card (it - {k}))\n                          (ahm_rehash_aux' sz (k, v) \\<sigma>) \\<and>\n                         array_length (ahm_rehash_aux' sz (k, v) \\<sigma>) =\n                         sz \\<and>\n                         (\\<forall>ka.\n                             if ka \\<in> it - {k}\n                             then ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  None\n                             else ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  ahm_\\<alpha>_aux a ka)\n 2. \\<And>\\<sigma>.\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k =\n                ahm_\\<alpha>_aux a k) \\<Longrightarrow>\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k) \\<or>\n       (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n           it \\<noteq> {} \\<and>\n           \\<not> True \\<and>\n           ahm_invar_aux (n - card it) \\<sigma> \\<and>\n           array_length \\<sigma> = sz \\<and>\n           (\\<forall>k.\n               if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n               else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k))\n 3. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom (ahm_\\<alpha>_aux a); it \\<noteq> {};\n        \\<not> True;\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n                         array_length \\<sigma> = sz \\<and>\n                         (\\<forall>k.\n                             if k \\<in> {}\n                             then ahm_\\<alpha>_aux \\<sigma> k = None\n                             else ahm_\\<alpha>_aux \\<sigma> k =\n                                  ahm_\\<alpha>_aux a k) \\<or>\n                         (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n                             it \\<noteq> {} \\<and>\n                             \\<not> True \\<and>\n                             ahm_invar_aux (n - card it) \\<sigma> \\<and>\n                             array_length \\<sigma> = sz \\<and>\n                             (\\<forall>k.\n                                 if k \\<in> it\n                                 then ahm_\\<alpha>_aux \\<sigma> k = None\n                                 else ahm_\\<alpha>_aux \\<sigma> k =\nahm_\\<alpha>_aux a k))", "moreover"], ["proof (state)\nthis:\n  0 < card it\n\ngoal (3 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>True; k \\<in> it; ahm_\\<alpha>_aux a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux a);\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card (it - {k}))\n                          (ahm_rehash_aux' sz (k, v) \\<sigma>) \\<and>\n                         array_length (ahm_rehash_aux' sz (k, v) \\<sigma>) =\n                         sz \\<and>\n                         (\\<forall>ka.\n                             if ka \\<in> it - {k}\n                             then ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  None\n                             else ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  ahm_\\<alpha>_aux a ka)\n 2. \\<And>\\<sigma>.\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k =\n                ahm_\\<alpha>_aux a k) \\<Longrightarrow>\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k) \\<or>\n       (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n           it \\<noteq> {} \\<and>\n           \\<not> True \\<and>\n           ahm_invar_aux (n - card it) \\<sigma> \\<and>\n           array_length \\<sigma> = sz \\<and>\n           (\\<forall>k.\n               if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n               else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k))\n 3. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom (ahm_\\<alpha>_aux a); it \\<noteq> {};\n        \\<not> True;\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n                         array_length \\<sigma> = sz \\<and>\n                         (\\<forall>k.\n                             if k \\<in> {}\n                             then ahm_\\<alpha>_aux \\<sigma> k = None\n                             else ahm_\\<alpha>_aux \\<sigma> k =\n                                  ahm_\\<alpha>_aux a k) \\<or>\n                         (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n                             it \\<noteq> {} \\<and>\n                             \\<not> True \\<and>\n                             ahm_invar_aux (n - card it) \\<sigma> \\<and>\n                             array_length \\<sigma> = sz \\<and>\n                             (\\<forall>k.\n                                 if k \\<in> it\n                                 then ahm_\\<alpha>_aux \\<sigma> k = None\n                                 else ahm_\\<alpha>_aux \\<sigma> k =\nahm_\\<alpha>_aux a k))", "from finite_dom_ahm_\\<alpha>_aux[OF inv] it_sub"], ["proof (chain)\npicking this:\n  finite (dom (ahm_\\<alpha>_aux a))\n  it \\<subseteq> dom (ahm_\\<alpha>_aux a)", "have \"card it \\<le> card (dom (ahm_\\<alpha>_aux a))\""], ["proof (prove)\nusing this:\n  finite (dom (ahm_\\<alpha>_aux a))\n  it \\<subseteq> dom (ahm_\\<alpha>_aux a)\n\ngoal (1 subgoal):\n 1. card it \\<le> card (dom (ahm_\\<alpha>_aux a))", "by(rule card_mono)"], ["proof (state)\nthis:\n  card it \\<le> card (dom (ahm_\\<alpha>_aux a))\n\ngoal (3 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>True; k \\<in> it; ahm_\\<alpha>_aux a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux a);\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card (it - {k}))\n                          (ahm_rehash_aux' sz (k, v) \\<sigma>) \\<and>\n                         array_length (ahm_rehash_aux' sz (k, v) \\<sigma>) =\n                         sz \\<and>\n                         (\\<forall>ka.\n                             if ka \\<in> it - {k}\n                             then ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  None\n                             else ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  ahm_\\<alpha>_aux a ka)\n 2. \\<And>\\<sigma>.\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k =\n                ahm_\\<alpha>_aux a k) \\<Longrightarrow>\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k) \\<or>\n       (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n           it \\<noteq> {} \\<and>\n           \\<not> True \\<and>\n           ahm_invar_aux (n - card it) \\<sigma> \\<and>\n           array_length \\<sigma> = sz \\<and>\n           (\\<forall>k.\n               if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n               else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k))\n 3. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom (ahm_\\<alpha>_aux a); it \\<noteq> {};\n        \\<not> True;\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n                         array_length \\<sigma> = sz \\<and>\n                         (\\<forall>k.\n                             if k \\<in> {}\n                             then ahm_\\<alpha>_aux \\<sigma> k = None\n                             else ahm_\\<alpha>_aux \\<sigma> k =\n                                  ahm_\\<alpha>_aux a k) \\<or>\n                         (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n                             it \\<noteq> {} \\<and>\n                             \\<not> True \\<and>\n                             ahm_invar_aux (n - card it) \\<sigma> \\<and>\n                             array_length \\<sigma> = sz \\<and>\n                             (\\<forall>k.\n                                 if k \\<in> it\n                                 then ahm_\\<alpha>_aux \\<sigma> k = None\n                                 else ahm_\\<alpha>_aux \\<sigma> k =\nahm_\\<alpha>_aux a k))", "moreover"], ["proof (state)\nthis:\n  card it \\<le> card (dom (ahm_\\<alpha>_aux a))\n\ngoal (3 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>True; k \\<in> it; ahm_\\<alpha>_aux a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux a);\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card (it - {k}))\n                          (ahm_rehash_aux' sz (k, v) \\<sigma>) \\<and>\n                         array_length (ahm_rehash_aux' sz (k, v) \\<sigma>) =\n                         sz \\<and>\n                         (\\<forall>ka.\n                             if ka \\<in> it - {k}\n                             then ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  None\n                             else ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  ahm_\\<alpha>_aux a ka)\n 2. \\<And>\\<sigma>.\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k =\n                ahm_\\<alpha>_aux a k) \\<Longrightarrow>\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k) \\<or>\n       (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n           it \\<noteq> {} \\<and>\n           \\<not> True \\<and>\n           ahm_invar_aux (n - card it) \\<sigma> \\<and>\n           array_length \\<sigma> = sz \\<and>\n           (\\<forall>k.\n               if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n               else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k))\n 3. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom (ahm_\\<alpha>_aux a); it \\<noteq> {};\n        \\<not> True;\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n                         array_length \\<sigma> = sz \\<and>\n                         (\\<forall>k.\n                             if k \\<in> {}\n                             then ahm_\\<alpha>_aux \\<sigma> k = None\n                             else ahm_\\<alpha>_aux \\<sigma> k =\n                                  ahm_\\<alpha>_aux a k) \\<or>\n                         (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n                             it \\<noteq> {} \\<and>\n                             \\<not> True \\<and>\n                             ahm_invar_aux (n - card it) \\<sigma> \\<and>\n                             array_length \\<sigma> = sz \\<and>\n                             (\\<forall>k.\n                                 if k \\<in> it\n                                 then ahm_\\<alpha>_aux \\<sigma> k = None\n                                 else ahm_\\<alpha>_aux \\<sigma> k =\nahm_\\<alpha>_aux a k))", "have \"\\<dots> = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (dom (ahm_\\<alpha>_aux a)) = n", "using inv"], ["proof (prove)\nusing this:\n  ahm_invar_aux n a\n\ngoal (1 subgoal):\n 1. card (dom (ahm_\\<alpha>_aux a)) = n", "by(simp add: ahm_invar_aux_card_dom_ahm_\\<alpha>_auxD)"], ["proof (state)\nthis:\n  card (dom (ahm_\\<alpha>_aux a)) = n\n\ngoal (3 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>True; k \\<in> it; ahm_\\<alpha>_aux a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux a);\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card (it - {k}))\n                          (ahm_rehash_aux' sz (k, v) \\<sigma>) \\<and>\n                         array_length (ahm_rehash_aux' sz (k, v) \\<sigma>) =\n                         sz \\<and>\n                         (\\<forall>ka.\n                             if ka \\<in> it - {k}\n                             then ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  None\n                             else ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  ahm_\\<alpha>_aux a ka)\n 2. \\<And>\\<sigma>.\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k =\n                ahm_\\<alpha>_aux a k) \\<Longrightarrow>\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k) \\<or>\n       (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n           it \\<noteq> {} \\<and>\n           \\<not> True \\<and>\n           ahm_invar_aux (n - card it) \\<sigma> \\<and>\n           array_length \\<sigma> = sz \\<and>\n           (\\<forall>k.\n               if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n               else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k))\n 3. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom (ahm_\\<alpha>_aux a); it \\<noteq> {};\n        \\<not> True;\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n                         array_length \\<sigma> = sz \\<and>\n                         (\\<forall>k.\n                             if k \\<in> {}\n                             then ahm_\\<alpha>_aux \\<sigma> k = None\n                             else ahm_\\<alpha>_aux \\<sigma> k =\n                                  ahm_\\<alpha>_aux a k) \\<or>\n                         (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n                             it \\<noteq> {} \\<and>\n                             \\<not> True \\<and>\n                             ahm_invar_aux (n - card it) \\<sigma> \\<and>\n                             array_length \\<sigma> = sz \\<and>\n                             (\\<forall>k.\n                                 if k \\<in> it\n                                 then ahm_\\<alpha>_aux \\<sigma> k = None\n                                 else ahm_\\<alpha>_aux \\<sigma> k =\nahm_\\<alpha>_aux a k))", "ultimately"], ["proof (chain)\npicking this:\n  finite it\n  0 < card it\n  card it \\<le> card (dom (ahm_\\<alpha>_aux a))\n  card (dom (ahm_\\<alpha>_aux a)) = n", "have \"n - card (it - {k}) = (n - card it) + 1\""], ["proof (prove)\nusing this:\n  finite it\n  0 < card it\n  card it \\<le> card (dom (ahm_\\<alpha>_aux a))\n  card (dom (ahm_\\<alpha>_aux a)) = n\n\ngoal (1 subgoal):\n 1. n - card (it - {k}) = n - card it + 1", "using \\<open>k \\<in> it\\<close>"], ["proof (prove)\nusing this:\n  finite it\n  0 < card it\n  card it \\<le> card (dom (ahm_\\<alpha>_aux a))\n  card (dom (ahm_\\<alpha>_aux a)) = n\n  k \\<in> it\n\ngoal (1 subgoal):\n 1. n - card (it - {k}) = n - card it + 1", "by auto"], ["proof (state)\nthis:\n  n - card (it - {k}) = n - card it + 1\n\ngoal (3 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>True; k \\<in> it; ahm_\\<alpha>_aux a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux a);\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card (it - {k}))\n                          (ahm_rehash_aux' sz (k, v) \\<sigma>) \\<and>\n                         array_length (ahm_rehash_aux' sz (k, v) \\<sigma>) =\n                         sz \\<and>\n                         (\\<forall>ka.\n                             if ka \\<in> it - {k}\n                             then ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  None\n                             else ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  ahm_\\<alpha>_aux a ka)\n 2. \\<And>\\<sigma>.\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k =\n                ahm_\\<alpha>_aux a k) \\<Longrightarrow>\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k) \\<or>\n       (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n           it \\<noteq> {} \\<and>\n           \\<not> True \\<and>\n           ahm_invar_aux (n - card it) \\<sigma> \\<and>\n           array_length \\<sigma> = sz \\<and>\n           (\\<forall>k.\n               if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n               else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k))\n 3. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom (ahm_\\<alpha>_aux a); it \\<noteq> {};\n        \\<not> True;\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n                         array_length \\<sigma> = sz \\<and>\n                         (\\<forall>k.\n                             if k \\<in> {}\n                             then ahm_\\<alpha>_aux \\<sigma> k = None\n                             else ahm_\\<alpha>_aux \\<sigma> k =\n                                  ahm_\\<alpha>_aux a k) \\<or>\n                         (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n                             it \\<noteq> {} \\<and>\n                             \\<not> True \\<and>\n                             ahm_invar_aux (n - card it) \\<sigma> \\<and>\n                             array_length \\<sigma> = sz \\<and>\n                             (\\<forall>k.\n                                 if k \\<in> it\n                                 then ahm_\\<alpha>_aux \\<sigma> k = None\n                                 else ahm_\\<alpha>_aux \\<sigma> k =\nahm_\\<alpha>_aux a k))", "moreover"], ["proof (state)\nthis:\n  n - card (it - {k}) = n - card it + 1\n\ngoal (3 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>True; k \\<in> it; ahm_\\<alpha>_aux a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux a);\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card (it - {k}))\n                          (ahm_rehash_aux' sz (k, v) \\<sigma>) \\<and>\n                         array_length (ahm_rehash_aux' sz (k, v) \\<sigma>) =\n                         sz \\<and>\n                         (\\<forall>ka.\n                             if ka \\<in> it - {k}\n                             then ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  None\n                             else ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  ahm_\\<alpha>_aux a ka)\n 2. \\<And>\\<sigma>.\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k =\n                ahm_\\<alpha>_aux a k) \\<Longrightarrow>\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k) \\<or>\n       (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n           it \\<noteq> {} \\<and>\n           \\<not> True \\<and>\n           ahm_invar_aux (n - card it) \\<sigma> \\<and>\n           array_length \\<sigma> = sz \\<and>\n           (\\<forall>k.\n               if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n               else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k))\n 3. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom (ahm_\\<alpha>_aux a); it \\<noteq> {};\n        \\<not> True;\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n                         array_length \\<sigma> = sz \\<and>\n                         (\\<forall>k.\n                             if k \\<in> {}\n                             then ahm_\\<alpha>_aux \\<sigma> k = None\n                             else ahm_\\<alpha>_aux \\<sigma> k =\n                                  ahm_\\<alpha>_aux a k) \\<or>\n                         (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n                             it \\<noteq> {} \\<and>\n                             \\<not> True \\<and>\n                             ahm_invar_aux (n - card it) \\<sigma> \\<and>\n                             array_length \\<sigma> = sz \\<and>\n                             (\\<forall>k.\n                                 if k \\<in> it\n                                 then ahm_\\<alpha>_aux \\<sigma> k = None\n                                 else ahm_\\<alpha>_aux \\<sigma> k =\nahm_\\<alpha>_aux a k))", "from \\<open>k \\<in> it\\<close>"], ["proof (chain)\npicking this:\n  k \\<in> it", "have \"ahm_\\<alpha>_aux a' k = None\""], ["proof (prove)\nusing this:\n  k \\<in> it\n\ngoal (1 subgoal):\n 1. ahm_\\<alpha>_aux a' k = None", "by(rule a'_None)"], ["proof (state)\nthis:\n  ahm_\\<alpha>_aux a' k = None\n\ngoal (3 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>True; k \\<in> it; ahm_\\<alpha>_aux a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux a);\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card (it - {k}))\n                          (ahm_rehash_aux' sz (k, v) \\<sigma>) \\<and>\n                         array_length (ahm_rehash_aux' sz (k, v) \\<sigma>) =\n                         sz \\<and>\n                         (\\<forall>ka.\n                             if ka \\<in> it - {k}\n                             then ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  None\n                             else ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  ahm_\\<alpha>_aux a ka)\n 2. \\<And>\\<sigma>.\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k =\n                ahm_\\<alpha>_aux a k) \\<Longrightarrow>\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k) \\<or>\n       (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n           it \\<noteq> {} \\<and>\n           \\<not> True \\<and>\n           ahm_invar_aux (n - card it) \\<sigma> \\<and>\n           array_length \\<sigma> = sz \\<and>\n           (\\<forall>k.\n               if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n               else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k))\n 3. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom (ahm_\\<alpha>_aux a); it \\<noteq> {};\n        \\<not> True;\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n                         array_length \\<sigma> = sz \\<and>\n                         (\\<forall>k.\n                             if k \\<in> {}\n                             then ahm_\\<alpha>_aux \\<sigma> k = None\n                             else ahm_\\<alpha>_aux \\<sigma> k =\n                                  ahm_\\<alpha>_aux a k) \\<or>\n                         (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n                             it \\<noteq> {} \\<and>\n                             \\<not> True \\<and>\n                             ahm_invar_aux (n - card it) \\<sigma> \\<and>\n                             array_length \\<sigma> = sz \\<and>\n                             (\\<forall>k.\n                                 if k \\<in> it\n                                 then ahm_\\<alpha>_aux \\<sigma> k = None\n                                 else ahm_\\<alpha>_aux \\<sigma> k =\nahm_\\<alpha>_aux a k))", "hence \"k \\<notin> fst ` set (array_get a' (bounded_hashcode_nat (array_length a') k))\""], ["proof (prove)\nusing this:\n  ahm_\\<alpha>_aux a' k = None\n\ngoal (1 subgoal):\n 1. k \\<notin> fst `\n               set (array_get a' (bounded_hashcode_nat (array_length a') k))", "by(simp add: map_of_eq_None_iff)"], ["proof (state)\nthis:\n  k \\<notin> fst `\n             set (array_get a' (bounded_hashcode_nat (array_length a') k))\n\ngoal (3 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>True; k \\<in> it; ahm_\\<alpha>_aux a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux a);\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card (it - {k}))\n                          (ahm_rehash_aux' sz (k, v) \\<sigma>) \\<and>\n                         array_length (ahm_rehash_aux' sz (k, v) \\<sigma>) =\n                         sz \\<and>\n                         (\\<forall>ka.\n                             if ka \\<in> it - {k}\n                             then ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  None\n                             else ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  ahm_\\<alpha>_aux a ka)\n 2. \\<And>\\<sigma>.\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k =\n                ahm_\\<alpha>_aux a k) \\<Longrightarrow>\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k) \\<or>\n       (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n           it \\<noteq> {} \\<and>\n           \\<not> True \\<and>\n           ahm_invar_aux (n - card it) \\<sigma> \\<and>\n           array_length \\<sigma> = sz \\<and>\n           (\\<forall>k.\n               if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n               else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k))\n 3. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom (ahm_\\<alpha>_aux a); it \\<noteq> {};\n        \\<not> True;\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n                         array_length \\<sigma> = sz \\<and>\n                         (\\<forall>k.\n                             if k \\<in> {}\n                             then ahm_\\<alpha>_aux \\<sigma> k = None\n                             else ahm_\\<alpha>_aux \\<sigma> k =\n                                  ahm_\\<alpha>_aux a k) \\<or>\n                         (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n                             it \\<noteq> {} \\<and>\n                             \\<not> True \\<and>\n                             ahm_invar_aux (n - card it) \\<sigma> \\<and>\n                             array_length \\<sigma> = sz \\<and>\n                             (\\<forall>k.\n                                 if k \\<in> it\n                                 then ahm_\\<alpha>_aux \\<sigma> k = None\n                                 else ahm_\\<alpha>_aux \\<sigma> k =\nahm_\\<alpha>_aux a k))", "ultimately"], ["proof (chain)\npicking this:\n  n - card (it - {k}) = n - card it + 1\n  k \\<notin> fst `\n             set (array_get a' (bounded_hashcode_nat (array_length a') k))", "have \"ahm_invar_aux (n - card (it - {k})) (ahm_rehash_aux' sz (k, v) a')\""], ["proof (prove)\nusing this:\n  n - card (it - {k}) = n - card it + 1\n  k \\<notin> fst `\n             set (array_get a' (bounded_hashcode_nat (array_length a') k))\n\ngoal (1 subgoal):\n 1. ahm_invar_aux (n - card (it - {k})) (ahm_rehash_aux' sz (k, v) a')", "using inv'"], ["proof (prove)\nusing this:\n  n - card (it - {k}) = n - card it + 1\n  k \\<notin> fst `\n             set (array_get a' (bounded_hashcode_nat (array_length a') k))\n  ahm_invar_aux (n - card it) a'\n\ngoal (1 subgoal):\n 1. ahm_invar_aux (n - card (it - {k})) (ahm_rehash_aux' sz (k, v) a')", "by(auto intro: ahm_rehash_aux'_preserves_ahm_invar_aux)"], ["proof (state)\nthis:\n  ahm_invar_aux (n - card (it - {k})) (ahm_rehash_aux' sz (k, v) a')\n\ngoal (3 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>True; k \\<in> it; ahm_\\<alpha>_aux a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux a);\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card (it - {k}))\n                          (ahm_rehash_aux' sz (k, v) \\<sigma>) \\<and>\n                         array_length (ahm_rehash_aux' sz (k, v) \\<sigma>) =\n                         sz \\<and>\n                         (\\<forall>ka.\n                             if ka \\<in> it - {k}\n                             then ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  None\n                             else ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  ahm_\\<alpha>_aux a ka)\n 2. \\<And>\\<sigma>.\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k =\n                ahm_\\<alpha>_aux a k) \\<Longrightarrow>\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k) \\<or>\n       (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n           it \\<noteq> {} \\<and>\n           \\<not> True \\<and>\n           ahm_invar_aux (n - card it) \\<sigma> \\<and>\n           array_length \\<sigma> = sz \\<and>\n           (\\<forall>k.\n               if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n               else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k))\n 3. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom (ahm_\\<alpha>_aux a); it \\<noteq> {};\n        \\<not> True;\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n                         array_length \\<sigma> = sz \\<and>\n                         (\\<forall>k.\n                             if k \\<in> {}\n                             then ahm_\\<alpha>_aux \\<sigma> k = None\n                             else ahm_\\<alpha>_aux \\<sigma> k =\n                                  ahm_\\<alpha>_aux a k) \\<or>\n                         (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n                             it \\<noteq> {} \\<and>\n                             \\<not> True \\<and>\n                             ahm_invar_aux (n - card it) \\<sigma> \\<and>\n                             array_length \\<sigma> = sz \\<and>\n                             (\\<forall>k.\n                                 if k \\<in> it\n                                 then ahm_\\<alpha>_aux \\<sigma> k = None\n                                 else ahm_\\<alpha>_aux \\<sigma> k =\nahm_\\<alpha>_aux a k))", "moreover"], ["proof (state)\nthis:\n  ahm_invar_aux (n - card (it - {k})) (ahm_rehash_aux' sz (k, v) a')\n\ngoal (3 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>True; k \\<in> it; ahm_\\<alpha>_aux a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux a);\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card (it - {k}))\n                          (ahm_rehash_aux' sz (k, v) \\<sigma>) \\<and>\n                         array_length (ahm_rehash_aux' sz (k, v) \\<sigma>) =\n                         sz \\<and>\n                         (\\<forall>ka.\n                             if ka \\<in> it - {k}\n                             then ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  None\n                             else ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  ahm_\\<alpha>_aux a ka)\n 2. \\<And>\\<sigma>.\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k =\n                ahm_\\<alpha>_aux a k) \\<Longrightarrow>\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k) \\<or>\n       (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n           it \\<noteq> {} \\<and>\n           \\<not> True \\<and>\n           ahm_invar_aux (n - card it) \\<sigma> \\<and>\n           array_length \\<sigma> = sz \\<and>\n           (\\<forall>k.\n               if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n               else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k))\n 3. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom (ahm_\\<alpha>_aux a); it \\<noteq> {};\n        \\<not> True;\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n                         array_length \\<sigma> = sz \\<and>\n                         (\\<forall>k.\n                             if k \\<in> {}\n                             then ahm_\\<alpha>_aux \\<sigma> k = None\n                             else ahm_\\<alpha>_aux \\<sigma> k =\n                                  ahm_\\<alpha>_aux a k) \\<or>\n                         (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n                             it \\<noteq> {} \\<and>\n                             \\<not> True \\<and>\n                             ahm_invar_aux (n - card it) \\<sigma> \\<and>\n                             array_length \\<sigma> = sz \\<and>\n                             (\\<forall>k.\n                                 if k \\<in> it\n                                 then ahm_\\<alpha>_aux \\<sigma> k = None\n                                 else ahm_\\<alpha>_aux \\<sigma> k =\nahm_\\<alpha>_aux a k))", "have \"array_length (ahm_rehash_aux' sz (k, v) a') = sz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. array_length (ahm_rehash_aux' sz (k, v) a') = sz", "by(simp add: array_length_ahm_rehash_aux')"], ["proof (state)\nthis:\n  array_length (ahm_rehash_aux' sz (k, v) a') = sz\n\ngoal (3 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>True; k \\<in> it; ahm_\\<alpha>_aux a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux a);\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card (it - {k}))\n                          (ahm_rehash_aux' sz (k, v) \\<sigma>) \\<and>\n                         array_length (ahm_rehash_aux' sz (k, v) \\<sigma>) =\n                         sz \\<and>\n                         (\\<forall>ka.\n                             if ka \\<in> it - {k}\n                             then ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  None\n                             else ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  ahm_\\<alpha>_aux a ka)\n 2. \\<And>\\<sigma>.\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k =\n                ahm_\\<alpha>_aux a k) \\<Longrightarrow>\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k) \\<or>\n       (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n           it \\<noteq> {} \\<and>\n           \\<not> True \\<and>\n           ahm_invar_aux (n - card it) \\<sigma> \\<and>\n           array_length \\<sigma> = sz \\<and>\n           (\\<forall>k.\n               if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n               else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k))\n 3. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom (ahm_\\<alpha>_aux a); it \\<noteq> {};\n        \\<not> True;\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n                         array_length \\<sigma> = sz \\<and>\n                         (\\<forall>k.\n                             if k \\<in> {}\n                             then ahm_\\<alpha>_aux \\<sigma> k = None\n                             else ahm_\\<alpha>_aux \\<sigma> k =\n                                  ahm_\\<alpha>_aux a k) \\<or>\n                         (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n                             it \\<noteq> {} \\<and>\n                             \\<not> True \\<and>\n                             ahm_invar_aux (n - card it) \\<sigma> \\<and>\n                             array_length \\<sigma> = sz \\<and>\n                             (\\<forall>k.\n                                 if k \\<in> it\n                                 then ahm_\\<alpha>_aux \\<sigma> k = None\n                                 else ahm_\\<alpha>_aux \\<sigma> k =\nahm_\\<alpha>_aux a k))", "moreover"], ["proof (state)\nthis:\n  array_length (ahm_rehash_aux' sz (k, v) a') = sz\n\ngoal (3 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>True; k \\<in> it; ahm_\\<alpha>_aux a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux a);\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card (it - {k}))\n                          (ahm_rehash_aux' sz (k, v) \\<sigma>) \\<and>\n                         array_length (ahm_rehash_aux' sz (k, v) \\<sigma>) =\n                         sz \\<and>\n                         (\\<forall>ka.\n                             if ka \\<in> it - {k}\n                             then ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  None\n                             else ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  ahm_\\<alpha>_aux a ka)\n 2. \\<And>\\<sigma>.\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k =\n                ahm_\\<alpha>_aux a k) \\<Longrightarrow>\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k) \\<or>\n       (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n           it \\<noteq> {} \\<and>\n           \\<not> True \\<and>\n           ahm_invar_aux (n - card it) \\<sigma> \\<and>\n           array_length \\<sigma> = sz \\<and>\n           (\\<forall>k.\n               if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n               else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k))\n 3. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom (ahm_\\<alpha>_aux a); it \\<noteq> {};\n        \\<not> True;\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n                         array_length \\<sigma> = sz \\<and>\n                         (\\<forall>k.\n                             if k \\<in> {}\n                             then ahm_\\<alpha>_aux \\<sigma> k = None\n                             else ahm_\\<alpha>_aux \\<sigma> k =\n                                  ahm_\\<alpha>_aux a k) \\<or>\n                         (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n                             it \\<noteq> {} \\<and>\n                             \\<not> True \\<and>\n                             ahm_invar_aux (n - card it) \\<sigma> \\<and>\n                             array_length \\<sigma> = sz \\<and>\n                             (\\<forall>k.\n                                 if k \\<in> it\n                                 then ahm_\\<alpha>_aux \\<sigma> k = None\n                                 else ahm_\\<alpha>_aux \\<sigma> k =\nahm_\\<alpha>_aux a k))", "{"], ["proof (state)\nthis:\n  array_length (ahm_rehash_aux' sz (k, v) a') = sz\n\ngoal (3 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>True; k \\<in> it; ahm_\\<alpha>_aux a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux a);\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card (it - {k}))\n                          (ahm_rehash_aux' sz (k, v) \\<sigma>) \\<and>\n                         array_length (ahm_rehash_aux' sz (k, v) \\<sigma>) =\n                         sz \\<and>\n                         (\\<forall>ka.\n                             if ka \\<in> it - {k}\n                             then ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  None\n                             else ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  ahm_\\<alpha>_aux a ka)\n 2. \\<And>\\<sigma>.\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k =\n                ahm_\\<alpha>_aux a k) \\<Longrightarrow>\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k) \\<or>\n       (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n           it \\<noteq> {} \\<and>\n           \\<not> True \\<and>\n           ahm_invar_aux (n - card it) \\<sigma> \\<and>\n           array_length \\<sigma> = sz \\<and>\n           (\\<forall>k.\n               if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n               else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k))\n 3. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom (ahm_\\<alpha>_aux a); it \\<noteq> {};\n        \\<not> True;\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n                         array_length \\<sigma> = sz \\<and>\n                         (\\<forall>k.\n                             if k \\<in> {}\n                             then ahm_\\<alpha>_aux \\<sigma> k = None\n                             else ahm_\\<alpha>_aux \\<sigma> k =\n                                  ahm_\\<alpha>_aux a k) \\<or>\n                         (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n                             it \\<noteq> {} \\<and>\n                             \\<not> True \\<and>\n                             ahm_invar_aux (n - card it) \\<sigma> \\<and>\n                             array_length \\<sigma> = sz \\<and>\n                             (\\<forall>k.\n                                 if k \\<in> it\n                                 then ahm_\\<alpha>_aux \\<sigma> k = None\n                                 else ahm_\\<alpha>_aux \\<sigma> k =\nahm_\\<alpha>_aux a k))", "fix k'"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>True; k \\<in> it; ahm_\\<alpha>_aux a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux a);\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card (it - {k}))\n                          (ahm_rehash_aux' sz (k, v) \\<sigma>) \\<and>\n                         array_length (ahm_rehash_aux' sz (k, v) \\<sigma>) =\n                         sz \\<and>\n                         (\\<forall>ka.\n                             if ka \\<in> it - {k}\n                             then ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  None\n                             else ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  ahm_\\<alpha>_aux a ka)\n 2. \\<And>\\<sigma>.\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k =\n                ahm_\\<alpha>_aux a k) \\<Longrightarrow>\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k) \\<or>\n       (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n           it \\<noteq> {} \\<and>\n           \\<not> True \\<and>\n           ahm_invar_aux (n - card it) \\<sigma> \\<and>\n           array_length \\<sigma> = sz \\<and>\n           (\\<forall>k.\n               if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n               else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k))\n 3. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom (ahm_\\<alpha>_aux a); it \\<noteq> {};\n        \\<not> True;\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n                         array_length \\<sigma> = sz \\<and>\n                         (\\<forall>k.\n                             if k \\<in> {}\n                             then ahm_\\<alpha>_aux \\<sigma> k = None\n                             else ahm_\\<alpha>_aux \\<sigma> k =\n                                  ahm_\\<alpha>_aux a k) \\<or>\n                         (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n                             it \\<noteq> {} \\<and>\n                             \\<not> True \\<and>\n                             ahm_invar_aux (n - card it) \\<sigma> \\<and>\n                             array_length \\<sigma> = sz \\<and>\n                             (\\<forall>k.\n                                 if k \\<in> it\n                                 then ahm_\\<alpha>_aux \\<sigma> k = None\n                                 else ahm_\\<alpha>_aux \\<sigma> k =\nahm_\\<alpha>_aux a k))", "assume \"k' \\<in> it - {k}\""], ["proof (state)\nthis:\n  k' \\<in> it - {k}\n\ngoal (3 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>True; k \\<in> it; ahm_\\<alpha>_aux a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux a);\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card (it - {k}))\n                          (ahm_rehash_aux' sz (k, v) \\<sigma>) \\<and>\n                         array_length (ahm_rehash_aux' sz (k, v) \\<sigma>) =\n                         sz \\<and>\n                         (\\<forall>ka.\n                             if ka \\<in> it - {k}\n                             then ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  None\n                             else ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  ahm_\\<alpha>_aux a ka)\n 2. \\<And>\\<sigma>.\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k =\n                ahm_\\<alpha>_aux a k) \\<Longrightarrow>\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k) \\<or>\n       (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n           it \\<noteq> {} \\<and>\n           \\<not> True \\<and>\n           ahm_invar_aux (n - card it) \\<sigma> \\<and>\n           array_length \\<sigma> = sz \\<and>\n           (\\<forall>k.\n               if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n               else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k))\n 3. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom (ahm_\\<alpha>_aux a); it \\<noteq> {};\n        \\<not> True;\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n                         array_length \\<sigma> = sz \\<and>\n                         (\\<forall>k.\n                             if k \\<in> {}\n                             then ahm_\\<alpha>_aux \\<sigma> k = None\n                             else ahm_\\<alpha>_aux \\<sigma> k =\n                                  ahm_\\<alpha>_aux a k) \\<or>\n                         (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n                             it \\<noteq> {} \\<and>\n                             \\<not> True \\<and>\n                             ahm_invar_aux (n - card it) \\<sigma> \\<and>\n                             array_length \\<sigma> = sz \\<and>\n                             (\\<forall>k.\n                                 if k \\<in> it\n                                 then ahm_\\<alpha>_aux \\<sigma> k = None\n                                 else ahm_\\<alpha>_aux \\<sigma> k =\nahm_\\<alpha>_aux a k))", "with bounded_hashcode_nat_bounds[OF \\<open>1 < sz\\<close>, of k'] a'_None[of k']"], ["proof (chain)\npicking this:\n  bounded_hashcode_nat sz k' < sz\n  k' \\<in> it \\<Longrightarrow> ahm_\\<alpha>_aux a' k' = None\n  k' \\<in> it - {k}", "have \"ahm_\\<alpha>_aux (ahm_rehash_aux' sz (k, v) a') k' = None\""], ["proof (prove)\nusing this:\n  bounded_hashcode_nat sz k' < sz\n  k' \\<in> it \\<Longrightarrow> ahm_\\<alpha>_aux a' k' = None\n  k' \\<in> it - {k}\n\ngoal (1 subgoal):\n 1. ahm_\\<alpha>_aux (ahm_rehash_aux' sz (k, v) a') k' = None", "by(cases \"bounded_hashcode_nat sz k = bounded_hashcode_nat sz k'\")(auto simp add: array_get_array_set_other ahm_rehash_aux'_def Let_def)"], ["proof (state)\nthis:\n  ahm_\\<alpha>_aux (ahm_rehash_aux' sz (k, v) a') k' = None\n\ngoal (3 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>True; k \\<in> it; ahm_\\<alpha>_aux a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux a);\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card (it - {k}))\n                          (ahm_rehash_aux' sz (k, v) \\<sigma>) \\<and>\n                         array_length (ahm_rehash_aux' sz (k, v) \\<sigma>) =\n                         sz \\<and>\n                         (\\<forall>ka.\n                             if ka \\<in> it - {k}\n                             then ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  None\n                             else ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  ahm_\\<alpha>_aux a ka)\n 2. \\<And>\\<sigma>.\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k =\n                ahm_\\<alpha>_aux a k) \\<Longrightarrow>\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k) \\<or>\n       (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n           it \\<noteq> {} \\<and>\n           \\<not> True \\<and>\n           ahm_invar_aux (n - card it) \\<sigma> \\<and>\n           array_length \\<sigma> = sz \\<and>\n           (\\<forall>k.\n               if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n               else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k))\n 3. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom (ahm_\\<alpha>_aux a); it \\<noteq> {};\n        \\<not> True;\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n                         array_length \\<sigma> = sz \\<and>\n                         (\\<forall>k.\n                             if k \\<in> {}\n                             then ahm_\\<alpha>_aux \\<sigma> k = None\n                             else ahm_\\<alpha>_aux \\<sigma> k =\n                                  ahm_\\<alpha>_aux a k) \\<or>\n                         (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n                             it \\<noteq> {} \\<and>\n                             \\<not> True \\<and>\n                             ahm_invar_aux (n - card it) \\<sigma> \\<and>\n                             array_length \\<sigma> = sz \\<and>\n                             (\\<forall>k.\n                                 if k \\<in> it\n                                 then ahm_\\<alpha>_aux \\<sigma> k = None\n                                 else ahm_\\<alpha>_aux \\<sigma> k =\nahm_\\<alpha>_aux a k))", "}"], ["proof (state)\nthis:\n  ?k'2 \\<in> it - {k} \\<Longrightarrow>\n  ahm_\\<alpha>_aux (ahm_rehash_aux' sz (k, v) a') ?k'2 = None\n\ngoal (3 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>True; k \\<in> it; ahm_\\<alpha>_aux a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux a);\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card (it - {k}))\n                          (ahm_rehash_aux' sz (k, v) \\<sigma>) \\<and>\n                         array_length (ahm_rehash_aux' sz (k, v) \\<sigma>) =\n                         sz \\<and>\n                         (\\<forall>ka.\n                             if ka \\<in> it - {k}\n                             then ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  None\n                             else ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  ahm_\\<alpha>_aux a ka)\n 2. \\<And>\\<sigma>.\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k =\n                ahm_\\<alpha>_aux a k) \\<Longrightarrow>\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k) \\<or>\n       (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n           it \\<noteq> {} \\<and>\n           \\<not> True \\<and>\n           ahm_invar_aux (n - card it) \\<sigma> \\<and>\n           array_length \\<sigma> = sz \\<and>\n           (\\<forall>k.\n               if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n               else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k))\n 3. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom (ahm_\\<alpha>_aux a); it \\<noteq> {};\n        \\<not> True;\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n                         array_length \\<sigma> = sz \\<and>\n                         (\\<forall>k.\n                             if k \\<in> {}\n                             then ahm_\\<alpha>_aux \\<sigma> k = None\n                             else ahm_\\<alpha>_aux \\<sigma> k =\n                                  ahm_\\<alpha>_aux a k) \\<or>\n                         (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n                             it \\<noteq> {} \\<and>\n                             \\<not> True \\<and>\n                             ahm_invar_aux (n - card it) \\<sigma> \\<and>\n                             array_length \\<sigma> = sz \\<and>\n                             (\\<forall>k.\n                                 if k \\<in> it\n                                 then ahm_\\<alpha>_aux \\<sigma> k = None\n                                 else ahm_\\<alpha>_aux \\<sigma> k =\nahm_\\<alpha>_aux a k))", "moreover"], ["proof (state)\nthis:\n  ?k'2 \\<in> it - {k} \\<Longrightarrow>\n  ahm_\\<alpha>_aux (ahm_rehash_aux' sz (k, v) a') ?k'2 = None\n\ngoal (3 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>True; k \\<in> it; ahm_\\<alpha>_aux a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux a);\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card (it - {k}))\n                          (ahm_rehash_aux' sz (k, v) \\<sigma>) \\<and>\n                         array_length (ahm_rehash_aux' sz (k, v) \\<sigma>) =\n                         sz \\<and>\n                         (\\<forall>ka.\n                             if ka \\<in> it - {k}\n                             then ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  None\n                             else ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  ahm_\\<alpha>_aux a ka)\n 2. \\<And>\\<sigma>.\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k =\n                ahm_\\<alpha>_aux a k) \\<Longrightarrow>\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k) \\<or>\n       (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n           it \\<noteq> {} \\<and>\n           \\<not> True \\<and>\n           ahm_invar_aux (n - card it) \\<sigma> \\<and>\n           array_length \\<sigma> = sz \\<and>\n           (\\<forall>k.\n               if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n               else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k))\n 3. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom (ahm_\\<alpha>_aux a); it \\<noteq> {};\n        \\<not> True;\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n                         array_length \\<sigma> = sz \\<and>\n                         (\\<forall>k.\n                             if k \\<in> {}\n                             then ahm_\\<alpha>_aux \\<sigma> k = None\n                             else ahm_\\<alpha>_aux \\<sigma> k =\n                                  ahm_\\<alpha>_aux a k) \\<or>\n                         (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n                             it \\<noteq> {} \\<and>\n                             \\<not> True \\<and>\n                             ahm_invar_aux (n - card it) \\<sigma> \\<and>\n                             array_length \\<sigma> = sz \\<and>\n                             (\\<forall>k.\n                                 if k \\<in> it\n                                 then ahm_\\<alpha>_aux \\<sigma> k = None\n                                 else ahm_\\<alpha>_aux \\<sigma> k =\nahm_\\<alpha>_aux a k))", "{"], ["proof (state)\nthis:\n  ?k'2 \\<in> it - {k} \\<Longrightarrow>\n  ahm_\\<alpha>_aux (ahm_rehash_aux' sz (k, v) a') ?k'2 = None\n\ngoal (3 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>True; k \\<in> it; ahm_\\<alpha>_aux a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux a);\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card (it - {k}))\n                          (ahm_rehash_aux' sz (k, v) \\<sigma>) \\<and>\n                         array_length (ahm_rehash_aux' sz (k, v) \\<sigma>) =\n                         sz \\<and>\n                         (\\<forall>ka.\n                             if ka \\<in> it - {k}\n                             then ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  None\n                             else ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  ahm_\\<alpha>_aux a ka)\n 2. \\<And>\\<sigma>.\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k =\n                ahm_\\<alpha>_aux a k) \\<Longrightarrow>\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k) \\<or>\n       (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n           it \\<noteq> {} \\<and>\n           \\<not> True \\<and>\n           ahm_invar_aux (n - card it) \\<sigma> \\<and>\n           array_length \\<sigma> = sz \\<and>\n           (\\<forall>k.\n               if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n               else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k))\n 3. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom (ahm_\\<alpha>_aux a); it \\<noteq> {};\n        \\<not> True;\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n                         array_length \\<sigma> = sz \\<and>\n                         (\\<forall>k.\n                             if k \\<in> {}\n                             then ahm_\\<alpha>_aux \\<sigma> k = None\n                             else ahm_\\<alpha>_aux \\<sigma> k =\n                                  ahm_\\<alpha>_aux a k) \\<or>\n                         (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n                             it \\<noteq> {} \\<and>\n                             \\<not> True \\<and>\n                             ahm_invar_aux (n - card it) \\<sigma> \\<and>\n                             array_length \\<sigma> = sz \\<and>\n                             (\\<forall>k.\n                                 if k \\<in> it\n                                 then ahm_\\<alpha>_aux \\<sigma> k = None\n                                 else ahm_\\<alpha>_aux \\<sigma> k =\nahm_\\<alpha>_aux a k))", "fix k'"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>True; k \\<in> it; ahm_\\<alpha>_aux a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux a);\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card (it - {k}))\n                          (ahm_rehash_aux' sz (k, v) \\<sigma>) \\<and>\n                         array_length (ahm_rehash_aux' sz (k, v) \\<sigma>) =\n                         sz \\<and>\n                         (\\<forall>ka.\n                             if ka \\<in> it - {k}\n                             then ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  None\n                             else ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  ahm_\\<alpha>_aux a ka)\n 2. \\<And>\\<sigma>.\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k =\n                ahm_\\<alpha>_aux a k) \\<Longrightarrow>\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k) \\<or>\n       (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n           it \\<noteq> {} \\<and>\n           \\<not> True \\<and>\n           ahm_invar_aux (n - card it) \\<sigma> \\<and>\n           array_length \\<sigma> = sz \\<and>\n           (\\<forall>k.\n               if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n               else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k))\n 3. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom (ahm_\\<alpha>_aux a); it \\<noteq> {};\n        \\<not> True;\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n                         array_length \\<sigma> = sz \\<and>\n                         (\\<forall>k.\n                             if k \\<in> {}\n                             then ahm_\\<alpha>_aux \\<sigma> k = None\n                             else ahm_\\<alpha>_aux \\<sigma> k =\n                                  ahm_\\<alpha>_aux a k) \\<or>\n                         (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n                             it \\<noteq> {} \\<and>\n                             \\<not> True \\<and>\n                             ahm_invar_aux (n - card it) \\<sigma> \\<and>\n                             array_length \\<sigma> = sz \\<and>\n                             (\\<forall>k.\n                                 if k \\<in> it\n                                 then ahm_\\<alpha>_aux \\<sigma> k = None\n                                 else ahm_\\<alpha>_aux \\<sigma> k =\nahm_\\<alpha>_aux a k))", "assume \"k' \\<notin> it - {k}\""], ["proof (state)\nthis:\n  k' \\<notin> it - {k}\n\ngoal (3 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>True; k \\<in> it; ahm_\\<alpha>_aux a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux a);\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card (it - {k}))\n                          (ahm_rehash_aux' sz (k, v) \\<sigma>) \\<and>\n                         array_length (ahm_rehash_aux' sz (k, v) \\<sigma>) =\n                         sz \\<and>\n                         (\\<forall>ka.\n                             if ka \\<in> it - {k}\n                             then ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  None\n                             else ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  ahm_\\<alpha>_aux a ka)\n 2. \\<And>\\<sigma>.\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k =\n                ahm_\\<alpha>_aux a k) \\<Longrightarrow>\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k) \\<or>\n       (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n           it \\<noteq> {} \\<and>\n           \\<not> True \\<and>\n           ahm_invar_aux (n - card it) \\<sigma> \\<and>\n           array_length \\<sigma> = sz \\<and>\n           (\\<forall>k.\n               if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n               else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k))\n 3. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom (ahm_\\<alpha>_aux a); it \\<noteq> {};\n        \\<not> True;\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n                         array_length \\<sigma> = sz \\<and>\n                         (\\<forall>k.\n                             if k \\<in> {}\n                             then ahm_\\<alpha>_aux \\<sigma> k = None\n                             else ahm_\\<alpha>_aux \\<sigma> k =\n                                  ahm_\\<alpha>_aux a k) \\<or>\n                         (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n                             it \\<noteq> {} \\<and>\n                             \\<not> True \\<and>\n                             ahm_invar_aux (n - card it) \\<sigma> \\<and>\n                             array_length \\<sigma> = sz \\<and>\n                             (\\<forall>k.\n                                 if k \\<in> it\n                                 then ahm_\\<alpha>_aux \\<sigma> k = None\n                                 else ahm_\\<alpha>_aux \\<sigma> k =\nahm_\\<alpha>_aux a k))", "with bounded_hashcode_nat_bounds[OF \\<open>1 < sz\\<close>, of k'] bounded_hashcode_nat_bounds[OF \\<open>1 < sz\\<close>, of k] a'_eq_a[of k'] \\<open>k \\<in> it\\<close>"], ["proof (chain)\npicking this:\n  bounded_hashcode_nat sz k' < sz\n  bounded_hashcode_nat sz k < sz\n  k' \\<notin> it \\<Longrightarrow>\n  ahm_\\<alpha>_aux a' k' = ahm_\\<alpha>_aux a k'\n  k \\<in> it\n  k' \\<notin> it - {k}", "have \"ahm_\\<alpha>_aux (ahm_rehash_aux' sz (k, v) a') k' = ahm_\\<alpha>_aux a k'\""], ["proof (prove)\nusing this:\n  bounded_hashcode_nat sz k' < sz\n  bounded_hashcode_nat sz k < sz\n  k' \\<notin> it \\<Longrightarrow>\n  ahm_\\<alpha>_aux a' k' = ahm_\\<alpha>_aux a k'\n  k \\<in> it\n  k' \\<notin> it - {k}\n\ngoal (1 subgoal):\n 1. ahm_\\<alpha>_aux (ahm_rehash_aux' sz (k, v) a') k' =\n    ahm_\\<alpha>_aux a k'", "unfolding ahm_rehash_aux'_def Let_def"], ["proof (prove)\nusing this:\n  bounded_hashcode_nat sz k' < sz\n  bounded_hashcode_nat sz k < sz\n  k' \\<notin> it \\<Longrightarrow>\n  ahm_\\<alpha>_aux a' k' = ahm_\\<alpha>_aux a k'\n  k \\<in> it\n  k' \\<notin> it - {k}\n\ngoal (1 subgoal):\n 1. ahm_\\<alpha>_aux\n     (array_set a' (bounded_hashcode_nat sz (fst (k, v)))\n       ((k, v) # array_get a' (bounded_hashcode_nat sz (fst (k, v)))))\n     k' =\n    ahm_\\<alpha>_aux a k'", "using \\<open>ahm_\\<alpha>_aux a k = Some v\\<close>"], ["proof (prove)\nusing this:\n  bounded_hashcode_nat sz k' < sz\n  bounded_hashcode_nat sz k < sz\n  k' \\<notin> it \\<Longrightarrow>\n  ahm_\\<alpha>_aux a' k' = ahm_\\<alpha>_aux a k'\n  k \\<in> it\n  k' \\<notin> it - {k}\n  ahm_\\<alpha>_aux a k = Some v\n\ngoal (1 subgoal):\n 1. ahm_\\<alpha>_aux\n     (array_set a' (bounded_hashcode_nat sz (fst (k, v)))\n       ((k, v) # array_get a' (bounded_hashcode_nat sz (fst (k, v)))))\n     k' =\n    ahm_\\<alpha>_aux a k'", "by(cases \"bounded_hashcode_nat sz k = bounded_hashcode_nat sz k'\")(case_tac [!] \"k' = k\", simp_all add: array_get_array_set_other)"], ["proof (state)\nthis:\n  ahm_\\<alpha>_aux (ahm_rehash_aux' sz (k, v) a') k' = ahm_\\<alpha>_aux a k'\n\ngoal (3 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>True; k \\<in> it; ahm_\\<alpha>_aux a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux a);\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card (it - {k}))\n                          (ahm_rehash_aux' sz (k, v) \\<sigma>) \\<and>\n                         array_length (ahm_rehash_aux' sz (k, v) \\<sigma>) =\n                         sz \\<and>\n                         (\\<forall>ka.\n                             if ka \\<in> it - {k}\n                             then ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  None\n                             else ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  ahm_\\<alpha>_aux a ka)\n 2. \\<And>\\<sigma>.\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k =\n                ahm_\\<alpha>_aux a k) \\<Longrightarrow>\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k) \\<or>\n       (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n           it \\<noteq> {} \\<and>\n           \\<not> True \\<and>\n           ahm_invar_aux (n - card it) \\<sigma> \\<and>\n           array_length \\<sigma> = sz \\<and>\n           (\\<forall>k.\n               if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n               else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k))\n 3. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom (ahm_\\<alpha>_aux a); it \\<noteq> {};\n        \\<not> True;\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n                         array_length \\<sigma> = sz \\<and>\n                         (\\<forall>k.\n                             if k \\<in> {}\n                             then ahm_\\<alpha>_aux \\<sigma> k = None\n                             else ahm_\\<alpha>_aux \\<sigma> k =\n                                  ahm_\\<alpha>_aux a k) \\<or>\n                         (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n                             it \\<noteq> {} \\<and>\n                             \\<not> True \\<and>\n                             ahm_invar_aux (n - card it) \\<sigma> \\<and>\n                             array_length \\<sigma> = sz \\<and>\n                             (\\<forall>k.\n                                 if k \\<in> it\n                                 then ahm_\\<alpha>_aux \\<sigma> k = None\n                                 else ahm_\\<alpha>_aux \\<sigma> k =\nahm_\\<alpha>_aux a k))", "}"], ["proof (state)\nthis:\n  ?k'2 \\<notin> it - {k} \\<Longrightarrow>\n  ahm_\\<alpha>_aux (ahm_rehash_aux' sz (k, v) a') ?k'2 =\n  ahm_\\<alpha>_aux a ?k'2\n\ngoal (3 subgoals):\n 1. \\<And>k v it \\<sigma>.\n       \\<lbrakk>True; k \\<in> it; ahm_\\<alpha>_aux a k = Some v;\n        it \\<subseteq> dom (ahm_\\<alpha>_aux a);\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card (it - {k}))\n                          (ahm_rehash_aux' sz (k, v) \\<sigma>) \\<and>\n                         array_length (ahm_rehash_aux' sz (k, v) \\<sigma>) =\n                         sz \\<and>\n                         (\\<forall>ka.\n                             if ka \\<in> it - {k}\n                             then ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  None\n                             else ahm_\\<alpha>_aux\n                                   (ahm_rehash_aux' sz (k, v) \\<sigma>) ka =\n                                  ahm_\\<alpha>_aux a ka)\n 2. \\<And>\\<sigma>.\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k =\n                ahm_\\<alpha>_aux a k) \\<Longrightarrow>\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k) \\<or>\n       (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n           it \\<noteq> {} \\<and>\n           \\<not> True \\<and>\n           ahm_invar_aux (n - card it) \\<sigma> \\<and>\n           array_length \\<sigma> = sz \\<and>\n           (\\<forall>k.\n               if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n               else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k))\n 3. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom (ahm_\\<alpha>_aux a); it \\<noteq> {};\n        \\<not> True;\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n                         array_length \\<sigma> = sz \\<and>\n                         (\\<forall>k.\n                             if k \\<in> {}\n                             then ahm_\\<alpha>_aux \\<sigma> k = None\n                             else ahm_\\<alpha>_aux \\<sigma> k =\n                                  ahm_\\<alpha>_aux a k) \\<or>\n                         (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n                             it \\<noteq> {} \\<and>\n                             \\<not> True \\<and>\n                             ahm_invar_aux (n - card it) \\<sigma> \\<and>\n                             array_length \\<sigma> = sz \\<and>\n                             (\\<forall>k.\n                                 if k \\<in> it\n                                 then ahm_\\<alpha>_aux \\<sigma> k = None\n                                 else ahm_\\<alpha>_aux \\<sigma> k =\nahm_\\<alpha>_aux a k))", "ultimately"], ["proof (chain)\npicking this:\n  ahm_invar_aux (n - card (it - {k})) (ahm_rehash_aux' sz (k, v) a')\n  array_length (ahm_rehash_aux' sz (k, v) a') = sz\n  ?k'2 \\<in> it - {k} \\<Longrightarrow>\n  ahm_\\<alpha>_aux (ahm_rehash_aux' sz (k, v) a') ?k'2 = None\n  ?k'2 \\<notin> it - {k} \\<Longrightarrow>\n  ahm_\\<alpha>_aux (ahm_rehash_aux' sz (k, v) a') ?k'2 =\n  ahm_\\<alpha>_aux a ?k'2", "show \"?I (it - {k}) (ahm_rehash_aux' sz (k, v) a')\""], ["proof (prove)\nusing this:\n  ahm_invar_aux (n - card (it - {k})) (ahm_rehash_aux' sz (k, v) a')\n  array_length (ahm_rehash_aux' sz (k, v) a') = sz\n  ?k'2 \\<in> it - {k} \\<Longrightarrow>\n  ahm_\\<alpha>_aux (ahm_rehash_aux' sz (k, v) a') ?k'2 = None\n  ?k'2 \\<notin> it - {k} \\<Longrightarrow>\n  ahm_\\<alpha>_aux (ahm_rehash_aux' sz (k, v) a') ?k'2 =\n  ahm_\\<alpha>_aux a ?k'2\n\ngoal (1 subgoal):\n 1. ahm_invar_aux (n - card (it - {k}))\n     (ahm_rehash_aux' sz (k, v) a') \\<and>\n    array_length (ahm_rehash_aux' sz (k, v) a') = sz \\<and>\n    (\\<forall>ka.\n        if ka \\<in> it - {k}\n        then ahm_\\<alpha>_aux (ahm_rehash_aux' sz (k, v) a') ka = None\n        else ahm_\\<alpha>_aux (ahm_rehash_aux' sz (k, v) a') ka =\n             ahm_\\<alpha>_aux a ka)", "by simp"], ["proof (state)\nthis:\n  ahm_invar_aux (n - card (it - {k})) (ahm_rehash_aux' sz (k, v) a') \\<and>\n  array_length (ahm_rehash_aux' sz (k, v) a') = sz \\<and>\n  (\\<forall>ka.\n      if ka \\<in> it - {k}\n      then ahm_\\<alpha>_aux (ahm_rehash_aux' sz (k, v) a') ka = None\n      else ahm_\\<alpha>_aux (ahm_rehash_aux' sz (k, v) a') ka =\n           ahm_\\<alpha>_aux a ka)\n\ngoal (2 subgoals):\n 1. \\<And>\\<sigma>.\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k =\n                ahm_\\<alpha>_aux a k) \\<Longrightarrow>\n       ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n       array_length \\<sigma> = sz \\<and>\n       (\\<forall>k.\n           if k \\<in> {} then ahm_\\<alpha>_aux \\<sigma> k = None\n           else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k) \\<or>\n       (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n           it \\<noteq> {} \\<and>\n           \\<not> True \\<and>\n           ahm_invar_aux (n - card it) \\<sigma> \\<and>\n           array_length \\<sigma> = sz \\<and>\n           (\\<forall>k.\n               if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n               else ahm_\\<alpha>_aux \\<sigma> k = ahm_\\<alpha>_aux a k))\n 2. \\<And>\\<sigma> it.\n       \\<lbrakk>it \\<subseteq> dom (ahm_\\<alpha>_aux a); it \\<noteq> {};\n        \\<not> True;\n        ahm_invar_aux (n - card it) \\<sigma> \\<and>\n        array_length \\<sigma> = sz \\<and>\n        (\\<forall>k.\n            if k \\<in> it then ahm_\\<alpha>_aux \\<sigma> k = None\n            else ahm_\\<alpha>_aux \\<sigma> k =\n                 ahm_\\<alpha>_aux a k)\\<rbrakk>\n       \\<Longrightarrow> ahm_invar_aux (n - card {}) \\<sigma> \\<and>\n                         array_length \\<sigma> = sz \\<and>\n                         (\\<forall>k.\n                             if k \\<in> {}\n                             then ahm_\\<alpha>_aux \\<sigma> k = None\n                             else ahm_\\<alpha>_aux \\<sigma> k =\n                                  ahm_\\<alpha>_aux a k) \\<or>\n                         (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n                             it \\<noteq> {} \\<and>\n                             \\<not> True \\<and>\n                             ahm_invar_aux (n - card it) \\<sigma> \\<and>\n                             array_length \\<sigma> = sz \\<and>\n                             (\\<forall>k.\n                                 if k \\<in> it\n                                 then ahm_\\<alpha>_aux \\<sigma> k = None\n                                 else ahm_\\<alpha>_aux \\<sigma> k =\nahm_\\<alpha>_aux a k))", "qed auto"], ["proof (state)\nthis:\n  ahm_invar_aux (n - card {}) (ahm_rehash_aux a sz) \\<and>\n  array_length (ahm_rehash_aux a sz) = sz \\<and>\n  (\\<forall>k.\n      if k \\<in> {} then ahm_\\<alpha>_aux (ahm_rehash_aux a sz) k = None\n      else ahm_\\<alpha>_aux (ahm_rehash_aux a sz) k =\n           ahm_\\<alpha>_aux a k) \\<or>\n  (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n      it \\<noteq> {} \\<and>\n      \\<not> True \\<and>\n      ahm_invar_aux (n - card it) (ahm_rehash_aux a sz) \\<and>\n      array_length (ahm_rehash_aux a sz) = sz \\<and>\n      (\\<forall>k.\n          if k \\<in> it then ahm_\\<alpha>_aux (ahm_rehash_aux a sz) k = None\n          else ahm_\\<alpha>_aux (ahm_rehash_aux a sz) k =\n               ahm_\\<alpha>_aux a k))\n\ngoal (2 subgoals):\n 1. ahm_invar_aux n (ahm_rehash_aux a sz)\n 2. ahm_\\<alpha>_aux (ahm_rehash_aux a sz) = ahm_\\<alpha>_aux a", "thus ?thesis1 ?thesis2"], ["proof (prove)\nusing this:\n  ahm_invar_aux (n - card {}) (ahm_rehash_aux a sz) \\<and>\n  array_length (ahm_rehash_aux a sz) = sz \\<and>\n  (\\<forall>k.\n      if k \\<in> {} then ahm_\\<alpha>_aux (ahm_rehash_aux a sz) k = None\n      else ahm_\\<alpha>_aux (ahm_rehash_aux a sz) k =\n           ahm_\\<alpha>_aux a k) \\<or>\n  (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n      it \\<noteq> {} \\<and>\n      \\<not> True \\<and>\n      ahm_invar_aux (n - card it) (ahm_rehash_aux a sz) \\<and>\n      array_length (ahm_rehash_aux a sz) = sz \\<and>\n      (\\<forall>k.\n          if k \\<in> it then ahm_\\<alpha>_aux (ahm_rehash_aux a sz) k = None\n          else ahm_\\<alpha>_aux (ahm_rehash_aux a sz) k =\n               ahm_\\<alpha>_aux a k))\n\ngoal (1 subgoal):\n 1. ahm_invar_aux n (ahm_rehash_aux a sz) &&&\n    ahm_\\<alpha>_aux (ahm_rehash_aux a sz) = ahm_\\<alpha>_aux a", "unfolding ahm_rehash_aux_def"], ["proof (prove)\nusing this:\n  ahm_invar_aux (n - card {})\n   (ahm_iteratei_aux a (\\<lambda>x. True) (ahm_rehash_aux' sz)\n     (new_array [] sz)) \\<and>\n  array_length\n   (ahm_iteratei_aux a (\\<lambda>x. True) (ahm_rehash_aux' sz)\n     (new_array [] sz)) =\n  sz \\<and>\n  (\\<forall>k.\n      if k \\<in> {}\n      then ahm_\\<alpha>_aux\n            (ahm_iteratei_aux a (\\<lambda>x. True) (ahm_rehash_aux' sz)\n              (new_array [] sz))\n            k =\n           None\n      else ahm_\\<alpha>_aux\n            (ahm_iteratei_aux a (\\<lambda>x. True) (ahm_rehash_aux' sz)\n              (new_array [] sz))\n            k =\n           ahm_\\<alpha>_aux a k) \\<or>\n  (\\<exists>it\\<subseteq>dom (ahm_\\<alpha>_aux a).\n      it \\<noteq> {} \\<and>\n      \\<not> True \\<and>\n      ahm_invar_aux (n - card it)\n       (ahm_iteratei_aux a (\\<lambda>x. True) (ahm_rehash_aux' sz)\n         (new_array [] sz)) \\<and>\n      array_length\n       (ahm_iteratei_aux a (\\<lambda>x. True) (ahm_rehash_aux' sz)\n         (new_array [] sz)) =\n      sz \\<and>\n      (\\<forall>k.\n          if k \\<in> it\n          then ahm_\\<alpha>_aux\n                (ahm_iteratei_aux a (\\<lambda>x. True) (ahm_rehash_aux' sz)\n                  (new_array [] sz))\n                k =\n               None\n          else ahm_\\<alpha>_aux\n                (ahm_iteratei_aux a (\\<lambda>x. True) (ahm_rehash_aux' sz)\n                  (new_array [] sz))\n                k =\n               ahm_\\<alpha>_aux a k))\n\ngoal (1 subgoal):\n 1. ahm_invar_aux n\n     (ahm_iteratei_aux a (\\<lambda>x. True) (ahm_rehash_aux' sz)\n       (new_array [] sz)) &&&\n    ahm_\\<alpha>_aux\n     (ahm_iteratei_aux a (\\<lambda>x. True) (ahm_rehash_aux' sz)\n       (new_array [] sz)) =\n    ahm_\\<alpha>_aux a", "by(auto intro: ext)"], ["proof (state)\nthis:\n  ahm_invar_aux n (ahm_rehash_aux a sz)\n  ahm_\\<alpha>_aux (ahm_rehash_aux a sz) = ahm_\\<alpha>_aux a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ahm_rehash_correct:\n  fixes hm :: \"('key :: hashable, 'val) hashmap\"\n  assumes inv: \"ahm_invar hm\"\n  and \"sz > 1\"\n  shows \"ahm_invar (ahm_rehash hm sz)\" \"ahm_\\<alpha> (ahm_rehash hm sz) = ahm_\\<alpha> hm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ahm_invar (ahm_rehash hm sz) &&&\n    ahm_\\<alpha> (ahm_rehash hm sz) = ahm_\\<alpha> hm", "using assms"], ["proof (prove)\nusing this:\n  ahm_invar hm\n  1 < sz\n\ngoal (1 subgoal):\n 1. ahm_invar (ahm_rehash hm sz) &&&\n    ahm_\\<alpha> (ahm_rehash hm sz) = ahm_\\<alpha> hm", "by -(case_tac [!] hm, auto intro: ahm_rehash_aux_correct)"], ["", "subsection \\<open>@{term ahm_update}\\<close>"], ["", "lemma ahm_update_aux_correct:\n  assumes inv: \"ahm_invar hm\"\n  shows \"ahm_invar (ahm_update_aux hm k v)\" (is ?thesis1)\n  and \"ahm_\\<alpha> (ahm_update_aux hm k v) = (ahm_\\<alpha> hm)(k \\<mapsto> v)\" (is ?thesis2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ahm_invar (ahm_update_aux hm k v) &&&\n    ahm_\\<alpha> (ahm_update_aux hm k v) = ahm_\\<alpha> hm(k \\<mapsto> v)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. ahm_invar (ahm_update_aux hm k v)\n 2. ahm_\\<alpha> (ahm_update_aux hm k v) = ahm_\\<alpha> hm(k \\<mapsto> v)", "obtain a n where [simp]: \"hm = HashMap a n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a n. hm = HashMap a n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases hm)"], ["proof (state)\nthis:\n  hm = HashMap a n\n\ngoal (2 subgoals):\n 1. ahm_invar (ahm_update_aux hm k v)\n 2. ahm_\\<alpha> (ahm_update_aux hm k v) = ahm_\\<alpha> hm(k \\<mapsto> v)", "let ?h = \"bounded_hashcode_nat (array_length a) k\""], ["proof (state)\ngoal (2 subgoals):\n 1. ahm_invar (ahm_update_aux hm k v)\n 2. ahm_\\<alpha> (ahm_update_aux hm k v) = ahm_\\<alpha> hm(k \\<mapsto> v)", "let ?a' = \"array_set a ?h (AList.update k v (array_get a ?h))\""], ["proof (state)\ngoal (2 subgoals):\n 1. ahm_invar (ahm_update_aux hm k v)\n 2. ahm_\\<alpha> (ahm_update_aux hm k v) = ahm_\\<alpha> hm(k \\<mapsto> v)", "let ?n' = \"if map_of (array_get a ?h) k = None then n + 1 else n\""], ["proof (state)\ngoal (2 subgoals):\n 1. ahm_invar (ahm_update_aux hm k v)\n 2. ahm_\\<alpha> (ahm_update_aux hm k v) = ahm_\\<alpha> hm(k \\<mapsto> v)", "have \"ahm_invar (HashMap ?a' ?n')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ahm_invar\n     (HashMap\n       (array_set a (bounded_hashcode_nat (array_length a) k)\n         (AList.update k v\n           (array_get a (bounded_hashcode_nat (array_length a) k))))\n       (if map_of (array_get a (bounded_hashcode_nat (array_length a) k))\n            k =\n           None\n        then n + 1 else n))", "unfolding ahm_invar.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. ahm_invar_aux\n     (if map_of (array_get a (bounded_hashcode_nat (array_length a) k)) k =\n         None\n      then n + 1 else n)\n     (array_set a (bounded_hashcode_nat (array_length a) k)\n       (AList.update k v\n         (array_get a (bounded_hashcode_nat (array_length a) k))))", "proof(rule ahm_invar_auxI)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>h.\n       h < array_length\n            (array_set a (bounded_hashcode_nat (array_length a) k)\n              (AList.update k v\n                (array_get a\n                  (bounded_hashcode_nat (array_length a)\n                    k)))) \\<Longrightarrow>\n       bucket_ok\n        (array_length\n          (array_set a (bounded_hashcode_nat (array_length a) k)\n            (AList.update k v\n              (array_get a (bounded_hashcode_nat (array_length a) k)))))\n        h (array_get\n            (array_set a (bounded_hashcode_nat (array_length a) k)\n              (AList.update k v\n                (array_get a (bounded_hashcode_nat (array_length a) k))))\n            h)\n 2. \\<And>h.\n       h < array_length\n            (array_set a (bounded_hashcode_nat (array_length a) k)\n              (AList.update k v\n                (array_get a\n                  (bounded_hashcode_nat (array_length a)\n                    k)))) \\<Longrightarrow>\n       distinct\n        (map fst\n          (array_get\n            (array_set a (bounded_hashcode_nat (array_length a) k)\n              (AList.update k v\n                (array_get a (bounded_hashcode_nat (array_length a) k))))\n            h))\n 3. (if map_of (array_get a (bounded_hashcode_nat (array_length a) k)) k =\n        None\n     then n + 1 else n) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bounded_hashcode_nat (array_length a) k)\n       (AList.update k v\n         (array_get a (bounded_hashcode_nat (array_length a) k))))\n 4. 1 < array_length\n         (array_set a (bounded_hashcode_nat (array_length a) k)\n           (AList.update k v\n             (array_get a (bounded_hashcode_nat (array_length a) k))))", "fix h"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>h.\n       h < array_length\n            (array_set a (bounded_hashcode_nat (array_length a) k)\n              (AList.update k v\n                (array_get a\n                  (bounded_hashcode_nat (array_length a)\n                    k)))) \\<Longrightarrow>\n       bucket_ok\n        (array_length\n          (array_set a (bounded_hashcode_nat (array_length a) k)\n            (AList.update k v\n              (array_get a (bounded_hashcode_nat (array_length a) k)))))\n        h (array_get\n            (array_set a (bounded_hashcode_nat (array_length a) k)\n              (AList.update k v\n                (array_get a (bounded_hashcode_nat (array_length a) k))))\n            h)\n 2. \\<And>h.\n       h < array_length\n            (array_set a (bounded_hashcode_nat (array_length a) k)\n              (AList.update k v\n                (array_get a\n                  (bounded_hashcode_nat (array_length a)\n                    k)))) \\<Longrightarrow>\n       distinct\n        (map fst\n          (array_get\n            (array_set a (bounded_hashcode_nat (array_length a) k)\n              (AList.update k v\n                (array_get a (bounded_hashcode_nat (array_length a) k))))\n            h))\n 3. (if map_of (array_get a (bounded_hashcode_nat (array_length a) k)) k =\n        None\n     then n + 1 else n) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bounded_hashcode_nat (array_length a) k)\n       (AList.update k v\n         (array_get a (bounded_hashcode_nat (array_length a) k))))\n 4. 1 < array_length\n         (array_set a (bounded_hashcode_nat (array_length a) k)\n           (AList.update k v\n             (array_get a (bounded_hashcode_nat (array_length a) k))))", "assume \"h < array_length ?a'\""], ["proof (state)\nthis:\n  h < array_length\n       (array_set a (bounded_hashcode_nat (array_length a) k)\n         (AList.update k v\n           (array_get a (bounded_hashcode_nat (array_length a) k))))\n\ngoal (4 subgoals):\n 1. \\<And>h.\n       h < array_length\n            (array_set a (bounded_hashcode_nat (array_length a) k)\n              (AList.update k v\n                (array_get a\n                  (bounded_hashcode_nat (array_length a)\n                    k)))) \\<Longrightarrow>\n       bucket_ok\n        (array_length\n          (array_set a (bounded_hashcode_nat (array_length a) k)\n            (AList.update k v\n              (array_get a (bounded_hashcode_nat (array_length a) k)))))\n        h (array_get\n            (array_set a (bounded_hashcode_nat (array_length a) k)\n              (AList.update k v\n                (array_get a (bounded_hashcode_nat (array_length a) k))))\n            h)\n 2. \\<And>h.\n       h < array_length\n            (array_set a (bounded_hashcode_nat (array_length a) k)\n              (AList.update k v\n                (array_get a\n                  (bounded_hashcode_nat (array_length a)\n                    k)))) \\<Longrightarrow>\n       distinct\n        (map fst\n          (array_get\n            (array_set a (bounded_hashcode_nat (array_length a) k)\n              (AList.update k v\n                (array_get a (bounded_hashcode_nat (array_length a) k))))\n            h))\n 3. (if map_of (array_get a (bounded_hashcode_nat (array_length a) k)) k =\n        None\n     then n + 1 else n) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bounded_hashcode_nat (array_length a) k)\n       (AList.update k v\n         (array_get a (bounded_hashcode_nat (array_length a) k))))\n 4. 1 < array_length\n         (array_set a (bounded_hashcode_nat (array_length a) k)\n           (AList.update k v\n             (array_get a (bounded_hashcode_nat (array_length a) k))))", "hence \"h < array_length a\""], ["proof (prove)\nusing this:\n  h < array_length\n       (array_set a (bounded_hashcode_nat (array_length a) k)\n         (AList.update k v\n           (array_get a (bounded_hashcode_nat (array_length a) k))))\n\ngoal (1 subgoal):\n 1. h < array_length a", "by simp"], ["proof (state)\nthis:\n  h < array_length a\n\ngoal (4 subgoals):\n 1. \\<And>h.\n       h < array_length\n            (array_set a (bounded_hashcode_nat (array_length a) k)\n              (AList.update k v\n                (array_get a\n                  (bounded_hashcode_nat (array_length a)\n                    k)))) \\<Longrightarrow>\n       bucket_ok\n        (array_length\n          (array_set a (bounded_hashcode_nat (array_length a) k)\n            (AList.update k v\n              (array_get a (bounded_hashcode_nat (array_length a) k)))))\n        h (array_get\n            (array_set a (bounded_hashcode_nat (array_length a) k)\n              (AList.update k v\n                (array_get a (bounded_hashcode_nat (array_length a) k))))\n            h)\n 2. \\<And>h.\n       h < array_length\n            (array_set a (bounded_hashcode_nat (array_length a) k)\n              (AList.update k v\n                (array_get a\n                  (bounded_hashcode_nat (array_length a)\n                    k)))) \\<Longrightarrow>\n       distinct\n        (map fst\n          (array_get\n            (array_set a (bounded_hashcode_nat (array_length a) k)\n              (AList.update k v\n                (array_get a (bounded_hashcode_nat (array_length a) k))))\n            h))\n 3. (if map_of (array_get a (bounded_hashcode_nat (array_length a) k)) k =\n        None\n     then n + 1 else n) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bounded_hashcode_nat (array_length a) k)\n       (AList.update k v\n         (array_get a (bounded_hashcode_nat (array_length a) k))))\n 4. 1 < array_length\n         (array_set a (bounded_hashcode_nat (array_length a) k)\n           (AList.update k v\n             (array_get a (bounded_hashcode_nat (array_length a) k))))", "with inv"], ["proof (chain)\npicking this:\n  ahm_invar hm\n  h < array_length a", "have \"bucket_ok (array_length a) h (array_get a h)\""], ["proof (prove)\nusing this:\n  ahm_invar hm\n  h < array_length a\n\ngoal (1 subgoal):\n 1. bucket_ok (array_length a) h (array_get a h)", "by(auto elim: ahm_invar_auxE)"], ["proof (state)\nthis:\n  bucket_ok (array_length a) h (array_get a h)\n\ngoal (4 subgoals):\n 1. \\<And>h.\n       h < array_length\n            (array_set a (bounded_hashcode_nat (array_length a) k)\n              (AList.update k v\n                (array_get a\n                  (bounded_hashcode_nat (array_length a)\n                    k)))) \\<Longrightarrow>\n       bucket_ok\n        (array_length\n          (array_set a (bounded_hashcode_nat (array_length a) k)\n            (AList.update k v\n              (array_get a (bounded_hashcode_nat (array_length a) k)))))\n        h (array_get\n            (array_set a (bounded_hashcode_nat (array_length a) k)\n              (AList.update k v\n                (array_get a (bounded_hashcode_nat (array_length a) k))))\n            h)\n 2. \\<And>h.\n       h < array_length\n            (array_set a (bounded_hashcode_nat (array_length a) k)\n              (AList.update k v\n                (array_get a\n                  (bounded_hashcode_nat (array_length a)\n                    k)))) \\<Longrightarrow>\n       distinct\n        (map fst\n          (array_get\n            (array_set a (bounded_hashcode_nat (array_length a) k)\n              (AList.update k v\n                (array_get a (bounded_hashcode_nat (array_length a) k))))\n            h))\n 3. (if map_of (array_get a (bounded_hashcode_nat (array_length a) k)) k =\n        None\n     then n + 1 else n) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bounded_hashcode_nat (array_length a) k)\n       (AList.update k v\n         (array_get a (bounded_hashcode_nat (array_length a) k))))\n 4. 1 < array_length\n         (array_set a (bounded_hashcode_nat (array_length a) k)\n           (AList.update k v\n             (array_get a (bounded_hashcode_nat (array_length a) k))))", "thus \"bucket_ok (array_length ?a') h (array_get ?a' h)\""], ["proof (prove)\nusing this:\n  bucket_ok (array_length a) h (array_get a h)\n\ngoal (1 subgoal):\n 1. bucket_ok\n     (array_length\n       (array_set a (bounded_hashcode_nat (array_length a) k)\n         (AList.update k v\n           (array_get a (bounded_hashcode_nat (array_length a) k)))))\n     h (array_get\n         (array_set a (bounded_hashcode_nat (array_length a) k)\n           (AList.update k v\n             (array_get a (bounded_hashcode_nat (array_length a) k))))\n         h)", "using \\<open>h < array_length a\\<close>"], ["proof (prove)\nusing this:\n  bucket_ok (array_length a) h (array_get a h)\n  h < array_length a\n\ngoal (1 subgoal):\n 1. bucket_ok\n     (array_length\n       (array_set a (bounded_hashcode_nat (array_length a) k)\n         (AList.update k v\n           (array_get a (bounded_hashcode_nat (array_length a) k)))))\n     h (array_get\n         (array_set a (bounded_hashcode_nat (array_length a) k)\n           (AList.update k v\n             (array_get a (bounded_hashcode_nat (array_length a) k))))\n         h)", "apply(cases \"h = bounded_hashcode_nat (array_length a) k\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>bucket_ok (array_length a) h (array_get a h);\n     h < array_length a;\n     h = bounded_hashcode_nat (array_length a) k\\<rbrakk>\n    \\<Longrightarrow> bucket_ok\n                       (array_length\n                         (array_set a\n                           (bounded_hashcode_nat (array_length a) k)\n                           (AList.update k v\n                             (array_get a\n                               (bounded_hashcode_nat (array_length a) k)))))\n                       h (array_get\n                           (array_set a\n                             (bounded_hashcode_nat (array_length a) k)\n                             (AList.update k v\n                               (array_get a\n                                 (bounded_hashcode_nat (array_length a)\n                                   k))))\n                           h)\n 2. \\<lbrakk>bucket_ok (array_length a) h (array_get a h);\n     h < array_length a;\n     h \\<noteq> bounded_hashcode_nat (array_length a) k\\<rbrakk>\n    \\<Longrightarrow> bucket_ok\n                       (array_length\n                         (array_set a\n                           (bounded_hashcode_nat (array_length a) k)\n                           (AList.update k v\n                             (array_get a\n                               (bounded_hashcode_nat (array_length a) k)))))\n                       h (array_get\n                           (array_set a\n                             (bounded_hashcode_nat (array_length a) k)\n                             (AList.update k v\n                               (array_get a\n                                 (bounded_hashcode_nat (array_length a)\n                                   k))))\n                           h)", "apply(fastforce intro!: bucket_okI simp add: dom_update array_get_array_set_other dest: bucket_okD del: imageE elim: imageE)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  bucket_ok\n   (array_length\n     (array_set a (bounded_hashcode_nat (array_length a) k)\n       (AList.update k v\n         (array_get a (bounded_hashcode_nat (array_length a) k)))))\n   h (array_get\n       (array_set a (bounded_hashcode_nat (array_length a) k)\n         (AList.update k v\n           (array_get a (bounded_hashcode_nat (array_length a) k))))\n       h)\n\ngoal (3 subgoals):\n 1. \\<And>h.\n       h < array_length\n            (array_set a (bounded_hashcode_nat (array_length a) k)\n              (AList.update k v\n                (array_get a\n                  (bounded_hashcode_nat (array_length a)\n                    k)))) \\<Longrightarrow>\n       distinct\n        (map fst\n          (array_get\n            (array_set a (bounded_hashcode_nat (array_length a) k)\n              (AList.update k v\n                (array_get a (bounded_hashcode_nat (array_length a) k))))\n            h))\n 2. (if map_of (array_get a (bounded_hashcode_nat (array_length a) k)) k =\n        None\n     then n + 1 else n) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bounded_hashcode_nat (array_length a) k)\n       (AList.update k v\n         (array_get a (bounded_hashcode_nat (array_length a) k))))\n 3. 1 < array_length\n         (array_set a (bounded_hashcode_nat (array_length a) k)\n           (AList.update k v\n             (array_get a (bounded_hashcode_nat (array_length a) k))))", "from \\<open>h < array_length a\\<close> inv"], ["proof (chain)\npicking this:\n  h < array_length a\n  ahm_invar hm", "have \"distinct (map fst (array_get a h))\""], ["proof (prove)\nusing this:\n  h < array_length a\n  ahm_invar hm\n\ngoal (1 subgoal):\n 1. distinct (map fst (array_get a h))", "by(auto elim: ahm_invar_auxE)"], ["proof (state)\nthis:\n  distinct (map fst (array_get a h))\n\ngoal (3 subgoals):\n 1. \\<And>h.\n       h < array_length\n            (array_set a (bounded_hashcode_nat (array_length a) k)\n              (AList.update k v\n                (array_get a\n                  (bounded_hashcode_nat (array_length a)\n                    k)))) \\<Longrightarrow>\n       distinct\n        (map fst\n          (array_get\n            (array_set a (bounded_hashcode_nat (array_length a) k)\n              (AList.update k v\n                (array_get a (bounded_hashcode_nat (array_length a) k))))\n            h))\n 2. (if map_of (array_get a (bounded_hashcode_nat (array_length a) k)) k =\n        None\n     then n + 1 else n) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bounded_hashcode_nat (array_length a) k)\n       (AList.update k v\n         (array_get a (bounded_hashcode_nat (array_length a) k))))\n 3. 1 < array_length\n         (array_set a (bounded_hashcode_nat (array_length a) k)\n           (AList.update k v\n             (array_get a (bounded_hashcode_nat (array_length a) k))))", "with \\<open>h < array_length a\\<close>"], ["proof (chain)\npicking this:\n  h < array_length a\n  distinct (map fst (array_get a h))", "show \"distinct (map fst (array_get ?a' h))\""], ["proof (prove)\nusing this:\n  h < array_length a\n  distinct (map fst (array_get a h))\n\ngoal (1 subgoal):\n 1. distinct\n     (map fst\n       (array_get\n         (array_set a (bounded_hashcode_nat (array_length a) k)\n           (AList.update k v\n             (array_get a (bounded_hashcode_nat (array_length a) k))))\n         h))", "by(cases \"h = bounded_hashcode_nat (array_length a) k\")(auto simp add: array_get_array_set_other intro: distinct_update)"], ["proof (state)\nthis:\n  distinct\n   (map fst\n     (array_get\n       (array_set a (bounded_hashcode_nat (array_length a) k)\n         (AList.update k v\n           (array_get a (bounded_hashcode_nat (array_length a) k))))\n       h))\n\ngoal (2 subgoals):\n 1. (if map_of (array_get a (bounded_hashcode_nat (array_length a) k)) k =\n        None\n     then n + 1 else n) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bounded_hashcode_nat (array_length a) k)\n       (AList.update k v\n         (array_get a (bounded_hashcode_nat (array_length a) k))))\n 2. 1 < array_length\n         (array_set a (bounded_hashcode_nat (array_length a) k)\n           (AList.update k v\n             (array_get a (bounded_hashcode_nat (array_length a) k))))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. (if map_of (array_get a (bounded_hashcode_nat (array_length a) k)) k =\n        None\n     then n + 1 else n) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bounded_hashcode_nat (array_length a) k)\n       (AList.update k v\n         (array_get a (bounded_hashcode_nat (array_length a) k))))\n 2. 1 < array_length\n         (array_set a (bounded_hashcode_nat (array_length a) k)\n           (AList.update k v\n             (array_get a (bounded_hashcode_nat (array_length a) k))))", "obtain xs where a [simp]: \"a = Array xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs. a = Array xs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases a)"], ["proof (state)\nthis:\n  a = Array xs\n\ngoal (2 subgoals):\n 1. (if map_of (array_get a (bounded_hashcode_nat (array_length a) k)) k =\n        None\n     then n + 1 else n) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bounded_hashcode_nat (array_length a) k)\n       (AList.update k v\n         (array_get a (bounded_hashcode_nat (array_length a) k))))\n 2. 1 < array_length\n         (array_set a (bounded_hashcode_nat (array_length a) k)\n           (AList.update k v\n             (array_get a (bounded_hashcode_nat (array_length a) k))))", "let ?f = \"\\<lambda>n kvs. n + length kvs\""], ["proof (state)\ngoal (2 subgoals):\n 1. (if map_of (array_get a (bounded_hashcode_nat (array_length a) k)) k =\n        None\n     then n + 1 else n) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bounded_hashcode_nat (array_length a) k)\n       (AList.update k v\n         (array_get a (bounded_hashcode_nat (array_length a) k))))\n 2. 1 < array_length\n         (array_set a (bounded_hashcode_nat (array_length a) k)\n           (AList.update k v\n             (array_get a (bounded_hashcode_nat (array_length a) k))))", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. (if map_of (array_get a (bounded_hashcode_nat (array_length a) k)) k =\n        None\n     then n + 1 else n) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bounded_hashcode_nat (array_length a) k)\n       (AList.update k v\n         (array_get a (bounded_hashcode_nat (array_length a) k))))\n 2. 1 < array_length\n         (array_set a (bounded_hashcode_nat (array_length a) k)\n           (AList.update k v\n             (array_get a (bounded_hashcode_nat (array_length a) k))))", "fix n :: nat and xs :: \"('a \\<times> 'b) list list\""], ["proof (state)\ngoal (2 subgoals):\n 1. (if map_of (array_get a (bounded_hashcode_nat (array_length a) k)) k =\n        None\n     then n__ + 1 else n__) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bounded_hashcode_nat (array_length a) k)\n       (AList.update k v\n         (array_get a (bounded_hashcode_nat (array_length a) k))))\n 2. 1 < array_length\n         (array_set a (bounded_hashcode_nat (array_length a) k)\n           (AList.update k v\n             (array_get a (bounded_hashcode_nat (array_length a) k))))", "have \"foldl ?f n xs = n + foldl ?f 0 xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (\\<lambda>n kvs. n + length kvs) n xs =\n    n + foldl (\\<lambda>n kvs. n + length kvs) 0 xs", "by(induct xs arbitrary:  rule: rev_induct) simp_all"], ["proof (state)\nthis:\n  foldl (\\<lambda>n kvs. n + length kvs) n xs =\n  n + foldl (\\<lambda>n kvs. n + length kvs) 0 xs\n\ngoal (2 subgoals):\n 1. (if map_of (array_get a (bounded_hashcode_nat (array_length a) k)) k =\n        None\n     then n__ + 1 else n__) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bounded_hashcode_nat (array_length a) k)\n       (AList.update k v\n         (array_get a (bounded_hashcode_nat (array_length a) k))))\n 2. 1 < array_length\n         (array_set a (bounded_hashcode_nat (array_length a) k)\n           (AList.update k v\n             (array_get a (bounded_hashcode_nat (array_length a) k))))", "}"], ["proof (state)\nthis:\n  foldl (\\<lambda>n kvs. n + length kvs) ?na3 ?xsa3 =\n  ?na3 + foldl (\\<lambda>n kvs. n + length kvs) 0 ?xsa3\n\ngoal (2 subgoals):\n 1. (if map_of (array_get a (bounded_hashcode_nat (array_length a) k)) k =\n        None\n     then n + 1 else n) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bounded_hashcode_nat (array_length a) k)\n       (AList.update k v\n         (array_get a (bounded_hashcode_nat (array_length a) k))))\n 2. 1 < array_length\n         (array_set a (bounded_hashcode_nat (array_length a) k)\n           (AList.update k v\n             (array_get a (bounded_hashcode_nat (array_length a) k))))", "note fold = this"], ["proof (state)\nthis:\n  foldl (\\<lambda>n kvs. n + length kvs) ?na3 ?xsa3 =\n  ?na3 + foldl (\\<lambda>n kvs. n + length kvs) 0 ?xsa3\n\ngoal (2 subgoals):\n 1. (if map_of (array_get a (bounded_hashcode_nat (array_length a) k)) k =\n        None\n     then n + 1 else n) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bounded_hashcode_nat (array_length a) k)\n       (AList.update k v\n         (array_get a (bounded_hashcode_nat (array_length a) k))))\n 2. 1 < array_length\n         (array_set a (bounded_hashcode_nat (array_length a) k)\n           (AList.update k v\n             (array_get a (bounded_hashcode_nat (array_length a) k))))", "from inv"], ["proof (chain)\npicking this:\n  ahm_invar hm", "have [simp]: \"bounded_hashcode_nat (length xs) k < length xs\""], ["proof (prove)\nusing this:\n  ahm_invar hm\n\ngoal (1 subgoal):\n 1. bounded_hashcode_nat (length xs) k < length xs", "by(simp add: ahm_invar_aux_def bounded_hashcode_nat_bounds)"], ["proof (state)\nthis:\n  bounded_hashcode_nat (length xs) k < length xs\n\ngoal (2 subgoals):\n 1. (if map_of (array_get a (bounded_hashcode_nat (array_length a) k)) k =\n        None\n     then n + 1 else n) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bounded_hashcode_nat (array_length a) k)\n       (AList.update k v\n         (array_get a (bounded_hashcode_nat (array_length a) k))))\n 2. 1 < array_length\n         (array_set a (bounded_hashcode_nat (array_length a) k)\n           (AList.update k v\n             (array_get a (bounded_hashcode_nat (array_length a) k))))", "have xs: \"xs = take ?h xs @ (xs ! ?h) # drop (Suc ?h) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs =\n    take (bounded_hashcode_nat (array_length a) k) xs @\n    xs ! bounded_hashcode_nat (array_length a) k #\n    drop (Suc (bounded_hashcode_nat (array_length a) k)) xs", "by(simp add: Cons_nth_drop_Suc)"], ["proof (state)\nthis:\n  xs =\n  take (bounded_hashcode_nat (array_length a) k) xs @\n  xs ! bounded_hashcode_nat (array_length a) k #\n  drop (Suc (bounded_hashcode_nat (array_length a) k)) xs\n\ngoal (2 subgoals):\n 1. (if map_of (array_get a (bounded_hashcode_nat (array_length a) k)) k =\n        None\n     then n + 1 else n) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bounded_hashcode_nat (array_length a) k)\n       (AList.update k v\n         (array_get a (bounded_hashcode_nat (array_length a) k))))\n 2. 1 < array_length\n         (array_set a (bounded_hashcode_nat (array_length a) k)\n           (AList.update k v\n             (array_get a (bounded_hashcode_nat (array_length a) k))))", "from inv"], ["proof (chain)\npicking this:\n  ahm_invar hm", "have \"n = array_foldl (\\<lambda>_ n kvs. n + length kvs) 0 a\""], ["proof (prove)\nusing this:\n  ahm_invar hm\n\ngoal (1 subgoal):\n 1. n = array_foldl (\\<lambda>_ n kvs. n + length kvs) 0 a", "by(auto elim: ahm_invar_auxE)"], ["proof (state)\nthis:\n  n = array_foldl (\\<lambda>_ n kvs. n + length kvs) 0 a\n\ngoal (2 subgoals):\n 1. (if map_of (array_get a (bounded_hashcode_nat (array_length a) k)) k =\n        None\n     then n + 1 else n) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bounded_hashcode_nat (array_length a) k)\n       (AList.update k v\n         (array_get a (bounded_hashcode_nat (array_length a) k))))\n 2. 1 < array_length\n         (array_set a (bounded_hashcode_nat (array_length a) k)\n           (AList.update k v\n             (array_get a (bounded_hashcode_nat (array_length a) k))))", "hence \"n = foldl ?f 0 (take ?h xs) + length (xs ! ?h) + foldl ?f 0 (drop (Suc ?h) xs)\""], ["proof (prove)\nusing this:\n  n = array_foldl (\\<lambda>_ n kvs. n + length kvs) 0 a\n\ngoal (1 subgoal):\n 1. n =\n    foldl (\\<lambda>n kvs. n + length kvs) 0\n     (take (bounded_hashcode_nat (array_length a) k) xs) +\n    length (xs ! bounded_hashcode_nat (array_length a) k) +\n    foldl (\\<lambda>n kvs. n + length kvs) 0\n     (drop (Suc (bounded_hashcode_nat (array_length a) k)) xs)", "by(simp add: array_foldl_foldl)(subst xs, simp, subst (1 2 3 4) fold, simp)"], ["proof (state)\nthis:\n  n =\n  foldl (\\<lambda>n kvs. n + length kvs) 0\n   (take (bounded_hashcode_nat (array_length a) k) xs) +\n  length (xs ! bounded_hashcode_nat (array_length a) k) +\n  foldl (\\<lambda>n kvs. n + length kvs) 0\n   (drop (Suc (bounded_hashcode_nat (array_length a) k)) xs)\n\ngoal (2 subgoals):\n 1. (if map_of (array_get a (bounded_hashcode_nat (array_length a) k)) k =\n        None\n     then n + 1 else n) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bounded_hashcode_nat (array_length a) k)\n       (AList.update k v\n         (array_get a (bounded_hashcode_nat (array_length a) k))))\n 2. 1 < array_length\n         (array_set a (bounded_hashcode_nat (array_length a) k)\n           (AList.update k v\n             (array_get a (bounded_hashcode_nat (array_length a) k))))", "thus \"?n' = array_foldl (\\<lambda>_ n kvs. n + length kvs) 0 ?a'\""], ["proof (prove)\nusing this:\n  n =\n  foldl (\\<lambda>n kvs. n + length kvs) 0\n   (take (bounded_hashcode_nat (array_length a) k) xs) +\n  length (xs ! bounded_hashcode_nat (array_length a) k) +\n  foldl (\\<lambda>n kvs. n + length kvs) 0\n   (drop (Suc (bounded_hashcode_nat (array_length a) k)) xs)\n\ngoal (1 subgoal):\n 1. (if map_of (array_get a (bounded_hashcode_nat (array_length a) k)) k =\n        None\n     then n + 1 else n) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bounded_hashcode_nat (array_length a) k)\n       (AList.update k v\n         (array_get a (bounded_hashcode_nat (array_length a) k))))", "apply(simp add: ahm_rehash_aux'_def Let_def array_foldl_foldl foldl_list_update map_of_eq_None_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. n =\n    foldl (\\<lambda>n kvs. n + length kvs) 0\n     (take (bounded_hashcode_nat (length xs) k) xs) +\n    length (xs ! bounded_hashcode_nat (length xs) k) +\n    foldl (\\<lambda>n kvs. n + length kvs) 0\n     (drop (Suc (bounded_hashcode_nat (length xs) k)) xs) \\<Longrightarrow>\n    (k \\<in> fst `\n             set (xs ! bounded_hashcode_nat (length xs) k) \\<longrightarrow>\n     foldl (\\<lambda>n kvs. n + length kvs) 0\n      (take (bounded_hashcode_nat (length xs) k) xs) +\n     length (xs ! bounded_hashcode_nat (length xs) k) +\n     foldl (\\<lambda>n kvs. n + length kvs) 0\n      (drop (Suc (bounded_hashcode_nat (length xs) k)) xs) =\n     foldl (\\<lambda>n kvs. n + length kvs)\n      (foldl (\\<lambda>n kvs. n + length kvs) 0\n        (take (bounded_hashcode_nat (length xs) k) xs) +\n       length (AList.update k v (xs ! bounded_hashcode_nat (length xs) k)))\n      (drop (Suc (bounded_hashcode_nat (length xs) k)) xs)) \\<and>\n    (k \\<notin> fst `\n                set (xs !\n                     bounded_hashcode_nat (length xs) k) \\<longrightarrow>\n     Suc (foldl (\\<lambda>n kvs. n + length kvs) 0\n           (take (bounded_hashcode_nat (length xs) k) xs) +\n          length (xs ! bounded_hashcode_nat (length xs) k) +\n          foldl (\\<lambda>n kvs. n + length kvs) 0\n           (drop (Suc (bounded_hashcode_nat (length xs) k)) xs)) =\n     foldl (\\<lambda>n kvs. n + length kvs)\n      (foldl (\\<lambda>n kvs. n + length kvs) 0\n        (take (bounded_hashcode_nat (length xs) k) xs) +\n       length (AList.update k v (xs ! bounded_hashcode_nat (length xs) k)))\n      (drop (Suc (bounded_hashcode_nat (length xs) k)) xs))", "apply(subst (1 2 3 4 5 6 7 8) fold)"], ["proof (prove)\ngoal (1 subgoal):\n 1. n =\n    foldl (\\<lambda>n kvs. n + length kvs) 0\n     (take (bounded_hashcode_nat (length xs) k) xs) +\n    length (xs ! bounded_hashcode_nat (length xs) k) +\n    foldl (\\<lambda>n kvs. n + length kvs) 0\n     (drop (Suc (bounded_hashcode_nat (length xs) k)) xs) \\<Longrightarrow>\n    (k \\<in> fst `\n             set (xs ! bounded_hashcode_nat (length xs) k) \\<longrightarrow>\n     0 +\n     foldl (\\<lambda>n kvs. n + length kvs) 0\n      (take (bounded_hashcode_nat (length xs) k) xs) +\n     length (xs ! bounded_hashcode_nat (length xs) k) +\n     (0 +\n      foldl (\\<lambda>n kvs. n + length kvs) 0\n       (drop (Suc (bounded_hashcode_nat (length xs) k)) xs)) =\n     0 +\n     foldl (\\<lambda>n kvs. n + length kvs) 0\n      (take (bounded_hashcode_nat (length xs) k) xs) +\n     length (AList.update k v (xs ! bounded_hashcode_nat (length xs) k)) +\n     foldl (\\<lambda>n kvs. n + length kvs) 0\n      (drop (Suc (bounded_hashcode_nat (length xs) k)) xs)) \\<and>\n    (k \\<notin> fst `\n                set (xs !\n                     bounded_hashcode_nat (length xs) k) \\<longrightarrow>\n     Suc (0 +\n          foldl (\\<lambda>n kvs. n + length kvs) 0\n           (take (bounded_hashcode_nat (length xs) k) xs) +\n          length (xs ! bounded_hashcode_nat (length xs) k) +\n          (0 +\n           foldl (\\<lambda>n kvs. n + length kvs) 0\n            (drop (Suc (bounded_hashcode_nat (length xs) k)) xs))) =\n     0 +\n     foldl (\\<lambda>n kvs. n + length kvs) 0\n      (take (bounded_hashcode_nat (length xs) k) xs) +\n     length (AList.update k v (xs ! bounded_hashcode_nat (length xs) k)) +\n     foldl (\\<lambda>n kvs. n + length kvs) 0\n      (drop (Suc (bounded_hashcode_nat (length xs) k)) xs))", "apply(simp add: length_update)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (if map_of (array_get a (bounded_hashcode_nat (array_length a) k)) k =\n      None\n   then n + 1 else n) =\n  array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n   (array_set a (bounded_hashcode_nat (array_length a) k)\n     (AList.update k v\n       (array_get a (bounded_hashcode_nat (array_length a) k))))\n\ngoal (1 subgoal):\n 1. 1 < array_length\n         (array_set a (bounded_hashcode_nat (array_length a) k)\n           (AList.update k v\n             (array_get a (bounded_hashcode_nat (array_length a) k))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 1 < array_length\n         (array_set a (bounded_hashcode_nat (array_length a) k)\n           (AList.update k v\n             (array_get a (bounded_hashcode_nat (array_length a) k))))", "from inv"], ["proof (chain)\npicking this:\n  ahm_invar hm", "have \"1 < array_length a\""], ["proof (prove)\nusing this:\n  ahm_invar hm\n\ngoal (1 subgoal):\n 1. 1 < array_length a", "by(auto elim: ahm_invar_auxE)"], ["proof (state)\nthis:\n  1 < array_length a\n\ngoal (1 subgoal):\n 1. 1 < array_length\n         (array_set a (bounded_hashcode_nat (array_length a) k)\n           (AList.update k v\n             (array_get a (bounded_hashcode_nat (array_length a) k))))", "thus \"1 < array_length ?a'\""], ["proof (prove)\nusing this:\n  1 < array_length a\n\ngoal (1 subgoal):\n 1. 1 < array_length\n         (array_set a (bounded_hashcode_nat (array_length a) k)\n           (AList.update k v\n             (array_get a (bounded_hashcode_nat (array_length a) k))))", "by simp"], ["proof (state)\nthis:\n  1 < array_length\n       (array_set a (bounded_hashcode_nat (array_length a) k)\n         (AList.update k v\n           (array_get a (bounded_hashcode_nat (array_length a) k))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ahm_invar\n   (HashMap\n     (array_set a (bounded_hashcode_nat (array_length a) k)\n       (AList.update k v\n         (array_get a (bounded_hashcode_nat (array_length a) k))))\n     (if map_of (array_get a (bounded_hashcode_nat (array_length a) k)) k =\n         None\n      then n + 1 else n))\n\ngoal (2 subgoals):\n 1. ahm_invar (ahm_update_aux hm k v)\n 2. ahm_\\<alpha> (ahm_update_aux hm k v) = ahm_\\<alpha> hm(k \\<mapsto> v)", "moreover"], ["proof (state)\nthis:\n  ahm_invar\n   (HashMap\n     (array_set a (bounded_hashcode_nat (array_length a) k)\n       (AList.update k v\n         (array_get a (bounded_hashcode_nat (array_length a) k))))\n     (if map_of (array_get a (bounded_hashcode_nat (array_length a) k)) k =\n         None\n      then n + 1 else n))\n\ngoal (2 subgoals):\n 1. ahm_invar (ahm_update_aux hm k v)\n 2. ahm_\\<alpha> (ahm_update_aux hm k v) = ahm_\\<alpha> hm(k \\<mapsto> v)", "have \"ahm_\\<alpha> (ahm_update_aux hm k v) = ahm_\\<alpha> hm(k \\<mapsto> v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ahm_\\<alpha> (ahm_update_aux hm k v) = ahm_\\<alpha> hm(k \\<mapsto> v)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       ahm_\\<alpha> (ahm_update_aux hm k v) x =\n       (ahm_\\<alpha> hm(k \\<mapsto> v)) x", "fix k'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       ahm_\\<alpha> (ahm_update_aux hm k v) x =\n       (ahm_\\<alpha> hm(k \\<mapsto> v)) x", "from inv"], ["proof (chain)\npicking this:\n  ahm_invar hm", "have \"1 < array_length a\""], ["proof (prove)\nusing this:\n  ahm_invar hm\n\ngoal (1 subgoal):\n 1. 1 < array_length a", "by(auto elim: ahm_invar_auxE)"], ["proof (state)\nthis:\n  1 < array_length a\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       ahm_\\<alpha> (ahm_update_aux hm k v) x =\n       (ahm_\\<alpha> hm(k \\<mapsto> v)) x", "with bounded_hashcode_nat_bounds[OF this, of k]"], ["proof (chain)\npicking this:\n  bounded_hashcode_nat (array_length a) k < array_length a\n  1 < array_length a", "show \"ahm_\\<alpha> (ahm_update_aux hm k v) k' = (ahm_\\<alpha> hm(k \\<mapsto> v)) k'\""], ["proof (prove)\nusing this:\n  bounded_hashcode_nat (array_length a) k < array_length a\n  1 < array_length a\n\ngoal (1 subgoal):\n 1. ahm_\\<alpha> (ahm_update_aux hm k v) k' =\n    (ahm_\\<alpha> hm(k \\<mapsto> v)) k'", "by(cases \"bounded_hashcode_nat (array_length a) k = bounded_hashcode_nat (array_length a) k'\")(auto simp add: Let_def update_conv array_get_array_set_other)"], ["proof (state)\nthis:\n  ahm_\\<alpha> (ahm_update_aux hm k v) k' =\n  (ahm_\\<alpha> hm(k \\<mapsto> v)) k'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ahm_\\<alpha> (ahm_update_aux hm k v) = ahm_\\<alpha> hm(k \\<mapsto> v)\n\ngoal (2 subgoals):\n 1. ahm_invar (ahm_update_aux hm k v)\n 2. ahm_\\<alpha> (ahm_update_aux hm k v) = ahm_\\<alpha> hm(k \\<mapsto> v)", "ultimately"], ["proof (chain)\npicking this:\n  ahm_invar\n   (HashMap\n     (array_set a (bounded_hashcode_nat (array_length a) k)\n       (AList.update k v\n         (array_get a (bounded_hashcode_nat (array_length a) k))))\n     (if map_of (array_get a (bounded_hashcode_nat (array_length a) k)) k =\n         None\n      then n + 1 else n))\n  ahm_\\<alpha> (ahm_update_aux hm k v) = ahm_\\<alpha> hm(k \\<mapsto> v)", "show ?thesis1 ?thesis2"], ["proof (prove)\nusing this:\n  ahm_invar\n   (HashMap\n     (array_set a (bounded_hashcode_nat (array_length a) k)\n       (AList.update k v\n         (array_get a (bounded_hashcode_nat (array_length a) k))))\n     (if map_of (array_get a (bounded_hashcode_nat (array_length a) k)) k =\n         None\n      then n + 1 else n))\n  ahm_\\<alpha> (ahm_update_aux hm k v) = ahm_\\<alpha> hm(k \\<mapsto> v)\n\ngoal (1 subgoal):\n 1. ahm_invar (ahm_update_aux hm k v) &&&\n    ahm_\\<alpha> (ahm_update_aux hm k v) = ahm_\\<alpha> hm(k \\<mapsto> v)", "by(simp_all add: Let_def)"], ["proof (state)\nthis:\n  ahm_invar (ahm_update_aux hm k v)\n  ahm_\\<alpha> (ahm_update_aux hm k v) = ahm_\\<alpha> hm(k \\<mapsto> v)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ahm_update_correct:\n  assumes inv: \"ahm_invar hm\"\n  shows \"ahm_invar (ahm_update k v hm)\"\n  and \"ahm_\\<alpha> (ahm_update k v hm) = (ahm_\\<alpha> hm)(k \\<mapsto> v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ahm_invar (ahm_update k v hm) &&&\n    ahm_\\<alpha> (ahm_update k v hm) = ahm_\\<alpha> hm(k \\<mapsto> v)", "using assms"], ["proof (prove)\nusing this:\n  ahm_invar hm\n\ngoal (1 subgoal):\n 1. ahm_invar (ahm_update k v hm) &&&\n    ahm_\\<alpha> (ahm_update k v hm) = ahm_\\<alpha> hm(k \\<mapsto> v)", "by(simp_all add: ahm_update_def Let_def ahm_rehash_correct ahm_update_aux_correct)"], ["", "lemma ahm_update_impl:\n  \"map_update ahm_\\<alpha> ahm_invar ahm_update\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_update ahm_\\<alpha> ahm_invar ahm_update", "by(unfold_locales)(simp_all add: ahm_update_correct)"], ["", "subsection \\<open>@{term \"ahm_delete\"}\\<close>"], ["", "lemma ahm_delete_correct:\n  assumes inv: \"ahm_invar hm\"\n  shows \"ahm_invar (ahm_delete k hm)\" (is \"?thesis1\")\n  and \"ahm_\\<alpha> (ahm_delete k hm) = (ahm_\\<alpha> hm) |` (- {k})\" (is \"?thesis2\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. ahm_invar (ahm_delete k hm) &&&\n    ahm_\\<alpha> (ahm_delete k hm) = ahm_\\<alpha> hm |` (- {k})", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. ahm_invar (ahm_delete k hm)\n 2. ahm_\\<alpha> (ahm_delete k hm) = ahm_\\<alpha> hm |` (- {k})", "obtain a n where hm [simp]: \"hm = HashMap a n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a n. hm = HashMap a n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases hm)"], ["proof (state)\nthis:\n  hm = HashMap a n\n\ngoal (2 subgoals):\n 1. ahm_invar (ahm_delete k hm)\n 2. ahm_\\<alpha> (ahm_delete k hm) = ahm_\\<alpha> hm |` (- {k})", "let ?h = \"bounded_hashcode_nat (array_length a) k\""], ["proof (state)\ngoal (2 subgoals):\n 1. ahm_invar (ahm_delete k hm)\n 2. ahm_\\<alpha> (ahm_delete k hm) = ahm_\\<alpha> hm |` (- {k})", "let ?a' = \"array_set a ?h (AList.delete k (array_get a ?h))\""], ["proof (state)\ngoal (2 subgoals):\n 1. ahm_invar (ahm_delete k hm)\n 2. ahm_\\<alpha> (ahm_delete k hm) = ahm_\\<alpha> hm |` (- {k})", "let ?n' = \"if map_of (array_get a (bounded_hashcode_nat (array_length a) k)) k = None then n else n - 1\""], ["proof (state)\ngoal (2 subgoals):\n 1. ahm_invar (ahm_delete k hm)\n 2. ahm_\\<alpha> (ahm_delete k hm) = ahm_\\<alpha> hm |` (- {k})", "have \"ahm_invar_aux ?n' ?a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ahm_invar_aux\n     (if map_of (array_get a (bounded_hashcode_nat (array_length a) k)) k =\n         None\n      then n else n - 1)\n     (array_set a (bounded_hashcode_nat (array_length a) k)\n       (AList.delete k\n         (array_get a (bounded_hashcode_nat (array_length a) k))))", "proof(rule ahm_invar_auxI)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>h.\n       h < array_length\n            (array_set a (bounded_hashcode_nat (array_length a) k)\n              (AList.delete k\n                (array_get a\n                  (bounded_hashcode_nat (array_length a)\n                    k)))) \\<Longrightarrow>\n       bucket_ok\n        (array_length\n          (array_set a (bounded_hashcode_nat (array_length a) k)\n            (AList.delete k\n              (array_get a (bounded_hashcode_nat (array_length a) k)))))\n        h (array_get\n            (array_set a (bounded_hashcode_nat (array_length a) k)\n              (AList.delete k\n                (array_get a (bounded_hashcode_nat (array_length a) k))))\n            h)\n 2. \\<And>h.\n       h < array_length\n            (array_set a (bounded_hashcode_nat (array_length a) k)\n              (AList.delete k\n                (array_get a\n                  (bounded_hashcode_nat (array_length a)\n                    k)))) \\<Longrightarrow>\n       distinct\n        (map fst\n          (array_get\n            (array_set a (bounded_hashcode_nat (array_length a) k)\n              (AList.delete k\n                (array_get a (bounded_hashcode_nat (array_length a) k))))\n            h))\n 3. (if map_of (array_get a (bounded_hashcode_nat (array_length a) k)) k =\n        None\n     then n else n - 1) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bounded_hashcode_nat (array_length a) k)\n       (AList.delete k\n         (array_get a (bounded_hashcode_nat (array_length a) k))))\n 4. 1 < array_length\n         (array_set a (bounded_hashcode_nat (array_length a) k)\n           (AList.delete k\n             (array_get a (bounded_hashcode_nat (array_length a) k))))", "fix h"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>h.\n       h < array_length\n            (array_set a (bounded_hashcode_nat (array_length a) k)\n              (AList.delete k\n                (array_get a\n                  (bounded_hashcode_nat (array_length a)\n                    k)))) \\<Longrightarrow>\n       bucket_ok\n        (array_length\n          (array_set a (bounded_hashcode_nat (array_length a) k)\n            (AList.delete k\n              (array_get a (bounded_hashcode_nat (array_length a) k)))))\n        h (array_get\n            (array_set a (bounded_hashcode_nat (array_length a) k)\n              (AList.delete k\n                (array_get a (bounded_hashcode_nat (array_length a) k))))\n            h)\n 2. \\<And>h.\n       h < array_length\n            (array_set a (bounded_hashcode_nat (array_length a) k)\n              (AList.delete k\n                (array_get a\n                  (bounded_hashcode_nat (array_length a)\n                    k)))) \\<Longrightarrow>\n       distinct\n        (map fst\n          (array_get\n            (array_set a (bounded_hashcode_nat (array_length a) k)\n              (AList.delete k\n                (array_get a (bounded_hashcode_nat (array_length a) k))))\n            h))\n 3. (if map_of (array_get a (bounded_hashcode_nat (array_length a) k)) k =\n        None\n     then n else n - 1) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bounded_hashcode_nat (array_length a) k)\n       (AList.delete k\n         (array_get a (bounded_hashcode_nat (array_length a) k))))\n 4. 1 < array_length\n         (array_set a (bounded_hashcode_nat (array_length a) k)\n           (AList.delete k\n             (array_get a (bounded_hashcode_nat (array_length a) k))))", "assume \"h < array_length ?a'\""], ["proof (state)\nthis:\n  h < array_length\n       (array_set a (bounded_hashcode_nat (array_length a) k)\n         (AList.delete k\n           (array_get a (bounded_hashcode_nat (array_length a) k))))\n\ngoal (4 subgoals):\n 1. \\<And>h.\n       h < array_length\n            (array_set a (bounded_hashcode_nat (array_length a) k)\n              (AList.delete k\n                (array_get a\n                  (bounded_hashcode_nat (array_length a)\n                    k)))) \\<Longrightarrow>\n       bucket_ok\n        (array_length\n          (array_set a (bounded_hashcode_nat (array_length a) k)\n            (AList.delete k\n              (array_get a (bounded_hashcode_nat (array_length a) k)))))\n        h (array_get\n            (array_set a (bounded_hashcode_nat (array_length a) k)\n              (AList.delete k\n                (array_get a (bounded_hashcode_nat (array_length a) k))))\n            h)\n 2. \\<And>h.\n       h < array_length\n            (array_set a (bounded_hashcode_nat (array_length a) k)\n              (AList.delete k\n                (array_get a\n                  (bounded_hashcode_nat (array_length a)\n                    k)))) \\<Longrightarrow>\n       distinct\n        (map fst\n          (array_get\n            (array_set a (bounded_hashcode_nat (array_length a) k)\n              (AList.delete k\n                (array_get a (bounded_hashcode_nat (array_length a) k))))\n            h))\n 3. (if map_of (array_get a (bounded_hashcode_nat (array_length a) k)) k =\n        None\n     then n else n - 1) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bounded_hashcode_nat (array_length a) k)\n       (AList.delete k\n         (array_get a (bounded_hashcode_nat (array_length a) k))))\n 4. 1 < array_length\n         (array_set a (bounded_hashcode_nat (array_length a) k)\n           (AList.delete k\n             (array_get a (bounded_hashcode_nat (array_length a) k))))", "hence \"h < array_length a\""], ["proof (prove)\nusing this:\n  h < array_length\n       (array_set a (bounded_hashcode_nat (array_length a) k)\n         (AList.delete k\n           (array_get a (bounded_hashcode_nat (array_length a) k))))\n\ngoal (1 subgoal):\n 1. h < array_length a", "by simp"], ["proof (state)\nthis:\n  h < array_length a\n\ngoal (4 subgoals):\n 1. \\<And>h.\n       h < array_length\n            (array_set a (bounded_hashcode_nat (array_length a) k)\n              (AList.delete k\n                (array_get a\n                  (bounded_hashcode_nat (array_length a)\n                    k)))) \\<Longrightarrow>\n       bucket_ok\n        (array_length\n          (array_set a (bounded_hashcode_nat (array_length a) k)\n            (AList.delete k\n              (array_get a (bounded_hashcode_nat (array_length a) k)))))\n        h (array_get\n            (array_set a (bounded_hashcode_nat (array_length a) k)\n              (AList.delete k\n                (array_get a (bounded_hashcode_nat (array_length a) k))))\n            h)\n 2. \\<And>h.\n       h < array_length\n            (array_set a (bounded_hashcode_nat (array_length a) k)\n              (AList.delete k\n                (array_get a\n                  (bounded_hashcode_nat (array_length a)\n                    k)))) \\<Longrightarrow>\n       distinct\n        (map fst\n          (array_get\n            (array_set a (bounded_hashcode_nat (array_length a) k)\n              (AList.delete k\n                (array_get a (bounded_hashcode_nat (array_length a) k))))\n            h))\n 3. (if map_of (array_get a (bounded_hashcode_nat (array_length a) k)) k =\n        None\n     then n else n - 1) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bounded_hashcode_nat (array_length a) k)\n       (AList.delete k\n         (array_get a (bounded_hashcode_nat (array_length a) k))))\n 4. 1 < array_length\n         (array_set a (bounded_hashcode_nat (array_length a) k)\n           (AList.delete k\n             (array_get a (bounded_hashcode_nat (array_length a) k))))", "with inv"], ["proof (chain)\npicking this:\n  ahm_invar hm\n  h < array_length a", "have \"bucket_ok (array_length a) h (array_get a h)\"\n      and \"1 < array_length a\" \n      and \"distinct (map fst (array_get a h))\""], ["proof (prove)\nusing this:\n  ahm_invar hm\n  h < array_length a\n\ngoal (1 subgoal):\n 1. bucket_ok (array_length a) h (array_get a h) &&&\n    1 < array_length a &&& distinct (map fst (array_get a h))", "by(auto elim: ahm_invar_auxE)"], ["proof (state)\nthis:\n  bucket_ok (array_length a) h (array_get a h)\n  1 < array_length a\n  distinct (map fst (array_get a h))\n\ngoal (4 subgoals):\n 1. \\<And>h.\n       h < array_length\n            (array_set a (bounded_hashcode_nat (array_length a) k)\n              (AList.delete k\n                (array_get a\n                  (bounded_hashcode_nat (array_length a)\n                    k)))) \\<Longrightarrow>\n       bucket_ok\n        (array_length\n          (array_set a (bounded_hashcode_nat (array_length a) k)\n            (AList.delete k\n              (array_get a (bounded_hashcode_nat (array_length a) k)))))\n        h (array_get\n            (array_set a (bounded_hashcode_nat (array_length a) k)\n              (AList.delete k\n                (array_get a (bounded_hashcode_nat (array_length a) k))))\n            h)\n 2. \\<And>h.\n       h < array_length\n            (array_set a (bounded_hashcode_nat (array_length a) k)\n              (AList.delete k\n                (array_get a\n                  (bounded_hashcode_nat (array_length a)\n                    k)))) \\<Longrightarrow>\n       distinct\n        (map fst\n          (array_get\n            (array_set a (bounded_hashcode_nat (array_length a) k)\n              (AList.delete k\n                (array_get a (bounded_hashcode_nat (array_length a) k))))\n            h))\n 3. (if map_of (array_get a (bounded_hashcode_nat (array_length a) k)) k =\n        None\n     then n else n - 1) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bounded_hashcode_nat (array_length a) k)\n       (AList.delete k\n         (array_get a (bounded_hashcode_nat (array_length a) k))))\n 4. 1 < array_length\n         (array_set a (bounded_hashcode_nat (array_length a) k)\n           (AList.delete k\n             (array_get a (bounded_hashcode_nat (array_length a) k))))", "thus \"bucket_ok (array_length ?a') h (array_get ?a' h)\"\n      and \"distinct (map fst (array_get ?a' h))\""], ["proof (prove)\nusing this:\n  bucket_ok (array_length a) h (array_get a h)\n  1 < array_length a\n  distinct (map fst (array_get a h))\n\ngoal (1 subgoal):\n 1. bucket_ok\n     (array_length\n       (array_set a (bounded_hashcode_nat (array_length a) k)\n         (AList.delete k\n           (array_get a (bounded_hashcode_nat (array_length a) k)))))\n     h (array_get\n         (array_set a (bounded_hashcode_nat (array_length a) k)\n           (AList.delete k\n             (array_get a (bounded_hashcode_nat (array_length a) k))))\n         h) &&&\n    distinct\n     (map fst\n       (array_get\n         (array_set a (bounded_hashcode_nat (array_length a) k)\n           (AList.delete k\n             (array_get a (bounded_hashcode_nat (array_length a) k))))\n         h))", "using bounded_hashcode_nat_bounds[of \"array_length a\" k]"], ["proof (prove)\nusing this:\n  bucket_ok (array_length a) h (array_get a h)\n  1 < array_length a\n  distinct (map fst (array_get a h))\n  1 < array_length a \\<Longrightarrow>\n  bounded_hashcode_nat (array_length a) k < array_length a\n\ngoal (1 subgoal):\n 1. bucket_ok\n     (array_length\n       (array_set a (bounded_hashcode_nat (array_length a) k)\n         (AList.delete k\n           (array_get a (bounded_hashcode_nat (array_length a) k)))))\n     h (array_get\n         (array_set a (bounded_hashcode_nat (array_length a) k)\n           (AList.delete k\n             (array_get a (bounded_hashcode_nat (array_length a) k))))\n         h) &&&\n    distinct\n     (map fst\n       (array_get\n         (array_set a (bounded_hashcode_nat (array_length a) k)\n           (AList.delete k\n             (array_get a (bounded_hashcode_nat (array_length a) k))))\n         h))", "by-(case_tac [!] \"h = bounded_hashcode_nat (array_length a) k\", auto simp add: array_get_array_set_other set_delete_conv intro!: bucket_okI dest: bucket_okD intro: distinct_delete)"], ["proof (state)\nthis:\n  bucket_ok\n   (array_length\n     (array_set a (bounded_hashcode_nat (array_length a) k)\n       (AList.delete k\n         (array_get a (bounded_hashcode_nat (array_length a) k)))))\n   h (array_get\n       (array_set a (bounded_hashcode_nat (array_length a) k)\n         (AList.delete k\n           (array_get a (bounded_hashcode_nat (array_length a) k))))\n       h)\n  distinct\n   (map fst\n     (array_get\n       (array_set a (bounded_hashcode_nat (array_length a) k)\n         (AList.delete k\n           (array_get a (bounded_hashcode_nat (array_length a) k))))\n       h))\n\ngoal (2 subgoals):\n 1. (if map_of (array_get a (bounded_hashcode_nat (array_length a) k)) k =\n        None\n     then n else n - 1) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bounded_hashcode_nat (array_length a) k)\n       (AList.delete k\n         (array_get a (bounded_hashcode_nat (array_length a) k))))\n 2. 1 < array_length\n         (array_set a (bounded_hashcode_nat (array_length a) k)\n           (AList.delete k\n             (array_get a (bounded_hashcode_nat (array_length a) k))))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. (if map_of (array_get a (bounded_hashcode_nat (array_length a) k)) k =\n        None\n     then n else n - 1) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bounded_hashcode_nat (array_length a) k)\n       (AList.delete k\n         (array_get a (bounded_hashcode_nat (array_length a) k))))\n 2. 1 < array_length\n         (array_set a (bounded_hashcode_nat (array_length a) k)\n           (AList.delete k\n             (array_get a (bounded_hashcode_nat (array_length a) k))))", "obtain xs where a [simp]: \"a = Array xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs. a = Array xs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases a)"], ["proof (state)\nthis:\n  a = Array xs\n\ngoal (2 subgoals):\n 1. (if map_of (array_get a (bounded_hashcode_nat (array_length a) k)) k =\n        None\n     then n else n - 1) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bounded_hashcode_nat (array_length a) k)\n       (AList.delete k\n         (array_get a (bounded_hashcode_nat (array_length a) k))))\n 2. 1 < array_length\n         (array_set a (bounded_hashcode_nat (array_length a) k)\n           (AList.delete k\n             (array_get a (bounded_hashcode_nat (array_length a) k))))", "let ?f = \"\\<lambda>n kvs. n + length kvs\""], ["proof (state)\ngoal (2 subgoals):\n 1. (if map_of (array_get a (bounded_hashcode_nat (array_length a) k)) k =\n        None\n     then n else n - 1) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bounded_hashcode_nat (array_length a) k)\n       (AList.delete k\n         (array_get a (bounded_hashcode_nat (array_length a) k))))\n 2. 1 < array_length\n         (array_set a (bounded_hashcode_nat (array_length a) k)\n           (AList.delete k\n             (array_get a (bounded_hashcode_nat (array_length a) k))))", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. (if map_of (array_get a (bounded_hashcode_nat (array_length a) k)) k =\n        None\n     then n else n - 1) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bounded_hashcode_nat (array_length a) k)\n       (AList.delete k\n         (array_get a (bounded_hashcode_nat (array_length a) k))))\n 2. 1 < array_length\n         (array_set a (bounded_hashcode_nat (array_length a) k)\n           (AList.delete k\n             (array_get a (bounded_hashcode_nat (array_length a) k))))", "fix n :: nat and xs :: \"('a \\<times> 'b) list list\""], ["proof (state)\ngoal (2 subgoals):\n 1. (if map_of (array_get a (bounded_hashcode_nat (array_length a) k)) k =\n        None\n     then n__ else n__ - 1) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bounded_hashcode_nat (array_length a) k)\n       (AList.delete k\n         (array_get a (bounded_hashcode_nat (array_length a) k))))\n 2. 1 < array_length\n         (array_set a (bounded_hashcode_nat (array_length a) k)\n           (AList.delete k\n             (array_get a (bounded_hashcode_nat (array_length a) k))))", "have \"foldl ?f n xs = n + foldl ?f 0 xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldl (\\<lambda>n kvs. n + length kvs) n xs =\n    n + foldl (\\<lambda>n kvs. n + length kvs) 0 xs", "by(induct xs arbitrary:  rule: rev_induct) simp_all"], ["proof (state)\nthis:\n  foldl (\\<lambda>n kvs. n + length kvs) n xs =\n  n + foldl (\\<lambda>n kvs. n + length kvs) 0 xs\n\ngoal (2 subgoals):\n 1. (if map_of (array_get a (bounded_hashcode_nat (array_length a) k)) k =\n        None\n     then n__ else n__ - 1) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bounded_hashcode_nat (array_length a) k)\n       (AList.delete k\n         (array_get a (bounded_hashcode_nat (array_length a) k))))\n 2. 1 < array_length\n         (array_set a (bounded_hashcode_nat (array_length a) k)\n           (AList.delete k\n             (array_get a (bounded_hashcode_nat (array_length a) k))))", "}"], ["proof (state)\nthis:\n  foldl (\\<lambda>n kvs. n + length kvs) ?na3 ?xsa3 =\n  ?na3 + foldl (\\<lambda>n kvs. n + length kvs) 0 ?xsa3\n\ngoal (2 subgoals):\n 1. (if map_of (array_get a (bounded_hashcode_nat (array_length a) k)) k =\n        None\n     then n else n - 1) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bounded_hashcode_nat (array_length a) k)\n       (AList.delete k\n         (array_get a (bounded_hashcode_nat (array_length a) k))))\n 2. 1 < array_length\n         (array_set a (bounded_hashcode_nat (array_length a) k)\n           (AList.delete k\n             (array_get a (bounded_hashcode_nat (array_length a) k))))", "note fold = this"], ["proof (state)\nthis:\n  foldl (\\<lambda>n kvs. n + length kvs) ?na3 ?xsa3 =\n  ?na3 + foldl (\\<lambda>n kvs. n + length kvs) 0 ?xsa3\n\ngoal (2 subgoals):\n 1. (if map_of (array_get a (bounded_hashcode_nat (array_length a) k)) k =\n        None\n     then n else n - 1) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bounded_hashcode_nat (array_length a) k)\n       (AList.delete k\n         (array_get a (bounded_hashcode_nat (array_length a) k))))\n 2. 1 < array_length\n         (array_set a (bounded_hashcode_nat (array_length a) k)\n           (AList.delete k\n             (array_get a (bounded_hashcode_nat (array_length a) k))))", "from inv"], ["proof (chain)\npicking this:\n  ahm_invar hm", "have [simp]: \"bounded_hashcode_nat (length xs) k < length xs\""], ["proof (prove)\nusing this:\n  ahm_invar hm\n\ngoal (1 subgoal):\n 1. bounded_hashcode_nat (length xs) k < length xs", "by(simp add: ahm_invar_aux_def bounded_hashcode_nat_bounds)"], ["proof (state)\nthis:\n  bounded_hashcode_nat (length xs) k < length xs\n\ngoal (2 subgoals):\n 1. (if map_of (array_get a (bounded_hashcode_nat (array_length a) k)) k =\n        None\n     then n else n - 1) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bounded_hashcode_nat (array_length a) k)\n       (AList.delete k\n         (array_get a (bounded_hashcode_nat (array_length a) k))))\n 2. 1 < array_length\n         (array_set a (bounded_hashcode_nat (array_length a) k)\n           (AList.delete k\n             (array_get a (bounded_hashcode_nat (array_length a) k))))", "from inv"], ["proof (chain)\npicking this:\n  ahm_invar hm", "have \"distinct (map fst (array_get a ?h))\""], ["proof (prove)\nusing this:\n  ahm_invar hm\n\ngoal (1 subgoal):\n 1. distinct\n     (map fst (array_get a (bounded_hashcode_nat (array_length a) k)))", "by(auto elim: ahm_invar_auxE)"], ["proof (state)\nthis:\n  distinct (map fst (array_get a (bounded_hashcode_nat (array_length a) k)))\n\ngoal (2 subgoals):\n 1. (if map_of (array_get a (bounded_hashcode_nat (array_length a) k)) k =\n        None\n     then n else n - 1) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bounded_hashcode_nat (array_length a) k)\n       (AList.delete k\n         (array_get a (bounded_hashcode_nat (array_length a) k))))\n 2. 1 < array_length\n         (array_set a (bounded_hashcode_nat (array_length a) k)\n           (AList.delete k\n             (array_get a (bounded_hashcode_nat (array_length a) k))))", "moreover"], ["proof (state)\nthis:\n  distinct (map fst (array_get a (bounded_hashcode_nat (array_length a) k)))\n\ngoal (2 subgoals):\n 1. (if map_of (array_get a (bounded_hashcode_nat (array_length a) k)) k =\n        None\n     then n else n - 1) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bounded_hashcode_nat (array_length a) k)\n       (AList.delete k\n         (array_get a (bounded_hashcode_nat (array_length a) k))))\n 2. 1 < array_length\n         (array_set a (bounded_hashcode_nat (array_length a) k)\n           (AList.delete k\n             (array_get a (bounded_hashcode_nat (array_length a) k))))", "have xs: \"xs = take ?h xs @ (xs ! ?h) # drop (Suc ?h) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs =\n    take (bounded_hashcode_nat (array_length a) k) xs @\n    xs ! bounded_hashcode_nat (array_length a) k #\n    drop (Suc (bounded_hashcode_nat (array_length a) k)) xs", "by(simp add: Cons_nth_drop_Suc)"], ["proof (state)\nthis:\n  xs =\n  take (bounded_hashcode_nat (array_length a) k) xs @\n  xs ! bounded_hashcode_nat (array_length a) k #\n  drop (Suc (bounded_hashcode_nat (array_length a) k)) xs\n\ngoal (2 subgoals):\n 1. (if map_of (array_get a (bounded_hashcode_nat (array_length a) k)) k =\n        None\n     then n else n - 1) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bounded_hashcode_nat (array_length a) k)\n       (AList.delete k\n         (array_get a (bounded_hashcode_nat (array_length a) k))))\n 2. 1 < array_length\n         (array_set a (bounded_hashcode_nat (array_length a) k)\n           (AList.delete k\n             (array_get a (bounded_hashcode_nat (array_length a) k))))", "from inv"], ["proof (chain)\npicking this:\n  ahm_invar hm", "have \"n = array_foldl (\\<lambda>_ n kvs. n + length kvs) 0 a\""], ["proof (prove)\nusing this:\n  ahm_invar hm\n\ngoal (1 subgoal):\n 1. n = array_foldl (\\<lambda>_ n kvs. n + length kvs) 0 a", "by(auto elim: ahm_invar_auxE)"], ["proof (state)\nthis:\n  n = array_foldl (\\<lambda>_ n kvs. n + length kvs) 0 a\n\ngoal (2 subgoals):\n 1. (if map_of (array_get a (bounded_hashcode_nat (array_length a) k)) k =\n        None\n     then n else n - 1) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bounded_hashcode_nat (array_length a) k)\n       (AList.delete k\n         (array_get a (bounded_hashcode_nat (array_length a) k))))\n 2. 1 < array_length\n         (array_set a (bounded_hashcode_nat (array_length a) k)\n           (AList.delete k\n             (array_get a (bounded_hashcode_nat (array_length a) k))))", "hence \"n = foldl ?f 0 (take ?h xs) + length (xs ! ?h) + foldl ?f 0 (drop (Suc ?h) xs)\""], ["proof (prove)\nusing this:\n  n = array_foldl (\\<lambda>_ n kvs. n + length kvs) 0 a\n\ngoal (1 subgoal):\n 1. n =\n    foldl (\\<lambda>n kvs. n + length kvs) 0\n     (take (bounded_hashcode_nat (array_length a) k) xs) +\n    length (xs ! bounded_hashcode_nat (array_length a) k) +\n    foldl (\\<lambda>n kvs. n + length kvs) 0\n     (drop (Suc (bounded_hashcode_nat (array_length a) k)) xs)", "by(simp add: array_foldl_foldl)(subst xs, simp, subst (1 2 3 4) fold, simp)"], ["proof (state)\nthis:\n  n =\n  foldl (\\<lambda>n kvs. n + length kvs) 0\n   (take (bounded_hashcode_nat (array_length a) k) xs) +\n  length (xs ! bounded_hashcode_nat (array_length a) k) +\n  foldl (\\<lambda>n kvs. n + length kvs) 0\n   (drop (Suc (bounded_hashcode_nat (array_length a) k)) xs)\n\ngoal (2 subgoals):\n 1. (if map_of (array_get a (bounded_hashcode_nat (array_length a) k)) k =\n        None\n     then n else n - 1) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bounded_hashcode_nat (array_length a) k)\n       (AList.delete k\n         (array_get a (bounded_hashcode_nat (array_length a) k))))\n 2. 1 < array_length\n         (array_set a (bounded_hashcode_nat (array_length a) k)\n           (AList.delete k\n             (array_get a (bounded_hashcode_nat (array_length a) k))))", "ultimately"], ["proof (chain)\npicking this:\n  distinct (map fst (array_get a (bounded_hashcode_nat (array_length a) k)))\n  n =\n  foldl (\\<lambda>n kvs. n + length kvs) 0\n   (take (bounded_hashcode_nat (array_length a) k) xs) +\n  length (xs ! bounded_hashcode_nat (array_length a) k) +\n  foldl (\\<lambda>n kvs. n + length kvs) 0\n   (drop (Suc (bounded_hashcode_nat (array_length a) k)) xs)", "show \"?n' = array_foldl (\\<lambda>_ n kvs. n + length kvs) 0 ?a'\""], ["proof (prove)\nusing this:\n  distinct (map fst (array_get a (bounded_hashcode_nat (array_length a) k)))\n  n =\n  foldl (\\<lambda>n kvs. n + length kvs) 0\n   (take (bounded_hashcode_nat (array_length a) k) xs) +\n  length (xs ! bounded_hashcode_nat (array_length a) k) +\n  foldl (\\<lambda>n kvs. n + length kvs) 0\n   (drop (Suc (bounded_hashcode_nat (array_length a) k)) xs)\n\ngoal (1 subgoal):\n 1. (if map_of (array_get a (bounded_hashcode_nat (array_length a) k)) k =\n        None\n     then n else n - 1) =\n    array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n     (array_set a (bounded_hashcode_nat (array_length a) k)\n       (AList.delete k\n         (array_get a (bounded_hashcode_nat (array_length a) k))))", "apply(simp add: array_foldl_foldl foldl_list_update map_of_eq_None_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (map fst (xs ! bounded_hashcode_nat (length xs) k));\n     n =\n     foldl (\\<lambda>n kvs. n + length kvs) 0\n      (take (bounded_hashcode_nat (length xs) k) xs) +\n     length (xs ! bounded_hashcode_nat (length xs) k) +\n     foldl (\\<lambda>n kvs. n + length kvs) 0\n      (drop (Suc (bounded_hashcode_nat (length xs) k)) xs)\\<rbrakk>\n    \\<Longrightarrow> (k \\<in> fst `\n                               set (xs !\n                                    bounded_hashcode_nat (length xs)\n                                     k) \\<longrightarrow>\n                       foldl (\\<lambda>n kvs. n + length kvs) 0\n                        (take (bounded_hashcode_nat (length xs) k) xs) +\n                       length (xs ! bounded_hashcode_nat (length xs) k) +\n                       foldl (\\<lambda>n kvs. n + length kvs) 0\n                        (drop (Suc (bounded_hashcode_nat (length xs) k))\n                          xs) -\n                       Suc 0 =\n                       foldl (\\<lambda>n kvs. n + length kvs)\n                        (foldl (\\<lambda>n kvs. n + length kvs) 0\n                          (take (bounded_hashcode_nat (length xs) k) xs) +\n                         length\n                          (AList.delete k\n                            (xs ! bounded_hashcode_nat (length xs) k)))\n                        (drop (Suc (bounded_hashcode_nat (length xs) k))\n                          xs)) \\<and>\n                      (k \\<notin> fst `\n                                  set (xs !\n bounded_hashcode_nat (length xs) k) \\<longrightarrow>\n                       foldl (\\<lambda>n kvs. n + length kvs) 0\n                        (take (bounded_hashcode_nat (length xs) k) xs) +\n                       length (xs ! bounded_hashcode_nat (length xs) k) +\n                       foldl (\\<lambda>n kvs. n + length kvs) 0\n                        (drop (Suc (bounded_hashcode_nat (length xs) k))\n                          xs) =\n                       foldl (\\<lambda>n kvs. n + length kvs)\n                        (foldl (\\<lambda>n kvs. n + length kvs) 0\n                          (take (bounded_hashcode_nat (length xs) k) xs) +\n                         length (xs ! bounded_hashcode_nat (length xs) k))\n                        (drop (Suc (bounded_hashcode_nat (length xs) k))\n                          xs))", "apply(subst (1 2 3 4 5 6 7 8) fold)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct (map fst (xs ! bounded_hashcode_nat (length xs) k));\n     n =\n     foldl (\\<lambda>n kvs. n + length kvs) 0\n      (take (bounded_hashcode_nat (length xs) k) xs) +\n     length (xs ! bounded_hashcode_nat (length xs) k) +\n     foldl (\\<lambda>n kvs. n + length kvs) 0\n      (drop (Suc (bounded_hashcode_nat (length xs) k)) xs)\\<rbrakk>\n    \\<Longrightarrow> (k \\<in> fst `\n                               set (xs !\n                                    bounded_hashcode_nat (length xs)\n                                     k) \\<longrightarrow>\n                       0 +\n                       foldl (\\<lambda>n kvs. n + length kvs) 0\n                        (take (bounded_hashcode_nat (length xs) k) xs) +\n                       length (xs ! bounded_hashcode_nat (length xs) k) +\n                       (0 +\n                        foldl (\\<lambda>n kvs. n + length kvs) 0\n                         (drop (Suc (bounded_hashcode_nat (length xs) k))\n                           xs)) -\n                       Suc 0 =\n                       0 +\n                       foldl (\\<lambda>n kvs. n + length kvs) 0\n                        (take (bounded_hashcode_nat (length xs) k) xs) +\n                       length\n                        (AList.delete k\n                          (xs ! bounded_hashcode_nat (length xs) k)) +\n                       foldl (\\<lambda>n kvs. n + length kvs) 0\n                        (drop (Suc (bounded_hashcode_nat (length xs) k))\n                          xs)) \\<and>\n                      (k \\<notin> fst `\n                                  set (xs !\n bounded_hashcode_nat (length xs) k) \\<longrightarrow>\n                       0 +\n                       foldl (\\<lambda>n kvs. n + length kvs) 0\n                        (take (bounded_hashcode_nat (length xs) k) xs) +\n                       length (xs ! bounded_hashcode_nat (length xs) k) +\n                       (0 +\n                        foldl (\\<lambda>n kvs. n + length kvs) 0\n                         (drop (Suc (bounded_hashcode_nat (length xs) k))\n                           xs)) =\n                       0 +\n                       foldl (\\<lambda>n kvs. n + length kvs) 0\n                        (take (bounded_hashcode_nat (length xs) k) xs) +\n                       length (xs ! bounded_hashcode_nat (length xs) k) +\n                       foldl (\\<lambda>n kvs. n + length kvs) 0\n                        (drop (Suc (bounded_hashcode_nat (length xs) k))\n                          xs))", "apply(auto simp add: length_distinct in_set_conv_nth)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (if map_of (array_get a (bounded_hashcode_nat (array_length a) k)) k =\n      None\n   then n else n - 1) =\n  array_foldl (\\<lambda>_ n kvs. n + length kvs) 0\n   (array_set a (bounded_hashcode_nat (array_length a) k)\n     (AList.delete k\n       (array_get a (bounded_hashcode_nat (array_length a) k))))\n\ngoal (1 subgoal):\n 1. 1 < array_length\n         (array_set a (bounded_hashcode_nat (array_length a) k)\n           (AList.delete k\n             (array_get a (bounded_hashcode_nat (array_length a) k))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 1 < array_length\n         (array_set a (bounded_hashcode_nat (array_length a) k)\n           (AList.delete k\n             (array_get a (bounded_hashcode_nat (array_length a) k))))", "from inv"], ["proof (chain)\npicking this:\n  ahm_invar hm", "show \"1 < array_length ?a'\""], ["proof (prove)\nusing this:\n  ahm_invar hm\n\ngoal (1 subgoal):\n 1. 1 < array_length\n         (array_set a (bounded_hashcode_nat (array_length a) k)\n           (AList.delete k\n             (array_get a (bounded_hashcode_nat (array_length a) k))))", "by(auto elim: ahm_invar_auxE)"], ["proof (state)\nthis:\n  1 < array_length\n       (array_set a (bounded_hashcode_nat (array_length a) k)\n         (AList.delete k\n           (array_get a (bounded_hashcode_nat (array_length a) k))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ahm_invar_aux\n   (if map_of (array_get a (bounded_hashcode_nat (array_length a) k)) k =\n       None\n    then n else n - 1)\n   (array_set a (bounded_hashcode_nat (array_length a) k)\n     (AList.delete k\n       (array_get a (bounded_hashcode_nat (array_length a) k))))\n\ngoal (2 subgoals):\n 1. ahm_invar (ahm_delete k hm)\n 2. ahm_\\<alpha> (ahm_delete k hm) = ahm_\\<alpha> hm |` (- {k})", "thus \"?thesis1\""], ["proof (prove)\nusing this:\n  ahm_invar_aux\n   (if map_of (array_get a (bounded_hashcode_nat (array_length a) k)) k =\n       None\n    then n else n - 1)\n   (array_set a (bounded_hashcode_nat (array_length a) k)\n     (AList.delete k\n       (array_get a (bounded_hashcode_nat (array_length a) k))))\n\ngoal (1 subgoal):\n 1. ahm_invar (ahm_delete k hm)", "by(auto simp add: Let_def)"], ["proof (state)\nthis:\n  ahm_invar (ahm_delete k hm)\n\ngoal (1 subgoal):\n 1. ahm_\\<alpha> (ahm_delete k hm) = ahm_\\<alpha> hm |` (- {k})", "have \"ahm_\\<alpha>_aux ?a' = ahm_\\<alpha>_aux a |` (- {k})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ahm_\\<alpha>_aux\n     (array_set a (bounded_hashcode_nat (array_length a) k)\n       (AList.delete k\n         (array_get a (bounded_hashcode_nat (array_length a) k)))) =\n    ahm_\\<alpha>_aux a |` (- {k})", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       ahm_\\<alpha>_aux\n        (array_set a (bounded_hashcode_nat (array_length a) k)\n          (AList.delete k\n            (array_get a (bounded_hashcode_nat (array_length a) k))))\n        x =\n       (ahm_\\<alpha>_aux a |` (- {k})) x", "fix k' :: 'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       ahm_\\<alpha>_aux\n        (array_set a (bounded_hashcode_nat (array_length a) k)\n          (AList.delete k\n            (array_get a (bounded_hashcode_nat (array_length a) k))))\n        x =\n       (ahm_\\<alpha>_aux a |` (- {k})) x", "from inv"], ["proof (chain)\npicking this:\n  ahm_invar hm", "have \"bounded_hashcode_nat (array_length a) k < array_length a\""], ["proof (prove)\nusing this:\n  ahm_invar hm\n\ngoal (1 subgoal):\n 1. bounded_hashcode_nat (array_length a) k < array_length a", "by(auto elim: ahm_invar_auxE simp add: bounded_hashcode_nat_bounds)"], ["proof (state)\nthis:\n  bounded_hashcode_nat (array_length a) k < array_length a\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       ahm_\\<alpha>_aux\n        (array_set a (bounded_hashcode_nat (array_length a) k)\n          (AList.delete k\n            (array_get a (bounded_hashcode_nat (array_length a) k))))\n        x =\n       (ahm_\\<alpha>_aux a |` (- {k})) x", "thus \"ahm_\\<alpha>_aux ?a' k' = (ahm_\\<alpha>_aux a |` (- {k})) k'\""], ["proof (prove)\nusing this:\n  bounded_hashcode_nat (array_length a) k < array_length a\n\ngoal (1 subgoal):\n 1. ahm_\\<alpha>_aux\n     (array_set a (bounded_hashcode_nat (array_length a) k)\n       (AList.delete k\n         (array_get a (bounded_hashcode_nat (array_length a) k))))\n     k' =\n    (ahm_\\<alpha>_aux a |` (- {k})) k'", "by(cases \"?h = bounded_hashcode_nat (array_length a) k'\")(auto simp add: restrict_map_def array_get_array_set_other delete_conv)"], ["proof (state)\nthis:\n  ahm_\\<alpha>_aux\n   (array_set a (bounded_hashcode_nat (array_length a) k)\n     (AList.delete k\n       (array_get a (bounded_hashcode_nat (array_length a) k))))\n   k' =\n  (ahm_\\<alpha>_aux a |` (- {k})) k'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ahm_\\<alpha>_aux\n   (array_set a (bounded_hashcode_nat (array_length a) k)\n     (AList.delete k\n       (array_get a (bounded_hashcode_nat (array_length a) k)))) =\n  ahm_\\<alpha>_aux a |` (- {k})\n\ngoal (1 subgoal):\n 1. ahm_\\<alpha> (ahm_delete k hm) = ahm_\\<alpha> hm |` (- {k})", "thus ?thesis2"], ["proof (prove)\nusing this:\n  ahm_\\<alpha>_aux\n   (array_set a (bounded_hashcode_nat (array_length a) k)\n     (AList.delete k\n       (array_get a (bounded_hashcode_nat (array_length a) k)))) =\n  ahm_\\<alpha>_aux a |` (- {k})\n\ngoal (1 subgoal):\n 1. ahm_\\<alpha> (ahm_delete k hm) = ahm_\\<alpha> hm |` (- {k})", "by(simp add: Let_def)"], ["proof (state)\nthis:\n  ahm_\\<alpha> (ahm_delete k hm) = ahm_\\<alpha> hm |` (- {k})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ahm_delete_impl:\n  \"map_delete ahm_\\<alpha> ahm_invar ahm_delete\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_delete ahm_\\<alpha> ahm_invar ahm_delete", "by(unfold_locales)(blast intro: ahm_delete_correct)+"], ["", "hide_const (open) HashMap ahm_empty bucket_ok ahm_invar ahm_\\<alpha> ahm_lookup\n  ahm_iteratei ahm_rehash hm_grow ahm_filled ahm_update ahm_delete"], ["", "hide_type (open) hashmap"], ["", "end"]]}