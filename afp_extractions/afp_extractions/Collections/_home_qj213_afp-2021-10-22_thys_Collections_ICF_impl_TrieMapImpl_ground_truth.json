{"file_name": "/home/qj213/afp-2021-10-22/thys/Collections/ICF/impl/TrieMapImpl.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Collections", "problem_names": ["lemma pi_trie_impl[proper_it]: \n  shows \"proper_it'\n    ((Trie_Impl.iteratei) :: _ \\<Rightarrow> (_,'\\<sigma>a) set_iterator)\n    ((Trie_Impl.iteratei) :: _ \\<Rightarrow> (_,'\\<sigma>b) set_iterator)\"", "lemma pi_trie[proper_it]: \n  \"proper_it' Trie2.iteratei Trie2.iteratei\""], "translations": [["", "lemma pi_trie_impl[proper_it]: \n  shows \"proper_it'\n    ((Trie_Impl.iteratei) :: _ \\<Rightarrow> (_,'\\<sigma>a) set_iterator)\n    ((Trie_Impl.iteratei) :: _ \\<Rightarrow> (_,'\\<sigma>b) set_iterator)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it' Trie_Impl.iteratei Trie_Impl.iteratei", "unfolding Trie_Impl.iteratei_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it' (iteratei_postfixed []) (iteratei_postfixed [])", "proof (rule proper_it'I)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. proper_it (iteratei_postfixed [] s) (iteratei_postfixed [] s)", "(*note [[show_types, show_consts]]*)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. proper_it (iteratei_postfixed [] s) (iteratei_postfixed [] s)", "fix t :: \"('k,'v) Trie.trie\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. proper_it (iteratei_postfixed [] s) (iteratei_postfixed [] s)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. proper_it (iteratei_postfixed [] s) (iteratei_postfixed [] s)", "fix l and t :: \"('k,'v) Trie.trie\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s. proper_it (iteratei_postfixed [] s) (iteratei_postfixed [] s)", "have \"proper_it ((Trie_Impl.iteratei_postfixed l t)\n       :: (_,'\\<sigma>a) set_iterator)\n      ((Trie_Impl.iteratei_postfixed l t)\n       :: (_,'\\<sigma>b) set_iterator)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it (iteratei_postfixed l t) (iteratei_postfixed l t)", "proof (induct t arbitrary: l)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>vo kvs l.\n       (\\<And>k t l.\n           (k, t) \\<in> set kvs \\<Longrightarrow>\n           proper_it (iteratei_postfixed l t)\n            (iteratei_postfixed l t)) \\<Longrightarrow>\n       proper_it (iteratei_postfixed l (Trie.trie.Trie vo kvs))\n        (iteratei_postfixed l (Trie.trie.Trie vo kvs))", "case (Trie vo kvs l)"], ["proof (state)\nthis:\n  (?k, ?t) \\<in> set kvs \\<Longrightarrow>\n  proper_it (iteratei_postfixed ?l ?t) (iteratei_postfixed ?l ?t)\n\ngoal (1 subgoal):\n 1. \\<And>vo kvs l.\n       (\\<And>k t l.\n           (k, t) \\<in> set kvs \\<Longrightarrow>\n           proper_it (iteratei_postfixed l t)\n            (iteratei_postfixed l t)) \\<Longrightarrow>\n       proper_it (iteratei_postfixed l (Trie.trie.Trie vo kvs))\n        (iteratei_postfixed l (Trie.trie.Trie vo kvs))", "let ?ITA = \"\\<lambda>l t. (Trie_Impl.iteratei_postfixed l t)\n        :: (_,'\\<sigma>a) set_iterator\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>vo kvs l.\n       (\\<And>k t l.\n           (k, t) \\<in> set kvs \\<Longrightarrow>\n           proper_it (iteratei_postfixed l t)\n            (iteratei_postfixed l t)) \\<Longrightarrow>\n       proper_it (iteratei_postfixed l (Trie.trie.Trie vo kvs))\n        (iteratei_postfixed l (Trie.trie.Trie vo kvs))", "let ?ITB = \"\\<lambda>l t. (Trie_Impl.iteratei_postfixed l t)\n        :: (_,'\\<sigma>b) set_iterator\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>vo kvs l.\n       (\\<And>k t l.\n           (k, t) \\<in> set kvs \\<Longrightarrow>\n           proper_it (iteratei_postfixed l t)\n            (iteratei_postfixed l t)) \\<Longrightarrow>\n       proper_it (iteratei_postfixed l (Trie.trie.Trie vo kvs))\n        (iteratei_postfixed l (Trie.trie.Trie vo kvs))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it (iteratei_postfixed l (Trie.trie.Trie vo kvs))\n     (iteratei_postfixed l (Trie.trie.Trie vo kvs))", "unfolding Trie_Impl.iteratei_postfixed_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it\n     (set_iterator_union\n       (case vo of None \\<Rightarrow> set_iterator_emp\n        | Some v \\<Rightarrow> set_iterator_sng (l, v))\n       (set_iterator_image snd\n         (set_iterator_product (foldli kvs)\n           (\\<lambda>(k, y). iteratei_postfixed (k # l) y))))\n     (set_iterator_union\n       (case vo of None \\<Rightarrow> set_iterator_emp\n        | Some v \\<Rightarrow> set_iterator_sng (l, v))\n       (set_iterator_image snd\n         (set_iterator_product (foldli kvs)\n           (\\<lambda>(k, y). iteratei_postfixed (k # l) y))))", "apply (rule pi_union)"], ["proof (prove)\ngoal (2 subgoals):\n 1. proper_it\n     (case vo of None \\<Rightarrow> set_iterator_emp\n      | Some v \\<Rightarrow> set_iterator_sng (l, v))\n     (case vo of None \\<Rightarrow> set_iterator_emp\n      | Some v \\<Rightarrow> set_iterator_sng (l, v))\n 2. proper_it\n     (set_iterator_image snd\n       (set_iterator_product (foldli kvs)\n         (\\<lambda>(k, y). iteratei_postfixed (k # l) y)))\n     (set_iterator_image snd\n       (set_iterator_product (foldli kvs)\n         (\\<lambda>(k, y). iteratei_postfixed (k # l) y)))", "apply (auto split: option.split intro: icf_proper_iteratorI) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it\n     (set_iterator_image snd\n       (set_iterator_product (foldli kvs)\n         (\\<lambda>(k, y). iteratei_postfixed (k # l) y)))\n     (set_iterator_image snd\n       (set_iterator_product (foldli kvs)\n         (\\<lambda>(k, y). iteratei_postfixed (k # l) y)))", "proof (rule pi_image)"], ["proof (state)\ngoal (1 subgoal):\n 1. proper_it\n     (set_iterator_product (foldli kvs)\n       (\\<lambda>(k, y). iteratei_postfixed (k # l) y))\n     (set_iterator_product (foldli kvs)\n       (\\<lambda>(k, y). iteratei_postfixed (k # l) y))", "define bs where \"bs = (\\<lambda>(k,t). SOME l'::('k list \\<times> 'v) list. \n          ?ITA (k#l) t = foldli l' \\<and> ?ITB (k#l) t = foldli l')\""], ["proof (state)\nthis:\n  bs =\n  (\\<lambda>(k, t).\n      SOME l'.\n         iteratei_postfixed (k # l) t = foldli l' \\<and>\n         iteratei_postfixed (k # l) t = foldli l')\n\ngoal (1 subgoal):\n 1. proper_it\n     (set_iterator_product (foldli kvs)\n       (\\<lambda>(k, y). iteratei_postfixed (k # l) y))\n     (set_iterator_product (foldli kvs)\n       (\\<lambda>(k, y). iteratei_postfixed (k # l) y))", "have EQ1: \"\\<forall>(k,t)\\<in>set kvs. ?ITA (k#l) t = foldli (bs (k,t))\" and\n          EQ2: \"\\<forall>(k,t)\\<in>set kvs. ?ITB (k#l) t = foldli (bs (k,t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(k, t)\\<in>set kvs.\n       iteratei_postfixed (k # l) t = foldli (bs (k, t)) &&&\n    \\<forall>(k, t)\\<in>set kvs.\n       iteratei_postfixed (k # l) t = foldli (bs (k, t))", "proof (safe)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       (a, b) \\<in> set kvs \\<Longrightarrow>\n       iteratei_postfixed (a # l) b = foldli (bs (a, b))\n 2. \\<And>a b.\n       (a, b) \\<in> set kvs \\<Longrightarrow>\n       iteratei_postfixed (a # l) b = foldli (bs (a, b))", "fix k t"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       (a, b) \\<in> set kvs \\<Longrightarrow>\n       iteratei_postfixed (a # l) b = foldli (bs (a, b))\n 2. \\<And>a b.\n       (a, b) \\<in> set kvs \\<Longrightarrow>\n       iteratei_postfixed (a # l) b = foldli (bs (a, b))", "assume A: \"(k,t) \\<in> set kvs\""], ["proof (state)\nthis:\n  (k, t) \\<in> set kvs\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       (a, b) \\<in> set kvs \\<Longrightarrow>\n       iteratei_postfixed (a # l) b = foldli (bs (a, b))\n 2. \\<And>a b.\n       (a, b) \\<in> set kvs \\<Longrightarrow>\n       iteratei_postfixed (a # l) b = foldli (bs (a, b))", "from Trie.hyps[OF A, of \"k#l\"]"], ["proof (chain)\npicking this:\n  proper_it (iteratei_postfixed (k # l) t) (iteratei_postfixed (k # l) t)", "have \n            PI: \"proper_it (?ITA (k#l) t) (?ITB (k#l) t)\""], ["proof (prove)\nusing this:\n  proper_it (iteratei_postfixed (k # l) t) (iteratei_postfixed (k # l) t)\n\ngoal (1 subgoal):\n 1. proper_it (iteratei_postfixed (k # l) t) (iteratei_postfixed (k # l) t)", "by assumption"], ["proof (state)\nthis:\n  proper_it (iteratei_postfixed (k # l) t) (iteratei_postfixed (k # l) t)\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       (a, b) \\<in> set kvs \\<Longrightarrow>\n       iteratei_postfixed (a # l) b = foldli (bs (a, b))\n 2. \\<And>a b.\n       (a, b) \\<in> set kvs \\<Longrightarrow>\n       iteratei_postfixed (a # l) b = foldli (bs (a, b))", "obtain l' where \n            \"?ITA (k#l) t = foldli l'\n          \\<and> (?ITB (k#l) t) = foldli l'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        iteratei_postfixed (k # l) t = foldli l' \\<and>\n        iteratei_postfixed (k # l) t = foldli l' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (blast intro: proper_itE[OF PI])"], ["proof (state)\nthis:\n  iteratei_postfixed (k # l) t = foldli l' \\<and>\n  iteratei_postfixed (k # l) t = foldli l'\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       (a, b) \\<in> set kvs \\<Longrightarrow>\n       iteratei_postfixed (a # l) b = foldli (bs (a, b))\n 2. \\<And>a b.\n       (a, b) \\<in> set kvs \\<Longrightarrow>\n       iteratei_postfixed (a # l) b = foldli (bs (a, b))", "thus \"?ITA (k#l) t = foldli (bs (k,t))\"\n            \"?ITB (k#l) t = foldli (bs (k,t))\""], ["proof (prove)\nusing this:\n  iteratei_postfixed (k # l) t = foldli l' \\<and>\n  iteratei_postfixed (k # l) t = foldli l'\n\ngoal (1 subgoal):\n 1. iteratei_postfixed (k # l) t = foldli (bs (k, t)) &&&\n    iteratei_postfixed (k # l) t = foldli (bs (k, t))", "unfolding bs_def"], ["proof (prove)\nusing this:\n  iteratei_postfixed (k # l) t = foldli l' \\<and>\n  iteratei_postfixed (k # l) t = foldli l'\n\ngoal (1 subgoal):\n 1. iteratei_postfixed (k # l) t =\n    foldli\n     (case (k, t) of\n      (k, t) \\<Rightarrow>\n        SOME l'.\n           iteratei_postfixed (k # l) t = foldli l' \\<and>\n           iteratei_postfixed (k # l) t = foldli l') &&&\n    iteratei_postfixed (k # l) t =\n    foldli\n     (case (k, t) of\n      (k, t) \\<Rightarrow>\n        SOME l'.\n           iteratei_postfixed (k # l) t = foldli l' \\<and>\n           iteratei_postfixed (k # l) t = foldli l')", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>iteratei_postfixed (k # l) t = foldli l';\n     iteratei_postfixed (k # l) t = foldli l'\\<rbrakk>\n    \\<Longrightarrow> foldli l' =\n                      foldli\n                       (SOME l'a.\n                           foldli l' = foldli l'a \\<and>\n                           foldli l' = foldli l'a)\n 2. \\<lbrakk>iteratei_postfixed (k # l) t = foldli l';\n     iteratei_postfixed (k # l) t = foldli l'\\<rbrakk>\n    \\<Longrightarrow> foldli l' =\n                      foldli\n                       (SOME l'a.\n                           foldli l' = foldli l'a \\<and>\n                           foldli l' = foldli l'a)", "apply (metis (lifting, full_types) someI_ex)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>iteratei_postfixed (k # l) t = foldli l';\n     iteratei_postfixed (k # l) t = foldli l'\\<rbrakk>\n    \\<Longrightarrow> foldli l' =\n                      foldli\n                       (SOME l'a.\n                           foldli l' = foldli l'a \\<and>\n                           foldli l' = foldli l'a)", "apply (metis (lifting, full_types) someI_ex)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  iteratei_postfixed (k # l) t = foldli (bs (k, t))\n  iteratei_postfixed (k # l) t = foldli (bs (k, t))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>(k, t)\\<in>set kvs.\n     iteratei_postfixed (k # l) t = foldli (bs (k, t))\n  \\<forall>(k, t)\\<in>set kvs.\n     iteratei_postfixed (k # l) t = foldli (bs (k, t))\n\ngoal (1 subgoal):\n 1. proper_it\n     (set_iterator_product (foldli kvs)\n       (\\<lambda>(k, y). iteratei_postfixed (k # l) y))\n     (set_iterator_product (foldli kvs)\n       (\\<lambda>(k, y). iteratei_postfixed (k # l) y))", "have PEQ1: \"set_iterator_product (foldli kvs) (\\<lambda>(k,t). ?ITA (k#l) t) \n          = set_iterator_product (foldli kvs) (\\<lambda>kt. foldli (bs kt))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_product (foldli kvs)\n     (\\<lambda>(k, t). iteratei_postfixed (k # l) t) =\n    set_iterator_product (foldli kvs) (\\<lambda>kt. foldli (bs kt))", "apply (rule set_iterator_product_eq2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set kvs.\n       (case a of (k, t) \\<Rightarrow> iteratei_postfixed (k # l) t) =\n       foldli (bs a)", "using EQ1"], ["proof (prove)\nusing this:\n  \\<forall>(k, t)\\<in>set kvs.\n     iteratei_postfixed (k # l) t = foldli (bs (k, t))\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set kvs.\n       (case a of (k, t) \\<Rightarrow> iteratei_postfixed (k # l) t) =\n       foldli (bs a)", "by auto"], ["proof (state)\nthis:\n  set_iterator_product (foldli kvs)\n   (\\<lambda>(k, t). iteratei_postfixed (k # l) t) =\n  set_iterator_product (foldli kvs) (\\<lambda>kt. foldli (bs kt))\n\ngoal (1 subgoal):\n 1. proper_it\n     (set_iterator_product (foldli kvs)\n       (\\<lambda>(k, y). iteratei_postfixed (k # l) y))\n     (set_iterator_product (foldli kvs)\n       (\\<lambda>(k, y). iteratei_postfixed (k # l) y))", "have PEQ2: \"set_iterator_product (foldli kvs) (\\<lambda>(k,t). ?ITB (k#l) t)\n          = set_iterator_product (foldli kvs) (\\<lambda>kt. foldli (bs kt))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_iterator_product (foldli kvs)\n     (\\<lambda>(k, t). iteratei_postfixed (k # l) t) =\n    set_iterator_product (foldli kvs) (\\<lambda>kt. foldli (bs kt))", "apply (rule set_iterator_product_eq2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set kvs.\n       (case a of (k, t) \\<Rightarrow> iteratei_postfixed (k # l) t) =\n       foldli (bs a)", "using EQ2"], ["proof (prove)\nusing this:\n  \\<forall>(k, t)\\<in>set kvs.\n     iteratei_postfixed (k # l) t = foldli (bs (k, t))\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set kvs.\n       (case a of (k, t) \\<Rightarrow> iteratei_postfixed (k # l) t) =\n       foldli (bs a)", "by auto"], ["proof (state)\nthis:\n  set_iterator_product (foldli kvs)\n   (\\<lambda>(k, t). iteratei_postfixed (k # l) t) =\n  set_iterator_product (foldli kvs) (\\<lambda>kt. foldli (bs kt))\n\ngoal (1 subgoal):\n 1. proper_it\n     (set_iterator_product (foldli kvs)\n       (\\<lambda>(k, y). iteratei_postfixed (k # l) y))\n     (set_iterator_product (foldli kvs)\n       (\\<lambda>(k, y). iteratei_postfixed (k # l) y))", "show \"proper_it\n          (set_iterator_product (foldli kvs) (\\<lambda>(k,t). ?ITA (k#l) t))\n          (set_iterator_product (foldli kvs) (\\<lambda>(k,t). ?ITB (k#l) t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it\n     (set_iterator_product (foldli kvs)\n       (\\<lambda>(k, t). iteratei_postfixed (k # l) t))\n     (set_iterator_product (foldli kvs)\n       (\\<lambda>(k, t). iteratei_postfixed (k # l) t))", "apply (subst PEQ1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it\n     (set_iterator_product (foldli kvs) (\\<lambda>kt. foldli (bs kt)))\n     (set_iterator_product (foldli kvs)\n       (\\<lambda>(k, y). iteratei_postfixed (k # l) y))", "apply (subst PEQ2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it\n     (set_iterator_product (foldli kvs) (\\<lambda>kt. foldli (bs kt)))\n     (set_iterator_product (foldli kvs) (\\<lambda>kt. foldli (bs kt)))", "apply (auto simp: set_iterator_product_foldli_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it\n     (foldli (concat (map (\\<lambda>kt. map (Pair kt) (bs kt)) kvs)))\n     (foldli (concat (map (\\<lambda>kt. map (Pair kt) (bs kt)) kvs)))", "by (blast intro: proper_itI)"], ["proof (state)\nthis:\n  proper_it\n   (set_iterator_product (foldli kvs)\n     (\\<lambda>(k, t). iteratei_postfixed (k # l) t))\n   (set_iterator_product (foldli kvs)\n     (\\<lambda>(k, t). iteratei_postfixed (k # l) t))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  proper_it (iteratei_postfixed l (Trie.trie.Trie vo kvs))\n   (iteratei_postfixed l (Trie.trie.Trie vo kvs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  proper_it (iteratei_postfixed l t) (iteratei_postfixed l t)\n\ngoal (1 subgoal):\n 1. \\<And>s. proper_it (iteratei_postfixed [] s) (iteratei_postfixed [] s)", "}"], ["proof (state)\nthis:\n  proper_it (iteratei_postfixed ?l2 ?ta2) (iteratei_postfixed ?l2 ?ta2)\n\ngoal (1 subgoal):\n 1. \\<And>s. proper_it (iteratei_postfixed [] s) (iteratei_postfixed [] s)", "thus \"proper_it\n      (iteratei_postfixed [] t :: (_,'\\<sigma>a) set_iterator) \n      (iteratei_postfixed [] t :: (_,'\\<sigma>b) set_iterator)\""], ["proof (prove)\nusing this:\n  proper_it (iteratei_postfixed ?l2 ?ta2) (iteratei_postfixed ?l2 ?ta2)\n\ngoal (1 subgoal):\n 1. proper_it (iteratei_postfixed [] t) (iteratei_postfixed [] t)", "."], ["proof (state)\nthis:\n  proper_it (iteratei_postfixed [] t) (iteratei_postfixed [] t)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pi_trie[proper_it]: \n  \"proper_it' Trie2.iteratei Trie2.iteratei\""], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it' Trie2.iteratei Trie2.iteratei", "unfolding Trie2.iteratei_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it'\n     (\\<lambda>t.\n         set_iterator_image trie_reverse_key\n          (Trie_Impl.iteratei (impl_of t)))\n     (\\<lambda>t.\n         set_iterator_image trie_reverse_key\n          (Trie_Impl.iteratei (impl_of t)))", "apply (rule proper_it'I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       proper_it\n        (set_iterator_image trie_reverse_key\n          (Trie_Impl.iteratei (impl_of s)))\n        (set_iterator_image trie_reverse_key\n          (Trie_Impl.iteratei (impl_of s)))", "apply (intro icf_proper_iteratorI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       proper_it (Trie_Impl.iteratei (impl_of s))\n        (Trie_Impl.iteratei (impl_of s))", "apply (rule proper_it'D)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s. proper_it' Trie_Impl.iteratei Trie_Impl.iteratei", "by (rule pi_trie_impl)"], ["", "interpretation pi_trie: proper_it_loc Trie2.iteratei Trie2.iteratei"], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it_loc Trie2.iteratei Trie2.iteratei", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. proper_it' Trie2.iteratei Trie2.iteratei", "apply (rule pi_trie)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Code generator test\\<close>"], ["", "definition \"test_codegen \\<equiv> (\n  tm.add ,\n  tm.add_dj ,\n  tm.ball ,\n  tm.bex ,\n  tm.delete ,\n  tm.empty ,\n  tm.isEmpty ,\n  tm.isSng ,\n  tm.iterate ,\n  tm.iteratei ,\n  tm.list_it ,\n  tm.lookup ,\n  tm.restrict ,\n  tm.sel ,\n  tm.size ,\n  tm.size_abort ,\n  tm.sng ,\n  tm.to_list ,\n  tm.to_map ,\n  tm.update ,\n  tm.update_dj)\""], ["", "export_code test_codegen checking SML"], ["", "end"]]}