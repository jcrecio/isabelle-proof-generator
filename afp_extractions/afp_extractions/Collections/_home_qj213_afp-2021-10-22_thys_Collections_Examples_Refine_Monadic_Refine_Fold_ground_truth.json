{"file_name": "/home/qj213/afp-2021-10-22/thys/Collections/Examples/Refine_Monadic/Refine_Fold.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Collections", "problem_names": ["lemma rfoldl_simps[simp]: \n    \"rfoldl f s [] = RETURN s\"\n    \"rfoldl f s (x#ls) = do { s\\<leftarrow>f s x; rfoldl f s ls}\"", "lemma rfoldl_refines[refine]:\n    assumes REFF: \"\\<And>x x' s s'. \\<lbrakk> (s,s')\\<in>Rs; (x,x')\\<in>Rl \\<rbrakk> \n      \\<Longrightarrow> f s x \\<le> \\<Down>Rs (f' s' x')\"\n    assumes REF0: \"(s0,s0')\\<in>Rs\"\n    assumes REFL: \"(l,l')\\<in>\\<langle>Rl\\<rangle>list_rel\"\n    shows \"rfoldl f s0 l \\<le> \\<Down>Rs (rfoldl f' s0' l')\"", "lemma transfer_rfoldl[refine_transfer]:\n    assumes \"\\<And>s x. RETURN (f s x) \\<le> F s x\"\n    shows \"RETURN (foldl f s l) \\<le> rfoldl F s l\"", "lemma [simp]: \n    \"pick_sum s [] = RETURN s\"\n    \"pick_sum s (x#l) = do {\n      ASSERT (x\\<noteq>{}); y\\<leftarrow>SPEC (\\<lambda>y. y\\<in>x); pick_sum (s+y) l\n    }\"", "lemma foldl_mono:\n    assumes \"\\<And>x. mono (\\<lambda>s. f s x)\"\n    shows \"mono (\\<lambda>s. foldl f s l)\"", "lemma pick_sum_correct:\n    assumes NE: \"{}\\<notin>set l\"  \n    assumes FIN: \"\\<forall>x\\<in>set l. finite x\"\n    shows \"pick_sum s0 l \\<le> SPEC (\\<lambda>s. s \\<le> foldl (\\<lambda>s x. s+Max x) s0 l)\"", "lemma pick_sum_impl_refine:\n    assumes A: \"(l,l')\\<in>\\<langle>br ls.\\<alpha> ls.invar\\<rangle>list_rel\"\n    shows \"pick_sum_impl s0 l \\<le> \\<Down>Id (pick_sum s0 l')\"", "lemma pick_sum_code_refines: \n    \"RETURN (pick_sum_code s l) \\<le> pick_sum_impl s l\""], "translations": [["", "lemma rfoldl_simps[simp]: \n    \"rfoldl f s [] = RETURN s\"\n    \"rfoldl f s (x#ls) = do { s\\<leftarrow>f s x; rfoldl f s ls}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rfoldl f s [] = RETURN s &&&\n    rfoldl f s (x # ls) = f s x \\<bind> (\\<lambda>s. rfoldl f s ls)", "apply (subst rfoldl.simps, simp)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma rfoldl_refines[refine]:\n    assumes REFF: \"\\<And>x x' s s'. \\<lbrakk> (s,s')\\<in>Rs; (x,x')\\<in>Rl \\<rbrakk> \n      \\<Longrightarrow> f s x \\<le> \\<Down>Rs (f' s' x')\"\n    assumes REF0: \"(s0,s0')\\<in>Rs\"\n    assumes REFL: \"(l,l')\\<in>\\<langle>Rl\\<rangle>list_rel\"\n    shows \"rfoldl f s0 l \\<le> \\<Down>Rs (rfoldl f' s0' l')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rfoldl f s0 l \\<le> \\<Down> Rs (rfoldl f' s0' l')", "using REFL[unfolded list_rel_def, simplified] REF0"], ["proof (prove)\nusing this:\n  list_all2 (\\<lambda>x x'. (x, x') \\<in> Rl) l l'\n  (s0, s0') \\<in> Rs\n\ngoal (1 subgoal):\n 1. rfoldl f s0 l \\<le> \\<Down> Rs (rfoldl f' s0' l')", "apply (induct arbitrary: s0 s0' rule: list_all2_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s0 s0'.\n       (s0, s0') \\<in> Rs \\<Longrightarrow>\n       rfoldl f s0 [] \\<le> \\<Down> Rs (rfoldl f' s0' [])\n 2. \\<And>x x' ls ls' s0 s0'.\n       \\<lbrakk>(x, x') \\<in> Rl;\n        list_all2 (\\<lambda>x x'. (x, x') \\<in> Rl) ls ls';\n        \\<And>s0 s0'.\n           (s0, s0') \\<in> Rs \\<Longrightarrow>\n           rfoldl f s0 ls \\<le> \\<Down> Rs (rfoldl f' s0' ls');\n        (s0, s0') \\<in> Rs\\<rbrakk>\n       \\<Longrightarrow> rfoldl f s0 (x # ls)\n                         \\<le> \\<Down> Rs (rfoldl f' s0' (x' # ls'))", "apply (simp add: REF0 RETURN_refine)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x' ls ls' s0 s0'.\n       \\<lbrakk>(x, x') \\<in> Rl;\n        list_all2 (\\<lambda>x x'. (x, x') \\<in> Rl) ls ls';\n        \\<And>s0 s0'.\n           (s0, s0') \\<in> Rs \\<Longrightarrow>\n           rfoldl f s0 ls \\<le> \\<Down> Rs (rfoldl f' s0' ls');\n        (s0, s0') \\<in> Rs\\<rbrakk>\n       \\<Longrightarrow> rfoldl f s0 (x # ls)\n                         \\<le> \\<Down> Rs (rfoldl f' s0' (x' # ls'))", "apply (simp only: rfoldl_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x' ls ls' s0 s0'.\n       \\<lbrakk>(x, x') \\<in> Rl;\n        list_all2 (\\<lambda>x x'. (x, x') \\<in> Rl) ls ls';\n        \\<And>s0 s0'.\n           (s0, s0') \\<in> Rs \\<Longrightarrow>\n           rfoldl f s0 ls \\<le> \\<Down> Rs (rfoldl f' s0' ls');\n        (s0, s0') \\<in> Rs\\<rbrakk>\n       \\<Longrightarrow> f s0 x \\<bind> (\\<lambda>s. rfoldl f s ls)\n                         \\<le> \\<Down> Rs\n                                (f' s0' x' \\<bind>\n                                 (\\<lambda>s. rfoldl f' s ls'))", "apply (refine_rcg)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x x' ls ls' s0 s0'.\n       \\<lbrakk>(x, x') \\<in> Rl;\n        list_all2 (\\<lambda>x x'. (x, x') \\<in> Rl) ls ls';\n        \\<And>s0 s0'.\n           (s0, s0') \\<in> Rs \\<Longrightarrow>\n           rfoldl f s0 ls \\<le> \\<Down> Rs (rfoldl f' s0' ls');\n        (s0, s0') \\<in> Rs\\<rbrakk>\n       \\<Longrightarrow> f s0 x\n                         \\<le> \\<Down> (?R'2 x x' ls ls' s0 s0') (f' s0' x')\n 2. \\<And>x x' ls ls' s0 s0' s sa.\n       \\<lbrakk>(x, x') \\<in> Rl;\n        list_all2 (\\<lambda>x x'. (x, x') \\<in> Rl) ls ls';\n        \\<And>s0 s0'.\n           (s0, s0') \\<in> Rs \\<Longrightarrow>\n           rfoldl f s0 ls \\<le> \\<Down> Rs (rfoldl f' s0' ls');\n        (s0, s0') \\<in> Rs; (s, sa) \\<in> ?R'2 x x' ls ls' s0 s0'\\<rbrakk>\n       \\<Longrightarrow> rfoldl f s ls \\<le> \\<Down> Rs (rfoldl f' sa ls')", "apply (rule REFF)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x x' ls ls' s0 s0'.\n       \\<lbrakk>(x, x') \\<in> Rl;\n        list_all2 (\\<lambda>x x'. (x, x') \\<in> Rl) ls ls';\n        \\<And>s0 s0'.\n           (s0, s0') \\<in> Rs \\<Longrightarrow>\n           rfoldl f s0 ls \\<le> \\<Down> Rs (rfoldl f' s0' ls');\n        (s0, s0') \\<in> Rs\\<rbrakk>\n       \\<Longrightarrow> (s0, s0') \\<in> Rs\n 2. \\<And>x x' ls ls' s0 s0'.\n       \\<lbrakk>(x, x') \\<in> Rl;\n        list_all2 (\\<lambda>x x'. (x, x') \\<in> Rl) ls ls';\n        \\<And>s0 s0'.\n           (s0, s0') \\<in> Rs \\<Longrightarrow>\n           rfoldl f s0 ls \\<le> \\<Down> Rs (rfoldl f' s0' ls');\n        (s0, s0') \\<in> Rs\\<rbrakk>\n       \\<Longrightarrow> (x, x') \\<in> Rl\n 3. \\<And>x x' ls ls' s0 s0' s sa.\n       \\<lbrakk>(x, x') \\<in> Rl;\n        list_all2 (\\<lambda>x x'. (x, x') \\<in> Rl) ls ls';\n        \\<And>s0 s0'.\n           (s0, s0') \\<in> Rs \\<Longrightarrow>\n           rfoldl f s0 ls \\<le> \\<Down> Rs (rfoldl f' s0' ls');\n        (s0, s0') \\<in> Rs; (s, sa) \\<in> Rs\\<rbrakk>\n       \\<Longrightarrow> rfoldl f s ls \\<le> \\<Down> Rs (rfoldl f' sa ls')", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma transfer_rfoldl[refine_transfer]:\n    assumes \"\\<And>s x. RETURN (f s x) \\<le> F s x\"\n    shows \"RETURN (foldl f s l) \\<le> rfoldl F s l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN (foldl f s l) \\<le> rfoldl F s l", "using assms"], ["proof (prove)\nusing this:\n  RETURN (f ?s ?x) \\<le> F ?s ?x\n\ngoal (1 subgoal):\n 1. RETURN (foldl f s l) \\<le> rfoldl F s l", "apply (induct l arbitrary: s)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s.\n       (\\<And>s x. RETURN (f s x) \\<le> F s x) \\<Longrightarrow>\n       RETURN (foldl f s []) \\<le> rfoldl F s []\n 2. \\<And>a l s.\n       \\<lbrakk>\\<And>s.\n                   (\\<And>s x. RETURN (f s x) \\<le> F s x) \\<Longrightarrow>\n                   RETURN (foldl f s l) \\<le> rfoldl F s l;\n        \\<And>s x. RETURN (f s x) \\<le> F s x\\<rbrakk>\n       \\<Longrightarrow> RETURN (foldl f s (a # l)) \\<le> rfoldl F s (a # l)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a l s.\n       \\<lbrakk>\\<And>s.\n                   (\\<And>s x. RETURN (f s x) \\<le> F s x) \\<Longrightarrow>\n                   RETURN (foldl f s l) \\<le> rfoldl F s l;\n        \\<And>s x. RETURN (f s x) \\<le> F s x\\<rbrakk>\n       \\<Longrightarrow> RETURN (foldl f s (a # l)) \\<le> rfoldl F s (a # l)", "apply (simp only: foldl_Nil foldl_append rfoldl_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a l s.\n       \\<lbrakk>\\<And>s.\n                   (\\<And>s x. True) \\<Longrightarrow>\n                   RETURN (foldl f s l) \\<le> rfoldl F s l;\n        \\<And>s x. RETURN (f s x) \\<le> F s x\\<rbrakk>\n       \\<Longrightarrow> RETURN (foldl f s (a # l))\n                         \\<le> F s a \\<bind> (\\<lambda>s. rfoldl F s l)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a l s.\n       \\<lbrakk>\\<And>s. RETURN (foldl f s l) \\<le> rfoldl F s l;\n        \\<And>s x. RETURN (f s x) \\<le> F s x\\<rbrakk>\n       \\<Longrightarrow> RETURN (foldl f (f s a) l)\n                         \\<le> F s a \\<bind> (\\<lambda>s. rfoldl F s l)", "apply (rule order_trans[rotated])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a l s.\n       \\<lbrakk>\\<And>s. RETURN (foldl f s l) \\<le> rfoldl F s l;\n        \\<And>s x. RETURN (f s x) \\<le> F s x\\<rbrakk>\n       \\<Longrightarrow> ?y2 a l s\n                         \\<le> F s a \\<bind> (\\<lambda>s. rfoldl F s l)\n 2. \\<And>a l s.\n       \\<lbrakk>\\<And>s. RETURN (foldl f s l) \\<le> rfoldl F s l;\n        \\<And>s x. RETURN (f s x) \\<le> F s x\\<rbrakk>\n       \\<Longrightarrow> RETURN (foldl f (f s a) l) \\<le> ?y2 a l s", "apply (rule refine_transfer)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a l s.\n       \\<lbrakk>\\<And>s. RETURN (foldl f s l) \\<le> rfoldl F s l;\n        \\<And>s x. RETURN (f s x) \\<le> F s x\\<rbrakk>\n       \\<Longrightarrow> RETURN (?x5 a l s) \\<le> F s a\n 2. \\<And>a l s x.\n       \\<lbrakk>\\<And>s. RETURN (foldl f s l) \\<le> rfoldl F s l;\n        \\<And>s x. RETURN (f s x) \\<le> F s x\\<rbrakk>\n       \\<Longrightarrow> RETURN (?f5 a l s x) \\<le> rfoldl F x l\n 3. \\<And>a l s.\n       \\<lbrakk>\\<And>s. RETURN (foldl f s l) \\<le> rfoldl F s l;\n        \\<And>s x. RETURN (f s x) \\<le> F s x\\<rbrakk>\n       \\<Longrightarrow> RETURN (foldl f (f s a) l)\n                         \\<le> RETURN (Let (?x5 a l s) (?f5 a l s))", "apply assumption"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a l s x.\n       \\<lbrakk>\\<And>s. RETURN (foldl f s l) \\<le> rfoldl F s l;\n        \\<And>s x. RETURN (f s x) \\<le> F s x\\<rbrakk>\n       \\<Longrightarrow> RETURN (?f5 a l s x) \\<le> rfoldl F x l\n 2. \\<And>a l s.\n       \\<lbrakk>\\<And>s. RETURN (foldl f s l) \\<le> rfoldl F s l;\n        \\<And>s x. RETURN (f s x) \\<le> F s x\\<rbrakk>\n       \\<Longrightarrow> RETURN (foldl f (f s a) l)\n                         \\<le> RETURN (Let (f s a) (?f5 a l s))", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a l s.\n       \\<lbrakk>\\<And>s. RETURN (foldl f s l) \\<le> rfoldl F s l;\n        \\<And>s x. RETURN (f s x) \\<le> F s x\\<rbrakk>\n       \\<Longrightarrow> RETURN (foldl f (f s a) l)\n                         \\<le> RETURN (let x = f s a in foldl f x l)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Example\\<close>"], ["", "text \\<open>\n    As example application, we define a program that takes as input a list\n    of non-empty sets of natural numbers, picks some number of each list,\n    and adds up the picked numbers.\n\\<close>"], ["", "definition \"pick_sum (s0::nat) l \\<equiv>\n    rfoldl (\\<lambda>s x. do {\n      ASSERT (x\\<noteq>{});\n      y\\<leftarrow>SPEC (\\<lambda>y. y\\<in>x);\n      RETURN (s+y)\n    }) s0 l\n    \""], ["", "lemma [simp]: \n    \"pick_sum s [] = RETURN s\"\n    \"pick_sum s (x#l) = do {\n      ASSERT (x\\<noteq>{}); y\\<leftarrow>SPEC (\\<lambda>y. y\\<in>x); pick_sum (s+y) l\n    }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pick_sum s [] = RETURN s &&&\n    pick_sum s (x # l) =\n    ASSERT (x \\<noteq> {}) \\<bind>\n    (\\<lambda>_.\n        SPEC (\\<lambda>y. y \\<in> x) \\<bind>\n        (\\<lambda>y. pick_sum (s + y) l))", "unfolding pick_sum_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rfoldl\n     (\\<lambda>s x.\n         ASSERT (x \\<noteq> {}) \\<bind>\n         (\\<lambda>_.\n             SPEC (\\<lambda>y. y \\<in> x) \\<bind>\n             (\\<lambda>y. RETURN (s + y))))\n     s [] =\n    RETURN s &&&\n    rfoldl\n     (\\<lambda>s x.\n         ASSERT (x \\<noteq> {}) \\<bind>\n         (\\<lambda>_.\n             SPEC (\\<lambda>y. y \\<in> x) \\<bind>\n             (\\<lambda>y. RETURN (s + y))))\n     s (x # l) =\n    ASSERT (x \\<noteq> {}) \\<bind>\n    (\\<lambda>_.\n        SPEC (\\<lambda>y. y \\<in> x) \\<bind>\n        (\\<lambda>y.\n            rfoldl\n             (\\<lambda>s x.\n                 ASSERT (x \\<noteq> {}) \\<bind>\n                 (\\<lambda>_.\n                     SPEC (\\<lambda>y. y \\<in> x) \\<bind>\n                     (\\<lambda>y. RETURN (s + y))))\n             (s + y) l))", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma foldl_mono:\n    assumes \"\\<And>x. mono (\\<lambda>s. f s x)\"\n    shows \"mono (\\<lambda>s. foldl f s l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono (\\<lambda>s. foldl f s l)", "apply (rule monoI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<le> y \\<Longrightarrow> foldl f x l \\<le> foldl f y l", "using assms"], ["proof (prove)\nusing this:\n  mono (\\<lambda>s. f s ?x)\n\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<le> y \\<Longrightarrow> foldl f x l \\<le> foldl f y l", "apply (induct l)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> y; \\<And>x. mono (\\<lambda>s. f s x)\\<rbrakk>\n       \\<Longrightarrow> foldl f x [] \\<le> foldl f y []\n 2. \\<And>a l x y.\n       \\<lbrakk>\\<And>x y.\n                   \\<lbrakk>x \\<le> y;\n                    \\<And>x. mono (\\<lambda>s. f s x)\\<rbrakk>\n                   \\<Longrightarrow> foldl f x l \\<le> foldl f y l;\n        x \\<le> y; \\<And>x. mono (\\<lambda>s. f s x)\\<rbrakk>\n       \\<Longrightarrow> foldl f x (a # l) \\<le> foldl f y (a # l)", "apply (auto dest: monoD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma pick_sum_correct:\n    assumes NE: \"{}\\<notin>set l\"  \n    assumes FIN: \"\\<forall>x\\<in>set l. finite x\"\n    shows \"pick_sum s0 l \\<le> SPEC (\\<lambda>s. s \\<le> foldl (\\<lambda>s x. s+Max x) s0 l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pick_sum s0 l\n    \\<le> SPEC (\\<lambda>s. s \\<le> foldl (\\<lambda>s x. s + Max x) s0 l)", "using NE FIN"], ["proof (prove)\nusing this:\n  {} \\<notin> set l\n  \\<forall>x\\<in>set l. finite x\n\ngoal (1 subgoal):\n 1. pick_sum s0 l\n    \\<le> SPEC (\\<lambda>s. s \\<le> foldl (\\<lambda>s x. s + Max x) s0 l)", "apply (induction l arbitrary: s0)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s0.\n       \\<lbrakk>{} \\<notin> set []; Ball (set []) finite\\<rbrakk>\n       \\<Longrightarrow> pick_sum s0 []\n                         \\<le> SPEC\n                                (\\<lambda>s.\n                                    s \\<le> foldl (\\<lambda>s x. s + Max x)\n       s0 [])\n 2. \\<And>a l s0.\n       \\<lbrakk>\\<And>s0.\n                   \\<lbrakk>{} \\<notin> set l; Ball (set l) finite\\<rbrakk>\n                   \\<Longrightarrow> pick_sum s0 l\n                                     \\<le> SPEC\n      (\\<lambda>s. s \\<le> foldl (\\<lambda>s x. s + Max x) s0 l);\n        {} \\<notin> set (a # l); Ball (set (a # l)) finite\\<rbrakk>\n       \\<Longrightarrow> pick_sum s0 (a # l)\n                         \\<le> SPEC\n                                (\\<lambda>s.\n                                    s \\<le> foldl (\\<lambda>s x. s + Max x)\n       s0 (a # l))", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a l s0.\n       \\<lbrakk>\\<And>s0.\n                   \\<lbrakk>{} \\<notin> set l; Ball (set l) finite\\<rbrakk>\n                   \\<Longrightarrow> pick_sum s0 l\n                                     \\<le> SPEC\n      (\\<lambda>s. s \\<le> foldl (\\<lambda>s x. s + Max x) s0 l);\n        {} \\<notin> set (a # l); Ball (set (a # l)) finite\\<rbrakk>\n       \\<Longrightarrow> pick_sum s0 (a # l)\n                         \\<le> SPEC\n                                (\\<lambda>s.\n                                    s \\<le> foldl (\\<lambda>s x. s + Max x)\n       s0 (a # l))", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a l s0.\n       \\<lbrakk>\\<And>s0.\n                   pick_sum s0 l\n                   \\<le> SPEC\n                          (\\<lambda>s.\n                              s \\<le> foldl (\\<lambda>s x. s + Max x) s0 l);\n        {} \\<noteq> a \\<and> {} \\<notin> set l;\n        finite a \\<and> (\\<forall>x\\<in>set l. finite x)\\<rbrakk>\n       \\<Longrightarrow> ASSERT (a \\<noteq> {}) \\<bind>\n                         (\\<lambda>_.\n                             RES a \\<bind>\n                             (\\<lambda>y. pick_sum (s0 + y) l))\n                         \\<le> SPEC\n                                (\\<lambda>s.\n                                    s \\<le> foldl (\\<lambda>s x. s + Max x)\n       (s0 + Max a) l)", "apply (intro refine_vcg)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a l s0.\n       \\<lbrakk>\\<And>s0.\n                   pick_sum s0 l\n                   \\<le> SPEC\n                          (\\<lambda>s.\n                              s \\<le> foldl (\\<lambda>s x. s + Max x) s0 l);\n        {} \\<noteq> a \\<and> {} \\<notin> set l;\n        finite a \\<and> (\\<forall>x\\<in>set l. finite x)\\<rbrakk>\n       \\<Longrightarrow> a \\<noteq> {}\n 2. \\<And>a l s0 x.\n       \\<lbrakk>\\<And>s0.\n                   pick_sum s0 l\n                   \\<le> SPEC\n                          (\\<lambda>s.\n                              s \\<le> foldl (\\<lambda>s x. s + Max x) s0 l);\n        {} \\<noteq> a \\<and> {} \\<notin> set l;\n        finite a \\<and> (\\<forall>x\\<in>set l. finite x); a \\<noteq> {};\n        x \\<in> a\\<rbrakk>\n       \\<Longrightarrow> pick_sum (s0 + x) l\n                         \\<le> SPEC\n                                (\\<lambda>s.\n                                    s \\<le> foldl (\\<lambda>s x. s + Max x)\n       (s0 + Max a) l)", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a l s0 x.\n       \\<lbrakk>\\<And>s0.\n                   pick_sum s0 l\n                   \\<le> SPEC\n                          (\\<lambda>s.\n                              s \\<le> foldl (\\<lambda>s x. s + Max x) s0 l);\n        {} \\<noteq> a \\<and> {} \\<notin> set l;\n        finite a \\<and> (\\<forall>x\\<in>set l. finite x); a \\<noteq> {};\n        x \\<in> a\\<rbrakk>\n       \\<Longrightarrow> pick_sum (s0 + x) l\n                         \\<le> SPEC\n                                (\\<lambda>s.\n                                    s \\<le> foldl (\\<lambda>s x. s + Max x)\n       (s0 + Max a) l)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a l s0 x.\n       \\<lbrakk>\\<And>s0.\n                   pick_sum s0 l\n                   \\<le> SPEC\n                          (\\<lambda>s.\n                              s \\<le> foldl (\\<lambda>s x. s + Max x) s0 l);\n        {} \\<notin> set l; finite a \\<and> (\\<forall>x\\<in>set l. finite x);\n        a \\<noteq> {}; x \\<in> a\\<rbrakk>\n       \\<Longrightarrow> pick_sum (s0 + x) l\n                         \\<le> SPEC\n                                (\\<lambda>s.\n                                    s \\<le> foldl (\\<lambda>s x. s + Max x)\n       (s0 + Max a) l)", "apply (rule order_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a l s0 x.\n       \\<lbrakk>\\<And>s0.\n                   pick_sum s0 l\n                   \\<le> SPEC\n                          (\\<lambda>s.\n                              s \\<le> foldl (\\<lambda>s x. s + Max x) s0 l);\n        {} \\<notin> set l; finite a \\<and> (\\<forall>x\\<in>set l. finite x);\n        a \\<noteq> {}; x \\<in> a\\<rbrakk>\n       \\<Longrightarrow> pick_sum (s0 + x) l \\<le> ?y26 a l s0 x\n 2. \\<And>a l s0 x.\n       \\<lbrakk>\\<And>s0.\n                   pick_sum s0 l\n                   \\<le> SPEC\n                          (\\<lambda>s.\n                              s \\<le> foldl (\\<lambda>s x. s + Max x) s0 l);\n        {} \\<notin> set l; finite a \\<and> (\\<forall>x\\<in>set l. finite x);\n        a \\<noteq> {}; x \\<in> a\\<rbrakk>\n       \\<Longrightarrow> ?y26 a l s0 x\n                         \\<le> SPEC\n                                (\\<lambda>s.\n                                    s \\<le> foldl (\\<lambda>s x. s + Max x)\n       (s0 + Max a) l)", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a l s0 x.\n       \\<lbrakk>\\<And>s0.\n                   pick_sum s0 l\n                   \\<le> SPEC\n                          (\\<lambda>s.\n                              s \\<le> foldl (\\<lambda>s x. s + Max x) s0 l);\n        {} \\<notin> set l; finite a \\<and> (\\<forall>x\\<in>set l. finite x);\n        a \\<noteq> {}; x \\<in> a\\<rbrakk>\n       \\<Longrightarrow> SPEC\n                          (\\<lambda>s.\n                              s \\<le> foldl (\\<lambda>s x. s + Max x)\n (s0 + x) l)\n                         \\<le> SPEC\n                                (\\<lambda>s.\n                                    s \\<le> foldl (\\<lambda>s x. s + Max x)\n       (s0 + Max a) l)", "apply (rule SPEC_rule)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a l s0 x xa.\n       \\<lbrakk>\\<And>s0.\n                   pick_sum s0 l\n                   \\<le> SPEC\n                          (\\<lambda>s.\n                              s \\<le> foldl (\\<lambda>s x. s + Max x) s0 l);\n        {} \\<notin> set l; finite a \\<and> (\\<forall>x\\<in>set l. finite x);\n        a \\<noteq> {}; x \\<in> a;\n        xa \\<le> foldl (\\<lambda>s x. s + Max x) (s0 + x) l\\<rbrakk>\n       \\<Longrightarrow> xa \\<le> foldl (\\<lambda>s x. s + Max x)\n                                   (s0 + Max a) l", "apply (erule order_trans)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a l s0 x xa.\n       \\<lbrakk>\\<And>s0.\n                   pick_sum s0 l\n                   \\<le> SPEC\n                          (\\<lambda>s.\n                              s \\<le> foldl (\\<lambda>s x. s + Max x) s0 l);\n        {} \\<notin> set l; finite a \\<and> (\\<forall>x\\<in>set l. finite x);\n        a \\<noteq> {}; x \\<in> a\\<rbrakk>\n       \\<Longrightarrow> foldl (\\<lambda>s x. s + Max x) (s0 + x) l\n                         \\<le> foldl (\\<lambda>s x. s + Max x) (s0 + Max a)\n                                l", "apply (rule monoD[OF foldl_mono])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a l s0 x xa xb.\n       \\<lbrakk>\\<And>s0.\n                   pick_sum s0 l\n                   \\<le> SPEC\n                          (\\<lambda>s.\n                              s \\<le> foldl (\\<lambda>s x. s + Max x) s0 l);\n        {} \\<notin> set l; finite a \\<and> (\\<forall>x\\<in>set l. finite x);\n        a \\<noteq> {}; x \\<in> a\\<rbrakk>\n       \\<Longrightarrow> mono (\\<lambda>s. s + Max xb)\n 2. \\<And>a l s0 x xa.\n       \\<lbrakk>\\<And>s0.\n                   pick_sum s0 l\n                   \\<le> SPEC\n                          (\\<lambda>s.\n                              s \\<le> foldl (\\<lambda>s x. s + Max x) s0 l);\n        {} \\<notin> set l; finite a \\<and> (\\<forall>x\\<in>set l. finite x);\n        a \\<noteq> {}; x \\<in> a\\<rbrakk>\n       \\<Longrightarrow> s0 + x \\<le> s0 + Max a", "apply (auto intro: monoI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition \"pick_sum_impl s0 l \\<equiv>\n    rfoldl (\\<lambda>s x. do {\n      y\\<leftarrow>RETURN (the (ls.sel x (\\<lambda>_. True)));\n      RETURN (s+y)\n    }) (s0::nat) l\""], ["", "lemma pick_sum_impl_refine:\n    assumes A: \"(l,l')\\<in>\\<langle>br ls.\\<alpha> ls.invar\\<rangle>list_rel\"\n    shows \"pick_sum_impl s0 l \\<le> \\<Down>Id (pick_sum s0 l')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pick_sum_impl s0 l \\<le> \\<Down> nat_rel (pick_sum s0 l')", "unfolding pick_sum_def pick_sum_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rfoldl\n     (\\<lambda>s x.\n         RETURN (the (ls.sel x (\\<lambda>_. True))) \\<bind>\n         (\\<lambda>y. RETURN (s + y)))\n     s0 l\n    \\<le> \\<Down> nat_rel\n           (rfoldl\n             (\\<lambda>s x.\n                 ASSERT (x \\<noteq> {}) \\<bind>\n                 (\\<lambda>_.\n                     SPEC (\\<lambda>y. y \\<in> x) \\<bind>\n                     (\\<lambda>y. RETURN (s + y))))\n             s0 l')", "using A"], ["proof (prove)\nusing this:\n  (l, l') \\<in> \\<langle>br ls.\\<alpha> ls.invar\\<rangle>list_rel\n\ngoal (1 subgoal):\n 1. rfoldl\n     (\\<lambda>s x.\n         RETURN (the (ls.sel x (\\<lambda>_. True))) \\<bind>\n         (\\<lambda>y. RETURN (s + y)))\n     s0 l\n    \\<le> \\<Down> nat_rel\n           (rfoldl\n             (\\<lambda>s x.\n                 ASSERT (x \\<noteq> {}) \\<bind>\n                 (\\<lambda>_.\n                     SPEC (\\<lambda>y. y \\<in> x) \\<bind>\n                     (\\<lambda>y. RETURN (s + y))))\n             s0 l')", "apply (refine_rcg)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x x' s s'.\n       \\<lbrakk>(l, l')\n                \\<in> \\<langle>br ls.\\<alpha> ls.invar\\<rangle>list_rel;\n        (s, s') \\<in> nat_rel; (x, x') \\<in> ?Rl1; x' \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> RETURN (the (ls.sel x (\\<lambda>_. True)))\n                         \\<le> SPEC (\\<lambda>y. y \\<in> x')\n 2. \\<And>x x' s s' y ya.\n       \\<lbrakk>(l, l')\n                \\<in> \\<langle>br ls.\\<alpha> ls.invar\\<rangle>list_rel;\n        (s, s') \\<in> nat_rel; (x, x') \\<in> ?Rl1; x' \\<noteq> {};\n        (y, ya) \\<in> nat_rel; ya \\<in> {y. y \\<in> x'}\\<rbrakk>\n       \\<Longrightarrow> (s + y, s' + ya) \\<in> nat_rel\n 3. (l, l')\n    \\<in> \\<langle>br ls.\\<alpha>\n                    ls.invar\\<rangle>list_rel \\<Longrightarrow>\n    (s0, s0) \\<in> nat_rel\n 4. (l, l')\n    \\<in> \\<langle>br ls.\\<alpha>\n                    ls.invar\\<rangle>list_rel \\<Longrightarrow>\n    (l, l') \\<in> \\<langle>?Rl1\\<rangle>list_rel", "apply (refine_dref_type)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x x' s s'.\n       \\<lbrakk>(l, l')\n                \\<in> \\<langle>br ls.\\<alpha> ls.invar\\<rangle>list_rel;\n        (s, s') \\<in> nat_rel; (x, x') \\<in> br ls.\\<alpha> ls.invar;\n        x' \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> RETURN (the (ls.sel x (\\<lambda>_. True)))\n                         \\<le> SPEC (\\<lambda>y. y \\<in> x')\n 2. \\<And>x x' s s' y ya.\n       \\<lbrakk>(l, l')\n                \\<in> \\<langle>br ls.\\<alpha> ls.invar\\<rangle>list_rel;\n        (s, s') \\<in> nat_rel; (x, x') \\<in> br ls.\\<alpha> ls.invar;\n        x' \\<noteq> {}; (y, ya) \\<in> nat_rel;\n        ya \\<in> {y. y \\<in> x'}\\<rbrakk>\n       \\<Longrightarrow> (s + y, s' + ya) \\<in> nat_rel\n 3. (l, l')\n    \\<in> \\<langle>br ls.\\<alpha>\n                    ls.invar\\<rangle>list_rel \\<Longrightarrow>\n    (s0, s0) \\<in> nat_rel", "apply (simp_all add: refine_hsimp refine_rel_defs)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "schematic_goal pick_sum_code_aux: \"RETURN ?f \\<le> pick_sum_impl s0 l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?f \\<le> pick_sum_impl s0 l", "unfolding pick_sum_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN ?f\n    \\<le> rfoldl\n           (\\<lambda>s x.\n               RETURN (the (ls.sel x (\\<lambda>_. True))) \\<bind>\n               (\\<lambda>y. RETURN (s + y)))\n           s0 l", "apply refine_transfer"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "concrete_definition pick_sum_code for ?s0.0 l uses pick_sum_code_aux"], ["", "lemma pick_sum_code_refines: \n    \"RETURN (pick_sum_code s l) \\<le> pick_sum_impl s l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RETURN (pick_sum_code s l) \\<le> pick_sum_impl s l", "by (rule pick_sum_code.refine)"], ["", "value \n    \"pick_sum_code 0 [list_to_ls [3,2,1], list_to_ls [1,2,3], list_to_ls[2,1]]\""], ["", "end"]]}