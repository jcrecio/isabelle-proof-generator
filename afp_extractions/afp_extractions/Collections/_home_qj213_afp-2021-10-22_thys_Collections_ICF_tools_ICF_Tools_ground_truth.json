{"file_name": "/home/qj213/afp-2021-10-22/thys/Collections/ICF/tools/ICF_Tools.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Collections", "problem_names": ["lemma meta_same_imp_rule: \"(\\<lbrakk>PROP P; PROP P\\<rbrakk> \\<Longrightarrow> PROP Q) \\<equiv> (PROP P \\<Longrightarrow> PROP Q)\""], "translations": [["", "lemma meta_same_imp_rule: \"(\\<lbrakk>PROP P; PROP P\\<rbrakk> \\<Longrightarrow> PROP Q) \\<equiv> (PROP P \\<Longrightarrow> PROP Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>PROP P; PROP P\\<rbrakk> \\<Longrightarrow> PROP Q) \\<equiv>\n    (PROP P \\<Longrightarrow> PROP Q)", "by rule"], ["", "(* TODO: Replace by distinct_prems_rl *)"], ["", "ML \\<open>\n  infix 0 ##;\n\n  fun (f ## g) (a,b) = (f a, g b)\n\n  signature ICF_TOOLS = sig\n    (* Generic *)\n    val gen_variant: (string -> bool) -> string -> string\n    val map_option: ('a -> 'b) -> 'a option -> 'b option\n\n    val parse_cpat: cterm context_parser\n\n    val rename_cterm: (cterm * cterm) ->\n      ((indexname * sort) * ctyp) list * ((indexname * typ) * cterm) list\n    val renames_cterm: (cterm * cterm) -> bool\n\n    val import_cterm: cterm -> Proof.context -> cterm * Proof.context\n    val inst_meta_cong: Proof.context -> cterm -> thm\n\n    (*\n    val thms_from_main: string -> thm list\n    val thm_from_main: string -> thm\n    *)\n\n    val sss_add: thm list -> Proof.context -> Proof.context\n\n    val changed_conv: conv -> conv\n    val repeat_top_sweep_conv: (Proof.context -> conv) -> Proof.context -> conv\n\n    val rem_dup_prems: Proof.context -> thm -> thm\n\n    (* Definition Theorems *)\n    val dest_def_eq: term -> term * term\n    val norm_def_thm: thm -> thm\n    val dthm_lhs: thm -> term\n    val dthm_rhs: thm -> term\n    val dthm_params: thm -> term list\n    val dthm_head: thm -> term\n\n    val dt_lhs: term -> term\n    val dt_rhs: term -> term\n    val dt_params: term -> term list\n    val dt_head: term -> term\n\n    val chead_of: cterm -> cterm\n    val chead_of_thm: thm -> cterm\n\n    (* Simple definition: name\\<equiv>term, fixes variables *)\n    val define_simple: string -> term -> local_theory \n      -> ((term * thm) * local_theory)\n\n    (* Wrapping stuff inside local theory context *)\n    val wrap_lthy_result_global: (local_theory -> 'a * local_theory) ->\n        (morphism -> 'a -> 'b) -> theory -> 'b * theory\n    val wrap_lthy_global: (local_theory -> local_theory) -> theory -> theory\n    val wrap_lthy_result_local: (local_theory -> 'a * local_theory) ->\n        (morphism -> 'a -> 'b) -> local_theory -> 'b * local_theory\n    val wrap_lthy_local: (local_theory -> local_theory) -> \n        local_theory -> local_theory\n\n    (* Wrapped versions of simple definition *)\n    val define_simple_global: string -> term -> theory \n      -> ((term * thm) * theory)\n    val define_simple_local: string -> term -> local_theory \n      -> ((term * thm) * local_theory)\n\n    (* Revert abbreviations matching pattern (TODO/FIXME: HACK) *)\n    val revert_abbrevs: string -> theory -> theory\n\n  end;\n\n  structure ICF_Tools: ICF_TOOLS = struct\n    fun gen_variant decl s = let\n      fun search s = if not (decl s) then s else search (Symbol.bump_string s);\n    in\n      if not (decl s) then s \n      else search (Symbol.bump_init s)\n    end;    \n\n\n    val parse_cpat =\n      Args.context --\n        Scan.lift Args.embedded_inner_syntax >> (fn (ctxt, str) => \n          Proof_Context.read_term_pattern ctxt str\n          |> Thm.cterm_of ctxt \n        );\n\n\n    (* Renaming first-order match *)\n    fun rename_cterm (ct1,ct2) = (\n      Thm.first_order_match (ct2,ct1);\n      Thm.first_order_match (ct1,ct2));\n\n    val renames_cterm = can rename_cterm;\n\n    fun import_cterm ct ctxt = let\n      val (t', ctxt') = yield_singleton (Variable.import_terms true) \n        (Thm.term_of ct) ctxt;\n      val ct' = Thm.cterm_of ctxt' t';\n    in (ct', ctxt') end\n\n  (* Get theorem by name, that is visible in HOL.Main. Moreover, the\n    theory of this theorem will be HOL.Main, which is required to avoid\n    non-trivial theory merges as they may occur when using thm-antiquotation.\n    (cf. post \n      https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2012-August/msg00175.html \n    on Isabelle mailing list)\n  *)(*\n  fun thms_from_main name = let\n    val xthmref = Facts.named name;\n    val thy = @{theory Main};\n    val name = Facts.ref_name xthmref\n    |> Global_Theory.intern_fact thy;\n    val name = case name of \"_\" => \"Pure.asm_rl\" | name => name;\n\n    val fs = Global_Theory.facts_of thy;\n    val thms = Facts.lookup (Context.Theory thy) fs name\n    |> the |> #2 |> map (Thm.transfer thy);\n  in thms end\n\n  fun thm_from_main name = thms_from_main name |> Facts.the_single (name, Position.none)\n*)\n    (* Unfold with simpset \n    fun unfold_ss ss = let\n      val simple_prover =\n        SINGLE o (fn ss => ALLGOALS (resolve_tac (Raw_Simplifier.prems_of ss)));\n    in Raw_Simplifier.rewrite_thm (true,false,false) simple_prover ss end;\n    *)\n\n    local\n      fun sss_add_single thm ss = let\n        val simps = Raw_Simplifier.dest_ss (simpset_of ss) |> #simps |> map #2;\n        val ess = ss delsimps simps;\n        val thm' = simplify ss thm;\n\n        val new_simps = simps\n          |> map (simplify \n              (ess addsimps [thm']));\n        val ss' = ess addsimps (thm'::new_simps)\n      in ss' end\n    in\n      val sss_add = fold sss_add_single\n    end\n\n    local\n      open Conv;\n    in\n      fun changed_conv cnv = (fn (ct:cterm) => let\n        val thm = cnv ct\n      in\n        if Thm.is_reflexive thm then \n          raise THM (\"changed_conv: Not changed\",~1,[thm])\n        else thm\n      end)\n\n      fun repeat_top_sweep_conv cnv ctxt = \n        repeat_conv (changed_conv (top_sweep_conv cnv ctxt));\n    end\n\n    (* Remove duplicate premises (stable) *)\n    fun rem_dup_prems ctxt thm = let\n      val prems = Thm.prems_of thm;\n      val perm = prems\n      |> tag_list 0 \n      |> map swap \n      |> Termtab.make_list\n      |> Termtab.dest \n      |> map snd\n      |> sort (int_ord o apply2 hd)\n      |> flat;\n\n      val thm' = Drule.rearrange_prems perm thm\n        |> Conv.fconv_rule \n             (Raw_Simplifier.rewrite ctxt true @{thms meta_same_imp_rule});\n    in thm' end;\n\n    fun dest_def_eq (Const (@{const_name Pure.eq},_)$l$r) = (l,r)\n    | dest_def_eq (Const (@{const_name HOL.Trueprop},_)\n                    $(Const (@{const_name HOL.eq},_)$l$r)) = (l,r)\n    | dest_def_eq t = raise TERM (\"No definitional equation\",[t]);\n\n    fun norm_def_thm thm =\n      case Thm.concl_of thm of\n        (Const (@{const_name Pure.eq},_)$_$_) => thm\n      | _ => thm RS eq_reflection;\n\n    val dt_lhs = dest_def_eq #> fst;\n    val dt_rhs = dest_def_eq #> snd;\n    val dt_params = dt_lhs #> strip_comb #> snd;\n    val dt_head = dt_lhs #> head_of;\n\n    val dthm_lhs = Thm.concl_of #> dt_lhs;\n    val dthm_rhs = Thm.concl_of #> dt_rhs;\n    val dthm_params = Thm.concl_of #> dt_params;\n    val dthm_head = Thm.concl_of #> dt_head;\n\n    (* Head of function application (cterm) *)\n    fun chead_of ct = case Thm.term_of ct of\n      (_$_) => chead_of (Thm.dest_fun ct)\n      | _ => ct;\n\n    val chead_of_thm = norm_def_thm #> Thm.lhs_of #> chead_of;\n\n    val meta_cong_rl = @{thm \"eq_reflection\"}\n        OF @{thms \"arg_cong\"} OF @{thms \"meta_eq_to_obj_eq\"}\n\n    fun inst_meta_cong ctxt ct = let\n      val (ct, ctxt') = import_cterm ct ctxt;\n      val mc_thm = meta_cong_rl;\n      val fpat = mc_thm |> Thm.cprop_of |> Drule.strip_imp_concl \n        |> Thm.dest_arg1 |> chead_of;\n      val inst = infer_instantiate ctxt [(#1 (dest_Var (Thm.term_of fpat)), ct)] mc_thm;\n      val inst' = singleton (Variable.export ctxt' ctxt) inst;\n    in inst' end\n\n\n    (* Define name\\<equiv>rhs, generate _def theorem. *)\n    fun define_simple name rhs lthy = let \n      (* Import type variables *)\n      val (rhs,lthy) = yield_singleton Variable.importT_terms rhs lthy;\n      val ((ft,(_,def_thm)),lthy) \n        = Local_Theory.define ((Binding.name name,NoSyn),\n         ((Binding.name (Thm.def_name name),[]),rhs)) lthy;\n    in ((ft,def_thm),lthy) end;\n\n    fun wrap_lthy_result_global f rmap thy = let\n      val lthy = Named_Target.theory_init thy;\n      val (r,lthy) = f lthy;\n      val (r,thy) = Local_Theory.exit_result_global rmap (r,lthy);\n    in\n      (r,thy)\n    end\n\n    fun wrap_lthy_global f = wrap_lthy_result_global (pair () o f) (K I) #> #2;\n\n    fun wrap_lthy_result_local f rmap lthy = let\n      val lthy = (snd o Local_Theory.begin_nested) lthy;\n      val (r,lthy) = f lthy;\n      val m = Local_Theory.target_morphism lthy;\n      val lthy = Local_Theory.end_nested lthy;\n      val r = rmap m r;\n    in\n      (r,lthy)\n    end\n\n    fun wrap_lthy_local f = wrap_lthy_result_local (pair () o f) (K I) #> #2;\n\n\n\n    (* Define name\\<equiv>rhs, yielding constant *)\n    fun define_simple_global name rhs thy = let\n      val lthy = Named_Target.theory_init thy;\n      val (r,lthy) = define_simple name rhs lthy;\n      fun map_res m (t,thm) = (Morphism.term m t,Morphism.thm m thm);\n      val (r,thy) = Local_Theory.exit_result_global (map_res) (r,lthy);\n    in (r,thy) end;\n\n    (* Define name\\<equiv>rhs, yielding constant *)\n    fun define_simple_local name rhs lthy = let\n      val lthy = (snd o Local_Theory.begin_nested) lthy;\n      val (r,lthy) = define_simple name rhs lthy;\n      val m = Local_Theory.target_morphism lthy;\n      val lthy = Local_Theory.end_nested lthy;\n      fun map_res m (t,thm) = (Morphism.term m t,Morphism.thm m thm);\n      val (r,lthy) = (map_res m r,lthy);\n    in (r,lthy) end;\n\n    fun map_option _ NONE = NONE\n      | map_option f (SOME a) = SOME (f a);\n\n\n    fun revert_abbrevs mpat thy = let\n      val ctxt = Proof_Context.init_global thy;\n      val match_prefix = if Long_Name.is_qualified mpat then mpat\n        else Long_Name.qualify (Context.theory_name thy) mpat;\n      val {const_space, constants, ...} = Sign.consts_of thy |> Consts.dest;\n      val names = \n      Name_Space.extern_entries true ctxt const_space constants\n      |> map_filter (fn\n          ((name, _), (_, SOME _)) =>\n            if Long_Name.qualifier name = match_prefix then SOME name else NONE\n        | _ => NONE)\n      val _ = if null names then \n        warning (\"ICF_Tools.revert_abbrevs: No names with prefix: \" \n          ^ match_prefix) \n      else ();\n    in fold (Sign.revert_abbrev \"\") names thy end\n\n\n  end;\n\n\\<close>"], ["", "attribute_setup rem_dup_prems = \\<open>\n  Scan.succeed (Thm.rule_attribute [] (ICF_Tools.rem_dup_prems o Context.proof_of))\n\\<close> \"Remove duplicate premises\""], ["", "method_setup dup_subgoals = \\<open>\n  Scan.succeed (fn ctxt => SIMPLE_METHOD (PRIMITIVE (ICF_Tools.rem_dup_prems ctxt)))\n\\<close> \"Remove duplicate subgoals\""], ["", "end"]]}