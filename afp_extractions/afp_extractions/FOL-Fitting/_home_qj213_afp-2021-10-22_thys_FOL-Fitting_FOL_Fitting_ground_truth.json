{"file_name": "/home/qj213/afp-2021-10-22/thys/FOL-Fitting/FOL_Fitting.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/FOL-Fitting", "problem_names": ["theorem set_inter_compl_diff [simp]: \\<open>- A \\<inter> B = B - A\\<close>", "theorem closedt_mono: assumes le: \\<open>i \\<le> j\\<close>\n  shows \\<open>closedt i (t::'a term) \\<Longrightarrow> closedt j t\\<close>\n    and \\<open>closedts i (ts::'a term list) \\<Longrightarrow> closedts j ts\\<close>", "theorem closed_mono: assumes le: \\<open>i \\<le> j\\<close>\n  shows \\<open>closed i p \\<Longrightarrow> closed j p\\<close>", "theorem lift_closed [simp]:\n  \\<open>closedt 0 (t::'a term) \\<Longrightarrow> closedt 0 (liftt t)\\<close>\n  \\<open>closedts 0 (ts::'a term list) \\<Longrightarrow> closedts 0 (liftts ts)\\<close>", "theorem subst_closedt [simp]:\n  assumes u: \\<open>closedt 0 u\\<close>\n  shows \\<open>closedt (Suc i) t \\<Longrightarrow> closedt i (t[u/i])\\<close>\n    and \\<open>closedts (Suc i) ts \\<Longrightarrow> closedts i (ts[u/i])\\<close>", "theorem subst_closed [simp]:\n  \\<open>closedt 0 t \\<Longrightarrow> closed (Suc i) p \\<Longrightarrow> closed i (p[t/i])\\<close>", "theorem subst_size_form [simp]: \\<open>size_form (subst p t i) = size_form p\\<close>", "theorem psubstt_closed [simp]:\n  \\<open>closedt i (psubstt f t) = closedt i t\\<close>\n  \\<open>closedts i (psubstts f ts) = closedts i ts\\<close>", "theorem psubst_closed [simp]:\n  \\<open>closed i (psubst f p) = closed i p\\<close>", "theorem psubstt_subst [simp]:\n  \\<open>psubstt f (substt t u i) = substt (psubstt f t) (psubstt f u) i\\<close>\n  \\<open>psubstts f (substts ts u i) = substts (psubstts f ts) (psubstt f u) i\\<close>", "theorem psubstt_lift [simp]:\n  \\<open>psubstt f (liftt t) = liftt (psubstt f t)\\<close>\n  \\<open>psubstts f (liftts ts) = liftts (psubstts f ts)\\<close>", "theorem psubst_subst [simp]:\n  \\<open>psubst f (subst P t i) = subst (psubst f P) (psubstt f t) i\\<close>", "theorem psubstt_upd [simp]:\n  \\<open>x \\<notin> paramst (t::'a term) \\<Longrightarrow> psubstt (f(x := y)) t = psubstt f t\\<close>\n  \\<open>x \\<notin> paramsts (ts::'a term list) \\<Longrightarrow> psubstts (f(x := y)) ts = psubstts f ts\\<close>", "theorem psubst_upd [simp]: \\<open>x \\<notin> params P \\<Longrightarrow> psubst (f(x := y)) P = psubst f P\\<close>", "theorem psubstt_id:\n  fixes t :: \\<open>'a term\\<close> and ts :: \\<open>'a term list\\<close>\n  shows \\<open>psubstt id t = t\\<close> and \\<open>psubstts (\\<lambda>x. x) ts = ts\\<close>", "theorem psubst_id [simp]: \\<open>psubst id = id\\<close>", "theorem psubstt_image [simp]:\n  \\<open>paramst (psubstt f t) = f ` paramst t\\<close>\n  \\<open>paramsts (psubstts f ts) = f ` paramsts ts\\<close>", "theorem psubst_image [simp]: \\<open>params (psubst f p) = f ` params p\\<close>", "lemma shift_eq [simp]: \\<open>i = j \\<Longrightarrow> (e\\<langle>i:T\\<rangle>) j = T\\<close>", "lemma shift_gt [simp]: \\<open>j < i \\<Longrightarrow> (e\\<langle>i:T\\<rangle>) j = e j\\<close>", "lemma shift_lt [simp]: \\<open>i < j \\<Longrightarrow> (e\\<langle>i:T\\<rangle>) j = e (j - 1)\\<close>", "lemma shift_commute [simp]: \\<open>e\\<langle>i:U\\<rangle>\\<langle>0:T\\<rangle> = e\\<langle>0:T\\<rangle>\\<langle>Suc i:U\\<rangle>\\<close>", "theorem subst_lemma' [simp]:\n  \\<open>evalt e f (substt t u i) = evalt (e\\<langle>i:evalt e f u\\<rangle>) f t\\<close>\n  \\<open>evalts e f (substts ts u i) = evalts (e\\<langle>i:evalt e f u\\<rangle>) f ts\\<close>", "theorem lift_lemma [simp]:\n  \\<open>evalt (e\\<langle>0:z\\<rangle>) f (liftt t) = evalt e f t\\<close>\n  \\<open>evalts (e\\<langle>0:z\\<rangle>) f (liftts ts) = evalts e f ts\\<close>", "theorem subst_lemma [simp]:\n  \\<open>eval e f g (subst a t i) = eval (e\\<langle>i:evalt e f t\\<rangle>) f g a\\<close>", "theorem upd_lemma' [simp]:\n  \\<open>n \\<notin> paramst t \\<Longrightarrow> evalt e (f(n := x)) t = evalt e f t\\<close>\n  \\<open>n \\<notin> paramsts ts \\<Longrightarrow> evalts e (f(n := x)) ts = evalts e f ts\\<close>", "theorem upd_lemma [simp]:\n  \\<open>n \\<notin> params p \\<Longrightarrow> eval e (f(n := x)) g p = eval e f g p\\<close>", "theorem list_upd_lemma [simp]: \\<open>list_all (\\<lambda>p. n \\<notin> params p) G \\<Longrightarrow>\n  list_all (eval e (f(n := x)) g) G = list_all (eval e f g) G\\<close>", "theorem psubst_eval' [simp]:\n  \\<open>evalt e f (psubstt h t) = evalt e (\\<lambda>p. f (h p)) t\\<close>\n  \\<open>evalts e f (psubstts h ts) = evalts e (\\<lambda>p. f (h p)) ts\\<close>", "theorem psubst_eval:\n  \\<open>eval e f g (psubst h p) = eval e (\\<lambda>p. f (h p)) g p\\<close>", "theorem ex_all_commute_eval:\n  \\<open>eval e f g (Impl (Exists (Forall (Pred p [Var 1, Var 0])))\n    (Forall (Exists (Pred p [Var 0, Var 1]))))\\<close>", "theorem Class': \\<open>Neg A # G \\<turnstile> A \\<Longrightarrow> G \\<turnstile> A\\<close>", "theorem cut: \\<open>G \\<turnstile> A \\<Longrightarrow> A # G \\<turnstile> B \\<Longrightarrow> G \\<turnstile> B\\<close>", "theorem ForallE': \\<open>G \\<turnstile> Forall a \\<Longrightarrow> subst a t 0 # G \\<turnstile> B \\<Longrightarrow> G \\<turnstile> B\\<close>", "theorem tnd: \\<open>[] \\<turnstile> Or (Pred p []) (Neg (Pred p []))\\<close> (is \\<open>_ \\<turnstile> ?or\\<close>)", "theorem ex_all_commute:\n  \\<open>([]::(nat, 'b) form list) \\<turnstile> Impl (Exists (Forall (Pred p [Var 1, Var 0])))\n     (Forall (Exists (Pred p [Var 0, Var 1])))\\<close>", "theorem drinker: \\<open>([]::(nat, 'b) form list) \\<turnstile>\n  Exists (Impl (Pred P [Var 0]) (Forall (Pred P [Var 0])))\\<close>", "theorem peirce:\n  \\<open>[] \\<turnstile> Impl (Impl (Impl (Pred P []) (Pred Q [])) (Pred P [])) (Pred P [])\\<close>\n  (is \\<open>[] \\<turnstile> Impl ?PQP (Pred P [])\\<close>)", "theorem correctness: \\<open>G \\<turnstile> p \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> p\\<close>", "theorem alt_consistency:\n  assumes conc: \\<open>consistency C\\<close>\n  shows \\<open>alt_consistency (mk_alt_consistency C)\\<close> (is \\<open>alt_consistency ?C'\\<close>)", "theorem mk_alt_consistency_subset: \\<open>C \\<subseteq> mk_alt_consistency C\\<close>", "lemma subset_in_close:\n  assumes \\<open>S \\<subseteq> S'\\<close>\n  shows \\<open>S' \\<union> x \\<in> C \\<longrightarrow> S \\<union> x \\<in> close C\\<close>", "theorem close_consistency:\n  assumes conc: \\<open>consistency C\\<close>\n  shows \\<open>consistency (close C)\\<close>", "theorem close_closed: \\<open>subset_closed (close C)\\<close>", "theorem close_subset: \\<open>C \\<subseteq> close C\\<close>", "theorem mk_alt_consistency_closed:\n  assumes \\<open>subset_closed C\\<close>\n  shows \\<open>subset_closed (mk_alt_consistency C)\\<close>", "theorem finite_alt_consistency:\n  assumes altconc: \\<open>alt_consistency C\\<close>\n    and \\<open>subset_closed C\\<close>\n  shows \\<open>alt_consistency (mk_finite_char C)\\<close>", "theorem finite_char: \\<open>finite_char (mk_finite_char C)\\<close>", "theorem finite_char_closed: \\<open>finite_char C \\<Longrightarrow> subset_closed C\\<close>", "theorem finite_char_subset: \\<open>subset_closed C \\<Longrightarrow> C \\<subseteq> mk_finite_char C\\<close>", "theorem is_chainD: \\<open>is_chain f \\<Longrightarrow> x \\<in> f m \\<Longrightarrow> x \\<in> f (m + n)\\<close>", "theorem is_chainD':\n  assumes \\<open>is_chain f\\<close> and \\<open>x \\<in> f m\\<close> and \\<open>m \\<le> k\\<close>\n  shows \\<open>x \\<in> f k\\<close>", "theorem chain_index:\n  assumes ch: \\<open>is_chain f\\<close> and fin: \\<open>finite F\\<close>\n  shows \\<open>F \\<subseteq> (\\<Union>n. f n) \\<Longrightarrow> \\<exists>n. F \\<subseteq> f n\\<close>", "lemma chain_union_closed':\n  assumes \\<open>is_chain f\\<close> and \\<open>(\\<forall>n. f n \\<in> C)\\<close> and \\<open>\\<forall>S' \\<in> C. \\<forall>S \\<subseteq> S'. S \\<in> C\\<close>\n    and \\<open>finite S'\\<close> and \\<open>S' \\<subseteq> (\\<Union>n. f n)\\<close>\n  shows \\<open>S' \\<in> C\\<close>", "theorem chain_union_closed:\n  assumes \\<open>finite_char C\\<close> and \\<open>is_chain f\\<close> and \\<open>\\<forall>n. f n \\<in> C\\<close>\n  shows \\<open>(\\<Union>n. f n) \\<in> C\\<close>", "theorem is_chain_extend: \\<open>is_chain (extend S C f)\\<close>", "theorem finite_paramst [simp]: \\<open>finite (paramst (t :: 'a term))\\<close>\n  \\<open>finite (paramsts (ts :: 'a term list))\\<close>", "theorem finite_params [simp]: \\<open>finite (params p)\\<close>", "theorem finite_params_extend [simp]:\n  \\<open>infinite (\\<Inter>p \\<in> S. - params p) \\<Longrightarrow> infinite (\\<Inter>p \\<in> extend S C f n. - params p)\\<close>", "lemma infinite_params_available:\n  assumes \\<open>infinite (- (\\<Union>p \\<in> S. params p))\\<close>\n  shows \\<open>\\<exists>x. x \\<notin> (\\<Union>p \\<in> extend S C f n \\<union> {f n}. params p)\\<close>", "lemma extend_in_C_Exists:\n  assumes \\<open>alt_consistency C\\<close>\n    and \\<open>infinite (- (\\<Union>p \\<in> S. params p))\\<close>\n    and \\<open>extend S C f n \\<union> {f n} \\<in> C\\<close> (is \\<open>?S' \\<in> C\\<close>)\n    and \\<open>\\<exists>p. f n = Exists p\\<close>\n  shows \\<open>extend S C f (Suc n) \\<in> C\\<close>", "lemma extend_in_C_Neg_Forall:\n  assumes \\<open>alt_consistency C\\<close>\n    and \\<open>infinite (- (\\<Union>p \\<in> S. params p))\\<close>\n    and \\<open>extend S C f n \\<union> {f n} \\<in> C\\<close> (is \\<open>?S' \\<in> C\\<close>)\n    and \\<open>\\<forall>p. f n \\<noteq> Exists p\\<close>\n    and \\<open>\\<exists>p. f n = Neg (Forall p)\\<close>\n  shows \\<open>extend S C f (Suc n) \\<in> C\\<close>", "lemma extend_in_C_no_delta:\n  assumes \\<open>extend S C f n \\<union> {f n} \\<in> C\\<close>\n    and \\<open>\\<forall>p. f n \\<noteq> Exists p\\<close>\n    and \\<open>\\<forall>p. f n \\<noteq> Neg (Forall p)\\<close>\n  shows \\<open>extend S C f (Suc n) \\<in> C\\<close>", "lemma extend_in_C_stop:\n  assumes \\<open>extend S C f n \\<in> C\\<close>\n    and \\<open>extend S C f n \\<union> {f n} \\<notin> C\\<close>\n  shows \\<open>extend S C f (Suc n) \\<in> C\\<close>", "theorem extend_in_C: \\<open>alt_consistency C \\<Longrightarrow>\n  S \\<in> C \\<Longrightarrow> infinite (- (\\<Union>p \\<in> S. params p)) \\<Longrightarrow> extend S C f n \\<in> C\\<close>", "theorem Extend_in_C: \\<open>alt_consistency C \\<Longrightarrow> finite_char C \\<Longrightarrow>\n  S \\<in> C \\<Longrightarrow> infinite (- (\\<Union>p \\<in> S. params p)) \\<Longrightarrow> Extend S C f \\<in> C\\<close>", "theorem Extend_subset: \\<open>S \\<subseteq> Extend S C f\\<close>", "theorem extend_maximal:\n  assumes \\<open>\\<forall>y. \\<exists>n. y = f n\\<close>\n    and \\<open>finite_char C\\<close>\n  shows \\<open>maximal (Extend S C f) C\\<close>", "theorem herbrand_evalt [simp]:\n  \\<open>closedt 0 t \\<Longrightarrow> term_of_hterm (evalt e HApp t) = t\\<close>\n  \\<open>closedts 0 ts \\<Longrightarrow> terms_of_hterms (evalts e HApp ts) = ts\\<close>", "theorem herbrand_evalt' [simp]:\n  \\<open>evalt e HApp (term_of_hterm ht) = ht\\<close>\n  \\<open>evalts e HApp (terms_of_hterms hts) = hts\\<close>", "theorem closed_hterm [simp]:\n  \\<open>closedt 0 (term_of_hterm (ht::'a hterm))\\<close>\n  \\<open>closedts 0 (terms_of_hterms (hts::'a hterm list))\\<close>", "theorem hintikka_model:\n  assumes hin: \\<open>hintikka H\\<close>\n  shows \\<open>(p \\<in> H \\<longrightarrow> closed 0 p \\<longrightarrow>\n    eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) p) \\<and>\n  (Neg p \\<in> H \\<longrightarrow> closed 0 p \\<longrightarrow>\n    eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) (Neg p))\\<close>", "lemma Exists_in_extend:\n  assumes \\<open>extend S C f n \\<union> {f n} \\<in> C\\<close> (is \\<open>?S' \\<in> C\\<close>)\n    and \\<open>Exists P = f n\\<close>\n  shows \\<open>P[(App (SOME k. k \\<notin> (\\<Union>p \\<in> extend S C f n \\<union> {f n}. params p)) [])/0] \\<in>\n          extend S C f (Suc n)\\<close>\n    (is \\<open>subst P ?t 0 \\<in> extend S C f (Suc n)\\<close>)", "lemma Neg_Forall_in_extend:\n  assumes \\<open>extend S C f n \\<union> {f n} \\<in> C\\<close> (is \\<open>?S' \\<in> C\\<close>)\n    and \\<open>Neg (Forall P) = f n\\<close>\n  shows \\<open>Neg (P[(App (SOME k. k \\<notin> (\\<Union>p \\<in> extend S C f n \\<union> {f n}. params p)) [])/0])  \\<in>\n          extend S C f (Suc n)\\<close>\n    (is \\<open>Neg (subst P ?t 0) \\<in> extend S C f (Suc n)\\<close>)", "theorem extend_hintikka:\n  assumes fin_ch: \\<open>finite_char C\\<close>\n    and infin_p: \\<open>infinite (- (\\<Union>p \\<in> S. params p))\\<close>\n    and surj: \\<open>\\<forall>y. \\<exists>n. y = f n\\<close>\n    and altc: \\<open>alt_consistency C\\<close>\n    and \\<open>S \\<in> C\\<close>\n  shows \\<open>hintikka (Extend S C f)\\<close> (is \\<open>hintikka ?H\\<close>)", "lemma hintikka_Extend_S:\n  assumes \\<open>consistency C\\<close> and \\<open>S \\<in> C\\<close>\n    and \\<open>infinite (- (\\<Union>p \\<in> S. params p))\\<close>\n  shows \\<open>hintikka (Extend S (mk_finite_char (mk_alt_consistency (close C))) from_nat)\\<close>\n    (is \\<open>hintikka (Extend S ?C' from_nat)\\<close>)", "theorem model_existence:\n  assumes \\<open>consistency C\\<close>\n    and \\<open>S \\<in> C\\<close>\n    and \\<open>infinite (- (\\<Union>p \\<in> S. params p))\\<close>\n    and \\<open>p \\<in> S\\<close>\n    and \\<open>closed 0 p\\<close>\n  shows \\<open>eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> Extend S\n        (mk_finite_char (mk_alt_consistency (close C))) from_nat) p\\<close>", "theorem deriv_consistency:\n  assumes inf_param: \\<open>infinite (UNIV :: 'a set)\\<close>\n  shows \\<open>consistency {S::('a, 'b) form set. \\<exists>G. S = set G \\<and> \\<not> G \\<turnstile> FF}\\<close>", "theorem natded_complete:\n  assumes \\<open>closed 0 p\\<close>\n    and \\<open>list_all (closed 0) ps\\<close>\n    and mod: \\<open>\\<forall>e f g. e,(f :: nat \\<Rightarrow> nat hterm list \\<Rightarrow> nat hterm),\n              (g :: nat \\<Rightarrow> nat hterm list \\<Rightarrow> bool),ps \\<Turnstile> p\\<close>\n  shows \\<open>ps \\<turnstile> p\\<close>", "theorem sat_consistency:\n  \\<open>consistency {S. infinite (- (\\<Union>p \\<in> S. params p)) \\<and> (\\<exists>f. \\<forall>(p::('a, 'b)form) \\<in> S. eval e f g p)}\\<close>", "theorem doublep_infinite_params:\n  \\<open>infinite (- (\\<Union>p \\<in> psubst (\\<lambda>n::nat. 2 * n) ` S. params p))\\<close>", "theorem loewenheim_skolem:\n  assumes evalS: \\<open>\\<forall>p \\<in> S. eval e f g p\\<close>\n  shows \\<open>\\<forall>p \\<in> S. closed 0 p \\<longrightarrow> eval e' (\\<lambda>n. HApp (2*n)) (\\<lambda>a ts.\n      Pred a (terms_of_hterms ts) \\<in> Extend (psubst (\\<lambda>n. 2 * n) ` S)\n        (mk_finite_char (mk_alt_consistency (close\n          {S. infinite (- (\\<Union>p \\<in> S. params p)) \\<and> (\\<exists>f. \\<forall>p \\<in> S. eval e f g p)}))) from_nat) p\\<close>\n    (is \\<open>\\<forall>_ \\<in> _. _ _ _ \\<longrightarrow> eval _ _ ?g _\\<close>)", "lemma new_psubst_image':\n  \\<open>new_term c t \\<Longrightarrow> d \\<notin> image f (paramst t) \\<Longrightarrow> new_term d (psubstt (f(c := d)) t)\\<close>\n  \\<open>new_list c l \\<Longrightarrow> d \\<notin> image f (paramsts l) \\<Longrightarrow> new_list d (psubstts (f(c := d)) l)\\<close>", "lemma new_psubst_image: \\<open>new c p \\<Longrightarrow> d \\<notin> image f (params p) \\<Longrightarrow> new d (psubst (f(c := d)) p)\\<close>", "lemma news_psubst: \\<open>news c z \\<Longrightarrow> d \\<notin> image f (\\<Union>p \\<in> set z. params p) \\<Longrightarrow>\n    news d (map (psubst (f(c := d))) z)\\<close>", "lemma member_psubst: \\<open>p \\<in> set z \\<Longrightarrow> psubst f p \\<in> set (map (psubst f) z)\\<close>", "lemma deriv_psubst:\n  fixes f :: \\<open>'a \\<Rightarrow> 'a\\<close>\n  assumes inf_params: \\<open>infinite (UNIV :: 'a set)\\<close>\n  shows \\<open>z \\<turnstile> p \\<Longrightarrow> map (psubst f) z \\<turnstile> psubst f p\\<close>", "lemma subst_0_lift:\n  \\<open>substt (liftt t) s 0 = t\\<close>\n  \\<open>substts (liftts l) s 0 = l\\<close>", "lemma params_lift [simp]:\n  fixes t :: \\<open>'a term\\<close> and ts :: \\<open>'a term list\\<close>\n  shows\n    \\<open>paramst (liftt t) = paramst t\\<close>\n    \\<open>paramsts (liftts ts) = paramsts ts\\<close>", "lemma subst_new' [simp]:\n  \\<open>new_term c s \\<Longrightarrow> new_term c t \\<Longrightarrow> new_term c (substt t s m)\\<close>\n  \\<open>new_term c s \\<Longrightarrow> new_list c l \\<Longrightarrow> new_list c (substts l s m)\\<close>", "lemma subst_new [simp]: \\<open>new_term c s \\<Longrightarrow> new c p \\<Longrightarrow> new c (subst p s m)\\<close>", "lemma subst_new_all:\n  assumes \\<open>a \\<notin> set cs\\<close> \\<open>list_all (\\<lambda>c. new c p) cs\\<close>\n  shows \\<open>list_all (\\<lambda>c. new c (subst p (App a []) m)) cs\\<close>", "lemma subc_new' [simp]:\n  \\<open>new_term c t \\<Longrightarrow> subc_term c s t = t\\<close>\n  \\<open>new_list c l \\<Longrightarrow> subc_list c s l = l\\<close>", "lemma subc_new [simp]: \\<open>new c p \\<Longrightarrow> subc c s p = p\\<close>", "lemma subcs_news: \\<open>news c z \\<Longrightarrow> subcs c s z = z\\<close>", "lemma subc_psubst' [simp]:\n  \\<open>(\\<forall>x \\<in> paramst t. x \\<noteq> c \\<longrightarrow> f x \\<noteq> f c) \\<Longrightarrow>\n    psubstt f (subc_term c s t) = subc_term (f c) (psubstt f s) (psubstt f t)\\<close>\n  \\<open>(\\<forall>x \\<in> paramsts l. x \\<noteq> c \\<longrightarrow> f x \\<noteq> f c) \\<Longrightarrow>\n    psubstts f (subc_list c s l) = subc_list (f c) (psubstt f s) (psubstts f l)\\<close>", "lemma subc_psubst: \\<open>(\\<forall>x \\<in> params p. x \\<noteq> c \\<longrightarrow> f x \\<noteq> f c) \\<Longrightarrow>\n    psubst f (subc c s p) = subc (f c) (psubstt f s) (psubst f p)\\<close>", "lemma subcs_psubst: \\<open>(\\<forall>x \\<in> (\\<Union>p \\<in> set z. params p). x \\<noteq> c \\<longrightarrow> f x \\<noteq> f c) \\<Longrightarrow>\n    map (psubst f) (subcs c s z) = subcs (f c) (psubstt f s) (map (psubst f) z)\\<close>", "lemma new_lift:\n  \\<open>new_term c t \\<Longrightarrow> new_term c (liftt t)\\<close>\n  \\<open>new_list c l \\<Longrightarrow> new_list c (liftts l)\\<close>", "lemma new_subc' [simp]:\n  \\<open>new_term d s \\<Longrightarrow> new_term d t \\<Longrightarrow> new_term d (subc_term c s t)\\<close>\n  \\<open>new_term d s \\<Longrightarrow> new_list d l \\<Longrightarrow> new_list d (subc_list c s l)\\<close>", "lemma new_subc [simp]: \\<open>new_term d s \\<Longrightarrow> new d p \\<Longrightarrow> new d (subc c s p)\\<close>", "lemma news_subcs: \\<open>new_term d s \\<Longrightarrow> news d z \\<Longrightarrow> news d (subcs c s z)\\<close>", "lemma psubst_new_free':\n  \\<open>c \\<noteq> n \\<Longrightarrow> new_term n (psubstt (id(n := c)) t)\\<close>\n  \\<open>c \\<noteq> n \\<Longrightarrow> new_list n (psubstts (id(n := c)) l)\\<close>", "lemma psubst_new_free: \\<open>c \\<noteq> n \\<Longrightarrow> new n (psubst (id(n := c)) p)\\<close>", "lemma map_psubst_new_free: \\<open>c \\<noteq> n \\<Longrightarrow> news n (map (psubst (id(n := c))) z)\\<close>", "lemma psubst_new_away' [simp]:\n  \\<open>new_term fresh t \\<Longrightarrow> psubstt (id(fresh := c)) (psubstt (id(c := fresh)) t) = t\\<close>\n  \\<open>new_list fresh l \\<Longrightarrow> psubstts (id(fresh := c)) (psubstts (id(c := fresh)) l) = l\\<close>", "lemma psubst_new_away [simp]: \\<open>new fresh p \\<Longrightarrow> psubst (id(fresh := c)) (psubst (id(c := fresh)) p) = p\\<close>", "lemma map_psubst_new_away:\n  \\<open>news fresh z \\<Longrightarrow> map (psubst (id(fresh := c))) (map (psubst (id(c := fresh))) z) = z\\<close>", "lemma psubst_new':\n  \\<open>new_term c t \\<Longrightarrow> psubstt (id(c := x)) t = t\\<close>\n  \\<open>new_list c l \\<Longrightarrow> psubstts (id(c := x)) l = l\\<close>", "lemma psubst_new: \\<open>new c p \\<Longrightarrow> psubst (id(c := x)) p = p\\<close>", "lemma map_psubst_new: \\<open>news c z \\<Longrightarrow> map (psubst (id(c := x))) z = z\\<close>", "lemma lift_subst [simp]:\n  \\<open>liftt (substt t u m) = substt (liftt t) (liftt u) (m + 1)\\<close>\n  \\<open>liftts (substts l u m) = substts (liftts l) (liftt u) (m + 1)\\<close>", "lemma new_subc_same' [simp]:\n  \\<open>new_term c s \\<Longrightarrow> new_term c (subc_term c s t)\\<close>\n  \\<open>new_term c s \\<Longrightarrow> new_list c (subc_list c s l)\\<close>", "lemma new_subc_same: \\<open>new_term c s \\<Longrightarrow> new c (subc c s p)\\<close>", "lemma lift_subc:\n  \\<open>liftt (subc_term c s t) = subc_term c (liftt s) (liftt t)\\<close>\n  \\<open>liftts (subc_list c s l) = subc_list c (liftt s) (liftts l)\\<close>", "lemma new_subc_put':\n  \\<open>new_term c s \\<Longrightarrow> subc_term c s (substt t u m) = subc_term c s (substt t (subc_term c s u) m)\\<close>\n  \\<open>new_term c s \\<Longrightarrow> subc_list c s (substts l u m) = subc_list c s (substts l (subc_term c s u) m)\\<close>", "lemma new_subc_put:\n  \\<open>new_term c s \\<Longrightarrow> subc c s (subst p t m) = subc c s (subst p (subc_term c s t) m)\\<close>", "lemma subc_subst_new':\n  \\<open>new_term c u \\<Longrightarrow> subc_term c (substt s u m) (substt t u m) = substt (subc_term c s t) u m\\<close>\n  \\<open>new_term c u \\<Longrightarrow> subc_list c (substt s u m) (substts l u m) = substts (subc_list c s l) u m\\<close>", "lemma subc_subst_new:\n  \\<open>new_term c t \\<Longrightarrow> subc c (substt s t m) (subst p t m) = subst (subc c s p) t m\\<close>", "lemma subc_sub_0_new [simp]:\n  \\<open>new_term c t \\<Longrightarrow> subc c s (subst p t 0) = subst (subc c (liftt s) p) t 0\\<close>", "lemma member_subc: \\<open>p \\<in> set z \\<Longrightarrow> subc c s p \\<in> set (subcs c s z)\\<close>", "lemma deriv_subc:\n  fixes p :: \\<open>('a, 'b) form\\<close>\n  assumes inf_params: \\<open>infinite (UNIV :: 'a set)\\<close>\n  shows \\<open>z \\<turnstile> p \\<Longrightarrow> subcs c s z \\<turnstile> subc c s p\\<close>", "lemma psubst_new_subset:\n  assumes \\<open>set z \\<subseteq> set z'\\<close> \\<open>c \\<notin> (\\<Union>p \\<in> set z. params p)\\<close>\n  shows \\<open>set z \\<subseteq> set (map (psubst (id(c := n))) z')\\<close>", "lemma subset_cons: \\<open>set z \\<subseteq> set z' \\<Longrightarrow> set (p # z) \\<subseteq> set (p # z')\\<close>", "lemma weaken_assumptions:\n  fixes p :: \\<open>('a, 'b) form\\<close>\n  assumes inf_params: \\<open>infinite (UNIV :: 'a set)\\<close>\n  shows \\<open>z \\<turnstile> p \\<Longrightarrow> set z \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> p\\<close>", "lemma semantics_put_imps:\n  \\<open>(e,f,g,z \\<Turnstile> p) = eval e f g (put_imps p z)\\<close>", "lemma shift_imp_assum:\n  fixes p :: \\<open>('a, 'b) form\\<close>\n  assumes inf_params: \\<open>infinite (UNIV :: 'a set)\\<close>\n    and \\<open>z \\<turnstile> Impl p q\\<close>\n  shows \\<open>p # z \\<turnstile> q\\<close>", "lemma remove_imps:\n  assumes \\<open>infinite (- params p)\\<close>\n  shows \\<open>z' \\<turnstile> put_imps p z \\<Longrightarrow> rev z @ z' \\<turnstile> p\\<close>", "lemma subc_sub_closed_var' [simp]:\n  \\<open>new_term c t \\<Longrightarrow> closedt (Suc m) t \\<Longrightarrow> subc_term c (Var m) (substt t (App c []) m) = t\\<close>\n  \\<open>new_list c l \\<Longrightarrow> closedts (Suc m) l \\<Longrightarrow> subc_list c (Var m) (substts l (App c []) m) = l\\<close>", "lemma subc_sub_closed_var [simp]: \\<open>new c p \\<Longrightarrow> closed (Suc m) p \\<Longrightarrow>\n    subc c (Var m) (subst p (App c []) m) = p\\<close>", "lemma sub_put_unis [simp]:\n  \\<open>subst (put_unis k p) (App c []) i = put_unis k (subst p (App c []) (i + k))\\<close>", "lemma closed_put_unis [simp]: \\<open>closed m (put_unis k p) = closed (m + k) p\\<close>", "lemma valid_put_unis: \\<open>\\<forall>(e :: nat \\<Rightarrow> 'a) f g. eval e f g p \\<Longrightarrow>\n    eval (e :: nat \\<Rightarrow> 'a) f g (put_unis m p)\\<close>", "lemma put_unis_collapse: \\<open>put_unis m (put_unis n p) = put_unis (m + n) p\\<close>", "lemma consts_for_unis: \\<open>[] \\<turnstile> put_unis (length cs) p \\<Longrightarrow>\n  [] \\<turnstile> consts_for_unis (put_unis (length cs) p) cs\\<close>", "lemma vars_for_consts:\n  assumes \\<open>infinite (- params p)\\<close>\n  shows \\<open>[] \\<turnstile> p \\<Longrightarrow> [] \\<turnstile> vars_for_consts p xs\\<close>", "lemma vars_for_consts_for_unis:\n  \\<open>closed (length cs) p \\<Longrightarrow> list_all (\\<lambda>c. new c p) cs \\<Longrightarrow> distinct cs \\<Longrightarrow>\n   vars_for_consts (consts_for_unis (put_unis (length cs) p) cs) cs = p\\<close>", "lemma fresh_constant:\n  fixes p :: \\<open>('a, 'b) form\\<close>\n  assumes \\<open>infinite (UNIV :: 'a set)\\<close>\n  shows \\<open>\\<exists>c. c \\<notin> set cs \\<and> new c p\\<close>", "lemma fresh_constants:\n  fixes p :: \\<open>('a, 'b) form\\<close>\n  assumes \\<open>infinite (UNIV :: 'a set)\\<close>\n  shows \\<open>\\<exists>cs. length cs = m \\<and> list_all (\\<lambda>c. new c p) cs \\<and> distinct cs\\<close>", "lemma closed_max:\n  assumes \\<open>closed m p\\<close> \\<open>closed n q\\<close>\n  shows \\<open>closed (max m n) p \\<and> closed (max m n) q\\<close>", "lemma ex_closed' [simp]:\n  fixes t :: \\<open>'a term\\<close> and l :: \\<open>'a term list\\<close>\n  shows \\<open>\\<exists>m. closedt m t\\<close> \\<open>\\<exists>n. closedts n l\\<close>", "lemma ex_closed [simp]: \\<open>\\<exists>m. closed m p\\<close>", "lemma ex_closure: \\<open>\\<exists>m. closed 0 (put_unis m p)\\<close>", "lemma remove_unis_sentence:\n  assumes inf_params: \\<open>infinite (- params p)\\<close>\n    and \\<open>closed 0 (put_unis m p)\\<close> \\<open>[] \\<turnstile> put_unis m p\\<close>\n  shows \\<open>[] \\<turnstile> p\\<close>", "theorem completeness:\n  fixes p :: \\<open>(nat, nat) form\\<close>\n  assumes \\<open>\\<forall>(e :: nat \\<Rightarrow> nat hterm) f g. e, f, g, z \\<Turnstile> p\\<close>\n  shows \\<open>z \\<turnstile> p\\<close>"], "translations": [["", "theorem set_inter_compl_diff [simp]: \\<open>- A \\<inter> B = B - A\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. - A \\<inter> B = B - A", "by blast"], ["", "section \\<open>Terms and formulae\\<close>"], ["", "text \\<open>\n\\label{sec:terms}\nThe datatypes of terms and formulae in {\\em de Bruijn notation}\nare defined as follows:\n\\<close>"], ["", "datatype 'a \"term\"\n  = Var nat\n  | App 'a \\<open>'a term list\\<close>"], ["", "datatype ('a, 'b) form\n  = FF\n  | TT\n  | Pred 'b \\<open>'a term list\\<close>\n  | And \\<open>('a, 'b) form\\<close> \\<open>('a, 'b) form\\<close>\n  | Or \\<open>('a, 'b) form\\<close> \\<open>('a, 'b) form\\<close>\n  | Impl \\<open>('a, 'b) form\\<close> \\<open>('a, 'b) form\\<close>\n  | Neg \\<open>('a, 'b) form\\<close>\n  | Forall \\<open>('a, 'b) form\\<close>\n  | Exists \\<open>('a, 'b) form\\<close>"], ["", "text \\<open>\nWe use \\<open>'a\\<close> and \\<open>'b\\<close> to denote the type of\n{\\em function symbols} and {\\em predicate symbols}, respectively.\nIn applications \\<open>App a ts\\<close> and predicates\n\\<open>Pred a ts\\<close>, the length of \\<open>ts\\<close> is considered\nto be a part of the function or predicate name, so \\<open>App a [t]\\<close>\nand \\<open>App a [t,u]\\<close> refer to different functions.\n\nThe size of a formula is used later for wellfounded induction. The\ndefault implementation provided by the datatype package is not quite\nwhat we need, so here is an alternative version:\n\\<close>"], ["", "primrec size_form :: \\<open>('a, 'b) form \\<Rightarrow> nat\\<close> where\n  \\<open>size_form FF = 0\\<close>\n| \\<open>size_form TT = 0\\<close>\n| \\<open>size_form (Pred _ _) = 0\\<close>\n| \\<open>size_form (And p q) = size_form p + size_form q + 1\\<close>\n| \\<open>size_form (Or p q) = size_form p + size_form q + 1\\<close>\n| \\<open>size_form (Impl p q) = size_form p + size_form q + 1\\<close>\n| \\<open>size_form (Neg p) = size_form p + 1\\<close>\n| \\<open>size_form (Forall p) = size_form p + 1\\<close>\n| \\<open>size_form (Exists p) = size_form p + 1\\<close>"], ["", "subsection \\<open>Closed terms and formulae\\<close>"], ["", "text \\<open>\nMany of the results proved in the following sections are restricted\nto closed terms and formulae. We call a term or formula {\\em closed at\nlevel \\<open>i\\<close>}, if it only contains ``loose'' bound variables with\nindices smaller than \\<open>i\\<close>.\n\\<close>"], ["", "primrec\n  closedt :: \\<open>nat \\<Rightarrow> 'a term \\<Rightarrow> bool\\<close> and\n  closedts :: \\<open>nat \\<Rightarrow> 'a term list \\<Rightarrow> bool\\<close> where\n  \\<open>closedt m (Var n) = (n < m)\\<close>\n| \\<open>closedt m (App a ts) = closedts m ts\\<close>\n| \\<open>closedts m [] = True\\<close>\n| \\<open>closedts m (t # ts) = (closedt m t \\<and> closedts m ts)\\<close>"], ["", "primrec closed :: \\<open>nat \\<Rightarrow> ('a, 'b) form \\<Rightarrow> bool\\<close> where\n  \\<open>closed m FF = True\\<close>\n| \\<open>closed m TT = True\\<close>\n| \\<open>closed m (Pred b ts) = closedts m ts\\<close>\n| \\<open>closed m (And p q) = (closed m p \\<and> closed m q)\\<close>\n| \\<open>closed m (Or p q) = (closed m p \\<and> closed m q)\\<close>\n| \\<open>closed m (Impl p q) = (closed m p \\<and> closed m q)\\<close>\n| \\<open>closed m (Neg p) = closed m p\\<close>\n| \\<open>closed m (Forall p) = closed (Suc m) p\\<close>\n| \\<open>closed m (Exists p) = closed (Suc m) p\\<close>"], ["", "theorem closedt_mono: assumes le: \\<open>i \\<le> j\\<close>\n  shows \\<open>closedt i (t::'a term) \\<Longrightarrow> closedt j t\\<close>\n    and \\<open>closedts i (ts::'a term list) \\<Longrightarrow> closedts j ts\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (closedt i t \\<Longrightarrow> closedt j t) &&&\n    (closedts i ts \\<Longrightarrow> closedts j ts)", "using le"], ["proof (prove)\nusing this:\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. (closedt i t \\<Longrightarrow> closedt j t) &&&\n    (closedts i ts \\<Longrightarrow> closedts j ts)", "by (induct t and ts rule: closedt.induct closedts.induct) simp_all"], ["", "theorem closed_mono: assumes le: \\<open>i \\<le> j\\<close>\n  shows \\<open>closed i p \\<Longrightarrow> closed j p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed i p \\<Longrightarrow> closed j p", "using le"], ["proof (prove)\nusing this:\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. closed i p \\<Longrightarrow> closed j p", "proof (induct p arbitrary: i j)"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>closed i FF; i \\<le> j\\<rbrakk>\n       \\<Longrightarrow> closed j FF\n 2. \\<And>i j.\n       \\<lbrakk>closed i TT; i \\<le> j\\<rbrakk>\n       \\<Longrightarrow> closed j TT\n 3. \\<And>x1 x2 i j.\n       \\<lbrakk>closed i (Pred x1 x2); i \\<le> j\\<rbrakk>\n       \\<Longrightarrow> closed j (Pred x1 x2)\n 4. \\<And>p1 p2 i j.\n       \\<lbrakk>\\<And>i j.\n                   \\<lbrakk>closed i p1; i \\<le> j\\<rbrakk>\n                   \\<Longrightarrow> closed j p1;\n        \\<And>i j.\n           \\<lbrakk>closed i p2; i \\<le> j\\<rbrakk>\n           \\<Longrightarrow> closed j p2;\n        closed i (And p1 p2); i \\<le> j\\<rbrakk>\n       \\<Longrightarrow> closed j (And p1 p2)\n 5. \\<And>p1 p2 i j.\n       \\<lbrakk>\\<And>i j.\n                   \\<lbrakk>closed i p1; i \\<le> j\\<rbrakk>\n                   \\<Longrightarrow> closed j p1;\n        \\<And>i j.\n           \\<lbrakk>closed i p2; i \\<le> j\\<rbrakk>\n           \\<Longrightarrow> closed j p2;\n        closed i (Or p1 p2); i \\<le> j\\<rbrakk>\n       \\<Longrightarrow> closed j (Or p1 p2)\n 6. \\<And>p1 p2 i j.\n       \\<lbrakk>\\<And>i j.\n                   \\<lbrakk>closed i p1; i \\<le> j\\<rbrakk>\n                   \\<Longrightarrow> closed j p1;\n        \\<And>i j.\n           \\<lbrakk>closed i p2; i \\<le> j\\<rbrakk>\n           \\<Longrightarrow> closed j p2;\n        closed i (Impl p1 p2); i \\<le> j\\<rbrakk>\n       \\<Longrightarrow> closed j (Impl p1 p2)\n 7. \\<And>p i j.\n       \\<lbrakk>\\<And>i j.\n                   \\<lbrakk>closed i p; i \\<le> j\\<rbrakk>\n                   \\<Longrightarrow> closed j p;\n        closed i (Neg p); i \\<le> j\\<rbrakk>\n       \\<Longrightarrow> closed j (Neg p)\n 8. \\<And>p i j.\n       \\<lbrakk>\\<And>i j.\n                   \\<lbrakk>closed i p; i \\<le> j\\<rbrakk>\n                   \\<Longrightarrow> closed j p;\n        closed i (Forall p); i \\<le> j\\<rbrakk>\n       \\<Longrightarrow> closed j (Forall p)\n 9. \\<And>p i j.\n       \\<lbrakk>\\<And>i j.\n                   \\<lbrakk>closed i p; i \\<le> j\\<rbrakk>\n                   \\<Longrightarrow> closed j p;\n        closed i (Exists p); i \\<le> j\\<rbrakk>\n       \\<Longrightarrow> closed j (Exists p)", "case (Pred i l)"], ["proof (state)\nthis:\n  closed i (Pred ia__ l)\n  i \\<le> j\n\ngoal (9 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>closed i FF; i \\<le> j\\<rbrakk>\n       \\<Longrightarrow> closed j FF\n 2. \\<And>i j.\n       \\<lbrakk>closed i TT; i \\<le> j\\<rbrakk>\n       \\<Longrightarrow> closed j TT\n 3. \\<And>x1 x2 i j.\n       \\<lbrakk>closed i (Pred x1 x2); i \\<le> j\\<rbrakk>\n       \\<Longrightarrow> closed j (Pred x1 x2)\n 4. \\<And>p1 p2 i j.\n       \\<lbrakk>\\<And>i j.\n                   \\<lbrakk>closed i p1; i \\<le> j\\<rbrakk>\n                   \\<Longrightarrow> closed j p1;\n        \\<And>i j.\n           \\<lbrakk>closed i p2; i \\<le> j\\<rbrakk>\n           \\<Longrightarrow> closed j p2;\n        closed i (And p1 p2); i \\<le> j\\<rbrakk>\n       \\<Longrightarrow> closed j (And p1 p2)\n 5. \\<And>p1 p2 i j.\n       \\<lbrakk>\\<And>i j.\n                   \\<lbrakk>closed i p1; i \\<le> j\\<rbrakk>\n                   \\<Longrightarrow> closed j p1;\n        \\<And>i j.\n           \\<lbrakk>closed i p2; i \\<le> j\\<rbrakk>\n           \\<Longrightarrow> closed j p2;\n        closed i (Or p1 p2); i \\<le> j\\<rbrakk>\n       \\<Longrightarrow> closed j (Or p1 p2)\n 6. \\<And>p1 p2 i j.\n       \\<lbrakk>\\<And>i j.\n                   \\<lbrakk>closed i p1; i \\<le> j\\<rbrakk>\n                   \\<Longrightarrow> closed j p1;\n        \\<And>i j.\n           \\<lbrakk>closed i p2; i \\<le> j\\<rbrakk>\n           \\<Longrightarrow> closed j p2;\n        closed i (Impl p1 p2); i \\<le> j\\<rbrakk>\n       \\<Longrightarrow> closed j (Impl p1 p2)\n 7. \\<And>p i j.\n       \\<lbrakk>\\<And>i j.\n                   \\<lbrakk>closed i p; i \\<le> j\\<rbrakk>\n                   \\<Longrightarrow> closed j p;\n        closed i (Neg p); i \\<le> j\\<rbrakk>\n       \\<Longrightarrow> closed j (Neg p)\n 8. \\<And>p i j.\n       \\<lbrakk>\\<And>i j.\n                   \\<lbrakk>closed i p; i \\<le> j\\<rbrakk>\n                   \\<Longrightarrow> closed j p;\n        closed i (Forall p); i \\<le> j\\<rbrakk>\n       \\<Longrightarrow> closed j (Forall p)\n 9. \\<And>p i j.\n       \\<lbrakk>\\<And>i j.\n                   \\<lbrakk>closed i p; i \\<le> j\\<rbrakk>\n                   \\<Longrightarrow> closed j p;\n        closed i (Exists p); i \\<le> j\\<rbrakk>\n       \\<Longrightarrow> closed j (Exists p)", "then"], ["proof (chain)\npicking this:\n  closed i (Pred ia__ l)\n  i \\<le> j", "show ?case"], ["proof (prove)\nusing this:\n  closed i (Pred ia__ l)\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. closed j (Pred ia__ l)", "using closedt_mono"], ["proof (prove)\nusing this:\n  closed i (Pred ia__ l)\n  i \\<le> j\n  \\<lbrakk>?i \\<le> ?j; closedt ?i ?t\\<rbrakk>\n  \\<Longrightarrow> closedt ?j ?t\n  \\<lbrakk>?i \\<le> ?j; closedts ?i ?ts\\<rbrakk>\n  \\<Longrightarrow> closedts ?j ?ts\n\ngoal (1 subgoal):\n 1. closed j (Pred ia__ l)", "by simp"], ["proof (state)\nthis:\n  closed j (Pred ia__ l)\n\ngoal (8 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>closed i FF; i \\<le> j\\<rbrakk>\n       \\<Longrightarrow> closed j FF\n 2. \\<And>i j.\n       \\<lbrakk>closed i TT; i \\<le> j\\<rbrakk>\n       \\<Longrightarrow> closed j TT\n 3. \\<And>p1 p2 i j.\n       \\<lbrakk>\\<And>i j.\n                   \\<lbrakk>closed i p1; i \\<le> j\\<rbrakk>\n                   \\<Longrightarrow> closed j p1;\n        \\<And>i j.\n           \\<lbrakk>closed i p2; i \\<le> j\\<rbrakk>\n           \\<Longrightarrow> closed j p2;\n        closed i (And p1 p2); i \\<le> j\\<rbrakk>\n       \\<Longrightarrow> closed j (And p1 p2)\n 4. \\<And>p1 p2 i j.\n       \\<lbrakk>\\<And>i j.\n                   \\<lbrakk>closed i p1; i \\<le> j\\<rbrakk>\n                   \\<Longrightarrow> closed j p1;\n        \\<And>i j.\n           \\<lbrakk>closed i p2; i \\<le> j\\<rbrakk>\n           \\<Longrightarrow> closed j p2;\n        closed i (Or p1 p2); i \\<le> j\\<rbrakk>\n       \\<Longrightarrow> closed j (Or p1 p2)\n 5. \\<And>p1 p2 i j.\n       \\<lbrakk>\\<And>i j.\n                   \\<lbrakk>closed i p1; i \\<le> j\\<rbrakk>\n                   \\<Longrightarrow> closed j p1;\n        \\<And>i j.\n           \\<lbrakk>closed i p2; i \\<le> j\\<rbrakk>\n           \\<Longrightarrow> closed j p2;\n        closed i (Impl p1 p2); i \\<le> j\\<rbrakk>\n       \\<Longrightarrow> closed j (Impl p1 p2)\n 6. \\<And>p i j.\n       \\<lbrakk>\\<And>i j.\n                   \\<lbrakk>closed i p; i \\<le> j\\<rbrakk>\n                   \\<Longrightarrow> closed j p;\n        closed i (Neg p); i \\<le> j\\<rbrakk>\n       \\<Longrightarrow> closed j (Neg p)\n 7. \\<And>p i j.\n       \\<lbrakk>\\<And>i j.\n                   \\<lbrakk>closed i p; i \\<le> j\\<rbrakk>\n                   \\<Longrightarrow> closed j p;\n        closed i (Forall p); i \\<le> j\\<rbrakk>\n       \\<Longrightarrow> closed j (Forall p)\n 8. \\<And>p i j.\n       \\<lbrakk>\\<And>i j.\n                   \\<lbrakk>closed i p; i \\<le> j\\<rbrakk>\n                   \\<Longrightarrow> closed j p;\n        closed i (Exists p); i \\<le> j\\<rbrakk>\n       \\<Longrightarrow> closed j (Exists p)", "qed auto"], ["", "subsection \\<open>Substitution\\<close>"], ["", "text \\<open>\nWe now define substitution functions for terms and formulae. When performing\nsubstitutions under quantifiers, we need to {\\em lift} the terms to be substituted\nfor variables, in order for the ``loose'' bound variables to point to the right\nposition.\n\\<close>"], ["", "primrec\n  substt :: \\<open>'a term \\<Rightarrow> 'a term \\<Rightarrow> nat \\<Rightarrow> 'a term\\<close> (\"_[_'/_]\" [300, 0, 0] 300) and\n  substts :: \\<open>'a term list \\<Rightarrow> 'a term \\<Rightarrow> nat \\<Rightarrow> 'a term list\\<close> (\"_[_'/_]\" [300, 0, 0] 300) where\n  \\<open>(Var i)[s/k] = (if k < i then Var (i - 1) else if i = k then s else Var i)\\<close>\n| \\<open>(App a ts)[s/k] = App a (ts[s/k])\\<close>\n| \\<open>[][s/k] = []\\<close>\n| \\<open>(t # ts)[s/k] = t[s/k] # ts[s/k]\\<close>"], ["", "primrec\n  liftt :: \\<open>'a term \\<Rightarrow> 'a term\\<close> and\n  liftts :: \\<open>'a term list \\<Rightarrow> 'a term list\\<close> where\n  \\<open>liftt (Var i) = Var (Suc i)\\<close>\n| \\<open>liftt (App a ts) = App a (liftts ts)\\<close>\n| \\<open>liftts [] = []\\<close>\n| \\<open>liftts (t # ts) = liftt t # liftts ts\\<close>"], ["", "primrec subst :: \\<open>('a, 'b) form \\<Rightarrow> 'a term \\<Rightarrow> nat \\<Rightarrow> ('a, 'b) form\\<close>\n  (\"_[_'/_]\" [300, 0, 0] 300) where\n  \\<open>FF[s/k] = FF\\<close>\n| \\<open>TT[s/k] = TT\\<close>\n| \\<open>(Pred b ts)[s/k] = Pred b (ts[s/k])\\<close>\n| \\<open>(And p q)[s/k] = And (p[s/k]) (q[s/k])\\<close>\n| \\<open>(Or p q)[s/k] = Or (p[s/k]) (q[s/k])\\<close>\n| \\<open>(Impl p q)[s/k] = Impl (p[s/k]) (q[s/k])\\<close>\n| \\<open>(Neg p)[s/k] = Neg (p[s/k])\\<close>\n| \\<open>(Forall p)[s/k] = Forall (p[liftt s/Suc k])\\<close>\n| \\<open>(Exists p)[s/k] = Exists (p[liftt s/Suc k])\\<close>"], ["", "theorem lift_closed [simp]:\n  \\<open>closedt 0 (t::'a term) \\<Longrightarrow> closedt 0 (liftt t)\\<close>\n  \\<open>closedts 0 (ts::'a term list) \\<Longrightarrow> closedts 0 (liftts ts)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (closedt 0 t \\<Longrightarrow> closedt 0 (liftt t)) &&&\n    (closedts 0 ts \\<Longrightarrow> closedts 0 (liftts ts))", "by (induct t and ts rule: closedt.induct closedts.induct) simp_all"], ["", "theorem subst_closedt [simp]:\n  assumes u: \\<open>closedt 0 u\\<close>\n  shows \\<open>closedt (Suc i) t \\<Longrightarrow> closedt i (t[u/i])\\<close>\n    and \\<open>closedts (Suc i) ts \\<Longrightarrow> closedts i (ts[u/i])\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (closedt (Suc i) t \\<Longrightarrow> closedt i (t[u/i])) &&&\n    (closedts (Suc i) ts \\<Longrightarrow> closedts i (ts[u/i]))", "using u closedt_mono(1)"], ["proof (prove)\nusing this:\n  closedt 0 u\n  \\<lbrakk>?i \\<le> ?j; closedt ?i ?t\\<rbrakk>\n  \\<Longrightarrow> closedt ?j ?t\n\ngoal (1 subgoal):\n 1. (closedt (Suc i) t \\<Longrightarrow> closedt i (t[u/i])) &&&\n    (closedts (Suc i) ts \\<Longrightarrow> closedts i (ts[u/i]))", "by (induct t and ts rule: closedt.induct closedts.induct) auto"], ["", "theorem subst_closed [simp]:\n  \\<open>closedt 0 t \\<Longrightarrow> closed (Suc i) p \\<Longrightarrow> closed i (p[t/i])\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>closedt 0 t; closed (Suc i) p\\<rbrakk>\n    \\<Longrightarrow> closed i (p[t/i])", "by (induct p arbitrary: i t) simp_all"], ["", "theorem subst_size_form [simp]: \\<open>size_form (subst p t i) = size_form p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. FOL_Fitting.size_form (p[t/i]) = FOL_Fitting.size_form p", "by (induct p arbitrary: i t) simp_all"], ["", "subsection \\<open>Parameters\\<close>"], ["", "text \\<open>\nThe introduction rule \\<open>ForallI\\<close> for the universal quantifier,\nas well as the elimination rule \\<open>ExistsE\\<close> for the existential\nquantifier introduced in \\secref{sec:proof-calculus} require the\nquantified variable to be replaced by a ``fresh'' parameter. Fitting's\nsolution is to use a new nullary function symbol for this purpose.\nTo express that a function symbol is ``fresh'', we introduce functions\nfor collecting all function symbols occurring in a term or formula.\n\\<close>"], ["", "primrec\n  paramst :: \\<open>'a term \\<Rightarrow> 'a set\\<close> and\n  paramsts :: \\<open>'a term list \\<Rightarrow> 'a set\\<close> where\n  \\<open>paramst (Var n) = {}\\<close>\n| \\<open>paramst (App a ts) = {a} \\<union> paramsts ts\\<close>\n| \\<open>paramsts [] = {}\\<close>\n| \\<open>paramsts (t # ts) = (paramst t \\<union> paramsts ts)\\<close>"], ["", "primrec params :: \\<open>('a, 'b) form \\<Rightarrow> 'a set\\<close> where\n  \\<open>params FF = {}\\<close>\n| \\<open>params TT = {}\\<close>\n| \\<open>params (Pred b ts) = paramsts ts\\<close>\n| \\<open>params (And p q) = params p \\<union> params q\\<close>\n| \\<open>params (Or p q) = params p \\<union> params q\\<close>\n| \\<open>params (Impl p q) = params p \\<union> params q\\<close>\n| \\<open>params (Neg p) = params p\\<close>\n| \\<open>params (Forall p) = params p\\<close>\n| \\<open>params (Exists p) = params p\\<close>"], ["", "text\\<open>\nWe also define parameter substitution functions on terms and formulae\nthat apply a function \\<open>f\\<close> to all function symbols.\n\\<close>"], ["", "primrec\n  psubstt :: \\<open>('a \\<Rightarrow> 'c) \\<Rightarrow> 'a term \\<Rightarrow> 'c term\\<close> and\n  psubstts :: \\<open>('a \\<Rightarrow> 'c) \\<Rightarrow> 'a term list \\<Rightarrow> 'c term list\\<close> where\n  \\<open>psubstt f (Var i) = Var i\\<close>\n| \\<open>psubstt f (App x ts) = App (f x) (psubstts f ts)\\<close>\n| \\<open>psubstts f [] = []\\<close>\n| \\<open>psubstts f (t # ts) = psubstt f t # psubstts f ts\\<close>"], ["", "primrec psubst :: \\<open>('a \\<Rightarrow> 'c) \\<Rightarrow> ('a, 'b) form \\<Rightarrow> ('c, 'b) form\\<close> where\n  \\<open>psubst f FF = FF\\<close>\n| \\<open>psubst f TT = TT\\<close>\n| \\<open>psubst f (Pred b ts) = Pred b (psubstts f ts)\\<close>\n| \\<open>psubst f (And p q) = And (psubst f p) (psubst f q)\\<close>\n| \\<open>psubst f (Or p q) = Or (psubst f p) (psubst f q)\\<close>\n| \\<open>psubst f (Impl p q) = Impl (psubst f p) (psubst f q)\\<close>\n| \\<open>psubst f (Neg p) = Neg (psubst f p)\\<close>\n| \\<open>psubst f (Forall p) = Forall (psubst f p)\\<close>\n| \\<open>psubst f (Exists p) = Exists (psubst f p)\\<close>"], ["", "theorem psubstt_closed [simp]:\n  \\<open>closedt i (psubstt f t) = closedt i t\\<close>\n  \\<open>closedts i (psubstts f ts) = closedts i ts\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. closedt i (psubstt f t) = closedt i t &&&\n    closedts i (psubstts f ts) = closedts i ts", "by (induct t and ts rule: closedt.induct closedts.induct) simp_all"], ["", "theorem psubst_closed [simp]:\n  \\<open>closed i (psubst f p) = closed i p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed i (psubst f p) = closed i p", "by (induct p arbitrary: i) simp_all"], ["", "theorem psubstt_subst [simp]:\n  \\<open>psubstt f (substt t u i) = substt (psubstt f t) (psubstt f u) i\\<close>\n  \\<open>psubstts f (substts ts u i) = substts (psubstts f ts) (psubstt f u) i\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. psubstt f (t[u/i]) = psubstt f t[psubstt f u/i] &&&\n    psubstts f (ts[u/i]) = psubstts f ts[psubstt f u/i]", "by (induct t and ts rule: psubstt.induct psubstts.induct) simp_all"], ["", "theorem psubstt_lift [simp]:\n  \\<open>psubstt f (liftt t) = liftt (psubstt f t)\\<close>\n  \\<open>psubstts f (liftts ts) = liftts (psubstts f ts)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. psubstt f (liftt t) = liftt (psubstt f t) &&&\n    psubstts f (liftts ts) = liftts (psubstts f ts)", "by (induct t and ts rule: psubstt.induct psubstts.induct) simp_all"], ["", "theorem psubst_subst [simp]:\n  \\<open>psubst f (subst P t i) = subst (psubst f P) (psubstt f t) i\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. psubst f (P[t/i]) = psubst f P[psubstt f t/i]", "by (induct P arbitrary: i t) simp_all"], ["", "theorem psubstt_upd [simp]:\n  \\<open>x \\<notin> paramst (t::'a term) \\<Longrightarrow> psubstt (f(x := y)) t = psubstt f t\\<close>\n  \\<open>x \\<notin> paramsts (ts::'a term list) \\<Longrightarrow> psubstts (f(x := y)) ts = psubstts f ts\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<notin> paramst t \\<Longrightarrow>\n     psubstt (f(x := y)) t = psubstt f t) &&&\n    (x \\<notin> paramsts ts \\<Longrightarrow>\n     psubstts (f(x := y)) ts = psubstts f ts)", "by (induct t and ts rule: psubstt.induct psubstts.induct) (auto split: sum.split)"], ["", "theorem psubst_upd [simp]: \\<open>x \\<notin> params P \\<Longrightarrow> psubst (f(x := y)) P = psubst f P\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> params P \\<Longrightarrow> psubst (f(x := y)) P = psubst f P", "by (induct P) (simp_all del: fun_upd_apply)"], ["", "theorem psubstt_id:\n  fixes t :: \\<open>'a term\\<close> and ts :: \\<open>'a term list\\<close>\n  shows \\<open>psubstt id t = t\\<close> and \\<open>psubstts (\\<lambda>x. x) ts = ts\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. psubstt id t = t &&& psubstts (\\<lambda>x. x) ts = ts", "by (induct t and ts rule: psubstt.induct psubstts.induct) simp_all"], ["", "theorem psubst_id [simp]: \\<open>psubst id = id\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. psubst id = id", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. psubst id x = id x", "fix p :: \\<open>('a, 'b) form\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. psubst id x = id x", "show \\<open>psubst id p = id p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. psubst id p = id p", "by (induct p) (simp_all add: psubstt_id)"], ["proof (state)\nthis:\n  psubst id p = id p\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem psubstt_image [simp]:\n  \\<open>paramst (psubstt f t) = f ` paramst t\\<close>\n  \\<open>paramsts (psubstts f ts) = f ` paramsts ts\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. paramst (psubstt f t) = f ` paramst t &&&\n    paramsts (psubstts f ts) = f ` paramsts ts", "by (induct t and ts rule: paramst.induct paramsts.induct) (simp_all add: image_Un)"], ["", "theorem psubst_image [simp]: \\<open>params (psubst f p) = f ` params p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. params (psubst f p) = f ` params p", "by (induct p) (simp_all add: image_Un)"], ["", "section \\<open>Semantics\\<close>"], ["", "text \\<open>\n\\label{sec:semantics}\nIn this section, we define evaluation functions for terms and formulae.\nEvaluation is performed relative to an environment mapping indices of variables\nto values. We also introduce a function, denoted by \\<open>e\\<langle>i:a\\<rangle>\\<close>, for inserting\na value \\<open>a\\<close> at position \\<open>i\\<close> into the environment. All values of variables\nwith indices less than \\<open>i\\<close> are left untouched by this operation, whereas the\nvalues of variables with indices greater or equal than \\<open>i\\<close> are shifted one\nposition up.\n\\<close>"], ["", "definition shift :: \\<open>(nat \\<Rightarrow> 'a) \\<Rightarrow> nat \\<Rightarrow> 'a \\<Rightarrow> nat \\<Rightarrow> 'a\\<close> (\"_\\<langle>_:_\\<rangle>\" [90, 0, 0] 91) where\n  \\<open>e\\<langle>i:a\\<rangle> = (\\<lambda>j. if j < i then e j else if j = i then a else e (j - 1))\\<close>"], ["", "lemma shift_eq [simp]: \\<open>i = j \\<Longrightarrow> (e\\<langle>i:T\\<rangle>) j = T\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. i = j \\<Longrightarrow> (e\\<langle>i:T\\<rangle>) j = T", "by (simp add: shift_def)"], ["", "lemma shift_gt [simp]: \\<open>j < i \\<Longrightarrow> (e\\<langle>i:T\\<rangle>) j = e j\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. j < i \\<Longrightarrow> (e\\<langle>i:T\\<rangle>) j = e j", "by (simp add: shift_def)"], ["", "lemma shift_lt [simp]: \\<open>i < j \\<Longrightarrow> (e\\<langle>i:T\\<rangle>) j = e (j - 1)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < j \\<Longrightarrow> (e\\<langle>i:T\\<rangle>) j = e (j - 1)", "by (simp add: shift_def)"], ["", "lemma shift_commute [simp]: \\<open>e\\<langle>i:U\\<rangle>\\<langle>0:T\\<rangle> = e\\<langle>0:T\\<rangle>\\<langle>Suc i:U\\<rangle>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. e\\<langle>i:U\\<rangle>\\<langle>0:T\\<rangle> =\n    e\\<langle>0:T\\<rangle>\\<langle>Suc i:U\\<rangle>", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (e\\<langle>i:U\\<rangle>\\<langle>0:T\\<rangle>) x =\n       (e\\<langle>0:T\\<rangle>\\<langle>Suc i:U\\<rangle>) x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (e\\<langle>i:U\\<rangle>\\<langle>0:T\\<rangle>) x =\n       (e\\<langle>0:T\\<rangle>\\<langle>Suc i:U\\<rangle>) x", "show \\<open>(e\\<langle>i:U\\<rangle>\\<langle>0:T\\<rangle>) x = (e\\<langle>0:T\\<rangle>\\<langle>Suc i:U\\<rangle>) x\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (e\\<langle>i:U\\<rangle>\\<langle>0:T\\<rangle>) x =\n    (e\\<langle>0:T\\<rangle>\\<langle>Suc i:U\\<rangle>) x", "by (cases x) (simp_all add: shift_def)"], ["proof (state)\nthis:\n  (e\\<langle>i:U\\<rangle>\\<langle>0:T\\<rangle>) x =\n  (e\\<langle>0:T\\<rangle>\\<langle>Suc i:U\\<rangle>) x\n\ngoal:\nNo subgoals!", "qed"], ["", "primrec\n  evalt :: \\<open>(nat \\<Rightarrow> 'c) \\<Rightarrow> ('a \\<Rightarrow> 'c list \\<Rightarrow> 'c) \\<Rightarrow> 'a term \\<Rightarrow> 'c\\<close> and\n  evalts :: \\<open>(nat \\<Rightarrow> 'c) \\<Rightarrow> ('a \\<Rightarrow> 'c list \\<Rightarrow> 'c) \\<Rightarrow> 'a term list \\<Rightarrow> 'c list\\<close> where\n  \\<open>evalt e f (Var n) = e n\\<close>\n| \\<open>evalt e f (App a ts) = f a (evalts e f ts)\\<close>\n| \\<open>evalts e f [] = []\\<close>\n| \\<open>evalts e f (t # ts) = evalt e f t # evalts e f ts\\<close>"], ["", "primrec eval :: \\<open>(nat \\<Rightarrow> 'c) \\<Rightarrow> ('a \\<Rightarrow> 'c list \\<Rightarrow> 'c) \\<Rightarrow>\n  ('b \\<Rightarrow> 'c list \\<Rightarrow> bool) \\<Rightarrow> ('a, 'b) form \\<Rightarrow> bool\\<close> where\n  \\<open>eval e f g FF = False\\<close>\n| \\<open>eval e f g TT = True\\<close>\n| \\<open>eval e f g (Pred a ts) = g a (evalts e f ts)\\<close>\n| \\<open>eval e f g (And p q) = ((eval e f g p) \\<and> (eval e f g q))\\<close>\n| \\<open>eval e f g (Or p q) = ((eval e f g p) \\<or> (eval e f g q))\\<close>\n| \\<open>eval e f g (Impl p q) = ((eval e f g p) \\<longrightarrow> (eval e f g q))\\<close>\n| \\<open>eval e f g (Neg p) = (\\<not> (eval e f g p))\\<close>\n| \\<open>eval e f g (Forall p) = (\\<forall>z. eval (e\\<langle>0:z\\<rangle>) f g p)\\<close>\n| \\<open>eval e f g (Exists p) = (\\<exists>z. eval (e\\<langle>0:z\\<rangle>) f g p)\\<close>"], ["", "text \\<open>\nWe write \\<open>e,f,g,ps \\<Turnstile> p\\<close> to mean that the formula \\<open>p\\<close> is a\nsemantic consequence of the list of formulae \\<open>ps\\<close> with respect to an\nenvironment \\<open>e\\<close> and interpretations \\<open>f\\<close> and \\<open>g\\<close> for\nfunction and predicate symbols, respectively.\n\\<close>"], ["", "definition model :: \\<open>(nat \\<Rightarrow> 'c) \\<Rightarrow> ('a \\<Rightarrow> 'c list \\<Rightarrow> 'c) \\<Rightarrow> ('b \\<Rightarrow> 'c list \\<Rightarrow> bool) \\<Rightarrow>\n    ('a, 'b) form list \\<Rightarrow> ('a, 'b) form \\<Rightarrow> bool\\<close> (\"_,_,_,_ \\<Turnstile> _\" [50,50] 50) where\n  \\<open>(e,f,g,ps \\<Turnstile> p) = (list_all (eval e f g) ps \\<longrightarrow> eval e f g p)\\<close>"], ["", "text \\<open>\nThe following substitution lemmas relate substitution and evaluation functions:\n\\<close>"], ["", "theorem subst_lemma' [simp]:\n  \\<open>evalt e f (substt t u i) = evalt (e\\<langle>i:evalt e f u\\<rangle>) f t\\<close>\n  \\<open>evalts e f (substts ts u i) = evalts (e\\<langle>i:evalt e f u\\<rangle>) f ts\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. evalt e f (t[u/i]) = evalt (e\\<langle>i:evalt e f u\\<rangle>) f t &&&\n    evalts e f (ts[u/i]) = evalts (e\\<langle>i:evalt e f u\\<rangle>) f ts", "by (induct t and ts rule: substt.induct substts.induct) simp_all"], ["", "theorem lift_lemma [simp]:\n  \\<open>evalt (e\\<langle>0:z\\<rangle>) f (liftt t) = evalt e f t\\<close>\n  \\<open>evalts (e\\<langle>0:z\\<rangle>) f (liftts ts) = evalts e f ts\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. evalt (e\\<langle>0:z\\<rangle>) f (liftt t) = evalt e f t &&&\n    evalts (e\\<langle>0:z\\<rangle>) f (liftts ts) = evalts e f ts", "by (induct t and ts rule: liftt.induct liftts.induct) simp_all"], ["", "theorem subst_lemma [simp]:\n  \\<open>eval e f g (subst a t i) = eval (e\\<langle>i:evalt e f t\\<rangle>) f g a\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval e f g (a[t/i]) = eval (e\\<langle>i:evalt e f t\\<rangle>) f g a", "by (induct a arbitrary: e i t) simp_all"], ["", "theorem upd_lemma' [simp]:\n  \\<open>n \\<notin> paramst t \\<Longrightarrow> evalt e (f(n := x)) t = evalt e f t\\<close>\n  \\<open>n \\<notin> paramsts ts \\<Longrightarrow> evalts e (f(n := x)) ts = evalts e f ts\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (n \\<notin> paramst t \\<Longrightarrow>\n     evalt e (f(n := x)) t = evalt e f t) &&&\n    (n \\<notin> paramsts ts \\<Longrightarrow>\n     evalts e (f(n := x)) ts = evalts e f ts)", "by (induct t and ts rule: paramst.induct paramsts.induct) auto"], ["", "theorem upd_lemma [simp]:\n  \\<open>n \\<notin> params p \\<Longrightarrow> eval e (f(n := x)) g p = eval e f g p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<notin> params p \\<Longrightarrow>\n    eval e (f(n := x)) g p = eval e f g p", "by (induct p arbitrary: e) simp_all"], ["", "theorem list_upd_lemma [simp]: \\<open>list_all (\\<lambda>p. n \\<notin> params p) G \\<Longrightarrow>\n  list_all (eval e (f(n := x)) g) G = list_all (eval e f g) G\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>p. n \\<notin> params p) G \\<Longrightarrow>\n    list_all (eval e (f(n := x)) g) G = list_all (eval e f g) G", "by (induct G) simp_all"], ["", "theorem psubst_eval' [simp]:\n  \\<open>evalt e f (psubstt h t) = evalt e (\\<lambda>p. f (h p)) t\\<close>\n  \\<open>evalts e f (psubstts h ts) = evalts e (\\<lambda>p. f (h p)) ts\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. evalt e f (psubstt h t) = evalt e (\\<lambda>p. f (h p)) t &&&\n    evalts e f (psubstts h ts) = evalts e (\\<lambda>p. f (h p)) ts", "by (induct t and ts rule: psubstt.induct psubstts.induct) simp_all"], ["", "theorem psubst_eval:\n  \\<open>eval e f g (psubst h p) = eval e (\\<lambda>p. f (h p)) g p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval e f g (psubst h p) = eval e (\\<lambda>p. f (h p)) g p", "by (induct p arbitrary: e) simp_all"], ["", "text \\<open>\nIn order to test the evaluation function defined above, we apply it\nto an example:\n\\<close>"], ["", "theorem ex_all_commute_eval:\n  \\<open>eval e f g (Impl (Exists (Forall (Pred p [Var 1, Var 0])))\n    (Forall (Exists (Pred p [Var 0, Var 1]))))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval e f g\n     (Impl (Exists (Forall (Pred p [Var 1, Var 0])))\n       (Forall (Exists (Pred p [Var 0, Var 1]))))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>z. \\<forall>za. g p [z, za]) \\<longrightarrow>\n    (\\<forall>z. \\<exists>za. g p [za, z])", "txt \\<open>\nSimplification yields the following proof state:\n@{subgoals [display]}\nThis is easily proved using intuitionistic logic:\n\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>z. \\<forall>za. g p [z, za]) \\<longrightarrow>\n    (\\<forall>z. \\<exists>za. g p [za, z])", "by iprover"], ["", "section \\<open>Proof calculus\\<close>"], ["", "text \\<open>\n\\label{sec:proof-calculus}\nWe now introduce a natural deduction proof calculus for first order logic.\nThe derivability judgement \\<open>G \\<turnstile> a\\<close> is defined as an inductive predicate.\n\\<close>"], ["", "inductive deriv :: \\<open>('a, 'b) form list \\<Rightarrow> ('a, 'b) form \\<Rightarrow> bool\\<close> (\"_ \\<turnstile> _\" [50,50] 50) where\n  Assum: \\<open>a \\<in> set G \\<Longrightarrow> G \\<turnstile> a\\<close>\n| TTI: \\<open>G \\<turnstile> TT\\<close>\n| FFE: \\<open>G \\<turnstile> FF \\<Longrightarrow> G \\<turnstile> a\\<close>\n| NegI: \\<open>a # G \\<turnstile> FF \\<Longrightarrow> G \\<turnstile> Neg a\\<close>\n| NegE: \\<open>G \\<turnstile> Neg a \\<Longrightarrow> G \\<turnstile> a \\<Longrightarrow> G \\<turnstile> FF\\<close>\n| Class: \\<open>Neg a # G \\<turnstile> FF \\<Longrightarrow> G \\<turnstile> a\\<close>\n| AndI: \\<open>G \\<turnstile> a \\<Longrightarrow> G \\<turnstile> b \\<Longrightarrow> G \\<turnstile> And a b\\<close>\n| AndE1: \\<open>G \\<turnstile> And a b \\<Longrightarrow> G \\<turnstile> a\\<close>\n| AndE2: \\<open>G \\<turnstile> And a b \\<Longrightarrow> G \\<turnstile> b\\<close>\n| OrI1: \\<open>G \\<turnstile> a \\<Longrightarrow> G \\<turnstile> Or a b\\<close>\n| OrI2: \\<open>G \\<turnstile> b \\<Longrightarrow> G \\<turnstile> Or a b\\<close>\n| OrE: \\<open>G \\<turnstile> Or a b \\<Longrightarrow> a # G \\<turnstile> c \\<Longrightarrow> b # G \\<turnstile> c \\<Longrightarrow> G \\<turnstile> c\\<close>\n| ImplI: \\<open>a # G \\<turnstile> b \\<Longrightarrow> G \\<turnstile> Impl a b\\<close>\n| ImplE: \\<open>G \\<turnstile> Impl a b \\<Longrightarrow> G \\<turnstile> a \\<Longrightarrow> G \\<turnstile> b\\<close>\n| ForallI: \\<open>G \\<turnstile> a[App n []/0] \\<Longrightarrow> list_all (\\<lambda>p. n \\<notin> params p) G \\<Longrightarrow>\n    n \\<notin> params a \\<Longrightarrow> G \\<turnstile> Forall a\\<close>\n| ForallE: \\<open>G \\<turnstile> Forall a \\<Longrightarrow> G \\<turnstile> a[t/0]\\<close>\n| ExistsI: \\<open>G \\<turnstile> a[t/0] \\<Longrightarrow> G \\<turnstile> Exists a\\<close>\n| ExistsE: \\<open>G \\<turnstile> Exists a \\<Longrightarrow> a[App n []/0] # G \\<turnstile> b \\<Longrightarrow>\n    list_all (\\<lambda>p. n \\<notin> params p) G \\<Longrightarrow> n \\<notin> params a \\<Longrightarrow> n \\<notin> params b \\<Longrightarrow> G \\<turnstile> b\\<close>"], ["", "text \\<open>\nThe following derived inference rules are sometimes useful in applications.\n\\<close>"], ["", "theorem Class': \\<open>Neg A # G \\<turnstile> A \\<Longrightarrow> G \\<turnstile> A\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Neg A # G \\<turnstile> A \\<Longrightarrow> G \\<turnstile> A", "by (rule Class, rule NegE, rule Assum) (simp, iprover)"], ["", "theorem cut: \\<open>G \\<turnstile> A \\<Longrightarrow> A # G \\<turnstile> B \\<Longrightarrow> G \\<turnstile> B\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>G \\<turnstile> A; A # G \\<turnstile> B\\<rbrakk>\n    \\<Longrightarrow> G \\<turnstile> B", "by (rule ImplE, rule ImplI)"], ["", "theorem ForallE': \\<open>G \\<turnstile> Forall a \\<Longrightarrow> subst a t 0 # G \\<turnstile> B \\<Longrightarrow> G \\<turnstile> B\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>G \\<turnstile> Forall a; a[t/0] # G \\<turnstile> B\\<rbrakk>\n    \\<Longrightarrow> G \\<turnstile> B", "by (rule cut, rule ForallE)"], ["", "text \\<open>\nAs an example, we show that the excluded middle, a commutation property\nfor existential and universal quantifiers, the drinker principle, as well\nas Peirce's law are derivable in the calculus given above.\n\\<close>"], ["", "theorem tnd: \\<open>[] \\<turnstile> Or (Pred p []) (Neg (Pred p []))\\<close> (is \\<open>_ \\<turnstile> ?or\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<turnstile> Or (Pred p []) (Neg (Pred p []))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. [] \\<turnstile> Or (Pred p []) (Neg (Pred p []))", "have \\<open>[Neg ?or] \\<turnstile> Neg ?or\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. [Neg (Or (Pred p [])\n           (Neg (Pred p\n                  [])))] \\<turnstile> Neg (Or (Pred p []) (Neg (Pred p [])))", "by (simp add: Assum)"], ["proof (state)\nthis:\n  [Neg (Or (Pred p [])\n         (Neg (Pred p\n                [])))] \\<turnstile> Neg (Or (Pred p []) (Neg (Pred p [])))\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> Or (Pred p []) (Neg (Pred p []))", "moreover"], ["proof (state)\nthis:\n  [Neg (Or (Pred p [])\n         (Neg (Pred p\n                [])))] \\<turnstile> Neg (Or (Pred p []) (Neg (Pred p [])))\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> Or (Pred p []) (Neg (Pred p []))", "{"], ["proof (state)\nthis:\n  [Neg (Or (Pred p [])\n         (Neg (Pred p\n                [])))] \\<turnstile> Neg (Or (Pred p []) (Neg (Pred p [])))\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> Or (Pred p []) (Neg (Pred p []))", "have \\<open>[Pred p [], Neg ?or] \\<turnstile> Neg ?or\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. [Pred p [],\n     Neg (Or (Pred p [])\n           (Neg (Pred p\n                  [])))] \\<turnstile> Neg (Or (Pred p []) (Neg (Pred p [])))", "by (simp add: Assum)"], ["proof (state)\nthis:\n  [Pred p [],\n   Neg (Or (Pred p [])\n         (Neg (Pred p\n                [])))] \\<turnstile> Neg (Or (Pred p []) (Neg (Pred p [])))\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> Or (Pred p []) (Neg (Pred p []))", "moreover"], ["proof (state)\nthis:\n  [Pred p [],\n   Neg (Or (Pred p [])\n         (Neg (Pred p\n                [])))] \\<turnstile> Neg (Or (Pred p []) (Neg (Pred p [])))\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> Or (Pred p []) (Neg (Pred p []))", "have \\<open>[Pred p [], Neg ?or] \\<turnstile> Pred p []\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. [Pred p [],\n     Neg (Or (Pred p []) (Neg (Pred p [])))] \\<turnstile> Pred p []", "by (simp add: Assum)"], ["proof (state)\nthis:\n  [Pred p [], Neg (Or (Pred p []) (Neg (Pred p [])))] \\<turnstile> Pred p []\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> Or (Pred p []) (Neg (Pred p []))", "then"], ["proof (chain)\npicking this:\n  [Pred p [], Neg (Or (Pred p []) (Neg (Pred p [])))] \\<turnstile> Pred p []", "have \\<open>[Pred p [], Neg ?or] \\<turnstile> ?or\\<close>"], ["proof (prove)\nusing this:\n  [Pred p [], Neg (Or (Pred p []) (Neg (Pred p [])))] \\<turnstile> Pred p []\n\ngoal (1 subgoal):\n 1. [Pred p [],\n     Neg (Or (Pred p [])\n           (Neg (Pred p [])))] \\<turnstile> Or (Pred p []) (Neg (Pred p []))", "by (rule OrI1)"], ["proof (state)\nthis:\n  [Pred p [],\n   Neg (Or (Pred p [])\n         (Neg (Pred p [])))] \\<turnstile> Or (Pred p []) (Neg (Pred p []))\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> Or (Pred p []) (Neg (Pred p []))", "ultimately"], ["proof (chain)\npicking this:\n  [Pred p [],\n   Neg (Or (Pred p [])\n         (Neg (Pred p\n                [])))] \\<turnstile> Neg (Or (Pred p []) (Neg (Pred p [])))\n  [Pred p [],\n   Neg (Or (Pred p [])\n         (Neg (Pred p [])))] \\<turnstile> Or (Pred p []) (Neg (Pred p []))", "have \\<open>[Pred p [], Neg ?or] \\<turnstile> FF\\<close>"], ["proof (prove)\nusing this:\n  [Pred p [],\n   Neg (Or (Pred p [])\n         (Neg (Pred p\n                [])))] \\<turnstile> Neg (Or (Pred p []) (Neg (Pred p [])))\n  [Pred p [],\n   Neg (Or (Pred p [])\n         (Neg (Pred p [])))] \\<turnstile> Or (Pred p []) (Neg (Pred p []))\n\ngoal (1 subgoal):\n 1. [Pred p [], Neg (Or (Pred p []) (Neg (Pred p [])))] \\<turnstile> FF", "by (rule NegE)"], ["proof (state)\nthis:\n  [Pred p [], Neg (Or (Pred p []) (Neg (Pred p [])))] \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> Or (Pred p []) (Neg (Pred p []))", "then"], ["proof (chain)\npicking this:\n  [Pred p [], Neg (Or (Pred p []) (Neg (Pred p [])))] \\<turnstile> FF", "have \\<open>[Neg ?or] \\<turnstile> Neg (Pred p [])\\<close>"], ["proof (prove)\nusing this:\n  [Pred p [], Neg (Or (Pred p []) (Neg (Pred p [])))] \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. [Neg (Or (Pred p []) (Neg (Pred p [])))] \\<turnstile> Neg (Pred p [])", "by (rule NegI)"], ["proof (state)\nthis:\n  [Neg (Or (Pred p []) (Neg (Pred p [])))] \\<turnstile> Neg (Pred p [])\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> Or (Pred p []) (Neg (Pred p []))", "then"], ["proof (chain)\npicking this:\n  [Neg (Or (Pred p []) (Neg (Pred p [])))] \\<turnstile> Neg (Pred p [])", "have \\<open>[Neg ?or] \\<turnstile> ?or\\<close>"], ["proof (prove)\nusing this:\n  [Neg (Or (Pred p []) (Neg (Pred p [])))] \\<turnstile> Neg (Pred p [])\n\ngoal (1 subgoal):\n 1. [Neg (Or (Pred p [])\n           (Neg (Pred p [])))] \\<turnstile> Or (Pred p []) (Neg (Pred p []))", "by (rule OrI2)"], ["proof (state)\nthis:\n  [Neg (Or (Pred p [])\n         (Neg (Pred p [])))] \\<turnstile> Or (Pred p []) (Neg (Pred p []))\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> Or (Pred p []) (Neg (Pred p []))", "}"], ["proof (state)\nthis:\n  [Neg (Or (Pred p [])\n         (Neg (Pred p [])))] \\<turnstile> Or (Pred p []) (Neg (Pred p []))\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> Or (Pred p []) (Neg (Pred p []))", "ultimately"], ["proof (chain)\npicking this:\n  [Neg (Or (Pred p [])\n         (Neg (Pred p\n                [])))] \\<turnstile> Neg (Or (Pred p []) (Neg (Pred p [])))\n  [Neg (Or (Pred p [])\n         (Neg (Pred p [])))] \\<turnstile> Or (Pred p []) (Neg (Pred p []))", "have \\<open>[Neg ?or] \\<turnstile> FF\\<close>"], ["proof (prove)\nusing this:\n  [Neg (Or (Pred p [])\n         (Neg (Pred p\n                [])))] \\<turnstile> Neg (Or (Pred p []) (Neg (Pred p [])))\n  [Neg (Or (Pred p [])\n         (Neg (Pred p [])))] \\<turnstile> Or (Pred p []) (Neg (Pred p []))\n\ngoal (1 subgoal):\n 1. [Neg (Or (Pred p []) (Neg (Pred p [])))] \\<turnstile> FF", "by (rule NegE)"], ["proof (state)\nthis:\n  [Neg (Or (Pred p []) (Neg (Pred p [])))] \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> Or (Pred p []) (Neg (Pred p []))", "then"], ["proof (chain)\npicking this:\n  [Neg (Or (Pred p []) (Neg (Pred p [])))] \\<turnstile> FF", "show ?thesis"], ["proof (prove)\nusing this:\n  [Neg (Or (Pred p []) (Neg (Pred p [])))] \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> Or (Pred p []) (Neg (Pred p []))", "by (rule Class)"], ["proof (state)\nthis:\n  [] \\<turnstile> Or (Pred p []) (Neg (Pred p []))\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem ex_all_commute:\n  \\<open>([]::(nat, 'b) form list) \\<turnstile> Impl (Exists (Forall (Pred p [Var 1, Var 0])))\n     (Forall (Exists (Pred p [Var 0, Var 1])))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<turnstile> Impl (Exists (Forall (Pred p [Var 1, Var 0])))\n                     (Forall (Exists (Pred p [Var 0, Var 1])))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. [] \\<turnstile> Impl (Exists (Forall (Pred p [Var 1, Var 0])))\n                     (Forall (Exists (Pred p [Var 0, Var 1])))", "let ?forall = \\<open>Forall (Pred p [Var 1, Var 0]) :: (nat, 'b) form\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. [] \\<turnstile> Impl (Exists (Forall (Pred p [Var 1, Var 0])))\n                     (Forall (Exists (Pred p [Var 0, Var 1])))", "have \\<open>[Exists ?forall] \\<turnstile> Exists ?forall\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. [Exists\n      (Forall\n        (Pred p\n          [Var 1,\n           Var 0]))] \\<turnstile> Exists (Forall (Pred p [Var 1, Var 0]))", "by (simp add: Assum)"], ["proof (state)\nthis:\n  [Exists\n    (Forall\n      (Pred p\n        [Var 1,\n         Var 0]))] \\<turnstile> Exists (Forall (Pred p [Var 1, Var 0]))\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> Impl (Exists (Forall (Pred p [Var 1, Var 0])))\n                     (Forall (Exists (Pred p [Var 0, Var 1])))", "moreover"], ["proof (state)\nthis:\n  [Exists\n    (Forall\n      (Pred p\n        [Var 1,\n         Var 0]))] \\<turnstile> Exists (Forall (Pred p [Var 1, Var 0]))\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> Impl (Exists (Forall (Pred p [Var 1, Var 0])))\n                     (Forall (Exists (Pred p [Var 0, Var 1])))", "{"], ["proof (state)\nthis:\n  [Exists\n    (Forall\n      (Pred p\n        [Var 1,\n         Var 0]))] \\<turnstile> Exists (Forall (Pred p [Var 1, Var 0]))\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> Impl (Exists (Forall (Pred p [Var 1, Var 0])))\n                     (Forall (Exists (Pred p [Var 0, Var 1])))", "have \\<open>[?forall[App 1 []/0], Exists ?forall] \\<turnstile> Forall (Pred p [App 1 [], Var 0])\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. [Forall (Pred p [Var 1, Var 0])[App 1 []/0],\n     Exists\n      (Forall\n        (Pred p\n          [Var 1, Var 0]))] \\<turnstile> Forall (Pred p [App 1 [], Var 0])", "by (simp add: Assum)"], ["proof (state)\nthis:\n  [Forall (Pred p [Var 1, Var 0])[App 1 []/0],\n   Exists\n    (Forall\n      (Pred p\n        [Var 1, Var 0]))] \\<turnstile> Forall (Pred p [App 1 [], Var 0])\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> Impl (Exists (Forall (Pred p [Var 1, Var 0])))\n                     (Forall (Exists (Pred p [Var 0, Var 1])))", "moreover"], ["proof (state)\nthis:\n  [Forall (Pred p [Var 1, Var 0])[App 1 []/0],\n   Exists\n    (Forall\n      (Pred p\n        [Var 1, Var 0]))] \\<turnstile> Forall (Pred p [App 1 [], Var 0])\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> Impl (Exists (Forall (Pred p [Var 1, Var 0])))\n                     (Forall (Exists (Pred p [Var 0, Var 1])))", "have \\<open>[Pred p [App 1 [], Var 0][App 0 []/0], ?forall[App 1 []/0],\n      Exists ?forall] \\<turnstile> Pred p [Var 0, App 0 []][App 1 []/0]\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. [Pred p [App 1 [], Var 0][App 0 []/0],\n     Forall (Pred p [Var 1, Var 0])[App 1 []/0],\n     Exists\n      (Forall\n        (Pred p\n          [Var 1,\n           Var 0]))] \\<turnstile> Pred p [Var 0, App 0 []][App 1 []/0]", "by (simp add: Assum)"], ["proof (state)\nthis:\n  [Pred p [App 1 [], Var 0][App 0 []/0],\n   Forall (Pred p [Var 1, Var 0])[App 1 []/0],\n   Exists\n    (Forall\n      (Pred p\n        [Var 1, Var 0]))] \\<turnstile> Pred p [Var 0, App 0 []][App 1 []/0]\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> Impl (Exists (Forall (Pred p [Var 1, Var 0])))\n                     (Forall (Exists (Pred p [Var 0, Var 1])))", "ultimately"], ["proof (chain)\npicking this:\n  [Forall (Pred p [Var 1, Var 0])[App 1 []/0],\n   Exists\n    (Forall\n      (Pred p\n        [Var 1, Var 0]))] \\<turnstile> Forall (Pred p [App 1 [], Var 0])\n  [Pred p [App 1 [], Var 0][App 0 []/0],\n   Forall (Pred p [Var 1, Var 0])[App 1 []/0],\n   Exists\n    (Forall\n      (Pred p\n        [Var 1, Var 0]))] \\<turnstile> Pred p [Var 0, App 0 []][App 1 []/0]", "have \\<open>[?forall[App 1 []/0], Exists ?forall] \\<turnstile> (Pred p [Var 0, App 0 []])[App 1 []/0]\\<close>"], ["proof (prove)\nusing this:\n  [Forall (Pred p [Var 1, Var 0])[App 1 []/0],\n   Exists\n    (Forall\n      (Pred p\n        [Var 1, Var 0]))] \\<turnstile> Forall (Pred p [App 1 [], Var 0])\n  [Pred p [App 1 [], Var 0][App 0 []/0],\n   Forall (Pred p [Var 1, Var 0])[App 1 []/0],\n   Exists\n    (Forall\n      (Pred p\n        [Var 1, Var 0]))] \\<turnstile> Pred p [Var 0, App 0 []][App 1 []/0]\n\ngoal (1 subgoal):\n 1. [Forall (Pred p [Var 1, Var 0])[App 1 []/0],\n     Exists\n      (Forall\n        (Pred p\n          [Var 1,\n           Var 0]))] \\<turnstile> Pred p [Var 0, App 0 []][App 1 []/0]", "by (rule ForallE')"], ["proof (state)\nthis:\n  [Forall (Pred p [Var 1, Var 0])[App 1 []/0],\n   Exists\n    (Forall\n      (Pred p\n        [Var 1, Var 0]))] \\<turnstile> Pred p [Var 0, App 0 []][App 1 []/0]\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> Impl (Exists (Forall (Pred p [Var 1, Var 0])))\n                     (Forall (Exists (Pred p [Var 0, Var 1])))", "}"], ["proof (state)\nthis:\n  [Forall (Pred p [Var 1, Var 0])[App 1 []/0],\n   Exists\n    (Forall\n      (Pred p\n        [Var 1, Var 0]))] \\<turnstile> Pred p [Var 0, App 0 []][App 1 []/0]\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> Impl (Exists (Forall (Pred p [Var 1, Var 0])))\n                     (Forall (Exists (Pred p [Var 0, Var 1])))", "then"], ["proof (chain)\npicking this:\n  [Forall (Pred p [Var 1, Var 0])[App 1 []/0],\n   Exists\n    (Forall\n      (Pred p\n        [Var 1, Var 0]))] \\<turnstile> Pred p [Var 0, App 0 []][App 1 []/0]", "have \\<open>[?forall[App 1 []/0], Exists ?forall] \\<turnstile> Exists (Pred p [Var 0, App 0 []])\\<close>"], ["proof (prove)\nusing this:\n  [Forall (Pred p [Var 1, Var 0])[App 1 []/0],\n   Exists\n    (Forall\n      (Pred p\n        [Var 1, Var 0]))] \\<turnstile> Pred p [Var 0, App 0 []][App 1 []/0]\n\ngoal (1 subgoal):\n 1. [Forall (Pred p [Var 1, Var 0])[App 1 []/0],\n     Exists\n      (Forall\n        (Pred p\n          [Var 1, Var 0]))] \\<turnstile> Exists (Pred p [Var 0, App 0 []])", "by (rule ExistsI)"], ["proof (state)\nthis:\n  [Forall (Pred p [Var 1, Var 0])[App 1 []/0],\n   Exists\n    (Forall\n      (Pred p\n        [Var 1, Var 0]))] \\<turnstile> Exists (Pred p [Var 0, App 0 []])\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> Impl (Exists (Forall (Pred p [Var 1, Var 0])))\n                     (Forall (Exists (Pred p [Var 0, Var 1])))", "moreover"], ["proof (state)\nthis:\n  [Forall (Pred p [Var 1, Var 0])[App 1 []/0],\n   Exists\n    (Forall\n      (Pred p\n        [Var 1, Var 0]))] \\<turnstile> Exists (Pred p [Var 0, App 0 []])\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> Impl (Exists (Forall (Pred p [Var 1, Var 0])))\n                     (Forall (Exists (Pred p [Var 0, Var 1])))", "have \\<open>list_all (\\<lambda>p. 1 \\<notin> params p) [Exists ?forall]\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>p. 1 \\<notin> params p)\n     [Exists (Forall (Pred p [Var 1, Var 0]))]", "by simp"], ["proof (state)\nthis:\n  list_all (\\<lambda>p. 1 \\<notin> params p)\n   [Exists (Forall (Pred p [Var 1, Var 0]))]\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> Impl (Exists (Forall (Pred p [Var 1, Var 0])))\n                     (Forall (Exists (Pred p [Var 0, Var 1])))", "moreover"], ["proof (state)\nthis:\n  list_all (\\<lambda>p. 1 \\<notin> params p)\n   [Exists (Forall (Pred p [Var 1, Var 0]))]\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> Impl (Exists (Forall (Pred p [Var 1, Var 0])))\n                     (Forall (Exists (Pred p [Var 0, Var 1])))", "have \\<open>1 \\<notin> params ?forall\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<notin> params (Forall (Pred p [Var 1, Var 0]))", "by simp"], ["proof (state)\nthis:\n  1 \\<notin> params (Forall (Pred p [Var 1, Var 0]))\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> Impl (Exists (Forall (Pred p [Var 1, Var 0])))\n                     (Forall (Exists (Pred p [Var 0, Var 1])))", "moreover"], ["proof (state)\nthis:\n  1 \\<notin> params (Forall (Pred p [Var 1, Var 0]))\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> Impl (Exists (Forall (Pred p [Var 1, Var 0])))\n                     (Forall (Exists (Pred p [Var 0, Var 1])))", "have \\<open>1 \\<notin> params (Exists (Pred p [Var 0, App (0 :: nat) []]))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<notin> params (Exists (Pred p [Var 0, App 0 []]))", "by simp"], ["proof (state)\nthis:\n  1 \\<notin> params (Exists (Pred p [Var 0, App 0 []]))\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> Impl (Exists (Forall (Pred p [Var 1, Var 0])))\n                     (Forall (Exists (Pred p [Var 0, Var 1])))", "ultimately"], ["proof (chain)\npicking this:\n  [Exists\n    (Forall\n      (Pred p\n        [Var 1,\n         Var 0]))] \\<turnstile> Exists (Forall (Pred p [Var 1, Var 0]))\n  [Forall (Pred p [Var 1, Var 0])[App 1 []/0],\n   Exists\n    (Forall\n      (Pred p\n        [Var 1, Var 0]))] \\<turnstile> Exists (Pred p [Var 0, App 0 []])\n  list_all (\\<lambda>p. 1 \\<notin> params p)\n   [Exists (Forall (Pred p [Var 1, Var 0]))]\n  1 \\<notin> params (Forall (Pred p [Var 1, Var 0]))\n  1 \\<notin> params (Exists (Pred p [Var 0, App 0 []]))", "have \\<open>[Exists ?forall] \\<turnstile> Exists (Pred p [Var 0, App 0 []])\\<close>"], ["proof (prove)\nusing this:\n  [Exists\n    (Forall\n      (Pred p\n        [Var 1,\n         Var 0]))] \\<turnstile> Exists (Forall (Pred p [Var 1, Var 0]))\n  [Forall (Pred p [Var 1, Var 0])[App 1 []/0],\n   Exists\n    (Forall\n      (Pred p\n        [Var 1, Var 0]))] \\<turnstile> Exists (Pred p [Var 0, App 0 []])\n  list_all (\\<lambda>p. 1 \\<notin> params p)\n   [Exists (Forall (Pred p [Var 1, Var 0]))]\n  1 \\<notin> params (Forall (Pred p [Var 1, Var 0]))\n  1 \\<notin> params (Exists (Pred p [Var 0, App 0 []]))\n\ngoal (1 subgoal):\n 1. [Exists\n      (Forall\n        (Pred p\n          [Var 1, Var 0]))] \\<turnstile> Exists (Pred p [Var 0, App 0 []])", "by (rule ExistsE)"], ["proof (state)\nthis:\n  [Exists\n    (Forall\n      (Pred p\n        [Var 1, Var 0]))] \\<turnstile> Exists (Pred p [Var 0, App 0 []])\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> Impl (Exists (Forall (Pred p [Var 1, Var 0])))\n                     (Forall (Exists (Pred p [Var 0, Var 1])))", "then"], ["proof (chain)\npicking this:\n  [Exists\n    (Forall\n      (Pred p\n        [Var 1, Var 0]))] \\<turnstile> Exists (Pred p [Var 0, App 0 []])", "have \\<open>[Exists ?forall] \\<turnstile> (Exists (Pred p [Var 0, Var 1]))[App 0 []/0]\\<close>"], ["proof (prove)\nusing this:\n  [Exists\n    (Forall\n      (Pred p\n        [Var 1, Var 0]))] \\<turnstile> Exists (Pred p [Var 0, App 0 []])\n\ngoal (1 subgoal):\n 1. [Exists\n      (Forall\n        (Pred p\n          [Var 1,\n           Var 0]))] \\<turnstile> Exists (Pred p [Var 0, Var 1])[App 0 []/0]", "by simp"], ["proof (state)\nthis:\n  [Exists\n    (Forall\n      (Pred p\n        [Var 1,\n         Var 0]))] \\<turnstile> Exists (Pred p [Var 0, Var 1])[App 0 []/0]\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> Impl (Exists (Forall (Pred p [Var 1, Var 0])))\n                     (Forall (Exists (Pred p [Var 0, Var 1])))", "moreover"], ["proof (state)\nthis:\n  [Exists\n    (Forall\n      (Pred p\n        [Var 1,\n         Var 0]))] \\<turnstile> Exists (Pred p [Var 0, Var 1])[App 0 []/0]\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> Impl (Exists (Forall (Pred p [Var 1, Var 0])))\n                     (Forall (Exists (Pred p [Var 0, Var 1])))", "have \\<open>list_all (\\<lambda>p. 0 \\<notin> params p) [Exists ?forall]\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>p. 0 \\<notin> params p)\n     [Exists (Forall (Pred p [Var 1, Var 0]))]", "by simp"], ["proof (state)\nthis:\n  list_all (\\<lambda>p. 0 \\<notin> params p)\n   [Exists (Forall (Pred p [Var 1, Var 0]))]\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> Impl (Exists (Forall (Pred p [Var 1, Var 0])))\n                     (Forall (Exists (Pred p [Var 0, Var 1])))", "moreover"], ["proof (state)\nthis:\n  list_all (\\<lambda>p. 0 \\<notin> params p)\n   [Exists (Forall (Pred p [Var 1, Var 0]))]\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> Impl (Exists (Forall (Pred p [Var 1, Var 0])))\n                     (Forall (Exists (Pred p [Var 0, Var 1])))", "have \\<open>0 \\<notin> params (Exists (Pred p [Var 0, Var 1]))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'a) \\<notin> params (Exists (Pred p [Var 0, Var 1]))", "by simp"], ["proof (state)\nthis:\n  (0::?'a1) \\<notin> params (Exists (Pred p [Var 0, Var 1]))\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> Impl (Exists (Forall (Pred p [Var 1, Var 0])))\n                     (Forall (Exists (Pred p [Var 0, Var 1])))", "ultimately"], ["proof (chain)\npicking this:\n  [Exists\n    (Forall\n      (Pred p\n        [Var 1,\n         Var 0]))] \\<turnstile> Exists (Pred p [Var 0, Var 1])[App 0 []/0]\n  list_all (\\<lambda>p. 0 \\<notin> params p)\n   [Exists (Forall (Pred p [Var 1, Var 0]))]\n  (0::?'a1) \\<notin> params (Exists (Pred p [Var 0, Var 1]))", "have \\<open>[Exists ?forall] \\<turnstile> Forall (Exists (Pred p [Var 0, Var 1]))\\<close>"], ["proof (prove)\nusing this:\n  [Exists\n    (Forall\n      (Pred p\n        [Var 1,\n         Var 0]))] \\<turnstile> Exists (Pred p [Var 0, Var 1])[App 0 []/0]\n  list_all (\\<lambda>p. 0 \\<notin> params p)\n   [Exists (Forall (Pred p [Var 1, Var 0]))]\n  (0::?'a1) \\<notin> params (Exists (Pred p [Var 0, Var 1]))\n\ngoal (1 subgoal):\n 1. [Exists\n      (Forall\n        (Pred p\n          [Var 1,\n           Var 0]))] \\<turnstile> Forall (Exists (Pred p [Var 0, Var 1]))", "by (rule ForallI)"], ["proof (state)\nthis:\n  [Exists\n    (Forall\n      (Pred p\n        [Var 1,\n         Var 0]))] \\<turnstile> Forall (Exists (Pred p [Var 0, Var 1]))\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> Impl (Exists (Forall (Pred p [Var 1, Var 0])))\n                     (Forall (Exists (Pred p [Var 0, Var 1])))", "then"], ["proof (chain)\npicking this:\n  [Exists\n    (Forall\n      (Pred p\n        [Var 1,\n         Var 0]))] \\<turnstile> Forall (Exists (Pred p [Var 0, Var 1]))", "show ?thesis"], ["proof (prove)\nusing this:\n  [Exists\n    (Forall\n      (Pred p\n        [Var 1,\n         Var 0]))] \\<turnstile> Forall (Exists (Pred p [Var 0, Var 1]))\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> Impl (Exists (Forall (Pred p [Var 1, Var 0])))\n                     (Forall (Exists (Pred p [Var 0, Var 1])))", "by (rule ImplI)"], ["proof (state)\nthis:\n  [] \\<turnstile> Impl (Exists (Forall (Pred p [Var 1, Var 0])))\n                   (Forall (Exists (Pred p [Var 0, Var 1])))\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem drinker: \\<open>([]::(nat, 'b) form list) \\<turnstile>\n  Exists (Impl (Pred P [Var 0]) (Forall (Pred P [Var 0])))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<turnstile> Exists (Impl (Pred P [Var 0]) (Forall (Pred P [Var 0])))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. [] \\<turnstile> Exists (Impl (Pred P [Var 0]) (Forall (Pred P [Var 0])))", "let ?impl = \\<open>(Impl (Pred P [Var 0]) (Forall (Pred P [Var 0]))) :: (nat, 'b) form\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. [] \\<turnstile> Exists (Impl (Pred P [Var 0]) (Forall (Pred P [Var 0])))", "let ?G' = \\<open>[Pred P [Var 0], Neg (Exists ?impl)]\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. [] \\<turnstile> Exists (Impl (Pred P [Var 0]) (Forall (Pred P [Var 0])))", "let ?G = \\<open>Neg (Pred P [App 0 []]) # ?G'\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. [] \\<turnstile> Exists (Impl (Pred P [Var 0]) (Forall (Pred P [Var 0])))", "have \\<open>?G \\<turnstile> Neg (Exists ?impl)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. [Neg (Pred P [App 0 []]), Pred P [Var 0],\n     Neg (Exists\n           (Impl (Pred P [Var 0])\n             (Forall\n               (Pred P\n                 [Var 0]))))] \\<turnstile> Neg\n      (Exists (Impl (Pred P [Var 0]) (Forall (Pred P [Var 0]))))", "by (simp add: Assum)"], ["proof (state)\nthis:\n  [Neg (Pred P [App 0 []]), Pred P [Var 0],\n   Neg (Exists\n         (Impl (Pred P [Var 0])\n           (Forall\n             (Pred P\n               [Var 0]))))] \\<turnstile> Neg\n    (Exists (Impl (Pred P [Var 0]) (Forall (Pred P [Var 0]))))\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> Exists (Impl (Pred P [Var 0]) (Forall (Pred P [Var 0])))", "moreover"], ["proof (state)\nthis:\n  [Neg (Pred P [App 0 []]), Pred P [Var 0],\n   Neg (Exists\n         (Impl (Pred P [Var 0])\n           (Forall\n             (Pred P\n               [Var 0]))))] \\<turnstile> Neg\n    (Exists (Impl (Pred P [Var 0]) (Forall (Pred P [Var 0]))))\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> Exists (Impl (Pred P [Var 0]) (Forall (Pred P [Var 0])))", "have \\<open>Pred P [App 0 []] # ?G \\<turnstile> Neg (Pred P [App 0 []])\\<close>\n    and \\<open>Pred P [App 0 []] # ?G \\<turnstile> Pred P [App 0 []]\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. [Pred P [App 0 []], Neg (Pred P [App 0 []]), Pred P [Var 0],\n     Neg (Exists\n           (Impl (Pred P [Var 0])\n             (Forall\n               (Pred P [Var 0]))))] \\<turnstile> Neg (Pred P [App 0 []]) &&&\n    [Pred P [App 0 []], Neg (Pred P [App 0 []]), Pred P [Var 0],\n     Neg (Exists\n           (Impl (Pred P [Var 0])\n             (Forall (Pred P [Var 0]))))] \\<turnstile> Pred P [App 0 []]", "by (simp_all add: Assum)"], ["proof (state)\nthis:\n  [Pred P [App 0 []], Neg (Pred P [App 0 []]), Pred P [Var 0],\n   Neg (Exists\n         (Impl (Pred P [Var 0])\n           (Forall (Pred P [Var 0]))))] \\<turnstile> Neg (Pred P [App 0 []])\n  [Pred P [App 0 []], Neg (Pred P [App 0 []]), Pred P [Var 0],\n   Neg (Exists\n         (Impl (Pred P [Var 0])\n           (Forall (Pred P [Var 0]))))] \\<turnstile> Pred P [App 0 []]\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> Exists (Impl (Pred P [Var 0]) (Forall (Pred P [Var 0])))", "then"], ["proof (chain)\npicking this:\n  [Pred P [App 0 []], Neg (Pred P [App 0 []]), Pred P [Var 0],\n   Neg (Exists\n         (Impl (Pred P [Var 0])\n           (Forall (Pred P [Var 0]))))] \\<turnstile> Neg (Pred P [App 0 []])\n  [Pred P [App 0 []], Neg (Pred P [App 0 []]), Pred P [Var 0],\n   Neg (Exists\n         (Impl (Pred P [Var 0])\n           (Forall (Pred P [Var 0]))))] \\<turnstile> Pred P [App 0 []]", "have \\<open>Pred P [App 0 []] # ?G \\<turnstile> FF\\<close>"], ["proof (prove)\nusing this:\n  [Pred P [App 0 []], Neg (Pred P [App 0 []]), Pred P [Var 0],\n   Neg (Exists\n         (Impl (Pred P [Var 0])\n           (Forall (Pred P [Var 0]))))] \\<turnstile> Neg (Pred P [App 0 []])\n  [Pred P [App 0 []], Neg (Pred P [App 0 []]), Pred P [Var 0],\n   Neg (Exists\n         (Impl (Pred P [Var 0])\n           (Forall (Pred P [Var 0]))))] \\<turnstile> Pred P [App 0 []]\n\ngoal (1 subgoal):\n 1. [Pred P [App 0 []], Neg (Pred P [App 0 []]), Pred P [Var 0],\n     Neg (Exists\n           (Impl (Pred P [Var 0])\n             (Forall (Pred P [Var 0]))))] \\<turnstile> FF", "by (rule NegE)"], ["proof (state)\nthis:\n  [Pred P [App 0 []], Neg (Pred P [App 0 []]), Pred P [Var 0],\n   Neg (Exists\n         (Impl (Pred P [Var 0]) (Forall (Pred P [Var 0]))))] \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> Exists (Impl (Pred P [Var 0]) (Forall (Pred P [Var 0])))", "then"], ["proof (chain)\npicking this:\n  [Pred P [App 0 []], Neg (Pred P [App 0 []]), Pred P [Var 0],\n   Neg (Exists\n         (Impl (Pred P [Var 0]) (Forall (Pred P [Var 0]))))] \\<turnstile> FF", "have \\<open>Pred P [App 0 []] # ?G \\<turnstile> Forall (Pred P [Var 0])\\<close>"], ["proof (prove)\nusing this:\n  [Pred P [App 0 []], Neg (Pred P [App 0 []]), Pred P [Var 0],\n   Neg (Exists\n         (Impl (Pred P [Var 0]) (Forall (Pred P [Var 0]))))] \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. [Pred P [App 0 []], Neg (Pred P [App 0 []]), Pred P [Var 0],\n     Neg (Exists\n           (Impl (Pred P [Var 0])\n             (Forall\n               (Pred P [Var 0]))))] \\<turnstile> Forall (Pred P [Var 0])", "by (rule FFE)"], ["proof (state)\nthis:\n  [Pred P [App 0 []], Neg (Pred P [App 0 []]), Pred P [Var 0],\n   Neg (Exists\n         (Impl (Pred P [Var 0])\n           (Forall (Pred P [Var 0]))))] \\<turnstile> Forall (Pred P [Var 0])\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> Exists (Impl (Pred P [Var 0]) (Forall (Pred P [Var 0])))", "then"], ["proof (chain)\npicking this:\n  [Pred P [App 0 []], Neg (Pred P [App 0 []]), Pred P [Var 0],\n   Neg (Exists\n         (Impl (Pred P [Var 0])\n           (Forall (Pred P [Var 0]))))] \\<turnstile> Forall (Pred P [Var 0])", "have \\<open>?G \\<turnstile> ?impl[App 0 []/0]\\<close>"], ["proof (prove)\nusing this:\n  [Pred P [App 0 []], Neg (Pred P [App 0 []]), Pred P [Var 0],\n   Neg (Exists\n         (Impl (Pred P [Var 0])\n           (Forall (Pred P [Var 0]))))] \\<turnstile> Forall (Pred P [Var 0])\n\ngoal (1 subgoal):\n 1. [Neg (Pred P [App 0 []]), Pred P [Var 0],\n     Neg (Exists\n           (Impl (Pred P [Var 0])\n             (Forall\n               (Pred P\n                 [Var 0]))))] \\<turnstile> Impl (Pred P [Var 0])\n      (Forall (Pred P [Var 0]))[App 0 []/0]", "using ImplI"], ["proof (prove)\nusing this:\n  [Pred P [App 0 []], Neg (Pred P [App 0 []]), Pred P [Var 0],\n   Neg (Exists\n         (Impl (Pred P [Var 0])\n           (Forall (Pred P [Var 0]))))] \\<turnstile> Forall (Pred P [Var 0])\n  ?a # ?G \\<turnstile> ?b \\<Longrightarrow> ?G \\<turnstile> Impl ?a ?b\n\ngoal (1 subgoal):\n 1. [Neg (Pred P [App 0 []]), Pred P [Var 0],\n     Neg (Exists\n           (Impl (Pred P [Var 0])\n             (Forall\n               (Pred P\n                 [Var 0]))))] \\<turnstile> Impl (Pred P [Var 0])\n      (Forall (Pred P [Var 0]))[App 0 []/0]", "by simp"], ["proof (state)\nthis:\n  [Neg (Pred P [App 0 []]), Pred P [Var 0],\n   Neg (Exists\n         (Impl (Pred P [Var 0])\n           (Forall\n             (Pred P\n               [Var 0]))))] \\<turnstile> Impl (Pred P [Var 0])\n    (Forall (Pred P [Var 0]))[App 0 []/0]\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> Exists (Impl (Pred P [Var 0]) (Forall (Pred P [Var 0])))", "then"], ["proof (chain)\npicking this:\n  [Neg (Pred P [App 0 []]), Pred P [Var 0],\n   Neg (Exists\n         (Impl (Pred P [Var 0])\n           (Forall\n             (Pred P\n               [Var 0]))))] \\<turnstile> Impl (Pred P [Var 0])\n    (Forall (Pred P [Var 0]))[App 0 []/0]", "have \\<open>?G \\<turnstile> Exists ?impl\\<close>"], ["proof (prove)\nusing this:\n  [Neg (Pred P [App 0 []]), Pred P [Var 0],\n   Neg (Exists\n         (Impl (Pred P [Var 0])\n           (Forall\n             (Pred P\n               [Var 0]))))] \\<turnstile> Impl (Pred P [Var 0])\n    (Forall (Pred P [Var 0]))[App 0 []/0]\n\ngoal (1 subgoal):\n 1. [Neg (Pred P [App 0 []]), Pred P [Var 0],\n     Neg (Exists\n           (Impl (Pred P [Var 0])\n             (Forall\n               (Pred P\n                 [Var 0]))))] \\<turnstile> Exists\n      (Impl (Pred P [Var 0]) (Forall (Pred P [Var 0])))", "by (rule ExistsI)"], ["proof (state)\nthis:\n  [Neg (Pred P [App 0 []]), Pred P [Var 0],\n   Neg (Exists\n         (Impl (Pred P [Var 0])\n           (Forall\n             (Pred P\n               [Var 0]))))] \\<turnstile> Exists\n    (Impl (Pred P [Var 0]) (Forall (Pred P [Var 0])))\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> Exists (Impl (Pred P [Var 0]) (Forall (Pred P [Var 0])))", "ultimately"], ["proof (chain)\npicking this:\n  [Neg (Pred P [App 0 []]), Pred P [Var 0],\n   Neg (Exists\n         (Impl (Pred P [Var 0])\n           (Forall\n             (Pred P\n               [Var 0]))))] \\<turnstile> Neg\n    (Exists (Impl (Pred P [Var 0]) (Forall (Pred P [Var 0]))))\n  [Neg (Pred P [App 0 []]), Pred P [Var 0],\n   Neg (Exists\n         (Impl (Pred P [Var 0])\n           (Forall\n             (Pred P\n               [Var 0]))))] \\<turnstile> Exists\n    (Impl (Pred P [Var 0]) (Forall (Pred P [Var 0])))", "have \\<open>?G \\<turnstile> FF\\<close>"], ["proof (prove)\nusing this:\n  [Neg (Pred P [App 0 []]), Pred P [Var 0],\n   Neg (Exists\n         (Impl (Pred P [Var 0])\n           (Forall\n             (Pred P\n               [Var 0]))))] \\<turnstile> Neg\n    (Exists (Impl (Pred P [Var 0]) (Forall (Pred P [Var 0]))))\n  [Neg (Pred P [App 0 []]), Pred P [Var 0],\n   Neg (Exists\n         (Impl (Pred P [Var 0])\n           (Forall\n             (Pred P\n               [Var 0]))))] \\<turnstile> Exists\n    (Impl (Pred P [Var 0]) (Forall (Pred P [Var 0])))\n\ngoal (1 subgoal):\n 1. [Neg (Pred P [App 0 []]), Pred P [Var 0],\n     Neg (Exists\n           (Impl (Pred P [Var 0])\n             (Forall (Pred P [Var 0]))))] \\<turnstile> FF", "by (rule NegE)"], ["proof (state)\nthis:\n  [Neg (Pred P [App 0 []]), Pred P [Var 0],\n   Neg (Exists\n         (Impl (Pred P [Var 0]) (Forall (Pred P [Var 0]))))] \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> Exists (Impl (Pred P [Var 0]) (Forall (Pred P [Var 0])))", "then"], ["proof (chain)\npicking this:\n  [Neg (Pred P [App 0 []]), Pred P [Var 0],\n   Neg (Exists\n         (Impl (Pred P [Var 0]) (Forall (Pred P [Var 0]))))] \\<turnstile> FF", "have \\<open>?G' \\<turnstile> Pred P [Var 0][App 0 []/0]\\<close>"], ["proof (prove)\nusing this:\n  [Neg (Pred P [App 0 []]), Pred P [Var 0],\n   Neg (Exists\n         (Impl (Pred P [Var 0]) (Forall (Pred P [Var 0]))))] \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. [Pred P [Var 0],\n     Neg (Exists\n           (Impl (Pred P [Var 0])\n             (Forall\n               (Pred P [Var 0]))))] \\<turnstile> Pred P [Var 0][App 0 []/0]", "using Class"], ["proof (prove)\nusing this:\n  [Neg (Pred P [App 0 []]), Pred P [Var 0],\n   Neg (Exists\n         (Impl (Pred P [Var 0]) (Forall (Pred P [Var 0]))))] \\<turnstile> FF\n  Neg ?a # ?G \\<turnstile> FF \\<Longrightarrow> ?G \\<turnstile> ?a\n\ngoal (1 subgoal):\n 1. [Pred P [Var 0],\n     Neg (Exists\n           (Impl (Pred P [Var 0])\n             (Forall\n               (Pred P [Var 0]))))] \\<turnstile> Pred P [Var 0][App 0 []/0]", "by simp"], ["proof (state)\nthis:\n  [Pred P [Var 0],\n   Neg (Exists\n         (Impl (Pred P [Var 0])\n           (Forall\n             (Pred P [Var 0]))))] \\<turnstile> Pred P [Var 0][App 0 []/0]\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> Exists (Impl (Pred P [Var 0]) (Forall (Pred P [Var 0])))", "moreover"], ["proof (state)\nthis:\n  [Pred P [Var 0],\n   Neg (Exists\n         (Impl (Pred P [Var 0])\n           (Forall\n             (Pred P [Var 0]))))] \\<turnstile> Pred P [Var 0][App 0 []/0]\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> Exists (Impl (Pred P [Var 0]) (Forall (Pred P [Var 0])))", "have \\<open>list_all (\\<lambda>p. (0 :: nat) \\<notin> params p) ?G'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>p. 0 \\<notin> params p)\n     [Pred P [Var 0],\n      Neg (Exists (Impl (Pred P [Var 0]) (Forall (Pred P [Var 0]))))]", "by simp"], ["proof (state)\nthis:\n  list_all (\\<lambda>p. 0 \\<notin> params p)\n   [Pred P [Var 0],\n    Neg (Exists (Impl (Pred P [Var 0]) (Forall (Pred P [Var 0]))))]\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> Exists (Impl (Pred P [Var 0]) (Forall (Pred P [Var 0])))", "moreover"], ["proof (state)\nthis:\n  list_all (\\<lambda>p. 0 \\<notin> params p)\n   [Pred P [Var 0],\n    Neg (Exists (Impl (Pred P [Var 0]) (Forall (Pred P [Var 0]))))]\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> Exists (Impl (Pred P [Var 0]) (Forall (Pred P [Var 0])))", "have \\<open>(0 :: nat) \\<notin> params (Pred P [Var 0])\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<notin> params (Pred P [Var 0])", "by simp"], ["proof (state)\nthis:\n  0 \\<notin> params (Pred P [Var 0])\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> Exists (Impl (Pred P [Var 0]) (Forall (Pred P [Var 0])))", "ultimately"], ["proof (chain)\npicking this:\n  [Pred P [Var 0],\n   Neg (Exists\n         (Impl (Pred P [Var 0])\n           (Forall\n             (Pred P [Var 0]))))] \\<turnstile> Pred P [Var 0][App 0 []/0]\n  list_all (\\<lambda>p. 0 \\<notin> params p)\n   [Pred P [Var 0],\n    Neg (Exists (Impl (Pred P [Var 0]) (Forall (Pred P [Var 0]))))]\n  0 \\<notin> params (Pred P [Var 0])", "have \\<open>?G' \\<turnstile> Forall (Pred P [Var 0])\\<close>"], ["proof (prove)\nusing this:\n  [Pred P [Var 0],\n   Neg (Exists\n         (Impl (Pred P [Var 0])\n           (Forall\n             (Pred P [Var 0]))))] \\<turnstile> Pred P [Var 0][App 0 []/0]\n  list_all (\\<lambda>p. 0 \\<notin> params p)\n   [Pred P [Var 0],\n    Neg (Exists (Impl (Pred P [Var 0]) (Forall (Pred P [Var 0]))))]\n  0 \\<notin> params (Pred P [Var 0])\n\ngoal (1 subgoal):\n 1. [Pred P [Var 0],\n     Neg (Exists\n           (Impl (Pred P [Var 0])\n             (Forall\n               (Pred P [Var 0]))))] \\<turnstile> Forall (Pred P [Var 0])", "by (rule ForallI)"], ["proof (state)\nthis:\n  [Pred P [Var 0],\n   Neg (Exists\n         (Impl (Pred P [Var 0])\n           (Forall (Pred P [Var 0]))))] \\<turnstile> Forall (Pred P [Var 0])\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> Exists (Impl (Pred P [Var 0]) (Forall (Pred P [Var 0])))", "then"], ["proof (chain)\npicking this:\n  [Pred P [Var 0],\n   Neg (Exists\n         (Impl (Pred P [Var 0])\n           (Forall (Pred P [Var 0]))))] \\<turnstile> Forall (Pred P [Var 0])", "have \\<open>[Neg (Exists ?impl)] \\<turnstile> ?impl[Var 0/0]\\<close>"], ["proof (prove)\nusing this:\n  [Pred P [Var 0],\n   Neg (Exists\n         (Impl (Pred P [Var 0])\n           (Forall (Pred P [Var 0]))))] \\<turnstile> Forall (Pred P [Var 0])\n\ngoal (1 subgoal):\n 1. [Neg (Exists\n           (Impl (Pred P [Var 0])\n             (Forall\n               (Pred P\n                 [Var 0]))))] \\<turnstile> Impl (Pred P [Var 0])\n      (Forall (Pred P [Var 0]))[Var 0/0]", "using ImplI"], ["proof (prove)\nusing this:\n  [Pred P [Var 0],\n   Neg (Exists\n         (Impl (Pred P [Var 0])\n           (Forall (Pred P [Var 0]))))] \\<turnstile> Forall (Pred P [Var 0])\n  ?a # ?G \\<turnstile> ?b \\<Longrightarrow> ?G \\<turnstile> Impl ?a ?b\n\ngoal (1 subgoal):\n 1. [Neg (Exists\n           (Impl (Pred P [Var 0])\n             (Forall\n               (Pred P\n                 [Var 0]))))] \\<turnstile> Impl (Pred P [Var 0])\n      (Forall (Pred P [Var 0]))[Var 0/0]", "by simp"], ["proof (state)\nthis:\n  [Neg (Exists\n         (Impl (Pred P [Var 0])\n           (Forall\n             (Pred P\n               [Var 0]))))] \\<turnstile> Impl (Pred P [Var 0])\n    (Forall (Pred P [Var 0]))[Var 0/0]\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> Exists (Impl (Pred P [Var 0]) (Forall (Pred P [Var 0])))", "then"], ["proof (chain)\npicking this:\n  [Neg (Exists\n         (Impl (Pred P [Var 0])\n           (Forall\n             (Pred P\n               [Var 0]))))] \\<turnstile> Impl (Pred P [Var 0])\n    (Forall (Pred P [Var 0]))[Var 0/0]", "have \\<open>[Neg (Exists ?impl)] \\<turnstile> Exists ?impl\\<close>"], ["proof (prove)\nusing this:\n  [Neg (Exists\n         (Impl (Pred P [Var 0])\n           (Forall\n             (Pred P\n               [Var 0]))))] \\<turnstile> Impl (Pred P [Var 0])\n    (Forall (Pred P [Var 0]))[Var 0/0]\n\ngoal (1 subgoal):\n 1. [Neg (Exists\n           (Impl (Pred P [Var 0])\n             (Forall\n               (Pred P\n                 [Var 0]))))] \\<turnstile> Exists\n      (Impl (Pred P [Var 0]) (Forall (Pred P [Var 0])))", "by (rule ExistsI)"], ["proof (state)\nthis:\n  [Neg (Exists\n         (Impl (Pred P [Var 0])\n           (Forall\n             (Pred P\n               [Var 0]))))] \\<turnstile> Exists\n    (Impl (Pred P [Var 0]) (Forall (Pred P [Var 0])))\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> Exists (Impl (Pred P [Var 0]) (Forall (Pred P [Var 0])))", "then"], ["proof (chain)\npicking this:\n  [Neg (Exists\n         (Impl (Pred P [Var 0])\n           (Forall\n             (Pred P\n               [Var 0]))))] \\<turnstile> Exists\n    (Impl (Pred P [Var 0]) (Forall (Pred P [Var 0])))", "show ?thesis"], ["proof (prove)\nusing this:\n  [Neg (Exists\n         (Impl (Pred P [Var 0])\n           (Forall\n             (Pred P\n               [Var 0]))))] \\<turnstile> Exists\n    (Impl (Pred P [Var 0]) (Forall (Pred P [Var 0])))\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> Exists (Impl (Pred P [Var 0]) (Forall (Pred P [Var 0])))", "by (rule Class')"], ["proof (state)\nthis:\n  [] \\<turnstile> Exists (Impl (Pred P [Var 0]) (Forall (Pred P [Var 0])))\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem peirce:\n  \\<open>[] \\<turnstile> Impl (Impl (Impl (Pred P []) (Pred Q [])) (Pred P [])) (Pred P [])\\<close>\n  (is \\<open>[] \\<turnstile> Impl ?PQP (Pred P [])\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<turnstile> Impl (Impl (Impl (Pred P []) (Pred Q [])) (Pred P []))\n                     (Pred P [])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. [] \\<turnstile> Impl (Impl (Impl (Pred P []) (Pred Q [])) (Pred P []))\n                     (Pred P [])", "let ?PQPP = \\<open>Impl ?PQP (Pred P [])\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. [] \\<turnstile> Impl (Impl (Impl (Pred P []) (Pred Q [])) (Pred P []))\n                     (Pred P [])", "have \\<open>[?PQP, Neg ?PQPP] \\<turnstile> ?PQP\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. [Impl (Impl (Pred P []) (Pred Q [])) (Pred P []),\n     Neg (Impl (Impl (Impl (Pred P []) (Pred Q [])) (Pred P []))\n           (Pred P\n             []))] \\<turnstile> Impl (Impl (Pred P []) (Pred Q []))\n                                 (Pred P [])", "by (simp add: Assum)"], ["proof (state)\nthis:\n  [Impl (Impl (Pred P []) (Pred Q [])) (Pred P []),\n   Neg (Impl (Impl (Impl (Pred P []) (Pred Q [])) (Pred P []))\n         (Pred P\n           []))] \\<turnstile> Impl (Impl (Pred P []) (Pred Q []))\n                               (Pred P [])\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> Impl (Impl (Impl (Pred P []) (Pred Q [])) (Pred P []))\n                     (Pred P [])", "moreover"], ["proof (state)\nthis:\n  [Impl (Impl (Pred P []) (Pred Q [])) (Pred P []),\n   Neg (Impl (Impl (Impl (Pred P []) (Pred Q [])) (Pred P []))\n         (Pred P\n           []))] \\<turnstile> Impl (Impl (Pred P []) (Pred Q []))\n                               (Pred P [])\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> Impl (Impl (Impl (Pred P []) (Pred Q [])) (Pred P []))\n                     (Pred P [])", "{"], ["proof (state)\nthis:\n  [Impl (Impl (Pred P []) (Pred Q [])) (Pred P []),\n   Neg (Impl (Impl (Impl (Pred P []) (Pred Q [])) (Pred P []))\n         (Pred P\n           []))] \\<turnstile> Impl (Impl (Pred P []) (Pred Q []))\n                               (Pred P [])\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> Impl (Impl (Impl (Pred P []) (Pred Q [])) (Pred P []))\n                     (Pred P [])", "have \\<open>[Pred P [], ?PQP, Neg ?PQPP] \\<turnstile> Neg ?PQPP\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. [Pred P [], Impl (Impl (Pred P []) (Pred Q [])) (Pred P []),\n     Neg (Impl (Impl (Impl (Pred P []) (Pred Q [])) (Pred P []))\n           (Pred P\n             []))] \\<turnstile> Neg (Impl\n(Impl (Impl (Pred P []) (Pred Q [])) (Pred P [])) (Pred P []))", "by (simp add: Assum)"], ["proof (state)\nthis:\n  [Pred P [], Impl (Impl (Pred P []) (Pred Q [])) (Pred P []),\n   Neg (Impl (Impl (Impl (Pred P []) (Pred Q [])) (Pred P []))\n         (Pred P\n           []))] \\<turnstile> Neg (Impl\n                                    (Impl (Impl (Pred P []) (Pred Q []))\n(Pred P []))\n                                    (Pred P []))\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> Impl (Impl (Impl (Pred P []) (Pred Q [])) (Pred P []))\n                     (Pred P [])", "moreover"], ["proof (state)\nthis:\n  [Pred P [], Impl (Impl (Pred P []) (Pred Q [])) (Pred P []),\n   Neg (Impl (Impl (Impl (Pred P []) (Pred Q [])) (Pred P []))\n         (Pred P\n           []))] \\<turnstile> Neg (Impl\n                                    (Impl (Impl (Pred P []) (Pred Q []))\n(Pred P []))\n                                    (Pred P []))\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> Impl (Impl (Impl (Pred P []) (Pred Q [])) (Pred P []))\n                     (Pred P [])", "have \\<open>[?PQP, Pred P [], ?PQP, Neg ?PQPP] \\<turnstile> Pred P []\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. [Impl (Impl (Pred P []) (Pred Q [])) (Pred P []), Pred P [],\n     Impl (Impl (Pred P []) (Pred Q [])) (Pred P []),\n     Neg (Impl (Impl (Impl (Pred P []) (Pred Q [])) (Pred P []))\n           (Pred P []))] \\<turnstile> Pred P []", "by (simp add: Assum)"], ["proof (state)\nthis:\n  [Impl (Impl (Pred P []) (Pred Q [])) (Pred P []), Pred P [],\n   Impl (Impl (Pred P []) (Pred Q [])) (Pred P []),\n   Neg (Impl (Impl (Impl (Pred P []) (Pred Q [])) (Pred P []))\n         (Pred P []))] \\<turnstile> Pred P []\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> Impl (Impl (Impl (Pred P []) (Pred Q [])) (Pred P []))\n                     (Pred P [])", "then"], ["proof (chain)\npicking this:\n  [Impl (Impl (Pred P []) (Pred Q [])) (Pred P []), Pred P [],\n   Impl (Impl (Pred P []) (Pred Q [])) (Pred P []),\n   Neg (Impl (Impl (Impl (Pred P []) (Pred Q [])) (Pred P []))\n         (Pred P []))] \\<turnstile> Pred P []", "have \\<open>[Pred P [], ?PQP, Neg ?PQPP] \\<turnstile> ?PQPP\\<close>"], ["proof (prove)\nusing this:\n  [Impl (Impl (Pred P []) (Pred Q [])) (Pred P []), Pred P [],\n   Impl (Impl (Pred P []) (Pred Q [])) (Pred P []),\n   Neg (Impl (Impl (Impl (Pred P []) (Pred Q [])) (Pred P []))\n         (Pred P []))] \\<turnstile> Pred P []\n\ngoal (1 subgoal):\n 1. [Pred P [], Impl (Impl (Pred P []) (Pred Q [])) (Pred P []),\n     Neg (Impl (Impl (Impl (Pred P []) (Pred Q [])) (Pred P []))\n           (Pred P\n             []))] \\<turnstile> Impl\n                                 (Impl (Impl (Pred P []) (Pred Q []))\n                                   (Pred P []))\n                                 (Pred P [])", "by (rule ImplI)"], ["proof (state)\nthis:\n  [Pred P [], Impl (Impl (Pred P []) (Pred Q [])) (Pred P []),\n   Neg (Impl (Impl (Impl (Pred P []) (Pred Q [])) (Pred P []))\n         (Pred P\n           []))] \\<turnstile> Impl\n                               (Impl (Impl (Pred P []) (Pred Q []))\n                                 (Pred P []))\n                               (Pred P [])\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> Impl (Impl (Impl (Pred P []) (Pred Q [])) (Pred P []))\n                     (Pred P [])", "ultimately"], ["proof (chain)\npicking this:\n  [Pred P [], Impl (Impl (Pred P []) (Pred Q [])) (Pred P []),\n   Neg (Impl (Impl (Impl (Pred P []) (Pred Q [])) (Pred P []))\n         (Pred P\n           []))] \\<turnstile> Neg (Impl\n                                    (Impl (Impl (Pred P []) (Pred Q []))\n(Pred P []))\n                                    (Pred P []))\n  [Pred P [], Impl (Impl (Pred P []) (Pred Q [])) (Pred P []),\n   Neg (Impl (Impl (Impl (Pred P []) (Pred Q [])) (Pred P []))\n         (Pred P\n           []))] \\<turnstile> Impl\n                               (Impl (Impl (Pred P []) (Pred Q []))\n                                 (Pred P []))\n                               (Pred P [])", "have \\<open>[Pred P [], ?PQP, Neg ?PQPP] \\<turnstile> FF\\<close>"], ["proof (prove)\nusing this:\n  [Pred P [], Impl (Impl (Pred P []) (Pred Q [])) (Pred P []),\n   Neg (Impl (Impl (Impl (Pred P []) (Pred Q [])) (Pred P []))\n         (Pred P\n           []))] \\<turnstile> Neg (Impl\n                                    (Impl (Impl (Pred P []) (Pred Q []))\n(Pred P []))\n                                    (Pred P []))\n  [Pred P [], Impl (Impl (Pred P []) (Pred Q [])) (Pred P []),\n   Neg (Impl (Impl (Impl (Pred P []) (Pred Q [])) (Pred P []))\n         (Pred P\n           []))] \\<turnstile> Impl\n                               (Impl (Impl (Pred P []) (Pred Q []))\n                                 (Pred P []))\n                               (Pred P [])\n\ngoal (1 subgoal):\n 1. [Pred P [], Impl (Impl (Pred P []) (Pred Q [])) (Pred P []),\n     Neg (Impl (Impl (Impl (Pred P []) (Pred Q [])) (Pred P []))\n           (Pred P []))] \\<turnstile> FF", "by (rule NegE)"], ["proof (state)\nthis:\n  [Pred P [], Impl (Impl (Pred P []) (Pred Q [])) (Pred P []),\n   Neg (Impl (Impl (Impl (Pred P []) (Pred Q [])) (Pred P []))\n         (Pred P []))] \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> Impl (Impl (Impl (Pred P []) (Pred Q [])) (Pred P []))\n                     (Pred P [])", "}"], ["proof (state)\nthis:\n  [Pred P [], Impl (Impl (Pred P []) (Pred Q [])) (Pred P []),\n   Neg (Impl (Impl (Impl (Pred P []) (Pred Q [])) (Pred P []))\n         (Pred P []))] \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> Impl (Impl (Impl (Pred P []) (Pred Q [])) (Pred P []))\n                     (Pred P [])", "then"], ["proof (chain)\npicking this:\n  [Pred P [], Impl (Impl (Pred P []) (Pred Q [])) (Pred P []),\n   Neg (Impl (Impl (Impl (Pred P []) (Pred Q [])) (Pred P []))\n         (Pred P []))] \\<turnstile> FF", "have \\<open>[Pred P [], ?PQP, Neg ?PQPP] \\<turnstile> Pred Q []\\<close>"], ["proof (prove)\nusing this:\n  [Pred P [], Impl (Impl (Pred P []) (Pred Q [])) (Pred P []),\n   Neg (Impl (Impl (Impl (Pred P []) (Pred Q [])) (Pred P []))\n         (Pred P []))] \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. [Pred P [], Impl (Impl (Pred P []) (Pred Q [])) (Pred P []),\n     Neg (Impl (Impl (Impl (Pred P []) (Pred Q [])) (Pred P []))\n           (Pred P []))] \\<turnstile> Pred Q []", "by (rule FFE)"], ["proof (state)\nthis:\n  [Pred P [], Impl (Impl (Pred P []) (Pred Q [])) (Pred P []),\n   Neg (Impl (Impl (Impl (Pred P []) (Pred Q [])) (Pred P []))\n         (Pred P []))] \\<turnstile> Pred Q []\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> Impl (Impl (Impl (Pred P []) (Pred Q [])) (Pred P []))\n                     (Pred P [])", "then"], ["proof (chain)\npicking this:\n  [Pred P [], Impl (Impl (Pred P []) (Pred Q [])) (Pred P []),\n   Neg (Impl (Impl (Impl (Pred P []) (Pred Q [])) (Pred P []))\n         (Pred P []))] \\<turnstile> Pred Q []", "have \\<open>[?PQP, Neg ?PQPP] \\<turnstile> Impl (Pred P []) (Pred Q [])\\<close>"], ["proof (prove)\nusing this:\n  [Pred P [], Impl (Impl (Pred P []) (Pred Q [])) (Pred P []),\n   Neg (Impl (Impl (Impl (Pred P []) (Pred Q [])) (Pred P []))\n         (Pred P []))] \\<turnstile> Pred Q []\n\ngoal (1 subgoal):\n 1. [Impl (Impl (Pred P []) (Pred Q [])) (Pred P []),\n     Neg (Impl (Impl (Impl (Pred P []) (Pred Q [])) (Pred P []))\n           (Pred P []))] \\<turnstile> Impl (Pred P []) (Pred Q [])", "by (rule ImplI)"], ["proof (state)\nthis:\n  [Impl (Impl (Pred P []) (Pred Q [])) (Pred P []),\n   Neg (Impl (Impl (Impl (Pred P []) (Pred Q [])) (Pred P []))\n         (Pred P []))] \\<turnstile> Impl (Pred P []) (Pred Q [])\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> Impl (Impl (Impl (Pred P []) (Pred Q [])) (Pred P []))\n                     (Pred P [])", "ultimately"], ["proof (chain)\npicking this:\n  [Impl (Impl (Pred P []) (Pred Q [])) (Pred P []),\n   Neg (Impl (Impl (Impl (Pred P []) (Pred Q [])) (Pred P []))\n         (Pred P\n           []))] \\<turnstile> Impl (Impl (Pred P []) (Pred Q []))\n                               (Pred P [])\n  [Impl (Impl (Pred P []) (Pred Q [])) (Pred P []),\n   Neg (Impl (Impl (Impl (Pred P []) (Pred Q [])) (Pred P []))\n         (Pred P []))] \\<turnstile> Impl (Pred P []) (Pred Q [])", "have \\<open>[?PQP, Neg ?PQPP] \\<turnstile> Pred P []\\<close>"], ["proof (prove)\nusing this:\n  [Impl (Impl (Pred P []) (Pred Q [])) (Pred P []),\n   Neg (Impl (Impl (Impl (Pred P []) (Pred Q [])) (Pred P []))\n         (Pred P\n           []))] \\<turnstile> Impl (Impl (Pred P []) (Pred Q []))\n                               (Pred P [])\n  [Impl (Impl (Pred P []) (Pred Q [])) (Pred P []),\n   Neg (Impl (Impl (Impl (Pred P []) (Pred Q [])) (Pred P []))\n         (Pred P []))] \\<turnstile> Impl (Pred P []) (Pred Q [])\n\ngoal (1 subgoal):\n 1. [Impl (Impl (Pred P []) (Pred Q [])) (Pred P []),\n     Neg (Impl (Impl (Impl (Pred P []) (Pred Q [])) (Pred P []))\n           (Pred P []))] \\<turnstile> Pred P []", "by (rule ImplE)"], ["proof (state)\nthis:\n  [Impl (Impl (Pred P []) (Pred Q [])) (Pred P []),\n   Neg (Impl (Impl (Impl (Pred P []) (Pred Q [])) (Pred P []))\n         (Pred P []))] \\<turnstile> Pred P []\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> Impl (Impl (Impl (Pred P []) (Pred Q [])) (Pred P []))\n                     (Pred P [])", "then"], ["proof (chain)\npicking this:\n  [Impl (Impl (Pred P []) (Pred Q [])) (Pred P []),\n   Neg (Impl (Impl (Impl (Pred P []) (Pred Q [])) (Pred P []))\n         (Pred P []))] \\<turnstile> Pred P []", "have \\<open>[Neg ?PQPP] \\<turnstile> ?PQPP\\<close>"], ["proof (prove)\nusing this:\n  [Impl (Impl (Pred P []) (Pred Q [])) (Pred P []),\n   Neg (Impl (Impl (Impl (Pred P []) (Pred Q [])) (Pred P []))\n         (Pred P []))] \\<turnstile> Pred P []\n\ngoal (1 subgoal):\n 1. [Neg (Impl (Impl (Impl (Pred P []) (Pred Q [])) (Pred P []))\n           (Pred P\n             []))] \\<turnstile> Impl\n                                 (Impl (Impl (Pred P []) (Pred Q []))\n                                   (Pred P []))\n                                 (Pred P [])", "by (rule ImplI)"], ["proof (state)\nthis:\n  [Neg (Impl (Impl (Impl (Pred P []) (Pred Q [])) (Pred P []))\n         (Pred P\n           []))] \\<turnstile> Impl\n                               (Impl (Impl (Pred P []) (Pred Q []))\n                                 (Pred P []))\n                               (Pred P [])\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> Impl (Impl (Impl (Pred P []) (Pred Q [])) (Pred P []))\n                     (Pred P [])", "then"], ["proof (chain)\npicking this:\n  [Neg (Impl (Impl (Impl (Pred P []) (Pred Q [])) (Pred P []))\n         (Pred P\n           []))] \\<turnstile> Impl\n                               (Impl (Impl (Pred P []) (Pred Q []))\n                                 (Pred P []))\n                               (Pred P [])", "show \\<open>[] \\<turnstile> ?PQPP\\<close>"], ["proof (prove)\nusing this:\n  [Neg (Impl (Impl (Impl (Pred P []) (Pred Q [])) (Pred P []))\n         (Pred P\n           []))] \\<turnstile> Impl\n                               (Impl (Impl (Pred P []) (Pred Q []))\n                                 (Pred P []))\n                               (Pred P [])\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> Impl (Impl (Impl (Pred P []) (Pred Q [])) (Pred P []))\n                     (Pred P [])", "by (rule Class')"], ["proof (state)\nthis:\n  [] \\<turnstile> Impl (Impl (Impl (Pred P []) (Pred Q [])) (Pred P []))\n                   (Pred P [])\n\ngoal:\nNo subgoals!", "qed"], ["", "section \\<open>Correctness\\<close>"], ["", "text \\<open>\nThe correctness of the proof calculus introduced in \\secref{sec:proof-calculus}\ncan now be proved by induction on the derivation of @{term \\<open>G \\<turnstile> p\\<close>}, using the\nsubstitution rules proved in \\secref{sec:semantics}.\n\\<close>"], ["", "theorem correctness: \\<open>G \\<turnstile> p \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<turnstile> p \\<Longrightarrow>\n    \\<forall>e f g. e,f,g,G \\<Turnstile> p", "proof (induct p rule: deriv.induct)"], ["proof (state)\ngoal (18 subgoals):\n 1. \\<And>a G.\n       a \\<in> set G \\<Longrightarrow>\n       \\<forall>e f g. e,f,g,G \\<Turnstile> a\n 2. \\<And>G. \\<forall>e f g. e,f,g,G \\<Turnstile> TT\n 3. \\<And>G a.\n       \\<lbrakk>G \\<turnstile> FF;\n        \\<forall>e f g. e,f,g,G \\<Turnstile> FF\\<rbrakk>\n       \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> a\n 4. \\<And>a G.\n       \\<lbrakk>a # G \\<turnstile> FF;\n        \\<forall>e f g. e,f,g,a # G \\<Turnstile> FF\\<rbrakk>\n       \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> Neg a\n 5. \\<And>G a.\n       \\<lbrakk>G \\<turnstile> Neg a;\n        \\<forall>e f g. e,f,g,G \\<Turnstile> Neg a; G \\<turnstile> a;\n        \\<forall>e f g. e,f,g,G \\<Turnstile> a\\<rbrakk>\n       \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> FF\n 6. \\<And>a G.\n       \\<lbrakk>Neg a # G \\<turnstile> FF;\n        \\<forall>e f g. e,f,g,Neg a # G \\<Turnstile> FF\\<rbrakk>\n       \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> a\n 7. \\<And>G a b.\n       \\<lbrakk>G \\<turnstile> a; \\<forall>e f g. e,f,g,G \\<Turnstile> a;\n        G \\<turnstile> b; \\<forall>e f g. e,f,g,G \\<Turnstile> b\\<rbrakk>\n       \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> And a b\n 8. \\<And>G a b.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<forall>e f g. e,f,g,G \\<Turnstile> And a b\\<rbrakk>\n       \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> a\n 9. \\<And>G a b.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<forall>e f g. e,f,g,G \\<Turnstile> And a b\\<rbrakk>\n       \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> b\n 10. \\<And>G a b.\n        \\<lbrakk>G \\<turnstile> a;\n         \\<forall>e f g. e,f,g,G \\<Turnstile> a\\<rbrakk>\n        \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> Or a b\nA total of 18 subgoals...", "case (Assum a G)"], ["proof (state)\nthis:\n  a \\<in> set G\n\ngoal (18 subgoals):\n 1. \\<And>a G.\n       a \\<in> set G \\<Longrightarrow>\n       \\<forall>e f g. e,f,g,G \\<Turnstile> a\n 2. \\<And>G. \\<forall>e f g. e,f,g,G \\<Turnstile> TT\n 3. \\<And>G a.\n       \\<lbrakk>G \\<turnstile> FF;\n        \\<forall>e f g. e,f,g,G \\<Turnstile> FF\\<rbrakk>\n       \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> a\n 4. \\<And>a G.\n       \\<lbrakk>a # G \\<turnstile> FF;\n        \\<forall>e f g. e,f,g,a # G \\<Turnstile> FF\\<rbrakk>\n       \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> Neg a\n 5. \\<And>G a.\n       \\<lbrakk>G \\<turnstile> Neg a;\n        \\<forall>e f g. e,f,g,G \\<Turnstile> Neg a; G \\<turnstile> a;\n        \\<forall>e f g. e,f,g,G \\<Turnstile> a\\<rbrakk>\n       \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> FF\n 6. \\<And>a G.\n       \\<lbrakk>Neg a # G \\<turnstile> FF;\n        \\<forall>e f g. e,f,g,Neg a # G \\<Turnstile> FF\\<rbrakk>\n       \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> a\n 7. \\<And>G a b.\n       \\<lbrakk>G \\<turnstile> a; \\<forall>e f g. e,f,g,G \\<Turnstile> a;\n        G \\<turnstile> b; \\<forall>e f g. e,f,g,G \\<Turnstile> b\\<rbrakk>\n       \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> And a b\n 8. \\<And>G a b.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<forall>e f g. e,f,g,G \\<Turnstile> And a b\\<rbrakk>\n       \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> a\n 9. \\<And>G a b.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<forall>e f g. e,f,g,G \\<Turnstile> And a b\\<rbrakk>\n       \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> b\n 10. \\<And>G a b.\n        \\<lbrakk>G \\<turnstile> a;\n         \\<forall>e f g. e,f,g,G \\<Turnstile> a\\<rbrakk>\n        \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> Or a b\nA total of 18 subgoals...", "then"], ["proof (chain)\npicking this:\n  a \\<in> set G", "show ?case"], ["proof (prove)\nusing this:\n  a \\<in> set G\n\ngoal (1 subgoal):\n 1. \\<forall>e f g. e,f,g,G \\<Turnstile> a", "by (simp add: model_def list_all_iff)"], ["proof (state)\nthis:\n  \\<forall>e f g. e,f,g,G \\<Turnstile> a\n\ngoal (17 subgoals):\n 1. \\<And>G. \\<forall>e f g. e,f,g,G \\<Turnstile> TT\n 2. \\<And>G a.\n       \\<lbrakk>G \\<turnstile> FF;\n        \\<forall>e f g. e,f,g,G \\<Turnstile> FF\\<rbrakk>\n       \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> a\n 3. \\<And>a G.\n       \\<lbrakk>a # G \\<turnstile> FF;\n        \\<forall>e f g. e,f,g,a # G \\<Turnstile> FF\\<rbrakk>\n       \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> Neg a\n 4. \\<And>G a.\n       \\<lbrakk>G \\<turnstile> Neg a;\n        \\<forall>e f g. e,f,g,G \\<Turnstile> Neg a; G \\<turnstile> a;\n        \\<forall>e f g. e,f,g,G \\<Turnstile> a\\<rbrakk>\n       \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> FF\n 5. \\<And>a G.\n       \\<lbrakk>Neg a # G \\<turnstile> FF;\n        \\<forall>e f g. e,f,g,Neg a # G \\<Turnstile> FF\\<rbrakk>\n       \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> a\n 6. \\<And>G a b.\n       \\<lbrakk>G \\<turnstile> a; \\<forall>e f g. e,f,g,G \\<Turnstile> a;\n        G \\<turnstile> b; \\<forall>e f g. e,f,g,G \\<Turnstile> b\\<rbrakk>\n       \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> And a b\n 7. \\<And>G a b.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<forall>e f g. e,f,g,G \\<Turnstile> And a b\\<rbrakk>\n       \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> a\n 8. \\<And>G a b.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<forall>e f g. e,f,g,G \\<Turnstile> And a b\\<rbrakk>\n       \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> b\n 9. \\<And>G a b.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<forall>e f g. e,f,g,G \\<Turnstile> a\\<rbrakk>\n       \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> Or a b\n 10. \\<And>G b a.\n        \\<lbrakk>G \\<turnstile> b;\n         \\<forall>e f g. e,f,g,G \\<Turnstile> b\\<rbrakk>\n        \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> Or a b\nA total of 17 subgoals...", "next"], ["proof (state)\ngoal (17 subgoals):\n 1. \\<And>G. \\<forall>e f g. e,f,g,G \\<Turnstile> TT\n 2. \\<And>G a.\n       \\<lbrakk>G \\<turnstile> FF;\n        \\<forall>e f g. e,f,g,G \\<Turnstile> FF\\<rbrakk>\n       \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> a\n 3. \\<And>a G.\n       \\<lbrakk>a # G \\<turnstile> FF;\n        \\<forall>e f g. e,f,g,a # G \\<Turnstile> FF\\<rbrakk>\n       \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> Neg a\n 4. \\<And>G a.\n       \\<lbrakk>G \\<turnstile> Neg a;\n        \\<forall>e f g. e,f,g,G \\<Turnstile> Neg a; G \\<turnstile> a;\n        \\<forall>e f g. e,f,g,G \\<Turnstile> a\\<rbrakk>\n       \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> FF\n 5. \\<And>a G.\n       \\<lbrakk>Neg a # G \\<turnstile> FF;\n        \\<forall>e f g. e,f,g,Neg a # G \\<Turnstile> FF\\<rbrakk>\n       \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> a\n 6. \\<And>G a b.\n       \\<lbrakk>G \\<turnstile> a; \\<forall>e f g. e,f,g,G \\<Turnstile> a;\n        G \\<turnstile> b; \\<forall>e f g. e,f,g,G \\<Turnstile> b\\<rbrakk>\n       \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> And a b\n 7. \\<And>G a b.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<forall>e f g. e,f,g,G \\<Turnstile> And a b\\<rbrakk>\n       \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> a\n 8. \\<And>G a b.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<forall>e f g. e,f,g,G \\<Turnstile> And a b\\<rbrakk>\n       \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> b\n 9. \\<And>G a b.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<forall>e f g. e,f,g,G \\<Turnstile> a\\<rbrakk>\n       \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> Or a b\n 10. \\<And>G b a.\n        \\<lbrakk>G \\<turnstile> b;\n         \\<forall>e f g. e,f,g,G \\<Turnstile> b\\<rbrakk>\n        \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> Or a b\nA total of 17 subgoals...", "case (ForallI G a n)"], ["proof (state)\nthis:\n  G \\<turnstile> a[App n []/0]\n  \\<forall>e f g. e,f,g,G \\<Turnstile> a[App n []/0]\n  list_all (\\<lambda>p. n \\<notin> params p) G\n  n \\<notin> params a\n\ngoal (17 subgoals):\n 1. \\<And>G. \\<forall>e f g. e,f,g,G \\<Turnstile> TT\n 2. \\<And>G a.\n       \\<lbrakk>G \\<turnstile> FF;\n        \\<forall>e f g. e,f,g,G \\<Turnstile> FF\\<rbrakk>\n       \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> a\n 3. \\<And>a G.\n       \\<lbrakk>a # G \\<turnstile> FF;\n        \\<forall>e f g. e,f,g,a # G \\<Turnstile> FF\\<rbrakk>\n       \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> Neg a\n 4. \\<And>G a.\n       \\<lbrakk>G \\<turnstile> Neg a;\n        \\<forall>e f g. e,f,g,G \\<Turnstile> Neg a; G \\<turnstile> a;\n        \\<forall>e f g. e,f,g,G \\<Turnstile> a\\<rbrakk>\n       \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> FF\n 5. \\<And>a G.\n       \\<lbrakk>Neg a # G \\<turnstile> FF;\n        \\<forall>e f g. e,f,g,Neg a # G \\<Turnstile> FF\\<rbrakk>\n       \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> a\n 6. \\<And>G a b.\n       \\<lbrakk>G \\<turnstile> a; \\<forall>e f g. e,f,g,G \\<Turnstile> a;\n        G \\<turnstile> b; \\<forall>e f g. e,f,g,G \\<Turnstile> b\\<rbrakk>\n       \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> And a b\n 7. \\<And>G a b.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<forall>e f g. e,f,g,G \\<Turnstile> And a b\\<rbrakk>\n       \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> a\n 8. \\<And>G a b.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<forall>e f g. e,f,g,G \\<Turnstile> And a b\\<rbrakk>\n       \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> b\n 9. \\<And>G a b.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<forall>e f g. e,f,g,G \\<Turnstile> a\\<rbrakk>\n       \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> Or a b\n 10. \\<And>G b a.\n        \\<lbrakk>G \\<turnstile> b;\n         \\<forall>e f g. e,f,g,G \\<Turnstile> b\\<rbrakk>\n        \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> Or a b\nA total of 17 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>e f g. e,f,g,G \\<Turnstile> Forall a", "proof (intro allI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e f g. e,f,g,G \\<Turnstile> Forall a", "fix f g and e :: \\<open>nat \\<Rightarrow> 'c\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e f g. e,f,g,G \\<Turnstile> Forall a", "have \\<open>\\<forall>z. e, (f(n := \\<lambda>x. z)), g, G \\<Turnstile> (a[App n []/0])\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>z. e,f(n := \\<lambda>x. z),g,G \\<Turnstile> a[App n []/0]", "using ForallI"], ["proof (prove)\nusing this:\n  G \\<turnstile> a[App n []/0]\n  \\<forall>e f g. e,f,g,G \\<Turnstile> a[App n []/0]\n  list_all (\\<lambda>p. n \\<notin> params p) G\n  n \\<notin> params a\n\ngoal (1 subgoal):\n 1. \\<forall>z. e,f(n := \\<lambda>x. z),g,G \\<Turnstile> a[App n []/0]", "by blast"], ["proof (state)\nthis:\n  \\<forall>z. e,f(n := \\<lambda>x. z),g,G \\<Turnstile> a[App n []/0]\n\ngoal (1 subgoal):\n 1. \\<And>e f g. e,f,g,G \\<Turnstile> Forall a", "then"], ["proof (chain)\npicking this:\n  \\<forall>z. e,f(n := \\<lambda>x. z),g,G \\<Turnstile> a[App n []/0]", "have \\<open>\\<forall>z. list_all (eval e f g) G \\<longrightarrow> eval (e\\<langle>0:z\\<rangle>) f g a\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>z. e,f(n := \\<lambda>x. z),g,G \\<Turnstile> a[App n []/0]\n\ngoal (1 subgoal):\n 1. \\<forall>z.\n       list_all (eval e f g) G \\<longrightarrow>\n       eval (e\\<langle>0:z\\<rangle>) f g a", "using ForallI"], ["proof (prove)\nusing this:\n  \\<forall>z. e,f(n := \\<lambda>x. z),g,G \\<Turnstile> a[App n []/0]\n  G \\<turnstile> a[App n []/0]\n  \\<forall>e f g. e,f,g,G \\<Turnstile> a[App n []/0]\n  list_all (\\<lambda>p. n \\<notin> params p) G\n  n \\<notin> params a\n\ngoal (1 subgoal):\n 1. \\<forall>z.\n       list_all (eval e f g) G \\<longrightarrow>\n       eval (e\\<langle>0:z\\<rangle>) f g a", "unfolding model_def"], ["proof (prove)\nusing this:\n  \\<forall>z.\n     list_all (eval e (f(n := \\<lambda>x. z)) g) G \\<longrightarrow>\n     eval e (f(n := \\<lambda>x. z)) g (a[App n []/0])\n  G \\<turnstile> a[App n []/0]\n  \\<forall>e f g.\n     list_all (eval e f g) G \\<longrightarrow> eval e f g (a[App n []/0])\n  list_all (\\<lambda>p. n \\<notin> params p) G\n  n \\<notin> params a\n\ngoal (1 subgoal):\n 1. \\<forall>z.\n       list_all (eval e f g) G \\<longrightarrow>\n       eval (e\\<langle>0:z\\<rangle>) f g a", "by simp"], ["proof (state)\nthis:\n  \\<forall>z.\n     list_all (eval e f g) G \\<longrightarrow>\n     eval (e\\<langle>0:z\\<rangle>) f g a\n\ngoal (1 subgoal):\n 1. \\<And>e f g. e,f,g,G \\<Turnstile> Forall a", "then"], ["proof (chain)\npicking this:\n  \\<forall>z.\n     list_all (eval e f g) G \\<longrightarrow>\n     eval (e\\<langle>0:z\\<rangle>) f g a", "show \\<open>e,f,g,G \\<Turnstile> Forall a\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>z.\n     list_all (eval e f g) G \\<longrightarrow>\n     eval (e\\<langle>0:z\\<rangle>) f g a\n\ngoal (1 subgoal):\n 1. e,f,g,G \\<Turnstile> Forall a", "unfolding model_def"], ["proof (prove)\nusing this:\n  \\<forall>z.\n     list_all (eval e f g) G \\<longrightarrow>\n     eval (e\\<langle>0:z\\<rangle>) f g a\n\ngoal (1 subgoal):\n 1. list_all (eval e f g) G \\<longrightarrow> eval e f g (Forall a)", "by simp"], ["proof (state)\nthis:\n  e,f,g,G \\<Turnstile> Forall a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>e f g. e,f,g,G \\<Turnstile> Forall a\n\ngoal (16 subgoals):\n 1. \\<And>G. \\<forall>e f g. e,f,g,G \\<Turnstile> TT\n 2. \\<And>G a.\n       \\<lbrakk>G \\<turnstile> FF;\n        \\<forall>e f g. e,f,g,G \\<Turnstile> FF\\<rbrakk>\n       \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> a\n 3. \\<And>a G.\n       \\<lbrakk>a # G \\<turnstile> FF;\n        \\<forall>e f g. e,f,g,a # G \\<Turnstile> FF\\<rbrakk>\n       \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> Neg a\n 4. \\<And>G a.\n       \\<lbrakk>G \\<turnstile> Neg a;\n        \\<forall>e f g. e,f,g,G \\<Turnstile> Neg a; G \\<turnstile> a;\n        \\<forall>e f g. e,f,g,G \\<Turnstile> a\\<rbrakk>\n       \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> FF\n 5. \\<And>a G.\n       \\<lbrakk>Neg a # G \\<turnstile> FF;\n        \\<forall>e f g. e,f,g,Neg a # G \\<Turnstile> FF\\<rbrakk>\n       \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> a\n 6. \\<And>G a b.\n       \\<lbrakk>G \\<turnstile> a; \\<forall>e f g. e,f,g,G \\<Turnstile> a;\n        G \\<turnstile> b; \\<forall>e f g. e,f,g,G \\<Turnstile> b\\<rbrakk>\n       \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> And a b\n 7. \\<And>G a b.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<forall>e f g. e,f,g,G \\<Turnstile> And a b\\<rbrakk>\n       \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> a\n 8. \\<And>G a b.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<forall>e f g. e,f,g,G \\<Turnstile> And a b\\<rbrakk>\n       \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> b\n 9. \\<And>G a b.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<forall>e f g. e,f,g,G \\<Turnstile> a\\<rbrakk>\n       \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> Or a b\n 10. \\<And>G b a.\n        \\<lbrakk>G \\<turnstile> b;\n         \\<forall>e f g. e,f,g,G \\<Turnstile> b\\<rbrakk>\n        \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> Or a b\nA total of 16 subgoals...", "next"], ["proof (state)\ngoal (16 subgoals):\n 1. \\<And>G. \\<forall>e f g. e,f,g,G \\<Turnstile> TT\n 2. \\<And>G a.\n       \\<lbrakk>G \\<turnstile> FF;\n        \\<forall>e f g. e,f,g,G \\<Turnstile> FF\\<rbrakk>\n       \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> a\n 3. \\<And>a G.\n       \\<lbrakk>a # G \\<turnstile> FF;\n        \\<forall>e f g. e,f,g,a # G \\<Turnstile> FF\\<rbrakk>\n       \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> Neg a\n 4. \\<And>G a.\n       \\<lbrakk>G \\<turnstile> Neg a;\n        \\<forall>e f g. e,f,g,G \\<Turnstile> Neg a; G \\<turnstile> a;\n        \\<forall>e f g. e,f,g,G \\<Turnstile> a\\<rbrakk>\n       \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> FF\n 5. \\<And>a G.\n       \\<lbrakk>Neg a # G \\<turnstile> FF;\n        \\<forall>e f g. e,f,g,Neg a # G \\<Turnstile> FF\\<rbrakk>\n       \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> a\n 6. \\<And>G a b.\n       \\<lbrakk>G \\<turnstile> a; \\<forall>e f g. e,f,g,G \\<Turnstile> a;\n        G \\<turnstile> b; \\<forall>e f g. e,f,g,G \\<Turnstile> b\\<rbrakk>\n       \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> And a b\n 7. \\<And>G a b.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<forall>e f g. e,f,g,G \\<Turnstile> And a b\\<rbrakk>\n       \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> a\n 8. \\<And>G a b.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<forall>e f g. e,f,g,G \\<Turnstile> And a b\\<rbrakk>\n       \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> b\n 9. \\<And>G a b.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<forall>e f g. e,f,g,G \\<Turnstile> a\\<rbrakk>\n       \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> Or a b\n 10. \\<And>G b a.\n        \\<lbrakk>G \\<turnstile> b;\n         \\<forall>e f g. e,f,g,G \\<Turnstile> b\\<rbrakk>\n        \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> Or a b\nA total of 16 subgoals...", "case (ExistsE G a n b)"], ["proof (state)\nthis:\n  G \\<turnstile> Exists a\n  \\<forall>e f g. e,f,g,G \\<Turnstile> Exists a\n  a[App n []/0] # G \\<turnstile> b\n  \\<forall>e f g. e,f,g,a[App n []/0] # G \\<Turnstile> b\n  list_all (\\<lambda>p. n \\<notin> params p) G\n  n \\<notin> params a\n  n \\<notin> params b\n\ngoal (16 subgoals):\n 1. \\<And>G. \\<forall>e f g. e,f,g,G \\<Turnstile> TT\n 2. \\<And>G a.\n       \\<lbrakk>G \\<turnstile> FF;\n        \\<forall>e f g. e,f,g,G \\<Turnstile> FF\\<rbrakk>\n       \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> a\n 3. \\<And>a G.\n       \\<lbrakk>a # G \\<turnstile> FF;\n        \\<forall>e f g. e,f,g,a # G \\<Turnstile> FF\\<rbrakk>\n       \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> Neg a\n 4. \\<And>G a.\n       \\<lbrakk>G \\<turnstile> Neg a;\n        \\<forall>e f g. e,f,g,G \\<Turnstile> Neg a; G \\<turnstile> a;\n        \\<forall>e f g. e,f,g,G \\<Turnstile> a\\<rbrakk>\n       \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> FF\n 5. \\<And>a G.\n       \\<lbrakk>Neg a # G \\<turnstile> FF;\n        \\<forall>e f g. e,f,g,Neg a # G \\<Turnstile> FF\\<rbrakk>\n       \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> a\n 6. \\<And>G a b.\n       \\<lbrakk>G \\<turnstile> a; \\<forall>e f g. e,f,g,G \\<Turnstile> a;\n        G \\<turnstile> b; \\<forall>e f g. e,f,g,G \\<Turnstile> b\\<rbrakk>\n       \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> And a b\n 7. \\<And>G a b.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<forall>e f g. e,f,g,G \\<Turnstile> And a b\\<rbrakk>\n       \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> a\n 8. \\<And>G a b.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<forall>e f g. e,f,g,G \\<Turnstile> And a b\\<rbrakk>\n       \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> b\n 9. \\<And>G a b.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<forall>e f g. e,f,g,G \\<Turnstile> a\\<rbrakk>\n       \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> Or a b\n 10. \\<And>G b a.\n        \\<lbrakk>G \\<turnstile> b;\n         \\<forall>e f g. e,f,g,G \\<Turnstile> b\\<rbrakk>\n        \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> Or a b\nA total of 16 subgoals...", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>e f g. e,f,g,G \\<Turnstile> b", "proof (intro allI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e f g. e,f,g,G \\<Turnstile> b", "fix f g and e :: \\<open>nat \\<Rightarrow> 'c\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e f g. e,f,g,G \\<Turnstile> b", "obtain z where \\<open>list_all (eval e f g) G \\<longrightarrow> eval (e\\<langle>0:z\\<rangle>) f g a\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>z.\n        list_all (eval e f g) G \\<longrightarrow>\n        eval (e\\<langle>0:z\\<rangle>) f g a \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using ExistsE"], ["proof (prove)\nusing this:\n  G \\<turnstile> Exists a\n  \\<forall>e f g. e,f,g,G \\<Turnstile> Exists a\n  a[App n []/0] # G \\<turnstile> b\n  \\<forall>e f g. e,f,g,a[App n []/0] # G \\<Turnstile> b\n  list_all (\\<lambda>p. n \\<notin> params p) G\n  n \\<notin> params a\n  n \\<notin> params b\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        list_all (eval e f g) G \\<longrightarrow>\n        eval (e\\<langle>0:z\\<rangle>) f g a \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding model_def"], ["proof (prove)\nusing this:\n  G \\<turnstile> Exists a\n  \\<forall>e f g.\n     list_all (eval e f g) G \\<longrightarrow> eval e f g (Exists a)\n  a[App n []/0] # G \\<turnstile> b\n  \\<forall>e f g.\n     list_all (eval e f g) (a[App n []/0] # G) \\<longrightarrow>\n     eval e f g b\n  list_all (\\<lambda>p. n \\<notin> params p) G\n  n \\<notin> params a\n  n \\<notin> params b\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        list_all (eval e f g) G \\<longrightarrow>\n        eval (e\\<langle>0:z\\<rangle>) f g a \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by simp blast"], ["proof (state)\nthis:\n  list_all (eval e f g) G \\<longrightarrow>\n  eval (e\\<langle>0:z\\<rangle>) f g a\n\ngoal (1 subgoal):\n 1. \\<And>e f g. e,f,g,G \\<Turnstile> b", "then"], ["proof (chain)\npicking this:\n  list_all (eval e f g) G \\<longrightarrow>\n  eval (e\\<langle>0:z\\<rangle>) f g a", "have \\<open>e, (f(n := \\<lambda>x. z)), g, G \\<Turnstile> b\\<close>"], ["proof (prove)\nusing this:\n  list_all (eval e f g) G \\<longrightarrow>\n  eval (e\\<langle>0:z\\<rangle>) f g a\n\ngoal (1 subgoal):\n 1. e,f(n := \\<lambda>x. z),g,G \\<Turnstile> b", "using ExistsE"], ["proof (prove)\nusing this:\n  list_all (eval e f g) G \\<longrightarrow>\n  eval (e\\<langle>0:z\\<rangle>) f g a\n  G \\<turnstile> Exists a\n  \\<forall>e f g. e,f,g,G \\<Turnstile> Exists a\n  a[App n []/0] # G \\<turnstile> b\n  \\<forall>e f g. e,f,g,a[App n []/0] # G \\<Turnstile> b\n  list_all (\\<lambda>p. n \\<notin> params p) G\n  n \\<notin> params a\n  n \\<notin> params b\n\ngoal (1 subgoal):\n 1. e,f(n := \\<lambda>x. z),g,G \\<Turnstile> b", "unfolding model_def"], ["proof (prove)\nusing this:\n  list_all (eval e f g) G \\<longrightarrow>\n  eval (e\\<langle>0:z\\<rangle>) f g a\n  G \\<turnstile> Exists a\n  \\<forall>e f g.\n     list_all (eval e f g) G \\<longrightarrow> eval e f g (Exists a)\n  a[App n []/0] # G \\<turnstile> b\n  \\<forall>e f g.\n     list_all (eval e f g) (a[App n []/0] # G) \\<longrightarrow>\n     eval e f g b\n  list_all (\\<lambda>p. n \\<notin> params p) G\n  n \\<notin> params a\n  n \\<notin> params b\n\ngoal (1 subgoal):\n 1. list_all (eval e (f(n := \\<lambda>x. z)) g) G \\<longrightarrow>\n    eval e (f(n := \\<lambda>x. z)) g b", "by simp"], ["proof (state)\nthis:\n  e,f(n := \\<lambda>x. z),g,G \\<Turnstile> b\n\ngoal (1 subgoal):\n 1. \\<And>e f g. e,f,g,G \\<Turnstile> b", "then"], ["proof (chain)\npicking this:\n  e,f(n := \\<lambda>x. z),g,G \\<Turnstile> b", "show \\<open>e,f,g,G \\<Turnstile> b\\<close>"], ["proof (prove)\nusing this:\n  e,f(n := \\<lambda>x. z),g,G \\<Turnstile> b\n\ngoal (1 subgoal):\n 1. e,f,g,G \\<Turnstile> b", "using ExistsE"], ["proof (prove)\nusing this:\n  e,f(n := \\<lambda>x. z),g,G \\<Turnstile> b\n  G \\<turnstile> Exists a\n  \\<forall>e f g. e,f,g,G \\<Turnstile> Exists a\n  a[App n []/0] # G \\<turnstile> b\n  \\<forall>e f g. e,f,g,a[App n []/0] # G \\<Turnstile> b\n  list_all (\\<lambda>p. n \\<notin> params p) G\n  n \\<notin> params a\n  n \\<notin> params b\n\ngoal (1 subgoal):\n 1. e,f,g,G \\<Turnstile> b", "unfolding model_def"], ["proof (prove)\nusing this:\n  list_all (eval e (f(n := \\<lambda>x. z)) g) G \\<longrightarrow>\n  eval e (f(n := \\<lambda>x. z)) g b\n  G \\<turnstile> Exists a\n  \\<forall>e f g.\n     list_all (eval e f g) G \\<longrightarrow> eval e f g (Exists a)\n  a[App n []/0] # G \\<turnstile> b\n  \\<forall>e f g.\n     list_all (eval e f g) (a[App n []/0] # G) \\<longrightarrow>\n     eval e f g b\n  list_all (\\<lambda>p. n \\<notin> params p) G\n  n \\<notin> params a\n  n \\<notin> params b\n\ngoal (1 subgoal):\n 1. list_all (eval e f g) G \\<longrightarrow> eval e f g b", "by simp"], ["proof (state)\nthis:\n  e,f,g,G \\<Turnstile> b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>e f g. e,f,g,G \\<Turnstile> b\n\ngoal (15 subgoals):\n 1. \\<And>G. \\<forall>e f g. e,f,g,G \\<Turnstile> TT\n 2. \\<And>G a.\n       \\<lbrakk>G \\<turnstile> FF;\n        \\<forall>e f g. e,f,g,G \\<Turnstile> FF\\<rbrakk>\n       \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> a\n 3. \\<And>a G.\n       \\<lbrakk>a # G \\<turnstile> FF;\n        \\<forall>e f g. e,f,g,a # G \\<Turnstile> FF\\<rbrakk>\n       \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> Neg a\n 4. \\<And>G a.\n       \\<lbrakk>G \\<turnstile> Neg a;\n        \\<forall>e f g. e,f,g,G \\<Turnstile> Neg a; G \\<turnstile> a;\n        \\<forall>e f g. e,f,g,G \\<Turnstile> a\\<rbrakk>\n       \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> FF\n 5. \\<And>a G.\n       \\<lbrakk>Neg a # G \\<turnstile> FF;\n        \\<forall>e f g. e,f,g,Neg a # G \\<Turnstile> FF\\<rbrakk>\n       \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> a\n 6. \\<And>G a b.\n       \\<lbrakk>G \\<turnstile> a; \\<forall>e f g. e,f,g,G \\<Turnstile> a;\n        G \\<turnstile> b; \\<forall>e f g. e,f,g,G \\<Turnstile> b\\<rbrakk>\n       \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> And a b\n 7. \\<And>G a b.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<forall>e f g. e,f,g,G \\<Turnstile> And a b\\<rbrakk>\n       \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> a\n 8. \\<And>G a b.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<forall>e f g. e,f,g,G \\<Turnstile> And a b\\<rbrakk>\n       \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> b\n 9. \\<And>G a b.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<forall>e f g. e,f,g,G \\<Turnstile> a\\<rbrakk>\n       \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> Or a b\n 10. \\<And>G b a.\n        \\<lbrakk>G \\<turnstile> b;\n         \\<forall>e f g. e,f,g,G \\<Turnstile> b\\<rbrakk>\n        \\<Longrightarrow> \\<forall>e f g. e,f,g,G \\<Turnstile> Or a b\nA total of 15 subgoals...", "qed (simp_all add: model_def, blast+)"], ["", "section \\<open>Completeness\\<close>"], ["", "text \\<open>\nThe goal of this section is to prove completeness of the natural deduction\ncalculus introduced in \\secref{sec:proof-calculus}. Before we start with the\nactual proof, it is useful to note that the following two formulations of\ncompleteness are equivalent:\n\\begin{enumerate}\n\\item All valid formulae are derivable, i.e.\n  \\<open>ps \\<Turnstile> p \\<Longrightarrow> ps \\<turnstile> p\\<close>\n\\item All consistent sets are satisfiable\n\\end{enumerate}\nThe latter property is called the {\\em model existence theorem}. To see why 2\nimplies 1, observe that \\<open>Neg p, ps \\<notturnstile> FF\\<close> implies\nthat \\<open>Neg p, ps\\<close> is consistent, which, by the model existence theorem,\nimplies that \\<open>Neg p, ps\\<close> has a model, which in turn implies that\n\\<open>ps \\<notTurnstile> p\\<close>. By contraposition, it therefore follows\nfrom \\<open>ps \\<Turnstile> p\\<close> that \\<open>Neg p, ps \\<turnstile> FF\\<close>, which allows us to\ndeduce \\<open>ps \\<turnstile> p\\<close> using rule \\<open>Class\\<close>.\n\nIn most textbooks on logic, a set \\<open>S\\<close> of formulae is called {\\em consistent},\nif no contradiction can be derived from \\<open>S\\<close> using a {\\em specific proof calculus},\ni.e.\\ \\<open>S \\<notturnstile> FF\\<close>. Rather than defining consistency relative to\na {\\em specific} calculus, Fitting uses the more general approach of describing\nproperties that all consistent sets must have (see \\secref{sec:consistent-sets}).\n\nThe key idea behind the proof of the model existence theorem is to\nextend a consistent set to one that is {\\em maximal} (see \\secref{sec:extend}).\nIn order to do this, we use the fact that the set of formulae is enumerable\n(see \\secref{sec:enumeration}), which allows us to form a sequence\n$\\phi_0$, $\\phi_1$, $\\phi_2$, $\\ldots$ containing all formulae.\nWe can then construct a sequence $S_i$ of consistent sets as follows:\n\\[\n\\begin{array}{l}\n  S_0 = S \\\\\n  S_{i+1} = \\left\\{\\begin{array}{ll}\n    S_i \\cup \\{\\phi_i\\} & \\hbox{if } S_i \\cup \\{\\phi_i\\} \\hbox{ consistent} \\\\\n    S_i & \\hbox{otherwise}\n  \\end{array}\\right.\n\\end{array}\n\\]\nTo obtain a maximal consistent set, we form the union $\\bigcup_i S_i$ of these\nsets. To ensure that this union is still consistent, additional closure\n(see \\secref{sec:closure}) and finiteness (see \\secref{sec:finiteness})\nproperties are needed.\nIt can be shown that a maximal consistent set is a {\\em Hintikka set}\n(see \\secref{sec:hintikka}). Hintikka sets are satisfiable in {\\em Herbrand}\nmodels, where closed terms coincide with their interpretation.\n\\<close>"], ["", "subsection \\<open>Consistent sets\\<close>"], ["", "text \\<open>\n\\label{sec:consistent-sets}\nIn this section, we describe an abstract criterion for consistent sets.\nA set of sets of formulae is called a {\\em consistency property}, if the\nfollowing holds:\n\\<close>"], ["", "definition consistency :: \\<open>('a, 'b) form set set \\<Rightarrow> bool\\<close> where\n  \\<open>consistency C = (\\<forall>S. S \\<in> C \\<longrightarrow>\n     (\\<forall>p ts. \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)) \\<and>\n     FF \\<notin> S \\<and> Neg TT \\<notin> S \\<and>\n     (\\<forall>Z. Neg (Neg Z) \\<in> S \\<longrightarrow> S \\<union> {Z} \\<in> C) \\<and>\n     (\\<forall>A B. And A B \\<in> S \\<longrightarrow> S \\<union> {A, B} \\<in> C) \\<and>\n     (\\<forall>A B. Neg (Or A B) \\<in> S \\<longrightarrow> S \\<union> {Neg A, Neg B} \\<in> C) \\<and>\n     (\\<forall>A B. Or A B \\<in> S \\<longrightarrow> S \\<union> {A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B. Neg (And A B) \\<in> S \\<longrightarrow> S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {Neg B} \\<in> C) \\<and>\n     (\\<forall>A B. Impl A B \\<in> S \\<longrightarrow> S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B. Neg (Impl A B) \\<in> S \\<longrightarrow> S \\<union> {A, Neg B} \\<in> C) \\<and>\n     (\\<forall>P t. closedt 0 t \\<longrightarrow> Forall P \\<in> S \\<longrightarrow> S \\<union> {P[t/0]} \\<in> C) \\<and>\n     (\\<forall>P t. closedt 0 t \\<longrightarrow> Neg (Exists P) \\<in> S \\<longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> C) \\<and>\n     (\\<forall>P. Exists P \\<in> S \\<longrightarrow> (\\<exists>x. S \\<union> {P[App x []/0]} \\<in> C)) \\<and>\n     (\\<forall>P. Neg (Forall P) \\<in> S \\<longrightarrow> (\\<exists>x. S \\<union> {Neg (P[App x []/0])} \\<in> C)))\\<close>"], ["", "text \\<open>\nIn \\secref{sec:finiteness}, we will show how to extend a consistency property\nto one that is of {\\em finite character}. However, the above\ndefinition of a consistency property cannot be used for this, since there is\na problem with the treatment of formulae of the form \\<open>Exists P\\<close> and\n\\<open>Neg (Forall P)\\<close>. Fitting therefore suggests to define an {\\em alternative\nconsistency property} as follows:\n\\<close>"], ["", "definition alt_consistency :: \\<open>('a, 'b) form set set \\<Rightarrow> bool\\<close> where\n  \\<open>alt_consistency C = (\\<forall>S. S \\<in> C \\<longrightarrow>\n     (\\<forall>p ts. \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)) \\<and>\n     FF \\<notin> S \\<and> Neg TT \\<notin> S \\<and>\n     (\\<forall>Z. Neg (Neg Z) \\<in> S \\<longrightarrow> S \\<union> {Z} \\<in> C) \\<and>\n     (\\<forall>A B. And A B \\<in> S \\<longrightarrow> S \\<union> {A, B} \\<in> C) \\<and>\n     (\\<forall>A B. Neg (Or A B) \\<in> S \\<longrightarrow> S \\<union> {Neg A, Neg B} \\<in> C) \\<and>\n     (\\<forall>A B. Or A B \\<in> S \\<longrightarrow> S \\<union> {A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B. Neg (And A B) \\<in> S \\<longrightarrow> S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {Neg B} \\<in> C) \\<and>\n     (\\<forall>A B. Impl A B \\<in> S \\<longrightarrow> S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B. Neg (Impl A B) \\<in> S \\<longrightarrow> S \\<union> {A, Neg B} \\<in> C) \\<and>\n     (\\<forall>P t. closedt 0 t \\<longrightarrow> Forall P \\<in> S \\<longrightarrow> S \\<union> {P[t/0]} \\<in> C) \\<and>\n     (\\<forall>P t. closedt 0 t \\<longrightarrow> Neg (Exists P) \\<in> S \\<longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> C) \\<and>\n     (\\<forall>P x. (\\<forall>a \\<in> S. x \\<notin> params a) \\<longrightarrow> Exists P \\<in> S \\<longrightarrow>\n       S \\<union> {P[App x []/0]} \\<in> C) \\<and>\n     (\\<forall>P x. (\\<forall>a \\<in> S. x \\<notin> params a) \\<longrightarrow> Neg (Forall P) \\<in> S \\<longrightarrow>\n       S \\<union> {Neg (P[App x []/0])} \\<in> C))\\<close>"], ["", "text \\<open>\nNote that in the clauses for \\<open>Exists P\\<close> and \\<open>Neg (Forall P)\\<close>,\nthe first definition requires the existence of a parameter \\<open>x\\<close> with a certain\nproperty, whereas the second definition requires that all parameters \\<open>x\\<close> that\nare new for \\<open>S\\<close> have a certain property. A consistency property can easily be\nturned into an alternative consistency property by applying a suitable parameter\nsubstitution:\n\\<close>"], ["", "definition mk_alt_consistency :: \\<open>('a, 'b) form set set \\<Rightarrow> ('a, 'b) form set set\\<close> where\n  \\<open>mk_alt_consistency C = {S. \\<exists>f. psubst f ` S \\<in> C}\\<close>"], ["", "theorem alt_consistency:\n  assumes conc: \\<open>consistency C\\<close>\n  shows \\<open>alt_consistency (mk_alt_consistency C)\\<close> (is \\<open>alt_consistency ?C'\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. alt_consistency (mk_alt_consistency C)", "unfolding alt_consistency_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>S.\n       S \\<in> mk_alt_consistency C \\<longrightarrow>\n       (\\<forall>p ts.\n           \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)) \\<and>\n       FF \\<notin> S \\<and>\n       Neg TT \\<notin> S \\<and>\n       (\\<forall>Z.\n           Neg (Neg Z) \\<in> S \\<longrightarrow>\n           S \\<union> {Z} \\<in> mk_alt_consistency C) \\<and>\n       (\\<forall>A B.\n           And A B \\<in> S \\<longrightarrow>\n           S \\<union> {A, B} \\<in> mk_alt_consistency C) \\<and>\n       (\\<forall>A B.\n           Neg (Or A B) \\<in> S \\<longrightarrow>\n           S \\<union> {Neg A, Neg B} \\<in> mk_alt_consistency C) \\<and>\n       (\\<forall>A B.\n           Or A B \\<in> S \\<longrightarrow>\n           S \\<union> {A} \\<in> mk_alt_consistency C \\<or>\n           S \\<union> {B} \\<in> mk_alt_consistency C) \\<and>\n       (\\<forall>A B.\n           Neg (And A B) \\<in> S \\<longrightarrow>\n           S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n           S \\<union> {Neg B} \\<in> mk_alt_consistency C) \\<and>\n       (\\<forall>A B.\n           Impl A B \\<in> S \\<longrightarrow>\n           S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n           S \\<union> {B} \\<in> mk_alt_consistency C) \\<and>\n       (\\<forall>A B.\n           Neg (Impl A B) \\<in> S \\<longrightarrow>\n           S \\<union> {A, Neg B} \\<in> mk_alt_consistency C) \\<and>\n       (\\<forall>P t.\n           closedt 0 t \\<longrightarrow>\n           Forall P \\<in> S \\<longrightarrow>\n           S \\<union> {P[t/0]} \\<in> mk_alt_consistency C) \\<and>\n       (\\<forall>P t.\n           closedt 0 t \\<longrightarrow>\n           Neg (Exists P) \\<in> S \\<longrightarrow>\n           S \\<union> {Neg (P[t/0])} \\<in> mk_alt_consistency C) \\<and>\n       (\\<forall>P x.\n           (\\<forall>a\\<in>S. x \\<notin> params a) \\<longrightarrow>\n           Exists P \\<in> S \\<longrightarrow>\n           S \\<union> {P[App x []/0]} \\<in> mk_alt_consistency C) \\<and>\n       (\\<forall>P x.\n           (\\<forall>a\\<in>S. x \\<notin> params a) \\<longrightarrow>\n           Neg (Forall P) \\<in> S \\<longrightarrow>\n           S \\<union> {Neg (P[App x []/0])} \\<in> mk_alt_consistency C)", "proof (intro allI impI conjI)"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>S p ts.\n       S \\<in> mk_alt_consistency C \\<Longrightarrow>\n       \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)\n 2. \\<And>S. S \\<in> mk_alt_consistency C \\<Longrightarrow> FF \\<notin> S\n 3. \\<And>S.\n       S \\<in> mk_alt_consistency C \\<Longrightarrow> Neg TT \\<notin> S\n 4. \\<And>S Z.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z} \\<in> mk_alt_consistency C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B} \\<in> mk_alt_consistency C\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> mk_alt_consistency C\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_alt_consistency C\n 9. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 10. \\<And>S A B.\n        \\<lbrakk>S \\<in> mk_alt_consistency C;\n         Neg (Impl A B) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> mk_alt_consistency C\nA total of 14 subgoals...", "fix f :: \\<open>'a \\<Rightarrow> 'a\\<close> and S :: \\<open>('a, 'b) form set\\<close>"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>S p ts.\n       S \\<in> mk_alt_consistency C \\<Longrightarrow>\n       \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)\n 2. \\<And>S. S \\<in> mk_alt_consistency C \\<Longrightarrow> FF \\<notin> S\n 3. \\<And>S.\n       S \\<in> mk_alt_consistency C \\<Longrightarrow> Neg TT \\<notin> S\n 4. \\<And>S Z.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z} \\<in> mk_alt_consistency C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B} \\<in> mk_alt_consistency C\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> mk_alt_consistency C\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_alt_consistency C\n 9. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 10. \\<And>S A B.\n        \\<lbrakk>S \\<in> mk_alt_consistency C;\n         Neg (Impl A B) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> mk_alt_consistency C\nA total of 14 subgoals...", "assume \\<open>S \\<in> mk_alt_consistency C\\<close>"], ["proof (state)\nthis:\n  S \\<in> mk_alt_consistency C\n\ngoal (14 subgoals):\n 1. \\<And>S p ts.\n       S \\<in> mk_alt_consistency C \\<Longrightarrow>\n       \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)\n 2. \\<And>S. S \\<in> mk_alt_consistency C \\<Longrightarrow> FF \\<notin> S\n 3. \\<And>S.\n       S \\<in> mk_alt_consistency C \\<Longrightarrow> Neg TT \\<notin> S\n 4. \\<And>S Z.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z} \\<in> mk_alt_consistency C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B} \\<in> mk_alt_consistency C\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> mk_alt_consistency C\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_alt_consistency C\n 9. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 10. \\<And>S A B.\n        \\<lbrakk>S \\<in> mk_alt_consistency C;\n         Neg (Impl A B) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> mk_alt_consistency C\nA total of 14 subgoals...", "then"], ["proof (chain)\npicking this:\n  S \\<in> mk_alt_consistency C", "obtain f where sc: \\<open>psubst f ` S \\<in> C\\<close> (is \\<open>?S' \\<in> C\\<close>)"], ["proof (prove)\nusing this:\n  S \\<in> mk_alt_consistency C\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        psubst f ` S \\<in> C \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding mk_alt_consistency_def"], ["proof (prove)\nusing this:\n  S \\<in> {S. \\<exists>f. psubst f ` S \\<in> C}\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        psubst f ` S \\<in> C \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  psubst f ` S \\<in> C\n\ngoal (14 subgoals):\n 1. \\<And>S p ts.\n       S \\<in> mk_alt_consistency C \\<Longrightarrow>\n       \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)\n 2. \\<And>S. S \\<in> mk_alt_consistency C \\<Longrightarrow> FF \\<notin> S\n 3. \\<And>S.\n       S \\<in> mk_alt_consistency C \\<Longrightarrow> Neg TT \\<notin> S\n 4. \\<And>S Z.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z} \\<in> mk_alt_consistency C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B} \\<in> mk_alt_consistency C\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> mk_alt_consistency C\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_alt_consistency C\n 9. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 10. \\<And>S A B.\n        \\<lbrakk>S \\<in> mk_alt_consistency C;\n         Neg (Impl A B) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> mk_alt_consistency C\nA total of 14 subgoals...", "fix p ts"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>S p ts.\n       S \\<in> mk_alt_consistency C \\<Longrightarrow>\n       \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)\n 2. \\<And>S. S \\<in> mk_alt_consistency C \\<Longrightarrow> FF \\<notin> S\n 3. \\<And>S.\n       S \\<in> mk_alt_consistency C \\<Longrightarrow> Neg TT \\<notin> S\n 4. \\<And>S Z.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z} \\<in> mk_alt_consistency C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B} \\<in> mk_alt_consistency C\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> mk_alt_consistency C\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_alt_consistency C\n 9. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 10. \\<And>S A B.\n        \\<lbrakk>S \\<in> mk_alt_consistency C;\n         Neg (Impl A B) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> mk_alt_consistency C\nA total of 14 subgoals...", "show \\<open>\\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S \\<Longrightarrow> False", "assume *: \\<open>Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S\\<close>"], ["proof (state)\nthis:\n  Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S\n\ngoal (1 subgoal):\n 1. Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S", "have \\<open>psubst f (Pred p ts) \\<in> ?S'\\<close>"], ["proof (prove)\nusing this:\n  Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S\n\ngoal (1 subgoal):\n 1. psubst f (Pred p ts) \\<in> psubst f ` S", "by blast"], ["proof (state)\nthis:\n  psubst f (Pred p ts) \\<in> psubst f ` S\n\ngoal (1 subgoal):\n 1. Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  psubst f (Pred p ts) \\<in> psubst f ` S", "have \\<open>Pred p (psubstts f ts) \\<in> ?S'\\<close>"], ["proof (prove)\nusing this:\n  psubst f (Pred p ts) \\<in> psubst f ` S\n\ngoal (1 subgoal):\n 1. Pred p (psubstts f ts) \\<in> psubst f ` S", "by simp"], ["proof (state)\nthis:\n  Pred p (psubstts f ts) \\<in> psubst f ` S\n\ngoal (1 subgoal):\n 1. Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  Pred p (psubstts f ts) \\<in> psubst f ` S", "have \\<open>Neg (Pred p (psubstts f ts)) \\<notin> ?S'\\<close>"], ["proof (prove)\nusing this:\n  Pred p (psubstts f ts) \\<in> psubst f ` S\n\ngoal (1 subgoal):\n 1. Neg (Pred p (psubstts f ts)) \\<notin> psubst f ` S", "using conc sc"], ["proof (prove)\nusing this:\n  Pred p (psubstts f ts) \\<in> psubst f ` S\n  consistency C\n  psubst f ` S \\<in> C\n\ngoal (1 subgoal):\n 1. Neg (Pred p (psubstts f ts)) \\<notin> psubst f ` S", "by (simp add: consistency_def)"], ["proof (state)\nthis:\n  Neg (Pred p (psubstts f ts)) \\<notin> psubst f ` S\n\ngoal (1 subgoal):\n 1. Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  Neg (Pred p (psubstts f ts)) \\<notin> psubst f ` S", "have \\<open>Neg (Pred p ts) \\<notin> S\\<close>"], ["proof (prove)\nusing this:\n  Neg (Pred p (psubstts f ts)) \\<notin> psubst f ` S\n\ngoal (1 subgoal):\n 1. Neg (Pred p ts) \\<notin> S", "by force"], ["proof (state)\nthis:\n  Neg (Pred p ts) \\<notin> S\n\ngoal (1 subgoal):\n 1. Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  Neg (Pred p ts) \\<notin> S", "show False"], ["proof (prove)\nusing this:\n  Neg (Pred p ts) \\<notin> S\n\ngoal (1 subgoal):\n 1. False", "using *"], ["proof (prove)\nusing this:\n  Neg (Pred p ts) \\<notin> S\n  Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)\n\ngoal (13 subgoals):\n 1. \\<And>S. S \\<in> mk_alt_consistency C \\<Longrightarrow> FF \\<notin> S\n 2. \\<And>S.\n       S \\<in> mk_alt_consistency C \\<Longrightarrow> Neg TT \\<notin> S\n 3. \\<And>S Z.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z} \\<in> mk_alt_consistency C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B} \\<in> mk_alt_consistency C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> mk_alt_consistency C\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_alt_consistency C\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 9. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> mk_alt_consistency C\n 10. \\<And>S P t.\n        \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n         Forall P \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_alt_consistency C\nA total of 13 subgoals...", "have \\<open>FF \\<notin> ?S'\\<close> and \\<open>Neg TT \\<notin> ?S'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. FF \\<notin> psubst f ` S &&& Neg TT \\<notin> psubst f ` S", "using conc sc"], ["proof (prove)\nusing this:\n  consistency C\n  psubst f ` S \\<in> C\n\ngoal (1 subgoal):\n 1. FF \\<notin> psubst f ` S &&& Neg TT \\<notin> psubst f ` S", "unfolding consistency_def"], ["proof (prove)\nusing this:\n  \\<forall>S.\n     S \\<in> C \\<longrightarrow>\n     (\\<forall>p ts.\n         \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)) \\<and>\n     FF \\<notin> S \\<and>\n     Neg TT \\<notin> S \\<and>\n     (\\<forall>Z.\n         Neg (Neg Z) \\<in> S \\<longrightarrow>\n         S \\<union> {Z} \\<in> C) \\<and>\n     (\\<forall>A B.\n         And A B \\<in> S \\<longrightarrow> S \\<union> {A, B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Or A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A, Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Or A B \\<in> S \\<longrightarrow>\n         S \\<union> {A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (And A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Impl A B \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Impl A B) \\<in> S \\<longrightarrow>\n         S \\<union> {A, Neg B} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Forall P \\<in> S \\<longrightarrow>\n         S \\<union> {P[t/0]} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Neg (Exists P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[t/0])} \\<in> C) \\<and>\n     (\\<forall>P.\n         Exists P \\<in> S \\<longrightarrow>\n         (\\<exists>x. S \\<union> {P[App x []/0]} \\<in> C)) \\<and>\n     (\\<forall>P.\n         Neg (Forall P) \\<in> S \\<longrightarrow>\n         (\\<exists>x. S \\<union> {Neg (P[App x []/0])} \\<in> C))\n  psubst f ` S \\<in> C\n\ngoal (1 subgoal):\n 1. FF \\<notin> psubst f ` S &&& Neg TT \\<notin> psubst f ` S", "by simp_all"], ["proof (state)\nthis:\n  FF \\<notin> psubst f ` S\n  Neg TT \\<notin> psubst f ` S\n\ngoal (13 subgoals):\n 1. \\<And>S. S \\<in> mk_alt_consistency C \\<Longrightarrow> FF \\<notin> S\n 2. \\<And>S.\n       S \\<in> mk_alt_consistency C \\<Longrightarrow> Neg TT \\<notin> S\n 3. \\<And>S Z.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z} \\<in> mk_alt_consistency C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B} \\<in> mk_alt_consistency C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> mk_alt_consistency C\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_alt_consistency C\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 9. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> mk_alt_consistency C\n 10. \\<And>S P t.\n        \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n         Forall P \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_alt_consistency C\nA total of 13 subgoals...", "then"], ["proof (chain)\npicking this:\n  FF \\<notin> psubst f ` S\n  Neg TT \\<notin> psubst f ` S", "show \\<open>FF \\<notin> S\\<close> and \\<open>Neg TT \\<notin> S\\<close>"], ["proof (prove)\nusing this:\n  FF \\<notin> psubst f ` S\n  Neg TT \\<notin> psubst f ` S\n\ngoal (1 subgoal):\n 1. FF \\<notin> S &&& Neg TT \\<notin> S", "by (force, force)"], ["proof (state)\nthis:\n  FF \\<notin> S\n  Neg TT \\<notin> S\n\ngoal (11 subgoals):\n 1. \\<And>S Z.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z} \\<in> mk_alt_consistency C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B} \\<in> mk_alt_consistency C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> mk_alt_consistency C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_alt_consistency C\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> mk_alt_consistency C\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_alt_consistency C\n 9. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> mk_alt_consistency C\n 10. \\<And>S P x.\n        \\<lbrakk>S \\<in> mk_alt_consistency C;\n         \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                          \\<in> mk_alt_consistency C\nA total of 11 subgoals...", "{"], ["proof (state)\nthis:\n  FF \\<notin> S\n  Neg TT \\<notin> S\n\ngoal (11 subgoals):\n 1. \\<And>S Z.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z} \\<in> mk_alt_consistency C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B} \\<in> mk_alt_consistency C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> mk_alt_consistency C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_alt_consistency C\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> mk_alt_consistency C\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_alt_consistency C\n 9. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> mk_alt_consistency C\n 10. \\<And>S P x.\n        \\<lbrakk>S \\<in> mk_alt_consistency C;\n         \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                          \\<in> mk_alt_consistency C\nA total of 11 subgoals...", "fix Z"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>S Z.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z} \\<in> mk_alt_consistency C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B} \\<in> mk_alt_consistency C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> mk_alt_consistency C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_alt_consistency C\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> mk_alt_consistency C\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_alt_consistency C\n 9. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> mk_alt_consistency C\n 10. \\<And>S P x.\n        \\<lbrakk>S \\<in> mk_alt_consistency C;\n         \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                          \\<in> mk_alt_consistency C\nA total of 11 subgoals...", "assume \\<open>Neg (Neg Z) \\<in> S\\<close>"], ["proof (state)\nthis:\n  Neg (Neg Z) \\<in> S\n\ngoal (11 subgoals):\n 1. \\<And>S Z.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z} \\<in> mk_alt_consistency C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B} \\<in> mk_alt_consistency C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> mk_alt_consistency C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_alt_consistency C\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> mk_alt_consistency C\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_alt_consistency C\n 9. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> mk_alt_consistency C\n 10. \\<And>S P x.\n        \\<lbrakk>S \\<in> mk_alt_consistency C;\n         \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                          \\<in> mk_alt_consistency C\nA total of 11 subgoals...", "then"], ["proof (chain)\npicking this:\n  Neg (Neg Z) \\<in> S", "have \\<open>psubst f (Neg (Neg Z)) \\<in> ?S'\\<close>"], ["proof (prove)\nusing this:\n  Neg (Neg Z) \\<in> S\n\ngoal (1 subgoal):\n 1. psubst f (Neg (Neg Z)) \\<in> psubst f ` S", "by blast"], ["proof (state)\nthis:\n  psubst f (Neg (Neg Z)) \\<in> psubst f ` S\n\ngoal (11 subgoals):\n 1. \\<And>S Z.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z} \\<in> mk_alt_consistency C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B} \\<in> mk_alt_consistency C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> mk_alt_consistency C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_alt_consistency C\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> mk_alt_consistency C\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_alt_consistency C\n 9. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> mk_alt_consistency C\n 10. \\<And>S P x.\n        \\<lbrakk>S \\<in> mk_alt_consistency C;\n         \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                          \\<in> mk_alt_consistency C\nA total of 11 subgoals...", "then"], ["proof (chain)\npicking this:\n  psubst f (Neg (Neg Z)) \\<in> psubst f ` S", "have \\<open>?S' \\<union> {psubst f Z} \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  psubst f (Neg (Neg Z)) \\<in> psubst f ` S\n\ngoal (1 subgoal):\n 1. psubst f ` S \\<union> {psubst f Z} \\<in> C", "using conc sc"], ["proof (prove)\nusing this:\n  psubst f (Neg (Neg Z)) \\<in> psubst f ` S\n  consistency C\n  psubst f ` S \\<in> C\n\ngoal (1 subgoal):\n 1. psubst f ` S \\<union> {psubst f Z} \\<in> C", "by (simp add: consistency_def)"], ["proof (state)\nthis:\n  psubst f ` S \\<union> {psubst f Z} \\<in> C\n\ngoal (11 subgoals):\n 1. \\<And>S Z.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z} \\<in> mk_alt_consistency C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B} \\<in> mk_alt_consistency C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> mk_alt_consistency C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_alt_consistency C\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> mk_alt_consistency C\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_alt_consistency C\n 9. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> mk_alt_consistency C\n 10. \\<And>S P x.\n        \\<lbrakk>S \\<in> mk_alt_consistency C;\n         \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                          \\<in> mk_alt_consistency C\nA total of 11 subgoals...", "then"], ["proof (chain)\npicking this:\n  psubst f ` S \\<union> {psubst f Z} \\<in> C", "show \\<open>S \\<union> {Z} \\<in> ?C'\\<close>"], ["proof (prove)\nusing this:\n  psubst f ` S \\<union> {psubst f Z} \\<in> C\n\ngoal (1 subgoal):\n 1. S \\<union> {Z} \\<in> mk_alt_consistency C", "unfolding mk_alt_consistency_def"], ["proof (prove)\nusing this:\n  psubst f ` S \\<union> {psubst f Z} \\<in> C\n\ngoal (1 subgoal):\n 1. S \\<union> {Z} \\<in> {S. \\<exists>f. psubst f ` S \\<in> C}", "by auto"], ["proof (state)\nthis:\n  S \\<union> {Z} \\<in> mk_alt_consistency C\n\ngoal (10 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B} \\<in> mk_alt_consistency C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> mk_alt_consistency C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_alt_consistency C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> mk_alt_consistency C\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_alt_consistency C\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> mk_alt_consistency C\n 9. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                         \\<in> mk_alt_consistency C\n 10. \\<And>S P x.\n        \\<lbrakk>S \\<in> mk_alt_consistency C;\n         \\<forall>a\\<in>S. x \\<notin> params a;\n         Neg (Forall P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                          \\<in> mk_alt_consistency C", "}"], ["proof (state)\nthis:\n  Neg (Neg ?Z2) \\<in> S \\<Longrightarrow>\n  S \\<union> {?Z2} \\<in> mk_alt_consistency C\n\ngoal (10 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B} \\<in> mk_alt_consistency C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> mk_alt_consistency C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_alt_consistency C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> mk_alt_consistency C\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_alt_consistency C\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> mk_alt_consistency C\n 9. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                         \\<in> mk_alt_consistency C\n 10. \\<And>S P x.\n        \\<lbrakk>S \\<in> mk_alt_consistency C;\n         \\<forall>a\\<in>S. x \\<notin> params a;\n         Neg (Forall P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                          \\<in> mk_alt_consistency C", "{"], ["proof (state)\nthis:\n  Neg (Neg ?Z2) \\<in> S \\<Longrightarrow>\n  S \\<union> {?Z2} \\<in> mk_alt_consistency C\n\ngoal (10 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B} \\<in> mk_alt_consistency C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> mk_alt_consistency C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_alt_consistency C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> mk_alt_consistency C\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_alt_consistency C\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> mk_alt_consistency C\n 9. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                         \\<in> mk_alt_consistency C\n 10. \\<And>S P x.\n        \\<lbrakk>S \\<in> mk_alt_consistency C;\n         \\<forall>a\\<in>S. x \\<notin> params a;\n         Neg (Forall P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                          \\<in> mk_alt_consistency C", "fix A B"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B} \\<in> mk_alt_consistency C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> mk_alt_consistency C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_alt_consistency C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> mk_alt_consistency C\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_alt_consistency C\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> mk_alt_consistency C\n 9. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                         \\<in> mk_alt_consistency C\n 10. \\<And>S P x.\n        \\<lbrakk>S \\<in> mk_alt_consistency C;\n         \\<forall>a\\<in>S. x \\<notin> params a;\n         Neg (Forall P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                          \\<in> mk_alt_consistency C", "assume \\<open>And A B \\<in> S\\<close>"], ["proof (state)\nthis:\n  And A B \\<in> S\n\ngoal (10 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B} \\<in> mk_alt_consistency C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> mk_alt_consistency C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_alt_consistency C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> mk_alt_consistency C\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_alt_consistency C\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> mk_alt_consistency C\n 9. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                         \\<in> mk_alt_consistency C\n 10. \\<And>S P x.\n        \\<lbrakk>S \\<in> mk_alt_consistency C;\n         \\<forall>a\\<in>S. x \\<notin> params a;\n         Neg (Forall P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                          \\<in> mk_alt_consistency C", "then"], ["proof (chain)\npicking this:\n  And A B \\<in> S", "have \\<open>psubst f (And A B) \\<in> ?S'\\<close>"], ["proof (prove)\nusing this:\n  And A B \\<in> S\n\ngoal (1 subgoal):\n 1. psubst f (And A B) \\<in> psubst f ` S", "by blast"], ["proof (state)\nthis:\n  psubst f (And A B) \\<in> psubst f ` S\n\ngoal (10 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B} \\<in> mk_alt_consistency C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> mk_alt_consistency C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_alt_consistency C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> mk_alt_consistency C\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_alt_consistency C\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> mk_alt_consistency C\n 9. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                         \\<in> mk_alt_consistency C\n 10. \\<And>S P x.\n        \\<lbrakk>S \\<in> mk_alt_consistency C;\n         \\<forall>a\\<in>S. x \\<notin> params a;\n         Neg (Forall P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                          \\<in> mk_alt_consistency C", "then"], ["proof (chain)\npicking this:\n  psubst f (And A B) \\<in> psubst f ` S", "have \\<open>?S' \\<union> {psubst f A, psubst f B} \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  psubst f (And A B) \\<in> psubst f ` S\n\ngoal (1 subgoal):\n 1. psubst f ` S \\<union> {psubst f A, psubst f B} \\<in> C", "using conc sc"], ["proof (prove)\nusing this:\n  psubst f (And A B) \\<in> psubst f ` S\n  consistency C\n  psubst f ` S \\<in> C\n\ngoal (1 subgoal):\n 1. psubst f ` S \\<union> {psubst f A, psubst f B} \\<in> C", "by (simp add: consistency_def)"], ["proof (state)\nthis:\n  psubst f ` S \\<union> {psubst f A, psubst f B} \\<in> C\n\ngoal (10 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B} \\<in> mk_alt_consistency C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> mk_alt_consistency C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_alt_consistency C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> mk_alt_consistency C\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_alt_consistency C\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> mk_alt_consistency C\n 9. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                         \\<in> mk_alt_consistency C\n 10. \\<And>S P x.\n        \\<lbrakk>S \\<in> mk_alt_consistency C;\n         \\<forall>a\\<in>S. x \\<notin> params a;\n         Neg (Forall P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                          \\<in> mk_alt_consistency C", "then"], ["proof (chain)\npicking this:\n  psubst f ` S \\<union> {psubst f A, psubst f B} \\<in> C", "show \\<open>S \\<union> {A, B} \\<in> ?C'\\<close>"], ["proof (prove)\nusing this:\n  psubst f ` S \\<union> {psubst f A, psubst f B} \\<in> C\n\ngoal (1 subgoal):\n 1. S \\<union> {A, B} \\<in> mk_alt_consistency C", "unfolding mk_alt_consistency_def"], ["proof (prove)\nusing this:\n  psubst f ` S \\<union> {psubst f A, psubst f B} \\<in> C\n\ngoal (1 subgoal):\n 1. S \\<union> {A, B} \\<in> {S. \\<exists>f. psubst f ` S \\<in> C}", "by auto"], ["proof (state)\nthis:\n  S \\<union> {A, B} \\<in> mk_alt_consistency C\n\ngoal (9 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> mk_alt_consistency C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_alt_consistency C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> mk_alt_consistency C\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_alt_consistency C\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> mk_alt_consistency C\n 8. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                         \\<in> mk_alt_consistency C\n 9. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "}"], ["proof (state)\nthis:\n  And ?A2 ?B2 \\<in> S \\<Longrightarrow>\n  S \\<union> {?A2, ?B2} \\<in> mk_alt_consistency C\n\ngoal (9 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> mk_alt_consistency C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_alt_consistency C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> mk_alt_consistency C\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_alt_consistency C\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> mk_alt_consistency C\n 8. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                         \\<in> mk_alt_consistency C\n 9. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "{"], ["proof (state)\nthis:\n  And ?A2 ?B2 \\<in> S \\<Longrightarrow>\n  S \\<union> {?A2, ?B2} \\<in> mk_alt_consistency C\n\ngoal (9 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> mk_alt_consistency C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_alt_consistency C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> mk_alt_consistency C\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_alt_consistency C\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> mk_alt_consistency C\n 8. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                         \\<in> mk_alt_consistency C\n 9. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "fix A B"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> mk_alt_consistency C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_alt_consistency C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> mk_alt_consistency C\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_alt_consistency C\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> mk_alt_consistency C\n 8. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                         \\<in> mk_alt_consistency C\n 9. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "assume \\<open>Neg (Or A B) \\<in> S\\<close>"], ["proof (state)\nthis:\n  Neg (Or A B) \\<in> S\n\ngoal (9 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> mk_alt_consistency C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_alt_consistency C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> mk_alt_consistency C\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_alt_consistency C\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> mk_alt_consistency C\n 8. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                         \\<in> mk_alt_consistency C\n 9. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "then"], ["proof (chain)\npicking this:\n  Neg (Or A B) \\<in> S", "have \\<open>psubst f (Neg (Or A B)) \\<in> ?S'\\<close>"], ["proof (prove)\nusing this:\n  Neg (Or A B) \\<in> S\n\ngoal (1 subgoal):\n 1. psubst f (Neg (Or A B)) \\<in> psubst f ` S", "by blast"], ["proof (state)\nthis:\n  psubst f (Neg (Or A B)) \\<in> psubst f ` S\n\ngoal (9 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> mk_alt_consistency C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_alt_consistency C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> mk_alt_consistency C\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_alt_consistency C\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> mk_alt_consistency C\n 8. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                         \\<in> mk_alt_consistency C\n 9. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "then"], ["proof (chain)\npicking this:\n  psubst f (Neg (Or A B)) \\<in> psubst f ` S", "have \\<open>?S' \\<union> {Neg (psubst f A), Neg (psubst f B)} \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  psubst f (Neg (Or A B)) \\<in> psubst f ` S\n\ngoal (1 subgoal):\n 1. psubst f ` S \\<union> {Neg (psubst f A), Neg (psubst f B)} \\<in> C", "using conc sc"], ["proof (prove)\nusing this:\n  psubst f (Neg (Or A B)) \\<in> psubst f ` S\n  consistency C\n  psubst f ` S \\<in> C\n\ngoal (1 subgoal):\n 1. psubst f ` S \\<union> {Neg (psubst f A), Neg (psubst f B)} \\<in> C", "by (simp add: consistency_def)"], ["proof (state)\nthis:\n  psubst f ` S \\<union> {Neg (psubst f A), Neg (psubst f B)} \\<in> C\n\ngoal (9 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> mk_alt_consistency C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_alt_consistency C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> mk_alt_consistency C\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_alt_consistency C\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> mk_alt_consistency C\n 8. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                         \\<in> mk_alt_consistency C\n 9. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "then"], ["proof (chain)\npicking this:\n  psubst f ` S \\<union> {Neg (psubst f A), Neg (psubst f B)} \\<in> C", "show \\<open>S \\<union> {Neg A, Neg B} \\<in> ?C'\\<close>"], ["proof (prove)\nusing this:\n  psubst f ` S \\<union> {Neg (psubst f A), Neg (psubst f B)} \\<in> C\n\ngoal (1 subgoal):\n 1. S \\<union> {Neg A, Neg B} \\<in> mk_alt_consistency C", "unfolding mk_alt_consistency_def"], ["proof (prove)\nusing this:\n  psubst f ` S \\<union> {Neg (psubst f A), Neg (psubst f B)} \\<in> C\n\ngoal (1 subgoal):\n 1. S \\<union> {Neg A, Neg B} \\<in> {S. \\<exists>f. psubst f ` S \\<in> C}", "by auto"], ["proof (state)\nthis:\n  S \\<union> {Neg A, Neg B} \\<in> mk_alt_consistency C\n\ngoal (8 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_alt_consistency C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> mk_alt_consistency C\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_alt_consistency C\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> mk_alt_consistency C\n 7. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                         \\<in> mk_alt_consistency C\n 8. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "}"], ["proof (state)\nthis:\n  Neg (Or ?A2 ?B2) \\<in> S \\<Longrightarrow>\n  S \\<union> {Neg ?A2, Neg ?B2} \\<in> mk_alt_consistency C\n\ngoal (8 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_alt_consistency C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> mk_alt_consistency C\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_alt_consistency C\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> mk_alt_consistency C\n 7. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                         \\<in> mk_alt_consistency C\n 8. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "{"], ["proof (state)\nthis:\n  Neg (Or ?A2 ?B2) \\<in> S \\<Longrightarrow>\n  S \\<union> {Neg ?A2, Neg ?B2} \\<in> mk_alt_consistency C\n\ngoal (8 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_alt_consistency C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> mk_alt_consistency C\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_alt_consistency C\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> mk_alt_consistency C\n 7. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                         \\<in> mk_alt_consistency C\n 8. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "fix A B"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_alt_consistency C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> mk_alt_consistency C\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_alt_consistency C\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> mk_alt_consistency C\n 7. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                         \\<in> mk_alt_consistency C\n 8. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "assume \\<open>Neg (Impl A B) \\<in> S\\<close>"], ["proof (state)\nthis:\n  Neg (Impl A B) \\<in> S\n\ngoal (8 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_alt_consistency C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> mk_alt_consistency C\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_alt_consistency C\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> mk_alt_consistency C\n 7. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                         \\<in> mk_alt_consistency C\n 8. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "then"], ["proof (chain)\npicking this:\n  Neg (Impl A B) \\<in> S", "have \\<open>psubst f (Neg (Impl A B)) \\<in> ?S'\\<close>"], ["proof (prove)\nusing this:\n  Neg (Impl A B) \\<in> S\n\ngoal (1 subgoal):\n 1. psubst f (Neg (Impl A B)) \\<in> psubst f ` S", "by blast"], ["proof (state)\nthis:\n  psubst f (Neg (Impl A B)) \\<in> psubst f ` S\n\ngoal (8 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_alt_consistency C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> mk_alt_consistency C\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_alt_consistency C\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> mk_alt_consistency C\n 7. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                         \\<in> mk_alt_consistency C\n 8. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "then"], ["proof (chain)\npicking this:\n  psubst f (Neg (Impl A B)) \\<in> psubst f ` S", "have \\<open>?S' \\<union> {psubst f A, Neg (psubst f B)} \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  psubst f (Neg (Impl A B)) \\<in> psubst f ` S\n\ngoal (1 subgoal):\n 1. psubst f ` S \\<union> {psubst f A, Neg (psubst f B)} \\<in> C", "using conc sc"], ["proof (prove)\nusing this:\n  psubst f (Neg (Impl A B)) \\<in> psubst f ` S\n  consistency C\n  psubst f ` S \\<in> C\n\ngoal (1 subgoal):\n 1. psubst f ` S \\<union> {psubst f A, Neg (psubst f B)} \\<in> C", "by (simp add: consistency_def)"], ["proof (state)\nthis:\n  psubst f ` S \\<union> {psubst f A, Neg (psubst f B)} \\<in> C\n\ngoal (8 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_alt_consistency C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> mk_alt_consistency C\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_alt_consistency C\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> mk_alt_consistency C\n 7. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                         \\<in> mk_alt_consistency C\n 8. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "then"], ["proof (chain)\npicking this:\n  psubst f ` S \\<union> {psubst f A, Neg (psubst f B)} \\<in> C", "show \\<open>S \\<union> {A, Neg B} \\<in> ?C'\\<close>"], ["proof (prove)\nusing this:\n  psubst f ` S \\<union> {psubst f A, Neg (psubst f B)} \\<in> C\n\ngoal (1 subgoal):\n 1. S \\<union> {A, Neg B} \\<in> mk_alt_consistency C", "unfolding mk_alt_consistency_def"], ["proof (prove)\nusing this:\n  psubst f ` S \\<union> {psubst f A, Neg (psubst f B)} \\<in> C\n\ngoal (1 subgoal):\n 1. S \\<union> {A, Neg B} \\<in> {S. \\<exists>f. psubst f ` S \\<in> C}", "by auto"], ["proof (state)\nthis:\n  S \\<union> {A, Neg B} \\<in> mk_alt_consistency C\n\ngoal (7 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_alt_consistency C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_alt_consistency C\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> mk_alt_consistency C\n 6. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                         \\<in> mk_alt_consistency C\n 7. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "}"], ["proof (state)\nthis:\n  Neg (Impl ?A2 ?B2) \\<in> S \\<Longrightarrow>\n  S \\<union> {?A2, Neg ?B2} \\<in> mk_alt_consistency C\n\ngoal (7 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_alt_consistency C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_alt_consistency C\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> mk_alt_consistency C\n 6. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                         \\<in> mk_alt_consistency C\n 7. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "{"], ["proof (state)\nthis:\n  Neg (Impl ?A2 ?B2) \\<in> S \\<Longrightarrow>\n  S \\<union> {?A2, Neg ?B2} \\<in> mk_alt_consistency C\n\ngoal (7 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_alt_consistency C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_alt_consistency C\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> mk_alt_consistency C\n 6. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                         \\<in> mk_alt_consistency C\n 7. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "fix A B"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_alt_consistency C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_alt_consistency C\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> mk_alt_consistency C\n 6. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                         \\<in> mk_alt_consistency C\n 7. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "assume \\<open>Or A B \\<in> S\\<close>"], ["proof (state)\nthis:\n  Or A B \\<in> S\n\ngoal (7 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_alt_consistency C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_alt_consistency C\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> mk_alt_consistency C\n 6. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                         \\<in> mk_alt_consistency C\n 7. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "then"], ["proof (chain)\npicking this:\n  Or A B \\<in> S", "have \\<open>psubst f (Or A B) \\<in> ?S'\\<close>"], ["proof (prove)\nusing this:\n  Or A B \\<in> S\n\ngoal (1 subgoal):\n 1. psubst f (Or A B) \\<in> psubst f ` S", "by blast"], ["proof (state)\nthis:\n  psubst f (Or A B) \\<in> psubst f ` S\n\ngoal (7 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_alt_consistency C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_alt_consistency C\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> mk_alt_consistency C\n 6. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                         \\<in> mk_alt_consistency C\n 7. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "then"], ["proof (chain)\npicking this:\n  psubst f (Or A B) \\<in> psubst f ` S", "have \\<open>?S' \\<union> {psubst f A} \\<in> C \\<or> ?S' \\<union> {psubst f B} \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  psubst f (Or A B) \\<in> psubst f ` S\n\ngoal (1 subgoal):\n 1. psubst f ` S \\<union> {psubst f A} \\<in> C \\<or>\n    psubst f ` S \\<union> {psubst f B} \\<in> C", "using conc sc"], ["proof (prove)\nusing this:\n  psubst f (Or A B) \\<in> psubst f ` S\n  consistency C\n  psubst f ` S \\<in> C\n\ngoal (1 subgoal):\n 1. psubst f ` S \\<union> {psubst f A} \\<in> C \\<or>\n    psubst f ` S \\<union> {psubst f B} \\<in> C", "by (simp add: consistency_def)"], ["proof (state)\nthis:\n  psubst f ` S \\<union> {psubst f A} \\<in> C \\<or>\n  psubst f ` S \\<union> {psubst f B} \\<in> C\n\ngoal (7 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_alt_consistency C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_alt_consistency C\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> mk_alt_consistency C\n 6. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                         \\<in> mk_alt_consistency C\n 7. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "then"], ["proof (chain)\npicking this:\n  psubst f ` S \\<union> {psubst f A} \\<in> C \\<or>\n  psubst f ` S \\<union> {psubst f B} \\<in> C", "show \\<open>S \\<union> {A} \\<in> ?C' \\<or> S \\<union> {B} \\<in> ?C'\\<close>"], ["proof (prove)\nusing this:\n  psubst f ` S \\<union> {psubst f A} \\<in> C \\<or>\n  psubst f ` S \\<union> {psubst f B} \\<in> C\n\ngoal (1 subgoal):\n 1. S \\<union> {A} \\<in> mk_alt_consistency C \\<or>\n    S \\<union> {B} \\<in> mk_alt_consistency C", "unfolding mk_alt_consistency_def"], ["proof (prove)\nusing this:\n  psubst f ` S \\<union> {psubst f A} \\<in> C \\<or>\n  psubst f ` S \\<union> {psubst f B} \\<in> C\n\ngoal (1 subgoal):\n 1. S \\<union> {A} \\<in> {S. \\<exists>f. psubst f ` S \\<in> C} \\<or>\n    S \\<union> {B} \\<in> {S. \\<exists>f. psubst f ` S \\<in> C}", "by auto"], ["proof (state)\nthis:\n  S \\<union> {A} \\<in> mk_alt_consistency C \\<or>\n  S \\<union> {B} \\<in> mk_alt_consistency C\n\ngoal (6 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_alt_consistency C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_alt_consistency C\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> mk_alt_consistency C\n 5. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                         \\<in> mk_alt_consistency C\n 6. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "}"], ["proof (state)\nthis:\n  Or ?A2 ?B2 \\<in> S \\<Longrightarrow>\n  S \\<union> {?A2} \\<in> mk_alt_consistency C \\<or>\n  S \\<union> {?B2} \\<in> mk_alt_consistency C\n\ngoal (6 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_alt_consistency C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_alt_consistency C\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> mk_alt_consistency C\n 5. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                         \\<in> mk_alt_consistency C\n 6. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "{"], ["proof (state)\nthis:\n  Or ?A2 ?B2 \\<in> S \\<Longrightarrow>\n  S \\<union> {?A2} \\<in> mk_alt_consistency C \\<or>\n  S \\<union> {?B2} \\<in> mk_alt_consistency C\n\ngoal (6 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_alt_consistency C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_alt_consistency C\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> mk_alt_consistency C\n 5. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                         \\<in> mk_alt_consistency C\n 6. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "fix A B"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_alt_consistency C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_alt_consistency C\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> mk_alt_consistency C\n 5. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                         \\<in> mk_alt_consistency C\n 6. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "assume \\<open>Neg (And A B) \\<in> S\\<close>"], ["proof (state)\nthis:\n  Neg (And A B) \\<in> S\n\ngoal (6 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_alt_consistency C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_alt_consistency C\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> mk_alt_consistency C\n 5. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                         \\<in> mk_alt_consistency C\n 6. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "then"], ["proof (chain)\npicking this:\n  Neg (And A B) \\<in> S", "have \\<open>psubst f (Neg (And A B)) \\<in> ?S'\\<close>"], ["proof (prove)\nusing this:\n  Neg (And A B) \\<in> S\n\ngoal (1 subgoal):\n 1. psubst f (Neg (And A B)) \\<in> psubst f ` S", "by blast"], ["proof (state)\nthis:\n  psubst f (Neg (And A B)) \\<in> psubst f ` S\n\ngoal (6 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_alt_consistency C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_alt_consistency C\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> mk_alt_consistency C\n 5. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                         \\<in> mk_alt_consistency C\n 6. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "then"], ["proof (chain)\npicking this:\n  psubst f (Neg (And A B)) \\<in> psubst f ` S", "have \\<open>?S' \\<union> {Neg (psubst f A)} \\<in> C \\<or> ?S' \\<union> {Neg (psubst f B)} \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  psubst f (Neg (And A B)) \\<in> psubst f ` S\n\ngoal (1 subgoal):\n 1. psubst f ` S \\<union> {Neg (psubst f A)} \\<in> C \\<or>\n    psubst f ` S \\<union> {Neg (psubst f B)} \\<in> C", "using conc sc"], ["proof (prove)\nusing this:\n  psubst f (Neg (And A B)) \\<in> psubst f ` S\n  consistency C\n  psubst f ` S \\<in> C\n\ngoal (1 subgoal):\n 1. psubst f ` S \\<union> {Neg (psubst f A)} \\<in> C \\<or>\n    psubst f ` S \\<union> {Neg (psubst f B)} \\<in> C", "by (simp add: consistency_def)"], ["proof (state)\nthis:\n  psubst f ` S \\<union> {Neg (psubst f A)} \\<in> C \\<or>\n  psubst f ` S \\<union> {Neg (psubst f B)} \\<in> C\n\ngoal (6 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_alt_consistency C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_alt_consistency C\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> mk_alt_consistency C\n 5. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                         \\<in> mk_alt_consistency C\n 6. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "then"], ["proof (chain)\npicking this:\n  psubst f ` S \\<union> {Neg (psubst f A)} \\<in> C \\<or>\n  psubst f ` S \\<union> {Neg (psubst f B)} \\<in> C", "show \\<open>S \\<union> {Neg A} \\<in> ?C' \\<or> S \\<union> {Neg B} \\<in> ?C'\\<close>"], ["proof (prove)\nusing this:\n  psubst f ` S \\<union> {Neg (psubst f A)} \\<in> C \\<or>\n  psubst f ` S \\<union> {Neg (psubst f B)} \\<in> C\n\ngoal (1 subgoal):\n 1. S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n    S \\<union> {Neg B} \\<in> mk_alt_consistency C", "unfolding mk_alt_consistency_def"], ["proof (prove)\nusing this:\n  psubst f ` S \\<union> {Neg (psubst f A)} \\<in> C \\<or>\n  psubst f ` S \\<union> {Neg (psubst f B)} \\<in> C\n\ngoal (1 subgoal):\n 1. S \\<union> {Neg A} \\<in> {S. \\<exists>f. psubst f ` S \\<in> C} \\<or>\n    S \\<union> {Neg B} \\<in> {S. \\<exists>f. psubst f ` S \\<in> C}", "by auto"], ["proof (state)\nthis:\n  S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n  S \\<union> {Neg B} \\<in> mk_alt_consistency C\n\ngoal (5 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_alt_consistency C\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> mk_alt_consistency C\n 4. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                         \\<in> mk_alt_consistency C\n 5. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "}"], ["proof (state)\nthis:\n  Neg (And ?A2 ?B2) \\<in> S \\<Longrightarrow>\n  S \\<union> {Neg ?A2} \\<in> mk_alt_consistency C \\<or>\n  S \\<union> {Neg ?B2} \\<in> mk_alt_consistency C\n\ngoal (5 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_alt_consistency C\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> mk_alt_consistency C\n 4. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                         \\<in> mk_alt_consistency C\n 5. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "{"], ["proof (state)\nthis:\n  Neg (And ?A2 ?B2) \\<in> S \\<Longrightarrow>\n  S \\<union> {Neg ?A2} \\<in> mk_alt_consistency C \\<or>\n  S \\<union> {Neg ?B2} \\<in> mk_alt_consistency C\n\ngoal (5 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_alt_consistency C\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> mk_alt_consistency C\n 4. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                         \\<in> mk_alt_consistency C\n 5. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "fix A B"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_alt_consistency C\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> mk_alt_consistency C\n 4. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                         \\<in> mk_alt_consistency C\n 5. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "assume \\<open>Impl A B \\<in> S\\<close>"], ["proof (state)\nthis:\n  Impl A B \\<in> S\n\ngoal (5 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_alt_consistency C\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> mk_alt_consistency C\n 4. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                         \\<in> mk_alt_consistency C\n 5. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "then"], ["proof (chain)\npicking this:\n  Impl A B \\<in> S", "have \\<open>psubst f (Impl A B) \\<in> ?S'\\<close>"], ["proof (prove)\nusing this:\n  Impl A B \\<in> S\n\ngoal (1 subgoal):\n 1. psubst f (Impl A B) \\<in> psubst f ` S", "by blast"], ["proof (state)\nthis:\n  psubst f (Impl A B) \\<in> psubst f ` S\n\ngoal (5 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_alt_consistency C\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> mk_alt_consistency C\n 4. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                         \\<in> mk_alt_consistency C\n 5. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "then"], ["proof (chain)\npicking this:\n  psubst f (Impl A B) \\<in> psubst f ` S", "have \\<open>?S' \\<union> {Neg (psubst f A)} \\<in> C \\<or> ?S' \\<union> {psubst f B} \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  psubst f (Impl A B) \\<in> psubst f ` S\n\ngoal (1 subgoal):\n 1. psubst f ` S \\<union> {Neg (psubst f A)} \\<in> C \\<or>\n    psubst f ` S \\<union> {psubst f B} \\<in> C", "using conc sc"], ["proof (prove)\nusing this:\n  psubst f (Impl A B) \\<in> psubst f ` S\n  consistency C\n  psubst f ` S \\<in> C\n\ngoal (1 subgoal):\n 1. psubst f ` S \\<union> {Neg (psubst f A)} \\<in> C \\<or>\n    psubst f ` S \\<union> {psubst f B} \\<in> C", "by (simp add: consistency_def)"], ["proof (state)\nthis:\n  psubst f ` S \\<union> {Neg (psubst f A)} \\<in> C \\<or>\n  psubst f ` S \\<union> {psubst f B} \\<in> C\n\ngoal (5 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n                         S \\<union> {B} \\<in> mk_alt_consistency C\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_alt_consistency C\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> mk_alt_consistency C\n 4. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                         \\<in> mk_alt_consistency C\n 5. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "then"], ["proof (chain)\npicking this:\n  psubst f ` S \\<union> {Neg (psubst f A)} \\<in> C \\<or>\n  psubst f ` S \\<union> {psubst f B} \\<in> C", "show \\<open>S \\<union> {Neg A} \\<in> ?C' \\<or> S \\<union> {B} \\<in> ?C'\\<close>"], ["proof (prove)\nusing this:\n  psubst f ` S \\<union> {Neg (psubst f A)} \\<in> C \\<or>\n  psubst f ` S \\<union> {psubst f B} \\<in> C\n\ngoal (1 subgoal):\n 1. S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n    S \\<union> {B} \\<in> mk_alt_consistency C", "unfolding mk_alt_consistency_def"], ["proof (prove)\nusing this:\n  psubst f ` S \\<union> {Neg (psubst f A)} \\<in> C \\<or>\n  psubst f ` S \\<union> {psubst f B} \\<in> C\n\ngoal (1 subgoal):\n 1. S \\<union> {Neg A} \\<in> {S. \\<exists>f. psubst f ` S \\<in> C} \\<or>\n    S \\<union> {B} \\<in> {S. \\<exists>f. psubst f ` S \\<in> C}", "by auto"], ["proof (state)\nthis:\n  S \\<union> {Neg A} \\<in> mk_alt_consistency C \\<or>\n  S \\<union> {B} \\<in> mk_alt_consistency C\n\ngoal (4 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_alt_consistency C\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> mk_alt_consistency C\n 3. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                         \\<in> mk_alt_consistency C\n 4. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "}"], ["proof (state)\nthis:\n  Impl ?A2 ?B2 \\<in> S \\<Longrightarrow>\n  S \\<union> {Neg ?A2} \\<in> mk_alt_consistency C \\<or>\n  S \\<union> {?B2} \\<in> mk_alt_consistency C\n\ngoal (4 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_alt_consistency C\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> mk_alt_consistency C\n 3. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                         \\<in> mk_alt_consistency C\n 4. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "{"], ["proof (state)\nthis:\n  Impl ?A2 ?B2 \\<in> S \\<Longrightarrow>\n  S \\<union> {Neg ?A2} \\<in> mk_alt_consistency C \\<or>\n  S \\<union> {?B2} \\<in> mk_alt_consistency C\n\ngoal (4 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_alt_consistency C\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> mk_alt_consistency C\n 3. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                         \\<in> mk_alt_consistency C\n 4. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "fix P and t :: \\<open>'a term\\<close>"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_alt_consistency C\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> mk_alt_consistency C\n 3. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                         \\<in> mk_alt_consistency C\n 4. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "assume \\<open>closedt 0 t\\<close> and \\<open>Forall P \\<in> S\\<close>"], ["proof (state)\nthis:\n  closedt 0 t\n  Forall P \\<in> S\n\ngoal (4 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_alt_consistency C\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> mk_alt_consistency C\n 3. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                         \\<in> mk_alt_consistency C\n 4. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "then"], ["proof (chain)\npicking this:\n  closedt 0 t\n  Forall P \\<in> S", "have \\<open>psubst f (Forall P) \\<in> ?S'\\<close>"], ["proof (prove)\nusing this:\n  closedt 0 t\n  Forall P \\<in> S\n\ngoal (1 subgoal):\n 1. psubst f (Forall P) \\<in> psubst f ` S", "by blast"], ["proof (state)\nthis:\n  psubst f (Forall P) \\<in> psubst f ` S\n\ngoal (4 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_alt_consistency C\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> mk_alt_consistency C\n 3. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                         \\<in> mk_alt_consistency C\n 4. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "then"], ["proof (chain)\npicking this:\n  psubst f (Forall P) \\<in> psubst f ` S", "have \\<open>?S' \\<union> {psubst f P[psubstt f t/0]} \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  psubst f (Forall P) \\<in> psubst f ` S\n\ngoal (1 subgoal):\n 1. psubst f ` S \\<union> {psubst f P[psubstt f t/0]} \\<in> C", "using \\<open>closedt 0 t\\<close> conc sc"], ["proof (prove)\nusing this:\n  psubst f (Forall P) \\<in> psubst f ` S\n  closedt 0 t\n  consistency C\n  psubst f ` S \\<in> C\n\ngoal (1 subgoal):\n 1. psubst f ` S \\<union> {psubst f P[psubstt f t/0]} \\<in> C", "by (simp add: consistency_def)"], ["proof (state)\nthis:\n  psubst f ` S \\<union> {psubst f P[psubstt f t/0]} \\<in> C\n\ngoal (4 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_alt_consistency C\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> mk_alt_consistency C\n 3. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                         \\<in> mk_alt_consistency C\n 4. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "then"], ["proof (chain)\npicking this:\n  psubst f ` S \\<union> {psubst f P[psubstt f t/0]} \\<in> C", "show \\<open>S \\<union> {P[t/0]} \\<in> ?C'\\<close>"], ["proof (prove)\nusing this:\n  psubst f ` S \\<union> {psubst f P[psubstt f t/0]} \\<in> C\n\ngoal (1 subgoal):\n 1. S \\<union> {P[t/0]} \\<in> mk_alt_consistency C", "unfolding mk_alt_consistency_def"], ["proof (prove)\nusing this:\n  psubst f ` S \\<union> {psubst f P[psubstt f t/0]} \\<in> C\n\ngoal (1 subgoal):\n 1. S \\<union> {P[t/0]} \\<in> {S. \\<exists>f. psubst f ` S \\<in> C}", "by auto"], ["proof (state)\nthis:\n  S \\<union> {P[t/0]} \\<in> mk_alt_consistency C\n\ngoal (3 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> mk_alt_consistency C\n 2. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                         \\<in> mk_alt_consistency C\n 3. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "}"], ["proof (state)\nthis:\n  \\<lbrakk>closedt 0 ?t2; Forall ?P2 \\<in> S\\<rbrakk>\n  \\<Longrightarrow> S \\<union> {?P2[?t2/0]} \\<in> mk_alt_consistency C\n\ngoal (3 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> mk_alt_consistency C\n 2. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                         \\<in> mk_alt_consistency C\n 3. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "{"], ["proof (state)\nthis:\n  \\<lbrakk>closedt 0 ?t2; Forall ?P2 \\<in> S\\<rbrakk>\n  \\<Longrightarrow> S \\<union> {?P2[?t2/0]} \\<in> mk_alt_consistency C\n\ngoal (3 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> mk_alt_consistency C\n 2. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                         \\<in> mk_alt_consistency C\n 3. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "fix P and t :: \\<open>'a term\\<close>"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> mk_alt_consistency C\n 2. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                         \\<in> mk_alt_consistency C\n 3. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "assume \\<open>closedt 0 t\\<close> and \\<open>Neg (Exists P) \\<in> S\\<close>"], ["proof (state)\nthis:\n  closedt 0 t\n  Neg (Exists P) \\<in> S\n\ngoal (3 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> mk_alt_consistency C\n 2. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                         \\<in> mk_alt_consistency C\n 3. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "then"], ["proof (chain)\npicking this:\n  closedt 0 t\n  Neg (Exists P) \\<in> S", "have \\<open>psubst f (Neg (Exists P)) \\<in> ?S'\\<close>"], ["proof (prove)\nusing this:\n  closedt 0 t\n  Neg (Exists P) \\<in> S\n\ngoal (1 subgoal):\n 1. psubst f (Neg (Exists P)) \\<in> psubst f ` S", "by blast"], ["proof (state)\nthis:\n  psubst f (Neg (Exists P)) \\<in> psubst f ` S\n\ngoal (3 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> mk_alt_consistency C\n 2. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                         \\<in> mk_alt_consistency C\n 3. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "then"], ["proof (chain)\npicking this:\n  psubst f (Neg (Exists P)) \\<in> psubst f ` S", "have \\<open>?S' \\<union> {Neg (psubst f P[psubstt f t/0])} \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  psubst f (Neg (Exists P)) \\<in> psubst f ` S\n\ngoal (1 subgoal):\n 1. psubst f ` S \\<union> {Neg (psubst f P[psubstt f t/0])} \\<in> C", "using \\<open>closedt 0 t\\<close> conc sc"], ["proof (prove)\nusing this:\n  psubst f (Neg (Exists P)) \\<in> psubst f ` S\n  closedt 0 t\n  consistency C\n  psubst f ` S \\<in> C\n\ngoal (1 subgoal):\n 1. psubst f ` S \\<union> {Neg (psubst f P[psubstt f t/0])} \\<in> C", "by (simp add: consistency_def)"], ["proof (state)\nthis:\n  psubst f ` S \\<union> {Neg (psubst f P[psubstt f t/0])} \\<in> C\n\ngoal (3 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_alt_consistency C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> mk_alt_consistency C\n 2. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                         \\<in> mk_alt_consistency C\n 3. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "then"], ["proof (chain)\npicking this:\n  psubst f ` S \\<union> {Neg (psubst f P[psubstt f t/0])} \\<in> C", "show \\<open>S \\<union> {Neg (P[t/0])} \\<in> ?C'\\<close>"], ["proof (prove)\nusing this:\n  psubst f ` S \\<union> {Neg (psubst f P[psubstt f t/0])} \\<in> C\n\ngoal (1 subgoal):\n 1. S \\<union> {Neg (P[t/0])} \\<in> mk_alt_consistency C", "unfolding mk_alt_consistency_def"], ["proof (prove)\nusing this:\n  psubst f ` S \\<union> {Neg (psubst f P[psubstt f t/0])} \\<in> C\n\ngoal (1 subgoal):\n 1. S \\<union> {Neg (P[t/0])} \\<in> {S. \\<exists>f. psubst f ` S \\<in> C}", "by auto"], ["proof (state)\nthis:\n  S \\<union> {Neg (P[t/0])} \\<in> mk_alt_consistency C\n\ngoal (2 subgoals):\n 1. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                         \\<in> mk_alt_consistency C\n 2. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "}"], ["proof (state)\nthis:\n  \\<lbrakk>closedt 0 ?t2; Neg (Exists ?P2) \\<in> S\\<rbrakk>\n  \\<Longrightarrow> S \\<union> {Neg (?P2[?t2/0])} \\<in> mk_alt_consistency C\n\ngoal (2 subgoals):\n 1. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                         \\<in> mk_alt_consistency C\n 2. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "{"], ["proof (state)\nthis:\n  \\<lbrakk>closedt 0 ?t2; Neg (Exists ?P2) \\<in> S\\<rbrakk>\n  \\<Longrightarrow> S \\<union> {Neg (?P2[?t2/0])} \\<in> mk_alt_consistency C\n\ngoal (2 subgoals):\n 1. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                         \\<in> mk_alt_consistency C\n 2. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "fix P :: \\<open>('a, 'b) form\\<close> and x f'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                         \\<in> mk_alt_consistency C\n 2. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "assume \\<open>\\<forall>a \\<in> S. x \\<notin> params a\\<close> and \\<open>Exists P \\<in> S\\<close>"], ["proof (state)\nthis:\n  \\<forall>a\\<in>S. x \\<notin> params a\n  Exists P \\<in> S\n\ngoal (2 subgoals):\n 1. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                         \\<in> mk_alt_consistency C\n 2. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "moreover"], ["proof (state)\nthis:\n  \\<forall>a\\<in>S. x \\<notin> params a\n  Exists P \\<in> S\n\ngoal (2 subgoals):\n 1. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                         \\<in> mk_alt_consistency C\n 2. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "have \\<open>psubst f (Exists P) \\<in> ?S'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. psubst f (Exists P) \\<in> psubst f ` S", "using calculation"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>S. x \\<notin> params a\n  Exists P \\<in> S\n\ngoal (1 subgoal):\n 1. psubst f (Exists P) \\<in> psubst f ` S", "by blast"], ["proof (state)\nthis:\n  psubst f (Exists P) \\<in> psubst f ` S\n\ngoal (2 subgoals):\n 1. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                         \\<in> mk_alt_consistency C\n 2. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "then"], ["proof (chain)\npicking this:\n  psubst f (Exists P) \\<in> psubst f ` S", "have \\<open>\\<exists>y. ?S' \\<union> {psubst f P[App y []/0]} \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  psubst f (Exists P) \\<in> psubst f ` S\n\ngoal (1 subgoal):\n 1. \\<exists>y. psubst f ` S \\<union> {psubst f P[App y []/0]} \\<in> C", "using conc sc"], ["proof (prove)\nusing this:\n  psubst f (Exists P) \\<in> psubst f ` S\n  consistency C\n  psubst f ` S \\<in> C\n\ngoal (1 subgoal):\n 1. \\<exists>y. psubst f ` S \\<union> {psubst f P[App y []/0]} \\<in> C", "by (simp add: consistency_def)"], ["proof (state)\nthis:\n  \\<exists>y. psubst f ` S \\<union> {psubst f P[App y []/0]} \\<in> C\n\ngoal (2 subgoals):\n 1. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                         \\<in> mk_alt_consistency C\n 2. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "then"], ["proof (chain)\npicking this:\n  \\<exists>y. psubst f ` S \\<union> {psubst f P[App y []/0]} \\<in> C", "obtain y where \\<open>?S' \\<union> {psubst f P[App y []/0]} \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>y. psubst f ` S \\<union> {psubst f P[App y []/0]} \\<in> C\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        psubst f ` S \\<union> {psubst f P[App y []/0]}\n        \\<in> C \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  psubst f ` S \\<union> {psubst f P[App y []/0]} \\<in> C\n\ngoal (2 subgoals):\n 1. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                         \\<in> mk_alt_consistency C\n 2. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "moreover"], ["proof (state)\nthis:\n  psubst f ` S \\<union> {psubst f P[App y []/0]} \\<in> C\n\ngoal (2 subgoals):\n 1. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                         \\<in> mk_alt_consistency C\n 2. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "have \\<open>psubst (f(x := y)) ` S = ?S'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. psubst (f(x := y)) ` S = psubst f ` S", "using calculation"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>S. x \\<notin> params a\n  Exists P \\<in> S\n  psubst f ` S \\<union> {psubst f P[App y []/0]} \\<in> C\n\ngoal (1 subgoal):\n 1. psubst (f(x := y)) ` S = psubst f ` S", "by (simp cong add: image_cong)"], ["proof (state)\nthis:\n  psubst (f(x := y)) ` S = psubst f ` S\n\ngoal (2 subgoals):\n 1. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                         \\<in> mk_alt_consistency C\n 2. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "moreover"], ["proof (state)\nthis:\n  psubst (f(x := y)) ` S = psubst f ` S\n\ngoal (2 subgoals):\n 1. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                         \\<in> mk_alt_consistency C\n 2. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "have \\<open>psubst (f(x := y)) `\n        S \\<union> {psubst (f(x := y)) P[App ((f(x := y)) x) []/0]} \\<in> C\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. psubst (f(x := y)) ` S \\<union>\n    {psubst (f(x := y)) P[App ((f(x := y)) x) []/0]}\n    \\<in> C", "using calculation"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>S. x \\<notin> params a\n  Exists P \\<in> S\n  psubst f ` S \\<union> {psubst f P[App y []/0]} \\<in> C\n  psubst (f(x := y)) ` S = psubst f ` S\n\ngoal (1 subgoal):\n 1. psubst (f(x := y)) ` S \\<union>\n    {psubst (f(x := y)) P[App ((f(x := y)) x) []/0]}\n    \\<in> C", "by auto"], ["proof (state)\nthis:\n  psubst (f(x := y)) ` S \\<union>\n  {psubst (f(x := y)) P[App ((f(x := y)) x) []/0]}\n  \\<in> C\n\ngoal (2 subgoals):\n 1. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                         \\<in> mk_alt_consistency C\n 2. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>S. x \\<notin> params a\n  Exists P \\<in> S\n  psubst f ` S \\<union> {psubst f P[App y []/0]} \\<in> C\n  psubst (f(x := y)) ` S = psubst f ` S\n  psubst (f(x := y)) ` S \\<union>\n  {psubst (f(x := y)) P[App ((f(x := y)) x) []/0]}\n  \\<in> C", "have \\<open>\\<exists>f. psubst f ` S \\<union> {psubst f P[App (f x) []/0]} \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>S. x \\<notin> params a\n  Exists P \\<in> S\n  psubst f ` S \\<union> {psubst f P[App y []/0]} \\<in> C\n  psubst (f(x := y)) ` S = psubst f ` S\n  psubst (f(x := y)) ` S \\<union>\n  {psubst (f(x := y)) P[App ((f(x := y)) x) []/0]}\n  \\<in> C\n\ngoal (1 subgoal):\n 1. \\<exists>f. psubst f ` S \\<union> {psubst f P[App (f x) []/0]} \\<in> C", "by blast"], ["proof (state)\nthis:\n  \\<exists>f. psubst f ` S \\<union> {psubst f P[App (f x) []/0]} \\<in> C\n\ngoal (2 subgoals):\n 1. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]}\n                         \\<in> mk_alt_consistency C\n 2. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "then"], ["proof (chain)\npicking this:\n  \\<exists>f. psubst f ` S \\<union> {psubst f P[App (f x) []/0]} \\<in> C", "show \\<open>S \\<union> {P[App x []/0]} \\<in> ?C'\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>f. psubst f ` S \\<union> {psubst f P[App (f x) []/0]} \\<in> C\n\ngoal (1 subgoal):\n 1. S \\<union> {P[App x []/0]} \\<in> mk_alt_consistency C", "unfolding mk_alt_consistency_def"], ["proof (prove)\nusing this:\n  \\<exists>f. psubst f ` S \\<union> {psubst f P[App (f x) []/0]} \\<in> C\n\ngoal (1 subgoal):\n 1. S \\<union> {P[App x []/0]} \\<in> {S. \\<exists>f. psubst f ` S \\<in> C}", "by simp"], ["proof (state)\nthis:\n  S \\<union> {P[App x []/0]} \\<in> mk_alt_consistency C\n\ngoal (1 subgoal):\n 1. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "}"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>a\\<in>S. ?x2 \\<notin> params a;\n   Exists ?P2 \\<in> S\\<rbrakk>\n  \\<Longrightarrow> S \\<union> {?P2[App ?x2 []/0]}\n                    \\<in> mk_alt_consistency C\n\ngoal (1 subgoal):\n 1. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "{"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>a\\<in>S. ?x2 \\<notin> params a;\n   Exists ?P2 \\<in> S\\<rbrakk>\n  \\<Longrightarrow> S \\<union> {?P2[App ?x2 []/0]}\n                    \\<in> mk_alt_consistency C\n\ngoal (1 subgoal):\n 1. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "fix P :: \\<open>('a, 'b) form\\<close> and x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "assume \\<open>\\<forall>a \\<in> S. x \\<notin> params a\\<close> and \\<open>Neg (Forall P) \\<in> S\\<close>"], ["proof (state)\nthis:\n  \\<forall>a\\<in>S. x \\<notin> params a\n  Neg (Forall P) \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "moreover"], ["proof (state)\nthis:\n  \\<forall>a\\<in>S. x \\<notin> params a\n  Neg (Forall P) \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "have \\<open>psubst f (Neg (Forall P)) \\<in> ?S'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. psubst f (Neg (Forall P)) \\<in> psubst f ` S", "using calculation"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>S. x \\<notin> params a\n  Neg (Forall P) \\<in> S\n\ngoal (1 subgoal):\n 1. psubst f (Neg (Forall P)) \\<in> psubst f ` S", "by blast"], ["proof (state)\nthis:\n  psubst f (Neg (Forall P)) \\<in> psubst f ` S\n\ngoal (1 subgoal):\n 1. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "then"], ["proof (chain)\npicking this:\n  psubst f (Neg (Forall P)) \\<in> psubst f ` S", "have \\<open>\\<exists>y. ?S' \\<union> {Neg (psubst f P[App y []/0])} \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  psubst f (Neg (Forall P)) \\<in> psubst f ` S\n\ngoal (1 subgoal):\n 1. \\<exists>y. psubst f ` S \\<union> {Neg (psubst f P[App y []/0])} \\<in> C", "using conc sc"], ["proof (prove)\nusing this:\n  psubst f (Neg (Forall P)) \\<in> psubst f ` S\n  consistency C\n  psubst f ` S \\<in> C\n\ngoal (1 subgoal):\n 1. \\<exists>y. psubst f ` S \\<union> {Neg (psubst f P[App y []/0])} \\<in> C", "by (simp add: consistency_def)"], ["proof (state)\nthis:\n  \\<exists>y. psubst f ` S \\<union> {Neg (psubst f P[App y []/0])} \\<in> C\n\ngoal (1 subgoal):\n 1. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "then"], ["proof (chain)\npicking this:\n  \\<exists>y. psubst f ` S \\<union> {Neg (psubst f P[App y []/0])} \\<in> C", "obtain y where \\<open>?S' \\<union> {Neg (psubst f P[App y []/0])} \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>y. psubst f ` S \\<union> {Neg (psubst f P[App y []/0])} \\<in> C\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        psubst f ` S \\<union> {Neg (psubst f P[App y []/0])}\n        \\<in> C \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  psubst f ` S \\<union> {Neg (psubst f P[App y []/0])} \\<in> C\n\ngoal (1 subgoal):\n 1. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "moreover"], ["proof (state)\nthis:\n  psubst f ` S \\<union> {Neg (psubst f P[App y []/0])} \\<in> C\n\ngoal (1 subgoal):\n 1. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "have \\<open>psubst (f(x := y)) ` S = ?S'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. psubst (f(x := y)) ` S = psubst f ` S", "using calculation"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>S. x \\<notin> params a\n  Neg (Forall P) \\<in> S\n  psubst f ` S \\<union> {Neg (psubst f P[App y []/0])} \\<in> C\n\ngoal (1 subgoal):\n 1. psubst (f(x := y)) ` S = psubst f ` S", "by (simp cong add: image_cong)"], ["proof (state)\nthis:\n  psubst (f(x := y)) ` S = psubst f ` S\n\ngoal (1 subgoal):\n 1. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "moreover"], ["proof (state)\nthis:\n  psubst (f(x := y)) ` S = psubst f ` S\n\ngoal (1 subgoal):\n 1. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "have \\<open>psubst (f(x := y)) `\n    S \\<union> {Neg (psubst (f(x := y)) P[App ((f(x := y)) x) []/0])} \\<in> C\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. psubst (f(x := y)) ` S \\<union>\n    {Neg (psubst (f(x := y)) P[App ((f(x := y)) x) []/0])}\n    \\<in> C", "using calculation"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>S. x \\<notin> params a\n  Neg (Forall P) \\<in> S\n  psubst f ` S \\<union> {Neg (psubst f P[App y []/0])} \\<in> C\n  psubst (f(x := y)) ` S = psubst f ` S\n\ngoal (1 subgoal):\n 1. psubst (f(x := y)) ` S \\<union>\n    {Neg (psubst (f(x := y)) P[App ((f(x := y)) x) []/0])}\n    \\<in> C", "by auto"], ["proof (state)\nthis:\n  psubst (f(x := y)) ` S \\<union>\n  {Neg (psubst (f(x := y)) P[App ((f(x := y)) x) []/0])}\n  \\<in> C\n\ngoal (1 subgoal):\n 1. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>S. x \\<notin> params a\n  Neg (Forall P) \\<in> S\n  psubst f ` S \\<union> {Neg (psubst f P[App y []/0])} \\<in> C\n  psubst (f(x := y)) ` S = psubst f ` S\n  psubst (f(x := y)) ` S \\<union>\n  {Neg (psubst (f(x := y)) P[App ((f(x := y)) x) []/0])}\n  \\<in> C", "have \\<open>\\<exists>f. psubst f ` S \\<union> {Neg (psubst f P[App (f x) []/0])} \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>S. x \\<notin> params a\n  Neg (Forall P) \\<in> S\n  psubst f ` S \\<union> {Neg (psubst f P[App y []/0])} \\<in> C\n  psubst (f(x := y)) ` S = psubst f ` S\n  psubst (f(x := y)) ` S \\<union>\n  {Neg (psubst (f(x := y)) P[App ((f(x := y)) x) []/0])}\n  \\<in> C\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       psubst f ` S \\<union> {Neg (psubst f P[App (f x) []/0])} \\<in> C", "by blast"], ["proof (state)\nthis:\n  \\<exists>f.\n     psubst f ` S \\<union> {Neg (psubst f P[App (f x) []/0])} \\<in> C\n\ngoal (1 subgoal):\n 1. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_alt_consistency C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_alt_consistency C", "then"], ["proof (chain)\npicking this:\n  \\<exists>f.\n     psubst f ` S \\<union> {Neg (psubst f P[App (f x) []/0])} \\<in> C", "show \\<open>S \\<union> {Neg (P[App x []/0])} \\<in> ?C'\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>f.\n     psubst f ` S \\<union> {Neg (psubst f P[App (f x) []/0])} \\<in> C\n\ngoal (1 subgoal):\n 1. S \\<union> {Neg (P[App x []/0])} \\<in> mk_alt_consistency C", "unfolding mk_alt_consistency_def"], ["proof (prove)\nusing this:\n  \\<exists>f.\n     psubst f ` S \\<union> {Neg (psubst f P[App (f x) []/0])} \\<in> C\n\ngoal (1 subgoal):\n 1. S \\<union> {Neg (P[App x []/0])}\n    \\<in> {S. \\<exists>f. psubst f ` S \\<in> C}", "by simp"], ["proof (state)\nthis:\n  S \\<union> {Neg (P[App x []/0])} \\<in> mk_alt_consistency C\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>a\\<in>S. ?x2 \\<notin> params a;\n   Neg (Forall ?P2) \\<in> S\\<rbrakk>\n  \\<Longrightarrow> S \\<union> {Neg (?P2[App ?x2 []/0])}\n                    \\<in> mk_alt_consistency C\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem mk_alt_consistency_subset: \\<open>C \\<subseteq> mk_alt_consistency C\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<subseteq> mk_alt_consistency C", "unfolding mk_alt_consistency_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<subseteq> {S. \\<exists>f. psubst f ` S \\<in> C}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> C \\<Longrightarrow>\n       x \\<in> {S. \\<exists>f. psubst f ` S \\<in> C}", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> C \\<Longrightarrow>\n       x \\<in> {S. \\<exists>f. psubst f ` S \\<in> C}", "assume \\<open>x \\<in> C\\<close>"], ["proof (state)\nthis:\n  x \\<in> C\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> C \\<Longrightarrow>\n       x \\<in> {S. \\<exists>f. psubst f ` S \\<in> C}", "then"], ["proof (chain)\npicking this:\n  x \\<in> C", "have \\<open>psubst id ` x \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> C\n\ngoal (1 subgoal):\n 1. psubst id ` x \\<in> C", "by simp"], ["proof (state)\nthis:\n  psubst id ` x \\<in> C\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> C \\<Longrightarrow>\n       x \\<in> {S. \\<exists>f. psubst f ` S \\<in> C}", "then"], ["proof (chain)\npicking this:\n  psubst id ` x \\<in> C", "have \\<open>(\\<exists>f. psubst f ` x \\<in> C)\\<close>"], ["proof (prove)\nusing this:\n  psubst id ` x \\<in> C\n\ngoal (1 subgoal):\n 1. \\<exists>f. psubst f ` x \\<in> C", "by blast"], ["proof (state)\nthis:\n  \\<exists>f. psubst f ` x \\<in> C\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> C \\<Longrightarrow>\n       x \\<in> {S. \\<exists>f. psubst f ` S \\<in> C}", "then"], ["proof (chain)\npicking this:\n  \\<exists>f. psubst f ` x \\<in> C", "show \\<open>x \\<in> {S. \\<exists>f. psubst f ` S \\<in> C}\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>f. psubst f ` x \\<in> C\n\ngoal (1 subgoal):\n 1. x \\<in> {S. \\<exists>f. psubst f ` S \\<in> C}", "by simp"], ["proof (state)\nthis:\n  x \\<in> {S. \\<exists>f. psubst f ` S \\<in> C}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Closure under subsets\\<close>"], ["", "text \\<open>\n\\label{sec:closure}\nWe now show that a consistency property can be extended to one\nthat is closed under subsets.\n\\<close>"], ["", "definition close :: \\<open>('a, 'b) form set set \\<Rightarrow> ('a, 'b) form set set\\<close> where\n  \\<open>close C = {S. \\<exists>S' \\<in> C. S \\<subseteq> S'}\\<close>"], ["", "definition subset_closed :: \\<open>'a set set \\<Rightarrow> bool\\<close> where\n  \\<open>subset_closed C = (\\<forall>S' \\<in> C. \\<forall>S. S \\<subseteq> S' \\<longrightarrow> S \\<in> C)\\<close>"], ["", "lemma subset_in_close:\n  assumes \\<open>S \\<subseteq> S'\\<close>\n  shows \\<open>S' \\<union> x \\<in> C \\<longrightarrow> S \\<union> x \\<in> close C\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. S' \\<union> x \\<in> C \\<longrightarrow> S \\<union> x \\<in> close C", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. S' \\<union> x \\<in> C \\<longrightarrow> S \\<union> x \\<in> close C", "have \\<open>S' \\<union> x \\<in> close C \\<longrightarrow> S \\<union> x \\<in> close C\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. S' \\<union> x \\<in> close C \\<longrightarrow> S \\<union> x \\<in> close C", "unfolding close_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. S' \\<union> x \\<in> {S. Bex C ((\\<subseteq>) S)} \\<longrightarrow>\n    S \\<union> x \\<in> {S. Bex C ((\\<subseteq>) S)}", "using \\<open>S \\<subseteq> S'\\<close>"], ["proof (prove)\nusing this:\n  S \\<subseteq> S'\n\ngoal (1 subgoal):\n 1. S' \\<union> x \\<in> {S. Bex C ((\\<subseteq>) S)} \\<longrightarrow>\n    S \\<union> x \\<in> {S. Bex C ((\\<subseteq>) S)}", "by blast"], ["proof (state)\nthis:\n  S' \\<union> x \\<in> close C \\<longrightarrow> S \\<union> x \\<in> close C\n\ngoal (1 subgoal):\n 1. S' \\<union> x \\<in> C \\<longrightarrow> S \\<union> x \\<in> close C", "then"], ["proof (chain)\npicking this:\n  S' \\<union> x \\<in> close C \\<longrightarrow> S \\<union> x \\<in> close C", "show ?thesis"], ["proof (prove)\nusing this:\n  S' \\<union> x \\<in> close C \\<longrightarrow> S \\<union> x \\<in> close C\n\ngoal (1 subgoal):\n 1. S' \\<union> x \\<in> C \\<longrightarrow> S \\<union> x \\<in> close C", "unfolding close_def"], ["proof (prove)\nusing this:\n  S' \\<union> x \\<in> {S. Bex C ((\\<subseteq>) S)} \\<longrightarrow>\n  S \\<union> x \\<in> {S. Bex C ((\\<subseteq>) S)}\n\ngoal (1 subgoal):\n 1. S' \\<union> x \\<in> C \\<longrightarrow>\n    S \\<union> x \\<in> {S. Bex C ((\\<subseteq>) S)}", "by blast"], ["proof (state)\nthis:\n  S' \\<union> x \\<in> C \\<longrightarrow> S \\<union> x \\<in> close C\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem close_consistency:\n  assumes conc: \\<open>consistency C\\<close>\n  shows \\<open>consistency (close C)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. consistency (close C)", "unfolding consistency_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>S.\n       S \\<in> close C \\<longrightarrow>\n       (\\<forall>p ts.\n           \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)) \\<and>\n       FF \\<notin> S \\<and>\n       Neg TT \\<notin> S \\<and>\n       (\\<forall>Z.\n           Neg (Neg Z) \\<in> S \\<longrightarrow>\n           S \\<union> {Z} \\<in> close C) \\<and>\n       (\\<forall>A B.\n           And A B \\<in> S \\<longrightarrow>\n           S \\<union> {A, B} \\<in> close C) \\<and>\n       (\\<forall>A B.\n           Neg (Or A B) \\<in> S \\<longrightarrow>\n           S \\<union> {Neg A, Neg B} \\<in> close C) \\<and>\n       (\\<forall>A B.\n           Or A B \\<in> S \\<longrightarrow>\n           S \\<union> {A} \\<in> close C \\<or>\n           S \\<union> {B} \\<in> close C) \\<and>\n       (\\<forall>A B.\n           Neg (And A B) \\<in> S \\<longrightarrow>\n           S \\<union> {Neg A} \\<in> close C \\<or>\n           S \\<union> {Neg B} \\<in> close C) \\<and>\n       (\\<forall>A B.\n           Impl A B \\<in> S \\<longrightarrow>\n           S \\<union> {Neg A} \\<in> close C \\<or>\n           S \\<union> {B} \\<in> close C) \\<and>\n       (\\<forall>A B.\n           Neg (Impl A B) \\<in> S \\<longrightarrow>\n           S \\<union> {A, Neg B} \\<in> close C) \\<and>\n       (\\<forall>P t.\n           closedt 0 t \\<longrightarrow>\n           Forall P \\<in> S \\<longrightarrow>\n           S \\<union> {P[t/0]} \\<in> close C) \\<and>\n       (\\<forall>P t.\n           closedt 0 t \\<longrightarrow>\n           Neg (Exists P) \\<in> S \\<longrightarrow>\n           S \\<union> {Neg (P[t/0])} \\<in> close C) \\<and>\n       (\\<forall>P.\n           Exists P \\<in> S \\<longrightarrow>\n           (\\<exists>x. S \\<union> {P[App x []/0]} \\<in> close C)) \\<and>\n       (\\<forall>P.\n           Neg (Forall P) \\<in> S \\<longrightarrow>\n           (\\<exists>x. S \\<union> {Neg (P[App x []/0])} \\<in> close C))", "proof (intro allI impI conjI)"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>S p ts.\n       S \\<in> close C \\<Longrightarrow>\n       \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)\n 2. \\<And>S. S \\<in> close C \\<Longrightarrow> FF \\<notin> S\n 3. \\<And>S. S \\<in> close C \\<Longrightarrow> Neg TT \\<notin> S\n 4. \\<And>S Z.\n       \\<lbrakk>S \\<in> close C; Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z} \\<in> close C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B} \\<in> close C\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B} \\<in> close C\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {Neg B} \\<in> close C\n 9. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 10. \\<And>S A B.\n        \\<lbrakk>S \\<in> close C; Neg (Impl A B) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> close C\nA total of 14 subgoals...", "fix S"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>S p ts.\n       S \\<in> close C \\<Longrightarrow>\n       \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)\n 2. \\<And>S. S \\<in> close C \\<Longrightarrow> FF \\<notin> S\n 3. \\<And>S. S \\<in> close C \\<Longrightarrow> Neg TT \\<notin> S\n 4. \\<And>S Z.\n       \\<lbrakk>S \\<in> close C; Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z} \\<in> close C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B} \\<in> close C\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B} \\<in> close C\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {Neg B} \\<in> close C\n 9. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 10. \\<And>S A B.\n        \\<lbrakk>S \\<in> close C; Neg (Impl A B) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> close C\nA total of 14 subgoals...", "assume \\<open>S \\<in> close C\\<close>"], ["proof (state)\nthis:\n  S \\<in> close C\n\ngoal (14 subgoals):\n 1. \\<And>S p ts.\n       S \\<in> close C \\<Longrightarrow>\n       \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)\n 2. \\<And>S. S \\<in> close C \\<Longrightarrow> FF \\<notin> S\n 3. \\<And>S. S \\<in> close C \\<Longrightarrow> Neg TT \\<notin> S\n 4. \\<And>S Z.\n       \\<lbrakk>S \\<in> close C; Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z} \\<in> close C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B} \\<in> close C\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B} \\<in> close C\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {Neg B} \\<in> close C\n 9. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 10. \\<And>S A B.\n        \\<lbrakk>S \\<in> close C; Neg (Impl A B) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> close C\nA total of 14 subgoals...", "then"], ["proof (chain)\npicking this:\n  S \\<in> close C", "obtain x where \\<open>x \\<in> C\\<close> and \\<open>S \\<subseteq> x\\<close>"], ["proof (prove)\nusing this:\n  S \\<in> close C\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> C; S \\<subseteq> x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding close_def"], ["proof (prove)\nusing this:\n  S \\<in> {S. Bex C ((\\<subseteq>) S)}\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> C; S \\<subseteq> x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x \\<in> C\n  S \\<subseteq> x\n\ngoal (14 subgoals):\n 1. \\<And>S p ts.\n       S \\<in> close C \\<Longrightarrow>\n       \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)\n 2. \\<And>S. S \\<in> close C \\<Longrightarrow> FF \\<notin> S\n 3. \\<And>S. S \\<in> close C \\<Longrightarrow> Neg TT \\<notin> S\n 4. \\<And>S Z.\n       \\<lbrakk>S \\<in> close C; Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z} \\<in> close C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B} \\<in> close C\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B} \\<in> close C\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {Neg B} \\<in> close C\n 9. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 10. \\<And>S A B.\n        \\<lbrakk>S \\<in> close C; Neg (Impl A B) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> close C\nA total of 14 subgoals...", "{"], ["proof (state)\nthis:\n  x \\<in> C\n  S \\<subseteq> x\n\ngoal (14 subgoals):\n 1. \\<And>S p ts.\n       S \\<in> close C \\<Longrightarrow>\n       \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)\n 2. \\<And>S. S \\<in> close C \\<Longrightarrow> FF \\<notin> S\n 3. \\<And>S. S \\<in> close C \\<Longrightarrow> Neg TT \\<notin> S\n 4. \\<And>S Z.\n       \\<lbrakk>S \\<in> close C; Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z} \\<in> close C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B} \\<in> close C\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B} \\<in> close C\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {Neg B} \\<in> close C\n 9. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 10. \\<And>S A B.\n        \\<lbrakk>S \\<in> close C; Neg (Impl A B) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> close C\nA total of 14 subgoals...", "fix p ts"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>S p ts.\n       S \\<in> close C \\<Longrightarrow>\n       \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)\n 2. \\<And>S. S \\<in> close C \\<Longrightarrow> FF \\<notin> S\n 3. \\<And>S. S \\<in> close C \\<Longrightarrow> Neg TT \\<notin> S\n 4. \\<And>S Z.\n       \\<lbrakk>S \\<in> close C; Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z} \\<in> close C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B} \\<in> close C\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B} \\<in> close C\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {Neg B} \\<in> close C\n 9. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 10. \\<And>S A B.\n        \\<lbrakk>S \\<in> close C; Neg (Impl A B) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> close C\nA total of 14 subgoals...", "have \\<open>\\<not> (Pred p ts \\<in> x \\<and> Neg (Pred p ts) \\<in> x)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (Pred p ts \\<in> x \\<and> Neg (Pred p ts) \\<in> x)", "using \\<open>x \\<in> C\\<close> conc"], ["proof (prove)\nusing this:\n  x \\<in> C\n  consistency C\n\ngoal (1 subgoal):\n 1. \\<not> (Pred p ts \\<in> x \\<and> Neg (Pred p ts) \\<in> x)", "unfolding consistency_def"], ["proof (prove)\nusing this:\n  x \\<in> C\n  \\<forall>S.\n     S \\<in> C \\<longrightarrow>\n     (\\<forall>p ts.\n         \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)) \\<and>\n     FF \\<notin> S \\<and>\n     Neg TT \\<notin> S \\<and>\n     (\\<forall>Z.\n         Neg (Neg Z) \\<in> S \\<longrightarrow>\n         S \\<union> {Z} \\<in> C) \\<and>\n     (\\<forall>A B.\n         And A B \\<in> S \\<longrightarrow> S \\<union> {A, B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Or A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A, Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Or A B \\<in> S \\<longrightarrow>\n         S \\<union> {A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (And A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Impl A B \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Impl A B) \\<in> S \\<longrightarrow>\n         S \\<union> {A, Neg B} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Forall P \\<in> S \\<longrightarrow>\n         S \\<union> {P[t/0]} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Neg (Exists P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[t/0])} \\<in> C) \\<and>\n     (\\<forall>P.\n         Exists P \\<in> S \\<longrightarrow>\n         (\\<exists>x. S \\<union> {P[App x []/0]} \\<in> C)) \\<and>\n     (\\<forall>P.\n         Neg (Forall P) \\<in> S \\<longrightarrow>\n         (\\<exists>x. S \\<union> {Neg (P[App x []/0])} \\<in> C))\n\ngoal (1 subgoal):\n 1. \\<not> (Pred p ts \\<in> x \\<and> Neg (Pred p ts) \\<in> x)", "by simp"], ["proof (state)\nthis:\n  \\<not> (Pred p ts \\<in> x \\<and> Neg (Pred p ts) \\<in> x)\n\ngoal (14 subgoals):\n 1. \\<And>S p ts.\n       S \\<in> close C \\<Longrightarrow>\n       \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)\n 2. \\<And>S. S \\<in> close C \\<Longrightarrow> FF \\<notin> S\n 3. \\<And>S. S \\<in> close C \\<Longrightarrow> Neg TT \\<notin> S\n 4. \\<And>S Z.\n       \\<lbrakk>S \\<in> close C; Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z} \\<in> close C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B} \\<in> close C\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B} \\<in> close C\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {Neg B} \\<in> close C\n 9. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 10. \\<And>S A B.\n        \\<lbrakk>S \\<in> close C; Neg (Impl A B) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> close C\nA total of 14 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<not> (Pred p ts \\<in> x \\<and> Neg (Pred p ts) \\<in> x)", "show \\<open>\\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)\\<close>"], ["proof (prove)\nusing this:\n  \\<not> (Pred p ts \\<in> x \\<and> Neg (Pred p ts) \\<in> x)\n\ngoal (1 subgoal):\n 1. \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)", "using \\<open>S \\<subseteq> x\\<close>"], ["proof (prove)\nusing this:\n  \\<not> (Pred p ts \\<in> x \\<and> Neg (Pred p ts) \\<in> x)\n  S \\<subseteq> x\n\ngoal (1 subgoal):\n 1. \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)", "by blast"], ["proof (state)\nthis:\n  \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)\n\ngoal (13 subgoals):\n 1. \\<And>S. S \\<in> close C \\<Longrightarrow> FF \\<notin> S\n 2. \\<And>S. S \\<in> close C \\<Longrightarrow> Neg TT \\<notin> S\n 3. \\<And>S Z.\n       \\<lbrakk>S \\<in> close C; Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z} \\<in> close C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B} \\<in> close C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B} \\<in> close C\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {Neg B} \\<in> close C\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 9. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> close C\n 10. \\<And>S P t.\n        \\<lbrakk>S \\<in> close C; closedt 0 t; Forall P \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> close C\nA total of 13 subgoals...", "}"], ["proof (state)\nthis:\n  \\<not> (Pred ?p2 ?ts2 \\<in> S \\<and> Neg (Pred ?p2 ?ts2) \\<in> S)\n\ngoal (13 subgoals):\n 1. \\<And>S. S \\<in> close C \\<Longrightarrow> FF \\<notin> S\n 2. \\<And>S. S \\<in> close C \\<Longrightarrow> Neg TT \\<notin> S\n 3. \\<And>S Z.\n       \\<lbrakk>S \\<in> close C; Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z} \\<in> close C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B} \\<in> close C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B} \\<in> close C\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {Neg B} \\<in> close C\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 9. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> close C\n 10. \\<And>S P t.\n        \\<lbrakk>S \\<in> close C; closedt 0 t; Forall P \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> close C\nA total of 13 subgoals...", "{"], ["proof (state)\nthis:\n  \\<not> (Pred ?p2 ?ts2 \\<in> S \\<and> Neg (Pred ?p2 ?ts2) \\<in> S)\n\ngoal (13 subgoals):\n 1. \\<And>S. S \\<in> close C \\<Longrightarrow> FF \\<notin> S\n 2. \\<And>S. S \\<in> close C \\<Longrightarrow> Neg TT \\<notin> S\n 3. \\<And>S Z.\n       \\<lbrakk>S \\<in> close C; Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z} \\<in> close C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B} \\<in> close C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B} \\<in> close C\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {Neg B} \\<in> close C\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 9. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> close C\n 10. \\<And>S P t.\n        \\<lbrakk>S \\<in> close C; closedt 0 t; Forall P \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> close C\nA total of 13 subgoals...", "have \\<open>FF \\<notin> x\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. FF \\<notin> x", "using \\<open>x \\<in> C\\<close> conc"], ["proof (prove)\nusing this:\n  x \\<in> C\n  consistency C\n\ngoal (1 subgoal):\n 1. FF \\<notin> x", "unfolding consistency_def"], ["proof (prove)\nusing this:\n  x \\<in> C\n  \\<forall>S.\n     S \\<in> C \\<longrightarrow>\n     (\\<forall>p ts.\n         \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)) \\<and>\n     FF \\<notin> S \\<and>\n     Neg TT \\<notin> S \\<and>\n     (\\<forall>Z.\n         Neg (Neg Z) \\<in> S \\<longrightarrow>\n         S \\<union> {Z} \\<in> C) \\<and>\n     (\\<forall>A B.\n         And A B \\<in> S \\<longrightarrow> S \\<union> {A, B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Or A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A, Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Or A B \\<in> S \\<longrightarrow>\n         S \\<union> {A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (And A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Impl A B \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Impl A B) \\<in> S \\<longrightarrow>\n         S \\<union> {A, Neg B} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Forall P \\<in> S \\<longrightarrow>\n         S \\<union> {P[t/0]} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Neg (Exists P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[t/0])} \\<in> C) \\<and>\n     (\\<forall>P.\n         Exists P \\<in> S \\<longrightarrow>\n         (\\<exists>x. S \\<union> {P[App x []/0]} \\<in> C)) \\<and>\n     (\\<forall>P.\n         Neg (Forall P) \\<in> S \\<longrightarrow>\n         (\\<exists>x. S \\<union> {Neg (P[App x []/0])} \\<in> C))\n\ngoal (1 subgoal):\n 1. FF \\<notin> x", "by blast"], ["proof (state)\nthis:\n  FF \\<notin> x\n\ngoal (13 subgoals):\n 1. \\<And>S. S \\<in> close C \\<Longrightarrow> FF \\<notin> S\n 2. \\<And>S. S \\<in> close C \\<Longrightarrow> Neg TT \\<notin> S\n 3. \\<And>S Z.\n       \\<lbrakk>S \\<in> close C; Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z} \\<in> close C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B} \\<in> close C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B} \\<in> close C\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {Neg B} \\<in> close C\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 9. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> close C\n 10. \\<And>S P t.\n        \\<lbrakk>S \\<in> close C; closedt 0 t; Forall P \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> close C\nA total of 13 subgoals...", "then"], ["proof (chain)\npicking this:\n  FF \\<notin> x", "show \\<open>FF \\<notin> S\\<close>"], ["proof (prove)\nusing this:\n  FF \\<notin> x\n\ngoal (1 subgoal):\n 1. FF \\<notin> S", "using \\<open>S \\<subseteq> x\\<close>"], ["proof (prove)\nusing this:\n  FF \\<notin> x\n  S \\<subseteq> x\n\ngoal (1 subgoal):\n 1. FF \\<notin> S", "by blast"], ["proof (state)\nthis:\n  FF \\<notin> S\n\ngoal (12 subgoals):\n 1. \\<And>S. S \\<in> close C \\<Longrightarrow> Neg TT \\<notin> S\n 2. \\<And>S Z.\n       \\<lbrakk>S \\<in> close C; Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z} \\<in> close C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B} \\<in> close C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B} \\<in> close C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {Neg B} \\<in> close C\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> close C\n 9. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> close C\n 10. \\<And>S P t.\n        \\<lbrakk>S \\<in> close C; closedt 0 t;\n         Neg (Exists P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> close C\nA total of 12 subgoals...", "}"], ["proof (state)\nthis:\n  FF \\<notin> S\n\ngoal (12 subgoals):\n 1. \\<And>S. S \\<in> close C \\<Longrightarrow> Neg TT \\<notin> S\n 2. \\<And>S Z.\n       \\<lbrakk>S \\<in> close C; Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z} \\<in> close C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B} \\<in> close C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B} \\<in> close C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {Neg B} \\<in> close C\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> close C\n 9. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> close C\n 10. \\<And>S P t.\n        \\<lbrakk>S \\<in> close C; closedt 0 t;\n         Neg (Exists P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> close C\nA total of 12 subgoals...", "{"], ["proof (state)\nthis:\n  FF \\<notin> S\n\ngoal (12 subgoals):\n 1. \\<And>S. S \\<in> close C \\<Longrightarrow> Neg TT \\<notin> S\n 2. \\<And>S Z.\n       \\<lbrakk>S \\<in> close C; Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z} \\<in> close C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B} \\<in> close C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B} \\<in> close C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {Neg B} \\<in> close C\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> close C\n 9. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> close C\n 10. \\<And>S P t.\n        \\<lbrakk>S \\<in> close C; closedt 0 t;\n         Neg (Exists P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> close C\nA total of 12 subgoals...", "have \\<open>Neg TT \\<notin> x\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Neg TT \\<notin> x", "using \\<open>x \\<in> C\\<close> conc"], ["proof (prove)\nusing this:\n  x \\<in> C\n  consistency C\n\ngoal (1 subgoal):\n 1. Neg TT \\<notin> x", "unfolding consistency_def"], ["proof (prove)\nusing this:\n  x \\<in> C\n  \\<forall>S.\n     S \\<in> C \\<longrightarrow>\n     (\\<forall>p ts.\n         \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)) \\<and>\n     FF \\<notin> S \\<and>\n     Neg TT \\<notin> S \\<and>\n     (\\<forall>Z.\n         Neg (Neg Z) \\<in> S \\<longrightarrow>\n         S \\<union> {Z} \\<in> C) \\<and>\n     (\\<forall>A B.\n         And A B \\<in> S \\<longrightarrow> S \\<union> {A, B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Or A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A, Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Or A B \\<in> S \\<longrightarrow>\n         S \\<union> {A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (And A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Impl A B \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Impl A B) \\<in> S \\<longrightarrow>\n         S \\<union> {A, Neg B} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Forall P \\<in> S \\<longrightarrow>\n         S \\<union> {P[t/0]} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Neg (Exists P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[t/0])} \\<in> C) \\<and>\n     (\\<forall>P.\n         Exists P \\<in> S \\<longrightarrow>\n         (\\<exists>x. S \\<union> {P[App x []/0]} \\<in> C)) \\<and>\n     (\\<forall>P.\n         Neg (Forall P) \\<in> S \\<longrightarrow>\n         (\\<exists>x. S \\<union> {Neg (P[App x []/0])} \\<in> C))\n\ngoal (1 subgoal):\n 1. Neg TT \\<notin> x", "by blast"], ["proof (state)\nthis:\n  Neg TT \\<notin> x\n\ngoal (12 subgoals):\n 1. \\<And>S. S \\<in> close C \\<Longrightarrow> Neg TT \\<notin> S\n 2. \\<And>S Z.\n       \\<lbrakk>S \\<in> close C; Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z} \\<in> close C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B} \\<in> close C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B} \\<in> close C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {Neg B} \\<in> close C\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> close C\n 9. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> close C\n 10. \\<And>S P t.\n        \\<lbrakk>S \\<in> close C; closedt 0 t;\n         Neg (Exists P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> close C\nA total of 12 subgoals...", "then"], ["proof (chain)\npicking this:\n  Neg TT \\<notin> x", "show \\<open>Neg TT \\<notin> S\\<close>"], ["proof (prove)\nusing this:\n  Neg TT \\<notin> x\n\ngoal (1 subgoal):\n 1. Neg TT \\<notin> S", "using \\<open>S \\<subseteq> x\\<close>"], ["proof (prove)\nusing this:\n  Neg TT \\<notin> x\n  S \\<subseteq> x\n\ngoal (1 subgoal):\n 1. Neg TT \\<notin> S", "by blast"], ["proof (state)\nthis:\n  Neg TT \\<notin> S\n\ngoal (11 subgoals):\n 1. \\<And>S Z.\n       \\<lbrakk>S \\<in> close C; Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z} \\<in> close C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B} \\<in> close C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B} \\<in> close C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {Neg B} \\<in> close C\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> close C\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> close C\n 9. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> close C\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> close C; Exists P \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {P[App x []/0]} \\<in> close C\nA total of 11 subgoals...", "}"], ["proof (state)\nthis:\n  Neg TT \\<notin> S\n\ngoal (11 subgoals):\n 1. \\<And>S Z.\n       \\<lbrakk>S \\<in> close C; Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z} \\<in> close C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B} \\<in> close C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B} \\<in> close C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {Neg B} \\<in> close C\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> close C\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> close C\n 9. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> close C\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> close C; Exists P \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {P[App x []/0]} \\<in> close C\nA total of 11 subgoals...", "{"], ["proof (state)\nthis:\n  Neg TT \\<notin> S\n\ngoal (11 subgoals):\n 1. \\<And>S Z.\n       \\<lbrakk>S \\<in> close C; Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z} \\<in> close C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B} \\<in> close C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B} \\<in> close C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {Neg B} \\<in> close C\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> close C\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> close C\n 9. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> close C\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> close C; Exists P \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {P[App x []/0]} \\<in> close C\nA total of 11 subgoals...", "fix Z"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>S Z.\n       \\<lbrakk>S \\<in> close C; Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z} \\<in> close C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B} \\<in> close C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B} \\<in> close C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {Neg B} \\<in> close C\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> close C\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> close C\n 9. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> close C\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> close C; Exists P \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {P[App x []/0]} \\<in> close C\nA total of 11 subgoals...", "assume \\<open>Neg (Neg Z) \\<in> S\\<close>"], ["proof (state)\nthis:\n  Neg (Neg Z) \\<in> S\n\ngoal (11 subgoals):\n 1. \\<And>S Z.\n       \\<lbrakk>S \\<in> close C; Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z} \\<in> close C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B} \\<in> close C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B} \\<in> close C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {Neg B} \\<in> close C\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> close C\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> close C\n 9. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> close C\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> close C; Exists P \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {P[App x []/0]} \\<in> close C\nA total of 11 subgoals...", "then"], ["proof (chain)\npicking this:\n  Neg (Neg Z) \\<in> S", "have \\<open>Neg (Neg Z) \\<in> x\\<close>"], ["proof (prove)\nusing this:\n  Neg (Neg Z) \\<in> S\n\ngoal (1 subgoal):\n 1. Neg (Neg Z) \\<in> x", "using \\<open>S \\<subseteq> x\\<close>"], ["proof (prove)\nusing this:\n  Neg (Neg Z) \\<in> S\n  S \\<subseteq> x\n\ngoal (1 subgoal):\n 1. Neg (Neg Z) \\<in> x", "by blast"], ["proof (state)\nthis:\n  Neg (Neg Z) \\<in> x\n\ngoal (11 subgoals):\n 1. \\<And>S Z.\n       \\<lbrakk>S \\<in> close C; Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z} \\<in> close C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B} \\<in> close C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B} \\<in> close C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {Neg B} \\<in> close C\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> close C\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> close C\n 9. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> close C\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> close C; Exists P \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {P[App x []/0]} \\<in> close C\nA total of 11 subgoals...", "then"], ["proof (chain)\npicking this:\n  Neg (Neg Z) \\<in> x", "have \\<open>x \\<union> {Z} \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  Neg (Neg Z) \\<in> x\n\ngoal (1 subgoal):\n 1. x \\<union> {Z} \\<in> C", "using \\<open>x \\<in> C\\<close> conc"], ["proof (prove)\nusing this:\n  Neg (Neg Z) \\<in> x\n  x \\<in> C\n  consistency C\n\ngoal (1 subgoal):\n 1. x \\<union> {Z} \\<in> C", "unfolding consistency_def"], ["proof (prove)\nusing this:\n  Neg (Neg Z) \\<in> x\n  x \\<in> C\n  \\<forall>S.\n     S \\<in> C \\<longrightarrow>\n     (\\<forall>p ts.\n         \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)) \\<and>\n     FF \\<notin> S \\<and>\n     Neg TT \\<notin> S \\<and>\n     (\\<forall>Z.\n         Neg (Neg Z) \\<in> S \\<longrightarrow>\n         S \\<union> {Z} \\<in> C) \\<and>\n     (\\<forall>A B.\n         And A B \\<in> S \\<longrightarrow> S \\<union> {A, B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Or A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A, Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Or A B \\<in> S \\<longrightarrow>\n         S \\<union> {A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (And A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Impl A B \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Impl A B) \\<in> S \\<longrightarrow>\n         S \\<union> {A, Neg B} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Forall P \\<in> S \\<longrightarrow>\n         S \\<union> {P[t/0]} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Neg (Exists P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[t/0])} \\<in> C) \\<and>\n     (\\<forall>P.\n         Exists P \\<in> S \\<longrightarrow>\n         (\\<exists>x. S \\<union> {P[App x []/0]} \\<in> C)) \\<and>\n     (\\<forall>P.\n         Neg (Forall P) \\<in> S \\<longrightarrow>\n         (\\<exists>x. S \\<union> {Neg (P[App x []/0])} \\<in> C))\n\ngoal (1 subgoal):\n 1. x \\<union> {Z} \\<in> C", "by simp"], ["proof (state)\nthis:\n  x \\<union> {Z} \\<in> C\n\ngoal (11 subgoals):\n 1. \\<And>S Z.\n       \\<lbrakk>S \\<in> close C; Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z} \\<in> close C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B} \\<in> close C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B} \\<in> close C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {Neg B} \\<in> close C\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> close C\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> close C\n 9. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> close C\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> close C; Exists P \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {P[App x []/0]} \\<in> close C\nA total of 11 subgoals...", "then"], ["proof (chain)\npicking this:\n  x \\<union> {Z} \\<in> C", "show \\<open>S \\<union> {Z} \\<in> close C\\<close>"], ["proof (prove)\nusing this:\n  x \\<union> {Z} \\<in> C\n\ngoal (1 subgoal):\n 1. S \\<union> {Z} \\<in> close C", "using \\<open>S \\<subseteq> x\\<close> subset_in_close"], ["proof (prove)\nusing this:\n  x \\<union> {Z} \\<in> C\n  S \\<subseteq> x\n  ?S \\<subseteq> ?S' \\<Longrightarrow>\n  ?S' \\<union> ?x \\<in> ?C \\<longrightarrow> ?S \\<union> ?x \\<in> close ?C\n\ngoal (1 subgoal):\n 1. S \\<union> {Z} \\<in> close C", "by blast"], ["proof (state)\nthis:\n  S \\<union> {Z} \\<in> close C\n\ngoal (10 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B} \\<in> close C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B} \\<in> close C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {Neg B} \\<in> close C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> close C\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> close C\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> close C\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]} \\<in> close C\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> close C; Neg (Forall P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {Neg (P[App x []/0])} \\<in> close C", "}"], ["proof (state)\nthis:\n  Neg (Neg ?Z2) \\<in> S \\<Longrightarrow> S \\<union> {?Z2} \\<in> close C\n\ngoal (10 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B} \\<in> close C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B} \\<in> close C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {Neg B} \\<in> close C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> close C\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> close C\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> close C\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]} \\<in> close C\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> close C; Neg (Forall P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {Neg (P[App x []/0])} \\<in> close C", "{"], ["proof (state)\nthis:\n  Neg (Neg ?Z2) \\<in> S \\<Longrightarrow> S \\<union> {?Z2} \\<in> close C\n\ngoal (10 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B} \\<in> close C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B} \\<in> close C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {Neg B} \\<in> close C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> close C\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> close C\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> close C\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]} \\<in> close C\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> close C; Neg (Forall P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {Neg (P[App x []/0])} \\<in> close C", "fix A B"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B} \\<in> close C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B} \\<in> close C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {Neg B} \\<in> close C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> close C\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> close C\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> close C\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]} \\<in> close C\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> close C; Neg (Forall P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {Neg (P[App x []/0])} \\<in> close C", "assume \\<open>And A B \\<in> S\\<close>"], ["proof (state)\nthis:\n  And A B \\<in> S\n\ngoal (10 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B} \\<in> close C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B} \\<in> close C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {Neg B} \\<in> close C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> close C\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> close C\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> close C\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]} \\<in> close C\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> close C; Neg (Forall P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {Neg (P[App x []/0])} \\<in> close C", "then"], ["proof (chain)\npicking this:\n  And A B \\<in> S", "have \\<open>And A B \\<in> x\\<close>"], ["proof (prove)\nusing this:\n  And A B \\<in> S\n\ngoal (1 subgoal):\n 1. And A B \\<in> x", "using \\<open>S \\<subseteq> x\\<close>"], ["proof (prove)\nusing this:\n  And A B \\<in> S\n  S \\<subseteq> x\n\ngoal (1 subgoal):\n 1. And A B \\<in> x", "by blast"], ["proof (state)\nthis:\n  And A B \\<in> x\n\ngoal (10 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B} \\<in> close C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B} \\<in> close C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {Neg B} \\<in> close C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> close C\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> close C\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> close C\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]} \\<in> close C\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> close C; Neg (Forall P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {Neg (P[App x []/0])} \\<in> close C", "then"], ["proof (chain)\npicking this:\n  And A B \\<in> x", "have \\<open>x \\<union> {A, B} \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  And A B \\<in> x\n\ngoal (1 subgoal):\n 1. x \\<union> {A, B} \\<in> C", "using \\<open>x \\<in> C\\<close> conc"], ["proof (prove)\nusing this:\n  And A B \\<in> x\n  x \\<in> C\n  consistency C\n\ngoal (1 subgoal):\n 1. x \\<union> {A, B} \\<in> C", "unfolding consistency_def"], ["proof (prove)\nusing this:\n  And A B \\<in> x\n  x \\<in> C\n  \\<forall>S.\n     S \\<in> C \\<longrightarrow>\n     (\\<forall>p ts.\n         \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)) \\<and>\n     FF \\<notin> S \\<and>\n     Neg TT \\<notin> S \\<and>\n     (\\<forall>Z.\n         Neg (Neg Z) \\<in> S \\<longrightarrow>\n         S \\<union> {Z} \\<in> C) \\<and>\n     (\\<forall>A B.\n         And A B \\<in> S \\<longrightarrow> S \\<union> {A, B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Or A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A, Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Or A B \\<in> S \\<longrightarrow>\n         S \\<union> {A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (And A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Impl A B \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Impl A B) \\<in> S \\<longrightarrow>\n         S \\<union> {A, Neg B} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Forall P \\<in> S \\<longrightarrow>\n         S \\<union> {P[t/0]} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Neg (Exists P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[t/0])} \\<in> C) \\<and>\n     (\\<forall>P.\n         Exists P \\<in> S \\<longrightarrow>\n         (\\<exists>x. S \\<union> {P[App x []/0]} \\<in> C)) \\<and>\n     (\\<forall>P.\n         Neg (Forall P) \\<in> S \\<longrightarrow>\n         (\\<exists>x. S \\<union> {Neg (P[App x []/0])} \\<in> C))\n\ngoal (1 subgoal):\n 1. x \\<union> {A, B} \\<in> C", "by simp"], ["proof (state)\nthis:\n  x \\<union> {A, B} \\<in> C\n\ngoal (10 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B} \\<in> close C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B} \\<in> close C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {Neg B} \\<in> close C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> close C\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> close C\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> close C\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]} \\<in> close C\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> close C; Neg (Forall P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {Neg (P[App x []/0])} \\<in> close C", "then"], ["proof (chain)\npicking this:\n  x \\<union> {A, B} \\<in> C", "show \\<open>S \\<union> {A, B} \\<in> close C\\<close>"], ["proof (prove)\nusing this:\n  x \\<union> {A, B} \\<in> C\n\ngoal (1 subgoal):\n 1. S \\<union> {A, B} \\<in> close C", "using \\<open>S \\<subseteq> x\\<close> subset_in_close"], ["proof (prove)\nusing this:\n  x \\<union> {A, B} \\<in> C\n  S \\<subseteq> x\n  ?S \\<subseteq> ?S' \\<Longrightarrow>\n  ?S' \\<union> ?x \\<in> ?C \\<longrightarrow> ?S \\<union> ?x \\<in> close ?C\n\ngoal (1 subgoal):\n 1. S \\<union> {A, B} \\<in> close C", "by blast"], ["proof (state)\nthis:\n  S \\<union> {A, B} \\<in> close C\n\ngoal (9 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B} \\<in> close C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {Neg B} \\<in> close C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> close C\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> close C\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> close C\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]} \\<in> close C\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])} \\<in> close C", "}"], ["proof (state)\nthis:\n  And ?A2 ?B2 \\<in> S \\<Longrightarrow> S \\<union> {?A2, ?B2} \\<in> close C\n\ngoal (9 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B} \\<in> close C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {Neg B} \\<in> close C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> close C\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> close C\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> close C\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]} \\<in> close C\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])} \\<in> close C", "{"], ["proof (state)\nthis:\n  And ?A2 ?B2 \\<in> S \\<Longrightarrow> S \\<union> {?A2, ?B2} \\<in> close C\n\ngoal (9 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B} \\<in> close C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {Neg B} \\<in> close C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> close C\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> close C\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> close C\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]} \\<in> close C\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])} \\<in> close C", "fix A B"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B} \\<in> close C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {Neg B} \\<in> close C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> close C\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> close C\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> close C\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]} \\<in> close C\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])} \\<in> close C", "assume \\<open>Neg (Or A B) \\<in> S\\<close>"], ["proof (state)\nthis:\n  Neg (Or A B) \\<in> S\n\ngoal (9 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B} \\<in> close C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {Neg B} \\<in> close C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> close C\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> close C\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> close C\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]} \\<in> close C\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])} \\<in> close C", "then"], ["proof (chain)\npicking this:\n  Neg (Or A B) \\<in> S", "have \\<open>Neg (Or A B) \\<in> x\\<close>"], ["proof (prove)\nusing this:\n  Neg (Or A B) \\<in> S\n\ngoal (1 subgoal):\n 1. Neg (Or A B) \\<in> x", "using \\<open>S \\<subseteq> x\\<close>"], ["proof (prove)\nusing this:\n  Neg (Or A B) \\<in> S\n  S \\<subseteq> x\n\ngoal (1 subgoal):\n 1. Neg (Or A B) \\<in> x", "by blast"], ["proof (state)\nthis:\n  Neg (Or A B) \\<in> x\n\ngoal (9 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B} \\<in> close C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {Neg B} \\<in> close C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> close C\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> close C\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> close C\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]} \\<in> close C\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])} \\<in> close C", "then"], ["proof (chain)\npicking this:\n  Neg (Or A B) \\<in> x", "have \\<open>x \\<union> {Neg A, Neg B} \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  Neg (Or A B) \\<in> x\n\ngoal (1 subgoal):\n 1. x \\<union> {Neg A, Neg B} \\<in> C", "using \\<open>x \\<in> C\\<close> conc"], ["proof (prove)\nusing this:\n  Neg (Or A B) \\<in> x\n  x \\<in> C\n  consistency C\n\ngoal (1 subgoal):\n 1. x \\<union> {Neg A, Neg B} \\<in> C", "unfolding consistency_def"], ["proof (prove)\nusing this:\n  Neg (Or A B) \\<in> x\n  x \\<in> C\n  \\<forall>S.\n     S \\<in> C \\<longrightarrow>\n     (\\<forall>p ts.\n         \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)) \\<and>\n     FF \\<notin> S \\<and>\n     Neg TT \\<notin> S \\<and>\n     (\\<forall>Z.\n         Neg (Neg Z) \\<in> S \\<longrightarrow>\n         S \\<union> {Z} \\<in> C) \\<and>\n     (\\<forall>A B.\n         And A B \\<in> S \\<longrightarrow> S \\<union> {A, B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Or A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A, Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Or A B \\<in> S \\<longrightarrow>\n         S \\<union> {A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (And A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Impl A B \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Impl A B) \\<in> S \\<longrightarrow>\n         S \\<union> {A, Neg B} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Forall P \\<in> S \\<longrightarrow>\n         S \\<union> {P[t/0]} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Neg (Exists P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[t/0])} \\<in> C) \\<and>\n     (\\<forall>P.\n         Exists P \\<in> S \\<longrightarrow>\n         (\\<exists>x. S \\<union> {P[App x []/0]} \\<in> C)) \\<and>\n     (\\<forall>P.\n         Neg (Forall P) \\<in> S \\<longrightarrow>\n         (\\<exists>x. S \\<union> {Neg (P[App x []/0])} \\<in> C))\n\ngoal (1 subgoal):\n 1. x \\<union> {Neg A, Neg B} \\<in> C", "by simp"], ["proof (state)\nthis:\n  x \\<union> {Neg A, Neg B} \\<in> C\n\ngoal (9 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B} \\<in> close C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {Neg B} \\<in> close C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> close C\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> close C\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> close C\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]} \\<in> close C\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])} \\<in> close C", "then"], ["proof (chain)\npicking this:\n  x \\<union> {Neg A, Neg B} \\<in> C", "show \\<open>S \\<union> {Neg A, Neg B} \\<in> close C\\<close>"], ["proof (prove)\nusing this:\n  x \\<union> {Neg A, Neg B} \\<in> C\n\ngoal (1 subgoal):\n 1. S \\<union> {Neg A, Neg B} \\<in> close C", "using \\<open>S \\<subseteq> x\\<close> subset_in_close"], ["proof (prove)\nusing this:\n  x \\<union> {Neg A, Neg B} \\<in> C\n  S \\<subseteq> x\n  ?S \\<subseteq> ?S' \\<Longrightarrow>\n  ?S' \\<union> ?x \\<in> ?C \\<longrightarrow> ?S \\<union> ?x \\<in> close ?C\n\ngoal (1 subgoal):\n 1. S \\<union> {Neg A, Neg B} \\<in> close C", "by blast"], ["proof (state)\nthis:\n  S \\<union> {Neg A, Neg B} \\<in> close C\n\ngoal (8 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {Neg B} \\<in> close C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> close C\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> close C\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> close C\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]} \\<in> close C\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])} \\<in> close C", "}"], ["proof (state)\nthis:\n  Neg (Or ?A2 ?B2) \\<in> S \\<Longrightarrow>\n  S \\<union> {Neg ?A2, Neg ?B2} \\<in> close C\n\ngoal (8 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {Neg B} \\<in> close C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> close C\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> close C\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> close C\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]} \\<in> close C\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])} \\<in> close C", "{"], ["proof (state)\nthis:\n  Neg (Or ?A2 ?B2) \\<in> S \\<Longrightarrow>\n  S \\<union> {Neg ?A2, Neg ?B2} \\<in> close C\n\ngoal (8 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {Neg B} \\<in> close C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> close C\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> close C\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> close C\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]} \\<in> close C\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])} \\<in> close C", "fix A B"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {Neg B} \\<in> close C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> close C\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> close C\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> close C\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]} \\<in> close C\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])} \\<in> close C", "assume \\<open>Or A B \\<in> S\\<close>"], ["proof (state)\nthis:\n  Or A B \\<in> S\n\ngoal (8 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {Neg B} \\<in> close C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> close C\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> close C\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> close C\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]} \\<in> close C\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])} \\<in> close C", "then"], ["proof (chain)\npicking this:\n  Or A B \\<in> S", "have \\<open>Or A B \\<in> x\\<close>"], ["proof (prove)\nusing this:\n  Or A B \\<in> S\n\ngoal (1 subgoal):\n 1. Or A B \\<in> x", "using \\<open>S \\<subseteq> x\\<close>"], ["proof (prove)\nusing this:\n  Or A B \\<in> S\n  S \\<subseteq> x\n\ngoal (1 subgoal):\n 1. Or A B \\<in> x", "by blast"], ["proof (state)\nthis:\n  Or A B \\<in> x\n\ngoal (8 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {Neg B} \\<in> close C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> close C\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> close C\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> close C\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]} \\<in> close C\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])} \\<in> close C", "then"], ["proof (chain)\npicking this:\n  Or A B \\<in> x", "have \\<open>x \\<union> {A} \\<in> C \\<or> x \\<union> {B} \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  Or A B \\<in> x\n\ngoal (1 subgoal):\n 1. x \\<union> {A} \\<in> C \\<or> x \\<union> {B} \\<in> C", "using \\<open>x \\<in> C\\<close> conc"], ["proof (prove)\nusing this:\n  Or A B \\<in> x\n  x \\<in> C\n  consistency C\n\ngoal (1 subgoal):\n 1. x \\<union> {A} \\<in> C \\<or> x \\<union> {B} \\<in> C", "unfolding consistency_def"], ["proof (prove)\nusing this:\n  Or A B \\<in> x\n  x \\<in> C\n  \\<forall>S.\n     S \\<in> C \\<longrightarrow>\n     (\\<forall>p ts.\n         \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)) \\<and>\n     FF \\<notin> S \\<and>\n     Neg TT \\<notin> S \\<and>\n     (\\<forall>Z.\n         Neg (Neg Z) \\<in> S \\<longrightarrow>\n         S \\<union> {Z} \\<in> C) \\<and>\n     (\\<forall>A B.\n         And A B \\<in> S \\<longrightarrow> S \\<union> {A, B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Or A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A, Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Or A B \\<in> S \\<longrightarrow>\n         S \\<union> {A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (And A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Impl A B \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Impl A B) \\<in> S \\<longrightarrow>\n         S \\<union> {A, Neg B} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Forall P \\<in> S \\<longrightarrow>\n         S \\<union> {P[t/0]} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Neg (Exists P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[t/0])} \\<in> C) \\<and>\n     (\\<forall>P.\n         Exists P \\<in> S \\<longrightarrow>\n         (\\<exists>x. S \\<union> {P[App x []/0]} \\<in> C)) \\<and>\n     (\\<forall>P.\n         Neg (Forall P) \\<in> S \\<longrightarrow>\n         (\\<exists>x. S \\<union> {Neg (P[App x []/0])} \\<in> C))\n\ngoal (1 subgoal):\n 1. x \\<union> {A} \\<in> C \\<or> x \\<union> {B} \\<in> C", "by simp"], ["proof (state)\nthis:\n  x \\<union> {A} \\<in> C \\<or> x \\<union> {B} \\<in> C\n\ngoal (8 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {Neg B} \\<in> close C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> close C\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> close C\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> close C\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]} \\<in> close C\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])} \\<in> close C", "then"], ["proof (chain)\npicking this:\n  x \\<union> {A} \\<in> C \\<or> x \\<union> {B} \\<in> C", "show \\<open>S \\<union> {A} \\<in> close C \\<or> S \\<union> {B} \\<in> close C\\<close>"], ["proof (prove)\nusing this:\n  x \\<union> {A} \\<in> C \\<or> x \\<union> {B} \\<in> C\n\ngoal (1 subgoal):\n 1. S \\<union> {A} \\<in> close C \\<or> S \\<union> {B} \\<in> close C", "using \\<open>S \\<subseteq> x\\<close> subset_in_close"], ["proof (prove)\nusing this:\n  x \\<union> {A} \\<in> C \\<or> x \\<union> {B} \\<in> C\n  S \\<subseteq> x\n  ?S \\<subseteq> ?S' \\<Longrightarrow>\n  ?S' \\<union> ?x \\<in> ?C \\<longrightarrow> ?S \\<union> ?x \\<in> close ?C\n\ngoal (1 subgoal):\n 1. S \\<union> {A} \\<in> close C \\<or> S \\<union> {B} \\<in> close C", "by blast"], ["proof (state)\nthis:\n  S \\<union> {A} \\<in> close C \\<or> S \\<union> {B} \\<in> close C\n\ngoal (7 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {Neg B} \\<in> close C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> close C\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> close C\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> close C\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]} \\<in> close C\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])} \\<in> close C", "}"], ["proof (state)\nthis:\n  Or ?A2 ?B2 \\<in> S \\<Longrightarrow>\n  S \\<union> {?A2} \\<in> close C \\<or> S \\<union> {?B2} \\<in> close C\n\ngoal (7 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {Neg B} \\<in> close C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> close C\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> close C\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> close C\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]} \\<in> close C\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])} \\<in> close C", "{"], ["proof (state)\nthis:\n  Or ?A2 ?B2 \\<in> S \\<Longrightarrow>\n  S \\<union> {?A2} \\<in> close C \\<or> S \\<union> {?B2} \\<in> close C\n\ngoal (7 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {Neg B} \\<in> close C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> close C\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> close C\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> close C\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]} \\<in> close C\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])} \\<in> close C", "fix A B"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {Neg B} \\<in> close C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> close C\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> close C\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> close C\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]} \\<in> close C\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])} \\<in> close C", "assume \\<open>Neg (And A B) \\<in> S\\<close>"], ["proof (state)\nthis:\n  Neg (And A B) \\<in> S\n\ngoal (7 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {Neg B} \\<in> close C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> close C\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> close C\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> close C\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]} \\<in> close C\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])} \\<in> close C", "then"], ["proof (chain)\npicking this:\n  Neg (And A B) \\<in> S", "have \\<open>Neg (And A B) \\<in> x\\<close>"], ["proof (prove)\nusing this:\n  Neg (And A B) \\<in> S\n\ngoal (1 subgoal):\n 1. Neg (And A B) \\<in> x", "using \\<open>S \\<subseteq> x\\<close>"], ["proof (prove)\nusing this:\n  Neg (And A B) \\<in> S\n  S \\<subseteq> x\n\ngoal (1 subgoal):\n 1. Neg (And A B) \\<in> x", "by blast"], ["proof (state)\nthis:\n  Neg (And A B) \\<in> x\n\ngoal (7 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {Neg B} \\<in> close C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> close C\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> close C\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> close C\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]} \\<in> close C\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])} \\<in> close C", "then"], ["proof (chain)\npicking this:\n  Neg (And A B) \\<in> x", "have \\<open>x \\<union> {Neg A} \\<in> C \\<or> x \\<union> {Neg B} \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  Neg (And A B) \\<in> x\n\ngoal (1 subgoal):\n 1. x \\<union> {Neg A} \\<in> C \\<or> x \\<union> {Neg B} \\<in> C", "using \\<open>x \\<in> C\\<close> conc"], ["proof (prove)\nusing this:\n  Neg (And A B) \\<in> x\n  x \\<in> C\n  consistency C\n\ngoal (1 subgoal):\n 1. x \\<union> {Neg A} \\<in> C \\<or> x \\<union> {Neg B} \\<in> C", "unfolding consistency_def"], ["proof (prove)\nusing this:\n  Neg (And A B) \\<in> x\n  x \\<in> C\n  \\<forall>S.\n     S \\<in> C \\<longrightarrow>\n     (\\<forall>p ts.\n         \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)) \\<and>\n     FF \\<notin> S \\<and>\n     Neg TT \\<notin> S \\<and>\n     (\\<forall>Z.\n         Neg (Neg Z) \\<in> S \\<longrightarrow>\n         S \\<union> {Z} \\<in> C) \\<and>\n     (\\<forall>A B.\n         And A B \\<in> S \\<longrightarrow> S \\<union> {A, B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Or A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A, Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Or A B \\<in> S \\<longrightarrow>\n         S \\<union> {A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (And A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Impl A B \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Impl A B) \\<in> S \\<longrightarrow>\n         S \\<union> {A, Neg B} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Forall P \\<in> S \\<longrightarrow>\n         S \\<union> {P[t/0]} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Neg (Exists P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[t/0])} \\<in> C) \\<and>\n     (\\<forall>P.\n         Exists P \\<in> S \\<longrightarrow>\n         (\\<exists>x. S \\<union> {P[App x []/0]} \\<in> C)) \\<and>\n     (\\<forall>P.\n         Neg (Forall P) \\<in> S \\<longrightarrow>\n         (\\<exists>x. S \\<union> {Neg (P[App x []/0])} \\<in> C))\n\ngoal (1 subgoal):\n 1. x \\<union> {Neg A} \\<in> C \\<or> x \\<union> {Neg B} \\<in> C", "by simp"], ["proof (state)\nthis:\n  x \\<union> {Neg A} \\<in> C \\<or> x \\<union> {Neg B} \\<in> C\n\ngoal (7 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {Neg B} \\<in> close C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> close C\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> close C\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> close C\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]} \\<in> close C\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])} \\<in> close C", "then"], ["proof (chain)\npicking this:\n  x \\<union> {Neg A} \\<in> C \\<or> x \\<union> {Neg B} \\<in> C", "show \\<open>S \\<union> {Neg A} \\<in> close C \\<or> S \\<union> {Neg B} \\<in> close C\\<close>"], ["proof (prove)\nusing this:\n  x \\<union> {Neg A} \\<in> C \\<or> x \\<union> {Neg B} \\<in> C\n\ngoal (1 subgoal):\n 1. S \\<union> {Neg A} \\<in> close C \\<or> S \\<union> {Neg B} \\<in> close C", "using \\<open>S \\<subseteq> x\\<close> subset_in_close"], ["proof (prove)\nusing this:\n  x \\<union> {Neg A} \\<in> C \\<or> x \\<union> {Neg B} \\<in> C\n  S \\<subseteq> x\n  ?S \\<subseteq> ?S' \\<Longrightarrow>\n  ?S' \\<union> ?x \\<in> ?C \\<longrightarrow> ?S \\<union> ?x \\<in> close ?C\n\ngoal (1 subgoal):\n 1. S \\<union> {Neg A} \\<in> close C \\<or> S \\<union> {Neg B} \\<in> close C", "by blast"], ["proof (state)\nthis:\n  S \\<union> {Neg A} \\<in> close C \\<or> S \\<union> {Neg B} \\<in> close C\n\ngoal (6 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> close C\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> close C\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> close C\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]} \\<in> close C\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])} \\<in> close C", "}"], ["proof (state)\nthis:\n  Neg (And ?A2 ?B2) \\<in> S \\<Longrightarrow>\n  S \\<union> {Neg ?A2} \\<in> close C \\<or>\n  S \\<union> {Neg ?B2} \\<in> close C\n\ngoal (6 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> close C\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> close C\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> close C\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]} \\<in> close C\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])} \\<in> close C", "{"], ["proof (state)\nthis:\n  Neg (And ?A2 ?B2) \\<in> S \\<Longrightarrow>\n  S \\<union> {Neg ?A2} \\<in> close C \\<or>\n  S \\<union> {Neg ?B2} \\<in> close C\n\ngoal (6 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> close C\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> close C\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> close C\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]} \\<in> close C\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])} \\<in> close C", "fix A B"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> close C\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> close C\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> close C\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]} \\<in> close C\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])} \\<in> close C", "assume \\<open>Impl A B \\<in> S\\<close>"], ["proof (state)\nthis:\n  Impl A B \\<in> S\n\ngoal (6 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> close C\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> close C\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> close C\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]} \\<in> close C\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])} \\<in> close C", "then"], ["proof (chain)\npicking this:\n  Impl A B \\<in> S", "have \\<open>Impl A B \\<in> x\\<close>"], ["proof (prove)\nusing this:\n  Impl A B \\<in> S\n\ngoal (1 subgoal):\n 1. Impl A B \\<in> x", "using \\<open>S \\<subseteq> x\\<close>"], ["proof (prove)\nusing this:\n  Impl A B \\<in> S\n  S \\<subseteq> x\n\ngoal (1 subgoal):\n 1. Impl A B \\<in> x", "by blast"], ["proof (state)\nthis:\n  Impl A B \\<in> x\n\ngoal (6 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> close C\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> close C\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> close C\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]} \\<in> close C\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])} \\<in> close C", "then"], ["proof (chain)\npicking this:\n  Impl A B \\<in> x", "have \\<open>x \\<union> {Neg A} \\<in> C \\<or> x \\<union> {B} \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  Impl A B \\<in> x\n\ngoal (1 subgoal):\n 1. x \\<union> {Neg A} \\<in> C \\<or> x \\<union> {B} \\<in> C", "using \\<open>x \\<in> C\\<close> conc"], ["proof (prove)\nusing this:\n  Impl A B \\<in> x\n  x \\<in> C\n  consistency C\n\ngoal (1 subgoal):\n 1. x \\<union> {Neg A} \\<in> C \\<or> x \\<union> {B} \\<in> C", "unfolding consistency_def"], ["proof (prove)\nusing this:\n  Impl A B \\<in> x\n  x \\<in> C\n  \\<forall>S.\n     S \\<in> C \\<longrightarrow>\n     (\\<forall>p ts.\n         \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)) \\<and>\n     FF \\<notin> S \\<and>\n     Neg TT \\<notin> S \\<and>\n     (\\<forall>Z.\n         Neg (Neg Z) \\<in> S \\<longrightarrow>\n         S \\<union> {Z} \\<in> C) \\<and>\n     (\\<forall>A B.\n         And A B \\<in> S \\<longrightarrow> S \\<union> {A, B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Or A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A, Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Or A B \\<in> S \\<longrightarrow>\n         S \\<union> {A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (And A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Impl A B \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Impl A B) \\<in> S \\<longrightarrow>\n         S \\<union> {A, Neg B} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Forall P \\<in> S \\<longrightarrow>\n         S \\<union> {P[t/0]} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Neg (Exists P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[t/0])} \\<in> C) \\<and>\n     (\\<forall>P.\n         Exists P \\<in> S \\<longrightarrow>\n         (\\<exists>x. S \\<union> {P[App x []/0]} \\<in> C)) \\<and>\n     (\\<forall>P.\n         Neg (Forall P) \\<in> S \\<longrightarrow>\n         (\\<exists>x. S \\<union> {Neg (P[App x []/0])} \\<in> C))\n\ngoal (1 subgoal):\n 1. x \\<union> {Neg A} \\<in> C \\<or> x \\<union> {B} \\<in> C", "by simp"], ["proof (state)\nthis:\n  x \\<union> {Neg A} \\<in> C \\<or> x \\<union> {B} \\<in> C\n\ngoal (6 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> close C \\<or>\n                         S \\<union> {B} \\<in> close C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> close C\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> close C\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> close C\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]} \\<in> close C\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])} \\<in> close C", "then"], ["proof (chain)\npicking this:\n  x \\<union> {Neg A} \\<in> C \\<or> x \\<union> {B} \\<in> C", "show \\<open>S \\<union> {Neg A} \\<in> close C \\<or> S \\<union> {B} \\<in> close C\\<close>"], ["proof (prove)\nusing this:\n  x \\<union> {Neg A} \\<in> C \\<or> x \\<union> {B} \\<in> C\n\ngoal (1 subgoal):\n 1. S \\<union> {Neg A} \\<in> close C \\<or> S \\<union> {B} \\<in> close C", "using \\<open>S \\<subseteq> x\\<close> subset_in_close"], ["proof (prove)\nusing this:\n  x \\<union> {Neg A} \\<in> C \\<or> x \\<union> {B} \\<in> C\n  S \\<subseteq> x\n  ?S \\<subseteq> ?S' \\<Longrightarrow>\n  ?S' \\<union> ?x \\<in> ?C \\<longrightarrow> ?S \\<union> ?x \\<in> close ?C\n\ngoal (1 subgoal):\n 1. S \\<union> {Neg A} \\<in> close C \\<or> S \\<union> {B} \\<in> close C", "by blast"], ["proof (state)\nthis:\n  S \\<union> {Neg A} \\<in> close C \\<or> S \\<union> {B} \\<in> close C\n\ngoal (5 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> close C\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> close C\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> close C\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]} \\<in> close C\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])} \\<in> close C", "}"], ["proof (state)\nthis:\n  Impl ?A2 ?B2 \\<in> S \\<Longrightarrow>\n  S \\<union> {Neg ?A2} \\<in> close C \\<or> S \\<union> {?B2} \\<in> close C\n\ngoal (5 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> close C\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> close C\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> close C\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]} \\<in> close C\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])} \\<in> close C", "{"], ["proof (state)\nthis:\n  Impl ?A2 ?B2 \\<in> S \\<Longrightarrow>\n  S \\<union> {Neg ?A2} \\<in> close C \\<or> S \\<union> {?B2} \\<in> close C\n\ngoal (5 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> close C\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> close C\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> close C\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]} \\<in> close C\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])} \\<in> close C", "fix A B"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> close C\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> close C\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> close C\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]} \\<in> close C\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])} \\<in> close C", "assume \\<open>Neg (Impl A B) \\<in> S\\<close>"], ["proof (state)\nthis:\n  Neg (Impl A B) \\<in> S\n\ngoal (5 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> close C\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> close C\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> close C\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]} \\<in> close C\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])} \\<in> close C", "then"], ["proof (chain)\npicking this:\n  Neg (Impl A B) \\<in> S", "have \\<open>Neg (Impl A B) \\<in> x\\<close>"], ["proof (prove)\nusing this:\n  Neg (Impl A B) \\<in> S\n\ngoal (1 subgoal):\n 1. Neg (Impl A B) \\<in> x", "using \\<open>S \\<subseteq> x\\<close>"], ["proof (prove)\nusing this:\n  Neg (Impl A B) \\<in> S\n  S \\<subseteq> x\n\ngoal (1 subgoal):\n 1. Neg (Impl A B) \\<in> x", "by blast"], ["proof (state)\nthis:\n  Neg (Impl A B) \\<in> x\n\ngoal (5 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> close C\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> close C\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> close C\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]} \\<in> close C\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])} \\<in> close C", "then"], ["proof (chain)\npicking this:\n  Neg (Impl A B) \\<in> x", "have \\<open>x \\<union> {A, Neg B} \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  Neg (Impl A B) \\<in> x\n\ngoal (1 subgoal):\n 1. x \\<union> {A, Neg B} \\<in> C", "using \\<open>x \\<in> C\\<close> conc"], ["proof (prove)\nusing this:\n  Neg (Impl A B) \\<in> x\n  x \\<in> C\n  consistency C\n\ngoal (1 subgoal):\n 1. x \\<union> {A, Neg B} \\<in> C", "unfolding consistency_def"], ["proof (prove)\nusing this:\n  Neg (Impl A B) \\<in> x\n  x \\<in> C\n  \\<forall>S.\n     S \\<in> C \\<longrightarrow>\n     (\\<forall>p ts.\n         \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)) \\<and>\n     FF \\<notin> S \\<and>\n     Neg TT \\<notin> S \\<and>\n     (\\<forall>Z.\n         Neg (Neg Z) \\<in> S \\<longrightarrow>\n         S \\<union> {Z} \\<in> C) \\<and>\n     (\\<forall>A B.\n         And A B \\<in> S \\<longrightarrow> S \\<union> {A, B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Or A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A, Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Or A B \\<in> S \\<longrightarrow>\n         S \\<union> {A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (And A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Impl A B \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Impl A B) \\<in> S \\<longrightarrow>\n         S \\<union> {A, Neg B} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Forall P \\<in> S \\<longrightarrow>\n         S \\<union> {P[t/0]} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Neg (Exists P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[t/0])} \\<in> C) \\<and>\n     (\\<forall>P.\n         Exists P \\<in> S \\<longrightarrow>\n         (\\<exists>x. S \\<union> {P[App x []/0]} \\<in> C)) \\<and>\n     (\\<forall>P.\n         Neg (Forall P) \\<in> S \\<longrightarrow>\n         (\\<exists>x. S \\<union> {Neg (P[App x []/0])} \\<in> C))\n\ngoal (1 subgoal):\n 1. x \\<union> {A, Neg B} \\<in> C", "by blast"], ["proof (state)\nthis:\n  x \\<union> {A, Neg B} \\<in> C\n\ngoal (5 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> close C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> close C\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> close C\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> close C\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]} \\<in> close C\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])} \\<in> close C", "then"], ["proof (chain)\npicking this:\n  x \\<union> {A, Neg B} \\<in> C", "show \\<open>S \\<union> {A, Neg B} \\<in> close C\\<close>"], ["proof (prove)\nusing this:\n  x \\<union> {A, Neg B} \\<in> C\n\ngoal (1 subgoal):\n 1. S \\<union> {A, Neg B} \\<in> close C", "using \\<open>S \\<subseteq> x\\<close> subset_in_close"], ["proof (prove)\nusing this:\n  x \\<union> {A, Neg B} \\<in> C\n  S \\<subseteq> x\n  ?S \\<subseteq> ?S' \\<Longrightarrow>\n  ?S' \\<union> ?x \\<in> ?C \\<longrightarrow> ?S \\<union> ?x \\<in> close ?C\n\ngoal (1 subgoal):\n 1. S \\<union> {A, Neg B} \\<in> close C", "by blast"], ["proof (state)\nthis:\n  S \\<union> {A, Neg B} \\<in> close C\n\ngoal (4 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> close C\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> close C\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]} \\<in> close C\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])} \\<in> close C", "}"], ["proof (state)\nthis:\n  Neg (Impl ?A2 ?B2) \\<in> S \\<Longrightarrow>\n  S \\<union> {?A2, Neg ?B2} \\<in> close C\n\ngoal (4 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> close C\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> close C\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]} \\<in> close C\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])} \\<in> close C", "{"], ["proof (state)\nthis:\n  Neg (Impl ?A2 ?B2) \\<in> S \\<Longrightarrow>\n  S \\<union> {?A2, Neg ?B2} \\<in> close C\n\ngoal (4 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> close C\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> close C\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]} \\<in> close C\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])} \\<in> close C", "fix P and t :: \\<open>'a term\\<close>"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> close C\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> close C\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]} \\<in> close C\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])} \\<in> close C", "assume \\<open>closedt 0 t\\<close> and \\<open>Forall P \\<in> S\\<close>"], ["proof (state)\nthis:\n  closedt 0 t\n  Forall P \\<in> S\n\ngoal (4 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> close C\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> close C\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]} \\<in> close C\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])} \\<in> close C", "then"], ["proof (chain)\npicking this:\n  closedt 0 t\n  Forall P \\<in> S", "have \\<open>Forall P \\<in> x\\<close>"], ["proof (prove)\nusing this:\n  closedt 0 t\n  Forall P \\<in> S\n\ngoal (1 subgoal):\n 1. Forall P \\<in> x", "using \\<open>S \\<subseteq> x\\<close>"], ["proof (prove)\nusing this:\n  closedt 0 t\n  Forall P \\<in> S\n  S \\<subseteq> x\n\ngoal (1 subgoal):\n 1. Forall P \\<in> x", "by blast"], ["proof (state)\nthis:\n  Forall P \\<in> x\n\ngoal (4 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> close C\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> close C\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]} \\<in> close C\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])} \\<in> close C", "then"], ["proof (chain)\npicking this:\n  Forall P \\<in> x", "have \\<open>x \\<union> {P[t/0]} \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  Forall P \\<in> x\n\ngoal (1 subgoal):\n 1. x \\<union> {P[t/0]} \\<in> C", "using \\<open>closedt 0 t\\<close> \\<open>x \\<in> C\\<close> conc"], ["proof (prove)\nusing this:\n  Forall P \\<in> x\n  closedt 0 t\n  x \\<in> C\n  consistency C\n\ngoal (1 subgoal):\n 1. x \\<union> {P[t/0]} \\<in> C", "unfolding consistency_def"], ["proof (prove)\nusing this:\n  Forall P \\<in> x\n  closedt 0 t\n  x \\<in> C\n  \\<forall>S.\n     S \\<in> C \\<longrightarrow>\n     (\\<forall>p ts.\n         \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)) \\<and>\n     FF \\<notin> S \\<and>\n     Neg TT \\<notin> S \\<and>\n     (\\<forall>Z.\n         Neg (Neg Z) \\<in> S \\<longrightarrow>\n         S \\<union> {Z} \\<in> C) \\<and>\n     (\\<forall>A B.\n         And A B \\<in> S \\<longrightarrow> S \\<union> {A, B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Or A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A, Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Or A B \\<in> S \\<longrightarrow>\n         S \\<union> {A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (And A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Impl A B \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Impl A B) \\<in> S \\<longrightarrow>\n         S \\<union> {A, Neg B} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Forall P \\<in> S \\<longrightarrow>\n         S \\<union> {P[t/0]} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Neg (Exists P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[t/0])} \\<in> C) \\<and>\n     (\\<forall>P.\n         Exists P \\<in> S \\<longrightarrow>\n         (\\<exists>x. S \\<union> {P[App x []/0]} \\<in> C)) \\<and>\n     (\\<forall>P.\n         Neg (Forall P) \\<in> S \\<longrightarrow>\n         (\\<exists>x. S \\<union> {Neg (P[App x []/0])} \\<in> C))\n\ngoal (1 subgoal):\n 1. x \\<union> {P[t/0]} \\<in> C", "by blast"], ["proof (state)\nthis:\n  x \\<union> {P[t/0]} \\<in> C\n\ngoal (4 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> close C\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> close C\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]} \\<in> close C\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])} \\<in> close C", "then"], ["proof (chain)\npicking this:\n  x \\<union> {P[t/0]} \\<in> C", "show \\<open>S \\<union> {P[t/0]} \\<in> close C\\<close>"], ["proof (prove)\nusing this:\n  x \\<union> {P[t/0]} \\<in> C\n\ngoal (1 subgoal):\n 1. S \\<union> {P[t/0]} \\<in> close C", "using \\<open>S \\<subseteq> x\\<close> subset_in_close"], ["proof (prove)\nusing this:\n  x \\<union> {P[t/0]} \\<in> C\n  S \\<subseteq> x\n  ?S \\<subseteq> ?S' \\<Longrightarrow>\n  ?S' \\<union> ?x \\<in> ?C \\<longrightarrow> ?S \\<union> ?x \\<in> close ?C\n\ngoal (1 subgoal):\n 1. S \\<union> {P[t/0]} \\<in> close C", "by blast"], ["proof (state)\nthis:\n  S \\<union> {P[t/0]} \\<in> close C\n\ngoal (3 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> close C\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]} \\<in> close C\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])} \\<in> close C", "}"], ["proof (state)\nthis:\n  \\<lbrakk>closedt 0 ?t2; Forall ?P2 \\<in> S\\<rbrakk>\n  \\<Longrightarrow> S \\<union> {?P2[?t2/0]} \\<in> close C\n\ngoal (3 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> close C\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]} \\<in> close C\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])} \\<in> close C", "{"], ["proof (state)\nthis:\n  \\<lbrakk>closedt 0 ?t2; Forall ?P2 \\<in> S\\<rbrakk>\n  \\<Longrightarrow> S \\<union> {?P2[?t2/0]} \\<in> close C\n\ngoal (3 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> close C\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]} \\<in> close C\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])} \\<in> close C", "fix P and t :: \\<open>'a term\\<close>"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> close C\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]} \\<in> close C\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])} \\<in> close C", "assume \\<open>closedt 0 t\\<close> and \\<open>Neg (Exists P) \\<in> S\\<close>"], ["proof (state)\nthis:\n  closedt 0 t\n  Neg (Exists P) \\<in> S\n\ngoal (3 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> close C\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]} \\<in> close C\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])} \\<in> close C", "then"], ["proof (chain)\npicking this:\n  closedt 0 t\n  Neg (Exists P) \\<in> S", "have \\<open>Neg (Exists P) \\<in> x\\<close>"], ["proof (prove)\nusing this:\n  closedt 0 t\n  Neg (Exists P) \\<in> S\n\ngoal (1 subgoal):\n 1. Neg (Exists P) \\<in> x", "using \\<open>S \\<subseteq> x\\<close>"], ["proof (prove)\nusing this:\n  closedt 0 t\n  Neg (Exists P) \\<in> S\n  S \\<subseteq> x\n\ngoal (1 subgoal):\n 1. Neg (Exists P) \\<in> x", "by blast"], ["proof (state)\nthis:\n  Neg (Exists P) \\<in> x\n\ngoal (3 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> close C\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]} \\<in> close C\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])} \\<in> close C", "then"], ["proof (chain)\npicking this:\n  Neg (Exists P) \\<in> x", "have \\<open>x \\<union> {Neg (P[t/0])} \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  Neg (Exists P) \\<in> x\n\ngoal (1 subgoal):\n 1. x \\<union> {Neg (P[t/0])} \\<in> C", "using \\<open>closedt 0 t\\<close> \\<open>x \\<in> C\\<close> conc"], ["proof (prove)\nusing this:\n  Neg (Exists P) \\<in> x\n  closedt 0 t\n  x \\<in> C\n  consistency C\n\ngoal (1 subgoal):\n 1. x \\<union> {Neg (P[t/0])} \\<in> C", "unfolding consistency_def"], ["proof (prove)\nusing this:\n  Neg (Exists P) \\<in> x\n  closedt 0 t\n  x \\<in> C\n  \\<forall>S.\n     S \\<in> C \\<longrightarrow>\n     (\\<forall>p ts.\n         \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)) \\<and>\n     FF \\<notin> S \\<and>\n     Neg TT \\<notin> S \\<and>\n     (\\<forall>Z.\n         Neg (Neg Z) \\<in> S \\<longrightarrow>\n         S \\<union> {Z} \\<in> C) \\<and>\n     (\\<forall>A B.\n         And A B \\<in> S \\<longrightarrow> S \\<union> {A, B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Or A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A, Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Or A B \\<in> S \\<longrightarrow>\n         S \\<union> {A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (And A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Impl A B \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Impl A B) \\<in> S \\<longrightarrow>\n         S \\<union> {A, Neg B} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Forall P \\<in> S \\<longrightarrow>\n         S \\<union> {P[t/0]} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Neg (Exists P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[t/0])} \\<in> C) \\<and>\n     (\\<forall>P.\n         Exists P \\<in> S \\<longrightarrow>\n         (\\<exists>x. S \\<union> {P[App x []/0]} \\<in> C)) \\<and>\n     (\\<forall>P.\n         Neg (Forall P) \\<in> S \\<longrightarrow>\n         (\\<exists>x. S \\<union> {Neg (P[App x []/0])} \\<in> C))\n\ngoal (1 subgoal):\n 1. x \\<union> {Neg (P[t/0])} \\<in> C", "by blast"], ["proof (state)\nthis:\n  x \\<union> {Neg (P[t/0])} \\<in> C\n\ngoal (3 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> close C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> close C\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]} \\<in> close C\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])} \\<in> close C", "then"], ["proof (chain)\npicking this:\n  x \\<union> {Neg (P[t/0])} \\<in> C", "show \\<open>S \\<union> {Neg (P[t/0])} \\<in> close C\\<close>"], ["proof (prove)\nusing this:\n  x \\<union> {Neg (P[t/0])} \\<in> C\n\ngoal (1 subgoal):\n 1. S \\<union> {Neg (P[t/0])} \\<in> close C", "using \\<open>S \\<subseteq> x\\<close> subset_in_close"], ["proof (prove)\nusing this:\n  x \\<union> {Neg (P[t/0])} \\<in> C\n  S \\<subseteq> x\n  ?S \\<subseteq> ?S' \\<Longrightarrow>\n  ?S' \\<union> ?x \\<in> ?C \\<longrightarrow> ?S \\<union> ?x \\<in> close ?C\n\ngoal (1 subgoal):\n 1. S \\<union> {Neg (P[t/0])} \\<in> close C", "by blast"], ["proof (state)\nthis:\n  S \\<union> {Neg (P[t/0])} \\<in> close C\n\ngoal (2 subgoals):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]} \\<in> close C\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])} \\<in> close C", "}"], ["proof (state)\nthis:\n  \\<lbrakk>closedt 0 ?t2; Neg (Exists ?P2) \\<in> S\\<rbrakk>\n  \\<Longrightarrow> S \\<union> {Neg (?P2[?t2/0])} \\<in> close C\n\ngoal (2 subgoals):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]} \\<in> close C\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])} \\<in> close C", "{"], ["proof (state)\nthis:\n  \\<lbrakk>closedt 0 ?t2; Neg (Exists ?P2) \\<in> S\\<rbrakk>\n  \\<Longrightarrow> S \\<union> {Neg (?P2[?t2/0])} \\<in> close C\n\ngoal (2 subgoals):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]} \\<in> close C\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])} \\<in> close C", "fix P"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]} \\<in> close C\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])} \\<in> close C", "assume \\<open>Exists P \\<in> S\\<close>"], ["proof (state)\nthis:\n  Exists P \\<in> S\n\ngoal (2 subgoals):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]} \\<in> close C\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])} \\<in> close C", "then"], ["proof (chain)\npicking this:\n  Exists P \\<in> S", "have \\<open>Exists P \\<in> x\\<close>"], ["proof (prove)\nusing this:\n  Exists P \\<in> S\n\ngoal (1 subgoal):\n 1. Exists P \\<in> x", "using \\<open>S \\<subseteq> x\\<close>"], ["proof (prove)\nusing this:\n  Exists P \\<in> S\n  S \\<subseteq> x\n\ngoal (1 subgoal):\n 1. Exists P \\<in> x", "by blast"], ["proof (state)\nthis:\n  Exists P \\<in> x\n\ngoal (2 subgoals):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]} \\<in> close C\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])} \\<in> close C", "then"], ["proof (chain)\npicking this:\n  Exists P \\<in> x", "have \\<open>\\<exists>c. x \\<union> {P[App c []/0]} \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  Exists P \\<in> x\n\ngoal (1 subgoal):\n 1. \\<exists>c. x \\<union> {P[App c []/0]} \\<in> C", "using \\<open>x \\<in> C\\<close> conc"], ["proof (prove)\nusing this:\n  Exists P \\<in> x\n  x \\<in> C\n  consistency C\n\ngoal (1 subgoal):\n 1. \\<exists>c. x \\<union> {P[App c []/0]} \\<in> C", "unfolding consistency_def"], ["proof (prove)\nusing this:\n  Exists P \\<in> x\n  x \\<in> C\n  \\<forall>S.\n     S \\<in> C \\<longrightarrow>\n     (\\<forall>p ts.\n         \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)) \\<and>\n     FF \\<notin> S \\<and>\n     Neg TT \\<notin> S \\<and>\n     (\\<forall>Z.\n         Neg (Neg Z) \\<in> S \\<longrightarrow>\n         S \\<union> {Z} \\<in> C) \\<and>\n     (\\<forall>A B.\n         And A B \\<in> S \\<longrightarrow> S \\<union> {A, B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Or A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A, Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Or A B \\<in> S \\<longrightarrow>\n         S \\<union> {A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (And A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Impl A B \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Impl A B) \\<in> S \\<longrightarrow>\n         S \\<union> {A, Neg B} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Forall P \\<in> S \\<longrightarrow>\n         S \\<union> {P[t/0]} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Neg (Exists P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[t/0])} \\<in> C) \\<and>\n     (\\<forall>P.\n         Exists P \\<in> S \\<longrightarrow>\n         (\\<exists>x. S \\<union> {P[App x []/0]} \\<in> C)) \\<and>\n     (\\<forall>P.\n         Neg (Forall P) \\<in> S \\<longrightarrow>\n         (\\<exists>x. S \\<union> {Neg (P[App x []/0])} \\<in> C))\n\ngoal (1 subgoal):\n 1. \\<exists>c. x \\<union> {P[App c []/0]} \\<in> C", "by blast"], ["proof (state)\nthis:\n  \\<exists>c. x \\<union> {P[App c []/0]} \\<in> C\n\ngoal (2 subgoals):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]} \\<in> close C\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])} \\<in> close C", "then"], ["proof (chain)\npicking this:\n  \\<exists>c. x \\<union> {P[App c []/0]} \\<in> C", "show \\<open>\\<exists>c. S \\<union> {P[App c []/0]} \\<in> close C\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>c. x \\<union> {P[App c []/0]} \\<in> C\n\ngoal (1 subgoal):\n 1. \\<exists>c. S \\<union> {P[App c []/0]} \\<in> close C", "using \\<open>S \\<subseteq> x\\<close> subset_in_close"], ["proof (prove)\nusing this:\n  \\<exists>c. x \\<union> {P[App c []/0]} \\<in> C\n  S \\<subseteq> x\n  ?S \\<subseteq> ?S' \\<Longrightarrow>\n  ?S' \\<union> ?x \\<in> ?C \\<longrightarrow> ?S \\<union> ?x \\<in> close ?C\n\ngoal (1 subgoal):\n 1. \\<exists>c. S \\<union> {P[App c []/0]} \\<in> close C", "by blast"], ["proof (state)\nthis:\n  \\<exists>c. S \\<union> {P[App c []/0]} \\<in> close C\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])} \\<in> close C", "}"], ["proof (state)\nthis:\n  Exists ?P2 \\<in> S \\<Longrightarrow>\n  \\<exists>c. S \\<union> {?P2[App c []/0]} \\<in> close C\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])} \\<in> close C", "{"], ["proof (state)\nthis:\n  Exists ?P2 \\<in> S \\<Longrightarrow>\n  \\<exists>c. S \\<union> {?P2[App c []/0]} \\<in> close C\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])} \\<in> close C", "fix P"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])} \\<in> close C", "assume \\<open>Neg (Forall P) \\<in> S\\<close>"], ["proof (state)\nthis:\n  Neg (Forall P) \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])} \\<in> close C", "then"], ["proof (chain)\npicking this:\n  Neg (Forall P) \\<in> S", "have \\<open>Neg (Forall P) \\<in> x\\<close>"], ["proof (prove)\nusing this:\n  Neg (Forall P) \\<in> S\n\ngoal (1 subgoal):\n 1. Neg (Forall P) \\<in> x", "using \\<open>S \\<subseteq> x\\<close>"], ["proof (prove)\nusing this:\n  Neg (Forall P) \\<in> S\n  S \\<subseteq> x\n\ngoal (1 subgoal):\n 1. Neg (Forall P) \\<in> x", "by blast"], ["proof (state)\nthis:\n  Neg (Forall P) \\<in> x\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])} \\<in> close C", "then"], ["proof (chain)\npicking this:\n  Neg (Forall P) \\<in> x", "have \\<open>\\<exists>c. x \\<union> {Neg (P[App c []/0])} \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  Neg (Forall P) \\<in> x\n\ngoal (1 subgoal):\n 1. \\<exists>c. x \\<union> {Neg (P[App c []/0])} \\<in> C", "using \\<open>x \\<in> C\\<close> conc"], ["proof (prove)\nusing this:\n  Neg (Forall P) \\<in> x\n  x \\<in> C\n  consistency C\n\ngoal (1 subgoal):\n 1. \\<exists>c. x \\<union> {Neg (P[App c []/0])} \\<in> C", "unfolding consistency_def"], ["proof (prove)\nusing this:\n  Neg (Forall P) \\<in> x\n  x \\<in> C\n  \\<forall>S.\n     S \\<in> C \\<longrightarrow>\n     (\\<forall>p ts.\n         \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)) \\<and>\n     FF \\<notin> S \\<and>\n     Neg TT \\<notin> S \\<and>\n     (\\<forall>Z.\n         Neg (Neg Z) \\<in> S \\<longrightarrow>\n         S \\<union> {Z} \\<in> C) \\<and>\n     (\\<forall>A B.\n         And A B \\<in> S \\<longrightarrow> S \\<union> {A, B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Or A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A, Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Or A B \\<in> S \\<longrightarrow>\n         S \\<union> {A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (And A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Impl A B \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Impl A B) \\<in> S \\<longrightarrow>\n         S \\<union> {A, Neg B} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Forall P \\<in> S \\<longrightarrow>\n         S \\<union> {P[t/0]} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Neg (Exists P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[t/0])} \\<in> C) \\<and>\n     (\\<forall>P.\n         Exists P \\<in> S \\<longrightarrow>\n         (\\<exists>x. S \\<union> {P[App x []/0]} \\<in> C)) \\<and>\n     (\\<forall>P.\n         Neg (Forall P) \\<in> S \\<longrightarrow>\n         (\\<exists>x. S \\<union> {Neg (P[App x []/0])} \\<in> C))\n\ngoal (1 subgoal):\n 1. \\<exists>c. x \\<union> {Neg (P[App c []/0])} \\<in> C", "by simp"], ["proof (state)\nthis:\n  \\<exists>c. x \\<union> {Neg (P[App c []/0])} \\<in> C\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> close C; Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])} \\<in> close C", "then"], ["proof (chain)\npicking this:\n  \\<exists>c. x \\<union> {Neg (P[App c []/0])} \\<in> C", "show \\<open>\\<exists>c. S \\<union> {Neg (P[App c []/0])} \\<in> close C\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>c. x \\<union> {Neg (P[App c []/0])} \\<in> C\n\ngoal (1 subgoal):\n 1. \\<exists>c. S \\<union> {Neg (P[App c []/0])} \\<in> close C", "using \\<open>S \\<subseteq> x\\<close> subset_in_close"], ["proof (prove)\nusing this:\n  \\<exists>c. x \\<union> {Neg (P[App c []/0])} \\<in> C\n  S \\<subseteq> x\n  ?S \\<subseteq> ?S' \\<Longrightarrow>\n  ?S' \\<union> ?x \\<in> ?C \\<longrightarrow> ?S \\<union> ?x \\<in> close ?C\n\ngoal (1 subgoal):\n 1. \\<exists>c. S \\<union> {Neg (P[App c []/0])} \\<in> close C", "by blast"], ["proof (state)\nthis:\n  \\<exists>c. S \\<union> {Neg (P[App c []/0])} \\<in> close C\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  Neg (Forall ?P2) \\<in> S \\<Longrightarrow>\n  \\<exists>c. S \\<union> {Neg (?P2[App c []/0])} \\<in> close C\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem close_closed: \\<open>subset_closed (close C)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. subset_closed (close C)", "unfolding close_def subset_closed_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>S'\\<in>{S. Bex C ((\\<subseteq>) S)}.\n       \\<forall>S\\<subseteq>S'. S \\<in> {S. Bex C ((\\<subseteq>) S)}", "by blast"], ["", "theorem close_subset: \\<open>C \\<subseteq> close C\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<subseteq> close C", "unfolding close_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<subseteq> {S. Bex C ((\\<subseteq>) S)}", "by blast"], ["", "text \\<open>\nIf a consistency property \\<open>C\\<close> is closed under subsets, so is the\ncorresponding alternative consistency property:\n\\<close>"], ["", "theorem mk_alt_consistency_closed:\n  assumes \\<open>subset_closed C\\<close>\n  shows \\<open>subset_closed (mk_alt_consistency C)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. subset_closed (mk_alt_consistency C)", "unfolding subset_closed_def mk_alt_consistency_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>S'\\<in>{S. \\<exists>f. psubst f ` S \\<in> C}.\n       \\<forall>S\\<subseteq>S'.\n          S \\<in> {S. \\<exists>f. psubst f ` S \\<in> C}", "proof (intro ballI allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S' S.\n       \\<lbrakk>S' \\<in> {S. \\<exists>f. psubst f ` S \\<in> C};\n        S \\<subseteq> S'\\<rbrakk>\n       \\<Longrightarrow> S \\<in> {S. \\<exists>f. psubst f ` S \\<in> C}", "fix S S' :: \\<open>('a, 'b) form set\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S' S.\n       \\<lbrakk>S' \\<in> {S. \\<exists>f. psubst f ` S \\<in> C};\n        S \\<subseteq> S'\\<rbrakk>\n       \\<Longrightarrow> S \\<in> {S. \\<exists>f. psubst f ` S \\<in> C}", "assume \\<open>S \\<subseteq> S'\\<close> and \\<open>S' \\<in> {S. \\<exists>f. psubst f ` S \\<in> C}\\<close>"], ["proof (state)\nthis:\n  S \\<subseteq> S'\n  S' \\<in> {S. \\<exists>f. psubst f ` S \\<in> C}\n\ngoal (1 subgoal):\n 1. \\<And>S' S.\n       \\<lbrakk>S' \\<in> {S. \\<exists>f. psubst f ` S \\<in> C};\n        S \\<subseteq> S'\\<rbrakk>\n       \\<Longrightarrow> S \\<in> {S. \\<exists>f. psubst f ` S \\<in> C}", "then"], ["proof (chain)\npicking this:\n  S \\<subseteq> S'\n  S' \\<in> {S. \\<exists>f. psubst f ` S \\<in> C}", "obtain f where *: \\<open>psubst f ` S' \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  S \\<subseteq> S'\n  S' \\<in> {S. \\<exists>f. psubst f ` S \\<in> C}\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        psubst f ` S' \\<in> C \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  psubst f ` S' \\<in> C\n\ngoal (1 subgoal):\n 1. \\<And>S' S.\n       \\<lbrakk>S' \\<in> {S. \\<exists>f. psubst f ` S \\<in> C};\n        S \\<subseteq> S'\\<rbrakk>\n       \\<Longrightarrow> S \\<in> {S. \\<exists>f. psubst f ` S \\<in> C}", "moreover"], ["proof (state)\nthis:\n  psubst f ` S' \\<in> C\n\ngoal (1 subgoal):\n 1. \\<And>S' S.\n       \\<lbrakk>S' \\<in> {S. \\<exists>f. psubst f ` S \\<in> C};\n        S \\<subseteq> S'\\<rbrakk>\n       \\<Longrightarrow> S \\<in> {S. \\<exists>f. psubst f ` S \\<in> C}", "have \\<open>psubst f ` S \\<subseteq> psubst f ` S'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. psubst f ` S \\<subseteq> psubst f ` S'", "using \\<open>S \\<subseteq> S'\\<close>"], ["proof (prove)\nusing this:\n  S \\<subseteq> S'\n\ngoal (1 subgoal):\n 1. psubst f ` S \\<subseteq> psubst f ` S'", "by blast"], ["proof (state)\nthis:\n  psubst f ` S \\<subseteq> psubst f ` S'\n\ngoal (1 subgoal):\n 1. \\<And>S' S.\n       \\<lbrakk>S' \\<in> {S. \\<exists>f. psubst f ` S \\<in> C};\n        S \\<subseteq> S'\\<rbrakk>\n       \\<Longrightarrow> S \\<in> {S. \\<exists>f. psubst f ` S \\<in> C}", "moreover"], ["proof (state)\nthis:\n  psubst f ` S \\<subseteq> psubst f ` S'\n\ngoal (1 subgoal):\n 1. \\<And>S' S.\n       \\<lbrakk>S' \\<in> {S. \\<exists>f. psubst f ` S \\<in> C};\n        S \\<subseteq> S'\\<rbrakk>\n       \\<Longrightarrow> S \\<in> {S. \\<exists>f. psubst f ` S \\<in> C}", "have \\<open>\\<forall>S' \\<in> C. \\<forall>S \\<subseteq> S'. S \\<in> C\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>S'\\<in>C. \\<forall>S\\<subseteq>S'. S \\<in> C", "using \\<open>subset_closed C\\<close>"], ["proof (prove)\nusing this:\n  subset_closed C\n\ngoal (1 subgoal):\n 1. \\<forall>S'\\<in>C. \\<forall>S\\<subseteq>S'. S \\<in> C", "unfolding subset_closed_def"], ["proof (prove)\nusing this:\n  \\<forall>S'\\<in>C. \\<forall>S\\<subseteq>S'. S \\<in> C\n\ngoal (1 subgoal):\n 1. \\<forall>S'\\<in>C. \\<forall>S\\<subseteq>S'. S \\<in> C", "by blast"], ["proof (state)\nthis:\n  \\<forall>S'\\<in>C. \\<forall>S\\<subseteq>S'. S \\<in> C\n\ngoal (1 subgoal):\n 1. \\<And>S' S.\n       \\<lbrakk>S' \\<in> {S. \\<exists>f. psubst f ` S \\<in> C};\n        S \\<subseteq> S'\\<rbrakk>\n       \\<Longrightarrow> S \\<in> {S. \\<exists>f. psubst f ` S \\<in> C}", "ultimately"], ["proof (chain)\npicking this:\n  psubst f ` S' \\<in> C\n  psubst f ` S \\<subseteq> psubst f ` S'\n  \\<forall>S'\\<in>C. \\<forall>S\\<subseteq>S'. S \\<in> C", "have \\<open>psubst f ` S \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  psubst f ` S' \\<in> C\n  psubst f ` S \\<subseteq> psubst f ` S'\n  \\<forall>S'\\<in>C. \\<forall>S\\<subseteq>S'. S \\<in> C\n\ngoal (1 subgoal):\n 1. psubst f ` S \\<in> C", "by blast"], ["proof (state)\nthis:\n  psubst f ` S \\<in> C\n\ngoal (1 subgoal):\n 1. \\<And>S' S.\n       \\<lbrakk>S' \\<in> {S. \\<exists>f. psubst f ` S \\<in> C};\n        S \\<subseteq> S'\\<rbrakk>\n       \\<Longrightarrow> S \\<in> {S. \\<exists>f. psubst f ` S \\<in> C}", "then"], ["proof (chain)\npicking this:\n  psubst f ` S \\<in> C", "show \\<open>S \\<in> {S. \\<exists>f. psubst f ` S \\<in> C}\\<close>"], ["proof (prove)\nusing this:\n  psubst f ` S \\<in> C\n\ngoal (1 subgoal):\n 1. S \\<in> {S. \\<exists>f. psubst f ` S \\<in> C}", "by blast"], ["proof (state)\nthis:\n  S \\<in> {S. \\<exists>f. psubst f ` S \\<in> C}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Finite character\\<close>"], ["", "text \\<open>\n\\label{sec:finiteness}\nIn this section, we show that an alternative consistency property can\nbe extended to one of finite character. A set of sets \\<open>C\\<close> is said\nto be of finite character, provided that \\<open>S\\<close> is a member of \\<open>C\\<close>\nif and only if every subset of \\<open>S\\<close> is.\n\\<close>"], ["", "definition finite_char :: \\<open>'a set set \\<Rightarrow> bool\\<close> where\n  \\<open>finite_char C = (\\<forall>S. S \\<in> C = (\\<forall>S'. finite S' \\<longrightarrow> S' \\<subseteq> S \\<longrightarrow> S' \\<in> C))\\<close>"], ["", "definition mk_finite_char :: \\<open>'a set set \\<Rightarrow> 'a set set\\<close> where\n  \\<open>mk_finite_char C = {S. \\<forall>S'. S' \\<subseteq> S \\<longrightarrow> finite S' \\<longrightarrow> S' \\<in> C}\\<close>"], ["", "theorem finite_alt_consistency:\n  assumes altconc: \\<open>alt_consistency C\\<close>\n    and \\<open>subset_closed C\\<close>\n  shows \\<open>alt_consistency (mk_finite_char C)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. alt_consistency (mk_finite_char C)", "unfolding alt_consistency_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>S.\n       S \\<in> mk_finite_char C \\<longrightarrow>\n       (\\<forall>p ts.\n           \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)) \\<and>\n       FF \\<notin> S \\<and>\n       Neg TT \\<notin> S \\<and>\n       (\\<forall>Z.\n           Neg (Neg Z) \\<in> S \\<longrightarrow>\n           S \\<union> {Z} \\<in> mk_finite_char C) \\<and>\n       (\\<forall>A B.\n           And A B \\<in> S \\<longrightarrow>\n           S \\<union> {A, B} \\<in> mk_finite_char C) \\<and>\n       (\\<forall>A B.\n           Neg (Or A B) \\<in> S \\<longrightarrow>\n           S \\<union> {Neg A, Neg B} \\<in> mk_finite_char C) \\<and>\n       (\\<forall>A B.\n           Or A B \\<in> S \\<longrightarrow>\n           S \\<union> {A} \\<in> mk_finite_char C \\<or>\n           S \\<union> {B} \\<in> mk_finite_char C) \\<and>\n       (\\<forall>A B.\n           Neg (And A B) \\<in> S \\<longrightarrow>\n           S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n           S \\<union> {Neg B} \\<in> mk_finite_char C) \\<and>\n       (\\<forall>A B.\n           Impl A B \\<in> S \\<longrightarrow>\n           S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n           S \\<union> {B} \\<in> mk_finite_char C) \\<and>\n       (\\<forall>A B.\n           Neg (Impl A B) \\<in> S \\<longrightarrow>\n           S \\<union> {A, Neg B} \\<in> mk_finite_char C) \\<and>\n       (\\<forall>P t.\n           closedt 0 t \\<longrightarrow>\n           Forall P \\<in> S \\<longrightarrow>\n           S \\<union> {P[t/0]} \\<in> mk_finite_char C) \\<and>\n       (\\<forall>P t.\n           closedt 0 t \\<longrightarrow>\n           Neg (Exists P) \\<in> S \\<longrightarrow>\n           S \\<union> {Neg (P[t/0])} \\<in> mk_finite_char C) \\<and>\n       (\\<forall>P x.\n           (\\<forall>a\\<in>S. x \\<notin> params a) \\<longrightarrow>\n           Exists P \\<in> S \\<longrightarrow>\n           S \\<union> {P[App x []/0]} \\<in> mk_finite_char C) \\<and>\n       (\\<forall>P x.\n           (\\<forall>a\\<in>S. x \\<notin> params a) \\<longrightarrow>\n           Neg (Forall P) \\<in> S \\<longrightarrow>\n           S \\<union> {Neg (P[App x []/0])} \\<in> mk_finite_char C)", "proof (intro allI impI conjI)"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>S p ts.\n       S \\<in> mk_finite_char C \\<Longrightarrow>\n       \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)\n 2. \\<And>S. S \\<in> mk_finite_char C \\<Longrightarrow> FF \\<notin> S\n 3. \\<And>S. S \\<in> mk_finite_char C \\<Longrightarrow> Neg TT \\<notin> S\n 4. \\<And>S Z.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z} \\<in> mk_finite_char C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B} \\<in> mk_finite_char C\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B} \\<in> mk_finite_char C\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_finite_char C\n 9. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 10. \\<And>S A B.\n        \\<lbrakk>S \\<in> mk_finite_char C; Neg (Impl A B) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> mk_finite_char C\nA total of 14 subgoals...", "fix S"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>S p ts.\n       S \\<in> mk_finite_char C \\<Longrightarrow>\n       \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)\n 2. \\<And>S. S \\<in> mk_finite_char C \\<Longrightarrow> FF \\<notin> S\n 3. \\<And>S. S \\<in> mk_finite_char C \\<Longrightarrow> Neg TT \\<notin> S\n 4. \\<And>S Z.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z} \\<in> mk_finite_char C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B} \\<in> mk_finite_char C\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B} \\<in> mk_finite_char C\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_finite_char C\n 9. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 10. \\<And>S A B.\n        \\<lbrakk>S \\<in> mk_finite_char C; Neg (Impl A B) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> mk_finite_char C\nA total of 14 subgoals...", "assume \\<open>S \\<in> mk_finite_char C\\<close>"], ["proof (state)\nthis:\n  S \\<in> mk_finite_char C\n\ngoal (14 subgoals):\n 1. \\<And>S p ts.\n       S \\<in> mk_finite_char C \\<Longrightarrow>\n       \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)\n 2. \\<And>S. S \\<in> mk_finite_char C \\<Longrightarrow> FF \\<notin> S\n 3. \\<And>S. S \\<in> mk_finite_char C \\<Longrightarrow> Neg TT \\<notin> S\n 4. \\<And>S Z.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z} \\<in> mk_finite_char C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B} \\<in> mk_finite_char C\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B} \\<in> mk_finite_char C\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_finite_char C\n 9. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 10. \\<And>S A B.\n        \\<lbrakk>S \\<in> mk_finite_char C; Neg (Impl A B) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> mk_finite_char C\nA total of 14 subgoals...", "then"], ["proof (chain)\npicking this:\n  S \\<in> mk_finite_char C", "have finc: \\<open>\\<forall>S' \\<subseteq> S. finite S' \\<longrightarrow> S' \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  S \\<in> mk_finite_char C\n\ngoal (1 subgoal):\n 1. \\<forall>S'\\<subseteq>S. finite S' \\<longrightarrow> S' \\<in> C", "unfolding mk_finite_char_def"], ["proof (prove)\nusing this:\n  S \\<in> {S. \\<forall>S'\\<subseteq>S.\n                 finite S' \\<longrightarrow> S' \\<in> C}\n\ngoal (1 subgoal):\n 1. \\<forall>S'\\<subseteq>S. finite S' \\<longrightarrow> S' \\<in> C", "by blast"], ["proof (state)\nthis:\n  \\<forall>S'\\<subseteq>S. finite S' \\<longrightarrow> S' \\<in> C\n\ngoal (14 subgoals):\n 1. \\<And>S p ts.\n       S \\<in> mk_finite_char C \\<Longrightarrow>\n       \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)\n 2. \\<And>S. S \\<in> mk_finite_char C \\<Longrightarrow> FF \\<notin> S\n 3. \\<And>S. S \\<in> mk_finite_char C \\<Longrightarrow> Neg TT \\<notin> S\n 4. \\<And>S Z.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z} \\<in> mk_finite_char C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B} \\<in> mk_finite_char C\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B} \\<in> mk_finite_char C\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_finite_char C\n 9. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 10. \\<And>S A B.\n        \\<lbrakk>S \\<in> mk_finite_char C; Neg (Impl A B) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> mk_finite_char C\nA total of 14 subgoals...", "have \\<open>\\<forall>S' \\<in> C. \\<forall>S \\<subseteq> S'. S \\<in> C\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>S'\\<in>C. \\<forall>S\\<subseteq>S'. S \\<in> C", "using \\<open>subset_closed C\\<close>"], ["proof (prove)\nusing this:\n  subset_closed C\n\ngoal (1 subgoal):\n 1. \\<forall>S'\\<in>C. \\<forall>S\\<subseteq>S'. S \\<in> C", "unfolding subset_closed_def"], ["proof (prove)\nusing this:\n  \\<forall>S'\\<in>C. \\<forall>S\\<subseteq>S'. S \\<in> C\n\ngoal (1 subgoal):\n 1. \\<forall>S'\\<in>C. \\<forall>S\\<subseteq>S'. S \\<in> C", "by blast"], ["proof (state)\nthis:\n  \\<forall>S'\\<in>C. \\<forall>S\\<subseteq>S'. S \\<in> C\n\ngoal (14 subgoals):\n 1. \\<And>S p ts.\n       S \\<in> mk_finite_char C \\<Longrightarrow>\n       \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)\n 2. \\<And>S. S \\<in> mk_finite_char C \\<Longrightarrow> FF \\<notin> S\n 3. \\<And>S. S \\<in> mk_finite_char C \\<Longrightarrow> Neg TT \\<notin> S\n 4. \\<And>S Z.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z} \\<in> mk_finite_char C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B} \\<in> mk_finite_char C\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B} \\<in> mk_finite_char C\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_finite_char C\n 9. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 10. \\<And>S A B.\n        \\<lbrakk>S \\<in> mk_finite_char C; Neg (Impl A B) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> mk_finite_char C\nA total of 14 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<forall>S'\\<in>C. \\<forall>S\\<subseteq>S'. S \\<in> C", "have sc: \\<open>\\<forall>S' x. S' \\<union> x \\<in> C \\<longrightarrow> (\\<forall>S \\<subseteq> S' \\<union> x. S \\<in> C)\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>S'\\<in>C. \\<forall>S\\<subseteq>S'. S \\<in> C\n\ngoal (1 subgoal):\n 1. \\<forall>S' x.\n       S' \\<union> x \\<in> C \\<longrightarrow>\n       (\\<forall>S\\<subseteq>S' \\<union> x. S \\<in> C)", "by blast"], ["proof (state)\nthis:\n  \\<forall>S' x.\n     S' \\<union> x \\<in> C \\<longrightarrow>\n     (\\<forall>S\\<subseteq>S' \\<union> x. S \\<in> C)\n\ngoal (14 subgoals):\n 1. \\<And>S p ts.\n       S \\<in> mk_finite_char C \\<Longrightarrow>\n       \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)\n 2. \\<And>S. S \\<in> mk_finite_char C \\<Longrightarrow> FF \\<notin> S\n 3. \\<And>S. S \\<in> mk_finite_char C \\<Longrightarrow> Neg TT \\<notin> S\n 4. \\<And>S Z.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z} \\<in> mk_finite_char C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B} \\<in> mk_finite_char C\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B} \\<in> mk_finite_char C\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_finite_char C\n 9. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 10. \\<And>S A B.\n        \\<lbrakk>S \\<in> mk_finite_char C; Neg (Impl A B) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> mk_finite_char C\nA total of 14 subgoals...", "{"], ["proof (state)\nthis:\n  \\<forall>S' x.\n     S' \\<union> x \\<in> C \\<longrightarrow>\n     (\\<forall>S\\<subseteq>S' \\<union> x. S \\<in> C)\n\ngoal (14 subgoals):\n 1. \\<And>S p ts.\n       S \\<in> mk_finite_char C \\<Longrightarrow>\n       \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)\n 2. \\<And>S. S \\<in> mk_finite_char C \\<Longrightarrow> FF \\<notin> S\n 3. \\<And>S. S \\<in> mk_finite_char C \\<Longrightarrow> Neg TT \\<notin> S\n 4. \\<And>S Z.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z} \\<in> mk_finite_char C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B} \\<in> mk_finite_char C\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B} \\<in> mk_finite_char C\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_finite_char C\n 9. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 10. \\<And>S A B.\n        \\<lbrakk>S \\<in> mk_finite_char C; Neg (Impl A B) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> mk_finite_char C\nA total of 14 subgoals...", "fix p ts"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>S p ts.\n       S \\<in> mk_finite_char C \\<Longrightarrow>\n       \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)\n 2. \\<And>S. S \\<in> mk_finite_char C \\<Longrightarrow> FF \\<notin> S\n 3. \\<And>S. S \\<in> mk_finite_char C \\<Longrightarrow> Neg TT \\<notin> S\n 4. \\<And>S Z.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z} \\<in> mk_finite_char C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B} \\<in> mk_finite_char C\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B} \\<in> mk_finite_char C\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_finite_char C\n 9. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 10. \\<And>S A B.\n        \\<lbrakk>S \\<in> mk_finite_char C; Neg (Impl A B) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> mk_finite_char C\nA total of 14 subgoals...", "show \\<open>\\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S \\<Longrightarrow> False", "assume \\<open>Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S\\<close>"], ["proof (state)\nthis:\n  Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S\n\ngoal (1 subgoal):\n 1. Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S", "have \\<open>{Pred p ts, Neg (Pred p ts)} \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S\n\ngoal (1 subgoal):\n 1. {Pred p ts, Neg (Pred p ts)} \\<in> C", "using finc"], ["proof (prove)\nusing this:\n  Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S\n  \\<forall>S'\\<subseteq>S. finite S' \\<longrightarrow> S' \\<in> C\n\ngoal (1 subgoal):\n 1. {Pred p ts, Neg (Pred p ts)} \\<in> C", "by simp"], ["proof (state)\nthis:\n  {Pred p ts, Neg (Pred p ts)} \\<in> C\n\ngoal (1 subgoal):\n 1. Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  {Pred p ts, Neg (Pred p ts)} \\<in> C", "show False"], ["proof (prove)\nusing this:\n  {Pred p ts, Neg (Pred p ts)} \\<in> C\n\ngoal (1 subgoal):\n 1. False", "using altconc"], ["proof (prove)\nusing this:\n  {Pred p ts, Neg (Pred p ts)} \\<in> C\n  alt_consistency C\n\ngoal (1 subgoal):\n 1. False", "unfolding alt_consistency_def"], ["proof (prove)\nusing this:\n  {Pred p ts, Neg (Pred p ts)} \\<in> C\n  \\<forall>S.\n     S \\<in> C \\<longrightarrow>\n     (\\<forall>p ts.\n         \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)) \\<and>\n     FF \\<notin> S \\<and>\n     Neg TT \\<notin> S \\<and>\n     (\\<forall>Z.\n         Neg (Neg Z) \\<in> S \\<longrightarrow>\n         S \\<union> {Z} \\<in> C) \\<and>\n     (\\<forall>A B.\n         And A B \\<in> S \\<longrightarrow> S \\<union> {A, B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Or A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A, Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Or A B \\<in> S \\<longrightarrow>\n         S \\<union> {A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (And A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Impl A B \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Impl A B) \\<in> S \\<longrightarrow>\n         S \\<union> {A, Neg B} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Forall P \\<in> S \\<longrightarrow>\n         S \\<union> {P[t/0]} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Neg (Exists P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[t/0])} \\<in> C) \\<and>\n     (\\<forall>P x.\n         (\\<forall>a\\<in>S. x \\<notin> params a) \\<longrightarrow>\n         Exists P \\<in> S \\<longrightarrow>\n         S \\<union> {P[App x []/0]} \\<in> C) \\<and>\n     (\\<forall>P x.\n         (\\<forall>a\\<in>S. x \\<notin> params a) \\<longrightarrow>\n         Neg (Forall P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[App x []/0])} \\<in> C)\n\ngoal (1 subgoal):\n 1. False", "by fast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)\n\ngoal (13 subgoals):\n 1. \\<And>S. S \\<in> mk_finite_char C \\<Longrightarrow> FF \\<notin> S\n 2. \\<And>S. S \\<in> mk_finite_char C \\<Longrightarrow> Neg TT \\<notin> S\n 3. \\<And>S Z.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z} \\<in> mk_finite_char C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B} \\<in> mk_finite_char C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B} \\<in> mk_finite_char C\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_finite_char C\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 9. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> mk_finite_char C\n 10. \\<And>S P t.\n        \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n         Forall P \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_finite_char C\nA total of 13 subgoals...", "}"], ["proof (state)\nthis:\n  \\<not> (Pred ?p2 ?ts2 \\<in> S \\<and> Neg (Pred ?p2 ?ts2) \\<in> S)\n\ngoal (13 subgoals):\n 1. \\<And>S. S \\<in> mk_finite_char C \\<Longrightarrow> FF \\<notin> S\n 2. \\<And>S. S \\<in> mk_finite_char C \\<Longrightarrow> Neg TT \\<notin> S\n 3. \\<And>S Z.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z} \\<in> mk_finite_char C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B} \\<in> mk_finite_char C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B} \\<in> mk_finite_char C\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_finite_char C\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 9. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> mk_finite_char C\n 10. \\<And>S P t.\n        \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n         Forall P \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_finite_char C\nA total of 13 subgoals...", "show \\<open>FF \\<notin> S\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. FF \\<notin> S", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. FF \\<in> S \\<Longrightarrow> False", "assume \\<open>FF \\<in> S\\<close>"], ["proof (state)\nthis:\n  FF \\<in> S\n\ngoal (1 subgoal):\n 1. FF \\<in> S \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  FF \\<in> S", "have \\<open>{FF} \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  FF \\<in> S\n\ngoal (1 subgoal):\n 1. {FF} \\<in> C", "using finc"], ["proof (prove)\nusing this:\n  FF \\<in> S\n  \\<forall>S'\\<subseteq>S. finite S' \\<longrightarrow> S' \\<in> C\n\ngoal (1 subgoal):\n 1. {FF} \\<in> C", "by simp"], ["proof (state)\nthis:\n  {FF} \\<in> C\n\ngoal (1 subgoal):\n 1. FF \\<in> S \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  {FF} \\<in> C", "show False"], ["proof (prove)\nusing this:\n  {FF} \\<in> C\n\ngoal (1 subgoal):\n 1. False", "using altconc"], ["proof (prove)\nusing this:\n  {FF} \\<in> C\n  alt_consistency C\n\ngoal (1 subgoal):\n 1. False", "unfolding alt_consistency_def"], ["proof (prove)\nusing this:\n  {FF} \\<in> C\n  \\<forall>S.\n     S \\<in> C \\<longrightarrow>\n     (\\<forall>p ts.\n         \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)) \\<and>\n     FF \\<notin> S \\<and>\n     Neg TT \\<notin> S \\<and>\n     (\\<forall>Z.\n         Neg (Neg Z) \\<in> S \\<longrightarrow>\n         S \\<union> {Z} \\<in> C) \\<and>\n     (\\<forall>A B.\n         And A B \\<in> S \\<longrightarrow> S \\<union> {A, B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Or A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A, Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Or A B \\<in> S \\<longrightarrow>\n         S \\<union> {A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (And A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Impl A B \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Impl A B) \\<in> S \\<longrightarrow>\n         S \\<union> {A, Neg B} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Forall P \\<in> S \\<longrightarrow>\n         S \\<union> {P[t/0]} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Neg (Exists P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[t/0])} \\<in> C) \\<and>\n     (\\<forall>P x.\n         (\\<forall>a\\<in>S. x \\<notin> params a) \\<longrightarrow>\n         Exists P \\<in> S \\<longrightarrow>\n         S \\<union> {P[App x []/0]} \\<in> C) \\<and>\n     (\\<forall>P x.\n         (\\<forall>a\\<in>S. x \\<notin> params a) \\<longrightarrow>\n         Neg (Forall P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[App x []/0])} \\<in> C)\n\ngoal (1 subgoal):\n 1. False", "by fast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  FF \\<notin> S\n\ngoal (12 subgoals):\n 1. \\<And>S. S \\<in> mk_finite_char C \\<Longrightarrow> Neg TT \\<notin> S\n 2. \\<And>S Z.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z} \\<in> mk_finite_char C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B} \\<in> mk_finite_char C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B} \\<in> mk_finite_char C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_finite_char C\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> mk_finite_char C\n 9. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_finite_char C\n 10. \\<And>S P t.\n        \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n         Neg (Exists P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> mk_finite_char C\nA total of 12 subgoals...", "show \\<open>Neg TT \\<notin> S\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Neg TT \\<notin> S", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. Neg TT \\<in> S \\<Longrightarrow> False", "assume \\<open>Neg TT \\<in> S\\<close>"], ["proof (state)\nthis:\n  Neg TT \\<in> S\n\ngoal (1 subgoal):\n 1. Neg TT \\<in> S \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  Neg TT \\<in> S", "have \\<open>{Neg TT} \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  Neg TT \\<in> S\n\ngoal (1 subgoal):\n 1. {Neg TT} \\<in> C", "using finc"], ["proof (prove)\nusing this:\n  Neg TT \\<in> S\n  \\<forall>S'\\<subseteq>S. finite S' \\<longrightarrow> S' \\<in> C\n\ngoal (1 subgoal):\n 1. {Neg TT} \\<in> C", "by simp"], ["proof (state)\nthis:\n  {Neg TT} \\<in> C\n\ngoal (1 subgoal):\n 1. Neg TT \\<in> S \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  {Neg TT} \\<in> C", "show False"], ["proof (prove)\nusing this:\n  {Neg TT} \\<in> C\n\ngoal (1 subgoal):\n 1. False", "using altconc"], ["proof (prove)\nusing this:\n  {Neg TT} \\<in> C\n  alt_consistency C\n\ngoal (1 subgoal):\n 1. False", "unfolding alt_consistency_def"], ["proof (prove)\nusing this:\n  {Neg TT} \\<in> C\n  \\<forall>S.\n     S \\<in> C \\<longrightarrow>\n     (\\<forall>p ts.\n         \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)) \\<and>\n     FF \\<notin> S \\<and>\n     Neg TT \\<notin> S \\<and>\n     (\\<forall>Z.\n         Neg (Neg Z) \\<in> S \\<longrightarrow>\n         S \\<union> {Z} \\<in> C) \\<and>\n     (\\<forall>A B.\n         And A B \\<in> S \\<longrightarrow> S \\<union> {A, B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Or A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A, Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Or A B \\<in> S \\<longrightarrow>\n         S \\<union> {A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (And A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Impl A B \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Impl A B) \\<in> S \\<longrightarrow>\n         S \\<union> {A, Neg B} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Forall P \\<in> S \\<longrightarrow>\n         S \\<union> {P[t/0]} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Neg (Exists P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[t/0])} \\<in> C) \\<and>\n     (\\<forall>P x.\n         (\\<forall>a\\<in>S. x \\<notin> params a) \\<longrightarrow>\n         Exists P \\<in> S \\<longrightarrow>\n         S \\<union> {P[App x []/0]} \\<in> C) \\<and>\n     (\\<forall>P x.\n         (\\<forall>a\\<in>S. x \\<notin> params a) \\<longrightarrow>\n         Neg (Forall P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[App x []/0])} \\<in> C)\n\ngoal (1 subgoal):\n 1. False", "by fast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Neg TT \\<notin> S\n\ngoal (11 subgoals):\n 1. \\<And>S Z.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z} \\<in> mk_finite_char C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B} \\<in> mk_finite_char C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B} \\<in> mk_finite_char C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_finite_char C\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> mk_finite_char C\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_finite_char C\n 9. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> mk_finite_char C\n 10. \\<And>S P x.\n        \\<lbrakk>S \\<in> mk_finite_char C;\n         \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {P[App x []/0]} \\<in> mk_finite_char C\nA total of 11 subgoals...", "{"], ["proof (state)\nthis:\n  Neg TT \\<notin> S\n\ngoal (11 subgoals):\n 1. \\<And>S Z.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z} \\<in> mk_finite_char C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B} \\<in> mk_finite_char C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B} \\<in> mk_finite_char C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_finite_char C\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> mk_finite_char C\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_finite_char C\n 9. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> mk_finite_char C\n 10. \\<And>S P x.\n        \\<lbrakk>S \\<in> mk_finite_char C;\n         \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {P[App x []/0]} \\<in> mk_finite_char C\nA total of 11 subgoals...", "fix Z"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>S Z.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z} \\<in> mk_finite_char C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B} \\<in> mk_finite_char C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B} \\<in> mk_finite_char C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_finite_char C\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> mk_finite_char C\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_finite_char C\n 9. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> mk_finite_char C\n 10. \\<And>S P x.\n        \\<lbrakk>S \\<in> mk_finite_char C;\n         \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {P[App x []/0]} \\<in> mk_finite_char C\nA total of 11 subgoals...", "assume *: \\<open>Neg (Neg Z) \\<in> S\\<close>"], ["proof (state)\nthis:\n  Neg (Neg Z) \\<in> S\n\ngoal (11 subgoals):\n 1. \\<And>S Z.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z} \\<in> mk_finite_char C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B} \\<in> mk_finite_char C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B} \\<in> mk_finite_char C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_finite_char C\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> mk_finite_char C\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_finite_char C\n 9. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> mk_finite_char C\n 10. \\<And>S P x.\n        \\<lbrakk>S \\<in> mk_finite_char C;\n         \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {P[App x []/0]} \\<in> mk_finite_char C\nA total of 11 subgoals...", "show \\<open>S \\<union> {Z} \\<in> mk_finite_char C\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<union> {Z} \\<in> mk_finite_char C", "unfolding mk_finite_char_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<union> {Z}\n    \\<in> {S. \\<forall>S'\\<subseteq>S.\n                 finite S' \\<longrightarrow> S' \\<in> C}", "proof (intro allI impI CollectI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {Z}; finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "fix S'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {Z}; finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "let ?S' = \\<open>S' - {Z} \\<union> {Neg (Neg Z)}\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {Z}; finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "assume \\<open>S' \\<subseteq> S \\<union> {Z}\\<close> and \\<open>finite S'\\<close>"], ["proof (state)\nthis:\n  S' \\<subseteq> S \\<union> {Z}\n  finite S'\n\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {Z}; finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "then"], ["proof (chain)\npicking this:\n  S' \\<subseteq> S \\<union> {Z}\n  finite S'", "have \\<open>?S' \\<subseteq> S\\<close>"], ["proof (prove)\nusing this:\n  S' \\<subseteq> S \\<union> {Z}\n  finite S'\n\ngoal (1 subgoal):\n 1. S' - {Z} \\<union> {Neg (Neg Z)} \\<subseteq> S", "using *"], ["proof (prove)\nusing this:\n  S' \\<subseteq> S \\<union> {Z}\n  finite S'\n  Neg (Neg Z) \\<in> S\n\ngoal (1 subgoal):\n 1. S' - {Z} \\<union> {Neg (Neg Z)} \\<subseteq> S", "by blast"], ["proof (state)\nthis:\n  S' - {Z} \\<union> {Neg (Neg Z)} \\<subseteq> S\n\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {Z}; finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "moreover"], ["proof (state)\nthis:\n  S' - {Z} \\<union> {Neg (Neg Z)} \\<subseteq> S\n\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {Z}; finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "have \\<open>finite ?S'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (S' - {Z} \\<union> {Neg (Neg Z)})", "using \\<open>finite S'\\<close>"], ["proof (prove)\nusing this:\n  finite S'\n\ngoal (1 subgoal):\n 1. finite (S' - {Z} \\<union> {Neg (Neg Z)})", "by blast"], ["proof (state)\nthis:\n  finite (S' - {Z} \\<union> {Neg (Neg Z)})\n\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {Z}; finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "ultimately"], ["proof (chain)\npicking this:\n  S' - {Z} \\<union> {Neg (Neg Z)} \\<subseteq> S\n  finite (S' - {Z} \\<union> {Neg (Neg Z)})", "have \\<open>?S' \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  S' - {Z} \\<union> {Neg (Neg Z)} \\<subseteq> S\n  finite (S' - {Z} \\<union> {Neg (Neg Z)})\n\ngoal (1 subgoal):\n 1. S' - {Z} \\<union> {Neg (Neg Z)} \\<in> C", "using finc"], ["proof (prove)\nusing this:\n  S' - {Z} \\<union> {Neg (Neg Z)} \\<subseteq> S\n  finite (S' - {Z} \\<union> {Neg (Neg Z)})\n  \\<forall>S'\\<subseteq>S. finite S' \\<longrightarrow> S' \\<in> C\n\ngoal (1 subgoal):\n 1. S' - {Z} \\<union> {Neg (Neg Z)} \\<in> C", "by blast"], ["proof (state)\nthis:\n  S' - {Z} \\<union> {Neg (Neg Z)} \\<in> C\n\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {Z}; finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "then"], ["proof (chain)\npicking this:\n  S' - {Z} \\<union> {Neg (Neg Z)} \\<in> C", "have \\<open>?S' \\<union> {Z} \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  S' - {Z} \\<union> {Neg (Neg Z)} \\<in> C\n\ngoal (1 subgoal):\n 1. S' - {Z} \\<union> {Neg (Neg Z)} \\<union> {Z} \\<in> C", "using altconc"], ["proof (prove)\nusing this:\n  S' - {Z} \\<union> {Neg (Neg Z)} \\<in> C\n  alt_consistency C\n\ngoal (1 subgoal):\n 1. S' - {Z} \\<union> {Neg (Neg Z)} \\<union> {Z} \\<in> C", "unfolding alt_consistency_def"], ["proof (prove)\nusing this:\n  S' - {Z} \\<union> {Neg (Neg Z)} \\<in> C\n  \\<forall>S.\n     S \\<in> C \\<longrightarrow>\n     (\\<forall>p ts.\n         \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)) \\<and>\n     FF \\<notin> S \\<and>\n     Neg TT \\<notin> S \\<and>\n     (\\<forall>Z.\n         Neg (Neg Z) \\<in> S \\<longrightarrow>\n         S \\<union> {Z} \\<in> C) \\<and>\n     (\\<forall>A B.\n         And A B \\<in> S \\<longrightarrow> S \\<union> {A, B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Or A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A, Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Or A B \\<in> S \\<longrightarrow>\n         S \\<union> {A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (And A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Impl A B \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Impl A B) \\<in> S \\<longrightarrow>\n         S \\<union> {A, Neg B} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Forall P \\<in> S \\<longrightarrow>\n         S \\<union> {P[t/0]} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Neg (Exists P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[t/0])} \\<in> C) \\<and>\n     (\\<forall>P x.\n         (\\<forall>a\\<in>S. x \\<notin> params a) \\<longrightarrow>\n         Exists P \\<in> S \\<longrightarrow>\n         S \\<union> {P[App x []/0]} \\<in> C) \\<and>\n     (\\<forall>P x.\n         (\\<forall>a\\<in>S. x \\<notin> params a) \\<longrightarrow>\n         Neg (Forall P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[App x []/0])} \\<in> C)\n\ngoal (1 subgoal):\n 1. S' - {Z} \\<union> {Neg (Neg Z)} \\<union> {Z} \\<in> C", "by simp"], ["proof (state)\nthis:\n  S' - {Z} \\<union> {Neg (Neg Z)} \\<union> {Z} \\<in> C\n\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {Z}; finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "then"], ["proof (chain)\npicking this:\n  S' - {Z} \\<union> {Neg (Neg Z)} \\<union> {Z} \\<in> C", "show \\<open>S' \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  S' - {Z} \\<union> {Neg (Neg Z)} \\<union> {Z} \\<in> C\n\ngoal (1 subgoal):\n 1. S' \\<in> C", "using sc"], ["proof (prove)\nusing this:\n  S' - {Z} \\<union> {Neg (Neg Z)} \\<union> {Z} \\<in> C\n  \\<forall>S' x.\n     S' \\<union> x \\<in> C \\<longrightarrow>\n     (\\<forall>S\\<subseteq>S' \\<union> x. S \\<in> C)\n\ngoal (1 subgoal):\n 1. S' \\<in> C", "by blast"], ["proof (state)\nthis:\n  S' \\<in> C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  S \\<union> {Z} \\<in> mk_finite_char C\n\ngoal (10 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B} \\<in> mk_finite_char C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B} \\<in> mk_finite_char C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_finite_char C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> mk_finite_char C\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_finite_char C\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> mk_finite_char C\n 9. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]} \\<in> mk_finite_char C\n 10. \\<And>S P x.\n        \\<lbrakk>S \\<in> mk_finite_char C;\n         \\<forall>a\\<in>S. x \\<notin> params a;\n         Neg (Forall P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                          \\<in> mk_finite_char C", "}"], ["proof (state)\nthis:\n  Neg (Neg ?Z2) \\<in> S \\<Longrightarrow>\n  S \\<union> {?Z2} \\<in> mk_finite_char C\n\ngoal (10 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B} \\<in> mk_finite_char C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B} \\<in> mk_finite_char C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_finite_char C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> mk_finite_char C\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_finite_char C\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> mk_finite_char C\n 9. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]} \\<in> mk_finite_char C\n 10. \\<And>S P x.\n        \\<lbrakk>S \\<in> mk_finite_char C;\n         \\<forall>a\\<in>S. x \\<notin> params a;\n         Neg (Forall P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                          \\<in> mk_finite_char C", "{"], ["proof (state)\nthis:\n  Neg (Neg ?Z2) \\<in> S \\<Longrightarrow>\n  S \\<union> {?Z2} \\<in> mk_finite_char C\n\ngoal (10 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B} \\<in> mk_finite_char C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B} \\<in> mk_finite_char C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_finite_char C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> mk_finite_char C\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_finite_char C\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> mk_finite_char C\n 9. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]} \\<in> mk_finite_char C\n 10. \\<And>S P x.\n        \\<lbrakk>S \\<in> mk_finite_char C;\n         \\<forall>a\\<in>S. x \\<notin> params a;\n         Neg (Forall P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                          \\<in> mk_finite_char C", "fix A B"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B} \\<in> mk_finite_char C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B} \\<in> mk_finite_char C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_finite_char C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> mk_finite_char C\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_finite_char C\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> mk_finite_char C\n 9. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]} \\<in> mk_finite_char C\n 10. \\<And>S P x.\n        \\<lbrakk>S \\<in> mk_finite_char C;\n         \\<forall>a\\<in>S. x \\<notin> params a;\n         Neg (Forall P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                          \\<in> mk_finite_char C", "assume *: \\<open>And A B \\<in> S\\<close>"], ["proof (state)\nthis:\n  And A B \\<in> S\n\ngoal (10 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B} \\<in> mk_finite_char C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B} \\<in> mk_finite_char C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_finite_char C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> mk_finite_char C\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_finite_char C\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> mk_finite_char C\n 9. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]} \\<in> mk_finite_char C\n 10. \\<And>S P x.\n        \\<lbrakk>S \\<in> mk_finite_char C;\n         \\<forall>a\\<in>S. x \\<notin> params a;\n         Neg (Forall P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                          \\<in> mk_finite_char C", "show \\<open>S \\<union> {A, B} \\<in> mk_finite_char C\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<union> {A, B} \\<in> mk_finite_char C", "unfolding mk_finite_char_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<union> {A, B}\n    \\<in> {S. \\<forall>S'\\<subseteq>S.\n                 finite S' \\<longrightarrow> S' \\<in> C}", "proof (intro allI impI CollectI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {A, B}; finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "fix S'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {A, B}; finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "let ?S' = \\<open>S' - {A, B} \\<union> {And A B}\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {A, B}; finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "assume \\<open>S' \\<subseteq> S \\<union> {A, B}\\<close> and \\<open>finite S'\\<close>"], ["proof (state)\nthis:\n  S' \\<subseteq> S \\<union> {A, B}\n  finite S'\n\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {A, B}; finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "then"], ["proof (chain)\npicking this:\n  S' \\<subseteq> S \\<union> {A, B}\n  finite S'", "have \\<open>?S' \\<subseteq> S\\<close>"], ["proof (prove)\nusing this:\n  S' \\<subseteq> S \\<union> {A, B}\n  finite S'\n\ngoal (1 subgoal):\n 1. S' - {A, B} \\<union> {And A B} \\<subseteq> S", "using *"], ["proof (prove)\nusing this:\n  S' \\<subseteq> S \\<union> {A, B}\n  finite S'\n  And A B \\<in> S\n\ngoal (1 subgoal):\n 1. S' - {A, B} \\<union> {And A B} \\<subseteq> S", "by blast"], ["proof (state)\nthis:\n  S' - {A, B} \\<union> {And A B} \\<subseteq> S\n\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {A, B}; finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "moreover"], ["proof (state)\nthis:\n  S' - {A, B} \\<union> {And A B} \\<subseteq> S\n\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {A, B}; finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "have \\<open>finite ?S'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (S' - {A, B} \\<union> {And A B})", "using \\<open>finite S'\\<close>"], ["proof (prove)\nusing this:\n  finite S'\n\ngoal (1 subgoal):\n 1. finite (S' - {A, B} \\<union> {And A B})", "by blast"], ["proof (state)\nthis:\n  finite (S' - {A, B} \\<union> {And A B})\n\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {A, B}; finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "ultimately"], ["proof (chain)\npicking this:\n  S' - {A, B} \\<union> {And A B} \\<subseteq> S\n  finite (S' - {A, B} \\<union> {And A B})", "have \\<open>?S' \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  S' - {A, B} \\<union> {And A B} \\<subseteq> S\n  finite (S' - {A, B} \\<union> {And A B})\n\ngoal (1 subgoal):\n 1. S' - {A, B} \\<union> {And A B} \\<in> C", "using finc"], ["proof (prove)\nusing this:\n  S' - {A, B} \\<union> {And A B} \\<subseteq> S\n  finite (S' - {A, B} \\<union> {And A B})\n  \\<forall>S'\\<subseteq>S. finite S' \\<longrightarrow> S' \\<in> C\n\ngoal (1 subgoal):\n 1. S' - {A, B} \\<union> {And A B} \\<in> C", "by blast"], ["proof (state)\nthis:\n  S' - {A, B} \\<union> {And A B} \\<in> C\n\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {A, B}; finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "then"], ["proof (chain)\npicking this:\n  S' - {A, B} \\<union> {And A B} \\<in> C", "have \\<open>?S' \\<union> {A, B} \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  S' - {A, B} \\<union> {And A B} \\<in> C\n\ngoal (1 subgoal):\n 1. S' - {A, B} \\<union> {And A B} \\<union> {A, B} \\<in> C", "using altconc"], ["proof (prove)\nusing this:\n  S' - {A, B} \\<union> {And A B} \\<in> C\n  alt_consistency C\n\ngoal (1 subgoal):\n 1. S' - {A, B} \\<union> {And A B} \\<union> {A, B} \\<in> C", "unfolding alt_consistency_def"], ["proof (prove)\nusing this:\n  S' - {A, B} \\<union> {And A B} \\<in> C\n  \\<forall>S.\n     S \\<in> C \\<longrightarrow>\n     (\\<forall>p ts.\n         \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)) \\<and>\n     FF \\<notin> S \\<and>\n     Neg TT \\<notin> S \\<and>\n     (\\<forall>Z.\n         Neg (Neg Z) \\<in> S \\<longrightarrow>\n         S \\<union> {Z} \\<in> C) \\<and>\n     (\\<forall>A B.\n         And A B \\<in> S \\<longrightarrow> S \\<union> {A, B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Or A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A, Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Or A B \\<in> S \\<longrightarrow>\n         S \\<union> {A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (And A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Impl A B \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Impl A B) \\<in> S \\<longrightarrow>\n         S \\<union> {A, Neg B} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Forall P \\<in> S \\<longrightarrow>\n         S \\<union> {P[t/0]} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Neg (Exists P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[t/0])} \\<in> C) \\<and>\n     (\\<forall>P x.\n         (\\<forall>a\\<in>S. x \\<notin> params a) \\<longrightarrow>\n         Exists P \\<in> S \\<longrightarrow>\n         S \\<union> {P[App x []/0]} \\<in> C) \\<and>\n     (\\<forall>P x.\n         (\\<forall>a\\<in>S. x \\<notin> params a) \\<longrightarrow>\n         Neg (Forall P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[App x []/0])} \\<in> C)\n\ngoal (1 subgoal):\n 1. S' - {A, B} \\<union> {And A B} \\<union> {A, B} \\<in> C", "by simp"], ["proof (state)\nthis:\n  S' - {A, B} \\<union> {And A B} \\<union> {A, B} \\<in> C\n\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {A, B}; finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "then"], ["proof (chain)\npicking this:\n  S' - {A, B} \\<union> {And A B} \\<union> {A, B} \\<in> C", "show \\<open>S' \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  S' - {A, B} \\<union> {And A B} \\<union> {A, B} \\<in> C\n\ngoal (1 subgoal):\n 1. S' \\<in> C", "using sc"], ["proof (prove)\nusing this:\n  S' - {A, B} \\<union> {And A B} \\<union> {A, B} \\<in> C\n  \\<forall>S' x.\n     S' \\<union> x \\<in> C \\<longrightarrow>\n     (\\<forall>S\\<subseteq>S' \\<union> x. S \\<in> C)\n\ngoal (1 subgoal):\n 1. S' \\<in> C", "by blast"], ["proof (state)\nthis:\n  S' \\<in> C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  S \\<union> {A, B} \\<in> mk_finite_char C\n\ngoal (9 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B} \\<in> mk_finite_char C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_finite_char C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> mk_finite_char C\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_finite_char C\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> mk_finite_char C\n 8. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]} \\<in> mk_finite_char C\n 9. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_finite_char C", "}"], ["proof (state)\nthis:\n  And ?A2 ?B2 \\<in> S \\<Longrightarrow>\n  S \\<union> {?A2, ?B2} \\<in> mk_finite_char C\n\ngoal (9 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B} \\<in> mk_finite_char C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_finite_char C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> mk_finite_char C\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_finite_char C\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> mk_finite_char C\n 8. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]} \\<in> mk_finite_char C\n 9. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_finite_char C", "{"], ["proof (state)\nthis:\n  And ?A2 ?B2 \\<in> S \\<Longrightarrow>\n  S \\<union> {?A2, ?B2} \\<in> mk_finite_char C\n\ngoal (9 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B} \\<in> mk_finite_char C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_finite_char C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> mk_finite_char C\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_finite_char C\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> mk_finite_char C\n 8. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]} \\<in> mk_finite_char C\n 9. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_finite_char C", "fix A B"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B} \\<in> mk_finite_char C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_finite_char C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> mk_finite_char C\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_finite_char C\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> mk_finite_char C\n 8. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]} \\<in> mk_finite_char C\n 9. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_finite_char C", "assume *: \\<open>Neg (Or A B) \\<in> S\\<close>"], ["proof (state)\nthis:\n  Neg (Or A B) \\<in> S\n\ngoal (9 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B} \\<in> mk_finite_char C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_finite_char C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> mk_finite_char C\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_finite_char C\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> mk_finite_char C\n 8. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]} \\<in> mk_finite_char C\n 9. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_finite_char C", "show \\<open>S \\<union> {Neg A, Neg B} \\<in> mk_finite_char C\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<union> {Neg A, Neg B} \\<in> mk_finite_char C", "unfolding mk_finite_char_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<union> {Neg A, Neg B}\n    \\<in> {S. \\<forall>S'\\<subseteq>S.\n                 finite S' \\<longrightarrow> S' \\<in> C}", "proof (intro allI impI CollectI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {Neg A, Neg B}; finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "fix S'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {Neg A, Neg B}; finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "let ?S' = \\<open>S' - {Neg A, Neg B} \\<union> {Neg (Or A B)}\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {Neg A, Neg B}; finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "assume \\<open>S' \\<subseteq> S \\<union> {Neg A, Neg B}\\<close> and \\<open>finite S'\\<close>"], ["proof (state)\nthis:\n  S' \\<subseteq> S \\<union> {Neg A, Neg B}\n  finite S'\n\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {Neg A, Neg B}; finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "then"], ["proof (chain)\npicking this:\n  S' \\<subseteq> S \\<union> {Neg A, Neg B}\n  finite S'", "have \\<open>?S' \\<subseteq> S\\<close>"], ["proof (prove)\nusing this:\n  S' \\<subseteq> S \\<union> {Neg A, Neg B}\n  finite S'\n\ngoal (1 subgoal):\n 1. S' - {Neg A, Neg B} \\<union> {Neg (Or A B)} \\<subseteq> S", "using *"], ["proof (prove)\nusing this:\n  S' \\<subseteq> S \\<union> {Neg A, Neg B}\n  finite S'\n  Neg (Or A B) \\<in> S\n\ngoal (1 subgoal):\n 1. S' - {Neg A, Neg B} \\<union> {Neg (Or A B)} \\<subseteq> S", "by blast"], ["proof (state)\nthis:\n  S' - {Neg A, Neg B} \\<union> {Neg (Or A B)} \\<subseteq> S\n\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {Neg A, Neg B}; finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "moreover"], ["proof (state)\nthis:\n  S' - {Neg A, Neg B} \\<union> {Neg (Or A B)} \\<subseteq> S\n\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {Neg A, Neg B}; finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "have \\<open>finite ?S'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (S' - {Neg A, Neg B} \\<union> {Neg (Or A B)})", "using \\<open>finite S'\\<close>"], ["proof (prove)\nusing this:\n  finite S'\n\ngoal (1 subgoal):\n 1. finite (S' - {Neg A, Neg B} \\<union> {Neg (Or A B)})", "by blast"], ["proof (state)\nthis:\n  finite (S' - {Neg A, Neg B} \\<union> {Neg (Or A B)})\n\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {Neg A, Neg B}; finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "ultimately"], ["proof (chain)\npicking this:\n  S' - {Neg A, Neg B} \\<union> {Neg (Or A B)} \\<subseteq> S\n  finite (S' - {Neg A, Neg B} \\<union> {Neg (Or A B)})", "have \\<open>?S' \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  S' - {Neg A, Neg B} \\<union> {Neg (Or A B)} \\<subseteq> S\n  finite (S' - {Neg A, Neg B} \\<union> {Neg (Or A B)})\n\ngoal (1 subgoal):\n 1. S' - {Neg A, Neg B} \\<union> {Neg (Or A B)} \\<in> C", "using finc"], ["proof (prove)\nusing this:\n  S' - {Neg A, Neg B} \\<union> {Neg (Or A B)} \\<subseteq> S\n  finite (S' - {Neg A, Neg B} \\<union> {Neg (Or A B)})\n  \\<forall>S'\\<subseteq>S. finite S' \\<longrightarrow> S' \\<in> C\n\ngoal (1 subgoal):\n 1. S' - {Neg A, Neg B} \\<union> {Neg (Or A B)} \\<in> C", "by blast"], ["proof (state)\nthis:\n  S' - {Neg A, Neg B} \\<union> {Neg (Or A B)} \\<in> C\n\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {Neg A, Neg B}; finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "then"], ["proof (chain)\npicking this:\n  S' - {Neg A, Neg B} \\<union> {Neg (Or A B)} \\<in> C", "have \\<open>?S' \\<union> {Neg A, Neg B} \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  S' - {Neg A, Neg B} \\<union> {Neg (Or A B)} \\<in> C\n\ngoal (1 subgoal):\n 1. S' - {Neg A, Neg B} \\<union> {Neg (Or A B)} \\<union> {Neg A, Neg B}\n    \\<in> C", "using altconc"], ["proof (prove)\nusing this:\n  S' - {Neg A, Neg B} \\<union> {Neg (Or A B)} \\<in> C\n  alt_consistency C\n\ngoal (1 subgoal):\n 1. S' - {Neg A, Neg B} \\<union> {Neg (Or A B)} \\<union> {Neg A, Neg B}\n    \\<in> C", "unfolding alt_consistency_def"], ["proof (prove)\nusing this:\n  S' - {Neg A, Neg B} \\<union> {Neg (Or A B)} \\<in> C\n  \\<forall>S.\n     S \\<in> C \\<longrightarrow>\n     (\\<forall>p ts.\n         \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)) \\<and>\n     FF \\<notin> S \\<and>\n     Neg TT \\<notin> S \\<and>\n     (\\<forall>Z.\n         Neg (Neg Z) \\<in> S \\<longrightarrow>\n         S \\<union> {Z} \\<in> C) \\<and>\n     (\\<forall>A B.\n         And A B \\<in> S \\<longrightarrow> S \\<union> {A, B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Or A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A, Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Or A B \\<in> S \\<longrightarrow>\n         S \\<union> {A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (And A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Impl A B \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Impl A B) \\<in> S \\<longrightarrow>\n         S \\<union> {A, Neg B} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Forall P \\<in> S \\<longrightarrow>\n         S \\<union> {P[t/0]} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Neg (Exists P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[t/0])} \\<in> C) \\<and>\n     (\\<forall>P x.\n         (\\<forall>a\\<in>S. x \\<notin> params a) \\<longrightarrow>\n         Exists P \\<in> S \\<longrightarrow>\n         S \\<union> {P[App x []/0]} \\<in> C) \\<and>\n     (\\<forall>P x.\n         (\\<forall>a\\<in>S. x \\<notin> params a) \\<longrightarrow>\n         Neg (Forall P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[App x []/0])} \\<in> C)\n\ngoal (1 subgoal):\n 1. S' - {Neg A, Neg B} \\<union> {Neg (Or A B)} \\<union> {Neg A, Neg B}\n    \\<in> C", "by simp"], ["proof (state)\nthis:\n  S' - {Neg A, Neg B} \\<union> {Neg (Or A B)} \\<union> {Neg A, Neg B}\n  \\<in> C\n\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {Neg A, Neg B}; finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "then"], ["proof (chain)\npicking this:\n  S' - {Neg A, Neg B} \\<union> {Neg (Or A B)} \\<union> {Neg A, Neg B}\n  \\<in> C", "show \\<open>S' \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  S' - {Neg A, Neg B} \\<union> {Neg (Or A B)} \\<union> {Neg A, Neg B}\n  \\<in> C\n\ngoal (1 subgoal):\n 1. S' \\<in> C", "using sc"], ["proof (prove)\nusing this:\n  S' - {Neg A, Neg B} \\<union> {Neg (Or A B)} \\<union> {Neg A, Neg B}\n  \\<in> C\n  \\<forall>S' x.\n     S' \\<union> x \\<in> C \\<longrightarrow>\n     (\\<forall>S\\<subseteq>S' \\<union> x. S \\<in> C)\n\ngoal (1 subgoal):\n 1. S' \\<in> C", "by blast"], ["proof (state)\nthis:\n  S' \\<in> C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  S \\<union> {Neg A, Neg B} \\<in> mk_finite_char C\n\ngoal (8 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_finite_char C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> mk_finite_char C\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_finite_char C\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> mk_finite_char C\n 7. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]} \\<in> mk_finite_char C\n 8. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_finite_char C", "}"], ["proof (state)\nthis:\n  Neg (Or ?A2 ?B2) \\<in> S \\<Longrightarrow>\n  S \\<union> {Neg ?A2, Neg ?B2} \\<in> mk_finite_char C\n\ngoal (8 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_finite_char C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> mk_finite_char C\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_finite_char C\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> mk_finite_char C\n 7. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]} \\<in> mk_finite_char C\n 8. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_finite_char C", "{"], ["proof (state)\nthis:\n  Neg (Or ?A2 ?B2) \\<in> S \\<Longrightarrow>\n  S \\<union> {Neg ?A2, Neg ?B2} \\<in> mk_finite_char C\n\ngoal (8 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_finite_char C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> mk_finite_char C\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_finite_char C\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> mk_finite_char C\n 7. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]} \\<in> mk_finite_char C\n 8. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_finite_char C", "fix A B"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_finite_char C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> mk_finite_char C\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_finite_char C\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> mk_finite_char C\n 7. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]} \\<in> mk_finite_char C\n 8. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_finite_char C", "assume *: \\<open>Neg (Impl A B) \\<in> S\\<close>"], ["proof (state)\nthis:\n  Neg (Impl A B) \\<in> S\n\ngoal (8 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_finite_char C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B} \\<in> mk_finite_char C\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_finite_char C\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> mk_finite_char C\n 7. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]} \\<in> mk_finite_char C\n 8. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_finite_char C", "show \\<open>S \\<union> {A, Neg B} \\<in> mk_finite_char C\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<union> {A, Neg B} \\<in> mk_finite_char C", "unfolding mk_finite_char_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<union> {A, Neg B}\n    \\<in> {S. \\<forall>S'\\<subseteq>S.\n                 finite S' \\<longrightarrow> S' \\<in> C}", "proof (intro allI impI CollectI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {A, Neg B}; finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "fix S'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {A, Neg B}; finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "let ?S' = \\<open>S' - {A, Neg B} \\<union> {Neg (Impl A B)}\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {A, Neg B}; finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "assume \\<open>S' \\<subseteq> S \\<union> {A, Neg B}\\<close> and \\<open>finite S'\\<close>"], ["proof (state)\nthis:\n  S' \\<subseteq> S \\<union> {A, Neg B}\n  finite S'\n\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {A, Neg B}; finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "then"], ["proof (chain)\npicking this:\n  S' \\<subseteq> S \\<union> {A, Neg B}\n  finite S'", "have \\<open>?S' \\<subseteq> S\\<close>"], ["proof (prove)\nusing this:\n  S' \\<subseteq> S \\<union> {A, Neg B}\n  finite S'\n\ngoal (1 subgoal):\n 1. S' - {A, Neg B} \\<union> {Neg (Impl A B)} \\<subseteq> S", "using *"], ["proof (prove)\nusing this:\n  S' \\<subseteq> S \\<union> {A, Neg B}\n  finite S'\n  Neg (Impl A B) \\<in> S\n\ngoal (1 subgoal):\n 1. S' - {A, Neg B} \\<union> {Neg (Impl A B)} \\<subseteq> S", "by blast"], ["proof (state)\nthis:\n  S' - {A, Neg B} \\<union> {Neg (Impl A B)} \\<subseteq> S\n\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {A, Neg B}; finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "moreover"], ["proof (state)\nthis:\n  S' - {A, Neg B} \\<union> {Neg (Impl A B)} \\<subseteq> S\n\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {A, Neg B}; finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "have \\<open>finite ?S'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (S' - {A, Neg B} \\<union> {Neg (Impl A B)})", "using \\<open>finite S'\\<close>"], ["proof (prove)\nusing this:\n  finite S'\n\ngoal (1 subgoal):\n 1. finite (S' - {A, Neg B} \\<union> {Neg (Impl A B)})", "by blast"], ["proof (state)\nthis:\n  finite (S' - {A, Neg B} \\<union> {Neg (Impl A B)})\n\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {A, Neg B}; finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "ultimately"], ["proof (chain)\npicking this:\n  S' - {A, Neg B} \\<union> {Neg (Impl A B)} \\<subseteq> S\n  finite (S' - {A, Neg B} \\<union> {Neg (Impl A B)})", "have \\<open>?S' \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  S' - {A, Neg B} \\<union> {Neg (Impl A B)} \\<subseteq> S\n  finite (S' - {A, Neg B} \\<union> {Neg (Impl A B)})\n\ngoal (1 subgoal):\n 1. S' - {A, Neg B} \\<union> {Neg (Impl A B)} \\<in> C", "using finc"], ["proof (prove)\nusing this:\n  S' - {A, Neg B} \\<union> {Neg (Impl A B)} \\<subseteq> S\n  finite (S' - {A, Neg B} \\<union> {Neg (Impl A B)})\n  \\<forall>S'\\<subseteq>S. finite S' \\<longrightarrow> S' \\<in> C\n\ngoal (1 subgoal):\n 1. S' - {A, Neg B} \\<union> {Neg (Impl A B)} \\<in> C", "by blast"], ["proof (state)\nthis:\n  S' - {A, Neg B} \\<union> {Neg (Impl A B)} \\<in> C\n\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {A, Neg B}; finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "then"], ["proof (chain)\npicking this:\n  S' - {A, Neg B} \\<union> {Neg (Impl A B)} \\<in> C", "have \\<open>?S' \\<union> {A, Neg B} \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  S' - {A, Neg B} \\<union> {Neg (Impl A B)} \\<in> C\n\ngoal (1 subgoal):\n 1. S' - {A, Neg B} \\<union> {Neg (Impl A B)} \\<union> {A, Neg B} \\<in> C", "using altconc"], ["proof (prove)\nusing this:\n  S' - {A, Neg B} \\<union> {Neg (Impl A B)} \\<in> C\n  alt_consistency C\n\ngoal (1 subgoal):\n 1. S' - {A, Neg B} \\<union> {Neg (Impl A B)} \\<union> {A, Neg B} \\<in> C", "unfolding alt_consistency_def"], ["proof (prove)\nusing this:\n  S' - {A, Neg B} \\<union> {Neg (Impl A B)} \\<in> C\n  \\<forall>S.\n     S \\<in> C \\<longrightarrow>\n     (\\<forall>p ts.\n         \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)) \\<and>\n     FF \\<notin> S \\<and>\n     Neg TT \\<notin> S \\<and>\n     (\\<forall>Z.\n         Neg (Neg Z) \\<in> S \\<longrightarrow>\n         S \\<union> {Z} \\<in> C) \\<and>\n     (\\<forall>A B.\n         And A B \\<in> S \\<longrightarrow> S \\<union> {A, B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Or A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A, Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Or A B \\<in> S \\<longrightarrow>\n         S \\<union> {A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (And A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Impl A B \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Impl A B) \\<in> S \\<longrightarrow>\n         S \\<union> {A, Neg B} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Forall P \\<in> S \\<longrightarrow>\n         S \\<union> {P[t/0]} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Neg (Exists P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[t/0])} \\<in> C) \\<and>\n     (\\<forall>P x.\n         (\\<forall>a\\<in>S. x \\<notin> params a) \\<longrightarrow>\n         Exists P \\<in> S \\<longrightarrow>\n         S \\<union> {P[App x []/0]} \\<in> C) \\<and>\n     (\\<forall>P x.\n         (\\<forall>a\\<in>S. x \\<notin> params a) \\<longrightarrow>\n         Neg (Forall P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[App x []/0])} \\<in> C)\n\ngoal (1 subgoal):\n 1. S' - {A, Neg B} \\<union> {Neg (Impl A B)} \\<union> {A, Neg B} \\<in> C", "by simp"], ["proof (state)\nthis:\n  S' - {A, Neg B} \\<union> {Neg (Impl A B)} \\<union> {A, Neg B} \\<in> C\n\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {A, Neg B}; finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "then"], ["proof (chain)\npicking this:\n  S' - {A, Neg B} \\<union> {Neg (Impl A B)} \\<union> {A, Neg B} \\<in> C", "show \\<open>S' \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  S' - {A, Neg B} \\<union> {Neg (Impl A B)} \\<union> {A, Neg B} \\<in> C\n\ngoal (1 subgoal):\n 1. S' \\<in> C", "using sc"], ["proof (prove)\nusing this:\n  S' - {A, Neg B} \\<union> {Neg (Impl A B)} \\<union> {A, Neg B} \\<in> C\n  \\<forall>S' x.\n     S' \\<union> x \\<in> C \\<longrightarrow>\n     (\\<forall>S\\<subseteq>S' \\<union> x. S \\<in> C)\n\ngoal (1 subgoal):\n 1. S' \\<in> C", "by blast"], ["proof (state)\nthis:\n  S' \\<in> C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  S \\<union> {A, Neg B} \\<in> mk_finite_char C\n\ngoal (7 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_finite_char C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_finite_char C\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> mk_finite_char C\n 6. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]} \\<in> mk_finite_char C\n 7. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_finite_char C", "}"], ["proof (state)\nthis:\n  Neg (Impl ?A2 ?B2) \\<in> S \\<Longrightarrow>\n  S \\<union> {?A2, Neg ?B2} \\<in> mk_finite_char C\n\ngoal (7 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_finite_char C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_finite_char C\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> mk_finite_char C\n 6. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]} \\<in> mk_finite_char C\n 7. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_finite_char C", "{"], ["proof (state)\nthis:\n  Neg (Impl ?A2 ?B2) \\<in> S \\<Longrightarrow>\n  S \\<union> {?A2, Neg ?B2} \\<in> mk_finite_char C\n\ngoal (7 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_finite_char C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_finite_char C\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> mk_finite_char C\n 6. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]} \\<in> mk_finite_char C\n 7. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_finite_char C", "fix A B"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_finite_char C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_finite_char C\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> mk_finite_char C\n 6. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]} \\<in> mk_finite_char C\n 7. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_finite_char C", "assume *: \\<open>Or A B \\<in> S\\<close>"], ["proof (state)\nthis:\n  Or A B \\<in> S\n\ngoal (7 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_finite_char C\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_finite_char C\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> mk_finite_char C\n 6. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]} \\<in> mk_finite_char C\n 7. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_finite_char C", "show \\<open>S \\<union> {A} \\<in> mk_finite_char C \\<or> S \\<union> {B} \\<in> mk_finite_char C\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<union> {A} \\<in> mk_finite_char C \\<or>\n    S \\<union> {B} \\<in> mk_finite_char C", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (S \\<union> {A} \\<in> mk_finite_char C \\<or>\n            S \\<union> {B} \\<in> mk_finite_char C) \\<Longrightarrow>\n    False", "assume \\<open>\\<not> ?thesis\\<close>"], ["proof (state)\nthis:\n  \\<not> (S \\<union> {A} \\<in> mk_finite_char C \\<or>\n          S \\<union> {B} \\<in> mk_finite_char C)\n\ngoal (1 subgoal):\n 1. \\<not> (S \\<union> {A} \\<in> mk_finite_char C \\<or>\n            S \\<union> {B} \\<in> mk_finite_char C) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> (S \\<union> {A} \\<in> mk_finite_char C \\<or>\n          S \\<union> {B} \\<in> mk_finite_char C)", "obtain Sa and Sb\n        where \\<open>Sa \\<subseteq> S \\<union> {A}\\<close> and \\<open>finite Sa\\<close> and \\<open>Sa \\<notin> C\\<close>\n          and \\<open>Sb \\<subseteq> S \\<union> {B}\\<close> and \\<open>finite Sb\\<close> and \\<open>Sb \\<notin> C\\<close>"], ["proof (prove)\nusing this:\n  \\<not> (S \\<union> {A} \\<in> mk_finite_char C \\<or>\n          S \\<union> {B} \\<in> mk_finite_char C)\n\ngoal (1 subgoal):\n 1. (\\<And>Sa Sb.\n        \\<lbrakk>Sa \\<subseteq> S \\<union> {A}; finite Sa; Sa \\<notin> C;\n         Sb \\<subseteq> S \\<union> {B}; finite Sb; Sb \\<notin> C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding mk_finite_char_def"], ["proof (prove)\nusing this:\n  \\<not> (S \\<union> {A}\n          \\<in> {S. \\<forall>S'\\<subseteq>S.\n                       finite S' \\<longrightarrow> S' \\<in> C} \\<or>\n          S \\<union> {B}\n          \\<in> {S. \\<forall>S'\\<subseteq>S.\n                       finite S' \\<longrightarrow> S' \\<in> C})\n\ngoal (1 subgoal):\n 1. (\\<And>Sa Sb.\n        \\<lbrakk>Sa \\<subseteq> S \\<union> {A}; finite Sa; Sa \\<notin> C;\n         Sb \\<subseteq> S \\<union> {B}; finite Sb; Sb \\<notin> C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  Sa \\<subseteq> S \\<union> {A}\n  finite Sa\n  Sa \\<notin> C\n  Sb \\<subseteq> S \\<union> {B}\n  finite Sb\n  Sb \\<notin> C\n\ngoal (1 subgoal):\n 1. \\<not> (S \\<union> {A} \\<in> mk_finite_char C \\<or>\n            S \\<union> {B} \\<in> mk_finite_char C) \\<Longrightarrow>\n    False", "let ?S' = \\<open>(Sa - {A}) \\<union> (Sb - {B}) \\<union> {Or A B}\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (S \\<union> {A} \\<in> mk_finite_char C \\<or>\n            S \\<union> {B} \\<in> mk_finite_char C) \\<Longrightarrow>\n    False", "have \\<open>?S' \\<subseteq> S\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Sa - {A} \\<union> (Sb - {B}) \\<union> {Or A B} \\<subseteq> S", "using \\<open>Sa \\<subseteq> S \\<union> {A}\\<close> \\<open>Sb \\<subseteq> S \\<union> {B}\\<close> *"], ["proof (prove)\nusing this:\n  Sa \\<subseteq> S \\<union> {A}\n  Sb \\<subseteq> S \\<union> {B}\n  Or A B \\<in> S\n\ngoal (1 subgoal):\n 1. Sa - {A} \\<union> (Sb - {B}) \\<union> {Or A B} \\<subseteq> S", "by blast"], ["proof (state)\nthis:\n  Sa - {A} \\<union> (Sb - {B}) \\<union> {Or A B} \\<subseteq> S\n\ngoal (1 subgoal):\n 1. \\<not> (S \\<union> {A} \\<in> mk_finite_char C \\<or>\n            S \\<union> {B} \\<in> mk_finite_char C) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  Sa - {A} \\<union> (Sb - {B}) \\<union> {Or A B} \\<subseteq> S\n\ngoal (1 subgoal):\n 1. \\<not> (S \\<union> {A} \\<in> mk_finite_char C \\<or>\n            S \\<union> {B} \\<in> mk_finite_char C) \\<Longrightarrow>\n    False", "have \\<open>finite ?S'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (Sa - {A} \\<union> (Sb - {B}) \\<union> {Or A B})", "using \\<open>finite Sa\\<close> \\<open>finite Sb\\<close>"], ["proof (prove)\nusing this:\n  finite Sa\n  finite Sb\n\ngoal (1 subgoal):\n 1. finite (Sa - {A} \\<union> (Sb - {B}) \\<union> {Or A B})", "by blast"], ["proof (state)\nthis:\n  finite (Sa - {A} \\<union> (Sb - {B}) \\<union> {Or A B})\n\ngoal (1 subgoal):\n 1. \\<not> (S \\<union> {A} \\<in> mk_finite_char C \\<or>\n            S \\<union> {B} \\<in> mk_finite_char C) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  Sa - {A} \\<union> (Sb - {B}) \\<union> {Or A B} \\<subseteq> S\n  finite (Sa - {A} \\<union> (Sb - {B}) \\<union> {Or A B})", "have \\<open>?S' \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  Sa - {A} \\<union> (Sb - {B}) \\<union> {Or A B} \\<subseteq> S\n  finite (Sa - {A} \\<union> (Sb - {B}) \\<union> {Or A B})\n\ngoal (1 subgoal):\n 1. Sa - {A} \\<union> (Sb - {B}) \\<union> {Or A B} \\<in> C", "using finc"], ["proof (prove)\nusing this:\n  Sa - {A} \\<union> (Sb - {B}) \\<union> {Or A B} \\<subseteq> S\n  finite (Sa - {A} \\<union> (Sb - {B}) \\<union> {Or A B})\n  \\<forall>S'\\<subseteq>S. finite S' \\<longrightarrow> S' \\<in> C\n\ngoal (1 subgoal):\n 1. Sa - {A} \\<union> (Sb - {B}) \\<union> {Or A B} \\<in> C", "by blast"], ["proof (state)\nthis:\n  Sa - {A} \\<union> (Sb - {B}) \\<union> {Or A B} \\<in> C\n\ngoal (1 subgoal):\n 1. \\<not> (S \\<union> {A} \\<in> mk_finite_char C \\<or>\n            S \\<union> {B} \\<in> mk_finite_char C) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  Sa - {A} \\<union> (Sb - {B}) \\<union> {Or A B} \\<in> C", "have \\<open>?S' \\<union> {A} \\<in> C \\<or> ?S' \\<union> {B} \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  Sa - {A} \\<union> (Sb - {B}) \\<union> {Or A B} \\<in> C\n\ngoal (1 subgoal):\n 1. Sa - {A} \\<union> (Sb - {B}) \\<union> {Or A B} \\<union> {A}\n    \\<in> C \\<or>\n    Sa - {A} \\<union> (Sb - {B}) \\<union> {Or A B} \\<union> {B} \\<in> C", "using altconc"], ["proof (prove)\nusing this:\n  Sa - {A} \\<union> (Sb - {B}) \\<union> {Or A B} \\<in> C\n  alt_consistency C\n\ngoal (1 subgoal):\n 1. Sa - {A} \\<union> (Sb - {B}) \\<union> {Or A B} \\<union> {A}\n    \\<in> C \\<or>\n    Sa - {A} \\<union> (Sb - {B}) \\<union> {Or A B} \\<union> {B} \\<in> C", "unfolding alt_consistency_def"], ["proof (prove)\nusing this:\n  Sa - {A} \\<union> (Sb - {B}) \\<union> {Or A B} \\<in> C\n  \\<forall>S.\n     S \\<in> C \\<longrightarrow>\n     (\\<forall>p ts.\n         \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)) \\<and>\n     FF \\<notin> S \\<and>\n     Neg TT \\<notin> S \\<and>\n     (\\<forall>Z.\n         Neg (Neg Z) \\<in> S \\<longrightarrow>\n         S \\<union> {Z} \\<in> C) \\<and>\n     (\\<forall>A B.\n         And A B \\<in> S \\<longrightarrow> S \\<union> {A, B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Or A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A, Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Or A B \\<in> S \\<longrightarrow>\n         S \\<union> {A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (And A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Impl A B \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Impl A B) \\<in> S \\<longrightarrow>\n         S \\<union> {A, Neg B} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Forall P \\<in> S \\<longrightarrow>\n         S \\<union> {P[t/0]} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Neg (Exists P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[t/0])} \\<in> C) \\<and>\n     (\\<forall>P x.\n         (\\<forall>a\\<in>S. x \\<notin> params a) \\<longrightarrow>\n         Exists P \\<in> S \\<longrightarrow>\n         S \\<union> {P[App x []/0]} \\<in> C) \\<and>\n     (\\<forall>P x.\n         (\\<forall>a\\<in>S. x \\<notin> params a) \\<longrightarrow>\n         Neg (Forall P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[App x []/0])} \\<in> C)\n\ngoal (1 subgoal):\n 1. Sa - {A} \\<union> (Sb - {B}) \\<union> {Or A B} \\<union> {A}\n    \\<in> C \\<or>\n    Sa - {A} \\<union> (Sb - {B}) \\<union> {Or A B} \\<union> {B} \\<in> C", "by simp"], ["proof (state)\nthis:\n  Sa - {A} \\<union> (Sb - {B}) \\<union> {Or A B} \\<union> {A} \\<in> C \\<or>\n  Sa - {A} \\<union> (Sb - {B}) \\<union> {Or A B} \\<union> {B} \\<in> C\n\ngoal (1 subgoal):\n 1. \\<not> (S \\<union> {A} \\<in> mk_finite_char C \\<or>\n            S \\<union> {B} \\<in> mk_finite_char C) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  Sa - {A} \\<union> (Sb - {B}) \\<union> {Or A B} \\<union> {A} \\<in> C \\<or>\n  Sa - {A} \\<union> (Sb - {B}) \\<union> {Or A B} \\<union> {B} \\<in> C", "have \\<open>Sa \\<in> C \\<or> Sb \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  Sa - {A} \\<union> (Sb - {B}) \\<union> {Or A B} \\<union> {A} \\<in> C \\<or>\n  Sa - {A} \\<union> (Sb - {B}) \\<union> {Or A B} \\<union> {B} \\<in> C\n\ngoal (1 subgoal):\n 1. Sa \\<in> C \\<or> Sb \\<in> C", "using sc"], ["proof (prove)\nusing this:\n  Sa - {A} \\<union> (Sb - {B}) \\<union> {Or A B} \\<union> {A} \\<in> C \\<or>\n  Sa - {A} \\<union> (Sb - {B}) \\<union> {Or A B} \\<union> {B} \\<in> C\n  \\<forall>S' x.\n     S' \\<union> x \\<in> C \\<longrightarrow>\n     (\\<forall>S\\<subseteq>S' \\<union> x. S \\<in> C)\n\ngoal (1 subgoal):\n 1. Sa \\<in> C \\<or> Sb \\<in> C", "by blast"], ["proof (state)\nthis:\n  Sa \\<in> C \\<or> Sb \\<in> C\n\ngoal (1 subgoal):\n 1. \\<not> (S \\<union> {A} \\<in> mk_finite_char C \\<or>\n            S \\<union> {B} \\<in> mk_finite_char C) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  Sa \\<in> C \\<or> Sb \\<in> C", "show False"], ["proof (prove)\nusing this:\n  Sa \\<in> C \\<or> Sb \\<in> C\n\ngoal (1 subgoal):\n 1. False", "using \\<open>Sa \\<notin> C\\<close> \\<open>Sb \\<notin> C\\<close>"], ["proof (prove)\nusing this:\n  Sa \\<in> C \\<or> Sb \\<in> C\n  Sa \\<notin> C\n  Sb \\<notin> C\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  S \\<union> {A} \\<in> mk_finite_char C \\<or>\n  S \\<union> {B} \\<in> mk_finite_char C\n\ngoal (6 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_finite_char C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_finite_char C\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> mk_finite_char C\n 5. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]} \\<in> mk_finite_char C\n 6. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_finite_char C", "}"], ["proof (state)\nthis:\n  Or ?A2 ?B2 \\<in> S \\<Longrightarrow>\n  S \\<union> {?A2} \\<in> mk_finite_char C \\<or>\n  S \\<union> {?B2} \\<in> mk_finite_char C\n\ngoal (6 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_finite_char C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_finite_char C\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> mk_finite_char C\n 5. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]} \\<in> mk_finite_char C\n 6. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_finite_char C", "{"], ["proof (state)\nthis:\n  Or ?A2 ?B2 \\<in> S \\<Longrightarrow>\n  S \\<union> {?A2} \\<in> mk_finite_char C \\<or>\n  S \\<union> {?B2} \\<in> mk_finite_char C\n\ngoal (6 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_finite_char C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_finite_char C\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> mk_finite_char C\n 5. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]} \\<in> mk_finite_char C\n 6. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_finite_char C", "fix A B"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_finite_char C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_finite_char C\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> mk_finite_char C\n 5. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]} \\<in> mk_finite_char C\n 6. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_finite_char C", "assume *: \\<open>Neg (And A B) \\<in> S\\<close>"], ["proof (state)\nthis:\n  Neg (And A B) \\<in> S\n\ngoal (6 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {Neg B} \\<in> mk_finite_char C\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_finite_char C\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> mk_finite_char C\n 5. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]} \\<in> mk_finite_char C\n 6. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_finite_char C", "show \\<open>S \\<union> {Neg A} \\<in> mk_finite_char C \\<or> S \\<union> {Neg B} \\<in> mk_finite_char C\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n    S \\<union> {Neg B} \\<in> mk_finite_char C", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n            S \\<union> {Neg B} \\<in> mk_finite_char C) \\<Longrightarrow>\n    False", "assume \\<open>\\<not> ?thesis\\<close>"], ["proof (state)\nthis:\n  \\<not> (S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n          S \\<union> {Neg B} \\<in> mk_finite_char C)\n\ngoal (1 subgoal):\n 1. \\<not> (S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n            S \\<union> {Neg B} \\<in> mk_finite_char C) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> (S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n          S \\<union> {Neg B} \\<in> mk_finite_char C)", "obtain Sa and Sb\n        where \\<open>Sa \\<subseteq> S \\<union> {Neg A}\\<close> and \\<open>finite Sa\\<close> and \\<open>Sa \\<notin> C\\<close>\n          and \\<open>Sb \\<subseteq> S \\<union> {Neg B}\\<close> and \\<open>finite Sb\\<close> and \\<open>Sb \\<notin> C\\<close>"], ["proof (prove)\nusing this:\n  \\<not> (S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n          S \\<union> {Neg B} \\<in> mk_finite_char C)\n\ngoal (1 subgoal):\n 1. (\\<And>Sa Sb.\n        \\<lbrakk>Sa \\<subseteq> S \\<union> {Neg A}; finite Sa;\n         Sa \\<notin> C; Sb \\<subseteq> S \\<union> {Neg B}; finite Sb;\n         Sb \\<notin> C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding mk_finite_char_def"], ["proof (prove)\nusing this:\n  \\<not> (S \\<union> {Neg A}\n          \\<in> {S. \\<forall>S'\\<subseteq>S.\n                       finite S' \\<longrightarrow> S' \\<in> C} \\<or>\n          S \\<union> {Neg B}\n          \\<in> {S. \\<forall>S'\\<subseteq>S.\n                       finite S' \\<longrightarrow> S' \\<in> C})\n\ngoal (1 subgoal):\n 1. (\\<And>Sa Sb.\n        \\<lbrakk>Sa \\<subseteq> S \\<union> {Neg A}; finite Sa;\n         Sa \\<notin> C; Sb \\<subseteq> S \\<union> {Neg B}; finite Sb;\n         Sb \\<notin> C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  Sa \\<subseteq> S \\<union> {Neg A}\n  finite Sa\n  Sa \\<notin> C\n  Sb \\<subseteq> S \\<union> {Neg B}\n  finite Sb\n  Sb \\<notin> C\n\ngoal (1 subgoal):\n 1. \\<not> (S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n            S \\<union> {Neg B} \\<in> mk_finite_char C) \\<Longrightarrow>\n    False", "let ?S' = \\<open>(Sa - {Neg A}) \\<union> (Sb - {Neg B}) \\<union> {Neg (And A B)}\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n            S \\<union> {Neg B} \\<in> mk_finite_char C) \\<Longrightarrow>\n    False", "have \\<open>?S' \\<subseteq> S\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Sa - {Neg A} \\<union> (Sb - {Neg B}) \\<union> {Neg (And A B)}\n    \\<subseteq> S", "using \\<open>Sa \\<subseteq> S \\<union> {Neg A}\\<close> \\<open>Sb \\<subseteq> S \\<union> {Neg B}\\<close> *"], ["proof (prove)\nusing this:\n  Sa \\<subseteq> S \\<union> {Neg A}\n  Sb \\<subseteq> S \\<union> {Neg B}\n  Neg (And A B) \\<in> S\n\ngoal (1 subgoal):\n 1. Sa - {Neg A} \\<union> (Sb - {Neg B}) \\<union> {Neg (And A B)}\n    \\<subseteq> S", "by blast"], ["proof (state)\nthis:\n  Sa - {Neg A} \\<union> (Sb - {Neg B}) \\<union> {Neg (And A B)}\n  \\<subseteq> S\n\ngoal (1 subgoal):\n 1. \\<not> (S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n            S \\<union> {Neg B} \\<in> mk_finite_char C) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  Sa - {Neg A} \\<union> (Sb - {Neg B}) \\<union> {Neg (And A B)}\n  \\<subseteq> S\n\ngoal (1 subgoal):\n 1. \\<not> (S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n            S \\<union> {Neg B} \\<in> mk_finite_char C) \\<Longrightarrow>\n    False", "have \\<open>finite ?S'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (Sa - {Neg A} \\<union> (Sb - {Neg B}) \\<union> {Neg (And A B)})", "using \\<open>finite Sa\\<close> \\<open>finite Sb\\<close>"], ["proof (prove)\nusing this:\n  finite Sa\n  finite Sb\n\ngoal (1 subgoal):\n 1. finite (Sa - {Neg A} \\<union> (Sb - {Neg B}) \\<union> {Neg (And A B)})", "by blast"], ["proof (state)\nthis:\n  finite (Sa - {Neg A} \\<union> (Sb - {Neg B}) \\<union> {Neg (And A B)})\n\ngoal (1 subgoal):\n 1. \\<not> (S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n            S \\<union> {Neg B} \\<in> mk_finite_char C) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  Sa - {Neg A} \\<union> (Sb - {Neg B}) \\<union> {Neg (And A B)}\n  \\<subseteq> S\n  finite (Sa - {Neg A} \\<union> (Sb - {Neg B}) \\<union> {Neg (And A B)})", "have \\<open>?S' \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  Sa - {Neg A} \\<union> (Sb - {Neg B}) \\<union> {Neg (And A B)}\n  \\<subseteq> S\n  finite (Sa - {Neg A} \\<union> (Sb - {Neg B}) \\<union> {Neg (And A B)})\n\ngoal (1 subgoal):\n 1. Sa - {Neg A} \\<union> (Sb - {Neg B}) \\<union> {Neg (And A B)} \\<in> C", "using finc"], ["proof (prove)\nusing this:\n  Sa - {Neg A} \\<union> (Sb - {Neg B}) \\<union> {Neg (And A B)}\n  \\<subseteq> S\n  finite (Sa - {Neg A} \\<union> (Sb - {Neg B}) \\<union> {Neg (And A B)})\n  \\<forall>S'\\<subseteq>S. finite S' \\<longrightarrow> S' \\<in> C\n\ngoal (1 subgoal):\n 1. Sa - {Neg A} \\<union> (Sb - {Neg B}) \\<union> {Neg (And A B)} \\<in> C", "by blast"], ["proof (state)\nthis:\n  Sa - {Neg A} \\<union> (Sb - {Neg B}) \\<union> {Neg (And A B)} \\<in> C\n\ngoal (1 subgoal):\n 1. \\<not> (S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n            S \\<union> {Neg B} \\<in> mk_finite_char C) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  Sa - {Neg A} \\<union> (Sb - {Neg B}) \\<union> {Neg (And A B)} \\<in> C", "have \\<open>?S' \\<union> {Neg A} \\<in> C \\<or> ?S' \\<union> {Neg B} \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  Sa - {Neg A} \\<union> (Sb - {Neg B}) \\<union> {Neg (And A B)} \\<in> C\n\ngoal (1 subgoal):\n 1. Sa - {Neg A} \\<union> (Sb - {Neg B}) \\<union> {Neg (And A B)} \\<union>\n    {Neg A}\n    \\<in> C \\<or>\n    Sa - {Neg A} \\<union> (Sb - {Neg B}) \\<union> {Neg (And A B)} \\<union>\n    {Neg B}\n    \\<in> C", "using altconc"], ["proof (prove)\nusing this:\n  Sa - {Neg A} \\<union> (Sb - {Neg B}) \\<union> {Neg (And A B)} \\<in> C\n  alt_consistency C\n\ngoal (1 subgoal):\n 1. Sa - {Neg A} \\<union> (Sb - {Neg B}) \\<union> {Neg (And A B)} \\<union>\n    {Neg A}\n    \\<in> C \\<or>\n    Sa - {Neg A} \\<union> (Sb - {Neg B}) \\<union> {Neg (And A B)} \\<union>\n    {Neg B}\n    \\<in> C", "unfolding alt_consistency_def"], ["proof (prove)\nusing this:\n  Sa - {Neg A} \\<union> (Sb - {Neg B}) \\<union> {Neg (And A B)} \\<in> C\n  \\<forall>S.\n     S \\<in> C \\<longrightarrow>\n     (\\<forall>p ts.\n         \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)) \\<and>\n     FF \\<notin> S \\<and>\n     Neg TT \\<notin> S \\<and>\n     (\\<forall>Z.\n         Neg (Neg Z) \\<in> S \\<longrightarrow>\n         S \\<union> {Z} \\<in> C) \\<and>\n     (\\<forall>A B.\n         And A B \\<in> S \\<longrightarrow> S \\<union> {A, B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Or A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A, Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Or A B \\<in> S \\<longrightarrow>\n         S \\<union> {A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (And A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Impl A B \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Impl A B) \\<in> S \\<longrightarrow>\n         S \\<union> {A, Neg B} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Forall P \\<in> S \\<longrightarrow>\n         S \\<union> {P[t/0]} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Neg (Exists P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[t/0])} \\<in> C) \\<and>\n     (\\<forall>P x.\n         (\\<forall>a\\<in>S. x \\<notin> params a) \\<longrightarrow>\n         Exists P \\<in> S \\<longrightarrow>\n         S \\<union> {P[App x []/0]} \\<in> C) \\<and>\n     (\\<forall>P x.\n         (\\<forall>a\\<in>S. x \\<notin> params a) \\<longrightarrow>\n         Neg (Forall P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[App x []/0])} \\<in> C)\n\ngoal (1 subgoal):\n 1. Sa - {Neg A} \\<union> (Sb - {Neg B}) \\<union> {Neg (And A B)} \\<union>\n    {Neg A}\n    \\<in> C \\<or>\n    Sa - {Neg A} \\<union> (Sb - {Neg B}) \\<union> {Neg (And A B)} \\<union>\n    {Neg B}\n    \\<in> C", "by simp"], ["proof (state)\nthis:\n  Sa - {Neg A} \\<union> (Sb - {Neg B}) \\<union> {Neg (And A B)} \\<union>\n  {Neg A}\n  \\<in> C \\<or>\n  Sa - {Neg A} \\<union> (Sb - {Neg B}) \\<union> {Neg (And A B)} \\<union>\n  {Neg B}\n  \\<in> C\n\ngoal (1 subgoal):\n 1. \\<not> (S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n            S \\<union> {Neg B} \\<in> mk_finite_char C) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  Sa - {Neg A} \\<union> (Sb - {Neg B}) \\<union> {Neg (And A B)} \\<union>\n  {Neg A}\n  \\<in> C \\<or>\n  Sa - {Neg A} \\<union> (Sb - {Neg B}) \\<union> {Neg (And A B)} \\<union>\n  {Neg B}\n  \\<in> C", "have \\<open>Sa \\<in> C \\<or> Sb \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  Sa - {Neg A} \\<union> (Sb - {Neg B}) \\<union> {Neg (And A B)} \\<union>\n  {Neg A}\n  \\<in> C \\<or>\n  Sa - {Neg A} \\<union> (Sb - {Neg B}) \\<union> {Neg (And A B)} \\<union>\n  {Neg B}\n  \\<in> C\n\ngoal (1 subgoal):\n 1. Sa \\<in> C \\<or> Sb \\<in> C", "using sc"], ["proof (prove)\nusing this:\n  Sa - {Neg A} \\<union> (Sb - {Neg B}) \\<union> {Neg (And A B)} \\<union>\n  {Neg A}\n  \\<in> C \\<or>\n  Sa - {Neg A} \\<union> (Sb - {Neg B}) \\<union> {Neg (And A B)} \\<union>\n  {Neg B}\n  \\<in> C\n  \\<forall>S' x.\n     S' \\<union> x \\<in> C \\<longrightarrow>\n     (\\<forall>S\\<subseteq>S' \\<union> x. S \\<in> C)\n\ngoal (1 subgoal):\n 1. Sa \\<in> C \\<or> Sb \\<in> C", "by blast"], ["proof (state)\nthis:\n  Sa \\<in> C \\<or> Sb \\<in> C\n\ngoal (1 subgoal):\n 1. \\<not> (S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n            S \\<union> {Neg B} \\<in> mk_finite_char C) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  Sa \\<in> C \\<or> Sb \\<in> C", "show False"], ["proof (prove)\nusing this:\n  Sa \\<in> C \\<or> Sb \\<in> C\n\ngoal (1 subgoal):\n 1. False", "using \\<open>Sa \\<notin> C\\<close> \\<open>Sb \\<notin> C\\<close>"], ["proof (prove)\nusing this:\n  Sa \\<in> C \\<or> Sb \\<in> C\n  Sa \\<notin> C\n  Sb \\<notin> C\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n  S \\<union> {Neg B} \\<in> mk_finite_char C\n\ngoal (5 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_finite_char C\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> mk_finite_char C\n 4. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]} \\<in> mk_finite_char C\n 5. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_finite_char C", "}"], ["proof (state)\nthis:\n  Neg (And ?A2 ?B2) \\<in> S \\<Longrightarrow>\n  S \\<union> {Neg ?A2} \\<in> mk_finite_char C \\<or>\n  S \\<union> {Neg ?B2} \\<in> mk_finite_char C\n\ngoal (5 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_finite_char C\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> mk_finite_char C\n 4. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]} \\<in> mk_finite_char C\n 5. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_finite_char C", "{"], ["proof (state)\nthis:\n  Neg (And ?A2 ?B2) \\<in> S \\<Longrightarrow>\n  S \\<union> {Neg ?A2} \\<in> mk_finite_char C \\<or>\n  S \\<union> {Neg ?B2} \\<in> mk_finite_char C\n\ngoal (5 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_finite_char C\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> mk_finite_char C\n 4. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]} \\<in> mk_finite_char C\n 5. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_finite_char C", "fix A B"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_finite_char C\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> mk_finite_char C\n 4. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]} \\<in> mk_finite_char C\n 5. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_finite_char C", "assume *: \\<open>Impl A B \\<in> S\\<close>"], ["proof (state)\nthis:\n  Impl A B \\<in> S\n\ngoal (5 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> mk_finite_char C; Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n                         S \\<union> {B} \\<in> mk_finite_char C\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_finite_char C\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> mk_finite_char C\n 4. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]} \\<in> mk_finite_char C\n 5. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_finite_char C", "show \\<open>S \\<union> {Neg A} \\<in> mk_finite_char C \\<or> S \\<union> {B} \\<in> mk_finite_char C\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n    S \\<union> {B} \\<in> mk_finite_char C", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n            S \\<union> {B} \\<in> mk_finite_char C) \\<Longrightarrow>\n    False", "assume \\<open>\\<not> ?thesis\\<close>"], ["proof (state)\nthis:\n  \\<not> (S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n          S \\<union> {B} \\<in> mk_finite_char C)\n\ngoal (1 subgoal):\n 1. \\<not> (S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n            S \\<union> {B} \\<in> mk_finite_char C) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> (S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n          S \\<union> {B} \\<in> mk_finite_char C)", "obtain Sa and Sb\n        where \\<open>Sa \\<subseteq> S \\<union> {Neg A}\\<close> and \\<open>finite Sa\\<close> and \\<open>Sa \\<notin> C\\<close>\n          and \\<open>Sb \\<subseteq> S \\<union> {B}\\<close> and \\<open>finite Sb\\<close> and \\<open>Sb \\<notin> C\\<close>"], ["proof (prove)\nusing this:\n  \\<not> (S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n          S \\<union> {B} \\<in> mk_finite_char C)\n\ngoal (1 subgoal):\n 1. (\\<And>Sa Sb.\n        \\<lbrakk>Sa \\<subseteq> S \\<union> {Neg A}; finite Sa;\n         Sa \\<notin> C; Sb \\<subseteq> S \\<union> {B}; finite Sb;\n         Sb \\<notin> C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding mk_finite_char_def"], ["proof (prove)\nusing this:\n  \\<not> (S \\<union> {Neg A}\n          \\<in> {S. \\<forall>S'\\<subseteq>S.\n                       finite S' \\<longrightarrow> S' \\<in> C} \\<or>\n          S \\<union> {B}\n          \\<in> {S. \\<forall>S'\\<subseteq>S.\n                       finite S' \\<longrightarrow> S' \\<in> C})\n\ngoal (1 subgoal):\n 1. (\\<And>Sa Sb.\n        \\<lbrakk>Sa \\<subseteq> S \\<union> {Neg A}; finite Sa;\n         Sa \\<notin> C; Sb \\<subseteq> S \\<union> {B}; finite Sb;\n         Sb \\<notin> C\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  Sa \\<subseteq> S \\<union> {Neg A}\n  finite Sa\n  Sa \\<notin> C\n  Sb \\<subseteq> S \\<union> {B}\n  finite Sb\n  Sb \\<notin> C\n\ngoal (1 subgoal):\n 1. \\<not> (S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n            S \\<union> {B} \\<in> mk_finite_char C) \\<Longrightarrow>\n    False", "let ?S' = \\<open>(Sa - {Neg A}) \\<union> (Sb - {B}) \\<union> {Impl A B}\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n            S \\<union> {B} \\<in> mk_finite_char C) \\<Longrightarrow>\n    False", "have \\<open>?S' \\<subseteq> S\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Sa - {Neg A} \\<union> (Sb - {B}) \\<union> {Impl A B} \\<subseteq> S", "using \\<open>Sa \\<subseteq> S \\<union> {Neg A}\\<close> \\<open>Sb \\<subseteq> S \\<union> {B}\\<close> *"], ["proof (prove)\nusing this:\n  Sa \\<subseteq> S \\<union> {Neg A}\n  Sb \\<subseteq> S \\<union> {B}\n  Impl A B \\<in> S\n\ngoal (1 subgoal):\n 1. Sa - {Neg A} \\<union> (Sb - {B}) \\<union> {Impl A B} \\<subseteq> S", "by blast"], ["proof (state)\nthis:\n  Sa - {Neg A} \\<union> (Sb - {B}) \\<union> {Impl A B} \\<subseteq> S\n\ngoal (1 subgoal):\n 1. \\<not> (S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n            S \\<union> {B} \\<in> mk_finite_char C) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  Sa - {Neg A} \\<union> (Sb - {B}) \\<union> {Impl A B} \\<subseteq> S\n\ngoal (1 subgoal):\n 1. \\<not> (S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n            S \\<union> {B} \\<in> mk_finite_char C) \\<Longrightarrow>\n    False", "have \\<open>finite ?S'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (Sa - {Neg A} \\<union> (Sb - {B}) \\<union> {Impl A B})", "using \\<open>finite Sa\\<close> \\<open>finite Sb\\<close>"], ["proof (prove)\nusing this:\n  finite Sa\n  finite Sb\n\ngoal (1 subgoal):\n 1. finite (Sa - {Neg A} \\<union> (Sb - {B}) \\<union> {Impl A B})", "by blast"], ["proof (state)\nthis:\n  finite (Sa - {Neg A} \\<union> (Sb - {B}) \\<union> {Impl A B})\n\ngoal (1 subgoal):\n 1. \\<not> (S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n            S \\<union> {B} \\<in> mk_finite_char C) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  Sa - {Neg A} \\<union> (Sb - {B}) \\<union> {Impl A B} \\<subseteq> S\n  finite (Sa - {Neg A} \\<union> (Sb - {B}) \\<union> {Impl A B})", "have \\<open>?S' \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  Sa - {Neg A} \\<union> (Sb - {B}) \\<union> {Impl A B} \\<subseteq> S\n  finite (Sa - {Neg A} \\<union> (Sb - {B}) \\<union> {Impl A B})\n\ngoal (1 subgoal):\n 1. Sa - {Neg A} \\<union> (Sb - {B}) \\<union> {Impl A B} \\<in> C", "using finc"], ["proof (prove)\nusing this:\n  Sa - {Neg A} \\<union> (Sb - {B}) \\<union> {Impl A B} \\<subseteq> S\n  finite (Sa - {Neg A} \\<union> (Sb - {B}) \\<union> {Impl A B})\n  \\<forall>S'\\<subseteq>S. finite S' \\<longrightarrow> S' \\<in> C\n\ngoal (1 subgoal):\n 1. Sa - {Neg A} \\<union> (Sb - {B}) \\<union> {Impl A B} \\<in> C", "by blast"], ["proof (state)\nthis:\n  Sa - {Neg A} \\<union> (Sb - {B}) \\<union> {Impl A B} \\<in> C\n\ngoal (1 subgoal):\n 1. \\<not> (S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n            S \\<union> {B} \\<in> mk_finite_char C) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  Sa - {Neg A} \\<union> (Sb - {B}) \\<union> {Impl A B} \\<in> C", "have \\<open>?S' \\<union> {Neg A} \\<in> C \\<or> ?S' \\<union> {B} \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  Sa - {Neg A} \\<union> (Sb - {B}) \\<union> {Impl A B} \\<in> C\n\ngoal (1 subgoal):\n 1. Sa - {Neg A} \\<union> (Sb - {B}) \\<union> {Impl A B} \\<union> {Neg A}\n    \\<in> C \\<or>\n    Sa - {Neg A} \\<union> (Sb - {B}) \\<union> {Impl A B} \\<union> {B}\n    \\<in> C", "using altconc"], ["proof (prove)\nusing this:\n  Sa - {Neg A} \\<union> (Sb - {B}) \\<union> {Impl A B} \\<in> C\n  alt_consistency C\n\ngoal (1 subgoal):\n 1. Sa - {Neg A} \\<union> (Sb - {B}) \\<union> {Impl A B} \\<union> {Neg A}\n    \\<in> C \\<or>\n    Sa - {Neg A} \\<union> (Sb - {B}) \\<union> {Impl A B} \\<union> {B}\n    \\<in> C", "unfolding alt_consistency_def"], ["proof (prove)\nusing this:\n  Sa - {Neg A} \\<union> (Sb - {B}) \\<union> {Impl A B} \\<in> C\n  \\<forall>S.\n     S \\<in> C \\<longrightarrow>\n     (\\<forall>p ts.\n         \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)) \\<and>\n     FF \\<notin> S \\<and>\n     Neg TT \\<notin> S \\<and>\n     (\\<forall>Z.\n         Neg (Neg Z) \\<in> S \\<longrightarrow>\n         S \\<union> {Z} \\<in> C) \\<and>\n     (\\<forall>A B.\n         And A B \\<in> S \\<longrightarrow> S \\<union> {A, B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Or A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A, Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Or A B \\<in> S \\<longrightarrow>\n         S \\<union> {A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (And A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Impl A B \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Impl A B) \\<in> S \\<longrightarrow>\n         S \\<union> {A, Neg B} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Forall P \\<in> S \\<longrightarrow>\n         S \\<union> {P[t/0]} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Neg (Exists P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[t/0])} \\<in> C) \\<and>\n     (\\<forall>P x.\n         (\\<forall>a\\<in>S. x \\<notin> params a) \\<longrightarrow>\n         Exists P \\<in> S \\<longrightarrow>\n         S \\<union> {P[App x []/0]} \\<in> C) \\<and>\n     (\\<forall>P x.\n         (\\<forall>a\\<in>S. x \\<notin> params a) \\<longrightarrow>\n         Neg (Forall P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[App x []/0])} \\<in> C)\n\ngoal (1 subgoal):\n 1. Sa - {Neg A} \\<union> (Sb - {B}) \\<union> {Impl A B} \\<union> {Neg A}\n    \\<in> C \\<or>\n    Sa - {Neg A} \\<union> (Sb - {B}) \\<union> {Impl A B} \\<union> {B}\n    \\<in> C", "by simp"], ["proof (state)\nthis:\n  Sa - {Neg A} \\<union> (Sb - {B}) \\<union> {Impl A B} \\<union> {Neg A}\n  \\<in> C \\<or>\n  Sa - {Neg A} \\<union> (Sb - {B}) \\<union> {Impl A B} \\<union> {B} \\<in> C\n\ngoal (1 subgoal):\n 1. \\<not> (S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n            S \\<union> {B} \\<in> mk_finite_char C) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  Sa - {Neg A} \\<union> (Sb - {B}) \\<union> {Impl A B} \\<union> {Neg A}\n  \\<in> C \\<or>\n  Sa - {Neg A} \\<union> (Sb - {B}) \\<union> {Impl A B} \\<union> {B} \\<in> C", "have \\<open>Sa \\<in> C \\<or> Sb \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  Sa - {Neg A} \\<union> (Sb - {B}) \\<union> {Impl A B} \\<union> {Neg A}\n  \\<in> C \\<or>\n  Sa - {Neg A} \\<union> (Sb - {B}) \\<union> {Impl A B} \\<union> {B} \\<in> C\n\ngoal (1 subgoal):\n 1. Sa \\<in> C \\<or> Sb \\<in> C", "using sc"], ["proof (prove)\nusing this:\n  Sa - {Neg A} \\<union> (Sb - {B}) \\<union> {Impl A B} \\<union> {Neg A}\n  \\<in> C \\<or>\n  Sa - {Neg A} \\<union> (Sb - {B}) \\<union> {Impl A B} \\<union> {B} \\<in> C\n  \\<forall>S' x.\n     S' \\<union> x \\<in> C \\<longrightarrow>\n     (\\<forall>S\\<subseteq>S' \\<union> x. S \\<in> C)\n\ngoal (1 subgoal):\n 1. Sa \\<in> C \\<or> Sb \\<in> C", "by blast"], ["proof (state)\nthis:\n  Sa \\<in> C \\<or> Sb \\<in> C\n\ngoal (1 subgoal):\n 1. \\<not> (S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n            S \\<union> {B} \\<in> mk_finite_char C) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  Sa \\<in> C \\<or> Sb \\<in> C", "show False"], ["proof (prove)\nusing this:\n  Sa \\<in> C \\<or> Sb \\<in> C\n\ngoal (1 subgoal):\n 1. False", "using \\<open>Sa \\<notin> C\\<close> \\<open>Sb \\<notin> C\\<close>"], ["proof (prove)\nusing this:\n  Sa \\<in> C \\<or> Sb \\<in> C\n  Sa \\<notin> C\n  Sb \\<notin> C\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  S \\<union> {Neg A} \\<in> mk_finite_char C \\<or>\n  S \\<union> {B} \\<in> mk_finite_char C\n\ngoal (4 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_finite_char C\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> mk_finite_char C\n 3. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]} \\<in> mk_finite_char C\n 4. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_finite_char C", "}"], ["proof (state)\nthis:\n  Impl ?A2 ?B2 \\<in> S \\<Longrightarrow>\n  S \\<union> {Neg ?A2} \\<in> mk_finite_char C \\<or>\n  S \\<union> {?B2} \\<in> mk_finite_char C\n\ngoal (4 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_finite_char C\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> mk_finite_char C\n 3. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]} \\<in> mk_finite_char C\n 4. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_finite_char C", "{"], ["proof (state)\nthis:\n  Impl ?A2 ?B2 \\<in> S \\<Longrightarrow>\n  S \\<union> {Neg ?A2} \\<in> mk_finite_char C \\<or>\n  S \\<union> {?B2} \\<in> mk_finite_char C\n\ngoal (4 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_finite_char C\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> mk_finite_char C\n 3. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]} \\<in> mk_finite_char C\n 4. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_finite_char C", "fix P and t :: \\<open>'a term\\<close>"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_finite_char C\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> mk_finite_char C\n 3. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]} \\<in> mk_finite_char C\n 4. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_finite_char C", "assume *: \\<open>Forall P \\<in> S\\<close> and \\<open>closedt 0 t\\<close>"], ["proof (state)\nthis:\n  Forall P \\<in> S\n  closedt 0 t\n\ngoal (4 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]} \\<in> mk_finite_char C\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> mk_finite_char C\n 3. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]} \\<in> mk_finite_char C\n 4. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_finite_char C", "show \\<open>S \\<union> {P[t/0]} \\<in> mk_finite_char C\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<union> {P[t/0]} \\<in> mk_finite_char C", "unfolding mk_finite_char_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<union> {P[t/0]}\n    \\<in> {S. \\<forall>S'\\<subseteq>S.\n                 finite S' \\<longrightarrow> S' \\<in> C}", "proof (intro allI impI CollectI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {P[t/0]}; finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "fix S'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {P[t/0]}; finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "let ?S' = \\<open>S' - {P[t/0]} \\<union> {Forall P}\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {P[t/0]}; finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "assume \\<open>S' \\<subseteq> S \\<union> {P[t/0]}\\<close> and \\<open>finite S'\\<close>"], ["proof (state)\nthis:\n  S' \\<subseteq> S \\<union> {P[t/0]}\n  finite S'\n\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {P[t/0]}; finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "then"], ["proof (chain)\npicking this:\n  S' \\<subseteq> S \\<union> {P[t/0]}\n  finite S'", "have \\<open>?S' \\<subseteq> S\\<close>"], ["proof (prove)\nusing this:\n  S' \\<subseteq> S \\<union> {P[t/0]}\n  finite S'\n\ngoal (1 subgoal):\n 1. S' - {P[t/0]} \\<union> {Forall P} \\<subseteq> S", "using *"], ["proof (prove)\nusing this:\n  S' \\<subseteq> S \\<union> {P[t/0]}\n  finite S'\n  Forall P \\<in> S\n\ngoal (1 subgoal):\n 1. S' - {P[t/0]} \\<union> {Forall P} \\<subseteq> S", "by blast"], ["proof (state)\nthis:\n  S' - {P[t/0]} \\<union> {Forall P} \\<subseteq> S\n\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {P[t/0]}; finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "moreover"], ["proof (state)\nthis:\n  S' - {P[t/0]} \\<union> {Forall P} \\<subseteq> S\n\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {P[t/0]}; finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "have \\<open>finite ?S'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (S' - {P[t/0]} \\<union> {Forall P})", "using \\<open>finite S'\\<close>"], ["proof (prove)\nusing this:\n  finite S'\n\ngoal (1 subgoal):\n 1. finite (S' - {P[t/0]} \\<union> {Forall P})", "by blast"], ["proof (state)\nthis:\n  finite (S' - {P[t/0]} \\<union> {Forall P})\n\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {P[t/0]}; finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "ultimately"], ["proof (chain)\npicking this:\n  S' - {P[t/0]} \\<union> {Forall P} \\<subseteq> S\n  finite (S' - {P[t/0]} \\<union> {Forall P})", "have \\<open>?S' \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  S' - {P[t/0]} \\<union> {Forall P} \\<subseteq> S\n  finite (S' - {P[t/0]} \\<union> {Forall P})\n\ngoal (1 subgoal):\n 1. S' - {P[t/0]} \\<union> {Forall P} \\<in> C", "using finc"], ["proof (prove)\nusing this:\n  S' - {P[t/0]} \\<union> {Forall P} \\<subseteq> S\n  finite (S' - {P[t/0]} \\<union> {Forall P})\n  \\<forall>S'\\<subseteq>S. finite S' \\<longrightarrow> S' \\<in> C\n\ngoal (1 subgoal):\n 1. S' - {P[t/0]} \\<union> {Forall P} \\<in> C", "by blast"], ["proof (state)\nthis:\n  S' - {P[t/0]} \\<union> {Forall P} \\<in> C\n\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {P[t/0]}; finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "then"], ["proof (chain)\npicking this:\n  S' - {P[t/0]} \\<union> {Forall P} \\<in> C", "have \\<open>?S' \\<union> {P[t/0]} \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  S' - {P[t/0]} \\<union> {Forall P} \\<in> C\n\ngoal (1 subgoal):\n 1. S' - {P[t/0]} \\<union> {Forall P} \\<union> {P[t/0]} \\<in> C", "using altconc \\<open>closedt 0 t\\<close>"], ["proof (prove)\nusing this:\n  S' - {P[t/0]} \\<union> {Forall P} \\<in> C\n  alt_consistency C\n  closedt 0 t\n\ngoal (1 subgoal):\n 1. S' - {P[t/0]} \\<union> {Forall P} \\<union> {P[t/0]} \\<in> C", "unfolding alt_consistency_def"], ["proof (prove)\nusing this:\n  S' - {P[t/0]} \\<union> {Forall P} \\<in> C\n  \\<forall>S.\n     S \\<in> C \\<longrightarrow>\n     (\\<forall>p ts.\n         \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)) \\<and>\n     FF \\<notin> S \\<and>\n     Neg TT \\<notin> S \\<and>\n     (\\<forall>Z.\n         Neg (Neg Z) \\<in> S \\<longrightarrow>\n         S \\<union> {Z} \\<in> C) \\<and>\n     (\\<forall>A B.\n         And A B \\<in> S \\<longrightarrow> S \\<union> {A, B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Or A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A, Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Or A B \\<in> S \\<longrightarrow>\n         S \\<union> {A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (And A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Impl A B \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Impl A B) \\<in> S \\<longrightarrow>\n         S \\<union> {A, Neg B} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Forall P \\<in> S \\<longrightarrow>\n         S \\<union> {P[t/0]} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Neg (Exists P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[t/0])} \\<in> C) \\<and>\n     (\\<forall>P x.\n         (\\<forall>a\\<in>S. x \\<notin> params a) \\<longrightarrow>\n         Exists P \\<in> S \\<longrightarrow>\n         S \\<union> {P[App x []/0]} \\<in> C) \\<and>\n     (\\<forall>P x.\n         (\\<forall>a\\<in>S. x \\<notin> params a) \\<longrightarrow>\n         Neg (Forall P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[App x []/0])} \\<in> C)\n  closedt 0 t\n\ngoal (1 subgoal):\n 1. S' - {P[t/0]} \\<union> {Forall P} \\<union> {P[t/0]} \\<in> C", "by simp"], ["proof (state)\nthis:\n  S' - {P[t/0]} \\<union> {Forall P} \\<union> {P[t/0]} \\<in> C\n\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {P[t/0]}; finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "then"], ["proof (chain)\npicking this:\n  S' - {P[t/0]} \\<union> {Forall P} \\<union> {P[t/0]} \\<in> C", "show \\<open>S' \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  S' - {P[t/0]} \\<union> {Forall P} \\<union> {P[t/0]} \\<in> C\n\ngoal (1 subgoal):\n 1. S' \\<in> C", "using sc"], ["proof (prove)\nusing this:\n  S' - {P[t/0]} \\<union> {Forall P} \\<union> {P[t/0]} \\<in> C\n  \\<forall>S' x.\n     S' \\<union> x \\<in> C \\<longrightarrow>\n     (\\<forall>S\\<subseteq>S' \\<union> x. S \\<in> C)\n\ngoal (1 subgoal):\n 1. S' \\<in> C", "by blast"], ["proof (state)\nthis:\n  S' \\<in> C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  S \\<union> {P[t/0]} \\<in> mk_finite_char C\n\ngoal (3 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> mk_finite_char C\n 2. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]} \\<in> mk_finite_char C\n 3. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_finite_char C", "}"], ["proof (state)\nthis:\n  \\<lbrakk>Forall ?P2 \\<in> S; closedt 0 ?t2\\<rbrakk>\n  \\<Longrightarrow> S \\<union> {?P2[?t2/0]} \\<in> mk_finite_char C\n\ngoal (3 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> mk_finite_char C\n 2. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]} \\<in> mk_finite_char C\n 3. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_finite_char C", "{"], ["proof (state)\nthis:\n  \\<lbrakk>Forall ?P2 \\<in> S; closedt 0 ?t2\\<rbrakk>\n  \\<Longrightarrow> S \\<union> {?P2[?t2/0]} \\<in> mk_finite_char C\n\ngoal (3 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> mk_finite_char C\n 2. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]} \\<in> mk_finite_char C\n 3. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_finite_char C", "fix P and t :: \\<open>'a term\\<close>"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> mk_finite_char C\n 2. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]} \\<in> mk_finite_char C\n 3. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_finite_char C", "assume *: \\<open>Neg (Exists P) \\<in> S\\<close> and \\<open>closedt 0 t\\<close>"], ["proof (state)\nthis:\n  Neg (Exists P) \\<in> S\n  closedt 0 t\n\ngoal (3 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> mk_finite_char C; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])} \\<in> mk_finite_char C\n 2. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]} \\<in> mk_finite_char C\n 3. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_finite_char C", "show \\<open>S \\<union> {Neg (P[t/0])} \\<in> mk_finite_char C\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<union> {Neg (P[t/0])} \\<in> mk_finite_char C", "unfolding mk_finite_char_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<union> {Neg (P[t/0])}\n    \\<in> {S. \\<forall>S'\\<subseteq>S.\n                 finite S' \\<longrightarrow> S' \\<in> C}", "proof (intro allI impI CollectI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {Neg (P[t/0])}; finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "fix S'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {Neg (P[t/0])}; finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "let ?S' = \\<open>S' - {Neg (P[t/0])} \\<union> {Neg (Exists P)}\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {Neg (P[t/0])}; finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "assume \\<open>S' \\<subseteq> S \\<union> {Neg (P[t/0])}\\<close> and \\<open>finite S'\\<close>"], ["proof (state)\nthis:\n  S' \\<subseteq> S \\<union> {Neg (P[t/0])}\n  finite S'\n\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {Neg (P[t/0])}; finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "then"], ["proof (chain)\npicking this:\n  S' \\<subseteq> S \\<union> {Neg (P[t/0])}\n  finite S'", "have \\<open>?S' \\<subseteq> S\\<close>"], ["proof (prove)\nusing this:\n  S' \\<subseteq> S \\<union> {Neg (P[t/0])}\n  finite S'\n\ngoal (1 subgoal):\n 1. S' - {Neg (P[t/0])} \\<union> {Neg (Exists P)} \\<subseteq> S", "using *"], ["proof (prove)\nusing this:\n  S' \\<subseteq> S \\<union> {Neg (P[t/0])}\n  finite S'\n  Neg (Exists P) \\<in> S\n\ngoal (1 subgoal):\n 1. S' - {Neg (P[t/0])} \\<union> {Neg (Exists P)} \\<subseteq> S", "by blast"], ["proof (state)\nthis:\n  S' - {Neg (P[t/0])} \\<union> {Neg (Exists P)} \\<subseteq> S\n\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {Neg (P[t/0])}; finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "moreover"], ["proof (state)\nthis:\n  S' - {Neg (P[t/0])} \\<union> {Neg (Exists P)} \\<subseteq> S\n\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {Neg (P[t/0])}; finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "have \\<open>finite ?S'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (S' - {Neg (P[t/0])} \\<union> {Neg (Exists P)})", "using \\<open>finite S'\\<close>"], ["proof (prove)\nusing this:\n  finite S'\n\ngoal (1 subgoal):\n 1. finite (S' - {Neg (P[t/0])} \\<union> {Neg (Exists P)})", "by blast"], ["proof (state)\nthis:\n  finite (S' - {Neg (P[t/0])} \\<union> {Neg (Exists P)})\n\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {Neg (P[t/0])}; finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "ultimately"], ["proof (chain)\npicking this:\n  S' - {Neg (P[t/0])} \\<union> {Neg (Exists P)} \\<subseteq> S\n  finite (S' - {Neg (P[t/0])} \\<union> {Neg (Exists P)})", "have \\<open>?S' \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  S' - {Neg (P[t/0])} \\<union> {Neg (Exists P)} \\<subseteq> S\n  finite (S' - {Neg (P[t/0])} \\<union> {Neg (Exists P)})\n\ngoal (1 subgoal):\n 1. S' - {Neg (P[t/0])} \\<union> {Neg (Exists P)} \\<in> C", "using finc"], ["proof (prove)\nusing this:\n  S' - {Neg (P[t/0])} \\<union> {Neg (Exists P)} \\<subseteq> S\n  finite (S' - {Neg (P[t/0])} \\<union> {Neg (Exists P)})\n  \\<forall>S'\\<subseteq>S. finite S' \\<longrightarrow> S' \\<in> C\n\ngoal (1 subgoal):\n 1. S' - {Neg (P[t/0])} \\<union> {Neg (Exists P)} \\<in> C", "by blast"], ["proof (state)\nthis:\n  S' - {Neg (P[t/0])} \\<union> {Neg (Exists P)} \\<in> C\n\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {Neg (P[t/0])}; finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "then"], ["proof (chain)\npicking this:\n  S' - {Neg (P[t/0])} \\<union> {Neg (Exists P)} \\<in> C", "have \\<open>?S' \\<union> {Neg (P[t/0])} \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  S' - {Neg (P[t/0])} \\<union> {Neg (Exists P)} \\<in> C\n\ngoal (1 subgoal):\n 1. S' - {Neg (P[t/0])} \\<union> {Neg (Exists P)} \\<union> {Neg (P[t/0])}\n    \\<in> C", "using altconc \\<open>closedt 0 t\\<close>"], ["proof (prove)\nusing this:\n  S' - {Neg (P[t/0])} \\<union> {Neg (Exists P)} \\<in> C\n  alt_consistency C\n  closedt 0 t\n\ngoal (1 subgoal):\n 1. S' - {Neg (P[t/0])} \\<union> {Neg (Exists P)} \\<union> {Neg (P[t/0])}\n    \\<in> C", "unfolding alt_consistency_def"], ["proof (prove)\nusing this:\n  S' - {Neg (P[t/0])} \\<union> {Neg (Exists P)} \\<in> C\n  \\<forall>S.\n     S \\<in> C \\<longrightarrow>\n     (\\<forall>p ts.\n         \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)) \\<and>\n     FF \\<notin> S \\<and>\n     Neg TT \\<notin> S \\<and>\n     (\\<forall>Z.\n         Neg (Neg Z) \\<in> S \\<longrightarrow>\n         S \\<union> {Z} \\<in> C) \\<and>\n     (\\<forall>A B.\n         And A B \\<in> S \\<longrightarrow> S \\<union> {A, B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Or A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A, Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Or A B \\<in> S \\<longrightarrow>\n         S \\<union> {A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (And A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Impl A B \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Impl A B) \\<in> S \\<longrightarrow>\n         S \\<union> {A, Neg B} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Forall P \\<in> S \\<longrightarrow>\n         S \\<union> {P[t/0]} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Neg (Exists P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[t/0])} \\<in> C) \\<and>\n     (\\<forall>P x.\n         (\\<forall>a\\<in>S. x \\<notin> params a) \\<longrightarrow>\n         Exists P \\<in> S \\<longrightarrow>\n         S \\<union> {P[App x []/0]} \\<in> C) \\<and>\n     (\\<forall>P x.\n         (\\<forall>a\\<in>S. x \\<notin> params a) \\<longrightarrow>\n         Neg (Forall P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[App x []/0])} \\<in> C)\n  closedt 0 t\n\ngoal (1 subgoal):\n 1. S' - {Neg (P[t/0])} \\<union> {Neg (Exists P)} \\<union> {Neg (P[t/0])}\n    \\<in> C", "by simp"], ["proof (state)\nthis:\n  S' - {Neg (P[t/0])} \\<union> {Neg (Exists P)} \\<union> {Neg (P[t/0])}\n  \\<in> C\n\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {Neg (P[t/0])}; finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "then"], ["proof (chain)\npicking this:\n  S' - {Neg (P[t/0])} \\<union> {Neg (Exists P)} \\<union> {Neg (P[t/0])}\n  \\<in> C", "show \\<open>S' \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  S' - {Neg (P[t/0])} \\<union> {Neg (Exists P)} \\<union> {Neg (P[t/0])}\n  \\<in> C\n\ngoal (1 subgoal):\n 1. S' \\<in> C", "using sc"], ["proof (prove)\nusing this:\n  S' - {Neg (P[t/0])} \\<union> {Neg (Exists P)} \\<union> {Neg (P[t/0])}\n  \\<in> C\n  \\<forall>S' x.\n     S' \\<union> x \\<in> C \\<longrightarrow>\n     (\\<forall>S\\<subseteq>S' \\<union> x. S \\<in> C)\n\ngoal (1 subgoal):\n 1. S' \\<in> C", "by blast"], ["proof (state)\nthis:\n  S' \\<in> C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  S \\<union> {Neg (P[t/0])} \\<in> mk_finite_char C\n\ngoal (2 subgoals):\n 1. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]} \\<in> mk_finite_char C\n 2. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_finite_char C", "}"], ["proof (state)\nthis:\n  \\<lbrakk>Neg (Exists ?P2) \\<in> S; closedt 0 ?t2\\<rbrakk>\n  \\<Longrightarrow> S \\<union> {Neg (?P2[?t2/0])} \\<in> mk_finite_char C\n\ngoal (2 subgoals):\n 1. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]} \\<in> mk_finite_char C\n 2. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_finite_char C", "{"], ["proof (state)\nthis:\n  \\<lbrakk>Neg (Exists ?P2) \\<in> S; closedt 0 ?t2\\<rbrakk>\n  \\<Longrightarrow> S \\<union> {Neg (?P2[?t2/0])} \\<in> mk_finite_char C\n\ngoal (2 subgoals):\n 1. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]} \\<in> mk_finite_char C\n 2. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_finite_char C", "fix P x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]} \\<in> mk_finite_char C\n 2. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_finite_char C", "assume *: \\<open>Exists P \\<in> S\\<close> and \\<open>\\<forall>a \\<in> S. x \\<notin> params a\\<close>"], ["proof (state)\nthis:\n  Exists P \\<in> S\n  \\<forall>a\\<in>S. x \\<notin> params a\n\ngoal (2 subgoals):\n 1. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a; Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[App x []/0]} \\<in> mk_finite_char C\n 2. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_finite_char C", "show \\<open>S \\<union> {P[App x []/0]} \\<in> mk_finite_char C\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<union> {P[App x []/0]} \\<in> mk_finite_char C", "unfolding mk_finite_char_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<union> {P[App x []/0]}\n    \\<in> {S. \\<forall>S'\\<subseteq>S.\n                 finite S' \\<longrightarrow> S' \\<in> C}", "proof (intro allI impI CollectI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {P[App x []/0]};\n        finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "fix S'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {P[App x []/0]};\n        finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "let ?S' = \\<open>S' - {P[App x []/0]} \\<union> {Exists P}\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {P[App x []/0]};\n        finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "assume \\<open>S' \\<subseteq> S \\<union> {P[App x []/0]}\\<close> and \\<open>finite S'\\<close>"], ["proof (state)\nthis:\n  S' \\<subseteq> S \\<union> {P[App x []/0]}\n  finite S'\n\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {P[App x []/0]};\n        finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "then"], ["proof (chain)\npicking this:\n  S' \\<subseteq> S \\<union> {P[App x []/0]}\n  finite S'", "have \\<open>?S' \\<subseteq> S\\<close>"], ["proof (prove)\nusing this:\n  S' \\<subseteq> S \\<union> {P[App x []/0]}\n  finite S'\n\ngoal (1 subgoal):\n 1. S' - {P[App x []/0]} \\<union> {Exists P} \\<subseteq> S", "using *"], ["proof (prove)\nusing this:\n  S' \\<subseteq> S \\<union> {P[App x []/0]}\n  finite S'\n  Exists P \\<in> S\n\ngoal (1 subgoal):\n 1. S' - {P[App x []/0]} \\<union> {Exists P} \\<subseteq> S", "by blast"], ["proof (state)\nthis:\n  S' - {P[App x []/0]} \\<union> {Exists P} \\<subseteq> S\n\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {P[App x []/0]};\n        finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "moreover"], ["proof (state)\nthis:\n  S' - {P[App x []/0]} \\<union> {Exists P} \\<subseteq> S\n\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {P[App x []/0]};\n        finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "have \\<open>finite ?S'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (S' - {P[App x []/0]} \\<union> {Exists P})", "using \\<open>finite S'\\<close>"], ["proof (prove)\nusing this:\n  finite S'\n\ngoal (1 subgoal):\n 1. finite (S' - {P[App x []/0]} \\<union> {Exists P})", "by blast"], ["proof (state)\nthis:\n  finite (S' - {P[App x []/0]} \\<union> {Exists P})\n\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {P[App x []/0]};\n        finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "ultimately"], ["proof (chain)\npicking this:\n  S' - {P[App x []/0]} \\<union> {Exists P} \\<subseteq> S\n  finite (S' - {P[App x []/0]} \\<union> {Exists P})", "have \\<open>?S' \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  S' - {P[App x []/0]} \\<union> {Exists P} \\<subseteq> S\n  finite (S' - {P[App x []/0]} \\<union> {Exists P})\n\ngoal (1 subgoal):\n 1. S' - {P[App x []/0]} \\<union> {Exists P} \\<in> C", "using finc"], ["proof (prove)\nusing this:\n  S' - {P[App x []/0]} \\<union> {Exists P} \\<subseteq> S\n  finite (S' - {P[App x []/0]} \\<union> {Exists P})\n  \\<forall>S'\\<subseteq>S. finite S' \\<longrightarrow> S' \\<in> C\n\ngoal (1 subgoal):\n 1. S' - {P[App x []/0]} \\<union> {Exists P} \\<in> C", "by blast"], ["proof (state)\nthis:\n  S' - {P[App x []/0]} \\<union> {Exists P} \\<in> C\n\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {P[App x []/0]};\n        finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "moreover"], ["proof (state)\nthis:\n  S' - {P[App x []/0]} \\<union> {Exists P} \\<in> C\n\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {P[App x []/0]};\n        finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "have \\<open>\\<forall>a \\<in> ?S'. x \\<notin> params a\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>S' - {P[App x []/0]} \\<union> {Exists P}.\n       x \\<notin> params a", "using \\<open>\\<forall>a \\<in> S. x \\<notin> params a\\<close> \\<open>?S' \\<subseteq> S\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>S. x \\<notin> params a\n  S' - {P[App x []/0]} \\<union> {Exists P} \\<subseteq> S\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>S' - {P[App x []/0]} \\<union> {Exists P}.\n       x \\<notin> params a", "by blast"], ["proof (state)\nthis:\n  \\<forall>a\\<in>S' - {P[App x []/0]} \\<union> {Exists P}.\n     x \\<notin> params a\n\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {P[App x []/0]};\n        finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "ultimately"], ["proof (chain)\npicking this:\n  S' - {P[App x []/0]} \\<union> {Exists P} \\<in> C\n  \\<forall>a\\<in>S' - {P[App x []/0]} \\<union> {Exists P}.\n     x \\<notin> params a", "have \\<open>?S' \\<union> {P[App x []/0]} \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  S' - {P[App x []/0]} \\<union> {Exists P} \\<in> C\n  \\<forall>a\\<in>S' - {P[App x []/0]} \\<union> {Exists P}.\n     x \\<notin> params a\n\ngoal (1 subgoal):\n 1. S' - {P[App x []/0]} \\<union> {Exists P} \\<union> {P[App x []/0]}\n    \\<in> C", "using altconc \\<open>\\<forall>a \\<in> S. x \\<notin> params a\\<close>"], ["proof (prove)\nusing this:\n  S' - {P[App x []/0]} \\<union> {Exists P} \\<in> C\n  \\<forall>a\\<in>S' - {P[App x []/0]} \\<union> {Exists P}.\n     x \\<notin> params a\n  alt_consistency C\n  \\<forall>a\\<in>S. x \\<notin> params a\n\ngoal (1 subgoal):\n 1. S' - {P[App x []/0]} \\<union> {Exists P} \\<union> {P[App x []/0]}\n    \\<in> C", "unfolding alt_consistency_def"], ["proof (prove)\nusing this:\n  S' - {P[App x []/0]} \\<union> {Exists P} \\<in> C\n  \\<forall>a\\<in>S' - {P[App x []/0]} \\<union> {Exists P}.\n     x \\<notin> params a\n  \\<forall>S.\n     S \\<in> C \\<longrightarrow>\n     (\\<forall>p ts.\n         \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)) \\<and>\n     FF \\<notin> S \\<and>\n     Neg TT \\<notin> S \\<and>\n     (\\<forall>Z.\n         Neg (Neg Z) \\<in> S \\<longrightarrow>\n         S \\<union> {Z} \\<in> C) \\<and>\n     (\\<forall>A B.\n         And A B \\<in> S \\<longrightarrow> S \\<union> {A, B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Or A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A, Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Or A B \\<in> S \\<longrightarrow>\n         S \\<union> {A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (And A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Impl A B \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Impl A B) \\<in> S \\<longrightarrow>\n         S \\<union> {A, Neg B} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Forall P \\<in> S \\<longrightarrow>\n         S \\<union> {P[t/0]} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Neg (Exists P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[t/0])} \\<in> C) \\<and>\n     (\\<forall>P x.\n         (\\<forall>a\\<in>S. x \\<notin> params a) \\<longrightarrow>\n         Exists P \\<in> S \\<longrightarrow>\n         S \\<union> {P[App x []/0]} \\<in> C) \\<and>\n     (\\<forall>P x.\n         (\\<forall>a\\<in>S. x \\<notin> params a) \\<longrightarrow>\n         Neg (Forall P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[App x []/0])} \\<in> C)\n  \\<forall>a\\<in>S. x \\<notin> params a\n\ngoal (1 subgoal):\n 1. S' - {P[App x []/0]} \\<union> {Exists P} \\<union> {P[App x []/0]}\n    \\<in> C", "by blast"], ["proof (state)\nthis:\n  S' - {P[App x []/0]} \\<union> {Exists P} \\<union> {P[App x []/0]} \\<in> C\n\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {P[App x []/0]};\n        finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "then"], ["proof (chain)\npicking this:\n  S' - {P[App x []/0]} \\<union> {Exists P} \\<union> {P[App x []/0]} \\<in> C", "show \\<open>S' \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  S' - {P[App x []/0]} \\<union> {Exists P} \\<union> {P[App x []/0]} \\<in> C\n\ngoal (1 subgoal):\n 1. S' \\<in> C", "using sc"], ["proof (prove)\nusing this:\n  S' - {P[App x []/0]} \\<union> {Exists P} \\<union> {P[App x []/0]} \\<in> C\n  \\<forall>S' x.\n     S' \\<union> x \\<in> C \\<longrightarrow>\n     (\\<forall>S\\<subseteq>S' \\<union> x. S \\<in> C)\n\ngoal (1 subgoal):\n 1. S' \\<in> C", "by blast"], ["proof (state)\nthis:\n  S' \\<in> C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  S \\<union> {P[App x []/0]} \\<in> mk_finite_char C\n\ngoal (1 subgoal):\n 1. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_finite_char C", "}"], ["proof (state)\nthis:\n  \\<lbrakk>Exists ?P2 \\<in> S;\n   \\<forall>a\\<in>S. ?x2 \\<notin> params a\\<rbrakk>\n  \\<Longrightarrow> S \\<union> {?P2[App ?x2 []/0]} \\<in> mk_finite_char C\n\ngoal (1 subgoal):\n 1. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_finite_char C", "{"], ["proof (state)\nthis:\n  \\<lbrakk>Exists ?P2 \\<in> S;\n   \\<forall>a\\<in>S. ?x2 \\<notin> params a\\<rbrakk>\n  \\<Longrightarrow> S \\<union> {?P2[App ?x2 []/0]} \\<in> mk_finite_char C\n\ngoal (1 subgoal):\n 1. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_finite_char C", "fix P x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_finite_char C", "assume *: \\<open>Neg (Forall P) \\<in> S\\<close> and \\<open>\\<forall>a \\<in> S. x \\<notin> params a\\<close>"], ["proof (state)\nthis:\n  Neg (Forall P) \\<in> S\n  \\<forall>a\\<in>S. x \\<notin> params a\n\ngoal (1 subgoal):\n 1. \\<And>S P x.\n       \\<lbrakk>S \\<in> mk_finite_char C;\n        \\<forall>a\\<in>S. x \\<notin> params a;\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[App x []/0])}\n                         \\<in> mk_finite_char C", "show \\<open>S \\<union> {Neg (P[App x []/0])} \\<in> mk_finite_char C\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<union> {Neg (P[App x []/0])} \\<in> mk_finite_char C", "unfolding mk_finite_char_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<union> {Neg (P[App x []/0])}\n    \\<in> {S. \\<forall>S'\\<subseteq>S.\n                 finite S' \\<longrightarrow> S' \\<in> C}", "proof (intro allI impI CollectI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {Neg (P[App x []/0])};\n        finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "fix S'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {Neg (P[App x []/0])};\n        finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "let ?S' = \\<open>S' - {Neg (P[App x []/0])} \\<union> {Neg (Forall P)}\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {Neg (P[App x []/0])};\n        finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "assume \\<open>S' \\<subseteq> S \\<union> {Neg (P[App x []/0])}\\<close> and \\<open>finite S'\\<close>"], ["proof (state)\nthis:\n  S' \\<subseteq> S \\<union> {Neg (P[App x []/0])}\n  finite S'\n\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {Neg (P[App x []/0])};\n        finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "then"], ["proof (chain)\npicking this:\n  S' \\<subseteq> S \\<union> {Neg (P[App x []/0])}\n  finite S'", "have \\<open>?S' \\<subseteq> S\\<close>"], ["proof (prove)\nusing this:\n  S' \\<subseteq> S \\<union> {Neg (P[App x []/0])}\n  finite S'\n\ngoal (1 subgoal):\n 1. S' - {Neg (P[App x []/0])} \\<union> {Neg (Forall P)} \\<subseteq> S", "using *"], ["proof (prove)\nusing this:\n  S' \\<subseteq> S \\<union> {Neg (P[App x []/0])}\n  finite S'\n  Neg (Forall P) \\<in> S\n\ngoal (1 subgoal):\n 1. S' - {Neg (P[App x []/0])} \\<union> {Neg (Forall P)} \\<subseteq> S", "by blast"], ["proof (state)\nthis:\n  S' - {Neg (P[App x []/0])} \\<union> {Neg (Forall P)} \\<subseteq> S\n\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {Neg (P[App x []/0])};\n        finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "moreover"], ["proof (state)\nthis:\n  S' - {Neg (P[App x []/0])} \\<union> {Neg (Forall P)} \\<subseteq> S\n\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {Neg (P[App x []/0])};\n        finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "have \\<open>finite ?S'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (S' - {Neg (P[App x []/0])} \\<union> {Neg (Forall P)})", "using \\<open>finite S'\\<close>"], ["proof (prove)\nusing this:\n  finite S'\n\ngoal (1 subgoal):\n 1. finite (S' - {Neg (P[App x []/0])} \\<union> {Neg (Forall P)})", "by blast"], ["proof (state)\nthis:\n  finite (S' - {Neg (P[App x []/0])} \\<union> {Neg (Forall P)})\n\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {Neg (P[App x []/0])};\n        finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "ultimately"], ["proof (chain)\npicking this:\n  S' - {Neg (P[App x []/0])} \\<union> {Neg (Forall P)} \\<subseteq> S\n  finite (S' - {Neg (P[App x []/0])} \\<union> {Neg (Forall P)})", "have \\<open>?S' \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  S' - {Neg (P[App x []/0])} \\<union> {Neg (Forall P)} \\<subseteq> S\n  finite (S' - {Neg (P[App x []/0])} \\<union> {Neg (Forall P)})\n\ngoal (1 subgoal):\n 1. S' - {Neg (P[App x []/0])} \\<union> {Neg (Forall P)} \\<in> C", "using finc"], ["proof (prove)\nusing this:\n  S' - {Neg (P[App x []/0])} \\<union> {Neg (Forall P)} \\<subseteq> S\n  finite (S' - {Neg (P[App x []/0])} \\<union> {Neg (Forall P)})\n  \\<forall>S'\\<subseteq>S. finite S' \\<longrightarrow> S' \\<in> C\n\ngoal (1 subgoal):\n 1. S' - {Neg (P[App x []/0])} \\<union> {Neg (Forall P)} \\<in> C", "by blast"], ["proof (state)\nthis:\n  S' - {Neg (P[App x []/0])} \\<union> {Neg (Forall P)} \\<in> C\n\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {Neg (P[App x []/0])};\n        finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "moreover"], ["proof (state)\nthis:\n  S' - {Neg (P[App x []/0])} \\<union> {Neg (Forall P)} \\<in> C\n\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {Neg (P[App x []/0])};\n        finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "have \\<open>\\<forall>a \\<in> ?S'. x \\<notin> params a\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>S' - {Neg (P[App x []/0])} \\<union> {Neg (Forall P)}.\n       x \\<notin> params a", "using \\<open>\\<forall>a \\<in> S. x \\<notin> params a\\<close> \\<open>?S' \\<subseteq> S\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>S. x \\<notin> params a\n  S' - {Neg (P[App x []/0])} \\<union> {Neg (Forall P)} \\<subseteq> S\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>S' - {Neg (P[App x []/0])} \\<union> {Neg (Forall P)}.\n       x \\<notin> params a", "by blast"], ["proof (state)\nthis:\n  \\<forall>a\\<in>S' - {Neg (P[App x []/0])} \\<union> {Neg (Forall P)}.\n     x \\<notin> params a\n\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {Neg (P[App x []/0])};\n        finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "ultimately"], ["proof (chain)\npicking this:\n  S' - {Neg (P[App x []/0])} \\<union> {Neg (Forall P)} \\<in> C\n  \\<forall>a\\<in>S' - {Neg (P[App x []/0])} \\<union> {Neg (Forall P)}.\n     x \\<notin> params a", "have \\<open>?S' \\<union> {Neg (P[App x []/0])} \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  S' - {Neg (P[App x []/0])} \\<union> {Neg (Forall P)} \\<in> C\n  \\<forall>a\\<in>S' - {Neg (P[App x []/0])} \\<union> {Neg (Forall P)}.\n     x \\<notin> params a\n\ngoal (1 subgoal):\n 1. S' - {Neg (P[App x []/0])} \\<union> {Neg (Forall P)} \\<union>\n    {Neg (P[App x []/0])}\n    \\<in> C", "using altconc \\<open>\\<forall>a \\<in> S. x \\<notin> params a\\<close>"], ["proof (prove)\nusing this:\n  S' - {Neg (P[App x []/0])} \\<union> {Neg (Forall P)} \\<in> C\n  \\<forall>a\\<in>S' - {Neg (P[App x []/0])} \\<union> {Neg (Forall P)}.\n     x \\<notin> params a\n  alt_consistency C\n  \\<forall>a\\<in>S. x \\<notin> params a\n\ngoal (1 subgoal):\n 1. S' - {Neg (P[App x []/0])} \\<union> {Neg (Forall P)} \\<union>\n    {Neg (P[App x []/0])}\n    \\<in> C", "unfolding alt_consistency_def"], ["proof (prove)\nusing this:\n  S' - {Neg (P[App x []/0])} \\<union> {Neg (Forall P)} \\<in> C\n  \\<forall>a\\<in>S' - {Neg (P[App x []/0])} \\<union> {Neg (Forall P)}.\n     x \\<notin> params a\n  \\<forall>S.\n     S \\<in> C \\<longrightarrow>\n     (\\<forall>p ts.\n         \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)) \\<and>\n     FF \\<notin> S \\<and>\n     Neg TT \\<notin> S \\<and>\n     (\\<forall>Z.\n         Neg (Neg Z) \\<in> S \\<longrightarrow>\n         S \\<union> {Z} \\<in> C) \\<and>\n     (\\<forall>A B.\n         And A B \\<in> S \\<longrightarrow> S \\<union> {A, B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Or A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A, Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Or A B \\<in> S \\<longrightarrow>\n         S \\<union> {A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (And A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Impl A B \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Impl A B) \\<in> S \\<longrightarrow>\n         S \\<union> {A, Neg B} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Forall P \\<in> S \\<longrightarrow>\n         S \\<union> {P[t/0]} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Neg (Exists P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[t/0])} \\<in> C) \\<and>\n     (\\<forall>P x.\n         (\\<forall>a\\<in>S. x \\<notin> params a) \\<longrightarrow>\n         Exists P \\<in> S \\<longrightarrow>\n         S \\<union> {P[App x []/0]} \\<in> C) \\<and>\n     (\\<forall>P x.\n         (\\<forall>a\\<in>S. x \\<notin> params a) \\<longrightarrow>\n         Neg (Forall P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[App x []/0])} \\<in> C)\n  \\<forall>a\\<in>S. x \\<notin> params a\n\ngoal (1 subgoal):\n 1. S' - {Neg (P[App x []/0])} \\<union> {Neg (Forall P)} \\<union>\n    {Neg (P[App x []/0])}\n    \\<in> C", "by simp"], ["proof (state)\nthis:\n  S' - {Neg (P[App x []/0])} \\<union> {Neg (Forall P)} \\<union>\n  {Neg (P[App x []/0])}\n  \\<in> C\n\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<subseteq> S \\<union> {Neg (P[App x []/0])};\n        finite S'\\<rbrakk>\n       \\<Longrightarrow> S' \\<in> C", "then"], ["proof (chain)\npicking this:\n  S' - {Neg (P[App x []/0])} \\<union> {Neg (Forall P)} \\<union>\n  {Neg (P[App x []/0])}\n  \\<in> C", "show \\<open>S' \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  S' - {Neg (P[App x []/0])} \\<union> {Neg (Forall P)} \\<union>\n  {Neg (P[App x []/0])}\n  \\<in> C\n\ngoal (1 subgoal):\n 1. S' \\<in> C", "using sc"], ["proof (prove)\nusing this:\n  S' - {Neg (P[App x []/0])} \\<union> {Neg (Forall P)} \\<union>\n  {Neg (P[App x []/0])}\n  \\<in> C\n  \\<forall>S' x.\n     S' \\<union> x \\<in> C \\<longrightarrow>\n     (\\<forall>S\\<subseteq>S' \\<union> x. S \\<in> C)\n\ngoal (1 subgoal):\n 1. S' \\<in> C", "by blast"], ["proof (state)\nthis:\n  S' \\<in> C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  S \\<union> {Neg (P[App x []/0])} \\<in> mk_finite_char C\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  \\<lbrakk>Neg (Forall ?P2) \\<in> S;\n   \\<forall>a\\<in>S. ?x2 \\<notin> params a\\<rbrakk>\n  \\<Longrightarrow> S \\<union> {Neg (?P2[App ?x2 []/0])}\n                    \\<in> mk_finite_char C\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem finite_char: \\<open>finite_char (mk_finite_char C)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_char (mk_finite_char C)", "unfolding finite_char_def mk_finite_char_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>S.\n       (S \\<in> {S. \\<forall>S'\\<subseteq>S.\n                       finite S' \\<longrightarrow> S' \\<in> C}) =\n       (\\<forall>S'.\n           finite S' \\<longrightarrow>\n           S' \\<subseteq> S \\<longrightarrow>\n           S' \\<in> {S. \\<forall>S'\\<subseteq>S.\n                           finite S' \\<longrightarrow> S' \\<in> C})", "by blast"], ["", "theorem finite_char_closed: \\<open>finite_char C \\<Longrightarrow> subset_closed C\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_char C \\<Longrightarrow> subset_closed C", "unfolding finite_char_def subset_closed_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>S.\n       (S \\<in> C) =\n       (\\<forall>S'.\n           finite S' \\<longrightarrow>\n           S' \\<subseteq> S \\<longrightarrow> S' \\<in> C) \\<Longrightarrow>\n    \\<forall>S'\\<in>C. \\<forall>S\\<subseteq>S'. S \\<in> C", "proof (intro ballI allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S' S.\n       \\<lbrakk>\\<forall>S.\n                   (S \\<in> C) =\n                   (\\<forall>S'.\n                       finite S' \\<longrightarrow>\n                       S' \\<subseteq> S \\<longrightarrow> S' \\<in> C);\n        S' \\<in> C; S \\<subseteq> S'\\<rbrakk>\n       \\<Longrightarrow> S \\<in> C", "fix S S'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S' S.\n       \\<lbrakk>\\<forall>S.\n                   (S \\<in> C) =\n                   (\\<forall>S'.\n                       finite S' \\<longrightarrow>\n                       S' \\<subseteq> S \\<longrightarrow> S' \\<in> C);\n        S' \\<in> C; S \\<subseteq> S'\\<rbrakk>\n       \\<Longrightarrow> S \\<in> C", "assume *: \\<open>\\<forall>S. (S \\<in> C) = (\\<forall>S'. finite S' \\<longrightarrow> S' \\<subseteq> S \\<longrightarrow> S' \\<in> C)\\<close>\n    and \\<open>S' \\<in> C\\<close> and \\<open>S \\<subseteq> S'\\<close>"], ["proof (state)\nthis:\n  \\<forall>S.\n     (S \\<in> C) =\n     (\\<forall>S'.\n         finite S' \\<longrightarrow>\n         S' \\<subseteq> S \\<longrightarrow> S' \\<in> C)\n  S' \\<in> C\n  S \\<subseteq> S'\n\ngoal (1 subgoal):\n 1. \\<And>S' S.\n       \\<lbrakk>\\<forall>S.\n                   (S \\<in> C) =\n                   (\\<forall>S'.\n                       finite S' \\<longrightarrow>\n                       S' \\<subseteq> S \\<longrightarrow> S' \\<in> C);\n        S' \\<in> C; S \\<subseteq> S'\\<rbrakk>\n       \\<Longrightarrow> S \\<in> C", "then"], ["proof (chain)\npicking this:\n  \\<forall>S.\n     (S \\<in> C) =\n     (\\<forall>S'.\n         finite S' \\<longrightarrow>\n         S' \\<subseteq> S \\<longrightarrow> S' \\<in> C)\n  S' \\<in> C\n  S \\<subseteq> S'", "have \\<open>\\<forall>S'. finite S' \\<longrightarrow> S' \\<subseteq> S \\<longrightarrow> S' \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>S.\n     (S \\<in> C) =\n     (\\<forall>S'.\n         finite S' \\<longrightarrow>\n         S' \\<subseteq> S \\<longrightarrow> S' \\<in> C)\n  S' \\<in> C\n  S \\<subseteq> S'\n\ngoal (1 subgoal):\n 1. \\<forall>S'.\n       finite S' \\<longrightarrow>\n       S' \\<subseteq> S \\<longrightarrow> S' \\<in> C", "by blast"], ["proof (state)\nthis:\n  \\<forall>S'.\n     finite S' \\<longrightarrow>\n     S' \\<subseteq> S \\<longrightarrow> S' \\<in> C\n\ngoal (1 subgoal):\n 1. \\<And>S' S.\n       \\<lbrakk>\\<forall>S.\n                   (S \\<in> C) =\n                   (\\<forall>S'.\n                       finite S' \\<longrightarrow>\n                       S' \\<subseteq> S \\<longrightarrow> S' \\<in> C);\n        S' \\<in> C; S \\<subseteq> S'\\<rbrakk>\n       \\<Longrightarrow> S \\<in> C", "then"], ["proof (chain)\npicking this:\n  \\<forall>S'.\n     finite S' \\<longrightarrow>\n     S' \\<subseteq> S \\<longrightarrow> S' \\<in> C", "show \\<open>S \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>S'.\n     finite S' \\<longrightarrow>\n     S' \\<subseteq> S \\<longrightarrow> S' \\<in> C\n\ngoal (1 subgoal):\n 1. S \\<in> C", "using *"], ["proof (prove)\nusing this:\n  \\<forall>S'.\n     finite S' \\<longrightarrow>\n     S' \\<subseteq> S \\<longrightarrow> S' \\<in> C\n  \\<forall>S.\n     (S \\<in> C) =\n     (\\<forall>S'.\n         finite S' \\<longrightarrow>\n         S' \\<subseteq> S \\<longrightarrow> S' \\<in> C)\n\ngoal (1 subgoal):\n 1. S \\<in> C", "by blast"], ["proof (state)\nthis:\n  S \\<in> C\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem finite_char_subset: \\<open>subset_closed C \\<Longrightarrow> C \\<subseteq> mk_finite_char C\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. subset_closed C \\<Longrightarrow> C \\<subseteq> mk_finite_char C", "unfolding mk_finite_char_def subset_closed_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>S'\\<in>C. \\<forall>S\\<subseteq>S'. S \\<in> C \\<Longrightarrow>\n    C \\<subseteq> {S. \\<forall>S'\\<subseteq>S.\n                         finite S' \\<longrightarrow> S' \\<in> C}", "by blast"], ["", "subsection \\<open>Enumerating datatypes\\<close>"], ["", "text \\<open>\n\\label{sec:enumeration}\nAs has already been mentioned earlier, the proof of the model existence theorem\nrelies on the fact that the set of formulae is enumerable. Using the infrastructure\nfor datatypes, the types @{type term} and @{type form} can automatically be shown to\nbe a member of the @{class countable} type class:\n\\<close>"], ["", "instance \\<open>term\\<close> :: (countable) countable"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a FOL_Fitting.term, countable_class)", "by countable_datatype"], ["", "instance form :: (countable, countable) countable"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) form, countable_class)", "by countable_datatype"], ["", "subsection \\<open>Extension to maximal consistent sets\\<close>"], ["", "text \\<open>\n\\label{sec:extend}\nGiven a set \\<open>C\\<close> of finite character, we show that\nthe least upper bound of a chain of sets that are elements\nof \\<open>C\\<close> is again an element of \\<open>C\\<close>.\n\\<close>"], ["", "definition is_chain :: \\<open>(nat \\<Rightarrow> 'a set) \\<Rightarrow> bool\\<close> where\n  \\<open>is_chain f = (\\<forall>n. f n \\<subseteq> f (Suc n))\\<close>"], ["", "theorem is_chainD: \\<open>is_chain f \\<Longrightarrow> x \\<in> f m \\<Longrightarrow> x \\<in> f (m + n)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_chain f; x \\<in> f m\\<rbrakk>\n    \\<Longrightarrow> x \\<in> f (m + n)", "by (induct n) (auto simp: is_chain_def)"], ["", "theorem is_chainD':\n  assumes \\<open>is_chain f\\<close> and \\<open>x \\<in> f m\\<close> and \\<open>m \\<le> k\\<close>\n  shows \\<open>x \\<in> f k\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> f k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> f k", "have \\<open>\\<exists>n. k = m + n\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n. k = m + n", "using \\<open>m \\<le> k\\<close>"], ["proof (prove)\nusing this:\n  m \\<le> k\n\ngoal (1 subgoal):\n 1. \\<exists>n. k = m + n", "by (simp add: le_iff_add)"], ["proof (state)\nthis:\n  \\<exists>n. k = m + n\n\ngoal (1 subgoal):\n 1. x \\<in> f k", "then"], ["proof (chain)\npicking this:\n  \\<exists>n. k = m + n", "obtain n where \\<open>k = m + n\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>n. k = m + n\n\ngoal (1 subgoal):\n 1. (\\<And>n. k = m + n \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  k = m + n\n\ngoal (1 subgoal):\n 1. x \\<in> f k", "then"], ["proof (chain)\npicking this:\n  k = m + n", "show \\<open>x \\<in> f k\\<close>"], ["proof (prove)\nusing this:\n  k = m + n\n\ngoal (1 subgoal):\n 1. x \\<in> f k", "using \\<open>is_chain f\\<close> \\<open>x \\<in> f m\\<close>"], ["proof (prove)\nusing this:\n  k = m + n\n  is_chain f\n  x \\<in> f m\n\ngoal (1 subgoal):\n 1. x \\<in> f k", "by (simp add: is_chainD)"], ["proof (state)\nthis:\n  x \\<in> f k\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem chain_index:\n  assumes ch: \\<open>is_chain f\\<close> and fin: \\<open>finite F\\<close>\n  shows \\<open>F \\<subseteq> (\\<Union>n. f n) \\<Longrightarrow> \\<exists>n. F \\<subseteq> f n\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. F \\<subseteq> \\<Union> (range f) \\<Longrightarrow>\n    \\<exists>n. F \\<subseteq> f n", "using fin"], ["proof (prove)\nusing this:\n  finite F\n\ngoal (1 subgoal):\n 1. F \\<subseteq> \\<Union> (range f) \\<Longrightarrow>\n    \\<exists>n. F \\<subseteq> f n", "proof (induct rule: finite_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. {} \\<subseteq> \\<Union> (range f) \\<Longrightarrow>\n    \\<exists>n. {} \\<subseteq> f n\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> \\<Union> (range f) \\<Longrightarrow>\n        \\<exists>n. F \\<subseteq> f n;\n        insert x F \\<subseteq> \\<Union> (range f)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. insert x F \\<subseteq> f n", "case empty"], ["proof (state)\nthis:\n  {} \\<subseteq> \\<Union> (range f)\n\ngoal (2 subgoals):\n 1. {} \\<subseteq> \\<Union> (range f) \\<Longrightarrow>\n    \\<exists>n. {} \\<subseteq> f n\n 2. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> \\<Union> (range f) \\<Longrightarrow>\n        \\<exists>n. F \\<subseteq> f n;\n        insert x F \\<subseteq> \\<Union> (range f)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. insert x F \\<subseteq> f n", "then"], ["proof (chain)\npicking this:\n  {} \\<subseteq> \\<Union> (range f)", "show ?case"], ["proof (prove)\nusing this:\n  {} \\<subseteq> \\<Union> (range f)\n\ngoal (1 subgoal):\n 1. \\<exists>n. {} \\<subseteq> f n", "by blast"], ["proof (state)\nthis:\n  \\<exists>n. {} \\<subseteq> f n\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> \\<Union> (range f) \\<Longrightarrow>\n        \\<exists>n. F \\<subseteq> f n;\n        insert x F \\<subseteq> \\<Union> (range f)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. insert x F \\<subseteq> f n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> \\<Union> (range f) \\<Longrightarrow>\n        \\<exists>n. F \\<subseteq> f n;\n        insert x F \\<subseteq> \\<Union> (range f)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. insert x F \\<subseteq> f n", "case (insert x F)"], ["proof (state)\nthis:\n  finite F\n  x \\<notin> F\n  F \\<subseteq> \\<Union> (range f) \\<Longrightarrow>\n  \\<exists>n. F \\<subseteq> f n\n  insert x F \\<subseteq> \\<Union> (range f)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> \\<Union> (range f) \\<Longrightarrow>\n        \\<exists>n. F \\<subseteq> f n;\n        insert x F \\<subseteq> \\<Union> (range f)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. insert x F \\<subseteq> f n", "then"], ["proof (chain)\npicking this:\n  finite F\n  x \\<notin> F\n  F \\<subseteq> \\<Union> (range f) \\<Longrightarrow>\n  \\<exists>n. F \\<subseteq> f n\n  insert x F \\<subseteq> \\<Union> (range f)", "have \\<open>\\<exists>n. F \\<subseteq> f n\\<close> and \\<open>\\<exists>m. x \\<in> f m\\<close> and \\<open>F \\<subseteq> (\\<Union>x. f x)\\<close>"], ["proof (prove)\nusing this:\n  finite F\n  x \\<notin> F\n  F \\<subseteq> \\<Union> (range f) \\<Longrightarrow>\n  \\<exists>n. F \\<subseteq> f n\n  insert x F \\<subseteq> \\<Union> (range f)\n\ngoal (1 subgoal):\n 1. \\<exists>n. F \\<subseteq> f n &&&\n    \\<exists>m. x \\<in> f m &&& F \\<subseteq> \\<Union> (range f)", "using ch"], ["proof (prove)\nusing this:\n  finite F\n  x \\<notin> F\n  F \\<subseteq> \\<Union> (range f) \\<Longrightarrow>\n  \\<exists>n. F \\<subseteq> f n\n  insert x F \\<subseteq> \\<Union> (range f)\n  is_chain f\n\ngoal (1 subgoal):\n 1. \\<exists>n. F \\<subseteq> f n &&&\n    \\<exists>m. x \\<in> f m &&& F \\<subseteq> \\<Union> (range f)", "by simp_all"], ["proof (state)\nthis:\n  \\<exists>n. F \\<subseteq> f n\n  \\<exists>m. x \\<in> f m\n  F \\<subseteq> \\<Union> (range f)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> \\<Union> (range f) \\<Longrightarrow>\n        \\<exists>n. F \\<subseteq> f n;\n        insert x F \\<subseteq> \\<Union> (range f)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. insert x F \\<subseteq> f n", "then"], ["proof (chain)\npicking this:\n  \\<exists>n. F \\<subseteq> f n\n  \\<exists>m. x \\<in> f m\n  F \\<subseteq> \\<Union> (range f)", "obtain n and m where \\<open>F \\<subseteq> f n\\<close> and \\<open>x \\<in> f m\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>n. F \\<subseteq> f n\n  \\<exists>m. x \\<in> f m\n  F \\<subseteq> \\<Union> (range f)\n\ngoal (1 subgoal):\n 1. (\\<And>n m.\n        \\<lbrakk>F \\<subseteq> f n; x \\<in> f m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  F \\<subseteq> f n\n  x \\<in> f m\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> \\<Union> (range f) \\<Longrightarrow>\n        \\<exists>n. F \\<subseteq> f n;\n        insert x F \\<subseteq> \\<Union> (range f)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. insert x F \\<subseteq> f n", "have \\<open>m \\<le> max n m\\<close> and \\<open>n \\<le> max n m\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> max n m &&& n \\<le> max n m", "by simp_all"], ["proof (state)\nthis:\n  m \\<le> max n m\n  n \\<le> max n m\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> \\<Union> (range f) \\<Longrightarrow>\n        \\<exists>n. F \\<subseteq> f n;\n        insert x F \\<subseteq> \\<Union> (range f)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. insert x F \\<subseteq> f n", "have \\<open>x \\<in> f (max n m)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> f (max n m)", "using is_chainD' ch \\<open>x \\<in> f m\\<close> \\<open>m \\<le> max n m\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_chain ?f; ?x \\<in> ?f ?m; ?m \\<le> ?k\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> ?f ?k\n  is_chain f\n  x \\<in> f m\n  m \\<le> max n m\n\ngoal (1 subgoal):\n 1. x \\<in> f (max n m)", "by fast"], ["proof (state)\nthis:\n  x \\<in> f (max n m)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> \\<Union> (range f) \\<Longrightarrow>\n        \\<exists>n. F \\<subseteq> f n;\n        insert x F \\<subseteq> \\<Union> (range f)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. insert x F \\<subseteq> f n", "moreover"], ["proof (state)\nthis:\n  x \\<in> f (max n m)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> \\<Union> (range f) \\<Longrightarrow>\n        \\<exists>n. F \\<subseteq> f n;\n        insert x F \\<subseteq> \\<Union> (range f)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. insert x F \\<subseteq> f n", "have \\<open>F \\<subseteq> f (max n m)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. F \\<subseteq> f (max n m)", "using is_chainD' ch \\<open>F \\<subseteq> f n\\<close> \\<open>n \\<le> max n m\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_chain ?f; ?x \\<in> ?f ?m; ?m \\<le> ?k\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> ?f ?k\n  is_chain f\n  F \\<subseteq> f n\n  n \\<le> max n m\n\ngoal (1 subgoal):\n 1. F \\<subseteq> f (max n m)", "by fast"], ["proof (state)\nthis:\n  F \\<subseteq> f (max n m)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> \\<Union> (range f) \\<Longrightarrow>\n        \\<exists>n. F \\<subseteq> f n;\n        insert x F \\<subseteq> \\<Union> (range f)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. insert x F \\<subseteq> f n", "moreover"], ["proof (state)\nthis:\n  F \\<subseteq> f (max n m)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> \\<Union> (range f) \\<Longrightarrow>\n        \\<exists>n. F \\<subseteq> f n;\n        insert x F \\<subseteq> \\<Union> (range f)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. insert x F \\<subseteq> f n", "have \\<open>x \\<in> f (max n m) \\<and> F \\<subseteq> f (max n m)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> f (max n m) \\<and> F \\<subseteq> f (max n m)", "using calculation"], ["proof (prove)\nusing this:\n  x \\<in> f (max n m)\n  F \\<subseteq> f (max n m)\n\ngoal (1 subgoal):\n 1. x \\<in> f (max n m) \\<and> F \\<subseteq> f (max n m)", "by blast"], ["proof (state)\nthis:\n  x \\<in> f (max n m) \\<and> F \\<subseteq> f (max n m)\n\ngoal (1 subgoal):\n 1. \\<And>x F.\n       \\<lbrakk>finite F; x \\<notin> F;\n        F \\<subseteq> \\<Union> (range f) \\<Longrightarrow>\n        \\<exists>n. F \\<subseteq> f n;\n        insert x F \\<subseteq> \\<Union> (range f)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. insert x F \\<subseteq> f n", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> f (max n m)\n  F \\<subseteq> f (max n m)\n  x \\<in> f (max n m) \\<and> F \\<subseteq> f (max n m)", "show ?case"], ["proof (prove)\nusing this:\n  x \\<in> f (max n m)\n  F \\<subseteq> f (max n m)\n  x \\<in> f (max n m) \\<and> F \\<subseteq> f (max n m)\n\ngoal (1 subgoal):\n 1. \\<exists>n. insert x F \\<subseteq> f n", "by blast"], ["proof (state)\nthis:\n  \\<exists>n. insert x F \\<subseteq> f n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma chain_union_closed':\n  assumes \\<open>is_chain f\\<close> and \\<open>(\\<forall>n. f n \\<in> C)\\<close> and \\<open>\\<forall>S' \\<in> C. \\<forall>S \\<subseteq> S'. S \\<in> C\\<close>\n    and \\<open>finite S'\\<close> and \\<open>S' \\<subseteq> (\\<Union>n. f n)\\<close>\n  shows \\<open>S' \\<in> C\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. S' \\<in> C", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. S' \\<in> C", "note \\<open>finite S'\\<close> and \\<open>S' \\<subseteq> (\\<Union>n. f n)\\<close>"], ["proof (state)\nthis:\n  finite S'\n  S' \\<subseteq> \\<Union> (range f)\n\ngoal (1 subgoal):\n 1. S' \\<in> C", "then"], ["proof (chain)\npicking this:\n  finite S'\n  S' \\<subseteq> \\<Union> (range f)", "obtain n where \\<open>S' \\<subseteq> f n\\<close>"], ["proof (prove)\nusing this:\n  finite S'\n  S' \\<subseteq> \\<Union> (range f)\n\ngoal (1 subgoal):\n 1. (\\<And>n. S' \\<subseteq> f n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using chain_index \\<open>is_chain f\\<close>"], ["proof (prove)\nusing this:\n  finite S'\n  S' \\<subseteq> \\<Union> (range f)\n  \\<lbrakk>is_chain ?f; finite ?F;\n   ?F \\<subseteq> \\<Union> (range ?f)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>n. ?F \\<subseteq> ?f n\n  is_chain f\n\ngoal (1 subgoal):\n 1. (\\<And>n. S' \\<subseteq> f n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  S' \\<subseteq> f n\n\ngoal (1 subgoal):\n 1. S' \\<in> C", "moreover"], ["proof (state)\nthis:\n  S' \\<subseteq> f n\n\ngoal (1 subgoal):\n 1. S' \\<in> C", "have \\<open>f n \\<in> C\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. f n \\<in> C", "using \\<open>\\<forall>n. f n \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>n. f n \\<in> C\n\ngoal (1 subgoal):\n 1. f n \\<in> C", "by blast"], ["proof (state)\nthis:\n  f n \\<in> C\n\ngoal (1 subgoal):\n 1. S' \\<in> C", "ultimately"], ["proof (chain)\npicking this:\n  S' \\<subseteq> f n\n  f n \\<in> C", "show \\<open>S' \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  S' \\<subseteq> f n\n  f n \\<in> C\n\ngoal (1 subgoal):\n 1. S' \\<in> C", "using \\<open>\\<forall>S' \\<in> C. \\<forall>S \\<subseteq> S'. S \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  S' \\<subseteq> f n\n  f n \\<in> C\n  \\<forall>S'\\<in>C. \\<forall>S\\<subseteq>S'. S \\<in> C\n\ngoal (1 subgoal):\n 1. S' \\<in> C", "by blast"], ["proof (state)\nthis:\n  S' \\<in> C\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem chain_union_closed:\n  assumes \\<open>finite_char C\\<close> and \\<open>is_chain f\\<close> and \\<open>\\<forall>n. f n \\<in> C\\<close>\n  shows \\<open>(\\<Union>n. f n) \\<in> C\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (range f) \\<in> C", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Union> (range f) \\<in> C", "have \\<open>subset_closed C\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. subset_closed C", "using finite_char_closed \\<open>finite_char C\\<close>"], ["proof (prove)\nusing this:\n  finite_char ?C \\<Longrightarrow> subset_closed ?C\n  finite_char C\n\ngoal (1 subgoal):\n 1. subset_closed C", "by blast"], ["proof (state)\nthis:\n  subset_closed C\n\ngoal (1 subgoal):\n 1. \\<Union> (range f) \\<in> C", "then"], ["proof (chain)\npicking this:\n  subset_closed C", "have \\<open>\\<forall>S' \\<in> C. \\<forall>S \\<subseteq> S'. S \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  subset_closed C\n\ngoal (1 subgoal):\n 1. \\<forall>S'\\<in>C. \\<forall>S\\<subseteq>S'. S \\<in> C", "using subset_closed_def"], ["proof (prove)\nusing this:\n  subset_closed C\n  subset_closed ?C =\n  (\\<forall>S'\\<in>?C. \\<forall>S\\<subseteq>S'. S \\<in> ?C)\n\ngoal (1 subgoal):\n 1. \\<forall>S'\\<in>C. \\<forall>S\\<subseteq>S'. S \\<in> C", "by blast"], ["proof (state)\nthis:\n  \\<forall>S'\\<in>C. \\<forall>S\\<subseteq>S'. S \\<in> C\n\ngoal (1 subgoal):\n 1. \\<Union> (range f) \\<in> C", "then"], ["proof (chain)\npicking this:\n  \\<forall>S'\\<in>C. \\<forall>S\\<subseteq>S'. S \\<in> C", "have \\<open>\\<forall>S'. finite S' \\<longrightarrow> S' \\<subseteq> (\\<Union>n. f n) \\<longrightarrow> S' \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>S'\\<in>C. \\<forall>S\\<subseteq>S'. S \\<in> C\n\ngoal (1 subgoal):\n 1. \\<forall>S'.\n       finite S' \\<longrightarrow>\n       S' \\<subseteq> \\<Union> (range f) \\<longrightarrow> S' \\<in> C", "using chain_union_closed' assms"], ["proof (prove)\nusing this:\n  \\<forall>S'\\<in>C. \\<forall>S\\<subseteq>S'. S \\<in> C\n  \\<lbrakk>is_chain ?f; \\<forall>n. ?f n \\<in> ?C;\n   \\<forall>S'\\<in>?C. \\<forall>S\\<subseteq>S'. S \\<in> ?C; finite ?S';\n   ?S' \\<subseteq> \\<Union> (range ?f)\\<rbrakk>\n  \\<Longrightarrow> ?S' \\<in> ?C\n  finite_char C\n  is_chain f\n  \\<forall>n. f n \\<in> C\n\ngoal (1 subgoal):\n 1. \\<forall>S'.\n       finite S' \\<longrightarrow>\n       S' \\<subseteq> \\<Union> (range f) \\<longrightarrow> S' \\<in> C", "by blast"], ["proof (state)\nthis:\n  \\<forall>S'.\n     finite S' \\<longrightarrow>\n     S' \\<subseteq> \\<Union> (range f) \\<longrightarrow> S' \\<in> C\n\ngoal (1 subgoal):\n 1. \\<Union> (range f) \\<in> C", "moreover"], ["proof (state)\nthis:\n  \\<forall>S'.\n     finite S' \\<longrightarrow>\n     S' \\<subseteq> \\<Union> (range f) \\<longrightarrow> S' \\<in> C\n\ngoal (1 subgoal):\n 1. \\<Union> (range f) \\<in> C", "have \\<open>((\\<Union>n. f n) \\<in> C) = (\\<forall>S'. finite S' \\<longrightarrow> S' \\<subseteq> (\\<Union>n. f n) \\<longrightarrow> S' \\<in> C)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union> (range f) \\<in> C) =\n    (\\<forall>S'.\n        finite S' \\<longrightarrow>\n        S' \\<subseteq> \\<Union> (range f) \\<longrightarrow> S' \\<in> C)", "using \\<open>finite_char C\\<close>"], ["proof (prove)\nusing this:\n  finite_char C\n\ngoal (1 subgoal):\n 1. (\\<Union> (range f) \\<in> C) =\n    (\\<forall>S'.\n        finite S' \\<longrightarrow>\n        S' \\<subseteq> \\<Union> (range f) \\<longrightarrow> S' \\<in> C)", "unfolding finite_char_def"], ["proof (prove)\nusing this:\n  \\<forall>S.\n     (S \\<in> C) =\n     (\\<forall>S'.\n         finite S' \\<longrightarrow>\n         S' \\<subseteq> S \\<longrightarrow> S' \\<in> C)\n\ngoal (1 subgoal):\n 1. (\\<Union> (range f) \\<in> C) =\n    (\\<forall>S'.\n        finite S' \\<longrightarrow>\n        S' \\<subseteq> \\<Union> (range f) \\<longrightarrow> S' \\<in> C)", "by blast"], ["proof (state)\nthis:\n  (\\<Union> (range f) \\<in> C) =\n  (\\<forall>S'.\n      finite S' \\<longrightarrow>\n      S' \\<subseteq> \\<Union> (range f) \\<longrightarrow> S' \\<in> C)\n\ngoal (1 subgoal):\n 1. \\<Union> (range f) \\<in> C", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>S'.\n     finite S' \\<longrightarrow>\n     S' \\<subseteq> \\<Union> (range f) \\<longrightarrow> S' \\<in> C\n  (\\<Union> (range f) \\<in> C) =\n  (\\<forall>S'.\n      finite S' \\<longrightarrow>\n      S' \\<subseteq> \\<Union> (range f) \\<longrightarrow> S' \\<in> C)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>S'.\n     finite S' \\<longrightarrow>\n     S' \\<subseteq> \\<Union> (range f) \\<longrightarrow> S' \\<in> C\n  (\\<Union> (range f) \\<in> C) =\n  (\\<forall>S'.\n      finite S' \\<longrightarrow>\n      S' \\<subseteq> \\<Union> (range f) \\<longrightarrow> S' \\<in> C)\n\ngoal (1 subgoal):\n 1. \\<Union> (range f) \\<in> C", "by blast"], ["proof (state)\nthis:\n  \\<Union> (range f) \\<in> C\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nWe can now define a function \\<open>Extend\\<close> that extends a consistent\nset to a maximal consistent set. To this end, we first define an auxiliary\nfunction \\<open>extend\\<close> that produces the elements of an ascending chain of\nconsistent sets.\n\\<close>"], ["", "primrec (nonexhaustive) dest_Neg :: \\<open>('a, 'b) form \\<Rightarrow> ('a, 'b) form\\<close> where\n  \\<open>dest_Neg (Neg p) = p\\<close>"], ["", "primrec (nonexhaustive) dest_Forall :: \\<open>('a, 'b) form \\<Rightarrow> ('a, 'b) form\\<close> where\n  \\<open>dest_Forall (Forall p) = p\\<close>"], ["", "primrec (nonexhaustive) dest_Exists :: \\<open>('a, 'b) form \\<Rightarrow> ('a, 'b) form\\<close> where\n  \\<open>dest_Exists (Exists p) = p\\<close>"], ["", "primrec extend :: \\<open>(nat, 'b) form set \\<Rightarrow> (nat, 'b) form set set \\<Rightarrow>\n    (nat \\<Rightarrow> (nat, 'b) form) \\<Rightarrow> nat \\<Rightarrow> (nat, 'b) form set\\<close> where\n  \\<open>extend S C f 0 = S\\<close>\n| \\<open>extend S C f (Suc n) = (if extend S C f n \\<union> {f n} \\<in> C\n     then\n       (if (\\<exists>p. f n = Exists p)\n        then extend S C f n \\<union> {f n} \\<union> {subst (dest_Exists (f n))\n          (App (SOME k. k \\<notin> (\\<Union>p \\<in> extend S C f n \\<union> {f n}. params p)) []) 0}\n        else if (\\<exists>p. f n = Neg (Forall p))\n        then extend S C f n \\<union> {f n} \\<union> {Neg (subst (dest_Forall (dest_Neg (f n)))\n          (App (SOME k. k \\<notin> (\\<Union>p \\<in> extend S C f n \\<union> {f n}. params p)) []) 0)}\n        else extend S C f n \\<union> {f n})\n     else extend S C f n)\\<close>"], ["", "definition Extend :: \\<open>(nat, 'b) form set \\<Rightarrow> (nat, 'b) form set set \\<Rightarrow>\n    (nat \\<Rightarrow> (nat, 'b) form) \\<Rightarrow> (nat, 'b) form set\\<close> where\n  \\<open>Extend S C f = (\\<Union>n. extend S C f n)\\<close>"], ["", "theorem is_chain_extend: \\<open>is_chain (extend S C f)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_chain (extend S C f)", "by (simp add: is_chain_def) blast"], ["", "theorem finite_paramst [simp]: \\<open>finite (paramst (t :: 'a term))\\<close>\n  \\<open>finite (paramsts (ts :: 'a term list))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (paramst t) &&& finite (paramsts ts)", "by (induct t and ts rule: paramst.induct paramsts.induct) (simp_all split: sum.split)"], ["", "theorem finite_params [simp]: \\<open>finite (params p)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (params p)", "by (induct p) simp_all"], ["", "theorem finite_params_extend [simp]:\n  \\<open>infinite (\\<Inter>p \\<in> S. - params p) \\<Longrightarrow> infinite (\\<Inter>p \\<in> extend S C f n. - params p)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite (\\<Inter>p\\<in>S. - params p) \\<Longrightarrow>\n    infinite (\\<Inter>p\\<in>extend S C f n. - params p)", "by (induct n) simp_all"], ["", "lemma infinite_params_available:\n  assumes \\<open>infinite (- (\\<Union>p \\<in> S. params p))\\<close>\n  shows \\<open>\\<exists>x. x \\<notin> (\\<Union>p \\<in> extend S C f n \\<union> {f n}. params p)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<notin> \\<Union> (params ` (extend S C f n \\<union> {f n}))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<notin> \\<Union> (params ` (extend S C f n \\<union> {f n}))", "let ?S' = \\<open>extend S C f n \\<union> {f n}\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<notin> \\<Union> (params ` (extend S C f n \\<union> {f n}))", "have \\<open>infinite (- (\\<Union>x \\<in> ?S'. params x))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite (- \\<Union> (params ` (extend S C f n \\<union> {f n})))", "using assms"], ["proof (prove)\nusing this:\n  infinite (- \\<Union> (params ` S))\n\ngoal (1 subgoal):\n 1. infinite (- \\<Union> (params ` (extend S C f n \\<union> {f n})))", "by simp"], ["proof (state)\nthis:\n  infinite (- \\<Union> (params ` (extend S C f n \\<union> {f n})))\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<notin> \\<Union> (params ` (extend S C f n \\<union> {f n}))", "then"], ["proof (chain)\npicking this:\n  infinite (- \\<Union> (params ` (extend S C f n \\<union> {f n})))", "obtain x where \\<open>x \\<in> - (\\<Union>x \\<in> ?S'. params x)\\<close>"], ["proof (prove)\nusing this:\n  infinite (- \\<Union> (params ` (extend S C f n \\<union> {f n})))\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> - \\<Union>\n                   (params `\n                    (extend S C f n \\<union> {f n})) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using infinite_imp_nonempty"], ["proof (prove)\nusing this:\n  infinite (- \\<Union> (params ` (extend S C f n \\<union> {f n})))\n  infinite ?S \\<Longrightarrow> ?S \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> - \\<Union>\n                   (params `\n                    (extend S C f n \\<union> {f n})) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x \\<in> - \\<Union> (params ` (extend S C f n \\<union> {f n}))\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<notin> \\<Union> (params ` (extend S C f n \\<union> {f n}))", "then"], ["proof (chain)\npicking this:\n  x \\<in> - \\<Union> (params ` (extend S C f n \\<union> {f n}))", "have \\<open>\\<forall>a \\<in> ?S'. x \\<notin> params a\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> - \\<Union> (params ` (extend S C f n \\<union> {f n}))\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>extend S C f n \\<union> {f n}. x \\<notin> params a", "by blast"], ["proof (state)\nthis:\n  \\<forall>a\\<in>extend S C f n \\<union> {f n}. x \\<notin> params a\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<notin> \\<Union> (params ` (extend S C f n \\<union> {f n}))", "then"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>extend S C f n \\<union> {f n}. x \\<notin> params a", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>extend S C f n \\<union> {f n}. x \\<notin> params a\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<notin> \\<Union> (params ` (extend S C f n \\<union> {f n}))", "by blast"], ["proof (state)\nthis:\n  \\<exists>x. x \\<notin> \\<Union> (params ` (extend S C f n \\<union> {f n}))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma extend_in_C_Exists:\n  assumes \\<open>alt_consistency C\\<close>\n    and \\<open>infinite (- (\\<Union>p \\<in> S. params p))\\<close>\n    and \\<open>extend S C f n \\<union> {f n} \\<in> C\\<close> (is \\<open>?S' \\<in> C\\<close>)\n    and \\<open>\\<exists>p. f n = Exists p\\<close>\n  shows \\<open>extend S C f (Suc n) \\<in> C\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. extend S C f (Suc n) \\<in> C", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. extend S C f (Suc n) \\<in> C", "obtain p where *: \\<open>f n = Exists p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p. f n = Exists p \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>\\<exists>p. f n = Exists p\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>p. f n = Exists p\n\ngoal (1 subgoal):\n 1. (\\<And>p. f n = Exists p \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  f n = Exists p\n\ngoal (1 subgoal):\n 1. extend S C f (Suc n) \\<in> C", "have \\<open>\\<exists>x. x \\<notin> (\\<Union>p \\<in> ?S'. params p)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<notin> \\<Union> (params ` (extend S C f n \\<union> {f n}))", "using \\<open>infinite (- (\\<Union>p \\<in> S. params p))\\<close> infinite_params_available"], ["proof (prove)\nusing this:\n  infinite (- \\<Union> (params ` S))\n  infinite (- \\<Union> (params ` ?S)) \\<Longrightarrow>\n  \\<exists>x.\n     x \\<notin> \\<Union> (params ` (extend ?S ?C ?f ?n \\<union> {?f ?n}))\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<notin> \\<Union> (params ` (extend S C f n \\<union> {f n}))", "by blast"], ["proof (state)\nthis:\n  \\<exists>x. x \\<notin> \\<Union> (params ` (extend S C f n \\<union> {f n}))\n\ngoal (1 subgoal):\n 1. extend S C f (Suc n) \\<in> C", "moreover"], ["proof (state)\nthis:\n  \\<exists>x. x \\<notin> \\<Union> (params ` (extend S C f n \\<union> {f n}))\n\ngoal (1 subgoal):\n 1. extend S C f (Suc n) \\<in> C", "have \\<open>Exists p \\<in> ?S'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Exists p \\<in> extend S C f n \\<union> {f n}", "using *"], ["proof (prove)\nusing this:\n  f n = Exists p\n\ngoal (1 subgoal):\n 1. Exists p \\<in> extend S C f n \\<union> {f n}", "by simp"], ["proof (state)\nthis:\n  Exists p \\<in> extend S C f n \\<union> {f n}\n\ngoal (1 subgoal):\n 1. extend S C f (Suc n) \\<in> C", "then"], ["proof (chain)\npicking this:\n  Exists p \\<in> extend S C f n \\<union> {f n}", "have \\<open>\\<forall>x. x \\<notin> (\\<Union>p \\<in> ?S'. params p) \\<longrightarrow> ?S' \\<union> {p[App x []/0]} \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  Exists p \\<in> extend S C f n \\<union> {f n}\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       x \\<notin> \\<Union>\n                   (params `\n                    (extend S C f n \\<union> {f n})) \\<longrightarrow>\n       extend S C f n \\<union> {f n} \\<union> {p[App x []/0]} \\<in> C", "using \\<open>?S' \\<in> C\\<close> \\<open>alt_consistency C\\<close>"], ["proof (prove)\nusing this:\n  Exists p \\<in> extend S C f n \\<union> {f n}\n  extend S C f n \\<union> {f n} \\<in> C\n  alt_consistency C\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       x \\<notin> \\<Union>\n                   (params `\n                    (extend S C f n \\<union> {f n})) \\<longrightarrow>\n       extend S C f n \\<union> {f n} \\<union> {p[App x []/0]} \\<in> C", "unfolding alt_consistency_def"], ["proof (prove)\nusing this:\n  Exists p \\<in> extend S C f n \\<union> {f n}\n  extend S C f n \\<union> {f n} \\<in> C\n  \\<forall>S.\n     S \\<in> C \\<longrightarrow>\n     (\\<forall>p ts.\n         \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)) \\<and>\n     FF \\<notin> S \\<and>\n     Neg TT \\<notin> S \\<and>\n     (\\<forall>Z.\n         Neg (Neg Z) \\<in> S \\<longrightarrow>\n         S \\<union> {Z} \\<in> C) \\<and>\n     (\\<forall>A B.\n         And A B \\<in> S \\<longrightarrow> S \\<union> {A, B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Or A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A, Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Or A B \\<in> S \\<longrightarrow>\n         S \\<union> {A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (And A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Impl A B \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Impl A B) \\<in> S \\<longrightarrow>\n         S \\<union> {A, Neg B} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Forall P \\<in> S \\<longrightarrow>\n         S \\<union> {P[t/0]} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Neg (Exists P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[t/0])} \\<in> C) \\<and>\n     (\\<forall>P x.\n         (\\<forall>a\\<in>S. x \\<notin> params a) \\<longrightarrow>\n         Exists P \\<in> S \\<longrightarrow>\n         S \\<union> {P[App x []/0]} \\<in> C) \\<and>\n     (\\<forall>P x.\n         (\\<forall>a\\<in>S. x \\<notin> params a) \\<longrightarrow>\n         Neg (Forall P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[App x []/0])} \\<in> C)\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       x \\<notin> \\<Union>\n                   (params `\n                    (extend S C f n \\<union> {f n})) \\<longrightarrow>\n       extend S C f n \\<union> {f n} \\<union> {p[App x []/0]} \\<in> C", "by simp"], ["proof (state)\nthis:\n  \\<forall>x.\n     x \\<notin> \\<Union>\n                 (params `\n                  (extend S C f n \\<union> {f n})) \\<longrightarrow>\n     extend S C f n \\<union> {f n} \\<union> {p[App x []/0]} \\<in> C\n\ngoal (1 subgoal):\n 1. extend S C f (Suc n) \\<in> C", "ultimately"], ["proof (chain)\npicking this:\n  \\<exists>x. x \\<notin> \\<Union> (params ` (extend S C f n \\<union> {f n}))\n  \\<forall>x.\n     x \\<notin> \\<Union>\n                 (params `\n                  (extend S C f n \\<union> {f n})) \\<longrightarrow>\n     extend S C f n \\<union> {f n} \\<union> {p[App x []/0]} \\<in> C", "have \\<open>(?S' \\<union> {p[App (SOME k. k \\<notin> (\\<Union>p \\<in> ?S'. params p)) []/0]}) \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>x. x \\<notin> \\<Union> (params ` (extend S C f n \\<union> {f n}))\n  \\<forall>x.\n     x \\<notin> \\<Union>\n                 (params `\n                  (extend S C f n \\<union> {f n})) \\<longrightarrow>\n     extend S C f n \\<union> {f n} \\<union> {p[App x []/0]} \\<in> C\n\ngoal (1 subgoal):\n 1. extend S C f n \\<union> {f n} \\<union>\n    {p[App (SOME k.\n               k \\<notin> \\<Union>\n                           (params ` (extend S C f n \\<union> {f n})))\n        []/0]}\n    \\<in> C", "by (metis (mono_tags, lifting) someI2)"], ["proof (state)\nthis:\n  extend S C f n \\<union> {f n} \\<union>\n  {p[App (SOME k.\n             k \\<notin> \\<Union> (params ` (extend S C f n \\<union> {f n})))\n      []/0]}\n  \\<in> C\n\ngoal (1 subgoal):\n 1. extend S C f (Suc n) \\<in> C", "then"], ["proof (chain)\npicking this:\n  extend S C f n \\<union> {f n} \\<union>\n  {p[App (SOME k.\n             k \\<notin> \\<Union> (params ` (extend S C f n \\<union> {f n})))\n      []/0]}\n  \\<in> C", "show ?thesis"], ["proof (prove)\nusing this:\n  extend S C f n \\<union> {f n} \\<union>\n  {p[App (SOME k.\n             k \\<notin> \\<Union> (params ` (extend S C f n \\<union> {f n})))\n      []/0]}\n  \\<in> C\n\ngoal (1 subgoal):\n 1. extend S C f (Suc n) \\<in> C", "using assms *"], ["proof (prove)\nusing this:\n  extend S C f n \\<union> {f n} \\<union>\n  {p[App (SOME k.\n             k \\<notin> \\<Union> (params ` (extend S C f n \\<union> {f n})))\n      []/0]}\n  \\<in> C\n  alt_consistency C\n  infinite (- \\<Union> (params ` S))\n  extend S C f n \\<union> {f n} \\<in> C\n  \\<exists>p. f n = Exists p\n  f n = Exists p\n\ngoal (1 subgoal):\n 1. extend S C f (Suc n) \\<in> C", "by simp"], ["proof (state)\nthis:\n  extend S C f (Suc n) \\<in> C\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma extend_in_C_Neg_Forall:\n  assumes \\<open>alt_consistency C\\<close>\n    and \\<open>infinite (- (\\<Union>p \\<in> S. params p))\\<close>\n    and \\<open>extend S C f n \\<union> {f n} \\<in> C\\<close> (is \\<open>?S' \\<in> C\\<close>)\n    and \\<open>\\<forall>p. f n \\<noteq> Exists p\\<close>\n    and \\<open>\\<exists>p. f n = Neg (Forall p)\\<close>\n  shows \\<open>extend S C f (Suc n) \\<in> C\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. extend S C f (Suc n) \\<in> C", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. extend S C f (Suc n) \\<in> C", "obtain p where *: \\<open>f n = Neg (Forall p)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p.\n        f n = Neg (Forall p) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>\\<exists>p. f n = Neg (Forall p)\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>p. f n = Neg (Forall p)\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        f n = Neg (Forall p) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  f n = Neg (Forall p)\n\ngoal (1 subgoal):\n 1. extend S C f (Suc n) \\<in> C", "have \\<open>\\<exists>x. x \\<notin> (\\<Union>p \\<in> ?S'. params p)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<notin> \\<Union> (params ` (extend S C f n \\<union> {f n}))", "using \\<open>infinite (- (\\<Union>p \\<in> S. params p))\\<close> infinite_params_available"], ["proof (prove)\nusing this:\n  infinite (- \\<Union> (params ` S))\n  infinite (- \\<Union> (params ` ?S)) \\<Longrightarrow>\n  \\<exists>x.\n     x \\<notin> \\<Union> (params ` (extend ?S ?C ?f ?n \\<union> {?f ?n}))\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<notin> \\<Union> (params ` (extend S C f n \\<union> {f n}))", "by blast"], ["proof (state)\nthis:\n  \\<exists>x. x \\<notin> \\<Union> (params ` (extend S C f n \\<union> {f n}))\n\ngoal (1 subgoal):\n 1. extend S C f (Suc n) \\<in> C", "moreover"], ["proof (state)\nthis:\n  \\<exists>x. x \\<notin> \\<Union> (params ` (extend S C f n \\<union> {f n}))\n\ngoal (1 subgoal):\n 1. extend S C f (Suc n) \\<in> C", "have \\<open>Neg (Forall p) \\<in> ?S'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Neg (Forall p) \\<in> extend S C f n \\<union> {f n}", "using *"], ["proof (prove)\nusing this:\n  f n = Neg (Forall p)\n\ngoal (1 subgoal):\n 1. Neg (Forall p) \\<in> extend S C f n \\<union> {f n}", "by simp"], ["proof (state)\nthis:\n  Neg (Forall p) \\<in> extend S C f n \\<union> {f n}\n\ngoal (1 subgoal):\n 1. extend S C f (Suc n) \\<in> C", "then"], ["proof (chain)\npicking this:\n  Neg (Forall p) \\<in> extend S C f n \\<union> {f n}", "have \\<open>\\<forall>x. x \\<notin> (\\<Union>p \\<in> ?S'. params p) \\<longrightarrow> ?S' \\<union> {Neg (p[App x []/0])} \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  Neg (Forall p) \\<in> extend S C f n \\<union> {f n}\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       x \\<notin> \\<Union>\n                   (params `\n                    (extend S C f n \\<union> {f n})) \\<longrightarrow>\n       extend S C f n \\<union> {f n} \\<union> {Neg (p[App x []/0])} \\<in> C", "using \\<open>?S' \\<in> C\\<close> \\<open>alt_consistency C\\<close>"], ["proof (prove)\nusing this:\n  Neg (Forall p) \\<in> extend S C f n \\<union> {f n}\n  extend S C f n \\<union> {f n} \\<in> C\n  alt_consistency C\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       x \\<notin> \\<Union>\n                   (params `\n                    (extend S C f n \\<union> {f n})) \\<longrightarrow>\n       extend S C f n \\<union> {f n} \\<union> {Neg (p[App x []/0])} \\<in> C", "unfolding alt_consistency_def"], ["proof (prove)\nusing this:\n  Neg (Forall p) \\<in> extend S C f n \\<union> {f n}\n  extend S C f n \\<union> {f n} \\<in> C\n  \\<forall>S.\n     S \\<in> C \\<longrightarrow>\n     (\\<forall>p ts.\n         \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)) \\<and>\n     FF \\<notin> S \\<and>\n     Neg TT \\<notin> S \\<and>\n     (\\<forall>Z.\n         Neg (Neg Z) \\<in> S \\<longrightarrow>\n         S \\<union> {Z} \\<in> C) \\<and>\n     (\\<forall>A B.\n         And A B \\<in> S \\<longrightarrow> S \\<union> {A, B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Or A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A, Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Or A B \\<in> S \\<longrightarrow>\n         S \\<union> {A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (And A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Impl A B \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Impl A B) \\<in> S \\<longrightarrow>\n         S \\<union> {A, Neg B} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Forall P \\<in> S \\<longrightarrow>\n         S \\<union> {P[t/0]} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Neg (Exists P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[t/0])} \\<in> C) \\<and>\n     (\\<forall>P x.\n         (\\<forall>a\\<in>S. x \\<notin> params a) \\<longrightarrow>\n         Exists P \\<in> S \\<longrightarrow>\n         S \\<union> {P[App x []/0]} \\<in> C) \\<and>\n     (\\<forall>P x.\n         (\\<forall>a\\<in>S. x \\<notin> params a) \\<longrightarrow>\n         Neg (Forall P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[App x []/0])} \\<in> C)\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       x \\<notin> \\<Union>\n                   (params `\n                    (extend S C f n \\<union> {f n})) \\<longrightarrow>\n       extend S C f n \\<union> {f n} \\<union> {Neg (p[App x []/0])} \\<in> C", "by simp"], ["proof (state)\nthis:\n  \\<forall>x.\n     x \\<notin> \\<Union>\n                 (params `\n                  (extend S C f n \\<union> {f n})) \\<longrightarrow>\n     extend S C f n \\<union> {f n} \\<union> {Neg (p[App x []/0])} \\<in> C\n\ngoal (1 subgoal):\n 1. extend S C f (Suc n) \\<in> C", "ultimately"], ["proof (chain)\npicking this:\n  \\<exists>x. x \\<notin> \\<Union> (params ` (extend S C f n \\<union> {f n}))\n  \\<forall>x.\n     x \\<notin> \\<Union>\n                 (params `\n                  (extend S C f n \\<union> {f n})) \\<longrightarrow>\n     extend S C f n \\<union> {f n} \\<union> {Neg (p[App x []/0])} \\<in> C", "have \\<open>(?S' \\<union> {Neg (p[App (SOME k. k \\<notin> (\\<Union>p \\<in> ?S'. params p)) []/0])}) \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>x. x \\<notin> \\<Union> (params ` (extend S C f n \\<union> {f n}))\n  \\<forall>x.\n     x \\<notin> \\<Union>\n                 (params `\n                  (extend S C f n \\<union> {f n})) \\<longrightarrow>\n     extend S C f n \\<union> {f n} \\<union> {Neg (p[App x []/0])} \\<in> C\n\ngoal (1 subgoal):\n 1. extend S C f n \\<union> {f n} \\<union>\n    {Neg (p[App (SOME k.\n                    k \\<notin> \\<Union>\n                                (params ` (extend S C f n \\<union> {f n})))\n             []/0])}\n    \\<in> C", "by (metis (mono_tags, lifting) someI2)"], ["proof (state)\nthis:\n  extend S C f n \\<union> {f n} \\<union>\n  {Neg (p[App (SOME k.\n                  k \\<notin> \\<Union>\n                              (params ` (extend S C f n \\<union> {f n})))\n           []/0])}\n  \\<in> C\n\ngoal (1 subgoal):\n 1. extend S C f (Suc n) \\<in> C", "then"], ["proof (chain)\npicking this:\n  extend S C f n \\<union> {f n} \\<union>\n  {Neg (p[App (SOME k.\n                  k \\<notin> \\<Union>\n                              (params ` (extend S C f n \\<union> {f n})))\n           []/0])}\n  \\<in> C", "show ?thesis"], ["proof (prove)\nusing this:\n  extend S C f n \\<union> {f n} \\<union>\n  {Neg (p[App (SOME k.\n                  k \\<notin> \\<Union>\n                              (params ` (extend S C f n \\<union> {f n})))\n           []/0])}\n  \\<in> C\n\ngoal (1 subgoal):\n 1. extend S C f (Suc n) \\<in> C", "using assms *"], ["proof (prove)\nusing this:\n  extend S C f n \\<union> {f n} \\<union>\n  {Neg (p[App (SOME k.\n                  k \\<notin> \\<Union>\n                              (params ` (extend S C f n \\<union> {f n})))\n           []/0])}\n  \\<in> C\n  alt_consistency C\n  infinite (- \\<Union> (params ` S))\n  extend S C f n \\<union> {f n} \\<in> C\n  \\<forall>p. f n \\<noteq> Exists p\n  \\<exists>p. f n = Neg (Forall p)\n  f n = Neg (Forall p)\n\ngoal (1 subgoal):\n 1. extend S C f (Suc n) \\<in> C", "by simp"], ["proof (state)\nthis:\n  extend S C f (Suc n) \\<in> C\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma extend_in_C_no_delta:\n  assumes \\<open>extend S C f n \\<union> {f n} \\<in> C\\<close>\n    and \\<open>\\<forall>p. f n \\<noteq> Exists p\\<close>\n    and \\<open>\\<forall>p. f n \\<noteq> Neg (Forall p)\\<close>\n  shows \\<open>extend S C f (Suc n) \\<in> C\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. extend S C f (Suc n) \\<in> C", "using assms"], ["proof (prove)\nusing this:\n  extend S C f n \\<union> {f n} \\<in> C\n  \\<forall>p. f n \\<noteq> Exists p\n  \\<forall>p. f n \\<noteq> Neg (Forall p)\n\ngoal (1 subgoal):\n 1. extend S C f (Suc n) \\<in> C", "by simp"], ["", "lemma extend_in_C_stop:\n  assumes \\<open>extend S C f n \\<in> C\\<close>\n    and \\<open>extend S C f n \\<union> {f n} \\<notin> C\\<close>\n  shows \\<open>extend S C f (Suc n) \\<in> C\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. extend S C f (Suc n) \\<in> C", "using assms"], ["proof (prove)\nusing this:\n  extend S C f n \\<in> C\n  extend S C f n \\<union> {f n} \\<notin> C\n\ngoal (1 subgoal):\n 1. extend S C f (Suc n) \\<in> C", "by simp"], ["", "theorem extend_in_C: \\<open>alt_consistency C \\<Longrightarrow>\n  S \\<in> C \\<Longrightarrow> infinite (- (\\<Union>p \\<in> S. params p)) \\<Longrightarrow> extend S C f n \\<in> C\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>alt_consistency C; S \\<in> C;\n     infinite (- \\<Union> (params ` S))\\<rbrakk>\n    \\<Longrightarrow> extend S C f n \\<in> C", "proof (induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>alt_consistency C; S \\<in> C;\n     infinite (- \\<Union> (params ` S))\\<rbrakk>\n    \\<Longrightarrow> extend S C f 0 \\<in> C\n 2. \\<And>n.\n       \\<lbrakk>\\<lbrakk>alt_consistency C; S \\<in> C;\n                 infinite (- \\<Union> (params ` S))\\<rbrakk>\n                \\<Longrightarrow> extend S C f n \\<in> C;\n        alt_consistency C; S \\<in> C;\n        infinite (- \\<Union> (params ` S))\\<rbrakk>\n       \\<Longrightarrow> extend S C f (Suc n) \\<in> C", "case 0"], ["proof (state)\nthis:\n  alt_consistency C\n  S \\<in> C\n  infinite (- \\<Union> (params ` S))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>alt_consistency C; S \\<in> C;\n     infinite (- \\<Union> (params ` S))\\<rbrakk>\n    \\<Longrightarrow> extend S C f 0 \\<in> C\n 2. \\<And>n.\n       \\<lbrakk>\\<lbrakk>alt_consistency C; S \\<in> C;\n                 infinite (- \\<Union> (params ` S))\\<rbrakk>\n                \\<Longrightarrow> extend S C f n \\<in> C;\n        alt_consistency C; S \\<in> C;\n        infinite (- \\<Union> (params ` S))\\<rbrakk>\n       \\<Longrightarrow> extend S C f (Suc n) \\<in> C", "then"], ["proof (chain)\npicking this:\n  alt_consistency C\n  S \\<in> C\n  infinite (- \\<Union> (params ` S))", "show ?case"], ["proof (prove)\nusing this:\n  alt_consistency C\n  S \\<in> C\n  infinite (- \\<Union> (params ` S))\n\ngoal (1 subgoal):\n 1. extend S C f 0 \\<in> C", "by simp"], ["proof (state)\nthis:\n  extend S C f 0 \\<in> C\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<lbrakk>alt_consistency C; S \\<in> C;\n                 infinite (- \\<Union> (params ` S))\\<rbrakk>\n                \\<Longrightarrow> extend S C f n \\<in> C;\n        alt_consistency C; S \\<in> C;\n        infinite (- \\<Union> (params ` S))\\<rbrakk>\n       \\<Longrightarrow> extend S C f (Suc n) \\<in> C", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<lbrakk>alt_consistency C; S \\<in> C;\n                 infinite (- \\<Union> (params ` S))\\<rbrakk>\n                \\<Longrightarrow> extend S C f n \\<in> C;\n        alt_consistency C; S \\<in> C;\n        infinite (- \\<Union> (params ` S))\\<rbrakk>\n       \\<Longrightarrow> extend S C f (Suc n) \\<in> C", "case (Suc n)"], ["proof (state)\nthis:\n  \\<lbrakk>alt_consistency C; S \\<in> C;\n   infinite (- \\<Union> (params ` S))\\<rbrakk>\n  \\<Longrightarrow> extend S C f n \\<in> C\n  alt_consistency C\n  S \\<in> C\n  infinite (- \\<Union> (params ` S))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<lbrakk>alt_consistency C; S \\<in> C;\n                 infinite (- \\<Union> (params ` S))\\<rbrakk>\n                \\<Longrightarrow> extend S C f n \\<in> C;\n        alt_consistency C; S \\<in> C;\n        infinite (- \\<Union> (params ` S))\\<rbrakk>\n       \\<Longrightarrow> extend S C f (Suc n) \\<in> C", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>alt_consistency C; S \\<in> C;\n   infinite (- \\<Union> (params ` S))\\<rbrakk>\n  \\<Longrightarrow> extend S C f n \\<in> C\n  alt_consistency C\n  S \\<in> C\n  infinite (- \\<Union> (params ` S))", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>alt_consistency C; S \\<in> C;\n   infinite (- \\<Union> (params ` S))\\<rbrakk>\n  \\<Longrightarrow> extend S C f n \\<in> C\n  alt_consistency C\n  S \\<in> C\n  infinite (- \\<Union> (params ` S))\n\ngoal (1 subgoal):\n 1. extend S C f (Suc n) \\<in> C", "using extend_in_C_Exists extend_in_C_Neg_Forall\n      extend_in_C_no_delta extend_in_C_stop"], ["proof (prove)\nusing this:\n  \\<lbrakk>alt_consistency C; S \\<in> C;\n   infinite (- \\<Union> (params ` S))\\<rbrakk>\n  \\<Longrightarrow> extend S C f n \\<in> C\n  alt_consistency C\n  S \\<in> C\n  infinite (- \\<Union> (params ` S))\n  \\<lbrakk>alt_consistency ?C; infinite (- \\<Union> (params ` ?S));\n   extend ?S ?C ?f ?n \\<union> {?f ?n} \\<in> ?C;\n   \\<exists>p. ?f ?n = Exists p\\<rbrakk>\n  \\<Longrightarrow> extend ?S ?C ?f (Suc ?n) \\<in> ?C\n  \\<lbrakk>alt_consistency ?C; infinite (- \\<Union> (params ` ?S));\n   extend ?S ?C ?f ?n \\<union> {?f ?n} \\<in> ?C;\n   \\<forall>p. ?f ?n \\<noteq> Exists p;\n   \\<exists>p. ?f ?n = Neg (Forall p)\\<rbrakk>\n  \\<Longrightarrow> extend ?S ?C ?f (Suc ?n) \\<in> ?C\n  \\<lbrakk>extend ?S ?C ?f ?n \\<union> {?f ?n} \\<in> ?C;\n   \\<forall>p. ?f ?n \\<noteq> Exists p;\n   \\<forall>p. ?f ?n \\<noteq> Neg (Forall p)\\<rbrakk>\n  \\<Longrightarrow> extend ?S ?C ?f (Suc ?n) \\<in> ?C\n  \\<lbrakk>extend ?S ?C ?f ?n \\<in> ?C;\n   extend ?S ?C ?f ?n \\<union> {?f ?n} \\<notin> ?C\\<rbrakk>\n  \\<Longrightarrow> extend ?S ?C ?f (Suc ?n) \\<in> ?C\n\ngoal (1 subgoal):\n 1. extend S C f (Suc n) \\<in> C", "by metis"], ["proof (state)\nthis:\n  extend S C f (Suc n) \\<in> C\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nThe main theorem about \\<open>Extend\\<close> says that if \\<open>C\\<close> is an\nalternative consistency property that is of finite character,\n\\<open>S\\<close> is consistent and \\<open>S\\<close> uses only finitely many\nparameters, then \\<open>Extend S C f\\<close> is again consistent.\n\\<close>"], ["", "theorem Extend_in_C: \\<open>alt_consistency C \\<Longrightarrow> finite_char C \\<Longrightarrow>\n  S \\<in> C \\<Longrightarrow> infinite (- (\\<Union>p \\<in> S. params p)) \\<Longrightarrow> Extend S C f \\<in> C\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>alt_consistency C; finite_char C; S \\<in> C;\n     infinite (- \\<Union> (params ` S))\\<rbrakk>\n    \\<Longrightarrow> Extend S C f \\<in> C", "unfolding Extend_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>alt_consistency C; finite_char C; S \\<in> C;\n     infinite (- \\<Union> (params ` S))\\<rbrakk>\n    \\<Longrightarrow> \\<Union> (range (extend S C f)) \\<in> C", "using chain_union_closed is_chain_extend extend_in_C"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite_char ?C; is_chain ?f; \\<forall>n. ?f n \\<in> ?C\\<rbrakk>\n  \\<Longrightarrow> \\<Union> (range ?f) \\<in> ?C\n  is_chain (extend ?S ?C ?f)\n  \\<lbrakk>alt_consistency ?C; ?S \\<in> ?C;\n   infinite (- \\<Union> (params ` ?S))\\<rbrakk>\n  \\<Longrightarrow> extend ?S ?C ?f ?n \\<in> ?C\n\ngoal (1 subgoal):\n 1. \\<lbrakk>alt_consistency C; finite_char C; S \\<in> C;\n     infinite (- \\<Union> (params ` S))\\<rbrakk>\n    \\<Longrightarrow> \\<Union> (range (extend S C f)) \\<in> C", "by blast"], ["", "theorem Extend_subset: \\<open>S \\<subseteq> Extend S C f\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<subseteq> Extend S C f", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S \\<Longrightarrow> x \\<in> Extend S C f", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S \\<Longrightarrow> x \\<in> Extend S C f", "assume \\<open>x \\<in> S\\<close>"], ["proof (state)\nthis:\n  x \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S \\<Longrightarrow> x \\<in> Extend S C f", "then"], ["proof (chain)\npicking this:\n  x \\<in> S", "have \\<open>x \\<in> extend S C f 0\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> S\n\ngoal (1 subgoal):\n 1. x \\<in> extend S C f 0", "by simp"], ["proof (state)\nthis:\n  x \\<in> extend S C f 0\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S \\<Longrightarrow> x \\<in> Extend S C f", "then"], ["proof (chain)\npicking this:\n  x \\<in> extend S C f 0", "have \\<open>\\<exists>n. x \\<in> extend S C f n\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> extend S C f 0\n\ngoal (1 subgoal):\n 1. \\<exists>n. x \\<in> extend S C f n", "by blast"], ["proof (state)\nthis:\n  \\<exists>n. x \\<in> extend S C f n\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S \\<Longrightarrow> x \\<in> Extend S C f", "then"], ["proof (chain)\npicking this:\n  \\<exists>n. x \\<in> extend S C f n", "show \\<open>x \\<in> Extend S C f\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>n. x \\<in> extend S C f n\n\ngoal (1 subgoal):\n 1. x \\<in> Extend S C f", "by (simp add: Extend_def)"], ["proof (state)\nthis:\n  x \\<in> Extend S C f\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nThe \\<open>Extend\\<close> function yields a maximal set:\n\\<close>"], ["", "definition maximal :: \\<open>'a set \\<Rightarrow> 'a set set \\<Rightarrow> bool\\<close> where\n  \\<open>maximal S C = (\\<forall>S' \\<in> C. S \\<subseteq> S' \\<longrightarrow> S = S')\\<close>"], ["", "theorem extend_maximal:\n  assumes \\<open>\\<forall>y. \\<exists>n. y = f n\\<close>\n    and \\<open>finite_char C\\<close>\n  shows \\<open>maximal (Extend S C f) C\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. maximal (Extend S C f) C", "unfolding maximal_def Extend_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>S'\\<in>C.\n       \\<Union> (range (extend S C f)) \\<subseteq> S' \\<longrightarrow>\n       \\<Union> (range (extend S C f)) = S'", "proof (intro ballI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<in> C;\n        \\<Union> (range (extend S C f)) \\<subseteq> S'\\<rbrakk>\n       \\<Longrightarrow> \\<Union> (range (extend S C f)) = S'", "fix S'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<in> C;\n        \\<Union> (range (extend S C f)) \\<subseteq> S'\\<rbrakk>\n       \\<Longrightarrow> \\<Union> (range (extend S C f)) = S'", "assume \\<open>S' \\<in> C\\<close>\n    and \\<open>(\\<Union>x. extend S C f x) \\<subseteq> S'\\<close>"], ["proof (state)\nthis:\n  S' \\<in> C\n  \\<Union> (range (extend S C f)) \\<subseteq> S'\n\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<in> C;\n        \\<Union> (range (extend S C f)) \\<subseteq> S'\\<rbrakk>\n       \\<Longrightarrow> \\<Union> (range (extend S C f)) = S'", "moreover"], ["proof (state)\nthis:\n  S' \\<in> C\n  \\<Union> (range (extend S C f)) \\<subseteq> S'\n\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<in> C;\n        \\<Union> (range (extend S C f)) \\<subseteq> S'\\<rbrakk>\n       \\<Longrightarrow> \\<Union> (range (extend S C f)) = S'", "have \\<open>S' \\<subseteq> (\\<Union>x. extend S C f x)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. S' \\<subseteq> \\<Union> (range (extend S C f))", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> S' \\<subseteq> \\<Union> (range (extend S C f)) \\<Longrightarrow>\n    False", "assume \\<open>\\<not> S' \\<subseteq> (\\<Union>x. extend S C f x)\\<close>"], ["proof (state)\nthis:\n  \\<not> S' \\<subseteq> \\<Union> (range (extend S C f))\n\ngoal (1 subgoal):\n 1. \\<not> S' \\<subseteq> \\<Union> (range (extend S C f)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> S' \\<subseteq> \\<Union> (range (extend S C f))", "have \\<open>\\<exists>z. z \\<in> S' \\<and> z \\<notin> (\\<Union>x. extend S C f x)\\<close>"], ["proof (prove)\nusing this:\n  \\<not> S' \\<subseteq> \\<Union> (range (extend S C f))\n\ngoal (1 subgoal):\n 1. \\<exists>z. z \\<in> S' \\<and> z \\<notin> \\<Union> (range (extend S C f))", "by blast"], ["proof (state)\nthis:\n  \\<exists>z. z \\<in> S' \\<and> z \\<notin> \\<Union> (range (extend S C f))\n\ngoal (1 subgoal):\n 1. \\<not> S' \\<subseteq> \\<Union> (range (extend S C f)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>z. z \\<in> S' \\<and> z \\<notin> \\<Union> (range (extend S C f))", "obtain z where \\<open>z \\<in> S'\\<close> and *: \\<open>z \\<notin> (\\<Union>x. extend S C f x)\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>z. z \\<in> S' \\<and> z \\<notin> \\<Union> (range (extend S C f))\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>z \\<in> S';\n         z \\<notin> \\<Union> (range (extend S C f))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  z \\<in> S'\n  z \\<notin> \\<Union> (range (extend S C f))\n\ngoal (1 subgoal):\n 1. \\<not> S' \\<subseteq> \\<Union> (range (extend S C f)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  z \\<in> S'\n  z \\<notin> \\<Union> (range (extend S C f))", "obtain n where \\<open>z = f n\\<close>"], ["proof (prove)\nusing this:\n  z \\<in> S'\n  z \\<notin> \\<Union> (range (extend S C f))\n\ngoal (1 subgoal):\n 1. (\\<And>n. z = f n \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using \\<open>\\<forall>y. \\<exists>n. y = f n\\<close>"], ["proof (prove)\nusing this:\n  z \\<in> S'\n  z \\<notin> \\<Union> (range (extend S C f))\n  \\<forall>y. \\<exists>n. y = f n\n\ngoal (1 subgoal):\n 1. (\\<And>n. z = f n \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  z = f n\n\ngoal (1 subgoal):\n 1. \\<not> S' \\<subseteq> \\<Union> (range (extend S C f)) \\<Longrightarrow>\n    False", "from \\<open>(\\<Union>x. extend S C f x) \\<subseteq> S'\\<close> \\<open>z = f n\\<close> \\<open>z \\<in> S'\\<close>"], ["proof (chain)\npicking this:\n  \\<Union> (range (extend S C f)) \\<subseteq> S'\n  z = f n\n  z \\<in> S'", "have \\<open>extend S C f n \\<union> {f n} \\<subseteq> S'\\<close>"], ["proof (prove)\nusing this:\n  \\<Union> (range (extend S C f)) \\<subseteq> S'\n  z = f n\n  z \\<in> S'\n\ngoal (1 subgoal):\n 1. extend S C f n \\<union> {f n} \\<subseteq> S'", "by blast"], ["proof (state)\nthis:\n  extend S C f n \\<union> {f n} \\<subseteq> S'\n\ngoal (1 subgoal):\n 1. \\<not> S' \\<subseteq> \\<Union> (range (extend S C f)) \\<Longrightarrow>\n    False", "from \\<open>finite_char C\\<close>"], ["proof (chain)\npicking this:\n  finite_char C", "have \\<open>subset_closed C\\<close>"], ["proof (prove)\nusing this:\n  finite_char C\n\ngoal (1 subgoal):\n 1. subset_closed C", "using finite_char_closed"], ["proof (prove)\nusing this:\n  finite_char C\n  finite_char ?C \\<Longrightarrow> subset_closed ?C\n\ngoal (1 subgoal):\n 1. subset_closed C", "by blast"], ["proof (state)\nthis:\n  subset_closed C\n\ngoal (1 subgoal):\n 1. \\<not> S' \\<subseteq> \\<Union> (range (extend S C f)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  subset_closed C", "have \\<open>\\<forall>S' \\<in> C. \\<forall>S \\<subseteq> S'. S \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  subset_closed C\n\ngoal (1 subgoal):\n 1. \\<forall>S'\\<in>C. \\<forall>S\\<subseteq>S'. S \\<in> C", "unfolding subset_closed_def"], ["proof (prove)\nusing this:\n  \\<forall>S'\\<in>C. \\<forall>S\\<subseteq>S'. S \\<in> C\n\ngoal (1 subgoal):\n 1. \\<forall>S'\\<in>C. \\<forall>S\\<subseteq>S'. S \\<in> C", "by simp"], ["proof (state)\nthis:\n  \\<forall>S'\\<in>C. \\<forall>S\\<subseteq>S'. S \\<in> C\n\ngoal (1 subgoal):\n 1. \\<not> S' \\<subseteq> \\<Union> (range (extend S C f)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<forall>S'\\<in>C. \\<forall>S\\<subseteq>S'. S \\<in> C", "have \\<open>\\<forall>S \\<subseteq> S'. S \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>S'\\<in>C. \\<forall>S\\<subseteq>S'. S \\<in> C\n\ngoal (1 subgoal):\n 1. \\<forall>S\\<subseteq>S'. S \\<in> C", "using \\<open>S' \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>S'\\<in>C. \\<forall>S\\<subseteq>S'. S \\<in> C\n  S' \\<in> C\n\ngoal (1 subgoal):\n 1. \\<forall>S\\<subseteq>S'. S \\<in> C", "by blast"], ["proof (state)\nthis:\n  \\<forall>S\\<subseteq>S'. S \\<in> C\n\ngoal (1 subgoal):\n 1. \\<not> S' \\<subseteq> \\<Union> (range (extend S C f)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<forall>S\\<subseteq>S'. S \\<in> C", "have \\<open>extend S C f n \\<union> {f n} \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>S\\<subseteq>S'. S \\<in> C\n\ngoal (1 subgoal):\n 1. extend S C f n \\<union> {f n} \\<in> C", "using \\<open>extend S C f n \\<union> {f n} \\<subseteq> S'\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>S\\<subseteq>S'. S \\<in> C\n  extend S C f n \\<union> {f n} \\<subseteq> S'\n\ngoal (1 subgoal):\n 1. extend S C f n \\<union> {f n} \\<in> C", "by blast"], ["proof (state)\nthis:\n  extend S C f n \\<union> {f n} \\<in> C\n\ngoal (1 subgoal):\n 1. \\<not> S' \\<subseteq> \\<Union> (range (extend S C f)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  extend S C f n \\<union> {f n} \\<in> C", "have \\<open>z \\<in> extend S C f (Suc n)\\<close>"], ["proof (prove)\nusing this:\n  extend S C f n \\<union> {f n} \\<in> C\n\ngoal (1 subgoal):\n 1. z \\<in> extend S C f (Suc n)", "using \\<open>z \\<notin> (\\<Union>x. extend S C f x)\\<close> \\<open>z = f n\\<close>"], ["proof (prove)\nusing this:\n  extend S C f n \\<union> {f n} \\<in> C\n  z \\<notin> \\<Union> (range (extend S C f))\n  z = f n\n\ngoal (1 subgoal):\n 1. z \\<in> extend S C f (Suc n)", "by simp"], ["proof (state)\nthis:\n  z \\<in> extend S C f (Suc n)\n\ngoal (1 subgoal):\n 1. \\<not> S' \\<subseteq> \\<Union> (range (extend S C f)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  z \\<in> extend S C f (Suc n)", "show False"], ["proof (prove)\nusing this:\n  z \\<in> extend S C f (Suc n)\n\ngoal (1 subgoal):\n 1. False", "using *"], ["proof (prove)\nusing this:\n  z \\<in> extend S C f (Suc n)\n  z \\<notin> \\<Union> (range (extend S C f))\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  S' \\<subseteq> \\<Union> (range (extend S C f))\n\ngoal (1 subgoal):\n 1. \\<And>S'.\n       \\<lbrakk>S' \\<in> C;\n        \\<Union> (range (extend S C f)) \\<subseteq> S'\\<rbrakk>\n       \\<Longrightarrow> \\<Union> (range (extend S C f)) = S'", "ultimately"], ["proof (chain)\npicking this:\n  S' \\<in> C\n  \\<Union> (range (extend S C f)) \\<subseteq> S'\n  S' \\<subseteq> \\<Union> (range (extend S C f))", "show \\<open>(\\<Union>x. extend S C f x) = S'\\<close>"], ["proof (prove)\nusing this:\n  S' \\<in> C\n  \\<Union> (range (extend S C f)) \\<subseteq> S'\n  S' \\<subseteq> \\<Union> (range (extend S C f))\n\ngoal (1 subgoal):\n 1. \\<Union> (range (extend S C f)) = S'", "by simp"], ["proof (state)\nthis:\n  \\<Union> (range (extend S C f)) = S'\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Hintikka sets and Herbrand models\\<close>"], ["", "text \\<open>\n\\label{sec:hintikka}\nA Hintikka set is defined as follows:\n\\<close>"], ["", "definition hintikka :: \\<open>('a, 'b) form set \\<Rightarrow> bool\\<close> where\n  \\<open>hintikka H =\n     ((\\<forall>p ts. \\<not> (Pred p ts \\<in> H \\<and> Neg (Pred p ts) \\<in> H)) \\<and>\n     FF \\<notin> H \\<and> Neg TT \\<notin> H \\<and>\n     (\\<forall>Z. Neg (Neg Z) \\<in> H \\<longrightarrow> Z \\<in> H) \\<and>\n     (\\<forall>A B. And A B \\<in> H \\<longrightarrow> A \\<in> H \\<and> B \\<in> H) \\<and>\n     (\\<forall>A B. Neg (Or A B) \\<in> H \\<longrightarrow> Neg A \\<in> H \\<and> Neg B \\<in> H) \\<and>\n     (\\<forall>A B. Or A B \\<in> H \\<longrightarrow> A \\<in> H \\<or> B \\<in> H) \\<and>\n     (\\<forall>A B. Neg (And A B) \\<in> H \\<longrightarrow> Neg A \\<in> H \\<or> Neg B \\<in> H) \\<and>\n     (\\<forall>A B. Impl A B \\<in> H \\<longrightarrow> Neg A \\<in> H \\<or> B \\<in> H) \\<and>\n     (\\<forall>A B. Neg (Impl A B) \\<in> H \\<longrightarrow> A \\<in> H \\<and> Neg B \\<in> H) \\<and>\n     (\\<forall>P t. closedt 0 t \\<longrightarrow> Forall P \\<in> H \\<longrightarrow> subst P t 0 \\<in> H) \\<and>\n     (\\<forall>P t. closedt 0 t \\<longrightarrow> Neg (Exists P) \\<in> H \\<longrightarrow> Neg (subst P t 0) \\<in> H) \\<and>\n     (\\<forall>P. Exists P \\<in> H \\<longrightarrow> (\\<exists>t. closedt 0 t \\<and> subst P t 0 \\<in> H)) \\<and>\n     (\\<forall>P. Neg (Forall P) \\<in> H \\<longrightarrow> (\\<exists>t. closedt 0 t \\<and> Neg (subst P t 0) \\<in> H)))\\<close>"], ["", "text \\<open>\nIn Herbrand models, each {\\em closed} term is interpreted by itself.\nWe introduce a new datatype \\<open>hterm\\<close> (``Herbrand terms''), which\nis similar to the datatype \\<open>term\\<close> introduced in \\secref{sec:terms},\nbut without variables. We also define functions for converting between\nclosed terms and Herbrand terms.\n\\<close>"], ["", "datatype 'a hterm = HApp 'a \\<open>'a hterm list\\<close>"], ["", "primrec\n  term_of_hterm :: \\<open>'a hterm \\<Rightarrow> 'a term\\<close> and\n  terms_of_hterms :: \\<open>'a hterm list \\<Rightarrow> 'a term list\\<close> where\n  \\<open>term_of_hterm (HApp a hts) = App a (terms_of_hterms hts)\\<close>\n| \\<open>terms_of_hterms [] = []\\<close>\n| \\<open>terms_of_hterms (ht # hts) = term_of_hterm ht # terms_of_hterms hts\\<close>"], ["", "theorem herbrand_evalt [simp]:\n  \\<open>closedt 0 t \\<Longrightarrow> term_of_hterm (evalt e HApp t) = t\\<close>\n  \\<open>closedts 0 ts \\<Longrightarrow> terms_of_hterms (evalts e HApp ts) = ts\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (closedt 0 t \\<Longrightarrow> term_of_hterm (evalt e HApp t) = t) &&&\n    (closedts 0 ts \\<Longrightarrow>\n     terms_of_hterms (evalts e HApp ts) = ts)", "by (induct t and ts rule: closedt.induct closedts.induct) simp_all"], ["", "theorem herbrand_evalt' [simp]:\n  \\<open>evalt e HApp (term_of_hterm ht) = ht\\<close>\n  \\<open>evalts e HApp (terms_of_hterms hts) = hts\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. evalt e HApp (term_of_hterm ht) = ht &&&\n    evalts e HApp (terms_of_hterms hts) = hts", "by (induct ht and hts rule: term_of_hterm.induct terms_of_hterms.induct) simp_all"], ["", "theorem closed_hterm [simp]:\n  \\<open>closedt 0 (term_of_hterm (ht::'a hterm))\\<close>\n  \\<open>closedts 0 (terms_of_hterms (hts::'a hterm list))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. closedt 0 (term_of_hterm ht) &&& closedts 0 (terms_of_hterms hts)", "by (induct ht and hts rule: term_of_hterm.induct terms_of_hterms.induct) simp_all"], ["", "text \\<open>\nWe can prove that Hintikka sets are satisfiable in Herbrand models.\nNote that this theorem cannot be proved by a simple structural induction\n(as claimed in Fitting's book), since a parameter substitution has\nto be applied in the cases for quantifiers. However, since parameter\nsubstitution does not change the size of formulae, the theorem can\nbe proved by well-founded induction on the size of the formula \\<open>p\\<close>.\n\\<close>"], ["", "theorem hintikka_model:\n  assumes hin: \\<open>hintikka H\\<close>\n  shows \\<open>(p \\<in> H \\<longrightarrow> closed 0 p \\<longrightarrow>\n    eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) p) \\<and>\n  (Neg p \\<in> H \\<longrightarrow> closed 0 p \\<longrightarrow>\n    eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) (Neg p))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (p \\<in> H \\<longrightarrow>\n     closed 0 p \\<longrightarrow>\n     eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n      p) \\<and>\n    (Neg p \\<in> H \\<longrightarrow>\n     closed 0 p \\<longrightarrow>\n     eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n      (Neg p))", "proof (induct p rule: wf_induct [where r=\\<open>measure size_form\\<close>])"], ["proof (state)\ngoal (2 subgoals):\n 1. wf (measure FOL_Fitting.size_form)\n 2. \\<And>x.\n       \\<forall>y.\n          (y, x) \\<in> measure FOL_Fitting.size_form \\<longrightarrow>\n          (y \\<in> H \\<longrightarrow>\n           closed 0 y \\<longrightarrow>\n           eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n            y) \\<and>\n          (Neg y \\<in> H \\<longrightarrow>\n           closed 0 y \\<longrightarrow>\n           eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n            (Neg y)) \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))", "show \\<open>wf (measure size_form)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (measure FOL_Fitting.size_form)", "by blast"], ["proof (state)\nthis:\n  wf (measure FOL_Fitting.size_form)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y.\n          (y, x) \\<in> measure FOL_Fitting.size_form \\<longrightarrow>\n          (y \\<in> H \\<longrightarrow>\n           closed 0 y \\<longrightarrow>\n           eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n            y) \\<and>\n          (Neg y \\<in> H \\<longrightarrow>\n           closed 0 y \\<longrightarrow>\n           eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n            (Neg y)) \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y.\n          (y, x) \\<in> measure FOL_Fitting.size_form \\<longrightarrow>\n          (y \\<in> H \\<longrightarrow>\n           closed 0 y \\<longrightarrow>\n           eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n            y) \\<and>\n          (Neg y \\<in> H \\<longrightarrow>\n           closed 0 y \\<longrightarrow>\n           eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n            (Neg y)) \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))", "let ?eval = \\<open>eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y.\n          (y, x) \\<in> measure FOL_Fitting.size_form \\<longrightarrow>\n          (y \\<in> H \\<longrightarrow>\n           closed 0 y \\<longrightarrow>\n           eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n            y) \\<and>\n          (Neg y \\<in> H \\<longrightarrow>\n           closed 0 y \\<longrightarrow>\n           eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n            (Neg y)) \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y.\n          (y, x) \\<in> measure FOL_Fitting.size_form \\<longrightarrow>\n          (y \\<in> H \\<longrightarrow>\n           closed 0 y \\<longrightarrow>\n           eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n            y) \\<and>\n          (Neg y \\<in> H \\<longrightarrow>\n           closed 0 y \\<longrightarrow>\n           eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n            (Neg y)) \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))", "assume wf: \\<open>\\<forall>y. (y, x) \\<in> measure size_form \\<longrightarrow>\n                  (y \\<in> H \\<longrightarrow> closed 0 y \\<longrightarrow> ?eval y) \\<and>\n              (Neg y \\<in> H \\<longrightarrow> closed 0 y \\<longrightarrow> ?eval (Neg y))\\<close>"], ["proof (state)\nthis:\n  \\<forall>y.\n     (y, x) \\<in> measure FOL_Fitting.size_form \\<longrightarrow>\n     (y \\<in> H \\<longrightarrow>\n      closed 0 y \\<longrightarrow>\n      eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n       y) \\<and>\n     (Neg y \\<in> H \\<longrightarrow>\n      closed 0 y \\<longrightarrow>\n      eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n       (Neg y))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<forall>y.\n          (y, x) \\<in> measure FOL_Fitting.size_form \\<longrightarrow>\n          (y \\<in> H \\<longrightarrow>\n           closed 0 y \\<longrightarrow>\n           eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n            y) \\<and>\n          (Neg y \\<in> H \\<longrightarrow>\n           closed 0 y \\<longrightarrow>\n           eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n            (Neg y)) \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))", "show \\<open>(x \\<in> H \\<longrightarrow> closed 0 x \\<longrightarrow> ?eval x) \\<and> (Neg x \\<in> H \\<longrightarrow> closed 0 x \\<longrightarrow> ?eval (Neg x))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> H \\<longrightarrow>\n     closed 0 x \\<longrightarrow>\n     eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n      x) \\<and>\n    (Neg x \\<in> H \\<longrightarrow>\n     closed 0 x \\<longrightarrow>\n     eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n      (Neg x))", "proof (cases x)"], ["proof (state)\ngoal (9 subgoals):\n 1. x = FF \\<Longrightarrow>\n    (x \\<in> H \\<longrightarrow>\n     closed 0 x \\<longrightarrow>\n     eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n      x) \\<and>\n    (Neg x \\<in> H \\<longrightarrow>\n     closed 0 x \\<longrightarrow>\n     eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n      (Neg x))\n 2. x = TT \\<Longrightarrow>\n    (x \\<in> H \\<longrightarrow>\n     closed 0 x \\<longrightarrow>\n     eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n      x) \\<and>\n    (Neg x \\<in> H \\<longrightarrow>\n     closed 0 x \\<longrightarrow>\n     eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n      (Neg x))\n 3. \\<And>x31 x32.\n       x = Pred x31 x32 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 4. \\<And>x41 x42.\n       x = And x41 x42 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 5. \\<And>x51 x52.\n       x = Or x51 x52 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 6. \\<And>x61 x62.\n       x = Impl x61 x62 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 7. \\<And>x7.\n       x = Neg x7 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 8. \\<And>x8.\n       x = Forall x8 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 9. \\<And>x9.\n       x = Exists x9 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))", "case FF"], ["proof (state)\nthis:\n  x = FF\n\ngoal (9 subgoals):\n 1. x = FF \\<Longrightarrow>\n    (x \\<in> H \\<longrightarrow>\n     closed 0 x \\<longrightarrow>\n     eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n      x) \\<and>\n    (Neg x \\<in> H \\<longrightarrow>\n     closed 0 x \\<longrightarrow>\n     eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n      (Neg x))\n 2. x = TT \\<Longrightarrow>\n    (x \\<in> H \\<longrightarrow>\n     closed 0 x \\<longrightarrow>\n     eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n      x) \\<and>\n    (Neg x \\<in> H \\<longrightarrow>\n     closed 0 x \\<longrightarrow>\n     eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n      (Neg x))\n 3. \\<And>x31 x32.\n       x = Pred x31 x32 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 4. \\<And>x41 x42.\n       x = And x41 x42 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 5. \\<And>x51 x52.\n       x = Or x51 x52 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 6. \\<And>x61 x62.\n       x = Impl x61 x62 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 7. \\<And>x7.\n       x = Neg x7 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 8. \\<And>x8.\n       x = Forall x8 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 9. \\<And>x9.\n       x = Exists x9 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> H \\<longrightarrow>\n     closed 0 x \\<longrightarrow>\n     eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n      x) \\<and>\n    (Neg x \\<in> H \\<longrightarrow>\n     closed 0 x \\<longrightarrow>\n     eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n      (Neg x))", "proof (intro conjI impI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       x\n 2. \\<lbrakk>Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "assume \\<open>x \\<in> H\\<close>"], ["proof (state)\nthis:\n  x \\<in> H\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       x\n 2. \\<lbrakk>Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "then"], ["proof (chain)\npicking this:\n  x \\<in> H", "show \\<open>?eval x\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> H\n\ngoal (1 subgoal):\n 1. eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) x", "using FF hin"], ["proof (prove)\nusing this:\n  x \\<in> H\n  x = FF\n  hintikka H\n\ngoal (1 subgoal):\n 1. eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) x", "by (simp add: hintikka_def)"], ["proof (state)\nthis:\n  eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "assume \\<open>Neg x \\<in> H\\<close>"], ["proof (state)\nthis:\n  Neg x \\<in> H\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "then"], ["proof (chain)\npicking this:\n  Neg x \\<in> H", "show \\<open>?eval (Neg x)\\<close>"], ["proof (prove)\nusing this:\n  Neg x \\<in> H\n\ngoal (1 subgoal):\n 1. eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) (Neg x)", "using FF"], ["proof (prove)\nusing this:\n  Neg x \\<in> H\n  x = FF\n\ngoal (1 subgoal):\n 1. eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) (Neg x)", "by simp"], ["proof (state)\nthis:\n  eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) (Neg x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (x \\<in> H \\<longrightarrow>\n   closed 0 x \\<longrightarrow>\n   eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n    x) \\<and>\n  (Neg x \\<in> H \\<longrightarrow>\n   closed 0 x \\<longrightarrow>\n   eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) (Neg x))\n\ngoal (8 subgoals):\n 1. x = TT \\<Longrightarrow>\n    (x \\<in> H \\<longrightarrow>\n     closed 0 x \\<longrightarrow>\n     eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n      x) \\<and>\n    (Neg x \\<in> H \\<longrightarrow>\n     closed 0 x \\<longrightarrow>\n     eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n      (Neg x))\n 2. \\<And>x31 x32.\n       x = Pred x31 x32 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 3. \\<And>x41 x42.\n       x = And x41 x42 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 4. \\<And>x51 x52.\n       x = Or x51 x52 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 5. \\<And>x61 x62.\n       x = Impl x61 x62 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 6. \\<And>x7.\n       x = Neg x7 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 7. \\<And>x8.\n       x = Forall x8 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 8. \\<And>x9.\n       x = Exists x9 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. x = TT \\<Longrightarrow>\n    (x \\<in> H \\<longrightarrow>\n     closed 0 x \\<longrightarrow>\n     eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n      x) \\<and>\n    (Neg x \\<in> H \\<longrightarrow>\n     closed 0 x \\<longrightarrow>\n     eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n      (Neg x))\n 2. \\<And>x31 x32.\n       x = Pred x31 x32 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 3. \\<And>x41 x42.\n       x = And x41 x42 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 4. \\<And>x51 x52.\n       x = Or x51 x52 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 5. \\<And>x61 x62.\n       x = Impl x61 x62 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 6. \\<And>x7.\n       x = Neg x7 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 7. \\<And>x8.\n       x = Forall x8 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 8. \\<And>x9.\n       x = Exists x9 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))", "case TT"], ["proof (state)\nthis:\n  x = TT\n\ngoal (8 subgoals):\n 1. x = TT \\<Longrightarrow>\n    (x \\<in> H \\<longrightarrow>\n     closed 0 x \\<longrightarrow>\n     eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n      x) \\<and>\n    (Neg x \\<in> H \\<longrightarrow>\n     closed 0 x \\<longrightarrow>\n     eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n      (Neg x))\n 2. \\<And>x31 x32.\n       x = Pred x31 x32 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 3. \\<And>x41 x42.\n       x = And x41 x42 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 4. \\<And>x51 x52.\n       x = Or x51 x52 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 5. \\<And>x61 x62.\n       x = Impl x61 x62 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 6. \\<And>x7.\n       x = Neg x7 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 7. \\<And>x8.\n       x = Forall x8 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 8. \\<And>x9.\n       x = Exists x9 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> H \\<longrightarrow>\n     closed 0 x \\<longrightarrow>\n     eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n      x) \\<and>\n    (Neg x \\<in> H \\<longrightarrow>\n     closed 0 x \\<longrightarrow>\n     eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n      (Neg x))", "proof (intro conjI impI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       x\n 2. \\<lbrakk>Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "assume \\<open>x \\<in> H\\<close>"], ["proof (state)\nthis:\n  x \\<in> H\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       x\n 2. \\<lbrakk>Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "then"], ["proof (chain)\npicking this:\n  x \\<in> H", "show \\<open>?eval x\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> H\n\ngoal (1 subgoal):\n 1. eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) x", "using TT"], ["proof (prove)\nusing this:\n  x \\<in> H\n  x = TT\n\ngoal (1 subgoal):\n 1. eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) x", "by simp"], ["proof (state)\nthis:\n  eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "assume \\<open>Neg x \\<in> H\\<close>"], ["proof (state)\nthis:\n  Neg x \\<in> H\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "then"], ["proof (chain)\npicking this:\n  Neg x \\<in> H", "show \\<open>?eval (Neg x)\\<close>"], ["proof (prove)\nusing this:\n  Neg x \\<in> H\n\ngoal (1 subgoal):\n 1. eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) (Neg x)", "using TT hin"], ["proof (prove)\nusing this:\n  Neg x \\<in> H\n  x = TT\n  hintikka H\n\ngoal (1 subgoal):\n 1. eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) (Neg x)", "by (simp add: hintikka_def)"], ["proof (state)\nthis:\n  eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) (Neg x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (x \\<in> H \\<longrightarrow>\n   closed 0 x \\<longrightarrow>\n   eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n    x) \\<and>\n  (Neg x \\<in> H \\<longrightarrow>\n   closed 0 x \\<longrightarrow>\n   eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) (Neg x))\n\ngoal (7 subgoals):\n 1. \\<And>x31 x32.\n       x = Pred x31 x32 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 2. \\<And>x41 x42.\n       x = And x41 x42 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 3. \\<And>x51 x52.\n       x = Or x51 x52 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 4. \\<And>x61 x62.\n       x = Impl x61 x62 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 5. \\<And>x7.\n       x = Neg x7 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 6. \\<And>x8.\n       x = Forall x8 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 7. \\<And>x9.\n       x = Exists x9 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>x31 x32.\n       x = Pred x31 x32 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 2. \\<And>x41 x42.\n       x = And x41 x42 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 3. \\<And>x51 x52.\n       x = Or x51 x52 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 4. \\<And>x61 x62.\n       x = Impl x61 x62 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 5. \\<And>x7.\n       x = Neg x7 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 6. \\<And>x8.\n       x = Forall x8 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 7. \\<And>x9.\n       x = Exists x9 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))", "case (Pred p ts)"], ["proof (state)\nthis:\n  x = Pred p ts\n\ngoal (7 subgoals):\n 1. \\<And>x31 x32.\n       x = Pred x31 x32 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 2. \\<And>x41 x42.\n       x = And x41 x42 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 3. \\<And>x51 x52.\n       x = Or x51 x52 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 4. \\<And>x61 x62.\n       x = Impl x61 x62 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 5. \\<And>x7.\n       x = Neg x7 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 6. \\<And>x8.\n       x = Forall x8 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 7. \\<And>x9.\n       x = Exists x9 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> H \\<longrightarrow>\n     closed 0 x \\<longrightarrow>\n     eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n      x) \\<and>\n    (Neg x \\<in> H \\<longrightarrow>\n     closed 0 x \\<longrightarrow>\n     eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n      (Neg x))", "proof (intro conjI impI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       x\n 2. \\<lbrakk>Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "assume \\<open>x \\<in> H\\<close> and \\<open>closed 0 x\\<close>"], ["proof (state)\nthis:\n  x \\<in> H\n  closed 0 x\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       x\n 2. \\<lbrakk>Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "then"], ["proof (chain)\npicking this:\n  x \\<in> H\n  closed 0 x", "show \\<open>?eval x\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> H\n  closed 0 x\n\ngoal (1 subgoal):\n 1. eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) x", "using Pred"], ["proof (prove)\nusing this:\n  x \\<in> H\n  closed 0 x\n  x = Pred p ts\n\ngoal (1 subgoal):\n 1. eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) x", "by simp"], ["proof (state)\nthis:\n  eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "assume \\<open>Neg x \\<in> H\\<close> and \\<open>closed 0 x\\<close>"], ["proof (state)\nthis:\n  Neg x \\<in> H\n  closed 0 x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "then"], ["proof (chain)\npicking this:\n  Neg x \\<in> H\n  closed 0 x", "have \\<open>Neg (Pred p ts) \\<in> H\\<close>"], ["proof (prove)\nusing this:\n  Neg x \\<in> H\n  closed 0 x\n\ngoal (1 subgoal):\n 1. Neg (Pred p ts) \\<in> H", "using Pred"], ["proof (prove)\nusing this:\n  Neg x \\<in> H\n  closed 0 x\n  x = Pred p ts\n\ngoal (1 subgoal):\n 1. Neg (Pred p ts) \\<in> H", "by simp"], ["proof (state)\nthis:\n  Neg (Pred p ts) \\<in> H\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "then"], ["proof (chain)\npicking this:\n  Neg (Pred p ts) \\<in> H", "have \\<open>Pred p ts \\<notin> H\\<close>"], ["proof (prove)\nusing this:\n  Neg (Pred p ts) \\<in> H\n\ngoal (1 subgoal):\n 1. Pred p ts \\<notin> H", "using hin"], ["proof (prove)\nusing this:\n  Neg (Pred p ts) \\<in> H\n  hintikka H\n\ngoal (1 subgoal):\n 1. Pred p ts \\<notin> H", "unfolding hintikka_def"], ["proof (prove)\nusing this:\n  Neg (Pred p ts) \\<in> H\n  (\\<forall>p ts.\n      \\<not> (Pred p ts \\<in> H \\<and> Neg (Pred p ts) \\<in> H)) \\<and>\n  FF \\<notin> H \\<and>\n  Neg TT \\<notin> H \\<and>\n  (\\<forall>Z. Neg (Neg Z) \\<in> H \\<longrightarrow> Z \\<in> H) \\<and>\n  (\\<forall>A B.\n      And A B \\<in> H \\<longrightarrow> A \\<in> H \\<and> B \\<in> H) \\<and>\n  (\\<forall>A B.\n      Neg (Or A B) \\<in> H \\<longrightarrow>\n      Neg A \\<in> H \\<and> Neg B \\<in> H) \\<and>\n  (\\<forall>A B.\n      Or A B \\<in> H \\<longrightarrow> A \\<in> H \\<or> B \\<in> H) \\<and>\n  (\\<forall>A B.\n      Neg (And A B) \\<in> H \\<longrightarrow>\n      Neg A \\<in> H \\<or> Neg B \\<in> H) \\<and>\n  (\\<forall>A B.\n      Impl A B \\<in> H \\<longrightarrow>\n      Neg A \\<in> H \\<or> B \\<in> H) \\<and>\n  (\\<forall>A B.\n      Neg (Impl A B) \\<in> H \\<longrightarrow>\n      A \\<in> H \\<and> Neg B \\<in> H) \\<and>\n  (\\<forall>P t.\n      closedt 0 t \\<longrightarrow>\n      Forall P \\<in> H \\<longrightarrow> P[t/0] \\<in> H) \\<and>\n  (\\<forall>P t.\n      closedt 0 t \\<longrightarrow>\n      Neg (Exists P) \\<in> H \\<longrightarrow> Neg (P[t/0]) \\<in> H) \\<and>\n  (\\<forall>P.\n      Exists P \\<in> H \\<longrightarrow>\n      (\\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> H)) \\<and>\n  (\\<forall>P.\n      Neg (Forall P) \\<in> H \\<longrightarrow>\n      (\\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> H))\n\ngoal (1 subgoal):\n 1. Pred p ts \\<notin> H", "by fast"], ["proof (state)\nthis:\n  Pred p ts \\<notin> H\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "then"], ["proof (chain)\npicking this:\n  Pred p ts \\<notin> H", "show \\<open>?eval (Neg x)\\<close>"], ["proof (prove)\nusing this:\n  Pred p ts \\<notin> H\n\ngoal (1 subgoal):\n 1. eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) (Neg x)", "using Pred \\<open>closed 0 x\\<close>"], ["proof (prove)\nusing this:\n  Pred p ts \\<notin> H\n  x = Pred p ts\n  closed 0 x\n\ngoal (1 subgoal):\n 1. eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) (Neg x)", "by simp"], ["proof (state)\nthis:\n  eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) (Neg x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (x \\<in> H \\<longrightarrow>\n   closed 0 x \\<longrightarrow>\n   eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n    x) \\<and>\n  (Neg x \\<in> H \\<longrightarrow>\n   closed 0 x \\<longrightarrow>\n   eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) (Neg x))\n\ngoal (6 subgoals):\n 1. \\<And>x41 x42.\n       x = And x41 x42 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 2. \\<And>x51 x52.\n       x = Or x51 x52 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 3. \\<And>x61 x62.\n       x = Impl x61 x62 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 4. \\<And>x7.\n       x = Neg x7 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 5. \\<And>x8.\n       x = Forall x8 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 6. \\<And>x9.\n       x = Exists x9 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x41 x42.\n       x = And x41 x42 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 2. \\<And>x51 x52.\n       x = Or x51 x52 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 3. \\<And>x61 x62.\n       x = Impl x61 x62 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 4. \\<And>x7.\n       x = Neg x7 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 5. \\<And>x8.\n       x = Forall x8 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 6. \\<And>x9.\n       x = Exists x9 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))", "case (Neg Z)"], ["proof (state)\nthis:\n  x = Neg Z\n\ngoal (6 subgoals):\n 1. \\<And>x41 x42.\n       x = And x41 x42 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 2. \\<And>x51 x52.\n       x = Or x51 x52 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 3. \\<And>x61 x62.\n       x = Impl x61 x62 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 4. \\<And>x7.\n       x = Neg x7 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 5. \\<And>x8.\n       x = Forall x8 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 6. \\<And>x9.\n       x = Exists x9 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))", "then"], ["proof (chain)\npicking this:\n  x = Neg Z", "show ?thesis"], ["proof (prove)\nusing this:\n  x = Neg Z\n\ngoal (1 subgoal):\n 1. (x \\<in> H \\<longrightarrow>\n     closed 0 x \\<longrightarrow>\n     eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n      x) \\<and>\n    (Neg x \\<in> H \\<longrightarrow>\n     closed 0 x \\<longrightarrow>\n     eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n      (Neg x))", "proof (intro conjI impI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>x = Neg Z; x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       x\n 2. \\<lbrakk>x = Neg Z; Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "assume \\<open>x \\<in> H\\<close> and \\<open>closed 0 x\\<close>"], ["proof (state)\nthis:\n  x \\<in> H\n  closed 0 x\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x = Neg Z; x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       x\n 2. \\<lbrakk>x = Neg Z; Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "then"], ["proof (chain)\npicking this:\n  x \\<in> H\n  closed 0 x", "show \\<open>?eval x\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> H\n  closed 0 x\n\ngoal (1 subgoal):\n 1. eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) x", "using Neg wf"], ["proof (prove)\nusing this:\n  x \\<in> H\n  closed 0 x\n  x = Neg Z\n  \\<forall>y.\n     (y, x) \\<in> measure FOL_Fitting.size_form \\<longrightarrow>\n     (y \\<in> H \\<longrightarrow>\n      closed 0 y \\<longrightarrow>\n      eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n       y) \\<and>\n     (Neg y \\<in> H \\<longrightarrow>\n      closed 0 y \\<longrightarrow>\n      eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n       (Neg y))\n\ngoal (1 subgoal):\n 1. eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) x", "by simp"], ["proof (state)\nthis:\n  eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = Neg Z; Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = Neg Z; Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "assume \\<open>Neg x \\<in> H\\<close>"], ["proof (state)\nthis:\n  Neg x \\<in> H\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = Neg Z; Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "then"], ["proof (chain)\npicking this:\n  Neg x \\<in> H", "have \\<open>Z \\<in> H\\<close>"], ["proof (prove)\nusing this:\n  Neg x \\<in> H\n\ngoal (1 subgoal):\n 1. Z \\<in> H", "using Neg hin"], ["proof (prove)\nusing this:\n  Neg x \\<in> H\n  x = Neg Z\n  hintikka H\n\ngoal (1 subgoal):\n 1. Z \\<in> H", "unfolding hintikka_def"], ["proof (prove)\nusing this:\n  Neg x \\<in> H\n  x = Neg Z\n  (\\<forall>p ts.\n      \\<not> (Pred p ts \\<in> H \\<and> Neg (Pred p ts) \\<in> H)) \\<and>\n  FF \\<notin> H \\<and>\n  Neg TT \\<notin> H \\<and>\n  (\\<forall>Z. Neg (Neg Z) \\<in> H \\<longrightarrow> Z \\<in> H) \\<and>\n  (\\<forall>A B.\n      And A B \\<in> H \\<longrightarrow> A \\<in> H \\<and> B \\<in> H) \\<and>\n  (\\<forall>A B.\n      Neg (Or A B) \\<in> H \\<longrightarrow>\n      Neg A \\<in> H \\<and> Neg B \\<in> H) \\<and>\n  (\\<forall>A B.\n      Or A B \\<in> H \\<longrightarrow> A \\<in> H \\<or> B \\<in> H) \\<and>\n  (\\<forall>A B.\n      Neg (And A B) \\<in> H \\<longrightarrow>\n      Neg A \\<in> H \\<or> Neg B \\<in> H) \\<and>\n  (\\<forall>A B.\n      Impl A B \\<in> H \\<longrightarrow>\n      Neg A \\<in> H \\<or> B \\<in> H) \\<and>\n  (\\<forall>A B.\n      Neg (Impl A B) \\<in> H \\<longrightarrow>\n      A \\<in> H \\<and> Neg B \\<in> H) \\<and>\n  (\\<forall>P t.\n      closedt 0 t \\<longrightarrow>\n      Forall P \\<in> H \\<longrightarrow> P[t/0] \\<in> H) \\<and>\n  (\\<forall>P t.\n      closedt 0 t \\<longrightarrow>\n      Neg (Exists P) \\<in> H \\<longrightarrow> Neg (P[t/0]) \\<in> H) \\<and>\n  (\\<forall>P.\n      Exists P \\<in> H \\<longrightarrow>\n      (\\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> H)) \\<and>\n  (\\<forall>P.\n      Neg (Forall P) \\<in> H \\<longrightarrow>\n      (\\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> H))\n\ngoal (1 subgoal):\n 1. Z \\<in> H", "by blast"], ["proof (state)\nthis:\n  Z \\<in> H\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = Neg Z; Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "moreover"], ["proof (state)\nthis:\n  Z \\<in> H\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = Neg Z; Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "assume \\<open>closed 0 x\\<close>"], ["proof (state)\nthis:\n  closed 0 x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = Neg Z; Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "then"], ["proof (chain)\npicking this:\n  closed 0 x", "have \\<open>closed 0 Z\\<close>"], ["proof (prove)\nusing this:\n  closed 0 x\n\ngoal (1 subgoal):\n 1. closed 0 Z", "using Neg"], ["proof (prove)\nusing this:\n  closed 0 x\n  x = Neg Z\n\ngoal (1 subgoal):\n 1. closed 0 Z", "by simp"], ["proof (state)\nthis:\n  closed 0 Z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = Neg Z; Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "ultimately"], ["proof (chain)\npicking this:\n  Z \\<in> H\n  closed 0 Z", "have \\<open>?eval Z\\<close>"], ["proof (prove)\nusing this:\n  Z \\<in> H\n  closed 0 Z\n\ngoal (1 subgoal):\n 1. eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) Z", "using Neg wf"], ["proof (prove)\nusing this:\n  Z \\<in> H\n  closed 0 Z\n  x = Neg Z\n  \\<forall>y.\n     (y, x) \\<in> measure FOL_Fitting.size_form \\<longrightarrow>\n     (y \\<in> H \\<longrightarrow>\n      closed 0 y \\<longrightarrow>\n      eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n       y) \\<and>\n     (Neg y \\<in> H \\<longrightarrow>\n      closed 0 y \\<longrightarrow>\n      eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n       (Neg y))\n\ngoal (1 subgoal):\n 1. eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) Z", "by simp"], ["proof (state)\nthis:\n  eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) Z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = Neg Z; Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "then"], ["proof (chain)\npicking this:\n  eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) Z", "show \\<open>?eval (Neg x)\\<close>"], ["proof (prove)\nusing this:\n  eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) Z\n\ngoal (1 subgoal):\n 1. eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) (Neg x)", "using Neg"], ["proof (prove)\nusing this:\n  eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) Z\n  x = Neg Z\n\ngoal (1 subgoal):\n 1. eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) (Neg x)", "by simp"], ["proof (state)\nthis:\n  eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) (Neg x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (x \\<in> H \\<longrightarrow>\n   closed 0 x \\<longrightarrow>\n   eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n    x) \\<and>\n  (Neg x \\<in> H \\<longrightarrow>\n   closed 0 x \\<longrightarrow>\n   eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) (Neg x))\n\ngoal (5 subgoals):\n 1. \\<And>x41 x42.\n       x = And x41 x42 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 2. \\<And>x51 x52.\n       x = Or x51 x52 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 3. \\<And>x61 x62.\n       x = Impl x61 x62 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 4. \\<And>x8.\n       x = Forall x8 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 5. \\<And>x9.\n       x = Exists x9 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x41 x42.\n       x = And x41 x42 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 2. \\<And>x51 x52.\n       x = Or x51 x52 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 3. \\<And>x61 x62.\n       x = Impl x61 x62 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 4. \\<And>x8.\n       x = Forall x8 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 5. \\<And>x9.\n       x = Exists x9 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))", "case (And A B)"], ["proof (state)\nthis:\n  x = And A B\n\ngoal (5 subgoals):\n 1. \\<And>x41 x42.\n       x = And x41 x42 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 2. \\<And>x51 x52.\n       x = Or x51 x52 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 3. \\<And>x61 x62.\n       x = Impl x61 x62 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 4. \\<And>x8.\n       x = Forall x8 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 5. \\<And>x9.\n       x = Exists x9 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))", "then"], ["proof (chain)\npicking this:\n  x = And A B", "show ?thesis"], ["proof (prove)\nusing this:\n  x = And A B\n\ngoal (1 subgoal):\n 1. (x \\<in> H \\<longrightarrow>\n     closed 0 x \\<longrightarrow>\n     eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n      x) \\<and>\n    (Neg x \\<in> H \\<longrightarrow>\n     closed 0 x \\<longrightarrow>\n     eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n      (Neg x))", "proof (intro conjI impI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>x = And A B; x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       x\n 2. \\<lbrakk>x = And A B; Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "assume \\<open>x \\<in> H\\<close> and \\<open>closed 0 x\\<close>"], ["proof (state)\nthis:\n  x \\<in> H\n  closed 0 x\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x = And A B; x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       x\n 2. \\<lbrakk>x = And A B; Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "then"], ["proof (chain)\npicking this:\n  x \\<in> H\n  closed 0 x", "have \\<open>And A B \\<in> H\\<close> and \\<open>closed 0 (And A B)\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> H\n  closed 0 x\n\ngoal (1 subgoal):\n 1. And A B \\<in> H &&& closed 0 (And A B)", "using And"], ["proof (prove)\nusing this:\n  x \\<in> H\n  closed 0 x\n  x = And A B\n\ngoal (1 subgoal):\n 1. And A B \\<in> H &&& closed 0 (And A B)", "by simp_all"], ["proof (state)\nthis:\n  And A B \\<in> H\n  closed 0 (And A B)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x = And A B; x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       x\n 2. \\<lbrakk>x = And A B; Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "then"], ["proof (chain)\npicking this:\n  And A B \\<in> H\n  closed 0 (And A B)", "have \\<open>A \\<in> H \\<and> B \\<in> H\\<close>"], ["proof (prove)\nusing this:\n  And A B \\<in> H\n  closed 0 (And A B)\n\ngoal (1 subgoal):\n 1. A \\<in> H \\<and> B \\<in> H", "using And hin"], ["proof (prove)\nusing this:\n  And A B \\<in> H\n  closed 0 (And A B)\n  x = And A B\n  hintikka H\n\ngoal (1 subgoal):\n 1. A \\<in> H \\<and> B \\<in> H", "unfolding hintikka_def"], ["proof (prove)\nusing this:\n  And A B \\<in> H\n  closed 0 (And A B)\n  x = And A B\n  (\\<forall>p ts.\n      \\<not> (Pred p ts \\<in> H \\<and> Neg (Pred p ts) \\<in> H)) \\<and>\n  FF \\<notin> H \\<and>\n  Neg TT \\<notin> H \\<and>\n  (\\<forall>Z. Neg (Neg Z) \\<in> H \\<longrightarrow> Z \\<in> H) \\<and>\n  (\\<forall>A B.\n      And A B \\<in> H \\<longrightarrow> A \\<in> H \\<and> B \\<in> H) \\<and>\n  (\\<forall>A B.\n      Neg (Or A B) \\<in> H \\<longrightarrow>\n      Neg A \\<in> H \\<and> Neg B \\<in> H) \\<and>\n  (\\<forall>A B.\n      Or A B \\<in> H \\<longrightarrow> A \\<in> H \\<or> B \\<in> H) \\<and>\n  (\\<forall>A B.\n      Neg (And A B) \\<in> H \\<longrightarrow>\n      Neg A \\<in> H \\<or> Neg B \\<in> H) \\<and>\n  (\\<forall>A B.\n      Impl A B \\<in> H \\<longrightarrow>\n      Neg A \\<in> H \\<or> B \\<in> H) \\<and>\n  (\\<forall>A B.\n      Neg (Impl A B) \\<in> H \\<longrightarrow>\n      A \\<in> H \\<and> Neg B \\<in> H) \\<and>\n  (\\<forall>P t.\n      closedt 0 t \\<longrightarrow>\n      Forall P \\<in> H \\<longrightarrow> P[t/0] \\<in> H) \\<and>\n  (\\<forall>P t.\n      closedt 0 t \\<longrightarrow>\n      Neg (Exists P) \\<in> H \\<longrightarrow> Neg (P[t/0]) \\<in> H) \\<and>\n  (\\<forall>P.\n      Exists P \\<in> H \\<longrightarrow>\n      (\\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> H)) \\<and>\n  (\\<forall>P.\n      Neg (Forall P) \\<in> H \\<longrightarrow>\n      (\\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> H))\n\ngoal (1 subgoal):\n 1. A \\<in> H \\<and> B \\<in> H", "by blast"], ["proof (state)\nthis:\n  A \\<in> H \\<and> B \\<in> H\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x = And A B; x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       x\n 2. \\<lbrakk>x = And A B; Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "then"], ["proof (chain)\npicking this:\n  A \\<in> H \\<and> B \\<in> H", "show \\<open>?eval x\\<close>"], ["proof (prove)\nusing this:\n  A \\<in> H \\<and> B \\<in> H\n\ngoal (1 subgoal):\n 1. eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) x", "using And wf \\<open>closed 0 (And A B)\\<close>"], ["proof (prove)\nusing this:\n  A \\<in> H \\<and> B \\<in> H\n  x = And A B\n  \\<forall>y.\n     (y, x) \\<in> measure FOL_Fitting.size_form \\<longrightarrow>\n     (y \\<in> H \\<longrightarrow>\n      closed 0 y \\<longrightarrow>\n      eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n       y) \\<and>\n     (Neg y \\<in> H \\<longrightarrow>\n      closed 0 y \\<longrightarrow>\n      eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n       (Neg y))\n  closed 0 (And A B)\n\ngoal (1 subgoal):\n 1. eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) x", "by simp"], ["proof (state)\nthis:\n  eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = And A B; Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = And A B; Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "assume \\<open>Neg x \\<in> H\\<close> and \\<open>closed 0 x\\<close>"], ["proof (state)\nthis:\n  Neg x \\<in> H\n  closed 0 x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = And A B; Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "then"], ["proof (chain)\npicking this:\n  Neg x \\<in> H\n  closed 0 x", "have \\<open>Neg (And A B) \\<in> H\\<close> and \\<open>closed 0 (And A B)\\<close>"], ["proof (prove)\nusing this:\n  Neg x \\<in> H\n  closed 0 x\n\ngoal (1 subgoal):\n 1. Neg (And A B) \\<in> H &&& closed 0 (And A B)", "using And"], ["proof (prove)\nusing this:\n  Neg x \\<in> H\n  closed 0 x\n  x = And A B\n\ngoal (1 subgoal):\n 1. Neg (And A B) \\<in> H &&& closed 0 (And A B)", "by simp_all"], ["proof (state)\nthis:\n  Neg (And A B) \\<in> H\n  closed 0 (And A B)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = And A B; Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "then"], ["proof (chain)\npicking this:\n  Neg (And A B) \\<in> H\n  closed 0 (And A B)", "have \\<open>Neg A \\<in> H \\<or> Neg B \\<in> H\\<close>"], ["proof (prove)\nusing this:\n  Neg (And A B) \\<in> H\n  closed 0 (And A B)\n\ngoal (1 subgoal):\n 1. Neg A \\<in> H \\<or> Neg B \\<in> H", "using hin"], ["proof (prove)\nusing this:\n  Neg (And A B) \\<in> H\n  closed 0 (And A B)\n  hintikka H\n\ngoal (1 subgoal):\n 1. Neg A \\<in> H \\<or> Neg B \\<in> H", "unfolding hintikka_def"], ["proof (prove)\nusing this:\n  Neg (And A B) \\<in> H\n  closed 0 (And A B)\n  (\\<forall>p ts.\n      \\<not> (Pred p ts \\<in> H \\<and> Neg (Pred p ts) \\<in> H)) \\<and>\n  FF \\<notin> H \\<and>\n  Neg TT \\<notin> H \\<and>\n  (\\<forall>Z. Neg (Neg Z) \\<in> H \\<longrightarrow> Z \\<in> H) \\<and>\n  (\\<forall>A B.\n      And A B \\<in> H \\<longrightarrow> A \\<in> H \\<and> B \\<in> H) \\<and>\n  (\\<forall>A B.\n      Neg (Or A B) \\<in> H \\<longrightarrow>\n      Neg A \\<in> H \\<and> Neg B \\<in> H) \\<and>\n  (\\<forall>A B.\n      Or A B \\<in> H \\<longrightarrow> A \\<in> H \\<or> B \\<in> H) \\<and>\n  (\\<forall>A B.\n      Neg (And A B) \\<in> H \\<longrightarrow>\n      Neg A \\<in> H \\<or> Neg B \\<in> H) \\<and>\n  (\\<forall>A B.\n      Impl A B \\<in> H \\<longrightarrow>\n      Neg A \\<in> H \\<or> B \\<in> H) \\<and>\n  (\\<forall>A B.\n      Neg (Impl A B) \\<in> H \\<longrightarrow>\n      A \\<in> H \\<and> Neg B \\<in> H) \\<and>\n  (\\<forall>P t.\n      closedt 0 t \\<longrightarrow>\n      Forall P \\<in> H \\<longrightarrow> P[t/0] \\<in> H) \\<and>\n  (\\<forall>P t.\n      closedt 0 t \\<longrightarrow>\n      Neg (Exists P) \\<in> H \\<longrightarrow> Neg (P[t/0]) \\<in> H) \\<and>\n  (\\<forall>P.\n      Exists P \\<in> H \\<longrightarrow>\n      (\\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> H)) \\<and>\n  (\\<forall>P.\n      Neg (Forall P) \\<in> H \\<longrightarrow>\n      (\\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> H))\n\ngoal (1 subgoal):\n 1. Neg A \\<in> H \\<or> Neg B \\<in> H", "by blast"], ["proof (state)\nthis:\n  Neg A \\<in> H \\<or> Neg B \\<in> H\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = And A B; Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "then"], ["proof (chain)\npicking this:\n  Neg A \\<in> H \\<or> Neg B \\<in> H", "show \\<open>?eval (Neg x)\\<close>"], ["proof (prove)\nusing this:\n  Neg A \\<in> H \\<or> Neg B \\<in> H\n\ngoal (1 subgoal):\n 1. eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) (Neg x)", "using And wf \\<open>closed 0 (And A B)\\<close>"], ["proof (prove)\nusing this:\n  Neg A \\<in> H \\<or> Neg B \\<in> H\n  x = And A B\n  \\<forall>y.\n     (y, x) \\<in> measure FOL_Fitting.size_form \\<longrightarrow>\n     (y \\<in> H \\<longrightarrow>\n      closed 0 y \\<longrightarrow>\n      eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n       y) \\<and>\n     (Neg y \\<in> H \\<longrightarrow>\n      closed 0 y \\<longrightarrow>\n      eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n       (Neg y))\n  closed 0 (And A B)\n\ngoal (1 subgoal):\n 1. eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) (Neg x)", "by fastforce"], ["proof (state)\nthis:\n  eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) (Neg x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (x \\<in> H \\<longrightarrow>\n   closed 0 x \\<longrightarrow>\n   eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n    x) \\<and>\n  (Neg x \\<in> H \\<longrightarrow>\n   closed 0 x \\<longrightarrow>\n   eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) (Neg x))\n\ngoal (4 subgoals):\n 1. \\<And>x51 x52.\n       x = Or x51 x52 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 2. \\<And>x61 x62.\n       x = Impl x61 x62 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 3. \\<And>x8.\n       x = Forall x8 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 4. \\<And>x9.\n       x = Exists x9 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x51 x52.\n       x = Or x51 x52 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 2. \\<And>x61 x62.\n       x = Impl x61 x62 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 3. \\<And>x8.\n       x = Forall x8 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 4. \\<And>x9.\n       x = Exists x9 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))", "case (Or A B)"], ["proof (state)\nthis:\n  x = Or A B\n\ngoal (4 subgoals):\n 1. \\<And>x51 x52.\n       x = Or x51 x52 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 2. \\<And>x61 x62.\n       x = Impl x61 x62 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 3. \\<And>x8.\n       x = Forall x8 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 4. \\<And>x9.\n       x = Exists x9 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))", "then"], ["proof (chain)\npicking this:\n  x = Or A B", "show ?thesis"], ["proof (prove)\nusing this:\n  x = Or A B\n\ngoal (1 subgoal):\n 1. (x \\<in> H \\<longrightarrow>\n     closed 0 x \\<longrightarrow>\n     eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n      x) \\<and>\n    (Neg x \\<in> H \\<longrightarrow>\n     closed 0 x \\<longrightarrow>\n     eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n      (Neg x))", "proof (intro conjI impI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>x = Or A B; x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       x\n 2. \\<lbrakk>x = Or A B; Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "assume \\<open>x \\<in> H\\<close> and \\<open>closed 0 x\\<close>"], ["proof (state)\nthis:\n  x \\<in> H\n  closed 0 x\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x = Or A B; x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       x\n 2. \\<lbrakk>x = Or A B; Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "then"], ["proof (chain)\npicking this:\n  x \\<in> H\n  closed 0 x", "have \\<open>Or A B \\<in> H\\<close> and \\<open>closed 0 (Or A B)\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> H\n  closed 0 x\n\ngoal (1 subgoal):\n 1. Or A B \\<in> H &&& closed 0 (Or A B)", "using Or"], ["proof (prove)\nusing this:\n  x \\<in> H\n  closed 0 x\n  x = Or A B\n\ngoal (1 subgoal):\n 1. Or A B \\<in> H &&& closed 0 (Or A B)", "by simp_all"], ["proof (state)\nthis:\n  Or A B \\<in> H\n  closed 0 (Or A B)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x = Or A B; x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       x\n 2. \\<lbrakk>x = Or A B; Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "then"], ["proof (chain)\npicking this:\n  Or A B \\<in> H\n  closed 0 (Or A B)", "have \\<open>A \\<in> H \\<or> B \\<in> H\\<close>"], ["proof (prove)\nusing this:\n  Or A B \\<in> H\n  closed 0 (Or A B)\n\ngoal (1 subgoal):\n 1. A \\<in> H \\<or> B \\<in> H", "using hin"], ["proof (prove)\nusing this:\n  Or A B \\<in> H\n  closed 0 (Or A B)\n  hintikka H\n\ngoal (1 subgoal):\n 1. A \\<in> H \\<or> B \\<in> H", "unfolding hintikka_def"], ["proof (prove)\nusing this:\n  Or A B \\<in> H\n  closed 0 (Or A B)\n  (\\<forall>p ts.\n      \\<not> (Pred p ts \\<in> H \\<and> Neg (Pred p ts) \\<in> H)) \\<and>\n  FF \\<notin> H \\<and>\n  Neg TT \\<notin> H \\<and>\n  (\\<forall>Z. Neg (Neg Z) \\<in> H \\<longrightarrow> Z \\<in> H) \\<and>\n  (\\<forall>A B.\n      And A B \\<in> H \\<longrightarrow> A \\<in> H \\<and> B \\<in> H) \\<and>\n  (\\<forall>A B.\n      Neg (Or A B) \\<in> H \\<longrightarrow>\n      Neg A \\<in> H \\<and> Neg B \\<in> H) \\<and>\n  (\\<forall>A B.\n      Or A B \\<in> H \\<longrightarrow> A \\<in> H \\<or> B \\<in> H) \\<and>\n  (\\<forall>A B.\n      Neg (And A B) \\<in> H \\<longrightarrow>\n      Neg A \\<in> H \\<or> Neg B \\<in> H) \\<and>\n  (\\<forall>A B.\n      Impl A B \\<in> H \\<longrightarrow>\n      Neg A \\<in> H \\<or> B \\<in> H) \\<and>\n  (\\<forall>A B.\n      Neg (Impl A B) \\<in> H \\<longrightarrow>\n      A \\<in> H \\<and> Neg B \\<in> H) \\<and>\n  (\\<forall>P t.\n      closedt 0 t \\<longrightarrow>\n      Forall P \\<in> H \\<longrightarrow> P[t/0] \\<in> H) \\<and>\n  (\\<forall>P t.\n      closedt 0 t \\<longrightarrow>\n      Neg (Exists P) \\<in> H \\<longrightarrow> Neg (P[t/0]) \\<in> H) \\<and>\n  (\\<forall>P.\n      Exists P \\<in> H \\<longrightarrow>\n      (\\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> H)) \\<and>\n  (\\<forall>P.\n      Neg (Forall P) \\<in> H \\<longrightarrow>\n      (\\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> H))\n\ngoal (1 subgoal):\n 1. A \\<in> H \\<or> B \\<in> H", "by blast"], ["proof (state)\nthis:\n  A \\<in> H \\<or> B \\<in> H\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x = Or A B; x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       x\n 2. \\<lbrakk>x = Or A B; Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "then"], ["proof (chain)\npicking this:\n  A \\<in> H \\<or> B \\<in> H", "show \\<open>?eval x\\<close>"], ["proof (prove)\nusing this:\n  A \\<in> H \\<or> B \\<in> H\n\ngoal (1 subgoal):\n 1. eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) x", "using Or wf \\<open>closed 0 (Or A B)\\<close>"], ["proof (prove)\nusing this:\n  A \\<in> H \\<or> B \\<in> H\n  x = Or A B\n  \\<forall>y.\n     (y, x) \\<in> measure FOL_Fitting.size_form \\<longrightarrow>\n     (y \\<in> H \\<longrightarrow>\n      closed 0 y \\<longrightarrow>\n      eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n       y) \\<and>\n     (Neg y \\<in> H \\<longrightarrow>\n      closed 0 y \\<longrightarrow>\n      eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n       (Neg y))\n  closed 0 (Or A B)\n\ngoal (1 subgoal):\n 1. eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) x", "by fastforce"], ["proof (state)\nthis:\n  eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = Or A B; Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = Or A B; Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "assume \\<open>Neg x \\<in> H\\<close> and \\<open>closed 0 x\\<close>"], ["proof (state)\nthis:\n  Neg x \\<in> H\n  closed 0 x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = Or A B; Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "then"], ["proof (chain)\npicking this:\n  Neg x \\<in> H\n  closed 0 x", "have \\<open>Neg (Or A B) \\<in> H\\<close> and \\<open>closed 0 (Or A B)\\<close>"], ["proof (prove)\nusing this:\n  Neg x \\<in> H\n  closed 0 x\n\ngoal (1 subgoal):\n 1. Neg (Or A B) \\<in> H &&& closed 0 (Or A B)", "using Or"], ["proof (prove)\nusing this:\n  Neg x \\<in> H\n  closed 0 x\n  x = Or A B\n\ngoal (1 subgoal):\n 1. Neg (Or A B) \\<in> H &&& closed 0 (Or A B)", "by simp_all"], ["proof (state)\nthis:\n  Neg (Or A B) \\<in> H\n  closed 0 (Or A B)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = Or A B; Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "then"], ["proof (chain)\npicking this:\n  Neg (Or A B) \\<in> H\n  closed 0 (Or A B)", "have \\<open>Neg A \\<in> H \\<and> Neg B \\<in> H\\<close>"], ["proof (prove)\nusing this:\n  Neg (Or A B) \\<in> H\n  closed 0 (Or A B)\n\ngoal (1 subgoal):\n 1. Neg A \\<in> H \\<and> Neg B \\<in> H", "using hin"], ["proof (prove)\nusing this:\n  Neg (Or A B) \\<in> H\n  closed 0 (Or A B)\n  hintikka H\n\ngoal (1 subgoal):\n 1. Neg A \\<in> H \\<and> Neg B \\<in> H", "unfolding hintikka_def"], ["proof (prove)\nusing this:\n  Neg (Or A B) \\<in> H\n  closed 0 (Or A B)\n  (\\<forall>p ts.\n      \\<not> (Pred p ts \\<in> H \\<and> Neg (Pred p ts) \\<in> H)) \\<and>\n  FF \\<notin> H \\<and>\n  Neg TT \\<notin> H \\<and>\n  (\\<forall>Z. Neg (Neg Z) \\<in> H \\<longrightarrow> Z \\<in> H) \\<and>\n  (\\<forall>A B.\n      And A B \\<in> H \\<longrightarrow> A \\<in> H \\<and> B \\<in> H) \\<and>\n  (\\<forall>A B.\n      Neg (Or A B) \\<in> H \\<longrightarrow>\n      Neg A \\<in> H \\<and> Neg B \\<in> H) \\<and>\n  (\\<forall>A B.\n      Or A B \\<in> H \\<longrightarrow> A \\<in> H \\<or> B \\<in> H) \\<and>\n  (\\<forall>A B.\n      Neg (And A B) \\<in> H \\<longrightarrow>\n      Neg A \\<in> H \\<or> Neg B \\<in> H) \\<and>\n  (\\<forall>A B.\n      Impl A B \\<in> H \\<longrightarrow>\n      Neg A \\<in> H \\<or> B \\<in> H) \\<and>\n  (\\<forall>A B.\n      Neg (Impl A B) \\<in> H \\<longrightarrow>\n      A \\<in> H \\<and> Neg B \\<in> H) \\<and>\n  (\\<forall>P t.\n      closedt 0 t \\<longrightarrow>\n      Forall P \\<in> H \\<longrightarrow> P[t/0] \\<in> H) \\<and>\n  (\\<forall>P t.\n      closedt 0 t \\<longrightarrow>\n      Neg (Exists P) \\<in> H \\<longrightarrow> Neg (P[t/0]) \\<in> H) \\<and>\n  (\\<forall>P.\n      Exists P \\<in> H \\<longrightarrow>\n      (\\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> H)) \\<and>\n  (\\<forall>P.\n      Neg (Forall P) \\<in> H \\<longrightarrow>\n      (\\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> H))\n\ngoal (1 subgoal):\n 1. Neg A \\<in> H \\<and> Neg B \\<in> H", "by blast"], ["proof (state)\nthis:\n  Neg A \\<in> H \\<and> Neg B \\<in> H\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = Or A B; Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "then"], ["proof (chain)\npicking this:\n  Neg A \\<in> H \\<and> Neg B \\<in> H", "show \\<open>?eval (Neg x)\\<close>"], ["proof (prove)\nusing this:\n  Neg A \\<in> H \\<and> Neg B \\<in> H\n\ngoal (1 subgoal):\n 1. eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) (Neg x)", "using Or wf \\<open>closed 0 (Or A B)\\<close>"], ["proof (prove)\nusing this:\n  Neg A \\<in> H \\<and> Neg B \\<in> H\n  x = Or A B\n  \\<forall>y.\n     (y, x) \\<in> measure FOL_Fitting.size_form \\<longrightarrow>\n     (y \\<in> H \\<longrightarrow>\n      closed 0 y \\<longrightarrow>\n      eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n       y) \\<and>\n     (Neg y \\<in> H \\<longrightarrow>\n      closed 0 y \\<longrightarrow>\n      eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n       (Neg y))\n  closed 0 (Or A B)\n\ngoal (1 subgoal):\n 1. eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) (Neg x)", "by simp"], ["proof (state)\nthis:\n  eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) (Neg x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (x \\<in> H \\<longrightarrow>\n   closed 0 x \\<longrightarrow>\n   eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n    x) \\<and>\n  (Neg x \\<in> H \\<longrightarrow>\n   closed 0 x \\<longrightarrow>\n   eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) (Neg x))\n\ngoal (3 subgoals):\n 1. \\<And>x61 x62.\n       x = Impl x61 x62 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 2. \\<And>x8.\n       x = Forall x8 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 3. \\<And>x9.\n       x = Exists x9 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x61 x62.\n       x = Impl x61 x62 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 2. \\<And>x8.\n       x = Forall x8 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 3. \\<And>x9.\n       x = Exists x9 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))", "case (Impl A B)"], ["proof (state)\nthis:\n  x = Impl A B\n\ngoal (3 subgoals):\n 1. \\<And>x61 x62.\n       x = Impl x61 x62 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 2. \\<And>x8.\n       x = Forall x8 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 3. \\<And>x9.\n       x = Exists x9 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))", "then"], ["proof (chain)\npicking this:\n  x = Impl A B", "show ?thesis"], ["proof (prove)\nusing this:\n  x = Impl A B\n\ngoal (1 subgoal):\n 1. (x \\<in> H \\<longrightarrow>\n     closed 0 x \\<longrightarrow>\n     eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n      x) \\<and>\n    (Neg x \\<in> H \\<longrightarrow>\n     closed 0 x \\<longrightarrow>\n     eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n      (Neg x))", "proof (intro conjI impI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>x = Impl A B; x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       x\n 2. \\<lbrakk>x = Impl A B; Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "assume \\<open>x \\<in> H\\<close> and \\<open>closed 0 x\\<close>"], ["proof (state)\nthis:\n  x \\<in> H\n  closed 0 x\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x = Impl A B; x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       x\n 2. \\<lbrakk>x = Impl A B; Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "then"], ["proof (chain)\npicking this:\n  x \\<in> H\n  closed 0 x", "have \\<open>Impl A B \\<in> H\\<close> and \\<open>closed 0 (Impl A B)\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> H\n  closed 0 x\n\ngoal (1 subgoal):\n 1. Impl A B \\<in> H &&& closed 0 (Impl A B)", "using Impl"], ["proof (prove)\nusing this:\n  x \\<in> H\n  closed 0 x\n  x = Impl A B\n\ngoal (1 subgoal):\n 1. Impl A B \\<in> H &&& closed 0 (Impl A B)", "by simp_all"], ["proof (state)\nthis:\n  Impl A B \\<in> H\n  closed 0 (Impl A B)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x = Impl A B; x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       x\n 2. \\<lbrakk>x = Impl A B; Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "then"], ["proof (chain)\npicking this:\n  Impl A B \\<in> H\n  closed 0 (Impl A B)", "have \\<open>Neg A \\<in> H \\<or> B \\<in> H\\<close>"], ["proof (prove)\nusing this:\n  Impl A B \\<in> H\n  closed 0 (Impl A B)\n\ngoal (1 subgoal):\n 1. Neg A \\<in> H \\<or> B \\<in> H", "using hin"], ["proof (prove)\nusing this:\n  Impl A B \\<in> H\n  closed 0 (Impl A B)\n  hintikka H\n\ngoal (1 subgoal):\n 1. Neg A \\<in> H \\<or> B \\<in> H", "unfolding hintikka_def"], ["proof (prove)\nusing this:\n  Impl A B \\<in> H\n  closed 0 (Impl A B)\n  (\\<forall>p ts.\n      \\<not> (Pred p ts \\<in> H \\<and> Neg (Pred p ts) \\<in> H)) \\<and>\n  FF \\<notin> H \\<and>\n  Neg TT \\<notin> H \\<and>\n  (\\<forall>Z. Neg (Neg Z) \\<in> H \\<longrightarrow> Z \\<in> H) \\<and>\n  (\\<forall>A B.\n      And A B \\<in> H \\<longrightarrow> A \\<in> H \\<and> B \\<in> H) \\<and>\n  (\\<forall>A B.\n      Neg (Or A B) \\<in> H \\<longrightarrow>\n      Neg A \\<in> H \\<and> Neg B \\<in> H) \\<and>\n  (\\<forall>A B.\n      Or A B \\<in> H \\<longrightarrow> A \\<in> H \\<or> B \\<in> H) \\<and>\n  (\\<forall>A B.\n      Neg (And A B) \\<in> H \\<longrightarrow>\n      Neg A \\<in> H \\<or> Neg B \\<in> H) \\<and>\n  (\\<forall>A B.\n      Impl A B \\<in> H \\<longrightarrow>\n      Neg A \\<in> H \\<or> B \\<in> H) \\<and>\n  (\\<forall>A B.\n      Neg (Impl A B) \\<in> H \\<longrightarrow>\n      A \\<in> H \\<and> Neg B \\<in> H) \\<and>\n  (\\<forall>P t.\n      closedt 0 t \\<longrightarrow>\n      Forall P \\<in> H \\<longrightarrow> P[t/0] \\<in> H) \\<and>\n  (\\<forall>P t.\n      closedt 0 t \\<longrightarrow>\n      Neg (Exists P) \\<in> H \\<longrightarrow> Neg (P[t/0]) \\<in> H) \\<and>\n  (\\<forall>P.\n      Exists P \\<in> H \\<longrightarrow>\n      (\\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> H)) \\<and>\n  (\\<forall>P.\n      Neg (Forall P) \\<in> H \\<longrightarrow>\n      (\\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> H))\n\ngoal (1 subgoal):\n 1. Neg A \\<in> H \\<or> B \\<in> H", "by blast"], ["proof (state)\nthis:\n  Neg A \\<in> H \\<or> B \\<in> H\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x = Impl A B; x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       x\n 2. \\<lbrakk>x = Impl A B; Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "then"], ["proof (chain)\npicking this:\n  Neg A \\<in> H \\<or> B \\<in> H", "show \\<open>?eval x\\<close>"], ["proof (prove)\nusing this:\n  Neg A \\<in> H \\<or> B \\<in> H\n\ngoal (1 subgoal):\n 1. eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) x", "using Impl wf \\<open>closed 0 (Impl A B)\\<close>"], ["proof (prove)\nusing this:\n  Neg A \\<in> H \\<or> B \\<in> H\n  x = Impl A B\n  \\<forall>y.\n     (y, x) \\<in> measure FOL_Fitting.size_form \\<longrightarrow>\n     (y \\<in> H \\<longrightarrow>\n      closed 0 y \\<longrightarrow>\n      eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n       y) \\<and>\n     (Neg y \\<in> H \\<longrightarrow>\n      closed 0 y \\<longrightarrow>\n      eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n       (Neg y))\n  closed 0 (Impl A B)\n\ngoal (1 subgoal):\n 1. eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) x", "by fastforce"], ["proof (state)\nthis:\n  eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = Impl A B; Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = Impl A B; Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "assume \\<open>Neg x \\<in> H\\<close> and \\<open>closed 0 x\\<close>"], ["proof (state)\nthis:\n  Neg x \\<in> H\n  closed 0 x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = Impl A B; Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "then"], ["proof (chain)\npicking this:\n  Neg x \\<in> H\n  closed 0 x", "have \\<open>Neg (Impl A B) \\<in> H\\<close> and \\<open>closed 0 (Impl A B)\\<close>"], ["proof (prove)\nusing this:\n  Neg x \\<in> H\n  closed 0 x\n\ngoal (1 subgoal):\n 1. Neg (Impl A B) \\<in> H &&& closed 0 (Impl A B)", "using Impl"], ["proof (prove)\nusing this:\n  Neg x \\<in> H\n  closed 0 x\n  x = Impl A B\n\ngoal (1 subgoal):\n 1. Neg (Impl A B) \\<in> H &&& closed 0 (Impl A B)", "by simp_all"], ["proof (state)\nthis:\n  Neg (Impl A B) \\<in> H\n  closed 0 (Impl A B)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = Impl A B; Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "then"], ["proof (chain)\npicking this:\n  Neg (Impl A B) \\<in> H\n  closed 0 (Impl A B)", "have \\<open>A \\<in> H \\<and> Neg B \\<in> H\\<close>"], ["proof (prove)\nusing this:\n  Neg (Impl A B) \\<in> H\n  closed 0 (Impl A B)\n\ngoal (1 subgoal):\n 1. A \\<in> H \\<and> Neg B \\<in> H", "using hin"], ["proof (prove)\nusing this:\n  Neg (Impl A B) \\<in> H\n  closed 0 (Impl A B)\n  hintikka H\n\ngoal (1 subgoal):\n 1. A \\<in> H \\<and> Neg B \\<in> H", "unfolding hintikka_def"], ["proof (prove)\nusing this:\n  Neg (Impl A B) \\<in> H\n  closed 0 (Impl A B)\n  (\\<forall>p ts.\n      \\<not> (Pred p ts \\<in> H \\<and> Neg (Pred p ts) \\<in> H)) \\<and>\n  FF \\<notin> H \\<and>\n  Neg TT \\<notin> H \\<and>\n  (\\<forall>Z. Neg (Neg Z) \\<in> H \\<longrightarrow> Z \\<in> H) \\<and>\n  (\\<forall>A B.\n      And A B \\<in> H \\<longrightarrow> A \\<in> H \\<and> B \\<in> H) \\<and>\n  (\\<forall>A B.\n      Neg (Or A B) \\<in> H \\<longrightarrow>\n      Neg A \\<in> H \\<and> Neg B \\<in> H) \\<and>\n  (\\<forall>A B.\n      Or A B \\<in> H \\<longrightarrow> A \\<in> H \\<or> B \\<in> H) \\<and>\n  (\\<forall>A B.\n      Neg (And A B) \\<in> H \\<longrightarrow>\n      Neg A \\<in> H \\<or> Neg B \\<in> H) \\<and>\n  (\\<forall>A B.\n      Impl A B \\<in> H \\<longrightarrow>\n      Neg A \\<in> H \\<or> B \\<in> H) \\<and>\n  (\\<forall>A B.\n      Neg (Impl A B) \\<in> H \\<longrightarrow>\n      A \\<in> H \\<and> Neg B \\<in> H) \\<and>\n  (\\<forall>P t.\n      closedt 0 t \\<longrightarrow>\n      Forall P \\<in> H \\<longrightarrow> P[t/0] \\<in> H) \\<and>\n  (\\<forall>P t.\n      closedt 0 t \\<longrightarrow>\n      Neg (Exists P) \\<in> H \\<longrightarrow> Neg (P[t/0]) \\<in> H) \\<and>\n  (\\<forall>P.\n      Exists P \\<in> H \\<longrightarrow>\n      (\\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> H)) \\<and>\n  (\\<forall>P.\n      Neg (Forall P) \\<in> H \\<longrightarrow>\n      (\\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> H))\n\ngoal (1 subgoal):\n 1. A \\<in> H \\<and> Neg B \\<in> H", "by blast"], ["proof (state)\nthis:\n  A \\<in> H \\<and> Neg B \\<in> H\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = Impl A B; Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "then"], ["proof (chain)\npicking this:\n  A \\<in> H \\<and> Neg B \\<in> H", "show \\<open>?eval (Neg x)\\<close>"], ["proof (prove)\nusing this:\n  A \\<in> H \\<and> Neg B \\<in> H\n\ngoal (1 subgoal):\n 1. eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) (Neg x)", "using Impl wf \\<open>closed 0 (Impl A B)\\<close>"], ["proof (prove)\nusing this:\n  A \\<in> H \\<and> Neg B \\<in> H\n  x = Impl A B\n  \\<forall>y.\n     (y, x) \\<in> measure FOL_Fitting.size_form \\<longrightarrow>\n     (y \\<in> H \\<longrightarrow>\n      closed 0 y \\<longrightarrow>\n      eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n       y) \\<and>\n     (Neg y \\<in> H \\<longrightarrow>\n      closed 0 y \\<longrightarrow>\n      eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n       (Neg y))\n  closed 0 (Impl A B)\n\ngoal (1 subgoal):\n 1. eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) (Neg x)", "by simp"], ["proof (state)\nthis:\n  eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) (Neg x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (x \\<in> H \\<longrightarrow>\n   closed 0 x \\<longrightarrow>\n   eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n    x) \\<and>\n  (Neg x \\<in> H \\<longrightarrow>\n   closed 0 x \\<longrightarrow>\n   eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) (Neg x))\n\ngoal (2 subgoals):\n 1. \\<And>x8.\n       x = Forall x8 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 2. \\<And>x9.\n       x = Exists x9 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x8.\n       x = Forall x8 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 2. \\<And>x9.\n       x = Exists x9 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))", "case (Forall P)"], ["proof (state)\nthis:\n  x = Forall P\n\ngoal (2 subgoals):\n 1. \\<And>x8.\n       x = Forall x8 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))\n 2. \\<And>x9.\n       x = Exists x9 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))", "then"], ["proof (chain)\npicking this:\n  x = Forall P", "show ?thesis"], ["proof (prove)\nusing this:\n  x = Forall P\n\ngoal (1 subgoal):\n 1. (x \\<in> H \\<longrightarrow>\n     closed 0 x \\<longrightarrow>\n     eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n      x) \\<and>\n    (Neg x \\<in> H \\<longrightarrow>\n     closed 0 x \\<longrightarrow>\n     eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n      (Neg x))", "proof (intro conjI impI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>x = Forall P; x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       x\n 2. \\<lbrakk>x = Forall P; Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "assume \\<open>x \\<in> H\\<close> and \\<open>closed 0 x\\<close>"], ["proof (state)\nthis:\n  x \\<in> H\n  closed 0 x\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x = Forall P; x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       x\n 2. \\<lbrakk>x = Forall P; Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "have \\<open>\\<forall>z. eval (e\\<langle>0:z\\<rangle>) HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) P\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>z.\n       eval (e\\<langle>0:z\\<rangle>) HApp\n        (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) P", "proof (rule allI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z.\n       eval (e\\<langle>0:z\\<rangle>) HApp\n        (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) P", "fix z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z.\n       eval (e\\<langle>0:z\\<rangle>) HApp\n        (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) P", "from \\<open>x \\<in> H\\<close> and \\<open>closed 0 x\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> H\n  closed 0 x", "have \\<open>Forall P \\<in> H\\<close> and \\<open>closed 0 (Forall P)\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> H\n  closed 0 x\n\ngoal (1 subgoal):\n 1. Forall P \\<in> H &&& closed 0 (Forall P)", "using Forall"], ["proof (prove)\nusing this:\n  x \\<in> H\n  closed 0 x\n  x = Forall P\n\ngoal (1 subgoal):\n 1. Forall P \\<in> H &&& closed 0 (Forall P)", "by simp_all"], ["proof (state)\nthis:\n  Forall P \\<in> H\n  closed 0 (Forall P)\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       eval (e\\<langle>0:z\\<rangle>) HApp\n        (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) P", "then"], ["proof (chain)\npicking this:\n  Forall P \\<in> H\n  closed 0 (Forall P)", "have *: \\<open>\\<forall>P t. closedt 0 t \\<longrightarrow> Forall P \\<in> H \\<longrightarrow> P[t/0] \\<in> H\\<close>"], ["proof (prove)\nusing this:\n  Forall P \\<in> H\n  closed 0 (Forall P)\n\ngoal (1 subgoal):\n 1. \\<forall>P t.\n       closedt 0 t \\<longrightarrow>\n       Forall P \\<in> H \\<longrightarrow> P[t/0] \\<in> H", "using hin"], ["proof (prove)\nusing this:\n  Forall P \\<in> H\n  closed 0 (Forall P)\n  hintikka H\n\ngoal (1 subgoal):\n 1. \\<forall>P t.\n       closedt 0 t \\<longrightarrow>\n       Forall P \\<in> H \\<longrightarrow> P[t/0] \\<in> H", "unfolding hintikka_def"], ["proof (prove)\nusing this:\n  Forall P \\<in> H\n  closed 0 (Forall P)\n  (\\<forall>p ts.\n      \\<not> (Pred p ts \\<in> H \\<and> Neg (Pred p ts) \\<in> H)) \\<and>\n  FF \\<notin> H \\<and>\n  Neg TT \\<notin> H \\<and>\n  (\\<forall>Z. Neg (Neg Z) \\<in> H \\<longrightarrow> Z \\<in> H) \\<and>\n  (\\<forall>A B.\n      And A B \\<in> H \\<longrightarrow> A \\<in> H \\<and> B \\<in> H) \\<and>\n  (\\<forall>A B.\n      Neg (Or A B) \\<in> H \\<longrightarrow>\n      Neg A \\<in> H \\<and> Neg B \\<in> H) \\<and>\n  (\\<forall>A B.\n      Or A B \\<in> H \\<longrightarrow> A \\<in> H \\<or> B \\<in> H) \\<and>\n  (\\<forall>A B.\n      Neg (And A B) \\<in> H \\<longrightarrow>\n      Neg A \\<in> H \\<or> Neg B \\<in> H) \\<and>\n  (\\<forall>A B.\n      Impl A B \\<in> H \\<longrightarrow>\n      Neg A \\<in> H \\<or> B \\<in> H) \\<and>\n  (\\<forall>A B.\n      Neg (Impl A B) \\<in> H \\<longrightarrow>\n      A \\<in> H \\<and> Neg B \\<in> H) \\<and>\n  (\\<forall>P t.\n      closedt 0 t \\<longrightarrow>\n      Forall P \\<in> H \\<longrightarrow> P[t/0] \\<in> H) \\<and>\n  (\\<forall>P t.\n      closedt 0 t \\<longrightarrow>\n      Neg (Exists P) \\<in> H \\<longrightarrow> Neg (P[t/0]) \\<in> H) \\<and>\n  (\\<forall>P.\n      Exists P \\<in> H \\<longrightarrow>\n      (\\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> H)) \\<and>\n  (\\<forall>P.\n      Neg (Forall P) \\<in> H \\<longrightarrow>\n      (\\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> H))\n\ngoal (1 subgoal):\n 1. \\<forall>P t.\n       closedt 0 t \\<longrightarrow>\n       Forall P \\<in> H \\<longrightarrow> P[t/0] \\<in> H", "by blast"], ["proof (state)\nthis:\n  \\<forall>P t.\n     closedt 0 t \\<longrightarrow>\n     Forall P \\<in> H \\<longrightarrow> P[t/0] \\<in> H\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       eval (e\\<langle>0:z\\<rangle>) HApp\n        (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) P", "from \\<open>closed 0 (Forall P)\\<close>"], ["proof (chain)\npicking this:\n  closed 0 (Forall P)", "have \\<open>closed (Suc 0) P\\<close>"], ["proof (prove)\nusing this:\n  closed 0 (Forall P)\n\ngoal (1 subgoal):\n 1. closed (Suc 0) P", "by simp"], ["proof (state)\nthis:\n  closed (Suc 0) P\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       eval (e\\<langle>0:z\\<rangle>) HApp\n        (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) P", "have \\<open>(P[term_of_hterm z/0], Forall P) \\<in> measure size_form \\<longrightarrow>\n              (P[term_of_hterm z/0] \\<in> H \\<longrightarrow> closed 0 (P[term_of_hterm z/0]) \\<longrightarrow>\n              ?eval (P[term_of_hterm z/0]))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (P[term_of_hterm z/0], Forall P)\n    \\<in> measure FOL_Fitting.size_form \\<longrightarrow>\n    P[term_of_hterm z/0] \\<in> H \\<longrightarrow>\n    closed 0 (P[term_of_hterm z/0]) \\<longrightarrow>\n    eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n     (P[term_of_hterm z/0])", "using Forall wf"], ["proof (prove)\nusing this:\n  x = Forall P\n  \\<forall>y.\n     (y, x) \\<in> measure FOL_Fitting.size_form \\<longrightarrow>\n     (y \\<in> H \\<longrightarrow>\n      closed 0 y \\<longrightarrow>\n      eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n       y) \\<and>\n     (Neg y \\<in> H \\<longrightarrow>\n      closed 0 y \\<longrightarrow>\n      eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n       (Neg y))\n\ngoal (1 subgoal):\n 1. (P[term_of_hterm z/0], Forall P)\n    \\<in> measure FOL_Fitting.size_form \\<longrightarrow>\n    P[term_of_hterm z/0] \\<in> H \\<longrightarrow>\n    closed 0 (P[term_of_hterm z/0]) \\<longrightarrow>\n    eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n     (P[term_of_hterm z/0])", "by blast"], ["proof (state)\nthis:\n  (P[term_of_hterm z/0], Forall P)\n  \\<in> measure FOL_Fitting.size_form \\<longrightarrow>\n  P[term_of_hterm z/0] \\<in> H \\<longrightarrow>\n  closed 0 (P[term_of_hterm z/0]) \\<longrightarrow>\n  eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n   (P[term_of_hterm z/0])\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       eval (e\\<langle>0:z\\<rangle>) HApp\n        (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) P", "then"], ["proof (chain)\npicking this:\n  (P[term_of_hterm z/0], Forall P)\n  \\<in> measure FOL_Fitting.size_form \\<longrightarrow>\n  P[term_of_hterm z/0] \\<in> H \\<longrightarrow>\n  closed 0 (P[term_of_hterm z/0]) \\<longrightarrow>\n  eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n   (P[term_of_hterm z/0])", "show \\<open>eval (e\\<langle>0:z\\<rangle>) HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) P\\<close>"], ["proof (prove)\nusing this:\n  (P[term_of_hterm z/0], Forall P)\n  \\<in> measure FOL_Fitting.size_form \\<longrightarrow>\n  P[term_of_hterm z/0] \\<in> H \\<longrightarrow>\n  closed 0 (P[term_of_hterm z/0]) \\<longrightarrow>\n  eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n   (P[term_of_hterm z/0])\n\ngoal (1 subgoal):\n 1. eval (e\\<langle>0:z\\<rangle>) HApp\n     (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) P", "using * \\<open>Forall P \\<in> H\\<close> \\<open>closed (Suc 0) P\\<close>"], ["proof (prove)\nusing this:\n  (P[term_of_hterm z/0], Forall P)\n  \\<in> measure FOL_Fitting.size_form \\<longrightarrow>\n  P[term_of_hterm z/0] \\<in> H \\<longrightarrow>\n  closed 0 (P[term_of_hterm z/0]) \\<longrightarrow>\n  eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n   (P[term_of_hterm z/0])\n  \\<forall>P t.\n     closedt 0 t \\<longrightarrow>\n     Forall P \\<in> H \\<longrightarrow> P[t/0] \\<in> H\n  Forall P \\<in> H\n  closed (Suc 0) P\n\ngoal (1 subgoal):\n 1. eval (e\\<langle>0:z\\<rangle>) HApp\n     (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) P", "by simp"], ["proof (state)\nthis:\n  eval (e\\<langle>0:z\\<rangle>) HApp\n   (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>z.\n     eval (e\\<langle>0:z\\<rangle>) HApp\n      (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) P\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x = Forall P; x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       x\n 2. \\<lbrakk>x = Forall P; Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "then"], ["proof (chain)\npicking this:\n  \\<forall>z.\n     eval (e\\<langle>0:z\\<rangle>) HApp\n      (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) P", "show \\<open>?eval x\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>z.\n     eval (e\\<langle>0:z\\<rangle>) HApp\n      (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) P\n\ngoal (1 subgoal):\n 1. eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) x", "using Forall"], ["proof (prove)\nusing this:\n  \\<forall>z.\n     eval (e\\<langle>0:z\\<rangle>) HApp\n      (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) P\n  x = Forall P\n\ngoal (1 subgoal):\n 1. eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) x", "by simp"], ["proof (state)\nthis:\n  eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = Forall P; Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = Forall P; Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "assume \\<open>Neg x \\<in> H\\<close> and \\<open>closed 0 x\\<close>"], ["proof (state)\nthis:\n  Neg x \\<in> H\n  closed 0 x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = Forall P; Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "then"], ["proof (chain)\npicking this:\n  Neg x \\<in> H\n  closed 0 x", "have \\<open>Neg (Forall P) \\<in> H\\<close>"], ["proof (prove)\nusing this:\n  Neg x \\<in> H\n  closed 0 x\n\ngoal (1 subgoal):\n 1. Neg (Forall P) \\<in> H", "using Forall"], ["proof (prove)\nusing this:\n  Neg x \\<in> H\n  closed 0 x\n  x = Forall P\n\ngoal (1 subgoal):\n 1. Neg (Forall P) \\<in> H", "by simp"], ["proof (state)\nthis:\n  Neg (Forall P) \\<in> H\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = Forall P; Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "then"], ["proof (chain)\npicking this:\n  Neg (Forall P) \\<in> H", "have \\<open>\\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> H\\<close>"], ["proof (prove)\nusing this:\n  Neg (Forall P) \\<in> H\n\ngoal (1 subgoal):\n 1. \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> H", "using Forall hin"], ["proof (prove)\nusing this:\n  Neg (Forall P) \\<in> H\n  x = Forall P\n  hintikka H\n\ngoal (1 subgoal):\n 1. \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> H", "unfolding hintikka_def"], ["proof (prove)\nusing this:\n  Neg (Forall P) \\<in> H\n  x = Forall P\n  (\\<forall>p ts.\n      \\<not> (Pred p ts \\<in> H \\<and> Neg (Pred p ts) \\<in> H)) \\<and>\n  FF \\<notin> H \\<and>\n  Neg TT \\<notin> H \\<and>\n  (\\<forall>Z. Neg (Neg Z) \\<in> H \\<longrightarrow> Z \\<in> H) \\<and>\n  (\\<forall>A B.\n      And A B \\<in> H \\<longrightarrow> A \\<in> H \\<and> B \\<in> H) \\<and>\n  (\\<forall>A B.\n      Neg (Or A B) \\<in> H \\<longrightarrow>\n      Neg A \\<in> H \\<and> Neg B \\<in> H) \\<and>\n  (\\<forall>A B.\n      Or A B \\<in> H \\<longrightarrow> A \\<in> H \\<or> B \\<in> H) \\<and>\n  (\\<forall>A B.\n      Neg (And A B) \\<in> H \\<longrightarrow>\n      Neg A \\<in> H \\<or> Neg B \\<in> H) \\<and>\n  (\\<forall>A B.\n      Impl A B \\<in> H \\<longrightarrow>\n      Neg A \\<in> H \\<or> B \\<in> H) \\<and>\n  (\\<forall>A B.\n      Neg (Impl A B) \\<in> H \\<longrightarrow>\n      A \\<in> H \\<and> Neg B \\<in> H) \\<and>\n  (\\<forall>P t.\n      closedt 0 t \\<longrightarrow>\n      Forall P \\<in> H \\<longrightarrow> P[t/0] \\<in> H) \\<and>\n  (\\<forall>P t.\n      closedt 0 t \\<longrightarrow>\n      Neg (Exists P) \\<in> H \\<longrightarrow> Neg (P[t/0]) \\<in> H) \\<and>\n  (\\<forall>P.\n      Exists P \\<in> H \\<longrightarrow>\n      (\\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> H)) \\<and>\n  (\\<forall>P.\n      Neg (Forall P) \\<in> H \\<longrightarrow>\n      (\\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> H))\n\ngoal (1 subgoal):\n 1. \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> H", "by blast"], ["proof (state)\nthis:\n  \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> H\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = Forall P; Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "then"], ["proof (chain)\npicking this:\n  \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> H", "obtain t where *: \\<open>closedt 0 t \\<and> Neg (P[t/0]) \\<in> H\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> H\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        closedt 0 t \\<and> Neg (P[t/0]) \\<in> H \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  closedt 0 t \\<and> Neg (P[t/0]) \\<in> H\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = Forall P; Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "then"], ["proof (chain)\npicking this:\n  closedt 0 t \\<and> Neg (P[t/0]) \\<in> H", "have \\<open>closed 0 (P[t/0])\\<close>"], ["proof (prove)\nusing this:\n  closedt 0 t \\<and> Neg (P[t/0]) \\<in> H\n\ngoal (1 subgoal):\n 1. closed 0 (P[t/0])", "using Forall \\<open>closed 0 x\\<close>"], ["proof (prove)\nusing this:\n  closedt 0 t \\<and> Neg (P[t/0]) \\<in> H\n  x = Forall P\n  closed 0 x\n\ngoal (1 subgoal):\n 1. closed 0 (P[t/0])", "by simp"], ["proof (state)\nthis:\n  closed 0 (P[t/0])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = Forall P; Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "have \\<open>(subst P t 0, Forall P) \\<in> measure size_form \\<longrightarrow>\n              (Neg (subst P t 0) \\<in> H \\<longrightarrow> closed 0 (subst P t 0) \\<longrightarrow>\n              ?eval (Neg (subst P t 0)))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (P[t/0], Forall P) \\<in> measure FOL_Fitting.size_form \\<longrightarrow>\n    Neg (P[t/0]) \\<in> H \\<longrightarrow>\n    closed 0 (P[t/0]) \\<longrightarrow>\n    eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n     (Neg (P[t/0]))", "using Forall wf"], ["proof (prove)\nusing this:\n  x = Forall P\n  \\<forall>y.\n     (y, x) \\<in> measure FOL_Fitting.size_form \\<longrightarrow>\n     (y \\<in> H \\<longrightarrow>\n      closed 0 y \\<longrightarrow>\n      eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n       y) \\<and>\n     (Neg y \\<in> H \\<longrightarrow>\n      closed 0 y \\<longrightarrow>\n      eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n       (Neg y))\n\ngoal (1 subgoal):\n 1. (P[t/0], Forall P) \\<in> measure FOL_Fitting.size_form \\<longrightarrow>\n    Neg (P[t/0]) \\<in> H \\<longrightarrow>\n    closed 0 (P[t/0]) \\<longrightarrow>\n    eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n     (Neg (P[t/0]))", "by blast"], ["proof (state)\nthis:\n  (P[t/0], Forall P) \\<in> measure FOL_Fitting.size_form \\<longrightarrow>\n  Neg (P[t/0]) \\<in> H \\<longrightarrow>\n  closed 0 (P[t/0]) \\<longrightarrow>\n  eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n   (Neg (P[t/0]))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = Forall P; Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "then"], ["proof (chain)\npicking this:\n  (P[t/0], Forall P) \\<in> measure FOL_Fitting.size_form \\<longrightarrow>\n  Neg (P[t/0]) \\<in> H \\<longrightarrow>\n  closed 0 (P[t/0]) \\<longrightarrow>\n  eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n   (Neg (P[t/0]))", "have \\<open>?eval (Neg (P[t/0]))\\<close>"], ["proof (prove)\nusing this:\n  (P[t/0], Forall P) \\<in> measure FOL_Fitting.size_form \\<longrightarrow>\n  Neg (P[t/0]) \\<in> H \\<longrightarrow>\n  closed 0 (P[t/0]) \\<longrightarrow>\n  eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n   (Neg (P[t/0]))\n\ngoal (1 subgoal):\n 1. eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n     (Neg (P[t/0]))", "using Forall * \\<open>closed 0 (P[t/0])\\<close>"], ["proof (prove)\nusing this:\n  (P[t/0], Forall P) \\<in> measure FOL_Fitting.size_form \\<longrightarrow>\n  Neg (P[t/0]) \\<in> H \\<longrightarrow>\n  closed 0 (P[t/0]) \\<longrightarrow>\n  eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n   (Neg (P[t/0]))\n  x = Forall P\n  closedt 0 t \\<and> Neg (P[t/0]) \\<in> H\n  closed 0 (P[t/0])\n\ngoal (1 subgoal):\n 1. eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n     (Neg (P[t/0]))", "by simp"], ["proof (state)\nthis:\n  eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n   (Neg (P[t/0]))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = Forall P; Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "then"], ["proof (chain)\npicking this:\n  eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n   (Neg (P[t/0]))", "have \\<open>\\<exists>z. \\<not> eval (e\\<langle>0:z\\<rangle>) HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) P\\<close>"], ["proof (prove)\nusing this:\n  eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n   (Neg (P[t/0]))\n\ngoal (1 subgoal):\n 1. \\<exists>z.\n       \\<not> eval (e\\<langle>0:z\\<rangle>) HApp\n               (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) P", "by auto"], ["proof (state)\nthis:\n  \\<exists>z.\n     \\<not> eval (e\\<langle>0:z\\<rangle>) HApp\n             (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) P\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = Forall P; Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "then"], ["proof (chain)\npicking this:\n  \\<exists>z.\n     \\<not> eval (e\\<langle>0:z\\<rangle>) HApp\n             (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) P", "show \\<open>?eval (Neg x)\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>z.\n     \\<not> eval (e\\<langle>0:z\\<rangle>) HApp\n             (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) P\n\ngoal (1 subgoal):\n 1. eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) (Neg x)", "using Forall"], ["proof (prove)\nusing this:\n  \\<exists>z.\n     \\<not> eval (e\\<langle>0:z\\<rangle>) HApp\n             (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) P\n  x = Forall P\n\ngoal (1 subgoal):\n 1. eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) (Neg x)", "by simp"], ["proof (state)\nthis:\n  eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) (Neg x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (x \\<in> H \\<longrightarrow>\n   closed 0 x \\<longrightarrow>\n   eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n    x) \\<and>\n  (Neg x \\<in> H \\<longrightarrow>\n   closed 0 x \\<longrightarrow>\n   eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) (Neg x))\n\ngoal (1 subgoal):\n 1. \\<And>x9.\n       x = Exists x9 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x9.\n       x = Exists x9 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))", "case (Exists P)"], ["proof (state)\nthis:\n  x = Exists P\n\ngoal (1 subgoal):\n 1. \\<And>x9.\n       x = Exists x9 \\<Longrightarrow>\n       (x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         x) \\<and>\n       (Neg x \\<in> H \\<longrightarrow>\n        closed 0 x \\<longrightarrow>\n        eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n         (Neg x))", "then"], ["proof (chain)\npicking this:\n  x = Exists P", "show ?thesis"], ["proof (prove)\nusing this:\n  x = Exists P\n\ngoal (1 subgoal):\n 1. (x \\<in> H \\<longrightarrow>\n     closed 0 x \\<longrightarrow>\n     eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n      x) \\<and>\n    (Neg x \\<in> H \\<longrightarrow>\n     closed 0 x \\<longrightarrow>\n     eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n      (Neg x))", "proof (intro conjI impI allI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>x = Exists P; x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       x\n 2. \\<lbrakk>x = Exists P; Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "assume \\<open>x \\<in> H\\<close> and \\<open>closed 0 x\\<close>"], ["proof (state)\nthis:\n  x \\<in> H\n  closed 0 x\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x = Exists P; x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       x\n 2. \\<lbrakk>x = Exists P; Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "then"], ["proof (chain)\npicking this:\n  x \\<in> H\n  closed 0 x", "have \\<open>\\<exists>t. closedt 0 t \\<and> (P[t/0]) \\<in> H\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> H\n  closed 0 x\n\ngoal (1 subgoal):\n 1. \\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> H", "using Exists hin"], ["proof (prove)\nusing this:\n  x \\<in> H\n  closed 0 x\n  x = Exists P\n  hintikka H\n\ngoal (1 subgoal):\n 1. \\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> H", "unfolding hintikka_def"], ["proof (prove)\nusing this:\n  x \\<in> H\n  closed 0 x\n  x = Exists P\n  (\\<forall>p ts.\n      \\<not> (Pred p ts \\<in> H \\<and> Neg (Pred p ts) \\<in> H)) \\<and>\n  FF \\<notin> H \\<and>\n  Neg TT \\<notin> H \\<and>\n  (\\<forall>Z. Neg (Neg Z) \\<in> H \\<longrightarrow> Z \\<in> H) \\<and>\n  (\\<forall>A B.\n      And A B \\<in> H \\<longrightarrow> A \\<in> H \\<and> B \\<in> H) \\<and>\n  (\\<forall>A B.\n      Neg (Or A B) \\<in> H \\<longrightarrow>\n      Neg A \\<in> H \\<and> Neg B \\<in> H) \\<and>\n  (\\<forall>A B.\n      Or A B \\<in> H \\<longrightarrow> A \\<in> H \\<or> B \\<in> H) \\<and>\n  (\\<forall>A B.\n      Neg (And A B) \\<in> H \\<longrightarrow>\n      Neg A \\<in> H \\<or> Neg B \\<in> H) \\<and>\n  (\\<forall>A B.\n      Impl A B \\<in> H \\<longrightarrow>\n      Neg A \\<in> H \\<or> B \\<in> H) \\<and>\n  (\\<forall>A B.\n      Neg (Impl A B) \\<in> H \\<longrightarrow>\n      A \\<in> H \\<and> Neg B \\<in> H) \\<and>\n  (\\<forall>P t.\n      closedt 0 t \\<longrightarrow>\n      Forall P \\<in> H \\<longrightarrow> P[t/0] \\<in> H) \\<and>\n  (\\<forall>P t.\n      closedt 0 t \\<longrightarrow>\n      Neg (Exists P) \\<in> H \\<longrightarrow> Neg (P[t/0]) \\<in> H) \\<and>\n  (\\<forall>P.\n      Exists P \\<in> H \\<longrightarrow>\n      (\\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> H)) \\<and>\n  (\\<forall>P.\n      Neg (Forall P) \\<in> H \\<longrightarrow>\n      (\\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> H))\n\ngoal (1 subgoal):\n 1. \\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> H", "by blast"], ["proof (state)\nthis:\n  \\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> H\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x = Exists P; x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       x\n 2. \\<lbrakk>x = Exists P; Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "then"], ["proof (chain)\npicking this:\n  \\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> H", "obtain t where *: \\<open>closedt 0 t \\<and> (P[t/0]) \\<in> H\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> H\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        closedt 0 t \\<and> P[t/0] \\<in> H \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  closedt 0 t \\<and> P[t/0] \\<in> H\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x = Exists P; x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       x\n 2. \\<lbrakk>x = Exists P; Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "then"], ["proof (chain)\npicking this:\n  closedt 0 t \\<and> P[t/0] \\<in> H", "have \\<open>closed 0 (P[t/0])\\<close>"], ["proof (prove)\nusing this:\n  closedt 0 t \\<and> P[t/0] \\<in> H\n\ngoal (1 subgoal):\n 1. closed 0 (P[t/0])", "using Exists \\<open>closed 0 x\\<close>"], ["proof (prove)\nusing this:\n  closedt 0 t \\<and> P[t/0] \\<in> H\n  x = Exists P\n  closed 0 x\n\ngoal (1 subgoal):\n 1. closed 0 (P[t/0])", "by simp"], ["proof (state)\nthis:\n  closed 0 (P[t/0])\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x = Exists P; x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       x\n 2. \\<lbrakk>x = Exists P; Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "have \\<open>(subst P t 0, Exists P) \\<in> measure size_form \\<longrightarrow>\n              ((subst P t 0) \\<in> H \\<longrightarrow> closed 0 (subst P t 0) \\<longrightarrow>\n              ?eval (subst P t 0))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (P[t/0], Exists P) \\<in> measure FOL_Fitting.size_form \\<longrightarrow>\n    P[t/0] \\<in> H \\<longrightarrow>\n    closed 0 (P[t/0]) \\<longrightarrow>\n    eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n     (P[t/0])", "using Exists wf"], ["proof (prove)\nusing this:\n  x = Exists P\n  \\<forall>y.\n     (y, x) \\<in> measure FOL_Fitting.size_form \\<longrightarrow>\n     (y \\<in> H \\<longrightarrow>\n      closed 0 y \\<longrightarrow>\n      eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n       y) \\<and>\n     (Neg y \\<in> H \\<longrightarrow>\n      closed 0 y \\<longrightarrow>\n      eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n       (Neg y))\n\ngoal (1 subgoal):\n 1. (P[t/0], Exists P) \\<in> measure FOL_Fitting.size_form \\<longrightarrow>\n    P[t/0] \\<in> H \\<longrightarrow>\n    closed 0 (P[t/0]) \\<longrightarrow>\n    eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n     (P[t/0])", "by blast"], ["proof (state)\nthis:\n  (P[t/0], Exists P) \\<in> measure FOL_Fitting.size_form \\<longrightarrow>\n  P[t/0] \\<in> H \\<longrightarrow>\n  closed 0 (P[t/0]) \\<longrightarrow>\n  eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) (P[t/0])\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x = Exists P; x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       x\n 2. \\<lbrakk>x = Exists P; Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "then"], ["proof (chain)\npicking this:\n  (P[t/0], Exists P) \\<in> measure FOL_Fitting.size_form \\<longrightarrow>\n  P[t/0] \\<in> H \\<longrightarrow>\n  closed 0 (P[t/0]) \\<longrightarrow>\n  eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) (P[t/0])", "have \\<open>?eval (P[t/0])\\<close>"], ["proof (prove)\nusing this:\n  (P[t/0], Exists P) \\<in> measure FOL_Fitting.size_form \\<longrightarrow>\n  P[t/0] \\<in> H \\<longrightarrow>\n  closed 0 (P[t/0]) \\<longrightarrow>\n  eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) (P[t/0])\n\ngoal (1 subgoal):\n 1. eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n     (P[t/0])", "using Exists * \\<open>closed 0 (P[t/0])\\<close>"], ["proof (prove)\nusing this:\n  (P[t/0], Exists P) \\<in> measure FOL_Fitting.size_form \\<longrightarrow>\n  P[t/0] \\<in> H \\<longrightarrow>\n  closed 0 (P[t/0]) \\<longrightarrow>\n  eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) (P[t/0])\n  x = Exists P\n  closedt 0 t \\<and> P[t/0] \\<in> H\n  closed 0 (P[t/0])\n\ngoal (1 subgoal):\n 1. eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n     (P[t/0])", "by simp"], ["proof (state)\nthis:\n  eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) (P[t/0])\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x = Exists P; x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       x\n 2. \\<lbrakk>x = Exists P; Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "then"], ["proof (chain)\npicking this:\n  eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) (P[t/0])", "have \\<open>\\<exists>z. eval (e\\<langle>0:z\\<rangle>) HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) P\\<close>"], ["proof (prove)\nusing this:\n  eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) (P[t/0])\n\ngoal (1 subgoal):\n 1. \\<exists>z.\n       eval (e\\<langle>0:z\\<rangle>) HApp\n        (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) P", "by auto"], ["proof (state)\nthis:\n  \\<exists>z.\n     eval (e\\<langle>0:z\\<rangle>) HApp\n      (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) P\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x = Exists P; x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       x\n 2. \\<lbrakk>x = Exists P; Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "then"], ["proof (chain)\npicking this:\n  \\<exists>z.\n     eval (e\\<langle>0:z\\<rangle>) HApp\n      (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) P", "show \\<open>?eval x\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>z.\n     eval (e\\<langle>0:z\\<rangle>) HApp\n      (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) P\n\ngoal (1 subgoal):\n 1. eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) x", "using Exists"], ["proof (prove)\nusing this:\n  \\<exists>z.\n     eval (e\\<langle>0:z\\<rangle>) HApp\n      (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) P\n  x = Exists P\n\ngoal (1 subgoal):\n 1. eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) x", "by simp"], ["proof (state)\nthis:\n  eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = Exists P; Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = Exists P; Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "assume \\<open>Neg x \\<in> H\\<close> and \\<open>closed 0 x\\<close>"], ["proof (state)\nthis:\n  Neg x \\<in> H\n  closed 0 x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = Exists P; Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "have \\<open>\\<forall>z. \\<not> eval (e\\<langle>0:z\\<rangle>) HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) P\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>z.\n       \\<not> eval (e\\<langle>0:z\\<rangle>) HApp\n               (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) P", "proof (rule allI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<not> eval (e\\<langle>0:z\\<rangle>) HApp\n               (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) P", "fix z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<not> eval (e\\<langle>0:z\\<rangle>) HApp\n               (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) P", "from \\<open>Neg x \\<in> H\\<close> and \\<open>closed 0 x\\<close>"], ["proof (chain)\npicking this:\n  Neg x \\<in> H\n  closed 0 x", "have \\<open>Neg (Exists P) \\<in> H\\<close> and \\<open>closed 0 (Neg (Exists P))\\<close>"], ["proof (prove)\nusing this:\n  Neg x \\<in> H\n  closed 0 x\n\ngoal (1 subgoal):\n 1. Neg (Exists P) \\<in> H &&& closed 0 (Neg (Exists P))", "using Exists"], ["proof (prove)\nusing this:\n  Neg x \\<in> H\n  closed 0 x\n  x = Exists P\n\ngoal (1 subgoal):\n 1. Neg (Exists P) \\<in> H &&& closed 0 (Neg (Exists P))", "by simp_all"], ["proof (state)\nthis:\n  Neg (Exists P) \\<in> H\n  closed 0 (Neg (Exists P))\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<not> eval (e\\<langle>0:z\\<rangle>) HApp\n               (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) P", "then"], ["proof (chain)\npicking this:\n  Neg (Exists P) \\<in> H\n  closed 0 (Neg (Exists P))", "have *: \\<open>\\<forall>P t. closedt 0 t \\<longrightarrow> Neg (Exists P) \\<in> H \\<longrightarrow> Neg (P[t/0]) \\<in> H\\<close>"], ["proof (prove)\nusing this:\n  Neg (Exists P) \\<in> H\n  closed 0 (Neg (Exists P))\n\ngoal (1 subgoal):\n 1. \\<forall>P t.\n       closedt 0 t \\<longrightarrow>\n       Neg (Exists P) \\<in> H \\<longrightarrow> Neg (P[t/0]) \\<in> H", "using hin"], ["proof (prove)\nusing this:\n  Neg (Exists P) \\<in> H\n  closed 0 (Neg (Exists P))\n  hintikka H\n\ngoal (1 subgoal):\n 1. \\<forall>P t.\n       closedt 0 t \\<longrightarrow>\n       Neg (Exists P) \\<in> H \\<longrightarrow> Neg (P[t/0]) \\<in> H", "unfolding hintikka_def"], ["proof (prove)\nusing this:\n  Neg (Exists P) \\<in> H\n  closed 0 (Neg (Exists P))\n  (\\<forall>p ts.\n      \\<not> (Pred p ts \\<in> H \\<and> Neg (Pred p ts) \\<in> H)) \\<and>\n  FF \\<notin> H \\<and>\n  Neg TT \\<notin> H \\<and>\n  (\\<forall>Z. Neg (Neg Z) \\<in> H \\<longrightarrow> Z \\<in> H) \\<and>\n  (\\<forall>A B.\n      And A B \\<in> H \\<longrightarrow> A \\<in> H \\<and> B \\<in> H) \\<and>\n  (\\<forall>A B.\n      Neg (Or A B) \\<in> H \\<longrightarrow>\n      Neg A \\<in> H \\<and> Neg B \\<in> H) \\<and>\n  (\\<forall>A B.\n      Or A B \\<in> H \\<longrightarrow> A \\<in> H \\<or> B \\<in> H) \\<and>\n  (\\<forall>A B.\n      Neg (And A B) \\<in> H \\<longrightarrow>\n      Neg A \\<in> H \\<or> Neg B \\<in> H) \\<and>\n  (\\<forall>A B.\n      Impl A B \\<in> H \\<longrightarrow>\n      Neg A \\<in> H \\<or> B \\<in> H) \\<and>\n  (\\<forall>A B.\n      Neg (Impl A B) \\<in> H \\<longrightarrow>\n      A \\<in> H \\<and> Neg B \\<in> H) \\<and>\n  (\\<forall>P t.\n      closedt 0 t \\<longrightarrow>\n      Forall P \\<in> H \\<longrightarrow> P[t/0] \\<in> H) \\<and>\n  (\\<forall>P t.\n      closedt 0 t \\<longrightarrow>\n      Neg (Exists P) \\<in> H \\<longrightarrow> Neg (P[t/0]) \\<in> H) \\<and>\n  (\\<forall>P.\n      Exists P \\<in> H \\<longrightarrow>\n      (\\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> H)) \\<and>\n  (\\<forall>P.\n      Neg (Forall P) \\<in> H \\<longrightarrow>\n      (\\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> H))\n\ngoal (1 subgoal):\n 1. \\<forall>P t.\n       closedt 0 t \\<longrightarrow>\n       Neg (Exists P) \\<in> H \\<longrightarrow> Neg (P[t/0]) \\<in> H", "by blast"], ["proof (state)\nthis:\n  \\<forall>P t.\n     closedt 0 t \\<longrightarrow>\n     Neg (Exists P) \\<in> H \\<longrightarrow> Neg (P[t/0]) \\<in> H\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<not> eval (e\\<langle>0:z\\<rangle>) HApp\n               (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) P", "from \\<open>closed 0 (Neg (Exists P))\\<close>"], ["proof (chain)\npicking this:\n  closed 0 (Neg (Exists P))", "have \\<open>closed (Suc 0) P\\<close>"], ["proof (prove)\nusing this:\n  closed 0 (Neg (Exists P))\n\ngoal (1 subgoal):\n 1. closed (Suc 0) P", "by simp"], ["proof (state)\nthis:\n  closed (Suc 0) P\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<not> eval (e\\<langle>0:z\\<rangle>) HApp\n               (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) P", "have \\<open>(P[term_of_hterm z/0], Exists P) \\<in> measure size_form \\<longrightarrow>\n              (Neg (P[term_of_hterm z/0]) \\<in> H \\<longrightarrow> closed 0 (P[term_of_hterm z/0]) \\<longrightarrow>\n              ?eval (Neg (P[term_of_hterm z/0])))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (P[term_of_hterm z/0], Exists P)\n    \\<in> measure FOL_Fitting.size_form \\<longrightarrow>\n    Neg (P[term_of_hterm z/0]) \\<in> H \\<longrightarrow>\n    closed 0 (P[term_of_hterm z/0]) \\<longrightarrow>\n    eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n     (Neg (P[term_of_hterm z/0]))", "using Exists wf"], ["proof (prove)\nusing this:\n  x = Exists P\n  \\<forall>y.\n     (y, x) \\<in> measure FOL_Fitting.size_form \\<longrightarrow>\n     (y \\<in> H \\<longrightarrow>\n      closed 0 y \\<longrightarrow>\n      eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n       y) \\<and>\n     (Neg y \\<in> H \\<longrightarrow>\n      closed 0 y \\<longrightarrow>\n      eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n       (Neg y))\n\ngoal (1 subgoal):\n 1. (P[term_of_hterm z/0], Exists P)\n    \\<in> measure FOL_Fitting.size_form \\<longrightarrow>\n    Neg (P[term_of_hterm z/0]) \\<in> H \\<longrightarrow>\n    closed 0 (P[term_of_hterm z/0]) \\<longrightarrow>\n    eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n     (Neg (P[term_of_hterm z/0]))", "by blast"], ["proof (state)\nthis:\n  (P[term_of_hterm z/0], Exists P)\n  \\<in> measure FOL_Fitting.size_form \\<longrightarrow>\n  Neg (P[term_of_hterm z/0]) \\<in> H \\<longrightarrow>\n  closed 0 (P[term_of_hterm z/0]) \\<longrightarrow>\n  eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n   (Neg (P[term_of_hterm z/0]))\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<not> eval (e\\<langle>0:z\\<rangle>) HApp\n               (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) P", "then"], ["proof (chain)\npicking this:\n  (P[term_of_hterm z/0], Exists P)\n  \\<in> measure FOL_Fitting.size_form \\<longrightarrow>\n  Neg (P[term_of_hterm z/0]) \\<in> H \\<longrightarrow>\n  closed 0 (P[term_of_hterm z/0]) \\<longrightarrow>\n  eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n   (Neg (P[term_of_hterm z/0]))", "show \\<open>\\<not> eval (e\\<langle>0:z\\<rangle>) HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) P\\<close>"], ["proof (prove)\nusing this:\n  (P[term_of_hterm z/0], Exists P)\n  \\<in> measure FOL_Fitting.size_form \\<longrightarrow>\n  Neg (P[term_of_hterm z/0]) \\<in> H \\<longrightarrow>\n  closed 0 (P[term_of_hterm z/0]) \\<longrightarrow>\n  eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n   (Neg (P[term_of_hterm z/0]))\n\ngoal (1 subgoal):\n 1. \\<not> eval (e\\<langle>0:z\\<rangle>) HApp\n            (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) P", "using * \\<open>Neg (Exists P) \\<in> H\\<close> \\<open>closed (Suc 0) P\\<close>"], ["proof (prove)\nusing this:\n  (P[term_of_hterm z/0], Exists P)\n  \\<in> measure FOL_Fitting.size_form \\<longrightarrow>\n  Neg (P[term_of_hterm z/0]) \\<in> H \\<longrightarrow>\n  closed 0 (P[term_of_hterm z/0]) \\<longrightarrow>\n  eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n   (Neg (P[term_of_hterm z/0]))\n  \\<forall>P t.\n     closedt 0 t \\<longrightarrow>\n     Neg (Exists P) \\<in> H \\<longrightarrow> Neg (P[t/0]) \\<in> H\n  Neg (Exists P) \\<in> H\n  closed (Suc 0) P\n\ngoal (1 subgoal):\n 1. \\<not> eval (e\\<langle>0:z\\<rangle>) HApp\n            (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) P", "by simp"], ["proof (state)\nthis:\n  \\<not> eval (e\\<langle>0:z\\<rangle>) HApp\n          (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>z.\n     \\<not> eval (e\\<langle>0:z\\<rangle>) HApp\n             (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) P\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = Exists P; Neg x \\<in> H; closed 0 x\\<rbrakk>\n    \\<Longrightarrow> eval e HApp\n                       (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n                       (Neg x)", "then"], ["proof (chain)\npicking this:\n  \\<forall>z.\n     \\<not> eval (e\\<langle>0:z\\<rangle>) HApp\n             (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) P", "show \\<open>?eval (Neg x)\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>z.\n     \\<not> eval (e\\<langle>0:z\\<rangle>) HApp\n             (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) P\n\ngoal (1 subgoal):\n 1. eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) (Neg x)", "using Exists"], ["proof (prove)\nusing this:\n  \\<forall>z.\n     \\<not> eval (e\\<langle>0:z\\<rangle>) HApp\n             (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) P\n  x = Exists P\n\ngoal (1 subgoal):\n 1. eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) (Neg x)", "by simp"], ["proof (state)\nthis:\n  eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) (Neg x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (x \\<in> H \\<longrightarrow>\n   closed 0 x \\<longrightarrow>\n   eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n    x) \\<and>\n  (Neg x \\<in> H \\<longrightarrow>\n   closed 0 x \\<longrightarrow>\n   eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) (Neg x))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (x \\<in> H \\<longrightarrow>\n   closed 0 x \\<longrightarrow>\n   eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H)\n    x) \\<and>\n  (Neg x \\<in> H \\<longrightarrow>\n   closed 0 x \\<longrightarrow>\n   eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> H) (Neg x))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nUsing the maximality of @{term \\<open>Extend S C f\\<close>}, we can show\nthat @{term \\<open>Extend S C f\\<close>} yields Hintikka sets:\n\\<close>"], ["", "lemma Exists_in_extend:\n  assumes \\<open>extend S C f n \\<union> {f n} \\<in> C\\<close> (is \\<open>?S' \\<in> C\\<close>)\n    and \\<open>Exists P = f n\\<close>\n  shows \\<open>P[(App (SOME k. k \\<notin> (\\<Union>p \\<in> extend S C f n \\<union> {f n}. params p)) [])/0] \\<in>\n          extend S C f (Suc n)\\<close>\n    (is \\<open>subst P ?t 0 \\<in> extend S C f (Suc n)\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P[App (SOME k.\n              k \\<notin> \\<Union>\n                          (params ` (extend S C f n \\<union> {f n})))\n       []/0]\n    \\<in> extend S C f (Suc n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P[App (SOME k.\n              k \\<notin> \\<Union>\n                          (params ` (extend S C f n \\<union> {f n})))\n       []/0]\n    \\<in> extend S C f (Suc n)", "have \\<open>\\<exists>p. f n = Exists p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p. f n = Exists p", "using \\<open>Exists P = f n\\<close>"], ["proof (prove)\nusing this:\n  Exists P = f n\n\ngoal (1 subgoal):\n 1. \\<exists>p. f n = Exists p", "by metis"], ["proof (state)\nthis:\n  \\<exists>p. f n = Exists p\n\ngoal (1 subgoal):\n 1. P[App (SOME k.\n              k \\<notin> \\<Union>\n                          (params ` (extend S C f n \\<union> {f n})))\n       []/0]\n    \\<in> extend S C f (Suc n)", "then"], ["proof (chain)\npicking this:\n  \\<exists>p. f n = Exists p", "have \\<open>extend S C f (Suc n) = (?S' \\<union> {(dest_Exists (f n))[?t/0]})\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>p. f n = Exists p\n\ngoal (1 subgoal):\n 1. extend S C f (Suc n) =\n    extend S C f n \\<union> {f n} \\<union>\n    {dest_Exists\n      (f n)[App (SOME k.\n                    k \\<notin> \\<Union>\n                                (params ` (extend S C f n \\<union> {f n})))\n             []/0]}", "using \\<open>?S' \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>p. f n = Exists p\n  extend S C f n \\<union> {f n} \\<in> C\n\ngoal (1 subgoal):\n 1. extend S C f (Suc n) =\n    extend S C f n \\<union> {f n} \\<union>\n    {dest_Exists\n      (f n)[App (SOME k.\n                    k \\<notin> \\<Union>\n                                (params ` (extend S C f n \\<union> {f n})))\n             []/0]}", "by simp"], ["proof (state)\nthis:\n  extend S C f (Suc n) =\n  extend S C f n \\<union> {f n} \\<union>\n  {dest_Exists\n    (f n)[App (SOME k.\n                  k \\<notin> \\<Union>\n                              (params ` (extend S C f n \\<union> {f n})))\n           []/0]}\n\ngoal (1 subgoal):\n 1. P[App (SOME k.\n              k \\<notin> \\<Union>\n                          (params ` (extend S C f n \\<union> {f n})))\n       []/0]\n    \\<in> extend S C f (Suc n)", "also"], ["proof (state)\nthis:\n  extend S C f (Suc n) =\n  extend S C f n \\<union> {f n} \\<union>\n  {dest_Exists\n    (f n)[App (SOME k.\n                  k \\<notin> \\<Union>\n                              (params ` (extend S C f n \\<union> {f n})))\n           []/0]}\n\ngoal (1 subgoal):\n 1. P[App (SOME k.\n              k \\<notin> \\<Union>\n                          (params ` (extend S C f n \\<union> {f n})))\n       []/0]\n    \\<in> extend S C f (Suc n)", "have \\<open>\\<dots> = (?S' \\<union> {(dest_Exists (Exists P))[?t/0]})\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. extend S C f n \\<union> {f n} \\<union>\n    {dest_Exists\n      (f n)[App (SOME k.\n                    k \\<notin> \\<Union>\n                                (params ` (extend S C f n \\<union> {f n})))\n             []/0]} =\n    extend S C f n \\<union> {f n} \\<union>\n    {dest_Exists\n      (Exists\n        P)[App (SOME k.\n                   k \\<notin> \\<Union>\n                               (params ` (extend S C f n \\<union> {f n})))\n            []/0]}", "using \\<open>Exists P = f n\\<close>"], ["proof (prove)\nusing this:\n  Exists P = f n\n\ngoal (1 subgoal):\n 1. extend S C f n \\<union> {f n} \\<union>\n    {dest_Exists\n      (f n)[App (SOME k.\n                    k \\<notin> \\<Union>\n                                (params ` (extend S C f n \\<union> {f n})))\n             []/0]} =\n    extend S C f n \\<union> {f n} \\<union>\n    {dest_Exists\n      (Exists\n        P)[App (SOME k.\n                   k \\<notin> \\<Union>\n                               (params ` (extend S C f n \\<union> {f n})))\n            []/0]}", "by simp"], ["proof (state)\nthis:\n  extend S C f n \\<union> {f n} \\<union>\n  {dest_Exists\n    (f n)[App (SOME k.\n                  k \\<notin> \\<Union>\n                              (params ` (extend S C f n \\<union> {f n})))\n           []/0]} =\n  extend S C f n \\<union> {f n} \\<union>\n  {dest_Exists\n    (Exists\n      P)[App (SOME k.\n                 k \\<notin> \\<Union>\n                             (params ` (extend S C f n \\<union> {f n})))\n          []/0]}\n\ngoal (1 subgoal):\n 1. P[App (SOME k.\n              k \\<notin> \\<Union>\n                          (params ` (extend S C f n \\<union> {f n})))\n       []/0]\n    \\<in> extend S C f (Suc n)", "also"], ["proof (state)\nthis:\n  extend S C f n \\<union> {f n} \\<union>\n  {dest_Exists\n    (f n)[App (SOME k.\n                  k \\<notin> \\<Union>\n                              (params ` (extend S C f n \\<union> {f n})))\n           []/0]} =\n  extend S C f n \\<union> {f n} \\<union>\n  {dest_Exists\n    (Exists\n      P)[App (SOME k.\n                 k \\<notin> \\<Union>\n                             (params ` (extend S C f n \\<union> {f n})))\n          []/0]}\n\ngoal (1 subgoal):\n 1. P[App (SOME k.\n              k \\<notin> \\<Union>\n                          (params ` (extend S C f n \\<union> {f n})))\n       []/0]\n    \\<in> extend S C f (Suc n)", "have \\<open>\\<dots> = (?S' \\<union> {P[?t/0]})\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. extend S C f n \\<union> {f n} \\<union>\n    {dest_Exists\n      (Exists\n        P)[App (SOME k.\n                   k \\<notin> \\<Union>\n                               (params ` (extend S C f n \\<union> {f n})))\n            []/0]} =\n    extend S C f n \\<union> {f n} \\<union>\n    {P[App (SOME k.\n               k \\<notin> \\<Union>\n                           (params ` (extend S C f n \\<union> {f n})))\n        []/0]}", "by simp"], ["proof (state)\nthis:\n  extend S C f n \\<union> {f n} \\<union>\n  {dest_Exists\n    (Exists\n      P)[App (SOME k.\n                 k \\<notin> \\<Union>\n                             (params ` (extend S C f n \\<union> {f n})))\n          []/0]} =\n  extend S C f n \\<union> {f n} \\<union>\n  {P[App (SOME k.\n             k \\<notin> \\<Union> (params ` (extend S C f n \\<union> {f n})))\n      []/0]}\n\ngoal (1 subgoal):\n 1. P[App (SOME k.\n              k \\<notin> \\<Union>\n                          (params ` (extend S C f n \\<union> {f n})))\n       []/0]\n    \\<in> extend S C f (Suc n)", "finally"], ["proof (chain)\npicking this:\n  extend S C f (Suc n) =\n  extend S C f n \\<union> {f n} \\<union>\n  {P[App (SOME k.\n             k \\<notin> \\<Union> (params ` (extend S C f n \\<union> {f n})))\n      []/0]}", "show ?thesis"], ["proof (prove)\nusing this:\n  extend S C f (Suc n) =\n  extend S C f n \\<union> {f n} \\<union>\n  {P[App (SOME k.\n             k \\<notin> \\<Union> (params ` (extend S C f n \\<union> {f n})))\n      []/0]}\n\ngoal (1 subgoal):\n 1. P[App (SOME k.\n              k \\<notin> \\<Union>\n                          (params ` (extend S C f n \\<union> {f n})))\n       []/0]\n    \\<in> extend S C f (Suc n)", "by blast"], ["proof (state)\nthis:\n  P[App (SOME k.\n            k \\<notin> \\<Union> (params ` (extend S C f n \\<union> {f n})))\n     []/0]\n  \\<in> extend S C f (Suc n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Neg_Forall_in_extend:\n  assumes \\<open>extend S C f n \\<union> {f n} \\<in> C\\<close> (is \\<open>?S' \\<in> C\\<close>)\n    and \\<open>Neg (Forall P) = f n\\<close>\n  shows \\<open>Neg (P[(App (SOME k. k \\<notin> (\\<Union>p \\<in> extend S C f n \\<union> {f n}. params p)) [])/0])  \\<in>\n          extend S C f (Suc n)\\<close>\n    (is \\<open>Neg (subst P ?t 0) \\<in> extend S C f (Suc n)\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Neg (P[App (SOME k.\n                   k \\<notin> \\<Union>\n                               (params ` (extend S C f n \\<union> {f n})))\n            []/0])\n    \\<in> extend S C f (Suc n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Neg (P[App (SOME k.\n                   k \\<notin> \\<Union>\n                               (params ` (extend S C f n \\<union> {f n})))\n            []/0])\n    \\<in> extend S C f (Suc n)", "have \\<open>f n \\<noteq> Exists P\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. f n \\<noteq> Exists P", "using \\<open>Neg (Forall P) = f n\\<close>"], ["proof (prove)\nusing this:\n  Neg (Forall P) = f n\n\ngoal (1 subgoal):\n 1. f n \\<noteq> Exists P", "by auto"], ["proof (state)\nthis:\n  f n \\<noteq> Exists P\n\ngoal (1 subgoal):\n 1. Neg (P[App (SOME k.\n                   k \\<notin> \\<Union>\n                               (params ` (extend S C f n \\<union> {f n})))\n            []/0])\n    \\<in> extend S C f (Suc n)", "have \\<open>\\<exists>p. f n = Neg (Forall p)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p. f n = Neg (Forall p)", "using \\<open>Neg (Forall P) = f n\\<close>"], ["proof (prove)\nusing this:\n  Neg (Forall P) = f n\n\ngoal (1 subgoal):\n 1. \\<exists>p. f n = Neg (Forall p)", "by metis"], ["proof (state)\nthis:\n  \\<exists>p. f n = Neg (Forall p)\n\ngoal (1 subgoal):\n 1. Neg (P[App (SOME k.\n                   k \\<notin> \\<Union>\n                               (params ` (extend S C f n \\<union> {f n})))\n            []/0])\n    \\<in> extend S C f (Suc n)", "then"], ["proof (chain)\npicking this:\n  \\<exists>p. f n = Neg (Forall p)", "have \\<open>extend S C f (Suc n) = (?S' \\<union> {Neg (dest_Forall (dest_Neg (f n))[?t/0])})\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>p. f n = Neg (Forall p)\n\ngoal (1 subgoal):\n 1. extend S C f (Suc n) =\n    extend S C f n \\<union> {f n} \\<union>\n    {Neg (dest_Forall\n           (dest_Neg\n             (f n))[App (SOME k.\n                            k \\<notin> \\<Union>\n  (params ` (extend S C f n \\<union> {f n})))\n                     []/0])}", "using \\<open>?S' \\<in> C\\<close> \\<open>f n \\<noteq> Exists P\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>p. f n = Neg (Forall p)\n  extend S C f n \\<union> {f n} \\<in> C\n  f n \\<noteq> Exists P\n\ngoal (1 subgoal):\n 1. extend S C f (Suc n) =\n    extend S C f n \\<union> {f n} \\<union>\n    {Neg (dest_Forall\n           (dest_Neg\n             (f n))[App (SOME k.\n                            k \\<notin> \\<Union>\n  (params ` (extend S C f n \\<union> {f n})))\n                     []/0])}", "by auto"], ["proof (state)\nthis:\n  extend S C f (Suc n) =\n  extend S C f n \\<union> {f n} \\<union>\n  {Neg (dest_Forall\n         (dest_Neg\n           (f n))[App (SOME k.\n                          k \\<notin> \\<Union>\n(params ` (extend S C f n \\<union> {f n})))\n                   []/0])}\n\ngoal (1 subgoal):\n 1. Neg (P[App (SOME k.\n                   k \\<notin> \\<Union>\n                               (params ` (extend S C f n \\<union> {f n})))\n            []/0])\n    \\<in> extend S C f (Suc n)", "also"], ["proof (state)\nthis:\n  extend S C f (Suc n) =\n  extend S C f n \\<union> {f n} \\<union>\n  {Neg (dest_Forall\n         (dest_Neg\n           (f n))[App (SOME k.\n                          k \\<notin> \\<Union>\n(params ` (extend S C f n \\<union> {f n})))\n                   []/0])}\n\ngoal (1 subgoal):\n 1. Neg (P[App (SOME k.\n                   k \\<notin> \\<Union>\n                               (params ` (extend S C f n \\<union> {f n})))\n            []/0])\n    \\<in> extend S C f (Suc n)", "have \\<open>\\<dots> = (?S' \\<union> {Neg (dest_Forall (dest_Neg (Neg (Forall P)))[?t/0])})\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. extend S C f n \\<union> {f n} \\<union>\n    {Neg (dest_Forall\n           (dest_Neg\n             (f n))[App (SOME k.\n                            k \\<notin> \\<Union>\n  (params ` (extend S C f n \\<union> {f n})))\n                     []/0])} =\n    extend S C f n \\<union> {f n} \\<union>\n    {Neg (dest_Forall\n           (dest_Neg\n             (Neg (Forall\n                    P)))[App (SOME k.\n                                 k \\<notin> \\<Union>\n       (params ` (extend S C f n \\<union> {f n})))\n                          []/0])}", "using \\<open>Neg (Forall P) = f n\\<close>"], ["proof (prove)\nusing this:\n  Neg (Forall P) = f n\n\ngoal (1 subgoal):\n 1. extend S C f n \\<union> {f n} \\<union>\n    {Neg (dest_Forall\n           (dest_Neg\n             (f n))[App (SOME k.\n                            k \\<notin> \\<Union>\n  (params ` (extend S C f n \\<union> {f n})))\n                     []/0])} =\n    extend S C f n \\<union> {f n} \\<union>\n    {Neg (dest_Forall\n           (dest_Neg\n             (Neg (Forall\n                    P)))[App (SOME k.\n                                 k \\<notin> \\<Union>\n       (params ` (extend S C f n \\<union> {f n})))\n                          []/0])}", "by simp"], ["proof (state)\nthis:\n  extend S C f n \\<union> {f n} \\<union>\n  {Neg (dest_Forall\n         (dest_Neg\n           (f n))[App (SOME k.\n                          k \\<notin> \\<Union>\n(params ` (extend S C f n \\<union> {f n})))\n                   []/0])} =\n  extend S C f n \\<union> {f n} \\<union>\n  {Neg (dest_Forall\n         (dest_Neg\n           (Neg (Forall\n                  P)))[App (SOME k.\n                               k \\<notin> \\<Union>\n     (params ` (extend S C f n \\<union> {f n})))\n                        []/0])}\n\ngoal (1 subgoal):\n 1. Neg (P[App (SOME k.\n                   k \\<notin> \\<Union>\n                               (params ` (extend S C f n \\<union> {f n})))\n            []/0])\n    \\<in> extend S C f (Suc n)", "also"], ["proof (state)\nthis:\n  extend S C f n \\<union> {f n} \\<union>\n  {Neg (dest_Forall\n         (dest_Neg\n           (f n))[App (SOME k.\n                          k \\<notin> \\<Union>\n(params ` (extend S C f n \\<union> {f n})))\n                   []/0])} =\n  extend S C f n \\<union> {f n} \\<union>\n  {Neg (dest_Forall\n         (dest_Neg\n           (Neg (Forall\n                  P)))[App (SOME k.\n                               k \\<notin> \\<Union>\n     (params ` (extend S C f n \\<union> {f n})))\n                        []/0])}\n\ngoal (1 subgoal):\n 1. Neg (P[App (SOME k.\n                   k \\<notin> \\<Union>\n                               (params ` (extend S C f n \\<union> {f n})))\n            []/0])\n    \\<in> extend S C f (Suc n)", "have \\<open>\\<dots> = (?S' \\<union> {Neg (P[?t/0])})\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. extend S C f n \\<union> {f n} \\<union>\n    {Neg (dest_Forall\n           (dest_Neg\n             (Neg (Forall\n                    P)))[App (SOME k.\n                                 k \\<notin> \\<Union>\n       (params ` (extend S C f n \\<union> {f n})))\n                          []/0])} =\n    extend S C f n \\<union> {f n} \\<union>\n    {Neg (P[App (SOME k.\n                    k \\<notin> \\<Union>\n                                (params ` (extend S C f n \\<union> {f n})))\n             []/0])}", "by simp"], ["proof (state)\nthis:\n  extend S C f n \\<union> {f n} \\<union>\n  {Neg (dest_Forall\n         (dest_Neg\n           (Neg (Forall\n                  P)))[App (SOME k.\n                               k \\<notin> \\<Union>\n     (params ` (extend S C f n \\<union> {f n})))\n                        []/0])} =\n  extend S C f n \\<union> {f n} \\<union>\n  {Neg (P[App (SOME k.\n                  k \\<notin> \\<Union>\n                              (params ` (extend S C f n \\<union> {f n})))\n           []/0])}\n\ngoal (1 subgoal):\n 1. Neg (P[App (SOME k.\n                   k \\<notin> \\<Union>\n                               (params ` (extend S C f n \\<union> {f n})))\n            []/0])\n    \\<in> extend S C f (Suc n)", "finally"], ["proof (chain)\npicking this:\n  extend S C f (Suc n) =\n  extend S C f n \\<union> {f n} \\<union>\n  {Neg (P[App (SOME k.\n                  k \\<notin> \\<Union>\n                              (params ` (extend S C f n \\<union> {f n})))\n           []/0])}", "show ?thesis"], ["proof (prove)\nusing this:\n  extend S C f (Suc n) =\n  extend S C f n \\<union> {f n} \\<union>\n  {Neg (P[App (SOME k.\n                  k \\<notin> \\<Union>\n                              (params ` (extend S C f n \\<union> {f n})))\n           []/0])}\n\ngoal (1 subgoal):\n 1. Neg (P[App (SOME k.\n                   k \\<notin> \\<Union>\n                               (params ` (extend S C f n \\<union> {f n})))\n            []/0])\n    \\<in> extend S C f (Suc n)", "by blast"], ["proof (state)\nthis:\n  Neg (P[App (SOME k.\n                 k \\<notin> \\<Union>\n                             (params ` (extend S C f n \\<union> {f n})))\n          []/0])\n  \\<in> extend S C f (Suc n)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem extend_hintikka:\n  assumes fin_ch: \\<open>finite_char C\\<close>\n    and infin_p: \\<open>infinite (- (\\<Union>p \\<in> S. params p))\\<close>\n    and surj: \\<open>\\<forall>y. \\<exists>n. y = f n\\<close>\n    and altc: \\<open>alt_consistency C\\<close>\n    and \\<open>S \\<in> C\\<close>\n  shows \\<open>hintikka (Extend S C f)\\<close> (is \\<open>hintikka ?H\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. hintikka (Extend S C f)", "unfolding hintikka_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>p ts.\n        \\<not> (Pred p ts \\<in> Extend S C f \\<and>\n                Neg (Pred p ts) \\<in> Extend S C f)) \\<and>\n    FF \\<notin> Extend S C f \\<and>\n    Neg TT \\<notin> Extend S C f \\<and>\n    (\\<forall>Z.\n        Neg (Neg Z) \\<in> Extend S C f \\<longrightarrow>\n        Z \\<in> Extend S C f) \\<and>\n    (\\<forall>A B.\n        And A B \\<in> Extend S C f \\<longrightarrow>\n        A \\<in> Extend S C f \\<and> B \\<in> Extend S C f) \\<and>\n    (\\<forall>A B.\n        Neg (Or A B) \\<in> Extend S C f \\<longrightarrow>\n        Neg A \\<in> Extend S C f \\<and> Neg B \\<in> Extend S C f) \\<and>\n    (\\<forall>A B.\n        Or A B \\<in> Extend S C f \\<longrightarrow>\n        A \\<in> Extend S C f \\<or> B \\<in> Extend S C f) \\<and>\n    (\\<forall>A B.\n        Neg (And A B) \\<in> Extend S C f \\<longrightarrow>\n        Neg A \\<in> Extend S C f \\<or> Neg B \\<in> Extend S C f) \\<and>\n    (\\<forall>A B.\n        Impl A B \\<in> Extend S C f \\<longrightarrow>\n        Neg A \\<in> Extend S C f \\<or> B \\<in> Extend S C f) \\<and>\n    (\\<forall>A B.\n        Neg (Impl A B) \\<in> Extend S C f \\<longrightarrow>\n        A \\<in> Extend S C f \\<and> Neg B \\<in> Extend S C f) \\<and>\n    (\\<forall>P t.\n        closedt 0 t \\<longrightarrow>\n        Forall P \\<in> Extend S C f \\<longrightarrow>\n        P[t/0] \\<in> Extend S C f) \\<and>\n    (\\<forall>P t.\n        closedt 0 t \\<longrightarrow>\n        Neg (Exists P) \\<in> Extend S C f \\<longrightarrow>\n        Neg (P[t/0]) \\<in> Extend S C f) \\<and>\n    (\\<forall>P.\n        Exists P \\<in> Extend S C f \\<longrightarrow>\n        (\\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> Extend S C f)) \\<and>\n    (\\<forall>P.\n        Neg (Forall P) \\<in> Extend S C f \\<longrightarrow>\n        (\\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> Extend S C f))", "proof (intro allI impI conjI)"], ["proof (state)\ngoal (17 subgoals):\n 1. \\<And>p ts.\n       \\<not> (Pred p ts \\<in> Extend S C f \\<and>\n               Neg (Pred p ts) \\<in> Extend S C f)\n 2. FF \\<notin> Extend S C f\n 3. Neg TT \\<notin> Extend S C f\n 4. \\<And>Z.\n       Neg (Neg Z) \\<in> Extend S C f \\<Longrightarrow> Z \\<in> Extend S C f\n 5. \\<And>A B.\n       And A B \\<in> Extend S C f \\<Longrightarrow> A \\<in> Extend S C f\n 6. \\<And>A B.\n       And A B \\<in> Extend S C f \\<Longrightarrow> B \\<in> Extend S C f\n 7. \\<And>A B.\n       Neg (Or A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f\n 8. \\<And>A B.\n       Neg (Or A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg B \\<in> Extend S C f\n 9. \\<And>A B.\n       Or A B \\<in> Extend S C f \\<Longrightarrow>\n       A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 10. \\<And>A B.\n        Neg (And A B) \\<in> Extend S C f \\<Longrightarrow>\n        Neg A \\<in> Extend S C f \\<or> Neg B \\<in> Extend S C f\nA total of 17 subgoals...", "have \\<open>maximal ?H C\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. maximal (Extend S C f) C", "by (simp add: extend_maximal fin_ch surj)"], ["proof (state)\nthis:\n  maximal (Extend S C f) C\n\ngoal (17 subgoals):\n 1. \\<And>p ts.\n       \\<not> (Pred p ts \\<in> Extend S C f \\<and>\n               Neg (Pred p ts) \\<in> Extend S C f)\n 2. FF \\<notin> Extend S C f\n 3. Neg TT \\<notin> Extend S C f\n 4. \\<And>Z.\n       Neg (Neg Z) \\<in> Extend S C f \\<Longrightarrow> Z \\<in> Extend S C f\n 5. \\<And>A B.\n       And A B \\<in> Extend S C f \\<Longrightarrow> A \\<in> Extend S C f\n 6. \\<And>A B.\n       And A B \\<in> Extend S C f \\<Longrightarrow> B \\<in> Extend S C f\n 7. \\<And>A B.\n       Neg (Or A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f\n 8. \\<And>A B.\n       Neg (Or A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg B \\<in> Extend S C f\n 9. \\<And>A B.\n       Or A B \\<in> Extend S C f \\<Longrightarrow>\n       A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 10. \\<And>A B.\n        Neg (And A B) \\<in> Extend S C f \\<Longrightarrow>\n        Neg A \\<in> Extend S C f \\<or> Neg B \\<in> Extend S C f\nA total of 17 subgoals...", "have \\<open>?H \\<in> C\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Extend S C f \\<in> C", "using Extend_in_C assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>alt_consistency ?C; finite_char ?C; ?S \\<in> ?C;\n   infinite (- \\<Union> (params ` ?S))\\<rbrakk>\n  \\<Longrightarrow> Extend ?S ?C ?f \\<in> ?C\n  finite_char C\n  infinite (- \\<Union> (params ` S))\n  \\<forall>y. \\<exists>n. y = f n\n  alt_consistency C\n  S \\<in> C\n\ngoal (1 subgoal):\n 1. Extend S C f \\<in> C", "by blast"], ["proof (state)\nthis:\n  Extend S C f \\<in> C\n\ngoal (17 subgoals):\n 1. \\<And>p ts.\n       \\<not> (Pred p ts \\<in> Extend S C f \\<and>\n               Neg (Pred p ts) \\<in> Extend S C f)\n 2. FF \\<notin> Extend S C f\n 3. Neg TT \\<notin> Extend S C f\n 4. \\<And>Z.\n       Neg (Neg Z) \\<in> Extend S C f \\<Longrightarrow> Z \\<in> Extend S C f\n 5. \\<And>A B.\n       And A B \\<in> Extend S C f \\<Longrightarrow> A \\<in> Extend S C f\n 6. \\<And>A B.\n       And A B \\<in> Extend S C f \\<Longrightarrow> B \\<in> Extend S C f\n 7. \\<And>A B.\n       Neg (Or A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f\n 8. \\<And>A B.\n       Neg (Or A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg B \\<in> Extend S C f\n 9. \\<And>A B.\n       Or A B \\<in> Extend S C f \\<Longrightarrow>\n       A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 10. \\<And>A B.\n        Neg (And A B) \\<in> Extend S C f \\<Longrightarrow>\n        Neg A \\<in> Extend S C f \\<or> Neg B \\<in> Extend S C f\nA total of 17 subgoals...", "have \\<open>\\<forall>S' \\<in> C. ?H \\<subseteq> S' \\<longrightarrow> ?H = S'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>S'\\<in>C.\n       Extend S C f \\<subseteq> S' \\<longrightarrow> Extend S C f = S'", "using \\<open>maximal ?H C\\<close>"], ["proof (prove)\nusing this:\n  maximal (Extend S C f) C\n\ngoal (1 subgoal):\n 1. \\<forall>S'\\<in>C.\n       Extend S C f \\<subseteq> S' \\<longrightarrow> Extend S C f = S'", "unfolding maximal_def"], ["proof (prove)\nusing this:\n  \\<forall>S'\\<in>C.\n     Extend S C f \\<subseteq> S' \\<longrightarrow> Extend S C f = S'\n\ngoal (1 subgoal):\n 1. \\<forall>S'\\<in>C.\n       Extend S C f \\<subseteq> S' \\<longrightarrow> Extend S C f = S'", "by blast"], ["proof (state)\nthis:\n  \\<forall>S'\\<in>C.\n     Extend S C f \\<subseteq> S' \\<longrightarrow> Extend S C f = S'\n\ngoal (17 subgoals):\n 1. \\<And>p ts.\n       \\<not> (Pred p ts \\<in> Extend S C f \\<and>\n               Neg (Pred p ts) \\<in> Extend S C f)\n 2. FF \\<notin> Extend S C f\n 3. Neg TT \\<notin> Extend S C f\n 4. \\<And>Z.\n       Neg (Neg Z) \\<in> Extend S C f \\<Longrightarrow> Z \\<in> Extend S C f\n 5. \\<And>A B.\n       And A B \\<in> Extend S C f \\<Longrightarrow> A \\<in> Extend S C f\n 6. \\<And>A B.\n       And A B \\<in> Extend S C f \\<Longrightarrow> B \\<in> Extend S C f\n 7. \\<And>A B.\n       Neg (Or A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f\n 8. \\<And>A B.\n       Neg (Or A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg B \\<in> Extend S C f\n 9. \\<And>A B.\n       Or A B \\<in> Extend S C f \\<Longrightarrow>\n       A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 10. \\<And>A B.\n        Neg (And A B) \\<in> Extend S C f \\<Longrightarrow>\n        Neg A \\<in> Extend S C f \\<or> Neg B \\<in> Extend S C f\nA total of 17 subgoals...", "{"], ["proof (state)\nthis:\n  \\<forall>S'\\<in>C.\n     Extend S C f \\<subseteq> S' \\<longrightarrow> Extend S C f = S'\n\ngoal (17 subgoals):\n 1. \\<And>p ts.\n       \\<not> (Pred p ts \\<in> Extend S C f \\<and>\n               Neg (Pred p ts) \\<in> Extend S C f)\n 2. FF \\<notin> Extend S C f\n 3. Neg TT \\<notin> Extend S C f\n 4. \\<And>Z.\n       Neg (Neg Z) \\<in> Extend S C f \\<Longrightarrow> Z \\<in> Extend S C f\n 5. \\<And>A B.\n       And A B \\<in> Extend S C f \\<Longrightarrow> A \\<in> Extend S C f\n 6. \\<And>A B.\n       And A B \\<in> Extend S C f \\<Longrightarrow> B \\<in> Extend S C f\n 7. \\<And>A B.\n       Neg (Or A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f\n 8. \\<And>A B.\n       Neg (Or A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg B \\<in> Extend S C f\n 9. \\<And>A B.\n       Or A B \\<in> Extend S C f \\<Longrightarrow>\n       A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 10. \\<And>A B.\n        Neg (And A B) \\<in> Extend S C f \\<Longrightarrow>\n        Neg A \\<in> Extend S C f \\<or> Neg B \\<in> Extend S C f\nA total of 17 subgoals...", "fix p ts"], ["proof (state)\ngoal (17 subgoals):\n 1. \\<And>p ts.\n       \\<not> (Pred p ts \\<in> Extend S C f \\<and>\n               Neg (Pred p ts) \\<in> Extend S C f)\n 2. FF \\<notin> Extend S C f\n 3. Neg TT \\<notin> Extend S C f\n 4. \\<And>Z.\n       Neg (Neg Z) \\<in> Extend S C f \\<Longrightarrow> Z \\<in> Extend S C f\n 5. \\<And>A B.\n       And A B \\<in> Extend S C f \\<Longrightarrow> A \\<in> Extend S C f\n 6. \\<And>A B.\n       And A B \\<in> Extend S C f \\<Longrightarrow> B \\<in> Extend S C f\n 7. \\<And>A B.\n       Neg (Or A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f\n 8. \\<And>A B.\n       Neg (Or A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg B \\<in> Extend S C f\n 9. \\<And>A B.\n       Or A B \\<in> Extend S C f \\<Longrightarrow>\n       A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 10. \\<And>A B.\n        Neg (And A B) \\<in> Extend S C f \\<Longrightarrow>\n        Neg A \\<in> Extend S C f \\<or> Neg B \\<in> Extend S C f\nA total of 17 subgoals...", "show \\<open>\\<not> (Pred p ts \\<in> ?H \\<and> Neg (Pred p ts) \\<in> ?H)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (Pred p ts \\<in> Extend S C f \\<and>\n            Neg (Pred p ts) \\<in> Extend S C f)", "using \\<open>?H \\<in> C\\<close> altc"], ["proof (prove)\nusing this:\n  Extend S C f \\<in> C\n  alt_consistency C\n\ngoal (1 subgoal):\n 1. \\<not> (Pred p ts \\<in> Extend S C f \\<and>\n            Neg (Pred p ts) \\<in> Extend S C f)", "unfolding alt_consistency_def"], ["proof (prove)\nusing this:\n  Extend S C f \\<in> C\n  \\<forall>S.\n     S \\<in> C \\<longrightarrow>\n     (\\<forall>p ts.\n         \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)) \\<and>\n     FF \\<notin> S \\<and>\n     Neg TT \\<notin> S \\<and>\n     (\\<forall>Z.\n         Neg (Neg Z) \\<in> S \\<longrightarrow>\n         S \\<union> {Z} \\<in> C) \\<and>\n     (\\<forall>A B.\n         And A B \\<in> S \\<longrightarrow> S \\<union> {A, B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Or A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A, Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Or A B \\<in> S \\<longrightarrow>\n         S \\<union> {A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (And A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Impl A B \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Impl A B) \\<in> S \\<longrightarrow>\n         S \\<union> {A, Neg B} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Forall P \\<in> S \\<longrightarrow>\n         S \\<union> {P[t/0]} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Neg (Exists P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[t/0])} \\<in> C) \\<and>\n     (\\<forall>P x.\n         (\\<forall>a\\<in>S. x \\<notin> params a) \\<longrightarrow>\n         Exists P \\<in> S \\<longrightarrow>\n         S \\<union> {P[App x []/0]} \\<in> C) \\<and>\n     (\\<forall>P x.\n         (\\<forall>a\\<in>S. x \\<notin> params a) \\<longrightarrow>\n         Neg (Forall P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[App x []/0])} \\<in> C)\n\ngoal (1 subgoal):\n 1. \\<not> (Pred p ts \\<in> Extend S C f \\<and>\n            Neg (Pred p ts) \\<in> Extend S C f)", "by fast"], ["proof (state)\nthis:\n  \\<not> (Pred p ts \\<in> Extend S C f \\<and>\n          Neg (Pred p ts) \\<in> Extend S C f)\n\ngoal (16 subgoals):\n 1. FF \\<notin> Extend S C f\n 2. Neg TT \\<notin> Extend S C f\n 3. \\<And>Z.\n       Neg (Neg Z) \\<in> Extend S C f \\<Longrightarrow> Z \\<in> Extend S C f\n 4. \\<And>A B.\n       And A B \\<in> Extend S C f \\<Longrightarrow> A \\<in> Extend S C f\n 5. \\<And>A B.\n       And A B \\<in> Extend S C f \\<Longrightarrow> B \\<in> Extend S C f\n 6. \\<And>A B.\n       Neg (Or A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f\n 7. \\<And>A B.\n       Neg (Or A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg B \\<in> Extend S C f\n 8. \\<And>A B.\n       Or A B \\<in> Extend S C f \\<Longrightarrow>\n       A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 9. \\<And>A B.\n       Neg (And A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> Neg B \\<in> Extend S C f\n 10. \\<And>A B.\n        Impl A B \\<in> Extend S C f \\<Longrightarrow>\n        Neg A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\nA total of 16 subgoals...", "}"], ["proof (state)\nthis:\n  \\<not> (Pred ?p2 ?ts2 \\<in> Extend S C f \\<and>\n          Neg (Pred ?p2 ?ts2) \\<in> Extend S C f)\n\ngoal (16 subgoals):\n 1. FF \\<notin> Extend S C f\n 2. Neg TT \\<notin> Extend S C f\n 3. \\<And>Z.\n       Neg (Neg Z) \\<in> Extend S C f \\<Longrightarrow> Z \\<in> Extend S C f\n 4. \\<And>A B.\n       And A B \\<in> Extend S C f \\<Longrightarrow> A \\<in> Extend S C f\n 5. \\<And>A B.\n       And A B \\<in> Extend S C f \\<Longrightarrow> B \\<in> Extend S C f\n 6. \\<And>A B.\n       Neg (Or A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f\n 7. \\<And>A B.\n       Neg (Or A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg B \\<in> Extend S C f\n 8. \\<And>A B.\n       Or A B \\<in> Extend S C f \\<Longrightarrow>\n       A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 9. \\<And>A B.\n       Neg (And A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> Neg B \\<in> Extend S C f\n 10. \\<And>A B.\n        Impl A B \\<in> Extend S C f \\<Longrightarrow>\n        Neg A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\nA total of 16 subgoals...", "show \\<open>FF \\<notin> ?H\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. FF \\<notin> Extend S C f", "using \\<open>?H \\<in> C\\<close> altc"], ["proof (prove)\nusing this:\n  Extend S C f \\<in> C\n  alt_consistency C\n\ngoal (1 subgoal):\n 1. FF \\<notin> Extend S C f", "unfolding alt_consistency_def"], ["proof (prove)\nusing this:\n  Extend S C f \\<in> C\n  \\<forall>S.\n     S \\<in> C \\<longrightarrow>\n     (\\<forall>p ts.\n         \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)) \\<and>\n     FF \\<notin> S \\<and>\n     Neg TT \\<notin> S \\<and>\n     (\\<forall>Z.\n         Neg (Neg Z) \\<in> S \\<longrightarrow>\n         S \\<union> {Z} \\<in> C) \\<and>\n     (\\<forall>A B.\n         And A B \\<in> S \\<longrightarrow> S \\<union> {A, B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Or A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A, Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Or A B \\<in> S \\<longrightarrow>\n         S \\<union> {A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (And A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Impl A B \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Impl A B) \\<in> S \\<longrightarrow>\n         S \\<union> {A, Neg B} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Forall P \\<in> S \\<longrightarrow>\n         S \\<union> {P[t/0]} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Neg (Exists P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[t/0])} \\<in> C) \\<and>\n     (\\<forall>P x.\n         (\\<forall>a\\<in>S. x \\<notin> params a) \\<longrightarrow>\n         Exists P \\<in> S \\<longrightarrow>\n         S \\<union> {P[App x []/0]} \\<in> C) \\<and>\n     (\\<forall>P x.\n         (\\<forall>a\\<in>S. x \\<notin> params a) \\<longrightarrow>\n         Neg (Forall P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[App x []/0])} \\<in> C)\n\ngoal (1 subgoal):\n 1. FF \\<notin> Extend S C f", "by blast"], ["proof (state)\nthis:\n  FF \\<notin> Extend S C f\n\ngoal (15 subgoals):\n 1. Neg TT \\<notin> Extend S C f\n 2. \\<And>Z.\n       Neg (Neg Z) \\<in> Extend S C f \\<Longrightarrow> Z \\<in> Extend S C f\n 3. \\<And>A B.\n       And A B \\<in> Extend S C f \\<Longrightarrow> A \\<in> Extend S C f\n 4. \\<And>A B.\n       And A B \\<in> Extend S C f \\<Longrightarrow> B \\<in> Extend S C f\n 5. \\<And>A B.\n       Neg (Or A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f\n 6. \\<And>A B.\n       Neg (Or A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg B \\<in> Extend S C f\n 7. \\<And>A B.\n       Or A B \\<in> Extend S C f \\<Longrightarrow>\n       A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 8. \\<And>A B.\n       Neg (And A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> Neg B \\<in> Extend S C f\n 9. \\<And>A B.\n       Impl A B \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 10. \\<And>A B.\n        Neg (Impl A B) \\<in> Extend S C f \\<Longrightarrow>\n        A \\<in> Extend S C f\nA total of 15 subgoals...", "show \\<open>Neg TT \\<notin> ?H\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Neg TT \\<notin> Extend S C f", "using \\<open>?H \\<in> C\\<close> altc"], ["proof (prove)\nusing this:\n  Extend S C f \\<in> C\n  alt_consistency C\n\ngoal (1 subgoal):\n 1. Neg TT \\<notin> Extend S C f", "unfolding alt_consistency_def"], ["proof (prove)\nusing this:\n  Extend S C f \\<in> C\n  \\<forall>S.\n     S \\<in> C \\<longrightarrow>\n     (\\<forall>p ts.\n         \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)) \\<and>\n     FF \\<notin> S \\<and>\n     Neg TT \\<notin> S \\<and>\n     (\\<forall>Z.\n         Neg (Neg Z) \\<in> S \\<longrightarrow>\n         S \\<union> {Z} \\<in> C) \\<and>\n     (\\<forall>A B.\n         And A B \\<in> S \\<longrightarrow> S \\<union> {A, B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Or A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A, Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Or A B \\<in> S \\<longrightarrow>\n         S \\<union> {A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (And A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Impl A B \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Impl A B) \\<in> S \\<longrightarrow>\n         S \\<union> {A, Neg B} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Forall P \\<in> S \\<longrightarrow>\n         S \\<union> {P[t/0]} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Neg (Exists P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[t/0])} \\<in> C) \\<and>\n     (\\<forall>P x.\n         (\\<forall>a\\<in>S. x \\<notin> params a) \\<longrightarrow>\n         Exists P \\<in> S \\<longrightarrow>\n         S \\<union> {P[App x []/0]} \\<in> C) \\<and>\n     (\\<forall>P x.\n         (\\<forall>a\\<in>S. x \\<notin> params a) \\<longrightarrow>\n         Neg (Forall P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[App x []/0])} \\<in> C)\n\ngoal (1 subgoal):\n 1. Neg TT \\<notin> Extend S C f", "by blast"], ["proof (state)\nthis:\n  Neg TT \\<notin> Extend S C f\n\ngoal (14 subgoals):\n 1. \\<And>Z.\n       Neg (Neg Z) \\<in> Extend S C f \\<Longrightarrow> Z \\<in> Extend S C f\n 2. \\<And>A B.\n       And A B \\<in> Extend S C f \\<Longrightarrow> A \\<in> Extend S C f\n 3. \\<And>A B.\n       And A B \\<in> Extend S C f \\<Longrightarrow> B \\<in> Extend S C f\n 4. \\<And>A B.\n       Neg (Or A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f\n 5. \\<And>A B.\n       Neg (Or A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg B \\<in> Extend S C f\n 6. \\<And>A B.\n       Or A B \\<in> Extend S C f \\<Longrightarrow>\n       A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 7. \\<And>A B.\n       Neg (And A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> Neg B \\<in> Extend S C f\n 8. \\<And>A B.\n       Impl A B \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 9. \\<And>A B.\n       Neg (Impl A B) \\<in> Extend S C f \\<Longrightarrow>\n       A \\<in> Extend S C f\n 10. \\<And>A B.\n        Neg (Impl A B) \\<in> Extend S C f \\<Longrightarrow>\n        Neg B \\<in> Extend S C f\nA total of 14 subgoals...", "{"], ["proof (state)\nthis:\n  Neg TT \\<notin> Extend S C f\n\ngoal (14 subgoals):\n 1. \\<And>Z.\n       Neg (Neg Z) \\<in> Extend S C f \\<Longrightarrow> Z \\<in> Extend S C f\n 2. \\<And>A B.\n       And A B \\<in> Extend S C f \\<Longrightarrow> A \\<in> Extend S C f\n 3. \\<And>A B.\n       And A B \\<in> Extend S C f \\<Longrightarrow> B \\<in> Extend S C f\n 4. \\<And>A B.\n       Neg (Or A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f\n 5. \\<And>A B.\n       Neg (Or A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg B \\<in> Extend S C f\n 6. \\<And>A B.\n       Or A B \\<in> Extend S C f \\<Longrightarrow>\n       A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 7. \\<And>A B.\n       Neg (And A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> Neg B \\<in> Extend S C f\n 8. \\<And>A B.\n       Impl A B \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 9. \\<And>A B.\n       Neg (Impl A B) \\<in> Extend S C f \\<Longrightarrow>\n       A \\<in> Extend S C f\n 10. \\<And>A B.\n        Neg (Impl A B) \\<in> Extend S C f \\<Longrightarrow>\n        Neg B \\<in> Extend S C f\nA total of 14 subgoals...", "fix Z"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>Z.\n       Neg (Neg Z) \\<in> Extend S C f \\<Longrightarrow> Z \\<in> Extend S C f\n 2. \\<And>A B.\n       And A B \\<in> Extend S C f \\<Longrightarrow> A \\<in> Extend S C f\n 3. \\<And>A B.\n       And A B \\<in> Extend S C f \\<Longrightarrow> B \\<in> Extend S C f\n 4. \\<And>A B.\n       Neg (Or A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f\n 5. \\<And>A B.\n       Neg (Or A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg B \\<in> Extend S C f\n 6. \\<And>A B.\n       Or A B \\<in> Extend S C f \\<Longrightarrow>\n       A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 7. \\<And>A B.\n       Neg (And A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> Neg B \\<in> Extend S C f\n 8. \\<And>A B.\n       Impl A B \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 9. \\<And>A B.\n       Neg (Impl A B) \\<in> Extend S C f \\<Longrightarrow>\n       A \\<in> Extend S C f\n 10. \\<And>A B.\n        Neg (Impl A B) \\<in> Extend S C f \\<Longrightarrow>\n        Neg B \\<in> Extend S C f\nA total of 14 subgoals...", "assume \\<open>Neg (Neg Z) \\<in> ?H\\<close>"], ["proof (state)\nthis:\n  Neg (Neg Z) \\<in> Extend S C f\n\ngoal (14 subgoals):\n 1. \\<And>Z.\n       Neg (Neg Z) \\<in> Extend S C f \\<Longrightarrow> Z \\<in> Extend S C f\n 2. \\<And>A B.\n       And A B \\<in> Extend S C f \\<Longrightarrow> A \\<in> Extend S C f\n 3. \\<And>A B.\n       And A B \\<in> Extend S C f \\<Longrightarrow> B \\<in> Extend S C f\n 4. \\<And>A B.\n       Neg (Or A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f\n 5. \\<And>A B.\n       Neg (Or A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg B \\<in> Extend S C f\n 6. \\<And>A B.\n       Or A B \\<in> Extend S C f \\<Longrightarrow>\n       A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 7. \\<And>A B.\n       Neg (And A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> Neg B \\<in> Extend S C f\n 8. \\<And>A B.\n       Impl A B \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 9. \\<And>A B.\n       Neg (Impl A B) \\<in> Extend S C f \\<Longrightarrow>\n       A \\<in> Extend S C f\n 10. \\<And>A B.\n        Neg (Impl A B) \\<in> Extend S C f \\<Longrightarrow>\n        Neg B \\<in> Extend S C f\nA total of 14 subgoals...", "then"], ["proof (chain)\npicking this:\n  Neg (Neg Z) \\<in> Extend S C f", "have \\<open>?H \\<union> {Z} \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  Neg (Neg Z) \\<in> Extend S C f\n\ngoal (1 subgoal):\n 1. Extend S C f \\<union> {Z} \\<in> C", "using \\<open>?H \\<in> C\\<close> altc"], ["proof (prove)\nusing this:\n  Neg (Neg Z) \\<in> Extend S C f\n  Extend S C f \\<in> C\n  alt_consistency C\n\ngoal (1 subgoal):\n 1. Extend S C f \\<union> {Z} \\<in> C", "unfolding alt_consistency_def"], ["proof (prove)\nusing this:\n  Neg (Neg Z) \\<in> Extend S C f\n  Extend S C f \\<in> C\n  \\<forall>S.\n     S \\<in> C \\<longrightarrow>\n     (\\<forall>p ts.\n         \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)) \\<and>\n     FF \\<notin> S \\<and>\n     Neg TT \\<notin> S \\<and>\n     (\\<forall>Z.\n         Neg (Neg Z) \\<in> S \\<longrightarrow>\n         S \\<union> {Z} \\<in> C) \\<and>\n     (\\<forall>A B.\n         And A B \\<in> S \\<longrightarrow> S \\<union> {A, B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Or A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A, Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Or A B \\<in> S \\<longrightarrow>\n         S \\<union> {A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (And A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Impl A B \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Impl A B) \\<in> S \\<longrightarrow>\n         S \\<union> {A, Neg B} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Forall P \\<in> S \\<longrightarrow>\n         S \\<union> {P[t/0]} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Neg (Exists P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[t/0])} \\<in> C) \\<and>\n     (\\<forall>P x.\n         (\\<forall>a\\<in>S. x \\<notin> params a) \\<longrightarrow>\n         Exists P \\<in> S \\<longrightarrow>\n         S \\<union> {P[App x []/0]} \\<in> C) \\<and>\n     (\\<forall>P x.\n         (\\<forall>a\\<in>S. x \\<notin> params a) \\<longrightarrow>\n         Neg (Forall P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[App x []/0])} \\<in> C)\n\ngoal (1 subgoal):\n 1. Extend S C f \\<union> {Z} \\<in> C", "by fast"], ["proof (state)\nthis:\n  Extend S C f \\<union> {Z} \\<in> C\n\ngoal (14 subgoals):\n 1. \\<And>Z.\n       Neg (Neg Z) \\<in> Extend S C f \\<Longrightarrow> Z \\<in> Extend S C f\n 2. \\<And>A B.\n       And A B \\<in> Extend S C f \\<Longrightarrow> A \\<in> Extend S C f\n 3. \\<And>A B.\n       And A B \\<in> Extend S C f \\<Longrightarrow> B \\<in> Extend S C f\n 4. \\<And>A B.\n       Neg (Or A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f\n 5. \\<And>A B.\n       Neg (Or A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg B \\<in> Extend S C f\n 6. \\<And>A B.\n       Or A B \\<in> Extend S C f \\<Longrightarrow>\n       A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 7. \\<And>A B.\n       Neg (And A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> Neg B \\<in> Extend S C f\n 8. \\<And>A B.\n       Impl A B \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 9. \\<And>A B.\n       Neg (Impl A B) \\<in> Extend S C f \\<Longrightarrow>\n       A \\<in> Extend S C f\n 10. \\<And>A B.\n        Neg (Impl A B) \\<in> Extend S C f \\<Longrightarrow>\n        Neg B \\<in> Extend S C f\nA total of 14 subgoals...", "then"], ["proof (chain)\npicking this:\n  Extend S C f \\<union> {Z} \\<in> C", "show \\<open>Z \\<in> ?H\\<close>"], ["proof (prove)\nusing this:\n  Extend S C f \\<union> {Z} \\<in> C\n\ngoal (1 subgoal):\n 1. Z \\<in> Extend S C f", "using \\<open>maximal ?H C\\<close>"], ["proof (prove)\nusing this:\n  Extend S C f \\<union> {Z} \\<in> C\n  maximal (Extend S C f) C\n\ngoal (1 subgoal):\n 1. Z \\<in> Extend S C f", "unfolding maximal_def"], ["proof (prove)\nusing this:\n  Extend S C f \\<union> {Z} \\<in> C\n  \\<forall>S'\\<in>C.\n     Extend S C f \\<subseteq> S' \\<longrightarrow> Extend S C f = S'\n\ngoal (1 subgoal):\n 1. Z \\<in> Extend S C f", "by fast"], ["proof (state)\nthis:\n  Z \\<in> Extend S C f\n\ngoal (13 subgoals):\n 1. \\<And>A B.\n       And A B \\<in> Extend S C f \\<Longrightarrow> A \\<in> Extend S C f\n 2. \\<And>A B.\n       And A B \\<in> Extend S C f \\<Longrightarrow> B \\<in> Extend S C f\n 3. \\<And>A B.\n       Neg (Or A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f\n 4. \\<And>A B.\n       Neg (Or A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg B \\<in> Extend S C f\n 5. \\<And>A B.\n       Or A B \\<in> Extend S C f \\<Longrightarrow>\n       A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 6. \\<And>A B.\n       Neg (And A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> Neg B \\<in> Extend S C f\n 7. \\<And>A B.\n       Impl A B \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 8. \\<And>A B.\n       Neg (Impl A B) \\<in> Extend S C f \\<Longrightarrow>\n       A \\<in> Extend S C f\n 9. \\<And>A B.\n       Neg (Impl A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg B \\<in> Extend S C f\n 10. \\<And>P t.\n        \\<lbrakk>closedt 0 t; Forall P \\<in> Extend S C f\\<rbrakk>\n        \\<Longrightarrow> P[t/0] \\<in> Extend S C f\nA total of 13 subgoals...", "}"], ["proof (state)\nthis:\n  Neg (Neg ?Z2) \\<in> Extend S C f \\<Longrightarrow> ?Z2 \\<in> Extend S C f\n\ngoal (13 subgoals):\n 1. \\<And>A B.\n       And A B \\<in> Extend S C f \\<Longrightarrow> A \\<in> Extend S C f\n 2. \\<And>A B.\n       And A B \\<in> Extend S C f \\<Longrightarrow> B \\<in> Extend S C f\n 3. \\<And>A B.\n       Neg (Or A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f\n 4. \\<And>A B.\n       Neg (Or A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg B \\<in> Extend S C f\n 5. \\<And>A B.\n       Or A B \\<in> Extend S C f \\<Longrightarrow>\n       A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 6. \\<And>A B.\n       Neg (And A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> Neg B \\<in> Extend S C f\n 7. \\<And>A B.\n       Impl A B \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 8. \\<And>A B.\n       Neg (Impl A B) \\<in> Extend S C f \\<Longrightarrow>\n       A \\<in> Extend S C f\n 9. \\<And>A B.\n       Neg (Impl A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg B \\<in> Extend S C f\n 10. \\<And>P t.\n        \\<lbrakk>closedt 0 t; Forall P \\<in> Extend S C f\\<rbrakk>\n        \\<Longrightarrow> P[t/0] \\<in> Extend S C f\nA total of 13 subgoals...", "{"], ["proof (state)\nthis:\n  Neg (Neg ?Z2) \\<in> Extend S C f \\<Longrightarrow> ?Z2 \\<in> Extend S C f\n\ngoal (13 subgoals):\n 1. \\<And>A B.\n       And A B \\<in> Extend S C f \\<Longrightarrow> A \\<in> Extend S C f\n 2. \\<And>A B.\n       And A B \\<in> Extend S C f \\<Longrightarrow> B \\<in> Extend S C f\n 3. \\<And>A B.\n       Neg (Or A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f\n 4. \\<And>A B.\n       Neg (Or A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg B \\<in> Extend S C f\n 5. \\<And>A B.\n       Or A B \\<in> Extend S C f \\<Longrightarrow>\n       A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 6. \\<And>A B.\n       Neg (And A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> Neg B \\<in> Extend S C f\n 7. \\<And>A B.\n       Impl A B \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 8. \\<And>A B.\n       Neg (Impl A B) \\<in> Extend S C f \\<Longrightarrow>\n       A \\<in> Extend S C f\n 9. \\<And>A B.\n       Neg (Impl A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg B \\<in> Extend S C f\n 10. \\<And>P t.\n        \\<lbrakk>closedt 0 t; Forall P \\<in> Extend S C f\\<rbrakk>\n        \\<Longrightarrow> P[t/0] \\<in> Extend S C f\nA total of 13 subgoals...", "fix A B"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>A B.\n       And A B \\<in> Extend S C f \\<Longrightarrow> A \\<in> Extend S C f\n 2. \\<And>A B.\n       And A B \\<in> Extend S C f \\<Longrightarrow> B \\<in> Extend S C f\n 3. \\<And>A B.\n       Neg (Or A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f\n 4. \\<And>A B.\n       Neg (Or A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg B \\<in> Extend S C f\n 5. \\<And>A B.\n       Or A B \\<in> Extend S C f \\<Longrightarrow>\n       A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 6. \\<And>A B.\n       Neg (And A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> Neg B \\<in> Extend S C f\n 7. \\<And>A B.\n       Impl A B \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 8. \\<And>A B.\n       Neg (Impl A B) \\<in> Extend S C f \\<Longrightarrow>\n       A \\<in> Extend S C f\n 9. \\<And>A B.\n       Neg (Impl A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg B \\<in> Extend S C f\n 10. \\<And>P t.\n        \\<lbrakk>closedt 0 t; Forall P \\<in> Extend S C f\\<rbrakk>\n        \\<Longrightarrow> P[t/0] \\<in> Extend S C f\nA total of 13 subgoals...", "assume \\<open>And A B \\<in> ?H\\<close>"], ["proof (state)\nthis:\n  And A B \\<in> Extend S C f\n\ngoal (13 subgoals):\n 1. \\<And>A B.\n       And A B \\<in> Extend S C f \\<Longrightarrow> A \\<in> Extend S C f\n 2. \\<And>A B.\n       And A B \\<in> Extend S C f \\<Longrightarrow> B \\<in> Extend S C f\n 3. \\<And>A B.\n       Neg (Or A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f\n 4. \\<And>A B.\n       Neg (Or A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg B \\<in> Extend S C f\n 5. \\<And>A B.\n       Or A B \\<in> Extend S C f \\<Longrightarrow>\n       A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 6. \\<And>A B.\n       Neg (And A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> Neg B \\<in> Extend S C f\n 7. \\<And>A B.\n       Impl A B \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 8. \\<And>A B.\n       Neg (Impl A B) \\<in> Extend S C f \\<Longrightarrow>\n       A \\<in> Extend S C f\n 9. \\<And>A B.\n       Neg (Impl A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg B \\<in> Extend S C f\n 10. \\<And>P t.\n        \\<lbrakk>closedt 0 t; Forall P \\<in> Extend S C f\\<rbrakk>\n        \\<Longrightarrow> P[t/0] \\<in> Extend S C f\nA total of 13 subgoals...", "then"], ["proof (chain)\npicking this:\n  And A B \\<in> Extend S C f", "have \\<open>?H \\<union> {A, B} \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  And A B \\<in> Extend S C f\n\ngoal (1 subgoal):\n 1. Extend S C f \\<union> {A, B} \\<in> C", "using \\<open>?H \\<in> C\\<close> altc"], ["proof (prove)\nusing this:\n  And A B \\<in> Extend S C f\n  Extend S C f \\<in> C\n  alt_consistency C\n\ngoal (1 subgoal):\n 1. Extend S C f \\<union> {A, B} \\<in> C", "unfolding alt_consistency_def"], ["proof (prove)\nusing this:\n  And A B \\<in> Extend S C f\n  Extend S C f \\<in> C\n  \\<forall>S.\n     S \\<in> C \\<longrightarrow>\n     (\\<forall>p ts.\n         \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)) \\<and>\n     FF \\<notin> S \\<and>\n     Neg TT \\<notin> S \\<and>\n     (\\<forall>Z.\n         Neg (Neg Z) \\<in> S \\<longrightarrow>\n         S \\<union> {Z} \\<in> C) \\<and>\n     (\\<forall>A B.\n         And A B \\<in> S \\<longrightarrow> S \\<union> {A, B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Or A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A, Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Or A B \\<in> S \\<longrightarrow>\n         S \\<union> {A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (And A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Impl A B \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Impl A B) \\<in> S \\<longrightarrow>\n         S \\<union> {A, Neg B} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Forall P \\<in> S \\<longrightarrow>\n         S \\<union> {P[t/0]} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Neg (Exists P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[t/0])} \\<in> C) \\<and>\n     (\\<forall>P x.\n         (\\<forall>a\\<in>S. x \\<notin> params a) \\<longrightarrow>\n         Exists P \\<in> S \\<longrightarrow>\n         S \\<union> {P[App x []/0]} \\<in> C) \\<and>\n     (\\<forall>P x.\n         (\\<forall>a\\<in>S. x \\<notin> params a) \\<longrightarrow>\n         Neg (Forall P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[App x []/0])} \\<in> C)\n\ngoal (1 subgoal):\n 1. Extend S C f \\<union> {A, B} \\<in> C", "by fast"], ["proof (state)\nthis:\n  Extend S C f \\<union> {A, B} \\<in> C\n\ngoal (13 subgoals):\n 1. \\<And>A B.\n       And A B \\<in> Extend S C f \\<Longrightarrow> A \\<in> Extend S C f\n 2. \\<And>A B.\n       And A B \\<in> Extend S C f \\<Longrightarrow> B \\<in> Extend S C f\n 3. \\<And>A B.\n       Neg (Or A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f\n 4. \\<And>A B.\n       Neg (Or A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg B \\<in> Extend S C f\n 5. \\<And>A B.\n       Or A B \\<in> Extend S C f \\<Longrightarrow>\n       A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 6. \\<And>A B.\n       Neg (And A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> Neg B \\<in> Extend S C f\n 7. \\<And>A B.\n       Impl A B \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 8. \\<And>A B.\n       Neg (Impl A B) \\<in> Extend S C f \\<Longrightarrow>\n       A \\<in> Extend S C f\n 9. \\<And>A B.\n       Neg (Impl A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg B \\<in> Extend S C f\n 10. \\<And>P t.\n        \\<lbrakk>closedt 0 t; Forall P \\<in> Extend S C f\\<rbrakk>\n        \\<Longrightarrow> P[t/0] \\<in> Extend S C f\nA total of 13 subgoals...", "then"], ["proof (chain)\npicking this:\n  Extend S C f \\<union> {A, B} \\<in> C", "show \\<open>A \\<in> ?H\\<close> and \\<open>B \\<in> ?H\\<close>"], ["proof (prove)\nusing this:\n  Extend S C f \\<union> {A, B} \\<in> C\n\ngoal (1 subgoal):\n 1. A \\<in> Extend S C f &&& B \\<in> Extend S C f", "using \\<open>maximal ?H C\\<close>"], ["proof (prove)\nusing this:\n  Extend S C f \\<union> {A, B} \\<in> C\n  maximal (Extend S C f) C\n\ngoal (1 subgoal):\n 1. A \\<in> Extend S C f &&& B \\<in> Extend S C f", "unfolding maximal_def"], ["proof (prove)\nusing this:\n  Extend S C f \\<union> {A, B} \\<in> C\n  \\<forall>S'\\<in>C.\n     Extend S C f \\<subseteq> S' \\<longrightarrow> Extend S C f = S'\n\ngoal (1 subgoal):\n 1. A \\<in> Extend S C f &&& B \\<in> Extend S C f", "by fast+"], ["proof (state)\nthis:\n  A \\<in> Extend S C f\n  B \\<in> Extend S C f\n\ngoal (11 subgoals):\n 1. \\<And>A B.\n       Neg (Or A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f\n 2. \\<And>A B.\n       Neg (Or A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg B \\<in> Extend S C f\n 3. \\<And>A B.\n       Or A B \\<in> Extend S C f \\<Longrightarrow>\n       A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 4. \\<And>A B.\n       Neg (And A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> Neg B \\<in> Extend S C f\n 5. \\<And>A B.\n       Impl A B \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 6. \\<And>A B.\n       Neg (Impl A B) \\<in> Extend S C f \\<Longrightarrow>\n       A \\<in> Extend S C f\n 7. \\<And>A B.\n       Neg (Impl A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg B \\<in> Extend S C f\n 8. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Forall P \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> P[t/0] \\<in> Extend S C f\n 9. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Neg (Exists P) \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> Neg (P[t/0]) \\<in> Extend S C f\n 10. \\<And>P.\n        Exists P \\<in> Extend S C f \\<Longrightarrow>\n        \\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> Extend S C f\nA total of 11 subgoals...", "}"], ["proof (state)\nthis:\n  And ?A2 ?B2 \\<in> Extend S C f \\<Longrightarrow> ?A2 \\<in> Extend S C f\n  And ?A2 ?B2 \\<in> Extend S C f \\<Longrightarrow> ?B2 \\<in> Extend S C f\n\ngoal (11 subgoals):\n 1. \\<And>A B.\n       Neg (Or A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f\n 2. \\<And>A B.\n       Neg (Or A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg B \\<in> Extend S C f\n 3. \\<And>A B.\n       Or A B \\<in> Extend S C f \\<Longrightarrow>\n       A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 4. \\<And>A B.\n       Neg (And A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> Neg B \\<in> Extend S C f\n 5. \\<And>A B.\n       Impl A B \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 6. \\<And>A B.\n       Neg (Impl A B) \\<in> Extend S C f \\<Longrightarrow>\n       A \\<in> Extend S C f\n 7. \\<And>A B.\n       Neg (Impl A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg B \\<in> Extend S C f\n 8. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Forall P \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> P[t/0] \\<in> Extend S C f\n 9. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Neg (Exists P) \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> Neg (P[t/0]) \\<in> Extend S C f\n 10. \\<And>P.\n        Exists P \\<in> Extend S C f \\<Longrightarrow>\n        \\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> Extend S C f\nA total of 11 subgoals...", "{"], ["proof (state)\nthis:\n  And ?A2 ?B2 \\<in> Extend S C f \\<Longrightarrow> ?A2 \\<in> Extend S C f\n  And ?A2 ?B2 \\<in> Extend S C f \\<Longrightarrow> ?B2 \\<in> Extend S C f\n\ngoal (11 subgoals):\n 1. \\<And>A B.\n       Neg (Or A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f\n 2. \\<And>A B.\n       Neg (Or A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg B \\<in> Extend S C f\n 3. \\<And>A B.\n       Or A B \\<in> Extend S C f \\<Longrightarrow>\n       A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 4. \\<And>A B.\n       Neg (And A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> Neg B \\<in> Extend S C f\n 5. \\<And>A B.\n       Impl A B \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 6. \\<And>A B.\n       Neg (Impl A B) \\<in> Extend S C f \\<Longrightarrow>\n       A \\<in> Extend S C f\n 7. \\<And>A B.\n       Neg (Impl A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg B \\<in> Extend S C f\n 8. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Forall P \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> P[t/0] \\<in> Extend S C f\n 9. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Neg (Exists P) \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> Neg (P[t/0]) \\<in> Extend S C f\n 10. \\<And>P.\n        Exists P \\<in> Extend S C f \\<Longrightarrow>\n        \\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> Extend S C f\nA total of 11 subgoals...", "fix A B"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>A B.\n       Neg (Or A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f\n 2. \\<And>A B.\n       Neg (Or A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg B \\<in> Extend S C f\n 3. \\<And>A B.\n       Or A B \\<in> Extend S C f \\<Longrightarrow>\n       A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 4. \\<And>A B.\n       Neg (And A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> Neg B \\<in> Extend S C f\n 5. \\<And>A B.\n       Impl A B \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 6. \\<And>A B.\n       Neg (Impl A B) \\<in> Extend S C f \\<Longrightarrow>\n       A \\<in> Extend S C f\n 7. \\<And>A B.\n       Neg (Impl A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg B \\<in> Extend S C f\n 8. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Forall P \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> P[t/0] \\<in> Extend S C f\n 9. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Neg (Exists P) \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> Neg (P[t/0]) \\<in> Extend S C f\n 10. \\<And>P.\n        Exists P \\<in> Extend S C f \\<Longrightarrow>\n        \\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> Extend S C f\nA total of 11 subgoals...", "assume \\<open>Neg (Or A B) \\<in> ?H\\<close>"], ["proof (state)\nthis:\n  Neg (Or A B) \\<in> Extend S C f\n\ngoal (11 subgoals):\n 1. \\<And>A B.\n       Neg (Or A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f\n 2. \\<And>A B.\n       Neg (Or A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg B \\<in> Extend S C f\n 3. \\<And>A B.\n       Or A B \\<in> Extend S C f \\<Longrightarrow>\n       A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 4. \\<And>A B.\n       Neg (And A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> Neg B \\<in> Extend S C f\n 5. \\<And>A B.\n       Impl A B \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 6. \\<And>A B.\n       Neg (Impl A B) \\<in> Extend S C f \\<Longrightarrow>\n       A \\<in> Extend S C f\n 7. \\<And>A B.\n       Neg (Impl A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg B \\<in> Extend S C f\n 8. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Forall P \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> P[t/0] \\<in> Extend S C f\n 9. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Neg (Exists P) \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> Neg (P[t/0]) \\<in> Extend S C f\n 10. \\<And>P.\n        Exists P \\<in> Extend S C f \\<Longrightarrow>\n        \\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> Extend S C f\nA total of 11 subgoals...", "then"], ["proof (chain)\npicking this:\n  Neg (Or A B) \\<in> Extend S C f", "have \\<open>?H \\<union> {Neg A, Neg B} \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  Neg (Or A B) \\<in> Extend S C f\n\ngoal (1 subgoal):\n 1. Extend S C f \\<union> {Neg A, Neg B} \\<in> C", "using \\<open>?H \\<in> C\\<close> altc"], ["proof (prove)\nusing this:\n  Neg (Or A B) \\<in> Extend S C f\n  Extend S C f \\<in> C\n  alt_consistency C\n\ngoal (1 subgoal):\n 1. Extend S C f \\<union> {Neg A, Neg B} \\<in> C", "unfolding alt_consistency_def"], ["proof (prove)\nusing this:\n  Neg (Or A B) \\<in> Extend S C f\n  Extend S C f \\<in> C\n  \\<forall>S.\n     S \\<in> C \\<longrightarrow>\n     (\\<forall>p ts.\n         \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)) \\<and>\n     FF \\<notin> S \\<and>\n     Neg TT \\<notin> S \\<and>\n     (\\<forall>Z.\n         Neg (Neg Z) \\<in> S \\<longrightarrow>\n         S \\<union> {Z} \\<in> C) \\<and>\n     (\\<forall>A B.\n         And A B \\<in> S \\<longrightarrow> S \\<union> {A, B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Or A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A, Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Or A B \\<in> S \\<longrightarrow>\n         S \\<union> {A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (And A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Impl A B \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Impl A B) \\<in> S \\<longrightarrow>\n         S \\<union> {A, Neg B} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Forall P \\<in> S \\<longrightarrow>\n         S \\<union> {P[t/0]} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Neg (Exists P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[t/0])} \\<in> C) \\<and>\n     (\\<forall>P x.\n         (\\<forall>a\\<in>S. x \\<notin> params a) \\<longrightarrow>\n         Exists P \\<in> S \\<longrightarrow>\n         S \\<union> {P[App x []/0]} \\<in> C) \\<and>\n     (\\<forall>P x.\n         (\\<forall>a\\<in>S. x \\<notin> params a) \\<longrightarrow>\n         Neg (Forall P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[App x []/0])} \\<in> C)\n\ngoal (1 subgoal):\n 1. Extend S C f \\<union> {Neg A, Neg B} \\<in> C", "by fast"], ["proof (state)\nthis:\n  Extend S C f \\<union> {Neg A, Neg B} \\<in> C\n\ngoal (11 subgoals):\n 1. \\<And>A B.\n       Neg (Or A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f\n 2. \\<And>A B.\n       Neg (Or A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg B \\<in> Extend S C f\n 3. \\<And>A B.\n       Or A B \\<in> Extend S C f \\<Longrightarrow>\n       A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 4. \\<And>A B.\n       Neg (And A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> Neg B \\<in> Extend S C f\n 5. \\<And>A B.\n       Impl A B \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 6. \\<And>A B.\n       Neg (Impl A B) \\<in> Extend S C f \\<Longrightarrow>\n       A \\<in> Extend S C f\n 7. \\<And>A B.\n       Neg (Impl A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg B \\<in> Extend S C f\n 8. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Forall P \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> P[t/0] \\<in> Extend S C f\n 9. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Neg (Exists P) \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> Neg (P[t/0]) \\<in> Extend S C f\n 10. \\<And>P.\n        Exists P \\<in> Extend S C f \\<Longrightarrow>\n        \\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> Extend S C f\nA total of 11 subgoals...", "then"], ["proof (chain)\npicking this:\n  Extend S C f \\<union> {Neg A, Neg B} \\<in> C", "show \\<open>Neg A \\<in> ?H\\<close> and \\<open>Neg B \\<in> ?H\\<close>"], ["proof (prove)\nusing this:\n  Extend S C f \\<union> {Neg A, Neg B} \\<in> C\n\ngoal (1 subgoal):\n 1. Neg A \\<in> Extend S C f &&& Neg B \\<in> Extend S C f", "using \\<open>maximal ?H C\\<close>"], ["proof (prove)\nusing this:\n  Extend S C f \\<union> {Neg A, Neg B} \\<in> C\n  maximal (Extend S C f) C\n\ngoal (1 subgoal):\n 1. Neg A \\<in> Extend S C f &&& Neg B \\<in> Extend S C f", "unfolding maximal_def"], ["proof (prove)\nusing this:\n  Extend S C f \\<union> {Neg A, Neg B} \\<in> C\n  \\<forall>S'\\<in>C.\n     Extend S C f \\<subseteq> S' \\<longrightarrow> Extend S C f = S'\n\ngoal (1 subgoal):\n 1. Neg A \\<in> Extend S C f &&& Neg B \\<in> Extend S C f", "by fast+"], ["proof (state)\nthis:\n  Neg A \\<in> Extend S C f\n  Neg B \\<in> Extend S C f\n\ngoal (9 subgoals):\n 1. \\<And>A B.\n       Or A B \\<in> Extend S C f \\<Longrightarrow>\n       A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 2. \\<And>A B.\n       Neg (And A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> Neg B \\<in> Extend S C f\n 3. \\<And>A B.\n       Impl A B \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 4. \\<And>A B.\n       Neg (Impl A B) \\<in> Extend S C f \\<Longrightarrow>\n       A \\<in> Extend S C f\n 5. \\<And>A B.\n       Neg (Impl A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg B \\<in> Extend S C f\n 6. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Forall P \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> P[t/0] \\<in> Extend S C f\n 7. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Neg (Exists P) \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> Neg (P[t/0]) \\<in> Extend S C f\n 8. \\<And>P.\n       Exists P \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> Extend S C f\n 9. \\<And>P.\n       Neg (Forall P) \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> Extend S C f", "}"], ["proof (state)\nthis:\n  Neg (Or ?A2 ?B2) \\<in> Extend S C f \\<Longrightarrow>\n  Neg ?A2 \\<in> Extend S C f\n  Neg (Or ?A2 ?B2) \\<in> Extend S C f \\<Longrightarrow>\n  Neg ?B2 \\<in> Extend S C f\n\ngoal (9 subgoals):\n 1. \\<And>A B.\n       Or A B \\<in> Extend S C f \\<Longrightarrow>\n       A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 2. \\<And>A B.\n       Neg (And A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> Neg B \\<in> Extend S C f\n 3. \\<And>A B.\n       Impl A B \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 4. \\<And>A B.\n       Neg (Impl A B) \\<in> Extend S C f \\<Longrightarrow>\n       A \\<in> Extend S C f\n 5. \\<And>A B.\n       Neg (Impl A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg B \\<in> Extend S C f\n 6. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Forall P \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> P[t/0] \\<in> Extend S C f\n 7. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Neg (Exists P) \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> Neg (P[t/0]) \\<in> Extend S C f\n 8. \\<And>P.\n       Exists P \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> Extend S C f\n 9. \\<And>P.\n       Neg (Forall P) \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> Extend S C f", "{"], ["proof (state)\nthis:\n  Neg (Or ?A2 ?B2) \\<in> Extend S C f \\<Longrightarrow>\n  Neg ?A2 \\<in> Extend S C f\n  Neg (Or ?A2 ?B2) \\<in> Extend S C f \\<Longrightarrow>\n  Neg ?B2 \\<in> Extend S C f\n\ngoal (9 subgoals):\n 1. \\<And>A B.\n       Or A B \\<in> Extend S C f \\<Longrightarrow>\n       A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 2. \\<And>A B.\n       Neg (And A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> Neg B \\<in> Extend S C f\n 3. \\<And>A B.\n       Impl A B \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 4. \\<And>A B.\n       Neg (Impl A B) \\<in> Extend S C f \\<Longrightarrow>\n       A \\<in> Extend S C f\n 5. \\<And>A B.\n       Neg (Impl A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg B \\<in> Extend S C f\n 6. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Forall P \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> P[t/0] \\<in> Extend S C f\n 7. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Neg (Exists P) \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> Neg (P[t/0]) \\<in> Extend S C f\n 8. \\<And>P.\n       Exists P \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> Extend S C f\n 9. \\<And>P.\n       Neg (Forall P) \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> Extend S C f", "fix A B"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>A B.\n       Or A B \\<in> Extend S C f \\<Longrightarrow>\n       A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 2. \\<And>A B.\n       Neg (And A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> Neg B \\<in> Extend S C f\n 3. \\<And>A B.\n       Impl A B \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 4. \\<And>A B.\n       Neg (Impl A B) \\<in> Extend S C f \\<Longrightarrow>\n       A \\<in> Extend S C f\n 5. \\<And>A B.\n       Neg (Impl A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg B \\<in> Extend S C f\n 6. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Forall P \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> P[t/0] \\<in> Extend S C f\n 7. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Neg (Exists P) \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> Neg (P[t/0]) \\<in> Extend S C f\n 8. \\<And>P.\n       Exists P \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> Extend S C f\n 9. \\<And>P.\n       Neg (Forall P) \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> Extend S C f", "assume \\<open>Neg (Impl A B) \\<in> ?H\\<close>"], ["proof (state)\nthis:\n  Neg (Impl A B) \\<in> Extend S C f\n\ngoal (9 subgoals):\n 1. \\<And>A B.\n       Or A B \\<in> Extend S C f \\<Longrightarrow>\n       A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 2. \\<And>A B.\n       Neg (And A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> Neg B \\<in> Extend S C f\n 3. \\<And>A B.\n       Impl A B \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 4. \\<And>A B.\n       Neg (Impl A B) \\<in> Extend S C f \\<Longrightarrow>\n       A \\<in> Extend S C f\n 5. \\<And>A B.\n       Neg (Impl A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg B \\<in> Extend S C f\n 6. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Forall P \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> P[t/0] \\<in> Extend S C f\n 7. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Neg (Exists P) \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> Neg (P[t/0]) \\<in> Extend S C f\n 8. \\<And>P.\n       Exists P \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> Extend S C f\n 9. \\<And>P.\n       Neg (Forall P) \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> Extend S C f", "then"], ["proof (chain)\npicking this:\n  Neg (Impl A B) \\<in> Extend S C f", "have \\<open>?H \\<union> {A, Neg B} \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  Neg (Impl A B) \\<in> Extend S C f\n\ngoal (1 subgoal):\n 1. Extend S C f \\<union> {A, Neg B} \\<in> C", "using \\<open>?H \\<in> C\\<close> altc"], ["proof (prove)\nusing this:\n  Neg (Impl A B) \\<in> Extend S C f\n  Extend S C f \\<in> C\n  alt_consistency C\n\ngoal (1 subgoal):\n 1. Extend S C f \\<union> {A, Neg B} \\<in> C", "unfolding alt_consistency_def"], ["proof (prove)\nusing this:\n  Neg (Impl A B) \\<in> Extend S C f\n  Extend S C f \\<in> C\n  \\<forall>S.\n     S \\<in> C \\<longrightarrow>\n     (\\<forall>p ts.\n         \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)) \\<and>\n     FF \\<notin> S \\<and>\n     Neg TT \\<notin> S \\<and>\n     (\\<forall>Z.\n         Neg (Neg Z) \\<in> S \\<longrightarrow>\n         S \\<union> {Z} \\<in> C) \\<and>\n     (\\<forall>A B.\n         And A B \\<in> S \\<longrightarrow> S \\<union> {A, B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Or A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A, Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Or A B \\<in> S \\<longrightarrow>\n         S \\<union> {A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (And A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Impl A B \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Impl A B) \\<in> S \\<longrightarrow>\n         S \\<union> {A, Neg B} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Forall P \\<in> S \\<longrightarrow>\n         S \\<union> {P[t/0]} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Neg (Exists P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[t/0])} \\<in> C) \\<and>\n     (\\<forall>P x.\n         (\\<forall>a\\<in>S. x \\<notin> params a) \\<longrightarrow>\n         Exists P \\<in> S \\<longrightarrow>\n         S \\<union> {P[App x []/0]} \\<in> C) \\<and>\n     (\\<forall>P x.\n         (\\<forall>a\\<in>S. x \\<notin> params a) \\<longrightarrow>\n         Neg (Forall P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[App x []/0])} \\<in> C)\n\ngoal (1 subgoal):\n 1. Extend S C f \\<union> {A, Neg B} \\<in> C", "by blast"], ["proof (state)\nthis:\n  Extend S C f \\<union> {A, Neg B} \\<in> C\n\ngoal (9 subgoals):\n 1. \\<And>A B.\n       Or A B \\<in> Extend S C f \\<Longrightarrow>\n       A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 2. \\<And>A B.\n       Neg (And A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> Neg B \\<in> Extend S C f\n 3. \\<And>A B.\n       Impl A B \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 4. \\<And>A B.\n       Neg (Impl A B) \\<in> Extend S C f \\<Longrightarrow>\n       A \\<in> Extend S C f\n 5. \\<And>A B.\n       Neg (Impl A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg B \\<in> Extend S C f\n 6. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Forall P \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> P[t/0] \\<in> Extend S C f\n 7. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Neg (Exists P) \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> Neg (P[t/0]) \\<in> Extend S C f\n 8. \\<And>P.\n       Exists P \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> Extend S C f\n 9. \\<And>P.\n       Neg (Forall P) \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> Extend S C f", "then"], ["proof (chain)\npicking this:\n  Extend S C f \\<union> {A, Neg B} \\<in> C", "show \\<open>A \\<in> ?H\\<close> and \\<open>Neg B \\<in> ?H\\<close>"], ["proof (prove)\nusing this:\n  Extend S C f \\<union> {A, Neg B} \\<in> C\n\ngoal (1 subgoal):\n 1. A \\<in> Extend S C f &&& Neg B \\<in> Extend S C f", "using \\<open>maximal ?H C\\<close>"], ["proof (prove)\nusing this:\n  Extend S C f \\<union> {A, Neg B} \\<in> C\n  maximal (Extend S C f) C\n\ngoal (1 subgoal):\n 1. A \\<in> Extend S C f &&& Neg B \\<in> Extend S C f", "unfolding maximal_def"], ["proof (prove)\nusing this:\n  Extend S C f \\<union> {A, Neg B} \\<in> C\n  \\<forall>S'\\<in>C.\n     Extend S C f \\<subseteq> S' \\<longrightarrow> Extend S C f = S'\n\ngoal (1 subgoal):\n 1. A \\<in> Extend S C f &&& Neg B \\<in> Extend S C f", "by fast+"], ["proof (state)\nthis:\n  A \\<in> Extend S C f\n  Neg B \\<in> Extend S C f\n\ngoal (7 subgoals):\n 1. \\<And>A B.\n       Or A B \\<in> Extend S C f \\<Longrightarrow>\n       A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 2. \\<And>A B.\n       Neg (And A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> Neg B \\<in> Extend S C f\n 3. \\<And>A B.\n       Impl A B \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 4. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Forall P \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> P[t/0] \\<in> Extend S C f\n 5. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Neg (Exists P) \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> Neg (P[t/0]) \\<in> Extend S C f\n 6. \\<And>P.\n       Exists P \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> Extend S C f\n 7. \\<And>P.\n       Neg (Forall P) \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> Extend S C f", "}"], ["proof (state)\nthis:\n  Neg (Impl ?A2 ?B2) \\<in> Extend S C f \\<Longrightarrow>\n  ?A2 \\<in> Extend S C f\n  Neg (Impl ?A2 ?B2) \\<in> Extend S C f \\<Longrightarrow>\n  Neg ?B2 \\<in> Extend S C f\n\ngoal (7 subgoals):\n 1. \\<And>A B.\n       Or A B \\<in> Extend S C f \\<Longrightarrow>\n       A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 2. \\<And>A B.\n       Neg (And A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> Neg B \\<in> Extend S C f\n 3. \\<And>A B.\n       Impl A B \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 4. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Forall P \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> P[t/0] \\<in> Extend S C f\n 5. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Neg (Exists P) \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> Neg (P[t/0]) \\<in> Extend S C f\n 6. \\<And>P.\n       Exists P \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> Extend S C f\n 7. \\<And>P.\n       Neg (Forall P) \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> Extend S C f", "{"], ["proof (state)\nthis:\n  Neg (Impl ?A2 ?B2) \\<in> Extend S C f \\<Longrightarrow>\n  ?A2 \\<in> Extend S C f\n  Neg (Impl ?A2 ?B2) \\<in> Extend S C f \\<Longrightarrow>\n  Neg ?B2 \\<in> Extend S C f\n\ngoal (7 subgoals):\n 1. \\<And>A B.\n       Or A B \\<in> Extend S C f \\<Longrightarrow>\n       A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 2. \\<And>A B.\n       Neg (And A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> Neg B \\<in> Extend S C f\n 3. \\<And>A B.\n       Impl A B \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 4. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Forall P \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> P[t/0] \\<in> Extend S C f\n 5. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Neg (Exists P) \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> Neg (P[t/0]) \\<in> Extend S C f\n 6. \\<And>P.\n       Exists P \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> Extend S C f\n 7. \\<And>P.\n       Neg (Forall P) \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> Extend S C f", "fix A B"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>A B.\n       Or A B \\<in> Extend S C f \\<Longrightarrow>\n       A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 2. \\<And>A B.\n       Neg (And A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> Neg B \\<in> Extend S C f\n 3. \\<And>A B.\n       Impl A B \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 4. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Forall P \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> P[t/0] \\<in> Extend S C f\n 5. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Neg (Exists P) \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> Neg (P[t/0]) \\<in> Extend S C f\n 6. \\<And>P.\n       Exists P \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> Extend S C f\n 7. \\<And>P.\n       Neg (Forall P) \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> Extend S C f", "assume \\<open>Or A B \\<in> ?H\\<close>"], ["proof (state)\nthis:\n  Or A B \\<in> Extend S C f\n\ngoal (7 subgoals):\n 1. \\<And>A B.\n       Or A B \\<in> Extend S C f \\<Longrightarrow>\n       A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 2. \\<And>A B.\n       Neg (And A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> Neg B \\<in> Extend S C f\n 3. \\<And>A B.\n       Impl A B \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 4. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Forall P \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> P[t/0] \\<in> Extend S C f\n 5. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Neg (Exists P) \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> Neg (P[t/0]) \\<in> Extend S C f\n 6. \\<And>P.\n       Exists P \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> Extend S C f\n 7. \\<And>P.\n       Neg (Forall P) \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> Extend S C f", "then"], ["proof (chain)\npicking this:\n  Or A B \\<in> Extend S C f", "have \\<open>?H \\<union> {A} \\<in> C \\<or> ?H \\<union> {B} \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  Or A B \\<in> Extend S C f\n\ngoal (1 subgoal):\n 1. Extend S C f \\<union> {A} \\<in> C \\<or>\n    Extend S C f \\<union> {B} \\<in> C", "using \\<open>?H \\<in> C\\<close> altc"], ["proof (prove)\nusing this:\n  Or A B \\<in> Extend S C f\n  Extend S C f \\<in> C\n  alt_consistency C\n\ngoal (1 subgoal):\n 1. Extend S C f \\<union> {A} \\<in> C \\<or>\n    Extend S C f \\<union> {B} \\<in> C", "unfolding alt_consistency_def"], ["proof (prove)\nusing this:\n  Or A B \\<in> Extend S C f\n  Extend S C f \\<in> C\n  \\<forall>S.\n     S \\<in> C \\<longrightarrow>\n     (\\<forall>p ts.\n         \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)) \\<and>\n     FF \\<notin> S \\<and>\n     Neg TT \\<notin> S \\<and>\n     (\\<forall>Z.\n         Neg (Neg Z) \\<in> S \\<longrightarrow>\n         S \\<union> {Z} \\<in> C) \\<and>\n     (\\<forall>A B.\n         And A B \\<in> S \\<longrightarrow> S \\<union> {A, B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Or A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A, Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Or A B \\<in> S \\<longrightarrow>\n         S \\<union> {A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (And A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Impl A B \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Impl A B) \\<in> S \\<longrightarrow>\n         S \\<union> {A, Neg B} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Forall P \\<in> S \\<longrightarrow>\n         S \\<union> {P[t/0]} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Neg (Exists P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[t/0])} \\<in> C) \\<and>\n     (\\<forall>P x.\n         (\\<forall>a\\<in>S. x \\<notin> params a) \\<longrightarrow>\n         Exists P \\<in> S \\<longrightarrow>\n         S \\<union> {P[App x []/0]} \\<in> C) \\<and>\n     (\\<forall>P x.\n         (\\<forall>a\\<in>S. x \\<notin> params a) \\<longrightarrow>\n         Neg (Forall P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[App x []/0])} \\<in> C)\n\ngoal (1 subgoal):\n 1. Extend S C f \\<union> {A} \\<in> C \\<or>\n    Extend S C f \\<union> {B} \\<in> C", "by fast"], ["proof (state)\nthis:\n  Extend S C f \\<union> {A} \\<in> C \\<or> Extend S C f \\<union> {B} \\<in> C\n\ngoal (7 subgoals):\n 1. \\<And>A B.\n       Or A B \\<in> Extend S C f \\<Longrightarrow>\n       A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 2. \\<And>A B.\n       Neg (And A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> Neg B \\<in> Extend S C f\n 3. \\<And>A B.\n       Impl A B \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 4. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Forall P \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> P[t/0] \\<in> Extend S C f\n 5. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Neg (Exists P) \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> Neg (P[t/0]) \\<in> Extend S C f\n 6. \\<And>P.\n       Exists P \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> Extend S C f\n 7. \\<And>P.\n       Neg (Forall P) \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> Extend S C f", "then"], ["proof (chain)\npicking this:\n  Extend S C f \\<union> {A} \\<in> C \\<or> Extend S C f \\<union> {B} \\<in> C", "show \\<open>A \\<in> ?H \\<or> B \\<in> ?H\\<close>"], ["proof (prove)\nusing this:\n  Extend S C f \\<union> {A} \\<in> C \\<or> Extend S C f \\<union> {B} \\<in> C\n\ngoal (1 subgoal):\n 1. A \\<in> Extend S C f \\<or> B \\<in> Extend S C f", "using \\<open>maximal ?H C\\<close>"], ["proof (prove)\nusing this:\n  Extend S C f \\<union> {A} \\<in> C \\<or> Extend S C f \\<union> {B} \\<in> C\n  maximal (Extend S C f) C\n\ngoal (1 subgoal):\n 1. A \\<in> Extend S C f \\<or> B \\<in> Extend S C f", "unfolding maximal_def"], ["proof (prove)\nusing this:\n  Extend S C f \\<union> {A} \\<in> C \\<or> Extend S C f \\<union> {B} \\<in> C\n  \\<forall>S'\\<in>C.\n     Extend S C f \\<subseteq> S' \\<longrightarrow> Extend S C f = S'\n\ngoal (1 subgoal):\n 1. A \\<in> Extend S C f \\<or> B \\<in> Extend S C f", "by fast"], ["proof (state)\nthis:\n  A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n\ngoal (6 subgoals):\n 1. \\<And>A B.\n       Neg (And A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> Neg B \\<in> Extend S C f\n 2. \\<And>A B.\n       Impl A B \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 3. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Forall P \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> P[t/0] \\<in> Extend S C f\n 4. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Neg (Exists P) \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> Neg (P[t/0]) \\<in> Extend S C f\n 5. \\<And>P.\n       Exists P \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> Extend S C f\n 6. \\<And>P.\n       Neg (Forall P) \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> Extend S C f", "}"], ["proof (state)\nthis:\n  Or ?A2 ?B2 \\<in> Extend S C f \\<Longrightarrow>\n  ?A2 \\<in> Extend S C f \\<or> ?B2 \\<in> Extend S C f\n\ngoal (6 subgoals):\n 1. \\<And>A B.\n       Neg (And A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> Neg B \\<in> Extend S C f\n 2. \\<And>A B.\n       Impl A B \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 3. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Forall P \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> P[t/0] \\<in> Extend S C f\n 4. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Neg (Exists P) \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> Neg (P[t/0]) \\<in> Extend S C f\n 5. \\<And>P.\n       Exists P \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> Extend S C f\n 6. \\<And>P.\n       Neg (Forall P) \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> Extend S C f", "{"], ["proof (state)\nthis:\n  Or ?A2 ?B2 \\<in> Extend S C f \\<Longrightarrow>\n  ?A2 \\<in> Extend S C f \\<or> ?B2 \\<in> Extend S C f\n\ngoal (6 subgoals):\n 1. \\<And>A B.\n       Neg (And A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> Neg B \\<in> Extend S C f\n 2. \\<And>A B.\n       Impl A B \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 3. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Forall P \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> P[t/0] \\<in> Extend S C f\n 4. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Neg (Exists P) \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> Neg (P[t/0]) \\<in> Extend S C f\n 5. \\<And>P.\n       Exists P \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> Extend S C f\n 6. \\<And>P.\n       Neg (Forall P) \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> Extend S C f", "fix A B"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>A B.\n       Neg (And A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> Neg B \\<in> Extend S C f\n 2. \\<And>A B.\n       Impl A B \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 3. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Forall P \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> P[t/0] \\<in> Extend S C f\n 4. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Neg (Exists P) \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> Neg (P[t/0]) \\<in> Extend S C f\n 5. \\<And>P.\n       Exists P \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> Extend S C f\n 6. \\<And>P.\n       Neg (Forall P) \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> Extend S C f", "assume \\<open>Neg (And A B) \\<in> ?H\\<close>"], ["proof (state)\nthis:\n  Neg (And A B) \\<in> Extend S C f\n\ngoal (6 subgoals):\n 1. \\<And>A B.\n       Neg (And A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> Neg B \\<in> Extend S C f\n 2. \\<And>A B.\n       Impl A B \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 3. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Forall P \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> P[t/0] \\<in> Extend S C f\n 4. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Neg (Exists P) \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> Neg (P[t/0]) \\<in> Extend S C f\n 5. \\<And>P.\n       Exists P \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> Extend S C f\n 6. \\<And>P.\n       Neg (Forall P) \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> Extend S C f", "then"], ["proof (chain)\npicking this:\n  Neg (And A B) \\<in> Extend S C f", "have \\<open>?H \\<union> {Neg A} \\<in> C \\<or> ?H \\<union> {Neg B} \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  Neg (And A B) \\<in> Extend S C f\n\ngoal (1 subgoal):\n 1. Extend S C f \\<union> {Neg A} \\<in> C \\<or>\n    Extend S C f \\<union> {Neg B} \\<in> C", "using \\<open>?H \\<in> C\\<close> altc"], ["proof (prove)\nusing this:\n  Neg (And A B) \\<in> Extend S C f\n  Extend S C f \\<in> C\n  alt_consistency C\n\ngoal (1 subgoal):\n 1. Extend S C f \\<union> {Neg A} \\<in> C \\<or>\n    Extend S C f \\<union> {Neg B} \\<in> C", "unfolding alt_consistency_def"], ["proof (prove)\nusing this:\n  Neg (And A B) \\<in> Extend S C f\n  Extend S C f \\<in> C\n  \\<forall>S.\n     S \\<in> C \\<longrightarrow>\n     (\\<forall>p ts.\n         \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)) \\<and>\n     FF \\<notin> S \\<and>\n     Neg TT \\<notin> S \\<and>\n     (\\<forall>Z.\n         Neg (Neg Z) \\<in> S \\<longrightarrow>\n         S \\<union> {Z} \\<in> C) \\<and>\n     (\\<forall>A B.\n         And A B \\<in> S \\<longrightarrow> S \\<union> {A, B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Or A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A, Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Or A B \\<in> S \\<longrightarrow>\n         S \\<union> {A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (And A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Impl A B \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Impl A B) \\<in> S \\<longrightarrow>\n         S \\<union> {A, Neg B} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Forall P \\<in> S \\<longrightarrow>\n         S \\<union> {P[t/0]} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Neg (Exists P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[t/0])} \\<in> C) \\<and>\n     (\\<forall>P x.\n         (\\<forall>a\\<in>S. x \\<notin> params a) \\<longrightarrow>\n         Exists P \\<in> S \\<longrightarrow>\n         S \\<union> {P[App x []/0]} \\<in> C) \\<and>\n     (\\<forall>P x.\n         (\\<forall>a\\<in>S. x \\<notin> params a) \\<longrightarrow>\n         Neg (Forall P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[App x []/0])} \\<in> C)\n\ngoal (1 subgoal):\n 1. Extend S C f \\<union> {Neg A} \\<in> C \\<or>\n    Extend S C f \\<union> {Neg B} \\<in> C", "by simp"], ["proof (state)\nthis:\n  Extend S C f \\<union> {Neg A} \\<in> C \\<or>\n  Extend S C f \\<union> {Neg B} \\<in> C\n\ngoal (6 subgoals):\n 1. \\<And>A B.\n       Neg (And A B) \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> Neg B \\<in> Extend S C f\n 2. \\<And>A B.\n       Impl A B \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 3. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Forall P \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> P[t/0] \\<in> Extend S C f\n 4. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Neg (Exists P) \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> Neg (P[t/0]) \\<in> Extend S C f\n 5. \\<And>P.\n       Exists P \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> Extend S C f\n 6. \\<And>P.\n       Neg (Forall P) \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> Extend S C f", "then"], ["proof (chain)\npicking this:\n  Extend S C f \\<union> {Neg A} \\<in> C \\<or>\n  Extend S C f \\<union> {Neg B} \\<in> C", "show \\<open>Neg A \\<in> ?H \\<or> Neg B \\<in> ?H\\<close>"], ["proof (prove)\nusing this:\n  Extend S C f \\<union> {Neg A} \\<in> C \\<or>\n  Extend S C f \\<union> {Neg B} \\<in> C\n\ngoal (1 subgoal):\n 1. Neg A \\<in> Extend S C f \\<or> Neg B \\<in> Extend S C f", "using \\<open>maximal ?H C\\<close>"], ["proof (prove)\nusing this:\n  Extend S C f \\<union> {Neg A} \\<in> C \\<or>\n  Extend S C f \\<union> {Neg B} \\<in> C\n  maximal (Extend S C f) C\n\ngoal (1 subgoal):\n 1. Neg A \\<in> Extend S C f \\<or> Neg B \\<in> Extend S C f", "unfolding maximal_def"], ["proof (prove)\nusing this:\n  Extend S C f \\<union> {Neg A} \\<in> C \\<or>\n  Extend S C f \\<union> {Neg B} \\<in> C\n  \\<forall>S'\\<in>C.\n     Extend S C f \\<subseteq> S' \\<longrightarrow> Extend S C f = S'\n\ngoal (1 subgoal):\n 1. Neg A \\<in> Extend S C f \\<or> Neg B \\<in> Extend S C f", "by fast"], ["proof (state)\nthis:\n  Neg A \\<in> Extend S C f \\<or> Neg B \\<in> Extend S C f\n\ngoal (5 subgoals):\n 1. \\<And>A B.\n       Impl A B \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 2. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Forall P \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> P[t/0] \\<in> Extend S C f\n 3. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Neg (Exists P) \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> Neg (P[t/0]) \\<in> Extend S C f\n 4. \\<And>P.\n       Exists P \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> Extend S C f\n 5. \\<And>P.\n       Neg (Forall P) \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> Extend S C f", "}"], ["proof (state)\nthis:\n  Neg (And ?A2 ?B2) \\<in> Extend S C f \\<Longrightarrow>\n  Neg ?A2 \\<in> Extend S C f \\<or> Neg ?B2 \\<in> Extend S C f\n\ngoal (5 subgoals):\n 1. \\<And>A B.\n       Impl A B \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 2. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Forall P \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> P[t/0] \\<in> Extend S C f\n 3. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Neg (Exists P) \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> Neg (P[t/0]) \\<in> Extend S C f\n 4. \\<And>P.\n       Exists P \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> Extend S C f\n 5. \\<And>P.\n       Neg (Forall P) \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> Extend S C f", "{"], ["proof (state)\nthis:\n  Neg (And ?A2 ?B2) \\<in> Extend S C f \\<Longrightarrow>\n  Neg ?A2 \\<in> Extend S C f \\<or> Neg ?B2 \\<in> Extend S C f\n\ngoal (5 subgoals):\n 1. \\<And>A B.\n       Impl A B \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 2. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Forall P \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> P[t/0] \\<in> Extend S C f\n 3. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Neg (Exists P) \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> Neg (P[t/0]) \\<in> Extend S C f\n 4. \\<And>P.\n       Exists P \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> Extend S C f\n 5. \\<And>P.\n       Neg (Forall P) \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> Extend S C f", "fix A B"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>A B.\n       Impl A B \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 2. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Forall P \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> P[t/0] \\<in> Extend S C f\n 3. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Neg (Exists P) \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> Neg (P[t/0]) \\<in> Extend S C f\n 4. \\<And>P.\n       Exists P \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> Extend S C f\n 5. \\<And>P.\n       Neg (Forall P) \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> Extend S C f", "assume \\<open>Impl A B \\<in> ?H\\<close>"], ["proof (state)\nthis:\n  Impl A B \\<in> Extend S C f\n\ngoal (5 subgoals):\n 1. \\<And>A B.\n       Impl A B \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 2. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Forall P \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> P[t/0] \\<in> Extend S C f\n 3. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Neg (Exists P) \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> Neg (P[t/0]) \\<in> Extend S C f\n 4. \\<And>P.\n       Exists P \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> Extend S C f\n 5. \\<And>P.\n       Neg (Forall P) \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> Extend S C f", "then"], ["proof (chain)\npicking this:\n  Impl A B \\<in> Extend S C f", "have \\<open>?H \\<union> {Neg A} \\<in> C \\<or> ?H \\<union> {B} \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  Impl A B \\<in> Extend S C f\n\ngoal (1 subgoal):\n 1. Extend S C f \\<union> {Neg A} \\<in> C \\<or>\n    Extend S C f \\<union> {B} \\<in> C", "using \\<open>?H \\<in> C\\<close> altc"], ["proof (prove)\nusing this:\n  Impl A B \\<in> Extend S C f\n  Extend S C f \\<in> C\n  alt_consistency C\n\ngoal (1 subgoal):\n 1. Extend S C f \\<union> {Neg A} \\<in> C \\<or>\n    Extend S C f \\<union> {B} \\<in> C", "unfolding alt_consistency_def"], ["proof (prove)\nusing this:\n  Impl A B \\<in> Extend S C f\n  Extend S C f \\<in> C\n  \\<forall>S.\n     S \\<in> C \\<longrightarrow>\n     (\\<forall>p ts.\n         \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)) \\<and>\n     FF \\<notin> S \\<and>\n     Neg TT \\<notin> S \\<and>\n     (\\<forall>Z.\n         Neg (Neg Z) \\<in> S \\<longrightarrow>\n         S \\<union> {Z} \\<in> C) \\<and>\n     (\\<forall>A B.\n         And A B \\<in> S \\<longrightarrow> S \\<union> {A, B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Or A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A, Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Or A B \\<in> S \\<longrightarrow>\n         S \\<union> {A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (And A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Impl A B \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Impl A B) \\<in> S \\<longrightarrow>\n         S \\<union> {A, Neg B} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Forall P \\<in> S \\<longrightarrow>\n         S \\<union> {P[t/0]} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Neg (Exists P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[t/0])} \\<in> C) \\<and>\n     (\\<forall>P x.\n         (\\<forall>a\\<in>S. x \\<notin> params a) \\<longrightarrow>\n         Exists P \\<in> S \\<longrightarrow>\n         S \\<union> {P[App x []/0]} \\<in> C) \\<and>\n     (\\<forall>P x.\n         (\\<forall>a\\<in>S. x \\<notin> params a) \\<longrightarrow>\n         Neg (Forall P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[App x []/0])} \\<in> C)\n\ngoal (1 subgoal):\n 1. Extend S C f \\<union> {Neg A} \\<in> C \\<or>\n    Extend S C f \\<union> {B} \\<in> C", "by simp"], ["proof (state)\nthis:\n  Extend S C f \\<union> {Neg A} \\<in> C \\<or>\n  Extend S C f \\<union> {B} \\<in> C\n\ngoal (5 subgoals):\n 1. \\<And>A B.\n       Impl A B \\<in> Extend S C f \\<Longrightarrow>\n       Neg A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n 2. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Forall P \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> P[t/0] \\<in> Extend S C f\n 3. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Neg (Exists P) \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> Neg (P[t/0]) \\<in> Extend S C f\n 4. \\<And>P.\n       Exists P \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> Extend S C f\n 5. \\<And>P.\n       Neg (Forall P) \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> Extend S C f", "then"], ["proof (chain)\npicking this:\n  Extend S C f \\<union> {Neg A} \\<in> C \\<or>\n  Extend S C f \\<union> {B} \\<in> C", "show \\<open>Neg A \\<in> ?H \\<or> B \\<in> ?H\\<close>"], ["proof (prove)\nusing this:\n  Extend S C f \\<union> {Neg A} \\<in> C \\<or>\n  Extend S C f \\<union> {B} \\<in> C\n\ngoal (1 subgoal):\n 1. Neg A \\<in> Extend S C f \\<or> B \\<in> Extend S C f", "using \\<open>maximal ?H C\\<close>"], ["proof (prove)\nusing this:\n  Extend S C f \\<union> {Neg A} \\<in> C \\<or>\n  Extend S C f \\<union> {B} \\<in> C\n  maximal (Extend S C f) C\n\ngoal (1 subgoal):\n 1. Neg A \\<in> Extend S C f \\<or> B \\<in> Extend S C f", "unfolding maximal_def"], ["proof (prove)\nusing this:\n  Extend S C f \\<union> {Neg A} \\<in> C \\<or>\n  Extend S C f \\<union> {B} \\<in> C\n  \\<forall>S'\\<in>C.\n     Extend S C f \\<subseteq> S' \\<longrightarrow> Extend S C f = S'\n\ngoal (1 subgoal):\n 1. Neg A \\<in> Extend S C f \\<or> B \\<in> Extend S C f", "by fast"], ["proof (state)\nthis:\n  Neg A \\<in> Extend S C f \\<or> B \\<in> Extend S C f\n\ngoal (4 subgoals):\n 1. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Forall P \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> P[t/0] \\<in> Extend S C f\n 2. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Neg (Exists P) \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> Neg (P[t/0]) \\<in> Extend S C f\n 3. \\<And>P.\n       Exists P \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> Extend S C f\n 4. \\<And>P.\n       Neg (Forall P) \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> Extend S C f", "}"], ["proof (state)\nthis:\n  Impl ?A2 ?B2 \\<in> Extend S C f \\<Longrightarrow>\n  Neg ?A2 \\<in> Extend S C f \\<or> ?B2 \\<in> Extend S C f\n\ngoal (4 subgoals):\n 1. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Forall P \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> P[t/0] \\<in> Extend S C f\n 2. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Neg (Exists P) \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> Neg (P[t/0]) \\<in> Extend S C f\n 3. \\<And>P.\n       Exists P \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> Extend S C f\n 4. \\<And>P.\n       Neg (Forall P) \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> Extend S C f", "{"], ["proof (state)\nthis:\n  Impl ?A2 ?B2 \\<in> Extend S C f \\<Longrightarrow>\n  Neg ?A2 \\<in> Extend S C f \\<or> ?B2 \\<in> Extend S C f\n\ngoal (4 subgoals):\n 1. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Forall P \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> P[t/0] \\<in> Extend S C f\n 2. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Neg (Exists P) \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> Neg (P[t/0]) \\<in> Extend S C f\n 3. \\<And>P.\n       Exists P \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> Extend S C f\n 4. \\<And>P.\n       Neg (Forall P) \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> Extend S C f", "fix P and t :: \\<open>nat term\\<close>"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Forall P \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> P[t/0] \\<in> Extend S C f\n 2. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Neg (Exists P) \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> Neg (P[t/0]) \\<in> Extend S C f\n 3. \\<And>P.\n       Exists P \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> Extend S C f\n 4. \\<And>P.\n       Neg (Forall P) \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> Extend S C f", "assume \\<open>Forall P \\<in> ?H\\<close> and \\<open>closedt 0 t\\<close>"], ["proof (state)\nthis:\n  Forall P \\<in> Extend S C f\n  closedt 0 t\n\ngoal (4 subgoals):\n 1. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Forall P \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> P[t/0] \\<in> Extend S C f\n 2. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Neg (Exists P) \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> Neg (P[t/0]) \\<in> Extend S C f\n 3. \\<And>P.\n       Exists P \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> Extend S C f\n 4. \\<And>P.\n       Neg (Forall P) \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> Extend S C f", "then"], ["proof (chain)\npicking this:\n  Forall P \\<in> Extend S C f\n  closedt 0 t", "have \\<open>?H \\<union> {P[t/0]} \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  Forall P \\<in> Extend S C f\n  closedt 0 t\n\ngoal (1 subgoal):\n 1. Extend S C f \\<union> {P[t/0]} \\<in> C", "using \\<open>?H \\<in> C\\<close> altc"], ["proof (prove)\nusing this:\n  Forall P \\<in> Extend S C f\n  closedt 0 t\n  Extend S C f \\<in> C\n  alt_consistency C\n\ngoal (1 subgoal):\n 1. Extend S C f \\<union> {P[t/0]} \\<in> C", "unfolding alt_consistency_def"], ["proof (prove)\nusing this:\n  Forall P \\<in> Extend S C f\n  closedt 0 t\n  Extend S C f \\<in> C\n  \\<forall>S.\n     S \\<in> C \\<longrightarrow>\n     (\\<forall>p ts.\n         \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)) \\<and>\n     FF \\<notin> S \\<and>\n     Neg TT \\<notin> S \\<and>\n     (\\<forall>Z.\n         Neg (Neg Z) \\<in> S \\<longrightarrow>\n         S \\<union> {Z} \\<in> C) \\<and>\n     (\\<forall>A B.\n         And A B \\<in> S \\<longrightarrow> S \\<union> {A, B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Or A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A, Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Or A B \\<in> S \\<longrightarrow>\n         S \\<union> {A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (And A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Impl A B \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Impl A B) \\<in> S \\<longrightarrow>\n         S \\<union> {A, Neg B} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Forall P \\<in> S \\<longrightarrow>\n         S \\<union> {P[t/0]} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Neg (Exists P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[t/0])} \\<in> C) \\<and>\n     (\\<forall>P x.\n         (\\<forall>a\\<in>S. x \\<notin> params a) \\<longrightarrow>\n         Exists P \\<in> S \\<longrightarrow>\n         S \\<union> {P[App x []/0]} \\<in> C) \\<and>\n     (\\<forall>P x.\n         (\\<forall>a\\<in>S. x \\<notin> params a) \\<longrightarrow>\n         Neg (Forall P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[App x []/0])} \\<in> C)\n\ngoal (1 subgoal):\n 1. Extend S C f \\<union> {P[t/0]} \\<in> C", "by blast"], ["proof (state)\nthis:\n  Extend S C f \\<union> {P[t/0]} \\<in> C\n\ngoal (4 subgoals):\n 1. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Forall P \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> P[t/0] \\<in> Extend S C f\n 2. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Neg (Exists P) \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> Neg (P[t/0]) \\<in> Extend S C f\n 3. \\<And>P.\n       Exists P \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> Extend S C f\n 4. \\<And>P.\n       Neg (Forall P) \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> Extend S C f", "then"], ["proof (chain)\npicking this:\n  Extend S C f \\<union> {P[t/0]} \\<in> C", "show \\<open>P[t/0] \\<in> ?H\\<close>"], ["proof (prove)\nusing this:\n  Extend S C f \\<union> {P[t/0]} \\<in> C\n\ngoal (1 subgoal):\n 1. P[t/0] \\<in> Extend S C f", "using \\<open>maximal ?H C\\<close>"], ["proof (prove)\nusing this:\n  Extend S C f \\<union> {P[t/0]} \\<in> C\n  maximal (Extend S C f) C\n\ngoal (1 subgoal):\n 1. P[t/0] \\<in> Extend S C f", "unfolding maximal_def"], ["proof (prove)\nusing this:\n  Extend S C f \\<union> {P[t/0]} \\<in> C\n  \\<forall>S'\\<in>C.\n     Extend S C f \\<subseteq> S' \\<longrightarrow> Extend S C f = S'\n\ngoal (1 subgoal):\n 1. P[t/0] \\<in> Extend S C f", "by fast"], ["proof (state)\nthis:\n  P[t/0] \\<in> Extend S C f\n\ngoal (3 subgoals):\n 1. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Neg (Exists P) \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> Neg (P[t/0]) \\<in> Extend S C f\n 2. \\<And>P.\n       Exists P \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> Extend S C f\n 3. \\<And>P.\n       Neg (Forall P) \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> Extend S C f", "}"], ["proof (state)\nthis:\n  \\<lbrakk>Forall ?P2 \\<in> Extend S C f; closedt 0 ?t2\\<rbrakk>\n  \\<Longrightarrow> ?P2[?t2/0] \\<in> Extend S C f\n\ngoal (3 subgoals):\n 1. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Neg (Exists P) \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> Neg (P[t/0]) \\<in> Extend S C f\n 2. \\<And>P.\n       Exists P \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> Extend S C f\n 3. \\<And>P.\n       Neg (Forall P) \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> Extend S C f", "{"], ["proof (state)\nthis:\n  \\<lbrakk>Forall ?P2 \\<in> Extend S C f; closedt 0 ?t2\\<rbrakk>\n  \\<Longrightarrow> ?P2[?t2/0] \\<in> Extend S C f\n\ngoal (3 subgoals):\n 1. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Neg (Exists P) \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> Neg (P[t/0]) \\<in> Extend S C f\n 2. \\<And>P.\n       Exists P \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> Extend S C f\n 3. \\<And>P.\n       Neg (Forall P) \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> Extend S C f", "fix P and t :: \\<open>nat term\\<close>"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Neg (Exists P) \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> Neg (P[t/0]) \\<in> Extend S C f\n 2. \\<And>P.\n       Exists P \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> Extend S C f\n 3. \\<And>P.\n       Neg (Forall P) \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> Extend S C f", "assume \\<open>Neg (Exists P) \\<in> ?H\\<close> and \\<open>closedt 0 t\\<close>"], ["proof (state)\nthis:\n  Neg (Exists P) \\<in> Extend S C f\n  closedt 0 t\n\ngoal (3 subgoals):\n 1. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Neg (Exists P) \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> Neg (P[t/0]) \\<in> Extend S C f\n 2. \\<And>P.\n       Exists P \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> Extend S C f\n 3. \\<And>P.\n       Neg (Forall P) \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> Extend S C f", "then"], ["proof (chain)\npicking this:\n  Neg (Exists P) \\<in> Extend S C f\n  closedt 0 t", "have \\<open>?H \\<union> {Neg (P[t/0])} \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  Neg (Exists P) \\<in> Extend S C f\n  closedt 0 t\n\ngoal (1 subgoal):\n 1. Extend S C f \\<union> {Neg (P[t/0])} \\<in> C", "using \\<open>?H \\<in> C\\<close> altc"], ["proof (prove)\nusing this:\n  Neg (Exists P) \\<in> Extend S C f\n  closedt 0 t\n  Extend S C f \\<in> C\n  alt_consistency C\n\ngoal (1 subgoal):\n 1. Extend S C f \\<union> {Neg (P[t/0])} \\<in> C", "unfolding alt_consistency_def"], ["proof (prove)\nusing this:\n  Neg (Exists P) \\<in> Extend S C f\n  closedt 0 t\n  Extend S C f \\<in> C\n  \\<forall>S.\n     S \\<in> C \\<longrightarrow>\n     (\\<forall>p ts.\n         \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)) \\<and>\n     FF \\<notin> S \\<and>\n     Neg TT \\<notin> S \\<and>\n     (\\<forall>Z.\n         Neg (Neg Z) \\<in> S \\<longrightarrow>\n         S \\<union> {Z} \\<in> C) \\<and>\n     (\\<forall>A B.\n         And A B \\<in> S \\<longrightarrow> S \\<union> {A, B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Or A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A, Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Or A B \\<in> S \\<longrightarrow>\n         S \\<union> {A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (And A B) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {Neg B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Impl A B \\<in> S \\<longrightarrow>\n         S \\<union> {Neg A} \\<in> C \\<or> S \\<union> {B} \\<in> C) \\<and>\n     (\\<forall>A B.\n         Neg (Impl A B) \\<in> S \\<longrightarrow>\n         S \\<union> {A, Neg B} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Forall P \\<in> S \\<longrightarrow>\n         S \\<union> {P[t/0]} \\<in> C) \\<and>\n     (\\<forall>P t.\n         closedt 0 t \\<longrightarrow>\n         Neg (Exists P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[t/0])} \\<in> C) \\<and>\n     (\\<forall>P x.\n         (\\<forall>a\\<in>S. x \\<notin> params a) \\<longrightarrow>\n         Exists P \\<in> S \\<longrightarrow>\n         S \\<union> {P[App x []/0]} \\<in> C) \\<and>\n     (\\<forall>P x.\n         (\\<forall>a\\<in>S. x \\<notin> params a) \\<longrightarrow>\n         Neg (Forall P) \\<in> S \\<longrightarrow>\n         S \\<union> {Neg (P[App x []/0])} \\<in> C)\n\ngoal (1 subgoal):\n 1. Extend S C f \\<union> {Neg (P[t/0])} \\<in> C", "by blast"], ["proof (state)\nthis:\n  Extend S C f \\<union> {Neg (P[t/0])} \\<in> C\n\ngoal (3 subgoals):\n 1. \\<And>P t.\n       \\<lbrakk>closedt 0 t; Neg (Exists P) \\<in> Extend S C f\\<rbrakk>\n       \\<Longrightarrow> Neg (P[t/0]) \\<in> Extend S C f\n 2. \\<And>P.\n       Exists P \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> Extend S C f\n 3. \\<And>P.\n       Neg (Forall P) \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> Extend S C f", "then"], ["proof (chain)\npicking this:\n  Extend S C f \\<union> {Neg (P[t/0])} \\<in> C", "show \\<open>Neg (P[t/0]) \\<in> ?H\\<close>"], ["proof (prove)\nusing this:\n  Extend S C f \\<union> {Neg (P[t/0])} \\<in> C\n\ngoal (1 subgoal):\n 1. Neg (P[t/0]) \\<in> Extend S C f", "using \\<open>maximal ?H C\\<close>"], ["proof (prove)\nusing this:\n  Extend S C f \\<union> {Neg (P[t/0])} \\<in> C\n  maximal (Extend S C f) C\n\ngoal (1 subgoal):\n 1. Neg (P[t/0]) \\<in> Extend S C f", "unfolding maximal_def"], ["proof (prove)\nusing this:\n  Extend S C f \\<union> {Neg (P[t/0])} \\<in> C\n  \\<forall>S'\\<in>C.\n     Extend S C f \\<subseteq> S' \\<longrightarrow> Extend S C f = S'\n\ngoal (1 subgoal):\n 1. Neg (P[t/0]) \\<in> Extend S C f", "by fast"], ["proof (state)\nthis:\n  Neg (P[t/0]) \\<in> Extend S C f\n\ngoal (2 subgoals):\n 1. \\<And>P.\n       Exists P \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> Extend S C f\n 2. \\<And>P.\n       Neg (Forall P) \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> Extend S C f", "}"], ["proof (state)\nthis:\n  \\<lbrakk>Neg (Exists ?P2) \\<in> Extend S C f; closedt 0 ?t2\\<rbrakk>\n  \\<Longrightarrow> Neg (?P2[?t2/0]) \\<in> Extend S C f\n\ngoal (2 subgoals):\n 1. \\<And>P.\n       Exists P \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> Extend S C f\n 2. \\<And>P.\n       Neg (Forall P) \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> Extend S C f", "{"], ["proof (state)\nthis:\n  \\<lbrakk>Neg (Exists ?P2) \\<in> Extend S C f; closedt 0 ?t2\\<rbrakk>\n  \\<Longrightarrow> Neg (?P2[?t2/0]) \\<in> Extend S C f\n\ngoal (2 subgoals):\n 1. \\<And>P.\n       Exists P \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> Extend S C f\n 2. \\<And>P.\n       Neg (Forall P) \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> Extend S C f", "fix P"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>P.\n       Exists P \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> Extend S C f\n 2. \\<And>P.\n       Neg (Forall P) \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> Extend S C f", "assume \\<open>Exists P \\<in> ?H\\<close>"], ["proof (state)\nthis:\n  Exists P \\<in> Extend S C f\n\ngoal (2 subgoals):\n 1. \\<And>P.\n       Exists P \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> Extend S C f\n 2. \\<And>P.\n       Neg (Forall P) \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> Extend S C f", "obtain n where *: \\<open>Exists P = f n\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n. Exists P = f n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using surj"], ["proof (prove)\nusing this:\n  \\<forall>y. \\<exists>n. y = f n\n\ngoal (1 subgoal):\n 1. (\\<And>n. Exists P = f n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  Exists P = f n\n\ngoal (2 subgoals):\n 1. \\<And>P.\n       Exists P \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> Extend S C f\n 2. \\<And>P.\n       Neg (Forall P) \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> Extend S C f", "let ?t = \\<open>App (SOME k. k \\<notin> (\\<Union>p \\<in> extend S C f n \\<union> {f n}. params p)) []\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>P.\n       Exists P \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> Extend S C f\n 2. \\<And>P.\n       Neg (Forall P) \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> Extend S C f", "have \\<open>closedt 0 ?t\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. closedt 0\n     (App (SOME k.\n              k \\<notin> \\<Union>\n                          (params ` (extend S C f n \\<union> {f n})))\n       [])", "by simp"], ["proof (state)\nthis:\n  closedt 0\n   (App (SOME k.\n            k \\<notin> \\<Union> (params ` (extend S C f n \\<union> {f n})))\n     [])\n\ngoal (2 subgoals):\n 1. \\<And>P.\n       Exists P \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> Extend S C f\n 2. \\<And>P.\n       Neg (Forall P) \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> Extend S C f", "have \\<open>Exists P \\<in> (\\<Union>n. extend S C f n)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Exists P \\<in> \\<Union> (range (extend S C f))", "using \\<open>Exists P \\<in> ?H\\<close> Extend_def"], ["proof (prove)\nusing this:\n  Exists P \\<in> Extend S C f\n  Extend ?S ?C ?f = \\<Union> (range (extend ?S ?C ?f))\n\ngoal (1 subgoal):\n 1. Exists P \\<in> \\<Union> (range (extend S C f))", "by blast"], ["proof (state)\nthis:\n  Exists P \\<in> \\<Union> (range (extend S C f))\n\ngoal (2 subgoals):\n 1. \\<And>P.\n       Exists P \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> Extend S C f\n 2. \\<And>P.\n       Neg (Forall P) \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> Extend S C f", "then"], ["proof (chain)\npicking this:\n  Exists P \\<in> \\<Union> (range (extend S C f))", "have \\<open>extend S C f n \\<union> {f n} \\<subseteq> (\\<Union>n. extend S C f n)\\<close>"], ["proof (prove)\nusing this:\n  Exists P \\<in> \\<Union> (range (extend S C f))\n\ngoal (1 subgoal):\n 1. extend S C f n \\<union> {f n}\n    \\<subseteq> \\<Union> (range (extend S C f))", "using *"], ["proof (prove)\nusing this:\n  Exists P \\<in> \\<Union> (range (extend S C f))\n  Exists P = f n\n\ngoal (1 subgoal):\n 1. extend S C f n \\<union> {f n}\n    \\<subseteq> \\<Union> (range (extend S C f))", "by (simp add: UN_upper)"], ["proof (state)\nthis:\n  extend S C f n \\<union> {f n} \\<subseteq> \\<Union> (range (extend S C f))\n\ngoal (2 subgoals):\n 1. \\<And>P.\n       Exists P \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> Extend S C f\n 2. \\<And>P.\n       Neg (Forall P) \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> Extend S C f", "then"], ["proof (chain)\npicking this:\n  extend S C f n \\<union> {f n} \\<subseteq> \\<Union> (range (extend S C f))", "have \\<open>extend S C f n \\<union> {f n} \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  extend S C f n \\<union> {f n} \\<subseteq> \\<Union> (range (extend S C f))\n\ngoal (1 subgoal):\n 1. extend S C f n \\<union> {f n} \\<in> C", "using Extend_def \\<open>Extend S C f \\<in> C\\<close> fin_ch finite_char_closed"], ["proof (prove)\nusing this:\n  extend S C f n \\<union> {f n} \\<subseteq> \\<Union> (range (extend S C f))\n  Extend ?S ?C ?f = \\<Union> (range (extend ?S ?C ?f))\n  Extend S C f \\<in> C\n  finite_char C\n  finite_char ?C \\<Longrightarrow> subset_closed ?C\n\ngoal (1 subgoal):\n 1. extend S C f n \\<union> {f n} \\<in> C", "unfolding subset_closed_def"], ["proof (prove)\nusing this:\n  extend S C f n \\<union> {f n} \\<subseteq> \\<Union> (range (extend S C f))\n  Extend ?S ?C ?f = \\<Union> (range (extend ?S ?C ?f))\n  Extend S C f \\<in> C\n  finite_char C\n  finite_char ?C \\<Longrightarrow>\n  \\<forall>S'\\<in>?C. \\<forall>S\\<subseteq>S'. S \\<in> ?C\n\ngoal (1 subgoal):\n 1. extend S C f n \\<union> {f n} \\<in> C", "by metis"], ["proof (state)\nthis:\n  extend S C f n \\<union> {f n} \\<in> C\n\ngoal (2 subgoals):\n 1. \\<And>P.\n       Exists P \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> Extend S C f\n 2. \\<And>P.\n       Neg (Forall P) \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> Extend S C f", "then"], ["proof (chain)\npicking this:\n  extend S C f n \\<union> {f n} \\<in> C", "have \\<open>P[?t/0] \\<in> extend S C f (Suc n)\\<close>"], ["proof (prove)\nusing this:\n  extend S C f n \\<union> {f n} \\<in> C\n\ngoal (1 subgoal):\n 1. P[App (SOME k.\n              k \\<notin> \\<Union>\n                          (params ` (extend S C f n \\<union> {f n})))\n       []/0]\n    \\<in> extend S C f (Suc n)", "using * Exists_in_extend"], ["proof (prove)\nusing this:\n  extend S C f n \\<union> {f n} \\<in> C\n  Exists P = f n\n  \\<lbrakk>extend ?S ?C ?f ?n \\<union> {?f ?n} \\<in> ?C;\n   Exists ?P = ?f ?n\\<rbrakk>\n  \\<Longrightarrow> ?P[App (SOME k.\n                               k \\<notin> \\<Union>\n     (params ` (extend ?S ?C ?f ?n \\<union> {?f ?n})))\n                        []/0]\n                    \\<in> extend ?S ?C ?f (Suc ?n)\n\ngoal (1 subgoal):\n 1. P[App (SOME k.\n              k \\<notin> \\<Union>\n                          (params ` (extend S C f n \\<union> {f n})))\n       []/0]\n    \\<in> extend S C f (Suc n)", "by blast"], ["proof (state)\nthis:\n  P[App (SOME k.\n            k \\<notin> \\<Union> (params ` (extend S C f n \\<union> {f n})))\n     []/0]\n  \\<in> extend S C f (Suc n)\n\ngoal (2 subgoals):\n 1. \\<And>P.\n       Exists P \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> Extend S C f\n 2. \\<And>P.\n       Neg (Forall P) \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> Extend S C f", "then"], ["proof (chain)\npicking this:\n  P[App (SOME k.\n            k \\<notin> \\<Union> (params ` (extend S C f n \\<union> {f n})))\n     []/0]\n  \\<in> extend S C f (Suc n)", "have \\<open>P[?t/0] \\<in> ?H\\<close>"], ["proof (prove)\nusing this:\n  P[App (SOME k.\n            k \\<notin> \\<Union> (params ` (extend S C f n \\<union> {f n})))\n     []/0]\n  \\<in> extend S C f (Suc n)\n\ngoal (1 subgoal):\n 1. P[App (SOME k.\n              k \\<notin> \\<Union>\n                          (params ` (extend S C f n \\<union> {f n})))\n       []/0]\n    \\<in> Extend S C f", "using Extend_def"], ["proof (prove)\nusing this:\n  P[App (SOME k.\n            k \\<notin> \\<Union> (params ` (extend S C f n \\<union> {f n})))\n     []/0]\n  \\<in> extend S C f (Suc n)\n  Extend ?S ?C ?f = \\<Union> (range (extend ?S ?C ?f))\n\ngoal (1 subgoal):\n 1. P[App (SOME k.\n              k \\<notin> \\<Union>\n                          (params ` (extend S C f n \\<union> {f n})))\n       []/0]\n    \\<in> Extend S C f", "by blast"], ["proof (state)\nthis:\n  P[App (SOME k.\n            k \\<notin> \\<Union> (params ` (extend S C f n \\<union> {f n})))\n     []/0]\n  \\<in> Extend S C f\n\ngoal (2 subgoals):\n 1. \\<And>P.\n       Exists P \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> Extend S C f\n 2. \\<And>P.\n       Neg (Forall P) \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> Extend S C f", "then"], ["proof (chain)\npicking this:\n  P[App (SOME k.\n            k \\<notin> \\<Union> (params ` (extend S C f n \\<union> {f n})))\n     []/0]\n  \\<in> Extend S C f", "show \\<open>\\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> ?H\\<close>"], ["proof (prove)\nusing this:\n  P[App (SOME k.\n            k \\<notin> \\<Union> (params ` (extend S C f n \\<union> {f n})))\n     []/0]\n  \\<in> Extend S C f\n\ngoal (1 subgoal):\n 1. \\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> Extend S C f", "using \\<open>closedt 0 ?t\\<close>"], ["proof (prove)\nusing this:\n  P[App (SOME k.\n            k \\<notin> \\<Union> (params ` (extend S C f n \\<union> {f n})))\n     []/0]\n  \\<in> Extend S C f\n  closedt 0\n   (App (SOME k.\n            k \\<notin> \\<Union> (params ` (extend S C f n \\<union> {f n})))\n     [])\n\ngoal (1 subgoal):\n 1. \\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> Extend S C f", "by blast"], ["proof (state)\nthis:\n  \\<exists>t. closedt 0 t \\<and> P[t/0] \\<in> Extend S C f\n\ngoal (1 subgoal):\n 1. \\<And>P.\n       Neg (Forall P) \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> Extend S C f", "}"], ["proof (state)\nthis:\n  Exists ?P2 \\<in> Extend S C f \\<Longrightarrow>\n  \\<exists>t. closedt 0 t \\<and> ?P2[t/0] \\<in> Extend S C f\n\ngoal (1 subgoal):\n 1. \\<And>P.\n       Neg (Forall P) \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> Extend S C f", "{"], ["proof (state)\nthis:\n  Exists ?P2 \\<in> Extend S C f \\<Longrightarrow>\n  \\<exists>t. closedt 0 t \\<and> ?P2[t/0] \\<in> Extend S C f\n\ngoal (1 subgoal):\n 1. \\<And>P.\n       Neg (Forall P) \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> Extend S C f", "fix P"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P.\n       Neg (Forall P) \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> Extend S C f", "assume \\<open>Neg (Forall P) \\<in> ?H\\<close>"], ["proof (state)\nthis:\n  Neg (Forall P) \\<in> Extend S C f\n\ngoal (1 subgoal):\n 1. \\<And>P.\n       Neg (Forall P) \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> Extend S C f", "obtain n where *: \\<open>Neg (Forall P) = f n\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n.\n        Neg (Forall P) = f n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using surj"], ["proof (prove)\nusing this:\n  \\<forall>y. \\<exists>n. y = f n\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        Neg (Forall P) = f n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  Neg (Forall P) = f n\n\ngoal (1 subgoal):\n 1. \\<And>P.\n       Neg (Forall P) \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> Extend S C f", "let ?t = \\<open>App (SOME k. k \\<notin> (\\<Union>p \\<in> extend S C f n \\<union> {f n}. params p)) []\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P.\n       Neg (Forall P) \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> Extend S C f", "have \\<open>closedt 0 ?t\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. closedt 0\n     (App (SOME k.\n              k \\<notin> \\<Union>\n                          (params ` (extend S C f n \\<union> {f n})))\n       [])", "by simp"], ["proof (state)\nthis:\n  closedt 0\n   (App (SOME k.\n            k \\<notin> \\<Union> (params ` (extend S C f n \\<union> {f n})))\n     [])\n\ngoal (1 subgoal):\n 1. \\<And>P.\n       Neg (Forall P) \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> Extend S C f", "have \\<open>Neg (Forall P) \\<in> (\\<Union>n. extend S C f n)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Neg (Forall P) \\<in> \\<Union> (range (extend S C f))", "using \\<open>Neg (Forall P) \\<in> ?H\\<close> Extend_def"], ["proof (prove)\nusing this:\n  Neg (Forall P) \\<in> Extend S C f\n  Extend ?S ?C ?f = \\<Union> (range (extend ?S ?C ?f))\n\ngoal (1 subgoal):\n 1. Neg (Forall P) \\<in> \\<Union> (range (extend S C f))", "by blast"], ["proof (state)\nthis:\n  Neg (Forall P) \\<in> \\<Union> (range (extend S C f))\n\ngoal (1 subgoal):\n 1. \\<And>P.\n       Neg (Forall P) \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> Extend S C f", "then"], ["proof (chain)\npicking this:\n  Neg (Forall P) \\<in> \\<Union> (range (extend S C f))", "have \\<open>extend S C f n \\<union> {f n} \\<subseteq> (\\<Union>n. extend S C f n)\\<close>"], ["proof (prove)\nusing this:\n  Neg (Forall P) \\<in> \\<Union> (range (extend S C f))\n\ngoal (1 subgoal):\n 1. extend S C f n \\<union> {f n}\n    \\<subseteq> \\<Union> (range (extend S C f))", "using *"], ["proof (prove)\nusing this:\n  Neg (Forall P) \\<in> \\<Union> (range (extend S C f))\n  Neg (Forall P) = f n\n\ngoal (1 subgoal):\n 1. extend S C f n \\<union> {f n}\n    \\<subseteq> \\<Union> (range (extend S C f))", "by (simp add: UN_upper)"], ["proof (state)\nthis:\n  extend S C f n \\<union> {f n} \\<subseteq> \\<Union> (range (extend S C f))\n\ngoal (1 subgoal):\n 1. \\<And>P.\n       Neg (Forall P) \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> Extend S C f", "then"], ["proof (chain)\npicking this:\n  extend S C f n \\<union> {f n} \\<subseteq> \\<Union> (range (extend S C f))", "have \\<open>extend S C f n \\<union> {f n} \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  extend S C f n \\<union> {f n} \\<subseteq> \\<Union> (range (extend S C f))\n\ngoal (1 subgoal):\n 1. extend S C f n \\<union> {f n} \\<in> C", "using Extend_def \\<open>Extend S C f \\<in> C\\<close> fin_ch finite_char_closed"], ["proof (prove)\nusing this:\n  extend S C f n \\<union> {f n} \\<subseteq> \\<Union> (range (extend S C f))\n  Extend ?S ?C ?f = \\<Union> (range (extend ?S ?C ?f))\n  Extend S C f \\<in> C\n  finite_char C\n  finite_char ?C \\<Longrightarrow> subset_closed ?C\n\ngoal (1 subgoal):\n 1. extend S C f n \\<union> {f n} \\<in> C", "unfolding subset_closed_def"], ["proof (prove)\nusing this:\n  extend S C f n \\<union> {f n} \\<subseteq> \\<Union> (range (extend S C f))\n  Extend ?S ?C ?f = \\<Union> (range (extend ?S ?C ?f))\n  Extend S C f \\<in> C\n  finite_char C\n  finite_char ?C \\<Longrightarrow>\n  \\<forall>S'\\<in>?C. \\<forall>S\\<subseteq>S'. S \\<in> ?C\n\ngoal (1 subgoal):\n 1. extend S C f n \\<union> {f n} \\<in> C", "by metis"], ["proof (state)\nthis:\n  extend S C f n \\<union> {f n} \\<in> C\n\ngoal (1 subgoal):\n 1. \\<And>P.\n       Neg (Forall P) \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> Extend S C f", "then"], ["proof (chain)\npicking this:\n  extend S C f n \\<union> {f n} \\<in> C", "have \\<open>Neg (P[?t/0]) \\<in> extend S C f (Suc n)\\<close>"], ["proof (prove)\nusing this:\n  extend S C f n \\<union> {f n} \\<in> C\n\ngoal (1 subgoal):\n 1. Neg (P[App (SOME k.\n                   k \\<notin> \\<Union>\n                               (params ` (extend S C f n \\<union> {f n})))\n            []/0])\n    \\<in> extend S C f (Suc n)", "using * Neg_Forall_in_extend"], ["proof (prove)\nusing this:\n  extend S C f n \\<union> {f n} \\<in> C\n  Neg (Forall P) = f n\n  \\<lbrakk>extend ?S ?C ?f ?n \\<union> {?f ?n} \\<in> ?C;\n   Neg (Forall ?P) = ?f ?n\\<rbrakk>\n  \\<Longrightarrow> Neg (?P[App (SOME k.\n                                    k \\<notin> \\<Union>\n          (params ` (extend ?S ?C ?f ?n \\<union> {?f ?n})))\n                             []/0])\n                    \\<in> extend ?S ?C ?f (Suc ?n)\n\ngoal (1 subgoal):\n 1. Neg (P[App (SOME k.\n                   k \\<notin> \\<Union>\n                               (params ` (extend S C f n \\<union> {f n})))\n            []/0])\n    \\<in> extend S C f (Suc n)", "by blast"], ["proof (state)\nthis:\n  Neg (P[App (SOME k.\n                 k \\<notin> \\<Union>\n                             (params ` (extend S C f n \\<union> {f n})))\n          []/0])\n  \\<in> extend S C f (Suc n)\n\ngoal (1 subgoal):\n 1. \\<And>P.\n       Neg (Forall P) \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> Extend S C f", "then"], ["proof (chain)\npicking this:\n  Neg (P[App (SOME k.\n                 k \\<notin> \\<Union>\n                             (params ` (extend S C f n \\<union> {f n})))\n          []/0])\n  \\<in> extend S C f (Suc n)", "have \\<open>Neg (P[?t/0]) \\<in> ?H\\<close>"], ["proof (prove)\nusing this:\n  Neg (P[App (SOME k.\n                 k \\<notin> \\<Union>\n                             (params ` (extend S C f n \\<union> {f n})))\n          []/0])\n  \\<in> extend S C f (Suc n)\n\ngoal (1 subgoal):\n 1. Neg (P[App (SOME k.\n                   k \\<notin> \\<Union>\n                               (params ` (extend S C f n \\<union> {f n})))\n            []/0])\n    \\<in> Extend S C f", "using Extend_def"], ["proof (prove)\nusing this:\n  Neg (P[App (SOME k.\n                 k \\<notin> \\<Union>\n                             (params ` (extend S C f n \\<union> {f n})))\n          []/0])\n  \\<in> extend S C f (Suc n)\n  Extend ?S ?C ?f = \\<Union> (range (extend ?S ?C ?f))\n\ngoal (1 subgoal):\n 1. Neg (P[App (SOME k.\n                   k \\<notin> \\<Union>\n                               (params ` (extend S C f n \\<union> {f n})))\n            []/0])\n    \\<in> Extend S C f", "by blast"], ["proof (state)\nthis:\n  Neg (P[App (SOME k.\n                 k \\<notin> \\<Union>\n                             (params ` (extend S C f n \\<union> {f n})))\n          []/0])\n  \\<in> Extend S C f\n\ngoal (1 subgoal):\n 1. \\<And>P.\n       Neg (Forall P) \\<in> Extend S C f \\<Longrightarrow>\n       \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> Extend S C f", "then"], ["proof (chain)\npicking this:\n  Neg (P[App (SOME k.\n                 k \\<notin> \\<Union>\n                             (params ` (extend S C f n \\<union> {f n})))\n          []/0])\n  \\<in> Extend S C f", "show \\<open>\\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> ?H\\<close>"], ["proof (prove)\nusing this:\n  Neg (P[App (SOME k.\n                 k \\<notin> \\<Union>\n                             (params ` (extend S C f n \\<union> {f n})))\n          []/0])\n  \\<in> Extend S C f\n\ngoal (1 subgoal):\n 1. \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> Extend S C f", "using \\<open>closedt 0 ?t\\<close>"], ["proof (prove)\nusing this:\n  Neg (P[App (SOME k.\n                 k \\<notin> \\<Union>\n                             (params ` (extend S C f n \\<union> {f n})))\n          []/0])\n  \\<in> Extend S C f\n  closedt 0\n   (App (SOME k.\n            k \\<notin> \\<Union> (params ` (extend S C f n \\<union> {f n})))\n     [])\n\ngoal (1 subgoal):\n 1. \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> Extend S C f", "by blast"], ["proof (state)\nthis:\n  \\<exists>t. closedt 0 t \\<and> Neg (P[t/0]) \\<in> Extend S C f\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  Neg (Forall ?P2) \\<in> Extend S C f \\<Longrightarrow>\n  \\<exists>t. closedt 0 t \\<and> Neg (?P2[t/0]) \\<in> Extend S C f\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Model existence theorem\\<close>"], ["", "text \\<open>\n\\label{sec:model-existence}\nSince the result of extending \\<open>S\\<close> is a superset of \\<open>S\\<close>,\nit follows that each consistent set \\<open>S\\<close> has a Herbrand model:\n\\<close>"], ["", "lemma hintikka_Extend_S:\n  assumes \\<open>consistency C\\<close> and \\<open>S \\<in> C\\<close>\n    and \\<open>infinite (- (\\<Union>p \\<in> S. params p))\\<close>\n  shows \\<open>hintikka (Extend S (mk_finite_char (mk_alt_consistency (close C))) from_nat)\\<close>\n    (is \\<open>hintikka (Extend S ?C' from_nat)\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. hintikka\n     (Extend S (mk_finite_char (mk_alt_consistency (close C))) from_nat)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. hintikka\n     (Extend S (mk_finite_char (mk_alt_consistency (close C))) from_nat)", "have \\<open>finite_char ?C'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite_char (mk_finite_char (mk_alt_consistency (close C)))", "using finite_char"], ["proof (prove)\nusing this:\n  finite_char (mk_finite_char ?C)\n\ngoal (1 subgoal):\n 1. finite_char (mk_finite_char (mk_alt_consistency (close C)))", "by blast"], ["proof (state)\nthis:\n  finite_char (mk_finite_char (mk_alt_consistency (close C)))\n\ngoal (1 subgoal):\n 1. hintikka\n     (Extend S (mk_finite_char (mk_alt_consistency (close C))) from_nat)", "moreover"], ["proof (state)\nthis:\n  finite_char (mk_finite_char (mk_alt_consistency (close C)))\n\ngoal (1 subgoal):\n 1. hintikka\n     (Extend S (mk_finite_char (mk_alt_consistency (close C))) from_nat)", "have \\<open>\\<forall>y. y = from_nat (to_nat y)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y. y = from_nat (to_nat y)", "by simp"], ["proof (state)\nthis:\n  \\<forall>y. y = from_nat (to_nat y)\n\ngoal (1 subgoal):\n 1. hintikka\n     (Extend S (mk_finite_char (mk_alt_consistency (close C))) from_nat)", "then"], ["proof (chain)\npicking this:\n  \\<forall>y. y = from_nat (to_nat y)", "have \\<open>\\<forall>y. \\<exists>n. y = from_nat n\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>y. y = from_nat (to_nat y)\n\ngoal (1 subgoal):\n 1. \\<forall>y. \\<exists>n. y = from_nat n", "by blast"], ["proof (state)\nthis:\n  \\<forall>y. \\<exists>n. y = from_nat n\n\ngoal (1 subgoal):\n 1. hintikka\n     (Extend S (mk_finite_char (mk_alt_consistency (close C))) from_nat)", "moreover"], ["proof (state)\nthis:\n  \\<forall>y. \\<exists>n. y = from_nat n\n\ngoal (1 subgoal):\n 1. hintikka\n     (Extend S (mk_finite_char (mk_alt_consistency (close C))) from_nat)", "have \\<open>alt_consistency ?C'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. alt_consistency (mk_finite_char (mk_alt_consistency (close C)))", "using alt_consistency close_closed close_consistency \\<open>consistency C\\<close>\n      finite_alt_consistency mk_alt_consistency_closed"], ["proof (prove)\nusing this:\n  consistency ?C \\<Longrightarrow> alt_consistency (mk_alt_consistency ?C)\n  subset_closed (close ?C)\n  consistency ?C \\<Longrightarrow> consistency (close ?C)\n  consistency C\n  \\<lbrakk>alt_consistency ?C; subset_closed ?C\\<rbrakk>\n  \\<Longrightarrow> alt_consistency (mk_finite_char ?C)\n  subset_closed ?C \\<Longrightarrow> subset_closed (mk_alt_consistency ?C)\n\ngoal (1 subgoal):\n 1. alt_consistency (mk_finite_char (mk_alt_consistency (close C)))", "by blast"], ["proof (state)\nthis:\n  alt_consistency (mk_finite_char (mk_alt_consistency (close C)))\n\ngoal (1 subgoal):\n 1. hintikka\n     (Extend S (mk_finite_char (mk_alt_consistency (close C))) from_nat)", "moreover"], ["proof (state)\nthis:\n  alt_consistency (mk_finite_char (mk_alt_consistency (close C)))\n\ngoal (1 subgoal):\n 1. hintikka\n     (Extend S (mk_finite_char (mk_alt_consistency (close C))) from_nat)", "have \\<open>S \\<in> close C\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<in> close C", "using close_subset \\<open>S \\<in> C\\<close>"], ["proof (prove)\nusing this:\n  ?C \\<subseteq> close ?C\n  S \\<in> C\n\ngoal (1 subgoal):\n 1. S \\<in> close C", "by blast"], ["proof (state)\nthis:\n  S \\<in> close C\n\ngoal (1 subgoal):\n 1. hintikka\n     (Extend S (mk_finite_char (mk_alt_consistency (close C))) from_nat)", "then"], ["proof (chain)\npicking this:\n  S \\<in> close C", "have \\<open>S \\<in> mk_alt_consistency (close C)\\<close>"], ["proof (prove)\nusing this:\n  S \\<in> close C\n\ngoal (1 subgoal):\n 1. S \\<in> mk_alt_consistency (close C)", "using mk_alt_consistency_subset"], ["proof (prove)\nusing this:\n  S \\<in> close C\n  ?C \\<subseteq> mk_alt_consistency ?C\n\ngoal (1 subgoal):\n 1. S \\<in> mk_alt_consistency (close C)", "by blast"], ["proof (state)\nthis:\n  S \\<in> mk_alt_consistency (close C)\n\ngoal (1 subgoal):\n 1. hintikka\n     (Extend S (mk_finite_char (mk_alt_consistency (close C))) from_nat)", "then"], ["proof (chain)\npicking this:\n  S \\<in> mk_alt_consistency (close C)", "have \\<open>S \\<in> ?C'\\<close>"], ["proof (prove)\nusing this:\n  S \\<in> mk_alt_consistency (close C)\n\ngoal (1 subgoal):\n 1. S \\<in> mk_finite_char (mk_alt_consistency (close C))", "using close_closed finite_char_subset mk_alt_consistency_closed"], ["proof (prove)\nusing this:\n  S \\<in> mk_alt_consistency (close C)\n  subset_closed (close ?C)\n  subset_closed ?C \\<Longrightarrow> ?C \\<subseteq> mk_finite_char ?C\n  subset_closed ?C \\<Longrightarrow> subset_closed (mk_alt_consistency ?C)\n\ngoal (1 subgoal):\n 1. S \\<in> mk_finite_char (mk_alt_consistency (close C))", "by blast"], ["proof (state)\nthis:\n  S \\<in> mk_finite_char (mk_alt_consistency (close C))\n\ngoal (1 subgoal):\n 1. hintikka\n     (Extend S (mk_finite_char (mk_alt_consistency (close C))) from_nat)", "ultimately"], ["proof (chain)\npicking this:\n  finite_char (mk_finite_char (mk_alt_consistency (close C)))\n  \\<forall>y. \\<exists>n. y = from_nat n\n  alt_consistency (mk_finite_char (mk_alt_consistency (close C)))\n  S \\<in> mk_finite_char (mk_alt_consistency (close C))", "show ?thesis"], ["proof (prove)\nusing this:\n  finite_char (mk_finite_char (mk_alt_consistency (close C)))\n  \\<forall>y. \\<exists>n. y = from_nat n\n  alt_consistency (mk_finite_char (mk_alt_consistency (close C)))\n  S \\<in> mk_finite_char (mk_alt_consistency (close C))\n\ngoal (1 subgoal):\n 1. hintikka\n     (Extend S (mk_finite_char (mk_alt_consistency (close C))) from_nat)", "using extend_hintikka \\<open>infinite (- (\\<Union>p \\<in> S. params p))\\<close>"], ["proof (prove)\nusing this:\n  finite_char (mk_finite_char (mk_alt_consistency (close C)))\n  \\<forall>y. \\<exists>n. y = from_nat n\n  alt_consistency (mk_finite_char (mk_alt_consistency (close C)))\n  S \\<in> mk_finite_char (mk_alt_consistency (close C))\n  \\<lbrakk>finite_char ?C; infinite (- \\<Union> (params ` ?S));\n   \\<forall>y. \\<exists>n. y = ?f n; alt_consistency ?C;\n   ?S \\<in> ?C\\<rbrakk>\n  \\<Longrightarrow> hintikka (Extend ?S ?C ?f)\n  infinite (- \\<Union> (params ` S))\n\ngoal (1 subgoal):\n 1. hintikka\n     (Extend S (mk_finite_char (mk_alt_consistency (close C))) from_nat)", "by metis"], ["proof (state)\nthis:\n  hintikka\n   (Extend S (mk_finite_char (mk_alt_consistency (close C))) from_nat)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem model_existence:\n  assumes \\<open>consistency C\\<close>\n    and \\<open>S \\<in> C\\<close>\n    and \\<open>infinite (- (\\<Union>p \\<in> S. params p))\\<close>\n    and \\<open>p \\<in> S\\<close>\n    and \\<open>closed 0 p\\<close>\n  shows \\<open>eval e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> Extend S\n        (mk_finite_char (mk_alt_consistency (close C))) from_nat) p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval e HApp\n     (\\<lambda>a ts.\n         Pred a (terms_of_hterms ts)\n         \\<in> Extend S (mk_finite_char (mk_alt_consistency (close C)))\n                from_nat)\n     p", "using assms hintikka_model hintikka_Extend_S Extend_subset"], ["proof (prove)\nusing this:\n  consistency C\n  S \\<in> C\n  infinite (- \\<Union> (params ` S))\n  p \\<in> S\n  closed 0 p\n  hintikka ?H \\<Longrightarrow>\n  (?p \\<in> ?H \\<longrightarrow>\n   closed 0 ?p \\<longrightarrow>\n   eval ?e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> ?H)\n    ?p) \\<and>\n  (Neg ?p \\<in> ?H \\<longrightarrow>\n   closed 0 ?p \\<longrightarrow>\n   eval ?e HApp (\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> ?H)\n    (Neg ?p))\n  \\<lbrakk>consistency ?C; ?S \\<in> ?C;\n   infinite (- \\<Union> (params ` ?S))\\<rbrakk>\n  \\<Longrightarrow> hintikka\n                     (Extend ?S\n                       (mk_finite_char (mk_alt_consistency (close ?C)))\n                       from_nat)\n  ?S \\<subseteq> Extend ?S ?C ?f\n\ngoal (1 subgoal):\n 1. eval e HApp\n     (\\<lambda>a ts.\n         Pred a (terms_of_hterms ts)\n         \\<in> Extend S (mk_finite_char (mk_alt_consistency (close C)))\n                from_nat)\n     p", "by blast"], ["", "subsection \\<open>Completeness for Natural Deduction\\<close>"], ["", "text \\<open>\nThanks to the model existence theorem, we can now show the completeness\nof the natural deduction calculus introduced in \\secref{sec:proof-calculus}.\nIn order for the model existence theorem to be applicable, we have to prove\nthat the set of sets that are consistent with respect to \\<open>\\<turnstile>\\<close> is a\nconsistency property:\n\\<close>"], ["", "theorem deriv_consistency:\n  assumes inf_param: \\<open>infinite (UNIV :: 'a set)\\<close>\n  shows \\<open>consistency {S::('a, 'b) form set. \\<exists>G. S = set G \\<and> \\<not> G \\<turnstile> FF}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. consistency {set G |G. \\<not> G \\<turnstile> FF}", "unfolding consistency_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>S.\n       S \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<longrightarrow>\n       (\\<forall>p ts.\n           \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)) \\<and>\n       FF \\<notin> S \\<and>\n       Neg TT \\<notin> S \\<and>\n       (\\<forall>Z.\n           Neg (Neg Z) \\<in> S \\<longrightarrow>\n           S \\<union> {Z} \\<in> {set G |G. \\<not> G \\<turnstile> FF}) \\<and>\n       (\\<forall>A B.\n           And A B \\<in> S \\<longrightarrow>\n           S \\<union> {A, B}\n           \\<in> {set G |G. \\<not> G \\<turnstile> FF}) \\<and>\n       (\\<forall>A B.\n           Neg (Or A B) \\<in> S \\<longrightarrow>\n           S \\<union> {Neg A, Neg B}\n           \\<in> {set G |G. \\<not> G \\<turnstile> FF}) \\<and>\n       (\\<forall>A B.\n           Or A B \\<in> S \\<longrightarrow>\n           S \\<union> {A} \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n           S \\<union> {B} \\<in> {set G |G. \\<not> G \\<turnstile> FF}) \\<and>\n       (\\<forall>A B.\n           Neg (And A B) \\<in> S \\<longrightarrow>\n           S \\<union> {Neg A}\n           \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n           S \\<union> {Neg B}\n           \\<in> {set G |G. \\<not> G \\<turnstile> FF}) \\<and>\n       (\\<forall>A B.\n           Impl A B \\<in> S \\<longrightarrow>\n           S \\<union> {Neg A}\n           \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n           S \\<union> {B} \\<in> {set G |G. \\<not> G \\<turnstile> FF}) \\<and>\n       (\\<forall>A B.\n           Neg (Impl A B) \\<in> S \\<longrightarrow>\n           S \\<union> {A, Neg B}\n           \\<in> {set G |G. \\<not> G \\<turnstile> FF}) \\<and>\n       (\\<forall>P t.\n           closedt 0 t \\<longrightarrow>\n           Forall P \\<in> S \\<longrightarrow>\n           S \\<union> {P[t/0]}\n           \\<in> {set G |G. \\<not> G \\<turnstile> FF}) \\<and>\n       (\\<forall>P t.\n           closedt 0 t \\<longrightarrow>\n           Neg (Exists P) \\<in> S \\<longrightarrow>\n           S \\<union> {Neg (P[t/0])}\n           \\<in> {set G |G. \\<not> G \\<turnstile> FF}) \\<and>\n       (\\<forall>P.\n           Exists P \\<in> S \\<longrightarrow>\n           (\\<exists>x.\n               S \\<union> {P[App x []/0]}\n               \\<in> {set G |G. \\<not> G \\<turnstile> FF})) \\<and>\n       (\\<forall>P.\n           Neg (Forall P) \\<in> S \\<longrightarrow>\n           (\\<exists>x.\n               S \\<union> {Neg (P[App x []/0])}\n               \\<in> {set G |G. \\<not> G \\<turnstile> FF}))", "proof (intro conjI allI impI notI)"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>S p ts.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>S.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        FF \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>S.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg TT \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>S Z.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 10. \\<And>S A B.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n         Neg (Impl A B) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {A, Neg B}\n                          \\<in> {set G |G. \\<not> G \\<turnstile> FF}\nA total of 14 subgoals...", "fix S :: \\<open>('a, 'b) form set\\<close>"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>S p ts.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>S.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        FF \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>S.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg TT \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>S Z.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 10. \\<And>S A B.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n         Neg (Impl A B) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {A, Neg B}\n                          \\<in> {set G |G. \\<not> G \\<turnstile> FF}\nA total of 14 subgoals...", "assume \\<open>S \\<in> {set G | G. \\<not> G \\<turnstile> FF}\\<close> (is \\<open>S \\<in> ?C\\<close>)"], ["proof (state)\nthis:\n  S \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n\ngoal (14 subgoals):\n 1. \\<And>S p ts.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>S.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        FF \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>S.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg TT \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>S Z.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 10. \\<And>S A B.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n         Neg (Impl A B) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {A, Neg B}\n                          \\<in> {set G |G. \\<not> G \\<turnstile> FF}\nA total of 14 subgoals...", "then"], ["proof (chain)\npicking this:\n  S \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "obtain G :: \\<open>('a, 'b) form list\\<close>\n    where *: \\<open>S = set G\\<close> and \\<open>\\<not> G \\<turnstile> FF\\<close>"], ["proof (prove)\nusing this:\n  S \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n\ngoal (1 subgoal):\n 1. (\\<And>G.\n        \\<lbrakk>S = set G; \\<not> G \\<turnstile> FF\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  S = set G\n  \\<not> G \\<turnstile> FF\n\ngoal (14 subgoals):\n 1. \\<And>S p ts.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>S.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        FF \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>S.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg TT \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>S Z.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 10. \\<And>S A B.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n         Neg (Impl A B) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {A, Neg B}\n                          \\<in> {set G |G. \\<not> G \\<turnstile> FF}\nA total of 14 subgoals...", "{"], ["proof (state)\nthis:\n  S = set G\n  \\<not> G \\<turnstile> FF\n\ngoal (14 subgoals):\n 1. \\<And>S p ts.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>S.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        FF \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>S.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg TT \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>S Z.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 10. \\<And>S A B.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n         Neg (Impl A B) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {A, Neg B}\n                          \\<in> {set G |G. \\<not> G \\<turnstile> FF}\nA total of 14 subgoals...", "fix p ts"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>S p ts.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>S.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        FF \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>S.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg TT \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>S Z.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 10. \\<And>S A B.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n         Neg (Impl A B) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {A, Neg B}\n                          \\<in> {set G |G. \\<not> G \\<turnstile> FF}\nA total of 14 subgoals...", "assume \\<open>Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S\\<close>"], ["proof (state)\nthis:\n  Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S\n\ngoal (14 subgoals):\n 1. \\<And>S p ts.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>S.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        FF \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>S.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg TT \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>S Z.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 10. \\<And>S A B.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n         Neg (Impl A B) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {A, Neg B}\n                          \\<in> {set G |G. \\<not> G \\<turnstile> FF}\nA total of 14 subgoals...", "then"], ["proof (chain)\npicking this:\n  Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S", "have \\<open>G \\<turnstile> Pred p ts\\<close> and \\<open>G \\<turnstile> Neg (Pred p ts)\\<close>"], ["proof (prove)\nusing this:\n  Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S\n\ngoal (1 subgoal):\n 1. G \\<turnstile> Pred p ts &&& G \\<turnstile> Neg (Pred p ts)", "using Assum *"], ["proof (prove)\nusing this:\n  Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S\n  ?a \\<in> set ?G \\<Longrightarrow> ?G \\<turnstile> ?a\n  S = set G\n\ngoal (1 subgoal):\n 1. G \\<turnstile> Pred p ts &&& G \\<turnstile> Neg (Pred p ts)", "by blast+"], ["proof (state)\nthis:\n  G \\<turnstile> Pred p ts\n  G \\<turnstile> Neg (Pred p ts)\n\ngoal (14 subgoals):\n 1. \\<And>S p ts.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>S.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        FF \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>S.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg TT \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>S Z.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 10. \\<And>S A B.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n         Neg (Impl A B) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {A, Neg B}\n                          \\<in> {set G |G. \\<not> G \\<turnstile> FF}\nA total of 14 subgoals...", "then"], ["proof (chain)\npicking this:\n  G \\<turnstile> Pred p ts\n  G \\<turnstile> Neg (Pred p ts)", "have \\<open>G \\<turnstile> FF\\<close>"], ["proof (prove)\nusing this:\n  G \\<turnstile> Pred p ts\n  G \\<turnstile> Neg (Pred p ts)\n\ngoal (1 subgoal):\n 1. G \\<turnstile> FF", "using NegE"], ["proof (prove)\nusing this:\n  G \\<turnstile> Pred p ts\n  G \\<turnstile> Neg (Pred p ts)\n  \\<lbrakk>?G \\<turnstile> Neg ?a; ?G \\<turnstile> ?a\\<rbrakk>\n  \\<Longrightarrow> ?G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. G \\<turnstile> FF", "by blast"], ["proof (state)\nthis:\n  G \\<turnstile> FF\n\ngoal (14 subgoals):\n 1. \\<And>S p ts.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>S.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        FF \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>S.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg TT \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>S Z.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 10. \\<And>S A B.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n         Neg (Impl A B) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {A, Neg B}\n                          \\<in> {set G |G. \\<not> G \\<turnstile> FF}\nA total of 14 subgoals...", "then"], ["proof (chain)\npicking this:\n  G \\<turnstile> FF", "show False"], ["proof (prove)\nusing this:\n  G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. False", "using \\<open>\\<not> G \\<turnstile> FF\\<close>"], ["proof (prove)\nusing this:\n  G \\<turnstile> FF\n  \\<not> G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (13 subgoals):\n 1. \\<And>S.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        FF \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>S.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg TT \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>S Z.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 10. \\<And>S P t.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n         Forall P \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {P[t/0]}\n                          \\<in> {set G |G. \\<not> G \\<turnstile> FF}\nA total of 13 subgoals...", "}"], ["proof (state)\nthis:\n  Pred ?p2 ?ts2 \\<in> S \\<and> Neg (Pred ?p2 ?ts2) \\<in> S \\<Longrightarrow>\n  False\n\ngoal (13 subgoals):\n 1. \\<And>S.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        FF \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>S.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg TT \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>S Z.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 10. \\<And>S P t.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n         Forall P \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {P[t/0]}\n                          \\<in> {set G |G. \\<not> G \\<turnstile> FF}\nA total of 13 subgoals...", "{"], ["proof (state)\nthis:\n  Pred ?p2 ?ts2 \\<in> S \\<and> Neg (Pred ?p2 ?ts2) \\<in> S \\<Longrightarrow>\n  False\n\ngoal (13 subgoals):\n 1. \\<And>S.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        FF \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>S.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg TT \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>S Z.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 10. \\<And>S P t.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n         Forall P \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {P[t/0]}\n                          \\<in> {set G |G. \\<not> G \\<turnstile> FF}\nA total of 13 subgoals...", "assume \\<open>FF \\<in> S\\<close>"], ["proof (state)\nthis:\n  FF \\<in> S\n\ngoal (13 subgoals):\n 1. \\<And>S.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        FF \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>S.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg TT \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>S Z.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 10. \\<And>S P t.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n         Forall P \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {P[t/0]}\n                          \\<in> {set G |G. \\<not> G \\<turnstile> FF}\nA total of 13 subgoals...", "then"], ["proof (chain)\npicking this:\n  FF \\<in> S", "have \\<open>G \\<turnstile> FF\\<close>"], ["proof (prove)\nusing this:\n  FF \\<in> S\n\ngoal (1 subgoal):\n 1. G \\<turnstile> FF", "using Assum *"], ["proof (prove)\nusing this:\n  FF \\<in> S\n  ?a \\<in> set ?G \\<Longrightarrow> ?G \\<turnstile> ?a\n  S = set G\n\ngoal (1 subgoal):\n 1. G \\<turnstile> FF", "by blast"], ["proof (state)\nthis:\n  G \\<turnstile> FF\n\ngoal (13 subgoals):\n 1. \\<And>S.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        FF \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>S.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg TT \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>S Z.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 10. \\<And>S P t.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n         Forall P \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {P[t/0]}\n                          \\<in> {set G |G. \\<not> G \\<turnstile> FF}\nA total of 13 subgoals...", "then"], ["proof (chain)\npicking this:\n  G \\<turnstile> FF", "show False"], ["proof (prove)\nusing this:\n  G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. False", "using \\<open>\\<not> G \\<turnstile> FF\\<close>"], ["proof (prove)\nusing this:\n  G \\<turnstile> FF\n  \\<not> G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (12 subgoals):\n 1. \\<And>S.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg TT \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>S Z.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 10. \\<And>S P t.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n         Neg (Exists P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                          \\<in> {set G |G. \\<not> G \\<turnstile> FF}\nA total of 12 subgoals...", "}"], ["proof (state)\nthis:\n  FF \\<in> S \\<Longrightarrow> False\n\ngoal (12 subgoals):\n 1. \\<And>S.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg TT \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>S Z.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 10. \\<And>S P t.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n         Neg (Exists P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                          \\<in> {set G |G. \\<not> G \\<turnstile> FF}\nA total of 12 subgoals...", "{"], ["proof (state)\nthis:\n  FF \\<in> S \\<Longrightarrow> False\n\ngoal (12 subgoals):\n 1. \\<And>S.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg TT \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>S Z.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 10. \\<And>S P t.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n         Neg (Exists P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                          \\<in> {set G |G. \\<not> G \\<turnstile> FF}\nA total of 12 subgoals...", "assume \\<open>Neg TT \\<in> S\\<close>"], ["proof (state)\nthis:\n  Neg TT \\<in> S\n\ngoal (12 subgoals):\n 1. \\<And>S.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg TT \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>S Z.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 10. \\<And>S P t.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n         Neg (Exists P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                          \\<in> {set G |G. \\<not> G \\<turnstile> FF}\nA total of 12 subgoals...", "then"], ["proof (chain)\npicking this:\n  Neg TT \\<in> S", "have \\<open>G \\<turnstile> Neg TT\\<close>"], ["proof (prove)\nusing this:\n  Neg TT \\<in> S\n\ngoal (1 subgoal):\n 1. G \\<turnstile> Neg TT", "using Assum *"], ["proof (prove)\nusing this:\n  Neg TT \\<in> S\n  ?a \\<in> set ?G \\<Longrightarrow> ?G \\<turnstile> ?a\n  S = set G\n\ngoal (1 subgoal):\n 1. G \\<turnstile> Neg TT", "by blast"], ["proof (state)\nthis:\n  G \\<turnstile> Neg TT\n\ngoal (12 subgoals):\n 1. \\<And>S.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg TT \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>S Z.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 10. \\<And>S P t.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n         Neg (Exists P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                          \\<in> {set G |G. \\<not> G \\<turnstile> FF}\nA total of 12 subgoals...", "moreover"], ["proof (state)\nthis:\n  G \\<turnstile> Neg TT\n\ngoal (12 subgoals):\n 1. \\<And>S.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg TT \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>S Z.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 10. \\<And>S P t.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n         Neg (Exists P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                          \\<in> {set G |G. \\<not> G \\<turnstile> FF}\nA total of 12 subgoals...", "have \\<open>G \\<turnstile> TT\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<turnstile> TT", "using TTI"], ["proof (prove)\nusing this:\n  ?G \\<turnstile> TT\n\ngoal (1 subgoal):\n 1. G \\<turnstile> TT", "by blast"], ["proof (state)\nthis:\n  G \\<turnstile> TT\n\ngoal (12 subgoals):\n 1. \\<And>S.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg TT \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>S Z.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 10. \\<And>S P t.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n         Neg (Exists P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                          \\<in> {set G |G. \\<not> G \\<turnstile> FF}\nA total of 12 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  G \\<turnstile> Neg TT\n  G \\<turnstile> TT", "have \\<open>G \\<turnstile> FF\\<close>"], ["proof (prove)\nusing this:\n  G \\<turnstile> Neg TT\n  G \\<turnstile> TT\n\ngoal (1 subgoal):\n 1. G \\<turnstile> FF", "using NegE"], ["proof (prove)\nusing this:\n  G \\<turnstile> Neg TT\n  G \\<turnstile> TT\n  \\<lbrakk>?G \\<turnstile> Neg ?a; ?G \\<turnstile> ?a\\<rbrakk>\n  \\<Longrightarrow> ?G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. G \\<turnstile> FF", "by blast"], ["proof (state)\nthis:\n  G \\<turnstile> FF\n\ngoal (12 subgoals):\n 1. \\<And>S.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg TT \\<in> S\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>S Z.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 10. \\<And>S P t.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n         Neg (Exists P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                          \\<in> {set G |G. \\<not> G \\<turnstile> FF}\nA total of 12 subgoals...", "then"], ["proof (chain)\npicking this:\n  G \\<turnstile> FF", "show False"], ["proof (prove)\nusing this:\n  G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. False", "using \\<open>\\<not> G \\<turnstile> FF\\<close>"], ["proof (prove)\nusing this:\n  G \\<turnstile> FF\n  \\<not> G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (11 subgoals):\n 1. \\<And>S Z.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n         Exists P \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {P[App x []/0]}\n                             \\<in> {set G |G. \\<not> G \\<turnstile> FF}\nA total of 11 subgoals...", "}"], ["proof (state)\nthis:\n  Neg TT \\<in> S \\<Longrightarrow> False\n\ngoal (11 subgoals):\n 1. \\<And>S Z.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n         Exists P \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {P[App x []/0]}\n                             \\<in> {set G |G. \\<not> G \\<turnstile> FF}\nA total of 11 subgoals...", "{"], ["proof (state)\nthis:\n  Neg TT \\<in> S \\<Longrightarrow> False\n\ngoal (11 subgoals):\n 1. \\<And>S Z.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n         Exists P \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {P[App x []/0]}\n                             \\<in> {set G |G. \\<not> G \\<turnstile> FF}\nA total of 11 subgoals...", "fix Z"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>S Z.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n         Exists P \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {P[App x []/0]}\n                             \\<in> {set G |G. \\<not> G \\<turnstile> FF}\nA total of 11 subgoals...", "assume \\<open>Neg (Neg Z) \\<in> S\\<close>"], ["proof (state)\nthis:\n  Neg (Neg Z) \\<in> S\n\ngoal (11 subgoals):\n 1. \\<And>S Z.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n         Exists P \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {P[App x []/0]}\n                             \\<in> {set G |G. \\<not> G \\<turnstile> FF}\nA total of 11 subgoals...", "then"], ["proof (chain)\npicking this:\n  Neg (Neg Z) \\<in> S", "have \\<open>G \\<turnstile> Neg (Neg Z)\\<close>"], ["proof (prove)\nusing this:\n  Neg (Neg Z) \\<in> S\n\ngoal (1 subgoal):\n 1. G \\<turnstile> Neg (Neg Z)", "using Assum *"], ["proof (prove)\nusing this:\n  Neg (Neg Z) \\<in> S\n  ?a \\<in> set ?G \\<Longrightarrow> ?G \\<turnstile> ?a\n  S = set G\n\ngoal (1 subgoal):\n 1. G \\<turnstile> Neg (Neg Z)", "by blast"], ["proof (state)\nthis:\n  G \\<turnstile> Neg (Neg Z)\n\ngoal (11 subgoals):\n 1. \\<And>S Z.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n         Exists P \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {P[App x []/0]}\n                             \\<in> {set G |G. \\<not> G \\<turnstile> FF}\nA total of 11 subgoals...", "{"], ["proof (state)\nthis:\n  G \\<turnstile> Neg (Neg Z)\n\ngoal (11 subgoals):\n 1. \\<And>S Z.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n         Exists P \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {P[App x []/0]}\n                             \\<in> {set G |G. \\<not> G \\<turnstile> FF}\nA total of 11 subgoals...", "assume \\<open>Z # G \\<turnstile> FF\\<close>"], ["proof (state)\nthis:\n  Z # G \\<turnstile> FF\n\ngoal (11 subgoals):\n 1. \\<And>S Z.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n         Exists P \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {P[App x []/0]}\n                             \\<in> {set G |G. \\<not> G \\<turnstile> FF}\nA total of 11 subgoals...", "then"], ["proof (chain)\npicking this:\n  Z # G \\<turnstile> FF", "have \\<open>G \\<turnstile> Neg Z\\<close>"], ["proof (prove)\nusing this:\n  Z # G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. G \\<turnstile> Neg Z", "using NegI"], ["proof (prove)\nusing this:\n  Z # G \\<turnstile> FF\n  ?a # ?G \\<turnstile> FF \\<Longrightarrow> ?G \\<turnstile> Neg ?a\n\ngoal (1 subgoal):\n 1. G \\<turnstile> Neg Z", "by blast"], ["proof (state)\nthis:\n  G \\<turnstile> Neg Z\n\ngoal (11 subgoals):\n 1. \\<And>S Z.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n         Exists P \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {P[App x []/0]}\n                             \\<in> {set G |G. \\<not> G \\<turnstile> FF}\nA total of 11 subgoals...", "then"], ["proof (chain)\npicking this:\n  G \\<turnstile> Neg Z", "have \\<open>G \\<turnstile> FF\\<close>"], ["proof (prove)\nusing this:\n  G \\<turnstile> Neg Z\n\ngoal (1 subgoal):\n 1. G \\<turnstile> FF", "using NegE \\<open>G \\<turnstile> Neg (Neg Z)\\<close>"], ["proof (prove)\nusing this:\n  G \\<turnstile> Neg Z\n  \\<lbrakk>?G \\<turnstile> Neg ?a; ?G \\<turnstile> ?a\\<rbrakk>\n  \\<Longrightarrow> ?G \\<turnstile> FF\n  G \\<turnstile> Neg (Neg Z)\n\ngoal (1 subgoal):\n 1. G \\<turnstile> FF", "by blast"], ["proof (state)\nthis:\n  G \\<turnstile> FF\n\ngoal (11 subgoals):\n 1. \\<And>S Z.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n         Exists P \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {P[App x []/0]}\n                             \\<in> {set G |G. \\<not> G \\<turnstile> FF}\nA total of 11 subgoals...", "then"], ["proof (chain)\npicking this:\n  G \\<turnstile> FF", "have False"], ["proof (prove)\nusing this:\n  G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. False", "using \\<open>\\<not> G \\<turnstile> FF\\<close>"], ["proof (prove)\nusing this:\n  G \\<turnstile> FF\n  \\<not> G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (11 subgoals):\n 1. \\<And>S Z.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n         Exists P \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {P[App x []/0]}\n                             \\<in> {set G |G. \\<not> G \\<turnstile> FF}\nA total of 11 subgoals...", "}"], ["proof (state)\nthis:\n  Z # G \\<turnstile> FF \\<Longrightarrow> False\n\ngoal (11 subgoals):\n 1. \\<And>S Z.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n         Exists P \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {P[App x []/0]}\n                             \\<in> {set G |G. \\<not> G \\<turnstile> FF}\nA total of 11 subgoals...", "then"], ["proof (chain)\npicking this:\n  Z # G \\<turnstile> FF \\<Longrightarrow> False", "have \\<open>\\<not> Z # G \\<turnstile> FF\\<close>"], ["proof (prove)\nusing this:\n  Z # G \\<turnstile> FF \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> Z # G \\<turnstile> FF", "by blast"], ["proof (state)\nthis:\n  \\<not> Z # G \\<turnstile> FF\n\ngoal (11 subgoals):\n 1. \\<And>S Z.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n         Exists P \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {P[App x []/0]}\n                             \\<in> {set G |G. \\<not> G \\<turnstile> FF}\nA total of 11 subgoals...", "moreover"], ["proof (state)\nthis:\n  \\<not> Z # G \\<turnstile> FF\n\ngoal (11 subgoals):\n 1. \\<And>S Z.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n         Exists P \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {P[App x []/0]}\n                             \\<in> {set G |G. \\<not> G \\<turnstile> FF}\nA total of 11 subgoals...", "have \\<open>S \\<union> {Z} = set (Z # G)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<union> {Z} = set (Z # G)", "using *"], ["proof (prove)\nusing this:\n  S = set G\n\ngoal (1 subgoal):\n 1. S \\<union> {Z} = set (Z # G)", "by simp"], ["proof (state)\nthis:\n  S \\<union> {Z} = set (Z # G)\n\ngoal (11 subgoals):\n 1. \\<And>S Z.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n         Exists P \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {P[App x []/0]}\n                             \\<in> {set G |G. \\<not> G \\<turnstile> FF}\nA total of 11 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> Z # G \\<turnstile> FF\n  S \\<union> {Z} = set (Z # G)", "show \\<open>S \\<union> {Z} \\<in> ?C\\<close>"], ["proof (prove)\nusing this:\n  \\<not> Z # G \\<turnstile> FF\n  S \\<union> {Z} = set (Z # G)\n\ngoal (1 subgoal):\n 1. S \\<union> {Z} \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "by blast"], ["proof (state)\nthis:\n  S \\<union> {Z} \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n\ngoal (10 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n         Neg (Forall P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {Neg (P[App x []/0])}\n                             \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "}"], ["proof (state)\nthis:\n  Neg (Neg ?Z2) \\<in> S \\<Longrightarrow>\n  S \\<union> {?Z2} \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n\ngoal (10 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n         Neg (Forall P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {Neg (P[App x []/0])}\n                             \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "{"], ["proof (state)\nthis:\n  Neg (Neg ?Z2) \\<in> S \\<Longrightarrow>\n  S \\<union> {?Z2} \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n\ngoal (10 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n         Neg (Forall P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {Neg (P[App x []/0])}\n                             \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "fix A B"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n         Neg (Forall P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {Neg (P[App x []/0])}\n                             \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "assume \\<open>And A B \\<in> S\\<close>"], ["proof (state)\nthis:\n  And A B \\<in> S\n\ngoal (10 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n         Neg (Forall P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {Neg (P[App x []/0])}\n                             \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  And A B \\<in> S", "have \\<open>G \\<turnstile> And A B\\<close>"], ["proof (prove)\nusing this:\n  And A B \\<in> S\n\ngoal (1 subgoal):\n 1. G \\<turnstile> And A B", "using Assum *"], ["proof (prove)\nusing this:\n  And A B \\<in> S\n  ?a \\<in> set ?G \\<Longrightarrow> ?G \\<turnstile> ?a\n  S = set G\n\ngoal (1 subgoal):\n 1. G \\<turnstile> And A B", "by blast"], ["proof (state)\nthis:\n  G \\<turnstile> And A B\n\ngoal (10 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n         Neg (Forall P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {Neg (P[App x []/0])}\n                             \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  G \\<turnstile> And A B", "have \\<open>G \\<turnstile> A\\<close> and \\<open>G \\<turnstile> B\\<close>"], ["proof (prove)\nusing this:\n  G \\<turnstile> And A B\n\ngoal (1 subgoal):\n 1. G \\<turnstile> A &&& G \\<turnstile> B", "using AndE1 AndE2"], ["proof (prove)\nusing this:\n  G \\<turnstile> And A B\n  ?G \\<turnstile> And ?a ?b \\<Longrightarrow> ?G \\<turnstile> ?a\n  ?G \\<turnstile> And ?a ?b \\<Longrightarrow> ?G \\<turnstile> ?b\n\ngoal (1 subgoal):\n 1. G \\<turnstile> A &&& G \\<turnstile> B", "by blast+"], ["proof (state)\nthis:\n  G \\<turnstile> A\n  G \\<turnstile> B\n\ngoal (10 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n         Neg (Forall P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {Neg (P[App x []/0])}\n                             \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "{"], ["proof (state)\nthis:\n  G \\<turnstile> A\n  G \\<turnstile> B\n\ngoal (10 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n         Neg (Forall P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {Neg (P[App x []/0])}\n                             \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "assume \\<open>A # B # G \\<turnstile> FF\\<close>"], ["proof (state)\nthis:\n  A # B # G \\<turnstile> FF\n\ngoal (10 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n         Neg (Forall P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {Neg (P[App x []/0])}\n                             \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  A # B # G \\<turnstile> FF", "have \\<open>B # G \\<turnstile> Neg A\\<close>"], ["proof (prove)\nusing this:\n  A # B # G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. B # G \\<turnstile> Neg A", "using NegI"], ["proof (prove)\nusing this:\n  A # B # G \\<turnstile> FF\n  ?a # ?G \\<turnstile> FF \\<Longrightarrow> ?G \\<turnstile> Neg ?a\n\ngoal (1 subgoal):\n 1. B # G \\<turnstile> Neg A", "by blast"], ["proof (state)\nthis:\n  B # G \\<turnstile> Neg A\n\ngoal (10 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n         Neg (Forall P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {Neg (P[App x []/0])}\n                             \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  B # G \\<turnstile> Neg A", "have \\<open>G \\<turnstile> Neg A\\<close>"], ["proof (prove)\nusing this:\n  B # G \\<turnstile> Neg A\n\ngoal (1 subgoal):\n 1. G \\<turnstile> Neg A", "using cut \\<open>G \\<turnstile> B\\<close>"], ["proof (prove)\nusing this:\n  B # G \\<turnstile> Neg A\n  \\<lbrakk>?G \\<turnstile> ?A; ?A # ?G \\<turnstile> ?B\\<rbrakk>\n  \\<Longrightarrow> ?G \\<turnstile> ?B\n  G \\<turnstile> B\n\ngoal (1 subgoal):\n 1. G \\<turnstile> Neg A", "by blast"], ["proof (state)\nthis:\n  G \\<turnstile> Neg A\n\ngoal (10 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n         Neg (Forall P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {Neg (P[App x []/0])}\n                             \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  G \\<turnstile> Neg A", "have \\<open>G \\<turnstile> FF\\<close>"], ["proof (prove)\nusing this:\n  G \\<turnstile> Neg A\n\ngoal (1 subgoal):\n 1. G \\<turnstile> FF", "using NegE \\<open>G \\<turnstile> A\\<close>"], ["proof (prove)\nusing this:\n  G \\<turnstile> Neg A\n  \\<lbrakk>?G \\<turnstile> Neg ?a; ?G \\<turnstile> ?a\\<rbrakk>\n  \\<Longrightarrow> ?G \\<turnstile> FF\n  G \\<turnstile> A\n\ngoal (1 subgoal):\n 1. G \\<turnstile> FF", "by blast"], ["proof (state)\nthis:\n  G \\<turnstile> FF\n\ngoal (10 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n         Neg (Forall P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {Neg (P[App x []/0])}\n                             \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  G \\<turnstile> FF", "have False"], ["proof (prove)\nusing this:\n  G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. False", "using \\<open>\\<not> G \\<turnstile> FF\\<close>"], ["proof (prove)\nusing this:\n  G \\<turnstile> FF\n  \\<not> G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (10 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n         Neg (Forall P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {Neg (P[App x []/0])}\n                             \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "}"], ["proof (state)\nthis:\n  A # B # G \\<turnstile> FF \\<Longrightarrow> False\n\ngoal (10 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n         Neg (Forall P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {Neg (P[App x []/0])}\n                             \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  A # B # G \\<turnstile> FF \\<Longrightarrow> False", "have \\<open>\\<not> A # B # G \\<turnstile> FF\\<close>"], ["proof (prove)\nusing this:\n  A # B # G \\<turnstile> FF \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> A # B # G \\<turnstile> FF", "by blast"], ["proof (state)\nthis:\n  \\<not> A # B # G \\<turnstile> FF\n\ngoal (10 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n         Neg (Forall P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {Neg (P[App x []/0])}\n                             \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "moreover"], ["proof (state)\nthis:\n  \\<not> A # B # G \\<turnstile> FF\n\ngoal (10 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n         Neg (Forall P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {Neg (P[App x []/0])}\n                             \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "have \\<open>S \\<union> {A, B} = set (A # B # G)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<union> {A, B} = set (A # B # G)", "using *"], ["proof (prove)\nusing this:\n  S = set G\n\ngoal (1 subgoal):\n 1. S \\<union> {A, B} = set (A # B # G)", "by simp"], ["proof (state)\nthis:\n  S \\<union> {A, B} = set (A # B # G)\n\ngoal (10 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n         Neg (Forall P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {Neg (P[App x []/0])}\n                             \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> A # B # G \\<turnstile> FF\n  S \\<union> {A, B} = set (A # B # G)", "show \\<open>S \\<union> {A, B} \\<in> ?C\\<close>"], ["proof (prove)\nusing this:\n  \\<not> A # B # G \\<turnstile> FF\n  S \\<union> {A, B} = set (A # B # G)\n\ngoal (1 subgoal):\n 1. S \\<union> {A, B} \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "by blast"], ["proof (state)\nthis:\n  S \\<union> {A, B} \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n\ngoal (9 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "}"], ["proof (state)\nthis:\n  And ?A2 ?B2 \\<in> S \\<Longrightarrow>\n  S \\<union> {?A2, ?B2} \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n\ngoal (9 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "{"], ["proof (state)\nthis:\n  And ?A2 ?B2 \\<in> S \\<Longrightarrow>\n  S \\<union> {?A2, ?B2} \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n\ngoal (9 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "fix A B"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "assume \\<open>Neg (Or A B) \\<in> S\\<close>"], ["proof (state)\nthis:\n  Neg (Or A B) \\<in> S\n\ngoal (9 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  Neg (Or A B) \\<in> S", "have \\<open>G \\<turnstile> Neg (Or A B)\\<close>"], ["proof (prove)\nusing this:\n  Neg (Or A B) \\<in> S\n\ngoal (1 subgoal):\n 1. G \\<turnstile> Neg (Or A B)", "using Assum *"], ["proof (prove)\nusing this:\n  Neg (Or A B) \\<in> S\n  ?a \\<in> set ?G \\<Longrightarrow> ?G \\<turnstile> ?a\n  S = set G\n\ngoal (1 subgoal):\n 1. G \\<turnstile> Neg (Or A B)", "by blast"], ["proof (state)\nthis:\n  G \\<turnstile> Neg (Or A B)\n\ngoal (9 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "have \\<open>A # Neg B # G \\<turnstile> A\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. A # Neg B # G \\<turnstile> A", "by (simp add: Assum)"], ["proof (state)\nthis:\n  A # Neg B # G \\<turnstile> A\n\ngoal (9 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  A # Neg B # G \\<turnstile> A", "have \\<open>A # Neg B # G \\<turnstile> Or A B\\<close>"], ["proof (prove)\nusing this:\n  A # Neg B # G \\<turnstile> A\n\ngoal (1 subgoal):\n 1. A # Neg B # G \\<turnstile> Or A B", "using OrI1"], ["proof (prove)\nusing this:\n  A # Neg B # G \\<turnstile> A\n  ?G \\<turnstile> ?a \\<Longrightarrow> ?G \\<turnstile> Or ?a ?b\n\ngoal (1 subgoal):\n 1. A # Neg B # G \\<turnstile> Or A B", "by blast"], ["proof (state)\nthis:\n  A # Neg B # G \\<turnstile> Or A B\n\ngoal (9 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "moreover"], ["proof (state)\nthis:\n  A # Neg B # G \\<turnstile> Or A B\n\ngoal (9 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "have \\<open>A # Neg B # G \\<turnstile> Neg (Or A B)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. A # Neg B # G \\<turnstile> Neg (Or A B)", "using * \\<open>Neg (Or A B) \\<in> S\\<close>"], ["proof (prove)\nusing this:\n  S = set G\n  Neg (Or A B) \\<in> S\n\ngoal (1 subgoal):\n 1. A # Neg B # G \\<turnstile> Neg (Or A B)", "by (simp add: Assum)"], ["proof (state)\nthis:\n  A # Neg B # G \\<turnstile> Neg (Or A B)\n\ngoal (9 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "ultimately"], ["proof (chain)\npicking this:\n  A # Neg B # G \\<turnstile> Or A B\n  A # Neg B # G \\<turnstile> Neg (Or A B)", "have \\<open>A # Neg B # G \\<turnstile> FF\\<close>"], ["proof (prove)\nusing this:\n  A # Neg B # G \\<turnstile> Or A B\n  A # Neg B # G \\<turnstile> Neg (Or A B)\n\ngoal (1 subgoal):\n 1. A # Neg B # G \\<turnstile> FF", "using NegE \\<open>A # Neg B # G \\<turnstile> Neg (Or A B)\\<close>"], ["proof (prove)\nusing this:\n  A # Neg B # G \\<turnstile> Or A B\n  A # Neg B # G \\<turnstile> Neg (Or A B)\n  \\<lbrakk>?G \\<turnstile> Neg ?a; ?G \\<turnstile> ?a\\<rbrakk>\n  \\<Longrightarrow> ?G \\<turnstile> FF\n  A # Neg B # G \\<turnstile> Neg (Or A B)\n\ngoal (1 subgoal):\n 1. A # Neg B # G \\<turnstile> FF", "by blast"], ["proof (state)\nthis:\n  A # Neg B # G \\<turnstile> FF\n\ngoal (9 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  A # Neg B # G \\<turnstile> FF", "have \\<open>Neg B # G \\<turnstile> Neg A\\<close>"], ["proof (prove)\nusing this:\n  A # Neg B # G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. Neg B # G \\<turnstile> Neg A", "using NegI"], ["proof (prove)\nusing this:\n  A # Neg B # G \\<turnstile> FF\n  ?a # ?G \\<turnstile> FF \\<Longrightarrow> ?G \\<turnstile> Neg ?a\n\ngoal (1 subgoal):\n 1. Neg B # G \\<turnstile> Neg A", "by blast"], ["proof (state)\nthis:\n  Neg B # G \\<turnstile> Neg A\n\ngoal (9 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "have \\<open>B # G \\<turnstile> B\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. B # G \\<turnstile> B", "by (simp add: Assum)"], ["proof (state)\nthis:\n  B # G \\<turnstile> B\n\ngoal (9 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  B # G \\<turnstile> B", "have \\<open>B # G \\<turnstile> Or A B\\<close>"], ["proof (prove)\nusing this:\n  B # G \\<turnstile> B\n\ngoal (1 subgoal):\n 1. B # G \\<turnstile> Or A B", "using OrI2"], ["proof (prove)\nusing this:\n  B # G \\<turnstile> B\n  ?G \\<turnstile> ?b \\<Longrightarrow> ?G \\<turnstile> Or ?a ?b\n\ngoal (1 subgoal):\n 1. B # G \\<turnstile> Or A B", "by blast"], ["proof (state)\nthis:\n  B # G \\<turnstile> Or A B\n\ngoal (9 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "moreover"], ["proof (state)\nthis:\n  B # G \\<turnstile> Or A B\n\ngoal (9 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "have \\<open>B # G \\<turnstile> Neg (Or A B)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. B # G \\<turnstile> Neg (Or A B)", "using * \\<open>Neg (Or A B) \\<in> S\\<close>"], ["proof (prove)\nusing this:\n  S = set G\n  Neg (Or A B) \\<in> S\n\ngoal (1 subgoal):\n 1. B # G \\<turnstile> Neg (Or A B)", "by (simp add: Assum)"], ["proof (state)\nthis:\n  B # G \\<turnstile> Neg (Or A B)\n\ngoal (9 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "ultimately"], ["proof (chain)\npicking this:\n  B # G \\<turnstile> Or A B\n  B # G \\<turnstile> Neg (Or A B)", "have \\<open>B # G \\<turnstile> FF\\<close>"], ["proof (prove)\nusing this:\n  B # G \\<turnstile> Or A B\n  B # G \\<turnstile> Neg (Or A B)\n\ngoal (1 subgoal):\n 1. B # G \\<turnstile> FF", "using NegE \\<open>B # G \\<turnstile> Neg (Or A B)\\<close>"], ["proof (prove)\nusing this:\n  B # G \\<turnstile> Or A B\n  B # G \\<turnstile> Neg (Or A B)\n  \\<lbrakk>?G \\<turnstile> Neg ?a; ?G \\<turnstile> ?a\\<rbrakk>\n  \\<Longrightarrow> ?G \\<turnstile> FF\n  B # G \\<turnstile> Neg (Or A B)\n\ngoal (1 subgoal):\n 1. B # G \\<turnstile> FF", "by blast"], ["proof (state)\nthis:\n  B # G \\<turnstile> FF\n\ngoal (9 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  B # G \\<turnstile> FF", "have \\<open>G \\<turnstile> Neg B\\<close>"], ["proof (prove)\nusing this:\n  B # G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. G \\<turnstile> Neg B", "using NegI"], ["proof (prove)\nusing this:\n  B # G \\<turnstile> FF\n  ?a # ?G \\<turnstile> FF \\<Longrightarrow> ?G \\<turnstile> Neg ?a\n\ngoal (1 subgoal):\n 1. G \\<turnstile> Neg B", "by blast"], ["proof (state)\nthis:\n  G \\<turnstile> Neg B\n\ngoal (9 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "{"], ["proof (state)\nthis:\n  G \\<turnstile> Neg B\n\ngoal (9 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "assume \\<open>Neg A # Neg B # G \\<turnstile> FF\\<close>"], ["proof (state)\nthis:\n  Neg A # Neg B # G \\<turnstile> FF\n\ngoal (9 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  Neg A # Neg B # G \\<turnstile> FF", "have \\<open>Neg B # G \\<turnstile> Neg (Neg A)\\<close>"], ["proof (prove)\nusing this:\n  Neg A # Neg B # G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. Neg B # G \\<turnstile> Neg (Neg A)", "using NegI"], ["proof (prove)\nusing this:\n  Neg A # Neg B # G \\<turnstile> FF\n  ?a # ?G \\<turnstile> FF \\<Longrightarrow> ?G \\<turnstile> Neg ?a\n\ngoal (1 subgoal):\n 1. Neg B # G \\<turnstile> Neg (Neg A)", "by blast"], ["proof (state)\nthis:\n  Neg B # G \\<turnstile> Neg (Neg A)\n\ngoal (9 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  Neg B # G \\<turnstile> Neg (Neg A)", "have \\<open>Neg B # G \\<turnstile> FF\\<close>"], ["proof (prove)\nusing this:\n  Neg B # G \\<turnstile> Neg (Neg A)\n\ngoal (1 subgoal):\n 1. Neg B # G \\<turnstile> FF", "using NegE \\<open>Neg B # G \\<turnstile> Neg A\\<close>"], ["proof (prove)\nusing this:\n  Neg B # G \\<turnstile> Neg (Neg A)\n  \\<lbrakk>?G \\<turnstile> Neg ?a; ?G \\<turnstile> ?a\\<rbrakk>\n  \\<Longrightarrow> ?G \\<turnstile> FF\n  Neg B # G \\<turnstile> Neg A\n\ngoal (1 subgoal):\n 1. Neg B # G \\<turnstile> FF", "by blast"], ["proof (state)\nthis:\n  Neg B # G \\<turnstile> FF\n\ngoal (9 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  Neg B # G \\<turnstile> FF", "have \\<open>G \\<turnstile> FF\\<close>"], ["proof (prove)\nusing this:\n  Neg B # G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. G \\<turnstile> FF", "using cut \\<open>G \\<turnstile> Neg B\\<close>"], ["proof (prove)\nusing this:\n  Neg B # G \\<turnstile> FF\n  \\<lbrakk>?G \\<turnstile> ?A; ?A # ?G \\<turnstile> ?B\\<rbrakk>\n  \\<Longrightarrow> ?G \\<turnstile> ?B\n  G \\<turnstile> Neg B\n\ngoal (1 subgoal):\n 1. G \\<turnstile> FF", "by blast"], ["proof (state)\nthis:\n  G \\<turnstile> FF\n\ngoal (9 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  G \\<turnstile> FF", "have False"], ["proof (prove)\nusing this:\n  G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. False", "using \\<open>\\<not> G \\<turnstile> FF\\<close>"], ["proof (prove)\nusing this:\n  G \\<turnstile> FF\n  \\<not> G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (9 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "}"], ["proof (state)\nthis:\n  Neg A # Neg B # G \\<turnstile> FF \\<Longrightarrow> False\n\ngoal (9 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  Neg A # Neg B # G \\<turnstile> FF \\<Longrightarrow> False", "have \\<open>\\<not> Neg A # Neg B # G \\<turnstile> FF\\<close>"], ["proof (prove)\nusing this:\n  Neg A # Neg B # G \\<turnstile> FF \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> Neg A # Neg B # G \\<turnstile> FF", "by blast"], ["proof (state)\nthis:\n  \\<not> Neg A # Neg B # G \\<turnstile> FF\n\ngoal (9 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "moreover"], ["proof (state)\nthis:\n  \\<not> Neg A # Neg B # G \\<turnstile> FF\n\ngoal (9 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "have \\<open>S \\<union> {Neg A, Neg B} = set (Neg A # Neg B # G)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<union> {Neg A, Neg B} = set (Neg A # Neg B # G)", "using *"], ["proof (prove)\nusing this:\n  S = set G\n\ngoal (1 subgoal):\n 1. S \\<union> {Neg A, Neg B} = set (Neg A # Neg B # G)", "by simp"], ["proof (state)\nthis:\n  S \\<union> {Neg A, Neg B} = set (Neg A # Neg B # G)\n\ngoal (9 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> Neg A # Neg B # G \\<turnstile> FF\n  S \\<union> {Neg A, Neg B} = set (Neg A # Neg B # G)", "show \\<open>S \\<union> {Neg A, Neg B} \\<in> ?C\\<close>"], ["proof (prove)\nusing this:\n  \\<not> Neg A # Neg B # G \\<turnstile> FF\n  S \\<union> {Neg A, Neg B} = set (Neg A # Neg B # G)\n\ngoal (1 subgoal):\n 1. S \\<union> {Neg A, Neg B} \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "by blast"], ["proof (state)\nthis:\n  S \\<union> {Neg A, Neg B} \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n\ngoal (8 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "}"], ["proof (state)\nthis:\n  Neg (Or ?A2 ?B2) \\<in> S \\<Longrightarrow>\n  S \\<union> {Neg ?A2, Neg ?B2} \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n\ngoal (8 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "{"], ["proof (state)\nthis:\n  Neg (Or ?A2 ?B2) \\<in> S \\<Longrightarrow>\n  S \\<union> {Neg ?A2, Neg ?B2} \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n\ngoal (8 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "fix A B"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "assume \\<open>Neg (Impl A B) \\<in> S\\<close>"], ["proof (state)\nthis:\n  Neg (Impl A B) \\<in> S\n\ngoal (8 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "have \\<open>A # Neg A # Neg B # G \\<turnstile> A\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. A # Neg A # Neg B # G \\<turnstile> A", "by (simp add: Assum)"], ["proof (state)\nthis:\n  A # Neg A # Neg B # G \\<turnstile> A\n\ngoal (8 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "moreover"], ["proof (state)\nthis:\n  A # Neg A # Neg B # G \\<turnstile> A\n\ngoal (8 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "have \\<open>A # Neg A # Neg B # G \\<turnstile> Neg A\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. A # Neg A # Neg B # G \\<turnstile> Neg A", "by (simp add: Assum)"], ["proof (state)\nthis:\n  A # Neg A # Neg B # G \\<turnstile> Neg A\n\ngoal (8 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "ultimately"], ["proof (chain)\npicking this:\n  A # Neg A # Neg B # G \\<turnstile> A\n  A # Neg A # Neg B # G \\<turnstile> Neg A", "have \\<open>A # Neg A # Neg B # G \\<turnstile> FF\\<close>"], ["proof (prove)\nusing this:\n  A # Neg A # Neg B # G \\<turnstile> A\n  A # Neg A # Neg B # G \\<turnstile> Neg A\n\ngoal (1 subgoal):\n 1. A # Neg A # Neg B # G \\<turnstile> FF", "using NegE"], ["proof (prove)\nusing this:\n  A # Neg A # Neg B # G \\<turnstile> A\n  A # Neg A # Neg B # G \\<turnstile> Neg A\n  \\<lbrakk>?G \\<turnstile> Neg ?a; ?G \\<turnstile> ?a\\<rbrakk>\n  \\<Longrightarrow> ?G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. A # Neg A # Neg B # G \\<turnstile> FF", "by blast"], ["proof (state)\nthis:\n  A # Neg A # Neg B # G \\<turnstile> FF\n\ngoal (8 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  A # Neg A # Neg B # G \\<turnstile> FF", "have \\<open>A # Neg A # Neg B # G \\<turnstile> B\\<close>"], ["proof (prove)\nusing this:\n  A # Neg A # Neg B # G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. A # Neg A # Neg B # G \\<turnstile> B", "using FFE"], ["proof (prove)\nusing this:\n  A # Neg A # Neg B # G \\<turnstile> FF\n  ?G \\<turnstile> FF \\<Longrightarrow> ?G \\<turnstile> ?a\n\ngoal (1 subgoal):\n 1. A # Neg A # Neg B # G \\<turnstile> B", "by blast"], ["proof (state)\nthis:\n  A # Neg A # Neg B # G \\<turnstile> B\n\ngoal (8 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  A # Neg A # Neg B # G \\<turnstile> B", "have \\<open>Neg A # Neg B # G \\<turnstile> Impl A B\\<close>"], ["proof (prove)\nusing this:\n  A # Neg A # Neg B # G \\<turnstile> B\n\ngoal (1 subgoal):\n 1. Neg A # Neg B # G \\<turnstile> Impl A B", "using ImplI"], ["proof (prove)\nusing this:\n  A # Neg A # Neg B # G \\<turnstile> B\n  ?a # ?G \\<turnstile> ?b \\<Longrightarrow> ?G \\<turnstile> Impl ?a ?b\n\ngoal (1 subgoal):\n 1. Neg A # Neg B # G \\<turnstile> Impl A B", "by blast"], ["proof (state)\nthis:\n  Neg A # Neg B # G \\<turnstile> Impl A B\n\ngoal (8 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "moreover"], ["proof (state)\nthis:\n  Neg A # Neg B # G \\<turnstile> Impl A B\n\ngoal (8 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "have \\<open>Neg A # Neg B # G \\<turnstile> Neg (Impl A B)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Neg A # Neg B # G \\<turnstile> Neg (Impl A B)", "using * \\<open>Neg (Impl A B) \\<in> S\\<close>"], ["proof (prove)\nusing this:\n  S = set G\n  Neg (Impl A B) \\<in> S\n\ngoal (1 subgoal):\n 1. Neg A # Neg B # G \\<turnstile> Neg (Impl A B)", "by (simp add: Assum)"], ["proof (state)\nthis:\n  Neg A # Neg B # G \\<turnstile> Neg (Impl A B)\n\ngoal (8 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "ultimately"], ["proof (chain)\npicking this:\n  Neg A # Neg B # G \\<turnstile> Impl A B\n  Neg A # Neg B # G \\<turnstile> Neg (Impl A B)", "have \\<open>Neg A # Neg B # G \\<turnstile> FF\\<close>"], ["proof (prove)\nusing this:\n  Neg A # Neg B # G \\<turnstile> Impl A B\n  Neg A # Neg B # G \\<turnstile> Neg (Impl A B)\n\ngoal (1 subgoal):\n 1. Neg A # Neg B # G \\<turnstile> FF", "using NegE"], ["proof (prove)\nusing this:\n  Neg A # Neg B # G \\<turnstile> Impl A B\n  Neg A # Neg B # G \\<turnstile> Neg (Impl A B)\n  \\<lbrakk>?G \\<turnstile> Neg ?a; ?G \\<turnstile> ?a\\<rbrakk>\n  \\<Longrightarrow> ?G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. Neg A # Neg B # G \\<turnstile> FF", "by blast"], ["proof (state)\nthis:\n  Neg A # Neg B # G \\<turnstile> FF\n\ngoal (8 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  Neg A # Neg B # G \\<turnstile> FF", "have \\<open>Neg B # G \\<turnstile> A\\<close>"], ["proof (prove)\nusing this:\n  Neg A # Neg B # G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. Neg B # G \\<turnstile> A", "using Class"], ["proof (prove)\nusing this:\n  Neg A # Neg B # G \\<turnstile> FF\n  Neg ?a # ?G \\<turnstile> FF \\<Longrightarrow> ?G \\<turnstile> ?a\n\ngoal (1 subgoal):\n 1. Neg B # G \\<turnstile> A", "by blast"], ["proof (state)\nthis:\n  Neg B # G \\<turnstile> A\n\ngoal (8 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "have \\<open>A # B # G \\<turnstile> B\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. A # B # G \\<turnstile> B", "by (simp add: Assum)"], ["proof (state)\nthis:\n  A # B # G \\<turnstile> B\n\ngoal (8 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  A # B # G \\<turnstile> B", "have \\<open>B # G \\<turnstile> Impl A B\\<close>"], ["proof (prove)\nusing this:\n  A # B # G \\<turnstile> B\n\ngoal (1 subgoal):\n 1. B # G \\<turnstile> Impl A B", "using ImplI"], ["proof (prove)\nusing this:\n  A # B # G \\<turnstile> B\n  ?a # ?G \\<turnstile> ?b \\<Longrightarrow> ?G \\<turnstile> Impl ?a ?b\n\ngoal (1 subgoal):\n 1. B # G \\<turnstile> Impl A B", "by blast"], ["proof (state)\nthis:\n  B # G \\<turnstile> Impl A B\n\ngoal (8 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "moreover"], ["proof (state)\nthis:\n  B # G \\<turnstile> Impl A B\n\ngoal (8 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "have \\<open>B # G \\<turnstile> Neg (Impl A B)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. B # G \\<turnstile> Neg (Impl A B)", "using * \\<open>Neg (Impl A B) \\<in> S\\<close>"], ["proof (prove)\nusing this:\n  S = set G\n  Neg (Impl A B) \\<in> S\n\ngoal (1 subgoal):\n 1. B # G \\<turnstile> Neg (Impl A B)", "by (simp add: Assum)"], ["proof (state)\nthis:\n  B # G \\<turnstile> Neg (Impl A B)\n\ngoal (8 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "ultimately"], ["proof (chain)\npicking this:\n  B # G \\<turnstile> Impl A B\n  B # G \\<turnstile> Neg (Impl A B)", "have \\<open>B # G \\<turnstile> FF\\<close>"], ["proof (prove)\nusing this:\n  B # G \\<turnstile> Impl A B\n  B # G \\<turnstile> Neg (Impl A B)\n\ngoal (1 subgoal):\n 1. B # G \\<turnstile> FF", "using NegE"], ["proof (prove)\nusing this:\n  B # G \\<turnstile> Impl A B\n  B # G \\<turnstile> Neg (Impl A B)\n  \\<lbrakk>?G \\<turnstile> Neg ?a; ?G \\<turnstile> ?a\\<rbrakk>\n  \\<Longrightarrow> ?G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. B # G \\<turnstile> FF", "by blast"], ["proof (state)\nthis:\n  B # G \\<turnstile> FF\n\ngoal (8 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  B # G \\<turnstile> FF", "have \\<open>G \\<turnstile> Neg B\\<close>"], ["proof (prove)\nusing this:\n  B # G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. G \\<turnstile> Neg B", "using NegI"], ["proof (prove)\nusing this:\n  B # G \\<turnstile> FF\n  ?a # ?G \\<turnstile> FF \\<Longrightarrow> ?G \\<turnstile> Neg ?a\n\ngoal (1 subgoal):\n 1. G \\<turnstile> Neg B", "by blast"], ["proof (state)\nthis:\n  G \\<turnstile> Neg B\n\ngoal (8 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "{"], ["proof (state)\nthis:\n  G \\<turnstile> Neg B\n\ngoal (8 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "assume \\<open>A # Neg B # G \\<turnstile> FF\\<close>"], ["proof (state)\nthis:\n  A # Neg B # G \\<turnstile> FF\n\ngoal (8 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  A # Neg B # G \\<turnstile> FF", "have \\<open>Neg B # G \\<turnstile> Neg A\\<close>"], ["proof (prove)\nusing this:\n  A # Neg B # G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. Neg B # G \\<turnstile> Neg A", "using NegI"], ["proof (prove)\nusing this:\n  A # Neg B # G \\<turnstile> FF\n  ?a # ?G \\<turnstile> FF \\<Longrightarrow> ?G \\<turnstile> Neg ?a\n\ngoal (1 subgoal):\n 1. Neg B # G \\<turnstile> Neg A", "by blast"], ["proof (state)\nthis:\n  Neg B # G \\<turnstile> Neg A\n\ngoal (8 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  Neg B # G \\<turnstile> Neg A", "have \\<open>Neg B # G \\<turnstile> FF\\<close>"], ["proof (prove)\nusing this:\n  Neg B # G \\<turnstile> Neg A\n\ngoal (1 subgoal):\n 1. Neg B # G \\<turnstile> FF", "using NegE \\<open>Neg B # G \\<turnstile> A\\<close>"], ["proof (prove)\nusing this:\n  Neg B # G \\<turnstile> Neg A\n  \\<lbrakk>?G \\<turnstile> Neg ?a; ?G \\<turnstile> ?a\\<rbrakk>\n  \\<Longrightarrow> ?G \\<turnstile> FF\n  Neg B # G \\<turnstile> A\n\ngoal (1 subgoal):\n 1. Neg B # G \\<turnstile> FF", "by blast"], ["proof (state)\nthis:\n  Neg B # G \\<turnstile> FF\n\ngoal (8 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  Neg B # G \\<turnstile> FF", "have \\<open>G \\<turnstile> FF\\<close>"], ["proof (prove)\nusing this:\n  Neg B # G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. G \\<turnstile> FF", "using cut \\<open>G \\<turnstile> Neg B\\<close>"], ["proof (prove)\nusing this:\n  Neg B # G \\<turnstile> FF\n  \\<lbrakk>?G \\<turnstile> ?A; ?A # ?G \\<turnstile> ?B\\<rbrakk>\n  \\<Longrightarrow> ?G \\<turnstile> ?B\n  G \\<turnstile> Neg B\n\ngoal (1 subgoal):\n 1. G \\<turnstile> FF", "by blast"], ["proof (state)\nthis:\n  G \\<turnstile> FF\n\ngoal (8 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  G \\<turnstile> FF", "have False"], ["proof (prove)\nusing this:\n  G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. False", "using \\<open>\\<not> G \\<turnstile> FF\\<close>"], ["proof (prove)\nusing this:\n  G \\<turnstile> FF\n  \\<not> G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (8 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "}"], ["proof (state)\nthis:\n  A # Neg B # G \\<turnstile> FF \\<Longrightarrow> False\n\ngoal (8 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  A # Neg B # G \\<turnstile> FF \\<Longrightarrow> False", "have \\<open>\\<not> A # Neg B # G \\<turnstile> FF\\<close>"], ["proof (prove)\nusing this:\n  A # Neg B # G \\<turnstile> FF \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> A # Neg B # G \\<turnstile> FF", "by blast"], ["proof (state)\nthis:\n  \\<not> A # Neg B # G \\<turnstile> FF\n\ngoal (8 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "moreover"], ["proof (state)\nthis:\n  \\<not> A # Neg B # G \\<turnstile> FF\n\ngoal (8 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "have \\<open>{A, Neg B} \\<union> S = set (A # Neg B # G)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. {A, Neg B} \\<union> S = set (A # Neg B # G)", "using *"], ["proof (prove)\nusing this:\n  S = set G\n\ngoal (1 subgoal):\n 1. {A, Neg B} \\<union> S = set (A # Neg B # G)", "by simp"], ["proof (state)\nthis:\n  {A, Neg B} \\<union> S = set (A # Neg B # G)\n\ngoal (8 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> A # Neg B # G \\<turnstile> FF\n  {A, Neg B} \\<union> S = set (A # Neg B # G)", "show \\<open>S \\<union> {A, Neg B} \\<in> ?C\\<close>"], ["proof (prove)\nusing this:\n  \\<not> A # Neg B # G \\<turnstile> FF\n  {A, Neg B} \\<union> S = set (A # Neg B # G)\n\ngoal (1 subgoal):\n 1. S \\<union> {A, Neg B} \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "by blast"], ["proof (state)\nthis:\n  S \\<union> {A, Neg B} \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n\ngoal (7 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "}"], ["proof (state)\nthis:\n  Neg (Impl ?A2 ?B2) \\<in> S \\<Longrightarrow>\n  S \\<union> {?A2, Neg ?B2} \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n\ngoal (7 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "{"], ["proof (state)\nthis:\n  Neg (Impl ?A2 ?B2) \\<in> S \\<Longrightarrow>\n  S \\<union> {?A2, Neg ?B2} \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n\ngoal (7 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "fix A B"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "assume \\<open>Or A B \\<in> S\\<close>"], ["proof (state)\nthis:\n  Or A B \\<in> S\n\ngoal (7 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  Or A B \\<in> S", "have \\<open>G \\<turnstile> Or A B\\<close>"], ["proof (prove)\nusing this:\n  Or A B \\<in> S\n\ngoal (1 subgoal):\n 1. G \\<turnstile> Or A B", "using * Assum"], ["proof (prove)\nusing this:\n  Or A B \\<in> S\n  S = set G\n  ?a \\<in> set ?G \\<Longrightarrow> ?G \\<turnstile> ?a\n\ngoal (1 subgoal):\n 1. G \\<turnstile> Or A B", "by blast"], ["proof (state)\nthis:\n  G \\<turnstile> Or A B\n\ngoal (7 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "{"], ["proof (state)\nthis:\n  G \\<turnstile> Or A B\n\ngoal (7 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "assume \\<open>(\\<forall>G'. set G' = S \\<union> {A} \\<longrightarrow> G' \\<turnstile> FF)\\<close>\n        and \\<open>(\\<forall>G'. set G' = S \\<union> {B} \\<longrightarrow> G' \\<turnstile> FF)\\<close>"], ["proof (state)\nthis:\n  \\<forall>G'. set G' = S \\<union> {A} \\<longrightarrow> G' \\<turnstile> FF\n  \\<forall>G'. set G' = S \\<union> {B} \\<longrightarrow> G' \\<turnstile> FF\n\ngoal (7 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  \\<forall>G'. set G' = S \\<union> {A} \\<longrightarrow> G' \\<turnstile> FF\n  \\<forall>G'. set G' = S \\<union> {B} \\<longrightarrow> G' \\<turnstile> FF", "have \\<open>A # G \\<turnstile> FF\\<close> and \\<open>B # G \\<turnstile> FF\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>G'. set G' = S \\<union> {A} \\<longrightarrow> G' \\<turnstile> FF\n  \\<forall>G'. set G' = S \\<union> {B} \\<longrightarrow> G' \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. A # G \\<turnstile> FF &&& B # G \\<turnstile> FF", "using *"], ["proof (prove)\nusing this:\n  \\<forall>G'. set G' = S \\<union> {A} \\<longrightarrow> G' \\<turnstile> FF\n  \\<forall>G'. set G' = S \\<union> {B} \\<longrightarrow> G' \\<turnstile> FF\n  S = set G\n\ngoal (1 subgoal):\n 1. A # G \\<turnstile> FF &&& B # G \\<turnstile> FF", "by simp_all"], ["proof (state)\nthis:\n  A # G \\<turnstile> FF\n  B # G \\<turnstile> FF\n\ngoal (7 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  A # G \\<turnstile> FF\n  B # G \\<turnstile> FF", "have \\<open>G \\<turnstile> FF\\<close>"], ["proof (prove)\nusing this:\n  A # G \\<turnstile> FF\n  B # G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. G \\<turnstile> FF", "using OrE \\<open>G \\<turnstile> Or A B\\<close>"], ["proof (prove)\nusing this:\n  A # G \\<turnstile> FF\n  B # G \\<turnstile> FF\n  \\<lbrakk>?G \\<turnstile> Or ?a ?b; ?a # ?G \\<turnstile> ?c;\n   ?b # ?G \\<turnstile> ?c\\<rbrakk>\n  \\<Longrightarrow> ?G \\<turnstile> ?c\n  G \\<turnstile> Or A B\n\ngoal (1 subgoal):\n 1. G \\<turnstile> FF", "by blast"], ["proof (state)\nthis:\n  G \\<turnstile> FF\n\ngoal (7 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  G \\<turnstile> FF", "have False"], ["proof (prove)\nusing this:\n  G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. False", "using \\<open>\\<not> G \\<turnstile> FF\\<close>"], ["proof (prove)\nusing this:\n  G \\<turnstile> FF\n  \\<not> G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (7 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "}"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>G'.\n              set G' = S \\<union> {A} \\<longrightarrow> G' \\<turnstile> FF;\n   \\<forall>G'.\n      set G' = S \\<union> {B} \\<longrightarrow> G' \\<turnstile> FF\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (7 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>G'.\n              set G' = S \\<union> {A} \\<longrightarrow> G' \\<turnstile> FF;\n   \\<forall>G'.\n      set G' = S \\<union> {B} \\<longrightarrow> G' \\<turnstile> FF\\<rbrakk>\n  \\<Longrightarrow> False", "show \\<open>S \\<union> {A} \\<in> ?C \\<or> S \\<union> {B} \\<in> ?C\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>G'.\n              set G' = S \\<union> {A} \\<longrightarrow> G' \\<turnstile> FF;\n   \\<forall>G'.\n      set G' = S \\<union> {B} \\<longrightarrow> G' \\<turnstile> FF\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. S \\<union> {A} \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n    S \\<union> {B} \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "by blast"], ["proof (state)\nthis:\n  S \\<union> {A} \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n  S \\<union> {B} \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n\ngoal (6 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "}"], ["proof (state)\nthis:\n  Or ?A2 ?B2 \\<in> S \\<Longrightarrow>\n  S \\<union> {?A2} \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n  S \\<union> {?B2} \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n\ngoal (6 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "{"], ["proof (state)\nthis:\n  Or ?A2 ?B2 \\<in> S \\<Longrightarrow>\n  S \\<union> {?A2} \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n  S \\<union> {?B2} \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n\ngoal (6 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "fix A B"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "assume \\<open>Neg (And A B) \\<in> S\\<close>"], ["proof (state)\nthis:\n  Neg (And A B) \\<in> S\n\ngoal (6 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "let ?x = \\<open>Or (Neg A) (Neg B)\\<close>"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "have \\<open>B # A # Neg ?x # G \\<turnstile> A\\<close> and \\<open>B # A # Neg ?x # G \\<turnstile> B\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. B # A # Neg (Or (Neg A) (Neg B)) # G \\<turnstile> A &&&\n    B # A # Neg (Or (Neg A) (Neg B)) # G \\<turnstile> B", "by (simp_all add: Assum)"], ["proof (state)\nthis:\n  B # A # Neg (Or (Neg A) (Neg B)) # G \\<turnstile> A\n  B # A # Neg (Or (Neg A) (Neg B)) # G \\<turnstile> B\n\ngoal (6 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  B # A # Neg (Or (Neg A) (Neg B)) # G \\<turnstile> A\n  B # A # Neg (Or (Neg A) (Neg B)) # G \\<turnstile> B", "have \\<open>B # A # Neg ?x # G \\<turnstile> And A B\\<close>"], ["proof (prove)\nusing this:\n  B # A # Neg (Or (Neg A) (Neg B)) # G \\<turnstile> A\n  B # A # Neg (Or (Neg A) (Neg B)) # G \\<turnstile> B\n\ngoal (1 subgoal):\n 1. B # A # Neg (Or (Neg A) (Neg B)) # G \\<turnstile> And A B", "using AndI"], ["proof (prove)\nusing this:\n  B # A # Neg (Or (Neg A) (Neg B)) # G \\<turnstile> A\n  B # A # Neg (Or (Neg A) (Neg B)) # G \\<turnstile> B\n  \\<lbrakk>?G \\<turnstile> ?a; ?G \\<turnstile> ?b\\<rbrakk>\n  \\<Longrightarrow> ?G \\<turnstile> And ?a ?b\n\ngoal (1 subgoal):\n 1. B # A # Neg (Or (Neg A) (Neg B)) # G \\<turnstile> And A B", "by blast"], ["proof (state)\nthis:\n  B # A # Neg (Or (Neg A) (Neg B)) # G \\<turnstile> And A B\n\ngoal (6 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "moreover"], ["proof (state)\nthis:\n  B # A # Neg (Or (Neg A) (Neg B)) # G \\<turnstile> And A B\n\ngoal (6 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "have \\<open>B # A # Neg ?x # G \\<turnstile> Neg (And A B)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. B # A # Neg (Or (Neg A) (Neg B)) # G \\<turnstile> Neg (And A B)", "using * \\<open>Neg (And A B) \\<in> S\\<close>"], ["proof (prove)\nusing this:\n  S = set G\n  Neg (And A B) \\<in> S\n\ngoal (1 subgoal):\n 1. B # A # Neg (Or (Neg A) (Neg B)) # G \\<turnstile> Neg (And A B)", "by (simp add: Assum)"], ["proof (state)\nthis:\n  B # A # Neg (Or (Neg A) (Neg B)) # G \\<turnstile> Neg (And A B)\n\ngoal (6 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "ultimately"], ["proof (chain)\npicking this:\n  B # A # Neg (Or (Neg A) (Neg B)) # G \\<turnstile> And A B\n  B # A # Neg (Or (Neg A) (Neg B)) # G \\<turnstile> Neg (And A B)", "have \\<open>B # A # Neg ?x # G \\<turnstile> FF\\<close>"], ["proof (prove)\nusing this:\n  B # A # Neg (Or (Neg A) (Neg B)) # G \\<turnstile> And A B\n  B # A # Neg (Or (Neg A) (Neg B)) # G \\<turnstile> Neg (And A B)\n\ngoal (1 subgoal):\n 1. B # A # Neg (Or (Neg A) (Neg B)) # G \\<turnstile> FF", "using NegE"], ["proof (prove)\nusing this:\n  B # A # Neg (Or (Neg A) (Neg B)) # G \\<turnstile> And A B\n  B # A # Neg (Or (Neg A) (Neg B)) # G \\<turnstile> Neg (And A B)\n  \\<lbrakk>?G \\<turnstile> Neg ?a; ?G \\<turnstile> ?a\\<rbrakk>\n  \\<Longrightarrow> ?G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. B # A # Neg (Or (Neg A) (Neg B)) # G \\<turnstile> FF", "by blast"], ["proof (state)\nthis:\n  B # A # Neg (Or (Neg A) (Neg B)) # G \\<turnstile> FF\n\ngoal (6 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  B # A # Neg (Or (Neg A) (Neg B)) # G \\<turnstile> FF", "have \\<open>A # Neg ?x # G \\<turnstile> Neg B\\<close>"], ["proof (prove)\nusing this:\n  B # A # Neg (Or (Neg A) (Neg B)) # G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. A # Neg (Or (Neg A) (Neg B)) # G \\<turnstile> Neg B", "using NegI"], ["proof (prove)\nusing this:\n  B # A # Neg (Or (Neg A) (Neg B)) # G \\<turnstile> FF\n  ?a # ?G \\<turnstile> FF \\<Longrightarrow> ?G \\<turnstile> Neg ?a\n\ngoal (1 subgoal):\n 1. A # Neg (Or (Neg A) (Neg B)) # G \\<turnstile> Neg B", "by blast"], ["proof (state)\nthis:\n  A # Neg (Or (Neg A) (Neg B)) # G \\<turnstile> Neg B\n\ngoal (6 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  A # Neg (Or (Neg A) (Neg B)) # G \\<turnstile> Neg B", "have \\<open>A # Neg ?x # G \\<turnstile> ?x\\<close>"], ["proof (prove)\nusing this:\n  A # Neg (Or (Neg A) (Neg B)) # G \\<turnstile> Neg B\n\ngoal (1 subgoal):\n 1. A # Neg (Or (Neg A) (Neg B)) # G \\<turnstile> Or (Neg A) (Neg B)", "using OrI2"], ["proof (prove)\nusing this:\n  A # Neg (Or (Neg A) (Neg B)) # G \\<turnstile> Neg B\n  ?G \\<turnstile> ?b \\<Longrightarrow> ?G \\<turnstile> Or ?a ?b\n\ngoal (1 subgoal):\n 1. A # Neg (Or (Neg A) (Neg B)) # G \\<turnstile> Or (Neg A) (Neg B)", "by blast"], ["proof (state)\nthis:\n  A # Neg (Or (Neg A) (Neg B)) # G \\<turnstile> Or (Neg A) (Neg B)\n\ngoal (6 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "moreover"], ["proof (state)\nthis:\n  A # Neg (Or (Neg A) (Neg B)) # G \\<turnstile> Or (Neg A) (Neg B)\n\ngoal (6 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "have \\<open>A # Neg ?x # G \\<turnstile> Neg ?x\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. A # Neg (Or (Neg A) (Neg B)) # G \\<turnstile> Neg (Or (Neg A) (Neg B))", "by (simp add: Assum)"], ["proof (state)\nthis:\n  A # Neg (Or (Neg A) (Neg B)) # G \\<turnstile> Neg (Or (Neg A) (Neg B))\n\ngoal (6 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "ultimately"], ["proof (chain)\npicking this:\n  A # Neg (Or (Neg A) (Neg B)) # G \\<turnstile> Or (Neg A) (Neg B)\n  A # Neg (Or (Neg A) (Neg B)) # G \\<turnstile> Neg (Or (Neg A) (Neg B))", "have \\<open>A # Neg ?x # G \\<turnstile> FF\\<close>"], ["proof (prove)\nusing this:\n  A # Neg (Or (Neg A) (Neg B)) # G \\<turnstile> Or (Neg A) (Neg B)\n  A # Neg (Or (Neg A) (Neg B)) # G \\<turnstile> Neg (Or (Neg A) (Neg B))\n\ngoal (1 subgoal):\n 1. A # Neg (Or (Neg A) (Neg B)) # G \\<turnstile> FF", "using NegE"], ["proof (prove)\nusing this:\n  A # Neg (Or (Neg A) (Neg B)) # G \\<turnstile> Or (Neg A) (Neg B)\n  A # Neg (Or (Neg A) (Neg B)) # G \\<turnstile> Neg (Or (Neg A) (Neg B))\n  \\<lbrakk>?G \\<turnstile> Neg ?a; ?G \\<turnstile> ?a\\<rbrakk>\n  \\<Longrightarrow> ?G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. A # Neg (Or (Neg A) (Neg B)) # G \\<turnstile> FF", "by blast"], ["proof (state)\nthis:\n  A # Neg (Or (Neg A) (Neg B)) # G \\<turnstile> FF\n\ngoal (6 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  A # Neg (Or (Neg A) (Neg B)) # G \\<turnstile> FF", "have \\<open>Neg ?x # G \\<turnstile> Neg A\\<close>"], ["proof (prove)\nusing this:\n  A # Neg (Or (Neg A) (Neg B)) # G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. Neg (Or (Neg A) (Neg B)) # G \\<turnstile> Neg A", "using NegI"], ["proof (prove)\nusing this:\n  A # Neg (Or (Neg A) (Neg B)) # G \\<turnstile> FF\n  ?a # ?G \\<turnstile> FF \\<Longrightarrow> ?G \\<turnstile> Neg ?a\n\ngoal (1 subgoal):\n 1. Neg (Or (Neg A) (Neg B)) # G \\<turnstile> Neg A", "by blast"], ["proof (state)\nthis:\n  Neg (Or (Neg A) (Neg B)) # G \\<turnstile> Neg A\n\ngoal (6 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  Neg (Or (Neg A) (Neg B)) # G \\<turnstile> Neg A", "have \\<open>Neg ?x # G \\<turnstile> ?x\\<close>"], ["proof (prove)\nusing this:\n  Neg (Or (Neg A) (Neg B)) # G \\<turnstile> Neg A\n\ngoal (1 subgoal):\n 1. Neg (Or (Neg A) (Neg B)) # G \\<turnstile> Or (Neg A) (Neg B)", "using OrI1"], ["proof (prove)\nusing this:\n  Neg (Or (Neg A) (Neg B)) # G \\<turnstile> Neg A\n  ?G \\<turnstile> ?a \\<Longrightarrow> ?G \\<turnstile> Or ?a ?b\n\ngoal (1 subgoal):\n 1. Neg (Or (Neg A) (Neg B)) # G \\<turnstile> Or (Neg A) (Neg B)", "by blast"], ["proof (state)\nthis:\n  Neg (Or (Neg A) (Neg B)) # G \\<turnstile> Or (Neg A) (Neg B)\n\ngoal (6 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  Neg (Or (Neg A) (Neg B)) # G \\<turnstile> Or (Neg A) (Neg B)", "have \\<open>G \\<turnstile> Or (Neg A) (Neg B)\\<close>"], ["proof (prove)\nusing this:\n  Neg (Or (Neg A) (Neg B)) # G \\<turnstile> Or (Neg A) (Neg B)\n\ngoal (1 subgoal):\n 1. G \\<turnstile> Or (Neg A) (Neg B)", "using Class'"], ["proof (prove)\nusing this:\n  Neg (Or (Neg A) (Neg B)) # G \\<turnstile> Or (Neg A) (Neg B)\n  Neg ?A # ?G \\<turnstile> ?A \\<Longrightarrow> ?G \\<turnstile> ?A\n\ngoal (1 subgoal):\n 1. G \\<turnstile> Or (Neg A) (Neg B)", "by blast"], ["proof (state)\nthis:\n  G \\<turnstile> Or (Neg A) (Neg B)\n\ngoal (6 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "{"], ["proof (state)\nthis:\n  G \\<turnstile> Or (Neg A) (Neg B)\n\ngoal (6 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "assume \\<open>(\\<forall>G'. set G' = S \\<union> {Neg A} \\<longrightarrow> G' \\<turnstile> FF)\\<close>\n        and \\<open>(\\<forall>G'. set G' = S \\<union> {Neg B} \\<longrightarrow> G' \\<turnstile> FF)\\<close>"], ["proof (state)\nthis:\n  \\<forall>G'.\n     set G' = S \\<union> {Neg A} \\<longrightarrow> G' \\<turnstile> FF\n  \\<forall>G'.\n     set G' = S \\<union> {Neg B} \\<longrightarrow> G' \\<turnstile> FF\n\ngoal (6 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  \\<forall>G'.\n     set G' = S \\<union> {Neg A} \\<longrightarrow> G' \\<turnstile> FF\n  \\<forall>G'.\n     set G' = S \\<union> {Neg B} \\<longrightarrow> G' \\<turnstile> FF", "have \\<open>Neg A # G \\<turnstile> FF\\<close> and \\<open>Neg B # G \\<turnstile> FF\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>G'.\n     set G' = S \\<union> {Neg A} \\<longrightarrow> G' \\<turnstile> FF\n  \\<forall>G'.\n     set G' = S \\<union> {Neg B} \\<longrightarrow> G' \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. Neg A # G \\<turnstile> FF &&& Neg B # G \\<turnstile> FF", "using *"], ["proof (prove)\nusing this:\n  \\<forall>G'.\n     set G' = S \\<union> {Neg A} \\<longrightarrow> G' \\<turnstile> FF\n  \\<forall>G'.\n     set G' = S \\<union> {Neg B} \\<longrightarrow> G' \\<turnstile> FF\n  S = set G\n\ngoal (1 subgoal):\n 1. Neg A # G \\<turnstile> FF &&& Neg B # G \\<turnstile> FF", "by simp_all"], ["proof (state)\nthis:\n  Neg A # G \\<turnstile> FF\n  Neg B # G \\<turnstile> FF\n\ngoal (6 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  Neg A # G \\<turnstile> FF\n  Neg B # G \\<turnstile> FF", "have \\<open>G \\<turnstile> FF\\<close>"], ["proof (prove)\nusing this:\n  Neg A # G \\<turnstile> FF\n  Neg B # G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. G \\<turnstile> FF", "using OrE \\<open>G \\<turnstile> Or (Neg A) (Neg B)\\<close>"], ["proof (prove)\nusing this:\n  Neg A # G \\<turnstile> FF\n  Neg B # G \\<turnstile> FF\n  \\<lbrakk>?G \\<turnstile> Or ?a ?b; ?a # ?G \\<turnstile> ?c;\n   ?b # ?G \\<turnstile> ?c\\<rbrakk>\n  \\<Longrightarrow> ?G \\<turnstile> ?c\n  G \\<turnstile> Or (Neg A) (Neg B)\n\ngoal (1 subgoal):\n 1. G \\<turnstile> FF", "by blast"], ["proof (state)\nthis:\n  G \\<turnstile> FF\n\ngoal (6 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  G \\<turnstile> FF", "have False"], ["proof (prove)\nusing this:\n  G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. False", "using \\<open>\\<not> G \\<turnstile> FF\\<close>"], ["proof (prove)\nusing this:\n  G \\<turnstile> FF\n  \\<not> G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (6 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "}"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>G'.\n              set G' = S \\<union> {Neg A} \\<longrightarrow>\n              G' \\<turnstile> FF;\n   \\<forall>G'.\n      set G' = S \\<union> {Neg B} \\<longrightarrow>\n      G' \\<turnstile> FF\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (6 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>G'.\n              set G' = S \\<union> {Neg A} \\<longrightarrow>\n              G' \\<turnstile> FF;\n   \\<forall>G'.\n      set G' = S \\<union> {Neg B} \\<longrightarrow>\n      G' \\<turnstile> FF\\<rbrakk>\n  \\<Longrightarrow> False", "show \\<open>S \\<union> {Neg A} \\<in> ?C \\<or> S \\<union> {Neg B} \\<in> ?C\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>G'.\n              set G' = S \\<union> {Neg A} \\<longrightarrow>\n              G' \\<turnstile> FF;\n   \\<forall>G'.\n      set G' = S \\<union> {Neg B} \\<longrightarrow>\n      G' \\<turnstile> FF\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. S \\<union> {Neg A} \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n    S \\<union> {Neg B} \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "by blast"], ["proof (state)\nthis:\n  S \\<union> {Neg A} \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n  S \\<union> {Neg B} \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n\ngoal (5 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "}"], ["proof (state)\nthis:\n  Neg (And ?A2 ?B2) \\<in> S \\<Longrightarrow>\n  S \\<union> {Neg ?A2} \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n  S \\<union> {Neg ?B2} \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n\ngoal (5 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "{"], ["proof (state)\nthis:\n  Neg (And ?A2 ?B2) \\<in> S \\<Longrightarrow>\n  S \\<union> {Neg ?A2} \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n  S \\<union> {Neg ?B2} \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n\ngoal (5 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "fix A B"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "assume \\<open>Impl A B \\<in> S\\<close>"], ["proof (state)\nthis:\n  Impl A B \\<in> S\n\ngoal (5 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "let ?x = \\<open>Or (Neg A) B\\<close>"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "have \\<open>A # Neg ?x # G \\<turnstile> A\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. A # Neg (Or (Neg A) B) # G \\<turnstile> A", "by (simp add: Assum)"], ["proof (state)\nthis:\n  A # Neg (Or (Neg A) B) # G \\<turnstile> A\n\ngoal (5 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "moreover"], ["proof (state)\nthis:\n  A # Neg (Or (Neg A) B) # G \\<turnstile> A\n\ngoal (5 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "have \\<open>A # Neg ?x # G \\<turnstile> Impl A B\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. A # Neg (Or (Neg A) B) # G \\<turnstile> Impl A B", "using * \\<open>Impl A B \\<in> S\\<close>"], ["proof (prove)\nusing this:\n  S = set G\n  Impl A B \\<in> S\n\ngoal (1 subgoal):\n 1. A # Neg (Or (Neg A) B) # G \\<turnstile> Impl A B", "by (simp add: Assum)"], ["proof (state)\nthis:\n  A # Neg (Or (Neg A) B) # G \\<turnstile> Impl A B\n\ngoal (5 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "ultimately"], ["proof (chain)\npicking this:\n  A # Neg (Or (Neg A) B) # G \\<turnstile> A\n  A # Neg (Or (Neg A) B) # G \\<turnstile> Impl A B", "have \\<open>A # Neg ?x # G \\<turnstile> B\\<close>"], ["proof (prove)\nusing this:\n  A # Neg (Or (Neg A) B) # G \\<turnstile> A\n  A # Neg (Or (Neg A) B) # G \\<turnstile> Impl A B\n\ngoal (1 subgoal):\n 1. A # Neg (Or (Neg A) B) # G \\<turnstile> B", "using ImplE"], ["proof (prove)\nusing this:\n  A # Neg (Or (Neg A) B) # G \\<turnstile> A\n  A # Neg (Or (Neg A) B) # G \\<turnstile> Impl A B\n  \\<lbrakk>?G \\<turnstile> Impl ?a ?b; ?G \\<turnstile> ?a\\<rbrakk>\n  \\<Longrightarrow> ?G \\<turnstile> ?b\n\ngoal (1 subgoal):\n 1. A # Neg (Or (Neg A) B) # G \\<turnstile> B", "by blast"], ["proof (state)\nthis:\n  A # Neg (Or (Neg A) B) # G \\<turnstile> B\n\ngoal (5 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  A # Neg (Or (Neg A) B) # G \\<turnstile> B", "have \\<open>A # Neg ?x # G \\<turnstile> ?x\\<close>"], ["proof (prove)\nusing this:\n  A # Neg (Or (Neg A) B) # G \\<turnstile> B\n\ngoal (1 subgoal):\n 1. A # Neg (Or (Neg A) B) # G \\<turnstile> Or (Neg A) B", "using OrI2"], ["proof (prove)\nusing this:\n  A # Neg (Or (Neg A) B) # G \\<turnstile> B\n  ?G \\<turnstile> ?b \\<Longrightarrow> ?G \\<turnstile> Or ?a ?b\n\ngoal (1 subgoal):\n 1. A # Neg (Or (Neg A) B) # G \\<turnstile> Or (Neg A) B", "by blast"], ["proof (state)\nthis:\n  A # Neg (Or (Neg A) B) # G \\<turnstile> Or (Neg A) B\n\ngoal (5 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "moreover"], ["proof (state)\nthis:\n  A # Neg (Or (Neg A) B) # G \\<turnstile> Or (Neg A) B\n\ngoal (5 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "have \\<open>A # Neg ?x # G \\<turnstile> Neg ?x\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. A # Neg (Or (Neg A) B) # G \\<turnstile> Neg (Or (Neg A) B)", "by (simp add: Assum)"], ["proof (state)\nthis:\n  A # Neg (Or (Neg A) B) # G \\<turnstile> Neg (Or (Neg A) B)\n\ngoal (5 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "ultimately"], ["proof (chain)\npicking this:\n  A # Neg (Or (Neg A) B) # G \\<turnstile> Or (Neg A) B\n  A # Neg (Or (Neg A) B) # G \\<turnstile> Neg (Or (Neg A) B)", "have \\<open>A # Neg ?x # G \\<turnstile> FF\\<close>"], ["proof (prove)\nusing this:\n  A # Neg (Or (Neg A) B) # G \\<turnstile> Or (Neg A) B\n  A # Neg (Or (Neg A) B) # G \\<turnstile> Neg (Or (Neg A) B)\n\ngoal (1 subgoal):\n 1. A # Neg (Or (Neg A) B) # G \\<turnstile> FF", "using NegE"], ["proof (prove)\nusing this:\n  A # Neg (Or (Neg A) B) # G \\<turnstile> Or (Neg A) B\n  A # Neg (Or (Neg A) B) # G \\<turnstile> Neg (Or (Neg A) B)\n  \\<lbrakk>?G \\<turnstile> Neg ?a; ?G \\<turnstile> ?a\\<rbrakk>\n  \\<Longrightarrow> ?G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. A # Neg (Or (Neg A) B) # G \\<turnstile> FF", "by blast"], ["proof (state)\nthis:\n  A # Neg (Or (Neg A) B) # G \\<turnstile> FF\n\ngoal (5 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  A # Neg (Or (Neg A) B) # G \\<turnstile> FF", "have \\<open>Neg ?x # G \\<turnstile> Neg A\\<close>"], ["proof (prove)\nusing this:\n  A # Neg (Or (Neg A) B) # G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. Neg (Or (Neg A) B) # G \\<turnstile> Neg A", "using NegI"], ["proof (prove)\nusing this:\n  A # Neg (Or (Neg A) B) # G \\<turnstile> FF\n  ?a # ?G \\<turnstile> FF \\<Longrightarrow> ?G \\<turnstile> Neg ?a\n\ngoal (1 subgoal):\n 1. Neg (Or (Neg A) B) # G \\<turnstile> Neg A", "by blast"], ["proof (state)\nthis:\n  Neg (Or (Neg A) B) # G \\<turnstile> Neg A\n\ngoal (5 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  Neg (Or (Neg A) B) # G \\<turnstile> Neg A", "have \\<open>Neg ?x # G \\<turnstile> ?x\\<close>"], ["proof (prove)\nusing this:\n  Neg (Or (Neg A) B) # G \\<turnstile> Neg A\n\ngoal (1 subgoal):\n 1. Neg (Or (Neg A) B) # G \\<turnstile> Or (Neg A) B", "using OrI1"], ["proof (prove)\nusing this:\n  Neg (Or (Neg A) B) # G \\<turnstile> Neg A\n  ?G \\<turnstile> ?a \\<Longrightarrow> ?G \\<turnstile> Or ?a ?b\n\ngoal (1 subgoal):\n 1. Neg (Or (Neg A) B) # G \\<turnstile> Or (Neg A) B", "by blast"], ["proof (state)\nthis:\n  Neg (Or (Neg A) B) # G \\<turnstile> Or (Neg A) B\n\ngoal (5 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  Neg (Or (Neg A) B) # G \\<turnstile> Or (Neg A) B", "have \\<open>G \\<turnstile> Or (Neg A) B\\<close>"], ["proof (prove)\nusing this:\n  Neg (Or (Neg A) B) # G \\<turnstile> Or (Neg A) B\n\ngoal (1 subgoal):\n 1. G \\<turnstile> Or (Neg A) B", "using Class'"], ["proof (prove)\nusing this:\n  Neg (Or (Neg A) B) # G \\<turnstile> Or (Neg A) B\n  Neg ?A # ?G \\<turnstile> ?A \\<Longrightarrow> ?G \\<turnstile> ?A\n\ngoal (1 subgoal):\n 1. G \\<turnstile> Or (Neg A) B", "by blast"], ["proof (state)\nthis:\n  G \\<turnstile> Or (Neg A) B\n\ngoal (5 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "{"], ["proof (state)\nthis:\n  G \\<turnstile> Or (Neg A) B\n\ngoal (5 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "assume \\<open>(\\<forall>G'. set G' = S \\<union> {Neg A} \\<longrightarrow> G' \\<turnstile> FF)\\<close>\n        and \\<open>(\\<forall>G'. set G' = S \\<union> {B} \\<longrightarrow> G' \\<turnstile> FF)\\<close>"], ["proof (state)\nthis:\n  \\<forall>G'.\n     set G' = S \\<union> {Neg A} \\<longrightarrow> G' \\<turnstile> FF\n  \\<forall>G'. set G' = S \\<union> {B} \\<longrightarrow> G' \\<turnstile> FF\n\ngoal (5 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  \\<forall>G'.\n     set G' = S \\<union> {Neg A} \\<longrightarrow> G' \\<turnstile> FF\n  \\<forall>G'. set G' = S \\<union> {B} \\<longrightarrow> G' \\<turnstile> FF", "have \\<open>Neg A # G \\<turnstile> FF\\<close> and \\<open>B # G \\<turnstile> FF\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>G'.\n     set G' = S \\<union> {Neg A} \\<longrightarrow> G' \\<turnstile> FF\n  \\<forall>G'. set G' = S \\<union> {B} \\<longrightarrow> G' \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. Neg A # G \\<turnstile> FF &&& B # G \\<turnstile> FF", "using *"], ["proof (prove)\nusing this:\n  \\<forall>G'.\n     set G' = S \\<union> {Neg A} \\<longrightarrow> G' \\<turnstile> FF\n  \\<forall>G'. set G' = S \\<union> {B} \\<longrightarrow> G' \\<turnstile> FF\n  S = set G\n\ngoal (1 subgoal):\n 1. Neg A # G \\<turnstile> FF &&& B # G \\<turnstile> FF", "by simp_all"], ["proof (state)\nthis:\n  Neg A # G \\<turnstile> FF\n  B # G \\<turnstile> FF\n\ngoal (5 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  Neg A # G \\<turnstile> FF\n  B # G \\<turnstile> FF", "have \\<open>G \\<turnstile> FF\\<close>"], ["proof (prove)\nusing this:\n  Neg A # G \\<turnstile> FF\n  B # G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. G \\<turnstile> FF", "using OrE \\<open>G \\<turnstile> Or (Neg A) B\\<close>"], ["proof (prove)\nusing this:\n  Neg A # G \\<turnstile> FF\n  B # G \\<turnstile> FF\n  \\<lbrakk>?G \\<turnstile> Or ?a ?b; ?a # ?G \\<turnstile> ?c;\n   ?b # ?G \\<turnstile> ?c\\<rbrakk>\n  \\<Longrightarrow> ?G \\<turnstile> ?c\n  G \\<turnstile> Or (Neg A) B\n\ngoal (1 subgoal):\n 1. G \\<turnstile> FF", "by blast"], ["proof (state)\nthis:\n  G \\<turnstile> FF\n\ngoal (5 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  G \\<turnstile> FF", "have False"], ["proof (prove)\nusing this:\n  G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. False", "using \\<open>\\<not> G \\<turnstile> FF\\<close>"], ["proof (prove)\nusing this:\n  G \\<turnstile> FF\n  \\<not> G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (5 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "}"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>G'.\n              set G' = S \\<union> {Neg A} \\<longrightarrow>\n              G' \\<turnstile> FF;\n   \\<forall>G'.\n      set G' = S \\<union> {B} \\<longrightarrow> G' \\<turnstile> FF\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (5 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n                         S \\<union> {B}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>G'.\n              set G' = S \\<union> {Neg A} \\<longrightarrow>\n              G' \\<turnstile> FF;\n   \\<forall>G'.\n      set G' = S \\<union> {B} \\<longrightarrow> G' \\<turnstile> FF\\<rbrakk>\n  \\<Longrightarrow> False", "show \\<open>S \\<union> {Neg A} \\<in> ?C \\<or> S \\<union> {B} \\<in> ?C\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>G'.\n              set G' = S \\<union> {Neg A} \\<longrightarrow>\n              G' \\<turnstile> FF;\n   \\<forall>G'.\n      set G' = S \\<union> {B} \\<longrightarrow> G' \\<turnstile> FF\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. S \\<union> {Neg A} \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n    S \\<union> {B} \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "by blast"], ["proof (state)\nthis:\n  S \\<union> {Neg A} \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n  S \\<union> {B} \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n\ngoal (4 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "}"], ["proof (state)\nthis:\n  Impl ?A2 ?B2 \\<in> S \\<Longrightarrow>\n  S \\<union> {Neg ?A2} \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n  S \\<union> {?B2} \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n\ngoal (4 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "{"], ["proof (state)\nthis:\n  Impl ?A2 ?B2 \\<in> S \\<Longrightarrow>\n  S \\<union> {Neg ?A2} \\<in> {set G |G. \\<not> G \\<turnstile> FF} \\<or>\n  S \\<union> {?B2} \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n\ngoal (4 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "fix P and t :: \\<open>'a term\\<close>"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "assume \\<open>closedt 0 t\\<close> and \\<open>Forall P \\<in> S\\<close>"], ["proof (state)\nthis:\n  closedt 0 t\n  Forall P \\<in> S\n\ngoal (4 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  closedt 0 t\n  Forall P \\<in> S", "have \\<open>G \\<turnstile> Forall P\\<close>"], ["proof (prove)\nusing this:\n  closedt 0 t\n  Forall P \\<in> S\n\ngoal (1 subgoal):\n 1. G \\<turnstile> Forall P", "using Assum *"], ["proof (prove)\nusing this:\n  closedt 0 t\n  Forall P \\<in> S\n  ?a \\<in> set ?G \\<Longrightarrow> ?G \\<turnstile> ?a\n  S = set G\n\ngoal (1 subgoal):\n 1. G \\<turnstile> Forall P", "by blast"], ["proof (state)\nthis:\n  G \\<turnstile> Forall P\n\ngoal (4 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  G \\<turnstile> Forall P", "have \\<open>G \\<turnstile> P[t/0]\\<close>"], ["proof (prove)\nusing this:\n  G \\<turnstile> Forall P\n\ngoal (1 subgoal):\n 1. G \\<turnstile> P[t/0]", "using ForallE"], ["proof (prove)\nusing this:\n  G \\<turnstile> Forall P\n  ?G \\<turnstile> Forall ?a \\<Longrightarrow> ?G \\<turnstile> ?a[?t/0]\n\ngoal (1 subgoal):\n 1. G \\<turnstile> P[t/0]", "by blast"], ["proof (state)\nthis:\n  G \\<turnstile> P[t/0]\n\ngoal (4 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "{"], ["proof (state)\nthis:\n  G \\<turnstile> P[t/0]\n\ngoal (4 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "assume \\<open>P[t/0] # G \\<turnstile> FF\\<close>"], ["proof (state)\nthis:\n  P[t/0] # G \\<turnstile> FF\n\ngoal (4 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  P[t/0] # G \\<turnstile> FF", "have \\<open>G \\<turnstile> FF\\<close>"], ["proof (prove)\nusing this:\n  P[t/0] # G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. G \\<turnstile> FF", "using cut \\<open>G \\<turnstile> P[t/0]\\<close>"], ["proof (prove)\nusing this:\n  P[t/0] # G \\<turnstile> FF\n  \\<lbrakk>?G \\<turnstile> ?A; ?A # ?G \\<turnstile> ?B\\<rbrakk>\n  \\<Longrightarrow> ?G \\<turnstile> ?B\n  G \\<turnstile> P[t/0]\n\ngoal (1 subgoal):\n 1. G \\<turnstile> FF", "by blast"], ["proof (state)\nthis:\n  G \\<turnstile> FF\n\ngoal (4 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  G \\<turnstile> FF", "have False"], ["proof (prove)\nusing this:\n  G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. False", "using \\<open>\\<not> G \\<turnstile> FF\\<close>"], ["proof (prove)\nusing this:\n  G \\<turnstile> FF\n  \\<not> G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (4 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "}"], ["proof (state)\nthis:\n  P[t/0] # G \\<turnstile> FF \\<Longrightarrow> False\n\ngoal (4 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  P[t/0] # G \\<turnstile> FF \\<Longrightarrow> False", "have \\<open>\\<not> P[t/0] # G \\<turnstile> FF\\<close>"], ["proof (prove)\nusing this:\n  P[t/0] # G \\<turnstile> FF \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> P[t/0] # G \\<turnstile> FF", "by blast"], ["proof (state)\nthis:\n  \\<not> P[t/0] # G \\<turnstile> FF\n\ngoal (4 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "moreover"], ["proof (state)\nthis:\n  \\<not> P[t/0] # G \\<turnstile> FF\n\ngoal (4 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "have \\<open>S \\<union> {P[t/0]} = set (P[t/0] # G)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<union> {P[t/0]} = set (P[t/0] # G)", "using *"], ["proof (prove)\nusing this:\n  S = set G\n\ngoal (1 subgoal):\n 1. S \\<union> {P[t/0]} = set (P[t/0] # G)", "by simp"], ["proof (state)\nthis:\n  S \\<union> {P[t/0]} = set (P[t/0] # G)\n\ngoal (4 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> P[t/0] # G \\<turnstile> FF\n  S \\<union> {P[t/0]} = set (P[t/0] # G)", "show \\<open>S \\<union> {P[t/0]} \\<in> ?C\\<close>"], ["proof (prove)\nusing this:\n  \\<not> P[t/0] # G \\<turnstile> FF\n  S \\<union> {P[t/0]} = set (P[t/0] # G)\n\ngoal (1 subgoal):\n 1. S \\<union> {P[t/0]} \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "by blast"], ["proof (state)\nthis:\n  S \\<union> {P[t/0]} \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n\ngoal (3 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "}"], ["proof (state)\nthis:\n  \\<lbrakk>closedt 0 ?t2; Forall ?P2 \\<in> S\\<rbrakk>\n  \\<Longrightarrow> S \\<union> {?P2[?t2/0]}\n                    \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n\ngoal (3 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "{"], ["proof (state)\nthis:\n  \\<lbrakk>closedt 0 ?t2; Forall ?P2 \\<in> S\\<rbrakk>\n  \\<Longrightarrow> S \\<union> {?P2[?t2/0]}\n                    \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n\ngoal (3 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "fix P and t :: \\<open>'a term\\<close>"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "assume \\<open>closedt 0 t\\<close> and \\<open>Neg (Exists P) \\<in> S\\<close>"], ["proof (state)\nthis:\n  closedt 0 t\n  Neg (Exists P) \\<in> S\n\ngoal (3 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  closedt 0 t\n  Neg (Exists P) \\<in> S", "have \\<open>G \\<turnstile> Neg (Exists P)\\<close>"], ["proof (prove)\nusing this:\n  closedt 0 t\n  Neg (Exists P) \\<in> S\n\ngoal (1 subgoal):\n 1. G \\<turnstile> Neg (Exists P)", "using Assum *"], ["proof (prove)\nusing this:\n  closedt 0 t\n  Neg (Exists P) \\<in> S\n  ?a \\<in> set ?G \\<Longrightarrow> ?G \\<turnstile> ?a\n  S = set G\n\ngoal (1 subgoal):\n 1. G \\<turnstile> Neg (Exists P)", "by blast"], ["proof (state)\nthis:\n  G \\<turnstile> Neg (Exists P)\n\ngoal (3 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  G \\<turnstile> Neg (Exists P)", "have \\<open>P[t/0] \\<in> set (P[t/0] # G)\\<close>"], ["proof (prove)\nusing this:\n  G \\<turnstile> Neg (Exists P)\n\ngoal (1 subgoal):\n 1. P[t/0] \\<in> set (P[t/0] # G)", "by (simp add: Assum)"], ["proof (state)\nthis:\n  P[t/0] \\<in> set (P[t/0] # G)\n\ngoal (3 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  P[t/0] \\<in> set (P[t/0] # G)", "have \\<open>P[t/0] # G \\<turnstile> P[t/0]\\<close>"], ["proof (prove)\nusing this:\n  P[t/0] \\<in> set (P[t/0] # G)\n\ngoal (1 subgoal):\n 1. P[t/0] # G \\<turnstile> P[t/0]", "using Assum"], ["proof (prove)\nusing this:\n  P[t/0] \\<in> set (P[t/0] # G)\n  ?a \\<in> set ?G \\<Longrightarrow> ?G \\<turnstile> ?a\n\ngoal (1 subgoal):\n 1. P[t/0] # G \\<turnstile> P[t/0]", "by blast"], ["proof (state)\nthis:\n  P[t/0] # G \\<turnstile> P[t/0]\n\ngoal (3 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  P[t/0] # G \\<turnstile> P[t/0]", "have \\<open>P[t/0] # G \\<turnstile> Exists P\\<close>"], ["proof (prove)\nusing this:\n  P[t/0] # G \\<turnstile> P[t/0]\n\ngoal (1 subgoal):\n 1. P[t/0] # G \\<turnstile> Exists P", "using ExistsI"], ["proof (prove)\nusing this:\n  P[t/0] # G \\<turnstile> P[t/0]\n  ?G \\<turnstile> ?a[?t/0] \\<Longrightarrow> ?G \\<turnstile> Exists ?a\n\ngoal (1 subgoal):\n 1. P[t/0] # G \\<turnstile> Exists P", "by blast"], ["proof (state)\nthis:\n  P[t/0] # G \\<turnstile> Exists P\n\ngoal (3 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "moreover"], ["proof (state)\nthis:\n  P[t/0] # G \\<turnstile> Exists P\n\ngoal (3 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "have \\<open>P[t/0] # G \\<turnstile> Neg (Exists P)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. P[t/0] # G \\<turnstile> Neg (Exists P)", "using * \\<open>Neg (Exists P) \\<in> S\\<close>"], ["proof (prove)\nusing this:\n  S = set G\n  Neg (Exists P) \\<in> S\n\ngoal (1 subgoal):\n 1. P[t/0] # G \\<turnstile> Neg (Exists P)", "by (simp add: Assum)"], ["proof (state)\nthis:\n  P[t/0] # G \\<turnstile> Neg (Exists P)\n\ngoal (3 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "ultimately"], ["proof (chain)\npicking this:\n  P[t/0] # G \\<turnstile> Exists P\n  P[t/0] # G \\<turnstile> Neg (Exists P)", "have \\<open>P[t/0] # G \\<turnstile> FF\\<close>"], ["proof (prove)\nusing this:\n  P[t/0] # G \\<turnstile> Exists P\n  P[t/0] # G \\<turnstile> Neg (Exists P)\n\ngoal (1 subgoal):\n 1. P[t/0] # G \\<turnstile> FF", "using NegE"], ["proof (prove)\nusing this:\n  P[t/0] # G \\<turnstile> Exists P\n  P[t/0] # G \\<turnstile> Neg (Exists P)\n  \\<lbrakk>?G \\<turnstile> Neg ?a; ?G \\<turnstile> ?a\\<rbrakk>\n  \\<Longrightarrow> ?G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. P[t/0] # G \\<turnstile> FF", "by blast"], ["proof (state)\nthis:\n  P[t/0] # G \\<turnstile> FF\n\ngoal (3 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  P[t/0] # G \\<turnstile> FF", "have \\<open>G \\<turnstile> Neg (P[t/0])\\<close>"], ["proof (prove)\nusing this:\n  P[t/0] # G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. G \\<turnstile> Neg (P[t/0])", "using NegI"], ["proof (prove)\nusing this:\n  P[t/0] # G \\<turnstile> FF\n  ?a # ?G \\<turnstile> FF \\<Longrightarrow> ?G \\<turnstile> Neg ?a\n\ngoal (1 subgoal):\n 1. G \\<turnstile> Neg (P[t/0])", "by blast"], ["proof (state)\nthis:\n  G \\<turnstile> Neg (P[t/0])\n\ngoal (3 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "{"], ["proof (state)\nthis:\n  G \\<turnstile> Neg (P[t/0])\n\ngoal (3 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "assume \\<open>Neg (P[t/0]) # G \\<turnstile> FF\\<close>"], ["proof (state)\nthis:\n  Neg (P[t/0]) # G \\<turnstile> FF\n\ngoal (3 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  Neg (P[t/0]) # G \\<turnstile> FF", "have \\<open>G \\<turnstile> FF\\<close>"], ["proof (prove)\nusing this:\n  Neg (P[t/0]) # G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. G \\<turnstile> FF", "using cut \\<open>G \\<turnstile> Neg (P[t/0])\\<close>"], ["proof (prove)\nusing this:\n  Neg (P[t/0]) # G \\<turnstile> FF\n  \\<lbrakk>?G \\<turnstile> ?A; ?A # ?G \\<turnstile> ?B\\<rbrakk>\n  \\<Longrightarrow> ?G \\<turnstile> ?B\n  G \\<turnstile> Neg (P[t/0])\n\ngoal (1 subgoal):\n 1. G \\<turnstile> FF", "by blast"], ["proof (state)\nthis:\n  G \\<turnstile> FF\n\ngoal (3 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  G \\<turnstile> FF", "have False"], ["proof (prove)\nusing this:\n  G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. False", "using \\<open>\\<not> G \\<turnstile> FF\\<close>"], ["proof (prove)\nusing this:\n  G \\<turnstile> FF\n  \\<not> G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "}"], ["proof (state)\nthis:\n  Neg (P[t/0]) # G \\<turnstile> FF \\<Longrightarrow> False\n\ngoal (3 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  Neg (P[t/0]) # G \\<turnstile> FF \\<Longrightarrow> False", "have \\<open>\\<not> Neg (P[t/0]) # G \\<turnstile> FF\\<close>"], ["proof (prove)\nusing this:\n  Neg (P[t/0]) # G \\<turnstile> FF \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> Neg (P[t/0]) # G \\<turnstile> FF", "by blast"], ["proof (state)\nthis:\n  \\<not> Neg (P[t/0]) # G \\<turnstile> FF\n\ngoal (3 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "moreover"], ["proof (state)\nthis:\n  \\<not> Neg (P[t/0]) # G \\<turnstile> FF\n\ngoal (3 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "have \\<open>S \\<union> {Neg (P[t/0])} = set (Neg (P[t/0]) # G)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<union> {Neg (P[t/0])} = set (Neg (P[t/0]) # G)", "using *"], ["proof (prove)\nusing this:\n  S = set G\n\ngoal (1 subgoal):\n 1. S \\<union> {Neg (P[t/0])} = set (Neg (P[t/0]) # G)", "by simp"], ["proof (state)\nthis:\n  S \\<union> {Neg (P[t/0])} = set (Neg (P[t/0]) # G)\n\ngoal (3 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF}; closedt 0 t;\n        Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> Neg (P[t/0]) # G \\<turnstile> FF\n  S \\<union> {Neg (P[t/0])} = set (Neg (P[t/0]) # G)", "show \\<open>S \\<union> {Neg (P[t/0])} \\<in> ?C\\<close>"], ["proof (prove)\nusing this:\n  \\<not> Neg (P[t/0]) # G \\<turnstile> FF\n  S \\<union> {Neg (P[t/0])} = set (Neg (P[t/0]) # G)\n\ngoal (1 subgoal):\n 1. S \\<union> {Neg (P[t/0])} \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "by blast"], ["proof (state)\nthis:\n  S \\<union> {Neg (P[t/0])} \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n\ngoal (2 subgoals):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "}"], ["proof (state)\nthis:\n  \\<lbrakk>closedt 0 ?t2; Neg (Exists ?P2) \\<in> S\\<rbrakk>\n  \\<Longrightarrow> S \\<union> {Neg (?P2[?t2/0])}\n                    \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n\ngoal (2 subgoals):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "{"], ["proof (state)\nthis:\n  \\<lbrakk>closedt 0 ?t2; Neg (Exists ?P2) \\<in> S\\<rbrakk>\n  \\<Longrightarrow> S \\<union> {Neg (?P2[?t2/0])}\n                    \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n\ngoal (2 subgoals):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "fix P"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "assume \\<open>Exists P \\<in> S\\<close>"], ["proof (state)\nthis:\n  Exists P \\<in> S\n\ngoal (2 subgoals):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  Exists P \\<in> S", "have \\<open>G \\<turnstile> Exists P\\<close>"], ["proof (prove)\nusing this:\n  Exists P \\<in> S\n\ngoal (1 subgoal):\n 1. G \\<turnstile> Exists P", "using * Assum"], ["proof (prove)\nusing this:\n  Exists P \\<in> S\n  S = set G\n  ?a \\<in> set ?G \\<Longrightarrow> ?G \\<turnstile> ?a\n\ngoal (1 subgoal):\n 1. G \\<turnstile> Exists P", "by blast"], ["proof (state)\nthis:\n  G \\<turnstile> Exists P\n\ngoal (2 subgoals):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "have \\<open>finite ((\\<Union>p \\<in> set G. params p) \\<union> params P)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (\\<Union> (params ` set G) \\<union> params P)", "by simp"], ["proof (state)\nthis:\n  finite (\\<Union> (params ` set G) \\<union> params P)\n\ngoal (2 subgoals):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  finite (\\<Union> (params ` set G) \\<union> params P)", "have \\<open>infinite (- ((\\<Union>p \\<in> set G. params p) \\<union> params P))\\<close>"], ["proof (prove)\nusing this:\n  finite (\\<Union> (params ` set G) \\<union> params P)\n\ngoal (1 subgoal):\n 1. infinite (- (\\<Union> (params ` set G) \\<union> params P))", "using inf_param Diff_infinite_finite finite_compl"], ["proof (prove)\nusing this:\n  finite (\\<Union> (params ` set G) \\<union> params P)\n  infinite UNIV\n  \\<lbrakk>finite ?T; infinite ?S\\<rbrakk>\n  \\<Longrightarrow> infinite (?S - ?T)\n  finite ?A \\<Longrightarrow> finite (- ?A) = finite UNIV\n\ngoal (1 subgoal):\n 1. infinite (- (\\<Union> (params ` set G) \\<union> params P))", "by blast"], ["proof (state)\nthis:\n  infinite (- (\\<Union> (params ` set G) \\<union> params P))\n\ngoal (2 subgoals):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  infinite (- (\\<Union> (params ` set G) \\<union> params P))", "have \\<open>infinite (- ((\\<Union>p \\<in> set G. params p) \\<union> params P))\\<close>"], ["proof (prove)\nusing this:\n  infinite (- (\\<Union> (params ` set G) \\<union> params P))\n\ngoal (1 subgoal):\n 1. infinite (- (\\<Union> (params ` set G) \\<union> params P))", "by (simp add: Compl_eq_Diff_UNIV)"], ["proof (state)\nthis:\n  infinite (- (\\<Union> (params ` set G) \\<union> params P))\n\ngoal (2 subgoals):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  infinite (- (\\<Union> (params ` set G) \\<union> params P))", "obtain x where **: \\<open>x \\<in> - ((\\<Union>p \\<in> set G. params p) \\<union> params P)\\<close>"], ["proof (prove)\nusing this:\n  infinite (- (\\<Union> (params ` set G) \\<union> params P))\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> - (\\<Union> (params ` set G) \\<union>\n                   params P) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using infinite_imp_nonempty"], ["proof (prove)\nusing this:\n  infinite (- (\\<Union> (params ` set G) \\<union> params P))\n  infinite ?S \\<Longrightarrow> ?S \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> - (\\<Union> (params ` set G) \\<union>\n                   params P) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x \\<in> - (\\<Union> (params ` set G) \\<union> params P)\n\ngoal (2 subgoals):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "{"], ["proof (state)\nthis:\n  x \\<in> - (\\<Union> (params ` set G) \\<union> params P)\n\ngoal (2 subgoals):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "assume \\<open>P[App x []/0] # G \\<turnstile> FF\\<close>"], ["proof (state)\nthis:\n  P[App x []/0] # G \\<turnstile> FF\n\ngoal (2 subgoals):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "moreover"], ["proof (state)\nthis:\n  P[App x []/0] # G \\<turnstile> FF\n\ngoal (2 subgoals):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "have \\<open>list_all (\\<lambda>p. x \\<notin> params p) G\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>p. x \\<notin> params p) G", "using **"], ["proof (prove)\nusing this:\n  x \\<in> - (\\<Union> (params ` set G) \\<union> params P)\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>p. x \\<notin> params p) G", "by (simp add: list_all_iff)"], ["proof (state)\nthis:\n  list_all (\\<lambda>p. x \\<notin> params p) G\n\ngoal (2 subgoals):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "moreover"], ["proof (state)\nthis:\n  list_all (\\<lambda>p. x \\<notin> params p) G\n\ngoal (2 subgoals):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "have \\<open>x \\<notin> params P\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> params P", "using **"], ["proof (prove)\nusing this:\n  x \\<in> - (\\<Union> (params ` set G) \\<union> params P)\n\ngoal (1 subgoal):\n 1. x \\<notin> params P", "by simp"], ["proof (state)\nthis:\n  x \\<notin> params P\n\ngoal (2 subgoals):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "moreover"], ["proof (state)\nthis:\n  x \\<notin> params P\n\ngoal (2 subgoals):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "have \\<open>x \\<notin> params FF\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> params FF", "by simp"], ["proof (state)\nthis:\n  x \\<notin> params FF\n\ngoal (2 subgoals):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "ultimately"], ["proof (chain)\npicking this:\n  P[App x []/0] # G \\<turnstile> FF\n  list_all (\\<lambda>p. x \\<notin> params p) G\n  x \\<notin> params P\n  x \\<notin> params FF", "have \\<open>G \\<turnstile> FF\\<close>"], ["proof (prove)\nusing this:\n  P[App x []/0] # G \\<turnstile> FF\n  list_all (\\<lambda>p. x \\<notin> params p) G\n  x \\<notin> params P\n  x \\<notin> params FF\n\ngoal (1 subgoal):\n 1. G \\<turnstile> FF", "using ExistsE \\<open>G \\<turnstile> Exists P\\<close>"], ["proof (prove)\nusing this:\n  P[App x []/0] # G \\<turnstile> FF\n  list_all (\\<lambda>p. x \\<notin> params p) G\n  x \\<notin> params P\n  x \\<notin> params FF\n  \\<lbrakk>?G \\<turnstile> Exists ?a; ?a[App ?n []/0] # ?G \\<turnstile> ?b;\n   list_all (\\<lambda>p. ?n \\<notin> params p) ?G; ?n \\<notin> params ?a;\n   ?n \\<notin> params ?b\\<rbrakk>\n  \\<Longrightarrow> ?G \\<turnstile> ?b\n  G \\<turnstile> Exists P\n\ngoal (1 subgoal):\n 1. G \\<turnstile> FF", "by fast"], ["proof (state)\nthis:\n  G \\<turnstile> FF\n\ngoal (2 subgoals):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  G \\<turnstile> FF", "have False"], ["proof (prove)\nusing this:\n  G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. False", "using \\<open>\\<not> G \\<turnstile> FF\\<close>"], ["proof (prove)\nusing this:\n  G \\<turnstile> FF\n  \\<not> G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "}"], ["proof (state)\nthis:\n  P[App x []/0] # G \\<turnstile> FF \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  P[App x []/0] # G \\<turnstile> FF \\<Longrightarrow> False", "have \\<open>\\<not> P[App x []/0] # G \\<turnstile> FF\\<close>"], ["proof (prove)\nusing this:\n  P[App x []/0] # G \\<turnstile> FF \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> P[App x []/0] # G \\<turnstile> FF", "by blast"], ["proof (state)\nthis:\n  \\<not> P[App x []/0] # G \\<turnstile> FF\n\ngoal (2 subgoals):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "moreover"], ["proof (state)\nthis:\n  \\<not> P[App x []/0] # G \\<turnstile> FF\n\ngoal (2 subgoals):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "have \\<open>S \\<union> {P[App x []/0]} = set (P[App x []/0] # G)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<union> {P[App x []/0]} = set (P[App x []/0] # G)", "using *"], ["proof (prove)\nusing this:\n  S = set G\n\ngoal (1 subgoal):\n 1. S \\<union> {P[App x []/0]} = set (P[App x []/0] # G)", "by simp"], ["proof (state)\nthis:\n  S \\<union> {P[App x []/0]} = set (P[App x []/0] # G)\n\ngoal (2 subgoals):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> P[App x []/0] # G \\<turnstile> FF\n  S \\<union> {P[App x []/0]} = set (P[App x []/0] # G)", "show \\<open>\\<exists>x. S \\<union> {P[App x []/0]} \\<in> ?C\\<close>"], ["proof (prove)\nusing this:\n  \\<not> P[App x []/0] # G \\<turnstile> FF\n  S \\<union> {P[App x []/0]} = set (P[App x []/0] # G)\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       S \\<union> {P[App x []/0]} \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "by blast"], ["proof (state)\nthis:\n  \\<exists>x.\n     S \\<union> {P[App x []/0]} \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "}"], ["proof (state)\nthis:\n  Exists ?P2 \\<in> S \\<Longrightarrow>\n  \\<exists>x.\n     S \\<union> {?P2[App x []/0]} \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "{"], ["proof (state)\nthis:\n  Exists ?P2 \\<in> S \\<Longrightarrow>\n  \\<exists>x.\n     S \\<union> {?P2[App x []/0]} \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "fix P"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "assume \\<open>Neg (Forall P) \\<in> S\\<close>"], ["proof (state)\nthis:\n  Neg (Forall P) \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  Neg (Forall P) \\<in> S", "have \\<open>G \\<turnstile> Neg (Forall P)\\<close>"], ["proof (prove)\nusing this:\n  Neg (Forall P) \\<in> S\n\ngoal (1 subgoal):\n 1. G \\<turnstile> Neg (Forall P)", "using * Assum"], ["proof (prove)\nusing this:\n  Neg (Forall P) \\<in> S\n  S = set G\n  ?a \\<in> set ?G \\<Longrightarrow> ?G \\<turnstile> ?a\n\ngoal (1 subgoal):\n 1. G \\<turnstile> Neg (Forall P)", "by blast"], ["proof (state)\nthis:\n  G \\<turnstile> Neg (Forall P)\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "have \\<open>finite ((\\<Union>p \\<in> set G. params p) \\<union> params P)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (\\<Union> (params ` set G) \\<union> params P)", "by simp"], ["proof (state)\nthis:\n  finite (\\<Union> (params ` set G) \\<union> params P)\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  finite (\\<Union> (params ` set G) \\<union> params P)", "have \\<open>infinite (- ((\\<Union>p \\<in> set G. params p) \\<union> params P))\\<close>"], ["proof (prove)\nusing this:\n  finite (\\<Union> (params ` set G) \\<union> params P)\n\ngoal (1 subgoal):\n 1. infinite (- (\\<Union> (params ` set G) \\<union> params P))", "using inf_param Diff_infinite_finite finite_compl"], ["proof (prove)\nusing this:\n  finite (\\<Union> (params ` set G) \\<union> params P)\n  infinite UNIV\n  \\<lbrakk>finite ?T; infinite ?S\\<rbrakk>\n  \\<Longrightarrow> infinite (?S - ?T)\n  finite ?A \\<Longrightarrow> finite (- ?A) = finite UNIV\n\ngoal (1 subgoal):\n 1. infinite (- (\\<Union> (params ` set G) \\<union> params P))", "by blast"], ["proof (state)\nthis:\n  infinite (- (\\<Union> (params ` set G) \\<union> params P))\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  infinite (- (\\<Union> (params ` set G) \\<union> params P))", "have \\<open>infinite (- ((\\<Union>p \\<in> set G. params p) \\<union> params P))\\<close>"], ["proof (prove)\nusing this:\n  infinite (- (\\<Union> (params ` set G) \\<union> params P))\n\ngoal (1 subgoal):\n 1. infinite (- (\\<Union> (params ` set G) \\<union> params P))", "by (simp add: Compl_eq_Diff_UNIV)"], ["proof (state)\nthis:\n  infinite (- (\\<Union> (params ` set G) \\<union> params P))\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  infinite (- (\\<Union> (params ` set G) \\<union> params P))", "obtain x where **: \\<open>x \\<in> - ((\\<Union>p \\<in> set G. params p) \\<union> params P)\\<close>"], ["proof (prove)\nusing this:\n  infinite (- (\\<Union> (params ` set G) \\<union> params P))\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> - (\\<Union> (params ` set G) \\<union>\n                   params P) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using infinite_imp_nonempty"], ["proof (prove)\nusing this:\n  infinite (- (\\<Union> (params ` set G) \\<union> params P))\n  infinite ?S \\<Longrightarrow> ?S \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> - (\\<Union> (params ` set G) \\<union>\n                   params P) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x \\<in> - (\\<Union> (params ` set G) \\<union> params P)\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "let ?x = \\<open>Neg (Exists (Neg P))\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "have \\<open>Neg (P[App x []/0]) # ?x # G \\<turnstile> Neg P[App x []/0]\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Neg (P[App x []/0]) #\n    Neg (Exists (Neg P)) # G \\<turnstile> Neg P[App x []/0]", "by (simp add: Assum)"], ["proof (state)\nthis:\n  Neg (P[App x []/0]) #\n  Neg (Exists (Neg P)) # G \\<turnstile> Neg P[App x []/0]\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  Neg (P[App x []/0]) #\n  Neg (Exists (Neg P)) # G \\<turnstile> Neg P[App x []/0]", "have \\<open>Neg (P[App x []/0]) # ?x # G \\<turnstile> Exists (Neg P)\\<close>"], ["proof (prove)\nusing this:\n  Neg (P[App x []/0]) #\n  Neg (Exists (Neg P)) # G \\<turnstile> Neg P[App x []/0]\n\ngoal (1 subgoal):\n 1. Neg (P[App x []/0]) #\n    Neg (Exists (Neg P)) # G \\<turnstile> Exists (Neg P)", "using ExistsI"], ["proof (prove)\nusing this:\n  Neg (P[App x []/0]) #\n  Neg (Exists (Neg P)) # G \\<turnstile> Neg P[App x []/0]\n  ?G \\<turnstile> ?a[?t/0] \\<Longrightarrow> ?G \\<turnstile> Exists ?a\n\ngoal (1 subgoal):\n 1. Neg (P[App x []/0]) #\n    Neg (Exists (Neg P)) # G \\<turnstile> Exists (Neg P)", "by blast"], ["proof (state)\nthis:\n  Neg (P[App x []/0]) # Neg (Exists (Neg P)) # G \\<turnstile> Exists (Neg P)\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "moreover"], ["proof (state)\nthis:\n  Neg (P[App x []/0]) # Neg (Exists (Neg P)) # G \\<turnstile> Exists (Neg P)\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "have \\<open>Neg (P[App x []/0]) # ?x # G \\<turnstile> ?x\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Neg (P[App x []/0]) #\n    Neg (Exists (Neg P)) # G \\<turnstile> Neg (Exists (Neg P))", "by (simp add: Assum)"], ["proof (state)\nthis:\n  Neg (P[App x []/0]) #\n  Neg (Exists (Neg P)) # G \\<turnstile> Neg (Exists (Neg P))\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "ultimately"], ["proof (chain)\npicking this:\n  Neg (P[App x []/0]) # Neg (Exists (Neg P)) # G \\<turnstile> Exists (Neg P)\n  Neg (P[App x []/0]) #\n  Neg (Exists (Neg P)) # G \\<turnstile> Neg (Exists (Neg P))", "have \\<open>Neg (P[App x []/0]) # ?x # G \\<turnstile> FF\\<close>"], ["proof (prove)\nusing this:\n  Neg (P[App x []/0]) # Neg (Exists (Neg P)) # G \\<turnstile> Exists (Neg P)\n  Neg (P[App x []/0]) #\n  Neg (Exists (Neg P)) # G \\<turnstile> Neg (Exists (Neg P))\n\ngoal (1 subgoal):\n 1. Neg (P[App x []/0]) # Neg (Exists (Neg P)) # G \\<turnstile> FF", "using NegE"], ["proof (prove)\nusing this:\n  Neg (P[App x []/0]) # Neg (Exists (Neg P)) # G \\<turnstile> Exists (Neg P)\n  Neg (P[App x []/0]) #\n  Neg (Exists (Neg P)) # G \\<turnstile> Neg (Exists (Neg P))\n  \\<lbrakk>?G \\<turnstile> Neg ?a; ?G \\<turnstile> ?a\\<rbrakk>\n  \\<Longrightarrow> ?G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. Neg (P[App x []/0]) # Neg (Exists (Neg P)) # G \\<turnstile> FF", "by blast"], ["proof (state)\nthis:\n  Neg (P[App x []/0]) # Neg (Exists (Neg P)) # G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  Neg (P[App x []/0]) # Neg (Exists (Neg P)) # G \\<turnstile> FF", "have \\<open>?x # G \\<turnstile> P[App x []/0]\\<close>"], ["proof (prove)\nusing this:\n  Neg (P[App x []/0]) # Neg (Exists (Neg P)) # G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. Neg (Exists (Neg P)) # G \\<turnstile> P[App x []/0]", "using Class"], ["proof (prove)\nusing this:\n  Neg (P[App x []/0]) # Neg (Exists (Neg P)) # G \\<turnstile> FF\n  Neg ?a # ?G \\<turnstile> FF \\<Longrightarrow> ?G \\<turnstile> ?a\n\ngoal (1 subgoal):\n 1. Neg (Exists (Neg P)) # G \\<turnstile> P[App x []/0]", "by blast"], ["proof (state)\nthis:\n  Neg (Exists (Neg P)) # G \\<turnstile> P[App x []/0]\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "moreover"], ["proof (state)\nthis:\n  Neg (Exists (Neg P)) # G \\<turnstile> P[App x []/0]\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "have \\<open>list_all (\\<lambda>p. x \\<notin> params p) (?x # G)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>p. x \\<notin> params p) (Neg (Exists (Neg P)) # G)", "using **"], ["proof (prove)\nusing this:\n  x \\<in> - (\\<Union> (params ` set G) \\<union> params P)\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>p. x \\<notin> params p) (Neg (Exists (Neg P)) # G)", "by (simp add: list_all_iff)"], ["proof (state)\nthis:\n  list_all (\\<lambda>p. x \\<notin> params p) (Neg (Exists (Neg P)) # G)\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "moreover"], ["proof (state)\nthis:\n  list_all (\\<lambda>p. x \\<notin> params p) (Neg (Exists (Neg P)) # G)\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "have \\<open>x \\<notin> params P\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> params P", "using **"], ["proof (prove)\nusing this:\n  x \\<in> - (\\<Union> (params ` set G) \\<union> params P)\n\ngoal (1 subgoal):\n 1. x \\<notin> params P", "by simp"], ["proof (state)\nthis:\n  x \\<notin> params P\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "ultimately"], ["proof (chain)\npicking this:\n  Neg (Exists (Neg P)) # G \\<turnstile> P[App x []/0]\n  list_all (\\<lambda>p. x \\<notin> params p) (Neg (Exists (Neg P)) # G)\n  x \\<notin> params P", "have \\<open>?x # G \\<turnstile> Forall P\\<close>"], ["proof (prove)\nusing this:\n  Neg (Exists (Neg P)) # G \\<turnstile> P[App x []/0]\n  list_all (\\<lambda>p. x \\<notin> params p) (Neg (Exists (Neg P)) # G)\n  x \\<notin> params P\n\ngoal (1 subgoal):\n 1. Neg (Exists (Neg P)) # G \\<turnstile> Forall P", "using ForallI"], ["proof (prove)\nusing this:\n  Neg (Exists (Neg P)) # G \\<turnstile> P[App x []/0]\n  list_all (\\<lambda>p. x \\<notin> params p) (Neg (Exists (Neg P)) # G)\n  x \\<notin> params P\n  \\<lbrakk>?G \\<turnstile> ?a[App ?n []/0];\n   list_all (\\<lambda>p. ?n \\<notin> params p) ?G;\n   ?n \\<notin> params ?a\\<rbrakk>\n  \\<Longrightarrow> ?G \\<turnstile> Forall ?a\n\ngoal (1 subgoal):\n 1. Neg (Exists (Neg P)) # G \\<turnstile> Forall P", "by fast"], ["proof (state)\nthis:\n  Neg (Exists (Neg P)) # G \\<turnstile> Forall P\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "moreover"], ["proof (state)\nthis:\n  Neg (Exists (Neg P)) # G \\<turnstile> Forall P\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "have \\<open>?x # G \\<turnstile> Neg (Forall P)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Neg (Exists (Neg P)) # G \\<turnstile> Neg (Forall P)", "using * \\<open>Neg (Forall P) \\<in> S\\<close>"], ["proof (prove)\nusing this:\n  S = set G\n  Neg (Forall P) \\<in> S\n\ngoal (1 subgoal):\n 1. Neg (Exists (Neg P)) # G \\<turnstile> Neg (Forall P)", "by (simp add: Assum)"], ["proof (state)\nthis:\n  Neg (Exists (Neg P)) # G \\<turnstile> Neg (Forall P)\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "ultimately"], ["proof (chain)\npicking this:\n  Neg (Exists (Neg P)) # G \\<turnstile> Forall P\n  Neg (Exists (Neg P)) # G \\<turnstile> Neg (Forall P)", "have \\<open>?x # G \\<turnstile> FF\\<close>"], ["proof (prove)\nusing this:\n  Neg (Exists (Neg P)) # G \\<turnstile> Forall P\n  Neg (Exists (Neg P)) # G \\<turnstile> Neg (Forall P)\n\ngoal (1 subgoal):\n 1. Neg (Exists (Neg P)) # G \\<turnstile> FF", "using NegE"], ["proof (prove)\nusing this:\n  Neg (Exists (Neg P)) # G \\<turnstile> Forall P\n  Neg (Exists (Neg P)) # G \\<turnstile> Neg (Forall P)\n  \\<lbrakk>?G \\<turnstile> Neg ?a; ?G \\<turnstile> ?a\\<rbrakk>\n  \\<Longrightarrow> ?G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. Neg (Exists (Neg P)) # G \\<turnstile> FF", "by blast"], ["proof (state)\nthis:\n  Neg (Exists (Neg P)) # G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  Neg (Exists (Neg P)) # G \\<turnstile> FF", "have \\<open>G \\<turnstile> Exists (Neg P)\\<close>"], ["proof (prove)\nusing this:\n  Neg (Exists (Neg P)) # G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. G \\<turnstile> Exists (Neg P)", "using Class"], ["proof (prove)\nusing this:\n  Neg (Exists (Neg P)) # G \\<turnstile> FF\n  Neg ?a # ?G \\<turnstile> FF \\<Longrightarrow> ?G \\<turnstile> ?a\n\ngoal (1 subgoal):\n 1. G \\<turnstile> Exists (Neg P)", "by blast"], ["proof (state)\nthis:\n  G \\<turnstile> Exists (Neg P)\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "{"], ["proof (state)\nthis:\n  G \\<turnstile> Exists (Neg P)\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "assume \\<open>Neg (P[App x []/0]) # G \\<turnstile> FF\\<close>"], ["proof (state)\nthis:\n  Neg (P[App x []/0]) # G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "moreover"], ["proof (state)\nthis:\n  Neg (P[App x []/0]) # G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "have \\<open>list_all (\\<lambda>p. x \\<notin> params p) G\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>p. x \\<notin> params p) G", "using **"], ["proof (prove)\nusing this:\n  x \\<in> - (\\<Union> (params ` set G) \\<union> params P)\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>p. x \\<notin> params p) G", "by (simp add: list_all_iff)"], ["proof (state)\nthis:\n  list_all (\\<lambda>p. x \\<notin> params p) G\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "moreover"], ["proof (state)\nthis:\n  list_all (\\<lambda>p. x \\<notin> params p) G\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "have \\<open>x \\<notin> params P\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> params P", "using **"], ["proof (prove)\nusing this:\n  x \\<in> - (\\<Union> (params ` set G) \\<union> params P)\n\ngoal (1 subgoal):\n 1. x \\<notin> params P", "by simp"], ["proof (state)\nthis:\n  x \\<notin> params P\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "moreover"], ["proof (state)\nthis:\n  x \\<notin> params P\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "have \\<open>x \\<notin> params FF\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> params FF", "by simp"], ["proof (state)\nthis:\n  x \\<notin> params FF\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "ultimately"], ["proof (chain)\npicking this:\n  Neg (P[App x []/0]) # G \\<turnstile> FF\n  list_all (\\<lambda>p. x \\<notin> params p) G\n  x \\<notin> params P\n  x \\<notin> params FF", "have \\<open>G \\<turnstile> FF\\<close>"], ["proof (prove)\nusing this:\n  Neg (P[App x []/0]) # G \\<turnstile> FF\n  list_all (\\<lambda>p. x \\<notin> params p) G\n  x \\<notin> params P\n  x \\<notin> params FF\n\ngoal (1 subgoal):\n 1. G \\<turnstile> FF", "using ExistsE \\<open>G \\<turnstile> Exists (Neg P)\\<close>"], ["proof (prove)\nusing this:\n  Neg (P[App x []/0]) # G \\<turnstile> FF\n  list_all (\\<lambda>p. x \\<notin> params p) G\n  x \\<notin> params P\n  x \\<notin> params FF\n  \\<lbrakk>?G \\<turnstile> Exists ?a; ?a[App ?n []/0] # ?G \\<turnstile> ?b;\n   list_all (\\<lambda>p. ?n \\<notin> params p) ?G; ?n \\<notin> params ?a;\n   ?n \\<notin> params ?b\\<rbrakk>\n  \\<Longrightarrow> ?G \\<turnstile> ?b\n  G \\<turnstile> Exists (Neg P)\n\ngoal (1 subgoal):\n 1. G \\<turnstile> FF", "by fastforce"], ["proof (state)\nthis:\n  G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  G \\<turnstile> FF", "have False"], ["proof (prove)\nusing this:\n  G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. False", "using \\<open>\\<not> G \\<turnstile> FF\\<close>"], ["proof (prove)\nusing this:\n  G \\<turnstile> FF\n  \\<not> G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "}"], ["proof (state)\nthis:\n  Neg (P[App x []/0]) # G \\<turnstile> FF \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "then"], ["proof (chain)\npicking this:\n  Neg (P[App x []/0]) # G \\<turnstile> FF \\<Longrightarrow> False", "have \\<open>\\<not> Neg (P[App x []/0]) # G \\<turnstile> FF\\<close>"], ["proof (prove)\nusing this:\n  Neg (P[App x []/0]) # G \\<turnstile> FF \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> Neg (P[App x []/0]) # G \\<turnstile> FF", "by blast"], ["proof (state)\nthis:\n  \\<not> Neg (P[App x []/0]) # G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "moreover"], ["proof (state)\nthis:\n  \\<not> Neg (P[App x []/0]) # G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "have \\<open>S \\<union> {Neg (P[App x []/0])} = set (Neg (P[App x []/0]) # G)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<union> {Neg (P[App x []/0])} = set (Neg (P[App x []/0]) # G)", "using *"], ["proof (prove)\nusing this:\n  S = set G\n\ngoal (1 subgoal):\n 1. S \\<union> {Neg (P[App x []/0])} = set (Neg (P[App x []/0]) # G)", "by simp"], ["proof (state)\nthis:\n  S \\<union> {Neg (P[App x []/0])} = set (Neg (P[App x []/0]) # G)\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {set G |G. \\<not> G \\<turnstile> FF};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> Neg (P[App x []/0]) # G \\<turnstile> FF\n  S \\<union> {Neg (P[App x []/0])} = set (Neg (P[App x []/0]) # G)", "show \\<open>\\<exists>x. S \\<union> {Neg (P[App x []/0])} \\<in> ?C\\<close>"], ["proof (prove)\nusing this:\n  \\<not> Neg (P[App x []/0]) # G \\<turnstile> FF\n  S \\<union> {Neg (P[App x []/0])} = set (Neg (P[App x []/0]) # G)\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       S \\<union> {Neg (P[App x []/0])}\n       \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "by blast"], ["proof (state)\nthis:\n  \\<exists>x.\n     S \\<union> {Neg (P[App x []/0])}\n     \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  Neg (Forall ?P2) \\<in> S \\<Longrightarrow>\n  \\<exists>x.\n     S \\<union> {Neg (?P2[App x []/0])}\n     \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nHence, by contradiction, we have completeness of natural deduction:\n\\<close>"], ["", "theorem natded_complete:\n  assumes \\<open>closed 0 p\\<close>\n    and \\<open>list_all (closed 0) ps\\<close>\n    and mod: \\<open>\\<forall>e f g. e,(f :: nat \\<Rightarrow> nat hterm list \\<Rightarrow> nat hterm),\n              (g :: nat \\<Rightarrow> nat hterm list \\<Rightarrow> bool),ps \\<Turnstile> p\\<close>\n  shows \\<open>ps \\<turnstile> p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. ps \\<turnstile> p", "proof (rule Class, rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Neg p # ps \\<turnstile> FF \\<Longrightarrow> False", "fix e"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Neg p # ps \\<turnstile> FF \\<Longrightarrow> False", "assume \\<open>\\<not> Neg p # ps \\<turnstile> FF\\<close>"], ["proof (state)\nthis:\n  \\<not> Neg p # ps \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. \\<not> Neg p # ps \\<turnstile> FF \\<Longrightarrow> False", "let ?S = \\<open>set (Neg p # ps)\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Neg p # ps \\<turnstile> FF \\<Longrightarrow> False", "let ?C = \\<open>{set (G :: (nat, nat) form list) | G. \\<not> G \\<turnstile> FF}\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Neg p # ps \\<turnstile> FF \\<Longrightarrow> False", "let ?f = HApp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Neg p # ps \\<turnstile> FF \\<Longrightarrow> False", "let ?g = \\<open>(\\<lambda>a ts. Pred a (terms_of_hterms ts) \\<in> Extend ?S\n              (mk_finite_char (mk_alt_consistency (close ?C))) from_nat)\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Neg p # ps \\<turnstile> FF \\<Longrightarrow> False", "from \\<open>list_all (closed 0) ps\\<close>"], ["proof (chain)\npicking this:\n  list_all (closed 0) ps", "have \\<open>\\<forall>p \\<in> set ps. closed 0 p\\<close>"], ["proof (prove)\nusing this:\n  list_all (closed 0) ps\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set ps. closed 0 p", "by (simp add: list_all_iff)"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set ps. closed 0 p\n\ngoal (1 subgoal):\n 1. \\<not> Neg p # ps \\<turnstile> FF \\<Longrightarrow> False", "{"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set ps. closed 0 p\n\ngoal (1 subgoal):\n 1. \\<not> Neg p # ps \\<turnstile> FF \\<Longrightarrow> False", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Neg p # ps \\<turnstile> FF \\<Longrightarrow> False", "assume \\<open>x \\<in> ?S\\<close>"], ["proof (state)\nthis:\n  x \\<in> set (Neg p # ps)\n\ngoal (1 subgoal):\n 1. \\<not> Neg p # ps \\<turnstile> FF \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  x \\<in> set (Neg p # ps)\n\ngoal (1 subgoal):\n 1. \\<not> Neg p # ps \\<turnstile> FF \\<Longrightarrow> False", "have \\<open>consistency ?C\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. consistency {set G |G. \\<not> G \\<turnstile> FF}", "using deriv_consistency"], ["proof (prove)\nusing this:\n  infinite UNIV \\<Longrightarrow>\n  consistency {set G |G. \\<not> G \\<turnstile> FF}\n\ngoal (1 subgoal):\n 1. consistency {set G |G. \\<not> G \\<turnstile> FF}", "by blast"], ["proof (state)\nthis:\n  consistency {set G |G. \\<not> G \\<turnstile> FF}\n\ngoal (1 subgoal):\n 1. \\<not> Neg p # ps \\<turnstile> FF \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  consistency {set G |G. \\<not> G \\<turnstile> FF}\n\ngoal (1 subgoal):\n 1. \\<not> Neg p # ps \\<turnstile> FF \\<Longrightarrow> False", "have \\<open>?S \\<in> ?C\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (Neg p # ps) \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "using \\<open>\\<not> Neg p # ps \\<turnstile> FF\\<close>"], ["proof (prove)\nusing this:\n  \\<not> Neg p # ps \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. set (Neg p # ps) \\<in> {set G |G. \\<not> G \\<turnstile> FF}", "by blast"], ["proof (state)\nthis:\n  set (Neg p # ps) \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n\ngoal (1 subgoal):\n 1. \\<not> Neg p # ps \\<turnstile> FF \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  set (Neg p # ps) \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n\ngoal (1 subgoal):\n 1. \\<not> Neg p # ps \\<turnstile> FF \\<Longrightarrow> False", "have \\<open>infinite (- (\\<Union>p \\<in> ?S. params p))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite (- \\<Union> (params ` set (Neg p # ps)))", "by (simp add: Compl_eq_Diff_UNIV)"], ["proof (state)\nthis:\n  infinite (- \\<Union> (params ` set (Neg p # ps)))\n\ngoal (1 subgoal):\n 1. \\<not> Neg p # ps \\<turnstile> FF \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  infinite (- \\<Union> (params ` set (Neg p # ps)))\n\ngoal (1 subgoal):\n 1. \\<not> Neg p # ps \\<turnstile> FF \\<Longrightarrow> False", "note \\<open>closed 0 p\\<close> \\<open>\\<forall>p \\<in> set ps. closed 0 p\\<close> \\<open>x \\<in> ?S\\<close>"], ["proof (state)\nthis:\n  closed 0 p\n  \\<forall>p\\<in>set ps. closed 0 p\n  x \\<in> set (Neg p # ps)\n\ngoal (1 subgoal):\n 1. \\<not> Neg p # ps \\<turnstile> FF \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  closed 0 p\n  \\<forall>p\\<in>set ps. closed 0 p\n  x \\<in> set (Neg p # ps)", "have \\<open>closed 0 x\\<close>"], ["proof (prove)\nusing this:\n  closed 0 p\n  \\<forall>p\\<in>set ps. closed 0 p\n  x \\<in> set (Neg p # ps)\n\ngoal (1 subgoal):\n 1. closed 0 x", "by auto"], ["proof (state)\nthis:\n  closed 0 x\n\ngoal (1 subgoal):\n 1. \\<not> Neg p # ps \\<turnstile> FF \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> set (Neg p # ps)\n  consistency {set G |G. \\<not> G \\<turnstile> FF}\n  set (Neg p # ps) \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n  infinite (- \\<Union> (params ` set (Neg p # ps)))\n  closed 0 x", "have \\<open>eval e ?f ?g x\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> set (Neg p # ps)\n  consistency {set G |G. \\<not> G \\<turnstile> FF}\n  set (Neg p # ps) \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n  infinite (- \\<Union> (params ` set (Neg p # ps)))\n  closed 0 x\n\ngoal (1 subgoal):\n 1. eval e HApp\n     (\\<lambda>a ts.\n         Pred a (terms_of_hterms ts)\n         \\<in> Extend (set (Neg p # ps))\n                (mk_finite_char\n                  (mk_alt_consistency\n                    (close {set G |G. \\<not> G \\<turnstile> FF})))\n                from_nat)\n     x", "using model_existence"], ["proof (prove)\nusing this:\n  x \\<in> set (Neg p # ps)\n  consistency {set G |G. \\<not> G \\<turnstile> FF}\n  set (Neg p # ps) \\<in> {set G |G. \\<not> G \\<turnstile> FF}\n  infinite (- \\<Union> (params ` set (Neg p # ps)))\n  closed 0 x\n  \\<lbrakk>consistency ?C; ?S \\<in> ?C; infinite (- \\<Union> (params ` ?S));\n   ?p \\<in> ?S; closed 0 ?p\\<rbrakk>\n  \\<Longrightarrow> eval ?e HApp\n                     (\\<lambda>a ts.\n                         Pred a (terms_of_hterms ts)\n                         \\<in> Extend ?S\n                                (mk_finite_char\n                                  (mk_alt_consistency (close ?C)))\n                                from_nat)\n                     ?p\n\ngoal (1 subgoal):\n 1. eval e HApp\n     (\\<lambda>a ts.\n         Pred a (terms_of_hterms ts)\n         \\<in> Extend (set (Neg p # ps))\n                (mk_finite_char\n                  (mk_alt_consistency\n                    (close {set G |G. \\<not> G \\<turnstile> FF})))\n                from_nat)\n     x", "by blast"], ["proof (state)\nthis:\n  eval e HApp\n   (\\<lambda>a ts.\n       Pred a (terms_of_hterms ts)\n       \\<in> Extend (set (Neg p # ps))\n              (mk_finite_char\n                (mk_alt_consistency\n                  (close {set G |G. \\<not> G \\<turnstile> FF})))\n              from_nat)\n   x\n\ngoal (1 subgoal):\n 1. \\<not> Neg p # ps \\<turnstile> FF \\<Longrightarrow> False", "}"], ["proof (state)\nthis:\n  ?x3 \\<in> set (Neg p # ps) \\<Longrightarrow>\n  eval e HApp\n   (\\<lambda>a ts.\n       Pred a (terms_of_hterms ts)\n       \\<in> Extend (set (Neg p # ps))\n              (mk_finite_char\n                (mk_alt_consistency\n                  (close {set G |G. \\<not> G \\<turnstile> FF})))\n              from_nat)\n   ?x3\n\ngoal (1 subgoal):\n 1. \\<not> Neg p # ps \\<turnstile> FF \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  ?x3 \\<in> set (Neg p # ps) \\<Longrightarrow>\n  eval e HApp\n   (\\<lambda>a ts.\n       Pred a (terms_of_hterms ts)\n       \\<in> Extend (set (Neg p # ps))\n              (mk_finite_char\n                (mk_alt_consistency\n                  (close {set G |G. \\<not> G \\<turnstile> FF})))\n              from_nat)\n   ?x3", "have \\<open>list_all (eval e ?f ?g) (Neg p # ps)\\<close>"], ["proof (prove)\nusing this:\n  ?x3 \\<in> set (Neg p # ps) \\<Longrightarrow>\n  eval e HApp\n   (\\<lambda>a ts.\n       Pred a (terms_of_hterms ts)\n       \\<in> Extend (set (Neg p # ps))\n              (mk_finite_char\n                (mk_alt_consistency\n                  (close {set G |G. \\<not> G \\<turnstile> FF})))\n              from_nat)\n   ?x3\n\ngoal (1 subgoal):\n 1. list_all\n     (eval e HApp\n       (\\<lambda>a ts.\n           Pred a (terms_of_hterms ts)\n           \\<in> Extend (set (Neg p # ps))\n                  (mk_finite_char\n                    (mk_alt_consistency\n                      (close {set G |G. \\<not> G \\<turnstile> FF})))\n                  from_nat))\n     (Neg p # ps)", "by (simp add: list_all_iff)"], ["proof (state)\nthis:\n  list_all\n   (eval e HApp\n     (\\<lambda>a ts.\n         Pred a (terms_of_hterms ts)\n         \\<in> Extend (set (Neg p # ps))\n                (mk_finite_char\n                  (mk_alt_consistency\n                    (close {set G |G. \\<not> G \\<turnstile> FF})))\n                from_nat))\n   (Neg p # ps)\n\ngoal (1 subgoal):\n 1. \\<not> Neg p # ps \\<turnstile> FF \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  list_all\n   (eval e HApp\n     (\\<lambda>a ts.\n         Pred a (terms_of_hterms ts)\n         \\<in> Extend (set (Neg p # ps))\n                (mk_finite_char\n                  (mk_alt_consistency\n                    (close {set G |G. \\<not> G \\<turnstile> FF})))\n                from_nat))\n   (Neg p # ps)\n\ngoal (1 subgoal):\n 1. \\<not> Neg p # ps \\<turnstile> FF \\<Longrightarrow> False", "have \\<open>eval e ?f ?g (Neg p)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval e HApp\n     (\\<lambda>a ts.\n         Pred a (terms_of_hterms ts)\n         \\<in> Extend (set (Neg p # ps))\n                (mk_finite_char\n                  (mk_alt_consistency\n                    (close {set G |G. \\<not> G \\<turnstile> FF})))\n                from_nat)\n     (Neg p)", "using calculation"], ["proof (prove)\nusing this:\n  list_all\n   (eval e HApp\n     (\\<lambda>a ts.\n         Pred a (terms_of_hterms ts)\n         \\<in> Extend (set (Neg p # ps))\n                (mk_finite_char\n                  (mk_alt_consistency\n                    (close {set G |G. \\<not> G \\<turnstile> FF})))\n                from_nat))\n   (Neg p # ps)\n\ngoal (1 subgoal):\n 1. eval e HApp\n     (\\<lambda>a ts.\n         Pred a (terms_of_hterms ts)\n         \\<in> Extend (set (Neg p # ps))\n                (mk_finite_char\n                  (mk_alt_consistency\n                    (close {set G |G. \\<not> G \\<turnstile> FF})))\n                from_nat)\n     (Neg p)", "by simp"], ["proof (state)\nthis:\n  eval e HApp\n   (\\<lambda>a ts.\n       Pred a (terms_of_hterms ts)\n       \\<in> Extend (set (Neg p # ps))\n              (mk_finite_char\n                (mk_alt_consistency\n                  (close {set G |G. \\<not> G \\<turnstile> FF})))\n              from_nat)\n   (Neg p)\n\ngoal (1 subgoal):\n 1. \\<not> Neg p # ps \\<turnstile> FF \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  eval e HApp\n   (\\<lambda>a ts.\n       Pred a (terms_of_hterms ts)\n       \\<in> Extend (set (Neg p # ps))\n              (mk_finite_char\n                (mk_alt_consistency\n                  (close {set G |G. \\<not> G \\<turnstile> FF})))\n              from_nat)\n   (Neg p)\n\ngoal (1 subgoal):\n 1. \\<not> Neg p # ps \\<turnstile> FF \\<Longrightarrow> False", "have \\<open>list_all (eval e ?f ?g) ps\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all\n     (eval e HApp\n       (\\<lambda>a ts.\n           Pred a (terms_of_hterms ts)\n           \\<in> Extend (set (Neg p # ps))\n                  (mk_finite_char\n                    (mk_alt_consistency\n                      (close {set G |G. \\<not> G \\<turnstile> FF})))\n                  from_nat))\n     ps", "using calculation"], ["proof (prove)\nusing this:\n  list_all\n   (eval e HApp\n     (\\<lambda>a ts.\n         Pred a (terms_of_hterms ts)\n         \\<in> Extend (set (Neg p # ps))\n                (mk_finite_char\n                  (mk_alt_consistency\n                    (close {set G |G. \\<not> G \\<turnstile> FF})))\n                from_nat))\n   (Neg p # ps)\n  eval e HApp\n   (\\<lambda>a ts.\n       Pred a (terms_of_hterms ts)\n       \\<in> Extend (set (Neg p # ps))\n              (mk_finite_char\n                (mk_alt_consistency\n                  (close {set G |G. \\<not> G \\<turnstile> FF})))\n              from_nat)\n   (Neg p)\n\ngoal (1 subgoal):\n 1. list_all\n     (eval e HApp\n       (\\<lambda>a ts.\n           Pred a (terms_of_hterms ts)\n           \\<in> Extend (set (Neg p # ps))\n                  (mk_finite_char\n                    (mk_alt_consistency\n                      (close {set G |G. \\<not> G \\<turnstile> FF})))\n                  from_nat))\n     ps", "by simp"], ["proof (state)\nthis:\n  list_all\n   (eval e HApp\n     (\\<lambda>a ts.\n         Pred a (terms_of_hterms ts)\n         \\<in> Extend (set (Neg p # ps))\n                (mk_finite_char\n                  (mk_alt_consistency\n                    (close {set G |G. \\<not> G \\<turnstile> FF})))\n                from_nat))\n   ps\n\ngoal (1 subgoal):\n 1. \\<not> Neg p # ps \\<turnstile> FF \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  list_all\n   (eval e HApp\n     (\\<lambda>a ts.\n         Pred a (terms_of_hterms ts)\n         \\<in> Extend (set (Neg p # ps))\n                (mk_finite_char\n                  (mk_alt_consistency\n                    (close {set G |G. \\<not> G \\<turnstile> FF})))\n                from_nat))\n   ps", "have \\<open>eval e ?f ?g p\\<close>"], ["proof (prove)\nusing this:\n  list_all\n   (eval e HApp\n     (\\<lambda>a ts.\n         Pred a (terms_of_hterms ts)\n         \\<in> Extend (set (Neg p # ps))\n                (mk_finite_char\n                  (mk_alt_consistency\n                    (close {set G |G. \\<not> G \\<turnstile> FF})))\n                from_nat))\n   ps\n\ngoal (1 subgoal):\n 1. eval e HApp\n     (\\<lambda>a ts.\n         Pred a (terms_of_hterms ts)\n         \\<in> Extend (set (Neg p # ps))\n                (mk_finite_char\n                  (mk_alt_consistency\n                    (close {set G |G. \\<not> G \\<turnstile> FF})))\n                from_nat)\n     p", "using mod"], ["proof (prove)\nusing this:\n  list_all\n   (eval e HApp\n     (\\<lambda>a ts.\n         Pred a (terms_of_hterms ts)\n         \\<in> Extend (set (Neg p # ps))\n                (mk_finite_char\n                  (mk_alt_consistency\n                    (close {set G |G. \\<not> G \\<turnstile> FF})))\n                from_nat))\n   ps\n  \\<forall>e f g. e,f,g,ps \\<Turnstile> p\n\ngoal (1 subgoal):\n 1. eval e HApp\n     (\\<lambda>a ts.\n         Pred a (terms_of_hterms ts)\n         \\<in> Extend (set (Neg p # ps))\n                (mk_finite_char\n                  (mk_alt_consistency\n                    (close {set G |G. \\<not> G \\<turnstile> FF})))\n                from_nat)\n     p", "unfolding model_def"], ["proof (prove)\nusing this:\n  list_all\n   (eval e HApp\n     (\\<lambda>a ts.\n         Pred a (terms_of_hterms ts)\n         \\<in> Extend (set (Neg p # ps))\n                (mk_finite_char\n                  (mk_alt_consistency\n                    (close {set G |G. \\<not> G \\<turnstile> FF})))\n                from_nat))\n   ps\n  \\<forall>e f g. list_all (eval e f g) ps \\<longrightarrow> eval e f g p\n\ngoal (1 subgoal):\n 1. eval e HApp\n     (\\<lambda>a ts.\n         Pred a (terms_of_hterms ts)\n         \\<in> Extend (set (Neg p # ps))\n                (mk_finite_char\n                  (mk_alt_consistency\n                    (close {set G |G. \\<not> G \\<turnstile> FF})))\n                from_nat)\n     p", "by blast"], ["proof (state)\nthis:\n  eval e HApp\n   (\\<lambda>a ts.\n       Pred a (terms_of_hterms ts)\n       \\<in> Extend (set (Neg p # ps))\n              (mk_finite_char\n                (mk_alt_consistency\n                  (close {set G |G. \\<not> G \\<turnstile> FF})))\n              from_nat)\n   p\n\ngoal (1 subgoal):\n 1. \\<not> Neg p # ps \\<turnstile> FF \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  list_all\n   (eval e HApp\n     (\\<lambda>a ts.\n         Pred a (terms_of_hterms ts)\n         \\<in> Extend (set (Neg p # ps))\n                (mk_finite_char\n                  (mk_alt_consistency\n                    (close {set G |G. \\<not> G \\<turnstile> FF})))\n                from_nat))\n   (Neg p # ps)\n  eval e HApp\n   (\\<lambda>a ts.\n       Pred a (terms_of_hterms ts)\n       \\<in> Extend (set (Neg p # ps))\n              (mk_finite_char\n                (mk_alt_consistency\n                  (close {set G |G. \\<not> G \\<turnstile> FF})))\n              from_nat)\n   (Neg p)\n  eval e HApp\n   (\\<lambda>a ts.\n       Pred a (terms_of_hterms ts)\n       \\<in> Extend (set (Neg p # ps))\n              (mk_finite_char\n                (mk_alt_consistency\n                  (close {set G |G. \\<not> G \\<turnstile> FF})))\n              from_nat)\n   p", "show False"], ["proof (prove)\nusing this:\n  list_all\n   (eval e HApp\n     (\\<lambda>a ts.\n         Pred a (terms_of_hterms ts)\n         \\<in> Extend (set (Neg p # ps))\n                (mk_finite_char\n                  (mk_alt_consistency\n                    (close {set G |G. \\<not> G \\<turnstile> FF})))\n                from_nat))\n   (Neg p # ps)\n  eval e HApp\n   (\\<lambda>a ts.\n       Pred a (terms_of_hterms ts)\n       \\<in> Extend (set (Neg p # ps))\n              (mk_finite_char\n                (mk_alt_consistency\n                  (close {set G |G. \\<not> G \\<turnstile> FF})))\n              from_nat)\n   (Neg p)\n  eval e HApp\n   (\\<lambda>a ts.\n       Pred a (terms_of_hterms ts)\n       \\<in> Extend (set (Neg p # ps))\n              (mk_finite_char\n                (mk_alt_consistency\n                  (close {set G |G. \\<not> G \\<turnstile> FF})))\n              from_nat)\n   p\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "section \\<open>L\\\"owenheim-Skolem theorem\\<close>"], ["", "text \\<open>\nAnother application of the model existence theorem presented in \\secref{sec:model-existence}\nis the L\\\"owenheim-Skolem theorem. It says that a set of formulae that is satisfiable in an\n{\\em arbitrary model} is also satisfiable in a {\\em Herbrand model}. The main idea behind the\nproof is to show that satisfiable sets are consistent, hence they must be satisfiable in a\nHerbrand model.\n\\<close>"], ["", "theorem sat_consistency:\n  \\<open>consistency {S. infinite (- (\\<Union>p \\<in> S. params p)) \\<and> (\\<exists>f. \\<forall>(p::('a, 'b)form) \\<in> S. eval e f g p)}\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. consistency\n     {S. infinite (- \\<Union> (params ` S)) \\<and>\n         (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)}", "unfolding consistency_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>S.\n       S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                   (\\<exists>f. Ball S (eval e f g))} \\<longrightarrow>\n       (\\<forall>p ts.\n           \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)) \\<and>\n       FF \\<notin> S \\<and>\n       Neg TT \\<notin> S \\<and>\n       (\\<forall>Z.\n           Neg (Neg Z) \\<in> S \\<longrightarrow>\n           S \\<union> {Z}\n           \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                     (\\<exists>f. Ball S (eval e f g))}) \\<and>\n       (\\<forall>A B.\n           And A B \\<in> S \\<longrightarrow>\n           S \\<union> {A, B}\n           \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                     (\\<exists>f. Ball S (eval e f g))}) \\<and>\n       (\\<forall>A B.\n           Neg (Or A B) \\<in> S \\<longrightarrow>\n           S \\<union> {Neg A, Neg B}\n           \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                     (\\<exists>f. Ball S (eval e f g))}) \\<and>\n       (\\<forall>A B.\n           Or A B \\<in> S \\<longrightarrow>\n           S \\<union> {A}\n           \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                     (\\<exists>f. Ball S (eval e f g))} \\<or>\n           S \\<union> {B}\n           \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                     (\\<exists>f. Ball S (eval e f g))}) \\<and>\n       (\\<forall>A B.\n           Neg (And A B) \\<in> S \\<longrightarrow>\n           S \\<union> {Neg A}\n           \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                     (\\<exists>f. Ball S (eval e f g))} \\<or>\n           S \\<union> {Neg B}\n           \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                     (\\<exists>f. Ball S (eval e f g))}) \\<and>\n       (\\<forall>A B.\n           Impl A B \\<in> S \\<longrightarrow>\n           S \\<union> {Neg A}\n           \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                     (\\<exists>f. Ball S (eval e f g))} \\<or>\n           S \\<union> {B}\n           \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                     (\\<exists>f. Ball S (eval e f g))}) \\<and>\n       (\\<forall>A B.\n           Neg (Impl A B) \\<in> S \\<longrightarrow>\n           S \\<union> {A, Neg B}\n           \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                     (\\<exists>f. Ball S (eval e f g))}) \\<and>\n       (\\<forall>P t.\n           closedt 0 t \\<longrightarrow>\n           Forall P \\<in> S \\<longrightarrow>\n           S \\<union> {P[t/0]}\n           \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                     (\\<exists>f. Ball S (eval e f g))}) \\<and>\n       (\\<forall>P t.\n           closedt 0 t \\<longrightarrow>\n           Neg (Exists P) \\<in> S \\<longrightarrow>\n           S \\<union> {Neg (P[t/0])}\n           \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                     (\\<exists>f. Ball S (eval e f g))}) \\<and>\n       (\\<forall>P.\n           Exists P \\<in> S \\<longrightarrow>\n           (\\<exists>x.\n               S \\<union> {P[App x []/0]}\n               \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                         (\\<exists>f. Ball S (eval e f g))})) \\<and>\n       (\\<forall>P.\n           Neg (Forall P) \\<in> S \\<longrightarrow>\n           (\\<exists>x.\n               S \\<union> {Neg (P[App x []/0])}\n               \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                         (\\<exists>f. Ball S (eval e f g))}))", "proof (intro allI impI conjI)"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>S p ts.\n       S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                   (\\<exists>f. Ball S (eval e f g))} \\<Longrightarrow>\n       \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)\n 2. \\<And>S.\n       S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                   (\\<exists>f. Ball S (eval e f g))} \\<Longrightarrow>\n       FF \\<notin> S\n 3. \\<And>S.\n       S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                   (\\<exists>f. Ball S (eval e f g))} \\<Longrightarrow>\n       Neg TT \\<notin> S\n 4. \\<And>S Z.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 9. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 10. \\<And>S A B.\n        \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                             (\\<exists>f. Ball S (eval e f g))};\n         Neg (Impl A B) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {A, Neg B}\n                          \\<in> {S. infinite\n                                     (- \\<Union> (params ` S)) \\<and>\n                                    (\\<exists>f. Ball S (eval e f g))}\nA total of 14 subgoals...", "let ?C = \\<open>{S. infinite (- (\\<Union>p \\<in> S. params p)) \\<and> (\\<exists>f. \\<forall>p \\<in> S. eval e f g p)}\\<close>"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>S p ts.\n       S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                   (\\<exists>f. Ball S (eval e f g))} \\<Longrightarrow>\n       \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)\n 2. \\<And>S.\n       S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                   (\\<exists>f. Ball S (eval e f g))} \\<Longrightarrow>\n       FF \\<notin> S\n 3. \\<And>S.\n       S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                   (\\<exists>f. Ball S (eval e f g))} \\<Longrightarrow>\n       Neg TT \\<notin> S\n 4. \\<And>S Z.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 9. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 10. \\<And>S A B.\n        \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                             (\\<exists>f. Ball S (eval e f g))};\n         Neg (Impl A B) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {A, Neg B}\n                          \\<in> {S. infinite\n                                     (- \\<Union> (params ` S)) \\<and>\n                                    (\\<exists>f. Ball S (eval e f g))}\nA total of 14 subgoals...", "fix S :: \\<open>('a, 'b) form set\\<close>"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>S p ts.\n       S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                   (\\<exists>f. Ball S (eval e f g))} \\<Longrightarrow>\n       \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)\n 2. \\<And>S.\n       S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                   (\\<exists>f. Ball S (eval e f g))} \\<Longrightarrow>\n       FF \\<notin> S\n 3. \\<And>S.\n       S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                   (\\<exists>f. Ball S (eval e f g))} \\<Longrightarrow>\n       Neg TT \\<notin> S\n 4. \\<And>S Z.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 9. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 10. \\<And>S A B.\n        \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                             (\\<exists>f. Ball S (eval e f g))};\n         Neg (Impl A B) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {A, Neg B}\n                          \\<in> {S. infinite\n                                     (- \\<Union> (params ` S)) \\<and>\n                                    (\\<exists>f. Ball S (eval e f g))}\nA total of 14 subgoals...", "assume \\<open>S \\<in> ?C\\<close>"], ["proof (state)\nthis:\n  S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n              (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)}\n\ngoal (14 subgoals):\n 1. \\<And>S p ts.\n       S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                   (\\<exists>f. Ball S (eval e f g))} \\<Longrightarrow>\n       \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)\n 2. \\<And>S.\n       S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                   (\\<exists>f. Ball S (eval e f g))} \\<Longrightarrow>\n       FF \\<notin> S\n 3. \\<And>S.\n       S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                   (\\<exists>f. Ball S (eval e f g))} \\<Longrightarrow>\n       Neg TT \\<notin> S\n 4. \\<And>S Z.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 9. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 10. \\<And>S A B.\n        \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                             (\\<exists>f. Ball S (eval e f g))};\n         Neg (Impl A B) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {A, Neg B}\n                          \\<in> {S. infinite\n                                     (- \\<Union> (params ` S)) \\<and>\n                                    (\\<exists>f. Ball S (eval e f g))}\nA total of 14 subgoals...", "then"], ["proof (chain)\npicking this:\n  S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n              (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)}", "have inf_params: \\<open>infinite (- (\\<Union>p \\<in> S. params p))\\<close>\n    and \\<open>\\<exists>f. \\<forall>p \\<in> S. eval e f g p\\<close>"], ["proof (prove)\nusing this:\n  S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n              (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)}\n\ngoal (1 subgoal):\n 1. infinite (- \\<Union> (params ` S)) &&&\n    \\<exists>f. \\<forall>p\\<in>S. eval e f g p", "by blast+"], ["proof (state)\nthis:\n  infinite (- \\<Union> (params ` S))\n  \\<exists>f. \\<forall>p\\<in>S. eval e f g p\n\ngoal (14 subgoals):\n 1. \\<And>S p ts.\n       S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                   (\\<exists>f. Ball S (eval e f g))} \\<Longrightarrow>\n       \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)\n 2. \\<And>S.\n       S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                   (\\<exists>f. Ball S (eval e f g))} \\<Longrightarrow>\n       FF \\<notin> S\n 3. \\<And>S.\n       S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                   (\\<exists>f. Ball S (eval e f g))} \\<Longrightarrow>\n       Neg TT \\<notin> S\n 4. \\<And>S Z.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 9. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 10. \\<And>S A B.\n        \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                             (\\<exists>f. Ball S (eval e f g))};\n         Neg (Impl A B) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {A, Neg B}\n                          \\<in> {S. infinite\n                                     (- \\<Union> (params ` S)) \\<and>\n                                    (\\<exists>f. Ball S (eval e f g))}\nA total of 14 subgoals...", "then"], ["proof (chain)\npicking this:\n  infinite (- \\<Union> (params ` S))\n  \\<exists>f. \\<forall>p\\<in>S. eval e f g p", "obtain f where *: \\<open>\\<forall>x \\<in> S. eval e f g x\\<close>"], ["proof (prove)\nusing this:\n  infinite (- \\<Union> (params ` S))\n  \\<exists>f. \\<forall>p\\<in>S. eval e f g p\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<forall>x\\<in>S. eval e f g x \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<forall>x\\<in>S. eval e f g x\n\ngoal (14 subgoals):\n 1. \\<And>S p ts.\n       S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                   (\\<exists>f. Ball S (eval e f g))} \\<Longrightarrow>\n       \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)\n 2. \\<And>S.\n       S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                   (\\<exists>f. Ball S (eval e f g))} \\<Longrightarrow>\n       FF \\<notin> S\n 3. \\<And>S.\n       S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                   (\\<exists>f. Ball S (eval e f g))} \\<Longrightarrow>\n       Neg TT \\<notin> S\n 4. \\<And>S Z.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 9. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 10. \\<And>S A B.\n        \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                             (\\<exists>f. Ball S (eval e f g))};\n         Neg (Impl A B) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {A, Neg B}\n                          \\<in> {S. infinite\n                                     (- \\<Union> (params ` S)) \\<and>\n                                    (\\<exists>f. Ball S (eval e f g))}\nA total of 14 subgoals...", "{"], ["proof (state)\nthis:\n  \\<forall>x\\<in>S. eval e f g x\n\ngoal (14 subgoals):\n 1. \\<And>S p ts.\n       S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                   (\\<exists>f. Ball S (eval e f g))} \\<Longrightarrow>\n       \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)\n 2. \\<And>S.\n       S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                   (\\<exists>f. Ball S (eval e f g))} \\<Longrightarrow>\n       FF \\<notin> S\n 3. \\<And>S.\n       S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                   (\\<exists>f. Ball S (eval e f g))} \\<Longrightarrow>\n       Neg TT \\<notin> S\n 4. \\<And>S Z.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 9. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 10. \\<And>S A B.\n        \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                             (\\<exists>f. Ball S (eval e f g))};\n         Neg (Impl A B) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {A, Neg B}\n                          \\<in> {S. infinite\n                                     (- \\<Union> (params ` S)) \\<and>\n                                    (\\<exists>f. Ball S (eval e f g))}\nA total of 14 subgoals...", "fix p ts"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>S p ts.\n       S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                   (\\<exists>f. Ball S (eval e f g))} \\<Longrightarrow>\n       \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)\n 2. \\<And>S.\n       S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                   (\\<exists>f. Ball S (eval e f g))} \\<Longrightarrow>\n       FF \\<notin> S\n 3. \\<And>S.\n       S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                   (\\<exists>f. Ball S (eval e f g))} \\<Longrightarrow>\n       Neg TT \\<notin> S\n 4. \\<And>S Z.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 9. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 10. \\<And>S A B.\n        \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                             (\\<exists>f. Ball S (eval e f g))};\n         Neg (Impl A B) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {A, Neg B}\n                          \\<in> {S. infinite\n                                     (- \\<Union> (params ` S)) \\<and>\n                                    (\\<exists>f. Ball S (eval e f g))}\nA total of 14 subgoals...", "show \\<open>\\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S \\<Longrightarrow> False", "assume \\<open>Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S\\<close>"], ["proof (state)\nthis:\n  Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S\n\ngoal (1 subgoal):\n 1. Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S", "have \\<open>eval e f g (Pred p ts) \\<and> eval e f g (Neg (Pred p ts))\\<close>"], ["proof (prove)\nusing this:\n  Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S\n\ngoal (1 subgoal):\n 1. eval e f g (Pred p ts) \\<and> eval e f g (Neg (Pred p ts))", "using *"], ["proof (prove)\nusing this:\n  Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S\n  \\<forall>x\\<in>S. eval e f g x\n\ngoal (1 subgoal):\n 1. eval e f g (Pred p ts) \\<and> eval e f g (Neg (Pred p ts))", "by blast"], ["proof (state)\nthis:\n  eval e f g (Pred p ts) \\<and> eval e f g (Neg (Pred p ts))\n\ngoal (1 subgoal):\n 1. Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  eval e f g (Pred p ts) \\<and> eval e f g (Neg (Pred p ts))", "show False"], ["proof (prove)\nusing this:\n  eval e f g (Pred p ts) \\<and> eval e f g (Neg (Pred p ts))\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> (Pred p ts \\<in> S \\<and> Neg (Pred p ts) \\<in> S)\n\ngoal (13 subgoals):\n 1. \\<And>S.\n       S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                   (\\<exists>f. Ball S (eval e f g))} \\<Longrightarrow>\n       FF \\<notin> S\n 2. \\<And>S.\n       S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                   (\\<exists>f. Ball S (eval e f g))} \\<Longrightarrow>\n       Neg TT \\<notin> S\n 3. \\<And>S Z.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 9. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 10. \\<And>S P t.\n        \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                             (\\<exists>f. Ball S (eval e f g))};\n         closedt 0 t; Forall P \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {P[t/0]}\n                          \\<in> {S. infinite\n                                     (- \\<Union> (params ` S)) \\<and>\n                                    (\\<exists>f. Ball S (eval e f g))}\nA total of 13 subgoals...", "}"], ["proof (state)\nthis:\n  \\<not> (Pred ?p3 ?ts3 \\<in> S \\<and> Neg (Pred ?p3 ?ts3) \\<in> S)\n\ngoal (13 subgoals):\n 1. \\<And>S.\n       S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                   (\\<exists>f. Ball S (eval e f g))} \\<Longrightarrow>\n       FF \\<notin> S\n 2. \\<And>S.\n       S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                   (\\<exists>f. Ball S (eval e f g))} \\<Longrightarrow>\n       Neg TT \\<notin> S\n 3. \\<And>S Z.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 9. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 10. \\<And>S P t.\n        \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                             (\\<exists>f. Ball S (eval e f g))};\n         closedt 0 t; Forall P \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {P[t/0]}\n                          \\<in> {S. infinite\n                                     (- \\<Union> (params ` S)) \\<and>\n                                    (\\<exists>f. Ball S (eval e f g))}\nA total of 13 subgoals...", "show \\<open>FF \\<notin> S\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. FF \\<notin> S", "using *"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>S. eval e f g x\n\ngoal (1 subgoal):\n 1. FF \\<notin> S", "by fastforce"], ["proof (state)\nthis:\n  FF \\<notin> S\n\ngoal (12 subgoals):\n 1. \\<And>S.\n       S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                   (\\<exists>f. Ball S (eval e f g))} \\<Longrightarrow>\n       Neg TT \\<notin> S\n 2. \\<And>S Z.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 8. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 9. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 10. \\<And>S P t.\n        \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                             (\\<exists>f. Ball S (eval e f g))};\n         closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                          \\<in> {S. infinite\n                                     (- \\<Union> (params ` S)) \\<and>\n                                    (\\<exists>f. Ball S (eval e f g))}\nA total of 12 subgoals...", "show \\<open>Neg TT \\<notin> S\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Neg TT \\<notin> S", "using *"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>S. eval e f g x\n\ngoal (1 subgoal):\n 1. Neg TT \\<notin> S", "by fastforce"], ["proof (state)\nthis:\n  Neg TT \\<notin> S\n\ngoal (11 subgoals):\n 1. \\<And>S Z.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 9. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                             (\\<exists>f. Ball S (eval e f g))};\n         Exists P \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {P[App x []/0]}\n                             \\<in> {S. infinite\n  (- \\<Union> (params ` S)) \\<and>\n (\\<exists>f. Ball S (eval e f g))}\nA total of 11 subgoals...", "{"], ["proof (state)\nthis:\n  Neg TT \\<notin> S\n\ngoal (11 subgoals):\n 1. \\<And>S Z.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 9. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                             (\\<exists>f. Ball S (eval e f g))};\n         Exists P \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {P[App x []/0]}\n                             \\<in> {S. infinite\n  (- \\<Union> (params ` S)) \\<and>\n (\\<exists>f. Ball S (eval e f g))}\nA total of 11 subgoals...", "fix Z"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>S Z.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 9. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                             (\\<exists>f. Ball S (eval e f g))};\n         Exists P \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {P[App x []/0]}\n                             \\<in> {S. infinite\n  (- \\<Union> (params ` S)) \\<and>\n (\\<exists>f. Ball S (eval e f g))}\nA total of 11 subgoals...", "assume \\<open>Neg (Neg Z) \\<in> S\\<close>"], ["proof (state)\nthis:\n  Neg (Neg Z) \\<in> S\n\ngoal (11 subgoals):\n 1. \\<And>S Z.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 9. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                             (\\<exists>f. Ball S (eval e f g))};\n         Exists P \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {P[App x []/0]}\n                             \\<in> {S. infinite\n  (- \\<Union> (params ` S)) \\<and>\n (\\<exists>f. Ball S (eval e f g))}\nA total of 11 subgoals...", "then"], ["proof (chain)\npicking this:\n  Neg (Neg Z) \\<in> S", "have \\<open>\\<forall>x \\<in> S \\<union> {Neg (Neg Z)}. eval e f g x\\<close>"], ["proof (prove)\nusing this:\n  Neg (Neg Z) \\<in> S\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>S \\<union> {Neg (Neg Z)}. eval e f g x", "using *"], ["proof (prove)\nusing this:\n  Neg (Neg Z) \\<in> S\n  \\<forall>x\\<in>S. eval e f g x\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>S \\<union> {Neg (Neg Z)}. eval e f g x", "by blast"], ["proof (state)\nthis:\n  \\<forall>x\\<in>S \\<union> {Neg (Neg Z)}. eval e f g x\n\ngoal (11 subgoals):\n 1. \\<And>S Z.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 9. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                             (\\<exists>f. Ball S (eval e f g))};\n         Exists P \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {P[App x []/0]}\n                             \\<in> {S. infinite\n  (- \\<Union> (params ` S)) \\<and>\n (\\<exists>f. Ball S (eval e f g))}\nA total of 11 subgoals...", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>S \\<union> {Neg (Neg Z)}. eval e f g x", "have \\<open>\\<forall>x \\<in> S \\<union> {Z}. eval e f g x\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>S \\<union> {Neg (Neg Z)}. eval e f g x\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>S \\<union> {Z}. eval e f g x", "by simp"], ["proof (state)\nthis:\n  \\<forall>x\\<in>S \\<union> {Z}. eval e f g x\n\ngoal (11 subgoals):\n 1. \\<And>S Z.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 9. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                             (\\<exists>f. Ball S (eval e f g))};\n         Exists P \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {P[App x []/0]}\n                             \\<in> {S. infinite\n  (- \\<Union> (params ` S)) \\<and>\n (\\<exists>f. Ball S (eval e f g))}\nA total of 11 subgoals...", "moreover"], ["proof (state)\nthis:\n  \\<forall>x\\<in>S \\<union> {Z}. eval e f g x\n\ngoal (11 subgoals):\n 1. \\<And>S Z.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 9. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                             (\\<exists>f. Ball S (eval e f g))};\n         Exists P \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {P[App x []/0]}\n                             \\<in> {S. infinite\n  (- \\<Union> (params ` S)) \\<and>\n (\\<exists>f. Ball S (eval e f g))}\nA total of 11 subgoals...", "have \\<open>infinite (- (\\<Union>p \\<in> S \\<union> {Z}. params p))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite (- \\<Union> (params ` (S \\<union> {Z})))", "using inf_params"], ["proof (prove)\nusing this:\n  infinite (- \\<Union> (params ` S))\n\ngoal (1 subgoal):\n 1. infinite (- \\<Union> (params ` (S \\<union> {Z})))", "by simp"], ["proof (state)\nthis:\n  infinite (- \\<Union> (params ` (S \\<union> {Z})))\n\ngoal (11 subgoals):\n 1. \\<And>S Z.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Neg Z) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Z}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 7. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 9. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                             (\\<exists>f. Ball S (eval e f g))};\n         Exists P \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {P[App x []/0]}\n                             \\<in> {S. infinite\n  (- \\<Union> (params ` S)) \\<and>\n (\\<exists>f. Ball S (eval e f g))}\nA total of 11 subgoals...", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>S \\<union> {Z}. eval e f g x\n  infinite (- \\<Union> (params ` (S \\<union> {Z})))", "show \\<open>S \\<union> {Z} \\<in> ?C\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>S \\<union> {Z}. eval e f g x\n  infinite (- \\<Union> (params ` (S \\<union> {Z})))\n\ngoal (1 subgoal):\n 1. S \\<union> {Z}\n    \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n              (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)}", "by blast"], ["proof (state)\nthis:\n  S \\<union> {Z}\n  \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n            (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)}\n\ngoal (10 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                             (\\<exists>f. Ball S (eval e f g))};\n         Neg (Forall P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {Neg (P[App x []/0])}\n                             \\<in> {S. infinite\n  (- \\<Union> (params ` S)) \\<and>\n (\\<exists>f. Ball S (eval e f g))}", "}"], ["proof (state)\nthis:\n  Neg (Neg ?Z3) \\<in> S \\<Longrightarrow>\n  S \\<union> {?Z3}\n  \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n            (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)}\n\ngoal (10 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                             (\\<exists>f. Ball S (eval e f g))};\n         Neg (Forall P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {Neg (P[App x []/0])}\n                             \\<in> {S. infinite\n  (- \\<Union> (params ` S)) \\<and>\n (\\<exists>f. Ball S (eval e f g))}", "{"], ["proof (state)\nthis:\n  Neg (Neg ?Z3) \\<in> S \\<Longrightarrow>\n  S \\<union> {?Z3}\n  \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n            (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)}\n\ngoal (10 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                             (\\<exists>f. Ball S (eval e f g))};\n         Neg (Forall P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {Neg (P[App x []/0])}\n                             \\<in> {S. infinite\n  (- \\<Union> (params ` S)) \\<and>\n (\\<exists>f. Ball S (eval e f g))}", "fix A B"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                             (\\<exists>f. Ball S (eval e f g))};\n         Neg (Forall P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {Neg (P[App x []/0])}\n                             \\<in> {S. infinite\n  (- \\<Union> (params ` S)) \\<and>\n (\\<exists>f. Ball S (eval e f g))}", "assume \\<open>And A B \\<in> S\\<close>"], ["proof (state)\nthis:\n  And A B \\<in> S\n\ngoal (10 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                             (\\<exists>f. Ball S (eval e f g))};\n         Neg (Forall P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {Neg (P[App x []/0])}\n                             \\<in> {S. infinite\n  (- \\<Union> (params ` S)) \\<and>\n (\\<exists>f. Ball S (eval e f g))}", "then"], ["proof (chain)\npicking this:\n  And A B \\<in> S", "have \\<open>\\<forall>x \\<in> S \\<union> {And A B}. eval e f g x\\<close>"], ["proof (prove)\nusing this:\n  And A B \\<in> S\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>S \\<union> {And A B}. eval e f g x", "using *"], ["proof (prove)\nusing this:\n  And A B \\<in> S\n  \\<forall>x\\<in>S. eval e f g x\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>S \\<union> {And A B}. eval e f g x", "by blast"], ["proof (state)\nthis:\n  \\<forall>x\\<in>S \\<union> {And A B}. eval e f g x\n\ngoal (10 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                             (\\<exists>f. Ball S (eval e f g))};\n         Neg (Forall P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {Neg (P[App x []/0])}\n                             \\<in> {S. infinite\n  (- \\<Union> (params ` S)) \\<and>\n (\\<exists>f. Ball S (eval e f g))}", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>S \\<union> {And A B}. eval e f g x", "have \\<open>\\<forall>x \\<in> S \\<union> {A, B}. eval e f g x\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>S \\<union> {And A B}. eval e f g x\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>S \\<union> {A, B}. eval e f g x", "by simp"], ["proof (state)\nthis:\n  \\<forall>x\\<in>S \\<union> {A, B}. eval e f g x\n\ngoal (10 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                             (\\<exists>f. Ball S (eval e f g))};\n         Neg (Forall P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {Neg (P[App x []/0])}\n                             \\<in> {S. infinite\n  (- \\<Union> (params ` S)) \\<and>\n (\\<exists>f. Ball S (eval e f g))}", "moreover"], ["proof (state)\nthis:\n  \\<forall>x\\<in>S \\<union> {A, B}. eval e f g x\n\ngoal (10 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                             (\\<exists>f. Ball S (eval e f g))};\n         Neg (Forall P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {Neg (P[App x []/0])}\n                             \\<in> {S. infinite\n  (- \\<Union> (params ` S)) \\<and>\n (\\<exists>f. Ball S (eval e f g))}", "have \\<open>infinite (- (\\<Union>p \\<in> S \\<union> {A, B}. params p))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite (- \\<Union> (params ` (S \\<union> {A, B})))", "using inf_params"], ["proof (prove)\nusing this:\n  infinite (- \\<Union> (params ` S))\n\ngoal (1 subgoal):\n 1. infinite (- \\<Union> (params ` (S \\<union> {A, B})))", "by simp"], ["proof (state)\nthis:\n  infinite (- \\<Union> (params ` (S \\<union> {A, B})))\n\ngoal (10 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        And A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 6. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 8. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 10. \\<And>S P.\n        \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                             (\\<exists>f. Ball S (eval e f g))};\n         Neg (Forall P) \\<in> S\\<rbrakk>\n        \\<Longrightarrow> \\<exists>x.\n                             S \\<union> {Neg (P[App x []/0])}\n                             \\<in> {S. infinite\n  (- \\<Union> (params ` S)) \\<and>\n (\\<exists>f. Ball S (eval e f g))}", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>S \\<union> {A, B}. eval e f g x\n  infinite (- \\<Union> (params ` (S \\<union> {A, B})))", "show \\<open>S \\<union> {A, B} \\<in> ?C\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>S \\<union> {A, B}. eval e f g x\n  infinite (- \\<Union> (params ` (S \\<union> {A, B})))\n\ngoal (1 subgoal):\n 1. S \\<union> {A, B}\n    \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n              (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)}", "by blast"], ["proof (state)\nthis:\n  S \\<union> {A, B}\n  \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n            (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)}\n\ngoal (9 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "}"], ["proof (state)\nthis:\n  And ?A3 ?B3 \\<in> S \\<Longrightarrow>\n  S \\<union> {?A3, ?B3}\n  \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n            (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)}\n\ngoal (9 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "{"], ["proof (state)\nthis:\n  And ?A3 ?B3 \\<in> S \\<Longrightarrow>\n  S \\<union> {?A3, ?B3}\n  \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n            (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)}\n\ngoal (9 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "fix A B"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "assume \\<open>Neg (Or A B) \\<in> S\\<close>"], ["proof (state)\nthis:\n  Neg (Or A B) \\<in> S\n\ngoal (9 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "then"], ["proof (chain)\npicking this:\n  Neg (Or A B) \\<in> S", "have \\<open>\\<forall>x \\<in> S \\<union> {Neg (Or A B)}. eval e f g x\\<close>"], ["proof (prove)\nusing this:\n  Neg (Or A B) \\<in> S\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>S \\<union> {Neg (Or A B)}. eval e f g x", "using *"], ["proof (prove)\nusing this:\n  Neg (Or A B) \\<in> S\n  \\<forall>x\\<in>S. eval e f g x\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>S \\<union> {Neg (Or A B)}. eval e f g x", "by blast"], ["proof (state)\nthis:\n  \\<forall>x\\<in>S \\<union> {Neg (Or A B)}. eval e f g x\n\ngoal (9 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>S \\<union> {Neg (Or A B)}. eval e f g x", "have \\<open>\\<forall>x \\<in> S \\<union> {Neg A, Neg B}. eval e f g x\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>S \\<union> {Neg (Or A B)}. eval e f g x\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>S \\<union> {Neg A, Neg B}. eval e f g x", "by simp"], ["proof (state)\nthis:\n  \\<forall>x\\<in>S \\<union> {Neg A, Neg B}. eval e f g x\n\ngoal (9 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "moreover"], ["proof (state)\nthis:\n  \\<forall>x\\<in>S \\<union> {Neg A, Neg B}. eval e f g x\n\ngoal (9 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "have \\<open>infinite (- (\\<Union>p \\<in> S \\<union> {Neg A, Neg B}. params p))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite (- \\<Union> (params ` (S \\<union> {Neg A, Neg B})))", "using inf_params"], ["proof (prove)\nusing this:\n  infinite (- \\<Union> (params ` S))\n\ngoal (1 subgoal):\n 1. infinite (- \\<Union> (params ` (S \\<union> {Neg A, Neg B})))", "by simp"], ["proof (state)\nthis:\n  infinite (- \\<Union> (params ` (S \\<union> {Neg A, Neg B})))\n\ngoal (9 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Or A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 7. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 9. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>S \\<union> {Neg A, Neg B}. eval e f g x\n  infinite (- \\<Union> (params ` (S \\<union> {Neg A, Neg B})))", "show \\<open>S \\<union> {Neg A, Neg B} \\<in> ?C\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>S \\<union> {Neg A, Neg B}. eval e f g x\n  infinite (- \\<Union> (params ` (S \\<union> {Neg A, Neg B})))\n\ngoal (1 subgoal):\n 1. S \\<union> {Neg A, Neg B}\n    \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n              (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)}", "by blast"], ["proof (state)\nthis:\n  S \\<union> {Neg A, Neg B}\n  \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n            (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)}\n\ngoal (8 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "}"], ["proof (state)\nthis:\n  Neg (Or ?A3 ?B3) \\<in> S \\<Longrightarrow>\n  S \\<union> {Neg ?A3, Neg ?B3}\n  \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n            (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)}\n\ngoal (8 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "{"], ["proof (state)\nthis:\n  Neg (Or ?A3 ?B3) \\<in> S \\<Longrightarrow>\n  S \\<union> {Neg ?A3, Neg ?B3}\n  \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n            (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)}\n\ngoal (8 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "fix A B"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "assume \\<open>Neg (Impl A B) \\<in> S\\<close>"], ["proof (state)\nthis:\n  Neg (Impl A B) \\<in> S\n\ngoal (8 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "then"], ["proof (chain)\npicking this:\n  Neg (Impl A B) \\<in> S", "have \\<open>\\<forall>x \\<in> S \\<union> {Neg (Impl A B)}. eval e f g x\\<close>"], ["proof (prove)\nusing this:\n  Neg (Impl A B) \\<in> S\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>S \\<union> {Neg (Impl A B)}. eval e f g x", "using *"], ["proof (prove)\nusing this:\n  Neg (Impl A B) \\<in> S\n  \\<forall>x\\<in>S. eval e f g x\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>S \\<union> {Neg (Impl A B)}. eval e f g x", "by blast"], ["proof (state)\nthis:\n  \\<forall>x\\<in>S \\<union> {Neg (Impl A B)}. eval e f g x\n\ngoal (8 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>S \\<union> {Neg (Impl A B)}. eval e f g x", "have \\<open>\\<forall>x \\<in> S \\<union> {A, Neg B}. eval e f g x\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>S \\<union> {Neg (Impl A B)}. eval e f g x\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>S \\<union> {A, Neg B}. eval e f g x", "by simp"], ["proof (state)\nthis:\n  \\<forall>x\\<in>S \\<union> {A, Neg B}. eval e f g x\n\ngoal (8 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "moreover"], ["proof (state)\nthis:\n  \\<forall>x\\<in>S \\<union> {A, Neg B}. eval e f g x\n\ngoal (8 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "have \\<open>infinite (- (\\<Union>p \\<in> S \\<union> {A, Neg B}. params p))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite (- \\<Union> (params ` (S \\<union> {A, Neg B})))", "using inf_params"], ["proof (prove)\nusing this:\n  infinite (- \\<Union> (params ` S))\n\ngoal (1 subgoal):\n 1. infinite (- \\<Union> (params ` (S \\<union> {A, Neg B})))", "by simp"], ["proof (state)\nthis:\n  infinite (- \\<Union> (params ` (S \\<union> {A, Neg B})))\n\ngoal (8 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Impl A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A, Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 6. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 8. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>S \\<union> {A, Neg B}. eval e f g x\n  infinite (- \\<Union> (params ` (S \\<union> {A, Neg B})))", "show \\<open>S \\<union> {A, Neg B} \\<in> ?C\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>S \\<union> {A, Neg B}. eval e f g x\n  infinite (- \\<Union> (params ` (S \\<union> {A, Neg B})))\n\ngoal (1 subgoal):\n 1. S \\<union> {A, Neg B}\n    \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n              (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)}", "by blast"], ["proof (state)\nthis:\n  S \\<union> {A, Neg B}\n  \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n            (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)}\n\ngoal (7 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "}"], ["proof (state)\nthis:\n  Neg (Impl ?A3 ?B3) \\<in> S \\<Longrightarrow>\n  S \\<union> {?A3, Neg ?B3}\n  \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n            (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)}\n\ngoal (7 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "{"], ["proof (state)\nthis:\n  Neg (Impl ?A3 ?B3) \\<in> S \\<Longrightarrow>\n  S \\<union> {?A3, Neg ?B3}\n  \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n            (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)}\n\ngoal (7 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "fix A B"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "assume \\<open>Or A B \\<in> S\\<close>"], ["proof (state)\nthis:\n  Or A B \\<in> S\n\ngoal (7 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "then"], ["proof (chain)\npicking this:\n  Or A B \\<in> S", "have \\<open>\\<forall>x \\<in> S \\<union> {Or A B}. eval e f g x\\<close>"], ["proof (prove)\nusing this:\n  Or A B \\<in> S\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>S \\<union> {Or A B}. eval e f g x", "using *"], ["proof (prove)\nusing this:\n  Or A B \\<in> S\n  \\<forall>x\\<in>S. eval e f g x\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>S \\<union> {Or A B}. eval e f g x", "by blast"], ["proof (state)\nthis:\n  \\<forall>x\\<in>S \\<union> {Or A B}. eval e f g x\n\ngoal (7 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>S \\<union> {Or A B}. eval e f g x", "have \\<open>(\\<forall>x \\<in> S \\<union> {A}. eval e f g x) \\<or>\n               (\\<forall>x \\<in> S \\<union> {B}. eval e f g x)\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>S \\<union> {Or A B}. eval e f g x\n\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>S \\<union> {A}. eval e f g x) \\<or>\n    (\\<forall>x\\<in>S \\<union> {B}. eval e f g x)", "by simp"], ["proof (state)\nthis:\n  (\\<forall>x\\<in>S \\<union> {A}. eval e f g x) \\<or>\n  (\\<forall>x\\<in>S \\<union> {B}. eval e f g x)\n\ngoal (7 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "moreover"], ["proof (state)\nthis:\n  (\\<forall>x\\<in>S \\<union> {A}. eval e f g x) \\<or>\n  (\\<forall>x\\<in>S \\<union> {B}. eval e f g x)\n\ngoal (7 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "have \\<open>infinite (- (\\<Union>p \\<in> S \\<union> {A}. params p))\\<close>\n      and \\<open>infinite (- (\\<Union>p \\<in> S \\<union> {B}. params p))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite (- \\<Union> (params ` (S \\<union> {A}))) &&&\n    infinite (- \\<Union> (params ` (S \\<union> {B})))", "using inf_params"], ["proof (prove)\nusing this:\n  infinite (- \\<Union> (params ` S))\n\ngoal (1 subgoal):\n 1. infinite (- \\<Union> (params ` (S \\<union> {A}))) &&&\n    infinite (- \\<Union> (params ` (S \\<union> {B})))", "by simp_all"], ["proof (state)\nthis:\n  infinite (- \\<Union> (params ` (S \\<union> {A})))\n  infinite (- \\<Union> (params ` (S \\<union> {B})))\n\ngoal (7 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Or A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 7. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "ultimately"], ["proof (chain)\npicking this:\n  (\\<forall>x\\<in>S \\<union> {A}. eval e f g x) \\<or>\n  (\\<forall>x\\<in>S \\<union> {B}. eval e f g x)\n  infinite (- \\<Union> (params ` (S \\<union> {A})))\n  infinite (- \\<Union> (params ` (S \\<union> {B})))", "show \\<open>S \\<union> {A} \\<in> ?C \\<or> S \\<union> {B} \\<in> ?C\\<close>"], ["proof (prove)\nusing this:\n  (\\<forall>x\\<in>S \\<union> {A}. eval e f g x) \\<or>\n  (\\<forall>x\\<in>S \\<union> {B}. eval e f g x)\n  infinite (- \\<Union> (params ` (S \\<union> {A})))\n  infinite (- \\<Union> (params ` (S \\<union> {B})))\n\ngoal (1 subgoal):\n 1. S \\<union> {A}\n    \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n              (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)} \\<or>\n    S \\<union> {B}\n    \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n              (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)}", "by blast"], ["proof (state)\nthis:\n  S \\<union> {A}\n  \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n            (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)} \\<or>\n  S \\<union> {B}\n  \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n            (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)}\n\ngoal (6 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "}"], ["proof (state)\nthis:\n  Or ?A3 ?B3 \\<in> S \\<Longrightarrow>\n  S \\<union> {?A3}\n  \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n            (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)} \\<or>\n  S \\<union> {?B3}\n  \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n            (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)}\n\ngoal (6 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "{"], ["proof (state)\nthis:\n  Or ?A3 ?B3 \\<in> S \\<Longrightarrow>\n  S \\<union> {?A3}\n  \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n            (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)} \\<or>\n  S \\<union> {?B3}\n  \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n            (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)}\n\ngoal (6 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "fix A B"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "assume \\<open>Neg (And A B) \\<in> S\\<close>"], ["proof (state)\nthis:\n  Neg (And A B) \\<in> S\n\ngoal (6 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "then"], ["proof (chain)\npicking this:\n  Neg (And A B) \\<in> S", "have \\<open>\\<forall>x \\<in> S \\<union> {Neg (And A B)}. eval e f g x\\<close>"], ["proof (prove)\nusing this:\n  Neg (And A B) \\<in> S\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>S \\<union> {Neg (And A B)}. eval e f g x", "using *"], ["proof (prove)\nusing this:\n  Neg (And A B) \\<in> S\n  \\<forall>x\\<in>S. eval e f g x\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>S \\<union> {Neg (And A B)}. eval e f g x", "by blast"], ["proof (state)\nthis:\n  \\<forall>x\\<in>S \\<union> {Neg (And A B)}. eval e f g x\n\ngoal (6 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>S \\<union> {Neg (And A B)}. eval e f g x", "have \\<open>(\\<forall>x \\<in> S \\<union> {Neg A}. eval e f g x) \\<or>\n               (\\<forall>x \\<in> S \\<union> {Neg B}. eval e f g x)\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>S \\<union> {Neg (And A B)}. eval e f g x\n\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>S \\<union> {Neg A}. eval e f g x) \\<or>\n    (\\<forall>x\\<in>S \\<union> {Neg B}. eval e f g x)", "by simp"], ["proof (state)\nthis:\n  (\\<forall>x\\<in>S \\<union> {Neg A}. eval e f g x) \\<or>\n  (\\<forall>x\\<in>S \\<union> {Neg B}. eval e f g x)\n\ngoal (6 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "moreover"], ["proof (state)\nthis:\n  (\\<forall>x\\<in>S \\<union> {Neg A}. eval e f g x) \\<or>\n  (\\<forall>x\\<in>S \\<union> {Neg B}. eval e f g x)\n\ngoal (6 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "have \\<open>infinite (- (\\<Union>p \\<in> S \\<union> {Neg A}. params p))\\<close>\n      and \\<open>infinite (- (\\<Union>p \\<in> S \\<union> {Neg B}. params p))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite (- \\<Union> (params ` (S \\<union> {Neg A}))) &&&\n    infinite (- \\<Union> (params ` (S \\<union> {Neg B})))", "using inf_params"], ["proof (prove)\nusing this:\n  infinite (- \\<Union> (params ` S))\n\ngoal (1 subgoal):\n 1. infinite (- \\<Union> (params ` (S \\<union> {Neg A}))) &&&\n    infinite (- \\<Union> (params ` (S \\<union> {Neg B})))", "by simp_all"], ["proof (state)\nthis:\n  infinite (- \\<Union> (params ` (S \\<union> {Neg A})))\n  infinite (- \\<Union> (params ` (S \\<union> {Neg B})))\n\ngoal (6 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (And A B) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {Neg B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 6. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "ultimately"], ["proof (chain)\npicking this:\n  (\\<forall>x\\<in>S \\<union> {Neg A}. eval e f g x) \\<or>\n  (\\<forall>x\\<in>S \\<union> {Neg B}. eval e f g x)\n  infinite (- \\<Union> (params ` (S \\<union> {Neg A})))\n  infinite (- \\<Union> (params ` (S \\<union> {Neg B})))", "show \\<open>S \\<union> {Neg A} \\<in> ?C \\<or> S \\<union> {Neg B} \\<in> ?C\\<close>"], ["proof (prove)\nusing this:\n  (\\<forall>x\\<in>S \\<union> {Neg A}. eval e f g x) \\<or>\n  (\\<forall>x\\<in>S \\<union> {Neg B}. eval e f g x)\n  infinite (- \\<Union> (params ` (S \\<union> {Neg A})))\n  infinite (- \\<Union> (params ` (S \\<union> {Neg B})))\n\ngoal (1 subgoal):\n 1. S \\<union> {Neg A}\n    \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n              (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)} \\<or>\n    S \\<union> {Neg B}\n    \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n              (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)}", "by blast"], ["proof (state)\nthis:\n  S \\<union> {Neg A}\n  \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n            (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)} \\<or>\n  S \\<union> {Neg B}\n  \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n            (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)}\n\ngoal (5 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "}"], ["proof (state)\nthis:\n  Neg (And ?A3 ?B3) \\<in> S \\<Longrightarrow>\n  S \\<union> {Neg ?A3}\n  \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n            (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)} \\<or>\n  S \\<union> {Neg ?B3}\n  \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n            (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)}\n\ngoal (5 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "{"], ["proof (state)\nthis:\n  Neg (And ?A3 ?B3) \\<in> S \\<Longrightarrow>\n  S \\<union> {Neg ?A3}\n  \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n            (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)} \\<or>\n  S \\<union> {Neg ?B3}\n  \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n            (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)}\n\ngoal (5 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "fix A B"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "assume \\<open>Impl A B \\<in> S\\<close>"], ["proof (state)\nthis:\n  Impl A B \\<in> S\n\ngoal (5 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "then"], ["proof (chain)\npicking this:\n  Impl A B \\<in> S", "have \\<open>\\<forall>x \\<in> S \\<union> {Impl A B}. eval e f g x\\<close>"], ["proof (prove)\nusing this:\n  Impl A B \\<in> S\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>S \\<union> {Impl A B}. eval e f g x", "using *"], ["proof (prove)\nusing this:\n  Impl A B \\<in> S\n  \\<forall>x\\<in>S. eval e f g x\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>S \\<union> {Impl A B}. eval e f g x", "by blast"], ["proof (state)\nthis:\n  \\<forall>x\\<in>S \\<union> {Impl A B}. eval e f g x\n\ngoal (5 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>S \\<union> {Impl A B}. eval e f g x", "have \\<open>(\\<forall>x \\<in> S \\<union> {Neg A}. eval e f g x) \\<or>\n               (\\<forall>x \\<in> S \\<union> {B}. eval e f g x)\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>S \\<union> {Impl A B}. eval e f g x\n\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>S \\<union> {Neg A}. eval e f g x) \\<or>\n    (\\<forall>x\\<in>S \\<union> {B}. eval e f g x)", "by simp"], ["proof (state)\nthis:\n  (\\<forall>x\\<in>S \\<union> {Neg A}. eval e f g x) \\<or>\n  (\\<forall>x\\<in>S \\<union> {B}. eval e f g x)\n\ngoal (5 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "moreover"], ["proof (state)\nthis:\n  (\\<forall>x\\<in>S \\<union> {Neg A}. eval e f g x) \\<or>\n  (\\<forall>x\\<in>S \\<union> {B}. eval e f g x)\n\ngoal (5 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "have \\<open>infinite (- (\\<Union>p \\<in> S \\<union> {Neg A}. params p))\\<close>\n      and \\<open>infinite (- (\\<Union>p \\<in> S \\<union> {B}. params p))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite (- \\<Union> (params ` (S \\<union> {Neg A}))) &&&\n    infinite (- \\<Union> (params ` (S \\<union> {B})))", "using inf_params"], ["proof (prove)\nusing this:\n  infinite (- \\<Union> (params ` S))\n\ngoal (1 subgoal):\n 1. infinite (- \\<Union> (params ` (S \\<union> {Neg A}))) &&&\n    infinite (- \\<Union> (params ` (S \\<union> {B})))", "by simp_all"], ["proof (state)\nthis:\n  infinite (- \\<Union> (params ` (S \\<union> {Neg A})))\n  infinite (- \\<Union> (params ` (S \\<union> {B})))\n\ngoal (5 subgoals):\n 1. \\<And>S A B.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Impl A B \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg A}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))} \\<or>\n                         S \\<union> {B}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 5. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "ultimately"], ["proof (chain)\npicking this:\n  (\\<forall>x\\<in>S \\<union> {Neg A}. eval e f g x) \\<or>\n  (\\<forall>x\\<in>S \\<union> {B}. eval e f g x)\n  infinite (- \\<Union> (params ` (S \\<union> {Neg A})))\n  infinite (- \\<Union> (params ` (S \\<union> {B})))", "show \\<open>S \\<union> {Neg A} \\<in> ?C \\<or> S \\<union> {B} \\<in> ?C\\<close>"], ["proof (prove)\nusing this:\n  (\\<forall>x\\<in>S \\<union> {Neg A}. eval e f g x) \\<or>\n  (\\<forall>x\\<in>S \\<union> {B}. eval e f g x)\n  infinite (- \\<Union> (params ` (S \\<union> {Neg A})))\n  infinite (- \\<Union> (params ` (S \\<union> {B})))\n\ngoal (1 subgoal):\n 1. S \\<union> {Neg A}\n    \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n              (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)} \\<or>\n    S \\<union> {B}\n    \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n              (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)}", "by blast"], ["proof (state)\nthis:\n  S \\<union> {Neg A}\n  \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n            (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)} \\<or>\n  S \\<union> {B}\n  \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n            (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)}\n\ngoal (4 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "}"], ["proof (state)\nthis:\n  Impl ?A3 ?B3 \\<in> S \\<Longrightarrow>\n  S \\<union> {Neg ?A3}\n  \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n            (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)} \\<or>\n  S \\<union> {?B3}\n  \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n            (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)}\n\ngoal (4 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "{"], ["proof (state)\nthis:\n  Impl ?A3 ?B3 \\<in> S \\<Longrightarrow>\n  S \\<union> {Neg ?A3}\n  \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n            (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)} \\<or>\n  S \\<union> {?B3}\n  \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n            (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)}\n\ngoal (4 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "fix P and t :: \\<open>'a term\\<close>"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "assume \\<open>Forall P \\<in> S\\<close>"], ["proof (state)\nthis:\n  Forall P \\<in> S\n\ngoal (4 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "then"], ["proof (chain)\npicking this:\n  Forall P \\<in> S", "have \\<open>\\<forall>x \\<in> S \\<union> {Forall P}. eval e f g x\\<close>"], ["proof (prove)\nusing this:\n  Forall P \\<in> S\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>S \\<union> {Forall P}. eval e f g x", "using *"], ["proof (prove)\nusing this:\n  Forall P \\<in> S\n  \\<forall>x\\<in>S. eval e f g x\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>S \\<union> {Forall P}. eval e f g x", "by blast"], ["proof (state)\nthis:\n  \\<forall>x\\<in>S \\<union> {Forall P}. eval e f g x\n\ngoal (4 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>S \\<union> {Forall P}. eval e f g x", "have \\<open>\\<forall>x \\<in> S \\<union> {P[t/0]}. eval e f g x\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>S \\<union> {Forall P}. eval e f g x\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>S \\<union> {P[t/0]}. eval e f g x", "by simp"], ["proof (state)\nthis:\n  \\<forall>x\\<in>S \\<union> {P[t/0]}. eval e f g x\n\ngoal (4 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "moreover"], ["proof (state)\nthis:\n  \\<forall>x\\<in>S \\<union> {P[t/0]}. eval e f g x\n\ngoal (4 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "have \\<open>infinite (- (\\<Union>p \\<in> S \\<union> {P[t/0]}. params p))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite (- \\<Union> (params ` (S \\<union> {P[t/0]})))", "using inf_params"], ["proof (prove)\nusing this:\n  infinite (- \\<Union> (params ` S))\n\ngoal (1 subgoal):\n 1. infinite (- \\<Union> (params ` (S \\<union> {P[t/0]})))", "by simp"], ["proof (state)\nthis:\n  infinite (- \\<Union> (params ` (S \\<union> {P[t/0]})))\n\ngoal (4 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Forall P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {P[t/0]}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 4. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>S \\<union> {P[t/0]}. eval e f g x\n  infinite (- \\<Union> (params ` (S \\<union> {P[t/0]})))", "show \\<open>S \\<union> {P[t/0]} \\<in> ?C\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>S \\<union> {P[t/0]}. eval e f g x\n  infinite (- \\<Union> (params ` (S \\<union> {P[t/0]})))\n\ngoal (1 subgoal):\n 1. S \\<union> {P[t/0]}\n    \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n              (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)}", "by blast"], ["proof (state)\nthis:\n  S \\<union> {P[t/0]}\n  \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n            (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)}\n\ngoal (3 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "}"], ["proof (state)\nthis:\n  Forall ?P3 \\<in> S \\<Longrightarrow>\n  S \\<union> {?P3[?t3/0]}\n  \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n            (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)}\n\ngoal (3 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "{"], ["proof (state)\nthis:\n  Forall ?P3 \\<in> S \\<Longrightarrow>\n  S \\<union> {?P3[?t3/0]}\n  \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n            (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)}\n\ngoal (3 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "fix P and t :: \\<open>'a term\\<close>"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "assume \\<open>Neg (Exists P) \\<in> S\\<close>"], ["proof (state)\nthis:\n  Neg (Exists P) \\<in> S\n\ngoal (3 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "then"], ["proof (chain)\npicking this:\n  Neg (Exists P) \\<in> S", "have \\<open>\\<forall>x \\<in> S \\<union> {Neg (Exists P)}. eval e f g x\\<close>"], ["proof (prove)\nusing this:\n  Neg (Exists P) \\<in> S\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>S \\<union> {Neg (Exists P)}. eval e f g x", "using *"], ["proof (prove)\nusing this:\n  Neg (Exists P) \\<in> S\n  \\<forall>x\\<in>S. eval e f g x\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>S \\<union> {Neg (Exists P)}. eval e f g x", "by blast"], ["proof (state)\nthis:\n  \\<forall>x\\<in>S \\<union> {Neg (Exists P)}. eval e f g x\n\ngoal (3 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>S \\<union> {Neg (Exists P)}. eval e f g x", "have \\<open>\\<forall>x \\<in> S \\<union> {Neg (P[t/0])}. eval e f g x\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>S \\<union> {Neg (Exists P)}. eval e f g x\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>S \\<union> {Neg (P[t/0])}. eval e f g x", "by simp"], ["proof (state)\nthis:\n  \\<forall>x\\<in>S \\<union> {Neg (P[t/0])}. eval e f g x\n\ngoal (3 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "moreover"], ["proof (state)\nthis:\n  \\<forall>x\\<in>S \\<union> {Neg (P[t/0])}. eval e f g x\n\ngoal (3 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "have \\<open>infinite (- (\\<Union>p \\<in> S \\<union> {Neg (P[t/0])}. params p))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite (- \\<Union> (params ` (S \\<union> {Neg (P[t/0])})))", "using inf_params"], ["proof (prove)\nusing this:\n  infinite (- \\<Union> (params ` S))\n\ngoal (1 subgoal):\n 1. infinite (- \\<Union> (params ` (S \\<union> {Neg (P[t/0])})))", "by simp"], ["proof (state)\nthis:\n  infinite (- \\<Union> (params ` (S \\<union> {Neg (P[t/0])})))\n\ngoal (3 subgoals):\n 1. \\<And>S P t.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        closedt 0 t; Neg (Exists P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> S \\<union> {Neg (P[t/0])}\n                         \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                                   (\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 3. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>S \\<union> {Neg (P[t/0])}. eval e f g x\n  infinite (- \\<Union> (params ` (S \\<union> {Neg (P[t/0])})))", "show \\<open>S \\<union> {Neg (P[t/0])} \\<in> ?C\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>S \\<union> {Neg (P[t/0])}. eval e f g x\n  infinite (- \\<Union> (params ` (S \\<union> {Neg (P[t/0])})))\n\ngoal (1 subgoal):\n 1. S \\<union> {Neg (P[t/0])}\n    \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n              (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)}", "by blast"], ["proof (state)\nthis:\n  S \\<union> {Neg (P[t/0])}\n  \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n            (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)}\n\ngoal (2 subgoals):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "}"], ["proof (state)\nthis:\n  Neg (Exists ?P3) \\<in> S \\<Longrightarrow>\n  S \\<union> {Neg (?P3[?t3/0])}\n  \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n            (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)}\n\ngoal (2 subgoals):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "{"], ["proof (state)\nthis:\n  Neg (Exists ?P3) \\<in> S \\<Longrightarrow>\n  S \\<union> {Neg (?P3[?t3/0])}\n  \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n            (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)}\n\ngoal (2 subgoals):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "fix P"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "assume \\<open>Exists P \\<in> S\\<close>"], ["proof (state)\nthis:\n  Exists P \\<in> S\n\ngoal (2 subgoals):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "then"], ["proof (chain)\npicking this:\n  Exists P \\<in> S", "have \\<open>\\<forall>x \\<in> S \\<union> {Exists P}. eval e f g x\\<close>"], ["proof (prove)\nusing this:\n  Exists P \\<in> S\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>S \\<union> {Exists P}. eval e f g x", "using *"], ["proof (prove)\nusing this:\n  Exists P \\<in> S\n  \\<forall>x\\<in>S. eval e f g x\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>S \\<union> {Exists P}. eval e f g x", "by blast"], ["proof (state)\nthis:\n  \\<forall>x\\<in>S \\<union> {Exists P}. eval e f g x\n\ngoal (2 subgoals):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>S \\<union> {Exists P}. eval e f g x", "have \\<open>eval e f g (Exists P)\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>S \\<union> {Exists P}. eval e f g x\n\ngoal (1 subgoal):\n 1. eval e f g (Exists P)", "by blast"], ["proof (state)\nthis:\n  eval e f g (Exists P)\n\ngoal (2 subgoals):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "then"], ["proof (chain)\npicking this:\n  eval e f g (Exists P)", "obtain z where \\<open>eval (e\\<langle>0:z\\<rangle>) f g P\\<close>"], ["proof (prove)\nusing this:\n  eval e f g (Exists P)\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        eval (e\\<langle>0:z\\<rangle>) f g P \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  eval (e\\<langle>0:z\\<rangle>) f g P\n\ngoal (2 subgoals):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "moreover"], ["proof (state)\nthis:\n  eval (e\\<langle>0:z\\<rangle>) f g P\n\ngoal (2 subgoals):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "obtain x where **: \\<open>x \\<in> - (\\<Union>p \\<in> S. params p)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> - \\<Union> (params ` S) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using inf_params infinite_imp_nonempty"], ["proof (prove)\nusing this:\n  infinite (- \\<Union> (params ` S))\n  infinite ?S \\<Longrightarrow> ?S \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> - \\<Union> (params ` S) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x \\<in> - \\<Union> (params ` S)\n\ngoal (2 subgoals):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "then"], ["proof (chain)\npicking this:\n  x \\<in> - \\<Union> (params ` S)", "have \\<open>x \\<notin> params P\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> - \\<Union> (params ` S)\n\ngoal (1 subgoal):\n 1. x \\<notin> params P", "using \\<open>Exists P \\<in> S\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> - \\<Union> (params ` S)\n  Exists P \\<in> S\n\ngoal (1 subgoal):\n 1. x \\<notin> params P", "by auto"], ["proof (state)\nthis:\n  x \\<notin> params P\n\ngoal (2 subgoals):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "ultimately"], ["proof (chain)\npicking this:\n  eval (e\\<langle>0:z\\<rangle>) f g P\n  x \\<notin> params P", "have \\<open>eval (e\\<langle>0:(f(x := \\<lambda>y. z)) x []\\<rangle>) (f(x := \\<lambda>y. z)) g P\\<close>"], ["proof (prove)\nusing this:\n  eval (e\\<langle>0:z\\<rangle>) f g P\n  x \\<notin> params P\n\ngoal (1 subgoal):\n 1. eval (e\\<langle>0:(f(x := \\<lambda>y. z)) x []\\<rangle>)\n     (f(x := \\<lambda>y. z)) g P", "by simp"], ["proof (state)\nthis:\n  eval (e\\<langle>0:(f(x := \\<lambda>y. z)) x []\\<rangle>)\n   (f(x := \\<lambda>y. z)) g P\n\ngoal (2 subgoals):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "moreover"], ["proof (state)\nthis:\n  eval (e\\<langle>0:(f(x := \\<lambda>y. z)) x []\\<rangle>)\n   (f(x := \\<lambda>y. z)) g P\n\ngoal (2 subgoals):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "have \\<open>\\<forall>p \\<in> S. eval e (f(x := \\<lambda>y. z)) g p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>S. eval e (f(x := \\<lambda>y. z)) g p", "using * **"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>S. eval e f g x\n  x \\<in> - \\<Union> (params ` S)\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>S. eval e (f(x := \\<lambda>y. z)) g p", "by simp"], ["proof (state)\nthis:\n  \\<forall>p\\<in>S. eval e (f(x := \\<lambda>y. z)) g p\n\ngoal (2 subgoals):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "moreover"], ["proof (state)\nthis:\n  \\<forall>p\\<in>S. eval e (f(x := \\<lambda>y. z)) g p\n\ngoal (2 subgoals):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "have \\<open>infinite (- (\\<Union>p \\<in> S \\<union> {P[App x []/0]}. params p))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite (- \\<Union> (params ` (S \\<union> {P[App x []/0]})))", "using inf_params"], ["proof (prove)\nusing this:\n  infinite (- \\<Union> (params ` S))\n\ngoal (1 subgoal):\n 1. infinite (- \\<Union> (params ` (S \\<union> {P[App x []/0]})))", "by simp"], ["proof (state)\nthis:\n  infinite (- \\<Union> (params ` (S \\<union> {P[App x []/0]})))\n\ngoal (2 subgoals):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "ultimately"], ["proof (chain)\npicking this:\n  eval (e\\<langle>0:(f(x := \\<lambda>y. z)) x []\\<rangle>)\n   (f(x := \\<lambda>y. z)) g P\n  \\<forall>p\\<in>S. eval e (f(x := \\<lambda>y. z)) g p\n  infinite (- \\<Union> (params ` (S \\<union> {P[App x []/0]})))", "have \\<open>S \\<union> {P[App x []/0]}  \\<in>\n                      {S. infinite (- (\\<Union>p \\<in> S. params p)) \\<and> (\\<forall>p \\<in> S. eval e (f(x := \\<lambda>y. z)) g p)}\\<close>"], ["proof (prove)\nusing this:\n  eval (e\\<langle>0:(f(x := \\<lambda>y. z)) x []\\<rangle>)\n   (f(x := \\<lambda>y. z)) g P\n  \\<forall>p\\<in>S. eval e (f(x := \\<lambda>y. z)) g p\n  infinite (- \\<Union> (params ` (S \\<union> {P[App x []/0]})))\n\ngoal (1 subgoal):\n 1. S \\<union> {P[App x []/0]}\n    \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n              (\\<forall>p\\<in>S. eval e (f(x := \\<lambda>y. z)) g p)}", "by simp"], ["proof (state)\nthis:\n  S \\<union> {P[App x []/0]}\n  \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n            (\\<forall>p\\<in>S. eval e (f(x := \\<lambda>y. z)) g p)}\n\ngoal (2 subgoals):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Exists P \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {P[App x []/0]}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}\n 2. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "then"], ["proof (chain)\npicking this:\n  S \\<union> {P[App x []/0]}\n  \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n            (\\<forall>p\\<in>S. eval e (f(x := \\<lambda>y. z)) g p)}", "show \\<open>\\<exists>x. S \\<union> {P[App x []/0]} \\<in> ?C\\<close>"], ["proof (prove)\nusing this:\n  S \\<union> {P[App x []/0]}\n  \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n            (\\<forall>p\\<in>S. eval e (f(x := \\<lambda>y. z)) g p)}\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       S \\<union> {P[App x []/0]}\n       \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                 (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)}", "by blast"], ["proof (state)\nthis:\n  \\<exists>x.\n     S \\<union> {P[App x []/0]}\n     \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n               (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)}\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "}"], ["proof (state)\nthis:\n  Exists ?P3 \\<in> S \\<Longrightarrow>\n  \\<exists>x.\n     S \\<union> {?P3[App x []/0]}\n     \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n               (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)}\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "{"], ["proof (state)\nthis:\n  Exists ?P3 \\<in> S \\<Longrightarrow>\n  \\<exists>x.\n     S \\<union> {?P3[App x []/0]}\n     \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n               (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)}\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "fix P"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "assume \\<open>Neg (Forall P) \\<in> S\\<close>"], ["proof (state)\nthis:\n  Neg (Forall P) \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "then"], ["proof (chain)\npicking this:\n  Neg (Forall P) \\<in> S", "have \\<open>\\<forall>x \\<in> S \\<union> {Neg (Forall P)}. eval e f g x\\<close>"], ["proof (prove)\nusing this:\n  Neg (Forall P) \\<in> S\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>S \\<union> {Neg (Forall P)}. eval e f g x", "using *"], ["proof (prove)\nusing this:\n  Neg (Forall P) \\<in> S\n  \\<forall>x\\<in>S. eval e f g x\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>S \\<union> {Neg (Forall P)}. eval e f g x", "by blast"], ["proof (state)\nthis:\n  \\<forall>x\\<in>S \\<union> {Neg (Forall P)}. eval e f g x\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>S \\<union> {Neg (Forall P)}. eval e f g x", "have \\<open>eval e f g (Neg (Forall P))\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>S \\<union> {Neg (Forall P)}. eval e f g x\n\ngoal (1 subgoal):\n 1. eval e f g (Neg (Forall P))", "by blast"], ["proof (state)\nthis:\n  eval e f g (Neg (Forall P))\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "then"], ["proof (chain)\npicking this:\n  eval e f g (Neg (Forall P))", "obtain z where \\<open>\\<not> eval (e\\<langle>0:z\\<rangle>) f g P\\<close>"], ["proof (prove)\nusing this:\n  eval e f g (Neg (Forall P))\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<not> eval (e\\<langle>0:z\\<rangle>) f g P \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<not> eval (e\\<langle>0:z\\<rangle>) f g P\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "moreover"], ["proof (state)\nthis:\n  \\<not> eval (e\\<langle>0:z\\<rangle>) f g P\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "obtain x where **: \\<open>x \\<in> - (\\<Union>p \\<in> S. params p)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> - \\<Union> (params ` S) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using inf_params infinite_imp_nonempty"], ["proof (prove)\nusing this:\n  infinite (- \\<Union> (params ` S))\n  infinite ?S \\<Longrightarrow> ?S \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> - \\<Union> (params ` S) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x \\<in> - \\<Union> (params ` S)\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "then"], ["proof (chain)\npicking this:\n  x \\<in> - \\<Union> (params ` S)", "have \\<open>x \\<notin> params P\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> - \\<Union> (params ` S)\n\ngoal (1 subgoal):\n 1. x \\<notin> params P", "using \\<open>Neg (Forall P) \\<in> S\\<close>"], ["proof (prove)\nusing this:\n  x \\<in> - \\<Union> (params ` S)\n  Neg (Forall P) \\<in> S\n\ngoal (1 subgoal):\n 1. x \\<notin> params P", "by auto"], ["proof (state)\nthis:\n  x \\<notin> params P\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> eval (e\\<langle>0:z\\<rangle>) f g P\n  x \\<notin> params P", "have \\<open>\\<not> eval (e\\<langle>0:(f(x := \\<lambda>y. z)) x []\\<rangle>) (f(x := \\<lambda>y. z)) g P\\<close>"], ["proof (prove)\nusing this:\n  \\<not> eval (e\\<langle>0:z\\<rangle>) f g P\n  x \\<notin> params P\n\ngoal (1 subgoal):\n 1. \\<not> eval (e\\<langle>0:(f(x := \\<lambda>y. z)) x []\\<rangle>)\n            (f(x := \\<lambda>y. z)) g P", "by simp"], ["proof (state)\nthis:\n  \\<not> eval (e\\<langle>0:(f(x := \\<lambda>y. z)) x []\\<rangle>)\n          (f(x := \\<lambda>y. z)) g P\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "moreover"], ["proof (state)\nthis:\n  \\<not> eval (e\\<langle>0:(f(x := \\<lambda>y. z)) x []\\<rangle>)\n          (f(x := \\<lambda>y. z)) g P\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "have \\<open>\\<forall>p \\<in> S. eval e (f(x := \\<lambda>y. z)) g p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>S. eval e (f(x := \\<lambda>y. z)) g p", "using * **"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>S. eval e f g x\n  x \\<in> - \\<Union> (params ` S)\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>S. eval e (f(x := \\<lambda>y. z)) g p", "by simp"], ["proof (state)\nthis:\n  \\<forall>p\\<in>S. eval e (f(x := \\<lambda>y. z)) g p\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "moreover"], ["proof (state)\nthis:\n  \\<forall>p\\<in>S. eval e (f(x := \\<lambda>y. z)) g p\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "have \\<open>infinite (- (\\<Union>p \\<in> S \\<union> {P[App x []/0]}. params p))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite (- \\<Union> (params ` (S \\<union> {P[App x []/0]})))", "using inf_params"], ["proof (prove)\nusing this:\n  infinite (- \\<Union> (params ` S))\n\ngoal (1 subgoal):\n 1. infinite (- \\<Union> (params ` (S \\<union> {P[App x []/0]})))", "by simp"], ["proof (state)\nthis:\n  infinite (- \\<Union> (params ` (S \\<union> {P[App x []/0]})))\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> eval (e\\<langle>0:(f(x := \\<lambda>y. z)) x []\\<rangle>)\n          (f(x := \\<lambda>y. z)) g P\n  \\<forall>p\\<in>S. eval e (f(x := \\<lambda>y. z)) g p\n  infinite (- \\<Union> (params ` (S \\<union> {P[App x []/0]})))", "have \\<open>S \\<union> {Neg (P[App x []/0])}  \\<in>\n                      {S. infinite (- (\\<Union>p \\<in> S. params p)) \\<and> (\\<forall>p \\<in> S. eval e (f(x := \\<lambda>y. z)) g p)}\\<close>"], ["proof (prove)\nusing this:\n  \\<not> eval (e\\<langle>0:(f(x := \\<lambda>y. z)) x []\\<rangle>)\n          (f(x := \\<lambda>y. z)) g P\n  \\<forall>p\\<in>S. eval e (f(x := \\<lambda>y. z)) g p\n  infinite (- \\<Union> (params ` (S \\<union> {P[App x []/0]})))\n\ngoal (1 subgoal):\n 1. S \\<union> {Neg (P[App x []/0])}\n    \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n              (\\<forall>p\\<in>S. eval e (f(x := \\<lambda>y. z)) g p)}", "by simp"], ["proof (state)\nthis:\n  S \\<union> {Neg (P[App x []/0])}\n  \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n            (\\<forall>p\\<in>S. eval e (f(x := \\<lambda>y. z)) g p)}\n\ngoal (1 subgoal):\n 1. \\<And>S P.\n       \\<lbrakk>S \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                            (\\<exists>f. Ball S (eval e f g))};\n        Neg (Forall P) \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x.\n                            S \\<union> {Neg (P[App x []/0])}\n                            \\<in> {S. infinite\n (- \\<Union> (params ` S)) \\<and>\n(\\<exists>f. Ball S (eval e f g))}", "then"], ["proof (chain)\npicking this:\n  S \\<union> {Neg (P[App x []/0])}\n  \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n            (\\<forall>p\\<in>S. eval e (f(x := \\<lambda>y. z)) g p)}", "show \\<open>\\<exists>x. S \\<union> {Neg (P[App x []/0])} \\<in> ?C\\<close>"], ["proof (prove)\nusing this:\n  S \\<union> {Neg (P[App x []/0])}\n  \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n            (\\<forall>p\\<in>S. eval e (f(x := \\<lambda>y. z)) g p)}\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       S \\<union> {Neg (P[App x []/0])}\n       \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n                 (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)}", "by blast"], ["proof (state)\nthis:\n  \\<exists>x.\n     S \\<union> {Neg (P[App x []/0])}\n     \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n               (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)}\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  Neg (Forall ?P3) \\<in> S \\<Longrightarrow>\n  \\<exists>x.\n     S \\<union> {Neg (?P3[App x []/0])}\n     \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n               (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)}\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem doublep_infinite_params:\n  \\<open>infinite (- (\\<Union>p \\<in> psubst (\\<lambda>n::nat. 2 * n) ` S. params p))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite (- \\<Union> (params ` psubst ((*) 2) ` S))", "proof (rule infinite_super)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?S \\<subseteq> - \\<Union> (params ` psubst ((*) 2) ` S)\n 2. infinite ?S", "show \\<open>infinite (range (\\<lambda>n::nat. 2 * n + 1))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite (range (\\<lambda>n. 2 * n + 1))", "using inj_onI Suc_1 Suc_mult_cancel1 add_right_imp_eq finite_imageD infinite_UNIV_char_0"], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      \\<lbrakk>x \\<in> ?A; y \\<in> ?A; ?f x = ?f y\\<rbrakk>\n      \\<Longrightarrow> x = y) \\<Longrightarrow>\n  inj_on ?f ?A\n  Suc 1 = 2\n  (Suc ?k * ?m = Suc ?k * ?n) = (?m = ?n)\n  ?b + ?a = ?c + ?a \\<Longrightarrow> ?b = ?c\n  \\<lbrakk>finite (?f ` ?A); inj_on ?f ?A\\<rbrakk>\n  \\<Longrightarrow> finite ?A\n  infinite UNIV\n\ngoal (1 subgoal):\n 1. infinite (range (\\<lambda>n. 2 * n + 1))", "by (metis (no_types, lifting))"], ["proof (state)\nthis:\n  infinite (range (\\<lambda>n. 2 * n + 1))\n\ngoal (1 subgoal):\n 1. range (\\<lambda>n. 2 * n + 1)\n    \\<subseteq> - \\<Union> (params ` psubst ((*) 2) ` S)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. range (\\<lambda>n. 2 * n + 1)\n    \\<subseteq> - \\<Union> (params ` psubst ((*) 2) ` S)", "have \\<open>\\<And>m n. Suc (2 * m) \\<noteq> 2 * n\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m n. Suc (2 * m) \\<noteq> 2 * n", "by arith"], ["proof (state)\nthis:\n  Suc (2 * ?m) \\<noteq> 2 * ?n\n\ngoal (1 subgoal):\n 1. range (\\<lambda>n. 2 * n + 1)\n    \\<subseteq> - \\<Union> (params ` psubst ((*) 2) ` S)", "then"], ["proof (chain)\npicking this:\n  Suc (2 * ?m) \\<noteq> 2 * ?n", "show \\<open>range (\\<lambda>n. 2 * n + 1)\n    \\<subseteq> - (\\<Union>p::(nat, 'a) form \\<in> psubst (\\<lambda>n . 2 * n) ` S. params p)\\<close>"], ["proof (prove)\nusing this:\n  Suc (2 * ?m) \\<noteq> 2 * ?n\n\ngoal (1 subgoal):\n 1. range (\\<lambda>n. 2 * n + 1)\n    \\<subseteq> - \\<Union> (params ` psubst ((*) 2) ` S)", "by auto"], ["proof (state)\nthis:\n  range (\\<lambda>n. 2 * n + 1)\n  \\<subseteq> - \\<Union> (params ` psubst ((*) 2) ` S)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nWhen applying the model existence theorem, there is a technical\ncomplication. We must make sure that there are infinitely many\nunused parameters. In order to achieve this, we encode parameters\nas natural numbers and multiply each parameter occurring in the\nset \\<open>S\\<close> by \\<open>2\\<close>.\n\\<close>"], ["", "theorem loewenheim_skolem:\n  assumes evalS: \\<open>\\<forall>p \\<in> S. eval e f g p\\<close>\n  shows \\<open>\\<forall>p \\<in> S. closed 0 p \\<longrightarrow> eval e' (\\<lambda>n. HApp (2*n)) (\\<lambda>a ts.\n      Pred a (terms_of_hterms ts) \\<in> Extend (psubst (\\<lambda>n. 2 * n) ` S)\n        (mk_finite_char (mk_alt_consistency (close\n          {S. infinite (- (\\<Union>p \\<in> S. params p)) \\<and> (\\<exists>f. \\<forall>p \\<in> S. eval e f g p)}))) from_nat) p\\<close>\n    (is \\<open>\\<forall>_ \\<in> _. _ _ _ \\<longrightarrow> eval _ _ ?g _\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>S.\n       closed 0 p \\<longrightarrow>\n       eval e' (\\<lambda>n. HApp (2 * n))\n        (\\<lambda>a ts.\n            Pred a (terms_of_hterms ts)\n            \\<in> Extend (psubst ((*) 2) ` S)\n                   (mk_finite_char\n                     (mk_alt_consistency\n                       (close\n                         {S. infinite (- \\<Union> (params ` S)) \\<and>\n                             (\\<exists>f.\n                                 \\<forall>p\\<in>S. eval e f g p)})))\n                   from_nat)\n        p", "using evalS"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>S. eval e f g p\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>S.\n       closed 0 p \\<longrightarrow>\n       eval e' (\\<lambda>n. HApp (2 * n))\n        (\\<lambda>a ts.\n            Pred a (terms_of_hterms ts)\n            \\<in> Extend (psubst ((*) 2) ` S)\n                   (mk_finite_char\n                     (mk_alt_consistency\n                       (close\n                         {S. infinite (- \\<Union> (params ` S)) \\<and>\n                             (\\<exists>f.\n                                 \\<forall>p\\<in>S. eval e f g p)})))\n                   from_nat)\n        p", "proof (intro ballI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>p\\<in>S. eval e f g p; p \\<in> S;\n        closed 0 p\\<rbrakk>\n       \\<Longrightarrow> eval e' (\\<lambda>n. HApp (2 * n))\n                          (\\<lambda>a ts.\n                              Pred a (terms_of_hterms ts)\n                              \\<in> Extend (psubst ((*) 2) ` S)\n                                     (mk_finite_char\n (mk_alt_consistency\n   (close\n     {S. infinite (- \\<Union> (params ` S)) \\<and>\n         (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)})))\n                                     from_nat)\n                          p", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>p\\<in>S. eval e f g p; p \\<in> S;\n        closed 0 p\\<rbrakk>\n       \\<Longrightarrow> eval e' (\\<lambda>n. HApp (2 * n))\n                          (\\<lambda>a ts.\n                              Pred a (terms_of_hterms ts)\n                              \\<in> Extend (psubst ((*) 2) ` S)\n                                     (mk_finite_char\n (mk_alt_consistency\n   (close\n     {S. infinite (- \\<Union> (params ` S)) \\<and>\n         (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)})))\n                                     from_nat)\n                          p", "let ?C = \\<open>{S. infinite (- (\\<Union>p \\<in> S. params p)) \\<and> (\\<exists>f. \\<forall>x \\<in> S. eval e f g x)}\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>p\\<in>S. eval e f g p; p \\<in> S;\n        closed 0 p\\<rbrakk>\n       \\<Longrightarrow> eval e' (\\<lambda>n. HApp (2 * n))\n                          (\\<lambda>a ts.\n                              Pred a (terms_of_hterms ts)\n                              \\<in> Extend (psubst ((*) 2) ` S)\n                                     (mk_finite_char\n (mk_alt_consistency\n   (close\n     {S. infinite (- \\<Union> (params ` S)) \\<and>\n         (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)})))\n                                     from_nat)\n                          p", "assume \\<open>p \\<in> S\\<close>\n    and \\<open>closed 0 p\\<close>"], ["proof (state)\nthis:\n  p \\<in> S\n  closed 0 p\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>p\\<in>S. eval e f g p; p \\<in> S;\n        closed 0 p\\<rbrakk>\n       \\<Longrightarrow> eval e' (\\<lambda>n. HApp (2 * n))\n                          (\\<lambda>a ts.\n                              Pred a (terms_of_hterms ts)\n                              \\<in> Extend (psubst ((*) 2) ` S)\n                                     (mk_finite_char\n (mk_alt_consistency\n   (close\n     {S. infinite (- \\<Union> (params ` S)) \\<and>\n         (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)})))\n                                     from_nat)\n                          p", "then"], ["proof (chain)\npicking this:\n  p \\<in> S\n  closed 0 p", "have \\<open>eval e f g p\\<close>"], ["proof (prove)\nusing this:\n  p \\<in> S\n  closed 0 p\n\ngoal (1 subgoal):\n 1. eval e f g p", "using evalS"], ["proof (prove)\nusing this:\n  p \\<in> S\n  closed 0 p\n  \\<forall>p\\<in>S. eval e f g p\n\ngoal (1 subgoal):\n 1. eval e f g p", "by blast"], ["proof (state)\nthis:\n  eval e f g p\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>p\\<in>S. eval e f g p; p \\<in> S;\n        closed 0 p\\<rbrakk>\n       \\<Longrightarrow> eval e' (\\<lambda>n. HApp (2 * n))\n                          (\\<lambda>a ts.\n                              Pred a (terms_of_hterms ts)\n                              \\<in> Extend (psubst ((*) 2) ` S)\n                                     (mk_finite_char\n (mk_alt_consistency\n   (close\n     {S. infinite (- \\<Union> (params ` S)) \\<and>\n         (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)})))\n                                     from_nat)\n                          p", "then"], ["proof (chain)\npicking this:\n  eval e f g p", "have \\<open>\\<forall>x \\<in> S. eval e f g x\\<close>"], ["proof (prove)\nusing this:\n  eval e f g p\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>S. eval e f g x", "using evalS"], ["proof (prove)\nusing this:\n  eval e f g p\n  \\<forall>p\\<in>S. eval e f g p\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>S. eval e f g x", "by blast"], ["proof (state)\nthis:\n  \\<forall>x\\<in>S. eval e f g x\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>p\\<in>S. eval e f g p; p \\<in> S;\n        closed 0 p\\<rbrakk>\n       \\<Longrightarrow> eval e' (\\<lambda>n. HApp (2 * n))\n                          (\\<lambda>a ts.\n                              Pred a (terms_of_hterms ts)\n                              \\<in> Extend (psubst ((*) 2) ` S)\n                                     (mk_finite_char\n (mk_alt_consistency\n   (close\n     {S. infinite (- \\<Union> (params ` S)) \\<and>\n         (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)})))\n                                     from_nat)\n                          p", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>S. eval e f g x", "have \\<open>\\<forall>p \\<in> psubst (\\<lambda>n. 2 * n) ` S. eval e (\\<lambda>n. f (n div 2)) g p\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>S. eval e f g x\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>psubst ((*) 2) ` S. eval e (\\<lambda>n. f (n div 2)) g p", "by (simp add: psubst_eval)"], ["proof (state)\nthis:\n  \\<forall>p\\<in>psubst ((*) 2) ` S. eval e (\\<lambda>n. f (n div 2)) g p\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>p\\<in>S. eval e f g p; p \\<in> S;\n        closed 0 p\\<rbrakk>\n       \\<Longrightarrow> eval e' (\\<lambda>n. HApp (2 * n))\n                          (\\<lambda>a ts.\n                              Pred a (terms_of_hterms ts)\n                              \\<in> Extend (psubst ((*) 2) ` S)\n                                     (mk_finite_char\n (mk_alt_consistency\n   (close\n     {S. infinite (- \\<Union> (params ` S)) \\<and>\n         (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)})))\n                                     from_nat)\n                          p", "then"], ["proof (chain)\npicking this:\n  \\<forall>p\\<in>psubst ((*) 2) ` S. eval e (\\<lambda>n. f (n div 2)) g p", "have \\<open>psubst (\\<lambda>n. 2 * n) ` S \\<in> ?C\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>psubst ((*) 2) ` S. eval e (\\<lambda>n. f (n div 2)) g p\n\ngoal (1 subgoal):\n 1. psubst ((*) 2) ` S\n    \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n              (\\<exists>f. \\<forall>x\\<in>S. eval e f g x)}", "using doublep_infinite_params"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>psubst ((*) 2) ` S. eval e (\\<lambda>n. f (n div 2)) g p\n  infinite (- \\<Union> (params ` psubst ((*) 2) ` ?S))\n\ngoal (1 subgoal):\n 1. psubst ((*) 2) ` S\n    \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n              (\\<exists>f. \\<forall>x\\<in>S. eval e f g x)}", "by blast"], ["proof (state)\nthis:\n  psubst ((*) 2) ` S\n  \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n            (\\<exists>f. \\<forall>x\\<in>S. eval e f g x)}\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>p\\<in>S. eval e f g p; p \\<in> S;\n        closed 0 p\\<rbrakk>\n       \\<Longrightarrow> eval e' (\\<lambda>n. HApp (2 * n))\n                          (\\<lambda>a ts.\n                              Pred a (terms_of_hterms ts)\n                              \\<in> Extend (psubst ((*) 2) ` S)\n                                     (mk_finite_char\n (mk_alt_consistency\n   (close\n     {S. infinite (- \\<Union> (params ` S)) \\<and>\n         (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)})))\n                                     from_nat)\n                          p", "moreover"], ["proof (state)\nthis:\n  psubst ((*) 2) ` S\n  \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n            (\\<exists>f. \\<forall>x\\<in>S. eval e f g x)}\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>p\\<in>S. eval e f g p; p \\<in> S;\n        closed 0 p\\<rbrakk>\n       \\<Longrightarrow> eval e' (\\<lambda>n. HApp (2 * n))\n                          (\\<lambda>a ts.\n                              Pred a (terms_of_hterms ts)\n                              \\<in> Extend (psubst ((*) 2) ` S)\n                                     (mk_finite_char\n (mk_alt_consistency\n   (close\n     {S. infinite (- \\<Union> (params ` S)) \\<and>\n         (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)})))\n                                     from_nat)\n                          p", "have \\<open>psubst (\\<lambda>n. 2 * n) p \\<in> psubst (\\<lambda>n. 2 * n) ` S\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. psubst ((*) 2) p \\<in> psubst ((*) 2) ` S", "using \\<open>p \\<in> S\\<close>"], ["proof (prove)\nusing this:\n  p \\<in> S\n\ngoal (1 subgoal):\n 1. psubst ((*) 2) p \\<in> psubst ((*) 2) ` S", "by blast"], ["proof (state)\nthis:\n  psubst ((*) 2) p \\<in> psubst ((*) 2) ` S\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>p\\<in>S. eval e f g p; p \\<in> S;\n        closed 0 p\\<rbrakk>\n       \\<Longrightarrow> eval e' (\\<lambda>n. HApp (2 * n))\n                          (\\<lambda>a ts.\n                              Pred a (terms_of_hterms ts)\n                              \\<in> Extend (psubst ((*) 2) ` S)\n                                     (mk_finite_char\n (mk_alt_consistency\n   (close\n     {S. infinite (- \\<Union> (params ` S)) \\<and>\n         (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)})))\n                                     from_nat)\n                          p", "moreover"], ["proof (state)\nthis:\n  psubst ((*) 2) p \\<in> psubst ((*) 2) ` S\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>p\\<in>S. eval e f g p; p \\<in> S;\n        closed 0 p\\<rbrakk>\n       \\<Longrightarrow> eval e' (\\<lambda>n. HApp (2 * n))\n                          (\\<lambda>a ts.\n                              Pred a (terms_of_hterms ts)\n                              \\<in> Extend (psubst ((*) 2) ` S)\n                                     (mk_finite_char\n (mk_alt_consistency\n   (close\n     {S. infinite (- \\<Union> (params ` S)) \\<and>\n         (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)})))\n                                     from_nat)\n                          p", "have \\<open>closed 0 (psubst (\\<lambda>n. 2 * n) p)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed 0 (psubst ((*) 2) p)", "using \\<open>closed 0 p\\<close>"], ["proof (prove)\nusing this:\n  closed 0 p\n\ngoal (1 subgoal):\n 1. closed 0 (psubst ((*) 2) p)", "by simp"], ["proof (state)\nthis:\n  closed 0 (psubst ((*) 2) p)\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>p\\<in>S. eval e f g p; p \\<in> S;\n        closed 0 p\\<rbrakk>\n       \\<Longrightarrow> eval e' (\\<lambda>n. HApp (2 * n))\n                          (\\<lambda>a ts.\n                              Pred a (terms_of_hterms ts)\n                              \\<in> Extend (psubst ((*) 2) ` S)\n                                     (mk_finite_char\n (mk_alt_consistency\n   (close\n     {S. infinite (- \\<Union> (params ` S)) \\<and>\n         (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)})))\n                                     from_nat)\n                          p", "moreover"], ["proof (state)\nthis:\n  closed 0 (psubst ((*) 2) p)\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>p\\<in>S. eval e f g p; p \\<in> S;\n        closed 0 p\\<rbrakk>\n       \\<Longrightarrow> eval e' (\\<lambda>n. HApp (2 * n))\n                          (\\<lambda>a ts.\n                              Pred a (terms_of_hterms ts)\n                              \\<in> Extend (psubst ((*) 2) ` S)\n                                     (mk_finite_char\n (mk_alt_consistency\n   (close\n     {S. infinite (- \\<Union> (params ` S)) \\<and>\n         (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)})))\n                                     from_nat)\n                          p", "have \\<open>consistency ?C\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. consistency\n     {S. infinite (- \\<Union> (params ` S)) \\<and>\n         (\\<exists>f. \\<forall>x\\<in>S. eval e f g x)}", "using sat_consistency"], ["proof (prove)\nusing this:\n  consistency\n   {S. infinite (- \\<Union> (params ` S)) \\<and>\n       (\\<exists>f. \\<forall>p\\<in>S. eval ?e f ?g p)}\n\ngoal (1 subgoal):\n 1. consistency\n     {S. infinite (- \\<Union> (params ` S)) \\<and>\n         (\\<exists>f. \\<forall>x\\<in>S. eval e f g x)}", "by blast"], ["proof (state)\nthis:\n  consistency\n   {S. infinite (- \\<Union> (params ` S)) \\<and>\n       (\\<exists>f. \\<forall>x\\<in>S. eval e f g x)}\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>p\\<in>S. eval e f g p; p \\<in> S;\n        closed 0 p\\<rbrakk>\n       \\<Longrightarrow> eval e' (\\<lambda>n. HApp (2 * n))\n                          (\\<lambda>a ts.\n                              Pred a (terms_of_hterms ts)\n                              \\<in> Extend (psubst ((*) 2) ` S)\n                                     (mk_finite_char\n (mk_alt_consistency\n   (close\n     {S. infinite (- \\<Union> (params ` S)) \\<and>\n         (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)})))\n                                     from_nat)\n                          p", "ultimately"], ["proof (chain)\npicking this:\n  psubst ((*) 2) ` S\n  \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n            (\\<exists>f. \\<forall>x\\<in>S. eval e f g x)}\n  psubst ((*) 2) p \\<in> psubst ((*) 2) ` S\n  closed 0 (psubst ((*) 2) p)\n  consistency\n   {S. infinite (- \\<Union> (params ` S)) \\<and>\n       (\\<exists>f. \\<forall>x\\<in>S. eval e f g x)}", "have \\<open>eval e' HApp ?g (psubst (\\<lambda>n. 2 * n) p)\\<close>"], ["proof (prove)\nusing this:\n  psubst ((*) 2) ` S\n  \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n            (\\<exists>f. \\<forall>x\\<in>S. eval e f g x)}\n  psubst ((*) 2) p \\<in> psubst ((*) 2) ` S\n  closed 0 (psubst ((*) 2) p)\n  consistency\n   {S. infinite (- \\<Union> (params ` S)) \\<and>\n       (\\<exists>f. \\<forall>x\\<in>S. eval e f g x)}\n\ngoal (1 subgoal):\n 1. eval e' HApp\n     (\\<lambda>a b.\n         Pred a (terms_of_hterms b)\n         \\<in> Extend (psubst ((*) 2) ` S)\n                (mk_finite_char\n                  (mk_alt_consistency\n                    (close\n                      {S. infinite (- \\<Union> (params ` S)) \\<and>\n                          (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)})))\n                from_nat)\n     (psubst ((*) 2) p)", "using model_existence"], ["proof (prove)\nusing this:\n  psubst ((*) 2) ` S\n  \\<in> {S. infinite (- \\<Union> (params ` S)) \\<and>\n            (\\<exists>f. \\<forall>x\\<in>S. eval e f g x)}\n  psubst ((*) 2) p \\<in> psubst ((*) 2) ` S\n  closed 0 (psubst ((*) 2) p)\n  consistency\n   {S. infinite (- \\<Union> (params ` S)) \\<and>\n       (\\<exists>f. \\<forall>x\\<in>S. eval e f g x)}\n  \\<lbrakk>consistency ?C; ?S \\<in> ?C; infinite (- \\<Union> (params ` ?S));\n   ?p \\<in> ?S; closed 0 ?p\\<rbrakk>\n  \\<Longrightarrow> eval ?e HApp\n                     (\\<lambda>a ts.\n                         Pred a (terms_of_hterms ts)\n                         \\<in> Extend ?S\n                                (mk_finite_char\n                                  (mk_alt_consistency (close ?C)))\n                                from_nat)\n                     ?p\n\ngoal (1 subgoal):\n 1. eval e' HApp\n     (\\<lambda>a b.\n         Pred a (terms_of_hterms b)\n         \\<in> Extend (psubst ((*) 2) ` S)\n                (mk_finite_char\n                  (mk_alt_consistency\n                    (close\n                      {S. infinite (- \\<Union> (params ` S)) \\<and>\n                          (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)})))\n                from_nat)\n     (psubst ((*) 2) p)", "by blast"], ["proof (state)\nthis:\n  eval e' HApp\n   (\\<lambda>a b.\n       Pred a (terms_of_hterms b)\n       \\<in> Extend (psubst ((*) 2) ` S)\n              (mk_finite_char\n                (mk_alt_consistency\n                  (close\n                    {S. infinite (- \\<Union> (params ` S)) \\<and>\n                        (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)})))\n              from_nat)\n   (psubst ((*) 2) p)\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>p\\<in>S. eval e f g p; p \\<in> S;\n        closed 0 p\\<rbrakk>\n       \\<Longrightarrow> eval e' (\\<lambda>n. HApp (2 * n))\n                          (\\<lambda>a ts.\n                              Pred a (terms_of_hterms ts)\n                              \\<in> Extend (psubst ((*) 2) ` S)\n                                     (mk_finite_char\n (mk_alt_consistency\n   (close\n     {S. infinite (- \\<Union> (params ` S)) \\<and>\n         (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)})))\n                                     from_nat)\n                          p", "then"], ["proof (chain)\npicking this:\n  eval e' HApp\n   (\\<lambda>a b.\n       Pred a (terms_of_hterms b)\n       \\<in> Extend (psubst ((*) 2) ` S)\n              (mk_finite_char\n                (mk_alt_consistency\n                  (close\n                    {S. infinite (- \\<Union> (params ` S)) \\<and>\n                        (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)})))\n              from_nat)\n   (psubst ((*) 2) p)", "show \\<open>eval e' (\\<lambda>n. HApp (2 * n)) ?g p\\<close>"], ["proof (prove)\nusing this:\n  eval e' HApp\n   (\\<lambda>a b.\n       Pred a (terms_of_hterms b)\n       \\<in> Extend (psubst ((*) 2) ` S)\n              (mk_finite_char\n                (mk_alt_consistency\n                  (close\n                    {S. infinite (- \\<Union> (params ` S)) \\<and>\n                        (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)})))\n              from_nat)\n   (psubst ((*) 2) p)\n\ngoal (1 subgoal):\n 1. eval e' (\\<lambda>n. HApp (2 * n))\n     (\\<lambda>a b.\n         Pred a (terms_of_hterms b)\n         \\<in> Extend (psubst ((*) 2) ` S)\n                (mk_finite_char\n                  (mk_alt_consistency\n                    (close\n                      {S. infinite (- \\<Union> (params ` S)) \\<and>\n                          (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)})))\n                from_nat)\n     p", "using psubst_eval"], ["proof (prove)\nusing this:\n  eval e' HApp\n   (\\<lambda>a b.\n       Pred a (terms_of_hterms b)\n       \\<in> Extend (psubst ((*) 2) ` S)\n              (mk_finite_char\n                (mk_alt_consistency\n                  (close\n                    {S. infinite (- \\<Union> (params ` S)) \\<and>\n                        (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)})))\n              from_nat)\n   (psubst ((*) 2) p)\n  eval ?e ?f ?g (psubst ?h ?p) = eval ?e (\\<lambda>p. ?f (?h p)) ?g ?p\n\ngoal (1 subgoal):\n 1. eval e' (\\<lambda>n. HApp (2 * n))\n     (\\<lambda>a b.\n         Pred a (terms_of_hterms b)\n         \\<in> Extend (psubst ((*) 2) ` S)\n                (mk_finite_char\n                  (mk_alt_consistency\n                    (close\n                      {S. infinite (- \\<Union> (params ` S)) \\<and>\n                          (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)})))\n                from_nat)\n     p", "by blast"], ["proof (state)\nthis:\n  eval e' (\\<lambda>n. HApp (2 * n))\n   (\\<lambda>a b.\n       Pred a (terms_of_hterms b)\n       \\<in> Extend (psubst ((*) 2) ` S)\n              (mk_finite_char\n                (mk_alt_consistency\n                  (close\n                    {S. infinite (- \\<Union> (params ` S)) \\<and>\n                        (\\<exists>f. \\<forall>p\\<in>S. eval e f g p)})))\n              from_nat)\n   p\n\ngoal:\nNo subgoals!", "qed"], ["", "section \\<open>Completeness for open formulas\\<close>"], ["", "abbreviation \\<open>new_term c t \\<equiv> c \\<notin> paramst t\\<close>"], ["", "abbreviation \\<open>new_list c ts \\<equiv> c \\<notin> paramsts ts\\<close>"], ["", "abbreviation \\<open>new c p \\<equiv> c \\<notin> params p\\<close>"], ["", "abbreviation \\<open>news c z \\<equiv> list_all (new c) z\\<close>"], ["", "subsection \\<open>Renaming\\<close>"], ["", "lemma new_psubst_image':\n  \\<open>new_term c t \\<Longrightarrow> d \\<notin> image f (paramst t) \\<Longrightarrow> new_term d (psubstt (f(c := d)) t)\\<close>\n  \\<open>new_list c l \\<Longrightarrow> d \\<notin> image f (paramsts l) \\<Longrightarrow> new_list d (psubstts (f(c := d)) l)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>new_term c t; d \\<notin> f ` paramst t\\<rbrakk>\n     \\<Longrightarrow> new_term d (psubstt (f(c := d)) t)) &&&\n    (\\<lbrakk>new_list c l; d \\<notin> f ` paramsts l\\<rbrakk>\n     \\<Longrightarrow> new_list d (psubstts (f(c := d)) l))", "by (induct t and l rule: paramst.induct paramsts.induct) auto"], ["", "lemma new_psubst_image: \\<open>new c p \\<Longrightarrow> d \\<notin> image f (params p) \\<Longrightarrow> new d (psubst (f(c := d)) p)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>new c p; d \\<notin> f ` params p\\<rbrakk>\n    \\<Longrightarrow> new d (psubst (f(c := d)) p)", "using new_psubst_image'"], ["proof (prove)\nusing this:\n  \\<lbrakk>new_term ?c ?t; ?d \\<notin> ?f ` paramst ?t\\<rbrakk>\n  \\<Longrightarrow> new_term ?d (psubstt (?f(?c := ?d)) ?t)\n  \\<lbrakk>new_list ?c ?l; ?d \\<notin> ?f ` paramsts ?l\\<rbrakk>\n  \\<Longrightarrow> new_list ?d (psubstts (?f(?c := ?d)) ?l)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>new c p; d \\<notin> f ` params p\\<rbrakk>\n    \\<Longrightarrow> new d (psubst (f(c := d)) p)", "by (induct p) auto"], ["", "lemma news_psubst: \\<open>news c z \\<Longrightarrow> d \\<notin> image f (\\<Union>p \\<in> set z. params p) \\<Longrightarrow>\n    news d (map (psubst (f(c := d))) z)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>news c z; d \\<notin> f ` \\<Union> (params ` set z)\\<rbrakk>\n    \\<Longrightarrow> news d (map (psubst (f(c := d))) z)", "using new_psubst_image"], ["proof (prove)\nusing this:\n  \\<lbrakk>new ?c ?p; ?d \\<notin> ?f ` params ?p\\<rbrakk>\n  \\<Longrightarrow> new ?d (psubst (?f(?c := ?d)) ?p)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>news c z; d \\<notin> f ` \\<Union> (params ` set z)\\<rbrakk>\n    \\<Longrightarrow> news d (map (psubst (f(c := d))) z)", "by (induct z) auto"], ["", "lemma member_psubst: \\<open>p \\<in> set z \\<Longrightarrow> psubst f p \\<in> set (map (psubst f) z)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> set z \\<Longrightarrow> psubst f p \\<in> set (map (psubst f) z)", "by (induct z) auto"], ["", "lemma deriv_psubst:\n  fixes f :: \\<open>'a \\<Rightarrow> 'a\\<close>\n  assumes inf_params: \\<open>infinite (UNIV :: 'a set)\\<close>\n  shows \\<open>z \\<turnstile> p \\<Longrightarrow> map (psubst f) z \\<turnstile> psubst f p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<turnstile> p \\<Longrightarrow>\n    map (psubst f) z \\<turnstile> psubst f p", "proof (induct z p arbitrary: f rule: deriv.induct)"], ["proof (state)\ngoal (18 subgoals):\n 1. \\<And>a G f.\n       a \\<in> set G \\<Longrightarrow>\n       map (psubst f) G \\<turnstile> psubst f a\n 2. \\<And>G f. map (psubst f) G \\<turnstile> psubst f TT\n 3. \\<And>G a f.\n       \\<lbrakk>G \\<turnstile> FF;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f FF\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f a\n 4. \\<And>a G f.\n       \\<lbrakk>a # G \\<turnstile> FF;\n        \\<And>f. map (psubst f) (a # G) \\<turnstile> psubst f FF\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Neg a)\n 5. \\<And>G a f.\n       \\<lbrakk>G \\<turnstile> Neg a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Neg a);\n        G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f FF\n 6. \\<And>a G f.\n       \\<lbrakk>Neg a # G \\<turnstile> FF;\n        \\<And>f.\n           map (psubst f) (Neg a # G) \\<turnstile> psubst f FF\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f a\n 7. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a; G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (And a b)\n 8. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f a\n 9. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b\n 10. \\<And>G a b f.\n        \\<lbrakk>G \\<turnstile> a;\n         \\<And>f. map (psubst f) G \\<turnstile> psubst f a\\<rbrakk>\n        \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Or a b)\nA total of 18 subgoals...", "case (Assum a G)"], ["proof (state)\nthis:\n  a \\<in> set G\n\ngoal (18 subgoals):\n 1. \\<And>a G f.\n       a \\<in> set G \\<Longrightarrow>\n       map (psubst f) G \\<turnstile> psubst f a\n 2. \\<And>G f. map (psubst f) G \\<turnstile> psubst f TT\n 3. \\<And>G a f.\n       \\<lbrakk>G \\<turnstile> FF;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f FF\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f a\n 4. \\<And>a G f.\n       \\<lbrakk>a # G \\<turnstile> FF;\n        \\<And>f. map (psubst f) (a # G) \\<turnstile> psubst f FF\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Neg a)\n 5. \\<And>G a f.\n       \\<lbrakk>G \\<turnstile> Neg a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Neg a);\n        G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f FF\n 6. \\<And>a G f.\n       \\<lbrakk>Neg a # G \\<turnstile> FF;\n        \\<And>f.\n           map (psubst f) (Neg a # G) \\<turnstile> psubst f FF\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f a\n 7. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a; G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (And a b)\n 8. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f a\n 9. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b\n 10. \\<And>G a b f.\n        \\<lbrakk>G \\<turnstile> a;\n         \\<And>f. map (psubst f) G \\<turnstile> psubst f a\\<rbrakk>\n        \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Or a b)\nA total of 18 subgoals...", "then"], ["proof (chain)\npicking this:\n  a \\<in> set G", "show ?case"], ["proof (prove)\nusing this:\n  a \\<in> set G\n\ngoal (1 subgoal):\n 1. map (psubst f) G \\<turnstile> psubst f a", "using deriv.Assum member_psubst"], ["proof (prove)\nusing this:\n  a \\<in> set G\n  ?a \\<in> set ?G \\<Longrightarrow> ?G \\<turnstile> ?a\n  ?p \\<in> set ?z \\<Longrightarrow>\n  psubst ?f ?p \\<in> set (map (psubst ?f) ?z)\n\ngoal (1 subgoal):\n 1. map (psubst f) G \\<turnstile> psubst f a", "by blast"], ["proof (state)\nthis:\n  map (psubst f) G \\<turnstile> psubst f a\n\ngoal (17 subgoals):\n 1. \\<And>G f. map (psubst f) G \\<turnstile> psubst f TT\n 2. \\<And>G a f.\n       \\<lbrakk>G \\<turnstile> FF;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f FF\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f a\n 3. \\<And>a G f.\n       \\<lbrakk>a # G \\<turnstile> FF;\n        \\<And>f. map (psubst f) (a # G) \\<turnstile> psubst f FF\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Neg a)\n 4. \\<And>G a f.\n       \\<lbrakk>G \\<turnstile> Neg a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Neg a);\n        G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f FF\n 5. \\<And>a G f.\n       \\<lbrakk>Neg a # G \\<turnstile> FF;\n        \\<And>f.\n           map (psubst f) (Neg a # G) \\<turnstile> psubst f FF\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f a\n 6. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a; G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (And a b)\n 7. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f a\n 8. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b\n 9. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Or a b)\n 10. \\<And>G b a f.\n        \\<lbrakk>G \\<turnstile> b;\n         \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n        \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Or a b)\nA total of 17 subgoals...", "next"], ["proof (state)\ngoal (17 subgoals):\n 1. \\<And>G f. map (psubst f) G \\<turnstile> psubst f TT\n 2. \\<And>G a f.\n       \\<lbrakk>G \\<turnstile> FF;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f FF\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f a\n 3. \\<And>a G f.\n       \\<lbrakk>a # G \\<turnstile> FF;\n        \\<And>f. map (psubst f) (a # G) \\<turnstile> psubst f FF\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Neg a)\n 4. \\<And>G a f.\n       \\<lbrakk>G \\<turnstile> Neg a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Neg a);\n        G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f FF\n 5. \\<And>a G f.\n       \\<lbrakk>Neg a # G \\<turnstile> FF;\n        \\<And>f.\n           map (psubst f) (Neg a # G) \\<turnstile> psubst f FF\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f a\n 6. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a; G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (And a b)\n 7. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f a\n 8. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b\n 9. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Or a b)\n 10. \\<And>G b a f.\n        \\<lbrakk>G \\<turnstile> b;\n         \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n        \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Or a b)\nA total of 17 subgoals...", "case (TTI G)"], ["proof (state)\nthis:\n  \n\ngoal (17 subgoals):\n 1. \\<And>G f. map (psubst f) G \\<turnstile> psubst f TT\n 2. \\<And>G a f.\n       \\<lbrakk>G \\<turnstile> FF;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f FF\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f a\n 3. \\<And>a G f.\n       \\<lbrakk>a # G \\<turnstile> FF;\n        \\<And>f. map (psubst f) (a # G) \\<turnstile> psubst f FF\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Neg a)\n 4. \\<And>G a f.\n       \\<lbrakk>G \\<turnstile> Neg a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Neg a);\n        G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f FF\n 5. \\<And>a G f.\n       \\<lbrakk>Neg a # G \\<turnstile> FF;\n        \\<And>f.\n           map (psubst f) (Neg a # G) \\<turnstile> psubst f FF\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f a\n 6. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a; G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (And a b)\n 7. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f a\n 8. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b\n 9. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Or a b)\n 10. \\<And>G b a f.\n        \\<lbrakk>G \\<turnstile> b;\n         \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n        \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Or a b)\nA total of 17 subgoals...", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (psubst f) G \\<turnstile> psubst f TT", "using deriv.TTI"], ["proof (prove)\nusing this:\n  ?G \\<turnstile> TT\n\ngoal (1 subgoal):\n 1. map (psubst f) G \\<turnstile> psubst f TT", "by auto"], ["proof (state)\nthis:\n  map (psubst f) G \\<turnstile> psubst f TT\n\ngoal (16 subgoals):\n 1. \\<And>G a f.\n       \\<lbrakk>G \\<turnstile> FF;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f FF\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f a\n 2. \\<And>a G f.\n       \\<lbrakk>a # G \\<turnstile> FF;\n        \\<And>f. map (psubst f) (a # G) \\<turnstile> psubst f FF\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Neg a)\n 3. \\<And>G a f.\n       \\<lbrakk>G \\<turnstile> Neg a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Neg a);\n        G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f FF\n 4. \\<And>a G f.\n       \\<lbrakk>Neg a # G \\<turnstile> FF;\n        \\<And>f.\n           map (psubst f) (Neg a # G) \\<turnstile> psubst f FF\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f a\n 5. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a; G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (And a b)\n 6. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f a\n 7. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b\n 8. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Or a b)\n 9. \\<And>G b a f.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Or a b)\n 10. \\<And>G a b c f.\n        \\<lbrakk>G \\<turnstile> Or a b;\n         \\<And>f. map (psubst f) G \\<turnstile> psubst f (Or a b);\n         a # G \\<turnstile> c;\n         \\<And>f. map (psubst f) (a # G) \\<turnstile> psubst f c;\n         b # G \\<turnstile> c;\n         \\<And>f. map (psubst f) (b # G) \\<turnstile> psubst f c\\<rbrakk>\n        \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f c\nA total of 16 subgoals...", "next"], ["proof (state)\ngoal (16 subgoals):\n 1. \\<And>G a f.\n       \\<lbrakk>G \\<turnstile> FF;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f FF\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f a\n 2. \\<And>a G f.\n       \\<lbrakk>a # G \\<turnstile> FF;\n        \\<And>f. map (psubst f) (a # G) \\<turnstile> psubst f FF\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Neg a)\n 3. \\<And>G a f.\n       \\<lbrakk>G \\<turnstile> Neg a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Neg a);\n        G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f FF\n 4. \\<And>a G f.\n       \\<lbrakk>Neg a # G \\<turnstile> FF;\n        \\<And>f.\n           map (psubst f) (Neg a # G) \\<turnstile> psubst f FF\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f a\n 5. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a; G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (And a b)\n 6. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f a\n 7. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b\n 8. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Or a b)\n 9. \\<And>G b a f.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Or a b)\n 10. \\<And>G a b c f.\n        \\<lbrakk>G \\<turnstile> Or a b;\n         \\<And>f. map (psubst f) G \\<turnstile> psubst f (Or a b);\n         a # G \\<turnstile> c;\n         \\<And>f. map (psubst f) (a # G) \\<turnstile> psubst f c;\n         b # G \\<turnstile> c;\n         \\<And>f. map (psubst f) (b # G) \\<turnstile> psubst f c\\<rbrakk>\n        \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f c\nA total of 16 subgoals...", "case (FFE G a)"], ["proof (state)\nthis:\n  G \\<turnstile> FF\n  map (psubst ?f) G \\<turnstile> psubst ?f FF\n\ngoal (16 subgoals):\n 1. \\<And>G a f.\n       \\<lbrakk>G \\<turnstile> FF;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f FF\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f a\n 2. \\<And>a G f.\n       \\<lbrakk>a # G \\<turnstile> FF;\n        \\<And>f. map (psubst f) (a # G) \\<turnstile> psubst f FF\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Neg a)\n 3. \\<And>G a f.\n       \\<lbrakk>G \\<turnstile> Neg a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Neg a);\n        G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f FF\n 4. \\<And>a G f.\n       \\<lbrakk>Neg a # G \\<turnstile> FF;\n        \\<And>f.\n           map (psubst f) (Neg a # G) \\<turnstile> psubst f FF\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f a\n 5. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a; G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (And a b)\n 6. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f a\n 7. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b\n 8. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Or a b)\n 9. \\<And>G b a f.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Or a b)\n 10. \\<And>G a b c f.\n        \\<lbrakk>G \\<turnstile> Or a b;\n         \\<And>f. map (psubst f) G \\<turnstile> psubst f (Or a b);\n         a # G \\<turnstile> c;\n         \\<And>f. map (psubst f) (a # G) \\<turnstile> psubst f c;\n         b # G \\<turnstile> c;\n         \\<And>f. map (psubst f) (b # G) \\<turnstile> psubst f c\\<rbrakk>\n        \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f c\nA total of 16 subgoals...", "then"], ["proof (chain)\npicking this:\n  G \\<turnstile> FF\n  map (psubst ?f) G \\<turnstile> psubst ?f FF", "show ?case"], ["proof (prove)\nusing this:\n  G \\<turnstile> FF\n  map (psubst ?f) G \\<turnstile> psubst ?f FF\n\ngoal (1 subgoal):\n 1. map (psubst f) G \\<turnstile> psubst f a", "using deriv.FFE"], ["proof (prove)\nusing this:\n  G \\<turnstile> FF\n  map (psubst ?f) G \\<turnstile> psubst ?f FF\n  ?G \\<turnstile> FF \\<Longrightarrow> ?G \\<turnstile> ?a\n\ngoal (1 subgoal):\n 1. map (psubst f) G \\<turnstile> psubst f a", "by auto"], ["proof (state)\nthis:\n  map (psubst f) G \\<turnstile> psubst f a\n\ngoal (15 subgoals):\n 1. \\<And>a G f.\n       \\<lbrakk>a # G \\<turnstile> FF;\n        \\<And>f. map (psubst f) (a # G) \\<turnstile> psubst f FF\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Neg a)\n 2. \\<And>G a f.\n       \\<lbrakk>G \\<turnstile> Neg a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Neg a);\n        G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f FF\n 3. \\<And>a G f.\n       \\<lbrakk>Neg a # G \\<turnstile> FF;\n        \\<And>f.\n           map (psubst f) (Neg a # G) \\<turnstile> psubst f FF\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f a\n 4. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a; G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (And a b)\n 5. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f a\n 6. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b\n 7. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Or a b)\n 8. \\<And>G b a f.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Or a b)\n 9. \\<And>G a b c f.\n       \\<lbrakk>G \\<turnstile> Or a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Or a b);\n        a # G \\<turnstile> c;\n        \\<And>f. map (psubst f) (a # G) \\<turnstile> psubst f c;\n        b # G \\<turnstile> c;\n        \\<And>f. map (psubst f) (b # G) \\<turnstile> psubst f c\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f c\n 10. \\<And>a G b f.\n        \\<lbrakk>a # G \\<turnstile> b;\n         \\<And>f. map (psubst f) (a # G) \\<turnstile> psubst f b\\<rbrakk>\n        \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Impl a b)\nA total of 15 subgoals...", "next"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>a G f.\n       \\<lbrakk>a # G \\<turnstile> FF;\n        \\<And>f. map (psubst f) (a # G) \\<turnstile> psubst f FF\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Neg a)\n 2. \\<And>G a f.\n       \\<lbrakk>G \\<turnstile> Neg a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Neg a);\n        G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f FF\n 3. \\<And>a G f.\n       \\<lbrakk>Neg a # G \\<turnstile> FF;\n        \\<And>f.\n           map (psubst f) (Neg a # G) \\<turnstile> psubst f FF\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f a\n 4. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a; G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (And a b)\n 5. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f a\n 6. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b\n 7. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Or a b)\n 8. \\<And>G b a f.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Or a b)\n 9. \\<And>G a b c f.\n       \\<lbrakk>G \\<turnstile> Or a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Or a b);\n        a # G \\<turnstile> c;\n        \\<And>f. map (psubst f) (a # G) \\<turnstile> psubst f c;\n        b # G \\<turnstile> c;\n        \\<And>f. map (psubst f) (b # G) \\<turnstile> psubst f c\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f c\n 10. \\<And>a G b f.\n        \\<lbrakk>a # G \\<turnstile> b;\n         \\<And>f. map (psubst f) (a # G) \\<turnstile> psubst f b\\<rbrakk>\n        \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Impl a b)\nA total of 15 subgoals...", "case (NegI a G)"], ["proof (state)\nthis:\n  a # G \\<turnstile> FF\n  map (psubst ?f) (a # G) \\<turnstile> psubst ?f FF\n\ngoal (15 subgoals):\n 1. \\<And>a G f.\n       \\<lbrakk>a # G \\<turnstile> FF;\n        \\<And>f. map (psubst f) (a # G) \\<turnstile> psubst f FF\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Neg a)\n 2. \\<And>G a f.\n       \\<lbrakk>G \\<turnstile> Neg a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Neg a);\n        G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f FF\n 3. \\<And>a G f.\n       \\<lbrakk>Neg a # G \\<turnstile> FF;\n        \\<And>f.\n           map (psubst f) (Neg a # G) \\<turnstile> psubst f FF\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f a\n 4. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a; G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (And a b)\n 5. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f a\n 6. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b\n 7. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Or a b)\n 8. \\<And>G b a f.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Or a b)\n 9. \\<And>G a b c f.\n       \\<lbrakk>G \\<turnstile> Or a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Or a b);\n        a # G \\<turnstile> c;\n        \\<And>f. map (psubst f) (a # G) \\<turnstile> psubst f c;\n        b # G \\<turnstile> c;\n        \\<And>f. map (psubst f) (b # G) \\<turnstile> psubst f c\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f c\n 10. \\<And>a G b f.\n        \\<lbrakk>a # G \\<turnstile> b;\n         \\<And>f. map (psubst f) (a # G) \\<turnstile> psubst f b\\<rbrakk>\n        \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Impl a b)\nA total of 15 subgoals...", "then"], ["proof (chain)\npicking this:\n  a # G \\<turnstile> FF\n  map (psubst ?f) (a # G) \\<turnstile> psubst ?f FF", "show ?case"], ["proof (prove)\nusing this:\n  a # G \\<turnstile> FF\n  map (psubst ?f) (a # G) \\<turnstile> psubst ?f FF\n\ngoal (1 subgoal):\n 1. map (psubst f) G \\<turnstile> psubst f (Neg a)", "using deriv.NegI"], ["proof (prove)\nusing this:\n  a # G \\<turnstile> FF\n  map (psubst ?f) (a # G) \\<turnstile> psubst ?f FF\n  ?a # ?G \\<turnstile> FF \\<Longrightarrow> ?G \\<turnstile> Neg ?a\n\ngoal (1 subgoal):\n 1. map (psubst f) G \\<turnstile> psubst f (Neg a)", "by auto"], ["proof (state)\nthis:\n  map (psubst f) G \\<turnstile> psubst f (Neg a)\n\ngoal (14 subgoals):\n 1. \\<And>G a f.\n       \\<lbrakk>G \\<turnstile> Neg a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Neg a);\n        G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f FF\n 2. \\<And>a G f.\n       \\<lbrakk>Neg a # G \\<turnstile> FF;\n        \\<And>f.\n           map (psubst f) (Neg a # G) \\<turnstile> psubst f FF\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f a\n 3. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a; G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (And a b)\n 4. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f a\n 5. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b\n 6. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Or a b)\n 7. \\<And>G b a f.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Or a b)\n 8. \\<And>G a b c f.\n       \\<lbrakk>G \\<turnstile> Or a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Or a b);\n        a # G \\<turnstile> c;\n        \\<And>f. map (psubst f) (a # G) \\<turnstile> psubst f c;\n        b # G \\<turnstile> c;\n        \\<And>f. map (psubst f) (b # G) \\<turnstile> psubst f c\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f c\n 9. \\<And>a G b f.\n       \\<lbrakk>a # G \\<turnstile> b;\n        \\<And>f. map (psubst f) (a # G) \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Impl a b)\n 10. \\<And>G a b f.\n        \\<lbrakk>G \\<turnstile> Impl a b;\n         \\<And>f. map (psubst f) G \\<turnstile> psubst f (Impl a b);\n         G \\<turnstile> a;\n         \\<And>f. map (psubst f) G \\<turnstile> psubst f a\\<rbrakk>\n        \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b\nA total of 14 subgoals...", "next"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>G a f.\n       \\<lbrakk>G \\<turnstile> Neg a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Neg a);\n        G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f FF\n 2. \\<And>a G f.\n       \\<lbrakk>Neg a # G \\<turnstile> FF;\n        \\<And>f.\n           map (psubst f) (Neg a # G) \\<turnstile> psubst f FF\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f a\n 3. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a; G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (And a b)\n 4. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f a\n 5. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b\n 6. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Or a b)\n 7. \\<And>G b a f.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Or a b)\n 8. \\<And>G a b c f.\n       \\<lbrakk>G \\<turnstile> Or a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Or a b);\n        a # G \\<turnstile> c;\n        \\<And>f. map (psubst f) (a # G) \\<turnstile> psubst f c;\n        b # G \\<turnstile> c;\n        \\<And>f. map (psubst f) (b # G) \\<turnstile> psubst f c\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f c\n 9. \\<And>a G b f.\n       \\<lbrakk>a # G \\<turnstile> b;\n        \\<And>f. map (psubst f) (a # G) \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Impl a b)\n 10. \\<And>G a b f.\n        \\<lbrakk>G \\<turnstile> Impl a b;\n         \\<And>f. map (psubst f) G \\<turnstile> psubst f (Impl a b);\n         G \\<turnstile> a;\n         \\<And>f. map (psubst f) G \\<turnstile> psubst f a\\<rbrakk>\n        \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b\nA total of 14 subgoals...", "case (NegE G a)"], ["proof (state)\nthis:\n  G \\<turnstile> Neg a\n  map (psubst ?f) G \\<turnstile> psubst ?f (Neg a)\n  G \\<turnstile> a\n  map (psubst ?f) G \\<turnstile> psubst ?f a\n\ngoal (14 subgoals):\n 1. \\<And>G a f.\n       \\<lbrakk>G \\<turnstile> Neg a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Neg a);\n        G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f FF\n 2. \\<And>a G f.\n       \\<lbrakk>Neg a # G \\<turnstile> FF;\n        \\<And>f.\n           map (psubst f) (Neg a # G) \\<turnstile> psubst f FF\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f a\n 3. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a; G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (And a b)\n 4. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f a\n 5. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b\n 6. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Or a b)\n 7. \\<And>G b a f.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Or a b)\n 8. \\<And>G a b c f.\n       \\<lbrakk>G \\<turnstile> Or a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Or a b);\n        a # G \\<turnstile> c;\n        \\<And>f. map (psubst f) (a # G) \\<turnstile> psubst f c;\n        b # G \\<turnstile> c;\n        \\<And>f. map (psubst f) (b # G) \\<turnstile> psubst f c\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f c\n 9. \\<And>a G b f.\n       \\<lbrakk>a # G \\<turnstile> b;\n        \\<And>f. map (psubst f) (a # G) \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Impl a b)\n 10. \\<And>G a b f.\n        \\<lbrakk>G \\<turnstile> Impl a b;\n         \\<And>f. map (psubst f) G \\<turnstile> psubst f (Impl a b);\n         G \\<turnstile> a;\n         \\<And>f. map (psubst f) G \\<turnstile> psubst f a\\<rbrakk>\n        \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b\nA total of 14 subgoals...", "then"], ["proof (chain)\npicking this:\n  G \\<turnstile> Neg a\n  map (psubst ?f) G \\<turnstile> psubst ?f (Neg a)\n  G \\<turnstile> a\n  map (psubst ?f) G \\<turnstile> psubst ?f a", "show ?case"], ["proof (prove)\nusing this:\n  G \\<turnstile> Neg a\n  map (psubst ?f) G \\<turnstile> psubst ?f (Neg a)\n  G \\<turnstile> a\n  map (psubst ?f) G \\<turnstile> psubst ?f a\n\ngoal (1 subgoal):\n 1. map (psubst f) G \\<turnstile> psubst f FF", "using deriv.NegE"], ["proof (prove)\nusing this:\n  G \\<turnstile> Neg a\n  map (psubst ?f) G \\<turnstile> psubst ?f (Neg a)\n  G \\<turnstile> a\n  map (psubst ?f) G \\<turnstile> psubst ?f a\n  \\<lbrakk>?G \\<turnstile> Neg ?a; ?G \\<turnstile> ?a\\<rbrakk>\n  \\<Longrightarrow> ?G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. map (psubst f) G \\<turnstile> psubst f FF", "by auto"], ["proof (state)\nthis:\n  map (psubst f) G \\<turnstile> psubst f FF\n\ngoal (13 subgoals):\n 1. \\<And>a G f.\n       \\<lbrakk>Neg a # G \\<turnstile> FF;\n        \\<And>f.\n           map (psubst f) (Neg a # G) \\<turnstile> psubst f FF\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f a\n 2. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a; G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (And a b)\n 3. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f a\n 4. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b\n 5. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Or a b)\n 6. \\<And>G b a f.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Or a b)\n 7. \\<And>G a b c f.\n       \\<lbrakk>G \\<turnstile> Or a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Or a b);\n        a # G \\<turnstile> c;\n        \\<And>f. map (psubst f) (a # G) \\<turnstile> psubst f c;\n        b # G \\<turnstile> c;\n        \\<And>f. map (psubst f) (b # G) \\<turnstile> psubst f c\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f c\n 8. \\<And>a G b f.\n       \\<lbrakk>a # G \\<turnstile> b;\n        \\<And>f. map (psubst f) (a # G) \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Impl a b)\n 9. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> Impl a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Impl a b);\n        G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b\n 10. \\<And>G a n f.\n        \\<lbrakk>G \\<turnstile> a[App n []/0];\n         \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[App n []/0]);\n         news n G; new n a\\<rbrakk>\n        \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Forall a)\nA total of 13 subgoals...", "next"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>a G f.\n       \\<lbrakk>Neg a # G \\<turnstile> FF;\n        \\<And>f.\n           map (psubst f) (Neg a # G) \\<turnstile> psubst f FF\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f a\n 2. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a; G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (And a b)\n 3. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f a\n 4. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b\n 5. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Or a b)\n 6. \\<And>G b a f.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Or a b)\n 7. \\<And>G a b c f.\n       \\<lbrakk>G \\<turnstile> Or a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Or a b);\n        a # G \\<turnstile> c;\n        \\<And>f. map (psubst f) (a # G) \\<turnstile> psubst f c;\n        b # G \\<turnstile> c;\n        \\<And>f. map (psubst f) (b # G) \\<turnstile> psubst f c\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f c\n 8. \\<And>a G b f.\n       \\<lbrakk>a # G \\<turnstile> b;\n        \\<And>f. map (psubst f) (a # G) \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Impl a b)\n 9. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> Impl a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Impl a b);\n        G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b\n 10. \\<And>G a n f.\n        \\<lbrakk>G \\<turnstile> a[App n []/0];\n         \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[App n []/0]);\n         news n G; new n a\\<rbrakk>\n        \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Forall a)\nA total of 13 subgoals...", "case (Class a G)"], ["proof (state)\nthis:\n  Neg a # G \\<turnstile> FF\n  map (psubst ?f) (Neg a # G) \\<turnstile> psubst ?f FF\n\ngoal (13 subgoals):\n 1. \\<And>a G f.\n       \\<lbrakk>Neg a # G \\<turnstile> FF;\n        \\<And>f.\n           map (psubst f) (Neg a # G) \\<turnstile> psubst f FF\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f a\n 2. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a; G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (And a b)\n 3. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f a\n 4. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b\n 5. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Or a b)\n 6. \\<And>G b a f.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Or a b)\n 7. \\<And>G a b c f.\n       \\<lbrakk>G \\<turnstile> Or a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Or a b);\n        a # G \\<turnstile> c;\n        \\<And>f. map (psubst f) (a # G) \\<turnstile> psubst f c;\n        b # G \\<turnstile> c;\n        \\<And>f. map (psubst f) (b # G) \\<turnstile> psubst f c\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f c\n 8. \\<And>a G b f.\n       \\<lbrakk>a # G \\<turnstile> b;\n        \\<And>f. map (psubst f) (a # G) \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Impl a b)\n 9. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> Impl a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Impl a b);\n        G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b\n 10. \\<And>G a n f.\n        \\<lbrakk>G \\<turnstile> a[App n []/0];\n         \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[App n []/0]);\n         news n G; new n a\\<rbrakk>\n        \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Forall a)\nA total of 13 subgoals...", "then"], ["proof (chain)\npicking this:\n  Neg a # G \\<turnstile> FF\n  map (psubst ?f) (Neg a # G) \\<turnstile> psubst ?f FF", "show ?case"], ["proof (prove)\nusing this:\n  Neg a # G \\<turnstile> FF\n  map (psubst ?f) (Neg a # G) \\<turnstile> psubst ?f FF\n\ngoal (1 subgoal):\n 1. map (psubst f) G \\<turnstile> psubst f a", "using deriv.Class"], ["proof (prove)\nusing this:\n  Neg a # G \\<turnstile> FF\n  map (psubst ?f) (Neg a # G) \\<turnstile> psubst ?f FF\n  Neg ?a # ?G \\<turnstile> FF \\<Longrightarrow> ?G \\<turnstile> ?a\n\ngoal (1 subgoal):\n 1. map (psubst f) G \\<turnstile> psubst f a", "by auto"], ["proof (state)\nthis:\n  map (psubst f) G \\<turnstile> psubst f a\n\ngoal (12 subgoals):\n 1. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a; G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (And a b)\n 2. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f a\n 3. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b\n 4. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Or a b)\n 5. \\<And>G b a f.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Or a b)\n 6. \\<And>G a b c f.\n       \\<lbrakk>G \\<turnstile> Or a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Or a b);\n        a # G \\<turnstile> c;\n        \\<And>f. map (psubst f) (a # G) \\<turnstile> psubst f c;\n        b # G \\<turnstile> c;\n        \\<And>f. map (psubst f) (b # G) \\<turnstile> psubst f c\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f c\n 7. \\<And>a G b f.\n       \\<lbrakk>a # G \\<turnstile> b;\n        \\<And>f. map (psubst f) (a # G) \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Impl a b)\n 8. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> Impl a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Impl a b);\n        G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b\n 9. \\<And>G a n f.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Forall a)\n 10. \\<And>G a t f.\n        \\<lbrakk>G \\<turnstile> Forall a;\n         \\<And>f. map (psubst f) G \\<turnstile> psubst f (Forall a)\\<rbrakk>\n        \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (a[t/0])\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a; G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (And a b)\n 2. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f a\n 3. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b\n 4. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Or a b)\n 5. \\<And>G b a f.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Or a b)\n 6. \\<And>G a b c f.\n       \\<lbrakk>G \\<turnstile> Or a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Or a b);\n        a # G \\<turnstile> c;\n        \\<And>f. map (psubst f) (a # G) \\<turnstile> psubst f c;\n        b # G \\<turnstile> c;\n        \\<And>f. map (psubst f) (b # G) \\<turnstile> psubst f c\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f c\n 7. \\<And>a G b f.\n       \\<lbrakk>a # G \\<turnstile> b;\n        \\<And>f. map (psubst f) (a # G) \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Impl a b)\n 8. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> Impl a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Impl a b);\n        G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b\n 9. \\<And>G a n f.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Forall a)\n 10. \\<And>G a t f.\n        \\<lbrakk>G \\<turnstile> Forall a;\n         \\<And>f. map (psubst f) G \\<turnstile> psubst f (Forall a)\\<rbrakk>\n        \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (a[t/0])\nA total of 12 subgoals...", "case (ImplE G a b)"], ["proof (state)\nthis:\n  G \\<turnstile> Impl a b\n  map (psubst ?f) G \\<turnstile> psubst ?f (Impl a b)\n  G \\<turnstile> a\n  map (psubst ?f) G \\<turnstile> psubst ?f a\n\ngoal (12 subgoals):\n 1. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a; G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (And a b)\n 2. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f a\n 3. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b\n 4. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Or a b)\n 5. \\<And>G b a f.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Or a b)\n 6. \\<And>G a b c f.\n       \\<lbrakk>G \\<turnstile> Or a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Or a b);\n        a # G \\<turnstile> c;\n        \\<And>f. map (psubst f) (a # G) \\<turnstile> psubst f c;\n        b # G \\<turnstile> c;\n        \\<And>f. map (psubst f) (b # G) \\<turnstile> psubst f c\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f c\n 7. \\<And>a G b f.\n       \\<lbrakk>a # G \\<turnstile> b;\n        \\<And>f. map (psubst f) (a # G) \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Impl a b)\n 8. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> Impl a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Impl a b);\n        G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b\n 9. \\<And>G a n f.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Forall a)\n 10. \\<And>G a t f.\n        \\<lbrakk>G \\<turnstile> Forall a;\n         \\<And>f. map (psubst f) G \\<turnstile> psubst f (Forall a)\\<rbrakk>\n        \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (a[t/0])\nA total of 12 subgoals...", "then"], ["proof (chain)\npicking this:\n  G \\<turnstile> Impl a b\n  map (psubst ?f) G \\<turnstile> psubst ?f (Impl a b)\n  G \\<turnstile> a\n  map (psubst ?f) G \\<turnstile> psubst ?f a", "have \\<open>map (psubst f) G \\<turnstile> Impl (psubst f a) (psubst f b)\\<close>\n    and \\<open>map (psubst f) G \\<turnstile> psubst f a\\<close>"], ["proof (prove)\nusing this:\n  G \\<turnstile> Impl a b\n  map (psubst ?f) G \\<turnstile> psubst ?f (Impl a b)\n  G \\<turnstile> a\n  map (psubst ?f) G \\<turnstile> psubst ?f a\n\ngoal (1 subgoal):\n 1. map (psubst f) G \\<turnstile> Impl (psubst f a) (psubst f b) &&&\n    map (psubst f) G \\<turnstile> psubst f a", "by simp_all"], ["proof (state)\nthis:\n  map (psubst f) G \\<turnstile> Impl (psubst f a) (psubst f b)\n  map (psubst f) G \\<turnstile> psubst f a\n\ngoal (12 subgoals):\n 1. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a; G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (And a b)\n 2. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f a\n 3. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b\n 4. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Or a b)\n 5. \\<And>G b a f.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Or a b)\n 6. \\<And>G a b c f.\n       \\<lbrakk>G \\<turnstile> Or a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Or a b);\n        a # G \\<turnstile> c;\n        \\<And>f. map (psubst f) (a # G) \\<turnstile> psubst f c;\n        b # G \\<turnstile> c;\n        \\<And>f. map (psubst f) (b # G) \\<turnstile> psubst f c\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f c\n 7. \\<And>a G b f.\n       \\<lbrakk>a # G \\<turnstile> b;\n        \\<And>f. map (psubst f) (a # G) \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Impl a b)\n 8. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> Impl a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Impl a b);\n        G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b\n 9. \\<And>G a n f.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Forall a)\n 10. \\<And>G a t f.\n        \\<lbrakk>G \\<turnstile> Forall a;\n         \\<And>f. map (psubst f) G \\<turnstile> psubst f (Forall a)\\<rbrakk>\n        \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (a[t/0])\nA total of 12 subgoals...", "then"], ["proof (chain)\npicking this:\n  map (psubst f) G \\<turnstile> Impl (psubst f a) (psubst f b)\n  map (psubst f) G \\<turnstile> psubst f a", "show ?case"], ["proof (prove)\nusing this:\n  map (psubst f) G \\<turnstile> Impl (psubst f a) (psubst f b)\n  map (psubst f) G \\<turnstile> psubst f a\n\ngoal (1 subgoal):\n 1. map (psubst f) G \\<turnstile> psubst f b", "using deriv.ImplE"], ["proof (prove)\nusing this:\n  map (psubst f) G \\<turnstile> Impl (psubst f a) (psubst f b)\n  map (psubst f) G \\<turnstile> psubst f a\n  \\<lbrakk>?G \\<turnstile> Impl ?a ?b; ?G \\<turnstile> ?a\\<rbrakk>\n  \\<Longrightarrow> ?G \\<turnstile> ?b\n\ngoal (1 subgoal):\n 1. map (psubst f) G \\<turnstile> psubst f b", "by blast"], ["proof (state)\nthis:\n  map (psubst f) G \\<turnstile> psubst f b\n\ngoal (11 subgoals):\n 1. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a; G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (And a b)\n 2. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f a\n 3. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b\n 4. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Or a b)\n 5. \\<And>G b a f.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Or a b)\n 6. \\<And>G a b c f.\n       \\<lbrakk>G \\<turnstile> Or a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Or a b);\n        a # G \\<turnstile> c;\n        \\<And>f. map (psubst f) (a # G) \\<turnstile> psubst f c;\n        b # G \\<turnstile> c;\n        \\<And>f. map (psubst f) (b # G) \\<turnstile> psubst f c\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f c\n 7. \\<And>a G b f.\n       \\<lbrakk>a # G \\<turnstile> b;\n        \\<And>f. map (psubst f) (a # G) \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Impl a b)\n 8. \\<And>G a n f.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Forall a)\n 9. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Forall a)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (a[t/0])\n 10. \\<And>G a t f.\n        \\<lbrakk>G \\<turnstile> a[t/0];\n         \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[t/0])\\<rbrakk>\n        \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Exists a)\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a; G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (And a b)\n 2. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f a\n 3. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b\n 4. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Or a b)\n 5. \\<And>G b a f.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Or a b)\n 6. \\<And>G a b c f.\n       \\<lbrakk>G \\<turnstile> Or a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Or a b);\n        a # G \\<turnstile> c;\n        \\<And>f. map (psubst f) (a # G) \\<turnstile> psubst f c;\n        b # G \\<turnstile> c;\n        \\<And>f. map (psubst f) (b # G) \\<turnstile> psubst f c\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f c\n 7. \\<And>a G b f.\n       \\<lbrakk>a # G \\<turnstile> b;\n        \\<And>f. map (psubst f) (a # G) \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Impl a b)\n 8. \\<And>G a n f.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Forall a)\n 9. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Forall a)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (a[t/0])\n 10. \\<And>G a t f.\n        \\<lbrakk>G \\<turnstile> a[t/0];\n         \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[t/0])\\<rbrakk>\n        \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Exists a)\nA total of 11 subgoals...", "case (ImplI G a b)"], ["proof (state)\nthis:\n  G # a \\<turnstile> b\n  map (psubst ?f) (G # a) \\<turnstile> psubst ?f b\n\ngoal (11 subgoals):\n 1. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a; G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (And a b)\n 2. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f a\n 3. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b\n 4. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Or a b)\n 5. \\<And>G b a f.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Or a b)\n 6. \\<And>G a b c f.\n       \\<lbrakk>G \\<turnstile> Or a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Or a b);\n        a # G \\<turnstile> c;\n        \\<And>f. map (psubst f) (a # G) \\<turnstile> psubst f c;\n        b # G \\<turnstile> c;\n        \\<And>f. map (psubst f) (b # G) \\<turnstile> psubst f c\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f c\n 7. \\<And>a G b f.\n       \\<lbrakk>a # G \\<turnstile> b;\n        \\<And>f. map (psubst f) (a # G) \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Impl a b)\n 8. \\<And>G a n f.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Forall a)\n 9. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Forall a)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (a[t/0])\n 10. \\<And>G a t f.\n        \\<lbrakk>G \\<turnstile> a[t/0];\n         \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[t/0])\\<rbrakk>\n        \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Exists a)\nA total of 11 subgoals...", "then"], ["proof (chain)\npicking this:\n  G # a \\<turnstile> b\n  map (psubst ?f) (G # a) \\<turnstile> psubst ?f b", "show ?case"], ["proof (prove)\nusing this:\n  G # a \\<turnstile> b\n  map (psubst ?f) (G # a) \\<turnstile> psubst ?f b\n\ngoal (1 subgoal):\n 1. map (psubst f) a \\<turnstile> psubst f (Impl G b)", "using deriv.ImplI"], ["proof (prove)\nusing this:\n  G # a \\<turnstile> b\n  map (psubst ?f) (G # a) \\<turnstile> psubst ?f b\n  ?a # ?G \\<turnstile> ?b \\<Longrightarrow> ?G \\<turnstile> Impl ?a ?b\n\ngoal (1 subgoal):\n 1. map (psubst f) a \\<turnstile> psubst f (Impl G b)", "by auto"], ["proof (state)\nthis:\n  map (psubst f) a \\<turnstile> psubst f (Impl G b)\n\ngoal (10 subgoals):\n 1. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a; G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (And a b)\n 2. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f a\n 3. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b\n 4. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Or a b)\n 5. \\<And>G b a f.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Or a b)\n 6. \\<And>G a b c f.\n       \\<lbrakk>G \\<turnstile> Or a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Or a b);\n        a # G \\<turnstile> c;\n        \\<And>f. map (psubst f) (a # G) \\<turnstile> psubst f c;\n        b # G \\<turnstile> c;\n        \\<And>f. map (psubst f) (b # G) \\<turnstile> psubst f c\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f c\n 7. \\<And>G a n f.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Forall a)\n 8. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Forall a)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (a[t/0])\n 9. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Exists a)\n 10. \\<And>G a n b f.\n        \\<lbrakk>G \\<turnstile> Exists a;\n         \\<And>f. map (psubst f) G \\<turnstile> psubst f (Exists a);\n         a[App n []/0] # G \\<turnstile> b;\n         \\<And>f.\n            map (psubst f) (a[App n []/0] # G) \\<turnstile> psubst f b;\n         news n G; new n a; new n b\\<rbrakk>\n        \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a; G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (And a b)\n 2. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f a\n 3. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b\n 4. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Or a b)\n 5. \\<And>G b a f.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Or a b)\n 6. \\<And>G a b c f.\n       \\<lbrakk>G \\<turnstile> Or a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Or a b);\n        a # G \\<turnstile> c;\n        \\<And>f. map (psubst f) (a # G) \\<turnstile> psubst f c;\n        b # G \\<turnstile> c;\n        \\<And>f. map (psubst f) (b # G) \\<turnstile> psubst f c\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f c\n 7. \\<And>G a n f.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Forall a)\n 8. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Forall a)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (a[t/0])\n 9. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Exists a)\n 10. \\<And>G a n b f.\n        \\<lbrakk>G \\<turnstile> Exists a;\n         \\<And>f. map (psubst f) G \\<turnstile> psubst f (Exists a);\n         a[App n []/0] # G \\<turnstile> b;\n         \\<And>f.\n            map (psubst f) (a[App n []/0] # G) \\<turnstile> psubst f b;\n         news n G; new n a; new n b\\<rbrakk>\n        \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b", "case (OrE G a b c)"], ["proof (state)\nthis:\n  G \\<turnstile> Or a b\n  map (psubst ?f) G \\<turnstile> psubst ?f (Or a b)\n  a # G \\<turnstile> c\n  map (psubst ?f) (a # G) \\<turnstile> psubst ?f c\n  b # G \\<turnstile> c\n  map (psubst ?f) (b # G) \\<turnstile> psubst ?f c\n\ngoal (10 subgoals):\n 1. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a; G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (And a b)\n 2. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f a\n 3. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b\n 4. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Or a b)\n 5. \\<And>G b a f.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Or a b)\n 6. \\<And>G a b c f.\n       \\<lbrakk>G \\<turnstile> Or a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Or a b);\n        a # G \\<turnstile> c;\n        \\<And>f. map (psubst f) (a # G) \\<turnstile> psubst f c;\n        b # G \\<turnstile> c;\n        \\<And>f. map (psubst f) (b # G) \\<turnstile> psubst f c\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f c\n 7. \\<And>G a n f.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Forall a)\n 8. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Forall a)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (a[t/0])\n 9. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Exists a)\n 10. \\<And>G a n b f.\n        \\<lbrakk>G \\<turnstile> Exists a;\n         \\<And>f. map (psubst f) G \\<turnstile> psubst f (Exists a);\n         a[App n []/0] # G \\<turnstile> b;\n         \\<And>f.\n            map (psubst f) (a[App n []/0] # G) \\<turnstile> psubst f b;\n         news n G; new n a; new n b\\<rbrakk>\n        \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b", "then"], ["proof (chain)\npicking this:\n  G \\<turnstile> Or a b\n  map (psubst ?f) G \\<turnstile> psubst ?f (Or a b)\n  a # G \\<turnstile> c\n  map (psubst ?f) (a # G) \\<turnstile> psubst ?f c\n  b # G \\<turnstile> c\n  map (psubst ?f) (b # G) \\<turnstile> psubst ?f c", "have \\<open>map (psubst f) G \\<turnstile> Or (psubst f a) (psubst f b)\\<close>\n    and \\<open>psubst f a # map (psubst f) G \\<turnstile> psubst f c\\<close>\n    and \\<open>psubst f b # map (psubst f) G \\<turnstile> psubst f c\\<close>"], ["proof (prove)\nusing this:\n  G \\<turnstile> Or a b\n  map (psubst ?f) G \\<turnstile> psubst ?f (Or a b)\n  a # G \\<turnstile> c\n  map (psubst ?f) (a # G) \\<turnstile> psubst ?f c\n  b # G \\<turnstile> c\n  map (psubst ?f) (b # G) \\<turnstile> psubst ?f c\n\ngoal (1 subgoal):\n 1. map (psubst f) G \\<turnstile> Or (psubst f a) (psubst f b) &&&\n    psubst f a # map (psubst f) G \\<turnstile> psubst f c &&&\n    psubst f b # map (psubst f) G \\<turnstile> psubst f c", "by simp_all"], ["proof (state)\nthis:\n  map (psubst f) G \\<turnstile> Or (psubst f a) (psubst f b)\n  psubst f a # map (psubst f) G \\<turnstile> psubst f c\n  psubst f b # map (psubst f) G \\<turnstile> psubst f c\n\ngoal (10 subgoals):\n 1. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a; G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (And a b)\n 2. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f a\n 3. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b\n 4. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Or a b)\n 5. \\<And>G b a f.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Or a b)\n 6. \\<And>G a b c f.\n       \\<lbrakk>G \\<turnstile> Or a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Or a b);\n        a # G \\<turnstile> c;\n        \\<And>f. map (psubst f) (a # G) \\<turnstile> psubst f c;\n        b # G \\<turnstile> c;\n        \\<And>f. map (psubst f) (b # G) \\<turnstile> psubst f c\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f c\n 7. \\<And>G a n f.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Forall a)\n 8. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Forall a)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (a[t/0])\n 9. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Exists a)\n 10. \\<And>G a n b f.\n        \\<lbrakk>G \\<turnstile> Exists a;\n         \\<And>f. map (psubst f) G \\<turnstile> psubst f (Exists a);\n         a[App n []/0] # G \\<turnstile> b;\n         \\<And>f.\n            map (psubst f) (a[App n []/0] # G) \\<turnstile> psubst f b;\n         news n G; new n a; new n b\\<rbrakk>\n        \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b", "then"], ["proof (chain)\npicking this:\n  map (psubst f) G \\<turnstile> Or (psubst f a) (psubst f b)\n  psubst f a # map (psubst f) G \\<turnstile> psubst f c\n  psubst f b # map (psubst f) G \\<turnstile> psubst f c", "show ?case"], ["proof (prove)\nusing this:\n  map (psubst f) G \\<turnstile> Or (psubst f a) (psubst f b)\n  psubst f a # map (psubst f) G \\<turnstile> psubst f c\n  psubst f b # map (psubst f) G \\<turnstile> psubst f c\n\ngoal (1 subgoal):\n 1. map (psubst f) G \\<turnstile> psubst f c", "using deriv.OrE"], ["proof (prove)\nusing this:\n  map (psubst f) G \\<turnstile> Or (psubst f a) (psubst f b)\n  psubst f a # map (psubst f) G \\<turnstile> psubst f c\n  psubst f b # map (psubst f) G \\<turnstile> psubst f c\n  \\<lbrakk>?G \\<turnstile> Or ?a ?b; ?a # ?G \\<turnstile> ?c;\n   ?b # ?G \\<turnstile> ?c\\<rbrakk>\n  \\<Longrightarrow> ?G \\<turnstile> ?c\n\ngoal (1 subgoal):\n 1. map (psubst f) G \\<turnstile> psubst f c", "by blast"], ["proof (state)\nthis:\n  map (psubst f) G \\<turnstile> psubst f c\n\ngoal (9 subgoals):\n 1. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a; G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (And a b)\n 2. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f a\n 3. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b\n 4. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Or a b)\n 5. \\<And>G b a f.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Or a b)\n 6. \\<And>G a n f.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Forall a)\n 7. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Forall a)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (a[t/0])\n 8. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Exists a)\n 9. \\<And>G a n b f.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Exists a);\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>f. map (psubst f) (a[App n []/0] # G) \\<turnstile> psubst f b;\n        news n G; new n a; new n b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a; G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (And a b)\n 2. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f a\n 3. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b\n 4. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Or a b)\n 5. \\<And>G b a f.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Or a b)\n 6. \\<And>G a n f.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Forall a)\n 7. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Forall a)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (a[t/0])\n 8. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Exists a)\n 9. \\<And>G a n b f.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Exists a);\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>f. map (psubst f) (a[App n []/0] # G) \\<turnstile> psubst f b;\n        news n G; new n a; new n b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b", "case (OrI1 G a b)"], ["proof (state)\nthis:\n  G \\<turnstile> a\n  map (psubst ?f) G \\<turnstile> psubst ?f a\n\ngoal (9 subgoals):\n 1. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a; G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (And a b)\n 2. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f a\n 3. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b\n 4. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Or a b)\n 5. \\<And>G b a f.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Or a b)\n 6. \\<And>G a n f.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Forall a)\n 7. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Forall a)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (a[t/0])\n 8. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Exists a)\n 9. \\<And>G a n b f.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Exists a);\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>f. map (psubst f) (a[App n []/0] # G) \\<turnstile> psubst f b;\n        news n G; new n a; new n b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b", "then"], ["proof (chain)\npicking this:\n  G \\<turnstile> a\n  map (psubst ?f) G \\<turnstile> psubst ?f a", "show ?case"], ["proof (prove)\nusing this:\n  G \\<turnstile> a\n  map (psubst ?f) G \\<turnstile> psubst ?f a\n\ngoal (1 subgoal):\n 1. map (psubst f) G \\<turnstile> psubst f (Or a b)", "using deriv.OrI1"], ["proof (prove)\nusing this:\n  G \\<turnstile> a\n  map (psubst ?f) G \\<turnstile> psubst ?f a\n  ?G \\<turnstile> ?a \\<Longrightarrow> ?G \\<turnstile> Or ?a ?b\n\ngoal (1 subgoal):\n 1. map (psubst f) G \\<turnstile> psubst f (Or a b)", "by auto"], ["proof (state)\nthis:\n  map (psubst f) G \\<turnstile> psubst f (Or a b)\n\ngoal (8 subgoals):\n 1. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a; G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (And a b)\n 2. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f a\n 3. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b\n 4. \\<And>G b a f.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Or a b)\n 5. \\<And>G a n f.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Forall a)\n 6. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Forall a)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (a[t/0])\n 7. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Exists a)\n 8. \\<And>G a n b f.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Exists a);\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>f. map (psubst f) (a[App n []/0] # G) \\<turnstile> psubst f b;\n        news n G; new n a; new n b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a; G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (And a b)\n 2. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f a\n 3. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b\n 4. \\<And>G b a f.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Or a b)\n 5. \\<And>G a n f.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Forall a)\n 6. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Forall a)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (a[t/0])\n 7. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Exists a)\n 8. \\<And>G a n b f.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Exists a);\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>f. map (psubst f) (a[App n []/0] # G) \\<turnstile> psubst f b;\n        news n G; new n a; new n b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b", "case (OrI2 G a b)"], ["proof (state)\nthis:\n  G \\<turnstile> a\n  map (psubst ?f) G \\<turnstile> psubst ?f a\n\ngoal (8 subgoals):\n 1. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a; G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (And a b)\n 2. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f a\n 3. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b\n 4. \\<And>G b a f.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Or a b)\n 5. \\<And>G a n f.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Forall a)\n 6. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Forall a)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (a[t/0])\n 7. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Exists a)\n 8. \\<And>G a n b f.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Exists a);\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>f. map (psubst f) (a[App n []/0] # G) \\<turnstile> psubst f b;\n        news n G; new n a; new n b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b", "then"], ["proof (chain)\npicking this:\n  G \\<turnstile> a\n  map (psubst ?f) G \\<turnstile> psubst ?f a", "show ?case"], ["proof (prove)\nusing this:\n  G \\<turnstile> a\n  map (psubst ?f) G \\<turnstile> psubst ?f a\n\ngoal (1 subgoal):\n 1. map (psubst f) G \\<turnstile> psubst f (Or b a)", "using deriv.OrI2"], ["proof (prove)\nusing this:\n  G \\<turnstile> a\n  map (psubst ?f) G \\<turnstile> psubst ?f a\n  ?G \\<turnstile> ?b \\<Longrightarrow> ?G \\<turnstile> Or ?a ?b\n\ngoal (1 subgoal):\n 1. map (psubst f) G \\<turnstile> psubst f (Or b a)", "by auto"], ["proof (state)\nthis:\n  map (psubst f) G \\<turnstile> psubst f (Or b a)\n\ngoal (7 subgoals):\n 1. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a; G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (And a b)\n 2. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f a\n 3. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b\n 4. \\<And>G a n f.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Forall a)\n 5. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Forall a)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (a[t/0])\n 6. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Exists a)\n 7. \\<And>G a n b f.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Exists a);\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>f. map (psubst f) (a[App n []/0] # G) \\<turnstile> psubst f b;\n        news n G; new n a; new n b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a; G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (And a b)\n 2. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f a\n 3. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b\n 4. \\<And>G a n f.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Forall a)\n 5. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Forall a)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (a[t/0])\n 6. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Exists a)\n 7. \\<And>G a n b f.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Exists a);\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>f. map (psubst f) (a[App n []/0] # G) \\<turnstile> psubst f b;\n        news n G; new n a; new n b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b", "case (AndE1 G a b)"], ["proof (state)\nthis:\n  G \\<turnstile> And a b\n  map (psubst ?f) G \\<turnstile> psubst ?f (And a b)\n\ngoal (7 subgoals):\n 1. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a; G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (And a b)\n 2. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f a\n 3. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b\n 4. \\<And>G a n f.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Forall a)\n 5. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Forall a)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (a[t/0])\n 6. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Exists a)\n 7. \\<And>G a n b f.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Exists a);\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>f. map (psubst f) (a[App n []/0] # G) \\<turnstile> psubst f b;\n        news n G; new n a; new n b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b", "then"], ["proof (chain)\npicking this:\n  G \\<turnstile> And a b\n  map (psubst ?f) G \\<turnstile> psubst ?f (And a b)", "show ?case"], ["proof (prove)\nusing this:\n  G \\<turnstile> And a b\n  map (psubst ?f) G \\<turnstile> psubst ?f (And a b)\n\ngoal (1 subgoal):\n 1. map (psubst f) G \\<turnstile> psubst f a", "using deriv.AndE1"], ["proof (prove)\nusing this:\n  G \\<turnstile> And a b\n  map (psubst ?f) G \\<turnstile> psubst ?f (And a b)\n  ?G \\<turnstile> And ?a ?b \\<Longrightarrow> ?G \\<turnstile> ?a\n\ngoal (1 subgoal):\n 1. map (psubst f) G \\<turnstile> psubst f a", "by auto"], ["proof (state)\nthis:\n  map (psubst f) G \\<turnstile> psubst f a\n\ngoal (6 subgoals):\n 1. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a; G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (And a b)\n 2. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b\n 3. \\<And>G a n f.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Forall a)\n 4. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Forall a)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (a[t/0])\n 5. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Exists a)\n 6. \\<And>G a n b f.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Exists a);\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>f. map (psubst f) (a[App n []/0] # G) \\<turnstile> psubst f b;\n        news n G; new n a; new n b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a; G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (And a b)\n 2. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b\n 3. \\<And>G a n f.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Forall a)\n 4. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Forall a)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (a[t/0])\n 5. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Exists a)\n 6. \\<And>G a n b f.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Exists a);\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>f. map (psubst f) (a[App n []/0] # G) \\<turnstile> psubst f b;\n        news n G; new n a; new n b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b", "case (AndE2 p q z)"], ["proof (state)\nthis:\n  p \\<turnstile> And q z\n  map (psubst ?f) p \\<turnstile> psubst ?f (And q z)\n\ngoal (6 subgoals):\n 1. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a; G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (And a b)\n 2. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (And a b)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b\n 3. \\<And>G a n f.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Forall a)\n 4. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Forall a)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (a[t/0])\n 5. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Exists a)\n 6. \\<And>G a n b f.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Exists a);\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>f. map (psubst f) (a[App n []/0] # G) \\<turnstile> psubst f b;\n        news n G; new n a; new n b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b", "then"], ["proof (chain)\npicking this:\n  p \\<turnstile> And q z\n  map (psubst ?f) p \\<turnstile> psubst ?f (And q z)", "show ?case"], ["proof (prove)\nusing this:\n  p \\<turnstile> And q z\n  map (psubst ?f) p \\<turnstile> psubst ?f (And q z)\n\ngoal (1 subgoal):\n 1. map (psubst f) p \\<turnstile> psubst f z", "using deriv.AndE2"], ["proof (prove)\nusing this:\n  p \\<turnstile> And q z\n  map (psubst ?f) p \\<turnstile> psubst ?f (And q z)\n  ?G \\<turnstile> And ?a ?b \\<Longrightarrow> ?G \\<turnstile> ?b\n\ngoal (1 subgoal):\n 1. map (psubst f) p \\<turnstile> psubst f z", "by auto"], ["proof (state)\nthis:\n  map (psubst f) p \\<turnstile> psubst f z\n\ngoal (5 subgoals):\n 1. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a; G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (And a b)\n 2. \\<And>G a n f.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Forall a)\n 3. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Forall a)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (a[t/0])\n 4. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Exists a)\n 5. \\<And>G a n b f.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Exists a);\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>f. map (psubst f) (a[App n []/0] # G) \\<turnstile> psubst f b;\n        news n G; new n a; new n b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a; G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (And a b)\n 2. \\<And>G a n f.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Forall a)\n 3. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Forall a)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (a[t/0])\n 4. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Exists a)\n 5. \\<And>G a n b f.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Exists a);\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>f. map (psubst f) (a[App n []/0] # G) \\<turnstile> psubst f b;\n        news n G; new n a; new n b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b", "case (AndI G a b)"], ["proof (state)\nthis:\n  G \\<turnstile> a\n  map (psubst ?f) G \\<turnstile> psubst ?f a\n  G \\<turnstile> b\n  map (psubst ?f) G \\<turnstile> psubst ?f b\n\ngoal (5 subgoals):\n 1. \\<And>G a b f.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f a; G \\<turnstile> b;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (And a b)\n 2. \\<And>G a n f.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Forall a)\n 3. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Forall a)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (a[t/0])\n 4. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Exists a)\n 5. \\<And>G a n b f.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Exists a);\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>f. map (psubst f) (a[App n []/0] # G) \\<turnstile> psubst f b;\n        news n G; new n a; new n b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b", "then"], ["proof (chain)\npicking this:\n  G \\<turnstile> a\n  map (psubst ?f) G \\<turnstile> psubst ?f a\n  G \\<turnstile> b\n  map (psubst ?f) G \\<turnstile> psubst ?f b", "show ?case"], ["proof (prove)\nusing this:\n  G \\<turnstile> a\n  map (psubst ?f) G \\<turnstile> psubst ?f a\n  G \\<turnstile> b\n  map (psubst ?f) G \\<turnstile> psubst ?f b\n\ngoal (1 subgoal):\n 1. map (psubst f) G \\<turnstile> psubst f (And a b)", "using deriv.AndI"], ["proof (prove)\nusing this:\n  G \\<turnstile> a\n  map (psubst ?f) G \\<turnstile> psubst ?f a\n  G \\<turnstile> b\n  map (psubst ?f) G \\<turnstile> psubst ?f b\n  \\<lbrakk>?G \\<turnstile> ?a; ?G \\<turnstile> ?b\\<rbrakk>\n  \\<Longrightarrow> ?G \\<turnstile> And ?a ?b\n\ngoal (1 subgoal):\n 1. map (psubst f) G \\<turnstile> psubst f (And a b)", "by fastforce"], ["proof (state)\nthis:\n  map (psubst f) G \\<turnstile> psubst f (And a b)\n\ngoal (4 subgoals):\n 1. \\<And>G a n f.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Forall a)\n 2. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Forall a)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (a[t/0])\n 3. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Exists a)\n 4. \\<And>G a n b f.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Exists a);\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>f. map (psubst f) (a[App n []/0] # G) \\<turnstile> psubst f b;\n        news n G; new n a; new n b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>G a n f.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Forall a)\n 2. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Forall a)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (a[t/0])\n 3. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Exists a)\n 4. \\<And>G a n b f.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Exists a);\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>f. map (psubst f) (a[App n []/0] # G) \\<turnstile> psubst f b;\n        news n G; new n a; new n b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b", "case (ExistsE z p c q)"], ["proof (state)\nthis:\n  z \\<turnstile> Exists p\n  map (psubst ?f) z \\<turnstile> psubst ?f (Exists p)\n  p[App c []/0] # z \\<turnstile> q\n  map (psubst ?f) (p[App c []/0] # z) \\<turnstile> psubst ?f q\n  news c z\n  new c p\n  new c q\n\ngoal (4 subgoals):\n 1. \\<And>G a n f.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Forall a)\n 2. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Forall a)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (a[t/0])\n 3. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Exists a)\n 4. \\<And>G a n b f.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Exists a);\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>f. map (psubst f) (a[App n []/0] # G) \\<turnstile> psubst f b;\n        news n G; new n a; new n b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b", "let ?params = \\<open>params p \\<union> params q \\<union> (\\<Union>p \\<in> set z. params p)\\<close>"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>G a n f.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Forall a)\n 2. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Forall a)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (a[t/0])\n 3. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Exists a)\n 4. \\<And>G a n b f.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Exists a);\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>f. map (psubst f) (a[App n []/0] # G) \\<turnstile> psubst f b;\n        news n G; new n a; new n b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b", "have \\<open>finite ?params\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (params p \\<union> params q \\<union> \\<Union> (params ` set z))", "by simp"], ["proof (state)\nthis:\n  finite (params p \\<union> params q \\<union> \\<Union> (params ` set z))\n\ngoal (4 subgoals):\n 1. \\<And>G a n f.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Forall a)\n 2. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Forall a)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (a[t/0])\n 3. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Exists a)\n 4. \\<And>G a n b f.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Exists a);\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>f. map (psubst f) (a[App n []/0] # G) \\<turnstile> psubst f b;\n        news n G; new n a; new n b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b", "then"], ["proof (chain)\npicking this:\n  finite (params p \\<union> params q \\<union> \\<Union> (params ` set z))", "obtain fresh where *: \\<open>fresh \\<notin> ?params \\<union> {c} \\<union> image f ?params\\<close>"], ["proof (prove)\nusing this:\n  finite (params p \\<union> params q \\<union> \\<Union> (params ` set z))\n\ngoal (1 subgoal):\n 1. (\\<And>fresh.\n        fresh\n        \\<notin> params p \\<union> params q \\<union>\n                 \\<Union> (params ` set z) \\<union>\n                 {c} \\<union>\n                 f `\n                 (params p \\<union> params q \\<union>\n                  \\<Union> (params ` set z)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using ex_new_if_finite inf_params"], ["proof (prove)\nusing this:\n  finite (params p \\<union> params q \\<union> \\<Union> (params ` set z))\n  \\<lbrakk>infinite UNIV; finite ?A\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a. a \\<notin> ?A\n  infinite UNIV\n\ngoal (1 subgoal):\n 1. (\\<And>fresh.\n        fresh\n        \\<notin> params p \\<union> params q \\<union>\n                 \\<Union> (params ` set z) \\<union>\n                 {c} \\<union>\n                 f `\n                 (params p \\<union> params q \\<union>\n                  \\<Union> (params ` set z)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis finite.emptyI finite.insertI finite_UnI finite_imageI)"], ["proof (state)\nthis:\n  fresh\n  \\<notin> params p \\<union> params q \\<union>\n           \\<Union> (params ` set z) \\<union>\n           {c} \\<union>\n           f `\n           (params p \\<union> params q \\<union> \\<Union> (params ` set z))\n\ngoal (4 subgoals):\n 1. \\<And>G a n f.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Forall a)\n 2. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Forall a)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (a[t/0])\n 3. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Exists a)\n 4. \\<And>G a n b f.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Exists a);\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>f. map (psubst f) (a[App n []/0] # G) \\<turnstile> psubst f b;\n        news n G; new n a; new n b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b", "let ?f = \\<open>f(c := fresh)\\<close>"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>G a n f.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Forall a)\n 2. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Forall a)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (a[t/0])\n 3. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Exists a)\n 4. \\<And>G a n b f.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Exists a);\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>f. map (psubst f) (a[App n []/0] # G) \\<turnstile> psubst f b;\n        news n G; new n a; new n b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b", "have \\<open>news c (p # q # z)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. news c (p # q # z)", "using ExistsE"], ["proof (prove)\nusing this:\n  z \\<turnstile> Exists p\n  map (psubst ?f) z \\<turnstile> psubst ?f (Exists p)\n  p[App c []/0] # z \\<turnstile> q\n  map (psubst ?f) (p[App c []/0] # z) \\<turnstile> psubst ?f q\n  news c z\n  new c p\n  new c q\n\ngoal (1 subgoal):\n 1. news c (p # q # z)", "by simp"], ["proof (state)\nthis:\n  news c (p # q # z)\n\ngoal (4 subgoals):\n 1. \\<And>G a n f.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Forall a)\n 2. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Forall a)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (a[t/0])\n 3. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Exists a)\n 4. \\<And>G a n b f.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Exists a);\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>f. map (psubst f) (a[App n []/0] # G) \\<turnstile> psubst f b;\n        news n G; new n a; new n b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b", "then"], ["proof (chain)\npicking this:\n  news c (p # q # z)", "have \\<open>new fresh (psubst ?f p)\\<close> \\<open>new fresh (psubst ?f q)\\<close> \\<open>news fresh (map (psubst ?f) z)\\<close>"], ["proof (prove)\nusing this:\n  news c (p # q # z)\n\ngoal (1 subgoal):\n 1. new fresh (psubst (f(c := fresh)) p) &&&\n    new fresh (psubst (f(c := fresh)) q) &&&\n    news fresh (map (psubst (f(c := fresh))) z)", "using * new_psubst_image news_psubst"], ["proof (prove)\nusing this:\n  news c (p # q # z)\n  fresh\n  \\<notin> params p \\<union> params q \\<union>\n           \\<Union> (params ` set z) \\<union>\n           {c} \\<union>\n           f `\n           (params p \\<union> params q \\<union> \\<Union> (params ` set z))\n  \\<lbrakk>new ?c ?p; ?d \\<notin> ?f ` params ?p\\<rbrakk>\n  \\<Longrightarrow> new ?d (psubst (?f(?c := ?d)) ?p)\n  \\<lbrakk>news ?c ?z; ?d \\<notin> ?f ` \\<Union> (params ` set ?z)\\<rbrakk>\n  \\<Longrightarrow> news ?d (map (psubst (?f(?c := ?d))) ?z)\n\ngoal (1 subgoal):\n 1. new fresh (psubst (f(c := fresh)) p) &&&\n    new fresh (psubst (f(c := fresh)) q) &&&\n    news fresh (map (psubst (f(c := fresh))) z)", "by (fastforce simp add: image_Un)+"], ["proof (state)\nthis:\n  new fresh (psubst (f(c := fresh)) p)\n  new fresh (psubst (f(c := fresh)) q)\n  news fresh (map (psubst (f(c := fresh))) z)\n\ngoal (4 subgoals):\n 1. \\<And>G a n f.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Forall a)\n 2. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Forall a)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (a[t/0])\n 3. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Exists a)\n 4. \\<And>G a n b f.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Exists a);\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>f. map (psubst f) (a[App n []/0] # G) \\<turnstile> psubst f b;\n        news n G; new n a; new n b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b", "then"], ["proof (chain)\npicking this:\n  new fresh (psubst (f(c := fresh)) p)\n  new fresh (psubst (f(c := fresh)) q)\n  news fresh (map (psubst (f(c := fresh))) z)", "have \\<open>map (psubst ?f) z = map (psubst f) z\\<close>"], ["proof (prove)\nusing this:\n  new fresh (psubst (f(c := fresh)) p)\n  new fresh (psubst (f(c := fresh)) q)\n  news fresh (map (psubst (f(c := fresh))) z)\n\ngoal (1 subgoal):\n 1. map (psubst (f(c := fresh))) z = map (psubst f) z", "using ExistsE"], ["proof (prove)\nusing this:\n  new fresh (psubst (f(c := fresh)) p)\n  new fresh (psubst (f(c := fresh)) q)\n  news fresh (map (psubst (f(c := fresh))) z)\n  z \\<turnstile> Exists p\n  map (psubst ?f) z \\<turnstile> psubst ?f (Exists p)\n  p[App c []/0] # z \\<turnstile> q\n  map (psubst ?f) (p[App c []/0] # z) \\<turnstile> psubst ?f q\n  news c z\n  new c p\n  new c q\n\ngoal (1 subgoal):\n 1. map (psubst (f(c := fresh))) z = map (psubst f) z", "by (metis (mono_tags, lifting) Ball_set map_eq_conv psubst_upd)"], ["proof (state)\nthis:\n  map (psubst (f(c := fresh))) z = map (psubst f) z\n\ngoal (4 subgoals):\n 1. \\<And>G a n f.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Forall a)\n 2. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Forall a)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (a[t/0])\n 3. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Exists a)\n 4. \\<And>G a n b f.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Exists a);\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>f. map (psubst f) (a[App n []/0] # G) \\<turnstile> psubst f b;\n        news n G; new n a; new n b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b", "have \\<open>map (psubst ?f) z \\<turnstile> psubst ?f (Exists p)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (psubst (f(c := fresh)))\n     z \\<turnstile> psubst (f(c := fresh)) (Exists p)", "using ExistsE"], ["proof (prove)\nusing this:\n  z \\<turnstile> Exists p\n  map (psubst ?f) z \\<turnstile> psubst ?f (Exists p)\n  p[App c []/0] # z \\<turnstile> q\n  map (psubst ?f) (p[App c []/0] # z) \\<turnstile> psubst ?f q\n  news c z\n  new c p\n  new c q\n\ngoal (1 subgoal):\n 1. map (psubst (f(c := fresh)))\n     z \\<turnstile> psubst (f(c := fresh)) (Exists p)", "by blast"], ["proof (state)\nthis:\n  map (psubst (f(c := fresh)))\n   z \\<turnstile> psubst (f(c := fresh)) (Exists p)\n\ngoal (4 subgoals):\n 1. \\<And>G a n f.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Forall a)\n 2. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Forall a)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (a[t/0])\n 3. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Exists a)\n 4. \\<And>G a n b f.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Exists a);\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>f. map (psubst f) (a[App n []/0] # G) \\<turnstile> psubst f b;\n        news n G; new n a; new n b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b", "then"], ["proof (chain)\npicking this:\n  map (psubst (f(c := fresh)))\n   z \\<turnstile> psubst (f(c := fresh)) (Exists p)", "have \\<open>map (psubst ?f) z \\<turnstile> Exists (psubst ?f p)\\<close>"], ["proof (prove)\nusing this:\n  map (psubst (f(c := fresh)))\n   z \\<turnstile> psubst (f(c := fresh)) (Exists p)\n\ngoal (1 subgoal):\n 1. map (psubst (f(c := fresh)))\n     z \\<turnstile> Exists (psubst (f(c := fresh)) p)", "by simp"], ["proof (state)\nthis:\n  map (psubst (f(c := fresh)))\n   z \\<turnstile> Exists (psubst (f(c := fresh)) p)\n\ngoal (4 subgoals):\n 1. \\<And>G a n f.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Forall a)\n 2. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Forall a)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (a[t/0])\n 3. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Exists a)\n 4. \\<And>G a n b f.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Exists a);\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>f. map (psubst f) (a[App n []/0] # G) \\<turnstile> psubst f b;\n        news n G; new n a; new n b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b", "moreover"], ["proof (state)\nthis:\n  map (psubst (f(c := fresh)))\n   z \\<turnstile> Exists (psubst (f(c := fresh)) p)\n\ngoal (4 subgoals):\n 1. \\<And>G a n f.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Forall a)\n 2. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Forall a)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (a[t/0])\n 3. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Exists a)\n 4. \\<And>G a n b f.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Exists a);\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>f. map (psubst f) (a[App n []/0] # G) \\<turnstile> psubst f b;\n        news n G; new n a; new n b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b", "have \\<open>map (psubst ?f) (subst p (App c []) 0 # z) \\<turnstile> psubst ?f q\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (psubst (f(c := fresh)))\n     (p[App c []/0] # z) \\<turnstile> psubst (f(c := fresh)) q", "using ExistsE"], ["proof (prove)\nusing this:\n  z \\<turnstile> Exists p\n  map (psubst ?f) z \\<turnstile> psubst ?f (Exists p)\n  p[App c []/0] # z \\<turnstile> q\n  map (psubst ?f) (p[App c []/0] # z) \\<turnstile> psubst ?f q\n  news c z\n  new c p\n  new c q\n\ngoal (1 subgoal):\n 1. map (psubst (f(c := fresh)))\n     (p[App c []/0] # z) \\<turnstile> psubst (f(c := fresh)) q", "by blast"], ["proof (state)\nthis:\n  map (psubst (f(c := fresh)))\n   (p[App c []/0] # z) \\<turnstile> psubst (f(c := fresh)) q\n\ngoal (4 subgoals):\n 1. \\<And>G a n f.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Forall a)\n 2. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Forall a)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (a[t/0])\n 3. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Exists a)\n 4. \\<And>G a n b f.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Exists a);\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>f. map (psubst f) (a[App n []/0] # G) \\<turnstile> psubst f b;\n        news n G; new n a; new n b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b", "then"], ["proof (chain)\npicking this:\n  map (psubst (f(c := fresh)))\n   (p[App c []/0] # z) \\<turnstile> psubst (f(c := fresh)) q", "have \\<open>subst (psubst ?f p) (App fresh []) 0 # map (psubst ?f) z \\<turnstile> psubst ?f q\\<close>"], ["proof (prove)\nusing this:\n  map (psubst (f(c := fresh)))\n   (p[App c []/0] # z) \\<turnstile> psubst (f(c := fresh)) q\n\ngoal (1 subgoal):\n 1. psubst (f(c := fresh)) p[App fresh []/0] #\n    map (psubst (f(c := fresh))) z \\<turnstile> psubst (f(c := fresh)) q", "by simp"], ["proof (state)\nthis:\n  psubst (f(c := fresh)) p[App fresh []/0] #\n  map (psubst (f(c := fresh))) z \\<turnstile> psubst (f(c := fresh)) q\n\ngoal (4 subgoals):\n 1. \\<And>G a n f.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Forall a)\n 2. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Forall a)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (a[t/0])\n 3. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Exists a)\n 4. \\<And>G a n b f.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Exists a);\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>f. map (psubst f) (a[App n []/0] # G) \\<turnstile> psubst f b;\n        news n G; new n a; new n b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b", "moreover"], ["proof (state)\nthis:\n  psubst (f(c := fresh)) p[App fresh []/0] #\n  map (psubst (f(c := fresh))) z \\<turnstile> psubst (f(c := fresh)) q\n\ngoal (4 subgoals):\n 1. \\<And>G a n f.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Forall a)\n 2. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Forall a)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (a[t/0])\n 3. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Exists a)\n 4. \\<And>G a n b f.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Exists a);\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>f. map (psubst f) (a[App n []/0] # G) \\<turnstile> psubst f b;\n        news n G; new n a; new n b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b", "have \\<open>news fresh (map (psubst ?f) (p # q # z))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. news fresh (map (psubst (f(c := fresh))) (p # q # z))", "using \\<open>new fresh (psubst ?f p)\\<close> \\<open>new fresh (psubst ?f q)\\<close> \\<open>news fresh (map (psubst ?f) z)\\<close>"], ["proof (prove)\nusing this:\n  new fresh (psubst (f(c := fresh)) p)\n  new fresh (psubst (f(c := fresh)) q)\n  news fresh (map (psubst (f(c := fresh))) z)\n\ngoal (1 subgoal):\n 1. news fresh (map (psubst (f(c := fresh))) (p # q # z))", "by simp"], ["proof (state)\nthis:\n  news fresh (map (psubst (f(c := fresh))) (p # q # z))\n\ngoal (4 subgoals):\n 1. \\<And>G a n f.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Forall a)\n 2. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Forall a)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (a[t/0])\n 3. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Exists a)\n 4. \\<And>G a n b f.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Exists a);\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>f. map (psubst f) (a[App n []/0] # G) \\<turnstile> psubst f b;\n        news n G; new n a; new n b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b", "then"], ["proof (chain)\npicking this:\n  news fresh (map (psubst (f(c := fresh))) (p # q # z))", "have \\<open>new fresh (psubst ?f p)\\<close> \\<open>new fresh (psubst ?f q)\\<close> \\<open>news fresh (map (psubst ?f) z)\\<close>"], ["proof (prove)\nusing this:\n  news fresh (map (psubst (f(c := fresh))) (p # q # z))\n\ngoal (1 subgoal):\n 1. new fresh (psubst (f(c := fresh)) p) &&&\n    new fresh (psubst (f(c := fresh)) q) &&&\n    news fresh (map (psubst (f(c := fresh))) z)", "by simp_all"], ["proof (state)\nthis:\n  new fresh (psubst (f(c := fresh)) p)\n  new fresh (psubst (f(c := fresh)) q)\n  news fresh (map (psubst (f(c := fresh))) z)\n\ngoal (4 subgoals):\n 1. \\<And>G a n f.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Forall a)\n 2. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Forall a)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (a[t/0])\n 3. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Exists a)\n 4. \\<And>G a n b f.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Exists a);\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>f. map (psubst f) (a[App n []/0] # G) \\<turnstile> psubst f b;\n        news n G; new n a; new n b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b", "ultimately"], ["proof (chain)\npicking this:\n  map (psubst (f(c := fresh)))\n   z \\<turnstile> Exists (psubst (f(c := fresh)) p)\n  psubst (f(c := fresh)) p[App fresh []/0] #\n  map (psubst (f(c := fresh))) z \\<turnstile> psubst (f(c := fresh)) q\n  new fresh (psubst (f(c := fresh)) p)\n  new fresh (psubst (f(c := fresh)) q)\n  news fresh (map (psubst (f(c := fresh))) z)", "have \\<open>map (psubst ?f) z \\<turnstile> psubst ?f q\\<close>"], ["proof (prove)\nusing this:\n  map (psubst (f(c := fresh)))\n   z \\<turnstile> Exists (psubst (f(c := fresh)) p)\n  psubst (f(c := fresh)) p[App fresh []/0] #\n  map (psubst (f(c := fresh))) z \\<turnstile> psubst (f(c := fresh)) q\n  new fresh (psubst (f(c := fresh)) p)\n  new fresh (psubst (f(c := fresh)) q)\n  news fresh (map (psubst (f(c := fresh))) z)\n\ngoal (1 subgoal):\n 1. map (psubst (f(c := fresh))) z \\<turnstile> psubst (f(c := fresh)) q", "using deriv.ExistsE"], ["proof (prove)\nusing this:\n  map (psubst (f(c := fresh)))\n   z \\<turnstile> Exists (psubst (f(c := fresh)) p)\n  psubst (f(c := fresh)) p[App fresh []/0] #\n  map (psubst (f(c := fresh))) z \\<turnstile> psubst (f(c := fresh)) q\n  new fresh (psubst (f(c := fresh)) p)\n  new fresh (psubst (f(c := fresh)) q)\n  news fresh (map (psubst (f(c := fresh))) z)\n  \\<lbrakk>?G \\<turnstile> Exists ?a; ?a[App ?n []/0] # ?G \\<turnstile> ?b;\n   news ?n ?G; new ?n ?a; new ?n ?b\\<rbrakk>\n  \\<Longrightarrow> ?G \\<turnstile> ?b\n\ngoal (1 subgoal):\n 1. map (psubst (f(c := fresh))) z \\<turnstile> psubst (f(c := fresh)) q", "by metis"], ["proof (state)\nthis:\n  map (psubst (f(c := fresh))) z \\<turnstile> psubst (f(c := fresh)) q\n\ngoal (4 subgoals):\n 1. \\<And>G a n f.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Forall a)\n 2. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Forall a)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (a[t/0])\n 3. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Exists a)\n 4. \\<And>G a n b f.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Exists a);\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>f. map (psubst f) (a[App n []/0] # G) \\<turnstile> psubst f b;\n        news n G; new n a; new n b\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f b", "then"], ["proof (chain)\npicking this:\n  map (psubst (f(c := fresh))) z \\<turnstile> psubst (f(c := fresh)) q", "show ?case"], ["proof (prove)\nusing this:\n  map (psubst (f(c := fresh))) z \\<turnstile> psubst (f(c := fresh)) q\n\ngoal (1 subgoal):\n 1. map (psubst f) z \\<turnstile> psubst f q", "using ExistsE \\<open>map (psubst ?f) z = map (psubst f) z\\<close>"], ["proof (prove)\nusing this:\n  map (psubst (f(c := fresh))) z \\<turnstile> psubst (f(c := fresh)) q\n  z \\<turnstile> Exists p\n  map (psubst ?f) z \\<turnstile> psubst ?f (Exists p)\n  p[App c []/0] # z \\<turnstile> q\n  map (psubst ?f) (p[App c []/0] # z) \\<turnstile> psubst ?f q\n  news c z\n  new c p\n  new c q\n  map (psubst (f(c := fresh))) z = map (psubst f) z\n\ngoal (1 subgoal):\n 1. map (psubst f) z \\<turnstile> psubst f q", "by simp"], ["proof (state)\nthis:\n  map (psubst f) z \\<turnstile> psubst f q\n\ngoal (3 subgoals):\n 1. \\<And>G a n f.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Forall a)\n 2. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Forall a)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (a[t/0])\n 3. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Exists a)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>G a n f.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Forall a)\n 2. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Forall a)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (a[t/0])\n 3. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Exists a)", "case (ExistsI z p t)"], ["proof (state)\nthis:\n  z \\<turnstile> p[t/0]\n  map (psubst ?f) z \\<turnstile> psubst ?f (p[t/0])\n\ngoal (3 subgoals):\n 1. \\<And>G a n f.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Forall a)\n 2. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Forall a)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (a[t/0])\n 3. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Exists a)", "then"], ["proof (chain)\npicking this:\n  z \\<turnstile> p[t/0]\n  map (psubst ?f) z \\<turnstile> psubst ?f (p[t/0])", "show ?case"], ["proof (prove)\nusing this:\n  z \\<turnstile> p[t/0]\n  map (psubst ?f) z \\<turnstile> psubst ?f (p[t/0])\n\ngoal (1 subgoal):\n 1. map (psubst f) z \\<turnstile> psubst f (Exists p)", "using deriv.ExistsI"], ["proof (prove)\nusing this:\n  z \\<turnstile> p[t/0]\n  map (psubst ?f) z \\<turnstile> psubst ?f (p[t/0])\n  ?G \\<turnstile> ?a[?t/0] \\<Longrightarrow> ?G \\<turnstile> Exists ?a\n\ngoal (1 subgoal):\n 1. map (psubst f) z \\<turnstile> psubst f (Exists p)", "by auto"], ["proof (state)\nthis:\n  map (psubst f) z \\<turnstile> psubst f (Exists p)\n\ngoal (2 subgoals):\n 1. \\<And>G a n f.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Forall a)\n 2. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Forall a)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (a[t/0])", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>G a n f.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Forall a)\n 2. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Forall a)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (a[t/0])", "case (ForallE z p t)"], ["proof (state)\nthis:\n  z \\<turnstile> Forall p\n  map (psubst ?f) z \\<turnstile> psubst ?f (Forall p)\n\ngoal (2 subgoals):\n 1. \\<And>G a n f.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Forall a)\n 2. \\<And>G a t f.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (Forall a)\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (a[t/0])", "then"], ["proof (chain)\npicking this:\n  z \\<turnstile> Forall p\n  map (psubst ?f) z \\<turnstile> psubst ?f (Forall p)", "show ?case"], ["proof (prove)\nusing this:\n  z \\<turnstile> Forall p\n  map (psubst ?f) z \\<turnstile> psubst ?f (Forall p)\n\ngoal (1 subgoal):\n 1. map (psubst f) z \\<turnstile> psubst f (p[t/0])", "using deriv.ForallE"], ["proof (prove)\nusing this:\n  z \\<turnstile> Forall p\n  map (psubst ?f) z \\<turnstile> psubst ?f (Forall p)\n  ?G \\<turnstile> Forall ?a \\<Longrightarrow> ?G \\<turnstile> ?a[?t/0]\n\ngoal (1 subgoal):\n 1. map (psubst f) z \\<turnstile> psubst f (p[t/0])", "by auto"], ["proof (state)\nthis:\n  map (psubst f) z \\<turnstile> psubst f (p[t/0])\n\ngoal (1 subgoal):\n 1. \\<And>G a n f.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Forall a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>G a n f.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Forall a)", "case (ForallI z p c)"], ["proof (state)\nthis:\n  z \\<turnstile> p[App c []/0]\n  map (psubst ?f) z \\<turnstile> psubst ?f (p[App c []/0])\n  news c z\n  new c p\n\ngoal (1 subgoal):\n 1. \\<And>G a n f.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Forall a)", "let ?params = \\<open>params p \\<union>(\\<Union>p \\<in> set z. params p)\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>G a n f.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Forall a)", "have \\<open>finite ?params\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (params p \\<union> \\<Union> (params ` set z))", "by simp"], ["proof (state)\nthis:\n  finite (params p \\<union> \\<Union> (params ` set z))\n\ngoal (1 subgoal):\n 1. \\<And>G a n f.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Forall a)", "then"], ["proof (chain)\npicking this:\n  finite (params p \\<union> \\<Union> (params ` set z))", "obtain fresh where *: \\<open>fresh \\<notin> ?params \\<union> {c} \\<union> image f ?params\\<close>"], ["proof (prove)\nusing this:\n  finite (params p \\<union> \\<Union> (params ` set z))\n\ngoal (1 subgoal):\n 1. (\\<And>fresh.\n        fresh\n        \\<notin> params p \\<union> \\<Union> (params ` set z) \\<union>\n                 {c} \\<union>\n                 f `\n                 (params p \\<union>\n                  \\<Union> (params ` set z)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using ex_new_if_finite inf_params"], ["proof (prove)\nusing this:\n  finite (params p \\<union> \\<Union> (params ` set z))\n  \\<lbrakk>infinite UNIV; finite ?A\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a. a \\<notin> ?A\n  infinite UNIV\n\ngoal (1 subgoal):\n 1. (\\<And>fresh.\n        fresh\n        \\<notin> params p \\<union> \\<Union> (params ` set z) \\<union>\n                 {c} \\<union>\n                 f `\n                 (params p \\<union>\n                  \\<Union> (params ` set z)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis finite.emptyI finite.insertI finite_UnI finite_imageI)"], ["proof (state)\nthis:\n  fresh\n  \\<notin> params p \\<union> \\<Union> (params ` set z) \\<union> {c} \\<union>\n           f ` (params p \\<union> \\<Union> (params ` set z))\n\ngoal (1 subgoal):\n 1. \\<And>G a n f.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Forall a)", "let ?f = \\<open>f(c := fresh)\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>G a n f.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Forall a)", "have \\<open>news c (p # z)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. news c (p # z)", "using ForallI"], ["proof (prove)\nusing this:\n  z \\<turnstile> p[App c []/0]\n  map (psubst ?f) z \\<turnstile> psubst ?f (p[App c []/0])\n  news c z\n  new c p\n\ngoal (1 subgoal):\n 1. news c (p # z)", "by simp"], ["proof (state)\nthis:\n  news c (p # z)\n\ngoal (1 subgoal):\n 1. \\<And>G a n f.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Forall a)", "then"], ["proof (chain)\npicking this:\n  news c (p # z)", "have \\<open>new fresh (psubst ?f p)\\<close> \\<open>news fresh (map (psubst ?f) z)\\<close>"], ["proof (prove)\nusing this:\n  news c (p # z)\n\ngoal (1 subgoal):\n 1. new fresh (psubst (f(c := fresh)) p) &&&\n    news fresh (map (psubst (f(c := fresh))) z)", "using * new_psubst_image news_psubst"], ["proof (prove)\nusing this:\n  news c (p # z)\n  fresh\n  \\<notin> params p \\<union> \\<Union> (params ` set z) \\<union> {c} \\<union>\n           f ` (params p \\<union> \\<Union> (params ` set z))\n  \\<lbrakk>new ?c ?p; ?d \\<notin> ?f ` params ?p\\<rbrakk>\n  \\<Longrightarrow> new ?d (psubst (?f(?c := ?d)) ?p)\n  \\<lbrakk>news ?c ?z; ?d \\<notin> ?f ` \\<Union> (params ` set ?z)\\<rbrakk>\n  \\<Longrightarrow> news ?d (map (psubst (?f(?c := ?d))) ?z)\n\ngoal (1 subgoal):\n 1. new fresh (psubst (f(c := fresh)) p) &&&\n    news fresh (map (psubst (f(c := fresh))) z)", "by (fastforce simp add: image_Un)+"], ["proof (state)\nthis:\n  new fresh (psubst (f(c := fresh)) p)\n  news fresh (map (psubst (f(c := fresh))) z)\n\ngoal (1 subgoal):\n 1. \\<And>G a n f.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Forall a)", "then"], ["proof (chain)\npicking this:\n  new fresh (psubst (f(c := fresh)) p)\n  news fresh (map (psubst (f(c := fresh))) z)", "have \\<open>map (psubst ?f) z = map (psubst f) z\\<close>"], ["proof (prove)\nusing this:\n  new fresh (psubst (f(c := fresh)) p)\n  news fresh (map (psubst (f(c := fresh))) z)\n\ngoal (1 subgoal):\n 1. map (psubst (f(c := fresh))) z = map (psubst f) z", "using ForallI"], ["proof (prove)\nusing this:\n  new fresh (psubst (f(c := fresh)) p)\n  news fresh (map (psubst (f(c := fresh))) z)\n  z \\<turnstile> p[App c []/0]\n  map (psubst ?f) z \\<turnstile> psubst ?f (p[App c []/0])\n  news c z\n  new c p\n\ngoal (1 subgoal):\n 1. map (psubst (f(c := fresh))) z = map (psubst f) z", "by (metis (mono_tags, lifting) Ball_set map_eq_conv psubst_upd)"], ["proof (state)\nthis:\n  map (psubst (f(c := fresh))) z = map (psubst f) z\n\ngoal (1 subgoal):\n 1. \\<And>G a n f.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Forall a)", "have \\<open>map (psubst ?f) z \\<turnstile> psubst ?f (subst p (App c []) 0)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (psubst (f(c := fresh)))\n     z \\<turnstile> psubst (f(c := fresh)) (p[App c []/0])", "using ForallI"], ["proof (prove)\nusing this:\n  z \\<turnstile> p[App c []/0]\n  map (psubst ?f) z \\<turnstile> psubst ?f (p[App c []/0])\n  news c z\n  new c p\n\ngoal (1 subgoal):\n 1. map (psubst (f(c := fresh)))\n     z \\<turnstile> psubst (f(c := fresh)) (p[App c []/0])", "by blast"], ["proof (state)\nthis:\n  map (psubst (f(c := fresh)))\n   z \\<turnstile> psubst (f(c := fresh)) (p[App c []/0])\n\ngoal (1 subgoal):\n 1. \\<And>G a n f.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Forall a)", "then"], ["proof (chain)\npicking this:\n  map (psubst (f(c := fresh)))\n   z \\<turnstile> psubst (f(c := fresh)) (p[App c []/0])", "have \\<open>map (psubst ?f) z \\<turnstile> subst (psubst ?f p) (App fresh []) 0\\<close>"], ["proof (prove)\nusing this:\n  map (psubst (f(c := fresh)))\n   z \\<turnstile> psubst (f(c := fresh)) (p[App c []/0])\n\ngoal (1 subgoal):\n 1. map (psubst (f(c := fresh)))\n     z \\<turnstile> psubst (f(c := fresh)) p[App fresh []/0]", "by simp"], ["proof (state)\nthis:\n  map (psubst (f(c := fresh)))\n   z \\<turnstile> psubst (f(c := fresh)) p[App fresh []/0]\n\ngoal (1 subgoal):\n 1. \\<And>G a n f.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Forall a)", "moreover"], ["proof (state)\nthis:\n  map (psubst (f(c := fresh)))\n   z \\<turnstile> psubst (f(c := fresh)) p[App fresh []/0]\n\ngoal (1 subgoal):\n 1. \\<And>G a n f.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Forall a)", "have \\<open>news fresh (map (psubst ?f) (p # z))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. news fresh (map (psubst (f(c := fresh))) (p # z))", "using \\<open>new fresh (psubst ?f p)\\<close> \\<open>news fresh (map (psubst ?f) z)\\<close>"], ["proof (prove)\nusing this:\n  new fresh (psubst (f(c := fresh)) p)\n  news fresh (map (psubst (f(c := fresh))) z)\n\ngoal (1 subgoal):\n 1. news fresh (map (psubst (f(c := fresh))) (p # z))", "by simp"], ["proof (state)\nthis:\n  news fresh (map (psubst (f(c := fresh))) (p # z))\n\ngoal (1 subgoal):\n 1. \\<And>G a n f.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Forall a)", "then"], ["proof (chain)\npicking this:\n  news fresh (map (psubst (f(c := fresh))) (p # z))", "have \\<open>new fresh (psubst ?f p)\\<close> \\<open>news fresh (map (psubst ?f) z)\\<close>"], ["proof (prove)\nusing this:\n  news fresh (map (psubst (f(c := fresh))) (p # z))\n\ngoal (1 subgoal):\n 1. new fresh (psubst (f(c := fresh)) p) &&&\n    news fresh (map (psubst (f(c := fresh))) z)", "by simp_all"], ["proof (state)\nthis:\n  new fresh (psubst (f(c := fresh)) p)\n  news fresh (map (psubst (f(c := fresh))) z)\n\ngoal (1 subgoal):\n 1. \\<And>G a n f.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Forall a)", "ultimately"], ["proof (chain)\npicking this:\n  map (psubst (f(c := fresh)))\n   z \\<turnstile> psubst (f(c := fresh)) p[App fresh []/0]\n  new fresh (psubst (f(c := fresh)) p)\n  news fresh (map (psubst (f(c := fresh))) z)", "have \\<open>map (psubst ?f) z \\<turnstile> Forall (psubst ?f p)\\<close>"], ["proof (prove)\nusing this:\n  map (psubst (f(c := fresh)))\n   z \\<turnstile> psubst (f(c := fresh)) p[App fresh []/0]\n  new fresh (psubst (f(c := fresh)) p)\n  news fresh (map (psubst (f(c := fresh))) z)\n\ngoal (1 subgoal):\n 1. map (psubst (f(c := fresh)))\n     z \\<turnstile> Forall (psubst (f(c := fresh)) p)", "using deriv.ForallI"], ["proof (prove)\nusing this:\n  map (psubst (f(c := fresh)))\n   z \\<turnstile> psubst (f(c := fresh)) p[App fresh []/0]\n  new fresh (psubst (f(c := fresh)) p)\n  news fresh (map (psubst (f(c := fresh))) z)\n  \\<lbrakk>?G \\<turnstile> ?a[App ?n []/0]; news ?n ?G; new ?n ?a\\<rbrakk>\n  \\<Longrightarrow> ?G \\<turnstile> Forall ?a\n\ngoal (1 subgoal):\n 1. map (psubst (f(c := fresh)))\n     z \\<turnstile> Forall (psubst (f(c := fresh)) p)", "by metis"], ["proof (state)\nthis:\n  map (psubst (f(c := fresh)))\n   z \\<turnstile> Forall (psubst (f(c := fresh)) p)\n\ngoal (1 subgoal):\n 1. \\<And>G a n f.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>f. map (psubst f) G \\<turnstile> psubst f (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> map (psubst f) G \\<turnstile> psubst f (Forall a)", "then"], ["proof (chain)\npicking this:\n  map (psubst (f(c := fresh)))\n   z \\<turnstile> Forall (psubst (f(c := fresh)) p)", "show ?case"], ["proof (prove)\nusing this:\n  map (psubst (f(c := fresh)))\n   z \\<turnstile> Forall (psubst (f(c := fresh)) p)\n\ngoal (1 subgoal):\n 1. map (psubst f) z \\<turnstile> psubst f (Forall p)", "using ForallI \\<open>map (psubst ?f) z = map (psubst f) z\\<close>"], ["proof (prove)\nusing this:\n  map (psubst (f(c := fresh)))\n   z \\<turnstile> Forall (psubst (f(c := fresh)) p)\n  z \\<turnstile> p[App c []/0]\n  map (psubst ?f) z \\<turnstile> psubst ?f (p[App c []/0])\n  news c z\n  new c p\n  map (psubst (f(c := fresh))) z = map (psubst f) z\n\ngoal (1 subgoal):\n 1. map (psubst f) z \\<turnstile> psubst f (Forall p)", "by simp"], ["proof (state)\nthis:\n  map (psubst f) z \\<turnstile> psubst f (Forall p)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Substitution for constants\\<close>"], ["", "primrec\n  subc_term :: \\<open>'a \\<Rightarrow> 'a term \\<Rightarrow> 'a term \\<Rightarrow> 'a term\\<close> and\n  subc_list :: \\<open>'a \\<Rightarrow> 'a term \\<Rightarrow> 'a term list \\<Rightarrow> 'a term list\\<close> where\n  \\<open>subc_term c s (Var n) = Var n\\<close> |\n  \\<open>subc_term c s (App i l) = (if i = c then s else App i (subc_list c s l))\\<close> |\n  \\<open>subc_list c s [] = []\\<close> |\n  \\<open>subc_list c s (t # l) = subc_term c s t # subc_list c s l\\<close>"], ["", "primrec subc :: \\<open>'a \\<Rightarrow> 'a term \\<Rightarrow> ('a, 'b) form \\<Rightarrow> ('a, 'b) form\\<close> where\n  \\<open>subc c s FF = FF\\<close> |\n  \\<open>subc c s TT = TT\\<close> |\n  \\<open>subc c s (Pred i l) = Pred i (subc_list c s l)\\<close> |\n  \\<open>subc c s (Neg p) = Neg (subc c s p)\\<close> |\n  \\<open>subc c s (Impl p q) = Impl (subc c s p) (subc c s q)\\<close> |\n  \\<open>subc c s (Or p q) = Or (subc c s p) (subc c s q)\\<close> |\n  \\<open>subc c s (And p q) = And (subc c s p) (subc c s q)\\<close> |\n  \\<open>subc c s (Exists p) = Exists (subc c (liftt s) p)\\<close> |\n  \\<open>subc c s (Forall p) = Forall (subc c (liftt s) p)\\<close>"], ["", "primrec subcs :: \\<open>'a \\<Rightarrow> 'a term \\<Rightarrow> ('a, 'b) form list \\<Rightarrow> ('a, 'b) form list\\<close> where\n  \\<open>subcs c s [] = []\\<close> |\n  \\<open>subcs c s (p # z) = subc c s p # subcs c s z\\<close>"], ["", "lemma subst_0_lift:\n  \\<open>substt (liftt t) s 0 = t\\<close>\n  \\<open>substts (liftts l) s 0 = l\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. liftt t[s/0] = t &&& liftts l[s/0] = l", "by (induct t and l rule: substt.induct substts.induct) simp_all"], ["", "lemma params_lift [simp]:\n  fixes t :: \\<open>'a term\\<close> and ts :: \\<open>'a term list\\<close>\n  shows\n    \\<open>paramst (liftt t) = paramst t\\<close>\n    \\<open>paramsts (liftts ts) = paramsts ts\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. paramst (liftt t) = paramst t &&& paramsts (liftts ts) = paramsts ts", "by (induct t and ts rule: paramst.induct paramsts.induct) simp_all"], ["", "lemma subst_new' [simp]:\n  \\<open>new_term c s \\<Longrightarrow> new_term c t \\<Longrightarrow> new_term c (substt t s m)\\<close>\n  \\<open>new_term c s \\<Longrightarrow> new_list c l \\<Longrightarrow> new_list c (substts l s m)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>new_term c s; new_term c t\\<rbrakk>\n     \\<Longrightarrow> new_term c (t[s/m])) &&&\n    (\\<lbrakk>new_term c s; new_list c l\\<rbrakk>\n     \\<Longrightarrow> new_list c (l[s/m]))", "by (induct t and l rule: substt.induct substts.induct) simp_all"], ["", "lemma subst_new [simp]: \\<open>new_term c s \\<Longrightarrow> new c p \\<Longrightarrow> new c (subst p s m)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>new_term c s; new c p\\<rbrakk> \\<Longrightarrow> new c (p[s/m])", "by (induct p arbitrary: m s) simp_all"], ["", "lemma subst_new_all:\n  assumes \\<open>a \\<notin> set cs\\<close> \\<open>list_all (\\<lambda>c. new c p) cs\\<close>\n  shows \\<open>list_all (\\<lambda>c. new c (subst p (App a []) m)) cs\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>c. new c (p[App a []/m])) cs", "using assms"], ["proof (prove)\nusing this:\n  a \\<notin> set cs\n  list_all (\\<lambda>c. new c p) cs\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>c. new c (p[App a []/m])) cs", "by (induct cs) auto"], ["", "lemma subc_new' [simp]:\n  \\<open>new_term c t \\<Longrightarrow> subc_term c s t = t\\<close>\n  \\<open>new_list c l \\<Longrightarrow> subc_list c s l = l\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (new_term c t \\<Longrightarrow> subc_term c s t = t) &&&\n    (new_list c l \\<Longrightarrow> subc_list c s l = l)", "by (induct t and l rule: subc_term.induct subc_list.induct) auto"], ["", "lemma subc_new [simp]: \\<open>new c p \\<Longrightarrow> subc c s p = p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. new c p \\<Longrightarrow> subc c s p = p", "by (induct p arbitrary: s) simp_all"], ["", "lemma subcs_news: \\<open>news c z \\<Longrightarrow> subcs c s z = z\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. news c z \\<Longrightarrow> subcs c s z = z", "by (induct z) simp_all"], ["", "lemma subc_psubst' [simp]:\n  \\<open>(\\<forall>x \\<in> paramst t. x \\<noteq> c \\<longrightarrow> f x \\<noteq> f c) \\<Longrightarrow>\n    psubstt f (subc_term c s t) = subc_term (f c) (psubstt f s) (psubstt f t)\\<close>\n  \\<open>(\\<forall>x \\<in> paramsts l. x \\<noteq> c \\<longrightarrow> f x \\<noteq> f c) \\<Longrightarrow>\n    psubstts f (subc_list c s l) = subc_list (f c) (psubstt f s) (psubstts f l)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>paramst t.\n        x \\<noteq> c \\<longrightarrow> f x \\<noteq> f c \\<Longrightarrow>\n     psubstt f (subc_term c s t) =\n     subc_term (f c) (psubstt f s) (psubstt f t)) &&&\n    (\\<forall>x\\<in>paramsts l.\n        x \\<noteq> c \\<longrightarrow> f x \\<noteq> f c \\<Longrightarrow>\n     psubstts f (subc_list c s l) =\n     subc_list (f c) (psubstt f s) (psubstts f l))", "by (induct t and l rule: psubstt.induct psubstts.induct) simp_all"], ["", "lemma subc_psubst: \\<open>(\\<forall>x \\<in> params p. x \\<noteq> c \\<longrightarrow> f x \\<noteq> f c) \\<Longrightarrow>\n    psubst f (subc c s p) = subc (f c) (psubstt f s) (psubst f p)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>params p.\n       x \\<noteq> c \\<longrightarrow> f x \\<noteq> f c \\<Longrightarrow>\n    psubst f (subc c s p) = subc (f c) (psubstt f s) (psubst f p)", "by (induct p arbitrary: s) simp_all"], ["", "lemma subcs_psubst: \\<open>(\\<forall>x \\<in> (\\<Union>p \\<in> set z. params p). x \\<noteq> c \\<longrightarrow> f x \\<noteq> f c) \\<Longrightarrow>\n    map (psubst f) (subcs c s z) = subcs (f c) (psubstt f s) (map (psubst f) z)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>\\<Union> (params ` set z).\n       x \\<noteq> c \\<longrightarrow> f x \\<noteq> f c \\<Longrightarrow>\n    map (psubst f) (subcs c s z) =\n    subcs (f c) (psubstt f s) (map (psubst f) z)", "by (induct z) (simp_all add: subc_psubst)"], ["", "lemma new_lift:\n  \\<open>new_term c t \\<Longrightarrow> new_term c (liftt t)\\<close>\n  \\<open>new_list c l \\<Longrightarrow> new_list c (liftts l)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (new_term c t \\<Longrightarrow> new_term c (liftt t)) &&&\n    (new_list c l \\<Longrightarrow> new_list c (liftts l))", "by (induct t and l rule: liftt.induct liftts.induct) simp_all"], ["", "lemma new_subc' [simp]:\n  \\<open>new_term d s \\<Longrightarrow> new_term d t \\<Longrightarrow> new_term d (subc_term c s t)\\<close>\n  \\<open>new_term d s \\<Longrightarrow> new_list d l \\<Longrightarrow> new_list d (subc_list c s l)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>new_term d s; new_term d t\\<rbrakk>\n     \\<Longrightarrow> new_term d (subc_term c s t)) &&&\n    (\\<lbrakk>new_term d s; new_list d l\\<rbrakk>\n     \\<Longrightarrow> new_list d (subc_list c s l))", "by (induct t and l rule: substt.induct substts.induct) simp_all"], ["", "lemma new_subc [simp]: \\<open>new_term d s \\<Longrightarrow> new d p \\<Longrightarrow> new d (subc c s p)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>new_term d s; new d p\\<rbrakk>\n    \\<Longrightarrow> new d (subc c s p)", "by (induct p arbitrary: s) simp_all"], ["", "lemma news_subcs: \\<open>new_term d s \\<Longrightarrow> news d z \\<Longrightarrow> news d (subcs c s z)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>new_term d s; news d z\\<rbrakk>\n    \\<Longrightarrow> news d (subcs c s z)", "by (induct z) simp_all"], ["", "lemma psubst_new_free':\n  \\<open>c \\<noteq> n \\<Longrightarrow> new_term n (psubstt (id(n := c)) t)\\<close>\n  \\<open>c \\<noteq> n \\<Longrightarrow> new_list n (psubstts (id(n := c)) l)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (c \\<noteq> n \\<Longrightarrow> new_term n (psubstt (id(n := c)) t)) &&&\n    (c \\<noteq> n \\<Longrightarrow> new_list n (psubstts (id(n := c)) l))", "by (induct t and l rule: paramst.induct paramsts.induct) simp_all"], ["", "lemma psubst_new_free: \\<open>c \\<noteq> n \\<Longrightarrow> new n (psubst (id(n := c)) p)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<noteq> n \\<Longrightarrow> new n (psubst (id(n := c)) p)", "using psubst_new_free'"], ["proof (prove)\nusing this:\n  ?c \\<noteq> ?n \\<Longrightarrow> new_term ?n (psubstt (id(?n := ?c)) ?t)\n  ?c \\<noteq> ?n \\<Longrightarrow> new_list ?n (psubstts (id(?n := ?c)) ?l)\n\ngoal (1 subgoal):\n 1. c \\<noteq> n \\<Longrightarrow> new n (psubst (id(n := c)) p)", "by (induct p) fastforce+"], ["", "lemma map_psubst_new_free: \\<open>c \\<noteq> n \\<Longrightarrow> news n (map (psubst (id(n := c))) z)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<noteq> n \\<Longrightarrow> news n (map (psubst (id(n := c))) z)", "using psubst_new_free"], ["proof (prove)\nusing this:\n  ?c \\<noteq> ?n \\<Longrightarrow> new ?n (psubst (id(?n := ?c)) ?p)\n\ngoal (1 subgoal):\n 1. c \\<noteq> n \\<Longrightarrow> news n (map (psubst (id(n := c))) z)", "by (induct z) fastforce+"], ["", "lemma psubst_new_away' [simp]:\n  \\<open>new_term fresh t \\<Longrightarrow> psubstt (id(fresh := c)) (psubstt (id(c := fresh)) t) = t\\<close>\n  \\<open>new_list fresh l \\<Longrightarrow> psubstts (id(fresh := c)) (psubstts (id(c := fresh)) l) = l\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (new_term fresh t \\<Longrightarrow>\n     psubstt (id(fresh := c)) (psubstt (id(c := fresh)) t) = t) &&&\n    (new_list fresh l \\<Longrightarrow>\n     psubstts (id(fresh := c)) (psubstts (id(c := fresh)) l) = l)", "by (induct t and l rule: psubstt.induct psubstts.induct) auto"], ["", "lemma psubst_new_away [simp]: \\<open>new fresh p \\<Longrightarrow> psubst (id(fresh := c)) (psubst (id(c := fresh)) p) = p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. new fresh p \\<Longrightarrow>\n    psubst (id(fresh := c)) (psubst (id(c := fresh)) p) = p", "by (induct p) simp_all"], ["", "lemma map_psubst_new_away:\n  \\<open>news fresh z \\<Longrightarrow> map (psubst (id(fresh := c))) (map (psubst (id(c := fresh))) z) = z\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. news fresh z \\<Longrightarrow>\n    map (psubst (id(fresh := c))) (map (psubst (id(c := fresh))) z) = z", "by (induct z) simp_all"], ["", "lemma psubst_new':\n  \\<open>new_term c t \\<Longrightarrow> psubstt (id(c := x)) t = t\\<close>\n  \\<open>new_list c l \\<Longrightarrow> psubstts (id(c := x)) l = l\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (new_term c t \\<Longrightarrow> psubstt (id(c := x)) t = t) &&&\n    (new_list c l \\<Longrightarrow> psubstts (id(c := x)) l = l)", "by (induct t and l rule: psubstt.induct psubstts.induct) auto"], ["", "lemma psubst_new: \\<open>new c p \\<Longrightarrow> psubst (id(c := x)) p = p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. new c p \\<Longrightarrow> psubst (id(c := x)) p = p", "using psubst_new'"], ["proof (prove)\nusing this:\n  new_term ?c ?t \\<Longrightarrow> psubstt (id(?c := ?x)) ?t = ?t\n  new_list ?c ?l \\<Longrightarrow> psubstts (id(?c := ?x)) ?l = ?l\n\ngoal (1 subgoal):\n 1. new c p \\<Longrightarrow> psubst (id(c := x)) p = p", "by (induct p) fastforce+"], ["", "lemma map_psubst_new: \\<open>news c z \\<Longrightarrow> map (psubst (id(c := x))) z = z\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. news c z \\<Longrightarrow> map (psubst (id(c := x))) z = z", "using psubst_new"], ["proof (prove)\nusing this:\n  new ?c ?p \\<Longrightarrow> psubst (id(?c := ?x)) ?p = ?p\n\ngoal (1 subgoal):\n 1. news c z \\<Longrightarrow> map (psubst (id(c := x))) z = z", "by (induct z) auto"], ["", "lemma lift_subst [simp]:\n  \\<open>liftt (substt t u m) = substt (liftt t) (liftt u) (m + 1)\\<close>\n  \\<open>liftts (substts l u m) = substts (liftts l) (liftt u) (m + 1)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. liftt (t[u/m]) = liftt t[liftt u/m + 1] &&&\n    liftts (l[u/m]) = liftts l[liftt u/m + 1]", "by (induct t and l rule: substt.induct substts.induct) simp_all"], ["", "lemma new_subc_same' [simp]:\n  \\<open>new_term c s \\<Longrightarrow> new_term c (subc_term c s t)\\<close>\n  \\<open>new_term c s \\<Longrightarrow> new_list c (subc_list c s l)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (new_term c s \\<Longrightarrow> new_term c (subc_term c s t)) &&&\n    (new_term c s \\<Longrightarrow> new_list c (subc_list c s l))", "by (induct t and l rule: subc_term.induct subc_list.induct) simp_all"], ["", "lemma new_subc_same: \\<open>new_term c s \\<Longrightarrow> new c (subc c s p)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. new_term c s \\<Longrightarrow> new c (subc c s p)", "by (induct p arbitrary: s) simp_all"], ["", "lemma lift_subc:\n  \\<open>liftt (subc_term c s t) = subc_term c (liftt s) (liftt t)\\<close>\n  \\<open>liftts (subc_list c s l) = subc_list c (liftt s) (liftts l)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. liftt (subc_term c s t) = subc_term c (liftt s) (liftt t) &&&\n    liftts (subc_list c s l) = subc_list c (liftt s) (liftts l)", "by (induct t and l rule: liftt.induct liftts.induct) simp_all"], ["", "lemma new_subc_put':\n  \\<open>new_term c s \\<Longrightarrow> subc_term c s (substt t u m) = subc_term c s (substt t (subc_term c s u) m)\\<close>\n  \\<open>new_term c s \\<Longrightarrow> subc_list c s (substts l u m) = subc_list c s (substts l (subc_term c s u) m)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (new_term c s \\<Longrightarrow>\n     subc_term c s (t[u/m]) = subc_term c s (t[subc_term c s u/m])) &&&\n    (new_term c s \\<Longrightarrow>\n     subc_list c s (l[u/m]) = subc_list c s (l[subc_term c s u/m]))", "by (induct t and l rule: subc_term.induct subc_list.induct) simp_all"], ["", "lemma new_subc_put:\n  \\<open>new_term c s \\<Longrightarrow> subc c s (subst p t m) = subc c s (subst p (subc_term c s t) m)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. new_term c s \\<Longrightarrow>\n    subc c s (p[t/m]) = subc c s (p[subc_term c s t/m])", "proof (induct p arbitrary: s m t)"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>s m t.\n       new_term c s \\<Longrightarrow>\n       subc c s (FF[t/m]) = subc c s (FF[subc_term c s t/m])\n 2. \\<And>s m t.\n       new_term c s \\<Longrightarrow>\n       subc c s (TT[t/m]) = subc c s (TT[subc_term c s t/m])\n 3. \\<And>x1 x2 s m t.\n       new_term c s \\<Longrightarrow>\n       subc c s (Pred x1 x2[t/m]) = subc c s (Pred x1 x2[subc_term c s t/m])\n 4. \\<And>p1 p2 s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p1[t/m]) = subc c s (p1[subc_term c s t/m]);\n        \\<And>s m t.\n           new_term c s \\<Longrightarrow>\n           subc c s (p2[t/m]) = subc c s (p2[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (And p1 p2[t/m]) =\n                         subc c s (And p1 p2[subc_term c s t/m])\n 5. \\<And>p1 p2 s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p1[t/m]) = subc c s (p1[subc_term c s t/m]);\n        \\<And>s m t.\n           new_term c s \\<Longrightarrow>\n           subc c s (p2[t/m]) = subc c s (p2[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Or p1 p2[t/m]) =\n                         subc c s (Or p1 p2[subc_term c s t/m])\n 6. \\<And>p1 p2 s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p1[t/m]) = subc c s (p1[subc_term c s t/m]);\n        \\<And>s m t.\n           new_term c s \\<Longrightarrow>\n           subc c s (p2[t/m]) = subc c s (p2[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Impl p1 p2[t/m]) =\n                         subc c s (Impl p1 p2[subc_term c s t/m])\n 7. \\<And>p s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p[t/m]) = subc c s (p[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Neg p[t/m]) =\n                         subc c s (Neg p[subc_term c s t/m])\n 8. \\<And>p s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p[t/m]) = subc c s (p[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Forall p[t/m]) =\n                         subc c s (Forall p[subc_term c s t/m])\n 9. \\<And>p s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p[t/m]) = subc c s (p[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Exists p[t/m]) =\n                         subc c s (Exists p[subc_term c s t/m])", "case FF"], ["proof (state)\nthis:\n  new_term c s\n\ngoal (9 subgoals):\n 1. \\<And>s m t.\n       new_term c s \\<Longrightarrow>\n       subc c s (FF[t/m]) = subc c s (FF[subc_term c s t/m])\n 2. \\<And>s m t.\n       new_term c s \\<Longrightarrow>\n       subc c s (TT[t/m]) = subc c s (TT[subc_term c s t/m])\n 3. \\<And>x1 x2 s m t.\n       new_term c s \\<Longrightarrow>\n       subc c s (Pred x1 x2[t/m]) = subc c s (Pred x1 x2[subc_term c s t/m])\n 4. \\<And>p1 p2 s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p1[t/m]) = subc c s (p1[subc_term c s t/m]);\n        \\<And>s m t.\n           new_term c s \\<Longrightarrow>\n           subc c s (p2[t/m]) = subc c s (p2[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (And p1 p2[t/m]) =\n                         subc c s (And p1 p2[subc_term c s t/m])\n 5. \\<And>p1 p2 s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p1[t/m]) = subc c s (p1[subc_term c s t/m]);\n        \\<And>s m t.\n           new_term c s \\<Longrightarrow>\n           subc c s (p2[t/m]) = subc c s (p2[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Or p1 p2[t/m]) =\n                         subc c s (Or p1 p2[subc_term c s t/m])\n 6. \\<And>p1 p2 s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p1[t/m]) = subc c s (p1[subc_term c s t/m]);\n        \\<And>s m t.\n           new_term c s \\<Longrightarrow>\n           subc c s (p2[t/m]) = subc c s (p2[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Impl p1 p2[t/m]) =\n                         subc c s (Impl p1 p2[subc_term c s t/m])\n 7. \\<And>p s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p[t/m]) = subc c s (p[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Neg p[t/m]) =\n                         subc c s (Neg p[subc_term c s t/m])\n 8. \\<And>p s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p[t/m]) = subc c s (p[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Forall p[t/m]) =\n                         subc c s (Forall p[subc_term c s t/m])\n 9. \\<And>p s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p[t/m]) = subc c s (p[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Exists p[t/m]) =\n                         subc c s (Exists p[subc_term c s t/m])", "then"], ["proof (chain)\npicking this:\n  new_term c s", "show ?case"], ["proof (prove)\nusing this:\n  new_term c s\n\ngoal (1 subgoal):\n 1. subc c s (FF[t/m]) = subc c s (FF[subc_term c s t/m])", "by simp"], ["proof (state)\nthis:\n  subc c s (FF[t/m]) = subc c s (FF[subc_term c s t/m])\n\ngoal (8 subgoals):\n 1. \\<And>s m t.\n       new_term c s \\<Longrightarrow>\n       subc c s (TT[t/m]) = subc c s (TT[subc_term c s t/m])\n 2. \\<And>x1 x2 s m t.\n       new_term c s \\<Longrightarrow>\n       subc c s (Pred x1 x2[t/m]) = subc c s (Pred x1 x2[subc_term c s t/m])\n 3. \\<And>p1 p2 s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p1[t/m]) = subc c s (p1[subc_term c s t/m]);\n        \\<And>s m t.\n           new_term c s \\<Longrightarrow>\n           subc c s (p2[t/m]) = subc c s (p2[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (And p1 p2[t/m]) =\n                         subc c s (And p1 p2[subc_term c s t/m])\n 4. \\<And>p1 p2 s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p1[t/m]) = subc c s (p1[subc_term c s t/m]);\n        \\<And>s m t.\n           new_term c s \\<Longrightarrow>\n           subc c s (p2[t/m]) = subc c s (p2[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Or p1 p2[t/m]) =\n                         subc c s (Or p1 p2[subc_term c s t/m])\n 5. \\<And>p1 p2 s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p1[t/m]) = subc c s (p1[subc_term c s t/m]);\n        \\<And>s m t.\n           new_term c s \\<Longrightarrow>\n           subc c s (p2[t/m]) = subc c s (p2[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Impl p1 p2[t/m]) =\n                         subc c s (Impl p1 p2[subc_term c s t/m])\n 6. \\<And>p s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p[t/m]) = subc c s (p[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Neg p[t/m]) =\n                         subc c s (Neg p[subc_term c s t/m])\n 7. \\<And>p s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p[t/m]) = subc c s (p[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Forall p[t/m]) =\n                         subc c s (Forall p[subc_term c s t/m])\n 8. \\<And>p s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p[t/m]) = subc c s (p[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Exists p[t/m]) =\n                         subc c s (Exists p[subc_term c s t/m])", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>s m t.\n       new_term c s \\<Longrightarrow>\n       subc c s (TT[t/m]) = subc c s (TT[subc_term c s t/m])\n 2. \\<And>x1 x2 s m t.\n       new_term c s \\<Longrightarrow>\n       subc c s (Pred x1 x2[t/m]) = subc c s (Pred x1 x2[subc_term c s t/m])\n 3. \\<And>p1 p2 s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p1[t/m]) = subc c s (p1[subc_term c s t/m]);\n        \\<And>s m t.\n           new_term c s \\<Longrightarrow>\n           subc c s (p2[t/m]) = subc c s (p2[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (And p1 p2[t/m]) =\n                         subc c s (And p1 p2[subc_term c s t/m])\n 4. \\<And>p1 p2 s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p1[t/m]) = subc c s (p1[subc_term c s t/m]);\n        \\<And>s m t.\n           new_term c s \\<Longrightarrow>\n           subc c s (p2[t/m]) = subc c s (p2[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Or p1 p2[t/m]) =\n                         subc c s (Or p1 p2[subc_term c s t/m])\n 5. \\<And>p1 p2 s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p1[t/m]) = subc c s (p1[subc_term c s t/m]);\n        \\<And>s m t.\n           new_term c s \\<Longrightarrow>\n           subc c s (p2[t/m]) = subc c s (p2[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Impl p1 p2[t/m]) =\n                         subc c s (Impl p1 p2[subc_term c s t/m])\n 6. \\<And>p s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p[t/m]) = subc c s (p[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Neg p[t/m]) =\n                         subc c s (Neg p[subc_term c s t/m])\n 7. \\<And>p s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p[t/m]) = subc c s (p[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Forall p[t/m]) =\n                         subc c s (Forall p[subc_term c s t/m])\n 8. \\<And>p s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p[t/m]) = subc c s (p[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Exists p[t/m]) =\n                         subc c s (Exists p[subc_term c s t/m])", "case TT"], ["proof (state)\nthis:\n  new_term c s\n\ngoal (8 subgoals):\n 1. \\<And>s m t.\n       new_term c s \\<Longrightarrow>\n       subc c s (TT[t/m]) = subc c s (TT[subc_term c s t/m])\n 2. \\<And>x1 x2 s m t.\n       new_term c s \\<Longrightarrow>\n       subc c s (Pred x1 x2[t/m]) = subc c s (Pred x1 x2[subc_term c s t/m])\n 3. \\<And>p1 p2 s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p1[t/m]) = subc c s (p1[subc_term c s t/m]);\n        \\<And>s m t.\n           new_term c s \\<Longrightarrow>\n           subc c s (p2[t/m]) = subc c s (p2[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (And p1 p2[t/m]) =\n                         subc c s (And p1 p2[subc_term c s t/m])\n 4. \\<And>p1 p2 s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p1[t/m]) = subc c s (p1[subc_term c s t/m]);\n        \\<And>s m t.\n           new_term c s \\<Longrightarrow>\n           subc c s (p2[t/m]) = subc c s (p2[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Or p1 p2[t/m]) =\n                         subc c s (Or p1 p2[subc_term c s t/m])\n 5. \\<And>p1 p2 s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p1[t/m]) = subc c s (p1[subc_term c s t/m]);\n        \\<And>s m t.\n           new_term c s \\<Longrightarrow>\n           subc c s (p2[t/m]) = subc c s (p2[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Impl p1 p2[t/m]) =\n                         subc c s (Impl p1 p2[subc_term c s t/m])\n 6. \\<And>p s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p[t/m]) = subc c s (p[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Neg p[t/m]) =\n                         subc c s (Neg p[subc_term c s t/m])\n 7. \\<And>p s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p[t/m]) = subc c s (p[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Forall p[t/m]) =\n                         subc c s (Forall p[subc_term c s t/m])\n 8. \\<And>p s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p[t/m]) = subc c s (p[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Exists p[t/m]) =\n                         subc c s (Exists p[subc_term c s t/m])", "then"], ["proof (chain)\npicking this:\n  new_term c s", "show ?case"], ["proof (prove)\nusing this:\n  new_term c s\n\ngoal (1 subgoal):\n 1. subc c s (TT[t/m]) = subc c s (TT[subc_term c s t/m])", "by simp"], ["proof (state)\nthis:\n  subc c s (TT[t/m]) = subc c s (TT[subc_term c s t/m])\n\ngoal (7 subgoals):\n 1. \\<And>x1 x2 s m t.\n       new_term c s \\<Longrightarrow>\n       subc c s (Pred x1 x2[t/m]) = subc c s (Pred x1 x2[subc_term c s t/m])\n 2. \\<And>p1 p2 s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p1[t/m]) = subc c s (p1[subc_term c s t/m]);\n        \\<And>s m t.\n           new_term c s \\<Longrightarrow>\n           subc c s (p2[t/m]) = subc c s (p2[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (And p1 p2[t/m]) =\n                         subc c s (And p1 p2[subc_term c s t/m])\n 3. \\<And>p1 p2 s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p1[t/m]) = subc c s (p1[subc_term c s t/m]);\n        \\<And>s m t.\n           new_term c s \\<Longrightarrow>\n           subc c s (p2[t/m]) = subc c s (p2[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Or p1 p2[t/m]) =\n                         subc c s (Or p1 p2[subc_term c s t/m])\n 4. \\<And>p1 p2 s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p1[t/m]) = subc c s (p1[subc_term c s t/m]);\n        \\<And>s m t.\n           new_term c s \\<Longrightarrow>\n           subc c s (p2[t/m]) = subc c s (p2[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Impl p1 p2[t/m]) =\n                         subc c s (Impl p1 p2[subc_term c s t/m])\n 5. \\<And>p s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p[t/m]) = subc c s (p[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Neg p[t/m]) =\n                         subc c s (Neg p[subc_term c s t/m])\n 6. \\<And>p s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p[t/m]) = subc c s (p[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Forall p[t/m]) =\n                         subc c s (Forall p[subc_term c s t/m])\n 7. \\<And>p s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p[t/m]) = subc c s (p[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Exists p[t/m]) =\n                         subc c s (Exists p[subc_term c s t/m])", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>x1 x2 s m t.\n       new_term c s \\<Longrightarrow>\n       subc c s (Pred x1 x2[t/m]) = subc c s (Pred x1 x2[subc_term c s t/m])\n 2. \\<And>p1 p2 s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p1[t/m]) = subc c s (p1[subc_term c s t/m]);\n        \\<And>s m t.\n           new_term c s \\<Longrightarrow>\n           subc c s (p2[t/m]) = subc c s (p2[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (And p1 p2[t/m]) =\n                         subc c s (And p1 p2[subc_term c s t/m])\n 3. \\<And>p1 p2 s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p1[t/m]) = subc c s (p1[subc_term c s t/m]);\n        \\<And>s m t.\n           new_term c s \\<Longrightarrow>\n           subc c s (p2[t/m]) = subc c s (p2[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Or p1 p2[t/m]) =\n                         subc c s (Or p1 p2[subc_term c s t/m])\n 4. \\<And>p1 p2 s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p1[t/m]) = subc c s (p1[subc_term c s t/m]);\n        \\<And>s m t.\n           new_term c s \\<Longrightarrow>\n           subc c s (p2[t/m]) = subc c s (p2[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Impl p1 p2[t/m]) =\n                         subc c s (Impl p1 p2[subc_term c s t/m])\n 5. \\<And>p s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p[t/m]) = subc c s (p[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Neg p[t/m]) =\n                         subc c s (Neg p[subc_term c s t/m])\n 6. \\<And>p s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p[t/m]) = subc c s (p[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Forall p[t/m]) =\n                         subc c s (Forall p[subc_term c s t/m])\n 7. \\<And>p s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p[t/m]) = subc c s (p[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Exists p[t/m]) =\n                         subc c s (Exists p[subc_term c s t/m])", "case (Pred i l)"], ["proof (state)\nthis:\n  new_term c s\n\ngoal (7 subgoals):\n 1. \\<And>x1 x2 s m t.\n       new_term c s \\<Longrightarrow>\n       subc c s (Pred x1 x2[t/m]) = subc c s (Pred x1 x2[subc_term c s t/m])\n 2. \\<And>p1 p2 s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p1[t/m]) = subc c s (p1[subc_term c s t/m]);\n        \\<And>s m t.\n           new_term c s \\<Longrightarrow>\n           subc c s (p2[t/m]) = subc c s (p2[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (And p1 p2[t/m]) =\n                         subc c s (And p1 p2[subc_term c s t/m])\n 3. \\<And>p1 p2 s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p1[t/m]) = subc c s (p1[subc_term c s t/m]);\n        \\<And>s m t.\n           new_term c s \\<Longrightarrow>\n           subc c s (p2[t/m]) = subc c s (p2[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Or p1 p2[t/m]) =\n                         subc c s (Or p1 p2[subc_term c s t/m])\n 4. \\<And>p1 p2 s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p1[t/m]) = subc c s (p1[subc_term c s t/m]);\n        \\<And>s m t.\n           new_term c s \\<Longrightarrow>\n           subc c s (p2[t/m]) = subc c s (p2[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Impl p1 p2[t/m]) =\n                         subc c s (Impl p1 p2[subc_term c s t/m])\n 5. \\<And>p s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p[t/m]) = subc c s (p[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Neg p[t/m]) =\n                         subc c s (Neg p[subc_term c s t/m])\n 6. \\<And>p s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p[t/m]) = subc c s (p[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Forall p[t/m]) =\n                         subc c s (Forall p[subc_term c s t/m])\n 7. \\<And>p s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p[t/m]) = subc c s (p[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Exists p[t/m]) =\n                         subc c s (Exists p[subc_term c s t/m])", "then"], ["proof (chain)\npicking this:\n  new_term c s", "show ?case"], ["proof (prove)\nusing this:\n  new_term c s\n\ngoal (1 subgoal):\n 1. subc c s (Pred i l[t/m]) = subc c s (Pred i l[subc_term c s t/m])", "using new_subc_put'"], ["proof (prove)\nusing this:\n  new_term c s\n  new_term ?c ?s \\<Longrightarrow>\n  subc_term ?c ?s (?t[?u/?m]) = subc_term ?c ?s (?t[subc_term ?c ?s ?u/?m])\n  new_term ?c ?s \\<Longrightarrow>\n  subc_list ?c ?s (?l[?u/?m]) = subc_list ?c ?s (?l[subc_term ?c ?s ?u/?m])\n\ngoal (1 subgoal):\n 1. subc c s (Pred i l[t/m]) = subc c s (Pred i l[subc_term c s t/m])", "by fastforce"], ["proof (state)\nthis:\n  subc c s (Pred i l[t/m]) = subc c s (Pred i l[subc_term c s t/m])\n\ngoal (6 subgoals):\n 1. \\<And>p1 p2 s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p1[t/m]) = subc c s (p1[subc_term c s t/m]);\n        \\<And>s m t.\n           new_term c s \\<Longrightarrow>\n           subc c s (p2[t/m]) = subc c s (p2[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (And p1 p2[t/m]) =\n                         subc c s (And p1 p2[subc_term c s t/m])\n 2. \\<And>p1 p2 s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p1[t/m]) = subc c s (p1[subc_term c s t/m]);\n        \\<And>s m t.\n           new_term c s \\<Longrightarrow>\n           subc c s (p2[t/m]) = subc c s (p2[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Or p1 p2[t/m]) =\n                         subc c s (Or p1 p2[subc_term c s t/m])\n 3. \\<And>p1 p2 s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p1[t/m]) = subc c s (p1[subc_term c s t/m]);\n        \\<And>s m t.\n           new_term c s \\<Longrightarrow>\n           subc c s (p2[t/m]) = subc c s (p2[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Impl p1 p2[t/m]) =\n                         subc c s (Impl p1 p2[subc_term c s t/m])\n 4. \\<And>p s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p[t/m]) = subc c s (p[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Neg p[t/m]) =\n                         subc c s (Neg p[subc_term c s t/m])\n 5. \\<And>p s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p[t/m]) = subc c s (p[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Forall p[t/m]) =\n                         subc c s (Forall p[subc_term c s t/m])\n 6. \\<And>p s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p[t/m]) = subc c s (p[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Exists p[t/m]) =\n                         subc c s (Exists p[subc_term c s t/m])", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>p1 p2 s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p1[t/m]) = subc c s (p1[subc_term c s t/m]);\n        \\<And>s m t.\n           new_term c s \\<Longrightarrow>\n           subc c s (p2[t/m]) = subc c s (p2[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (And p1 p2[t/m]) =\n                         subc c s (And p1 p2[subc_term c s t/m])\n 2. \\<And>p1 p2 s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p1[t/m]) = subc c s (p1[subc_term c s t/m]);\n        \\<And>s m t.\n           new_term c s \\<Longrightarrow>\n           subc c s (p2[t/m]) = subc c s (p2[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Or p1 p2[t/m]) =\n                         subc c s (Or p1 p2[subc_term c s t/m])\n 3. \\<And>p1 p2 s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p1[t/m]) = subc c s (p1[subc_term c s t/m]);\n        \\<And>s m t.\n           new_term c s \\<Longrightarrow>\n           subc c s (p2[t/m]) = subc c s (p2[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Impl p1 p2[t/m]) =\n                         subc c s (Impl p1 p2[subc_term c s t/m])\n 4. \\<And>p s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p[t/m]) = subc c s (p[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Neg p[t/m]) =\n                         subc c s (Neg p[subc_term c s t/m])\n 5. \\<And>p s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p[t/m]) = subc c s (p[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Forall p[t/m]) =\n                         subc c s (Forall p[subc_term c s t/m])\n 6. \\<And>p s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p[t/m]) = subc c s (p[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Exists p[t/m]) =\n                         subc c s (Exists p[subc_term c s t/m])", "case (Neg p)"], ["proof (state)\nthis:\n  new_term c ?s \\<Longrightarrow>\n  subc c ?s (p[?t/?m]) = subc c ?s (p[subc_term c ?s ?t/?m])\n  new_term c s\n\ngoal (6 subgoals):\n 1. \\<And>p1 p2 s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p1[t/m]) = subc c s (p1[subc_term c s t/m]);\n        \\<And>s m t.\n           new_term c s \\<Longrightarrow>\n           subc c s (p2[t/m]) = subc c s (p2[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (And p1 p2[t/m]) =\n                         subc c s (And p1 p2[subc_term c s t/m])\n 2. \\<And>p1 p2 s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p1[t/m]) = subc c s (p1[subc_term c s t/m]);\n        \\<And>s m t.\n           new_term c s \\<Longrightarrow>\n           subc c s (p2[t/m]) = subc c s (p2[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Or p1 p2[t/m]) =\n                         subc c s (Or p1 p2[subc_term c s t/m])\n 3. \\<And>p1 p2 s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p1[t/m]) = subc c s (p1[subc_term c s t/m]);\n        \\<And>s m t.\n           new_term c s \\<Longrightarrow>\n           subc c s (p2[t/m]) = subc c s (p2[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Impl p1 p2[t/m]) =\n                         subc c s (Impl p1 p2[subc_term c s t/m])\n 4. \\<And>p s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p[t/m]) = subc c s (p[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Neg p[t/m]) =\n                         subc c s (Neg p[subc_term c s t/m])\n 5. \\<And>p s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p[t/m]) = subc c s (p[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Forall p[t/m]) =\n                         subc c s (Forall p[subc_term c s t/m])\n 6. \\<And>p s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p[t/m]) = subc c s (p[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Exists p[t/m]) =\n                         subc c s (Exists p[subc_term c s t/m])", "then"], ["proof (chain)\npicking this:\n  new_term c ?s \\<Longrightarrow>\n  subc c ?s (p[?t/?m]) = subc c ?s (p[subc_term c ?s ?t/?m])\n  new_term c s", "show ?case"], ["proof (prove)\nusing this:\n  new_term c ?s \\<Longrightarrow>\n  subc c ?s (p[?t/?m]) = subc c ?s (p[subc_term c ?s ?t/?m])\n  new_term c s\n\ngoal (1 subgoal):\n 1. subc c s (Neg p[t/m]) = subc c s (Neg p[subc_term c s t/m])", "by (metis subc.simps(4) subst.simps(7))"], ["proof (state)\nthis:\n  subc c s (Neg p[t/m]) = subc c s (Neg p[subc_term c s t/m])\n\ngoal (5 subgoals):\n 1. \\<And>p1 p2 s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p1[t/m]) = subc c s (p1[subc_term c s t/m]);\n        \\<And>s m t.\n           new_term c s \\<Longrightarrow>\n           subc c s (p2[t/m]) = subc c s (p2[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (And p1 p2[t/m]) =\n                         subc c s (And p1 p2[subc_term c s t/m])\n 2. \\<And>p1 p2 s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p1[t/m]) = subc c s (p1[subc_term c s t/m]);\n        \\<And>s m t.\n           new_term c s \\<Longrightarrow>\n           subc c s (p2[t/m]) = subc c s (p2[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Or p1 p2[t/m]) =\n                         subc c s (Or p1 p2[subc_term c s t/m])\n 3. \\<And>p1 p2 s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p1[t/m]) = subc c s (p1[subc_term c s t/m]);\n        \\<And>s m t.\n           new_term c s \\<Longrightarrow>\n           subc c s (p2[t/m]) = subc c s (p2[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Impl p1 p2[t/m]) =\n                         subc c s (Impl p1 p2[subc_term c s t/m])\n 4. \\<And>p s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p[t/m]) = subc c s (p[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Forall p[t/m]) =\n                         subc c s (Forall p[subc_term c s t/m])\n 5. \\<And>p s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p[t/m]) = subc c s (p[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Exists p[t/m]) =\n                         subc c s (Exists p[subc_term c s t/m])", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>p1 p2 s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p1[t/m]) = subc c s (p1[subc_term c s t/m]);\n        \\<And>s m t.\n           new_term c s \\<Longrightarrow>\n           subc c s (p2[t/m]) = subc c s (p2[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (And p1 p2[t/m]) =\n                         subc c s (And p1 p2[subc_term c s t/m])\n 2. \\<And>p1 p2 s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p1[t/m]) = subc c s (p1[subc_term c s t/m]);\n        \\<And>s m t.\n           new_term c s \\<Longrightarrow>\n           subc c s (p2[t/m]) = subc c s (p2[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Or p1 p2[t/m]) =\n                         subc c s (Or p1 p2[subc_term c s t/m])\n 3. \\<And>p1 p2 s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p1[t/m]) = subc c s (p1[subc_term c s t/m]);\n        \\<And>s m t.\n           new_term c s \\<Longrightarrow>\n           subc c s (p2[t/m]) = subc c s (p2[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Impl p1 p2[t/m]) =\n                         subc c s (Impl p1 p2[subc_term c s t/m])\n 4. \\<And>p s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p[t/m]) = subc c s (p[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Forall p[t/m]) =\n                         subc c s (Forall p[subc_term c s t/m])\n 5. \\<And>p s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p[t/m]) = subc c s (p[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Exists p[t/m]) =\n                         subc c s (Exists p[subc_term c s t/m])", "case (Impl p q)"], ["proof (state)\nthis:\n  new_term c ?s \\<Longrightarrow>\n  subc c ?s (p[?t/?m]) = subc c ?s (p[subc_term c ?s ?t/?m])\n  new_term c ?s \\<Longrightarrow>\n  subc c ?s (q[?t/?m]) = subc c ?s (q[subc_term c ?s ?t/?m])\n  new_term c s\n\ngoal (5 subgoals):\n 1. \\<And>p1 p2 s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p1[t/m]) = subc c s (p1[subc_term c s t/m]);\n        \\<And>s m t.\n           new_term c s \\<Longrightarrow>\n           subc c s (p2[t/m]) = subc c s (p2[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (And p1 p2[t/m]) =\n                         subc c s (And p1 p2[subc_term c s t/m])\n 2. \\<And>p1 p2 s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p1[t/m]) = subc c s (p1[subc_term c s t/m]);\n        \\<And>s m t.\n           new_term c s \\<Longrightarrow>\n           subc c s (p2[t/m]) = subc c s (p2[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Or p1 p2[t/m]) =\n                         subc c s (Or p1 p2[subc_term c s t/m])\n 3. \\<And>p1 p2 s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p1[t/m]) = subc c s (p1[subc_term c s t/m]);\n        \\<And>s m t.\n           new_term c s \\<Longrightarrow>\n           subc c s (p2[t/m]) = subc c s (p2[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Impl p1 p2[t/m]) =\n                         subc c s (Impl p1 p2[subc_term c s t/m])\n 4. \\<And>p s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p[t/m]) = subc c s (p[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Forall p[t/m]) =\n                         subc c s (Forall p[subc_term c s t/m])\n 5. \\<And>p s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p[t/m]) = subc c s (p[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Exists p[t/m]) =\n                         subc c s (Exists p[subc_term c s t/m])", "then"], ["proof (chain)\npicking this:\n  new_term c ?s \\<Longrightarrow>\n  subc c ?s (p[?t/?m]) = subc c ?s (p[subc_term c ?s ?t/?m])\n  new_term c ?s \\<Longrightarrow>\n  subc c ?s (q[?t/?m]) = subc c ?s (q[subc_term c ?s ?t/?m])\n  new_term c s", "show ?case"], ["proof (prove)\nusing this:\n  new_term c ?s \\<Longrightarrow>\n  subc c ?s (p[?t/?m]) = subc c ?s (p[subc_term c ?s ?t/?m])\n  new_term c ?s \\<Longrightarrow>\n  subc c ?s (q[?t/?m]) = subc c ?s (q[subc_term c ?s ?t/?m])\n  new_term c s\n\ngoal (1 subgoal):\n 1. subc c s (Impl p q[t/m]) = subc c s (Impl p q[subc_term c s t/m])", "by (metis subc.simps(5) subst.simps(6))"], ["proof (state)\nthis:\n  subc c s (Impl p q[t/m]) = subc c s (Impl p q[subc_term c s t/m])\n\ngoal (4 subgoals):\n 1. \\<And>p1 p2 s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p1[t/m]) = subc c s (p1[subc_term c s t/m]);\n        \\<And>s m t.\n           new_term c s \\<Longrightarrow>\n           subc c s (p2[t/m]) = subc c s (p2[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (And p1 p2[t/m]) =\n                         subc c s (And p1 p2[subc_term c s t/m])\n 2. \\<And>p1 p2 s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p1[t/m]) = subc c s (p1[subc_term c s t/m]);\n        \\<And>s m t.\n           new_term c s \\<Longrightarrow>\n           subc c s (p2[t/m]) = subc c s (p2[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Or p1 p2[t/m]) =\n                         subc c s (Or p1 p2[subc_term c s t/m])\n 3. \\<And>p s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p[t/m]) = subc c s (p[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Forall p[t/m]) =\n                         subc c s (Forall p[subc_term c s t/m])\n 4. \\<And>p s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p[t/m]) = subc c s (p[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Exists p[t/m]) =\n                         subc c s (Exists p[subc_term c s t/m])", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>p1 p2 s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p1[t/m]) = subc c s (p1[subc_term c s t/m]);\n        \\<And>s m t.\n           new_term c s \\<Longrightarrow>\n           subc c s (p2[t/m]) = subc c s (p2[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (And p1 p2[t/m]) =\n                         subc c s (And p1 p2[subc_term c s t/m])\n 2. \\<And>p1 p2 s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p1[t/m]) = subc c s (p1[subc_term c s t/m]);\n        \\<And>s m t.\n           new_term c s \\<Longrightarrow>\n           subc c s (p2[t/m]) = subc c s (p2[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Or p1 p2[t/m]) =\n                         subc c s (Or p1 p2[subc_term c s t/m])\n 3. \\<And>p s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p[t/m]) = subc c s (p[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Forall p[t/m]) =\n                         subc c s (Forall p[subc_term c s t/m])\n 4. \\<And>p s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p[t/m]) = subc c s (p[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Exists p[t/m]) =\n                         subc c s (Exists p[subc_term c s t/m])", "case (Or p q)"], ["proof (state)\nthis:\n  new_term c ?s \\<Longrightarrow>\n  subc c ?s (p[?t/?m]) = subc c ?s (p[subc_term c ?s ?t/?m])\n  new_term c ?s \\<Longrightarrow>\n  subc c ?s (q[?t/?m]) = subc c ?s (q[subc_term c ?s ?t/?m])\n  new_term c s\n\ngoal (4 subgoals):\n 1. \\<And>p1 p2 s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p1[t/m]) = subc c s (p1[subc_term c s t/m]);\n        \\<And>s m t.\n           new_term c s \\<Longrightarrow>\n           subc c s (p2[t/m]) = subc c s (p2[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (And p1 p2[t/m]) =\n                         subc c s (And p1 p2[subc_term c s t/m])\n 2. \\<And>p1 p2 s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p1[t/m]) = subc c s (p1[subc_term c s t/m]);\n        \\<And>s m t.\n           new_term c s \\<Longrightarrow>\n           subc c s (p2[t/m]) = subc c s (p2[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Or p1 p2[t/m]) =\n                         subc c s (Or p1 p2[subc_term c s t/m])\n 3. \\<And>p s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p[t/m]) = subc c s (p[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Forall p[t/m]) =\n                         subc c s (Forall p[subc_term c s t/m])\n 4. \\<And>p s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p[t/m]) = subc c s (p[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Exists p[t/m]) =\n                         subc c s (Exists p[subc_term c s t/m])", "then"], ["proof (chain)\npicking this:\n  new_term c ?s \\<Longrightarrow>\n  subc c ?s (p[?t/?m]) = subc c ?s (p[subc_term c ?s ?t/?m])\n  new_term c ?s \\<Longrightarrow>\n  subc c ?s (q[?t/?m]) = subc c ?s (q[subc_term c ?s ?t/?m])\n  new_term c s", "show ?case"], ["proof (prove)\nusing this:\n  new_term c ?s \\<Longrightarrow>\n  subc c ?s (p[?t/?m]) = subc c ?s (p[subc_term c ?s ?t/?m])\n  new_term c ?s \\<Longrightarrow>\n  subc c ?s (q[?t/?m]) = subc c ?s (q[subc_term c ?s ?t/?m])\n  new_term c s\n\ngoal (1 subgoal):\n 1. subc c s (Or p q[t/m]) = subc c s (Or p q[subc_term c s t/m])", "by (metis subc.simps(6) subst.simps(5))"], ["proof (state)\nthis:\n  subc c s (Or p q[t/m]) = subc c s (Or p q[subc_term c s t/m])\n\ngoal (3 subgoals):\n 1. \\<And>p1 p2 s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p1[t/m]) = subc c s (p1[subc_term c s t/m]);\n        \\<And>s m t.\n           new_term c s \\<Longrightarrow>\n           subc c s (p2[t/m]) = subc c s (p2[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (And p1 p2[t/m]) =\n                         subc c s (And p1 p2[subc_term c s t/m])\n 2. \\<And>p s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p[t/m]) = subc c s (p[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Forall p[t/m]) =\n                         subc c s (Forall p[subc_term c s t/m])\n 3. \\<And>p s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p[t/m]) = subc c s (p[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Exists p[t/m]) =\n                         subc c s (Exists p[subc_term c s t/m])", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>p1 p2 s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p1[t/m]) = subc c s (p1[subc_term c s t/m]);\n        \\<And>s m t.\n           new_term c s \\<Longrightarrow>\n           subc c s (p2[t/m]) = subc c s (p2[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (And p1 p2[t/m]) =\n                         subc c s (And p1 p2[subc_term c s t/m])\n 2. \\<And>p s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p[t/m]) = subc c s (p[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Forall p[t/m]) =\n                         subc c s (Forall p[subc_term c s t/m])\n 3. \\<And>p s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p[t/m]) = subc c s (p[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Exists p[t/m]) =\n                         subc c s (Exists p[subc_term c s t/m])", "case (And p q)"], ["proof (state)\nthis:\n  new_term c ?s \\<Longrightarrow>\n  subc c ?s (p[?t/?m]) = subc c ?s (p[subc_term c ?s ?t/?m])\n  new_term c ?s \\<Longrightarrow>\n  subc c ?s (q[?t/?m]) = subc c ?s (q[subc_term c ?s ?t/?m])\n  new_term c s\n\ngoal (3 subgoals):\n 1. \\<And>p1 p2 s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p1[t/m]) = subc c s (p1[subc_term c s t/m]);\n        \\<And>s m t.\n           new_term c s \\<Longrightarrow>\n           subc c s (p2[t/m]) = subc c s (p2[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (And p1 p2[t/m]) =\n                         subc c s (And p1 p2[subc_term c s t/m])\n 2. \\<And>p s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p[t/m]) = subc c s (p[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Forall p[t/m]) =\n                         subc c s (Forall p[subc_term c s t/m])\n 3. \\<And>p s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p[t/m]) = subc c s (p[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Exists p[t/m]) =\n                         subc c s (Exists p[subc_term c s t/m])", "then"], ["proof (chain)\npicking this:\n  new_term c ?s \\<Longrightarrow>\n  subc c ?s (p[?t/?m]) = subc c ?s (p[subc_term c ?s ?t/?m])\n  new_term c ?s \\<Longrightarrow>\n  subc c ?s (q[?t/?m]) = subc c ?s (q[subc_term c ?s ?t/?m])\n  new_term c s", "show ?case"], ["proof (prove)\nusing this:\n  new_term c ?s \\<Longrightarrow>\n  subc c ?s (p[?t/?m]) = subc c ?s (p[subc_term c ?s ?t/?m])\n  new_term c ?s \\<Longrightarrow>\n  subc c ?s (q[?t/?m]) = subc c ?s (q[subc_term c ?s ?t/?m])\n  new_term c s\n\ngoal (1 subgoal):\n 1. subc c s (And p q[t/m]) = subc c s (And p q[subc_term c s t/m])", "by (metis subc.simps(7) subst.simps(4))"], ["proof (state)\nthis:\n  subc c s (And p q[t/m]) = subc c s (And p q[subc_term c s t/m])\n\ngoal (2 subgoals):\n 1. \\<And>p s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p[t/m]) = subc c s (p[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Forall p[t/m]) =\n                         subc c s (Forall p[subc_term c s t/m])\n 2. \\<And>p s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p[t/m]) = subc c s (p[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Exists p[t/m]) =\n                         subc c s (Exists p[subc_term c s t/m])", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p[t/m]) = subc c s (p[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Forall p[t/m]) =\n                         subc c s (Forall p[subc_term c s t/m])\n 2. \\<And>p s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p[t/m]) = subc c s (p[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Exists p[t/m]) =\n                         subc c s (Exists p[subc_term c s t/m])", "case (Exists p)"], ["proof (state)\nthis:\n  new_term c ?s \\<Longrightarrow>\n  subc c ?s (p[?t/?m]) = subc c ?s (p[subc_term c ?s ?t/?m])\n  new_term c s\n\ngoal (2 subgoals):\n 1. \\<And>p s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p[t/m]) = subc c s (p[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Forall p[t/m]) =\n                         subc c s (Forall p[subc_term c s t/m])\n 2. \\<And>p s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p[t/m]) = subc c s (p[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Exists p[t/m]) =\n                         subc c s (Exists p[subc_term c s t/m])", "have \\<open>subc c s (subst (Exists p) (subc_term c s t) m) =\n      Exists (subc c (liftt s) (subst p (subc_term c (liftt s) (liftt t)) (Suc m)))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. subc c s (Exists p[subc_term c s t/m]) =\n    Exists (subc c (liftt s) (p[subc_term c (liftt s) (liftt t)/Suc m]))", "by (simp add: lift_subc)"], ["proof (state)\nthis:\n  subc c s (Exists p[subc_term c s t/m]) =\n  Exists (subc c (liftt s) (p[subc_term c (liftt s) (liftt t)/Suc m]))\n\ngoal (2 subgoals):\n 1. \\<And>p s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p[t/m]) = subc c s (p[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Forall p[t/m]) =\n                         subc c s (Forall p[subc_term c s t/m])\n 2. \\<And>p s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p[t/m]) = subc c s (p[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Exists p[t/m]) =\n                         subc c s (Exists p[subc_term c s t/m])", "also"], ["proof (state)\nthis:\n  subc c s (Exists p[subc_term c s t/m]) =\n  Exists (subc c (liftt s) (p[subc_term c (liftt s) (liftt t)/Suc m]))\n\ngoal (2 subgoals):\n 1. \\<And>p s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p[t/m]) = subc c s (p[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Forall p[t/m]) =\n                         subc c s (Forall p[subc_term c s t/m])\n 2. \\<And>p s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p[t/m]) = subc c s (p[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Exists p[t/m]) =\n                         subc c s (Exists p[subc_term c s t/m])", "have \\<open>\\<dots> = Exists (subc c (liftt s) (subst p (liftt t) (Suc m)))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Exists (subc c (liftt s) (p[subc_term c (liftt s) (liftt t)/Suc m])) =\n    Exists (subc c (liftt s) (p[liftt t/Suc m]))", "using Exists new_lift(1)"], ["proof (prove)\nusing this:\n  new_term c ?s \\<Longrightarrow>\n  subc c ?s (p[?t/?m]) = subc c ?s (p[subc_term c ?s ?t/?m])\n  new_term c s\n  new_term ?c ?t \\<Longrightarrow> new_term ?c (liftt ?t)\n\ngoal (1 subgoal):\n 1. Exists (subc c (liftt s) (p[subc_term c (liftt s) (liftt t)/Suc m])) =\n    Exists (subc c (liftt s) (p[liftt t/Suc m]))", "by metis"], ["proof (state)\nthis:\n  Exists (subc c (liftt s) (p[subc_term c (liftt s) (liftt t)/Suc m])) =\n  Exists (subc c (liftt s) (p[liftt t/Suc m]))\n\ngoal (2 subgoals):\n 1. \\<And>p s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p[t/m]) = subc c s (p[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Forall p[t/m]) =\n                         subc c s (Forall p[subc_term c s t/m])\n 2. \\<And>p s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p[t/m]) = subc c s (p[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Exists p[t/m]) =\n                         subc c s (Exists p[subc_term c s t/m])", "finally"], ["proof (chain)\npicking this:\n  subc c s (Exists p[subc_term c s t/m]) =\n  Exists (subc c (liftt s) (p[liftt t/Suc m]))", "show ?case"], ["proof (prove)\nusing this:\n  subc c s (Exists p[subc_term c s t/m]) =\n  Exists (subc c (liftt s) (p[liftt t/Suc m]))\n\ngoal (1 subgoal):\n 1. subc c s (Exists p[t/m]) = subc c s (Exists p[subc_term c s t/m])", "by simp"], ["proof (state)\nthis:\n  subc c s (Exists p[t/m]) = subc c s (Exists p[subc_term c s t/m])\n\ngoal (1 subgoal):\n 1. \\<And>p s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p[t/m]) = subc c s (p[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Forall p[t/m]) =\n                         subc c s (Forall p[subc_term c s t/m])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p[t/m]) = subc c s (p[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Forall p[t/m]) =\n                         subc c s (Forall p[subc_term c s t/m])", "case (Forall p)"], ["proof (state)\nthis:\n  new_term c ?s \\<Longrightarrow>\n  subc c ?s (p[?t/?m]) = subc c ?s (p[subc_term c ?s ?t/?m])\n  new_term c s\n\ngoal (1 subgoal):\n 1. \\<And>p s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p[t/m]) = subc c s (p[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Forall p[t/m]) =\n                         subc c s (Forall p[subc_term c s t/m])", "have \\<open>subc c s (subst (Forall p) (subc_term c s t) m) =\n      Forall (subc c (liftt s) (subst p (subc_term c (liftt s) (liftt t)) (Suc m)))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. subc c s (Forall p[subc_term c s t/m]) =\n    Forall (subc c (liftt s) (p[subc_term c (liftt s) (liftt t)/Suc m]))", "by (simp add: lift_subc)"], ["proof (state)\nthis:\n  subc c s (Forall p[subc_term c s t/m]) =\n  Forall (subc c (liftt s) (p[subc_term c (liftt s) (liftt t)/Suc m]))\n\ngoal (1 subgoal):\n 1. \\<And>p s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p[t/m]) = subc c s (p[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Forall p[t/m]) =\n                         subc c s (Forall p[subc_term c s t/m])", "also"], ["proof (state)\nthis:\n  subc c s (Forall p[subc_term c s t/m]) =\n  Forall (subc c (liftt s) (p[subc_term c (liftt s) (liftt t)/Suc m]))\n\ngoal (1 subgoal):\n 1. \\<And>p s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p[t/m]) = subc c s (p[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Forall p[t/m]) =\n                         subc c s (Forall p[subc_term c s t/m])", "have \\<open>\\<dots> = Forall (subc c (liftt s) (subst p (liftt t) (Suc m)))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Forall (subc c (liftt s) (p[subc_term c (liftt s) (liftt t)/Suc m])) =\n    Forall (subc c (liftt s) (p[liftt t/Suc m]))", "using Forall new_lift(1)"], ["proof (prove)\nusing this:\n  new_term c ?s \\<Longrightarrow>\n  subc c ?s (p[?t/?m]) = subc c ?s (p[subc_term c ?s ?t/?m])\n  new_term c s\n  new_term ?c ?t \\<Longrightarrow> new_term ?c (liftt ?t)\n\ngoal (1 subgoal):\n 1. Forall (subc c (liftt s) (p[subc_term c (liftt s) (liftt t)/Suc m])) =\n    Forall (subc c (liftt s) (p[liftt t/Suc m]))", "by metis"], ["proof (state)\nthis:\n  Forall (subc c (liftt s) (p[subc_term c (liftt s) (liftt t)/Suc m])) =\n  Forall (subc c (liftt s) (p[liftt t/Suc m]))\n\ngoal (1 subgoal):\n 1. \\<And>p s m t.\n       \\<lbrakk>\\<And>s m t.\n                   new_term c s \\<Longrightarrow>\n                   subc c s (p[t/m]) = subc c s (p[subc_term c s t/m]);\n        new_term c s\\<rbrakk>\n       \\<Longrightarrow> subc c s (Forall p[t/m]) =\n                         subc c s (Forall p[subc_term c s t/m])", "finally"], ["proof (chain)\npicking this:\n  subc c s (Forall p[subc_term c s t/m]) =\n  Forall (subc c (liftt s) (p[liftt t/Suc m]))", "show ?case"], ["proof (prove)\nusing this:\n  subc c s (Forall p[subc_term c s t/m]) =\n  Forall (subc c (liftt s) (p[liftt t/Suc m]))\n\ngoal (1 subgoal):\n 1. subc c s (Forall p[t/m]) = subc c s (Forall p[subc_term c s t/m])", "by simp"], ["proof (state)\nthis:\n  subc c s (Forall p[t/m]) = subc c s (Forall p[subc_term c s t/m])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subc_subst_new':\n  \\<open>new_term c u \\<Longrightarrow> subc_term c (substt s u m) (substt t u m) = substt (subc_term c s t) u m\\<close>\n  \\<open>new_term c u \\<Longrightarrow> subc_list c (substt s u m) (substts l u m) = substts (subc_list c s l) u m\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (new_term c u \\<Longrightarrow>\n     subc_term c (s[u/m]) (t[u/m]) = subc_term c s t[u/m]) &&&\n    (new_term c u \\<Longrightarrow>\n     subc_list c (s[u/m]) (l[u/m]) = subc_list c s l[u/m])", "by (induct t and l rule: subc_term.induct subc_list.induct) simp_all"], ["", "lemma subc_subst_new:\n  \\<open>new_term c t \\<Longrightarrow> subc c (substt s t m) (subst p t m) = subst (subc c s p) t m\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. new_term c t \\<Longrightarrow>\n    subc c (s[t/m]) (p[t/m]) = subc c s p[t/m]", "using subc_subst_new'"], ["proof (prove)\nusing this:\n  new_term ?c ?u \\<Longrightarrow>\n  subc_term ?c (?s[?u/?m]) (?t[?u/?m]) = subc_term ?c ?s ?t[?u/?m]\n  new_term ?c ?u \\<Longrightarrow>\n  subc_list ?c (?s[?u/?m]) (?l[?u/?m]) = subc_list ?c ?s ?l[?u/?m]\n\ngoal (1 subgoal):\n 1. new_term c t \\<Longrightarrow>\n    subc c (s[t/m]) (p[t/m]) = subc c s p[t/m]", "by (induct p arbitrary: m t s) fastforce+"], ["", "lemma subc_sub_0_new [simp]:\n  \\<open>new_term c t \\<Longrightarrow> subc c s (subst p t 0) = subst (subc c (liftt s) p) t 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. new_term c t \\<Longrightarrow>\n    subc c s (p[t/0]) = subc c (liftt s) p[t/0]", "using subc_subst_new subst_0_lift(1)"], ["proof (prove)\nusing this:\n  new_term ?c ?t \\<Longrightarrow>\n  subc ?c (?s[?t/?m]) (?p[?t/?m]) = subc ?c ?s ?p[?t/?m]\n  liftt ?t[?s/0] = ?t\n\ngoal (1 subgoal):\n 1. new_term c t \\<Longrightarrow>\n    subc c s (p[t/0]) = subc c (liftt s) p[t/0]", "by metis"], ["", "lemma member_subc: \\<open>p \\<in> set z \\<Longrightarrow> subc c s p \\<in> set (subcs c s z)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> set z \\<Longrightarrow> subc c s p \\<in> set (subcs c s z)", "by (induct z) auto"], ["", "lemma deriv_subc:\n  fixes p :: \\<open>('a, 'b) form\\<close>\n  assumes inf_params: \\<open>infinite (UNIV :: 'a set)\\<close>\n  shows \\<open>z \\<turnstile> p \\<Longrightarrow> subcs c s z \\<turnstile> subc c s p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<turnstile> p \\<Longrightarrow> subcs c s z \\<turnstile> subc c s p", "proof (induct z p arbitrary: c s rule: deriv.induct)"], ["proof (state)\ngoal (18 subgoals):\n 1. \\<And>a G c s.\n       a \\<in> set G \\<Longrightarrow> subcs c s G \\<turnstile> subc c s a\n 2. \\<And>G c s. subcs c s G \\<turnstile> subc c s TT\n 3. \\<And>G a c s.\n       \\<lbrakk>G \\<turnstile> FF;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s FF\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s a\n 4. \\<And>a G c s.\n       \\<lbrakk>a # G \\<turnstile> FF;\n        \\<And>c s. subcs c s (a # G) \\<turnstile> subc c s FF\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Neg a)\n 5. \\<And>G a c s.\n       \\<lbrakk>G \\<turnstile> Neg a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Neg a);\n        G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s FF\n 6. \\<And>a G c s.\n       \\<lbrakk>Neg a # G \\<turnstile> FF;\n        \\<And>c s. subcs c s (Neg a # G) \\<turnstile> subc c s FF\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s a\n 7. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a; G \\<turnstile> b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (And a b)\n 8. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s a\n 9. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s b\n 10. \\<And>G a b c s.\n        \\<lbrakk>G \\<turnstile> a;\n         \\<And>c s. subcs c s G \\<turnstile> subc c s a\\<rbrakk>\n        \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Or a b)\nA total of 18 subgoals...", "case (Assum p z)"], ["proof (state)\nthis:\n  p \\<in> set z\n\ngoal (18 subgoals):\n 1. \\<And>a G c s.\n       a \\<in> set G \\<Longrightarrow> subcs c s G \\<turnstile> subc c s a\n 2. \\<And>G c s. subcs c s G \\<turnstile> subc c s TT\n 3. \\<And>G a c s.\n       \\<lbrakk>G \\<turnstile> FF;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s FF\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s a\n 4. \\<And>a G c s.\n       \\<lbrakk>a # G \\<turnstile> FF;\n        \\<And>c s. subcs c s (a # G) \\<turnstile> subc c s FF\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Neg a)\n 5. \\<And>G a c s.\n       \\<lbrakk>G \\<turnstile> Neg a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Neg a);\n        G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s FF\n 6. \\<And>a G c s.\n       \\<lbrakk>Neg a # G \\<turnstile> FF;\n        \\<And>c s. subcs c s (Neg a # G) \\<turnstile> subc c s FF\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s a\n 7. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a; G \\<turnstile> b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (And a b)\n 8. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s a\n 9. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s b\n 10. \\<And>G a b c s.\n        \\<lbrakk>G \\<turnstile> a;\n         \\<And>c s. subcs c s G \\<turnstile> subc c s a\\<rbrakk>\n        \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Or a b)\nA total of 18 subgoals...", "then"], ["proof (chain)\npicking this:\n  p \\<in> set z", "show ?case"], ["proof (prove)\nusing this:\n  p \\<in> set z\n\ngoal (1 subgoal):\n 1. subcs c s z \\<turnstile> subc c s p", "using member_subc deriv.Assum"], ["proof (prove)\nusing this:\n  p \\<in> set z\n  ?p \\<in> set ?z \\<Longrightarrow> subc ?c ?s ?p \\<in> set (subcs ?c ?s ?z)\n  ?a \\<in> set ?G \\<Longrightarrow> ?G \\<turnstile> ?a\n\ngoal (1 subgoal):\n 1. subcs c s z \\<turnstile> subc c s p", "by fast"], ["proof (state)\nthis:\n  subcs c s z \\<turnstile> subc c s p\n\ngoal (17 subgoals):\n 1. \\<And>G c s. subcs c s G \\<turnstile> subc c s TT\n 2. \\<And>G a c s.\n       \\<lbrakk>G \\<turnstile> FF;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s FF\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s a\n 3. \\<And>a G c s.\n       \\<lbrakk>a # G \\<turnstile> FF;\n        \\<And>c s. subcs c s (a # G) \\<turnstile> subc c s FF\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Neg a)\n 4. \\<And>G a c s.\n       \\<lbrakk>G \\<turnstile> Neg a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Neg a);\n        G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s FF\n 5. \\<And>a G c s.\n       \\<lbrakk>Neg a # G \\<turnstile> FF;\n        \\<And>c s. subcs c s (Neg a # G) \\<turnstile> subc c s FF\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s a\n 6. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a; G \\<turnstile> b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (And a b)\n 7. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s a\n 8. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s b\n 9. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Or a b)\n 10. \\<And>G b a c s.\n        \\<lbrakk>G \\<turnstile> b;\n         \\<And>c s. subcs c s G \\<turnstile> subc c s b\\<rbrakk>\n        \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Or a b)\nA total of 17 subgoals...", "next"], ["proof (state)\ngoal (17 subgoals):\n 1. \\<And>G c s. subcs c s G \\<turnstile> subc c s TT\n 2. \\<And>G a c s.\n       \\<lbrakk>G \\<turnstile> FF;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s FF\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s a\n 3. \\<And>a G c s.\n       \\<lbrakk>a # G \\<turnstile> FF;\n        \\<And>c s. subcs c s (a # G) \\<turnstile> subc c s FF\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Neg a)\n 4. \\<And>G a c s.\n       \\<lbrakk>G \\<turnstile> Neg a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Neg a);\n        G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s FF\n 5. \\<And>a G c s.\n       \\<lbrakk>Neg a # G \\<turnstile> FF;\n        \\<And>c s. subcs c s (Neg a # G) \\<turnstile> subc c s FF\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s a\n 6. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a; G \\<turnstile> b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (And a b)\n 7. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s a\n 8. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s b\n 9. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Or a b)\n 10. \\<And>G b a c s.\n        \\<lbrakk>G \\<turnstile> b;\n         \\<And>c s. subcs c s G \\<turnstile> subc c s b\\<rbrakk>\n        \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Or a b)\nA total of 17 subgoals...", "case TTI"], ["proof (state)\nthis:\n  \n\ngoal (17 subgoals):\n 1. \\<And>G c s. subcs c s G \\<turnstile> subc c s TT\n 2. \\<And>G a c s.\n       \\<lbrakk>G \\<turnstile> FF;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s FF\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s a\n 3. \\<And>a G c s.\n       \\<lbrakk>a # G \\<turnstile> FF;\n        \\<And>c s. subcs c s (a # G) \\<turnstile> subc c s FF\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Neg a)\n 4. \\<And>G a c s.\n       \\<lbrakk>G \\<turnstile> Neg a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Neg a);\n        G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s FF\n 5. \\<And>a G c s.\n       \\<lbrakk>Neg a # G \\<turnstile> FF;\n        \\<And>c s. subcs c s (Neg a # G) \\<turnstile> subc c s FF\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s a\n 6. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a; G \\<turnstile> b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (And a b)\n 7. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s a\n 8. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s b\n 9. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Or a b)\n 10. \\<And>G b a c s.\n        \\<lbrakk>G \\<turnstile> b;\n         \\<And>c s. subcs c s G \\<turnstile> subc c s b\\<rbrakk>\n        \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Or a b)\nA total of 17 subgoals...", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. subcs c s G_ \\<turnstile> subc c s TT", "using deriv.TTI"], ["proof (prove)\nusing this:\n  ?G \\<turnstile> TT\n\ngoal (1 subgoal):\n 1. subcs c s G_ \\<turnstile> subc c s TT", "by simp"], ["proof (state)\nthis:\n  subcs c s G_ \\<turnstile> subc c s TT\n\ngoal (16 subgoals):\n 1. \\<And>G a c s.\n       \\<lbrakk>G \\<turnstile> FF;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s FF\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s a\n 2. \\<And>a G c s.\n       \\<lbrakk>a # G \\<turnstile> FF;\n        \\<And>c s. subcs c s (a # G) \\<turnstile> subc c s FF\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Neg a)\n 3. \\<And>G a c s.\n       \\<lbrakk>G \\<turnstile> Neg a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Neg a);\n        G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s FF\n 4. \\<And>a G c s.\n       \\<lbrakk>Neg a # G \\<turnstile> FF;\n        \\<And>c s. subcs c s (Neg a # G) \\<turnstile> subc c s FF\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s a\n 5. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a; G \\<turnstile> b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (And a b)\n 6. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s a\n 7. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s b\n 8. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Or a b)\n 9. \\<And>G b a c s.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Or a b)\n 10. \\<And>G a b c ca s.\n        \\<lbrakk>G \\<turnstile> Or a b;\n         \\<And>c s. subcs c s G \\<turnstile> subc c s (Or a b);\n         a # G \\<turnstile> c;\n         \\<And>ca s. subcs ca s (a # G) \\<turnstile> subc ca s c;\n         b # G \\<turnstile> c;\n         \\<And>ca s. subcs ca s (b # G) \\<turnstile> subc ca s c\\<rbrakk>\n        \\<Longrightarrow> subcs ca s G \\<turnstile> subc ca s c\nA total of 16 subgoals...", "case FFE"], ["proof (state)\nthis:\n  G_ \\<turnstile> FF\n  subcs ?c ?s G_ \\<turnstile> subc ?c ?s FF\n\ngoal (16 subgoals):\n 1. \\<And>G a c s.\n       \\<lbrakk>G \\<turnstile> FF;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s FF\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s a\n 2. \\<And>a G c s.\n       \\<lbrakk>a # G \\<turnstile> FF;\n        \\<And>c s. subcs c s (a # G) \\<turnstile> subc c s FF\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Neg a)\n 3. \\<And>G a c s.\n       \\<lbrakk>G \\<turnstile> Neg a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Neg a);\n        G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s FF\n 4. \\<And>a G c s.\n       \\<lbrakk>Neg a # G \\<turnstile> FF;\n        \\<And>c s. subcs c s (Neg a # G) \\<turnstile> subc c s FF\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s a\n 5. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a; G \\<turnstile> b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (And a b)\n 6. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s a\n 7. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s b\n 8. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Or a b)\n 9. \\<And>G b a c s.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Or a b)\n 10. \\<And>G a b c ca s.\n        \\<lbrakk>G \\<turnstile> Or a b;\n         \\<And>c s. subcs c s G \\<turnstile> subc c s (Or a b);\n         a # G \\<turnstile> c;\n         \\<And>ca s. subcs ca s (a # G) \\<turnstile> subc ca s c;\n         b # G \\<turnstile> c;\n         \\<And>ca s. subcs ca s (b # G) \\<turnstile> subc ca s c\\<rbrakk>\n        \\<Longrightarrow> subcs ca s G \\<turnstile> subc ca s c\nA total of 16 subgoals...", "then"], ["proof (chain)\npicking this:\n  G_ \\<turnstile> FF\n  subcs ?c ?s G_ \\<turnstile> subc ?c ?s FF", "show ?case"], ["proof (prove)\nusing this:\n  G_ \\<turnstile> FF\n  subcs ?c ?s G_ \\<turnstile> subc ?c ?s FF\n\ngoal (1 subgoal):\n 1. subcs c s G_ \\<turnstile> subc c s a_", "using deriv.FFE"], ["proof (prove)\nusing this:\n  G_ \\<turnstile> FF\n  subcs ?c ?s G_ \\<turnstile> subc ?c ?s FF\n  ?G \\<turnstile> FF \\<Longrightarrow> ?G \\<turnstile> ?a\n\ngoal (1 subgoal):\n 1. subcs c s G_ \\<turnstile> subc c s a_", "by auto"], ["proof (state)\nthis:\n  subcs c s G_ \\<turnstile> subc c s a_\n\ngoal (15 subgoals):\n 1. \\<And>a G c s.\n       \\<lbrakk>a # G \\<turnstile> FF;\n        \\<And>c s. subcs c s (a # G) \\<turnstile> subc c s FF\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Neg a)\n 2. \\<And>G a c s.\n       \\<lbrakk>G \\<turnstile> Neg a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Neg a);\n        G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s FF\n 3. \\<And>a G c s.\n       \\<lbrakk>Neg a # G \\<turnstile> FF;\n        \\<And>c s. subcs c s (Neg a # G) \\<turnstile> subc c s FF\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s a\n 4. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a; G \\<turnstile> b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (And a b)\n 5. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s a\n 6. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s b\n 7. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Or a b)\n 8. \\<And>G b a c s.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Or a b)\n 9. \\<And>G a b c ca s.\n       \\<lbrakk>G \\<turnstile> Or a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Or a b);\n        a # G \\<turnstile> c;\n        \\<And>ca s. subcs ca s (a # G) \\<turnstile> subc ca s c;\n        b # G \\<turnstile> c;\n        \\<And>ca s. subcs ca s (b # G) \\<turnstile> subc ca s c\\<rbrakk>\n       \\<Longrightarrow> subcs ca s G \\<turnstile> subc ca s c\n 10. \\<And>a G b c s.\n        \\<lbrakk>a # G \\<turnstile> b;\n         \\<And>c s. subcs c s (a # G) \\<turnstile> subc c s b\\<rbrakk>\n        \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Impl a b)\nA total of 15 subgoals...", "next"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>a G c s.\n       \\<lbrakk>a # G \\<turnstile> FF;\n        \\<And>c s. subcs c s (a # G) \\<turnstile> subc c s FF\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Neg a)\n 2. \\<And>G a c s.\n       \\<lbrakk>G \\<turnstile> Neg a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Neg a);\n        G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s FF\n 3. \\<And>a G c s.\n       \\<lbrakk>Neg a # G \\<turnstile> FF;\n        \\<And>c s. subcs c s (Neg a # G) \\<turnstile> subc c s FF\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s a\n 4. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a; G \\<turnstile> b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (And a b)\n 5. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s a\n 6. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s b\n 7. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Or a b)\n 8. \\<And>G b a c s.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Or a b)\n 9. \\<And>G a b c ca s.\n       \\<lbrakk>G \\<turnstile> Or a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Or a b);\n        a # G \\<turnstile> c;\n        \\<And>ca s. subcs ca s (a # G) \\<turnstile> subc ca s c;\n        b # G \\<turnstile> c;\n        \\<And>ca s. subcs ca s (b # G) \\<turnstile> subc ca s c\\<rbrakk>\n       \\<Longrightarrow> subcs ca s G \\<turnstile> subc ca s c\n 10. \\<And>a G b c s.\n        \\<lbrakk>a # G \\<turnstile> b;\n         \\<And>c s. subcs c s (a # G) \\<turnstile> subc c s b\\<rbrakk>\n        \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Impl a b)\nA total of 15 subgoals...", "case (NegI z p)"], ["proof (state)\nthis:\n  z # p \\<turnstile> FF\n  subcs ?c ?s (z # p) \\<turnstile> subc ?c ?s FF\n\ngoal (15 subgoals):\n 1. \\<And>a G c s.\n       \\<lbrakk>a # G \\<turnstile> FF;\n        \\<And>c s. subcs c s (a # G) \\<turnstile> subc c s FF\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Neg a)\n 2. \\<And>G a c s.\n       \\<lbrakk>G \\<turnstile> Neg a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Neg a);\n        G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s FF\n 3. \\<And>a G c s.\n       \\<lbrakk>Neg a # G \\<turnstile> FF;\n        \\<And>c s. subcs c s (Neg a # G) \\<turnstile> subc c s FF\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s a\n 4. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a; G \\<turnstile> b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (And a b)\n 5. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s a\n 6. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s b\n 7. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Or a b)\n 8. \\<And>G b a c s.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Or a b)\n 9. \\<And>G a b c ca s.\n       \\<lbrakk>G \\<turnstile> Or a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Or a b);\n        a # G \\<turnstile> c;\n        \\<And>ca s. subcs ca s (a # G) \\<turnstile> subc ca s c;\n        b # G \\<turnstile> c;\n        \\<And>ca s. subcs ca s (b # G) \\<turnstile> subc ca s c\\<rbrakk>\n       \\<Longrightarrow> subcs ca s G \\<turnstile> subc ca s c\n 10. \\<And>a G b c s.\n        \\<lbrakk>a # G \\<turnstile> b;\n         \\<And>c s. subcs c s (a # G) \\<turnstile> subc c s b\\<rbrakk>\n        \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Impl a b)\nA total of 15 subgoals...", "then"], ["proof (chain)\npicking this:\n  z # p \\<turnstile> FF\n  subcs ?c ?s (z # p) \\<turnstile> subc ?c ?s FF", "show ?case"], ["proof (prove)\nusing this:\n  z # p \\<turnstile> FF\n  subcs ?c ?s (z # p) \\<turnstile> subc ?c ?s FF\n\ngoal (1 subgoal):\n 1. subcs c s p \\<turnstile> subc c s (Neg z)", "using deriv.NegI"], ["proof (prove)\nusing this:\n  z # p \\<turnstile> FF\n  subcs ?c ?s (z # p) \\<turnstile> subc ?c ?s FF\n  ?a # ?G \\<turnstile> FF \\<Longrightarrow> ?G \\<turnstile> Neg ?a\n\ngoal (1 subgoal):\n 1. subcs c s p \\<turnstile> subc c s (Neg z)", "by auto"], ["proof (state)\nthis:\n  subcs c s p \\<turnstile> subc c s (Neg z)\n\ngoal (14 subgoals):\n 1. \\<And>G a c s.\n       \\<lbrakk>G \\<turnstile> Neg a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Neg a);\n        G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s FF\n 2. \\<And>a G c s.\n       \\<lbrakk>Neg a # G \\<turnstile> FF;\n        \\<And>c s. subcs c s (Neg a # G) \\<turnstile> subc c s FF\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s a\n 3. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a; G \\<turnstile> b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (And a b)\n 4. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s a\n 5. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s b\n 6. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Or a b)\n 7. \\<And>G b a c s.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Or a b)\n 8. \\<And>G a b c ca s.\n       \\<lbrakk>G \\<turnstile> Or a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Or a b);\n        a # G \\<turnstile> c;\n        \\<And>ca s. subcs ca s (a # G) \\<turnstile> subc ca s c;\n        b # G \\<turnstile> c;\n        \\<And>ca s. subcs ca s (b # G) \\<turnstile> subc ca s c\\<rbrakk>\n       \\<Longrightarrow> subcs ca s G \\<turnstile> subc ca s c\n 9. \\<And>a G b c s.\n       \\<lbrakk>a # G \\<turnstile> b;\n        \\<And>c s. subcs c s (a # G) \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Impl a b)\n 10. \\<And>G a b c s.\n        \\<lbrakk>G \\<turnstile> Impl a b;\n         \\<And>c s. subcs c s G \\<turnstile> subc c s (Impl a b);\n         G \\<turnstile> a;\n         \\<And>c s. subcs c s G \\<turnstile> subc c s a\\<rbrakk>\n        \\<Longrightarrow> subcs c s G \\<turnstile> subc c s b\nA total of 14 subgoals...", "next"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>G a c s.\n       \\<lbrakk>G \\<turnstile> Neg a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Neg a);\n        G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s FF\n 2. \\<And>a G c s.\n       \\<lbrakk>Neg a # G \\<turnstile> FF;\n        \\<And>c s. subcs c s (Neg a # G) \\<turnstile> subc c s FF\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s a\n 3. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a; G \\<turnstile> b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (And a b)\n 4. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s a\n 5. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s b\n 6. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Or a b)\n 7. \\<And>G b a c s.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Or a b)\n 8. \\<And>G a b c ca s.\n       \\<lbrakk>G \\<turnstile> Or a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Or a b);\n        a # G \\<turnstile> c;\n        \\<And>ca s. subcs ca s (a # G) \\<turnstile> subc ca s c;\n        b # G \\<turnstile> c;\n        \\<And>ca s. subcs ca s (b # G) \\<turnstile> subc ca s c\\<rbrakk>\n       \\<Longrightarrow> subcs ca s G \\<turnstile> subc ca s c\n 9. \\<And>a G b c s.\n       \\<lbrakk>a # G \\<turnstile> b;\n        \\<And>c s. subcs c s (a # G) \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Impl a b)\n 10. \\<And>G a b c s.\n        \\<lbrakk>G \\<turnstile> Impl a b;\n         \\<And>c s. subcs c s G \\<turnstile> subc c s (Impl a b);\n         G \\<turnstile> a;\n         \\<And>c s. subcs c s G \\<turnstile> subc c s a\\<rbrakk>\n        \\<Longrightarrow> subcs c s G \\<turnstile> subc c s b\nA total of 14 subgoals...", "case (NegE z p)"], ["proof (state)\nthis:\n  z \\<turnstile> Neg p\n  subcs ?c ?s z \\<turnstile> subc ?c ?s (Neg p)\n  z \\<turnstile> p\n  subcs ?c ?s z \\<turnstile> subc ?c ?s p\n\ngoal (14 subgoals):\n 1. \\<And>G a c s.\n       \\<lbrakk>G \\<turnstile> Neg a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Neg a);\n        G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s FF\n 2. \\<And>a G c s.\n       \\<lbrakk>Neg a # G \\<turnstile> FF;\n        \\<And>c s. subcs c s (Neg a # G) \\<turnstile> subc c s FF\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s a\n 3. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a; G \\<turnstile> b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (And a b)\n 4. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s a\n 5. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s b\n 6. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Or a b)\n 7. \\<And>G b a c s.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Or a b)\n 8. \\<And>G a b c ca s.\n       \\<lbrakk>G \\<turnstile> Or a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Or a b);\n        a # G \\<turnstile> c;\n        \\<And>ca s. subcs ca s (a # G) \\<turnstile> subc ca s c;\n        b # G \\<turnstile> c;\n        \\<And>ca s. subcs ca s (b # G) \\<turnstile> subc ca s c\\<rbrakk>\n       \\<Longrightarrow> subcs ca s G \\<turnstile> subc ca s c\n 9. \\<And>a G b c s.\n       \\<lbrakk>a # G \\<turnstile> b;\n        \\<And>c s. subcs c s (a # G) \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Impl a b)\n 10. \\<And>G a b c s.\n        \\<lbrakk>G \\<turnstile> Impl a b;\n         \\<And>c s. subcs c s G \\<turnstile> subc c s (Impl a b);\n         G \\<turnstile> a;\n         \\<And>c s. subcs c s G \\<turnstile> subc c s a\\<rbrakk>\n        \\<Longrightarrow> subcs c s G \\<turnstile> subc c s b\nA total of 14 subgoals...", "then"], ["proof (chain)\npicking this:\n  z \\<turnstile> Neg p\n  subcs ?c ?s z \\<turnstile> subc ?c ?s (Neg p)\n  z \\<turnstile> p\n  subcs ?c ?s z \\<turnstile> subc ?c ?s p", "show ?case"], ["proof (prove)\nusing this:\n  z \\<turnstile> Neg p\n  subcs ?c ?s z \\<turnstile> subc ?c ?s (Neg p)\n  z \\<turnstile> p\n  subcs ?c ?s z \\<turnstile> subc ?c ?s p\n\ngoal (1 subgoal):\n 1. subcs c s z \\<turnstile> subc c s FF", "using deriv.NegE"], ["proof (prove)\nusing this:\n  z \\<turnstile> Neg p\n  subcs ?c ?s z \\<turnstile> subc ?c ?s (Neg p)\n  z \\<turnstile> p\n  subcs ?c ?s z \\<turnstile> subc ?c ?s p\n  \\<lbrakk>?G \\<turnstile> Neg ?a; ?G \\<turnstile> ?a\\<rbrakk>\n  \\<Longrightarrow> ?G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. subcs c s z \\<turnstile> subc c s FF", "by fastforce"], ["proof (state)\nthis:\n  subcs c s z \\<turnstile> subc c s FF\n\ngoal (13 subgoals):\n 1. \\<And>a G c s.\n       \\<lbrakk>Neg a # G \\<turnstile> FF;\n        \\<And>c s. subcs c s (Neg a # G) \\<turnstile> subc c s FF\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s a\n 2. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a; G \\<turnstile> b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (And a b)\n 3. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s a\n 4. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s b\n 5. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Or a b)\n 6. \\<And>G b a c s.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Or a b)\n 7. \\<And>G a b c ca s.\n       \\<lbrakk>G \\<turnstile> Or a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Or a b);\n        a # G \\<turnstile> c;\n        \\<And>ca s. subcs ca s (a # G) \\<turnstile> subc ca s c;\n        b # G \\<turnstile> c;\n        \\<And>ca s. subcs ca s (b # G) \\<turnstile> subc ca s c\\<rbrakk>\n       \\<Longrightarrow> subcs ca s G \\<turnstile> subc ca s c\n 8. \\<And>a G b c s.\n       \\<lbrakk>a # G \\<turnstile> b;\n        \\<And>c s. subcs c s (a # G) \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Impl a b)\n 9. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> Impl a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Impl a b);\n        G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s b\n 10. \\<And>G a n c s.\n        \\<lbrakk>G \\<turnstile> a[App n []/0];\n         \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n         news n G; new n a\\<rbrakk>\n        \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\nA total of 13 subgoals...", "next"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>a G c s.\n       \\<lbrakk>Neg a # G \\<turnstile> FF;\n        \\<And>c s. subcs c s (Neg a # G) \\<turnstile> subc c s FF\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s a\n 2. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a; G \\<turnstile> b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (And a b)\n 3. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s a\n 4. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s b\n 5. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Or a b)\n 6. \\<And>G b a c s.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Or a b)\n 7. \\<And>G a b c ca s.\n       \\<lbrakk>G \\<turnstile> Or a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Or a b);\n        a # G \\<turnstile> c;\n        \\<And>ca s. subcs ca s (a # G) \\<turnstile> subc ca s c;\n        b # G \\<turnstile> c;\n        \\<And>ca s. subcs ca s (b # G) \\<turnstile> subc ca s c\\<rbrakk>\n       \\<Longrightarrow> subcs ca s G \\<turnstile> subc ca s c\n 8. \\<And>a G b c s.\n       \\<lbrakk>a # G \\<turnstile> b;\n        \\<And>c s. subcs c s (a # G) \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Impl a b)\n 9. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> Impl a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Impl a b);\n        G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s b\n 10. \\<And>G a n c s.\n        \\<lbrakk>G \\<turnstile> a[App n []/0];\n         \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n         news n G; new n a\\<rbrakk>\n        \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\nA total of 13 subgoals...", "case (Class p z)"], ["proof (state)\nthis:\n  Neg p # z \\<turnstile> FF\n  subcs ?c ?s (Neg p # z) \\<turnstile> subc ?c ?s FF\n\ngoal (13 subgoals):\n 1. \\<And>a G c s.\n       \\<lbrakk>Neg a # G \\<turnstile> FF;\n        \\<And>c s. subcs c s (Neg a # G) \\<turnstile> subc c s FF\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s a\n 2. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a; G \\<turnstile> b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (And a b)\n 3. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s a\n 4. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s b\n 5. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Or a b)\n 6. \\<And>G b a c s.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Or a b)\n 7. \\<And>G a b c ca s.\n       \\<lbrakk>G \\<turnstile> Or a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Or a b);\n        a # G \\<turnstile> c;\n        \\<And>ca s. subcs ca s (a # G) \\<turnstile> subc ca s c;\n        b # G \\<turnstile> c;\n        \\<And>ca s. subcs ca s (b # G) \\<turnstile> subc ca s c\\<rbrakk>\n       \\<Longrightarrow> subcs ca s G \\<turnstile> subc ca s c\n 8. \\<And>a G b c s.\n       \\<lbrakk>a # G \\<turnstile> b;\n        \\<And>c s. subcs c s (a # G) \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Impl a b)\n 9. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> Impl a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Impl a b);\n        G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s b\n 10. \\<And>G a n c s.\n        \\<lbrakk>G \\<turnstile> a[App n []/0];\n         \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n         news n G; new n a\\<rbrakk>\n        \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\nA total of 13 subgoals...", "then"], ["proof (chain)\npicking this:\n  Neg p # z \\<turnstile> FF\n  subcs ?c ?s (Neg p # z) \\<turnstile> subc ?c ?s FF", "show ?case"], ["proof (prove)\nusing this:\n  Neg p # z \\<turnstile> FF\n  subcs ?c ?s (Neg p # z) \\<turnstile> subc ?c ?s FF\n\ngoal (1 subgoal):\n 1. subcs c s z \\<turnstile> subc c s p", "using deriv.Class"], ["proof (prove)\nusing this:\n  Neg p # z \\<turnstile> FF\n  subcs ?c ?s (Neg p # z) \\<turnstile> subc ?c ?s FF\n  Neg ?a # ?G \\<turnstile> FF \\<Longrightarrow> ?G \\<turnstile> ?a\n\ngoal (1 subgoal):\n 1. subcs c s z \\<turnstile> subc c s p", "by auto"], ["proof (state)\nthis:\n  subcs c s z \\<turnstile> subc c s p\n\ngoal (12 subgoals):\n 1. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a; G \\<turnstile> b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (And a b)\n 2. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s a\n 3. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s b\n 4. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Or a b)\n 5. \\<And>G b a c s.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Or a b)\n 6. \\<And>G a b c ca s.\n       \\<lbrakk>G \\<turnstile> Or a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Or a b);\n        a # G \\<turnstile> c;\n        \\<And>ca s. subcs ca s (a # G) \\<turnstile> subc ca s c;\n        b # G \\<turnstile> c;\n        \\<And>ca s. subcs ca s (b # G) \\<turnstile> subc ca s c\\<rbrakk>\n       \\<Longrightarrow> subcs ca s G \\<turnstile> subc ca s c\n 7. \\<And>a G b c s.\n       \\<lbrakk>a # G \\<turnstile> b;\n        \\<And>c s. subcs c s (a # G) \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Impl a b)\n 8. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> Impl a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Impl a b);\n        G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s b\n 9. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 10. \\<And>G a t c s.\n        \\<lbrakk>G \\<turnstile> Forall a;\n         \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n        \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a; G \\<turnstile> b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (And a b)\n 2. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s a\n 3. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s b\n 4. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Or a b)\n 5. \\<And>G b a c s.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Or a b)\n 6. \\<And>G a b c ca s.\n       \\<lbrakk>G \\<turnstile> Or a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Or a b);\n        a # G \\<turnstile> c;\n        \\<And>ca s. subcs ca s (a # G) \\<turnstile> subc ca s c;\n        b # G \\<turnstile> c;\n        \\<And>ca s. subcs ca s (b # G) \\<turnstile> subc ca s c\\<rbrakk>\n       \\<Longrightarrow> subcs ca s G \\<turnstile> subc ca s c\n 7. \\<And>a G b c s.\n       \\<lbrakk>a # G \\<turnstile> b;\n        \\<And>c s. subcs c s (a # G) \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Impl a b)\n 8. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> Impl a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Impl a b);\n        G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s b\n 9. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 10. \\<And>G a t c s.\n        \\<lbrakk>G \\<turnstile> Forall a;\n         \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n        \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])\nA total of 12 subgoals...", "case (ImplE z p q)"], ["proof (state)\nthis:\n  z \\<turnstile> Impl p q\n  subcs ?c ?s z \\<turnstile> subc ?c ?s (Impl p q)\n  z \\<turnstile> p\n  subcs ?c ?s z \\<turnstile> subc ?c ?s p\n\ngoal (12 subgoals):\n 1. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a; G \\<turnstile> b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (And a b)\n 2. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s a\n 3. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s b\n 4. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Or a b)\n 5. \\<And>G b a c s.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Or a b)\n 6. \\<And>G a b c ca s.\n       \\<lbrakk>G \\<turnstile> Or a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Or a b);\n        a # G \\<turnstile> c;\n        \\<And>ca s. subcs ca s (a # G) \\<turnstile> subc ca s c;\n        b # G \\<turnstile> c;\n        \\<And>ca s. subcs ca s (b # G) \\<turnstile> subc ca s c\\<rbrakk>\n       \\<Longrightarrow> subcs ca s G \\<turnstile> subc ca s c\n 7. \\<And>a G b c s.\n       \\<lbrakk>a # G \\<turnstile> b;\n        \\<And>c s. subcs c s (a # G) \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Impl a b)\n 8. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> Impl a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Impl a b);\n        G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s b\n 9. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 10. \\<And>G a t c s.\n        \\<lbrakk>G \\<turnstile> Forall a;\n         \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n        \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])\nA total of 12 subgoals...", "then"], ["proof (chain)\npicking this:\n  z \\<turnstile> Impl p q\n  subcs ?c ?s z \\<turnstile> subc ?c ?s (Impl p q)\n  z \\<turnstile> p\n  subcs ?c ?s z \\<turnstile> subc ?c ?s p", "show ?case"], ["proof (prove)\nusing this:\n  z \\<turnstile> Impl p q\n  subcs ?c ?s z \\<turnstile> subc ?c ?s (Impl p q)\n  z \\<turnstile> p\n  subcs ?c ?s z \\<turnstile> subc ?c ?s p\n\ngoal (1 subgoal):\n 1. subcs c s z \\<turnstile> subc c s q", "using deriv.ImplE"], ["proof (prove)\nusing this:\n  z \\<turnstile> Impl p q\n  subcs ?c ?s z \\<turnstile> subc ?c ?s (Impl p q)\n  z \\<turnstile> p\n  subcs ?c ?s z \\<turnstile> subc ?c ?s p\n  \\<lbrakk>?G \\<turnstile> Impl ?a ?b; ?G \\<turnstile> ?a\\<rbrakk>\n  \\<Longrightarrow> ?G \\<turnstile> ?b\n\ngoal (1 subgoal):\n 1. subcs c s z \\<turnstile> subc c s q", "by fastforce"], ["proof (state)\nthis:\n  subcs c s z \\<turnstile> subc c s q\n\ngoal (11 subgoals):\n 1. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a; G \\<turnstile> b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (And a b)\n 2. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s a\n 3. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s b\n 4. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Or a b)\n 5. \\<And>G b a c s.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Or a b)\n 6. \\<And>G a b c ca s.\n       \\<lbrakk>G \\<turnstile> Or a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Or a b);\n        a # G \\<turnstile> c;\n        \\<And>ca s. subcs ca s (a # G) \\<turnstile> subc ca s c;\n        b # G \\<turnstile> c;\n        \\<And>ca s. subcs ca s (b # G) \\<turnstile> subc ca s c\\<rbrakk>\n       \\<Longrightarrow> subcs ca s G \\<turnstile> subc ca s c\n 7. \\<And>a G b c s.\n       \\<lbrakk>a # G \\<turnstile> b;\n        \\<And>c s. subcs c s (a # G) \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Impl a b)\n 8. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 9. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])\n 10. \\<And>G a t c s.\n        \\<lbrakk>G \\<turnstile> a[t/0];\n         \\<And>c s. subcs c s G \\<turnstile> subc c s (a[t/0])\\<rbrakk>\n        \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Exists a)\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a; G \\<turnstile> b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (And a b)\n 2. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s a\n 3. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s b\n 4. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Or a b)\n 5. \\<And>G b a c s.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Or a b)\n 6. \\<And>G a b c ca s.\n       \\<lbrakk>G \\<turnstile> Or a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Or a b);\n        a # G \\<turnstile> c;\n        \\<And>ca s. subcs ca s (a # G) \\<turnstile> subc ca s c;\n        b # G \\<turnstile> c;\n        \\<And>ca s. subcs ca s (b # G) \\<turnstile> subc ca s c\\<rbrakk>\n       \\<Longrightarrow> subcs ca s G \\<turnstile> subc ca s c\n 7. \\<And>a G b c s.\n       \\<lbrakk>a # G \\<turnstile> b;\n        \\<And>c s. subcs c s (a # G) \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Impl a b)\n 8. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 9. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])\n 10. \\<And>G a t c s.\n        \\<lbrakk>G \\<turnstile> a[t/0];\n         \\<And>c s. subcs c s G \\<turnstile> subc c s (a[t/0])\\<rbrakk>\n        \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Exists a)\nA total of 11 subgoals...", "case (ImplI z q p)"], ["proof (state)\nthis:\n  z # q \\<turnstile> p\n  subcs ?c ?s (z # q) \\<turnstile> subc ?c ?s p\n\ngoal (11 subgoals):\n 1. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a; G \\<turnstile> b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (And a b)\n 2. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s a\n 3. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s b\n 4. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Or a b)\n 5. \\<And>G b a c s.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Or a b)\n 6. \\<And>G a b c ca s.\n       \\<lbrakk>G \\<turnstile> Or a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Or a b);\n        a # G \\<turnstile> c;\n        \\<And>ca s. subcs ca s (a # G) \\<turnstile> subc ca s c;\n        b # G \\<turnstile> c;\n        \\<And>ca s. subcs ca s (b # G) \\<turnstile> subc ca s c\\<rbrakk>\n       \\<Longrightarrow> subcs ca s G \\<turnstile> subc ca s c\n 7. \\<And>a G b c s.\n       \\<lbrakk>a # G \\<turnstile> b;\n        \\<And>c s. subcs c s (a # G) \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Impl a b)\n 8. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 9. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])\n 10. \\<And>G a t c s.\n        \\<lbrakk>G \\<turnstile> a[t/0];\n         \\<And>c s. subcs c s G \\<turnstile> subc c s (a[t/0])\\<rbrakk>\n        \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Exists a)\nA total of 11 subgoals...", "then"], ["proof (chain)\npicking this:\n  z # q \\<turnstile> p\n  subcs ?c ?s (z # q) \\<turnstile> subc ?c ?s p", "show ?case"], ["proof (prove)\nusing this:\n  z # q \\<turnstile> p\n  subcs ?c ?s (z # q) \\<turnstile> subc ?c ?s p\n\ngoal (1 subgoal):\n 1. subcs c s q \\<turnstile> subc c s (Impl z p)", "using deriv.ImplI"], ["proof (prove)\nusing this:\n  z # q \\<turnstile> p\n  subcs ?c ?s (z # q) \\<turnstile> subc ?c ?s p\n  ?a # ?G \\<turnstile> ?b \\<Longrightarrow> ?G \\<turnstile> Impl ?a ?b\n\ngoal (1 subgoal):\n 1. subcs c s q \\<turnstile> subc c s (Impl z p)", "by fastforce"], ["proof (state)\nthis:\n  subcs c s q \\<turnstile> subc c s (Impl z p)\n\ngoal (10 subgoals):\n 1. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a; G \\<turnstile> b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (And a b)\n 2. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s a\n 3. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s b\n 4. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Or a b)\n 5. \\<And>G b a c s.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Or a b)\n 6. \\<And>G a b c ca s.\n       \\<lbrakk>G \\<turnstile> Or a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Or a b);\n        a # G \\<turnstile> c;\n        \\<And>ca s. subcs ca s (a # G) \\<turnstile> subc ca s c;\n        b # G \\<turnstile> c;\n        \\<And>ca s. subcs ca s (b # G) \\<turnstile> subc ca s c\\<rbrakk>\n       \\<Longrightarrow> subcs ca s G \\<turnstile> subc ca s c\n 7. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 8. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])\n 9. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Exists a)\n 10. \\<And>G a n b c s.\n        \\<lbrakk>G \\<turnstile> Exists a;\n         \\<And>c s. subcs c s G \\<turnstile> subc c s (Exists a);\n         a[App n []/0] # G \\<turnstile> b;\n         \\<And>c s. subcs c s (a[App n []/0] # G) \\<turnstile> subc c s b;\n         news n G; new n a; new n b\\<rbrakk>\n        \\<Longrightarrow> subcs c s G \\<turnstile> subc c s b", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a; G \\<turnstile> b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (And a b)\n 2. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s a\n 3. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s b\n 4. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Or a b)\n 5. \\<And>G b a c s.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Or a b)\n 6. \\<And>G a b c ca s.\n       \\<lbrakk>G \\<turnstile> Or a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Or a b);\n        a # G \\<turnstile> c;\n        \\<And>ca s. subcs ca s (a # G) \\<turnstile> subc ca s c;\n        b # G \\<turnstile> c;\n        \\<And>ca s. subcs ca s (b # G) \\<turnstile> subc ca s c\\<rbrakk>\n       \\<Longrightarrow> subcs ca s G \\<turnstile> subc ca s c\n 7. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 8. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])\n 9. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Exists a)\n 10. \\<And>G a n b c s.\n        \\<lbrakk>G \\<turnstile> Exists a;\n         \\<And>c s. subcs c s G \\<turnstile> subc c s (Exists a);\n         a[App n []/0] # G \\<turnstile> b;\n         \\<And>c s. subcs c s (a[App n []/0] # G) \\<turnstile> subc c s b;\n         news n G; new n a; new n b\\<rbrakk>\n        \\<Longrightarrow> subcs c s G \\<turnstile> subc c s b", "case (OrE z p q r)"], ["proof (state)\nthis:\n  z \\<turnstile> Or p q\n  subcs ?c ?s z \\<turnstile> subc ?c ?s (Or p q)\n  p # z \\<turnstile> r\n  subcs ?c ?s (p # z) \\<turnstile> subc ?c ?s r\n  q # z \\<turnstile> r\n  subcs ?c ?s (q # z) \\<turnstile> subc ?c ?s r\n\ngoal (10 subgoals):\n 1. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a; G \\<turnstile> b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (And a b)\n 2. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s a\n 3. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s b\n 4. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Or a b)\n 5. \\<And>G b a c s.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Or a b)\n 6. \\<And>G a b c ca s.\n       \\<lbrakk>G \\<turnstile> Or a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Or a b);\n        a # G \\<turnstile> c;\n        \\<And>ca s. subcs ca s (a # G) \\<turnstile> subc ca s c;\n        b # G \\<turnstile> c;\n        \\<And>ca s. subcs ca s (b # G) \\<turnstile> subc ca s c\\<rbrakk>\n       \\<Longrightarrow> subcs ca s G \\<turnstile> subc ca s c\n 7. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 8. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])\n 9. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Exists a)\n 10. \\<And>G a n b c s.\n        \\<lbrakk>G \\<turnstile> Exists a;\n         \\<And>c s. subcs c s G \\<turnstile> subc c s (Exists a);\n         a[App n []/0] # G \\<turnstile> b;\n         \\<And>c s. subcs c s (a[App n []/0] # G) \\<turnstile> subc c s b;\n         news n G; new n a; new n b\\<rbrakk>\n        \\<Longrightarrow> subcs c s G \\<turnstile> subc c s b", "then"], ["proof (chain)\npicking this:\n  z \\<turnstile> Or p q\n  subcs ?c ?s z \\<turnstile> subc ?c ?s (Or p q)\n  p # z \\<turnstile> r\n  subcs ?c ?s (p # z) \\<turnstile> subc ?c ?s r\n  q # z \\<turnstile> r\n  subcs ?c ?s (q # z) \\<turnstile> subc ?c ?s r", "show ?case"], ["proof (prove)\nusing this:\n  z \\<turnstile> Or p q\n  subcs ?c ?s z \\<turnstile> subc ?c ?s (Or p q)\n  p # z \\<turnstile> r\n  subcs ?c ?s (p # z) \\<turnstile> subc ?c ?s r\n  q # z \\<turnstile> r\n  subcs ?c ?s (q # z) \\<turnstile> subc ?c ?s r\n\ngoal (1 subgoal):\n 1. subcs c s z \\<turnstile> subc c s r", "using deriv.OrE"], ["proof (prove)\nusing this:\n  z \\<turnstile> Or p q\n  subcs ?c ?s z \\<turnstile> subc ?c ?s (Or p q)\n  p # z \\<turnstile> r\n  subcs ?c ?s (p # z) \\<turnstile> subc ?c ?s r\n  q # z \\<turnstile> r\n  subcs ?c ?s (q # z) \\<turnstile> subc ?c ?s r\n  \\<lbrakk>?G \\<turnstile> Or ?a ?b; ?a # ?G \\<turnstile> ?c;\n   ?b # ?G \\<turnstile> ?c\\<rbrakk>\n  \\<Longrightarrow> ?G \\<turnstile> ?c\n\ngoal (1 subgoal):\n 1. subcs c s z \\<turnstile> subc c s r", "by fastforce"], ["proof (state)\nthis:\n  subcs c s z \\<turnstile> subc c s r\n\ngoal (9 subgoals):\n 1. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a; G \\<turnstile> b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (And a b)\n 2. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s a\n 3. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s b\n 4. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Or a b)\n 5. \\<And>G b a c s.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Or a b)\n 6. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 7. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])\n 8. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Exists a)\n 9. \\<And>G a n b c s.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Exists a);\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>c s. subcs c s (a[App n []/0] # G) \\<turnstile> subc c s b;\n        news n G; new n a; new n b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s b", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a; G \\<turnstile> b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (And a b)\n 2. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s a\n 3. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s b\n 4. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Or a b)\n 5. \\<And>G b a c s.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Or a b)\n 6. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 7. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])\n 8. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Exists a)\n 9. \\<And>G a n b c s.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Exists a);\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>c s. subcs c s (a[App n []/0] # G) \\<turnstile> subc c s b;\n        news n G; new n a; new n b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s b", "case (OrI1 z p q)"], ["proof (state)\nthis:\n  z \\<turnstile> p\n  subcs ?c ?s z \\<turnstile> subc ?c ?s p\n\ngoal (9 subgoals):\n 1. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a; G \\<turnstile> b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (And a b)\n 2. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s a\n 3. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s b\n 4. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Or a b)\n 5. \\<And>G b a c s.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Or a b)\n 6. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 7. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])\n 8. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Exists a)\n 9. \\<And>G a n b c s.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Exists a);\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>c s. subcs c s (a[App n []/0] # G) \\<turnstile> subc c s b;\n        news n G; new n a; new n b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s b", "then"], ["proof (chain)\npicking this:\n  z \\<turnstile> p\n  subcs ?c ?s z \\<turnstile> subc ?c ?s p", "show ?case"], ["proof (prove)\nusing this:\n  z \\<turnstile> p\n  subcs ?c ?s z \\<turnstile> subc ?c ?s p\n\ngoal (1 subgoal):\n 1. subcs c s z \\<turnstile> subc c s (Or p q)", "using deriv.OrI1"], ["proof (prove)\nusing this:\n  z \\<turnstile> p\n  subcs ?c ?s z \\<turnstile> subc ?c ?s p\n  ?G \\<turnstile> ?a \\<Longrightarrow> ?G \\<turnstile> Or ?a ?b\n\ngoal (1 subgoal):\n 1. subcs c s z \\<turnstile> subc c s (Or p q)", "by fastforce"], ["proof (state)\nthis:\n  subcs c s z \\<turnstile> subc c s (Or p q)\n\ngoal (8 subgoals):\n 1. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a; G \\<turnstile> b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (And a b)\n 2. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s a\n 3. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s b\n 4. \\<And>G b a c s.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Or a b)\n 5. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 6. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])\n 7. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Exists a)\n 8. \\<And>G a n b c s.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Exists a);\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>c s. subcs c s (a[App n []/0] # G) \\<turnstile> subc c s b;\n        news n G; new n a; new n b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s b", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a; G \\<turnstile> b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (And a b)\n 2. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s a\n 3. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s b\n 4. \\<And>G b a c s.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Or a b)\n 5. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 6. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])\n 7. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Exists a)\n 8. \\<And>G a n b c s.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Exists a);\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>c s. subcs c s (a[App n []/0] # G) \\<turnstile> subc c s b;\n        news n G; new n a; new n b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s b", "case (OrI2 z q p)"], ["proof (state)\nthis:\n  z \\<turnstile> q\n  subcs ?c ?s z \\<turnstile> subc ?c ?s q\n\ngoal (8 subgoals):\n 1. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a; G \\<turnstile> b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (And a b)\n 2. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s a\n 3. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s b\n 4. \\<And>G b a c s.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Or a b)\n 5. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 6. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])\n 7. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Exists a)\n 8. \\<And>G a n b c s.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Exists a);\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>c s. subcs c s (a[App n []/0] # G) \\<turnstile> subc c s b;\n        news n G; new n a; new n b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s b", "then"], ["proof (chain)\npicking this:\n  z \\<turnstile> q\n  subcs ?c ?s z \\<turnstile> subc ?c ?s q", "show ?case"], ["proof (prove)\nusing this:\n  z \\<turnstile> q\n  subcs ?c ?s z \\<turnstile> subc ?c ?s q\n\ngoal (1 subgoal):\n 1. subcs c s z \\<turnstile> subc c s (Or p q)", "using deriv.OrI2"], ["proof (prove)\nusing this:\n  z \\<turnstile> q\n  subcs ?c ?s z \\<turnstile> subc ?c ?s q\n  ?G \\<turnstile> ?b \\<Longrightarrow> ?G \\<turnstile> Or ?a ?b\n\ngoal (1 subgoal):\n 1. subcs c s z \\<turnstile> subc c s (Or p q)", "by fastforce"], ["proof (state)\nthis:\n  subcs c s z \\<turnstile> subc c s (Or p q)\n\ngoal (7 subgoals):\n 1. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a; G \\<turnstile> b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (And a b)\n 2. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s a\n 3. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s b\n 4. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 5. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])\n 6. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Exists a)\n 7. \\<And>G a n b c s.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Exists a);\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>c s. subcs c s (a[App n []/0] # G) \\<turnstile> subc c s b;\n        news n G; new n a; new n b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s b", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a; G \\<turnstile> b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (And a b)\n 2. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s a\n 3. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s b\n 4. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 5. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])\n 6. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Exists a)\n 7. \\<And>G a n b c s.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Exists a);\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>c s. subcs c s (a[App n []/0] # G) \\<turnstile> subc c s b;\n        news n G; new n a; new n b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s b", "case (AndE1 z p q)"], ["proof (state)\nthis:\n  z \\<turnstile> And p q\n  subcs ?c ?s z \\<turnstile> subc ?c ?s (And p q)\n\ngoal (7 subgoals):\n 1. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a; G \\<turnstile> b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (And a b)\n 2. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s a\n 3. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s b\n 4. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 5. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])\n 6. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Exists a)\n 7. \\<And>G a n b c s.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Exists a);\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>c s. subcs c s (a[App n []/0] # G) \\<turnstile> subc c s b;\n        news n G; new n a; new n b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s b", "then"], ["proof (chain)\npicking this:\n  z \\<turnstile> And p q\n  subcs ?c ?s z \\<turnstile> subc ?c ?s (And p q)", "show ?case"], ["proof (prove)\nusing this:\n  z \\<turnstile> And p q\n  subcs ?c ?s z \\<turnstile> subc ?c ?s (And p q)\n\ngoal (1 subgoal):\n 1. subcs c s z \\<turnstile> subc c s p", "using deriv.AndE1"], ["proof (prove)\nusing this:\n  z \\<turnstile> And p q\n  subcs ?c ?s z \\<turnstile> subc ?c ?s (And p q)\n  ?G \\<turnstile> And ?a ?b \\<Longrightarrow> ?G \\<turnstile> ?a\n\ngoal (1 subgoal):\n 1. subcs c s z \\<turnstile> subc c s p", "by fastforce"], ["proof (state)\nthis:\n  subcs c s z \\<turnstile> subc c s p\n\ngoal (6 subgoals):\n 1. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a; G \\<turnstile> b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (And a b)\n 2. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s b\n 3. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 4. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])\n 5. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Exists a)\n 6. \\<And>G a n b c s.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Exists a);\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>c s. subcs c s (a[App n []/0] # G) \\<turnstile> subc c s b;\n        news n G; new n a; new n b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s b", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a; G \\<turnstile> b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (And a b)\n 2. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s b\n 3. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 4. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])\n 5. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Exists a)\n 6. \\<And>G a n b c s.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Exists a);\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>c s. subcs c s (a[App n []/0] # G) \\<turnstile> subc c s b;\n        news n G; new n a; new n b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s b", "case (AndE2 z p q)"], ["proof (state)\nthis:\n  z \\<turnstile> And p q\n  subcs ?c ?s z \\<turnstile> subc ?c ?s (And p q)\n\ngoal (6 subgoals):\n 1. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a; G \\<turnstile> b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (And a b)\n 2. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (And a b)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s b\n 3. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 4. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])\n 5. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Exists a)\n 6. \\<And>G a n b c s.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Exists a);\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>c s. subcs c s (a[App n []/0] # G) \\<turnstile> subc c s b;\n        news n G; new n a; new n b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s b", "then"], ["proof (chain)\npicking this:\n  z \\<turnstile> And p q\n  subcs ?c ?s z \\<turnstile> subc ?c ?s (And p q)", "show ?case"], ["proof (prove)\nusing this:\n  z \\<turnstile> And p q\n  subcs ?c ?s z \\<turnstile> subc ?c ?s (And p q)\n\ngoal (1 subgoal):\n 1. subcs c s z \\<turnstile> subc c s q", "using deriv.AndE2"], ["proof (prove)\nusing this:\n  z \\<turnstile> And p q\n  subcs ?c ?s z \\<turnstile> subc ?c ?s (And p q)\n  ?G \\<turnstile> And ?a ?b \\<Longrightarrow> ?G \\<turnstile> ?b\n\ngoal (1 subgoal):\n 1. subcs c s z \\<turnstile> subc c s q", "by fastforce"], ["proof (state)\nthis:\n  subcs c s z \\<turnstile> subc c s q\n\ngoal (5 subgoals):\n 1. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a; G \\<turnstile> b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (And a b)\n 2. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 3. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])\n 4. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Exists a)\n 5. \\<And>G a n b c s.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Exists a);\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>c s. subcs c s (a[App n []/0] # G) \\<turnstile> subc c s b;\n        news n G; new n a; new n b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s b", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a; G \\<turnstile> b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (And a b)\n 2. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 3. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])\n 4. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Exists a)\n 5. \\<And>G a n b c s.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Exists a);\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>c s. subcs c s (a[App n []/0] # G) \\<turnstile> subc c s b;\n        news n G; new n a; new n b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s b", "case (AndI p z q)"], ["proof (state)\nthis:\n  p \\<turnstile> z\n  subcs ?c ?s p \\<turnstile> subc ?c ?s z\n  p \\<turnstile> q\n  subcs ?c ?s p \\<turnstile> subc ?c ?s q\n\ngoal (5 subgoals):\n 1. \\<And>G a b c s.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s a; G \\<turnstile> b;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (And a b)\n 2. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 3. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])\n 4. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Exists a)\n 5. \\<And>G a n b c s.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Exists a);\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>c s. subcs c s (a[App n []/0] # G) \\<turnstile> subc c s b;\n        news n G; new n a; new n b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s b", "then"], ["proof (chain)\npicking this:\n  p \\<turnstile> z\n  subcs ?c ?s p \\<turnstile> subc ?c ?s z\n  p \\<turnstile> q\n  subcs ?c ?s p \\<turnstile> subc ?c ?s q", "show ?case"], ["proof (prove)\nusing this:\n  p \\<turnstile> z\n  subcs ?c ?s p \\<turnstile> subc ?c ?s z\n  p \\<turnstile> q\n  subcs ?c ?s p \\<turnstile> subc ?c ?s q\n\ngoal (1 subgoal):\n 1. subcs c s p \\<turnstile> subc c s (And z q)", "using deriv.AndI"], ["proof (prove)\nusing this:\n  p \\<turnstile> z\n  subcs ?c ?s p \\<turnstile> subc ?c ?s z\n  p \\<turnstile> q\n  subcs ?c ?s p \\<turnstile> subc ?c ?s q\n  \\<lbrakk>?G \\<turnstile> ?a; ?G \\<turnstile> ?b\\<rbrakk>\n  \\<Longrightarrow> ?G \\<turnstile> And ?a ?b\n\ngoal (1 subgoal):\n 1. subcs c s p \\<turnstile> subc c s (And z q)", "by fastforce"], ["proof (state)\nthis:\n  subcs c s p \\<turnstile> subc c s (And z q)\n\ngoal (4 subgoals):\n 1. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 2. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])\n 3. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Exists a)\n 4. \\<And>G a n b c s.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Exists a);\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>c s. subcs c s (a[App n []/0] # G) \\<turnstile> subc c s b;\n        news n G; new n a; new n b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s b", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 2. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])\n 3. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Exists a)\n 4. \\<And>G a n b c s.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Exists a);\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>c s. subcs c s (a[App n []/0] # G) \\<turnstile> subc c s b;\n        news n G; new n a; new n b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s b", "case (ExistsE z p d q)"], ["proof (state)\nthis:\n  z \\<turnstile> Exists p\n  subcs ?c ?s z \\<turnstile> subc ?c ?s (Exists p)\n  p[App d []/0] # z \\<turnstile> q\n  subcs ?c ?s (p[App d []/0] # z) \\<turnstile> subc ?c ?s q\n  news d z\n  new d p\n  new d q\n\ngoal (4 subgoals):\n 1. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 2. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])\n 3. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Exists a)\n 4. \\<And>G a n b c s.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Exists a);\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>c s. subcs c s (a[App n []/0] # G) \\<turnstile> subc c s b;\n        news n G; new n a; new n b\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s b", "then"], ["proof (chain)\npicking this:\n  z \\<turnstile> Exists p\n  subcs ?c ?s z \\<turnstile> subc ?c ?s (Exists p)\n  p[App d []/0] # z \\<turnstile> q\n  subcs ?c ?s (p[App d []/0] # z) \\<turnstile> subc ?c ?s q\n  news d z\n  new d p\n  new d q", "show ?case"], ["proof (prove)\nusing this:\n  z \\<turnstile> Exists p\n  subcs ?c ?s z \\<turnstile> subc ?c ?s (Exists p)\n  p[App d []/0] # z \\<turnstile> q\n  subcs ?c ?s (p[App d []/0] # z) \\<turnstile> subc ?c ?s q\n  news d z\n  new d p\n  new d q\n\ngoal (1 subgoal):\n 1. subcs c s z \\<turnstile> subc c s q", "proof (cases \\<open>c = d\\<close>)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>z \\<turnstile> Exists p;\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (Exists p);\n     p[App d []/0] # z \\<turnstile> q;\n     \\<And>c s. subcs c s (p[App d []/0] # z) \\<turnstile> subc c s q;\n     news d z; new d p; new d q; c = d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s q\n 2. \\<lbrakk>z \\<turnstile> Exists p;\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (Exists p);\n     p[App d []/0] # z \\<turnstile> q;\n     \\<And>c s. subcs c s (p[App d []/0] # z) \\<turnstile> subc c s q;\n     news d z; new d p; new d q; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s q", "case True"], ["proof (state)\nthis:\n  c = d\n\ngoal (2 subgoals):\n 1. \\<lbrakk>z \\<turnstile> Exists p;\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (Exists p);\n     p[App d []/0] # z \\<turnstile> q;\n     \\<And>c s. subcs c s (p[App d []/0] # z) \\<turnstile> subc c s q;\n     news d z; new d p; new d q; c = d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s q\n 2. \\<lbrakk>z \\<turnstile> Exists p;\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (Exists p);\n     p[App d []/0] # z \\<turnstile> q;\n     \\<And>c s. subcs c s (p[App d []/0] # z) \\<turnstile> subc c s q;\n     news d z; new d p; new d q; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s q", "then"], ["proof (chain)\npicking this:\n  c = d", "have \\<open>z \\<turnstile> q\\<close>"], ["proof (prove)\nusing this:\n  c = d\n\ngoal (1 subgoal):\n 1. z \\<turnstile> q", "using ExistsE deriv.ExistsE"], ["proof (prove)\nusing this:\n  c = d\n  z \\<turnstile> Exists p\n  subcs ?c ?s z \\<turnstile> subc ?c ?s (Exists p)\n  p[App d []/0] # z \\<turnstile> q\n  subcs ?c ?s (p[App d []/0] # z) \\<turnstile> subc ?c ?s q\n  news d z\n  new d p\n  new d q\n  \\<lbrakk>?G \\<turnstile> Exists ?a; ?a[App ?n []/0] # ?G \\<turnstile> ?b;\n   news ?n ?G; new ?n ?a; new ?n ?b\\<rbrakk>\n  \\<Longrightarrow> ?G \\<turnstile> ?b\n\ngoal (1 subgoal):\n 1. z \\<turnstile> q", "by fast"], ["proof (state)\nthis:\n  z \\<turnstile> q\n\ngoal (2 subgoals):\n 1. \\<lbrakk>z \\<turnstile> Exists p;\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (Exists p);\n     p[App d []/0] # z \\<turnstile> q;\n     \\<And>c s. subcs c s (p[App d []/0] # z) \\<turnstile> subc c s q;\n     news d z; new d p; new d q; c = d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s q\n 2. \\<lbrakk>z \\<turnstile> Exists p;\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (Exists p);\n     p[App d []/0] # z \\<turnstile> q;\n     \\<And>c s. subcs c s (p[App d []/0] # z) \\<turnstile> subc c s q;\n     news d z; new d p; new d q; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s q", "moreover"], ["proof (state)\nthis:\n  z \\<turnstile> q\n\ngoal (2 subgoals):\n 1. \\<lbrakk>z \\<turnstile> Exists p;\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (Exists p);\n     p[App d []/0] # z \\<turnstile> q;\n     \\<And>c s. subcs c s (p[App d []/0] # z) \\<turnstile> subc c s q;\n     news d z; new d p; new d q; c = d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s q\n 2. \\<lbrakk>z \\<turnstile> Exists p;\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (Exists p);\n     p[App d []/0] # z \\<turnstile> q;\n     \\<And>c s. subcs c s (p[App d []/0] # z) \\<turnstile> subc c s q;\n     news d z; new d p; new d q; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s q", "have \\<open>new c q\\<close> and \\<open>news c z\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. new c q &&& news c z", "using ExistsE True"], ["proof (prove)\nusing this:\n  z \\<turnstile> Exists p\n  subcs ?c ?s z \\<turnstile> subc ?c ?s (Exists p)\n  p[App d []/0] # z \\<turnstile> q\n  subcs ?c ?s (p[App d []/0] # z) \\<turnstile> subc ?c ?s q\n  news d z\n  new d p\n  new d q\n  c = d\n\ngoal (1 subgoal):\n 1. new c q &&& news c z", "by simp_all"], ["proof (state)\nthis:\n  new c q\n  news c z\n\ngoal (2 subgoals):\n 1. \\<lbrakk>z \\<turnstile> Exists p;\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (Exists p);\n     p[App d []/0] # z \\<turnstile> q;\n     \\<And>c s. subcs c s (p[App d []/0] # z) \\<turnstile> subc c s q;\n     news d z; new d p; new d q; c = d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s q\n 2. \\<lbrakk>z \\<turnstile> Exists p;\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (Exists p);\n     p[App d []/0] # z \\<turnstile> q;\n     \\<And>c s. subcs c s (p[App d []/0] # z) \\<turnstile> subc c s q;\n     news d z; new d p; new d q; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s q", "ultimately"], ["proof (chain)\npicking this:\n  z \\<turnstile> q\n  new c q\n  news c z", "show ?thesis"], ["proof (prove)\nusing this:\n  z \\<turnstile> q\n  new c q\n  news c z\n\ngoal (1 subgoal):\n 1. subcs c s z \\<turnstile> subc c s q", "using subc_new subcs_news"], ["proof (prove)\nusing this:\n  z \\<turnstile> q\n  new c q\n  news c z\n  new ?c ?p \\<Longrightarrow> subc ?c ?s ?p = ?p\n  news ?c ?z \\<Longrightarrow> subcs ?c ?s ?z = ?z\n\ngoal (1 subgoal):\n 1. subcs c s z \\<turnstile> subc c s q", "by metis"], ["proof (state)\nthis:\n  subcs c s z \\<turnstile> subc c s q\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> Exists p;\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (Exists p);\n     p[App d []/0] # z \\<turnstile> q;\n     \\<And>c s. subcs c s (p[App d []/0] # z) \\<turnstile> subc c s q;\n     news d z; new d p; new d q; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s q", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> Exists p;\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (Exists p);\n     p[App d []/0] # z \\<turnstile> q;\n     \\<And>c s. subcs c s (p[App d []/0] # z) \\<turnstile> subc c s q;\n     news d z; new d p; new d q; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s q", "case False"], ["proof (state)\nthis:\n  c \\<noteq> d\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> Exists p;\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (Exists p);\n     p[App d []/0] # z \\<turnstile> q;\n     \\<And>c s. subcs c s (p[App d []/0] # z) \\<turnstile> subc c s q;\n     news d z; new d p; new d q; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s q", "let ?params = \\<open>params p \\<union> params q \\<union> (\\<Union>p \\<in> set z. params p) \\<union> paramst s \\<union> {c} \\<union> {d}\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> Exists p;\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (Exists p);\n     p[App d []/0] # z \\<turnstile> q;\n     \\<And>c s. subcs c s (p[App d []/0] # z) \\<turnstile> subc c s q;\n     news d z; new d p; new d q; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s q", "have \\<open>finite ?params\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (params p \\<union> params q \\<union> \\<Union> (params ` set z) \\<union>\n      paramst s \\<union>\n      {c} \\<union>\n      {d})", "by simp"], ["proof (state)\nthis:\n  finite\n   (params p \\<union> params q \\<union> \\<Union> (params ` set z) \\<union>\n    paramst s \\<union>\n    {c} \\<union>\n    {d})\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> Exists p;\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (Exists p);\n     p[App d []/0] # z \\<turnstile> q;\n     \\<And>c s. subcs c s (p[App d []/0] # z) \\<turnstile> subc c s q;\n     news d z; new d p; new d q; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s q", "then"], ["proof (chain)\npicking this:\n  finite\n   (params p \\<union> params q \\<union> \\<Union> (params ` set z) \\<union>\n    paramst s \\<union>\n    {c} \\<union>\n    {d})", "obtain fresh where fresh: \\<open>fresh \\<notin> ?params\\<close>"], ["proof (prove)\nusing this:\n  finite\n   (params p \\<union> params q \\<union> \\<Union> (params ` set z) \\<union>\n    paramst s \\<union>\n    {c} \\<union>\n    {d})\n\ngoal (1 subgoal):\n 1. (\\<And>fresh.\n        fresh\n        \\<notin> params p \\<union> params q \\<union>\n                 \\<Union> (params ` set z) \\<union>\n                 paramst s \\<union>\n                 {c} \\<union>\n                 {d} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using inf_params"], ["proof (prove)\nusing this:\n  finite\n   (params p \\<union> params q \\<union> \\<Union> (params ` set z) \\<union>\n    paramst s \\<union>\n    {c} \\<union>\n    {d})\n  infinite UNIV\n\ngoal (1 subgoal):\n 1. (\\<And>fresh.\n        fresh\n        \\<notin> params p \\<union> params q \\<union>\n                 \\<Union> (params ` set z) \\<union>\n                 paramst s \\<union>\n                 {c} \\<union>\n                 {d} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (meson ex_new_if_finite infinite_UNIV_listI)"], ["proof (state)\nthis:\n  fresh\n  \\<notin> params p \\<union> params q \\<union>\n           \\<Union> (params ` set z) \\<union>\n           paramst s \\<union>\n           {c} \\<union>\n           {d}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> Exists p;\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (Exists p);\n     p[App d []/0] # z \\<turnstile> q;\n     \\<And>c s. subcs c s (p[App d []/0] # z) \\<turnstile> subc c s q;\n     news d z; new d p; new d q; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s q", "let ?s = \\<open>psubstt (id(d := fresh)) s\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> Exists p;\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (Exists p);\n     p[App d []/0] # z \\<turnstile> q;\n     \\<And>c s. subcs c s (p[App d []/0] # z) \\<turnstile> subc c s q;\n     news d z; new d p; new d q; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s q", "let ?f = \\<open>id(d := fresh, fresh := d)\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> Exists p;\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (Exists p);\n     p[App d []/0] # z \\<turnstile> q;\n     \\<And>c s. subcs c s (p[App d []/0] # z) \\<turnstile> subc c s q;\n     news d z; new d p; new d q; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s q", "have f: \\<open>\\<forall>x \\<in> ?params. x \\<noteq> c \\<longrightarrow> ?f x \\<noteq> ?f c\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>params p \\<union> params q \\<union>\n                   \\<Union> (params ` set z) \\<union>\n                   paramst s \\<union>\n                   {c} \\<union>\n                   {d}.\n       x \\<noteq> c \\<longrightarrow>\n       (id(d := fresh, fresh := d)) x \\<noteq>\n       (id(d := fresh, fresh := d)) c", "using fresh"], ["proof (prove)\nusing this:\n  fresh\n  \\<notin> params p \\<union> params q \\<union>\n           \\<Union> (params ` set z) \\<union>\n           paramst s \\<union>\n           {c} \\<union>\n           {d}\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>params p \\<union> params q \\<union>\n                   \\<Union> (params ` set z) \\<union>\n                   paramst s \\<union>\n                   {c} \\<union>\n                   {d}.\n       x \\<noteq> c \\<longrightarrow>\n       (id(d := fresh, fresh := d)) x \\<noteq>\n       (id(d := fresh, fresh := d)) c", "by simp"], ["proof (state)\nthis:\n  \\<forall>x\\<in>params p \\<union> params q \\<union>\n                 \\<Union> (params ` set z) \\<union>\n                 paramst s \\<union>\n                 {c} \\<union>\n                 {d}.\n     x \\<noteq> c \\<longrightarrow>\n     (id(d := fresh, fresh := d)) x \\<noteq> (id(d := fresh, fresh := d)) c\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> Exists p;\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (Exists p);\n     p[App d []/0] # z \\<turnstile> q;\n     \\<And>c s. subcs c s (p[App d []/0] # z) \\<turnstile> subc c s q;\n     news d z; new d p; new d q; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s q", "have \\<open>new_term d ?s\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. new_term d (psubstt (id(d := fresh)) s)", "using fresh psubst_new_free'(1)"], ["proof (prove)\nusing this:\n  fresh\n  \\<notin> params p \\<union> params q \\<union>\n           \\<Union> (params ` set z) \\<union>\n           paramst s \\<union>\n           {c} \\<union>\n           {d}\n  ?c \\<noteq> ?n \\<Longrightarrow> new_term ?n (psubstt (id(?n := ?c)) ?t)\n\ngoal (1 subgoal):\n 1. new_term d (psubstt (id(d := fresh)) s)", "by fast"], ["proof (state)\nthis:\n  new_term d (psubstt (id(d := fresh)) s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> Exists p;\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (Exists p);\n     p[App d []/0] # z \\<turnstile> q;\n     \\<And>c s. subcs c s (p[App d []/0] # z) \\<turnstile> subc c s q;\n     news d z; new d p; new d q; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s q", "then"], ["proof (chain)\npicking this:\n  new_term d (psubstt (id(d := fresh)) s)", "have \\<open>psubstt ?f ?s = psubstt (id(fresh := d)) ?s\\<close>"], ["proof (prove)\nusing this:\n  new_term d (psubstt (id(d := fresh)) s)\n\ngoal (1 subgoal):\n 1. psubstt (id(d := fresh, fresh := d)) (psubstt (id(d := fresh)) s) =\n    psubstt (id(fresh := d)) (psubstt (id(d := fresh)) s)", "by (metis fun_upd_twist psubstt_upd(1))"], ["proof (state)\nthis:\n  psubstt (id(d := fresh, fresh := d)) (psubstt (id(d := fresh)) s) =\n  psubstt (id(fresh := d)) (psubstt (id(d := fresh)) s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> Exists p;\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (Exists p);\n     p[App d []/0] # z \\<turnstile> q;\n     \\<And>c s. subcs c s (p[App d []/0] # z) \\<turnstile> subc c s q;\n     news d z; new d p; new d q; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s q", "then"], ["proof (chain)\npicking this:\n  psubstt (id(d := fresh, fresh := d)) (psubstt (id(d := fresh)) s) =\n  psubstt (id(fresh := d)) (psubstt (id(d := fresh)) s)", "have psubst_s: \\<open>psubstt ?f ?s = s\\<close>"], ["proof (prove)\nusing this:\n  psubstt (id(d := fresh, fresh := d)) (psubstt (id(d := fresh)) s) =\n  psubstt (id(fresh := d)) (psubstt (id(d := fresh)) s)\n\ngoal (1 subgoal):\n 1. psubstt (id(d := fresh, fresh := d)) (psubstt (id(d := fresh)) s) = s", "using fresh"], ["proof (prove)\nusing this:\n  psubstt (id(d := fresh, fresh := d)) (psubstt (id(d := fresh)) s) =\n  psubstt (id(fresh := d)) (psubstt (id(d := fresh)) s)\n  fresh\n  \\<notin> params p \\<union> params q \\<union>\n           \\<Union> (params ` set z) \\<union>\n           paramst s \\<union>\n           {c} \\<union>\n           {d}\n\ngoal (1 subgoal):\n 1. psubstt (id(d := fresh, fresh := d)) (psubstt (id(d := fresh)) s) = s", "by simp"], ["proof (state)\nthis:\n  psubstt (id(d := fresh, fresh := d)) (psubstt (id(d := fresh)) s) = s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> Exists p;\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (Exists p);\n     p[App d []/0] # z \\<turnstile> q;\n     \\<And>c s. subcs c s (p[App d []/0] # z) \\<turnstile> subc c s q;\n     news d z; new d p; new d q; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s q", "have \\<open>?f c = c\\<close> and \\<open>new_term (?f c) (App fresh [])\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (id(d := fresh, fresh := d)) c = c &&&\n    new_term ((id(d := fresh, fresh := d)) c) (App fresh [])", "using False fresh"], ["proof (prove)\nusing this:\n  c \\<noteq> d\n  fresh\n  \\<notin> params p \\<union> params q \\<union>\n           \\<Union> (params ` set z) \\<union>\n           paramst s \\<union>\n           {c} \\<union>\n           {d}\n\ngoal (1 subgoal):\n 1. (id(d := fresh, fresh := d)) c = c &&&\n    new_term ((id(d := fresh, fresh := d)) c) (App fresh [])", "by auto"], ["proof (state)\nthis:\n  (id(d := fresh, fresh := d)) c = c\n  new_term ((id(d := fresh, fresh := d)) c) (App fresh [])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> Exists p;\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (Exists p);\n     p[App d []/0] # z \\<turnstile> q;\n     \\<And>c s. subcs c s (p[App d []/0] # z) \\<turnstile> subc c s q;\n     news d z; new d p; new d q; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s q", "have \\<open>subcs c (psubstt ?f ?s) z \\<turnstile> subc c (psubstt ?f ?s) (Exists p)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. subcs c\n     (psubstt (id(d := fresh, fresh := d)) (psubstt (id(d := fresh)) s))\n     z \\<turnstile> subc c\n                     (psubstt (id(d := fresh, fresh := d))\n                       (psubstt (id(d := fresh)) s))\n                     (Exists p)", "using ExistsE"], ["proof (prove)\nusing this:\n  z \\<turnstile> Exists p\n  subcs ?c ?s z \\<turnstile> subc ?c ?s (Exists p)\n  p[App d []/0] # z \\<turnstile> q\n  subcs ?c ?s (p[App d []/0] # z) \\<turnstile> subc ?c ?s q\n  news d z\n  new d p\n  new d q\n\ngoal (1 subgoal):\n 1. subcs c\n     (psubstt (id(d := fresh, fresh := d)) (psubstt (id(d := fresh)) s))\n     z \\<turnstile> subc c\n                     (psubstt (id(d := fresh, fresh := d))\n                       (psubstt (id(d := fresh)) s))\n                     (Exists p)", "by blast"], ["proof (state)\nthis:\n  subcs c\n   (psubstt (id(d := fresh, fresh := d)) (psubstt (id(d := fresh)) s))\n   z \\<turnstile> subc c\n                   (psubstt (id(d := fresh, fresh := d))\n                     (psubstt (id(d := fresh)) s))\n                   (Exists p)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> Exists p;\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (Exists p);\n     p[App d []/0] # z \\<turnstile> q;\n     \\<And>c s. subcs c s (p[App d []/0] # z) \\<turnstile> subc c s q;\n     news d z; new d p; new d q; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s q", "then"], ["proof (chain)\npicking this:\n  subcs c\n   (psubstt (id(d := fresh, fresh := d)) (psubstt (id(d := fresh)) s))\n   z \\<turnstile> subc c\n                   (psubstt (id(d := fresh, fresh := d))\n                     (psubstt (id(d := fresh)) s))\n                   (Exists p)", "have exi_p:\n      \\<open>subcs c s z \\<turnstile> Exists (subc c (liftt (psubstt ?f ?s)) p)\\<close>"], ["proof (prove)\nusing this:\n  subcs c\n   (psubstt (id(d := fresh, fresh := d)) (psubstt (id(d := fresh)) s))\n   z \\<turnstile> subc c\n                   (psubstt (id(d := fresh, fresh := d))\n                     (psubstt (id(d := fresh)) s))\n                   (Exists p)\n\ngoal (1 subgoal):\n 1. subcs c s\n     z \\<turnstile> Exists\n                     (subc c\n                       (liftt\n                         (psubstt (id(d := fresh, fresh := d))\n                           (psubstt (id(d := fresh)) s)))\n                       p)", "using psubst_s"], ["proof (prove)\nusing this:\n  subcs c\n   (psubstt (id(d := fresh, fresh := d)) (psubstt (id(d := fresh)) s))\n   z \\<turnstile> subc c\n                   (psubstt (id(d := fresh, fresh := d))\n                     (psubstt (id(d := fresh)) s))\n                   (Exists p)\n  psubstt (id(d := fresh, fresh := d)) (psubstt (id(d := fresh)) s) = s\n\ngoal (1 subgoal):\n 1. subcs c s\n     z \\<turnstile> Exists\n                     (subc c\n                       (liftt\n                         (psubstt (id(d := fresh, fresh := d))\n                           (psubstt (id(d := fresh)) s)))\n                       p)", "by simp"], ["proof (state)\nthis:\n  subcs c s\n   z \\<turnstile> Exists\n                   (subc c\n                     (liftt\n                       (psubstt (id(d := fresh, fresh := d))\n                         (psubstt (id(d := fresh)) s)))\n                     p)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> Exists p;\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (Exists p);\n     p[App d []/0] # z \\<turnstile> q;\n     \\<And>c s. subcs c s (p[App d []/0] # z) \\<turnstile> subc c s q;\n     news d z; new d p; new d q; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s q", "have \\<open>news d z\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. news d z", "using ExistsE"], ["proof (prove)\nusing this:\n  z \\<turnstile> Exists p\n  subcs ?c ?s z \\<turnstile> subc ?c ?s (Exists p)\n  p[App d []/0] # z \\<turnstile> q\n  subcs ?c ?s (p[App d []/0] # z) \\<turnstile> subc ?c ?s q\n  news d z\n  new d p\n  new d q\n\ngoal (1 subgoal):\n 1. news d z", "by simp"], ["proof (state)\nthis:\n  news d z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> Exists p;\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (Exists p);\n     p[App d []/0] # z \\<turnstile> q;\n     \\<And>c s. subcs c s (p[App d []/0] # z) \\<turnstile> subc c s q;\n     news d z; new d p; new d q; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s q", "moreover"], ["proof (state)\nthis:\n  news d z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> Exists p;\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (Exists p);\n     p[App d []/0] # z \\<turnstile> q;\n     \\<And>c s. subcs c s (p[App d []/0] # z) \\<turnstile> subc c s q;\n     news d z; new d p; new d q; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s q", "have \\<open>news fresh z\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. news fresh z", "using fresh"], ["proof (prove)\nusing this:\n  fresh\n  \\<notin> params p \\<union> params q \\<union>\n           \\<Union> (params ` set z) \\<union>\n           paramst s \\<union>\n           {c} \\<union>\n           {d}\n\ngoal (1 subgoal):\n 1. news fresh z", "by (induct z) simp_all"], ["proof (state)\nthis:\n  news fresh z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> Exists p;\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (Exists p);\n     p[App d []/0] # z \\<turnstile> q;\n     \\<And>c s. subcs c s (p[App d []/0] # z) \\<turnstile> subc c s q;\n     news d z; new d p; new d q; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s q", "ultimately"], ["proof (chain)\npicking this:\n  news d z\n  news fresh z", "have \\<open>map (psubst ?f) z = z\\<close>"], ["proof (prove)\nusing this:\n  news d z\n  news fresh z\n\ngoal (1 subgoal):\n 1. map (psubst (id(d := fresh, fresh := d))) z = z", "by (induct z) simp_all"], ["proof (state)\nthis:\n  map (psubst (id(d := fresh, fresh := d))) z = z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> Exists p;\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (Exists p);\n     p[App d []/0] # z \\<turnstile> q;\n     \\<And>c s. subcs c s (p[App d []/0] # z) \\<turnstile> subc c s q;\n     news d z; new d p; new d q; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s q", "moreover"], ["proof (state)\nthis:\n  map (psubst (id(d := fresh, fresh := d))) z = z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> Exists p;\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (Exists p);\n     p[App d []/0] # z \\<turnstile> q;\n     \\<And>c s. subcs c s (p[App d []/0] # z) \\<turnstile> subc c s q;\n     news d z; new d p; new d q; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s q", "have \\<open>\\<forall>x \\<in> \\<Union>p \\<in> set z. params p. x \\<noteq> c \\<longrightarrow> ?f x \\<noteq> ?f c\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>\\<Union> (params ` set z).\n       x \\<noteq> c \\<longrightarrow>\n       (id(d := fresh, fresh := d)) x \\<noteq>\n       (id(d := fresh, fresh := d)) c", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<in>\\<Union> (params ` set z).\n     x \\<noteq> c \\<longrightarrow>\n     (id(d := fresh, fresh := d)) x \\<noteq> (id(d := fresh, fresh := d)) c\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> Exists p;\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (Exists p);\n     p[App d []/0] # z \\<turnstile> q;\n     \\<And>c s. subcs c s (p[App d []/0] # z) \\<turnstile> subc c s q;\n     news d z; new d p; new d q; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s q", "ultimately"], ["proof (chain)\npicking this:\n  map (psubst (id(d := fresh, fresh := d))) z = z\n  \\<forall>x\\<in>\\<Union> (params ` set z).\n     x \\<noteq> c \\<longrightarrow>\n     (id(d := fresh, fresh := d)) x \\<noteq> (id(d := fresh, fresh := d)) c", "have psubst_z: \\<open>map (psubst ?f) (subcs c ?s z) = subcs c s z\\<close>"], ["proof (prove)\nusing this:\n  map (psubst (id(d := fresh, fresh := d))) z = z\n  \\<forall>x\\<in>\\<Union> (params ` set z).\n     x \\<noteq> c \\<longrightarrow>\n     (id(d := fresh, fresh := d)) x \\<noteq> (id(d := fresh, fresh := d)) c\n\ngoal (1 subgoal):\n 1. map (psubst (id(d := fresh, fresh := d)))\n     (subcs c (psubstt (id(d := fresh)) s) z) =\n    subcs c s z", "using \\<open>?f c = c\\<close> psubst_s"], ["proof (prove)\nusing this:\n  map (psubst (id(d := fresh, fresh := d))) z = z\n  \\<forall>x\\<in>\\<Union> (params ` set z).\n     x \\<noteq> c \\<longrightarrow>\n     (id(d := fresh, fresh := d)) x \\<noteq> (id(d := fresh, fresh := d)) c\n  (id(d := fresh, fresh := d)) c = c\n  psubstt (id(d := fresh, fresh := d)) (psubstt (id(d := fresh)) s) = s\n\ngoal (1 subgoal):\n 1. map (psubst (id(d := fresh, fresh := d)))\n     (subcs c (psubstt (id(d := fresh)) s) z) =\n    subcs c s z", "by (simp add: subcs_psubst)"], ["proof (state)\nthis:\n  map (psubst (id(d := fresh, fresh := d)))\n   (subcs c (psubstt (id(d := fresh)) s) z) =\n  subcs c s z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> Exists p;\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (Exists p);\n     p[App d []/0] # z \\<turnstile> q;\n     \\<And>c s. subcs c s (p[App d []/0] # z) \\<turnstile> subc c s q;\n     news d z; new d p; new d q; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s q", "have \\<open>psubst ?f (subc c ?s (subst p (App d []) 0)) =\n        subc (?f c) (psubstt ?f ?s) (psubst ?f (subst p (App d []) 0))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. psubst (id(d := fresh, fresh := d))\n     (subc c (psubstt (id(d := fresh)) s) (p[App d []/0])) =\n    subc ((id(d := fresh, fresh := d)) c)\n     (psubstt (id(d := fresh, fresh := d)) (psubstt (id(d := fresh)) s))\n     (psubst (id(d := fresh, fresh := d)) (p[App d []/0]))", "using fresh"], ["proof (prove)\nusing this:\n  fresh\n  \\<notin> params p \\<union> params q \\<union>\n           \\<Union> (params ` set z) \\<union>\n           paramst s \\<union>\n           {c} \\<union>\n           {d}\n\ngoal (1 subgoal):\n 1. psubst (id(d := fresh, fresh := d))\n     (subc c (psubstt (id(d := fresh)) s) (p[App d []/0])) =\n    subc ((id(d := fresh, fresh := d)) c)\n     (psubstt (id(d := fresh, fresh := d)) (psubstt (id(d := fresh)) s))\n     (psubst (id(d := fresh, fresh := d)) (p[App d []/0]))", "by (simp add: subc_psubst)"], ["proof (state)\nthis:\n  psubst (id(d := fresh, fresh := d))\n   (subc c (psubstt (id(d := fresh)) s) (p[App d []/0])) =\n  subc ((id(d := fresh, fresh := d)) c)\n   (psubstt (id(d := fresh, fresh := d)) (psubstt (id(d := fresh)) s))\n   (psubst (id(d := fresh, fresh := d)) (p[App d []/0]))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> Exists p;\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (Exists p);\n     p[App d []/0] # z \\<turnstile> q;\n     \\<And>c s. subcs c s (p[App d []/0] # z) \\<turnstile> subc c s q;\n     news d z; new d p; new d q; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s q", "also"], ["proof (state)\nthis:\n  psubst (id(d := fresh, fresh := d))\n   (subc c (psubstt (id(d := fresh)) s) (p[App d []/0])) =\n  subc ((id(d := fresh, fresh := d)) c)\n   (psubstt (id(d := fresh, fresh := d)) (psubstt (id(d := fresh)) s))\n   (psubst (id(d := fresh, fresh := d)) (p[App d []/0]))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> Exists p;\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (Exists p);\n     p[App d []/0] # z \\<turnstile> q;\n     \\<And>c s. subcs c s (p[App d []/0] # z) \\<turnstile> subc c s q;\n     news d z; new d p; new d q; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s q", "have \\<open>\\<dots> = subc c s (subst (psubst ?f p) (App fresh []) 0)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. subc ((id(d := fresh, fresh := d)) c)\n     (psubstt (id(d := fresh, fresh := d)) (psubstt (id(d := fresh)) s))\n     (psubst (id(d := fresh, fresh := d)) (p[App d []/0])) =\n    subc c s (psubst (id(d := fresh, fresh := d)) p[App fresh []/0])", "using psubst_subst psubst_s \\<open>?f c = c\\<close>"], ["proof (prove)\nusing this:\n  psubst ?f (?P[?t/?i]) = psubst ?f ?P[psubstt ?f ?t/?i]\n  psubstt (id(d := fresh, fresh := d)) (psubstt (id(d := fresh)) s) = s\n  (id(d := fresh, fresh := d)) c = c\n\ngoal (1 subgoal):\n 1. subc ((id(d := fresh, fresh := d)) c)\n     (psubstt (id(d := fresh, fresh := d)) (psubstt (id(d := fresh)) s))\n     (psubst (id(d := fresh, fresh := d)) (p[App d []/0])) =\n    subc c s (psubst (id(d := fresh, fresh := d)) p[App fresh []/0])", "by simp"], ["proof (state)\nthis:\n  subc ((id(d := fresh, fresh := d)) c)\n   (psubstt (id(d := fresh, fresh := d)) (psubstt (id(d := fresh)) s))\n   (psubst (id(d := fresh, fresh := d)) (p[App d []/0])) =\n  subc c s (psubst (id(d := fresh, fresh := d)) p[App fresh []/0])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> Exists p;\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (Exists p);\n     p[App d []/0] # z \\<turnstile> q;\n     \\<And>c s. subcs c s (p[App d []/0] # z) \\<turnstile> subc c s q;\n     news d z; new d p; new d q; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s q", "also"], ["proof (state)\nthis:\n  subc ((id(d := fresh, fresh := d)) c)\n   (psubstt (id(d := fresh, fresh := d)) (psubstt (id(d := fresh)) s))\n   (psubst (id(d := fresh, fresh := d)) (p[App d []/0])) =\n  subc c s (psubst (id(d := fresh, fresh := d)) p[App fresh []/0])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> Exists p;\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (Exists p);\n     p[App d []/0] # z \\<turnstile> q;\n     \\<And>c s. subcs c s (p[App d []/0] # z) \\<turnstile> subc c s q;\n     news d z; new d p; new d q; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s q", "have \\<open>\\<dots> = subc c s (subst p (App fresh []) 0)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. subc c s (psubst (id(d := fresh, fresh := d)) p[App fresh []/0]) =\n    subc c s (p[App fresh []/0])", "using ExistsE fresh"], ["proof (prove)\nusing this:\n  z \\<turnstile> Exists p\n  subcs ?c ?s z \\<turnstile> subc ?c ?s (Exists p)\n  p[App d []/0] # z \\<turnstile> q\n  subcs ?c ?s (p[App d []/0] # z) \\<turnstile> subc ?c ?s q\n  news d z\n  new d p\n  new d q\n  fresh\n  \\<notin> params p \\<union> params q \\<union>\n           \\<Union> (params ` set z) \\<union>\n           paramst s \\<union>\n           {c} \\<union>\n           {d}\n\ngoal (1 subgoal):\n 1. subc c s (psubst (id(d := fresh, fresh := d)) p[App fresh []/0]) =\n    subc c s (p[App fresh []/0])", "by simp"], ["proof (state)\nthis:\n  subc c s (psubst (id(d := fresh, fresh := d)) p[App fresh []/0]) =\n  subc c s (p[App fresh []/0])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> Exists p;\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (Exists p);\n     p[App d []/0] # z \\<turnstile> q;\n     \\<And>c s. subcs c s (p[App d []/0] # z) \\<turnstile> subc c s q;\n     news d z; new d p; new d q; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s q", "finally"], ["proof (chain)\npicking this:\n  psubst (id(d := fresh, fresh := d))\n   (subc c (psubstt (id(d := fresh)) s) (p[App d []/0])) =\n  subc c s (p[App fresh []/0])", "have psubst_p: \\<open>psubst ?f (subc c ?s (subst p (App d []) 0)) =\n        subst (subc c (liftt s) p) (App fresh []) 0\\<close>"], ["proof (prove)\nusing this:\n  psubst (id(d := fresh, fresh := d))\n   (subc c (psubstt (id(d := fresh)) s) (p[App d []/0])) =\n  subc c s (p[App fresh []/0])\n\ngoal (1 subgoal):\n 1. psubst (id(d := fresh, fresh := d))\n     (subc c (psubstt (id(d := fresh)) s) (p[App d []/0])) =\n    subc c (liftt s) p[App fresh []/0]", "using subc_sub_0_new \\<open>new_term (?f c) (App fresh [])\\<close> \\<open>?f c = c\\<close>"], ["proof (prove)\nusing this:\n  psubst (id(d := fresh, fresh := d))\n   (subc c (psubstt (id(d := fresh)) s) (p[App d []/0])) =\n  subc c s (p[App fresh []/0])\n  new_term ?c ?t \\<Longrightarrow>\n  subc ?c ?s (?p[?t/0]) = subc ?c (liftt ?s) ?p[?t/0]\n  new_term ((id(d := fresh, fresh := d)) c) (App fresh [])\n  (id(d := fresh, fresh := d)) c = c\n\ngoal (1 subgoal):\n 1. psubst (id(d := fresh, fresh := d))\n     (subc c (psubstt (id(d := fresh)) s) (p[App d []/0])) =\n    subc c (liftt s) p[App fresh []/0]", "by metis"], ["proof (state)\nthis:\n  psubst (id(d := fresh, fresh := d))\n   (subc c (psubstt (id(d := fresh)) s) (p[App d []/0])) =\n  subc c (liftt s) p[App fresh []/0]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> Exists p;\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (Exists p);\n     p[App d []/0] # z \\<turnstile> q;\n     \\<And>c s. subcs c s (p[App d []/0] # z) \\<turnstile> subc c s q;\n     news d z; new d p; new d q; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s q", "have \\<open>\\<forall>x \\<in> params q. x \\<noteq> c \\<longrightarrow> ?f x \\<noteq> ?f c\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>params q.\n       x \\<noteq> c \\<longrightarrow>\n       (id(d := fresh, fresh := d)) x \\<noteq>\n       (id(d := fresh, fresh := d)) c", "using f"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>params p \\<union> params q \\<union>\n                 \\<Union> (params ` set z) \\<union>\n                 paramst s \\<union>\n                 {c} \\<union>\n                 {d}.\n     x \\<noteq> c \\<longrightarrow>\n     (id(d := fresh, fresh := d)) x \\<noteq> (id(d := fresh, fresh := d)) c\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>params q.\n       x \\<noteq> c \\<longrightarrow>\n       (id(d := fresh, fresh := d)) x \\<noteq>\n       (id(d := fresh, fresh := d)) c", "by blast"], ["proof (state)\nthis:\n  \\<forall>x\\<in>params q.\n     x \\<noteq> c \\<longrightarrow>\n     (id(d := fresh, fresh := d)) x \\<noteq> (id(d := fresh, fresh := d)) c\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> Exists p;\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (Exists p);\n     p[App d []/0] # z \\<turnstile> q;\n     \\<And>c s. subcs c s (p[App d []/0] # z) \\<turnstile> subc c s q;\n     news d z; new d p; new d q; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s q", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>params q.\n     x \\<noteq> c \\<longrightarrow>\n     (id(d := fresh, fresh := d)) x \\<noteq> (id(d := fresh, fresh := d)) c", "have psubst_q: \\<open>psubst ?f (subc c ?s q) = subc c s q\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>params q.\n     x \\<noteq> c \\<longrightarrow>\n     (id(d := fresh, fresh := d)) x \\<noteq> (id(d := fresh, fresh := d)) c\n\ngoal (1 subgoal):\n 1. psubst (id(d := fresh, fresh := d))\n     (subc c (psubstt (id(d := fresh)) s) q) =\n    subc c s q", "using ExistsE fresh \\<open>?f c = c\\<close> psubst_s f"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>params q.\n     x \\<noteq> c \\<longrightarrow>\n     (id(d := fresh, fresh := d)) x \\<noteq> (id(d := fresh, fresh := d)) c\n  z \\<turnstile> Exists p\n  subcs ?c ?s z \\<turnstile> subc ?c ?s (Exists p)\n  p[App d []/0] # z \\<turnstile> q\n  subcs ?c ?s (p[App d []/0] # z) \\<turnstile> subc ?c ?s q\n  news d z\n  new d p\n  new d q\n  fresh\n  \\<notin> params p \\<union> params q \\<union>\n           \\<Union> (params ` set z) \\<union>\n           paramst s \\<union>\n           {c} \\<union>\n           {d}\n  (id(d := fresh, fresh := d)) c = c\n  psubstt (id(d := fresh, fresh := d)) (psubstt (id(d := fresh)) s) = s\n  \\<forall>x\\<in>params p \\<union> params q \\<union>\n                 \\<Union> (params ` set z) \\<union>\n                 paramst s \\<union>\n                 {c} \\<union>\n                 {d}.\n     x \\<noteq> c \\<longrightarrow>\n     (id(d := fresh, fresh := d)) x \\<noteq> (id(d := fresh, fresh := d)) c\n\ngoal (1 subgoal):\n 1. psubst (id(d := fresh, fresh := d))\n     (subc c (psubstt (id(d := fresh)) s) q) =\n    subc c s q", "by (simp add: subc_psubst)"], ["proof (state)\nthis:\n  psubst (id(d := fresh, fresh := d))\n   (subc c (psubstt (id(d := fresh)) s) q) =\n  subc c s q\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> Exists p;\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (Exists p);\n     p[App d []/0] # z \\<turnstile> q;\n     \\<And>c s. subcs c s (p[App d []/0] # z) \\<turnstile> subc c s q;\n     news d z; new d p; new d q; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s q", "have \\<open>subcs c ?s (subst p (App d []) 0 # z) \\<turnstile> subc c ?s q\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. subcs c (psubstt (id(d := fresh)) s)\n     (p[App d []/0] # z) \\<turnstile> subc c (psubstt (id(d := fresh)) s) q", "using ExistsE"], ["proof (prove)\nusing this:\n  z \\<turnstile> Exists p\n  subcs ?c ?s z \\<turnstile> subc ?c ?s (Exists p)\n  p[App d []/0] # z \\<turnstile> q\n  subcs ?c ?s (p[App d []/0] # z) \\<turnstile> subc ?c ?s q\n  news d z\n  new d p\n  new d q\n\ngoal (1 subgoal):\n 1. subcs c (psubstt (id(d := fresh)) s)\n     (p[App d []/0] # z) \\<turnstile> subc c (psubstt (id(d := fresh)) s) q", "by blast"], ["proof (state)\nthis:\n  subcs c (psubstt (id(d := fresh)) s)\n   (p[App d []/0] # z) \\<turnstile> subc c (psubstt (id(d := fresh)) s) q\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> Exists p;\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (Exists p);\n     p[App d []/0] # z \\<turnstile> q;\n     \\<And>c s. subcs c s (p[App d []/0] # z) \\<turnstile> subc c s q;\n     news d z; new d p; new d q; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s q", "then"], ["proof (chain)\npicking this:\n  subcs c (psubstt (id(d := fresh)) s)\n   (p[App d []/0] # z) \\<turnstile> subc c (psubstt (id(d := fresh)) s) q", "have \\<open>subc c ?s (subst p (App d []) 0) # subcs c ?s z \\<turnstile> subc c ?s q\\<close>"], ["proof (prove)\nusing this:\n  subcs c (psubstt (id(d := fresh)) s)\n   (p[App d []/0] # z) \\<turnstile> subc c (psubstt (id(d := fresh)) s) q\n\ngoal (1 subgoal):\n 1. subc c (psubstt (id(d := fresh)) s) (p[App d []/0]) #\n    subcs c (psubstt (id(d := fresh)) s)\n     z \\<turnstile> subc c (psubstt (id(d := fresh)) s) q", "by simp"], ["proof (state)\nthis:\n  subc c (psubstt (id(d := fresh)) s) (p[App d []/0]) #\n  subcs c (psubstt (id(d := fresh)) s)\n   z \\<turnstile> subc c (psubstt (id(d := fresh)) s) q\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> Exists p;\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (Exists p);\n     p[App d []/0] # z \\<turnstile> q;\n     \\<And>c s. subcs c s (p[App d []/0] # z) \\<turnstile> subc c s q;\n     news d z; new d p; new d q; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s q", "then"], ["proof (chain)\npicking this:\n  subc c (psubstt (id(d := fresh)) s) (p[App d []/0]) #\n  subcs c (psubstt (id(d := fresh)) s)\n   z \\<turnstile> subc c (psubstt (id(d := fresh)) s) q", "have \\<open>psubst ?f (subc c ?s (subst p (App d []) 0)) # map (psubst ?f) (subcs c ?s z)\n        \\<turnstile> psubst ?f (subc c ?s q)\\<close>"], ["proof (prove)\nusing this:\n  subc c (psubstt (id(d := fresh)) s) (p[App d []/0]) #\n  subcs c (psubstt (id(d := fresh)) s)\n   z \\<turnstile> subc c (psubstt (id(d := fresh)) s) q\n\ngoal (1 subgoal):\n 1. psubst (id(d := fresh, fresh := d))\n     (subc c (psubstt (id(d := fresh)) s) (p[App d []/0])) #\n    map (psubst (id(d := fresh, fresh := d)))\n     (subcs c (psubstt (id(d := fresh)) s)\n       z) \\<turnstile> psubst (id(d := fresh, fresh := d))\n                        (subc c (psubstt (id(d := fresh)) s) q)", "using deriv_psubst inf_params"], ["proof (prove)\nusing this:\n  subc c (psubstt (id(d := fresh)) s) (p[App d []/0]) #\n  subcs c (psubstt (id(d := fresh)) s)\n   z \\<turnstile> subc c (psubstt (id(d := fresh)) s) q\n  \\<lbrakk>infinite UNIV; ?z \\<turnstile> ?p\\<rbrakk>\n  \\<Longrightarrow> map (psubst ?f) ?z \\<turnstile> psubst ?f ?p\n  infinite UNIV\n\ngoal (1 subgoal):\n 1. psubst (id(d := fresh, fresh := d))\n     (subc c (psubstt (id(d := fresh)) s) (p[App d []/0])) #\n    map (psubst (id(d := fresh, fresh := d)))\n     (subcs c (psubstt (id(d := fresh)) s)\n       z) \\<turnstile> psubst (id(d := fresh, fresh := d))\n                        (subc c (psubstt (id(d := fresh)) s) q)", "by fastforce"], ["proof (state)\nthis:\n  psubst (id(d := fresh, fresh := d))\n   (subc c (psubstt (id(d := fresh)) s) (p[App d []/0])) #\n  map (psubst (id(d := fresh, fresh := d)))\n   (subcs c (psubstt (id(d := fresh)) s)\n     z) \\<turnstile> psubst (id(d := fresh, fresh := d))\n                      (subc c (psubstt (id(d := fresh)) s) q)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> Exists p;\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (Exists p);\n     p[App d []/0] # z \\<turnstile> q;\n     \\<And>c s. subcs c s (p[App d []/0] # z) \\<turnstile> subc c s q;\n     news d z; new d p; new d q; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s q", "then"], ["proof (chain)\npicking this:\n  psubst (id(d := fresh, fresh := d))\n   (subc c (psubstt (id(d := fresh)) s) (p[App d []/0])) #\n  map (psubst (id(d := fresh, fresh := d)))\n   (subcs c (psubstt (id(d := fresh)) s)\n     z) \\<turnstile> psubst (id(d := fresh, fresh := d))\n                      (subc c (psubstt (id(d := fresh)) s) q)", "have q: \\<open>subst (subc c (liftt s) p) (App fresh []) 0 # subcs c s z \\<turnstile> subc c s q\\<close>"], ["proof (prove)\nusing this:\n  psubst (id(d := fresh, fresh := d))\n   (subc c (psubstt (id(d := fresh)) s) (p[App d []/0])) #\n  map (psubst (id(d := fresh, fresh := d)))\n   (subcs c (psubstt (id(d := fresh)) s)\n     z) \\<turnstile> psubst (id(d := fresh, fresh := d))\n                      (subc c (psubstt (id(d := fresh)) s) q)\n\ngoal (1 subgoal):\n 1. subc c (liftt s) p[App fresh []/0] # subcs c s z \\<turnstile> subc c s q", "using psubst_q psubst_z psubst_p"], ["proof (prove)\nusing this:\n  psubst (id(d := fresh, fresh := d))\n   (subc c (psubstt (id(d := fresh)) s) (p[App d []/0])) #\n  map (psubst (id(d := fresh, fresh := d)))\n   (subcs c (psubstt (id(d := fresh)) s)\n     z) \\<turnstile> psubst (id(d := fresh, fresh := d))\n                      (subc c (psubstt (id(d := fresh)) s) q)\n  psubst (id(d := fresh, fresh := d))\n   (subc c (psubstt (id(d := fresh)) s) q) =\n  subc c s q\n  map (psubst (id(d := fresh, fresh := d)))\n   (subcs c (psubstt (id(d := fresh)) s) z) =\n  subcs c s z\n  psubst (id(d := fresh, fresh := d))\n   (subc c (psubstt (id(d := fresh)) s) (p[App d []/0])) =\n  subc c (liftt s) p[App fresh []/0]\n\ngoal (1 subgoal):\n 1. subc c (liftt s) p[App fresh []/0] # subcs c s z \\<turnstile> subc c s q", "by simp"], ["proof (state)\nthis:\n  subc c (liftt s) p[App fresh []/0] # subcs c s z \\<turnstile> subc c s q\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> Exists p;\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (Exists p);\n     p[App d []/0] # z \\<turnstile> q;\n     \\<And>c s. subcs c s (p[App d []/0] # z) \\<turnstile> subc c s q;\n     news d z; new d p; new d q; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s q", "have \\<open>new fresh (subc c (liftt s) p)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. new fresh (subc c (liftt s) p)", "using fresh new_subc new_lift"], ["proof (prove)\nusing this:\n  fresh\n  \\<notin> params p \\<union> params q \\<union>\n           \\<Union> (params ` set z) \\<union>\n           paramst s \\<union>\n           {c} \\<union>\n           {d}\n  \\<lbrakk>new_term ?d ?s; new ?d ?p\\<rbrakk>\n  \\<Longrightarrow> new ?d (subc ?c ?s ?p)\n  new_term ?c ?t \\<Longrightarrow> new_term ?c (liftt ?t)\n  new_list ?c ?l \\<Longrightarrow> new_list ?c (liftts ?l)\n\ngoal (1 subgoal):\n 1. new fresh (subc c (liftt s) p)", "by simp"], ["proof (state)\nthis:\n  new fresh (subc c (liftt s) p)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> Exists p;\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (Exists p);\n     p[App d []/0] # z \\<turnstile> q;\n     \\<And>c s. subcs c s (p[App d []/0] # z) \\<turnstile> subc c s q;\n     news d z; new d p; new d q; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s q", "moreover"], ["proof (state)\nthis:\n  new fresh (subc c (liftt s) p)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> Exists p;\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (Exists p);\n     p[App d []/0] # z \\<turnstile> q;\n     \\<And>c s. subcs c s (p[App d []/0] # z) \\<turnstile> subc c s q;\n     news d z; new d p; new d q; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s q", "have \\<open>new fresh (subc c s q)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. new fresh (subc c s q)", "using fresh new_subc"], ["proof (prove)\nusing this:\n  fresh\n  \\<notin> params p \\<union> params q \\<union>\n           \\<Union> (params ` set z) \\<union>\n           paramst s \\<union>\n           {c} \\<union>\n           {d}\n  \\<lbrakk>new_term ?d ?s; new ?d ?p\\<rbrakk>\n  \\<Longrightarrow> new ?d (subc ?c ?s ?p)\n\ngoal (1 subgoal):\n 1. new fresh (subc c s q)", "by simp"], ["proof (state)\nthis:\n  new fresh (subc c s q)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> Exists p;\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (Exists p);\n     p[App d []/0] # z \\<turnstile> q;\n     \\<And>c s. subcs c s (p[App d []/0] # z) \\<turnstile> subc c s q;\n     news d z; new d p; new d q; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s q", "moreover"], ["proof (state)\nthis:\n  new fresh (subc c s q)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> Exists p;\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (Exists p);\n     p[App d []/0] # z \\<turnstile> q;\n     \\<And>c s. subcs c s (p[App d []/0] # z) \\<turnstile> subc c s q;\n     news d z; new d p; new d q; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s q", "have \\<open>news fresh (subcs c s z)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. news fresh (subcs c s z)", "using fresh \\<open>news fresh z\\<close>"], ["proof (prove)\nusing this:\n  fresh\n  \\<notin> params p \\<union> params q \\<union>\n           \\<Union> (params ` set z) \\<union>\n           paramst s \\<union>\n           {c} \\<union>\n           {d}\n  news fresh z\n\ngoal (1 subgoal):\n 1. news fresh (subcs c s z)", "by (simp add: news_subcs)"], ["proof (state)\nthis:\n  news fresh (subcs c s z)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> Exists p;\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (Exists p);\n     p[App d []/0] # z \\<turnstile> q;\n     \\<And>c s. subcs c s (p[App d []/0] # z) \\<turnstile> subc c s q;\n     news d z; new d p; new d q; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s q", "ultimately"], ["proof (chain)\npicking this:\n  new fresh (subc c (liftt s) p)\n  new fresh (subc c s q)\n  news fresh (subcs c s z)", "show \\<open>subcs c s z \\<turnstile> subc c s q\\<close>"], ["proof (prove)\nusing this:\n  new fresh (subc c (liftt s) p)\n  new fresh (subc c s q)\n  news fresh (subcs c s z)\n\ngoal (1 subgoal):\n 1. subcs c s z \\<turnstile> subc c s q", "using deriv.ExistsE exi_p q psubst_s"], ["proof (prove)\nusing this:\n  new fresh (subc c (liftt s) p)\n  new fresh (subc c s q)\n  news fresh (subcs c s z)\n  \\<lbrakk>?G \\<turnstile> Exists ?a; ?a[App ?n []/0] # ?G \\<turnstile> ?b;\n   news ?n ?G; new ?n ?a; new ?n ?b\\<rbrakk>\n  \\<Longrightarrow> ?G \\<turnstile> ?b\n  subcs c s\n   z \\<turnstile> Exists\n                   (subc c\n                     (liftt\n                       (psubstt (id(d := fresh, fresh := d))\n                         (psubstt (id(d := fresh)) s)))\n                     p)\n  subc c (liftt s) p[App fresh []/0] # subcs c s z \\<turnstile> subc c s q\n  psubstt (id(d := fresh, fresh := d)) (psubstt (id(d := fresh)) s) = s\n\ngoal (1 subgoal):\n 1. subcs c s z \\<turnstile> subc c s q", "by metis"], ["proof (state)\nthis:\n  subcs c s z \\<turnstile> subc c s q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  subcs c s z \\<turnstile> subc c s q\n\ngoal (3 subgoals):\n 1. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 2. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])\n 3. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Exists a)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 2. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])\n 3. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Exists a)", "case (ExistsI z p t)"], ["proof (state)\nthis:\n  z \\<turnstile> p[t/0]\n  subcs ?c ?s z \\<turnstile> subc ?c ?s (p[t/0])\n\ngoal (3 subgoals):\n 1. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 2. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])\n 3. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Exists a)", "let ?params = \\<open>params p \\<union> (\\<Union>p \\<in> set z. params p) \\<union> paramst s \\<union> paramst t \\<union> {c}\\<close>"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 2. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])\n 3. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Exists a)", "have \\<open>finite ?params\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (params p \\<union> \\<Union> (params ` set z) \\<union>\n      paramst s \\<union>\n      paramst t \\<union>\n      {c})", "by simp"], ["proof (state)\nthis:\n  finite\n   (params p \\<union> \\<Union> (params ` set z) \\<union> paramst s \\<union>\n    paramst t \\<union>\n    {c})\n\ngoal (3 subgoals):\n 1. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 2. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])\n 3. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Exists a)", "then"], ["proof (chain)\npicking this:\n  finite\n   (params p \\<union> \\<Union> (params ` set z) \\<union> paramst s \\<union>\n    paramst t \\<union>\n    {c})", "obtain fresh where fresh: \\<open>fresh \\<notin> ?params\\<close>"], ["proof (prove)\nusing this:\n  finite\n   (params p \\<union> \\<Union> (params ` set z) \\<union> paramst s \\<union>\n    paramst t \\<union>\n    {c})\n\ngoal (1 subgoal):\n 1. (\\<And>fresh.\n        fresh\n        \\<notin> params p \\<union> \\<Union> (params ` set z) \\<union>\n                 paramst s \\<union>\n                 paramst t \\<union>\n                 {c} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using inf_params"], ["proof (prove)\nusing this:\n  finite\n   (params p \\<union> \\<Union> (params ` set z) \\<union> paramst s \\<union>\n    paramst t \\<union>\n    {c})\n  infinite UNIV\n\ngoal (1 subgoal):\n 1. (\\<And>fresh.\n        fresh\n        \\<notin> params p \\<union> \\<Union> (params ` set z) \\<union>\n                 paramst s \\<union>\n                 paramst t \\<union>\n                 {c} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (meson ex_new_if_finite infinite_UNIV_listI)"], ["proof (state)\nthis:\n  fresh\n  \\<notin> params p \\<union> \\<Union> (params ` set z) \\<union>\n           paramst s \\<union>\n           paramst t \\<union>\n           {c}\n\ngoal (3 subgoals):\n 1. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 2. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])\n 3. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Exists a)", "let ?f = \\<open>id(c := fresh)\\<close>"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 2. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])\n 3. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Exists a)", "let ?g = \\<open>id(fresh := c)\\<close>"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 2. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])\n 3. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Exists a)", "let ?s = \\<open>psubstt ?f s\\<close>"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 2. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])\n 3. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Exists a)", "have c: \\<open>?g c = c\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (id(fresh := c)) c = c", "using fresh"], ["proof (prove)\nusing this:\n  fresh\n  \\<notin> params p \\<union> \\<Union> (params ` set z) \\<union>\n           paramst s \\<union>\n           paramst t \\<union>\n           {c}\n\ngoal (1 subgoal):\n 1. (id(fresh := c)) c = c", "by simp"], ["proof (state)\nthis:\n  (id(fresh := c)) c = c\n\ngoal (3 subgoals):\n 1. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 2. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])\n 3. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Exists a)", "have s: \\<open>psubstt ?g ?s = s\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. psubstt (id(fresh := c)) (psubstt (id(c := fresh)) s) = s", "using fresh"], ["proof (prove)\nusing this:\n  fresh\n  \\<notin> params p \\<union> \\<Union> (params ` set z) \\<union>\n           paramst s \\<union>\n           paramst t \\<union>\n           {c}\n\ngoal (1 subgoal):\n 1. psubstt (id(fresh := c)) (psubstt (id(c := fresh)) s) = s", "by simp"], ["proof (state)\nthis:\n  psubstt (id(fresh := c)) (psubstt (id(c := fresh)) s) = s\n\ngoal (3 subgoals):\n 1. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 2. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])\n 3. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Exists a)", "have p: \\<open>psubst ?g (Exists p) = Exists p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. psubst (id(fresh := c)) (Exists p) = Exists p", "using fresh"], ["proof (prove)\nusing this:\n  fresh\n  \\<notin> params p \\<union> \\<Union> (params ` set z) \\<union>\n           paramst s \\<union>\n           paramst t \\<union>\n           {c}\n\ngoal (1 subgoal):\n 1. psubst (id(fresh := c)) (Exists p) = Exists p", "by simp"], ["proof (state)\nthis:\n  psubst (id(fresh := c)) (Exists p) = Exists p\n\ngoal (3 subgoals):\n 1. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 2. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])\n 3. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Exists a)", "have \\<open>\\<forall>x \\<in> (\\<Union>p \\<in> set z. params p). x \\<noteq> c \\<longrightarrow> ?g x \\<noteq> ?g c\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>\\<Union> (params ` set z).\n       x \\<noteq> c \\<longrightarrow>\n       (id(fresh := c)) x \\<noteq> (id(fresh := c)) c", "using fresh"], ["proof (prove)\nusing this:\n  fresh\n  \\<notin> params p \\<union> \\<Union> (params ` set z) \\<union>\n           paramst s \\<union>\n           paramst t \\<union>\n           {c}\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>\\<Union> (params ` set z).\n       x \\<noteq> c \\<longrightarrow>\n       (id(fresh := c)) x \\<noteq> (id(fresh := c)) c", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<in>\\<Union> (params ` set z).\n     x \\<noteq> c \\<longrightarrow>\n     (id(fresh := c)) x \\<noteq> (id(fresh := c)) c\n\ngoal (3 subgoals):\n 1. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 2. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])\n 3. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Exists a)", "moreover"], ["proof (state)\nthis:\n  \\<forall>x\\<in>\\<Union> (params ` set z).\n     x \\<noteq> c \\<longrightarrow>\n     (id(fresh := c)) x \\<noteq> (id(fresh := c)) c\n\ngoal (3 subgoals):\n 1. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 2. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])\n 3. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Exists a)", "have \\<open>map (psubst ?g) z = z\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (psubst (id(fresh := c))) z = z", "using fresh"], ["proof (prove)\nusing this:\n  fresh\n  \\<notin> params p \\<union> \\<Union> (params ` set z) \\<union>\n           paramst s \\<union>\n           paramst t \\<union>\n           {c}\n\ngoal (1 subgoal):\n 1. map (psubst (id(fresh := c))) z = z", "by (induct z) simp_all"], ["proof (state)\nthis:\n  map (psubst (id(fresh := c))) z = z\n\ngoal (3 subgoals):\n 1. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 2. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])\n 3. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Exists a)", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>\\<Union> (params ` set z).\n     x \\<noteq> c \\<longrightarrow>\n     (id(fresh := c)) x \\<noteq> (id(fresh := c)) c\n  map (psubst (id(fresh := c))) z = z", "have z: \\<open>map (psubst ?g) (subcs c ?s z) = subcs c s z\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>\\<Union> (params ` set z).\n     x \\<noteq> c \\<longrightarrow>\n     (id(fresh := c)) x \\<noteq> (id(fresh := c)) c\n  map (psubst (id(fresh := c))) z = z\n\ngoal (1 subgoal):\n 1. map (psubst (id(fresh := c))) (subcs c (psubstt (id(c := fresh)) s) z) =\n    subcs c s z", "using s"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>\\<Union> (params ` set z).\n     x \\<noteq> c \\<longrightarrow>\n     (id(fresh := c)) x \\<noteq> (id(fresh := c)) c\n  map (psubst (id(fresh := c))) z = z\n  psubstt (id(fresh := c)) (psubstt (id(c := fresh)) s) = s\n\ngoal (1 subgoal):\n 1. map (psubst (id(fresh := c))) (subcs c (psubstt (id(c := fresh)) s) z) =\n    subcs c s z", "by (simp add: subcs_psubst)"], ["proof (state)\nthis:\n  map (psubst (id(fresh := c))) (subcs c (psubstt (id(c := fresh)) s) z) =\n  subcs c s z\n\ngoal (3 subgoals):\n 1. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 2. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])\n 3. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Exists a)", "have \\<open>new_term c ?s\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. new_term c (psubstt (id(c := fresh)) s)", "using fresh psubst_new_free'"], ["proof (prove)\nusing this:\n  fresh\n  \\<notin> params p \\<union> \\<Union> (params ` set z) \\<union>\n           paramst s \\<union>\n           paramst t \\<union>\n           {c}\n  ?c \\<noteq> ?n \\<Longrightarrow> new_term ?n (psubstt (id(?n := ?c)) ?t)\n  ?c \\<noteq> ?n \\<Longrightarrow> new_list ?n (psubstts (id(?n := ?c)) ?l)\n\ngoal (1 subgoal):\n 1. new_term c (psubstt (id(c := fresh)) s)", "by fast"], ["proof (state)\nthis:\n  new_term c (psubstt (id(c := fresh)) s)\n\ngoal (3 subgoals):\n 1. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 2. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])\n 3. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Exists a)", "then"], ["proof (chain)\npicking this:\n  new_term c (psubstt (id(c := fresh)) s)", "have \\<open>subcs c ?s z \\<turnstile> subc c ?s (subst p (subc_term c ?s t) 0)\\<close>"], ["proof (prove)\nusing this:\n  new_term c (psubstt (id(c := fresh)) s)\n\ngoal (1 subgoal):\n 1. subcs c (psubstt (id(c := fresh)) s)\n     z \\<turnstile> subc c (psubstt (id(c := fresh)) s)\n                     (p[subc_term c (psubstt (id(c := fresh)) s) t/0])", "using ExistsI new_subc_put"], ["proof (prove)\nusing this:\n  new_term c (psubstt (id(c := fresh)) s)\n  z \\<turnstile> p[t/0]\n  subcs ?c ?s z \\<turnstile> subc ?c ?s (p[t/0])\n  new_term ?c ?s \\<Longrightarrow>\n  subc ?c ?s (?p[?t/?m]) = subc ?c ?s (?p[subc_term ?c ?s ?t/?m])\n\ngoal (1 subgoal):\n 1. subcs c (psubstt (id(c := fresh)) s)\n     z \\<turnstile> subc c (psubstt (id(c := fresh)) s)\n                     (p[subc_term c (psubstt (id(c := fresh)) s) t/0])", "by metis"], ["proof (state)\nthis:\n  subcs c (psubstt (id(c := fresh)) s)\n   z \\<turnstile> subc c (psubstt (id(c := fresh)) s)\n                   (p[subc_term c (psubstt (id(c := fresh)) s) t/0])\n\ngoal (3 subgoals):\n 1. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 2. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])\n 3. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Exists a)", "moreover"], ["proof (state)\nthis:\n  subcs c (psubstt (id(c := fresh)) s)\n   z \\<turnstile> subc c (psubstt (id(c := fresh)) s)\n                   (p[subc_term c (psubstt (id(c := fresh)) s) t/0])\n\ngoal (3 subgoals):\n 1. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 2. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])\n 3. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Exists a)", "have \\<open>new_term c (subc_term c ?s t)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. new_term c (subc_term c (psubstt (id(c := fresh)) s) t)", "using \\<open>new_term c ?s\\<close> new_subc_same'"], ["proof (prove)\nusing this:\n  new_term c (psubstt (id(c := fresh)) s)\n  new_term ?c ?s \\<Longrightarrow> new_term ?c (subc_term ?c ?s ?t)\n  new_term ?c ?s \\<Longrightarrow> new_list ?c (subc_list ?c ?s ?l)\n\ngoal (1 subgoal):\n 1. new_term c (subc_term c (psubstt (id(c := fresh)) s) t)", "by fast"], ["proof (state)\nthis:\n  new_term c (subc_term c (psubstt (id(c := fresh)) s) t)\n\ngoal (3 subgoals):\n 1. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 2. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])\n 3. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Exists a)", "ultimately"], ["proof (chain)\npicking this:\n  subcs c (psubstt (id(c := fresh)) s)\n   z \\<turnstile> subc c (psubstt (id(c := fresh)) s)\n                   (p[subc_term c (psubstt (id(c := fresh)) s) t/0])\n  new_term c (subc_term c (psubstt (id(c := fresh)) s) t)", "have \\<open>subcs c ?s z \\<turnstile> subst (subc c (liftt ?s) p) (subc_term c ?s t) 0\\<close>"], ["proof (prove)\nusing this:\n  subcs c (psubstt (id(c := fresh)) s)\n   z \\<turnstile> subc c (psubstt (id(c := fresh)) s)\n                   (p[subc_term c (psubstt (id(c := fresh)) s) t/0])\n  new_term c (subc_term c (psubstt (id(c := fresh)) s) t)\n\ngoal (1 subgoal):\n 1. subcs c (psubstt (id(c := fresh)) s)\n     z \\<turnstile> subc c (liftt (psubstt (id(c := fresh)) s))\n                     p[subc_term c (psubstt (id(c := fresh)) s) t/0]", "using subc_sub_0_new"], ["proof (prove)\nusing this:\n  subcs c (psubstt (id(c := fresh)) s)\n   z \\<turnstile> subc c (psubstt (id(c := fresh)) s)\n                   (p[subc_term c (psubstt (id(c := fresh)) s) t/0])\n  new_term c (subc_term c (psubstt (id(c := fresh)) s) t)\n  new_term ?c ?t \\<Longrightarrow>\n  subc ?c ?s (?p[?t/0]) = subc ?c (liftt ?s) ?p[?t/0]\n\ngoal (1 subgoal):\n 1. subcs c (psubstt (id(c := fresh)) s)\n     z \\<turnstile> subc c (liftt (psubstt (id(c := fresh)) s))\n                     p[subc_term c (psubstt (id(c := fresh)) s) t/0]", "by metis"], ["proof (state)\nthis:\n  subcs c (psubstt (id(c := fresh)) s)\n   z \\<turnstile> subc c (liftt (psubstt (id(c := fresh)) s))\n                   p[subc_term c (psubstt (id(c := fresh)) s) t/0]\n\ngoal (3 subgoals):\n 1. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 2. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])\n 3. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Exists a)", "then"], ["proof (chain)\npicking this:\n  subcs c (psubstt (id(c := fresh)) s)\n   z \\<turnstile> subc c (liftt (psubstt (id(c := fresh)) s))\n                   p[subc_term c (psubstt (id(c := fresh)) s) t/0]", "have \\<open>subcs c ?s z \\<turnstile> subc c ?s (Exists p)\\<close>"], ["proof (prove)\nusing this:\n  subcs c (psubstt (id(c := fresh)) s)\n   z \\<turnstile> subc c (liftt (psubstt (id(c := fresh)) s))\n                   p[subc_term c (psubstt (id(c := fresh)) s) t/0]\n\ngoal (1 subgoal):\n 1. subcs c (psubstt (id(c := fresh)) s)\n     z \\<turnstile> subc c (psubstt (id(c := fresh)) s) (Exists p)", "using deriv.ExistsI"], ["proof (prove)\nusing this:\n  subcs c (psubstt (id(c := fresh)) s)\n   z \\<turnstile> subc c (liftt (psubstt (id(c := fresh)) s))\n                   p[subc_term c (psubstt (id(c := fresh)) s) t/0]\n  ?G \\<turnstile> ?a[?t/0] \\<Longrightarrow> ?G \\<turnstile> Exists ?a\n\ngoal (1 subgoal):\n 1. subcs c (psubstt (id(c := fresh)) s)\n     z \\<turnstile> subc c (psubstt (id(c := fresh)) s) (Exists p)", "by simp"], ["proof (state)\nthis:\n  subcs c (psubstt (id(c := fresh)) s)\n   z \\<turnstile> subc c (psubstt (id(c := fresh)) s) (Exists p)\n\ngoal (3 subgoals):\n 1. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 2. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])\n 3. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Exists a)", "then"], ["proof (chain)\npicking this:\n  subcs c (psubstt (id(c := fresh)) s)\n   z \\<turnstile> subc c (psubstt (id(c := fresh)) s) (Exists p)", "have \\<open>map (psubst ?g) (subcs c ?s z) \\<turnstile> psubst ?g (subc c ?s (Exists p))\\<close>"], ["proof (prove)\nusing this:\n  subcs c (psubstt (id(c := fresh)) s)\n   z \\<turnstile> subc c (psubstt (id(c := fresh)) s) (Exists p)\n\ngoal (1 subgoal):\n 1. map (psubst (id(fresh := c)))\n     (subcs c (psubstt (id(c := fresh)) s)\n       z) \\<turnstile> psubst (id(fresh := c))\n                        (subc c (psubstt (id(c := fresh)) s) (Exists p))", "using deriv_psubst inf_params"], ["proof (prove)\nusing this:\n  subcs c (psubstt (id(c := fresh)) s)\n   z \\<turnstile> subc c (psubstt (id(c := fresh)) s) (Exists p)\n  \\<lbrakk>infinite UNIV; ?z \\<turnstile> ?p\\<rbrakk>\n  \\<Longrightarrow> map (psubst ?f) ?z \\<turnstile> psubst ?f ?p\n  infinite UNIV\n\ngoal (1 subgoal):\n 1. map (psubst (id(fresh := c)))\n     (subcs c (psubstt (id(c := fresh)) s)\n       z) \\<turnstile> psubst (id(fresh := c))\n                        (subc c (psubstt (id(c := fresh)) s) (Exists p))", "by blast"], ["proof (state)\nthis:\n  map (psubst (id(fresh := c)))\n   (subcs c (psubstt (id(c := fresh)) s)\n     z) \\<turnstile> psubst (id(fresh := c))\n                      (subc c (psubstt (id(c := fresh)) s) (Exists p))\n\ngoal (3 subgoals):\n 1. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 2. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])\n 3. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Exists a)", "moreover"], ["proof (state)\nthis:\n  map (psubst (id(fresh := c)))\n   (subcs c (psubstt (id(c := fresh)) s)\n     z) \\<turnstile> psubst (id(fresh := c))\n                      (subc c (psubstt (id(c := fresh)) s) (Exists p))\n\ngoal (3 subgoals):\n 1. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 2. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])\n 3. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Exists a)", "have \\<open>\\<forall>x \\<in> params (Exists p). x \\<noteq> c \\<longrightarrow> ?g x \\<noteq> ?g c\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>params (Exists p).\n       x \\<noteq> c \\<longrightarrow>\n       (id(fresh := c)) x \\<noteq> (id(fresh := c)) c", "using fresh"], ["proof (prove)\nusing this:\n  fresh\n  \\<notin> params p \\<union> \\<Union> (params ` set z) \\<union>\n           paramst s \\<union>\n           paramst t \\<union>\n           {c}\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>params (Exists p).\n       x \\<noteq> c \\<longrightarrow>\n       (id(fresh := c)) x \\<noteq> (id(fresh := c)) c", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<in>params (Exists p).\n     x \\<noteq> c \\<longrightarrow>\n     (id(fresh := c)) x \\<noteq> (id(fresh := c)) c\n\ngoal (3 subgoals):\n 1. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 2. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])\n 3. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[t/0])\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Exists a)", "ultimately"], ["proof (chain)\npicking this:\n  map (psubst (id(fresh := c)))\n   (subcs c (psubstt (id(c := fresh)) s)\n     z) \\<turnstile> psubst (id(fresh := c))\n                      (subc c (psubstt (id(c := fresh)) s) (Exists p))\n  \\<forall>x\\<in>params (Exists p).\n     x \\<noteq> c \\<longrightarrow>\n     (id(fresh := c)) x \\<noteq> (id(fresh := c)) c", "show \\<open>subcs c s z \\<turnstile> subc c s (Exists p)\\<close>"], ["proof (prove)\nusing this:\n  map (psubst (id(fresh := c)))\n   (subcs c (psubstt (id(c := fresh)) s)\n     z) \\<turnstile> psubst (id(fresh := c))\n                      (subc c (psubstt (id(c := fresh)) s) (Exists p))\n  \\<forall>x\\<in>params (Exists p).\n     x \\<noteq> c \\<longrightarrow>\n     (id(fresh := c)) x \\<noteq> (id(fresh := c)) c\n\ngoal (1 subgoal):\n 1. subcs c s z \\<turnstile> subc c s (Exists p)", "using c s p z"], ["proof (prove)\nusing this:\n  map (psubst (id(fresh := c)))\n   (subcs c (psubstt (id(c := fresh)) s)\n     z) \\<turnstile> psubst (id(fresh := c))\n                      (subc c (psubstt (id(c := fresh)) s) (Exists p))\n  \\<forall>x\\<in>params (Exists p).\n     x \\<noteq> c \\<longrightarrow>\n     (id(fresh := c)) x \\<noteq> (id(fresh := c)) c\n  (id(fresh := c)) c = c\n  psubstt (id(fresh := c)) (psubstt (id(c := fresh)) s) = s\n  psubst (id(fresh := c)) (Exists p) = Exists p\n  map (psubst (id(fresh := c))) (subcs c (psubstt (id(c := fresh)) s) z) =\n  subcs c s z\n\ngoal (1 subgoal):\n 1. subcs c s z \\<turnstile> subc c s (Exists p)", "by (simp add: subc_psubst)"], ["proof (state)\nthis:\n  subcs c s z \\<turnstile> subc c s (Exists p)\n\ngoal (2 subgoals):\n 1. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 2. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 2. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])", "case (ForallE z p t)"], ["proof (state)\nthis:\n  z \\<turnstile> Forall p\n  subcs ?c ?s z \\<turnstile> subc ?c ?s (Forall p)\n\ngoal (2 subgoals):\n 1. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 2. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])", "let ?params = \\<open>params p \\<union> (\\<Union>p \\<in> set z. params p) \\<union> paramst s \\<union> paramst t \\<union> {c}\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 2. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])", "have \\<open>finite ?params\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (params p \\<union> \\<Union> (params ` set z) \\<union>\n      paramst s \\<union>\n      paramst t \\<union>\n      {c})", "by simp"], ["proof (state)\nthis:\n  finite\n   (params p \\<union> \\<Union> (params ` set z) \\<union> paramst s \\<union>\n    paramst t \\<union>\n    {c})\n\ngoal (2 subgoals):\n 1. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 2. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])", "then"], ["proof (chain)\npicking this:\n  finite\n   (params p \\<union> \\<Union> (params ` set z) \\<union> paramst s \\<union>\n    paramst t \\<union>\n    {c})", "obtain fresh where fresh: \\<open>fresh \\<notin> ?params\\<close>"], ["proof (prove)\nusing this:\n  finite\n   (params p \\<union> \\<Union> (params ` set z) \\<union> paramst s \\<union>\n    paramst t \\<union>\n    {c})\n\ngoal (1 subgoal):\n 1. (\\<And>fresh.\n        fresh\n        \\<notin> params p \\<union> \\<Union> (params ` set z) \\<union>\n                 paramst s \\<union>\n                 paramst t \\<union>\n                 {c} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using inf_params"], ["proof (prove)\nusing this:\n  finite\n   (params p \\<union> \\<Union> (params ` set z) \\<union> paramst s \\<union>\n    paramst t \\<union>\n    {c})\n  infinite UNIV\n\ngoal (1 subgoal):\n 1. (\\<And>fresh.\n        fresh\n        \\<notin> params p \\<union> \\<Union> (params ` set z) \\<union>\n                 paramst s \\<union>\n                 paramst t \\<union>\n                 {c} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (meson ex_new_if_finite infinite_UNIV_listI)"], ["proof (state)\nthis:\n  fresh\n  \\<notin> params p \\<union> \\<Union> (params ` set z) \\<union>\n           paramst s \\<union>\n           paramst t \\<union>\n           {c}\n\ngoal (2 subgoals):\n 1. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 2. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])", "let ?f = \\<open>id(c := fresh)\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 2. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])", "let ?g = \\<open>id(fresh := c)\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 2. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])", "let ?s = \\<open>psubstt ?f s\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 2. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])", "have c: \\<open>?g c = c\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (id(fresh := c)) c = c", "using fresh"], ["proof (prove)\nusing this:\n  fresh\n  \\<notin> params p \\<union> \\<Union> (params ` set z) \\<union>\n           paramst s \\<union>\n           paramst t \\<union>\n           {c}\n\ngoal (1 subgoal):\n 1. (id(fresh := c)) c = c", "by simp"], ["proof (state)\nthis:\n  (id(fresh := c)) c = c\n\ngoal (2 subgoals):\n 1. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 2. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])", "have s: \\<open>psubstt ?g ?s = s\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. psubstt (id(fresh := c)) (psubstt (id(c := fresh)) s) = s", "using fresh"], ["proof (prove)\nusing this:\n  fresh\n  \\<notin> params p \\<union> \\<Union> (params ` set z) \\<union>\n           paramst s \\<union>\n           paramst t \\<union>\n           {c}\n\ngoal (1 subgoal):\n 1. psubstt (id(fresh := c)) (psubstt (id(c := fresh)) s) = s", "by simp"], ["proof (state)\nthis:\n  psubstt (id(fresh := c)) (psubstt (id(c := fresh)) s) = s\n\ngoal (2 subgoals):\n 1. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 2. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])", "have p: \\<open>psubst ?g (subst p t 0) = subst p t 0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. psubst (id(fresh := c)) (p[t/0]) = p[t/0]", "using fresh psubst_new psubst_subst subst_new psubst_new'(1)"], ["proof (prove)\nusing this:\n  fresh\n  \\<notin> params p \\<union> \\<Union> (params ` set z) \\<union>\n           paramst s \\<union>\n           paramst t \\<union>\n           {c}\n  new ?c ?p \\<Longrightarrow> psubst (id(?c := ?x)) ?p = ?p\n  psubst ?f (?P[?t/?i]) = psubst ?f ?P[psubstt ?f ?t/?i]\n  \\<lbrakk>new_term ?c ?s; new ?c ?p\\<rbrakk>\n  \\<Longrightarrow> new ?c (?p[?s/?m])\n  new_term ?c ?t \\<Longrightarrow> psubstt (id(?c := ?x)) ?t = ?t\n\ngoal (1 subgoal):\n 1. psubst (id(fresh := c)) (p[t/0]) = p[t/0]", "by fastforce"], ["proof (state)\nthis:\n  psubst (id(fresh := c)) (p[t/0]) = p[t/0]\n\ngoal (2 subgoals):\n 1. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 2. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])", "have \\<open>\\<forall>x \\<in> (\\<Union>p \\<in> set z. params p). x \\<noteq> c \\<longrightarrow> ?g x \\<noteq> ?g c\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>\\<Union> (params ` set z).\n       x \\<noteq> c \\<longrightarrow>\n       (id(fresh := c)) x \\<noteq> (id(fresh := c)) c", "using fresh"], ["proof (prove)\nusing this:\n  fresh\n  \\<notin> params p \\<union> \\<Union> (params ` set z) \\<union>\n           paramst s \\<union>\n           paramst t \\<union>\n           {c}\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>\\<Union> (params ` set z).\n       x \\<noteq> c \\<longrightarrow>\n       (id(fresh := c)) x \\<noteq> (id(fresh := c)) c", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<in>\\<Union> (params ` set z).\n     x \\<noteq> c \\<longrightarrow>\n     (id(fresh := c)) x \\<noteq> (id(fresh := c)) c\n\ngoal (2 subgoals):\n 1. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 2. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])", "moreover"], ["proof (state)\nthis:\n  \\<forall>x\\<in>\\<Union> (params ` set z).\n     x \\<noteq> c \\<longrightarrow>\n     (id(fresh := c)) x \\<noteq> (id(fresh := c)) c\n\ngoal (2 subgoals):\n 1. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 2. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])", "have \\<open>map (psubst ?g) z = z\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (psubst (id(fresh := c))) z = z", "using fresh"], ["proof (prove)\nusing this:\n  fresh\n  \\<notin> params p \\<union> \\<Union> (params ` set z) \\<union>\n           paramst s \\<union>\n           paramst t \\<union>\n           {c}\n\ngoal (1 subgoal):\n 1. map (psubst (id(fresh := c))) z = z", "by (induct z) simp_all"], ["proof (state)\nthis:\n  map (psubst (id(fresh := c))) z = z\n\ngoal (2 subgoals):\n 1. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 2. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>\\<Union> (params ` set z).\n     x \\<noteq> c \\<longrightarrow>\n     (id(fresh := c)) x \\<noteq> (id(fresh := c)) c\n  map (psubst (id(fresh := c))) z = z", "have z: \\<open>map (psubst ?g) (subcs c ?s z) = subcs c s z\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>\\<Union> (params ` set z).\n     x \\<noteq> c \\<longrightarrow>\n     (id(fresh := c)) x \\<noteq> (id(fresh := c)) c\n  map (psubst (id(fresh := c))) z = z\n\ngoal (1 subgoal):\n 1. map (psubst (id(fresh := c))) (subcs c (psubstt (id(c := fresh)) s) z) =\n    subcs c s z", "using s"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>\\<Union> (params ` set z).\n     x \\<noteq> c \\<longrightarrow>\n     (id(fresh := c)) x \\<noteq> (id(fresh := c)) c\n  map (psubst (id(fresh := c))) z = z\n  psubstt (id(fresh := c)) (psubstt (id(c := fresh)) s) = s\n\ngoal (1 subgoal):\n 1. map (psubst (id(fresh := c))) (subcs c (psubstt (id(c := fresh)) s) z) =\n    subcs c s z", "by (simp add: subcs_psubst)"], ["proof (state)\nthis:\n  map (psubst (id(fresh := c))) (subcs c (psubstt (id(c := fresh)) s) z) =\n  subcs c s z\n\ngoal (2 subgoals):\n 1. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 2. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])", "have \\<open>new_term c ?s\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. new_term c (psubstt (id(c := fresh)) s)", "using fresh psubst_new_free'"], ["proof (prove)\nusing this:\n  fresh\n  \\<notin> params p \\<union> \\<Union> (params ` set z) \\<union>\n           paramst s \\<union>\n           paramst t \\<union>\n           {c}\n  ?c \\<noteq> ?n \\<Longrightarrow> new_term ?n (psubstt (id(?n := ?c)) ?t)\n  ?c \\<noteq> ?n \\<Longrightarrow> new_list ?n (psubstts (id(?n := ?c)) ?l)\n\ngoal (1 subgoal):\n 1. new_term c (psubstt (id(c := fresh)) s)", "by fastforce"], ["proof (state)\nthis:\n  new_term c (psubstt (id(c := fresh)) s)\n\ngoal (2 subgoals):\n 1. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 2. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])", "have \\<open>subcs c ?s z \\<turnstile> Forall (subc c (liftt ?s) p)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. subcs c (psubstt (id(c := fresh)) s)\n     z \\<turnstile> Forall (subc c (liftt (psubstt (id(c := fresh)) s)) p)", "using ForallE"], ["proof (prove)\nusing this:\n  z \\<turnstile> Forall p\n  subcs ?c ?s z \\<turnstile> subc ?c ?s (Forall p)\n\ngoal (1 subgoal):\n 1. subcs c (psubstt (id(c := fresh)) s)\n     z \\<turnstile> Forall (subc c (liftt (psubstt (id(c := fresh)) s)) p)", "by simp"], ["proof (state)\nthis:\n  subcs c (psubstt (id(c := fresh)) s)\n   z \\<turnstile> Forall (subc c (liftt (psubstt (id(c := fresh)) s)) p)\n\ngoal (2 subgoals):\n 1. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 2. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])", "then"], ["proof (chain)\npicking this:\n  subcs c (psubstt (id(c := fresh)) s)\n   z \\<turnstile> Forall (subc c (liftt (psubstt (id(c := fresh)) s)) p)", "have \\<open>subcs c ?s z \\<turnstile> subst (subc c (liftt ?s) p) (subc_term c ?s t) 0\\<close>"], ["proof (prove)\nusing this:\n  subcs c (psubstt (id(c := fresh)) s)\n   z \\<turnstile> Forall (subc c (liftt (psubstt (id(c := fresh)) s)) p)\n\ngoal (1 subgoal):\n 1. subcs c (psubstt (id(c := fresh)) s)\n     z \\<turnstile> subc c (liftt (psubstt (id(c := fresh)) s))\n                     p[subc_term c (psubstt (id(c := fresh)) s) t/0]", "using deriv.ForallE"], ["proof (prove)\nusing this:\n  subcs c (psubstt (id(c := fresh)) s)\n   z \\<turnstile> Forall (subc c (liftt (psubstt (id(c := fresh)) s)) p)\n  ?G \\<turnstile> Forall ?a \\<Longrightarrow> ?G \\<turnstile> ?a[?t/0]\n\ngoal (1 subgoal):\n 1. subcs c (psubstt (id(c := fresh)) s)\n     z \\<turnstile> subc c (liftt (psubstt (id(c := fresh)) s))\n                     p[subc_term c (psubstt (id(c := fresh)) s) t/0]", "by blast"], ["proof (state)\nthis:\n  subcs c (psubstt (id(c := fresh)) s)\n   z \\<turnstile> subc c (liftt (psubstt (id(c := fresh)) s))\n                   p[subc_term c (psubstt (id(c := fresh)) s) t/0]\n\ngoal (2 subgoals):\n 1. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 2. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])", "moreover"], ["proof (state)\nthis:\n  subcs c (psubstt (id(c := fresh)) s)\n   z \\<turnstile> subc c (liftt (psubstt (id(c := fresh)) s))\n                   p[subc_term c (psubstt (id(c := fresh)) s) t/0]\n\ngoal (2 subgoals):\n 1. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 2. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])", "have \\<open>new_term c (subc_term c ?s t)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. new_term c (subc_term c (psubstt (id(c := fresh)) s) t)", "using \\<open>new_term c ?s\\<close> new_subc_same'"], ["proof (prove)\nusing this:\n  new_term c (psubstt (id(c := fresh)) s)\n  new_term ?c ?s \\<Longrightarrow> new_term ?c (subc_term ?c ?s ?t)\n  new_term ?c ?s \\<Longrightarrow> new_list ?c (subc_list ?c ?s ?l)\n\ngoal (1 subgoal):\n 1. new_term c (subc_term c (psubstt (id(c := fresh)) s) t)", "by fast"], ["proof (state)\nthis:\n  new_term c (subc_term c (psubstt (id(c := fresh)) s) t)\n\ngoal (2 subgoals):\n 1. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 2. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])", "ultimately"], ["proof (chain)\npicking this:\n  subcs c (psubstt (id(c := fresh)) s)\n   z \\<turnstile> subc c (liftt (psubstt (id(c := fresh)) s))\n                   p[subc_term c (psubstt (id(c := fresh)) s) t/0]\n  new_term c (subc_term c (psubstt (id(c := fresh)) s) t)", "have \\<open>subcs c ?s z \\<turnstile> subc c ?s (subst p (subc_term c ?s t) 0)\\<close>"], ["proof (prove)\nusing this:\n  subcs c (psubstt (id(c := fresh)) s)\n   z \\<turnstile> subc c (liftt (psubstt (id(c := fresh)) s))\n                   p[subc_term c (psubstt (id(c := fresh)) s) t/0]\n  new_term c (subc_term c (psubstt (id(c := fresh)) s) t)\n\ngoal (1 subgoal):\n 1. subcs c (psubstt (id(c := fresh)) s)\n     z \\<turnstile> subc c (psubstt (id(c := fresh)) s)\n                     (p[subc_term c (psubstt (id(c := fresh)) s) t/0])", "by simp"], ["proof (state)\nthis:\n  subcs c (psubstt (id(c := fresh)) s)\n   z \\<turnstile> subc c (psubstt (id(c := fresh)) s)\n                   (p[subc_term c (psubstt (id(c := fresh)) s) t/0])\n\ngoal (2 subgoals):\n 1. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 2. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])", "then"], ["proof (chain)\npicking this:\n  subcs c (psubstt (id(c := fresh)) s)\n   z \\<turnstile> subc c (psubstt (id(c := fresh)) s)\n                   (p[subc_term c (psubstt (id(c := fresh)) s) t/0])", "have \\<open>subcs c ?s z \\<turnstile> subc c ?s (subst p t 0)\\<close>"], ["proof (prove)\nusing this:\n  subcs c (psubstt (id(c := fresh)) s)\n   z \\<turnstile> subc c (psubstt (id(c := fresh)) s)\n                   (p[subc_term c (psubstt (id(c := fresh)) s) t/0])\n\ngoal (1 subgoal):\n 1. subcs c (psubstt (id(c := fresh)) s)\n     z \\<turnstile> subc c (psubstt (id(c := fresh)) s) (p[t/0])", "using new_subc_put \\<open>new_term c ?s\\<close>"], ["proof (prove)\nusing this:\n  subcs c (psubstt (id(c := fresh)) s)\n   z \\<turnstile> subc c (psubstt (id(c := fresh)) s)\n                   (p[subc_term c (psubstt (id(c := fresh)) s) t/0])\n  new_term ?c ?s \\<Longrightarrow>\n  subc ?c ?s (?p[?t/?m]) = subc ?c ?s (?p[subc_term ?c ?s ?t/?m])\n  new_term c (psubstt (id(c := fresh)) s)\n\ngoal (1 subgoal):\n 1. subcs c (psubstt (id(c := fresh)) s)\n     z \\<turnstile> subc c (psubstt (id(c := fresh)) s) (p[t/0])", "by metis"], ["proof (state)\nthis:\n  subcs c (psubstt (id(c := fresh)) s)\n   z \\<turnstile> subc c (psubstt (id(c := fresh)) s) (p[t/0])\n\ngoal (2 subgoals):\n 1. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 2. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])", "then"], ["proof (chain)\npicking this:\n  subcs c (psubstt (id(c := fresh)) s)\n   z \\<turnstile> subc c (psubstt (id(c := fresh)) s) (p[t/0])", "have \\<open>map (psubst ?g) (subcs c ?s z) \\<turnstile> psubst ?g (subc c ?s (subst p t 0))\\<close>"], ["proof (prove)\nusing this:\n  subcs c (psubstt (id(c := fresh)) s)\n   z \\<turnstile> subc c (psubstt (id(c := fresh)) s) (p[t/0])\n\ngoal (1 subgoal):\n 1. map (psubst (id(fresh := c)))\n     (subcs c (psubstt (id(c := fresh)) s)\n       z) \\<turnstile> psubst (id(fresh := c))\n                        (subc c (psubstt (id(c := fresh)) s) (p[t/0]))", "using deriv_psubst inf_params"], ["proof (prove)\nusing this:\n  subcs c (psubstt (id(c := fresh)) s)\n   z \\<turnstile> subc c (psubstt (id(c := fresh)) s) (p[t/0])\n  \\<lbrakk>infinite UNIV; ?z \\<turnstile> ?p\\<rbrakk>\n  \\<Longrightarrow> map (psubst ?f) ?z \\<turnstile> psubst ?f ?p\n  infinite UNIV\n\ngoal (1 subgoal):\n 1. map (psubst (id(fresh := c)))\n     (subcs c (psubstt (id(c := fresh)) s)\n       z) \\<turnstile> psubst (id(fresh := c))\n                        (subc c (psubstt (id(c := fresh)) s) (p[t/0]))", "by blast"], ["proof (state)\nthis:\n  map (psubst (id(fresh := c)))\n   (subcs c (psubstt (id(c := fresh)) s)\n     z) \\<turnstile> psubst (id(fresh := c))\n                      (subc c (psubstt (id(c := fresh)) s) (p[t/0]))\n\ngoal (2 subgoals):\n 1. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 2. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])", "moreover"], ["proof (state)\nthis:\n  map (psubst (id(fresh := c)))\n   (subcs c (psubstt (id(c := fresh)) s)\n     z) \\<turnstile> psubst (id(fresh := c))\n                      (subc c (psubstt (id(c := fresh)) s) (p[t/0]))\n\ngoal (2 subgoals):\n 1. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 2. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])", "have \\<open>\\<forall>x \\<in> params (subst p t 0). x \\<noteq> c \\<longrightarrow> ?g x \\<noteq> ?g c\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>params (p[t/0]).\n       x \\<noteq> c \\<longrightarrow>\n       (id(fresh := c)) x \\<noteq> (id(fresh := c)) c", "using fresh p psubst_new_free"], ["proof (prove)\nusing this:\n  fresh\n  \\<notin> params p \\<union> \\<Union> (params ` set z) \\<union>\n           paramst s \\<union>\n           paramst t \\<union>\n           {c}\n  psubst (id(fresh := c)) (p[t/0]) = p[t/0]\n  ?c \\<noteq> ?n \\<Longrightarrow> new ?n (psubst (id(?n := ?c)) ?p)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>params (p[t/0]).\n       x \\<noteq> c \\<longrightarrow>\n       (id(fresh := c)) x \\<noteq> (id(fresh := c)) c", "by (metis fun_upd_apply id_apply)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>params (p[t/0]).\n     x \\<noteq> c \\<longrightarrow>\n     (id(fresh := c)) x \\<noteq> (id(fresh := c)) c\n\ngoal (2 subgoals):\n 1. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)\n 2. \\<And>G a t c s.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (Forall a)\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (a[t/0])", "ultimately"], ["proof (chain)\npicking this:\n  map (psubst (id(fresh := c)))\n   (subcs c (psubstt (id(c := fresh)) s)\n     z) \\<turnstile> psubst (id(fresh := c))\n                      (subc c (psubstt (id(c := fresh)) s) (p[t/0]))\n  \\<forall>x\\<in>params (p[t/0]).\n     x \\<noteq> c \\<longrightarrow>\n     (id(fresh := c)) x \\<noteq> (id(fresh := c)) c", "show \\<open>subcs c s z \\<turnstile> subc c s (subst p t 0)\\<close>"], ["proof (prove)\nusing this:\n  map (psubst (id(fresh := c)))\n   (subcs c (psubstt (id(c := fresh)) s)\n     z) \\<turnstile> psubst (id(fresh := c))\n                      (subc c (psubstt (id(c := fresh)) s) (p[t/0]))\n  \\<forall>x\\<in>params (p[t/0]).\n     x \\<noteq> c \\<longrightarrow>\n     (id(fresh := c)) x \\<noteq> (id(fresh := c)) c\n\ngoal (1 subgoal):\n 1. subcs c s z \\<turnstile> subc c s (p[t/0])", "using c s p z"], ["proof (prove)\nusing this:\n  map (psubst (id(fresh := c)))\n   (subcs c (psubstt (id(c := fresh)) s)\n     z) \\<turnstile> psubst (id(fresh := c))\n                      (subc c (psubstt (id(c := fresh)) s) (p[t/0]))\n  \\<forall>x\\<in>params (p[t/0]).\n     x \\<noteq> c \\<longrightarrow>\n     (id(fresh := c)) x \\<noteq> (id(fresh := c)) c\n  (id(fresh := c)) c = c\n  psubstt (id(fresh := c)) (psubstt (id(c := fresh)) s) = s\n  psubst (id(fresh := c)) (p[t/0]) = p[t/0]\n  map (psubst (id(fresh := c))) (subcs c (psubstt (id(c := fresh)) s) z) =\n  subcs c s z\n\ngoal (1 subgoal):\n 1. subcs c s z \\<turnstile> subc c s (p[t/0])", "by (simp add: subc_psubst)"], ["proof (state)\nthis:\n  subcs c s z \\<turnstile> subc c s (p[t/0])\n\ngoal (1 subgoal):\n 1. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)", "case (ForallI z p d)"], ["proof (state)\nthis:\n  z \\<turnstile> p[App d []/0]\n  subcs ?c ?s z \\<turnstile> subc ?c ?s (p[App d []/0])\n  news d z\n  new d p\n\ngoal (1 subgoal):\n 1. \\<And>G a n c s.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>c s. subcs c s G \\<turnstile> subc c s (a[App n []/0]);\n        news n G; new n a\\<rbrakk>\n       \\<Longrightarrow> subcs c s G \\<turnstile> subc c s (Forall a)", "then"], ["proof (chain)\npicking this:\n  z \\<turnstile> p[App d []/0]\n  subcs ?c ?s z \\<turnstile> subc ?c ?s (p[App d []/0])\n  news d z\n  new d p", "show ?case"], ["proof (prove)\nusing this:\n  z \\<turnstile> p[App d []/0]\n  subcs ?c ?s z \\<turnstile> subc ?c ?s (p[App d []/0])\n  news d z\n  new d p\n\ngoal (1 subgoal):\n 1. subcs c s z \\<turnstile> subc c s (Forall p)", "proof (cases \\<open>c = d\\<close>)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>z \\<turnstile> p[App d []/0];\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (p[App d []/0]); news d z;\n     new d p; c = d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s (Forall p)\n 2. \\<lbrakk>z \\<turnstile> p[App d []/0];\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (p[App d []/0]); news d z;\n     new d p; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s (Forall p)", "case True"], ["proof (state)\nthis:\n  c = d\n\ngoal (2 subgoals):\n 1. \\<lbrakk>z \\<turnstile> p[App d []/0];\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (p[App d []/0]); news d z;\n     new d p; c = d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s (Forall p)\n 2. \\<lbrakk>z \\<turnstile> p[App d []/0];\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (p[App d []/0]); news d z;\n     new d p; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s (Forall p)", "then"], ["proof (chain)\npicking this:\n  c = d", "have \\<open>z \\<turnstile> Forall p\\<close>"], ["proof (prove)\nusing this:\n  c = d\n\ngoal (1 subgoal):\n 1. z \\<turnstile> Forall p", "using ForallI deriv.ForallI"], ["proof (prove)\nusing this:\n  c = d\n  z \\<turnstile> p[App d []/0]\n  subcs ?c ?s z \\<turnstile> subc ?c ?s (p[App d []/0])\n  news d z\n  new d p\n  \\<lbrakk>?G \\<turnstile> ?a[App ?n []/0]; news ?n ?G; new ?n ?a\\<rbrakk>\n  \\<Longrightarrow> ?G \\<turnstile> Forall ?a\n\ngoal (1 subgoal):\n 1. z \\<turnstile> Forall p", "by fast"], ["proof (state)\nthis:\n  z \\<turnstile> Forall p\n\ngoal (2 subgoals):\n 1. \\<lbrakk>z \\<turnstile> p[App d []/0];\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (p[App d []/0]); news d z;\n     new d p; c = d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s (Forall p)\n 2. \\<lbrakk>z \\<turnstile> p[App d []/0];\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (p[App d []/0]); news d z;\n     new d p; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s (Forall p)", "moreover"], ["proof (state)\nthis:\n  z \\<turnstile> Forall p\n\ngoal (2 subgoals):\n 1. \\<lbrakk>z \\<turnstile> p[App d []/0];\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (p[App d []/0]); news d z;\n     new d p; c = d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s (Forall p)\n 2. \\<lbrakk>z \\<turnstile> p[App d []/0];\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (p[App d []/0]); news d z;\n     new d p; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s (Forall p)", "have \\<open>new c p\\<close> and \\<open>news c z\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. new c p &&& news c z", "using ForallI True"], ["proof (prove)\nusing this:\n  z \\<turnstile> p[App d []/0]\n  subcs ?c ?s z \\<turnstile> subc ?c ?s (p[App d []/0])\n  news d z\n  new d p\n  c = d\n\ngoal (1 subgoal):\n 1. new c p &&& news c z", "by simp_all"], ["proof (state)\nthis:\n  new c p\n  news c z\n\ngoal (2 subgoals):\n 1. \\<lbrakk>z \\<turnstile> p[App d []/0];\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (p[App d []/0]); news d z;\n     new d p; c = d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s (Forall p)\n 2. \\<lbrakk>z \\<turnstile> p[App d []/0];\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (p[App d []/0]); news d z;\n     new d p; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s (Forall p)", "ultimately"], ["proof (chain)\npicking this:\n  z \\<turnstile> Forall p\n  new c p\n  news c z", "show ?thesis"], ["proof (prove)\nusing this:\n  z \\<turnstile> Forall p\n  new c p\n  news c z\n\ngoal (1 subgoal):\n 1. subcs c s z \\<turnstile> subc c s (Forall p)", "by (simp add: subcs_news)"], ["proof (state)\nthis:\n  subcs c s z \\<turnstile> subc c s (Forall p)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> p[App d []/0];\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (p[App d []/0]); news d z;\n     new d p; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s (Forall p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> p[App d []/0];\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (p[App d []/0]); news d z;\n     new d p; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s (Forall p)", "case False"], ["proof (state)\nthis:\n  c \\<noteq> d\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> p[App d []/0];\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (p[App d []/0]); news d z;\n     new d p; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s (Forall p)", "let ?params = \\<open>params p \\<union> (\\<Union>p \\<in> set z. params p) \\<union> paramst s \\<union> {c} \\<union> {d}\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> p[App d []/0];\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (p[App d []/0]); news d z;\n     new d p; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s (Forall p)", "have \\<open>finite ?params\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (params p \\<union> \\<Union> (params ` set z) \\<union>\n      paramst s \\<union>\n      {c} \\<union>\n      {d})", "by simp"], ["proof (state)\nthis:\n  finite\n   (params p \\<union> \\<Union> (params ` set z) \\<union> paramst s \\<union>\n    {c} \\<union>\n    {d})\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> p[App d []/0];\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (p[App d []/0]); news d z;\n     new d p; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s (Forall p)", "then"], ["proof (chain)\npicking this:\n  finite\n   (params p \\<union> \\<Union> (params ` set z) \\<union> paramst s \\<union>\n    {c} \\<union>\n    {d})", "obtain fresh where fresh: \\<open>fresh \\<notin> ?params\\<close>"], ["proof (prove)\nusing this:\n  finite\n   (params p \\<union> \\<Union> (params ` set z) \\<union> paramst s \\<union>\n    {c} \\<union>\n    {d})\n\ngoal (1 subgoal):\n 1. (\\<And>fresh.\n        fresh\n        \\<notin> params p \\<union> \\<Union> (params ` set z) \\<union>\n                 paramst s \\<union>\n                 {c} \\<union>\n                 {d} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using inf_params"], ["proof (prove)\nusing this:\n  finite\n   (params p \\<union> \\<Union> (params ` set z) \\<union> paramst s \\<union>\n    {c} \\<union>\n    {d})\n  infinite UNIV\n\ngoal (1 subgoal):\n 1. (\\<And>fresh.\n        fresh\n        \\<notin> params p \\<union> \\<Union> (params ` set z) \\<union>\n                 paramst s \\<union>\n                 {c} \\<union>\n                 {d} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (meson ex_new_if_finite infinite_UNIV_listI)"], ["proof (state)\nthis:\n  fresh\n  \\<notin> params p \\<union> \\<Union> (params ` set z) \\<union>\n           paramst s \\<union>\n           {c} \\<union>\n           {d}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> p[App d []/0];\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (p[App d []/0]); news d z;\n     new d p; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s (Forall p)", "let ?s = \\<open>psubstt (id(d := fresh)) s\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> p[App d []/0];\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (p[App d []/0]); news d z;\n     new d p; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s (Forall p)", "let ?f = \\<open>id(d := fresh, fresh := d)\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> p[App d []/0];\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (p[App d []/0]); news d z;\n     new d p; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s (Forall p)", "have f: \\<open>\\<forall>x \\<in> ?params. x \\<noteq> c \\<longrightarrow> ?f x \\<noteq> ?f c\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>params p \\<union> \\<Union> (params ` set z) \\<union>\n                   paramst s \\<union>\n                   {c} \\<union>\n                   {d}.\n       x \\<noteq> c \\<longrightarrow>\n       (id(d := fresh, fresh := d)) x \\<noteq>\n       (id(d := fresh, fresh := d)) c", "using fresh"], ["proof (prove)\nusing this:\n  fresh\n  \\<notin> params p \\<union> \\<Union> (params ` set z) \\<union>\n           paramst s \\<union>\n           {c} \\<union>\n           {d}\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>params p \\<union> \\<Union> (params ` set z) \\<union>\n                   paramst s \\<union>\n                   {c} \\<union>\n                   {d}.\n       x \\<noteq> c \\<longrightarrow>\n       (id(d := fresh, fresh := d)) x \\<noteq>\n       (id(d := fresh, fresh := d)) c", "by simp"], ["proof (state)\nthis:\n  \\<forall>x\\<in>params p \\<union> \\<Union> (params ` set z) \\<union>\n                 paramst s \\<union>\n                 {c} \\<union>\n                 {d}.\n     x \\<noteq> c \\<longrightarrow>\n     (id(d := fresh, fresh := d)) x \\<noteq> (id(d := fresh, fresh := d)) c\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> p[App d []/0];\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (p[App d []/0]); news d z;\n     new d p; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s (Forall p)", "have \\<open>new_term d ?s\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. new_term d (psubstt (id(d := fresh)) s)", "using fresh psubst_new_free'"], ["proof (prove)\nusing this:\n  fresh\n  \\<notin> params p \\<union> \\<Union> (params ` set z) \\<union>\n           paramst s \\<union>\n           {c} \\<union>\n           {d}\n  ?c \\<noteq> ?n \\<Longrightarrow> new_term ?n (psubstt (id(?n := ?c)) ?t)\n  ?c \\<noteq> ?n \\<Longrightarrow> new_list ?n (psubstts (id(?n := ?c)) ?l)\n\ngoal (1 subgoal):\n 1. new_term d (psubstt (id(d := fresh)) s)", "by fastforce"], ["proof (state)\nthis:\n  new_term d (psubstt (id(d := fresh)) s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> p[App d []/0];\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (p[App d []/0]); news d z;\n     new d p; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s (Forall p)", "then"], ["proof (chain)\npicking this:\n  new_term d (psubstt (id(d := fresh)) s)", "have \\<open>psubstt ?f ?s = psubstt (id(fresh := d)) ?s\\<close>"], ["proof (prove)\nusing this:\n  new_term d (psubstt (id(d := fresh)) s)\n\ngoal (1 subgoal):\n 1. psubstt (id(d := fresh, fresh := d)) (psubstt (id(d := fresh)) s) =\n    psubstt (id(fresh := d)) (psubstt (id(d := fresh)) s)", "by (metis fun_upd_twist psubstt_upd(1))"], ["proof (state)\nthis:\n  psubstt (id(d := fresh, fresh := d)) (psubstt (id(d := fresh)) s) =\n  psubstt (id(fresh := d)) (psubstt (id(d := fresh)) s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> p[App d []/0];\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (p[App d []/0]); news d z;\n     new d p; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s (Forall p)", "then"], ["proof (chain)\npicking this:\n  psubstt (id(d := fresh, fresh := d)) (psubstt (id(d := fresh)) s) =\n  psubstt (id(fresh := d)) (psubstt (id(d := fresh)) s)", "have psubst_s: \\<open>psubstt ?f ?s = s\\<close>"], ["proof (prove)\nusing this:\n  psubstt (id(d := fresh, fresh := d)) (psubstt (id(d := fresh)) s) =\n  psubstt (id(fresh := d)) (psubstt (id(d := fresh)) s)\n\ngoal (1 subgoal):\n 1. psubstt (id(d := fresh, fresh := d)) (psubstt (id(d := fresh)) s) = s", "using fresh"], ["proof (prove)\nusing this:\n  psubstt (id(d := fresh, fresh := d)) (psubstt (id(d := fresh)) s) =\n  psubstt (id(fresh := d)) (psubstt (id(d := fresh)) s)\n  fresh\n  \\<notin> params p \\<union> \\<Union> (params ` set z) \\<union>\n           paramst s \\<union>\n           {c} \\<union>\n           {d}\n\ngoal (1 subgoal):\n 1. psubstt (id(d := fresh, fresh := d)) (psubstt (id(d := fresh)) s) = s", "by simp"], ["proof (state)\nthis:\n  psubstt (id(d := fresh, fresh := d)) (psubstt (id(d := fresh)) s) = s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> p[App d []/0];\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (p[App d []/0]); news d z;\n     new d p; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s (Forall p)", "have \\<open>?f c = c\\<close> and \\<open>new_term c (App fresh [])\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (id(d := fresh, fresh := d)) c = c &&& new_term c (App fresh [])", "using False fresh"], ["proof (prove)\nusing this:\n  c \\<noteq> d\n  fresh\n  \\<notin> params p \\<union> \\<Union> (params ` set z) \\<union>\n           paramst s \\<union>\n           {c} \\<union>\n           {d}\n\ngoal (1 subgoal):\n 1. (id(d := fresh, fresh := d)) c = c &&& new_term c (App fresh [])", "by auto"], ["proof (state)\nthis:\n  (id(d := fresh, fresh := d)) c = c\n  new_term c (App fresh [])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> p[App d []/0];\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (p[App d []/0]); news d z;\n     new d p; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s (Forall p)", "have \\<open>psubst ?f (subc c ?s (subst p (App d []) 0)) =\n      subc (?f c) (psubstt ?f ?s) (psubst ?f (subst p (App d []) 0))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. psubst (id(d := fresh, fresh := d))\n     (subc c (psubstt (id(d := fresh)) s) (p[App d []/0])) =\n    subc ((id(d := fresh, fresh := d)) c)\n     (psubstt (id(d := fresh, fresh := d)) (psubstt (id(d := fresh)) s))\n     (psubst (id(d := fresh, fresh := d)) (p[App d []/0]))", "by (simp add: subc_psubst)"], ["proof (state)\nthis:\n  psubst (id(d := fresh, fresh := d))\n   (subc c (psubstt (id(d := fresh)) s) (p[App d []/0])) =\n  subc ((id(d := fresh, fresh := d)) c)\n   (psubstt (id(d := fresh, fresh := d)) (psubstt (id(d := fresh)) s))\n   (psubst (id(d := fresh, fresh := d)) (p[App d []/0]))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> p[App d []/0];\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (p[App d []/0]); news d z;\n     new d p; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s (Forall p)", "also"], ["proof (state)\nthis:\n  psubst (id(d := fresh, fresh := d))\n   (subc c (psubstt (id(d := fresh)) s) (p[App d []/0])) =\n  subc ((id(d := fresh, fresh := d)) c)\n   (psubstt (id(d := fresh, fresh := d)) (psubstt (id(d := fresh)) s))\n   (psubst (id(d := fresh, fresh := d)) (p[App d []/0]))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> p[App d []/0];\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (p[App d []/0]); news d z;\n     new d p; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s (Forall p)", "have \\<open>\\<dots> = subc c s (subst (psubst ?f p) (App fresh []) 0)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. subc ((id(d := fresh, fresh := d)) c)\n     (psubstt (id(d := fresh, fresh := d)) (psubstt (id(d := fresh)) s))\n     (psubst (id(d := fresh, fresh := d)) (p[App d []/0])) =\n    subc c s (psubst (id(d := fresh, fresh := d)) p[App fresh []/0])", "using \\<open>?f c = c\\<close> psubst_subst psubst_s"], ["proof (prove)\nusing this:\n  (id(d := fresh, fresh := d)) c = c\n  psubst ?f (?P[?t/?i]) = psubst ?f ?P[psubstt ?f ?t/?i]\n  psubstt (id(d := fresh, fresh := d)) (psubstt (id(d := fresh)) s) = s\n\ngoal (1 subgoal):\n 1. subc ((id(d := fresh, fresh := d)) c)\n     (psubstt (id(d := fresh, fresh := d)) (psubstt (id(d := fresh)) s))\n     (psubst (id(d := fresh, fresh := d)) (p[App d []/0])) =\n    subc c s (psubst (id(d := fresh, fresh := d)) p[App fresh []/0])", "by simp"], ["proof (state)\nthis:\n  subc ((id(d := fresh, fresh := d)) c)\n   (psubstt (id(d := fresh, fresh := d)) (psubstt (id(d := fresh)) s))\n   (psubst (id(d := fresh, fresh := d)) (p[App d []/0])) =\n  subc c s (psubst (id(d := fresh, fresh := d)) p[App fresh []/0])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> p[App d []/0];\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (p[App d []/0]); news d z;\n     new d p; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s (Forall p)", "also"], ["proof (state)\nthis:\n  subc ((id(d := fresh, fresh := d)) c)\n   (psubstt (id(d := fresh, fresh := d)) (psubstt (id(d := fresh)) s))\n   (psubst (id(d := fresh, fresh := d)) (p[App d []/0])) =\n  subc c s (psubst (id(d := fresh, fresh := d)) p[App fresh []/0])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> p[App d []/0];\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (p[App d []/0]); news d z;\n     new d p; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s (Forall p)", "have \\<open>\\<dots> = subc c s (subst p (App fresh []) 0)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. subc c s (psubst (id(d := fresh, fresh := d)) p[App fresh []/0]) =\n    subc c s (p[App fresh []/0])", "using ForallI fresh"], ["proof (prove)\nusing this:\n  z \\<turnstile> p[App d []/0]\n  subcs ?c ?s z \\<turnstile> subc ?c ?s (p[App d []/0])\n  news d z\n  new d p\n  fresh\n  \\<notin> params p \\<union> \\<Union> (params ` set z) \\<union>\n           paramst s \\<union>\n           {c} \\<union>\n           {d}\n\ngoal (1 subgoal):\n 1. subc c s (psubst (id(d := fresh, fresh := d)) p[App fresh []/0]) =\n    subc c s (p[App fresh []/0])", "by simp"], ["proof (state)\nthis:\n  subc c s (psubst (id(d := fresh, fresh := d)) p[App fresh []/0]) =\n  subc c s (p[App fresh []/0])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> p[App d []/0];\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (p[App d []/0]); news d z;\n     new d p; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s (Forall p)", "finally"], ["proof (chain)\npicking this:\n  psubst (id(d := fresh, fresh := d))\n   (subc c (psubstt (id(d := fresh)) s) (p[App d []/0])) =\n  subc c s (p[App fresh []/0])", "have psubst_p: \\<open>psubst ?f (subc c ?s (subst p (App d []) 0)) =\n        subst (subc c (liftt s) p) (App fresh []) 0\\<close>"], ["proof (prove)\nusing this:\n  psubst (id(d := fresh, fresh := d))\n   (subc c (psubstt (id(d := fresh)) s) (p[App d []/0])) =\n  subc c s (p[App fresh []/0])\n\ngoal (1 subgoal):\n 1. psubst (id(d := fresh, fresh := d))\n     (subc c (psubstt (id(d := fresh)) s) (p[App d []/0])) =\n    subc c (liftt s) p[App fresh []/0]", "using subc_sub_0_new \\<open>new_term c (App fresh [])\\<close>"], ["proof (prove)\nusing this:\n  psubst (id(d := fresh, fresh := d))\n   (subc c (psubstt (id(d := fresh)) s) (p[App d []/0])) =\n  subc c s (p[App fresh []/0])\n  new_term ?c ?t \\<Longrightarrow>\n  subc ?c ?s (?p[?t/0]) = subc ?c (liftt ?s) ?p[?t/0]\n  new_term c (App fresh [])\n\ngoal (1 subgoal):\n 1. psubst (id(d := fresh, fresh := d))\n     (subc c (psubstt (id(d := fresh)) s) (p[App d []/0])) =\n    subc c (liftt s) p[App fresh []/0]", "by simp"], ["proof (state)\nthis:\n  psubst (id(d := fresh, fresh := d))\n   (subc c (psubstt (id(d := fresh)) s) (p[App d []/0])) =\n  subc c (liftt s) p[App fresh []/0]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> p[App d []/0];\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (p[App d []/0]); news d z;\n     new d p; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s (Forall p)", "have \\<open>news d z\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. news d z", "using ForallI"], ["proof (prove)\nusing this:\n  z \\<turnstile> p[App d []/0]\n  subcs ?c ?s z \\<turnstile> subc ?c ?s (p[App d []/0])\n  news d z\n  new d p\n\ngoal (1 subgoal):\n 1. news d z", "by simp"], ["proof (state)\nthis:\n  news d z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> p[App d []/0];\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (p[App d []/0]); news d z;\n     new d p; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s (Forall p)", "moreover"], ["proof (state)\nthis:\n  news d z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> p[App d []/0];\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (p[App d []/0]); news d z;\n     new d p; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s (Forall p)", "have \\<open>news fresh z\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. news fresh z", "using fresh"], ["proof (prove)\nusing this:\n  fresh\n  \\<notin> params p \\<union> \\<Union> (params ` set z) \\<union>\n           paramst s \\<union>\n           {c} \\<union>\n           {d}\n\ngoal (1 subgoal):\n 1. news fresh z", "by (induct z) simp_all"], ["proof (state)\nthis:\n  news fresh z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> p[App d []/0];\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (p[App d []/0]); news d z;\n     new d p; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s (Forall p)", "ultimately"], ["proof (chain)\npicking this:\n  news d z\n  news fresh z", "have \\<open>map (psubst ?f) z = z\\<close>"], ["proof (prove)\nusing this:\n  news d z\n  news fresh z\n\ngoal (1 subgoal):\n 1. map (psubst (id(d := fresh, fresh := d))) z = z", "by (induct z) simp_all"], ["proof (state)\nthis:\n  map (psubst (id(d := fresh, fresh := d))) z = z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> p[App d []/0];\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (p[App d []/0]); news d z;\n     new d p; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s (Forall p)", "moreover"], ["proof (state)\nthis:\n  map (psubst (id(d := fresh, fresh := d))) z = z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> p[App d []/0];\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (p[App d []/0]); news d z;\n     new d p; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s (Forall p)", "have \\<open>\\<forall>x \\<in> \\<Union>p \\<in> set z. params p. x \\<noteq> c \\<longrightarrow> ?f x \\<noteq> ?f c\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>\\<Union> (params ` set z).\n       x \\<noteq> c \\<longrightarrow>\n       (id(d := fresh, fresh := d)) x \\<noteq>\n       (id(d := fresh, fresh := d)) c", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<in>\\<Union> (params ` set z).\n     x \\<noteq> c \\<longrightarrow>\n     (id(d := fresh, fresh := d)) x \\<noteq> (id(d := fresh, fresh := d)) c\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> p[App d []/0];\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (p[App d []/0]); news d z;\n     new d p; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s (Forall p)", "ultimately"], ["proof (chain)\npicking this:\n  map (psubst (id(d := fresh, fresh := d))) z = z\n  \\<forall>x\\<in>\\<Union> (params ` set z).\n     x \\<noteq> c \\<longrightarrow>\n     (id(d := fresh, fresh := d)) x \\<noteq> (id(d := fresh, fresh := d)) c", "have psubst_z: \\<open>map (psubst ?f) (subcs c ?s z) = subcs c s z\\<close>"], ["proof (prove)\nusing this:\n  map (psubst (id(d := fresh, fresh := d))) z = z\n  \\<forall>x\\<in>\\<Union> (params ` set z).\n     x \\<noteq> c \\<longrightarrow>\n     (id(d := fresh, fresh := d)) x \\<noteq> (id(d := fresh, fresh := d)) c\n\ngoal (1 subgoal):\n 1. map (psubst (id(d := fresh, fresh := d)))\n     (subcs c (psubstt (id(d := fresh)) s) z) =\n    subcs c s z", "using \\<open>?f c = c\\<close> psubst_s"], ["proof (prove)\nusing this:\n  map (psubst (id(d := fresh, fresh := d))) z = z\n  \\<forall>x\\<in>\\<Union> (params ` set z).\n     x \\<noteq> c \\<longrightarrow>\n     (id(d := fresh, fresh := d)) x \\<noteq> (id(d := fresh, fresh := d)) c\n  (id(d := fresh, fresh := d)) c = c\n  psubstt (id(d := fresh, fresh := d)) (psubstt (id(d := fresh)) s) = s\n\ngoal (1 subgoal):\n 1. map (psubst (id(d := fresh, fresh := d)))\n     (subcs c (psubstt (id(d := fresh)) s) z) =\n    subcs c s z", "by (simp add: subcs_psubst)"], ["proof (state)\nthis:\n  map (psubst (id(d := fresh, fresh := d)))\n   (subcs c (psubstt (id(d := fresh)) s) z) =\n  subcs c s z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> p[App d []/0];\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (p[App d []/0]); news d z;\n     new d p; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s (Forall p)", "have \\<open>subcs c ?s z \\<turnstile> subc c ?s (subst p (App d []) 0)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. subcs c (psubstt (id(d := fresh)) s)\n     z \\<turnstile> subc c (psubstt (id(d := fresh)) s) (p[App d []/0])", "using ForallI"], ["proof (prove)\nusing this:\n  z \\<turnstile> p[App d []/0]\n  subcs ?c ?s z \\<turnstile> subc ?c ?s (p[App d []/0])\n  news d z\n  new d p\n\ngoal (1 subgoal):\n 1. subcs c (psubstt (id(d := fresh)) s)\n     z \\<turnstile> subc c (psubstt (id(d := fresh)) s) (p[App d []/0])", "by blast"], ["proof (state)\nthis:\n  subcs c (psubstt (id(d := fresh)) s)\n   z \\<turnstile> subc c (psubstt (id(d := fresh)) s) (p[App d []/0])\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> p[App d []/0];\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (p[App d []/0]); news d z;\n     new d p; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s (Forall p)", "then"], ["proof (chain)\npicking this:\n  subcs c (psubstt (id(d := fresh)) s)\n   z \\<turnstile> subc c (psubstt (id(d := fresh)) s) (p[App d []/0])", "have \\<open>map (psubst ?f) (subcs c ?s z) \\<turnstile> psubst ?f (subc c ?s (subst p (App d []) 0))\\<close>"], ["proof (prove)\nusing this:\n  subcs c (psubstt (id(d := fresh)) s)\n   z \\<turnstile> subc c (psubstt (id(d := fresh)) s) (p[App d []/0])\n\ngoal (1 subgoal):\n 1. map (psubst (id(d := fresh, fresh := d)))\n     (subcs c (psubstt (id(d := fresh)) s)\n       z) \\<turnstile> psubst (id(d := fresh, fresh := d))\n                        (subc c (psubstt (id(d := fresh)) s)\n                          (p[App d []/0]))", "using deriv_psubst inf_params"], ["proof (prove)\nusing this:\n  subcs c (psubstt (id(d := fresh)) s)\n   z \\<turnstile> subc c (psubstt (id(d := fresh)) s) (p[App d []/0])\n  \\<lbrakk>infinite UNIV; ?z \\<turnstile> ?p\\<rbrakk>\n  \\<Longrightarrow> map (psubst ?f) ?z \\<turnstile> psubst ?f ?p\n  infinite UNIV\n\ngoal (1 subgoal):\n 1. map (psubst (id(d := fresh, fresh := d)))\n     (subcs c (psubstt (id(d := fresh)) s)\n       z) \\<turnstile> psubst (id(d := fresh, fresh := d))\n                        (subc c (psubstt (id(d := fresh)) s)\n                          (p[App d []/0]))", "by blast"], ["proof (state)\nthis:\n  map (psubst (id(d := fresh, fresh := d)))\n   (subcs c (psubstt (id(d := fresh)) s)\n     z) \\<turnstile> psubst (id(d := fresh, fresh := d))\n                      (subc c (psubstt (id(d := fresh)) s) (p[App d []/0]))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> p[App d []/0];\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (p[App d []/0]); news d z;\n     new d p; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s (Forall p)", "then"], ["proof (chain)\npicking this:\n  map (psubst (id(d := fresh, fresh := d)))\n   (subcs c (psubstt (id(d := fresh)) s)\n     z) \\<turnstile> psubst (id(d := fresh, fresh := d))\n                      (subc c (psubstt (id(d := fresh)) s) (p[App d []/0]))", "have \\<open>subcs c s z \\<turnstile> psubst ?f (subc c ?s (subst p (App d []) 0))\\<close>"], ["proof (prove)\nusing this:\n  map (psubst (id(d := fresh, fresh := d)))\n   (subcs c (psubstt (id(d := fresh)) s)\n     z) \\<turnstile> psubst (id(d := fresh, fresh := d))\n                      (subc c (psubstt (id(d := fresh)) s) (p[App d []/0]))\n\ngoal (1 subgoal):\n 1. subcs c s\n     z \\<turnstile> psubst (id(d := fresh, fresh := d))\n                     (subc c (psubstt (id(d := fresh)) s) (p[App d []/0]))", "using psubst_z"], ["proof (prove)\nusing this:\n  map (psubst (id(d := fresh, fresh := d)))\n   (subcs c (psubstt (id(d := fresh)) s)\n     z) \\<turnstile> psubst (id(d := fresh, fresh := d))\n                      (subc c (psubstt (id(d := fresh)) s) (p[App d []/0]))\n  map (psubst (id(d := fresh, fresh := d)))\n   (subcs c (psubstt (id(d := fresh)) s) z) =\n  subcs c s z\n\ngoal (1 subgoal):\n 1. subcs c s\n     z \\<turnstile> psubst (id(d := fresh, fresh := d))\n                     (subc c (psubstt (id(d := fresh)) s) (p[App d []/0]))", "by simp"], ["proof (state)\nthis:\n  subcs c s\n   z \\<turnstile> psubst (id(d := fresh, fresh := d))\n                   (subc c (psubstt (id(d := fresh)) s) (p[App d []/0]))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> p[App d []/0];\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (p[App d []/0]); news d z;\n     new d p; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s (Forall p)", "then"], ["proof (chain)\npicking this:\n  subcs c s\n   z \\<turnstile> psubst (id(d := fresh, fresh := d))\n                   (subc c (psubstt (id(d := fresh)) s) (p[App d []/0]))", "have sub_p: \\<open>subcs c s z \\<turnstile> subst (subc c (liftt s) p) (App fresh []) 0\\<close>"], ["proof (prove)\nusing this:\n  subcs c s\n   z \\<turnstile> psubst (id(d := fresh, fresh := d))\n                   (subc c (psubstt (id(d := fresh)) s) (p[App d []/0]))\n\ngoal (1 subgoal):\n 1. subcs c s z \\<turnstile> subc c (liftt s) p[App fresh []/0]", "using psubst_p"], ["proof (prove)\nusing this:\n  subcs c s\n   z \\<turnstile> psubst (id(d := fresh, fresh := d))\n                   (subc c (psubstt (id(d := fresh)) s) (p[App d []/0]))\n  psubst (id(d := fresh, fresh := d))\n   (subc c (psubstt (id(d := fresh)) s) (p[App d []/0])) =\n  subc c (liftt s) p[App fresh []/0]\n\ngoal (1 subgoal):\n 1. subcs c s z \\<turnstile> subc c (liftt s) p[App fresh []/0]", "by simp"], ["proof (state)\nthis:\n  subcs c s z \\<turnstile> subc c (liftt s) p[App fresh []/0]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> p[App d []/0];\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (p[App d []/0]); news d z;\n     new d p; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s (Forall p)", "have \\<open>new_term fresh s\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. new_term fresh s", "using fresh"], ["proof (prove)\nusing this:\n  fresh\n  \\<notin> params p \\<union> \\<Union> (params ` set z) \\<union>\n           paramst s \\<union>\n           {c} \\<union>\n           {d}\n\ngoal (1 subgoal):\n 1. new_term fresh s", "by simp"], ["proof (state)\nthis:\n  new_term fresh s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> p[App d []/0];\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (p[App d []/0]); news d z;\n     new d p; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s (Forall p)", "then"], ["proof (chain)\npicking this:\n  new_term fresh s", "have \\<open>new_term fresh (liftt s)\\<close>"], ["proof (prove)\nusing this:\n  new_term fresh s\n\ngoal (1 subgoal):\n 1. new_term fresh (liftt s)", "using new_lift"], ["proof (prove)\nusing this:\n  new_term fresh s\n  new_term ?c ?t \\<Longrightarrow> new_term ?c (liftt ?t)\n  new_list ?c ?l \\<Longrightarrow> new_list ?c (liftts ?l)\n\ngoal (1 subgoal):\n 1. new_term fresh (liftt s)", "by simp"], ["proof (state)\nthis:\n  new_term fresh (liftt s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> p[App d []/0];\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (p[App d []/0]); news d z;\n     new d p; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s (Forall p)", "then"], ["proof (chain)\npicking this:\n  new_term fresh (liftt s)", "have \\<open>new fresh (subc c (liftt s) p)\\<close>"], ["proof (prove)\nusing this:\n  new_term fresh (liftt s)\n\ngoal (1 subgoal):\n 1. new fresh (subc c (liftt s) p)", "using fresh new_subc"], ["proof (prove)\nusing this:\n  new_term fresh (liftt s)\n  fresh\n  \\<notin> params p \\<union> \\<Union> (params ` set z) \\<union>\n           paramst s \\<union>\n           {c} \\<union>\n           {d}\n  \\<lbrakk>new_term ?d ?s; new ?d ?p\\<rbrakk>\n  \\<Longrightarrow> new ?d (subc ?c ?s ?p)\n\ngoal (1 subgoal):\n 1. new fresh (subc c (liftt s) p)", "by simp"], ["proof (state)\nthis:\n  new fresh (subc c (liftt s) p)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> p[App d []/0];\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (p[App d []/0]); news d z;\n     new d p; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s (Forall p)", "moreover"], ["proof (state)\nthis:\n  new fresh (subc c (liftt s) p)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> p[App d []/0];\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (p[App d []/0]); news d z;\n     new d p; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s (Forall p)", "have \\<open>news fresh (subcs c s z)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. news fresh (subcs c s z)", "using \\<open>news fresh z\\<close> \\<open>new_term fresh s\\<close> news_subcs"], ["proof (prove)\nusing this:\n  news fresh z\n  new_term fresh s\n  \\<lbrakk>new_term ?d ?s; news ?d ?z\\<rbrakk>\n  \\<Longrightarrow> news ?d (subcs ?c ?s ?z)\n\ngoal (1 subgoal):\n 1. news fresh (subcs c s z)", "by fast"], ["proof (state)\nthis:\n  news fresh (subcs c s z)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> p[App d []/0];\n     \\<And>c s. subcs c s z \\<turnstile> subc c s (p[App d []/0]); news d z;\n     new d p; c \\<noteq> d\\<rbrakk>\n    \\<Longrightarrow> subcs c s z \\<turnstile> subc c s (Forall p)", "ultimately"], ["proof (chain)\npicking this:\n  new fresh (subc c (liftt s) p)\n  news fresh (subcs c s z)", "show \\<open>subcs c s z \\<turnstile> subc c s (Forall p)\\<close>"], ["proof (prove)\nusing this:\n  new fresh (subc c (liftt s) p)\n  news fresh (subcs c s z)\n\ngoal (1 subgoal):\n 1. subcs c s z \\<turnstile> subc c s (Forall p)", "using deriv.ForallI sub_p"], ["proof (prove)\nusing this:\n  new fresh (subc c (liftt s) p)\n  news fresh (subcs c s z)\n  \\<lbrakk>?G \\<turnstile> ?a[App ?n []/0]; news ?n ?G; new ?n ?a\\<rbrakk>\n  \\<Longrightarrow> ?G \\<turnstile> Forall ?a\n  subcs c s z \\<turnstile> subc c (liftt s) p[App fresh []/0]\n\ngoal (1 subgoal):\n 1. subcs c s z \\<turnstile> subc c s (Forall p)", "by simp"], ["proof (state)\nthis:\n  subcs c s z \\<turnstile> subc c s (Forall p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  subcs c s z \\<turnstile> subc c s (Forall p)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Weakening assumptions\\<close>"], ["", "lemma psubst_new_subset:\n  assumes \\<open>set z \\<subseteq> set z'\\<close> \\<open>c \\<notin> (\\<Union>p \\<in> set z. params p)\\<close>\n  shows \\<open>set z \\<subseteq> set (map (psubst (id(c := n))) z')\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. set z \\<subseteq> set (map (psubst (id(c := n))) z')", "using assms"], ["proof (prove)\nusing this:\n  set z \\<subseteq> set z'\n  c \\<notin> \\<Union> (params ` set z)\n\ngoal (1 subgoal):\n 1. set z \\<subseteq> set (map (psubst (id(c := n))) z')", "by force"], ["", "lemma subset_cons: \\<open>set z \\<subseteq> set z' \\<Longrightarrow> set (p # z) \\<subseteq> set (p # z')\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. set z \\<subseteq> set z' \\<Longrightarrow>\n    set (p # z) \\<subseteq> set (p # z')", "by auto"], ["", "lemma weaken_assumptions:\n  fixes p :: \\<open>('a, 'b) form\\<close>\n  assumes inf_params: \\<open>infinite (UNIV :: 'a set)\\<close>\n  shows \\<open>z \\<turnstile> p \\<Longrightarrow> set z \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>z \\<turnstile> p; set z \\<subseteq> set z'\\<rbrakk>\n    \\<Longrightarrow> z' \\<turnstile> p", "proof (induct z p arbitrary: z' rule: deriv.induct)"], ["proof (state)\ngoal (18 subgoals):\n 1. \\<And>a G z'.\n       \\<lbrakk>a \\<in> set G; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a\n 2. \\<And>G z'.\n       set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> TT\n 3. \\<And>G a z'.\n       \\<lbrakk>G \\<turnstile> FF;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> FF;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a\n 4. \\<And>a G z'.\n       \\<lbrakk>a # G \\<turnstile> FF;\n        \\<And>z'.\n           set (a # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> FF;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Neg a\n 5. \\<And>G a z'.\n       \\<lbrakk>G \\<turnstile> Neg a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> Neg a;\n        G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> FF\n 6. \\<And>a G z'.\n       \\<lbrakk>Neg a # G \\<turnstile> FF;\n        \\<And>z'.\n           set (Neg a # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> FF;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a\n 7. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        G \\<turnstile> b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> And a b\n 8. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a\n 9. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b\n 10. \\<And>G a b z'.\n        \\<lbrakk>G \\<turnstile> a;\n         \\<And>z'.\n            set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n         set G \\<subseteq> set z'\\<rbrakk>\n        \\<Longrightarrow> z' \\<turnstile> Or a b\nA total of 18 subgoals...", "case (Assum p z)"], ["proof (state)\nthis:\n  p \\<in> set z\n  set z \\<subseteq> set z'\n\ngoal (18 subgoals):\n 1. \\<And>a G z'.\n       \\<lbrakk>a \\<in> set G; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a\n 2. \\<And>G z'.\n       set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> TT\n 3. \\<And>G a z'.\n       \\<lbrakk>G \\<turnstile> FF;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> FF;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a\n 4. \\<And>a G z'.\n       \\<lbrakk>a # G \\<turnstile> FF;\n        \\<And>z'.\n           set (a # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> FF;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Neg a\n 5. \\<And>G a z'.\n       \\<lbrakk>G \\<turnstile> Neg a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> Neg a;\n        G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> FF\n 6. \\<And>a G z'.\n       \\<lbrakk>Neg a # G \\<turnstile> FF;\n        \\<And>z'.\n           set (Neg a # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> FF;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a\n 7. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        G \\<turnstile> b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> And a b\n 8. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a\n 9. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b\n 10. \\<And>G a b z'.\n        \\<lbrakk>G \\<turnstile> a;\n         \\<And>z'.\n            set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n         set G \\<subseteq> set z'\\<rbrakk>\n        \\<Longrightarrow> z' \\<turnstile> Or a b\nA total of 18 subgoals...", "then"], ["proof (chain)\npicking this:\n  p \\<in> set z\n  set z \\<subseteq> set z'", "show ?case"], ["proof (prove)\nusing this:\n  p \\<in> set z\n  set z \\<subseteq> set z'\n\ngoal (1 subgoal):\n 1. z' \\<turnstile> p", "using deriv.Assum"], ["proof (prove)\nusing this:\n  p \\<in> set z\n  set z \\<subseteq> set z'\n  ?a \\<in> set ?G \\<Longrightarrow> ?G \\<turnstile> ?a\n\ngoal (1 subgoal):\n 1. z' \\<turnstile> p", "by auto"], ["proof (state)\nthis:\n  z' \\<turnstile> p\n\ngoal (17 subgoals):\n 1. \\<And>G z'.\n       set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> TT\n 2. \\<And>G a z'.\n       \\<lbrakk>G \\<turnstile> FF;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> FF;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a\n 3. \\<And>a G z'.\n       \\<lbrakk>a # G \\<turnstile> FF;\n        \\<And>z'.\n           set (a # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> FF;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Neg a\n 4. \\<And>G a z'.\n       \\<lbrakk>G \\<turnstile> Neg a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> Neg a;\n        G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> FF\n 5. \\<And>a G z'.\n       \\<lbrakk>Neg a # G \\<turnstile> FF;\n        \\<And>z'.\n           set (Neg a # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> FF;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a\n 6. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        G \\<turnstile> b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> And a b\n 7. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a\n 8. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b\n 9. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Or a b\n 10. \\<And>G b a z'.\n        \\<lbrakk>G \\<turnstile> b;\n         \\<And>z'.\n            set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n         set G \\<subseteq> set z'\\<rbrakk>\n        \\<Longrightarrow> z' \\<turnstile> Or a b\nA total of 17 subgoals...", "next"], ["proof (state)\ngoal (17 subgoals):\n 1. \\<And>G z'.\n       set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> TT\n 2. \\<And>G a z'.\n       \\<lbrakk>G \\<turnstile> FF;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> FF;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a\n 3. \\<And>a G z'.\n       \\<lbrakk>a # G \\<turnstile> FF;\n        \\<And>z'.\n           set (a # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> FF;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Neg a\n 4. \\<And>G a z'.\n       \\<lbrakk>G \\<turnstile> Neg a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> Neg a;\n        G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> FF\n 5. \\<And>a G z'.\n       \\<lbrakk>Neg a # G \\<turnstile> FF;\n        \\<And>z'.\n           set (Neg a # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> FF;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a\n 6. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        G \\<turnstile> b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> And a b\n 7. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a\n 8. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b\n 9. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Or a b\n 10. \\<And>G b a z'.\n        \\<lbrakk>G \\<turnstile> b;\n         \\<And>z'.\n            set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n         set G \\<subseteq> set z'\\<rbrakk>\n        \\<Longrightarrow> z' \\<turnstile> Or a b\nA total of 17 subgoals...", "case TTI"], ["proof (state)\nthis:\n  set G_ \\<subseteq> set z'\n\ngoal (17 subgoals):\n 1. \\<And>G z'.\n       set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> TT\n 2. \\<And>G a z'.\n       \\<lbrakk>G \\<turnstile> FF;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> FF;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a\n 3. \\<And>a G z'.\n       \\<lbrakk>a # G \\<turnstile> FF;\n        \\<And>z'.\n           set (a # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> FF;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Neg a\n 4. \\<And>G a z'.\n       \\<lbrakk>G \\<turnstile> Neg a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> Neg a;\n        G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> FF\n 5. \\<And>a G z'.\n       \\<lbrakk>Neg a # G \\<turnstile> FF;\n        \\<And>z'.\n           set (Neg a # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> FF;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a\n 6. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        G \\<turnstile> b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> And a b\n 7. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a\n 8. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b\n 9. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Or a b\n 10. \\<And>G b a z'.\n        \\<lbrakk>G \\<turnstile> b;\n         \\<And>z'.\n            set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n         set G \\<subseteq> set z'\\<rbrakk>\n        \\<Longrightarrow> z' \\<turnstile> Or a b\nA total of 17 subgoals...", "then"], ["proof (chain)\npicking this:\n  set G_ \\<subseteq> set z'", "show ?case"], ["proof (prove)\nusing this:\n  set G_ \\<subseteq> set z'\n\ngoal (1 subgoal):\n 1. z' \\<turnstile> TT", "using deriv.TTI"], ["proof (prove)\nusing this:\n  set G_ \\<subseteq> set z'\n  ?G \\<turnstile> TT\n\ngoal (1 subgoal):\n 1. z' \\<turnstile> TT", "by auto"], ["proof (state)\nthis:\n  z' \\<turnstile> TT\n\ngoal (16 subgoals):\n 1. \\<And>G a z'.\n       \\<lbrakk>G \\<turnstile> FF;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> FF;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a\n 2. \\<And>a G z'.\n       \\<lbrakk>a # G \\<turnstile> FF;\n        \\<And>z'.\n           set (a # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> FF;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Neg a\n 3. \\<And>G a z'.\n       \\<lbrakk>G \\<turnstile> Neg a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> Neg a;\n        G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> FF\n 4. \\<And>a G z'.\n       \\<lbrakk>Neg a # G \\<turnstile> FF;\n        \\<And>z'.\n           set (Neg a # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> FF;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a\n 5. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        G \\<turnstile> b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> And a b\n 6. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a\n 7. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b\n 8. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Or a b\n 9. \\<And>G b a z'.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Or a b\n 10. \\<And>G a b c z'.\n        \\<lbrakk>G \\<turnstile> Or a b;\n         \\<And>z'.\n            set G \\<subseteq> set z' \\<Longrightarrow>\n            z' \\<turnstile> Or a b;\n         a # G \\<turnstile> c;\n         \\<And>z'.\n            set (a # G) \\<subseteq> set z' \\<Longrightarrow>\n            z' \\<turnstile> c;\n         b # G \\<turnstile> c;\n         \\<And>z'.\n            set (b # G) \\<subseteq> set z' \\<Longrightarrow>\n            z' \\<turnstile> c;\n         set G \\<subseteq> set z'\\<rbrakk>\n        \\<Longrightarrow> z' \\<turnstile> c\nA total of 16 subgoals...", "next"], ["proof (state)\ngoal (16 subgoals):\n 1. \\<And>G a z'.\n       \\<lbrakk>G \\<turnstile> FF;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> FF;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a\n 2. \\<And>a G z'.\n       \\<lbrakk>a # G \\<turnstile> FF;\n        \\<And>z'.\n           set (a # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> FF;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Neg a\n 3. \\<And>G a z'.\n       \\<lbrakk>G \\<turnstile> Neg a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> Neg a;\n        G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> FF\n 4. \\<And>a G z'.\n       \\<lbrakk>Neg a # G \\<turnstile> FF;\n        \\<And>z'.\n           set (Neg a # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> FF;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a\n 5. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        G \\<turnstile> b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> And a b\n 6. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a\n 7. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b\n 8. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Or a b\n 9. \\<And>G b a z'.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Or a b\n 10. \\<And>G a b c z'.\n        \\<lbrakk>G \\<turnstile> Or a b;\n         \\<And>z'.\n            set G \\<subseteq> set z' \\<Longrightarrow>\n            z' \\<turnstile> Or a b;\n         a # G \\<turnstile> c;\n         \\<And>z'.\n            set (a # G) \\<subseteq> set z' \\<Longrightarrow>\n            z' \\<turnstile> c;\n         b # G \\<turnstile> c;\n         \\<And>z'.\n            set (b # G) \\<subseteq> set z' \\<Longrightarrow>\n            z' \\<turnstile> c;\n         set G \\<subseteq> set z'\\<rbrakk>\n        \\<Longrightarrow> z' \\<turnstile> c\nA total of 16 subgoals...", "case FFE"], ["proof (state)\nthis:\n  G_ \\<turnstile> FF\n  set G_ \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> FF\n  set G_ \\<subseteq> set z'\n\ngoal (16 subgoals):\n 1. \\<And>G a z'.\n       \\<lbrakk>G \\<turnstile> FF;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> FF;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a\n 2. \\<And>a G z'.\n       \\<lbrakk>a # G \\<turnstile> FF;\n        \\<And>z'.\n           set (a # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> FF;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Neg a\n 3. \\<And>G a z'.\n       \\<lbrakk>G \\<turnstile> Neg a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> Neg a;\n        G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> FF\n 4. \\<And>a G z'.\n       \\<lbrakk>Neg a # G \\<turnstile> FF;\n        \\<And>z'.\n           set (Neg a # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> FF;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a\n 5. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        G \\<turnstile> b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> And a b\n 6. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a\n 7. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b\n 8. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Or a b\n 9. \\<And>G b a z'.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Or a b\n 10. \\<And>G a b c z'.\n        \\<lbrakk>G \\<turnstile> Or a b;\n         \\<And>z'.\n            set G \\<subseteq> set z' \\<Longrightarrow>\n            z' \\<turnstile> Or a b;\n         a # G \\<turnstile> c;\n         \\<And>z'.\n            set (a # G) \\<subseteq> set z' \\<Longrightarrow>\n            z' \\<turnstile> c;\n         b # G \\<turnstile> c;\n         \\<And>z'.\n            set (b # G) \\<subseteq> set z' \\<Longrightarrow>\n            z' \\<turnstile> c;\n         set G \\<subseteq> set z'\\<rbrakk>\n        \\<Longrightarrow> z' \\<turnstile> c\nA total of 16 subgoals...", "then"], ["proof (chain)\npicking this:\n  G_ \\<turnstile> FF\n  set G_ \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> FF\n  set G_ \\<subseteq> set z'", "show ?case"], ["proof (prove)\nusing this:\n  G_ \\<turnstile> FF\n  set G_ \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> FF\n  set G_ \\<subseteq> set z'\n\ngoal (1 subgoal):\n 1. z' \\<turnstile> a_", "using deriv.FFE"], ["proof (prove)\nusing this:\n  G_ \\<turnstile> FF\n  set G_ \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> FF\n  set G_ \\<subseteq> set z'\n  ?G \\<turnstile> FF \\<Longrightarrow> ?G \\<turnstile> ?a\n\ngoal (1 subgoal):\n 1. z' \\<turnstile> a_", "by auto"], ["proof (state)\nthis:\n  z' \\<turnstile> a_\n\ngoal (15 subgoals):\n 1. \\<And>a G z'.\n       \\<lbrakk>a # G \\<turnstile> FF;\n        \\<And>z'.\n           set (a # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> FF;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Neg a\n 2. \\<And>G a z'.\n       \\<lbrakk>G \\<turnstile> Neg a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> Neg a;\n        G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> FF\n 3. \\<And>a G z'.\n       \\<lbrakk>Neg a # G \\<turnstile> FF;\n        \\<And>z'.\n           set (Neg a # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> FF;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a\n 4. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        G \\<turnstile> b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> And a b\n 5. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a\n 6. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b\n 7. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Or a b\n 8. \\<And>G b a z'.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Or a b\n 9. \\<And>G a b c z'.\n       \\<lbrakk>G \\<turnstile> Or a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Or a b;\n        a # G \\<turnstile> c;\n        \\<And>z'.\n           set (a # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> c;\n        b # G \\<turnstile> c;\n        \\<And>z'.\n           set (b # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> c;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> c\n 10. \\<And>a G b z'.\n        \\<lbrakk>a # G \\<turnstile> b;\n         \\<And>z'.\n            set (a # G) \\<subseteq> set z' \\<Longrightarrow>\n            z' \\<turnstile> b;\n         set G \\<subseteq> set z'\\<rbrakk>\n        \\<Longrightarrow> z' \\<turnstile> Impl a b\nA total of 15 subgoals...", "next"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>a G z'.\n       \\<lbrakk>a # G \\<turnstile> FF;\n        \\<And>z'.\n           set (a # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> FF;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Neg a\n 2. \\<And>G a z'.\n       \\<lbrakk>G \\<turnstile> Neg a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> Neg a;\n        G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> FF\n 3. \\<And>a G z'.\n       \\<lbrakk>Neg a # G \\<turnstile> FF;\n        \\<And>z'.\n           set (Neg a # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> FF;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a\n 4. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        G \\<turnstile> b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> And a b\n 5. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a\n 6. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b\n 7. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Or a b\n 8. \\<And>G b a z'.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Or a b\n 9. \\<And>G a b c z'.\n       \\<lbrakk>G \\<turnstile> Or a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Or a b;\n        a # G \\<turnstile> c;\n        \\<And>z'.\n           set (a # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> c;\n        b # G \\<turnstile> c;\n        \\<And>z'.\n           set (b # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> c;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> c\n 10. \\<And>a G b z'.\n        \\<lbrakk>a # G \\<turnstile> b;\n         \\<And>z'.\n            set (a # G) \\<subseteq> set z' \\<Longrightarrow>\n            z' \\<turnstile> b;\n         set G \\<subseteq> set z'\\<rbrakk>\n        \\<Longrightarrow> z' \\<turnstile> Impl a b\nA total of 15 subgoals...", "case (NegI p z)"], ["proof (state)\nthis:\n  p # z \\<turnstile> FF\n  set (p # z) \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> FF\n  set z \\<subseteq> set z'\n\ngoal (15 subgoals):\n 1. \\<And>a G z'.\n       \\<lbrakk>a # G \\<turnstile> FF;\n        \\<And>z'.\n           set (a # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> FF;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Neg a\n 2. \\<And>G a z'.\n       \\<lbrakk>G \\<turnstile> Neg a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> Neg a;\n        G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> FF\n 3. \\<And>a G z'.\n       \\<lbrakk>Neg a # G \\<turnstile> FF;\n        \\<And>z'.\n           set (Neg a # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> FF;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a\n 4. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        G \\<turnstile> b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> And a b\n 5. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a\n 6. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b\n 7. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Or a b\n 8. \\<And>G b a z'.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Or a b\n 9. \\<And>G a b c z'.\n       \\<lbrakk>G \\<turnstile> Or a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Or a b;\n        a # G \\<turnstile> c;\n        \\<And>z'.\n           set (a # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> c;\n        b # G \\<turnstile> c;\n        \\<And>z'.\n           set (b # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> c;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> c\n 10. \\<And>a G b z'.\n        \\<lbrakk>a # G \\<turnstile> b;\n         \\<And>z'.\n            set (a # G) \\<subseteq> set z' \\<Longrightarrow>\n            z' \\<turnstile> b;\n         set G \\<subseteq> set z'\\<rbrakk>\n        \\<Longrightarrow> z' \\<turnstile> Impl a b\nA total of 15 subgoals...", "then"], ["proof (chain)\npicking this:\n  p # z \\<turnstile> FF\n  set (p # z) \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> FF\n  set z \\<subseteq> set z'", "show ?case"], ["proof (prove)\nusing this:\n  p # z \\<turnstile> FF\n  set (p # z) \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> FF\n  set z \\<subseteq> set z'\n\ngoal (1 subgoal):\n 1. z' \\<turnstile> Neg p", "using deriv.NegI subset_cons"], ["proof (prove)\nusing this:\n  p # z \\<turnstile> FF\n  set (p # z) \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> FF\n  set z \\<subseteq> set z'\n  ?a # ?G \\<turnstile> FF \\<Longrightarrow> ?G \\<turnstile> Neg ?a\n  set ?z \\<subseteq> set ?z' \\<Longrightarrow>\n  set (?p # ?z) \\<subseteq> set (?p # ?z')\n\ngoal (1 subgoal):\n 1. z' \\<turnstile> Neg p", "by metis"], ["proof (state)\nthis:\n  z' \\<turnstile> Neg p\n\ngoal (14 subgoals):\n 1. \\<And>G a z'.\n       \\<lbrakk>G \\<turnstile> Neg a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> Neg a;\n        G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> FF\n 2. \\<And>a G z'.\n       \\<lbrakk>Neg a # G \\<turnstile> FF;\n        \\<And>z'.\n           set (Neg a # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> FF;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a\n 3. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        G \\<turnstile> b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> And a b\n 4. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a\n 5. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b\n 6. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Or a b\n 7. \\<And>G b a z'.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Or a b\n 8. \\<And>G a b c z'.\n       \\<lbrakk>G \\<turnstile> Or a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Or a b;\n        a # G \\<turnstile> c;\n        \\<And>z'.\n           set (a # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> c;\n        b # G \\<turnstile> c;\n        \\<And>z'.\n           set (b # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> c;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> c\n 9. \\<And>a G b z'.\n       \\<lbrakk>a # G \\<turnstile> b;\n        \\<And>z'.\n           set (a # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Impl a b\n 10. \\<And>G a b z'.\n        \\<lbrakk>G \\<turnstile> Impl a b;\n         \\<And>z'.\n            set G \\<subseteq> set z' \\<Longrightarrow>\n            z' \\<turnstile> Impl a b;\n         G \\<turnstile> a;\n         \\<And>z'.\n            set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n         set G \\<subseteq> set z'\\<rbrakk>\n        \\<Longrightarrow> z' \\<turnstile> b\nA total of 14 subgoals...", "next"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>G a z'.\n       \\<lbrakk>G \\<turnstile> Neg a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> Neg a;\n        G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> FF\n 2. \\<And>a G z'.\n       \\<lbrakk>Neg a # G \\<turnstile> FF;\n        \\<And>z'.\n           set (Neg a # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> FF;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a\n 3. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        G \\<turnstile> b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> And a b\n 4. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a\n 5. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b\n 6. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Or a b\n 7. \\<And>G b a z'.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Or a b\n 8. \\<And>G a b c z'.\n       \\<lbrakk>G \\<turnstile> Or a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Or a b;\n        a # G \\<turnstile> c;\n        \\<And>z'.\n           set (a # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> c;\n        b # G \\<turnstile> c;\n        \\<And>z'.\n           set (b # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> c;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> c\n 9. \\<And>a G b z'.\n       \\<lbrakk>a # G \\<turnstile> b;\n        \\<And>z'.\n           set (a # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Impl a b\n 10. \\<And>G a b z'.\n        \\<lbrakk>G \\<turnstile> Impl a b;\n         \\<And>z'.\n            set G \\<subseteq> set z' \\<Longrightarrow>\n            z' \\<turnstile> Impl a b;\n         G \\<turnstile> a;\n         \\<And>z'.\n            set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n         set G \\<subseteq> set z'\\<rbrakk>\n        \\<Longrightarrow> z' \\<turnstile> b\nA total of 14 subgoals...", "case (NegE p z)"], ["proof (state)\nthis:\n  p \\<turnstile> Neg z\n  set p \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> Neg z\n  p \\<turnstile> z\n  set p \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> z\n  set p \\<subseteq> set z'\n\ngoal (14 subgoals):\n 1. \\<And>G a z'.\n       \\<lbrakk>G \\<turnstile> Neg a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> Neg a;\n        G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> FF\n 2. \\<And>a G z'.\n       \\<lbrakk>Neg a # G \\<turnstile> FF;\n        \\<And>z'.\n           set (Neg a # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> FF;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a\n 3. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        G \\<turnstile> b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> And a b\n 4. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a\n 5. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b\n 6. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Or a b\n 7. \\<And>G b a z'.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Or a b\n 8. \\<And>G a b c z'.\n       \\<lbrakk>G \\<turnstile> Or a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Or a b;\n        a # G \\<turnstile> c;\n        \\<And>z'.\n           set (a # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> c;\n        b # G \\<turnstile> c;\n        \\<And>z'.\n           set (b # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> c;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> c\n 9. \\<And>a G b z'.\n       \\<lbrakk>a # G \\<turnstile> b;\n        \\<And>z'.\n           set (a # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Impl a b\n 10. \\<And>G a b z'.\n        \\<lbrakk>G \\<turnstile> Impl a b;\n         \\<And>z'.\n            set G \\<subseteq> set z' \\<Longrightarrow>\n            z' \\<turnstile> Impl a b;\n         G \\<turnstile> a;\n         \\<And>z'.\n            set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n         set G \\<subseteq> set z'\\<rbrakk>\n        \\<Longrightarrow> z' \\<turnstile> b\nA total of 14 subgoals...", "then"], ["proof (chain)\npicking this:\n  p \\<turnstile> Neg z\n  set p \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> Neg z\n  p \\<turnstile> z\n  set p \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> z\n  set p \\<subseteq> set z'", "show ?case"], ["proof (prove)\nusing this:\n  p \\<turnstile> Neg z\n  set p \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> Neg z\n  p \\<turnstile> z\n  set p \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> z\n  set p \\<subseteq> set z'\n\ngoal (1 subgoal):\n 1. z' \\<turnstile> FF", "using deriv.NegE"], ["proof (prove)\nusing this:\n  p \\<turnstile> Neg z\n  set p \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> Neg z\n  p \\<turnstile> z\n  set p \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> z\n  set p \\<subseteq> set z'\n  \\<lbrakk>?G \\<turnstile> Neg ?a; ?G \\<turnstile> ?a\\<rbrakk>\n  \\<Longrightarrow> ?G \\<turnstile> FF\n\ngoal (1 subgoal):\n 1. z' \\<turnstile> FF", "by metis"], ["proof (state)\nthis:\n  z' \\<turnstile> FF\n\ngoal (13 subgoals):\n 1. \\<And>a G z'.\n       \\<lbrakk>Neg a # G \\<turnstile> FF;\n        \\<And>z'.\n           set (Neg a # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> FF;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a\n 2. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        G \\<turnstile> b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> And a b\n 3. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a\n 4. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b\n 5. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Or a b\n 6. \\<And>G b a z'.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Or a b\n 7. \\<And>G a b c z'.\n       \\<lbrakk>G \\<turnstile> Or a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Or a b;\n        a # G \\<turnstile> c;\n        \\<And>z'.\n           set (a # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> c;\n        b # G \\<turnstile> c;\n        \\<And>z'.\n           set (b # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> c;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> c\n 8. \\<And>a G b z'.\n       \\<lbrakk>a # G \\<turnstile> b;\n        \\<And>z'.\n           set (a # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Impl a b\n 9. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> Impl a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Impl a b;\n        G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b\n 10. \\<And>G a n z'.\n        \\<lbrakk>G \\<turnstile> a[App n []/0];\n         \\<And>z'.\n            set G \\<subseteq> set z' \\<Longrightarrow>\n            z' \\<turnstile> a[App n []/0];\n         news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n        \\<Longrightarrow> z' \\<turnstile> Forall a\nA total of 13 subgoals...", "next"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>a G z'.\n       \\<lbrakk>Neg a # G \\<turnstile> FF;\n        \\<And>z'.\n           set (Neg a # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> FF;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a\n 2. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        G \\<turnstile> b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> And a b\n 3. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a\n 4. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b\n 5. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Or a b\n 6. \\<And>G b a z'.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Or a b\n 7. \\<And>G a b c z'.\n       \\<lbrakk>G \\<turnstile> Or a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Or a b;\n        a # G \\<turnstile> c;\n        \\<And>z'.\n           set (a # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> c;\n        b # G \\<turnstile> c;\n        \\<And>z'.\n           set (b # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> c;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> c\n 8. \\<And>a G b z'.\n       \\<lbrakk>a # G \\<turnstile> b;\n        \\<And>z'.\n           set (a # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Impl a b\n 9. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> Impl a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Impl a b;\n        G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b\n 10. \\<And>G a n z'.\n        \\<lbrakk>G \\<turnstile> a[App n []/0];\n         \\<And>z'.\n            set G \\<subseteq> set z' \\<Longrightarrow>\n            z' \\<turnstile> a[App n []/0];\n         news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n        \\<Longrightarrow> z' \\<turnstile> Forall a\nA total of 13 subgoals...", "case (Class z p)"], ["proof (state)\nthis:\n  Neg z # p \\<turnstile> FF\n  set (Neg z # p) \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> FF\n  set p \\<subseteq> set z'\n\ngoal (13 subgoals):\n 1. \\<And>a G z'.\n       \\<lbrakk>Neg a # G \\<turnstile> FF;\n        \\<And>z'.\n           set (Neg a # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> FF;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a\n 2. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        G \\<turnstile> b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> And a b\n 3. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a\n 4. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b\n 5. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Or a b\n 6. \\<And>G b a z'.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Or a b\n 7. \\<And>G a b c z'.\n       \\<lbrakk>G \\<turnstile> Or a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Or a b;\n        a # G \\<turnstile> c;\n        \\<And>z'.\n           set (a # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> c;\n        b # G \\<turnstile> c;\n        \\<And>z'.\n           set (b # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> c;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> c\n 8. \\<And>a G b z'.\n       \\<lbrakk>a # G \\<turnstile> b;\n        \\<And>z'.\n           set (a # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Impl a b\n 9. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> Impl a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Impl a b;\n        G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b\n 10. \\<And>G a n z'.\n        \\<lbrakk>G \\<turnstile> a[App n []/0];\n         \\<And>z'.\n            set G \\<subseteq> set z' \\<Longrightarrow>\n            z' \\<turnstile> a[App n []/0];\n         news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n        \\<Longrightarrow> z' \\<turnstile> Forall a\nA total of 13 subgoals...", "then"], ["proof (chain)\npicking this:\n  Neg z # p \\<turnstile> FF\n  set (Neg z # p) \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> FF\n  set p \\<subseteq> set z'", "show ?case"], ["proof (prove)\nusing this:\n  Neg z # p \\<turnstile> FF\n  set (Neg z # p) \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> FF\n  set p \\<subseteq> set z'\n\ngoal (1 subgoal):\n 1. z' \\<turnstile> z", "using deriv.Class subset_cons"], ["proof (prove)\nusing this:\n  Neg z # p \\<turnstile> FF\n  set (Neg z # p) \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> FF\n  set p \\<subseteq> set z'\n  Neg ?a # ?G \\<turnstile> FF \\<Longrightarrow> ?G \\<turnstile> ?a\n  set ?z \\<subseteq> set ?z' \\<Longrightarrow>\n  set (?p # ?z) \\<subseteq> set (?p # ?z')\n\ngoal (1 subgoal):\n 1. z' \\<turnstile> z", "by metis"], ["proof (state)\nthis:\n  z' \\<turnstile> z\n\ngoal (12 subgoals):\n 1. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        G \\<turnstile> b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> And a b\n 2. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a\n 3. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b\n 4. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Or a b\n 5. \\<And>G b a z'.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Or a b\n 6. \\<And>G a b c z'.\n       \\<lbrakk>G \\<turnstile> Or a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Or a b;\n        a # G \\<turnstile> c;\n        \\<And>z'.\n           set (a # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> c;\n        b # G \\<turnstile> c;\n        \\<And>z'.\n           set (b # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> c;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> c\n 7. \\<And>a G b z'.\n       \\<lbrakk>a # G \\<turnstile> b;\n        \\<And>z'.\n           set (a # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Impl a b\n 8. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> Impl a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Impl a b;\n        G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b\n 9. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a\n 10. \\<And>G a t z'.\n        \\<lbrakk>G \\<turnstile> Forall a;\n         \\<And>z'.\n            set G \\<subseteq> set z' \\<Longrightarrow>\n            z' \\<turnstile> Forall a;\n         set G \\<subseteq> set z'\\<rbrakk>\n        \\<Longrightarrow> z' \\<turnstile> a[t/0]\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        G \\<turnstile> b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> And a b\n 2. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a\n 3. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b\n 4. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Or a b\n 5. \\<And>G b a z'.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Or a b\n 6. \\<And>G a b c z'.\n       \\<lbrakk>G \\<turnstile> Or a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Or a b;\n        a # G \\<turnstile> c;\n        \\<And>z'.\n           set (a # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> c;\n        b # G \\<turnstile> c;\n        \\<And>z'.\n           set (b # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> c;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> c\n 7. \\<And>a G b z'.\n       \\<lbrakk>a # G \\<turnstile> b;\n        \\<And>z'.\n           set (a # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Impl a b\n 8. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> Impl a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Impl a b;\n        G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b\n 9. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a\n 10. \\<And>G a t z'.\n        \\<lbrakk>G \\<turnstile> Forall a;\n         \\<And>z'.\n            set G \\<subseteq> set z' \\<Longrightarrow>\n            z' \\<turnstile> Forall a;\n         set G \\<subseteq> set z'\\<rbrakk>\n        \\<Longrightarrow> z' \\<turnstile> a[t/0]\nA total of 12 subgoals...", "case (ImplE z p q)"], ["proof (state)\nthis:\n  z \\<turnstile> Impl p q\n  set z \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> Impl p q\n  z \\<turnstile> p\n  set z \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> p\n  set z \\<subseteq> set z'\n\ngoal (12 subgoals):\n 1. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        G \\<turnstile> b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> And a b\n 2. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a\n 3. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b\n 4. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Or a b\n 5. \\<And>G b a z'.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Or a b\n 6. \\<And>G a b c z'.\n       \\<lbrakk>G \\<turnstile> Or a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Or a b;\n        a # G \\<turnstile> c;\n        \\<And>z'.\n           set (a # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> c;\n        b # G \\<turnstile> c;\n        \\<And>z'.\n           set (b # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> c;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> c\n 7. \\<And>a G b z'.\n       \\<lbrakk>a # G \\<turnstile> b;\n        \\<And>z'.\n           set (a # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Impl a b\n 8. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> Impl a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Impl a b;\n        G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b\n 9. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a\n 10. \\<And>G a t z'.\n        \\<lbrakk>G \\<turnstile> Forall a;\n         \\<And>z'.\n            set G \\<subseteq> set z' \\<Longrightarrow>\n            z' \\<turnstile> Forall a;\n         set G \\<subseteq> set z'\\<rbrakk>\n        \\<Longrightarrow> z' \\<turnstile> a[t/0]\nA total of 12 subgoals...", "then"], ["proof (chain)\npicking this:\n  z \\<turnstile> Impl p q\n  set z \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> Impl p q\n  z \\<turnstile> p\n  set z \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> p\n  set z \\<subseteq> set z'", "show ?case"], ["proof (prove)\nusing this:\n  z \\<turnstile> Impl p q\n  set z \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> Impl p q\n  z \\<turnstile> p\n  set z \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> p\n  set z \\<subseteq> set z'\n\ngoal (1 subgoal):\n 1. z' \\<turnstile> q", "using deriv.ImplE"], ["proof (prove)\nusing this:\n  z \\<turnstile> Impl p q\n  set z \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> Impl p q\n  z \\<turnstile> p\n  set z \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> p\n  set z \\<subseteq> set z'\n  \\<lbrakk>?G \\<turnstile> Impl ?a ?b; ?G \\<turnstile> ?a\\<rbrakk>\n  \\<Longrightarrow> ?G \\<turnstile> ?b\n\ngoal (1 subgoal):\n 1. z' \\<turnstile> q", "by blast"], ["proof (state)\nthis:\n  z' \\<turnstile> q\n\ngoal (11 subgoals):\n 1. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        G \\<turnstile> b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> And a b\n 2. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a\n 3. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b\n 4. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Or a b\n 5. \\<And>G b a z'.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Or a b\n 6. \\<And>G a b c z'.\n       \\<lbrakk>G \\<turnstile> Or a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Or a b;\n        a # G \\<turnstile> c;\n        \\<And>z'.\n           set (a # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> c;\n        b # G \\<turnstile> c;\n        \\<And>z'.\n           set (b # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> c;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> c\n 7. \\<And>a G b z'.\n       \\<lbrakk>a # G \\<turnstile> b;\n        \\<And>z'.\n           set (a # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Impl a b\n 8. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a\n 9. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Forall a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a[t/0]\n 10. \\<And>G a t z'.\n        \\<lbrakk>G \\<turnstile> a[t/0];\n         \\<And>z'.\n            set G \\<subseteq> set z' \\<Longrightarrow>\n            z' \\<turnstile> a[t/0];\n         set G \\<subseteq> set z'\\<rbrakk>\n        \\<Longrightarrow> z' \\<turnstile> Exists a\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        G \\<turnstile> b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> And a b\n 2. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a\n 3. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b\n 4. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Or a b\n 5. \\<And>G b a z'.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Or a b\n 6. \\<And>G a b c z'.\n       \\<lbrakk>G \\<turnstile> Or a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Or a b;\n        a # G \\<turnstile> c;\n        \\<And>z'.\n           set (a # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> c;\n        b # G \\<turnstile> c;\n        \\<And>z'.\n           set (b # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> c;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> c\n 7. \\<And>a G b z'.\n       \\<lbrakk>a # G \\<turnstile> b;\n        \\<And>z'.\n           set (a # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Impl a b\n 8. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a\n 9. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Forall a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a[t/0]\n 10. \\<And>G a t z'.\n        \\<lbrakk>G \\<turnstile> a[t/0];\n         \\<And>z'.\n            set G \\<subseteq> set z' \\<Longrightarrow>\n            z' \\<turnstile> a[t/0];\n         set G \\<subseteq> set z'\\<rbrakk>\n        \\<Longrightarrow> z' \\<turnstile> Exists a\nA total of 11 subgoals...", "case (ImplI z q p)"], ["proof (state)\nthis:\n  z # q \\<turnstile> p\n  set (z # q) \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> p\n  set q \\<subseteq> set z'\n\ngoal (11 subgoals):\n 1. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        G \\<turnstile> b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> And a b\n 2. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a\n 3. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b\n 4. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Or a b\n 5. \\<And>G b a z'.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Or a b\n 6. \\<And>G a b c z'.\n       \\<lbrakk>G \\<turnstile> Or a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Or a b;\n        a # G \\<turnstile> c;\n        \\<And>z'.\n           set (a # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> c;\n        b # G \\<turnstile> c;\n        \\<And>z'.\n           set (b # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> c;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> c\n 7. \\<And>a G b z'.\n       \\<lbrakk>a # G \\<turnstile> b;\n        \\<And>z'.\n           set (a # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Impl a b\n 8. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a\n 9. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Forall a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a[t/0]\n 10. \\<And>G a t z'.\n        \\<lbrakk>G \\<turnstile> a[t/0];\n         \\<And>z'.\n            set G \\<subseteq> set z' \\<Longrightarrow>\n            z' \\<turnstile> a[t/0];\n         set G \\<subseteq> set z'\\<rbrakk>\n        \\<Longrightarrow> z' \\<turnstile> Exists a\nA total of 11 subgoals...", "then"], ["proof (chain)\npicking this:\n  z # q \\<turnstile> p\n  set (z # q) \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> p\n  set q \\<subseteq> set z'", "show ?case"], ["proof (prove)\nusing this:\n  z # q \\<turnstile> p\n  set (z # q) \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> p\n  set q \\<subseteq> set z'\n\ngoal (1 subgoal):\n 1. z' \\<turnstile> Impl z p", "using deriv.ImplI subset_cons"], ["proof (prove)\nusing this:\n  z # q \\<turnstile> p\n  set (z # q) \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> p\n  set q \\<subseteq> set z'\n  ?a # ?G \\<turnstile> ?b \\<Longrightarrow> ?G \\<turnstile> Impl ?a ?b\n  set ?z \\<subseteq> set ?z' \\<Longrightarrow>\n  set (?p # ?z) \\<subseteq> set (?p # ?z')\n\ngoal (1 subgoal):\n 1. z' \\<turnstile> Impl z p", "by metis"], ["proof (state)\nthis:\n  z' \\<turnstile> Impl z p\n\ngoal (10 subgoals):\n 1. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        G \\<turnstile> b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> And a b\n 2. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a\n 3. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b\n 4. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Or a b\n 5. \\<And>G b a z'.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Or a b\n 6. \\<And>G a b c z'.\n       \\<lbrakk>G \\<turnstile> Or a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Or a b;\n        a # G \\<turnstile> c;\n        \\<And>z'.\n           set (a # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> c;\n        b # G \\<turnstile> c;\n        \\<And>z'.\n           set (b # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> c;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> c\n 7. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a\n 8. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Forall a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a[t/0]\n 9. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[t/0];\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Exists a\n 10. \\<And>G a n b z'.\n        \\<lbrakk>G \\<turnstile> Exists a;\n         \\<And>z'.\n            set G \\<subseteq> set z' \\<Longrightarrow>\n            z' \\<turnstile> Exists a;\n         a[App n []/0] # G \\<turnstile> b;\n         \\<And>z'.\n            set (a[App n []/0] # G) \\<subseteq> set z' \\<Longrightarrow>\n            z' \\<turnstile> b;\n         news n G; new n a; new n b; set G \\<subseteq> set z'\\<rbrakk>\n        \\<Longrightarrow> z' \\<turnstile> b", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        G \\<turnstile> b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> And a b\n 2. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a\n 3. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b\n 4. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Or a b\n 5. \\<And>G b a z'.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Or a b\n 6. \\<And>G a b c z'.\n       \\<lbrakk>G \\<turnstile> Or a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Or a b;\n        a # G \\<turnstile> c;\n        \\<And>z'.\n           set (a # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> c;\n        b # G \\<turnstile> c;\n        \\<And>z'.\n           set (b # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> c;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> c\n 7. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a\n 8. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Forall a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a[t/0]\n 9. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[t/0];\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Exists a\n 10. \\<And>G a n b z'.\n        \\<lbrakk>G \\<turnstile> Exists a;\n         \\<And>z'.\n            set G \\<subseteq> set z' \\<Longrightarrow>\n            z' \\<turnstile> Exists a;\n         a[App n []/0] # G \\<turnstile> b;\n         \\<And>z'.\n            set (a[App n []/0] # G) \\<subseteq> set z' \\<Longrightarrow>\n            z' \\<turnstile> b;\n         news n G; new n a; new n b; set G \\<subseteq> set z'\\<rbrakk>\n        \\<Longrightarrow> z' \\<turnstile> b", "case (OrE z p q z )"], ["proof (state)\nthis:\n  za__ \\<turnstile> Or p q\n  set za__ \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> Or p q\n  p # za__ \\<turnstile> z\n  set (p # za__) \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> z\n  q # za__ \\<turnstile> z\n  set (q # za__) \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> z\n  set za__ \\<subseteq> set z'\n\ngoal (10 subgoals):\n 1. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        G \\<turnstile> b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> And a b\n 2. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a\n 3. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b\n 4. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Or a b\n 5. \\<And>G b a z'.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Or a b\n 6. \\<And>G a b c z'.\n       \\<lbrakk>G \\<turnstile> Or a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Or a b;\n        a # G \\<turnstile> c;\n        \\<And>z'.\n           set (a # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> c;\n        b # G \\<turnstile> c;\n        \\<And>z'.\n           set (b # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> c;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> c\n 7. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a\n 8. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Forall a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a[t/0]\n 9. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[t/0];\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Exists a\n 10. \\<And>G a n b z'.\n        \\<lbrakk>G \\<turnstile> Exists a;\n         \\<And>z'.\n            set G \\<subseteq> set z' \\<Longrightarrow>\n            z' \\<turnstile> Exists a;\n         a[App n []/0] # G \\<turnstile> b;\n         \\<And>z'.\n            set (a[App n []/0] # G) \\<subseteq> set z' \\<Longrightarrow>\n            z' \\<turnstile> b;\n         news n G; new n a; new n b; set G \\<subseteq> set z'\\<rbrakk>\n        \\<Longrightarrow> z' \\<turnstile> b", "then"], ["proof (chain)\npicking this:\n  za__ \\<turnstile> Or p q\n  set za__ \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> Or p q\n  p # za__ \\<turnstile> z\n  set (p # za__) \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> z\n  q # za__ \\<turnstile> z\n  set (q # za__) \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> z\n  set za__ \\<subseteq> set z'", "show ?case"], ["proof (prove)\nusing this:\n  za__ \\<turnstile> Or p q\n  set za__ \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> Or p q\n  p # za__ \\<turnstile> z\n  set (p # za__) \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> z\n  q # za__ \\<turnstile> z\n  set (q # za__) \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> z\n  set za__ \\<subseteq> set z'\n\ngoal (1 subgoal):\n 1. z' \\<turnstile> z", "using deriv.OrE subset_cons"], ["proof (prove)\nusing this:\n  za__ \\<turnstile> Or p q\n  set za__ \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> Or p q\n  p # za__ \\<turnstile> z\n  set (p # za__) \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> z\n  q # za__ \\<turnstile> z\n  set (q # za__) \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> z\n  set za__ \\<subseteq> set z'\n  \\<lbrakk>?G \\<turnstile> Or ?a ?b; ?a # ?G \\<turnstile> ?c;\n   ?b # ?G \\<turnstile> ?c\\<rbrakk>\n  \\<Longrightarrow> ?G \\<turnstile> ?c\n  set ?z \\<subseteq> set ?z' \\<Longrightarrow>\n  set (?p # ?z) \\<subseteq> set (?p # ?z')\n\ngoal (1 subgoal):\n 1. z' \\<turnstile> z", "by metis"], ["proof (state)\nthis:\n  z' \\<turnstile> z\n\ngoal (9 subgoals):\n 1. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        G \\<turnstile> b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> And a b\n 2. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a\n 3. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b\n 4. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Or a b\n 5. \\<And>G b a z'.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Or a b\n 6. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a\n 7. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Forall a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a[t/0]\n 8. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[t/0];\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Exists a\n 9. \\<And>G a n b z'.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Exists a;\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>z'.\n           set (a[App n []/0] # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> b;\n        news n G; new n a; new n b; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        G \\<turnstile> b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> And a b\n 2. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a\n 3. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b\n 4. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Or a b\n 5. \\<And>G b a z'.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Or a b\n 6. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a\n 7. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Forall a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a[t/0]\n 8. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[t/0];\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Exists a\n 9. \\<And>G a n b z'.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Exists a;\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>z'.\n           set (a[App n []/0] # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> b;\n        news n G; new n a; new n b; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b", "case (OrI1 z p q)"], ["proof (state)\nthis:\n  z \\<turnstile> p\n  set z \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> p\n  set z \\<subseteq> set z'\n\ngoal (9 subgoals):\n 1. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        G \\<turnstile> b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> And a b\n 2. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a\n 3. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b\n 4. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Or a b\n 5. \\<And>G b a z'.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Or a b\n 6. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a\n 7. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Forall a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a[t/0]\n 8. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[t/0];\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Exists a\n 9. \\<And>G a n b z'.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Exists a;\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>z'.\n           set (a[App n []/0] # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> b;\n        news n G; new n a; new n b; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b", "then"], ["proof (chain)\npicking this:\n  z \\<turnstile> p\n  set z \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> p\n  set z \\<subseteq> set z'", "show ?case"], ["proof (prove)\nusing this:\n  z \\<turnstile> p\n  set z \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> p\n  set z \\<subseteq> set z'\n\ngoal (1 subgoal):\n 1. z' \\<turnstile> Or p q", "using deriv.OrI1"], ["proof (prove)\nusing this:\n  z \\<turnstile> p\n  set z \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> p\n  set z \\<subseteq> set z'\n  ?G \\<turnstile> ?a \\<Longrightarrow> ?G \\<turnstile> Or ?a ?b\n\ngoal (1 subgoal):\n 1. z' \\<turnstile> Or p q", "by blast"], ["proof (state)\nthis:\n  z' \\<turnstile> Or p q\n\ngoal (8 subgoals):\n 1. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        G \\<turnstile> b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> And a b\n 2. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a\n 3. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b\n 4. \\<And>G b a z'.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Or a b\n 5. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a\n 6. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Forall a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a[t/0]\n 7. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[t/0];\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Exists a\n 8. \\<And>G a n b z'.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Exists a;\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>z'.\n           set (a[App n []/0] # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> b;\n        news n G; new n a; new n b; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        G \\<turnstile> b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> And a b\n 2. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a\n 3. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b\n 4. \\<And>G b a z'.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Or a b\n 5. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a\n 6. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Forall a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a[t/0]\n 7. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[t/0];\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Exists a\n 8. \\<And>G a n b z'.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Exists a;\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>z'.\n           set (a[App n []/0] # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> b;\n        news n G; new n a; new n b; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b", "case (OrI2 z q p)"], ["proof (state)\nthis:\n  z \\<turnstile> q\n  set z \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> q\n  set z \\<subseteq> set z'\n\ngoal (8 subgoals):\n 1. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        G \\<turnstile> b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> And a b\n 2. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a\n 3. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b\n 4. \\<And>G b a z'.\n       \\<lbrakk>G \\<turnstile> b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Or a b\n 5. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a\n 6. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Forall a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a[t/0]\n 7. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[t/0];\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Exists a\n 8. \\<And>G a n b z'.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Exists a;\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>z'.\n           set (a[App n []/0] # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> b;\n        news n G; new n a; new n b; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b", "then"], ["proof (chain)\npicking this:\n  z \\<turnstile> q\n  set z \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> q\n  set z \\<subseteq> set z'", "show ?case"], ["proof (prove)\nusing this:\n  z \\<turnstile> q\n  set z \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> q\n  set z \\<subseteq> set z'\n\ngoal (1 subgoal):\n 1. z' \\<turnstile> Or p q", "using deriv.OrI2"], ["proof (prove)\nusing this:\n  z \\<turnstile> q\n  set z \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> q\n  set z \\<subseteq> set z'\n  ?G \\<turnstile> ?b \\<Longrightarrow> ?G \\<turnstile> Or ?a ?b\n\ngoal (1 subgoal):\n 1. z' \\<turnstile> Or p q", "by blast"], ["proof (state)\nthis:\n  z' \\<turnstile> Or p q\n\ngoal (7 subgoals):\n 1. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        G \\<turnstile> b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> And a b\n 2. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a\n 3. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b\n 4. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a\n 5. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Forall a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a[t/0]\n 6. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[t/0];\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Exists a\n 7. \\<And>G a n b z'.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Exists a;\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>z'.\n           set (a[App n []/0] # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> b;\n        news n G; new n a; new n b; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        G \\<turnstile> b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> And a b\n 2. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a\n 3. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b\n 4. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a\n 5. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Forall a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a[t/0]\n 6. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[t/0];\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Exists a\n 7. \\<And>G a n b z'.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Exists a;\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>z'.\n           set (a[App n []/0] # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> b;\n        news n G; new n a; new n b; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b", "case (AndE1 z p q)"], ["proof (state)\nthis:\n  z \\<turnstile> And p q\n  set z \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> And p q\n  set z \\<subseteq> set z'\n\ngoal (7 subgoals):\n 1. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        G \\<turnstile> b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> And a b\n 2. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a\n 3. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b\n 4. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a\n 5. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Forall a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a[t/0]\n 6. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[t/0];\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Exists a\n 7. \\<And>G a n b z'.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Exists a;\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>z'.\n           set (a[App n []/0] # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> b;\n        news n G; new n a; new n b; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b", "then"], ["proof (chain)\npicking this:\n  z \\<turnstile> And p q\n  set z \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> And p q\n  set z \\<subseteq> set z'", "show ?case"], ["proof (prove)\nusing this:\n  z \\<turnstile> And p q\n  set z \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> And p q\n  set z \\<subseteq> set z'\n\ngoal (1 subgoal):\n 1. z' \\<turnstile> p", "using deriv.AndE1"], ["proof (prove)\nusing this:\n  z \\<turnstile> And p q\n  set z \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> And p q\n  set z \\<subseteq> set z'\n  ?G \\<turnstile> And ?a ?b \\<Longrightarrow> ?G \\<turnstile> ?a\n\ngoal (1 subgoal):\n 1. z' \\<turnstile> p", "by blast"], ["proof (state)\nthis:\n  z' \\<turnstile> p\n\ngoal (6 subgoals):\n 1. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        G \\<turnstile> b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> And a b\n 2. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b\n 3. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a\n 4. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Forall a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a[t/0]\n 5. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[t/0];\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Exists a\n 6. \\<And>G a n b z'.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Exists a;\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>z'.\n           set (a[App n []/0] # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> b;\n        news n G; new n a; new n b; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        G \\<turnstile> b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> And a b\n 2. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b\n 3. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a\n 4. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Forall a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a[t/0]\n 5. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[t/0];\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Exists a\n 6. \\<And>G a n b z'.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Exists a;\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>z'.\n           set (a[App n []/0] # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> b;\n        news n G; new n a; new n b; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b", "case (AndE2 z p q)"], ["proof (state)\nthis:\n  z \\<turnstile> And p q\n  set z \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> And p q\n  set z \\<subseteq> set z'\n\ngoal (6 subgoals):\n 1. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        G \\<turnstile> b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> And a b\n 2. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> And a b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> And a b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b\n 3. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a\n 4. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Forall a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a[t/0]\n 5. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[t/0];\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Exists a\n 6. \\<And>G a n b z'.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Exists a;\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>z'.\n           set (a[App n []/0] # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> b;\n        news n G; new n a; new n b; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b", "then"], ["proof (chain)\npicking this:\n  z \\<turnstile> And p q\n  set z \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> And p q\n  set z \\<subseteq> set z'", "show ?case"], ["proof (prove)\nusing this:\n  z \\<turnstile> And p q\n  set z \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> And p q\n  set z \\<subseteq> set z'\n\ngoal (1 subgoal):\n 1. z' \\<turnstile> q", "using deriv.AndE2"], ["proof (prove)\nusing this:\n  z \\<turnstile> And p q\n  set z \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> And p q\n  set z \\<subseteq> set z'\n  ?G \\<turnstile> And ?a ?b \\<Longrightarrow> ?G \\<turnstile> ?b\n\ngoal (1 subgoal):\n 1. z' \\<turnstile> q", "by blast"], ["proof (state)\nthis:\n  z' \\<turnstile> q\n\ngoal (5 subgoals):\n 1. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        G \\<turnstile> b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> And a b\n 2. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a\n 3. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Forall a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a[t/0]\n 4. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[t/0];\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Exists a\n 5. \\<And>G a n b z'.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Exists a;\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>z'.\n           set (a[App n []/0] # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> b;\n        news n G; new n a; new n b; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        G \\<turnstile> b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> And a b\n 2. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a\n 3. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Forall a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a[t/0]\n 4. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[t/0];\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Exists a\n 5. \\<And>G a n b z'.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Exists a;\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>z'.\n           set (a[App n []/0] # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> b;\n        news n G; new n a; new n b; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b", "case (AndI z p q)"], ["proof (state)\nthis:\n  z \\<turnstile> p\n  set z \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> p\n  z \\<turnstile> q\n  set z \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> q\n  set z \\<subseteq> set z'\n\ngoal (5 subgoals):\n 1. \\<And>G a b z'.\n       \\<lbrakk>G \\<turnstile> a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> a;\n        G \\<turnstile> b;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow> z' \\<turnstile> b;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> And a b\n 2. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a\n 3. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Forall a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a[t/0]\n 4. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[t/0];\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Exists a\n 5. \\<And>G a n b z'.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Exists a;\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>z'.\n           set (a[App n []/0] # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> b;\n        news n G; new n a; new n b; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b", "then"], ["proof (chain)\npicking this:\n  z \\<turnstile> p\n  set z \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> p\n  z \\<turnstile> q\n  set z \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> q\n  set z \\<subseteq> set z'", "show ?case"], ["proof (prove)\nusing this:\n  z \\<turnstile> p\n  set z \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> p\n  z \\<turnstile> q\n  set z \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> q\n  set z \\<subseteq> set z'\n\ngoal (1 subgoal):\n 1. z' \\<turnstile> And p q", "using deriv.AndI"], ["proof (prove)\nusing this:\n  z \\<turnstile> p\n  set z \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> p\n  z \\<turnstile> q\n  set z \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> q\n  set z \\<subseteq> set z'\n  \\<lbrakk>?G \\<turnstile> ?a; ?G \\<turnstile> ?b\\<rbrakk>\n  \\<Longrightarrow> ?G \\<turnstile> And ?a ?b\n\ngoal (1 subgoal):\n 1. z' \\<turnstile> And p q", "by blast"], ["proof (state)\nthis:\n  z' \\<turnstile> And p q\n\ngoal (4 subgoals):\n 1. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a\n 2. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Forall a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a[t/0]\n 3. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[t/0];\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Exists a\n 4. \\<And>G a n b z'.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Exists a;\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>z'.\n           set (a[App n []/0] # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> b;\n        news n G; new n a; new n b; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a\n 2. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Forall a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a[t/0]\n 3. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[t/0];\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Exists a\n 4. \\<And>G a n b z'.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Exists a;\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>z'.\n           set (a[App n []/0] # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> b;\n        news n G; new n a; new n b; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b", "case (ExistsE z p c q)"], ["proof (state)\nthis:\n  z \\<turnstile> Exists p\n  set z \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> Exists p\n  p[App c []/0] # z \\<turnstile> q\n  set (p[App c []/0] # z) \\<subseteq> set ?z' \\<Longrightarrow>\n  ?z' \\<turnstile> q\n  news c z\n  new c p\n  new c q\n  set z \\<subseteq> set z'\n\ngoal (4 subgoals):\n 1. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a\n 2. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Forall a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a[t/0]\n 3. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[t/0];\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Exists a\n 4. \\<And>G a n b z'.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Exists a;\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>z'.\n           set (a[App n []/0] # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> b;\n        news n G; new n a; new n b; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b", "let ?params = \\<open>params p \\<union> params q \\<union> (\\<Union>p \\<in> set z'. params p) \\<union> {c}\\<close>"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a\n 2. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Forall a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a[t/0]\n 3. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[t/0];\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Exists a\n 4. \\<And>G a n b z'.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Exists a;\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>z'.\n           set (a[App n []/0] # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> b;\n        news n G; new n a; new n b; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b", "have \\<open>finite ?params\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (params p \\<union> params q \\<union>\n      \\<Union> (params ` set z') \\<union>\n      {c})", "by simp"], ["proof (state)\nthis:\n  finite\n   (params p \\<union> params q \\<union> \\<Union> (params ` set z') \\<union>\n    {c})\n\ngoal (4 subgoals):\n 1. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a\n 2. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Forall a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a[t/0]\n 3. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[t/0];\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Exists a\n 4. \\<And>G a n b z'.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Exists a;\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>z'.\n           set (a[App n []/0] # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> b;\n        news n G; new n a; new n b; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b", "then"], ["proof (chain)\npicking this:\n  finite\n   (params p \\<union> params q \\<union> \\<Union> (params ` set z') \\<union>\n    {c})", "obtain fresh where fresh: \\<open>fresh \\<notin> ?params\\<close>"], ["proof (prove)\nusing this:\n  finite\n   (params p \\<union> params q \\<union> \\<Union> (params ` set z') \\<union>\n    {c})\n\ngoal (1 subgoal):\n 1. (\\<And>fresh.\n        fresh\n        \\<notin> params p \\<union> params q \\<union>\n                 \\<Union> (params ` set z') \\<union>\n                 {c} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using inf_params"], ["proof (prove)\nusing this:\n  finite\n   (params p \\<union> params q \\<union> \\<Union> (params ` set z') \\<union>\n    {c})\n  infinite UNIV\n\ngoal (1 subgoal):\n 1. (\\<And>fresh.\n        fresh\n        \\<notin> params p \\<union> params q \\<union>\n                 \\<Union> (params ` set z') \\<union>\n                 {c} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (meson ex_new_if_finite List.finite_set infinite_UNIV_listI)"], ["proof (state)\nthis:\n  fresh\n  \\<notin> params p \\<union> params q \\<union>\n           \\<Union> (params ` set z') \\<union>\n           {c}\n\ngoal (4 subgoals):\n 1. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a\n 2. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Forall a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a[t/0]\n 3. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[t/0];\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Exists a\n 4. \\<And>G a n b z'.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Exists a;\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>z'.\n           set (a[App n []/0] # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> b;\n        news n G; new n a; new n b; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b", "let ?z' = \\<open>map (psubst (id(c := fresh))) z'\\<close>"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a\n 2. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Forall a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a[t/0]\n 3. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[t/0];\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Exists a\n 4. \\<And>G a n b z'.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Exists a;\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>z'.\n           set (a[App n []/0] # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> b;\n        news n G; new n a; new n b; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b", "have \\<open>news c z\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. news c z", "using ExistsE"], ["proof (prove)\nusing this:\n  z \\<turnstile> Exists p\n  set z \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> Exists p\n  p[App c []/0] # z \\<turnstile> q\n  set (p[App c []/0] # z) \\<subseteq> set ?z' \\<Longrightarrow>\n  ?z' \\<turnstile> q\n  news c z\n  new c p\n  new c q\n  set z \\<subseteq> set z'\n\ngoal (1 subgoal):\n 1. news c z", "by simp"], ["proof (state)\nthis:\n  news c z\n\ngoal (4 subgoals):\n 1. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a\n 2. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Forall a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a[t/0]\n 3. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[t/0];\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Exists a\n 4. \\<And>G a n b z'.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Exists a;\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>z'.\n           set (a[App n []/0] # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> b;\n        news n G; new n a; new n b; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b", "then"], ["proof (chain)\npicking this:\n  news c z", "have \\<open>set z \\<subseteq> set ?z'\\<close>"], ["proof (prove)\nusing this:\n  news c z\n\ngoal (1 subgoal):\n 1. set z \\<subseteq> set (map (psubst (id(c := fresh))) z')", "using ExistsE psubst_new_subset"], ["proof (prove)\nusing this:\n  news c z\n  z \\<turnstile> Exists p\n  set z \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> Exists p\n  p[App c []/0] # z \\<turnstile> q\n  set (p[App c []/0] # z) \\<subseteq> set ?z' \\<Longrightarrow>\n  ?z' \\<turnstile> q\n  news c z\n  new c p\n  new c q\n  set z \\<subseteq> set z'\n  \\<lbrakk>set ?z \\<subseteq> set ?z';\n   ?c \\<notin> \\<Union> (params ` set ?z)\\<rbrakk>\n  \\<Longrightarrow> set ?z \\<subseteq> set (map (psubst (id(?c := ?n))) ?z')\n\ngoal (1 subgoal):\n 1. set z \\<subseteq> set (map (psubst (id(c := fresh))) z')", "by (simp add: Ball_set)"], ["proof (state)\nthis:\n  set z \\<subseteq> set (map (psubst (id(c := fresh))) z')\n\ngoal (4 subgoals):\n 1. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a\n 2. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Forall a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a[t/0]\n 3. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[t/0];\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Exists a\n 4. \\<And>G a n b z'.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Exists a;\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>z'.\n           set (a[App n []/0] # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> b;\n        news n G; new n a; new n b; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b", "then"], ["proof (chain)\npicking this:\n  set z \\<subseteq> set (map (psubst (id(c := fresh))) z')", "have \\<open>?z' \\<turnstile> Exists p\\<close>"], ["proof (prove)\nusing this:\n  set z \\<subseteq> set (map (psubst (id(c := fresh))) z')\n\ngoal (1 subgoal):\n 1. map (psubst (id(c := fresh))) z' \\<turnstile> Exists p", "using ExistsE"], ["proof (prove)\nusing this:\n  set z \\<subseteq> set (map (psubst (id(c := fresh))) z')\n  z \\<turnstile> Exists p\n  set z \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> Exists p\n  p[App c []/0] # z \\<turnstile> q\n  set (p[App c []/0] # z) \\<subseteq> set ?z' \\<Longrightarrow>\n  ?z' \\<turnstile> q\n  news c z\n  new c p\n  new c q\n  set z \\<subseteq> set z'\n\ngoal (1 subgoal):\n 1. map (psubst (id(c := fresh))) z' \\<turnstile> Exists p", "by blast"], ["proof (state)\nthis:\n  map (psubst (id(c := fresh))) z' \\<turnstile> Exists p\n\ngoal (4 subgoals):\n 1. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a\n 2. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Forall a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a[t/0]\n 3. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[t/0];\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Exists a\n 4. \\<And>G a n b z'.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Exists a;\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>z'.\n           set (a[App n []/0] # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> b;\n        news n G; new n a; new n b; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b", "moreover"], ["proof (state)\nthis:\n  map (psubst (id(c := fresh))) z' \\<turnstile> Exists p\n\ngoal (4 subgoals):\n 1. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a\n 2. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Forall a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a[t/0]\n 3. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[t/0];\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Exists a\n 4. \\<And>G a n b z'.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Exists a;\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>z'.\n           set (a[App n []/0] # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> b;\n        news n G; new n a; new n b; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b", "have \\<open>set (subst p (App c []) 0 # z) \\<subseteq> set (subst p (App c []) 0 # ?z')\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (p[App c []/0] # z)\n    \\<subseteq> set (p[App c []/0] # map (psubst (id(c := fresh))) z')", "using \\<open>set z \\<subseteq> set ?z'\\<close>"], ["proof (prove)\nusing this:\n  set z \\<subseteq> set (map (psubst (id(c := fresh))) z')\n\ngoal (1 subgoal):\n 1. set (p[App c []/0] # z)\n    \\<subseteq> set (p[App c []/0] # map (psubst (id(c := fresh))) z')", "by auto"], ["proof (state)\nthis:\n  set (p[App c []/0] # z)\n  \\<subseteq> set (p[App c []/0] # map (psubst (id(c := fresh))) z')\n\ngoal (4 subgoals):\n 1. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a\n 2. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Forall a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a[t/0]\n 3. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[t/0];\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Exists a\n 4. \\<And>G a n b z'.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Exists a;\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>z'.\n           set (a[App n []/0] # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> b;\n        news n G; new n a; new n b; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b", "then"], ["proof (chain)\npicking this:\n  set (p[App c []/0] # z)\n  \\<subseteq> set (p[App c []/0] # map (psubst (id(c := fresh))) z')", "have \\<open>subst p (App c []) 0 # ?z' \\<turnstile> q\\<close>"], ["proof (prove)\nusing this:\n  set (p[App c []/0] # z)\n  \\<subseteq> set (p[App c []/0] # map (psubst (id(c := fresh))) z')\n\ngoal (1 subgoal):\n 1. p[App c []/0] # map (psubst (id(c := fresh))) z' \\<turnstile> q", "using ExistsE"], ["proof (prove)\nusing this:\n  set (p[App c []/0] # z)\n  \\<subseteq> set (p[App c []/0] # map (psubst (id(c := fresh))) z')\n  z \\<turnstile> Exists p\n  set z \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> Exists p\n  p[App c []/0] # z \\<turnstile> q\n  set (p[App c []/0] # z) \\<subseteq> set ?z' \\<Longrightarrow>\n  ?z' \\<turnstile> q\n  news c z\n  new c p\n  new c q\n  set z \\<subseteq> set z'\n\ngoal (1 subgoal):\n 1. p[App c []/0] # map (psubst (id(c := fresh))) z' \\<turnstile> q", "by blast"], ["proof (state)\nthis:\n  p[App c []/0] # map (psubst (id(c := fresh))) z' \\<turnstile> q\n\ngoal (4 subgoals):\n 1. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a\n 2. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Forall a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a[t/0]\n 3. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[t/0];\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Exists a\n 4. \\<And>G a n b z'.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Exists a;\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>z'.\n           set (a[App n []/0] # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> b;\n        news n G; new n a; new n b; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b", "moreover"], ["proof (state)\nthis:\n  p[App c []/0] # map (psubst (id(c := fresh))) z' \\<turnstile> q\n\ngoal (4 subgoals):\n 1. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a\n 2. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Forall a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a[t/0]\n 3. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[t/0];\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Exists a\n 4. \\<And>G a n b z'.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Exists a;\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>z'.\n           set (a[App n []/0] # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> b;\n        news n G; new n a; new n b; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b", "have \\<open>news c ?z'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. news c (map (psubst (id(c := fresh))) z')", "using fresh"], ["proof (prove)\nusing this:\n  fresh\n  \\<notin> params p \\<union> params q \\<union>\n           \\<Union> (params ` set z') \\<union>\n           {c}\n\ngoal (1 subgoal):\n 1. news c (map (psubst (id(c := fresh))) z')", "by (simp add: map_psubst_new_free)"], ["proof (state)\nthis:\n  news c (map (psubst (id(c := fresh))) z')\n\ngoal (4 subgoals):\n 1. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a\n 2. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Forall a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a[t/0]\n 3. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[t/0];\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Exists a\n 4. \\<And>G a n b z'.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Exists a;\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>z'.\n           set (a[App n []/0] # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> b;\n        news n G; new n a; new n b; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b", "then"], ["proof (chain)\npicking this:\n  news c (map (psubst (id(c := fresh))) z')", "have \\<open>new c p\\<close> \\<open>new c q\\<close> \\<open>news c ?z'\\<close>"], ["proof (prove)\nusing this:\n  news c (map (psubst (id(c := fresh))) z')\n\ngoal (1 subgoal):\n 1. new c p &&& new c q &&& news c (map (psubst (id(c := fresh))) z')", "using ExistsE"], ["proof (prove)\nusing this:\n  news c (map (psubst (id(c := fresh))) z')\n  z \\<turnstile> Exists p\n  set z \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> Exists p\n  p[App c []/0] # z \\<turnstile> q\n  set (p[App c []/0] # z) \\<subseteq> set ?z' \\<Longrightarrow>\n  ?z' \\<turnstile> q\n  news c z\n  new c p\n  new c q\n  set z \\<subseteq> set z'\n\ngoal (1 subgoal):\n 1. new c p &&& new c q &&& news c (map (psubst (id(c := fresh))) z')", "by simp_all"], ["proof (state)\nthis:\n  new c p\n  new c q\n  news c (map (psubst (id(c := fresh))) z')\n\ngoal (4 subgoals):\n 1. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a\n 2. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Forall a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a[t/0]\n 3. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[t/0];\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Exists a\n 4. \\<And>G a n b z'.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Exists a;\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>z'.\n           set (a[App n []/0] # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> b;\n        news n G; new n a; new n b; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b", "ultimately"], ["proof (chain)\npicking this:\n  map (psubst (id(c := fresh))) z' \\<turnstile> Exists p\n  p[App c []/0] # map (psubst (id(c := fresh))) z' \\<turnstile> q\n  new c p\n  new c q\n  news c (map (psubst (id(c := fresh))) z')", "have \\<open>?z' \\<turnstile> q\\<close>"], ["proof (prove)\nusing this:\n  map (psubst (id(c := fresh))) z' \\<turnstile> Exists p\n  p[App c []/0] # map (psubst (id(c := fresh))) z' \\<turnstile> q\n  new c p\n  new c q\n  news c (map (psubst (id(c := fresh))) z')\n\ngoal (1 subgoal):\n 1. map (psubst (id(c := fresh))) z' \\<turnstile> q", "using ExistsE deriv.ExistsE"], ["proof (prove)\nusing this:\n  map (psubst (id(c := fresh))) z' \\<turnstile> Exists p\n  p[App c []/0] # map (psubst (id(c := fresh))) z' \\<turnstile> q\n  new c p\n  new c q\n  news c (map (psubst (id(c := fresh))) z')\n  z \\<turnstile> Exists p\n  set z \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> Exists p\n  p[App c []/0] # z \\<turnstile> q\n  set (p[App c []/0] # z) \\<subseteq> set ?z' \\<Longrightarrow>\n  ?z' \\<turnstile> q\n  news c z\n  new c p\n  new c q\n  set z \\<subseteq> set z'\n  \\<lbrakk>?G \\<turnstile> Exists ?a; ?a[App ?n []/0] # ?G \\<turnstile> ?b;\n   news ?n ?G; new ?n ?a; new ?n ?b\\<rbrakk>\n  \\<Longrightarrow> ?G \\<turnstile> ?b\n\ngoal (1 subgoal):\n 1. map (psubst (id(c := fresh))) z' \\<turnstile> q", "by metis"], ["proof (state)\nthis:\n  map (psubst (id(c := fresh))) z' \\<turnstile> q\n\ngoal (4 subgoals):\n 1. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a\n 2. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Forall a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a[t/0]\n 3. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[t/0];\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Exists a\n 4. \\<And>G a n b z'.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Exists a;\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>z'.\n           set (a[App n []/0] # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> b;\n        news n G; new n a; new n b; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b", "then"], ["proof (chain)\npicking this:\n  map (psubst (id(c := fresh))) z' \\<turnstile> q", "have \\<open>map (psubst (id(fresh := c))) ?z' \\<turnstile> psubst (id(fresh := c)) q\\<close>"], ["proof (prove)\nusing this:\n  map (psubst (id(c := fresh))) z' \\<turnstile> q\n\ngoal (1 subgoal):\n 1. map (psubst (id(fresh := c)))\n     (map (psubst (id(c := fresh)))\n       z') \\<turnstile> psubst (id(fresh := c)) q", "using deriv_psubst inf_params"], ["proof (prove)\nusing this:\n  map (psubst (id(c := fresh))) z' \\<turnstile> q\n  \\<lbrakk>infinite UNIV; ?z \\<turnstile> ?p\\<rbrakk>\n  \\<Longrightarrow> map (psubst ?f) ?z \\<turnstile> psubst ?f ?p\n  infinite UNIV\n\ngoal (1 subgoal):\n 1. map (psubst (id(fresh := c)))\n     (map (psubst (id(c := fresh)))\n       z') \\<turnstile> psubst (id(fresh := c)) q", "by blast"], ["proof (state)\nthis:\n  map (psubst (id(fresh := c)))\n   (map (psubst (id(c := fresh))) z') \\<turnstile> psubst (id(fresh := c)) q\n\ngoal (4 subgoals):\n 1. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a\n 2. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Forall a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a[t/0]\n 3. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[t/0];\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Exists a\n 4. \\<And>G a n b z'.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Exists a;\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>z'.\n           set (a[App n []/0] # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> b;\n        news n G; new n a; new n b; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b", "moreover"], ["proof (state)\nthis:\n  map (psubst (id(fresh := c)))\n   (map (psubst (id(c := fresh))) z') \\<turnstile> psubst (id(fresh := c)) q\n\ngoal (4 subgoals):\n 1. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a\n 2. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Forall a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a[t/0]\n 3. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[t/0];\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Exists a\n 4. \\<And>G a n b z'.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Exists a;\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>z'.\n           set (a[App n []/0] # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> b;\n        news n G; new n a; new n b; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b", "have \\<open>map (psubst (id(fresh := c))) ?z' = z'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (psubst (id(fresh := c))) (map (psubst (id(c := fresh))) z') = z'", "using fresh map_psubst_new_away Ball_set"], ["proof (prove)\nusing this:\n  fresh\n  \\<notin> params p \\<union> params q \\<union>\n           \\<Union> (params ` set z') \\<union>\n           {c}\n  news ?fresh ?z \\<Longrightarrow>\n  map (psubst (id(?fresh := ?c))) (map (psubst (id(?c := ?fresh))) ?z) = ?z\n  Ball (set ?xs) ?P = list_all ?P ?xs\n\ngoal (1 subgoal):\n 1. map (psubst (id(fresh := c))) (map (psubst (id(c := fresh))) z') = z'", "by fastforce"], ["proof (state)\nthis:\n  map (psubst (id(fresh := c))) (map (psubst (id(c := fresh))) z') = z'\n\ngoal (4 subgoals):\n 1. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a\n 2. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Forall a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a[t/0]\n 3. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[t/0];\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Exists a\n 4. \\<And>G a n b z'.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Exists a;\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>z'.\n           set (a[App n []/0] # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> b;\n        news n G; new n a; new n b; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b", "moreover"], ["proof (state)\nthis:\n  map (psubst (id(fresh := c))) (map (psubst (id(c := fresh))) z') = z'\n\ngoal (4 subgoals):\n 1. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a\n 2. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Forall a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a[t/0]\n 3. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[t/0];\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Exists a\n 4. \\<And>G a n b z'.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Exists a;\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>z'.\n           set (a[App n []/0] # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> b;\n        news n G; new n a; new n b; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b", "have \\<open>psubst (id(fresh := c)) q = q\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. psubst (id(fresh := c)) q = q", "using fresh"], ["proof (prove)\nusing this:\n  fresh\n  \\<notin> params p \\<union> params q \\<union>\n           \\<Union> (params ` set z') \\<union>\n           {c}\n\ngoal (1 subgoal):\n 1. psubst (id(fresh := c)) q = q", "by simp"], ["proof (state)\nthis:\n  psubst (id(fresh := c)) q = q\n\ngoal (4 subgoals):\n 1. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a\n 2. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Forall a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a[t/0]\n 3. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[t/0];\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Exists a\n 4. \\<And>G a n b z'.\n       \\<lbrakk>G \\<turnstile> Exists a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Exists a;\n        a[App n []/0] # G \\<turnstile> b;\n        \\<And>z'.\n           set (a[App n []/0] # G) \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> b;\n        news n G; new n a; new n b; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> b", "ultimately"], ["proof (chain)\npicking this:\n  map (psubst (id(fresh := c)))\n   (map (psubst (id(c := fresh))) z') \\<turnstile> psubst (id(fresh := c)) q\n  map (psubst (id(fresh := c))) (map (psubst (id(c := fresh))) z') = z'\n  psubst (id(fresh := c)) q = q", "show \\<open>z' \\<turnstile> q\\<close>"], ["proof (prove)\nusing this:\n  map (psubst (id(fresh := c)))\n   (map (psubst (id(c := fresh))) z') \\<turnstile> psubst (id(fresh := c)) q\n  map (psubst (id(fresh := c))) (map (psubst (id(c := fresh))) z') = z'\n  psubst (id(fresh := c)) q = q\n\ngoal (1 subgoal):\n 1. z' \\<turnstile> q", "by simp"], ["proof (state)\nthis:\n  z' \\<turnstile> q\n\ngoal (3 subgoals):\n 1. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a\n 2. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Forall a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a[t/0]\n 3. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[t/0];\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Exists a", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a\n 2. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Forall a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a[t/0]\n 3. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[t/0];\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Exists a", "case (ExistsI z p t)"], ["proof (state)\nthis:\n  z \\<turnstile> p[t/0]\n  set z \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> p[t/0]\n  set z \\<subseteq> set z'\n\ngoal (3 subgoals):\n 1. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a\n 2. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Forall a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a[t/0]\n 3. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> a[t/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[t/0];\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Exists a", "then"], ["proof (chain)\npicking this:\n  z \\<turnstile> p[t/0]\n  set z \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> p[t/0]\n  set z \\<subseteq> set z'", "show ?case"], ["proof (prove)\nusing this:\n  z \\<turnstile> p[t/0]\n  set z \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> p[t/0]\n  set z \\<subseteq> set z'\n\ngoal (1 subgoal):\n 1. z' \\<turnstile> Exists p", "using deriv.ExistsI"], ["proof (prove)\nusing this:\n  z \\<turnstile> p[t/0]\n  set z \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> p[t/0]\n  set z \\<subseteq> set z'\n  ?G \\<turnstile> ?a[?t/0] \\<Longrightarrow> ?G \\<turnstile> Exists ?a\n\ngoal (1 subgoal):\n 1. z' \\<turnstile> Exists p", "by blast"], ["proof (state)\nthis:\n  z' \\<turnstile> Exists p\n\ngoal (2 subgoals):\n 1. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a\n 2. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Forall a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a[t/0]", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a\n 2. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Forall a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a[t/0]", "case (ForallE p z t)"], ["proof (state)\nthis:\n  p \\<turnstile> Forall z\n  set p \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> Forall z\n  set p \\<subseteq> set z'\n\ngoal (2 subgoals):\n 1. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a\n 2. \\<And>G a t z'.\n       \\<lbrakk>G \\<turnstile> Forall a;\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> Forall a;\n        set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> a[t/0]", "then"], ["proof (chain)\npicking this:\n  p \\<turnstile> Forall z\n  set p \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> Forall z\n  set p \\<subseteq> set z'", "show ?case"], ["proof (prove)\nusing this:\n  p \\<turnstile> Forall z\n  set p \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> Forall z\n  set p \\<subseteq> set z'\n\ngoal (1 subgoal):\n 1. z' \\<turnstile> z[t/0]", "using deriv.ForallE"], ["proof (prove)\nusing this:\n  p \\<turnstile> Forall z\n  set p \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> Forall z\n  set p \\<subseteq> set z'\n  ?G \\<turnstile> Forall ?a \\<Longrightarrow> ?G \\<turnstile> ?a[?t/0]\n\ngoal (1 subgoal):\n 1. z' \\<turnstile> z[t/0]", "by blast"], ["proof (state)\nthis:\n  z' \\<turnstile> z[t/0]\n\ngoal (1 subgoal):\n 1. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a", "case (ForallI z p c)"], ["proof (state)\nthis:\n  z \\<turnstile> p[App c []/0]\n  set z \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> p[App c []/0]\n  news c z\n  new c p\n  set z \\<subseteq> set z'\n\ngoal (1 subgoal):\n 1. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a", "let ?params = \\<open>params p \\<union> (\\<Union>p \\<in> set z'. params p) \\<union> {c}\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a", "have \\<open>finite ?params\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (params p \\<union> \\<Union> (params ` set z') \\<union> {c})", "by simp"], ["proof (state)\nthis:\n  finite (params p \\<union> \\<Union> (params ` set z') \\<union> {c})\n\ngoal (1 subgoal):\n 1. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a", "then"], ["proof (chain)\npicking this:\n  finite (params p \\<union> \\<Union> (params ` set z') \\<union> {c})", "obtain fresh where fresh: \\<open>fresh \\<notin> ?params\\<close>"], ["proof (prove)\nusing this:\n  finite (params p \\<union> \\<Union> (params ` set z') \\<union> {c})\n\ngoal (1 subgoal):\n 1. (\\<And>fresh.\n        fresh\n        \\<notin> params p \\<union> \\<Union> (params ` set z') \\<union>\n                 {c} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using inf_params"], ["proof (prove)\nusing this:\n  finite (params p \\<union> \\<Union> (params ` set z') \\<union> {c})\n  infinite UNIV\n\ngoal (1 subgoal):\n 1. (\\<And>fresh.\n        fresh\n        \\<notin> params p \\<union> \\<Union> (params ` set z') \\<union>\n                 {c} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (meson ex_new_if_finite List.finite_set infinite_UNIV_listI)"], ["proof (state)\nthis:\n  fresh \\<notin> params p \\<union> \\<Union> (params ` set z') \\<union> {c}\n\ngoal (1 subgoal):\n 1. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a", "let ?z' = \\<open>map (psubst (id(c := fresh))) z'\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a", "have \\<open>news c z\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. news c z", "using ForallI"], ["proof (prove)\nusing this:\n  z \\<turnstile> p[App c []/0]\n  set z \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> p[App c []/0]\n  news c z\n  new c p\n  set z \\<subseteq> set z'\n\ngoal (1 subgoal):\n 1. news c z", "by simp"], ["proof (state)\nthis:\n  news c z\n\ngoal (1 subgoal):\n 1. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a", "then"], ["proof (chain)\npicking this:\n  news c z", "have \\<open>set z \\<subseteq> set ?z'\\<close>"], ["proof (prove)\nusing this:\n  news c z\n\ngoal (1 subgoal):\n 1. set z \\<subseteq> set (map (psubst (id(c := fresh))) z')", "using ForallI psubst_new_subset"], ["proof (prove)\nusing this:\n  news c z\n  z \\<turnstile> p[App c []/0]\n  set z \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> p[App c []/0]\n  news c z\n  new c p\n  set z \\<subseteq> set z'\n  \\<lbrakk>set ?z \\<subseteq> set ?z';\n   ?c \\<notin> \\<Union> (params ` set ?z)\\<rbrakk>\n  \\<Longrightarrow> set ?z \\<subseteq> set (map (psubst (id(?c := ?n))) ?z')\n\ngoal (1 subgoal):\n 1. set z \\<subseteq> set (map (psubst (id(c := fresh))) z')", "by (metis (no_types, lifting) Ball_set UN_iff)"], ["proof (state)\nthis:\n  set z \\<subseteq> set (map (psubst (id(c := fresh))) z')\n\ngoal (1 subgoal):\n 1. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a", "then"], ["proof (chain)\npicking this:\n  set z \\<subseteq> set (map (psubst (id(c := fresh))) z')", "have \\<open>?z' \\<turnstile> subst p (App c []) 0\\<close>"], ["proof (prove)\nusing this:\n  set z \\<subseteq> set (map (psubst (id(c := fresh))) z')\n\ngoal (1 subgoal):\n 1. map (psubst (id(c := fresh))) z' \\<turnstile> p[App c []/0]", "using ForallI"], ["proof (prove)\nusing this:\n  set z \\<subseteq> set (map (psubst (id(c := fresh))) z')\n  z \\<turnstile> p[App c []/0]\n  set z \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> p[App c []/0]\n  news c z\n  new c p\n  set z \\<subseteq> set z'\n\ngoal (1 subgoal):\n 1. map (psubst (id(c := fresh))) z' \\<turnstile> p[App c []/0]", "by blast"], ["proof (state)\nthis:\n  map (psubst (id(c := fresh))) z' \\<turnstile> p[App c []/0]\n\ngoal (1 subgoal):\n 1. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a", "moreover"], ["proof (state)\nthis:\n  map (psubst (id(c := fresh))) z' \\<turnstile> p[App c []/0]\n\ngoal (1 subgoal):\n 1. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a", "have \\<open>\\<forall>p \\<in> set ?z'. c \\<notin> params p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set (map (psubst (id(c := fresh))) z'). new c p", "using fresh psubst_new_free"], ["proof (prove)\nusing this:\n  fresh \\<notin> params p \\<union> \\<Union> (params ` set z') \\<union> {c}\n  ?c \\<noteq> ?n \\<Longrightarrow> new ?n (psubst (id(?n := ?c)) ?p)\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>set (map (psubst (id(c := fresh))) z'). new c p", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>p\\<in>set (map (psubst (id(c := fresh))) z'). new c p\n\ngoal (1 subgoal):\n 1. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a", "then"], ["proof (chain)\npicking this:\n  \\<forall>p\\<in>set (map (psubst (id(c := fresh))) z'). new c p", "have \\<open>list_all (\\<lambda>p. c \\<notin> params p) (p # ?z')\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set (map (psubst (id(c := fresh))) z'). new c p\n\ngoal (1 subgoal):\n 1. news c (p # map (psubst (id(c := fresh))) z')", "using ForallI"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>set (map (psubst (id(c := fresh))) z'). new c p\n  z \\<turnstile> p[App c []/0]\n  set z \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> p[App c []/0]\n  news c z\n  new c p\n  set z \\<subseteq> set z'\n\ngoal (1 subgoal):\n 1. news c (p # map (psubst (id(c := fresh))) z')", "by (simp add: list_all_iff)"], ["proof (state)\nthis:\n  news c (p # map (psubst (id(c := fresh))) z')\n\ngoal (1 subgoal):\n 1. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a", "then"], ["proof (chain)\npicking this:\n  news c (p # map (psubst (id(c := fresh))) z')", "have \\<open>new c p\\<close> \\<open>news c ?z'\\<close>"], ["proof (prove)\nusing this:\n  news c (p # map (psubst (id(c := fresh))) z')\n\ngoal (1 subgoal):\n 1. new c p &&& news c (map (psubst (id(c := fresh))) z')", "by simp_all"], ["proof (state)\nthis:\n  new c p\n  news c (map (psubst (id(c := fresh))) z')\n\ngoal (1 subgoal):\n 1. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a", "ultimately"], ["proof (chain)\npicking this:\n  map (psubst (id(c := fresh))) z' \\<turnstile> p[App c []/0]\n  new c p\n  news c (map (psubst (id(c := fresh))) z')", "have \\<open>?z' \\<turnstile> Forall p\\<close>"], ["proof (prove)\nusing this:\n  map (psubst (id(c := fresh))) z' \\<turnstile> p[App c []/0]\n  new c p\n  news c (map (psubst (id(c := fresh))) z')\n\ngoal (1 subgoal):\n 1. map (psubst (id(c := fresh))) z' \\<turnstile> Forall p", "using ForallI deriv.ForallI"], ["proof (prove)\nusing this:\n  map (psubst (id(c := fresh))) z' \\<turnstile> p[App c []/0]\n  new c p\n  news c (map (psubst (id(c := fresh))) z')\n  z \\<turnstile> p[App c []/0]\n  set z \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> p[App c []/0]\n  news c z\n  new c p\n  set z \\<subseteq> set z'\n  \\<lbrakk>?G \\<turnstile> ?a[App ?n []/0]; news ?n ?G; new ?n ?a\\<rbrakk>\n  \\<Longrightarrow> ?G \\<turnstile> Forall ?a\n\ngoal (1 subgoal):\n 1. map (psubst (id(c := fresh))) z' \\<turnstile> Forall p", "by fast"], ["proof (state)\nthis:\n  map (psubst (id(c := fresh))) z' \\<turnstile> Forall p\n\ngoal (1 subgoal):\n 1. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a", "then"], ["proof (chain)\npicking this:\n  map (psubst (id(c := fresh))) z' \\<turnstile> Forall p", "have \\<open>map (psubst (id(fresh := c))) ?z' \\<turnstile> psubst (id(fresh := c)) (Forall p)\\<close>"], ["proof (prove)\nusing this:\n  map (psubst (id(c := fresh))) z' \\<turnstile> Forall p\n\ngoal (1 subgoal):\n 1. map (psubst (id(fresh := c)))\n     (map (psubst (id(c := fresh)))\n       z') \\<turnstile> psubst (id(fresh := c)) (Forall p)", "using deriv_psubst inf_params"], ["proof (prove)\nusing this:\n  map (psubst (id(c := fresh))) z' \\<turnstile> Forall p\n  \\<lbrakk>infinite UNIV; ?z \\<turnstile> ?p\\<rbrakk>\n  \\<Longrightarrow> map (psubst ?f) ?z \\<turnstile> psubst ?f ?p\n  infinite UNIV\n\ngoal (1 subgoal):\n 1. map (psubst (id(fresh := c)))\n     (map (psubst (id(c := fresh)))\n       z') \\<turnstile> psubst (id(fresh := c)) (Forall p)", "by blast"], ["proof (state)\nthis:\n  map (psubst (id(fresh := c)))\n   (map (psubst (id(c := fresh)))\n     z') \\<turnstile> psubst (id(fresh := c)) (Forall p)\n\ngoal (1 subgoal):\n 1. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a", "moreover"], ["proof (state)\nthis:\n  map (psubst (id(fresh := c)))\n   (map (psubst (id(c := fresh)))\n     z') \\<turnstile> psubst (id(fresh := c)) (Forall p)\n\ngoal (1 subgoal):\n 1. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a", "have \\<open>map (psubst (id(fresh := c))) ?z' = z'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (psubst (id(fresh := c))) (map (psubst (id(c := fresh))) z') = z'", "using fresh map_psubst_new_away Ball_set"], ["proof (prove)\nusing this:\n  fresh \\<notin> params p \\<union> \\<Union> (params ` set z') \\<union> {c}\n  news ?fresh ?z \\<Longrightarrow>\n  map (psubst (id(?fresh := ?c))) (map (psubst (id(?c := ?fresh))) ?z) = ?z\n  Ball (set ?xs) ?P = list_all ?P ?xs\n\ngoal (1 subgoal):\n 1. map (psubst (id(fresh := c))) (map (psubst (id(c := fresh))) z') = z'", "by fastforce"], ["proof (state)\nthis:\n  map (psubst (id(fresh := c))) (map (psubst (id(c := fresh))) z') = z'\n\ngoal (1 subgoal):\n 1. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a", "moreover"], ["proof (state)\nthis:\n  map (psubst (id(fresh := c))) (map (psubst (id(c := fresh))) z') = z'\n\ngoal (1 subgoal):\n 1. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a", "have \\<open>psubst (id(fresh := c)) (Forall p) = Forall p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. psubst (id(fresh := c)) (Forall p) = Forall p", "using fresh ForallI"], ["proof (prove)\nusing this:\n  fresh \\<notin> params p \\<union> \\<Union> (params ` set z') \\<union> {c}\n  z \\<turnstile> p[App c []/0]\n  set z \\<subseteq> set ?z' \\<Longrightarrow> ?z' \\<turnstile> p[App c []/0]\n  news c z\n  new c p\n  set z \\<subseteq> set z'\n\ngoal (1 subgoal):\n 1. psubst (id(fresh := c)) (Forall p) = Forall p", "by simp"], ["proof (state)\nthis:\n  psubst (id(fresh := c)) (Forall p) = Forall p\n\ngoal (1 subgoal):\n 1. \\<And>G a n z'.\n       \\<lbrakk>G \\<turnstile> a[App n []/0];\n        \\<And>z'.\n           set G \\<subseteq> set z' \\<Longrightarrow>\n           z' \\<turnstile> a[App n []/0];\n        news n G; new n a; set G \\<subseteq> set z'\\<rbrakk>\n       \\<Longrightarrow> z' \\<turnstile> Forall a", "ultimately"], ["proof (chain)\npicking this:\n  map (psubst (id(fresh := c)))\n   (map (psubst (id(c := fresh)))\n     z') \\<turnstile> psubst (id(fresh := c)) (Forall p)\n  map (psubst (id(fresh := c))) (map (psubst (id(c := fresh))) z') = z'\n  psubst (id(fresh := c)) (Forall p) = Forall p", "show \\<open>z' \\<turnstile> Forall p\\<close>"], ["proof (prove)\nusing this:\n  map (psubst (id(fresh := c)))\n   (map (psubst (id(c := fresh)))\n     z') \\<turnstile> psubst (id(fresh := c)) (Forall p)\n  map (psubst (id(fresh := c))) (map (psubst (id(c := fresh))) z') = z'\n  psubst (id(fresh := c)) (Forall p) = Forall p\n\ngoal (1 subgoal):\n 1. z' \\<turnstile> Forall p", "by simp"], ["proof (state)\nthis:\n  z' \\<turnstile> Forall p\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Implications and assumptions\\<close>"], ["", "primrec put_imps :: \\<open>('a, 'b) form \\<Rightarrow> ('a, 'b) form list \\<Rightarrow> ('a, 'b) form\\<close> where\n  \\<open>put_imps p [] = p\\<close> |\n  \\<open>put_imps p (q # z) = Impl q (put_imps p z)\\<close>"], ["", "lemma semantics_put_imps:\n  \\<open>(e,f,g,z \\<Turnstile> p) = eval e f g (put_imps p z)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (e,f,g,z \\<Turnstile> p) = eval e f g (put_imps p z)", "unfolding model_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_all (eval e f g) z \\<longrightarrow> eval e f g p) =\n    eval e f g (put_imps p z)", "by (induct z) auto"], ["", "lemma shift_imp_assum:\n  fixes p :: \\<open>('a, 'b) form\\<close>\n  assumes inf_params: \\<open>infinite (UNIV :: 'a set)\\<close>\n    and \\<open>z \\<turnstile> Impl p q\\<close>\n  shows \\<open>p # z \\<turnstile> q\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. p # z \\<turnstile> q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p # z \\<turnstile> q", "have \\<open>set z \\<subseteq> set (p # z)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. set z \\<subseteq> set (p # z)", "by auto"], ["proof (state)\nthis:\n  set z \\<subseteq> set (p # z)\n\ngoal (1 subgoal):\n 1. p # z \\<turnstile> q", "then"], ["proof (chain)\npicking this:\n  set z \\<subseteq> set (p # z)", "have \\<open>p # z \\<turnstile> Impl p q\\<close>"], ["proof (prove)\nusing this:\n  set z \\<subseteq> set (p # z)\n\ngoal (1 subgoal):\n 1. p # z \\<turnstile> Impl p q", "using assms weaken_assumptions inf_params"], ["proof (prove)\nusing this:\n  set z \\<subseteq> set (p # z)\n  infinite UNIV\n  z \\<turnstile> Impl p q\n  \\<lbrakk>infinite UNIV; ?z \\<turnstile> ?p;\n   set ?z \\<subseteq> set ?z'\\<rbrakk>\n  \\<Longrightarrow> ?z' \\<turnstile> ?p\n  infinite UNIV\n\ngoal (1 subgoal):\n 1. p # z \\<turnstile> Impl p q", "by blast"], ["proof (state)\nthis:\n  p # z \\<turnstile> Impl p q\n\ngoal (1 subgoal):\n 1. p # z \\<turnstile> q", "moreover"], ["proof (state)\nthis:\n  p # z \\<turnstile> Impl p q\n\ngoal (1 subgoal):\n 1. p # z \\<turnstile> q", "have \\<open>p # z \\<turnstile> p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. p # z \\<turnstile> p", "by (simp add: Assum)"], ["proof (state)\nthis:\n  p # z \\<turnstile> p\n\ngoal (1 subgoal):\n 1. p # z \\<turnstile> q", "ultimately"], ["proof (chain)\npicking this:\n  p # z \\<turnstile> Impl p q\n  p # z \\<turnstile> p", "show \\<open>p # z \\<turnstile> q\\<close>"], ["proof (prove)\nusing this:\n  p # z \\<turnstile> Impl p q\n  p # z \\<turnstile> p\n\ngoal (1 subgoal):\n 1. p # z \\<turnstile> q", "using ImplE"], ["proof (prove)\nusing this:\n  p # z \\<turnstile> Impl p q\n  p # z \\<turnstile> p\n  \\<lbrakk>?G \\<turnstile> Impl ?a ?b; ?G \\<turnstile> ?a\\<rbrakk>\n  \\<Longrightarrow> ?G \\<turnstile> ?b\n\ngoal (1 subgoal):\n 1. p # z \\<turnstile> q", "by blast"], ["proof (state)\nthis:\n  p # z \\<turnstile> q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma remove_imps:\n  assumes \\<open>infinite (- params p)\\<close>\n  shows \\<open>z' \\<turnstile> put_imps p z \\<Longrightarrow> rev z @ z' \\<turnstile> p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. z' \\<turnstile> put_imps p z \\<Longrightarrow> rev z @ z' \\<turnstile> p", "using assms shift_imp_assum"], ["proof (prove)\nusing this:\n  infinite (- params p)\n  \\<lbrakk>infinite UNIV; ?z \\<turnstile> Impl ?p ?q\\<rbrakk>\n  \\<Longrightarrow> ?p # ?z \\<turnstile> ?q\n\ngoal (1 subgoal):\n 1. z' \\<turnstile> put_imps p z \\<Longrightarrow> rev z @ z' \\<turnstile> p", "by (induct z arbitrary: z') auto"], ["", "subsection \\<open>Closure elimination\\<close>"], ["", "lemma subc_sub_closed_var' [simp]:\n  \\<open>new_term c t \\<Longrightarrow> closedt (Suc m) t \\<Longrightarrow> subc_term c (Var m) (substt t (App c []) m) = t\\<close>\n  \\<open>new_list c l \\<Longrightarrow> closedts (Suc m) l \\<Longrightarrow> subc_list c (Var m) (substts l (App c []) m) = l\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>new_term c t; closedt (Suc m) t\\<rbrakk>\n     \\<Longrightarrow> subc_term c (Var m) (t[App c []/m]) = t) &&&\n    (\\<lbrakk>new_list c l; closedts (Suc m) l\\<rbrakk>\n     \\<Longrightarrow> subc_list c (Var m) (l[App c []/m]) = l)", "by (induct t and l rule: substt.induct substts.induct) auto"], ["", "lemma subc_sub_closed_var [simp]: \\<open>new c p \\<Longrightarrow> closed (Suc m) p \\<Longrightarrow>\n    subc c (Var m) (subst p (App c []) m) = p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>new c p; closed (Suc m) p\\<rbrakk>\n    \\<Longrightarrow> subc c (Var m) (p[App c []/m]) = p", "by (induct p arbitrary: m) simp_all"], ["", "primrec put_unis :: \\<open>nat \\<Rightarrow> ('a, 'b) form \\<Rightarrow> ('a, 'b) form\\<close> where\n  \\<open>put_unis 0 p = p\\<close> |\n  \\<open>put_unis (Suc m) p = Forall (put_unis m p)\\<close>"], ["", "lemma sub_put_unis [simp]:\n  \\<open>subst (put_unis k p) (App c []) i = put_unis k (subst p (App c []) (i + k))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. put_unis k p[App c []/i] = put_unis k (p[App c []/i + k])", "by (induct k arbitrary: i) simp_all"], ["", "lemma closed_put_unis [simp]: \\<open>closed m (put_unis k p) = closed (m + k) p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed m (put_unis k p) = closed (m + k) p", "by (induct k arbitrary: m) simp_all"], ["", "lemma valid_put_unis: \\<open>\\<forall>(e :: nat \\<Rightarrow> 'a) f g. eval e f g p \\<Longrightarrow>\n    eval (e :: nat \\<Rightarrow> 'a) f g (put_unis m p)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>e f g. eval e f g p \\<Longrightarrow> eval e f g (put_unis m p)", "by (induct m arbitrary: e) simp_all"], ["", "lemma put_unis_collapse: \\<open>put_unis m (put_unis n p) = put_unis (m + n) p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. put_unis m (put_unis n p) = put_unis (m + n) p", "by (induct m) simp_all"], ["", "fun consts_for_unis :: \\<open>('a, 'b) form \\<Rightarrow> 'a list \\<Rightarrow> ('a, 'b) form\\<close> where\n  \\<open>consts_for_unis (Forall p) (c#cs) = consts_for_unis (subst p (App c []) 0) cs\\<close> |\n  \\<open>consts_for_unis p _ = p\\<close>"], ["", "lemma consts_for_unis: \\<open>[] \\<turnstile> put_unis (length cs) p \\<Longrightarrow>\n  [] \\<turnstile> consts_for_unis (put_unis (length cs) p) cs\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<turnstile> put_unis (length cs) p \\<Longrightarrow>\n    [] \\<turnstile> consts_for_unis (put_unis (length cs) p) cs", "proof (induct cs arbitrary: p)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p.\n       [] \\<turnstile> put_unis (length []) p \\<Longrightarrow>\n       [] \\<turnstile> consts_for_unis (put_unis (length []) p) []\n 2. \\<And>a cs p.\n       \\<lbrakk>\\<And>p.\n                   [] \\<turnstile> put_unis (length cs) p \\<Longrightarrow>\n                   [] \\<turnstile> consts_for_unis (put_unis (length cs) p)\n                                    cs;\n        [] \\<turnstile> put_unis (length (a # cs)) p\\<rbrakk>\n       \\<Longrightarrow> [] \\<turnstile> consts_for_unis\n    (put_unis (length (a # cs)) p) (a # cs)", "case (Cons c cs)"], ["proof (state)\nthis:\n  [] \\<turnstile> put_unis (length cs) ?p \\<Longrightarrow>\n  [] \\<turnstile> consts_for_unis (put_unis (length cs) ?p) cs\n  [] \\<turnstile> put_unis (length (c # cs)) p\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       [] \\<turnstile> put_unis (length []) p \\<Longrightarrow>\n       [] \\<turnstile> consts_for_unis (put_unis (length []) p) []\n 2. \\<And>a cs p.\n       \\<lbrakk>\\<And>p.\n                   [] \\<turnstile> put_unis (length cs) p \\<Longrightarrow>\n                   [] \\<turnstile> consts_for_unis (put_unis (length cs) p)\n                                    cs;\n        [] \\<turnstile> put_unis (length (a # cs)) p\\<rbrakk>\n       \\<Longrightarrow> [] \\<turnstile> consts_for_unis\n    (put_unis (length (a # cs)) p) (a # cs)", "then"], ["proof (chain)\npicking this:\n  [] \\<turnstile> put_unis (length cs) ?p \\<Longrightarrow>\n  [] \\<turnstile> consts_for_unis (put_unis (length cs) ?p) cs\n  [] \\<turnstile> put_unis (length (c # cs)) p", "have \\<open>[] \\<turnstile> Forall (put_unis (length cs) p)\\<close>"], ["proof (prove)\nusing this:\n  [] \\<turnstile> put_unis (length cs) ?p \\<Longrightarrow>\n  [] \\<turnstile> consts_for_unis (put_unis (length cs) ?p) cs\n  [] \\<turnstile> put_unis (length (c # cs)) p\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> Forall (put_unis (length cs) p)", "by simp"], ["proof (state)\nthis:\n  [] \\<turnstile> Forall (put_unis (length cs) p)\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       [] \\<turnstile> put_unis (length []) p \\<Longrightarrow>\n       [] \\<turnstile> consts_for_unis (put_unis (length []) p) []\n 2. \\<And>a cs p.\n       \\<lbrakk>\\<And>p.\n                   [] \\<turnstile> put_unis (length cs) p \\<Longrightarrow>\n                   [] \\<turnstile> consts_for_unis (put_unis (length cs) p)\n                                    cs;\n        [] \\<turnstile> put_unis (length (a # cs)) p\\<rbrakk>\n       \\<Longrightarrow> [] \\<turnstile> consts_for_unis\n    (put_unis (length (a # cs)) p) (a # cs)", "then"], ["proof (chain)\npicking this:\n  [] \\<turnstile> Forall (put_unis (length cs) p)", "have \\<open>[] \\<turnstile> subst (put_unis (length cs) p) (App c []) 0\\<close>"], ["proof (prove)\nusing this:\n  [] \\<turnstile> Forall (put_unis (length cs) p)\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> put_unis (length cs) p[App c []/0]", "using ForallE"], ["proof (prove)\nusing this:\n  [] \\<turnstile> Forall (put_unis (length cs) p)\n  ?G \\<turnstile> Forall ?a \\<Longrightarrow> ?G \\<turnstile> ?a[?t/0]\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> put_unis (length cs) p[App c []/0]", "by blast"], ["proof (state)\nthis:\n  [] \\<turnstile> put_unis (length cs) p[App c []/0]\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       [] \\<turnstile> put_unis (length []) p \\<Longrightarrow>\n       [] \\<turnstile> consts_for_unis (put_unis (length []) p) []\n 2. \\<And>a cs p.\n       \\<lbrakk>\\<And>p.\n                   [] \\<turnstile> put_unis (length cs) p \\<Longrightarrow>\n                   [] \\<turnstile> consts_for_unis (put_unis (length cs) p)\n                                    cs;\n        [] \\<turnstile> put_unis (length (a # cs)) p\\<rbrakk>\n       \\<Longrightarrow> [] \\<turnstile> consts_for_unis\n    (put_unis (length (a # cs)) p) (a # cs)", "then"], ["proof (chain)\npicking this:\n  [] \\<turnstile> put_unis (length cs) p[App c []/0]", "show ?case"], ["proof (prove)\nusing this:\n  [] \\<turnstile> put_unis (length cs) p[App c []/0]\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> consts_for_unis (put_unis (length (c # cs)) p) (c # cs)", "using Cons"], ["proof (prove)\nusing this:\n  [] \\<turnstile> put_unis (length cs) p[App c []/0]\n  [] \\<turnstile> put_unis (length cs) ?p \\<Longrightarrow>\n  [] \\<turnstile> consts_for_unis (put_unis (length cs) ?p) cs\n  [] \\<turnstile> put_unis (length (c # cs)) p\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> consts_for_unis (put_unis (length (c # cs)) p) (c # cs)", "by simp"], ["proof (state)\nthis:\n  [] \\<turnstile> consts_for_unis (put_unis (length (c # cs)) p) (c # cs)\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       [] \\<turnstile> put_unis (length []) p \\<Longrightarrow>\n       [] \\<turnstile> consts_for_unis (put_unis (length []) p) []", "qed simp"], ["", "primrec vars_for_consts :: \\<open>('a, 'b) form \\<Rightarrow> 'a list \\<Rightarrow> ('a, 'b) form\\<close> where\n  \\<open>vars_for_consts p [] = p\\<close> |\n  \\<open>vars_for_consts p (c # cs) = subc c (Var (length cs)) (vars_for_consts p cs)\\<close>"], ["", "lemma vars_for_consts:\n  assumes \\<open>infinite (- params p)\\<close>\n  shows \\<open>[] \\<turnstile> p \\<Longrightarrow> [] \\<turnstile> vars_for_consts p xs\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<turnstile> p \\<Longrightarrow> [] \\<turnstile> vars_for_consts p xs", "using assms deriv_subc"], ["proof (prove)\nusing this:\n  infinite (- params p)\n  \\<lbrakk>infinite UNIV; ?z \\<turnstile> ?p\\<rbrakk>\n  \\<Longrightarrow> subcs ?c ?s ?z \\<turnstile> subc ?c ?s ?p\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> p \\<Longrightarrow> [] \\<turnstile> vars_for_consts p xs", "by (induct xs arbitrary: p) fastforce+"], ["", "lemma vars_for_consts_for_unis:\n  \\<open>closed (length cs) p \\<Longrightarrow> list_all (\\<lambda>c. new c p) cs \\<Longrightarrow> distinct cs \\<Longrightarrow>\n   vars_for_consts (consts_for_unis (put_unis (length cs) p) cs) cs = p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>closed (length cs) p; list_all (\\<lambda>c. new c p) cs;\n     distinct cs\\<rbrakk>\n    \\<Longrightarrow> vars_for_consts\n                       (consts_for_unis (put_unis (length cs) p) cs) cs =\n                      p", "by (induct cs arbitrary: p) (simp_all add: subst_new_all)"], ["", "lemma fresh_constant:\n  fixes p :: \\<open>('a, 'b) form\\<close>\n  assumes \\<open>infinite (UNIV :: 'a set)\\<close>\n  shows \\<open>\\<exists>c. c \\<notin> set cs \\<and> new c p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c. c \\<notin> set cs \\<and> new c p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>c. c \\<notin> set cs \\<and> new c p", "have \\<open>finite (set cs \\<union> params p)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (set cs \\<union> params p)", "by simp"], ["proof (state)\nthis:\n  finite (set cs \\<union> params p)\n\ngoal (1 subgoal):\n 1. \\<exists>c. c \\<notin> set cs \\<and> new c p", "then"], ["proof (chain)\npicking this:\n  finite (set cs \\<union> params p)", "show ?thesis"], ["proof (prove)\nusing this:\n  finite (set cs \\<union> params p)\n\ngoal (1 subgoal):\n 1. \\<exists>c. c \\<notin> set cs \\<and> new c p", "using assms ex_new_if_finite UnI1 UnI2"], ["proof (prove)\nusing this:\n  finite (set cs \\<union> params p)\n  infinite UNIV\n  \\<lbrakk>infinite UNIV; finite ?A\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a. a \\<notin> ?A\n  ?c \\<in> ?A \\<Longrightarrow> ?c \\<in> ?A \\<union> ?B\n  ?c \\<in> ?B \\<Longrightarrow> ?c \\<in> ?A \\<union> ?B\n\ngoal (1 subgoal):\n 1. \\<exists>c. c \\<notin> set cs \\<and> new c p", "by metis"], ["proof (state)\nthis:\n  \\<exists>c. c \\<notin> set cs \\<and> new c p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fresh_constants:\n  fixes p :: \\<open>('a, 'b) form\\<close>\n  assumes \\<open>infinite (UNIV :: 'a set)\\<close>\n  shows \\<open>\\<exists>cs. length cs = m \\<and> list_all (\\<lambda>c. new c p) cs \\<and> distinct cs\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>cs.\n       length cs = m \\<and>\n       list_all (\\<lambda>c. new c p) cs \\<and> distinct cs", "proof (induct m)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>cs.\n       length cs = 0 \\<and>\n       list_all (\\<lambda>c. new c p) cs \\<and> distinct cs\n 2. \\<And>m.\n       \\<exists>cs.\n          length cs = m \\<and>\n          list_all (\\<lambda>c. new c p) cs \\<and>\n          distinct cs \\<Longrightarrow>\n       \\<exists>cs.\n          length cs = Suc m \\<and>\n          list_all (\\<lambda>c. new c p) cs \\<and> distinct cs", "case (Suc m)"], ["proof (state)\nthis:\n  \\<exists>cs.\n     length cs = m \\<and>\n     list_all (\\<lambda>c. new c p) cs \\<and> distinct cs\n\ngoal (2 subgoals):\n 1. \\<exists>cs.\n       length cs = 0 \\<and>\n       list_all (\\<lambda>c. new c p) cs \\<and> distinct cs\n 2. \\<And>m.\n       \\<exists>cs.\n          length cs = m \\<and>\n          list_all (\\<lambda>c. new c p) cs \\<and>\n          distinct cs \\<Longrightarrow>\n       \\<exists>cs.\n          length cs = Suc m \\<and>\n          list_all (\\<lambda>c. new c p) cs \\<and> distinct cs", "then"], ["proof (chain)\npicking this:\n  \\<exists>cs.\n     length cs = m \\<and>\n     list_all (\\<lambda>c. new c p) cs \\<and> distinct cs", "obtain cs where \\<open>length cs = m \\<and> list_all (\\<lambda>c. new c p) cs \\<and> distinct cs\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>cs.\n     length cs = m \\<and>\n     list_all (\\<lambda>c. new c p) cs \\<and> distinct cs\n\ngoal (1 subgoal):\n 1. (\\<And>cs.\n        length cs = m \\<and>\n        list_all (\\<lambda>c. new c p) cs \\<and>\n        distinct cs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  length cs = m \\<and> list_all (\\<lambda>c. new c p) cs \\<and> distinct cs\n\ngoal (2 subgoals):\n 1. \\<exists>cs.\n       length cs = 0 \\<and>\n       list_all (\\<lambda>c. new c p) cs \\<and> distinct cs\n 2. \\<And>m.\n       \\<exists>cs.\n          length cs = m \\<and>\n          list_all (\\<lambda>c. new c p) cs \\<and>\n          distinct cs \\<Longrightarrow>\n       \\<exists>cs.\n          length cs = Suc m \\<and>\n          list_all (\\<lambda>c. new c p) cs \\<and> distinct cs", "moreover"], ["proof (state)\nthis:\n  length cs = m \\<and> list_all (\\<lambda>c. new c p) cs \\<and> distinct cs\n\ngoal (2 subgoals):\n 1. \\<exists>cs.\n       length cs = 0 \\<and>\n       list_all (\\<lambda>c. new c p) cs \\<and> distinct cs\n 2. \\<And>m.\n       \\<exists>cs.\n          length cs = m \\<and>\n          list_all (\\<lambda>c. new c p) cs \\<and>\n          distinct cs \\<Longrightarrow>\n       \\<exists>cs.\n          length cs = Suc m \\<and>\n          list_all (\\<lambda>c. new c p) cs \\<and> distinct cs", "obtain c where \\<open>c \\<notin> set cs \\<and> new c p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c.\n        c \\<notin> set cs \\<and> new c p \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using Suc assms fresh_constant"], ["proof (prove)\nusing this:\n  \\<exists>cs.\n     length cs = m \\<and>\n     list_all (\\<lambda>c. new c p) cs \\<and> distinct cs\n  infinite UNIV\n  infinite UNIV \\<Longrightarrow>\n  \\<exists>c. c \\<notin> set ?cs \\<and> new c ?p\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        c \\<notin> set cs \\<and> new c p \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  c \\<notin> set cs \\<and> new c p\n\ngoal (2 subgoals):\n 1. \\<exists>cs.\n       length cs = 0 \\<and>\n       list_all (\\<lambda>c. new c p) cs \\<and> distinct cs\n 2. \\<And>m.\n       \\<exists>cs.\n          length cs = m \\<and>\n          list_all (\\<lambda>c. new c p) cs \\<and>\n          distinct cs \\<Longrightarrow>\n       \\<exists>cs.\n          length cs = Suc m \\<and>\n          list_all (\\<lambda>c. new c p) cs \\<and> distinct cs", "ultimately"], ["proof (chain)\npicking this:\n  length cs = m \\<and> list_all (\\<lambda>c. new c p) cs \\<and> distinct cs\n  c \\<notin> set cs \\<and> new c p", "have \\<open>length (c # cs) = Suc m \\<and> list_all (\\<lambda>c. new c p) (c # cs) \\<and> distinct (c # cs)\\<close>"], ["proof (prove)\nusing this:\n  length cs = m \\<and> list_all (\\<lambda>c. new c p) cs \\<and> distinct cs\n  c \\<notin> set cs \\<and> new c p\n\ngoal (1 subgoal):\n 1. length (c # cs) = Suc m \\<and>\n    list_all (\\<lambda>c. new c p) (c # cs) \\<and> distinct (c # cs)", "by simp"], ["proof (state)\nthis:\n  length (c # cs) = Suc m \\<and>\n  list_all (\\<lambda>c. new c p) (c # cs) \\<and> distinct (c # cs)\n\ngoal (2 subgoals):\n 1. \\<exists>cs.\n       length cs = 0 \\<and>\n       list_all (\\<lambda>c. new c p) cs \\<and> distinct cs\n 2. \\<And>m.\n       \\<exists>cs.\n          length cs = m \\<and>\n          list_all (\\<lambda>c. new c p) cs \\<and>\n          distinct cs \\<Longrightarrow>\n       \\<exists>cs.\n          length cs = Suc m \\<and>\n          list_all (\\<lambda>c. new c p) cs \\<and> distinct cs", "then"], ["proof (chain)\npicking this:\n  length (c # cs) = Suc m \\<and>\n  list_all (\\<lambda>c. new c p) (c # cs) \\<and> distinct (c # cs)", "show ?case"], ["proof (prove)\nusing this:\n  length (c # cs) = Suc m \\<and>\n  list_all (\\<lambda>c. new c p) (c # cs) \\<and> distinct (c # cs)\n\ngoal (1 subgoal):\n 1. \\<exists>cs.\n       length cs = Suc m \\<and>\n       list_all (\\<lambda>c. new c p) cs \\<and> distinct cs", "by blast"], ["proof (state)\nthis:\n  \\<exists>cs.\n     length cs = Suc m \\<and>\n     list_all (\\<lambda>c. new c p) cs \\<and> distinct cs\n\ngoal (1 subgoal):\n 1. \\<exists>cs.\n       length cs = 0 \\<and>\n       list_all (\\<lambda>c. new c p) cs \\<and> distinct cs", "qed simp"], ["", "lemma closed_max:\n  assumes \\<open>closed m p\\<close> \\<open>closed n q\\<close>\n  shows \\<open>closed (max m n) p \\<and> closed (max m n) q\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed (max m n) p \\<and> closed (max m n) q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. closed (max m n) p \\<and> closed (max m n) q", "have \\<open>m \\<le> max m n\\<close> and \\<open>n \\<le> max m n\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> max m n &&& n \\<le> max m n", "by simp_all"], ["proof (state)\nthis:\n  m \\<le> max m n\n  n \\<le> max m n\n\ngoal (1 subgoal):\n 1. closed (max m n) p \\<and> closed (max m n) q", "then"], ["proof (chain)\npicking this:\n  m \\<le> max m n\n  n \\<le> max m n", "show ?thesis"], ["proof (prove)\nusing this:\n  m \\<le> max m n\n  n \\<le> max m n\n\ngoal (1 subgoal):\n 1. closed (max m n) p \\<and> closed (max m n) q", "using assms closed_mono"], ["proof (prove)\nusing this:\n  m \\<le> max m n\n  n \\<le> max m n\n  closed m p\n  closed n q\n  \\<lbrakk>?i \\<le> ?j; closed ?i ?p\\<rbrakk> \\<Longrightarrow> closed ?j ?p\n\ngoal (1 subgoal):\n 1. closed (max m n) p \\<and> closed (max m n) q", "by metis"], ["proof (state)\nthis:\n  closed (max m n) p \\<and> closed (max m n) q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ex_closed' [simp]:\n  fixes t :: \\<open>'a term\\<close> and l :: \\<open>'a term list\\<close>\n  shows \\<open>\\<exists>m. closedt m t\\<close> \\<open>\\<exists>n. closedts n l\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m. closedt m t &&& \\<exists>n. closedts n l", "proof (induct t and l rule: closedt.induct closedts.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x. \\<exists>m. closedt m (Var x)\n 2. \\<And>x1 x2.\n       \\<exists>n. closedts n x2 \\<Longrightarrow>\n       \\<exists>m. closedt m (App x1 x2)\n 3. \\<exists>n. closedts n []\n 4. \\<And>x1 x2.\n       \\<lbrakk>\\<exists>m. closedt m x1; \\<exists>n. closedts n x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. closedts n (x1 # x2)", "case (Cons_term t l)"], ["proof (state)\nthis:\n  \\<exists>m. closedt m t\n  \\<exists>n. closedts n l\n\ngoal (4 subgoals):\n 1. \\<And>x. \\<exists>m. closedt m (Var x)\n 2. \\<And>x1 x2.\n       \\<exists>n. closedts n x2 \\<Longrightarrow>\n       \\<exists>m. closedt m (App x1 x2)\n 3. \\<exists>n. closedts n []\n 4. \\<And>x1 x2.\n       \\<lbrakk>\\<exists>m. closedt m x1; \\<exists>n. closedts n x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. closedts n (x1 # x2)", "then"], ["proof (chain)\npicking this:\n  \\<exists>m. closedt m t\n  \\<exists>n. closedts n l", "obtain m and n where \\<open>closedt m t\\<close> and \\<open>closedts n l\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>m. closedt m t\n  \\<exists>n. closedts n l\n\ngoal (1 subgoal):\n 1. (\\<And>m n.\n        \\<lbrakk>closedt m t; closedts n l\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  closedt m t\n  closedts n l\n\ngoal (4 subgoals):\n 1. \\<And>x. \\<exists>m. closedt m (Var x)\n 2. \\<And>x1 x2.\n       \\<exists>n. closedts n x2 \\<Longrightarrow>\n       \\<exists>m. closedt m (App x1 x2)\n 3. \\<exists>n. closedts n []\n 4. \\<And>x1 x2.\n       \\<lbrakk>\\<exists>m. closedt m x1; \\<exists>n. closedts n x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. closedts n (x1 # x2)", "moreover"], ["proof (state)\nthis:\n  closedt m t\n  closedts n l\n\ngoal (4 subgoals):\n 1. \\<And>x. \\<exists>m. closedt m (Var x)\n 2. \\<And>x1 x2.\n       \\<exists>n. closedts n x2 \\<Longrightarrow>\n       \\<exists>m. closedt m (App x1 x2)\n 3. \\<exists>n. closedts n []\n 4. \\<And>x1 x2.\n       \\<lbrakk>\\<exists>m. closedt m x1; \\<exists>n. closedts n x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. closedts n (x1 # x2)", "have \\<open>m \\<le> max m n\\<close> and \\<open>n \\<le> max m n\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> max m n &&& n \\<le> max m n", "by simp_all"], ["proof (state)\nthis:\n  m \\<le> max m n\n  n \\<le> max m n\n\ngoal (4 subgoals):\n 1. \\<And>x. \\<exists>m. closedt m (Var x)\n 2. \\<And>x1 x2.\n       \\<exists>n. closedts n x2 \\<Longrightarrow>\n       \\<exists>m. closedt m (App x1 x2)\n 3. \\<exists>n. closedts n []\n 4. \\<And>x1 x2.\n       \\<lbrakk>\\<exists>m. closedt m x1; \\<exists>n. closedts n x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. closedts n (x1 # x2)", "ultimately"], ["proof (chain)\npicking this:\n  closedt m t\n  closedts n l\n  m \\<le> max m n\n  n \\<le> max m n", "have \\<open>closedt (max m n) t\\<close> and \\<open>closedts (max m n) l\\<close>"], ["proof (prove)\nusing this:\n  closedt m t\n  closedts n l\n  m \\<le> max m n\n  n \\<le> max m n\n\ngoal (1 subgoal):\n 1. closedt (max m n) t &&& closedts (max m n) l", "using closedt_mono"], ["proof (prove)\nusing this:\n  closedt m t\n  closedts n l\n  m \\<le> max m n\n  n \\<le> max m n\n  \\<lbrakk>?i \\<le> ?j; closedt ?i ?t\\<rbrakk>\n  \\<Longrightarrow> closedt ?j ?t\n  \\<lbrakk>?i \\<le> ?j; closedts ?i ?ts\\<rbrakk>\n  \\<Longrightarrow> closedts ?j ?ts\n\ngoal (1 subgoal):\n 1. closedt (max m n) t &&& closedts (max m n) l", "by blast+"], ["proof (state)\nthis:\n  closedt (max m n) t\n  closedts (max m n) l\n\ngoal (4 subgoals):\n 1. \\<And>x. \\<exists>m. closedt m (Var x)\n 2. \\<And>x1 x2.\n       \\<exists>n. closedts n x2 \\<Longrightarrow>\n       \\<exists>m. closedt m (App x1 x2)\n 3. \\<exists>n. closedts n []\n 4. \\<And>x1 x2.\n       \\<lbrakk>\\<exists>m. closedt m x1; \\<exists>n. closedts n x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n. closedts n (x1 # x2)", "then"], ["proof (chain)\npicking this:\n  closedt (max m n) t\n  closedts (max m n) l", "show ?case"], ["proof (prove)\nusing this:\n  closedt (max m n) t\n  closedts (max m n) l\n\ngoal (1 subgoal):\n 1. \\<exists>n. closedts n (t # l)", "by auto"], ["proof (state)\nthis:\n  \\<exists>n. closedts n (t # l)\n\ngoal (3 subgoals):\n 1. \\<And>x. \\<exists>m. closedt m (Var x)\n 2. \\<And>x1 x2.\n       \\<exists>n. closedts n x2 \\<Longrightarrow>\n       \\<exists>m. closedt m (App x1 x2)\n 3. \\<exists>n. closedts n []", "qed auto"], ["", "lemma ex_closed [simp]: \\<open>\\<exists>m. closed m p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m. closed m p", "proof (induct p)"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<exists>m. closed m FF\n 2. \\<exists>m. closed m TT\n 3. \\<And>x1 x2. \\<exists>m. closed m (Pred x1 x2)\n 4. \\<And>p1 p2.\n       \\<lbrakk>\\<exists>m. closed m p1; \\<exists>m. closed m p2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m. closed m (And p1 p2)\n 5. \\<And>p1 p2.\n       \\<lbrakk>\\<exists>m. closed m p1; \\<exists>m. closed m p2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m. closed m (Or p1 p2)\n 6. \\<And>p1 p2.\n       \\<lbrakk>\\<exists>m. closed m p1; \\<exists>m. closed m p2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m. closed m (Impl p1 p2)\n 7. \\<And>p.\n       \\<exists>m. closed m p \\<Longrightarrow> \\<exists>m. closed m (Neg p)\n 8. \\<And>p.\n       \\<exists>m. closed m p \\<Longrightarrow>\n       \\<exists>m. closed m (Forall p)\n 9. \\<And>p.\n       \\<exists>m. closed m p \\<Longrightarrow>\n       \\<exists>m. closed m (Exists p)", "case FF"], ["proof (state)\nthis:\n  \n\ngoal (9 subgoals):\n 1. \\<exists>m. closed m FF\n 2. \\<exists>m. closed m TT\n 3. \\<And>x1 x2. \\<exists>m. closed m (Pred x1 x2)\n 4. \\<And>p1 p2.\n       \\<lbrakk>\\<exists>m. closed m p1; \\<exists>m. closed m p2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m. closed m (And p1 p2)\n 5. \\<And>p1 p2.\n       \\<lbrakk>\\<exists>m. closed m p1; \\<exists>m. closed m p2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m. closed m (Or p1 p2)\n 6. \\<And>p1 p2.\n       \\<lbrakk>\\<exists>m. closed m p1; \\<exists>m. closed m p2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m. closed m (Impl p1 p2)\n 7. \\<And>p.\n       \\<exists>m. closed m p \\<Longrightarrow> \\<exists>m. closed m (Neg p)\n 8. \\<And>p.\n       \\<exists>m. closed m p \\<Longrightarrow>\n       \\<exists>m. closed m (Forall p)\n 9. \\<And>p.\n       \\<exists>m. closed m p \\<Longrightarrow>\n       \\<exists>m. closed m (Exists p)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m. closed m FF", "by simp"], ["proof (state)\nthis:\n  \\<exists>m. closed m FF\n\ngoal (8 subgoals):\n 1. \\<exists>m. closed m TT\n 2. \\<And>x1 x2. \\<exists>m. closed m (Pred x1 x2)\n 3. \\<And>p1 p2.\n       \\<lbrakk>\\<exists>m. closed m p1; \\<exists>m. closed m p2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m. closed m (And p1 p2)\n 4. \\<And>p1 p2.\n       \\<lbrakk>\\<exists>m. closed m p1; \\<exists>m. closed m p2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m. closed m (Or p1 p2)\n 5. \\<And>p1 p2.\n       \\<lbrakk>\\<exists>m. closed m p1; \\<exists>m. closed m p2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m. closed m (Impl p1 p2)\n 6. \\<And>p.\n       \\<exists>m. closed m p \\<Longrightarrow> \\<exists>m. closed m (Neg p)\n 7. \\<And>p.\n       \\<exists>m. closed m p \\<Longrightarrow>\n       \\<exists>m. closed m (Forall p)\n 8. \\<And>p.\n       \\<exists>m. closed m p \\<Longrightarrow>\n       \\<exists>m. closed m (Exists p)", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<exists>m. closed m TT\n 2. \\<And>x1 x2. \\<exists>m. closed m (Pred x1 x2)\n 3. \\<And>p1 p2.\n       \\<lbrakk>\\<exists>m. closed m p1; \\<exists>m. closed m p2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m. closed m (And p1 p2)\n 4. \\<And>p1 p2.\n       \\<lbrakk>\\<exists>m. closed m p1; \\<exists>m. closed m p2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m. closed m (Or p1 p2)\n 5. \\<And>p1 p2.\n       \\<lbrakk>\\<exists>m. closed m p1; \\<exists>m. closed m p2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m. closed m (Impl p1 p2)\n 6. \\<And>p.\n       \\<exists>m. closed m p \\<Longrightarrow> \\<exists>m. closed m (Neg p)\n 7. \\<And>p.\n       \\<exists>m. closed m p \\<Longrightarrow>\n       \\<exists>m. closed m (Forall p)\n 8. \\<And>p.\n       \\<exists>m. closed m p \\<Longrightarrow>\n       \\<exists>m. closed m (Exists p)", "case TT"], ["proof (state)\nthis:\n  \n\ngoal (8 subgoals):\n 1. \\<exists>m. closed m TT\n 2. \\<And>x1 x2. \\<exists>m. closed m (Pred x1 x2)\n 3. \\<And>p1 p2.\n       \\<lbrakk>\\<exists>m. closed m p1; \\<exists>m. closed m p2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m. closed m (And p1 p2)\n 4. \\<And>p1 p2.\n       \\<lbrakk>\\<exists>m. closed m p1; \\<exists>m. closed m p2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m. closed m (Or p1 p2)\n 5. \\<And>p1 p2.\n       \\<lbrakk>\\<exists>m. closed m p1; \\<exists>m. closed m p2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m. closed m (Impl p1 p2)\n 6. \\<And>p.\n       \\<exists>m. closed m p \\<Longrightarrow> \\<exists>m. closed m (Neg p)\n 7. \\<And>p.\n       \\<exists>m. closed m p \\<Longrightarrow>\n       \\<exists>m. closed m (Forall p)\n 8. \\<And>p.\n       \\<exists>m. closed m p \\<Longrightarrow>\n       \\<exists>m. closed m (Exists p)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m. closed m TT", "by simp"], ["proof (state)\nthis:\n  \\<exists>m. closed m TT\n\ngoal (7 subgoals):\n 1. \\<And>x1 x2. \\<exists>m. closed m (Pred x1 x2)\n 2. \\<And>p1 p2.\n       \\<lbrakk>\\<exists>m. closed m p1; \\<exists>m. closed m p2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m. closed m (And p1 p2)\n 3. \\<And>p1 p2.\n       \\<lbrakk>\\<exists>m. closed m p1; \\<exists>m. closed m p2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m. closed m (Or p1 p2)\n 4. \\<And>p1 p2.\n       \\<lbrakk>\\<exists>m. closed m p1; \\<exists>m. closed m p2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m. closed m (Impl p1 p2)\n 5. \\<And>p.\n       \\<exists>m. closed m p \\<Longrightarrow> \\<exists>m. closed m (Neg p)\n 6. \\<And>p.\n       \\<exists>m. closed m p \\<Longrightarrow>\n       \\<exists>m. closed m (Forall p)\n 7. \\<And>p.\n       \\<exists>m. closed m p \\<Longrightarrow>\n       \\<exists>m. closed m (Exists p)", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>x1 x2. \\<exists>m. closed m (Pred x1 x2)\n 2. \\<And>p1 p2.\n       \\<lbrakk>\\<exists>m. closed m p1; \\<exists>m. closed m p2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m. closed m (And p1 p2)\n 3. \\<And>p1 p2.\n       \\<lbrakk>\\<exists>m. closed m p1; \\<exists>m. closed m p2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m. closed m (Or p1 p2)\n 4. \\<And>p1 p2.\n       \\<lbrakk>\\<exists>m. closed m p1; \\<exists>m. closed m p2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m. closed m (Impl p1 p2)\n 5. \\<And>p.\n       \\<exists>m. closed m p \\<Longrightarrow> \\<exists>m. closed m (Neg p)\n 6. \\<And>p.\n       \\<exists>m. closed m p \\<Longrightarrow>\n       \\<exists>m. closed m (Forall p)\n 7. \\<And>p.\n       \\<exists>m. closed m p \\<Longrightarrow>\n       \\<exists>m. closed m (Exists p)", "case (Neg p)"], ["proof (state)\nthis:\n  \\<exists>m. closed m p\n\ngoal (7 subgoals):\n 1. \\<And>x1 x2. \\<exists>m. closed m (Pred x1 x2)\n 2. \\<And>p1 p2.\n       \\<lbrakk>\\<exists>m. closed m p1; \\<exists>m. closed m p2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m. closed m (And p1 p2)\n 3. \\<And>p1 p2.\n       \\<lbrakk>\\<exists>m. closed m p1; \\<exists>m. closed m p2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m. closed m (Or p1 p2)\n 4. \\<And>p1 p2.\n       \\<lbrakk>\\<exists>m. closed m p1; \\<exists>m. closed m p2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m. closed m (Impl p1 p2)\n 5. \\<And>p.\n       \\<exists>m. closed m p \\<Longrightarrow> \\<exists>m. closed m (Neg p)\n 6. \\<And>p.\n       \\<exists>m. closed m p \\<Longrightarrow>\n       \\<exists>m. closed m (Forall p)\n 7. \\<And>p.\n       \\<exists>m. closed m p \\<Longrightarrow>\n       \\<exists>m. closed m (Exists p)", "then"], ["proof (chain)\npicking this:\n  \\<exists>m. closed m p", "show ?case"], ["proof (prove)\nusing this:\n  \\<exists>m. closed m p\n\ngoal (1 subgoal):\n 1. \\<exists>m. closed m (Neg p)", "by simp"], ["proof (state)\nthis:\n  \\<exists>m. closed m (Neg p)\n\ngoal (6 subgoals):\n 1. \\<And>x1 x2. \\<exists>m. closed m (Pred x1 x2)\n 2. \\<And>p1 p2.\n       \\<lbrakk>\\<exists>m. closed m p1; \\<exists>m. closed m p2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m. closed m (And p1 p2)\n 3. \\<And>p1 p2.\n       \\<lbrakk>\\<exists>m. closed m p1; \\<exists>m. closed m p2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m. closed m (Or p1 p2)\n 4. \\<And>p1 p2.\n       \\<lbrakk>\\<exists>m. closed m p1; \\<exists>m. closed m p2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m. closed m (Impl p1 p2)\n 5. \\<And>p.\n       \\<exists>m. closed m p \\<Longrightarrow>\n       \\<exists>m. closed m (Forall p)\n 6. \\<And>p.\n       \\<exists>m. closed m p \\<Longrightarrow>\n       \\<exists>m. closed m (Exists p)", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x1 x2. \\<exists>m. closed m (Pred x1 x2)\n 2. \\<And>p1 p2.\n       \\<lbrakk>\\<exists>m. closed m p1; \\<exists>m. closed m p2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m. closed m (And p1 p2)\n 3. \\<And>p1 p2.\n       \\<lbrakk>\\<exists>m. closed m p1; \\<exists>m. closed m p2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m. closed m (Or p1 p2)\n 4. \\<And>p1 p2.\n       \\<lbrakk>\\<exists>m. closed m p1; \\<exists>m. closed m p2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m. closed m (Impl p1 p2)\n 5. \\<And>p.\n       \\<exists>m. closed m p \\<Longrightarrow>\n       \\<exists>m. closed m (Forall p)\n 6. \\<And>p.\n       \\<exists>m. closed m p \\<Longrightarrow>\n       \\<exists>m. closed m (Exists p)", "case (Impl p q)"], ["proof (state)\nthis:\n  \\<exists>m. closed m p\n  \\<exists>m. closed m q\n\ngoal (6 subgoals):\n 1. \\<And>x1 x2. \\<exists>m. closed m (Pred x1 x2)\n 2. \\<And>p1 p2.\n       \\<lbrakk>\\<exists>m. closed m p1; \\<exists>m. closed m p2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m. closed m (And p1 p2)\n 3. \\<And>p1 p2.\n       \\<lbrakk>\\<exists>m. closed m p1; \\<exists>m. closed m p2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m. closed m (Or p1 p2)\n 4. \\<And>p1 p2.\n       \\<lbrakk>\\<exists>m. closed m p1; \\<exists>m. closed m p2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m. closed m (Impl p1 p2)\n 5. \\<And>p.\n       \\<exists>m. closed m p \\<Longrightarrow>\n       \\<exists>m. closed m (Forall p)\n 6. \\<And>p.\n       \\<exists>m. closed m p \\<Longrightarrow>\n       \\<exists>m. closed m (Exists p)", "then"], ["proof (chain)\npicking this:\n  \\<exists>m. closed m p\n  \\<exists>m. closed m q", "show ?case"], ["proof (prove)\nusing this:\n  \\<exists>m. closed m p\n  \\<exists>m. closed m q\n\ngoal (1 subgoal):\n 1. \\<exists>m. closed m (Impl p q)", "using closed_max"], ["proof (prove)\nusing this:\n  \\<exists>m. closed m p\n  \\<exists>m. closed m q\n  \\<lbrakk>closed ?m ?p; closed ?n ?q\\<rbrakk>\n  \\<Longrightarrow> closed (max ?m ?n) ?p \\<and> closed (max ?m ?n) ?q\n\ngoal (1 subgoal):\n 1. \\<exists>m. closed m (Impl p q)", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>m. closed m (Impl p q)\n\ngoal (5 subgoals):\n 1. \\<And>x1 x2. \\<exists>m. closed m (Pred x1 x2)\n 2. \\<And>p1 p2.\n       \\<lbrakk>\\<exists>m. closed m p1; \\<exists>m. closed m p2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m. closed m (And p1 p2)\n 3. \\<And>p1 p2.\n       \\<lbrakk>\\<exists>m. closed m p1; \\<exists>m. closed m p2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m. closed m (Or p1 p2)\n 4. \\<And>p.\n       \\<exists>m. closed m p \\<Longrightarrow>\n       \\<exists>m. closed m (Forall p)\n 5. \\<And>p.\n       \\<exists>m. closed m p \\<Longrightarrow>\n       \\<exists>m. closed m (Exists p)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x1 x2. \\<exists>m. closed m (Pred x1 x2)\n 2. \\<And>p1 p2.\n       \\<lbrakk>\\<exists>m. closed m p1; \\<exists>m. closed m p2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m. closed m (And p1 p2)\n 3. \\<And>p1 p2.\n       \\<lbrakk>\\<exists>m. closed m p1; \\<exists>m. closed m p2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m. closed m (Or p1 p2)\n 4. \\<And>p.\n       \\<exists>m. closed m p \\<Longrightarrow>\n       \\<exists>m. closed m (Forall p)\n 5. \\<And>p.\n       \\<exists>m. closed m p \\<Longrightarrow>\n       \\<exists>m. closed m (Exists p)", "case (Or p q)"], ["proof (state)\nthis:\n  \\<exists>m. closed m p\n  \\<exists>m. closed m q\n\ngoal (5 subgoals):\n 1. \\<And>x1 x2. \\<exists>m. closed m (Pred x1 x2)\n 2. \\<And>p1 p2.\n       \\<lbrakk>\\<exists>m. closed m p1; \\<exists>m. closed m p2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m. closed m (And p1 p2)\n 3. \\<And>p1 p2.\n       \\<lbrakk>\\<exists>m. closed m p1; \\<exists>m. closed m p2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m. closed m (Or p1 p2)\n 4. \\<And>p.\n       \\<exists>m. closed m p \\<Longrightarrow>\n       \\<exists>m. closed m (Forall p)\n 5. \\<And>p.\n       \\<exists>m. closed m p \\<Longrightarrow>\n       \\<exists>m. closed m (Exists p)", "then"], ["proof (chain)\npicking this:\n  \\<exists>m. closed m p\n  \\<exists>m. closed m q", "show ?case"], ["proof (prove)\nusing this:\n  \\<exists>m. closed m p\n  \\<exists>m. closed m q\n\ngoal (1 subgoal):\n 1. \\<exists>m. closed m (Or p q)", "using closed_max"], ["proof (prove)\nusing this:\n  \\<exists>m. closed m p\n  \\<exists>m. closed m q\n  \\<lbrakk>closed ?m ?p; closed ?n ?q\\<rbrakk>\n  \\<Longrightarrow> closed (max ?m ?n) ?p \\<and> closed (max ?m ?n) ?q\n\ngoal (1 subgoal):\n 1. \\<exists>m. closed m (Or p q)", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>m. closed m (Or p q)\n\ngoal (4 subgoals):\n 1. \\<And>x1 x2. \\<exists>m. closed m (Pred x1 x2)\n 2. \\<And>p1 p2.\n       \\<lbrakk>\\<exists>m. closed m p1; \\<exists>m. closed m p2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m. closed m (And p1 p2)\n 3. \\<And>p.\n       \\<exists>m. closed m p \\<Longrightarrow>\n       \\<exists>m. closed m (Forall p)\n 4. \\<And>p.\n       \\<exists>m. closed m p \\<Longrightarrow>\n       \\<exists>m. closed m (Exists p)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1 x2. \\<exists>m. closed m (Pred x1 x2)\n 2. \\<And>p1 p2.\n       \\<lbrakk>\\<exists>m. closed m p1; \\<exists>m. closed m p2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m. closed m (And p1 p2)\n 3. \\<And>p.\n       \\<exists>m. closed m p \\<Longrightarrow>\n       \\<exists>m. closed m (Forall p)\n 4. \\<And>p.\n       \\<exists>m. closed m p \\<Longrightarrow>\n       \\<exists>m. closed m (Exists p)", "case (And p q)"], ["proof (state)\nthis:\n  \\<exists>m. closed m p\n  \\<exists>m. closed m q\n\ngoal (4 subgoals):\n 1. \\<And>x1 x2. \\<exists>m. closed m (Pred x1 x2)\n 2. \\<And>p1 p2.\n       \\<lbrakk>\\<exists>m. closed m p1; \\<exists>m. closed m p2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m. closed m (And p1 p2)\n 3. \\<And>p.\n       \\<exists>m. closed m p \\<Longrightarrow>\n       \\<exists>m. closed m (Forall p)\n 4. \\<And>p.\n       \\<exists>m. closed m p \\<Longrightarrow>\n       \\<exists>m. closed m (Exists p)", "then"], ["proof (chain)\npicking this:\n  \\<exists>m. closed m p\n  \\<exists>m. closed m q", "show ?case"], ["proof (prove)\nusing this:\n  \\<exists>m. closed m p\n  \\<exists>m. closed m q\n\ngoal (1 subgoal):\n 1. \\<exists>m. closed m (And p q)", "using closed_max"], ["proof (prove)\nusing this:\n  \\<exists>m. closed m p\n  \\<exists>m. closed m q\n  \\<lbrakk>closed ?m ?p; closed ?n ?q\\<rbrakk>\n  \\<Longrightarrow> closed (max ?m ?n) ?p \\<and> closed (max ?m ?n) ?q\n\ngoal (1 subgoal):\n 1. \\<exists>m. closed m (And p q)", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>m. closed m (And p q)\n\ngoal (3 subgoals):\n 1. \\<And>x1 x2. \\<exists>m. closed m (Pred x1 x2)\n 2. \\<And>p.\n       \\<exists>m. closed m p \\<Longrightarrow>\n       \\<exists>m. closed m (Forall p)\n 3. \\<And>p.\n       \\<exists>m. closed m p \\<Longrightarrow>\n       \\<exists>m. closed m (Exists p)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1 x2. \\<exists>m. closed m (Pred x1 x2)\n 2. \\<And>p.\n       \\<exists>m. closed m p \\<Longrightarrow>\n       \\<exists>m. closed m (Forall p)\n 3. \\<And>p.\n       \\<exists>m. closed m p \\<Longrightarrow>\n       \\<exists>m. closed m (Exists p)", "case (Exists p)"], ["proof (state)\nthis:\n  \\<exists>m. closed m p\n\ngoal (3 subgoals):\n 1. \\<And>x1 x2. \\<exists>m. closed m (Pred x1 x2)\n 2. \\<And>p.\n       \\<exists>m. closed m p \\<Longrightarrow>\n       \\<exists>m. closed m (Forall p)\n 3. \\<And>p.\n       \\<exists>m. closed m p \\<Longrightarrow>\n       \\<exists>m. closed m (Exists p)", "then"], ["proof (chain)\npicking this:\n  \\<exists>m. closed m p", "obtain m where \\<open>closed m p\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>m. closed m p\n\ngoal (1 subgoal):\n 1. (\\<And>m. closed m p \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  closed m p\n\ngoal (3 subgoals):\n 1. \\<And>x1 x2. \\<exists>m. closed m (Pred x1 x2)\n 2. \\<And>p.\n       \\<exists>m. closed m p \\<Longrightarrow>\n       \\<exists>m. closed m (Forall p)\n 3. \\<And>p.\n       \\<exists>m. closed m p \\<Longrightarrow>\n       \\<exists>m. closed m (Exists p)", "then"], ["proof (chain)\npicking this:\n  closed m p", "have \\<open>closed (Suc m) p\\<close>"], ["proof (prove)\nusing this:\n  closed m p\n\ngoal (1 subgoal):\n 1. closed (Suc m) p", "using closed_mono Suc_n_not_le_n nat_le_linear"], ["proof (prove)\nusing this:\n  closed m p\n  \\<lbrakk>?i \\<le> ?j; closed ?i ?p\\<rbrakk> \\<Longrightarrow> closed ?j ?p\n  \\<not> Suc ?n \\<le> ?n\n  ?m \\<le> ?n \\<or> ?n \\<le> ?m\n\ngoal (1 subgoal):\n 1. closed (Suc m) p", "by blast"], ["proof (state)\nthis:\n  closed (Suc m) p\n\ngoal (3 subgoals):\n 1. \\<And>x1 x2. \\<exists>m. closed m (Pred x1 x2)\n 2. \\<And>p.\n       \\<exists>m. closed m p \\<Longrightarrow>\n       \\<exists>m. closed m (Forall p)\n 3. \\<And>p.\n       \\<exists>m. closed m p \\<Longrightarrow>\n       \\<exists>m. closed m (Exists p)", "then"], ["proof (chain)\npicking this:\n  closed (Suc m) p", "show ?case"], ["proof (prove)\nusing this:\n  closed (Suc m) p\n\ngoal (1 subgoal):\n 1. \\<exists>m. closed m (Exists p)", "by auto"], ["proof (state)\nthis:\n  \\<exists>m. closed m (Exists p)\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2. \\<exists>m. closed m (Pred x1 x2)\n 2. \\<And>p.\n       \\<exists>m. closed m p \\<Longrightarrow>\n       \\<exists>m. closed m (Forall p)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 x2. \\<exists>m. closed m (Pred x1 x2)\n 2. \\<And>p.\n       \\<exists>m. closed m p \\<Longrightarrow>\n       \\<exists>m. closed m (Forall p)", "case (Forall p)"], ["proof (state)\nthis:\n  \\<exists>m. closed m p\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2. \\<exists>m. closed m (Pred x1 x2)\n 2. \\<And>p.\n       \\<exists>m. closed m p \\<Longrightarrow>\n       \\<exists>m. closed m (Forall p)", "then"], ["proof (chain)\npicking this:\n  \\<exists>m. closed m p", "obtain m where \\<open>closed m p\\<close>"], ["proof (prove)\nusing this:\n  \\<exists>m. closed m p\n\ngoal (1 subgoal):\n 1. (\\<And>m. closed m p \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  closed m p\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2. \\<exists>m. closed m (Pred x1 x2)\n 2. \\<And>p.\n       \\<exists>m. closed m p \\<Longrightarrow>\n       \\<exists>m. closed m (Forall p)", "then"], ["proof (chain)\npicking this:\n  closed m p", "have \\<open>closed (Suc m) p\\<close>"], ["proof (prove)\nusing this:\n  closed m p\n\ngoal (1 subgoal):\n 1. closed (Suc m) p", "using closed_mono Suc_n_not_le_n nat_le_linear"], ["proof (prove)\nusing this:\n  closed m p\n  \\<lbrakk>?i \\<le> ?j; closed ?i ?p\\<rbrakk> \\<Longrightarrow> closed ?j ?p\n  \\<not> Suc ?n \\<le> ?n\n  ?m \\<le> ?n \\<or> ?n \\<le> ?m\n\ngoal (1 subgoal):\n 1. closed (Suc m) p", "by blast"], ["proof (state)\nthis:\n  closed (Suc m) p\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2. \\<exists>m. closed m (Pred x1 x2)\n 2. \\<And>p.\n       \\<exists>m. closed m p \\<Longrightarrow>\n       \\<exists>m. closed m (Forall p)", "then"], ["proof (chain)\npicking this:\n  closed (Suc m) p", "show ?case"], ["proof (prove)\nusing this:\n  closed (Suc m) p\n\ngoal (1 subgoal):\n 1. \\<exists>m. closed m (Forall p)", "by auto"], ["proof (state)\nthis:\n  \\<exists>m. closed m (Forall p)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2. \\<exists>m. closed m (Pred x1 x2)", "qed simp_all"], ["", "lemma ex_closure: \\<open>\\<exists>m. closed 0 (put_unis m p)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m. closed 0 (put_unis m p)", "by simp"], ["", "lemma remove_unis_sentence:\n  assumes inf_params: \\<open>infinite (- params p)\\<close>\n    and \\<open>closed 0 (put_unis m p)\\<close> \\<open>[] \\<turnstile> put_unis m p\\<close>\n  shows \\<open>[] \\<turnstile> p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<turnstile> p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. [] \\<turnstile> p", "obtain cs :: \\<open>'a list\\<close> where \\<open>length cs = m\\<close>\n    and *: \\<open>distinct cs\\<close> and **: \\<open>list_all (\\<lambda>c. new c p) cs\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>cs.\n        \\<lbrakk>length cs = m; distinct cs;\n         list_all (\\<lambda>c. new c p) cs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms finite_compl finite_params fresh_constants inf_params"], ["proof (prove)\nusing this:\n  infinite (- params p)\n  closed 0 (put_unis m p)\n  [] \\<turnstile> put_unis m p\n  finite ?A \\<Longrightarrow> finite (- ?A) = finite UNIV\n  finite (params ?p)\n  infinite UNIV \\<Longrightarrow>\n  \\<exists>cs.\n     length cs = ?m \\<and>\n     list_all (\\<lambda>c. new c ?p) cs \\<and> distinct cs\n  infinite (- params p)\n\ngoal (1 subgoal):\n 1. (\\<And>cs.\n        \\<lbrakk>length cs = m; distinct cs;\n         list_all (\\<lambda>c. new c p) cs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  length cs = m\n  distinct cs\n  list_all (\\<lambda>c. new c p) cs\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> p", "then"], ["proof (chain)\npicking this:\n  length cs = m\n  distinct cs\n  list_all (\\<lambda>c. new c p) cs", "have \\<open>[] \\<turnstile> consts_for_unis (put_unis (length cs) p) cs\\<close>"], ["proof (prove)\nusing this:\n  length cs = m\n  distinct cs\n  list_all (\\<lambda>c. new c p) cs\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> consts_for_unis (put_unis (length cs) p) cs", "using assms consts_for_unis"], ["proof (prove)\nusing this:\n  length cs = m\n  distinct cs\n  list_all (\\<lambda>c. new c p) cs\n  infinite (- params p)\n  closed 0 (put_unis m p)\n  [] \\<turnstile> put_unis m p\n  [] \\<turnstile> put_unis (length ?cs) ?p \\<Longrightarrow>\n  [] \\<turnstile> consts_for_unis (put_unis (length ?cs) ?p) ?cs\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> consts_for_unis (put_unis (length cs) p) cs", "by blast"], ["proof (state)\nthis:\n  [] \\<turnstile> consts_for_unis (put_unis (length cs) p) cs\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> p", "then"], ["proof (chain)\npicking this:\n  [] \\<turnstile> consts_for_unis (put_unis (length cs) p) cs", "have \\<open>[] \\<turnstile> vars_for_consts (consts_for_unis (put_unis (length cs) p) cs) cs\\<close>"], ["proof (prove)\nusing this:\n  [] \\<turnstile> consts_for_unis (put_unis (length cs) p) cs\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> vars_for_consts\n                     (consts_for_unis (put_unis (length cs) p) cs) cs", "using vars_for_consts inf_params"], ["proof (prove)\nusing this:\n  [] \\<turnstile> consts_for_unis (put_unis (length cs) p) cs\n  \\<lbrakk>infinite (- params ?p); [] \\<turnstile> ?p\\<rbrakk>\n  \\<Longrightarrow> [] \\<turnstile> vars_for_consts ?p ?xs\n  infinite (- params p)\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> vars_for_consts\n                     (consts_for_unis (put_unis (length cs) p) cs) cs", "by fastforce"], ["proof (state)\nthis:\n  [] \\<turnstile> vars_for_consts\n                   (consts_for_unis (put_unis (length cs) p) cs) cs\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> p", "moreover"], ["proof (state)\nthis:\n  [] \\<turnstile> vars_for_consts\n                   (consts_for_unis (put_unis (length cs) p) cs) cs\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> p", "have \\<open>closed (length cs) p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. closed (length cs) p", "using assms \\<open>length cs = m\\<close>"], ["proof (prove)\nusing this:\n  infinite (- params p)\n  closed 0 (put_unis m p)\n  [] \\<turnstile> put_unis m p\n  length cs = m\n\ngoal (1 subgoal):\n 1. closed (length cs) p", "by simp"], ["proof (state)\nthis:\n  closed (length cs) p\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> p", "ultimately"], ["proof (chain)\npicking this:\n  [] \\<turnstile> vars_for_consts\n                   (consts_for_unis (put_unis (length cs) p) cs) cs\n  closed (length cs) p", "show \\<open>[] \\<turnstile> p\\<close>"], ["proof (prove)\nusing this:\n  [] \\<turnstile> vars_for_consts\n                   (consts_for_unis (put_unis (length cs) p) cs) cs\n  closed (length cs) p\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> p", "using vars_for_consts_for_unis * **"], ["proof (prove)\nusing this:\n  [] \\<turnstile> vars_for_consts\n                   (consts_for_unis (put_unis (length cs) p) cs) cs\n  closed (length cs) p\n  \\<lbrakk>closed (length ?cs) ?p; list_all (\\<lambda>c. new c ?p) ?cs;\n   distinct ?cs\\<rbrakk>\n  \\<Longrightarrow> vars_for_consts\n                     (consts_for_unis (put_unis (length ?cs) ?p) ?cs) ?cs =\n                    ?p\n  distinct cs\n  list_all (\\<lambda>c. new c p) cs\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> p", "by metis"], ["proof (state)\nthis:\n  [] \\<turnstile> p\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Completeness\\<close>"], ["", "theorem completeness:\n  fixes p :: \\<open>(nat, nat) form\\<close>\n  assumes \\<open>\\<forall>(e :: nat \\<Rightarrow> nat hterm) f g. e, f, g, z \\<Turnstile> p\\<close>\n  shows \\<open>z \\<turnstile> p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<turnstile> p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. z \\<turnstile> p", "let ?p = \\<open>put_imps p (rev z)\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. z \\<turnstile> p", "have *: \\<open>\\<forall>(e :: nat \\<Rightarrow> nat hterm) f g. eval e f g ?p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>e f g. eval e f g (put_imps p (rev z))", "using assms semantics_put_imps"], ["proof (prove)\nusing this:\n  \\<forall>e f g. e,f,g,z \\<Turnstile> p\n  (?e,?f,?g,?z \\<Turnstile> ?p) = eval ?e ?f ?g (put_imps ?p ?z)\n\ngoal (1 subgoal):\n 1. \\<forall>e f g. eval e f g (put_imps p (rev z))", "unfolding model_def"], ["proof (prove)\nusing this:\n  \\<forall>e f g. list_all (eval e f g) z \\<longrightarrow> eval e f g p\n  (list_all (eval ?e ?f ?g) ?z \\<longrightarrow> eval ?e ?f ?g ?p) =\n  eval ?e ?f ?g (put_imps ?p ?z)\n\ngoal (1 subgoal):\n 1. \\<forall>e f g. eval e f g (put_imps p (rev z))", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>e f g. eval e f g (put_imps p (rev z))\n\ngoal (1 subgoal):\n 1. z \\<turnstile> p", "obtain m where **: \\<open>closed 0 (put_unis m ?p)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m.\n        closed 0 (put_unis m (put_imps p (rev z))) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using ex_closure"], ["proof (prove)\nusing this:\n  \\<exists>m. closed 0 (put_unis m ?p)\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        closed 0 (put_unis m (put_imps p (rev z))) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  closed 0 (put_unis m (put_imps p (rev z)))\n\ngoal (1 subgoal):\n 1. z \\<turnstile> p", "moreover"], ["proof (state)\nthis:\n  closed 0 (put_unis m (put_imps p (rev z)))\n\ngoal (1 subgoal):\n 1. z \\<turnstile> p", "have \\<open>list_all (closed 0) []\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (closed 0) []", "by simp"], ["proof (state)\nthis:\n  list_all (closed 0) []\n\ngoal (1 subgoal):\n 1. z \\<turnstile> p", "moreover"], ["proof (state)\nthis:\n  list_all (closed 0) []\n\ngoal (1 subgoal):\n 1. z \\<turnstile> p", "have \\<open>\\<forall>(e :: nat \\<Rightarrow> nat hterm) f g. e, f, g, [] \\<Turnstile> put_unis m ?p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>e f g. e,f,g,[] \\<Turnstile> put_unis m (put_imps p (rev z))", "using * valid_put_unis"], ["proof (prove)\nusing this:\n  \\<forall>e f g. eval e f g (put_imps p (rev z))\n  \\<forall>e f g. eval e f g ?p \\<Longrightarrow>\n  eval ?e ?f ?g (put_unis ?m ?p)\n\ngoal (1 subgoal):\n 1. \\<forall>e f g. e,f,g,[] \\<Turnstile> put_unis m (put_imps p (rev z))", "unfolding model_def"], ["proof (prove)\nusing this:\n  \\<forall>e f g. eval e f g (put_imps p (rev z))\n  \\<forall>e f g. eval e f g ?p \\<Longrightarrow>\n  eval ?e ?f ?g (put_unis ?m ?p)\n\ngoal (1 subgoal):\n 1. \\<forall>e f g.\n       list_all (eval e f g) [] \\<longrightarrow>\n       eval e f g (put_unis m (put_imps p (rev z)))", "by blast"], ["proof (state)\nthis:\n  \\<forall>e f g. e,f,g,[] \\<Turnstile> put_unis m (put_imps p (rev z))\n\ngoal (1 subgoal):\n 1. z \\<turnstile> p", "ultimately"], ["proof (chain)\npicking this:\n  closed 0 (put_unis m (put_imps p (rev z)))\n  list_all (closed 0) []\n  \\<forall>e f g. e,f,g,[] \\<Turnstile> put_unis m (put_imps p (rev z))", "have \\<open>[] \\<turnstile> put_unis m ?p\\<close>"], ["proof (prove)\nusing this:\n  closed 0 (put_unis m (put_imps p (rev z)))\n  list_all (closed 0) []\n  \\<forall>e f g. e,f,g,[] \\<Turnstile> put_unis m (put_imps p (rev z))\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> put_unis m (put_imps p (rev z))", "using natded_complete"], ["proof (prove)\nusing this:\n  closed 0 (put_unis m (put_imps p (rev z)))\n  list_all (closed 0) []\n  \\<forall>e f g. e,f,g,[] \\<Turnstile> put_unis m (put_imps p (rev z))\n  \\<lbrakk>closed 0 ?p; list_all (closed 0) ?ps;\n   \\<forall>e f g. e,f,g,?ps \\<Turnstile> ?p\\<rbrakk>\n  \\<Longrightarrow> ?ps \\<turnstile> ?p\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> put_unis m (put_imps p (rev z))", "by blast"], ["proof (state)\nthis:\n  [] \\<turnstile> put_unis m (put_imps p (rev z))\n\ngoal (1 subgoal):\n 1. z \\<turnstile> p", "then"], ["proof (chain)\npicking this:\n  [] \\<turnstile> put_unis m (put_imps p (rev z))", "have \\<open>[] \\<turnstile> ?p\\<close>"], ["proof (prove)\nusing this:\n  [] \\<turnstile> put_unis m (put_imps p (rev z))\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> put_imps p (rev z)", "using ** remove_unis_sentence"], ["proof (prove)\nusing this:\n  [] \\<turnstile> put_unis m (put_imps p (rev z))\n  closed 0 (put_unis m (put_imps p (rev z)))\n  \\<lbrakk>infinite (- params ?p); closed 0 (put_unis ?m ?p);\n   [] \\<turnstile> put_unis ?m ?p\\<rbrakk>\n  \\<Longrightarrow> [] \\<turnstile> ?p\n\ngoal (1 subgoal):\n 1. [] \\<turnstile> put_imps p (rev z)", "by fastforce"], ["proof (state)\nthis:\n  [] \\<turnstile> put_imps p (rev z)\n\ngoal (1 subgoal):\n 1. z \\<turnstile> p", "then"], ["proof (chain)\npicking this:\n  [] \\<turnstile> put_imps p (rev z)", "show \\<open>z \\<turnstile> p\\<close>"], ["proof (prove)\nusing this:\n  [] \\<turnstile> put_imps p (rev z)\n\ngoal (1 subgoal):\n 1. z \\<turnstile> p", "using remove_imps"], ["proof (prove)\nusing this:\n  [] \\<turnstile> put_imps p (rev z)\n  \\<lbrakk>infinite (- params ?p); ?z' \\<turnstile> put_imps ?p ?z\\<rbrakk>\n  \\<Longrightarrow> rev ?z @ ?z' \\<turnstile> ?p\n\ngoal (1 subgoal):\n 1. z \\<turnstile> p", "by fastforce"], ["proof (state)\nthis:\n  z \\<turnstile> p\n\ngoal:\nNo subgoals!", "qed"], ["", "abbreviation \\<open>valid p \\<equiv> \\<forall>(e :: nat \\<Rightarrow> nat hterm) f g. eval e f g p\\<close>"], ["", "proposition\n  fixes p :: \\<open>(nat, nat) form\\<close>\n  shows \\<open>valid p \\<Longrightarrow> eval e f g p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid p \\<Longrightarrow> eval e f g p", "using completeness correctness"], ["proof (prove)\nusing this:\n  \\<forall>e f g. e,f,g,?z \\<Turnstile> ?p \\<Longrightarrow>\n  ?z \\<turnstile> ?p\n  ?G \\<turnstile> ?p \\<Longrightarrow>\n  \\<forall>e f g. e,f,g,?G \\<Turnstile> ?p\n\ngoal (1 subgoal):\n 1. valid p \\<Longrightarrow> eval e f g p", "unfolding model_def"], ["proof (prove)\nusing this:\n  \\<forall>e f g.\n     list_all (eval e f g) ?z \\<longrightarrow>\n     eval e f g ?p \\<Longrightarrow>\n  ?z \\<turnstile> ?p\n  ?G \\<turnstile> ?p \\<Longrightarrow>\n  \\<forall>e f g. list_all (eval e f g) ?G \\<longrightarrow> eval e f g ?p\n\ngoal (1 subgoal):\n 1. valid p \\<Longrightarrow> eval e f g p", "by (metis list.pred_inject(1))"], ["", "proposition\n  fixes p :: \\<open>(nat, nat) form\\<close>\n  shows \\<open>([] \\<turnstile> p) = valid p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. ([] \\<turnstile> p) = valid p", "using completeness correctness"], ["proof (prove)\nusing this:\n  \\<forall>e f g. e,f,g,?z \\<Turnstile> ?p \\<Longrightarrow>\n  ?z \\<turnstile> ?p\n  ?G \\<turnstile> ?p \\<Longrightarrow>\n  \\<forall>e f g. e,f,g,?G \\<Turnstile> ?p\n\ngoal (1 subgoal):\n 1. ([] \\<turnstile> p) = valid p", "unfolding model_def"], ["proof (prove)\nusing this:\n  \\<forall>e f g.\n     list_all (eval e f g) ?z \\<longrightarrow>\n     eval e f g ?p \\<Longrightarrow>\n  ?z \\<turnstile> ?p\n  ?G \\<turnstile> ?p \\<Longrightarrow>\n  \\<forall>e f g. list_all (eval e f g) ?G \\<longrightarrow> eval e f g ?p\n\ngoal (1 subgoal):\n 1. ([] \\<turnstile> p) = valid p", "by fastforce"], ["", "corollary \\<open>\\<forall>e (f::nat \\<Rightarrow> nat hterm list \\<Rightarrow> nat hterm) (g::nat \\<Rightarrow> nat hterm list \\<Rightarrow> bool).\n    e,f,g,ps \\<Turnstile> p \\<Longrightarrow> ps \\<turnstile> p\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>e f g. e,f,g,ps \\<Turnstile> p \\<Longrightarrow>\n    ps \\<turnstile> p", "by (rule completeness)"], ["", "end"]]}