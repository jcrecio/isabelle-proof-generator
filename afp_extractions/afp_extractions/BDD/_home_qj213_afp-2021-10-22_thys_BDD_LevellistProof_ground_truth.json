{"file_name": "/home/qj213/afp-2021-10-22/thys/BDD/LevellistProof.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/BDD", "problem_names": ["lemma (in Levellist_impl) Levellist_modifies:\n  shows \"\\<forall>\\<sigma>. \\<Gamma>\\<turnstile>{\\<sigma>} \\<acute>levellist :== PROC Levellist (\\<acute>p, \\<acute>m, \\<acute>levellist)\n             {t. t may_only_modify_globals \\<sigma> in [mark,next]}\"", "lemma all_stop_cong: \"(\\<forall>x. P x) = (\\<forall>x. P x)\"", "lemma Dag_RefD:\n  \"\\<lbrakk>Dag p l r t; p\\<noteq>Null\\<rbrakk> \\<Longrightarrow>\n    \\<exists>lt rt. t=Node lt p rt \\<and> Dag (l p) l r lt \\<and> Dag (r p) l r rt\"", "lemma Dag_unique_ex_conjI:\n  \"\\<lbrakk>Dag p l r t;   P t\\<rbrakk> \\<Longrightarrow> (\\<exists>t. Dag p l r t \\<and> P t)\"", "lemma dag_Null [simp]: \"dag Null l r = Tip\"", "lemma first_simps [simp]:\n \"first [] = Null\"\n \"first (r#rs) = r\"", "lemma Levellist_unique:\n  assumes ll: \"Levellist hds next ll\"\n  assumes ll': \"Levellist hds next ll'\"\n  shows \"ll=ll'\"", "lemma Levellist_unique_ex_conj_simp [simp]:\n\"Levellist hds next ll \\<Longrightarrow> (\\<exists>ll. Levellist hds next ll \\<and> P ll) = P ll\"", "lemma in_set_concat_idx:\n  \"x \\<in> set (concat xss) \\<Longrightarrow> \\<exists>i < length xss. x \\<in> set (xss!i)\"", "lemma wf_levellist_subset:\n  assumes wf_ll: \"wf_levellist t ll ll' var\"\n  shows \"set (concat ll') \\<subseteq>  set (concat ll) \\<union> set_of t\"", "lemma Levellist_ext_to_all: \"((\\<exists>ll. Levellist hds next ll \\<and> P ll) \\<longrightarrow> Q)\n       =\n       (\\<forall>ll. Levellist hds next ll \\<and> P ll \\<longrightarrow> Q)\"", "lemma Levellist_length: \"Levellist hds p ll \\<Longrightarrow> length ll = length hds\"", "lemma map_update:\n  \"\\<And>i. i < length xss \\<Longrightarrow> map f (xss[i := xs]) = (map f xss) [i := f xs]\"", "lemma (in Levellist_impl) Levellist_spec_total':\nshows \"\\<forall>ll \\<sigma> t. \\<Gamma>,\\<Theta>\\<turnstile>\\<^sub>t\n        \\<lbrace>\\<sigma>. Dag \\<acute>p \\<acute>low \\<acute>high t \\<and> (\\<acute>p \\<noteq> Null \\<longrightarrow> (\\<acute>p\\<rightarrow>\\<acute>var) < length \\<acute>levellist) \\<and>\n             ordered t \\<acute>var \\<and> Levellist \\<acute>levellist \\<acute>next ll \\<and>\n             (\\<forall>n \\<in> set_of t.\n              (if \\<acute>mark n = \\<acute>m\n               then n \\<in> set (ll ! \\<acute>var n) \\<and>\n                    (\\<forall>nt p. Dag n \\<acute>low \\<acute>high nt \\<and> p \\<in> set_of nt\n                     \\<longrightarrow> \\<acute>mark p = \\<acute>m)\n               else n \\<notin> set (concat ll)))\\<rbrace>\n          \\<acute>levellist :== PROC Levellist (\\<acute>p, \\<acute>m, \\<acute>levellist)\n       \\<lbrace>\\<exists>ll'. Levellist \\<acute>levellist \\<acute>next ll' \\<and> wf_levellist t ll ll' \\<^bsup>\\<sigma>\\<^esup>var \\<and>\n        wf_marking t  \\<^bsup>\\<sigma>\\<^esup>mark \\<acute>mark \\<^bsup>\\<sigma>\\<^esup>m \\<and>\n        (\\<forall>p. p \\<notin> set_of t \\<longrightarrow> \\<^bsup>\\<sigma>\\<^esup>next p = \\<acute>next p)\n        \\<rbrace>\"", "lemma allD: \"\\<forall>ll. P ll \\<Longrightarrow> P ll\"", "lemma replicate_spec: \"\\<lbrakk>\\<forall>i < n. xs ! i = x; n=length xs\\<rbrakk>\n  \\<Longrightarrow> replicate (length xs) x = xs\"", "lemma (in Levellist_impl) Levellist_spec_total:\nshows \"\\<forall>\\<sigma> t. \\<Gamma>,\\<Theta>\\<turnstile>\\<^sub>t\n        \\<lbrace>\\<sigma>. Dag \\<acute>p \\<acute>low \\<acute>high t \\<and> (\\<forall>i < length \\<acute>levellist. \\<acute>levellist ! i = Null) \\<and>\n             length \\<acute>levellist  = \\<acute>p \\<rightarrow> \\<acute>var + 1 \\<and>\n             ordered t \\<acute>var \\<and> (\\<forall>n \\<in> set_of t. \\<acute>mark n = (\\<not> \\<acute>m) )\\<rbrace>\n          \\<acute>levellist :== PROC Levellist (\\<acute>p, \\<acute>m, \\<acute>levellist)\n       \\<lbrace>\\<exists>ll. Levellist \\<acute>levellist \\<acute>next ll \\<and> wf_ll t ll \\<^bsup>\\<sigma>\\<^esup>var  \\<and>\n         length \\<acute>levellist = \\<^bsup>\\<sigma>\\<^esup>p \\<rightarrow> \\<^bsup>\\<sigma>\\<^esup>var + 1 \\<and>\n         wf_marking t \\<^bsup>\\<sigma>\\<^esup>mark \\<acute>mark \\<^bsup>\\<sigma>\\<^esup>m \\<and>\n         (\\<forall>p. p \\<notin> set_of t \\<longrightarrow> \\<^bsup>\\<sigma>\\<^esup>next p = \\<acute>next p)\\<rbrace>\""], "translations": [["", "lemma (in Levellist_impl) Levellist_modifies:\n  shows \"\\<forall>\\<sigma>. \\<Gamma>\\<turnstile>{\\<sigma>} \\<acute>levellist :== PROC Levellist (\\<acute>p, \\<acute>m, \\<acute>levellist)\n             {t. t may_only_modify_globals \\<sigma> in [mark,next]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>\n          \\<turnstile> {\\<sigma>}\n                       \\<acute>levellist :== PROC Levellist(\\<acute>p,\n                       \\<acute>m,\\<acute>levellist)\n                       {t. t may_only_modify_globals \\<sigma> in [mark,\n                        next]}", "apply (hoare_rule HoarePartial.ProcRec1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       \\<Gamma>,(\\<Union>\\<sigma>.\n                    {({\\<sigma>}, Levellist_'proc,\n                      {t. t may_only_modify_globals \\<sigma> in [mark,\n                       next]},\n                      {})})\n          \\<turnstile> {\\<sigma>}\n                       IF \\<acute>p \\<noteq> Null\n                       THEN IF \\<acute>p\\<rightarrow>\\<acute>mark \\<noteq>\n                               \\<acute>m\n                            THEN \\<acute>levellist :== CALL Levellist(\\<acute>p\\<rightarrow>\\<acute>low,\n                              \\<acute>m,\\<acute>levellist);;\n                              \\<acute>levellist :== CALL Levellist(\\<acute>p\\<rightarrow>\\<acute>high,\n                              \\<acute>m,\\<acute>levellist);;\n                              \\<acute>p\\<rightarrow>\\<acute>next :==\n                              \\<acute>levellist !\n                              (\\<acute>p\\<rightarrow>\\<acute>var);;\n                              \\<acute>levellist !\n                              (\\<acute>p\\<rightarrow>\\<acute>var) :==\n                              \\<acute>p;;\n                              \\<acute>p\\<rightarrow>\\<acute>mark :==\n                              \\<acute>m\n                            FI\n                       FI\n                       {t. t may_only_modify_globals \\<sigma> in [mark,\n                        next]}", "apply (vcg spec=modifies)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*a well formed levellist is a list that contains all nodes with variable\ni on position i\nbecause the elements of levellist can contain old elements before the call of Levellist,\nsubdag_eq t pt can not be postulated for all elements of the sublists. One has to make\nshure that the initial call of Levellist is parameterized with a levellist with empty sublists.\nOtherwise some problems could arise in the call of Reduce!\n(\\<exists> ptt. (Dag pt low high ptt \\<and> subdag_eq (Node lt p rt) ptt \\<and> pt\\<rightarrow>var = i))\nconsts wf_levellist :: \"dag \\<Rightarrow> ref list list \\<Rightarrow> ref list list \\<Rightarrow>\n                        (ref \\<Rightarrow> nat) \\<Rightarrow> (ref \\<Rightarrow> ref) \\<Rightarrow> (ref \\<Rightarrow> ref) \\<Rightarrow> bool\"\ndefs wf_levellist_def: \"wf_levellist t levellist_old levellist_new var low high \\<equiv>\ncase t of Tip \\<Rightarrow> levellist_old = levellist_new\n| (Node lt p rt) \\<Rightarrow>\n  (\\<forall> q. q \\<in> set_of t \\<longrightarrow> q \\<in> set (levellist_new ! (q\\<rightarrow>var))) \\<and>\n  (\\<forall> i \\<le> p\\<rightarrow>var. (\\<exists> prx. (levellist_new ! i) = prx@(levellist_old ! i)\n                       \\<and> (\\<forall> pt \\<in> set prx. pt \\<in> set_of t \\<and> pt\\<rightarrow>var = i))) \\<and>\n  (\\<forall> i. (p\\<rightarrow>var) < i \\<longrightarrow> (levellist_new ! i) = (levellist_old ! i)) \\<and>\n  (length levellist_new = length levellist_old)\"\n*)"], ["", "lemma all_stop_cong: \"(\\<forall>x. P x) = (\\<forall>x. P x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x. P x) = (\\<forall>x. P x)", "by simp"], ["", "lemma Dag_RefD:\n  \"\\<lbrakk>Dag p l r t; p\\<noteq>Null\\<rbrakk> \\<Longrightarrow>\n    \\<exists>lt rt. t=Node lt p rt \\<and> Dag (l p) l r lt \\<and> Dag (r p) l r rt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Dag p l r t; p \\<noteq> Null\\<rbrakk>\n    \\<Longrightarrow> \\<exists>lt rt.\n                         t = Node lt p rt \\<and>\n                         Dag (l p) l r lt \\<and> Dag (r p) l r rt", "by simp"], ["", "lemma Dag_unique_ex_conjI:\n  \"\\<lbrakk>Dag p l r t;   P t\\<rbrakk> \\<Longrightarrow> (\\<exists>t. Dag p l r t \\<and> P t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Dag p l r t; P t\\<rbrakk>\n    \\<Longrightarrow> \\<exists>t. Dag p l r t \\<and> P t", "by simp"], ["", "(* FIXME: To BinDag *)"], ["", "lemma dag_Null [simp]: \"dag Null l r = Tip\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dag Null l r = Tip", "by (simp add: dag_def)"], ["", "definition first:: \"ref list \\<Rightarrow> ref\" where\n\"first ps = (case ps of [] \\<Rightarrow> Null | (p#rs) \\<Rightarrow> p)\""], ["", "lemma first_simps [simp]:\n \"first [] = Null\"\n \"first (r#rs) = r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. first [] = Null &&& first (r # rs) = r", "by (simp_all add: first_def)"], ["", "definition Levellist:: \"ref list \\<Rightarrow> (ref \\<Rightarrow> ref) \\<Rightarrow> (ref list list) \\<Rightarrow> bool\" where\n\"Levellist hds next ll \\<longleftrightarrow> (map first ll = hds) \\<and>\n                         (\\<forall>i < length hds. List (hds ! i) next (ll!i))\""], ["", "lemma Levellist_unique:\n  assumes ll: \"Levellist hds next ll\"\n  assumes ll': \"Levellist hds next ll'\"\n  shows \"ll=ll'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ll = ll'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ll = ll'", "from ll"], ["proof (chain)\npicking this:\n  Levellist hds next ll", "have \"length ll = length hds\""], ["proof (prove)\nusing this:\n  Levellist hds next ll\n\ngoal (1 subgoal):\n 1. length ll = length hds", "by (clarsimp simp add: Levellist_def)"], ["proof (state)\nthis:\n  length ll = length hds\n\ngoal (1 subgoal):\n 1. ll = ll'", "moreover"], ["proof (state)\nthis:\n  length ll = length hds\n\ngoal (1 subgoal):\n 1. ll = ll'", "from ll'"], ["proof (chain)\npicking this:\n  Levellist hds next ll'", "have \"length ll' = length hds\""], ["proof (prove)\nusing this:\n  Levellist hds next ll'\n\ngoal (1 subgoal):\n 1. length ll' = length hds", "by (clarsimp simp add: Levellist_def)"], ["proof (state)\nthis:\n  length ll' = length hds\n\ngoal (1 subgoal):\n 1. ll = ll'", "ultimately"], ["proof (chain)\npicking this:\n  length ll = length hds\n  length ll' = length hds", "have leq: \"length ll = length ll'\""], ["proof (prove)\nusing this:\n  length ll = length hds\n  length ll' = length hds\n\ngoal (1 subgoal):\n 1. length ll = length ll'", "by simp"], ["proof (state)\nthis:\n  length ll = length ll'\n\ngoal (1 subgoal):\n 1. ll = ll'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ll = ll'", "proof (rule nth_equalityI [OF leq, rule_format])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. i < length ll \\<Longrightarrow> ll ! i = ll' ! i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. i < length ll \\<Longrightarrow> ll ! i = ll' ! i", "assume \"i < length ll\""], ["proof (state)\nthis:\n  i < length ll\n\ngoal (1 subgoal):\n 1. \\<And>i. i < length ll \\<Longrightarrow> ll ! i = ll' ! i", "with ll ll'"], ["proof (chain)\npicking this:\n  Levellist hds next ll\n  Levellist hds next ll'\n  i < length ll", "show \"ll!i = ll'!i\""], ["proof (prove)\nusing this:\n  Levellist hds next ll\n  Levellist hds next ll'\n  i < length ll\n\ngoal (1 subgoal):\n 1. ll ! i = ll' ! i", "apply (clarsimp simp add: Levellist_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length ll;\n     \\<forall>i<length ll. List (first (ll ! i)) next (ll ! i);\n     hds = map first ll; map first ll' = map first ll;\n     \\<forall>i<length ll. List (first (ll ! i)) next (ll' ! i)\\<rbrakk>\n    \\<Longrightarrow> ll ! i = ll' ! i", "apply (erule_tac x=i in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length ll; hds = map first ll;\n     map first ll' = map first ll;\n     \\<forall>i<length ll. List (first (ll ! i)) next (ll' ! i);\n     i < length ll \\<longrightarrow>\n     List (first (ll ! i)) next (ll ! i)\\<rbrakk>\n    \\<Longrightarrow> ll ! i = ll' ! i", "apply (erule_tac x=i in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length ll; hds = map first ll;\n     map first ll' = map first ll;\n     i < length ll \\<longrightarrow> List (first (ll ! i)) next (ll ! i);\n     i < length ll \\<longrightarrow>\n     List (first (ll ! i)) next (ll' ! i)\\<rbrakk>\n    \\<Longrightarrow> ll ! i = ll' ! i", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length ll; hds = map first ll;\n     map first ll' = map first ll; List (first (ll ! i)) next (ll ! i);\n     List (first (ll ! i)) next (ll' ! i)\\<rbrakk>\n    \\<Longrightarrow> ll ! i = ll' ! i", "by (erule List_unique)"], ["proof (state)\nthis:\n  ll ! i = ll' ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ll = ll'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Levellist_unique_ex_conj_simp [simp]:\n\"Levellist hds next ll \\<Longrightarrow> (\\<exists>ll. Levellist hds next ll \\<and> P ll) = P ll\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Levellist hds next ll \\<Longrightarrow>\n    (\\<exists>ll. Levellist hds next ll \\<and> P ll) = P ll", "by (auto dest: Levellist_unique)"], ["", "lemma in_set_concat_idx:\n  \"x \\<in> set (concat xss) \\<Longrightarrow> \\<exists>i < length xss. x \\<in> set (xss!i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set (concat xss) \\<Longrightarrow>\n    \\<exists>i<length xss. x \\<in> set (xss ! i)", "apply (induct xss)"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<in> set (concat []) \\<Longrightarrow>\n    \\<exists>i<length []. x \\<in> set ([] ! i)\n 2. \\<And>a xss.\n       \\<lbrakk>x \\<in> set (concat xss) \\<Longrightarrow>\n                \\<exists>i<length xss. x \\<in> set (xss ! i);\n        x \\<in> set (concat (a # xss))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length (a # xss).\n                            x \\<in> set ((a # xss) ! i)", "apply  simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xss.\n       \\<lbrakk>x \\<in> set (concat xss) \\<Longrightarrow>\n                \\<exists>i<length xss. x \\<in> set (xss ! i);\n        x \\<in> set (concat (a # xss))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<length (a # xss).\n                            x \\<in> set ((a # xss) ! i)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xss.\n       \\<lbrakk>\\<exists>xa\\<in>set xss. x \\<in> set xa \\<Longrightarrow>\n                \\<exists>i<length xss. x \\<in> set (xss ! i);\n        x \\<in> set a \\<or>\n        (\\<exists>xa\\<in>set xss. x \\<in> set xa)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<Suc (length xss).\n                            x \\<in> set ((a # xss) ! i)", "apply (erule disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a xss.\n       \\<lbrakk>\\<exists>xa\\<in>set xss. x \\<in> set xa \\<Longrightarrow>\n                \\<exists>i<length xss. x \\<in> set (xss ! i);\n        x \\<in> set a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<Suc (length xss).\n                            x \\<in> set ((a # xss) ! i)\n 2. \\<And>a xss.\n       \\<lbrakk>\\<exists>xa\\<in>set xss. x \\<in> set xa \\<Longrightarrow>\n                \\<exists>i<length xss. x \\<in> set (xss ! i);\n        \\<exists>xa\\<in>set xss. x \\<in> set xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<Suc (length xss).\n                            x \\<in> set ((a # xss) ! i)", "apply  (rule_tac x=0 in exI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a xss.\n       \\<lbrakk>\\<exists>xa\\<in>set xss. x \\<in> set xa \\<Longrightarrow>\n                \\<exists>i<length xss. x \\<in> set (xss ! i);\n        x \\<in> set a\\<rbrakk>\n       \\<Longrightarrow> 0 < Suc (length xss) \\<and>\n                         x \\<in> set ((a # xss) ! 0)\n 2. \\<And>a xss.\n       \\<lbrakk>\\<exists>xa\\<in>set xss. x \\<in> set xa \\<Longrightarrow>\n                \\<exists>i<length xss. x \\<in> set (xss ! i);\n        \\<exists>xa\\<in>set xss. x \\<in> set xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<Suc (length xss).\n                            x \\<in> set ((a # xss) ! i)", "apply  simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xss.\n       \\<lbrakk>\\<exists>xa\\<in>set xss. x \\<in> set xa \\<Longrightarrow>\n                \\<exists>i<length xss. x \\<in> set (xss ! i);\n        \\<exists>xa\\<in>set xss. x \\<in> set xa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i<Suc (length xss).\n                            x \\<in> set ((a # xss) ! i)", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition wf_levellist :: \"dag \\<Rightarrow> ref list list \\<Rightarrow> ref list list \\<Rightarrow>\n                       (ref \\<Rightarrow> nat) \\<Rightarrow> bool\" where\n\"wf_levellist t levellist_old levellist_new var =\n(case t of Tip \\<Rightarrow> levellist_old = levellist_new\n| (Node lt p rt) \\<Rightarrow>\n  (\\<forall> q. q \\<in> set_of t \\<longrightarrow> q \\<in> set (levellist_new ! (var q))) \\<and>\n  (\\<forall> i \\<le> var p. (\\<exists> prx. (levellist_new ! i) = prx@(levellist_old ! i)\n                       \\<and> (\\<forall> pt \\<in> set prx. pt \\<in> set_of t \\<and> var pt = i))) \\<and>\n  (\\<forall> i. (var p) < i \\<longrightarrow> (levellist_new ! i) = (levellist_old ! i)) \\<and>\n  (length levellist_new = length levellist_old))\""], ["", "lemma wf_levellist_subset:\n  assumes wf_ll: \"wf_levellist t ll ll' var\"\n  shows \"set (concat ll') \\<subseteq>  set (concat ll) \\<union> set_of t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (concat ll') \\<subseteq> set (concat ll) \\<union> set_of t", "proof (cases t)"], ["proof (state)\ngoal (2 subgoals):\n 1. t = Tip \\<Longrightarrow>\n    set (concat ll') \\<subseteq> set (concat ll) \\<union> set_of t\n 2. \\<And>x21 x22 x23.\n       t = Node x21 x22 x23 \\<Longrightarrow>\n       set (concat ll') \\<subseteq> set (concat ll) \\<union> set_of t", "case Tip"], ["proof (state)\nthis:\n  t = Tip\n\ngoal (2 subgoals):\n 1. t = Tip \\<Longrightarrow>\n    set (concat ll') \\<subseteq> set (concat ll) \\<union> set_of t\n 2. \\<And>x21 x22 x23.\n       t = Node x21 x22 x23 \\<Longrightarrow>\n       set (concat ll') \\<subseteq> set (concat ll) \\<union> set_of t", "with wf_ll"], ["proof (chain)\npicking this:\n  wf_levellist t ll ll' var\n  t = Tip", "show ?thesis"], ["proof (prove)\nusing this:\n  wf_levellist t ll ll' var\n  t = Tip\n\ngoal (1 subgoal):\n 1. set (concat ll') \\<subseteq> set (concat ll) \\<union> set_of t", "by (simp add: wf_levellist_def)"], ["proof (state)\nthis:\n  set (concat ll') \\<subseteq> set (concat ll) \\<union> set_of t\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       t = Node x21 x22 x23 \\<Longrightarrow>\n       set (concat ll') \\<subseteq> set (concat ll) \\<union> set_of t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       t = Node x21 x22 x23 \\<Longrightarrow>\n       set (concat ll') \\<subseteq> set (concat ll) \\<union> set_of t", "case (Node lt p rt)"], ["proof (state)\nthis:\n  t = Node lt p rt\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       t = Node x21 x22 x23 \\<Longrightarrow>\n       set (concat ll') \\<subseteq> set (concat ll) \\<union> set_of t", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (concat ll') \\<subseteq> set (concat ll) \\<union> set_of t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (concat ll') \\<subseteq> set (concat ll) \\<union> set_of t", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. set (concat ll') \\<subseteq> set (concat ll) \\<union> set_of t", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. set (concat ll') \\<subseteq> set (concat ll) \\<union> set_of t", "assume \"n \\<in> set (concat ll')\""], ["proof (state)\nthis:\n  n \\<in> set (concat ll')\n\ngoal (1 subgoal):\n 1. set (concat ll') \\<subseteq> set (concat ll) \\<union> set_of t", "from in_set_concat_idx [OF this]"], ["proof (chain)\npicking this:\n  \\<exists>i<length ll'. n \\<in> set (ll' ! i)", "obtain i where i_bound: \"i < length ll'\" and n_in: \"n \\<in> set (ll' ! i)\""], ["proof (prove)\nusing this:\n  \\<exists>i<length ll'. n \\<in> set (ll' ! i)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length ll'; n \\<in> set (ll' ! i)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  i < length ll'\n  n \\<in> set (ll' ! i)\n\ngoal (1 subgoal):\n 1. set (concat ll') \\<subseteq> set (concat ll) \\<union> set_of t", "have \"n \\<in> set (concat ll) \\<union> set_of t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<in> set (concat ll) \\<union> set_of t", "proof (cases \"i \\<le> var p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i \\<le> var p \\<Longrightarrow>\n    n \\<in> set (concat ll) \\<union> set_of t\n 2. \\<not> i \\<le> var p \\<Longrightarrow>\n    n \\<in> set (concat ll) \\<union> set_of t", "case True"], ["proof (state)\nthis:\n  i \\<le> var p\n\ngoal (2 subgoals):\n 1. i \\<le> var p \\<Longrightarrow>\n    n \\<in> set (concat ll) \\<union> set_of t\n 2. \\<not> i \\<le> var p \\<Longrightarrow>\n    n \\<in> set (concat ll) \\<union> set_of t", "with wf_ll"], ["proof (chain)\npicking this:\n  wf_levellist t ll ll' var\n  i \\<le> var p", "obtain prx where\n          ll'_ll: \"ll' ! i = prx @ ll ! i\" and\n          prx: \"\\<forall>pt \\<in> set prx. pt \\<in> set_of t\"  and\n          leq: \"length ll' = length ll\""], ["proof (prove)\nusing this:\n  wf_levellist t ll ll' var\n  i \\<le> var p\n\ngoal (1 subgoal):\n 1. (\\<And>prx.\n        \\<lbrakk>ll' ! i = prx @ ll ! i;\n         \\<forall>pt\\<in>set prx. pt \\<in> set_of t;\n         length ll' = length ll\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (clarsimp simp add: wf_levellist_def Node)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>prx.\n                \\<lbrakk>ll' ! i = prx @ ll ! i;\n                 \\<forall>pt\\<in>set prx.\n                    pt = p \\<or>\n                    pt \\<in> set_of lt \\<or> pt \\<in> set_of rt\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     i \\<le> var p;\n     \\<forall>q.\n        (q = p \\<longrightarrow> p \\<in> set (ll' ! var p)) \\<and>\n        (q \\<in> set_of lt \\<longrightarrow>\n         q \\<in> set (ll' ! var q)) \\<and>\n        (q \\<in> set_of rt \\<longrightarrow> q \\<in> set (ll' ! var q));\n     \\<forall>i\\<le>var p.\n        \\<exists>prx.\n           ll' ! i = prx @ ll ! i \\<and>\n           (\\<forall>pt\\<in>set prx.\n               (pt = p \\<or>\n                pt \\<in> set_of lt \\<or> pt \\<in> set_of rt) \\<and>\n               var pt = i);\n     \\<forall>i>var p. ll' ! i = ll ! i; length ll' = length ll\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply (erule_tac x=\"i\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>prx.\n                \\<lbrakk>ll' ! i = prx @ ll ! i;\n                 \\<forall>pt\\<in>set prx.\n                    pt = p \\<or>\n                    pt \\<in> set_of lt \\<or> pt \\<in> set_of rt\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     i \\<le> var p;\n     \\<forall>q.\n        (q = p \\<longrightarrow> p \\<in> set (ll' ! var p)) \\<and>\n        (q \\<in> set_of lt \\<longrightarrow>\n         q \\<in> set (ll' ! var q)) \\<and>\n        (q \\<in> set_of rt \\<longrightarrow> q \\<in> set (ll' ! var q));\n     \\<forall>i>var p. ll' ! i = ll ! i; length ll' = length ll;\n     i \\<le> var p \\<longrightarrow>\n     (\\<exists>prx.\n         ll' ! i = prx @ ll ! i \\<and>\n         (\\<forall>pt\\<in>set prx.\n             (pt = p \\<or>\n              pt \\<in> set_of lt \\<or> pt \\<in> set_of rt) \\<and>\n             var pt = i))\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply clarsimp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ll' ! i = prx @ ll ! i\n  \\<forall>pt\\<in>set prx. pt \\<in> set_of t\n  length ll' = length ll\n\ngoal (2 subgoals):\n 1. i \\<le> var p \\<Longrightarrow>\n    n \\<in> set (concat ll) \\<union> set_of t\n 2. \\<not> i \\<le> var p \\<Longrightarrow>\n    n \\<in> set (concat ll) \\<union> set_of t", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<in> set (concat ll) \\<union> set_of t", "proof (cases \"n \\<in> set prx\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n \\<in> set prx \\<Longrightarrow>\n    n \\<in> set (concat ll) \\<union> set_of t\n 2. n \\<notin> set prx \\<Longrightarrow>\n    n \\<in> set (concat ll) \\<union> set_of t", "case True"], ["proof (state)\nthis:\n  n \\<in> set prx\n\ngoal (2 subgoals):\n 1. n \\<in> set prx \\<Longrightarrow>\n    n \\<in> set (concat ll) \\<union> set_of t\n 2. n \\<notin> set prx \\<Longrightarrow>\n    n \\<in> set (concat ll) \\<union> set_of t", "with prx"], ["proof (chain)\npicking this:\n  \\<forall>pt\\<in>set prx. pt \\<in> set_of t\n  n \\<in> set prx", "have \"n \\<in> set_of t\""], ["proof (prove)\nusing this:\n  \\<forall>pt\\<in>set prx. pt \\<in> set_of t\n  n \\<in> set prx\n\ngoal (1 subgoal):\n 1. n \\<in> set_of t", "by simp"], ["proof (state)\nthis:\n  n \\<in> set_of t\n\ngoal (2 subgoals):\n 1. n \\<in> set prx \\<Longrightarrow>\n    n \\<in> set (concat ll) \\<union> set_of t\n 2. n \\<notin> set prx \\<Longrightarrow>\n    n \\<in> set (concat ll) \\<union> set_of t", "thus ?thesis"], ["proof (prove)\nusing this:\n  n \\<in> set_of t\n\ngoal (1 subgoal):\n 1. n \\<in> set (concat ll) \\<union> set_of t", "by simp"], ["proof (state)\nthis:\n  n \\<in> set (concat ll) \\<union> set_of t\n\ngoal (1 subgoal):\n 1. n \\<notin> set prx \\<Longrightarrow>\n    n \\<in> set (concat ll) \\<union> set_of t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<notin> set prx \\<Longrightarrow>\n    n \\<in> set (concat ll) \\<union> set_of t", "case False"], ["proof (state)\nthis:\n  n \\<notin> set prx\n\ngoal (1 subgoal):\n 1. n \\<notin> set prx \\<Longrightarrow>\n    n \\<in> set (concat ll) \\<union> set_of t", "with n_in ll'_ll"], ["proof (chain)\npicking this:\n  n \\<in> set (ll' ! i)\n  ll' ! i = prx @ ll ! i\n  n \\<notin> set prx", "have \"n \\<in> set (ll ! i)\""], ["proof (prove)\nusing this:\n  n \\<in> set (ll' ! i)\n  ll' ! i = prx @ ll ! i\n  n \\<notin> set prx\n\ngoal (1 subgoal):\n 1. n \\<in> set (ll ! i)", "by simp"], ["proof (state)\nthis:\n  n \\<in> set (ll ! i)\n\ngoal (1 subgoal):\n 1. n \\<notin> set prx \\<Longrightarrow>\n    n \\<in> set (concat ll) \\<union> set_of t", "with i_bound leq"], ["proof (chain)\npicking this:\n  i < length ll'\n  length ll' = length ll\n  n \\<in> set (ll ! i)", "have \"n \\<in> set (concat ll)\""], ["proof (prove)\nusing this:\n  i < length ll'\n  length ll' = length ll\n  n \\<in> set (ll ! i)\n\ngoal (1 subgoal):\n 1. n \\<in> set (concat ll)", "by auto"], ["proof (state)\nthis:\n  n \\<in> set (concat ll)\n\ngoal (1 subgoal):\n 1. n \\<notin> set prx \\<Longrightarrow>\n    n \\<in> set (concat ll) \\<union> set_of t", "thus ?thesis"], ["proof (prove)\nusing this:\n  n \\<in> set (concat ll)\n\ngoal (1 subgoal):\n 1. n \\<in> set (concat ll) \\<union> set_of t", "by simp"], ["proof (state)\nthis:\n  n \\<in> set (concat ll) \\<union> set_of t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n \\<in> set (concat ll) \\<union> set_of t\n\ngoal (1 subgoal):\n 1. \\<not> i \\<le> var p \\<Longrightarrow>\n    n \\<in> set (concat ll) \\<union> set_of t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i \\<le> var p \\<Longrightarrow>\n    n \\<in> set (concat ll) \\<union> set_of t", "case False"], ["proof (state)\nthis:\n  \\<not> i \\<le> var p\n\ngoal (1 subgoal):\n 1. \\<not> i \\<le> var p \\<Longrightarrow>\n    n \\<in> set (concat ll) \\<union> set_of t", "with wf_ll"], ["proof (chain)\npicking this:\n  wf_levellist t ll ll' var\n  \\<not> i \\<le> var p", "obtain \"ll'!i = ll!i\" \"length ll' = length ll\""], ["proof (prove)\nusing this:\n  wf_levellist t ll ll' var\n  \\<not> i \\<le> var p\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>ll' ! i = ll ! i; length ll' = length ll\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: wf_levellist_def Node)"], ["proof (state)\nthis:\n  ll' ! i = ll ! i\n  length ll' = length ll\n\ngoal (1 subgoal):\n 1. \\<not> i \\<le> var p \\<Longrightarrow>\n    n \\<in> set (concat ll) \\<union> set_of t", "with n_in i_bound"], ["proof (chain)\npicking this:\n  n \\<in> set (ll' ! i)\n  i < length ll'\n  ll' ! i = ll ! i\n  length ll' = length ll", "have \"n \\<in> set (concat ll)\""], ["proof (prove)\nusing this:\n  n \\<in> set (ll' ! i)\n  i < length ll'\n  ll' ! i = ll ! i\n  length ll' = length ll\n\ngoal (1 subgoal):\n 1. n \\<in> set (concat ll)", "by auto"], ["proof (state)\nthis:\n  n \\<in> set (concat ll)\n\ngoal (1 subgoal):\n 1. \\<not> i \\<le> var p \\<Longrightarrow>\n    n \\<in> set (concat ll) \\<union> set_of t", "thus ?thesis"], ["proof (prove)\nusing this:\n  n \\<in> set (concat ll)\n\ngoal (1 subgoal):\n 1. n \\<in> set (concat ll) \\<union> set_of t", "by simp"], ["proof (state)\nthis:\n  n \\<in> set (concat ll) \\<union> set_of t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n \\<in> set (concat ll) \\<union> set_of t\n\ngoal (1 subgoal):\n 1. set (concat ll') \\<subseteq> set (concat ll) \\<union> set_of t", "}"], ["proof (state)\nthis:\n  ?n2 \\<in> set (concat ll') \\<Longrightarrow>\n  ?n2 \\<in> set (concat ll) \\<union> set_of t\n\ngoal (1 subgoal):\n 1. set (concat ll') \\<subseteq> set (concat ll) \\<union> set_of t", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?n2 \\<in> set (concat ll') \\<Longrightarrow>\n  ?n2 \\<in> set (concat ll) \\<union> set_of t\n\ngoal (1 subgoal):\n 1. set (concat ll') \\<subseteq> set (concat ll) \\<union> set_of t", "by auto"], ["proof (state)\nthis:\n  set (concat ll') \\<subseteq> set (concat ll) \\<union> set_of t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set (concat ll') \\<subseteq> set (concat ll) \\<union> set_of t\n\ngoal:\nNo subgoals!", "qed"], ["", "(*\n  next\n    show \"set (concat ll) \\<union> set_of t \\<subseteq> set (concat ll')\"\n    proof -\n      {\n        fix n\n        assume \"n \\<in> set (concat ll)\"\n        from in_set_concat_idx [OF this]\n        obtain i where i_bound: \"i < length ll\" and n_in: \"n \\<in> set (ll ! i)\"\n          by blast\n        with wf_ll\n        obtain \"n \\<in> set (ll' ! i)\" \"length ll = length ll'\"\n          apply (clarsimp simp add: wf_levellist_def Node)\n          apply (case_tac \"i \\<le> var p\")\n          apply  fastforce\n          apply fastforce\n          done\n        with i_bound have \"n \\<in> set (concat ll')\"\n          by auto\n      }\n      moreover\n      {\n        fix n\n        assume \"n \\<in> set_of t\"\n        with wf_ll obtain \"n \\<in> set (ll' ! var n)\" \"length ll' = length ll\"\n          by (auto simp add: wf_levellist_def Node)\n        with root\n\n            next\n\n          proof (cases prx)\n            case Nil\n            with ll'_ll i_bound leq n_in\n            have \"n \\<in> set (concat ll)\"\n              by auto\n            thus ?thesis by simp\n          next\n            case (Cons p prx')\n            show ?thesis\n\n              apply auto\n        *)\n\n\n(*\nconsts wf_levellist :: \"dag \\<Rightarrow> ref list \\<Rightarrow> ref list \\<Rightarrow>\n                        (ref \\<Rightarrow> ref) \\<Rightarrow> (ref \\<Rightarrow> ref) \\<Rightarrow>\n                       (ref \\<Rightarrow> nat) \\<Rightarrow> bool\"\ndefs wf_levellist_def:\n\"wf_levellist t levellist_old levellist_new next_old next_new var  \\<equiv>\ncase t of Tip \\<Rightarrow> levellist_old = levellist_new\n| (Node lt p rt) \\<Rightarrow>\n  (\\<forall> q. q \\<in> set_of t \\<longrightarrow> (\\<exists>ns. List (levellist_new ! (var q)) next_new ns \\<and>\n                                q \\<in> set ns)) \\<and>\n  (\\<forall> i \\<le> var p. (\\<exists>ns_new ns_old.\n                  List (levellist_new ! i) next_new ns_new \\<and>\n                  List (levellist_old ! i) next_old ns_old \\<and>\n                 (\\<exists> prx. ns_new = prx@ns_old\n                       \\<and> (\\<forall> pt \\<in> set prx. pt \\<in> set_of t \\<and> var pt = i)))) \\<and>\n  (\\<forall> i. (var p) < i \\<longrightarrow> (\\<exists>ns_new ns_old.\n                          List (levellist_new ! i) next_new ns_new \\<and>\n                          List (levellist_old ! i) next_old ns_old \\<and>\n                          ns_new = ns_old)) \\<and>\n  (length levellist_new = length levellist_old)\"\n*)"], ["", "lemma Levellist_ext_to_all: \"((\\<exists>ll. Levellist hds next ll \\<and> P ll) \\<longrightarrow> Q)\n       =\n       (\\<forall>ll. Levellist hds next ll \\<and> P ll \\<longrightarrow> Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<exists>ll. Levellist hds next ll \\<and> P ll) \\<longrightarrow> Q) =\n    (\\<forall>ll. Levellist hds next ll \\<and> P ll \\<longrightarrow> Q)", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Levellist_length: \"Levellist hds p ll \\<Longrightarrow> length ll = length hds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Levellist hds p ll \\<Longrightarrow> length ll = length hds", "by (auto simp add: Levellist_def)"], ["", "lemma map_update:\n  \"\\<And>i. i < length xss \\<Longrightarrow> map f (xss[i := xs]) = (map f xss) [i := f xs]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length xss \\<Longrightarrow>\n       map f (xss[i := xs]) = (map f xss)[i := f xs]", "apply (induct xss)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i < length [] \\<Longrightarrow>\n       map f ([][i := xs]) = (map f [])[i := f xs]\n 2. \\<And>a xss i.\n       \\<lbrakk>\\<And>i.\n                   i < length xss \\<Longrightarrow>\n                   map f (xss[i := xs]) = (map f xss)[i := f xs];\n        i < length (a # xss)\\<rbrakk>\n       \\<Longrightarrow> map f ((a # xss)[i := xs]) = (map f (a # xss))\n                         [i := f xs]", "apply  simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xss i.\n       \\<lbrakk>\\<And>i.\n                   i < length xss \\<Longrightarrow>\n                   map f (xss[i := xs]) = (map f xss)[i := f xs];\n        i < length (a # xss)\\<rbrakk>\n       \\<Longrightarrow> map f ((a # xss)[i := xs]) = (map f (a # xss))\n                         [i := f xs]", "apply (case_tac i)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a xss i.\n       \\<lbrakk>\\<And>i.\n                   i < length xss \\<Longrightarrow>\n                   map f (xss[i := xs]) = (map f xss)[i := f xs];\n        i < length (a # xss); i = 0\\<rbrakk>\n       \\<Longrightarrow> map f ((a # xss)[i := xs]) = (map f (a # xss))\n                         [i := f xs]\n 2. \\<And>a xss i nat.\n       \\<lbrakk>\\<And>i.\n                   i < length xss \\<Longrightarrow>\n                   map f (xss[i := xs]) = (map f xss)[i := f xs];\n        i < length (a # xss); i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> map f ((a # xss)[i := xs]) = (map f (a # xss))\n                         [i := f xs]", "apply  simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xss i nat.\n       \\<lbrakk>\\<And>i.\n                   i < length xss \\<Longrightarrow>\n                   map f (xss[i := xs]) = (map f xss)[i := f xs];\n        i < length (a # xss); i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> map f ((a # xss)[i := xs]) = (map f (a # xss))\n                         [i := f xs]", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in Levellist_impl) Levellist_spec_total':\nshows \"\\<forall>ll \\<sigma> t. \\<Gamma>,\\<Theta>\\<turnstile>\\<^sub>t\n        \\<lbrace>\\<sigma>. Dag \\<acute>p \\<acute>low \\<acute>high t \\<and> (\\<acute>p \\<noteq> Null \\<longrightarrow> (\\<acute>p\\<rightarrow>\\<acute>var) < length \\<acute>levellist) \\<and>\n             ordered t \\<acute>var \\<and> Levellist \\<acute>levellist \\<acute>next ll \\<and>\n             (\\<forall>n \\<in> set_of t.\n              (if \\<acute>mark n = \\<acute>m\n               then n \\<in> set (ll ! \\<acute>var n) \\<and>\n                    (\\<forall>nt p. Dag n \\<acute>low \\<acute>high nt \\<and> p \\<in> set_of nt\n                     \\<longrightarrow> \\<acute>mark p = \\<acute>m)\n               else n \\<notin> set (concat ll)))\\<rbrace>\n          \\<acute>levellist :== PROC Levellist (\\<acute>p, \\<acute>m, \\<acute>levellist)\n       \\<lbrace>\\<exists>ll'. Levellist \\<acute>levellist \\<acute>next ll' \\<and> wf_levellist t ll ll' \\<^bsup>\\<sigma>\\<^esup>var \\<and>\n        wf_marking t  \\<^bsup>\\<sigma>\\<^esup>mark \\<acute>mark \\<^bsup>\\<sigma>\\<^esup>m \\<and>\n        (\\<forall>p. p \\<notin> set_of t \\<longrightarrow> \\<^bsup>\\<sigma>\\<^esup>next p = \\<acute>next p)\n        \\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ll \\<sigma> t.\n       \\<Gamma>,\\<Theta>\n          \\<turnstile>\\<^sub>t \\<lbrace>\\<sigma>. Dag \\<acute>p \\<acute>low\n             \\<acute>high t \\<and>\n            (\\<acute>p \\<noteq> Null \\<longrightarrow>\n             \\<acute>p\\<rightarrow>\\<acute>var\n             < length \\<acute>levellist) \\<and>\n            ordered t \\<acute>var \\<and>\n            Levellist \\<acute>levellist \\<acute>next ll \\<and>\n            (\\<forall>n\\<in>set_of t.\n                if n\\<rightarrow>\\<acute>mark = \\<acute>m\n                then n \\<in> set (ll ! (n\\<rightarrow>\\<acute>var)) \\<and>\n                     (\\<forall>nt p.\n                         Dag n \\<acute>low \\<acute>high nt \\<and>\n                         p \\<in> set_of nt \\<longrightarrow>\n                         p\\<rightarrow>\\<acute>mark = \\<acute>m)\n                else n \\<notin> set (concat ll))\\<rbrace>\n                               \\<acute>levellist :== PROC Levellist(\\<acute>p,\n                               \\<acute>m,\\<acute>levellist)\n                               \\<lbrace>\\<exists>ll'.\n     Levellist \\<acute>levellist \\<acute>next ll' \\<and>\n     wf_levellist t ll ll' \\<^bsup>\\<sigma>\\<^esup>var \\<and>\n     wf_marking t \\<^bsup>\\<sigma>\\<^esup>mark \\<acute>mark\n      \\<^bsup>\\<sigma>\\<^esup>m \\<and>\n     (\\<forall>p.\n         p \\<notin> set_of t \\<longrightarrow>\n         \\<^bsup>\\<sigma>\\<^esup>next p =\n         p\\<rightarrow>\\<acute>next)\\<rbrace>", "apply (hoare_rule HoareTotal.ProcRec1\n           [where r=\"measure (\\<lambda>(s,p). size (dag \\<^bsup>s\\<^esup>p \\<^bsup>s\\<^esup>low \\<^bsup>s\\<^esup>high))\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma> ll \\<sigma>' t.\n       \\<Gamma>,\\<Theta> \\<union>\n                (\\<Union>ll \\<sigma>' t.\n                    {(\\<lbrace>\\<sigma>'. Dag \\<acute>p \\<acute>low\n     \\<acute>high t \\<and>\n    (\\<acute>p \\<noteq> Null \\<longrightarrow>\n     \\<acute>p\\<rightarrow>\\<acute>var < length \\<acute>levellist) \\<and>\n    ordered t \\<acute>var \\<and>\n    Levellist \\<acute>levellist \\<acute>next ll \\<and>\n    (\\<forall>n\\<in>set_of t.\n        if n\\<rightarrow>\\<acute>mark = \\<acute>m\n        then n \\<in> set (ll ! (n\\<rightarrow>\\<acute>var)) \\<and>\n             (\\<forall>nt p.\n                 Dag n \\<acute>low \\<acute>high nt \\<and>\n                 p \\<in> set_of nt \\<longrightarrow>\n                 p\\<rightarrow>\\<acute>mark = \\<acute>m)\n        else n \\<notin> set (concat ll))\\<rbrace> \\<inter>\n                      \\<lbrace>size (dag \\<acute>p \\<acute>low \\<acute>high)\n                               < size\n                                  (dag \\<^bsup>\\<sigma>\\<^esup>p\n                                    \\<^bsup>\\<sigma>\\<^esup>low\n                                    \\<^bsup>\\<sigma>\\<^esup>high)\\<rbrace>,\n                      Levellist_'proc,\n                      \\<lbrace>\\<exists>ll'.\n                                  Levellist \\<acute>levellist \\<acute>next\n                                   ll' \\<and>\n                                  wf_levellist t ll ll'\n                                   \\<^bsup>\\<sigma>'\\<^esup>var \\<and>\n                                  wf_marking t \\<^bsup>\\<sigma>'\\<^esup>mark\n                                   \\<acute>mark\n                                   \\<^bsup>\\<sigma>'\\<^esup>m \\<and>\n                                  (\\<forall>p.\np \\<notin> set_of t \\<longrightarrow>\n\\<^bsup>\\<sigma>'\\<^esup>next p = p\\<rightarrow>\\<acute>next)\\<rbrace>,\n                      {})})\n          \\<turnstile>\\<^sub>t ({\\<sigma>} \\<inter>\n                                \\<lbrace>\\<sigma>'. Dag \\<acute>p\n               \\<acute>low \\<acute>high t \\<and>\n              (\\<acute>p \\<noteq> Null \\<longrightarrow>\n               \\<acute>p\\<rightarrow>\\<acute>var\n               < length \\<acute>levellist) \\<and>\n              ordered t \\<acute>var \\<and>\n              Levellist \\<acute>levellist \\<acute>next ll \\<and>\n              (\\<forall>n\\<in>set_of t.\n                  if n\\<rightarrow>\\<acute>mark = \\<acute>m\n                  then n \\<in> set (ll ! (n\\<rightarrow>\\<acute>var)) \\<and>\n                       (\\<forall>nt p.\n                           Dag n \\<acute>low \\<acute>high nt \\<and>\n                           p \\<in> set_of nt \\<longrightarrow>\n                           p\\<rightarrow>\\<acute>mark = \\<acute>m)\n                  else n \\<notin> set (concat ll))\\<rbrace>)\n                               IF \\<acute>p \\<noteq> Null\n                               THEN IF \\<acute>p\\<rightarrow>\\<acute>mark \\<noteq>\n \\<acute>m\n                                    THEN\n\\<acute>levellist :== CALL Levellist(\\<acute>p\\<rightarrow>\\<acute>low,\n\\<acute>m,\\<acute>levellist);;\n\\<acute>levellist :== CALL Levellist(\\<acute>p\\<rightarrow>\\<acute>high,\n\\<acute>m,\\<acute>levellist);;\n\\<acute>p\\<rightarrow>\\<acute>next :==\n\\<acute>levellist ! (\\<acute>p\\<rightarrow>\\<acute>var);;\n\\<acute>levellist ! (\\<acute>p\\<rightarrow>\\<acute>var) :== \\<acute>p;;\n\\<acute>p\\<rightarrow>\\<acute>mark :== \\<acute>m\n                                    FI\n                               FI\n                               \\<lbrace>\\<exists>ll'.\n     Levellist \\<acute>levellist \\<acute>next ll' \\<and>\n     wf_levellist t ll ll' \\<^bsup>\\<sigma>'\\<^esup>var \\<and>\n     wf_marking t \\<^bsup>\\<sigma>'\\<^esup>mark \\<acute>mark\n      \\<^bsup>\\<sigma>'\\<^esup>m \\<and>\n     (\\<forall>p.\n         p \\<notin> set_of t \\<longrightarrow>\n         \\<^bsup>\\<sigma>'\\<^esup>next p =\n         p\\<rightarrow>\\<acute>next)\\<rbrace>", "apply vcg"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ll t var low high mark next p levellist m.\n       \\<lbrakk>Dag p low high t;\n        p \\<noteq> Null \\<longrightarrow> var p < length levellist;\n        ordered t var; Levellist levellist next ll;\n        \\<forall>n\\<in>set_of t.\n           if mark n = m\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt p.\n                    Dag n low high nt \\<and>\n                    p \\<in> set_of nt \\<longrightarrow>\n                    mark p = m)\n           else n \\<notin> set (concat ll)\\<rbrakk>\n       \\<Longrightarrow> (p \\<noteq> Null \\<longrightarrow>\n                          (mark p \\<noteq> m \\<longrightarrow>\n                           (\\<exists>lla ta.\n                               Dag (low p) low high ta \\<and>\n                               (low p \\<noteq> Null \\<longrightarrow>\n                                var (low p) < length levellist) \\<and>\n                               ordered ta var \\<and>\n                               Levellist levellist next lla \\<and>\n                               (\\<forall>n\\<in>set_of ta.\n                                   if mark n = m\n                                   then n \\<in> set (lla ! var n) \\<and>\n  (\\<forall>nt p.\n      Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n      mark p = m)\n                                   else n \\<notin> set (concat lla)) \\<and>\n                               size (dag (low p) low high)\n                               < size (dag p low high) \\<and>\n                               (\\<forall>marka nexta levellist.\n                                   (\\<exists>ll'.\n Levellist levellist nexta ll' \\<and>\n wf_levellist ta lla ll' var \\<and>\n wf_marking ta mark marka m \\<and>\n (\\<forall>p.\n     p \\<notin> set_of ta \\<longrightarrow>\n     next p = nexta p)) \\<longrightarrow>\n                                   (\\<exists>lla ta.\n Dag (high p) low high ta \\<and>\n (high p \\<noteq> Null \\<longrightarrow>\n  var (high p) < length levellist) \\<and>\n ordered ta var \\<and>\n Levellist levellist nexta lla \\<and>\n (\\<forall>n\\<in>set_of ta.\n     if marka n = m\n     then n \\<in> set (lla ! var n) \\<and>\n          (\\<forall>nt p.\n              Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n              marka p = m)\n     else n \\<notin> set (concat lla)) \\<and>\n size (dag (high p) low high) < size (dag p low high) \\<and>\n (\\<forall>markb nextb levellist.\n     (\\<exists>ll'.\n         Levellist levellist nextb ll' \\<and>\n         wf_levellist ta lla ll' var \\<and>\n         wf_marking ta marka markb m \\<and>\n         (\\<forall>p.\n             p \\<notin> set_of ta \\<longrightarrow>\n             nexta p = nextb p)) \\<longrightarrow>\n     (\\<exists>ll'.\n         Levellist (levellist[var p := p]) (nextb(p := levellist ! var p))\n          ll' \\<and>\n         wf_levellist t ll ll' var \\<and>\n         wf_marking t mark (markb(p := m)) m \\<and>\n         (\\<forall>pa.\n             pa \\<notin> set_of t \\<longrightarrow>\n             next pa = (nextb(p := levellist ! var p)) pa))))))) \\<and>\n                          (\\<not> mark p \\<noteq> m \\<longrightarrow>\n                           (\\<exists>ll'.\n                               Levellist levellist next ll' \\<and>\n                               wf_levellist t ll ll' var \\<and>\n                               wf_marking t mark mark m \\<and>\n                               (\\<forall>p.\n                                   p \\<notin> set_of t \\<longrightarrow>\n                                   next p = next p)))) \\<and>\n                         (\\<not> p \\<noteq> Null \\<longrightarrow>\n                          (\\<exists>ll'.\n                              Levellist levellist next ll' \\<and>\n                              wf_levellist t ll ll' var \\<and>\n                              wf_marking t mark mark m \\<and>\n                              (\\<forall>p.\n                                  p \\<notin> set_of t \\<longrightarrow>\n                                  next p = next p)))", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ll t var low high mark next p levellist m.\n       \\<lbrakk>Dag p low high t;\n        p \\<noteq> Null \\<longrightarrow> var p < length levellist;\n        ordered t var; Levellist levellist next ll;\n        \\<forall>n\\<in>set_of t.\n           if mark n = m\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt p.\n                    Dag n low high nt \\<and>\n                    p \\<in> set_of nt \\<longrightarrow>\n                    mark p = m)\n           else n \\<notin> set (concat ll)\\<rbrakk>\n       \\<Longrightarrow> p \\<noteq> Null \\<longrightarrow>\n                         (mark p \\<noteq> m \\<longrightarrow>\n                          (\\<exists>lla ta.\n                              Dag (low p) low high ta \\<and>\n                              (low p \\<noteq> Null \\<longrightarrow>\n                               var (low p) < length levellist) \\<and>\n                              ordered ta var \\<and>\n                              Levellist levellist next lla \\<and>\n                              (\\<forall>n\\<in>set_of ta.\n                                  if mark n = m\n                                  then n \\<in> set (lla ! var n) \\<and>\n (\\<forall>nt p.\n     Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n     mark p = m)\n                                  else n \\<notin> set (concat lla)) \\<and>\n                              size (dag (low p) low high)\n                              < size (dag p low high) \\<and>\n                              (\\<forall>marka nexta levellist.\n                                  (\\<exists>ll'.\nLevellist levellist nexta ll' \\<and>\nwf_levellist ta lla ll' var \\<and>\nwf_marking ta mark marka m \\<and>\n(\\<forall>p.\n    p \\<notin> set_of ta \\<longrightarrow>\n    next p = nexta p)) \\<longrightarrow>\n                                  (\\<exists>lla ta.\nDag (high p) low high ta \\<and>\n(high p \\<noteq> Null \\<longrightarrow>\n var (high p) < length levellist) \\<and>\nordered ta var \\<and>\nLevellist levellist nexta lla \\<and>\n(\\<forall>n\\<in>set_of ta.\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)) \\<and>\nsize (dag (high p) low high) < size (dag p low high) \\<and>\n(\\<forall>markb nextb levellist.\n    (\\<exists>ll'.\n        Levellist levellist nextb ll' \\<and>\n        wf_levellist ta lla ll' var \\<and>\n        wf_marking ta marka markb m \\<and>\n        (\\<forall>p.\n            p \\<notin> set_of ta \\<longrightarrow>\n            nexta p = nextb p)) \\<longrightarrow>\n    (\\<exists>ll'.\n        Levellist (levellist[var p := p]) (nextb(p := levellist ! var p))\n         ll' \\<and>\n        wf_levellist t ll ll' var \\<and>\n        wf_marking t mark (markb(p := m)) m \\<and>\n        (\\<forall>pa.\n            pa \\<notin> set_of t \\<longrightarrow>\n            next pa = (nextb(p := levellist ! var p)) pa))))))) \\<and>\n                         (\\<not> mark p \\<noteq> m \\<longrightarrow>\n                          (\\<exists>ll'.\n                              Levellist levellist next ll' \\<and>\n                              wf_levellist t ll ll' var \\<and>\n                              wf_marking t mark mark m \\<and>\n                              (\\<forall>p.\n                                  p \\<notin> set_of t \\<longrightarrow>\n                                  next p = next p)))\n 2. \\<And>ll t var low high mark next p levellist m.\n       \\<lbrakk>Dag p low high t;\n        p \\<noteq> Null \\<longrightarrow> var p < length levellist;\n        ordered t var; Levellist levellist next ll;\n        \\<forall>n\\<in>set_of t.\n           if mark n = m\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt p.\n                    Dag n low high nt \\<and>\n                    p \\<in> set_of nt \\<longrightarrow>\n                    mark p = m)\n           else n \\<notin> set (concat ll)\\<rbrakk>\n       \\<Longrightarrow> \\<not> p \\<noteq> Null \\<longrightarrow>\n                         (\\<exists>ll'.\n                             Levellist levellist next ll' \\<and>\n                             wf_levellist t ll ll' var \\<and>\n                             wf_marking t mark mark m \\<and>\n                             (\\<forall>p.\n                                 p \\<notin> set_of t \\<longrightarrow>\n                                 next p = next p))", "apply  clarify"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ll t var low high mark next p levellist m.\n       \\<lbrakk>Dag p low high t; ordered t var;\n        Levellist levellist next ll;\n        \\<forall>n\\<in>set_of t.\n           if mark n = m\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt p.\n                    Dag n low high nt \\<and>\n                    p \\<in> set_of nt \\<longrightarrow>\n                    mark p = m)\n           else n \\<notin> set (concat ll);\n        p \\<noteq> Null; var p < length levellist\\<rbrakk>\n       \\<Longrightarrow> (mark p \\<noteq> m \\<longrightarrow>\n                          (\\<exists>lla ta.\n                              Dag (low p) low high ta \\<and>\n                              (low p \\<noteq> Null \\<longrightarrow>\n                               var (low p) < length levellist) \\<and>\n                              ordered ta var \\<and>\n                              Levellist levellist next lla \\<and>\n                              (\\<forall>n\\<in>set_of ta.\n                                  if mark n = m\n                                  then n \\<in> set (lla ! var n) \\<and>\n (\\<forall>nt p.\n     Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n     mark p = m)\n                                  else n \\<notin> set (concat lla)) \\<and>\n                              size (dag (low p) low high)\n                              < size (dag p low high) \\<and>\n                              (\\<forall>marka nexta levellist.\n                                  (\\<exists>ll'.\nLevellist levellist nexta ll' \\<and>\nwf_levellist ta lla ll' var \\<and>\nwf_marking ta mark marka m \\<and>\n(\\<forall>p.\n    p \\<notin> set_of ta \\<longrightarrow>\n    next p = nexta p)) \\<longrightarrow>\n                                  (\\<exists>lla ta.\nDag (high p) low high ta \\<and>\n(high p \\<noteq> Null \\<longrightarrow>\n var (high p) < length levellist) \\<and>\nordered ta var \\<and>\nLevellist levellist nexta lla \\<and>\n(\\<forall>n\\<in>set_of ta.\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)) \\<and>\nsize (dag (high p) low high) < size (dag p low high) \\<and>\n(\\<forall>markb nextb levellist.\n    (\\<exists>ll'.\n        Levellist levellist nextb ll' \\<and>\n        wf_levellist ta lla ll' var \\<and>\n        wf_marking ta marka markb m \\<and>\n        (\\<forall>p.\n            p \\<notin> set_of ta \\<longrightarrow>\n            nexta p = nextb p)) \\<longrightarrow>\n    (\\<exists>ll'.\n        Levellist (levellist[var p := p]) (nextb(p := levellist ! var p))\n         ll' \\<and>\n        wf_levellist t ll ll' var \\<and>\n        wf_marking t mark (markb(p := m)) m \\<and>\n        (\\<forall>pa.\n            pa \\<notin> set_of t \\<longrightarrow>\n            next pa = (nextb(p := levellist ! var p)) pa))))))) \\<and>\n                         (\\<not> mark p \\<noteq> m \\<longrightarrow>\n                          (\\<exists>ll'.\n                              Levellist levellist next ll' \\<and>\n                              wf_levellist t ll ll' var \\<and>\n                              wf_marking t mark mark m \\<and>\n                              (\\<forall>p.\n                                  p \\<notin> set_of t \\<longrightarrow>\n                                  next p = next p)))\n 2. \\<And>ll t var low high mark next p levellist m.\n       \\<lbrakk>Dag p low high t;\n        p \\<noteq> Null \\<longrightarrow> var p < length levellist;\n        ordered t var; Levellist levellist next ll;\n        \\<forall>n\\<in>set_of t.\n           if mark n = m\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt p.\n                    Dag n low high nt \\<and>\n                    p \\<in> set_of nt \\<longrightarrow>\n                    mark p = m)\n           else n \\<notin> set (concat ll)\\<rbrakk>\n       \\<Longrightarrow> \\<not> p \\<noteq> Null \\<longrightarrow>\n                         (\\<exists>ll'.\n                             Levellist levellist next ll' \\<and>\n                             wf_levellist t ll ll' var \\<and>\n                             wf_marking t mark mark m \\<and>\n                             (\\<forall>p.\n                                 p \\<notin> set_of t \\<longrightarrow>\n                                 next p = next p))", "apply  (rule conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ll t var low high mark next p levellist m.\n       \\<lbrakk>Dag p low high t; ordered t var;\n        Levellist levellist next ll;\n        \\<forall>n\\<in>set_of t.\n           if mark n = m\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt p.\n                    Dag n low high nt \\<and>\n                    p \\<in> set_of nt \\<longrightarrow>\n                    mark p = m)\n           else n \\<notin> set (concat ll);\n        p \\<noteq> Null; var p < length levellist\\<rbrakk>\n       \\<Longrightarrow> mark p \\<noteq> m \\<longrightarrow>\n                         (\\<exists>lla ta.\n                             Dag (low p) low high ta \\<and>\n                             (low p \\<noteq> Null \\<longrightarrow>\n                              var (low p) < length levellist) \\<and>\n                             ordered ta var \\<and>\n                             Levellist levellist next lla \\<and>\n                             (\\<forall>n\\<in>set_of ta.\n                                 if mark n = m\n                                 then n \\<in> set (lla ! var n) \\<and>\n(\\<forall>nt p.\n    Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow> mark p = m)\n                                 else n \\<notin> set (concat lla)) \\<and>\n                             size (dag (low p) low high)\n                             < size (dag p low high) \\<and>\n                             (\\<forall>marka nexta levellist.\n                                 (\\<exists>ll'.\n                                     Levellist levellist nexta ll' \\<and>\n                                     wf_levellist ta lla ll' var \\<and>\n                                     wf_marking ta mark marka m \\<and>\n                                     (\\<forall>p.\n   p \\<notin> set_of ta \\<longrightarrow>\n   next p = nexta p)) \\<longrightarrow>\n                                 (\\<exists>lla ta.\n                                     Dag (high p) low high ta \\<and>\n                                     (high p \\<noteq> Null \\<longrightarrow>\nvar (high p) < length levellist) \\<and>\n                                     ordered ta var \\<and>\n                                     Levellist levellist nexta lla \\<and>\n                                     (\\<forall>n\\<in>set_of ta.\n   if marka n = m\n   then n \\<in> set (lla ! var n) \\<and>\n        (\\<forall>nt p.\n            Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n            marka p = m)\n   else n \\<notin> set (concat lla)) \\<and>\n                                     size (dag (high p) low high)\n                                     < size (dag p low high) \\<and>\n                                     (\\<forall>markb nextb levellist.\n   (\\<exists>ll'.\n       Levellist levellist nextb ll' \\<and>\n       wf_levellist ta lla ll' var \\<and>\n       wf_marking ta marka markb m \\<and>\n       (\\<forall>p.\n           p \\<notin> set_of ta \\<longrightarrow>\n           nexta p = nextb p)) \\<longrightarrow>\n   (\\<exists>ll'.\n       Levellist (levellist[var p := p]) (nextb(p := levellist ! var p))\n        ll' \\<and>\n       wf_levellist t ll ll' var \\<and>\n       wf_marking t mark (markb(p := m)) m \\<and>\n       (\\<forall>pa.\n           pa \\<notin> set_of t \\<longrightarrow>\n           next pa = (nextb(p := levellist ! var p)) pa))))))\n 2. \\<And>ll t var low high mark next p levellist m.\n       \\<lbrakk>Dag p low high t; ordered t var;\n        Levellist levellist next ll;\n        \\<forall>n\\<in>set_of t.\n           if mark n = m\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt p.\n                    Dag n low high nt \\<and>\n                    p \\<in> set_of nt \\<longrightarrow>\n                    mark p = m)\n           else n \\<notin> set (concat ll);\n        p \\<noteq> Null; var p < length levellist\\<rbrakk>\n       \\<Longrightarrow> \\<not> mark p \\<noteq> m \\<longrightarrow>\n                         (\\<exists>ll'.\n                             Levellist levellist next ll' \\<and>\n                             wf_levellist t ll ll' var \\<and>\n                             wf_marking t mark mark m \\<and>\n                             (\\<forall>p.\n                                 p \\<notin> set_of t \\<longrightarrow>\n                                 next p = next p))\n 3. \\<And>ll t var low high mark next p levellist m.\n       \\<lbrakk>Dag p low high t;\n        p \\<noteq> Null \\<longrightarrow> var p < length levellist;\n        ordered t var; Levellist levellist next ll;\n        \\<forall>n\\<in>set_of t.\n           if mark n = m\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt p.\n                    Dag n low high nt \\<and>\n                    p \\<in> set_of nt \\<longrightarrow>\n                    mark p = m)\n           else n \\<notin> set (concat ll)\\<rbrakk>\n       \\<Longrightarrow> \\<not> p \\<noteq> Null \\<longrightarrow>\n                         (\\<exists>ll'.\n                             Levellist levellist next ll' \\<and>\n                             wf_levellist t ll ll' var \\<and>\n                             wf_marking t mark mark m \\<and>\n                             (\\<forall>p.\n                                 p \\<notin> set_of t \\<longrightarrow>\n                                 next p = next p))", "apply   clarify"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ll t var low high mark next p levellist m.\n       \\<lbrakk>Dag p low high t; ordered t var;\n        Levellist levellist next ll;\n        \\<forall>n\\<in>set_of t.\n           if mark n = m\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt p.\n                    Dag n low high nt \\<and>\n                    p \\<in> set_of nt \\<longrightarrow>\n                    mark p = m)\n           else n \\<notin> set (concat ll);\n        p \\<noteq> Null; var p < length levellist;\n        mark p \\<noteq> m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>lla ta.\n                            Dag (low p) low high ta \\<and>\n                            (low p \\<noteq> Null \\<longrightarrow>\n                             var (low p) < length levellist) \\<and>\n                            ordered ta var \\<and>\n                            Levellist levellist next lla \\<and>\n                            (\\<forall>n\\<in>set_of ta.\n                                if mark n = m\n                                then n \\<in> set (lla ! var n) \\<and>\n                                     (\\<forall>nt p.\n   Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow> mark p = m)\n                                else n \\<notin> set (concat lla)) \\<and>\n                            size (dag (low p) low high)\n                            < size (dag p low high) \\<and>\n                            (\\<forall>marka nexta levellist.\n                                (\\<exists>ll'.\n                                    Levellist levellist nexta ll' \\<and>\n                                    wf_levellist ta lla ll' var \\<and>\n                                    wf_marking ta mark marka m \\<and>\n                                    (\\<forall>p.\n  p \\<notin> set_of ta \\<longrightarrow>\n  next p = nexta p)) \\<longrightarrow>\n                                (\\<exists>lla ta.\n                                    Dag (high p) low high ta \\<and>\n                                    (high p \\<noteq> Null \\<longrightarrow>\n                                     var (high p) < length levellist) \\<and>\n                                    ordered ta var \\<and>\n                                    Levellist levellist nexta lla \\<and>\n                                    (\\<forall>n\\<in>set_of ta.\n  if marka n = m\n  then n \\<in> set (lla ! var n) \\<and>\n       (\\<forall>nt p.\n           Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n           marka p = m)\n  else n \\<notin> set (concat lla)) \\<and>\n                                    size (dag (high p) low high)\n                                    < size (dag p low high) \\<and>\n                                    (\\<forall>markb nextb levellist.\n  (\\<exists>ll'.\n      Levellist levellist nextb ll' \\<and>\n      wf_levellist ta lla ll' var \\<and>\n      wf_marking ta marka markb m \\<and>\n      (\\<forall>p.\n          p \\<notin> set_of ta \\<longrightarrow>\n          nexta p = nextb p)) \\<longrightarrow>\n  (\\<exists>ll'.\n      Levellist (levellist[var p := p]) (nextb(p := levellist ! var p))\n       ll' \\<and>\n      wf_levellist t ll ll' var \\<and>\n      wf_marking t mark (markb(p := m)) m \\<and>\n      (\\<forall>pa.\n          pa \\<notin> set_of t \\<longrightarrow>\n          next pa = (nextb(p := levellist ! var p)) pa)))))\n 2. \\<And>ll t var low high mark next p levellist m.\n       \\<lbrakk>Dag p low high t; ordered t var;\n        Levellist levellist next ll;\n        \\<forall>n\\<in>set_of t.\n           if mark n = m\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt p.\n                    Dag n low high nt \\<and>\n                    p \\<in> set_of nt \\<longrightarrow>\n                    mark p = m)\n           else n \\<notin> set (concat ll);\n        p \\<noteq> Null; var p < length levellist\\<rbrakk>\n       \\<Longrightarrow> \\<not> mark p \\<noteq> m \\<longrightarrow>\n                         (\\<exists>ll'.\n                             Levellist levellist next ll' \\<and>\n                             wf_levellist t ll ll' var \\<and>\n                             wf_marking t mark mark m \\<and>\n                             (\\<forall>p.\n                                 p \\<notin> set_of t \\<longrightarrow>\n                                 next p = next p))\n 3. \\<And>ll t var low high mark next p levellist m.\n       \\<lbrakk>Dag p low high t;\n        p \\<noteq> Null \\<longrightarrow> var p < length levellist;\n        ordered t var; Levellist levellist next ll;\n        \\<forall>n\\<in>set_of t.\n           if mark n = m\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt p.\n                    Dag n low high nt \\<and>\n                    p \\<in> set_of nt \\<longrightarrow>\n                    mark p = m)\n           else n \\<notin> set (concat ll)\\<rbrakk>\n       \\<Longrightarrow> \\<not> p \\<noteq> Null \\<longrightarrow>\n                         (\\<exists>ll'.\n                             Levellist levellist next ll' \\<and>\n                             wf_levellist t ll ll' var \\<and>\n                             wf_marking t mark mark m \\<and>\n                             (\\<forall>p.\n                                 p \\<notin> set_of t \\<longrightarrow>\n                                 next p = next p))", "apply   (clarsimp simp del: BinDag.set_of.simps split del: if_split)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ll var low high mark next p levellist m lt rt.\n       \\<lbrakk>ordered (Node lt p rt) var; Levellist levellist next ll;\n        \\<forall>n\\<in>set_of (Node lt p rt).\n           if mark n = m\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt p.\n                    Dag n low high nt \\<and>\n                    p \\<in> set_of nt \\<longrightarrow>\n                    mark p = m)\n           else n \\<notin> set (concat ll);\n        p \\<noteq> Null; var p < length levellist; mark p = (\\<not> m);\n        Dag (low p) low high lt; Dag (high p) low high rt\\<rbrakk>\n       \\<Longrightarrow> (low p \\<noteq> Null \\<longrightarrow>\n                          var (low p) < length levellist) \\<and>\n                         ordered lt var \\<and>\n                         (\\<forall>n\\<in>set_of lt.\n                             if mark n = m\n                             then n \\<in> set (ll ! var n) \\<and>\n                                  (\\<forall>nt p.\nDag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow> mark p = m)\n                             else n \\<notin> set (concat ll)) \\<and>\n                         size (dag (low p) low high)\n                         < size (dag p low high) \\<and>\n                         (\\<forall>marka nexta levellist.\n                             (\\<exists>ll'.\n                                 Levellist levellist nexta ll' \\<and>\n                                 wf_levellist lt ll ll' var \\<and>\n                                 wf_marking lt mark marka m \\<and>\n                                 (\\<forall>p.\n                                     p \\<notin> set_of lt \\<longrightarrow>\n                                     next p = nexta p)) \\<longrightarrow>\n                             (high p \\<noteq> Null \\<longrightarrow>\n                              var (high p) < length levellist) \\<and>\n                             ordered rt var \\<and>\n                             (\\<exists>lla.\n                                 Levellist levellist nexta lla \\<and>\n                                 (\\<forall>n\\<in>set_of rt.\n                                     if marka n = m\n                                     then n \\<in> set (lla ! var n) \\<and>\n    (\\<forall>nt p.\n        Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n        marka p = m)\n                                     else n\n    \\<notin> set (concat lla)) \\<and>\n                                 size (dag (high p) low high)\n                                 < size (dag p low high) \\<and>\n                                 (\\<forall>markb nextb levellist.\n                                     (\\<exists>ll'.\n   Levellist levellist nextb ll' \\<and>\n   wf_levellist rt lla ll' var \\<and>\n   wf_marking rt marka markb m \\<and>\n   (\\<forall>p.\n       p \\<notin> set_of rt \\<longrightarrow>\n       nexta p = nextb p)) \\<longrightarrow>\n                                     (\\<exists>ll'.\n   Levellist (levellist[var p := p]) (nextb(p := levellist ! var p))\n    ll' \\<and>\n   wf_levellist (Node lt p rt) ll ll' var \\<and>\n   wf_marking (Node lt p rt) mark (markb(p := m)) m \\<and>\n   (\\<forall>pa.\n       pa \\<notin> set_of (Node lt p rt) \\<longrightarrow>\n       next pa = (if pa = p then levellist ! var p else nextb pa))))))\n 2. \\<And>ll t var low high mark next p levellist m.\n       \\<lbrakk>Dag p low high t; ordered t var;\n        Levellist levellist next ll;\n        \\<forall>n\\<in>set_of t.\n           if mark n = m\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt p.\n                    Dag n low high nt \\<and>\n                    p \\<in> set_of nt \\<longrightarrow>\n                    mark p = m)\n           else n \\<notin> set (concat ll);\n        p \\<noteq> Null; var p < length levellist\\<rbrakk>\n       \\<Longrightarrow> \\<not> mark p \\<noteq> m \\<longrightarrow>\n                         (\\<exists>ll'.\n                             Levellist levellist next ll' \\<and>\n                             wf_levellist t ll ll' var \\<and>\n                             wf_marking t mark mark m \\<and>\n                             (\\<forall>p.\n                                 p \\<notin> set_of t \\<longrightarrow>\n                                 next p = next p))\n 3. \\<And>ll t var low high mark next p levellist m.\n       \\<lbrakk>Dag p low high t;\n        p \\<noteq> Null \\<longrightarrow> var p < length levellist;\n        ordered t var; Levellist levellist next ll;\n        \\<forall>n\\<in>set_of t.\n           if mark n = m\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt p.\n                    Dag n low high nt \\<and>\n                    p \\<in> set_of nt \\<longrightarrow>\n                    mark p = m)\n           else n \\<notin> set (concat ll)\\<rbrakk>\n       \\<Longrightarrow> \\<not> p \\<noteq> Null \\<longrightarrow>\n                         (\\<exists>ll'.\n                             Levellist levellist next ll' \\<and>\n                             wf_levellist t ll ll' var \\<and>\n                             wf_marking t mark mark m \\<and>\n                             (\\<forall>p.\n                                 p \\<notin> set_of t \\<longrightarrow>\n                                 next p = next p))", "defer"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ll t var low high mark next p levellist m.\n       \\<lbrakk>Dag p low high t; ordered t var;\n        Levellist levellist next ll;\n        \\<forall>n\\<in>set_of t.\n           if mark n = m\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt p.\n                    Dag n low high nt \\<and>\n                    p \\<in> set_of nt \\<longrightarrow>\n                    mark p = m)\n           else n \\<notin> set (concat ll);\n        p \\<noteq> Null; var p < length levellist\\<rbrakk>\n       \\<Longrightarrow> \\<not> mark p \\<noteq> m \\<longrightarrow>\n                         (\\<exists>ll'.\n                             Levellist levellist next ll' \\<and>\n                             wf_levellist t ll ll' var \\<and>\n                             wf_marking t mark mark m \\<and>\n                             (\\<forall>p.\n                                 p \\<notin> set_of t \\<longrightarrow>\n                                 next p = next p))\n 2. \\<And>ll t var low high mark next p levellist m.\n       \\<lbrakk>Dag p low high t;\n        p \\<noteq> Null \\<longrightarrow> var p < length levellist;\n        ordered t var; Levellist levellist next ll;\n        \\<forall>n\\<in>set_of t.\n           if mark n = m\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt p.\n                    Dag n low high nt \\<and>\n                    p \\<in> set_of nt \\<longrightarrow>\n                    mark p = m)\n           else n \\<notin> set (concat ll)\\<rbrakk>\n       \\<Longrightarrow> \\<not> p \\<noteq> Null \\<longrightarrow>\n                         (\\<exists>ll'.\n                             Levellist levellist next ll' \\<and>\n                             wf_levellist t ll ll' var \\<and>\n                             wf_marking t mark mark m \\<and>\n                             (\\<forall>p.\n                                 p \\<notin> set_of t \\<longrightarrow>\n                                 next p = next p))\n 3. \\<And>ll var low high mark next p levellist m lt rt.\n       \\<lbrakk>ordered (Node lt p rt) var; Levellist levellist next ll;\n        \\<forall>n\\<in>set_of (Node lt p rt).\n           if mark n = m\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt p.\n                    Dag n low high nt \\<and>\n                    p \\<in> set_of nt \\<longrightarrow>\n                    mark p = m)\n           else n \\<notin> set (concat ll);\n        p \\<noteq> Null; var p < length levellist; mark p = (\\<not> m);\n        Dag (low p) low high lt; Dag (high p) low high rt\\<rbrakk>\n       \\<Longrightarrow> (low p \\<noteq> Null \\<longrightarrow>\n                          var (low p) < length levellist) \\<and>\n                         ordered lt var \\<and>\n                         (\\<forall>n\\<in>set_of lt.\n                             if mark n = m\n                             then n \\<in> set (ll ! var n) \\<and>\n                                  (\\<forall>nt p.\nDag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow> mark p = m)\n                             else n \\<notin> set (concat ll)) \\<and>\n                         size (dag (low p) low high)\n                         < size (dag p low high) \\<and>\n                         (\\<forall>marka nexta levellist.\n                             (\\<exists>ll'.\n                                 Levellist levellist nexta ll' \\<and>\n                                 wf_levellist lt ll ll' var \\<and>\n                                 wf_marking lt mark marka m \\<and>\n                                 (\\<forall>p.\n                                     p \\<notin> set_of lt \\<longrightarrow>\n                                     next p = nexta p)) \\<longrightarrow>\n                             (high p \\<noteq> Null \\<longrightarrow>\n                              var (high p) < length levellist) \\<and>\n                             ordered rt var \\<and>\n                             (\\<exists>lla.\n                                 Levellist levellist nexta lla \\<and>\n                                 (\\<forall>n\\<in>set_of rt.\n                                     if marka n = m\n                                     then n \\<in> set (lla ! var n) \\<and>\n    (\\<forall>nt p.\n        Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n        marka p = m)\n                                     else n\n    \\<notin> set (concat lla)) \\<and>\n                                 size (dag (high p) low high)\n                                 < size (dag p low high) \\<and>\n                                 (\\<forall>markb nextb levellist.\n                                     (\\<exists>ll'.\n   Levellist levellist nextb ll' \\<and>\n   wf_levellist rt lla ll' var \\<and>\n   wf_marking rt marka markb m \\<and>\n   (\\<forall>p.\n       p \\<notin> set_of rt \\<longrightarrow>\n       nexta p = nextb p)) \\<longrightarrow>\n                                     (\\<exists>ll'.\n   Levellist (levellist[var p := p]) (nextb(p := levellist ! var p))\n    ll' \\<and>\n   wf_levellist (Node lt p rt) ll ll' var \\<and>\n   wf_marking (Node lt p rt) mark (markb(p := m)) m \\<and>\n   (\\<forall>pa.\n       pa \\<notin> set_of (Node lt p rt) \\<longrightarrow>\n       next pa = (if pa = p then levellist ! var p else nextb pa))))))", "apply   (rule impI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ll t var low high mark next p levellist m.\n       \\<lbrakk>Dag p low high t; ordered t var;\n        Levellist levellist next ll;\n        \\<forall>n\\<in>set_of t.\n           if mark n = m\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt p.\n                    Dag n low high nt \\<and>\n                    p \\<in> set_of nt \\<longrightarrow>\n                    mark p = m)\n           else n \\<notin> set (concat ll);\n        p \\<noteq> Null; var p < length levellist;\n        \\<not> mark p \\<noteq> m\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ll'.\n                            Levellist levellist next ll' \\<and>\n                            wf_levellist t ll ll' var \\<and>\n                            wf_marking t mark mark m \\<and>\n                            (\\<forall>p.\n                                p \\<notin> set_of t \\<longrightarrow>\n                                next p = next p)\n 2. \\<And>ll t var low high mark next p levellist m.\n       \\<lbrakk>Dag p low high t;\n        p \\<noteq> Null \\<longrightarrow> var p < length levellist;\n        ordered t var; Levellist levellist next ll;\n        \\<forall>n\\<in>set_of t.\n           if mark n = m\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt p.\n                    Dag n low high nt \\<and>\n                    p \\<in> set_of nt \\<longrightarrow>\n                    mark p = m)\n           else n \\<notin> set (concat ll)\\<rbrakk>\n       \\<Longrightarrow> \\<not> p \\<noteq> Null \\<longrightarrow>\n                         (\\<exists>ll'.\n                             Levellist levellist next ll' \\<and>\n                             wf_levellist t ll ll' var \\<and>\n                             wf_marking t mark mark m \\<and>\n                             (\\<forall>p.\n                                 p \\<notin> set_of t \\<longrightarrow>\n                                 next p = next p))\n 3. \\<And>ll var low high mark next p levellist m lt rt.\n       \\<lbrakk>ordered (Node lt p rt) var; Levellist levellist next ll;\n        \\<forall>n\\<in>set_of (Node lt p rt).\n           if mark n = m\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt p.\n                    Dag n low high nt \\<and>\n                    p \\<in> set_of nt \\<longrightarrow>\n                    mark p = m)\n           else n \\<notin> set (concat ll);\n        p \\<noteq> Null; var p < length levellist; mark p = (\\<not> m);\n        Dag (low p) low high lt; Dag (high p) low high rt\\<rbrakk>\n       \\<Longrightarrow> (low p \\<noteq> Null \\<longrightarrow>\n                          var (low p) < length levellist) \\<and>\n                         ordered lt var \\<and>\n                         (\\<forall>n\\<in>set_of lt.\n                             if mark n = m\n                             then n \\<in> set (ll ! var n) \\<and>\n                                  (\\<forall>nt p.\nDag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow> mark p = m)\n                             else n \\<notin> set (concat ll)) \\<and>\n                         size (dag (low p) low high)\n                         < size (dag p low high) \\<and>\n                         (\\<forall>marka nexta levellist.\n                             (\\<exists>ll'.\n                                 Levellist levellist nexta ll' \\<and>\n                                 wf_levellist lt ll ll' var \\<and>\n                                 wf_marking lt mark marka m \\<and>\n                                 (\\<forall>p.\n                                     p \\<notin> set_of lt \\<longrightarrow>\n                                     next p = nexta p)) \\<longrightarrow>\n                             (high p \\<noteq> Null \\<longrightarrow>\n                              var (high p) < length levellist) \\<and>\n                             ordered rt var \\<and>\n                             (\\<exists>lla.\n                                 Levellist levellist nexta lla \\<and>\n                                 (\\<forall>n\\<in>set_of rt.\n                                     if marka n = m\n                                     then n \\<in> set (lla ! var n) \\<and>\n    (\\<forall>nt p.\n        Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n        marka p = m)\n                                     else n\n    \\<notin> set (concat lla)) \\<and>\n                                 size (dag (high p) low high)\n                                 < size (dag p low high) \\<and>\n                                 (\\<forall>markb nextb levellist.\n                                     (\\<exists>ll'.\n   Levellist levellist nextb ll' \\<and>\n   wf_levellist rt lla ll' var \\<and>\n   wf_marking rt marka markb m \\<and>\n   (\\<forall>p.\n       p \\<notin> set_of rt \\<longrightarrow>\n       nexta p = nextb p)) \\<longrightarrow>\n                                     (\\<exists>ll'.\n   Levellist (levellist[var p := p]) (nextb(p := levellist ! var p))\n    ll' \\<and>\n   wf_levellist (Node lt p rt) ll ll' var \\<and>\n   wf_marking (Node lt p rt) mark (markb(p := m)) m \\<and>\n   (\\<forall>pa.\n       pa \\<notin> set_of (Node lt p rt) \\<longrightarrow>\n       next pa = (if pa = p then levellist ! var p else nextb pa))))))", "apply   (clarsimp simp del: BinDag.set_of.simps split del: if_split)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ll var low high mark next p levellist lt rt.\n       \\<lbrakk>ordered (Node lt p rt) var; Levellist levellist next ll;\n        \\<forall>n\\<in>set_of (Node lt p rt).\n           if mark n = mark p\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt pa.\n                    Dag n low high nt \\<and>\n                    pa \\<in> set_of nt \\<longrightarrow>\n                    mark pa = mark p)\n           else n \\<notin> set (concat ll);\n        p \\<noteq> Null; var p < length levellist; Dag (low p) low high lt;\n        Dag (high p) low high rt\\<rbrakk>\n       \\<Longrightarrow> wf_levellist (Node lt p rt) ll ll var \\<and>\n                         wf_marking (Node lt p rt) mark mark (mark p)\n 2. \\<And>ll t var low high mark next p levellist m.\n       \\<lbrakk>Dag p low high t;\n        p \\<noteq> Null \\<longrightarrow> var p < length levellist;\n        ordered t var; Levellist levellist next ll;\n        \\<forall>n\\<in>set_of t.\n           if mark n = m\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt p.\n                    Dag n low high nt \\<and>\n                    p \\<in> set_of nt \\<longrightarrow>\n                    mark p = m)\n           else n \\<notin> set (concat ll)\\<rbrakk>\n       \\<Longrightarrow> \\<not> p \\<noteq> Null \\<longrightarrow>\n                         (\\<exists>ll'.\n                             Levellist levellist next ll' \\<and>\n                             wf_levellist t ll ll' var \\<and>\n                             wf_marking t mark mark m \\<and>\n                             (\\<forall>p.\n                                 p \\<notin> set_of t \\<longrightarrow>\n                                 next p = next p))\n 3. \\<And>ll var low high mark next p levellist m lt rt.\n       \\<lbrakk>ordered (Node lt p rt) var; Levellist levellist next ll;\n        \\<forall>n\\<in>set_of (Node lt p rt).\n           if mark n = m\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt p.\n                    Dag n low high nt \\<and>\n                    p \\<in> set_of nt \\<longrightarrow>\n                    mark p = m)\n           else n \\<notin> set (concat ll);\n        p \\<noteq> Null; var p < length levellist; mark p = (\\<not> m);\n        Dag (low p) low high lt; Dag (high p) low high rt\\<rbrakk>\n       \\<Longrightarrow> (low p \\<noteq> Null \\<longrightarrow>\n                          var (low p) < length levellist) \\<and>\n                         ordered lt var \\<and>\n                         (\\<forall>n\\<in>set_of lt.\n                             if mark n = m\n                             then n \\<in> set (ll ! var n) \\<and>\n                                  (\\<forall>nt p.\nDag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow> mark p = m)\n                             else n \\<notin> set (concat ll)) \\<and>\n                         size (dag (low p) low high)\n                         < size (dag p low high) \\<and>\n                         (\\<forall>marka nexta levellist.\n                             (\\<exists>ll'.\n                                 Levellist levellist nexta ll' \\<and>\n                                 wf_levellist lt ll ll' var \\<and>\n                                 wf_marking lt mark marka m \\<and>\n                                 (\\<forall>p.\n                                     p \\<notin> set_of lt \\<longrightarrow>\n                                     next p = nexta p)) \\<longrightarrow>\n                             (high p \\<noteq> Null \\<longrightarrow>\n                              var (high p) < length levellist) \\<and>\n                             ordered rt var \\<and>\n                             (\\<exists>lla.\n                                 Levellist levellist nexta lla \\<and>\n                                 (\\<forall>n\\<in>set_of rt.\n                                     if marka n = m\n                                     then n \\<in> set (lla ! var n) \\<and>\n    (\\<forall>nt p.\n        Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n        marka p = m)\n                                     else n\n    \\<notin> set (concat lla)) \\<and>\n                                 size (dag (high p) low high)\n                                 < size (dag p low high) \\<and>\n                                 (\\<forall>markb nextb levellist.\n                                     (\\<exists>ll'.\n   Levellist levellist nextb ll' \\<and>\n   wf_levellist rt lla ll' var \\<and>\n   wf_marking rt marka markb m \\<and>\n   (\\<forall>p.\n       p \\<notin> set_of rt \\<longrightarrow>\n       nexta p = nextb p)) \\<longrightarrow>\n                                     (\\<exists>ll'.\n   Levellist (levellist[var p := p]) (nextb(p := levellist ! var p))\n    ll' \\<and>\n   wf_levellist (Node lt p rt) ll ll' var \\<and>\n   wf_marking (Node lt p rt) mark (markb(p := m)) m \\<and>\n   (\\<forall>pa.\n       pa \\<notin> set_of (Node lt p rt) \\<longrightarrow>\n       next pa = (if pa = p then levellist ! var p else nextb pa))))))", "defer"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ll t var low high mark next p levellist m.\n       \\<lbrakk>Dag p low high t;\n        p \\<noteq> Null \\<longrightarrow> var p < length levellist;\n        ordered t var; Levellist levellist next ll;\n        \\<forall>n\\<in>set_of t.\n           if mark n = m\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt p.\n                    Dag n low high nt \\<and>\n                    p \\<in> set_of nt \\<longrightarrow>\n                    mark p = m)\n           else n \\<notin> set (concat ll)\\<rbrakk>\n       \\<Longrightarrow> \\<not> p \\<noteq> Null \\<longrightarrow>\n                         (\\<exists>ll'.\n                             Levellist levellist next ll' \\<and>\n                             wf_levellist t ll ll' var \\<and>\n                             wf_marking t mark mark m \\<and>\n                             (\\<forall>p.\n                                 p \\<notin> set_of t \\<longrightarrow>\n                                 next p = next p))\n 2. \\<And>ll var low high mark next p levellist m lt rt.\n       \\<lbrakk>ordered (Node lt p rt) var; Levellist levellist next ll;\n        \\<forall>n\\<in>set_of (Node lt p rt).\n           if mark n = m\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt p.\n                    Dag n low high nt \\<and>\n                    p \\<in> set_of nt \\<longrightarrow>\n                    mark p = m)\n           else n \\<notin> set (concat ll);\n        p \\<noteq> Null; var p < length levellist; mark p = (\\<not> m);\n        Dag (low p) low high lt; Dag (high p) low high rt\\<rbrakk>\n       \\<Longrightarrow> (low p \\<noteq> Null \\<longrightarrow>\n                          var (low p) < length levellist) \\<and>\n                         ordered lt var \\<and>\n                         (\\<forall>n\\<in>set_of lt.\n                             if mark n = m\n                             then n \\<in> set (ll ! var n) \\<and>\n                                  (\\<forall>nt p.\nDag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow> mark p = m)\n                             else n \\<notin> set (concat ll)) \\<and>\n                         size (dag (low p) low high)\n                         < size (dag p low high) \\<and>\n                         (\\<forall>marka nexta levellist.\n                             (\\<exists>ll'.\n                                 Levellist levellist nexta ll' \\<and>\n                                 wf_levellist lt ll ll' var \\<and>\n                                 wf_marking lt mark marka m \\<and>\n                                 (\\<forall>p.\n                                     p \\<notin> set_of lt \\<longrightarrow>\n                                     next p = nexta p)) \\<longrightarrow>\n                             (high p \\<noteq> Null \\<longrightarrow>\n                              var (high p) < length levellist) \\<and>\n                             ordered rt var \\<and>\n                             (\\<exists>lla.\n                                 Levellist levellist nexta lla \\<and>\n                                 (\\<forall>n\\<in>set_of rt.\n                                     if marka n = m\n                                     then n \\<in> set (lla ! var n) \\<and>\n    (\\<forall>nt p.\n        Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n        marka p = m)\n                                     else n\n    \\<notin> set (concat lla)) \\<and>\n                                 size (dag (high p) low high)\n                                 < size (dag p low high) \\<and>\n                                 (\\<forall>markb nextb levellist.\n                                     (\\<exists>ll'.\n   Levellist levellist nextb ll' \\<and>\n   wf_levellist rt lla ll' var \\<and>\n   wf_marking rt marka markb m \\<and>\n   (\\<forall>p.\n       p \\<notin> set_of rt \\<longrightarrow>\n       nexta p = nextb p)) \\<longrightarrow>\n                                     (\\<exists>ll'.\n   Levellist (levellist[var p := p]) (nextb(p := levellist ! var p))\n    ll' \\<and>\n   wf_levellist (Node lt p rt) ll ll' var \\<and>\n   wf_marking (Node lt p rt) mark (markb(p := m)) m \\<and>\n   (\\<forall>pa.\n       pa \\<notin> set_of (Node lt p rt) \\<longrightarrow>\n       next pa = (if pa = p then levellist ! var p else nextb pa))))))\n 3. \\<And>ll var low high mark next p levellist lt rt.\n       \\<lbrakk>ordered (Node lt p rt) var; Levellist levellist next ll;\n        \\<forall>n\\<in>set_of (Node lt p rt).\n           if mark n = mark p\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt pa.\n                    Dag n low high nt \\<and>\n                    pa \\<in> set_of nt \\<longrightarrow>\n                    mark pa = mark p)\n           else n \\<notin> set (concat ll);\n        p \\<noteq> Null; var p < length levellist; Dag (low p) low high lt;\n        Dag (high p) low high rt\\<rbrakk>\n       \\<Longrightarrow> wf_levellist (Node lt p rt) ll ll var \\<and>\n                         wf_marking (Node lt p rt) mark mark (mark p)", "apply   (clarsimp simp add: wf_levellist_def wf_marking_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ll var low high mark next p levellist m lt rt.\n       \\<lbrakk>ordered (Node lt p rt) var; Levellist levellist next ll;\n        \\<forall>n\\<in>set_of (Node lt p rt).\n           if mark n = m\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt p.\n                    Dag n low high nt \\<and>\n                    p \\<in> set_of nt \\<longrightarrow>\n                    mark p = m)\n           else n \\<notin> set (concat ll);\n        p \\<noteq> Null; var p < length levellist; mark p = (\\<not> m);\n        Dag (low p) low high lt; Dag (high p) low high rt\\<rbrakk>\n       \\<Longrightarrow> (low p \\<noteq> Null \\<longrightarrow>\n                          var (low p) < length levellist) \\<and>\n                         ordered lt var \\<and>\n                         (\\<forall>n\\<in>set_of lt.\n                             if mark n = m\n                             then n \\<in> set (ll ! var n) \\<and>\n                                  (\\<forall>nt p.\nDag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow> mark p = m)\n                             else n \\<notin> set (concat ll)) \\<and>\n                         size (dag (low p) low high)\n                         < size (dag p low high) \\<and>\n                         (\\<forall>marka nexta levellist.\n                             (\\<exists>ll'.\n                                 Levellist levellist nexta ll' \\<and>\n                                 wf_levellist lt ll ll' var \\<and>\n                                 wf_marking lt mark marka m \\<and>\n                                 (\\<forall>p.\n                                     p \\<notin> set_of lt \\<longrightarrow>\n                                     next p = nexta p)) \\<longrightarrow>\n                             (high p \\<noteq> Null \\<longrightarrow>\n                              var (high p) < length levellist) \\<and>\n                             ordered rt var \\<and>\n                             (\\<exists>lla.\n                                 Levellist levellist nexta lla \\<and>\n                                 (\\<forall>n\\<in>set_of rt.\n                                     if marka n = m\n                                     then n \\<in> set (lla ! var n) \\<and>\n    (\\<forall>nt p.\n        Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n        marka p = m)\n                                     else n\n    \\<notin> set (concat lla)) \\<and>\n                                 size (dag (high p) low high)\n                                 < size (dag p low high) \\<and>\n                                 (\\<forall>markb nextb levellist.\n                                     (\\<exists>ll'.\n   Levellist levellist nextb ll' \\<and>\n   wf_levellist rt lla ll' var \\<and>\n   wf_marking rt marka markb m \\<and>\n   (\\<forall>p.\n       p \\<notin> set_of rt \\<longrightarrow>\n       nexta p = nextb p)) \\<longrightarrow>\n                                     (\\<exists>ll'.\n   Levellist (levellist[var p := p]) (nextb(p := levellist ! var p))\n    ll' \\<and>\n   wf_levellist (Node lt p rt) ll ll' var \\<and>\n   wf_marking (Node lt p rt) mark (markb(p := m)) m \\<and>\n   (\\<forall>pa.\n       pa \\<notin> set_of (Node lt p rt) \\<longrightarrow>\n       next pa = (if pa = p then levellist ! var p else nextb pa))))))\n 2. \\<And>ll var low high mark next p levellist lt rt.\n       \\<lbrakk>ordered (Node lt p rt) var; Levellist levellist next ll;\n        \\<forall>n\\<in>set_of (Node lt p rt).\n           if mark n = mark p\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt pa.\n                    Dag n low high nt \\<and>\n                    pa \\<in> set_of nt \\<longrightarrow>\n                    mark pa = mark p)\n           else n \\<notin> set (concat ll);\n        p \\<noteq> Null; var p < length levellist; Dag (low p) low high lt;\n        Dag (high p) low high rt\\<rbrakk>\n       \\<Longrightarrow> wf_levellist (Node lt p rt) ll ll var \\<and>\n                         wf_marking (Node lt p rt) mark mark (mark p)", "(* p=Null*)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ll var low high mark next p levellist m lt rt.\n       \\<lbrakk>ordered (Node lt p rt) var; Levellist levellist next ll;\n        \\<forall>n\\<in>set_of (Node lt p rt).\n           if mark n = m\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt p.\n                    Dag n low high nt \\<and>\n                    p \\<in> set_of nt \\<longrightarrow>\n                    mark p = m)\n           else n \\<notin> set (concat ll);\n        p \\<noteq> Null; var p < length levellist; mark p = (\\<not> m);\n        Dag (low p) low high lt; Dag (high p) low high rt\\<rbrakk>\n       \\<Longrightarrow> (low p \\<noteq> Null \\<longrightarrow>\n                          var (low p) < length levellist) \\<and>\n                         ordered lt var \\<and>\n                         (\\<forall>n\\<in>set_of lt.\n                             if mark n = m\n                             then n \\<in> set (ll ! var n) \\<and>\n                                  (\\<forall>nt p.\nDag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow> mark p = m)\n                             else n \\<notin> set (concat ll)) \\<and>\n                         size (dag (low p) low high)\n                         < size (dag p low high) \\<and>\n                         (\\<forall>marka nexta levellist.\n                             (\\<exists>ll'.\n                                 Levellist levellist nexta ll' \\<and>\n                                 wf_levellist lt ll ll' var \\<and>\n                                 wf_marking lt mark marka m \\<and>\n                                 (\\<forall>p.\n                                     p \\<notin> set_of lt \\<longrightarrow>\n                                     next p = nexta p)) \\<longrightarrow>\n                             (high p \\<noteq> Null \\<longrightarrow>\n                              var (high p) < length levellist) \\<and>\n                             ordered rt var \\<and>\n                             (\\<exists>lla.\n                                 Levellist levellist nexta lla \\<and>\n                                 (\\<forall>n\\<in>set_of rt.\n                                     if marka n = m\n                                     then n \\<in> set (lla ! var n) \\<and>\n    (\\<forall>nt p.\n        Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n        marka p = m)\n                                     else n\n    \\<notin> set (concat lla)) \\<and>\n                                 size (dag (high p) low high)\n                                 < size (dag p low high) \\<and>\n                                 (\\<forall>markb nextb levellist.\n                                     (\\<exists>ll'.\n   Levellist levellist nextb ll' \\<and>\n   wf_levellist rt lla ll' var \\<and>\n   wf_marking rt marka markb m \\<and>\n   (\\<forall>p.\n       p \\<notin> set_of rt \\<longrightarrow>\n       nexta p = nextb p)) \\<longrightarrow>\n                                     (\\<exists>ll'.\n   Levellist (levellist[var p := p]) (nextb(p := levellist ! var p))\n    ll' \\<and>\n   wf_levellist (Node lt p rt) ll ll' var \\<and>\n   wf_marking (Node lt p rt) mark (markb(p := m)) m \\<and>\n   (\\<forall>pa.\n       pa \\<notin> set_of (Node lt p rt) \\<longrightarrow>\n       next pa = (if pa = p then levellist ! var p else nextb pa))))))\n 2. \\<And>ll var low high mark next p levellist lt rt.\n       \\<lbrakk>ordered (Node lt p rt) var; Levellist levellist next ll;\n        \\<forall>n\\<in>set_of (Node lt p rt).\n           if mark n = mark p\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt pa.\n                    Dag n low high nt \\<and>\n                    pa \\<in> set_of nt \\<longrightarrow>\n                    mark pa = mark p)\n           else n \\<notin> set (concat ll);\n        p \\<noteq> Null; var p < length levellist; Dag (low p) low high lt;\n        Dag (high p) low high rt\\<rbrakk>\n       \\<Longrightarrow> wf_levellist (Node lt p rt) ll ll var \\<and>\n                         wf_marking (Node lt p rt) mark mark (mark p)", "apply (simp only: Levellist_ext_to_all )"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ll var low high mark next p levellist m lt rt.\n       \\<lbrakk>ordered (Node lt p rt) var; Levellist levellist next ll;\n        \\<forall>n\\<in>set_of (Node lt p rt).\n           if mark n = m\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt p.\n                    Dag n low high nt \\<and>\n                    p \\<in> set_of nt \\<longrightarrow>\n                    mark p = m)\n           else n \\<notin> set (concat ll);\n        p \\<noteq> Null; var p < length levellist; mark p = (\\<not> m);\n        Dag (low p) low high lt; Dag (high p) low high rt\\<rbrakk>\n       \\<Longrightarrow> (low p \\<noteq> Null \\<longrightarrow>\n                          var (low p) < length levellist) \\<and>\n                         ordered lt var \\<and>\n                         (\\<forall>n\\<in>set_of lt.\n                             if mark n = m\n                             then n \\<in> set (ll ! var n) \\<and>\n                                  (\\<forall>nt p.\nDag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow> mark p = m)\n                             else n \\<notin> set (concat ll)) \\<and>\n                         size (dag (low p) low high)\n                         < size (dag p low high) \\<and>\n                         (\\<forall>marka nexta levellist ll'.\n                             Levellist levellist nexta ll' \\<and>\n                             wf_levellist lt ll ll' var \\<and>\n                             wf_marking lt mark marka m \\<and>\n                             (\\<forall>p.\n                                 p \\<notin> set_of lt \\<longrightarrow>\n                                 next p = nexta p) \\<longrightarrow>\n                             (high p \\<noteq> Null \\<longrightarrow>\n                              var (high p) < length levellist) \\<and>\n                             ordered rt var \\<and>\n                             (\\<exists>lla.\n                                 Levellist levellist nexta lla \\<and>\n                                 (\\<forall>n\\<in>set_of rt.\n                                     if marka n = m\n                                     then n \\<in> set (lla ! var n) \\<and>\n    (\\<forall>nt p.\n        Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n        marka p = m)\n                                     else n\n    \\<notin> set (concat lla)) \\<and>\n                                 size (dag (high p) low high)\n                                 < size (dag p low high) \\<and>\n                                 (\\<forall>markb nextb levellist ll'.\n                                     Levellist levellist nextb ll' \\<and>\n                                     wf_levellist rt lla ll' var \\<and>\n                                     wf_marking rt marka markb m \\<and>\n                                     (\\<forall>p.\n   p \\<notin> set_of rt \\<longrightarrow>\n   nexta p = nextb p) \\<longrightarrow>\n                                     (\\<exists>ll'.\n   Levellist (levellist[var p := p]) (nextb(p := levellist ! var p))\n    ll' \\<and>\n   wf_levellist (Node lt p rt) ll ll' var \\<and>\n   wf_marking (Node lt p rt) mark (markb(p := m)) m \\<and>\n   (\\<forall>pa.\n       pa \\<notin> set_of (Node lt p rt) \\<longrightarrow>\n       next pa = (if pa = p then levellist ! var p else nextb pa))))))\n 2. \\<And>ll var low high mark next p levellist lt rt.\n       \\<lbrakk>ordered (Node lt p rt) var; Levellist levellist next ll;\n        \\<forall>n\\<in>set_of (Node lt p rt).\n           if mark n = mark p\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt pa.\n                    Dag n low high nt \\<and>\n                    pa \\<in> set_of nt \\<longrightarrow>\n                    mark pa = mark p)\n           else n \\<notin> set (concat ll);\n        p \\<noteq> Null; var p < length levellist; Dag (low p) low high lt;\n        Dag (high p) low high rt\\<rbrakk>\n       \\<Longrightarrow> wf_levellist (Node lt p rt) ll ll var \\<and>\n                         wf_marking (Node lt p rt) mark mark (mark p)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ll var low high mark next p levellist m lt rt.\n       \\<lbrakk>ordered (Node lt p rt) var; Levellist levellist next ll;\n        \\<forall>n\\<in>set_of (Node lt p rt).\n           if mark n = m\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt p.\n                    Dag n low high nt \\<and>\n                    p \\<in> set_of nt \\<longrightarrow>\n                    mark p = m)\n           else n \\<notin> set (concat ll);\n        p \\<noteq> Null; var p < length levellist; mark p = (\\<not> m);\n        Dag (low p) low high lt; Dag (high p) low high rt\\<rbrakk>\n       \\<Longrightarrow> (low p \\<noteq> Null \\<longrightarrow>\n                          var (low p) < length levellist) \\<and>\n                         ordered lt var \\<and>\n                         (\\<forall>n\\<in>set_of lt.\n                             if mark n = m\n                             then n \\<in> set (ll ! var n) \\<and>\n                                  (\\<forall>nt p.\nDag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow> mark p = m)\n                             else n \\<notin> set (concat ll)) \\<and>\n                         size (dag (low p) low high)\n                         < size (dag p low high) \\<and>\n                         (\\<forall>marka nexta levellist ll'.\n                             Levellist levellist nexta ll' \\<and>\n                             wf_levellist lt ll ll' var \\<and>\n                             wf_marking lt mark marka m \\<and>\n                             (\\<forall>p.\n                                 p \\<notin> set_of lt \\<longrightarrow>\n                                 next p = nexta p) \\<longrightarrow>\n                             (high p \\<noteq> Null \\<longrightarrow>\n                              var (high p) < length levellist) \\<and>\n                             ordered rt var \\<and>\n                             (\\<exists>lla.\n                                 Levellist levellist nexta lla \\<and>\n                                 (\\<forall>n\\<in>set_of rt.\n                                     if marka n = m\n                                     then n \\<in> set (lla ! var n) \\<and>\n    (\\<forall>nt p.\n        Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n        marka p = m)\n                                     else n\n    \\<notin> set (concat lla)) \\<and>\n                                 size (dag (high p) low high)\n                                 < size (dag p low high) \\<and>\n                                 (\\<forall>markb nextb levellist ll'.\n                                     Levellist levellist nextb ll' \\<and>\n                                     wf_levellist rt lla ll' var \\<and>\n                                     wf_marking rt marka markb m \\<and>\n                                     (\\<forall>p.\n   p \\<notin> set_of rt \\<longrightarrow>\n   nexta p = nextb p) \\<longrightarrow>\n                                     (\\<exists>ll'.\n   Levellist (levellist[var p := p]) (nextb(p := levellist ! var p))\n    ll' \\<and>\n   wf_levellist (Node lt p rt) ll ll' var \\<and>\n   wf_marking (Node lt p rt) mark (markb(p := m)) m \\<and>\n   (\\<forall>pa.\n       pa \\<notin> set_of (Node lt p rt) \\<longrightarrow>\n       next pa = (if pa = p then levellist ! var p else nextb pa))))))\n 2. \\<And>ll var low high mark next p levellist lt rt.\n       \\<lbrakk>ordered (Node lt p rt) var; Levellist levellist next ll;\n        \\<forall>n\\<in>set_of (Node lt p rt).\n           if mark n = mark p\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt pa.\n                    Dag n low high nt \\<and>\n                    pa \\<in> set_of nt \\<longrightarrow>\n                    mark pa = mark p)\n           else n \\<notin> set (concat ll);\n        p \\<noteq> Null; var p < length levellist; Dag (low p) low high lt;\n        Dag (high p) low high rt\\<rbrakk>\n       \\<Longrightarrow> wf_levellist (Node lt p rt) ll ll var \\<and>\n                         wf_marking (Node lt p rt) mark mark (mark p)", "fix ll var low high mark \"next\" nexta p levellist m lt rt"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ll var low high mark next p levellist m lt rt.\n       \\<lbrakk>ordered (Node lt p rt) var; Levellist levellist next ll;\n        \\<forall>n\\<in>set_of (Node lt p rt).\n           if mark n = m\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt p.\n                    Dag n low high nt \\<and>\n                    p \\<in> set_of nt \\<longrightarrow>\n                    mark p = m)\n           else n \\<notin> set (concat ll);\n        p \\<noteq> Null; var p < length levellist; mark p = (\\<not> m);\n        Dag (low p) low high lt; Dag (high p) low high rt\\<rbrakk>\n       \\<Longrightarrow> (low p \\<noteq> Null \\<longrightarrow>\n                          var (low p) < length levellist) \\<and>\n                         ordered lt var \\<and>\n                         (\\<forall>n\\<in>set_of lt.\n                             if mark n = m\n                             then n \\<in> set (ll ! var n) \\<and>\n                                  (\\<forall>nt p.\nDag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow> mark p = m)\n                             else n \\<notin> set (concat ll)) \\<and>\n                         size (dag (low p) low high)\n                         < size (dag p low high) \\<and>\n                         (\\<forall>marka nexta levellist ll'.\n                             Levellist levellist nexta ll' \\<and>\n                             wf_levellist lt ll ll' var \\<and>\n                             wf_marking lt mark marka m \\<and>\n                             (\\<forall>p.\n                                 p \\<notin> set_of lt \\<longrightarrow>\n                                 next p = nexta p) \\<longrightarrow>\n                             (high p \\<noteq> Null \\<longrightarrow>\n                              var (high p) < length levellist) \\<and>\n                             ordered rt var \\<and>\n                             (\\<exists>lla.\n                                 Levellist levellist nexta lla \\<and>\n                                 (\\<forall>n\\<in>set_of rt.\n                                     if marka n = m\n                                     then n \\<in> set (lla ! var n) \\<and>\n    (\\<forall>nt p.\n        Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n        marka p = m)\n                                     else n\n    \\<notin> set (concat lla)) \\<and>\n                                 size (dag (high p) low high)\n                                 < size (dag p low high) \\<and>\n                                 (\\<forall>markb nextb levellist ll'.\n                                     Levellist levellist nextb ll' \\<and>\n                                     wf_levellist rt lla ll' var \\<and>\n                                     wf_marking rt marka markb m \\<and>\n                                     (\\<forall>p.\n   p \\<notin> set_of rt \\<longrightarrow>\n   nexta p = nextb p) \\<longrightarrow>\n                                     (\\<exists>ll'.\n   Levellist (levellist[var p := p]) (nextb(p := levellist ! var p))\n    ll' \\<and>\n   wf_levellist (Node lt p rt) ll ll' var \\<and>\n   wf_marking (Node lt p rt) mark (markb(p := m)) m \\<and>\n   (\\<forall>pa.\n       pa \\<notin> set_of (Node lt p rt) \\<longrightarrow>\n       next pa = (if pa = p then levellist ! var p else nextb pa))))))\n 2. \\<And>ll var low high mark next p levellist lt rt.\n       \\<lbrakk>ordered (Node lt p rt) var; Levellist levellist next ll;\n        \\<forall>n\\<in>set_of (Node lt p rt).\n           if mark n = mark p\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt pa.\n                    Dag n low high nt \\<and>\n                    pa \\<in> set_of nt \\<longrightarrow>\n                    mark pa = mark p)\n           else n \\<notin> set (concat ll);\n        p \\<noteq> Null; var p < length levellist; Dag (low p) low high lt;\n        Dag (high p) low high rt\\<rbrakk>\n       \\<Longrightarrow> wf_levellist (Node lt p rt) ll ll var \\<and>\n                         wf_marking (Node lt p rt) mark mark (mark p)", "assume pnN: \"p \\<noteq> Null\""], ["proof (state)\nthis:\n  p \\<noteq> Null\n\ngoal (2 subgoals):\n 1. \\<And>ll var low high mark next p levellist m lt rt.\n       \\<lbrakk>ordered (Node lt p rt) var; Levellist levellist next ll;\n        \\<forall>n\\<in>set_of (Node lt p rt).\n           if mark n = m\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt p.\n                    Dag n low high nt \\<and>\n                    p \\<in> set_of nt \\<longrightarrow>\n                    mark p = m)\n           else n \\<notin> set (concat ll);\n        p \\<noteq> Null; var p < length levellist; mark p = (\\<not> m);\n        Dag (low p) low high lt; Dag (high p) low high rt\\<rbrakk>\n       \\<Longrightarrow> (low p \\<noteq> Null \\<longrightarrow>\n                          var (low p) < length levellist) \\<and>\n                         ordered lt var \\<and>\n                         (\\<forall>n\\<in>set_of lt.\n                             if mark n = m\n                             then n \\<in> set (ll ! var n) \\<and>\n                                  (\\<forall>nt p.\nDag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow> mark p = m)\n                             else n \\<notin> set (concat ll)) \\<and>\n                         size (dag (low p) low high)\n                         < size (dag p low high) \\<and>\n                         (\\<forall>marka nexta levellist ll'.\n                             Levellist levellist nexta ll' \\<and>\n                             wf_levellist lt ll ll' var \\<and>\n                             wf_marking lt mark marka m \\<and>\n                             (\\<forall>p.\n                                 p \\<notin> set_of lt \\<longrightarrow>\n                                 next p = nexta p) \\<longrightarrow>\n                             (high p \\<noteq> Null \\<longrightarrow>\n                              var (high p) < length levellist) \\<and>\n                             ordered rt var \\<and>\n                             (\\<exists>lla.\n                                 Levellist levellist nexta lla \\<and>\n                                 (\\<forall>n\\<in>set_of rt.\n                                     if marka n = m\n                                     then n \\<in> set (lla ! var n) \\<and>\n    (\\<forall>nt p.\n        Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n        marka p = m)\n                                     else n\n    \\<notin> set (concat lla)) \\<and>\n                                 size (dag (high p) low high)\n                                 < size (dag p low high) \\<and>\n                                 (\\<forall>markb nextb levellist ll'.\n                                     Levellist levellist nextb ll' \\<and>\n                                     wf_levellist rt lla ll' var \\<and>\n                                     wf_marking rt marka markb m \\<and>\n                                     (\\<forall>p.\n   p \\<notin> set_of rt \\<longrightarrow>\n   nexta p = nextb p) \\<longrightarrow>\n                                     (\\<exists>ll'.\n   Levellist (levellist[var p := p]) (nextb(p := levellist ! var p))\n    ll' \\<and>\n   wf_levellist (Node lt p rt) ll ll' var \\<and>\n   wf_marking (Node lt p rt) mark (markb(p := m)) m \\<and>\n   (\\<forall>pa.\n       pa \\<notin> set_of (Node lt p rt) \\<longrightarrow>\n       next pa = (if pa = p then levellist ! var p else nextb pa))))))\n 2. \\<And>ll var low high mark next p levellist lt rt.\n       \\<lbrakk>ordered (Node lt p rt) var; Levellist levellist next ll;\n        \\<forall>n\\<in>set_of (Node lt p rt).\n           if mark n = mark p\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt pa.\n                    Dag n low high nt \\<and>\n                    pa \\<in> set_of nt \\<longrightarrow>\n                    mark pa = mark p)\n           else n \\<notin> set (concat ll);\n        p \\<noteq> Null; var p < length levellist; Dag (low p) low high lt;\n        Dag (high p) low high rt\\<rbrakk>\n       \\<Longrightarrow> wf_levellist (Node lt p rt) ll ll var \\<and>\n                         wf_marking (Node lt p rt) mark mark (mark p)", "assume mark_p: \"mark p = (\\<not> m)\""], ["proof (state)\nthis:\n  mark p = (\\<not> m)\n\ngoal (2 subgoals):\n 1. \\<And>ll var low high mark next p levellist m lt rt.\n       \\<lbrakk>ordered (Node lt p rt) var; Levellist levellist next ll;\n        \\<forall>n\\<in>set_of (Node lt p rt).\n           if mark n = m\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt p.\n                    Dag n low high nt \\<and>\n                    p \\<in> set_of nt \\<longrightarrow>\n                    mark p = m)\n           else n \\<notin> set (concat ll);\n        p \\<noteq> Null; var p < length levellist; mark p = (\\<not> m);\n        Dag (low p) low high lt; Dag (high p) low high rt\\<rbrakk>\n       \\<Longrightarrow> (low p \\<noteq> Null \\<longrightarrow>\n                          var (low p) < length levellist) \\<and>\n                         ordered lt var \\<and>\n                         (\\<forall>n\\<in>set_of lt.\n                             if mark n = m\n                             then n \\<in> set (ll ! var n) \\<and>\n                                  (\\<forall>nt p.\nDag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow> mark p = m)\n                             else n \\<notin> set (concat ll)) \\<and>\n                         size (dag (low p) low high)\n                         < size (dag p low high) \\<and>\n                         (\\<forall>marka nexta levellist ll'.\n                             Levellist levellist nexta ll' \\<and>\n                             wf_levellist lt ll ll' var \\<and>\n                             wf_marking lt mark marka m \\<and>\n                             (\\<forall>p.\n                                 p \\<notin> set_of lt \\<longrightarrow>\n                                 next p = nexta p) \\<longrightarrow>\n                             (high p \\<noteq> Null \\<longrightarrow>\n                              var (high p) < length levellist) \\<and>\n                             ordered rt var \\<and>\n                             (\\<exists>lla.\n                                 Levellist levellist nexta lla \\<and>\n                                 (\\<forall>n\\<in>set_of rt.\n                                     if marka n = m\n                                     then n \\<in> set (lla ! var n) \\<and>\n    (\\<forall>nt p.\n        Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n        marka p = m)\n                                     else n\n    \\<notin> set (concat lla)) \\<and>\n                                 size (dag (high p) low high)\n                                 < size (dag p low high) \\<and>\n                                 (\\<forall>markb nextb levellist ll'.\n                                     Levellist levellist nextb ll' \\<and>\n                                     wf_levellist rt lla ll' var \\<and>\n                                     wf_marking rt marka markb m \\<and>\n                                     (\\<forall>p.\n   p \\<notin> set_of rt \\<longrightarrow>\n   nexta p = nextb p) \\<longrightarrow>\n                                     (\\<exists>ll'.\n   Levellist (levellist[var p := p]) (nextb(p := levellist ! var p))\n    ll' \\<and>\n   wf_levellist (Node lt p rt) ll ll' var \\<and>\n   wf_marking (Node lt p rt) mark (markb(p := m)) m \\<and>\n   (\\<forall>pa.\n       pa \\<notin> set_of (Node lt p rt) \\<longrightarrow>\n       next pa = (if pa = p then levellist ! var p else nextb pa))))))\n 2. \\<And>ll var low high mark next p levellist lt rt.\n       \\<lbrakk>ordered (Node lt p rt) var; Levellist levellist next ll;\n        \\<forall>n\\<in>set_of (Node lt p rt).\n           if mark n = mark p\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt pa.\n                    Dag n low high nt \\<and>\n                    pa \\<in> set_of nt \\<longrightarrow>\n                    mark pa = mark p)\n           else n \\<notin> set (concat ll);\n        p \\<noteq> Null; var p < length levellist; Dag (low p) low high lt;\n        Dag (high p) low high rt\\<rbrakk>\n       \\<Longrightarrow> wf_levellist (Node lt p rt) ll ll var \\<and>\n                         wf_marking (Node lt p rt) mark mark (mark p)", "assume lt: \"Dag (low p) low high lt\""], ["proof (state)\nthis:\n  Dag (low p) low high lt\n\ngoal (2 subgoals):\n 1. \\<And>ll var low high mark next p levellist m lt rt.\n       \\<lbrakk>ordered (Node lt p rt) var; Levellist levellist next ll;\n        \\<forall>n\\<in>set_of (Node lt p rt).\n           if mark n = m\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt p.\n                    Dag n low high nt \\<and>\n                    p \\<in> set_of nt \\<longrightarrow>\n                    mark p = m)\n           else n \\<notin> set (concat ll);\n        p \\<noteq> Null; var p < length levellist; mark p = (\\<not> m);\n        Dag (low p) low high lt; Dag (high p) low high rt\\<rbrakk>\n       \\<Longrightarrow> (low p \\<noteq> Null \\<longrightarrow>\n                          var (low p) < length levellist) \\<and>\n                         ordered lt var \\<and>\n                         (\\<forall>n\\<in>set_of lt.\n                             if mark n = m\n                             then n \\<in> set (ll ! var n) \\<and>\n                                  (\\<forall>nt p.\nDag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow> mark p = m)\n                             else n \\<notin> set (concat ll)) \\<and>\n                         size (dag (low p) low high)\n                         < size (dag p low high) \\<and>\n                         (\\<forall>marka nexta levellist ll'.\n                             Levellist levellist nexta ll' \\<and>\n                             wf_levellist lt ll ll' var \\<and>\n                             wf_marking lt mark marka m \\<and>\n                             (\\<forall>p.\n                                 p \\<notin> set_of lt \\<longrightarrow>\n                                 next p = nexta p) \\<longrightarrow>\n                             (high p \\<noteq> Null \\<longrightarrow>\n                              var (high p) < length levellist) \\<and>\n                             ordered rt var \\<and>\n                             (\\<exists>lla.\n                                 Levellist levellist nexta lla \\<and>\n                                 (\\<forall>n\\<in>set_of rt.\n                                     if marka n = m\n                                     then n \\<in> set (lla ! var n) \\<and>\n    (\\<forall>nt p.\n        Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n        marka p = m)\n                                     else n\n    \\<notin> set (concat lla)) \\<and>\n                                 size (dag (high p) low high)\n                                 < size (dag p low high) \\<and>\n                                 (\\<forall>markb nextb levellist ll'.\n                                     Levellist levellist nextb ll' \\<and>\n                                     wf_levellist rt lla ll' var \\<and>\n                                     wf_marking rt marka markb m \\<and>\n                                     (\\<forall>p.\n   p \\<notin> set_of rt \\<longrightarrow>\n   nexta p = nextb p) \\<longrightarrow>\n                                     (\\<exists>ll'.\n   Levellist (levellist[var p := p]) (nextb(p := levellist ! var p))\n    ll' \\<and>\n   wf_levellist (Node lt p rt) ll ll' var \\<and>\n   wf_marking (Node lt p rt) mark (markb(p := m)) m \\<and>\n   (\\<forall>pa.\n       pa \\<notin> set_of (Node lt p rt) \\<longrightarrow>\n       next pa = (if pa = p then levellist ! var p else nextb pa))))))\n 2. \\<And>ll var low high mark next p levellist lt rt.\n       \\<lbrakk>ordered (Node lt p rt) var; Levellist levellist next ll;\n        \\<forall>n\\<in>set_of (Node lt p rt).\n           if mark n = mark p\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt pa.\n                    Dag n low high nt \\<and>\n                    pa \\<in> set_of nt \\<longrightarrow>\n                    mark pa = mark p)\n           else n \\<notin> set (concat ll);\n        p \\<noteq> Null; var p < length levellist; Dag (low p) low high lt;\n        Dag (high p) low high rt\\<rbrakk>\n       \\<Longrightarrow> wf_levellist (Node lt p rt) ll ll var \\<and>\n                         wf_marking (Node lt p rt) mark mark (mark p)", "assume rt: \"Dag (high p) low high rt\""], ["proof (state)\nthis:\n  Dag (high p) low high rt\n\ngoal (2 subgoals):\n 1. \\<And>ll var low high mark next p levellist m lt rt.\n       \\<lbrakk>ordered (Node lt p rt) var; Levellist levellist next ll;\n        \\<forall>n\\<in>set_of (Node lt p rt).\n           if mark n = m\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt p.\n                    Dag n low high nt \\<and>\n                    p \\<in> set_of nt \\<longrightarrow>\n                    mark p = m)\n           else n \\<notin> set (concat ll);\n        p \\<noteq> Null; var p < length levellist; mark p = (\\<not> m);\n        Dag (low p) low high lt; Dag (high p) low high rt\\<rbrakk>\n       \\<Longrightarrow> (low p \\<noteq> Null \\<longrightarrow>\n                          var (low p) < length levellist) \\<and>\n                         ordered lt var \\<and>\n                         (\\<forall>n\\<in>set_of lt.\n                             if mark n = m\n                             then n \\<in> set (ll ! var n) \\<and>\n                                  (\\<forall>nt p.\nDag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow> mark p = m)\n                             else n \\<notin> set (concat ll)) \\<and>\n                         size (dag (low p) low high)\n                         < size (dag p low high) \\<and>\n                         (\\<forall>marka nexta levellist ll'.\n                             Levellist levellist nexta ll' \\<and>\n                             wf_levellist lt ll ll' var \\<and>\n                             wf_marking lt mark marka m \\<and>\n                             (\\<forall>p.\n                                 p \\<notin> set_of lt \\<longrightarrow>\n                                 next p = nexta p) \\<longrightarrow>\n                             (high p \\<noteq> Null \\<longrightarrow>\n                              var (high p) < length levellist) \\<and>\n                             ordered rt var \\<and>\n                             (\\<exists>lla.\n                                 Levellist levellist nexta lla \\<and>\n                                 (\\<forall>n\\<in>set_of rt.\n                                     if marka n = m\n                                     then n \\<in> set (lla ! var n) \\<and>\n    (\\<forall>nt p.\n        Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n        marka p = m)\n                                     else n\n    \\<notin> set (concat lla)) \\<and>\n                                 size (dag (high p) low high)\n                                 < size (dag p low high) \\<and>\n                                 (\\<forall>markb nextb levellist ll'.\n                                     Levellist levellist nextb ll' \\<and>\n                                     wf_levellist rt lla ll' var \\<and>\n                                     wf_marking rt marka markb m \\<and>\n                                     (\\<forall>p.\n   p \\<notin> set_of rt \\<longrightarrow>\n   nexta p = nextb p) \\<longrightarrow>\n                                     (\\<exists>ll'.\n   Levellist (levellist[var p := p]) (nextb(p := levellist ! var p))\n    ll' \\<and>\n   wf_levellist (Node lt p rt) ll ll' var \\<and>\n   wf_marking (Node lt p rt) mark (markb(p := m)) m \\<and>\n   (\\<forall>pa.\n       pa \\<notin> set_of (Node lt p rt) \\<longrightarrow>\n       next pa = (if pa = p then levellist ! var p else nextb pa))))))\n 2. \\<And>ll var low high mark next p levellist lt rt.\n       \\<lbrakk>ordered (Node lt p rt) var; Levellist levellist next ll;\n        \\<forall>n\\<in>set_of (Node lt p rt).\n           if mark n = mark p\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt pa.\n                    Dag n low high nt \\<and>\n                    pa \\<in> set_of nt \\<longrightarrow>\n                    mark pa = mark p)\n           else n \\<notin> set (concat ll);\n        p \\<noteq> Null; var p < length levellist; Dag (low p) low high lt;\n        Dag (high p) low high rt\\<rbrakk>\n       \\<Longrightarrow> wf_levellist (Node lt p rt) ll ll var \\<and>\n                         wf_marking (Node lt p rt) mark mark (mark p)", "from pnN lt rt"], ["proof (chain)\npicking this:\n  p \\<noteq> Null\n  Dag (low p) low high lt\n  Dag (high p) low high rt", "have Dag_p: \"Dag p low high (Node lt p rt)\""], ["proof (prove)\nusing this:\n  p \\<noteq> Null\n  Dag (low p) low high lt\n  Dag (high p) low high rt\n\ngoal (1 subgoal):\n 1. Dag p low high (Node lt p rt)", "by simp"], ["proof (state)\nthis:\n  Dag p low high (Node lt p rt)\n\ngoal (2 subgoals):\n 1. \\<And>ll var low high mark next p levellist m lt rt.\n       \\<lbrakk>ordered (Node lt p rt) var; Levellist levellist next ll;\n        \\<forall>n\\<in>set_of (Node lt p rt).\n           if mark n = m\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt p.\n                    Dag n low high nt \\<and>\n                    p \\<in> set_of nt \\<longrightarrow>\n                    mark p = m)\n           else n \\<notin> set (concat ll);\n        p \\<noteq> Null; var p < length levellist; mark p = (\\<not> m);\n        Dag (low p) low high lt; Dag (high p) low high rt\\<rbrakk>\n       \\<Longrightarrow> (low p \\<noteq> Null \\<longrightarrow>\n                          var (low p) < length levellist) \\<and>\n                         ordered lt var \\<and>\n                         (\\<forall>n\\<in>set_of lt.\n                             if mark n = m\n                             then n \\<in> set (ll ! var n) \\<and>\n                                  (\\<forall>nt p.\nDag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow> mark p = m)\n                             else n \\<notin> set (concat ll)) \\<and>\n                         size (dag (low p) low high)\n                         < size (dag p low high) \\<and>\n                         (\\<forall>marka nexta levellist ll'.\n                             Levellist levellist nexta ll' \\<and>\n                             wf_levellist lt ll ll' var \\<and>\n                             wf_marking lt mark marka m \\<and>\n                             (\\<forall>p.\n                                 p \\<notin> set_of lt \\<longrightarrow>\n                                 next p = nexta p) \\<longrightarrow>\n                             (high p \\<noteq> Null \\<longrightarrow>\n                              var (high p) < length levellist) \\<and>\n                             ordered rt var \\<and>\n                             (\\<exists>lla.\n                                 Levellist levellist nexta lla \\<and>\n                                 (\\<forall>n\\<in>set_of rt.\n                                     if marka n = m\n                                     then n \\<in> set (lla ! var n) \\<and>\n    (\\<forall>nt p.\n        Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n        marka p = m)\n                                     else n\n    \\<notin> set (concat lla)) \\<and>\n                                 size (dag (high p) low high)\n                                 < size (dag p low high) \\<and>\n                                 (\\<forall>markb nextb levellist ll'.\n                                     Levellist levellist nextb ll' \\<and>\n                                     wf_levellist rt lla ll' var \\<and>\n                                     wf_marking rt marka markb m \\<and>\n                                     (\\<forall>p.\n   p \\<notin> set_of rt \\<longrightarrow>\n   nexta p = nextb p) \\<longrightarrow>\n                                     (\\<exists>ll'.\n   Levellist (levellist[var p := p]) (nextb(p := levellist ! var p))\n    ll' \\<and>\n   wf_levellist (Node lt p rt) ll ll' var \\<and>\n   wf_marking (Node lt p rt) mark (markb(p := m)) m \\<and>\n   (\\<forall>pa.\n       pa \\<notin> set_of (Node lt p rt) \\<longrightarrow>\n       next pa = (if pa = p then levellist ! var p else nextb pa))))))\n 2. \\<And>ll var low high mark next p levellist lt rt.\n       \\<lbrakk>ordered (Node lt p rt) var; Levellist levellist next ll;\n        \\<forall>n\\<in>set_of (Node lt p rt).\n           if mark n = mark p\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt pa.\n                    Dag n low high nt \\<and>\n                    pa \\<in> set_of nt \\<longrightarrow>\n                    mark pa = mark p)\n           else n \\<notin> set (concat ll);\n        p \\<noteq> Null; var p < length levellist; Dag (low p) low high lt;\n        Dag (high p) low high rt\\<rbrakk>\n       \\<Longrightarrow> wf_levellist (Node lt p rt) ll ll var \\<and>\n                         wf_marking (Node lt p rt) mark mark (mark p)", "from Dag_p rt"], ["proof (chain)\npicking this:\n  Dag p low high (Node lt p rt)\n  Dag (high p) low high rt", "have size_rt_dec: \"size (dag (high p) low high) < size (dag p low high)\""], ["proof (prove)\nusing this:\n  Dag p low high (Node lt p rt)\n  Dag (high p) low high rt\n\ngoal (1 subgoal):\n 1. size (dag (high p) low high) < size (dag p low high)", "by (simp only: Dag_dag) simp"], ["proof (state)\nthis:\n  size (dag (high p) low high) < size (dag p low high)\n\ngoal (2 subgoals):\n 1. \\<And>ll var low high mark next p levellist m lt rt.\n       \\<lbrakk>ordered (Node lt p rt) var; Levellist levellist next ll;\n        \\<forall>n\\<in>set_of (Node lt p rt).\n           if mark n = m\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt p.\n                    Dag n low high nt \\<and>\n                    p \\<in> set_of nt \\<longrightarrow>\n                    mark p = m)\n           else n \\<notin> set (concat ll);\n        p \\<noteq> Null; var p < length levellist; mark p = (\\<not> m);\n        Dag (low p) low high lt; Dag (high p) low high rt\\<rbrakk>\n       \\<Longrightarrow> (low p \\<noteq> Null \\<longrightarrow>\n                          var (low p) < length levellist) \\<and>\n                         ordered lt var \\<and>\n                         (\\<forall>n\\<in>set_of lt.\n                             if mark n = m\n                             then n \\<in> set (ll ! var n) \\<and>\n                                  (\\<forall>nt p.\nDag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow> mark p = m)\n                             else n \\<notin> set (concat ll)) \\<and>\n                         size (dag (low p) low high)\n                         < size (dag p low high) \\<and>\n                         (\\<forall>marka nexta levellist ll'.\n                             Levellist levellist nexta ll' \\<and>\n                             wf_levellist lt ll ll' var \\<and>\n                             wf_marking lt mark marka m \\<and>\n                             (\\<forall>p.\n                                 p \\<notin> set_of lt \\<longrightarrow>\n                                 next p = nexta p) \\<longrightarrow>\n                             (high p \\<noteq> Null \\<longrightarrow>\n                              var (high p) < length levellist) \\<and>\n                             ordered rt var \\<and>\n                             (\\<exists>lla.\n                                 Levellist levellist nexta lla \\<and>\n                                 (\\<forall>n\\<in>set_of rt.\n                                     if marka n = m\n                                     then n \\<in> set (lla ! var n) \\<and>\n    (\\<forall>nt p.\n        Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n        marka p = m)\n                                     else n\n    \\<notin> set (concat lla)) \\<and>\n                                 size (dag (high p) low high)\n                                 < size (dag p low high) \\<and>\n                                 (\\<forall>markb nextb levellist ll'.\n                                     Levellist levellist nextb ll' \\<and>\n                                     wf_levellist rt lla ll' var \\<and>\n                                     wf_marking rt marka markb m \\<and>\n                                     (\\<forall>p.\n   p \\<notin> set_of rt \\<longrightarrow>\n   nexta p = nextb p) \\<longrightarrow>\n                                     (\\<exists>ll'.\n   Levellist (levellist[var p := p]) (nextb(p := levellist ! var p))\n    ll' \\<and>\n   wf_levellist (Node lt p rt) ll ll' var \\<and>\n   wf_marking (Node lt p rt) mark (markb(p := m)) m \\<and>\n   (\\<forall>pa.\n       pa \\<notin> set_of (Node lt p rt) \\<longrightarrow>\n       next pa = (if pa = p then levellist ! var p else nextb pa))))))\n 2. \\<And>ll var low high mark next p levellist lt rt.\n       \\<lbrakk>ordered (Node lt p rt) var; Levellist levellist next ll;\n        \\<forall>n\\<in>set_of (Node lt p rt).\n           if mark n = mark p\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt pa.\n                    Dag n low high nt \\<and>\n                    pa \\<in> set_of nt \\<longrightarrow>\n                    mark pa = mark p)\n           else n \\<notin> set (concat ll);\n        p \\<noteq> Null; var p < length levellist; Dag (low p) low high lt;\n        Dag (high p) low high rt\\<rbrakk>\n       \\<Longrightarrow> wf_levellist (Node lt p rt) ll ll var \\<and>\n                         wf_marking (Node lt p rt) mark mark (mark p)", "from Dag_p lt"], ["proof (chain)\npicking this:\n  Dag p low high (Node lt p rt)\n  Dag (low p) low high lt", "have size_lt_dec: \"size (dag (low p) low high) < size (dag p low high)\""], ["proof (prove)\nusing this:\n  Dag p low high (Node lt p rt)\n  Dag (low p) low high lt\n\ngoal (1 subgoal):\n 1. size (dag (low p) low high) < size (dag p low high)", "by (simp only: Dag_dag) simp"], ["proof (state)\nthis:\n  size (dag (low p) low high) < size (dag p low high)\n\ngoal (2 subgoals):\n 1. \\<And>ll var low high mark next p levellist m lt rt.\n       \\<lbrakk>ordered (Node lt p rt) var; Levellist levellist next ll;\n        \\<forall>n\\<in>set_of (Node lt p rt).\n           if mark n = m\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt p.\n                    Dag n low high nt \\<and>\n                    p \\<in> set_of nt \\<longrightarrow>\n                    mark p = m)\n           else n \\<notin> set (concat ll);\n        p \\<noteq> Null; var p < length levellist; mark p = (\\<not> m);\n        Dag (low p) low high lt; Dag (high p) low high rt\\<rbrakk>\n       \\<Longrightarrow> (low p \\<noteq> Null \\<longrightarrow>\n                          var (low p) < length levellist) \\<and>\n                         ordered lt var \\<and>\n                         (\\<forall>n\\<in>set_of lt.\n                             if mark n = m\n                             then n \\<in> set (ll ! var n) \\<and>\n                                  (\\<forall>nt p.\nDag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow> mark p = m)\n                             else n \\<notin> set (concat ll)) \\<and>\n                         size (dag (low p) low high)\n                         < size (dag p low high) \\<and>\n                         (\\<forall>marka nexta levellist ll'.\n                             Levellist levellist nexta ll' \\<and>\n                             wf_levellist lt ll ll' var \\<and>\n                             wf_marking lt mark marka m \\<and>\n                             (\\<forall>p.\n                                 p \\<notin> set_of lt \\<longrightarrow>\n                                 next p = nexta p) \\<longrightarrow>\n                             (high p \\<noteq> Null \\<longrightarrow>\n                              var (high p) < length levellist) \\<and>\n                             ordered rt var \\<and>\n                             (\\<exists>lla.\n                                 Levellist levellist nexta lla \\<and>\n                                 (\\<forall>n\\<in>set_of rt.\n                                     if marka n = m\n                                     then n \\<in> set (lla ! var n) \\<and>\n    (\\<forall>nt p.\n        Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n        marka p = m)\n                                     else n\n    \\<notin> set (concat lla)) \\<and>\n                                 size (dag (high p) low high)\n                                 < size (dag p low high) \\<and>\n                                 (\\<forall>markb nextb levellist ll'.\n                                     Levellist levellist nextb ll' \\<and>\n                                     wf_levellist rt lla ll' var \\<and>\n                                     wf_marking rt marka markb m \\<and>\n                                     (\\<forall>p.\n   p \\<notin> set_of rt \\<longrightarrow>\n   nexta p = nextb p) \\<longrightarrow>\n                                     (\\<exists>ll'.\n   Levellist (levellist[var p := p]) (nextb(p := levellist ! var p))\n    ll' \\<and>\n   wf_levellist (Node lt p rt) ll ll' var \\<and>\n   wf_marking (Node lt p rt) mark (markb(p := m)) m \\<and>\n   (\\<forall>pa.\n       pa \\<notin> set_of (Node lt p rt) \\<longrightarrow>\n       next pa = (if pa = p then levellist ! var p else nextb pa))))))\n 2. \\<And>ll var low high mark next p levellist lt rt.\n       \\<lbrakk>ordered (Node lt p rt) var; Levellist levellist next ll;\n        \\<forall>n\\<in>set_of (Node lt p rt).\n           if mark n = mark p\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt pa.\n                    Dag n low high nt \\<and>\n                    pa \\<in> set_of nt \\<longrightarrow>\n                    mark pa = mark p)\n           else n \\<notin> set (concat ll);\n        p \\<noteq> Null; var p < length levellist; Dag (low p) low high lt;\n        Dag (high p) low high rt\\<rbrakk>\n       \\<Longrightarrow> wf_levellist (Node lt p rt) ll ll var \\<and>\n                         wf_marking (Node lt p rt) mark mark (mark p)", "assume ll: \"Levellist levellist next ll\""], ["proof (state)\nthis:\n  Levellist levellist next ll\n\ngoal (2 subgoals):\n 1. \\<And>ll var low high mark next p levellist m lt rt.\n       \\<lbrakk>ordered (Node lt p rt) var; Levellist levellist next ll;\n        \\<forall>n\\<in>set_of (Node lt p rt).\n           if mark n = m\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt p.\n                    Dag n low high nt \\<and>\n                    p \\<in> set_of nt \\<longrightarrow>\n                    mark p = m)\n           else n \\<notin> set (concat ll);\n        p \\<noteq> Null; var p < length levellist; mark p = (\\<not> m);\n        Dag (low p) low high lt; Dag (high p) low high rt\\<rbrakk>\n       \\<Longrightarrow> (low p \\<noteq> Null \\<longrightarrow>\n                          var (low p) < length levellist) \\<and>\n                         ordered lt var \\<and>\n                         (\\<forall>n\\<in>set_of lt.\n                             if mark n = m\n                             then n \\<in> set (ll ! var n) \\<and>\n                                  (\\<forall>nt p.\nDag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow> mark p = m)\n                             else n \\<notin> set (concat ll)) \\<and>\n                         size (dag (low p) low high)\n                         < size (dag p low high) \\<and>\n                         (\\<forall>marka nexta levellist ll'.\n                             Levellist levellist nexta ll' \\<and>\n                             wf_levellist lt ll ll' var \\<and>\n                             wf_marking lt mark marka m \\<and>\n                             (\\<forall>p.\n                                 p \\<notin> set_of lt \\<longrightarrow>\n                                 next p = nexta p) \\<longrightarrow>\n                             (high p \\<noteq> Null \\<longrightarrow>\n                              var (high p) < length levellist) \\<and>\n                             ordered rt var \\<and>\n                             (\\<exists>lla.\n                                 Levellist levellist nexta lla \\<and>\n                                 (\\<forall>n\\<in>set_of rt.\n                                     if marka n = m\n                                     then n \\<in> set (lla ! var n) \\<and>\n    (\\<forall>nt p.\n        Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n        marka p = m)\n                                     else n\n    \\<notin> set (concat lla)) \\<and>\n                                 size (dag (high p) low high)\n                                 < size (dag p low high) \\<and>\n                                 (\\<forall>markb nextb levellist ll'.\n                                     Levellist levellist nextb ll' \\<and>\n                                     wf_levellist rt lla ll' var \\<and>\n                                     wf_marking rt marka markb m \\<and>\n                                     (\\<forall>p.\n   p \\<notin> set_of rt \\<longrightarrow>\n   nexta p = nextb p) \\<longrightarrow>\n                                     (\\<exists>ll'.\n   Levellist (levellist[var p := p]) (nextb(p := levellist ! var p))\n    ll' \\<and>\n   wf_levellist (Node lt p rt) ll ll' var \\<and>\n   wf_marking (Node lt p rt) mark (markb(p := m)) m \\<and>\n   (\\<forall>pa.\n       pa \\<notin> set_of (Node lt p rt) \\<longrightarrow>\n       next pa = (if pa = p then levellist ! var p else nextb pa))))))\n 2. \\<And>ll var low high mark next p levellist lt rt.\n       \\<lbrakk>ordered (Node lt p rt) var; Levellist levellist next ll;\n        \\<forall>n\\<in>set_of (Node lt p rt).\n           if mark n = mark p\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt pa.\n                    Dag n low high nt \\<and>\n                    pa \\<in> set_of nt \\<longrightarrow>\n                    mark pa = mark p)\n           else n \\<notin> set (concat ll);\n        p \\<noteq> Null; var p < length levellist; Dag (low p) low high lt;\n        Dag (high p) low high rt\\<rbrakk>\n       \\<Longrightarrow> wf_levellist (Node lt p rt) ll ll var \\<and>\n                         wf_marking (Node lt p rt) mark mark (mark p)", "assume marked_child_ll:\n    \"\\<forall>n \\<in> set_of (Node lt p rt).\n        if mark n = m\n        then n \\<in> set (ll ! var n) \\<and>\n             (\\<forall>nt p. Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow> mark p = m)\n        else n \\<notin> set (concat ll)\""], ["proof (state)\nthis:\n  \\<forall>n\\<in>set_of (Node lt p rt).\n     if mark n = m\n     then n \\<in> set (ll ! var n) \\<and>\n          (\\<forall>nt p.\n              Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n              mark p = m)\n     else n \\<notin> set (concat ll)\n\ngoal (2 subgoals):\n 1. \\<And>ll var low high mark next p levellist m lt rt.\n       \\<lbrakk>ordered (Node lt p rt) var; Levellist levellist next ll;\n        \\<forall>n\\<in>set_of (Node lt p rt).\n           if mark n = m\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt p.\n                    Dag n low high nt \\<and>\n                    p \\<in> set_of nt \\<longrightarrow>\n                    mark p = m)\n           else n \\<notin> set (concat ll);\n        p \\<noteq> Null; var p < length levellist; mark p = (\\<not> m);\n        Dag (low p) low high lt; Dag (high p) low high rt\\<rbrakk>\n       \\<Longrightarrow> (low p \\<noteq> Null \\<longrightarrow>\n                          var (low p) < length levellist) \\<and>\n                         ordered lt var \\<and>\n                         (\\<forall>n\\<in>set_of lt.\n                             if mark n = m\n                             then n \\<in> set (ll ! var n) \\<and>\n                                  (\\<forall>nt p.\nDag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow> mark p = m)\n                             else n \\<notin> set (concat ll)) \\<and>\n                         size (dag (low p) low high)\n                         < size (dag p low high) \\<and>\n                         (\\<forall>marka nexta levellist ll'.\n                             Levellist levellist nexta ll' \\<and>\n                             wf_levellist lt ll ll' var \\<and>\n                             wf_marking lt mark marka m \\<and>\n                             (\\<forall>p.\n                                 p \\<notin> set_of lt \\<longrightarrow>\n                                 next p = nexta p) \\<longrightarrow>\n                             (high p \\<noteq> Null \\<longrightarrow>\n                              var (high p) < length levellist) \\<and>\n                             ordered rt var \\<and>\n                             (\\<exists>lla.\n                                 Levellist levellist nexta lla \\<and>\n                                 (\\<forall>n\\<in>set_of rt.\n                                     if marka n = m\n                                     then n \\<in> set (lla ! var n) \\<and>\n    (\\<forall>nt p.\n        Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n        marka p = m)\n                                     else n\n    \\<notin> set (concat lla)) \\<and>\n                                 size (dag (high p) low high)\n                                 < size (dag p low high) \\<and>\n                                 (\\<forall>markb nextb levellist ll'.\n                                     Levellist levellist nextb ll' \\<and>\n                                     wf_levellist rt lla ll' var \\<and>\n                                     wf_marking rt marka markb m \\<and>\n                                     (\\<forall>p.\n   p \\<notin> set_of rt \\<longrightarrow>\n   nexta p = nextb p) \\<longrightarrow>\n                                     (\\<exists>ll'.\n   Levellist (levellist[var p := p]) (nextb(p := levellist ! var p))\n    ll' \\<and>\n   wf_levellist (Node lt p rt) ll ll' var \\<and>\n   wf_marking (Node lt p rt) mark (markb(p := m)) m \\<and>\n   (\\<forall>pa.\n       pa \\<notin> set_of (Node lt p rt) \\<longrightarrow>\n       next pa = (if pa = p then levellist ! var p else nextb pa))))))\n 2. \\<And>ll var low high mark next p levellist lt rt.\n       \\<lbrakk>ordered (Node lt p rt) var; Levellist levellist next ll;\n        \\<forall>n\\<in>set_of (Node lt p rt).\n           if mark n = mark p\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt pa.\n                    Dag n low high nt \\<and>\n                    pa \\<in> set_of nt \\<longrightarrow>\n                    mark pa = mark p)\n           else n \\<notin> set (concat ll);\n        p \\<noteq> Null; var p < length levellist; Dag (low p) low high lt;\n        Dag (high p) low high rt\\<rbrakk>\n       \\<Longrightarrow> wf_levellist (Node lt p rt) ll ll var \\<and>\n                         wf_marking (Node lt p rt) mark mark (mark p)", "with mark_p"], ["proof (chain)\npicking this:\n  mark p = (\\<not> m)\n  \\<forall>n\\<in>set_of (Node lt p rt).\n     if mark n = m\n     then n \\<in> set (ll ! var n) \\<and>\n          (\\<forall>nt p.\n              Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n              mark p = m)\n     else n \\<notin> set (concat ll)", "have p_notin_ll: \"p \\<notin> set (concat ll)\""], ["proof (prove)\nusing this:\n  mark p = (\\<not> m)\n  \\<forall>n\\<in>set_of (Node lt p rt).\n     if mark n = m\n     then n \\<in> set (ll ! var n) \\<and>\n          (\\<forall>nt p.\n              Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n              mark p = m)\n     else n \\<notin> set (concat ll)\n\ngoal (1 subgoal):\n 1. p \\<notin> set (concat ll)", "by auto"], ["proof (state)\nthis:\n  p \\<notin> set (concat ll)\n\ngoal (2 subgoals):\n 1. \\<And>ll var low high mark next p levellist m lt rt.\n       \\<lbrakk>ordered (Node lt p rt) var; Levellist levellist next ll;\n        \\<forall>n\\<in>set_of (Node lt p rt).\n           if mark n = m\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt p.\n                    Dag n low high nt \\<and>\n                    p \\<in> set_of nt \\<longrightarrow>\n                    mark p = m)\n           else n \\<notin> set (concat ll);\n        p \\<noteq> Null; var p < length levellist; mark p = (\\<not> m);\n        Dag (low p) low high lt; Dag (high p) low high rt\\<rbrakk>\n       \\<Longrightarrow> (low p \\<noteq> Null \\<longrightarrow>\n                          var (low p) < length levellist) \\<and>\n                         ordered lt var \\<and>\n                         (\\<forall>n\\<in>set_of lt.\n                             if mark n = m\n                             then n \\<in> set (ll ! var n) \\<and>\n                                  (\\<forall>nt p.\nDag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow> mark p = m)\n                             else n \\<notin> set (concat ll)) \\<and>\n                         size (dag (low p) low high)\n                         < size (dag p low high) \\<and>\n                         (\\<forall>marka nexta levellist ll'.\n                             Levellist levellist nexta ll' \\<and>\n                             wf_levellist lt ll ll' var \\<and>\n                             wf_marking lt mark marka m \\<and>\n                             (\\<forall>p.\n                                 p \\<notin> set_of lt \\<longrightarrow>\n                                 next p = nexta p) \\<longrightarrow>\n                             (high p \\<noteq> Null \\<longrightarrow>\n                              var (high p) < length levellist) \\<and>\n                             ordered rt var \\<and>\n                             (\\<exists>lla.\n                                 Levellist levellist nexta lla \\<and>\n                                 (\\<forall>n\\<in>set_of rt.\n                                     if marka n = m\n                                     then n \\<in> set (lla ! var n) \\<and>\n    (\\<forall>nt p.\n        Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n        marka p = m)\n                                     else n\n    \\<notin> set (concat lla)) \\<and>\n                                 size (dag (high p) low high)\n                                 < size (dag p low high) \\<and>\n                                 (\\<forall>markb nextb levellist ll'.\n                                     Levellist levellist nextb ll' \\<and>\n                                     wf_levellist rt lla ll' var \\<and>\n                                     wf_marking rt marka markb m \\<and>\n                                     (\\<forall>p.\n   p \\<notin> set_of rt \\<longrightarrow>\n   nexta p = nextb p) \\<longrightarrow>\n                                     (\\<exists>ll'.\n   Levellist (levellist[var p := p]) (nextb(p := levellist ! var p))\n    ll' \\<and>\n   wf_levellist (Node lt p rt) ll ll' var \\<and>\n   wf_marking (Node lt p rt) mark (markb(p := m)) m \\<and>\n   (\\<forall>pa.\n       pa \\<notin> set_of (Node lt p rt) \\<longrightarrow>\n       next pa = (if pa = p then levellist ! var p else nextb pa))))))\n 2. \\<And>ll var low high mark next p levellist lt rt.\n       \\<lbrakk>ordered (Node lt p rt) var; Levellist levellist next ll;\n        \\<forall>n\\<in>set_of (Node lt p rt).\n           if mark n = mark p\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt pa.\n                    Dag n low high nt \\<and>\n                    pa \\<in> set_of nt \\<longrightarrow>\n                    mark pa = mark p)\n           else n \\<notin> set (concat ll);\n        p \\<noteq> Null; var p < length levellist; Dag (low p) low high lt;\n        Dag (high p) low high rt\\<rbrakk>\n       \\<Longrightarrow> wf_levellist (Node lt p rt) ll ll var \\<and>\n                         wf_marking (Node lt p rt) mark mark (mark p)", "assume varsll': \"var p < length levellist\""], ["proof (state)\nthis:\n  var p < length levellist\n\ngoal (2 subgoals):\n 1. \\<And>ll var low high mark next p levellist m lt rt.\n       \\<lbrakk>ordered (Node lt p rt) var; Levellist levellist next ll;\n        \\<forall>n\\<in>set_of (Node lt p rt).\n           if mark n = m\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt p.\n                    Dag n low high nt \\<and>\n                    p \\<in> set_of nt \\<longrightarrow>\n                    mark p = m)\n           else n \\<notin> set (concat ll);\n        p \\<noteq> Null; var p < length levellist; mark p = (\\<not> m);\n        Dag (low p) low high lt; Dag (high p) low high rt\\<rbrakk>\n       \\<Longrightarrow> (low p \\<noteq> Null \\<longrightarrow>\n                          var (low p) < length levellist) \\<and>\n                         ordered lt var \\<and>\n                         (\\<forall>n\\<in>set_of lt.\n                             if mark n = m\n                             then n \\<in> set (ll ! var n) \\<and>\n                                  (\\<forall>nt p.\nDag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow> mark p = m)\n                             else n \\<notin> set (concat ll)) \\<and>\n                         size (dag (low p) low high)\n                         < size (dag p low high) \\<and>\n                         (\\<forall>marka nexta levellist ll'.\n                             Levellist levellist nexta ll' \\<and>\n                             wf_levellist lt ll ll' var \\<and>\n                             wf_marking lt mark marka m \\<and>\n                             (\\<forall>p.\n                                 p \\<notin> set_of lt \\<longrightarrow>\n                                 next p = nexta p) \\<longrightarrow>\n                             (high p \\<noteq> Null \\<longrightarrow>\n                              var (high p) < length levellist) \\<and>\n                             ordered rt var \\<and>\n                             (\\<exists>lla.\n                                 Levellist levellist nexta lla \\<and>\n                                 (\\<forall>n\\<in>set_of rt.\n                                     if marka n = m\n                                     then n \\<in> set (lla ! var n) \\<and>\n    (\\<forall>nt p.\n        Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n        marka p = m)\n                                     else n\n    \\<notin> set (concat lla)) \\<and>\n                                 size (dag (high p) low high)\n                                 < size (dag p low high) \\<and>\n                                 (\\<forall>markb nextb levellist ll'.\n                                     Levellist levellist nextb ll' \\<and>\n                                     wf_levellist rt lla ll' var \\<and>\n                                     wf_marking rt marka markb m \\<and>\n                                     (\\<forall>p.\n   p \\<notin> set_of rt \\<longrightarrow>\n   nexta p = nextb p) \\<longrightarrow>\n                                     (\\<exists>ll'.\n   Levellist (levellist[var p := p]) (nextb(p := levellist ! var p))\n    ll' \\<and>\n   wf_levellist (Node lt p rt) ll ll' var \\<and>\n   wf_marking (Node lt p rt) mark (markb(p := m)) m \\<and>\n   (\\<forall>pa.\n       pa \\<notin> set_of (Node lt p rt) \\<longrightarrow>\n       next pa = (if pa = p then levellist ! var p else nextb pa))))))\n 2. \\<And>ll var low high mark next p levellist lt rt.\n       \\<lbrakk>ordered (Node lt p rt) var; Levellist levellist next ll;\n        \\<forall>n\\<in>set_of (Node lt p rt).\n           if mark n = mark p\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt pa.\n                    Dag n low high nt \\<and>\n                    pa \\<in> set_of nt \\<longrightarrow>\n                    mark pa = mark p)\n           else n \\<notin> set (concat ll);\n        p \\<noteq> Null; var p < length levellist; Dag (low p) low high lt;\n        Dag (high p) low high rt\\<rbrakk>\n       \\<Longrightarrow> wf_levellist (Node lt p rt) ll ll var \\<and>\n                         wf_marking (Node lt p rt) mark mark (mark p)", "with ll"], ["proof (chain)\npicking this:\n  Levellist levellist next ll\n  var p < length levellist", "have varsll: \"var p < length ll\""], ["proof (prove)\nusing this:\n  Levellist levellist next ll\n  var p < length levellist\n\ngoal (1 subgoal):\n 1. var p < length ll", "by (simp add: Levellist_length)"], ["proof (state)\nthis:\n  var p < length ll\n\ngoal (2 subgoals):\n 1. \\<And>ll var low high mark next p levellist m lt rt.\n       \\<lbrakk>ordered (Node lt p rt) var; Levellist levellist next ll;\n        \\<forall>n\\<in>set_of (Node lt p rt).\n           if mark n = m\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt p.\n                    Dag n low high nt \\<and>\n                    p \\<in> set_of nt \\<longrightarrow>\n                    mark p = m)\n           else n \\<notin> set (concat ll);\n        p \\<noteq> Null; var p < length levellist; mark p = (\\<not> m);\n        Dag (low p) low high lt; Dag (high p) low high rt\\<rbrakk>\n       \\<Longrightarrow> (low p \\<noteq> Null \\<longrightarrow>\n                          var (low p) < length levellist) \\<and>\n                         ordered lt var \\<and>\n                         (\\<forall>n\\<in>set_of lt.\n                             if mark n = m\n                             then n \\<in> set (ll ! var n) \\<and>\n                                  (\\<forall>nt p.\nDag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow> mark p = m)\n                             else n \\<notin> set (concat ll)) \\<and>\n                         size (dag (low p) low high)\n                         < size (dag p low high) \\<and>\n                         (\\<forall>marka nexta levellist ll'.\n                             Levellist levellist nexta ll' \\<and>\n                             wf_levellist lt ll ll' var \\<and>\n                             wf_marking lt mark marka m \\<and>\n                             (\\<forall>p.\n                                 p \\<notin> set_of lt \\<longrightarrow>\n                                 next p = nexta p) \\<longrightarrow>\n                             (high p \\<noteq> Null \\<longrightarrow>\n                              var (high p) < length levellist) \\<and>\n                             ordered rt var \\<and>\n                             (\\<exists>lla.\n                                 Levellist levellist nexta lla \\<and>\n                                 (\\<forall>n\\<in>set_of rt.\n                                     if marka n = m\n                                     then n \\<in> set (lla ! var n) \\<and>\n    (\\<forall>nt p.\n        Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n        marka p = m)\n                                     else n\n    \\<notin> set (concat lla)) \\<and>\n                                 size (dag (high p) low high)\n                                 < size (dag p low high) \\<and>\n                                 (\\<forall>markb nextb levellist ll'.\n                                     Levellist levellist nextb ll' \\<and>\n                                     wf_levellist rt lla ll' var \\<and>\n                                     wf_marking rt marka markb m \\<and>\n                                     (\\<forall>p.\n   p \\<notin> set_of rt \\<longrightarrow>\n   nexta p = nextb p) \\<longrightarrow>\n                                     (\\<exists>ll'.\n   Levellist (levellist[var p := p]) (nextb(p := levellist ! var p))\n    ll' \\<and>\n   wf_levellist (Node lt p rt) ll ll' var \\<and>\n   wf_marking (Node lt p rt) mark (markb(p := m)) m \\<and>\n   (\\<forall>pa.\n       pa \\<notin> set_of (Node lt p rt) \\<longrightarrow>\n       next pa = (if pa = p then levellist ! var p else nextb pa))))))\n 2. \\<And>ll var low high mark next p levellist lt rt.\n       \\<lbrakk>ordered (Node lt p rt) var; Levellist levellist next ll;\n        \\<forall>n\\<in>set_of (Node lt p rt).\n           if mark n = mark p\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt pa.\n                    Dag n low high nt \\<and>\n                    pa \\<in> set_of nt \\<longrightarrow>\n                    mark pa = mark p)\n           else n \\<notin> set (concat ll);\n        p \\<noteq> Null; var p < length levellist; Dag (low p) low high lt;\n        Dag (high p) low high rt\\<rbrakk>\n       \\<Longrightarrow> wf_levellist (Node lt p rt) ll ll var \\<and>\n                         wf_marking (Node lt p rt) mark mark (mark p)", "assume orderedt: \"ordered (Node lt p rt) var\""], ["proof (state)\nthis:\n  ordered (Node lt p rt) var\n\ngoal (2 subgoals):\n 1. \\<And>ll var low high mark next p levellist m lt rt.\n       \\<lbrakk>ordered (Node lt p rt) var; Levellist levellist next ll;\n        \\<forall>n\\<in>set_of (Node lt p rt).\n           if mark n = m\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt p.\n                    Dag n low high nt \\<and>\n                    p \\<in> set_of nt \\<longrightarrow>\n                    mark p = m)\n           else n \\<notin> set (concat ll);\n        p \\<noteq> Null; var p < length levellist; mark p = (\\<not> m);\n        Dag (low p) low high lt; Dag (high p) low high rt\\<rbrakk>\n       \\<Longrightarrow> (low p \\<noteq> Null \\<longrightarrow>\n                          var (low p) < length levellist) \\<and>\n                         ordered lt var \\<and>\n                         (\\<forall>n\\<in>set_of lt.\n                             if mark n = m\n                             then n \\<in> set (ll ! var n) \\<and>\n                                  (\\<forall>nt p.\nDag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow> mark p = m)\n                             else n \\<notin> set (concat ll)) \\<and>\n                         size (dag (low p) low high)\n                         < size (dag p low high) \\<and>\n                         (\\<forall>marka nexta levellist ll'.\n                             Levellist levellist nexta ll' \\<and>\n                             wf_levellist lt ll ll' var \\<and>\n                             wf_marking lt mark marka m \\<and>\n                             (\\<forall>p.\n                                 p \\<notin> set_of lt \\<longrightarrow>\n                                 next p = nexta p) \\<longrightarrow>\n                             (high p \\<noteq> Null \\<longrightarrow>\n                              var (high p) < length levellist) \\<and>\n                             ordered rt var \\<and>\n                             (\\<exists>lla.\n                                 Levellist levellist nexta lla \\<and>\n                                 (\\<forall>n\\<in>set_of rt.\n                                     if marka n = m\n                                     then n \\<in> set (lla ! var n) \\<and>\n    (\\<forall>nt p.\n        Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n        marka p = m)\n                                     else n\n    \\<notin> set (concat lla)) \\<and>\n                                 size (dag (high p) low high)\n                                 < size (dag p low high) \\<and>\n                                 (\\<forall>markb nextb levellist ll'.\n                                     Levellist levellist nextb ll' \\<and>\n                                     wf_levellist rt lla ll' var \\<and>\n                                     wf_marking rt marka markb m \\<and>\n                                     (\\<forall>p.\n   p \\<notin> set_of rt \\<longrightarrow>\n   nexta p = nextb p) \\<longrightarrow>\n                                     (\\<exists>ll'.\n   Levellist (levellist[var p := p]) (nextb(p := levellist ! var p))\n    ll' \\<and>\n   wf_levellist (Node lt p rt) ll ll' var \\<and>\n   wf_marking (Node lt p rt) mark (markb(p := m)) m \\<and>\n   (\\<forall>pa.\n       pa \\<notin> set_of (Node lt p rt) \\<longrightarrow>\n       next pa = (if pa = p then levellist ! var p else nextb pa))))))\n 2. \\<And>ll var low high mark next p levellist lt rt.\n       \\<lbrakk>ordered (Node lt p rt) var; Levellist levellist next ll;\n        \\<forall>n\\<in>set_of (Node lt p rt).\n           if mark n = mark p\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt pa.\n                    Dag n low high nt \\<and>\n                    pa \\<in> set_of nt \\<longrightarrow>\n                    mark pa = mark p)\n           else n \\<notin> set (concat ll);\n        p \\<noteq> Null; var p < length levellist; Dag (low p) low high lt;\n        Dag (high p) low high rt\\<rbrakk>\n       \\<Longrightarrow> wf_levellist (Node lt p rt) ll ll var \\<and>\n                         wf_marking (Node lt p rt) mark mark (mark p)", "show \"(low p \\<noteq> Null \\<longrightarrow> var (low p) < length levellist) \\<and>\n          ordered lt var \\<and>\n          (\\<forall>n \\<in> set_of lt.\n              if mark n = m\n              then n \\<in> set (ll ! var n) \\<and>\n                   (\\<forall>nt p. Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow> mark p = m)\n              else n \\<notin> set (concat ll)) \\<and>\n          size (dag (low p) low high) < size (dag p low high) \\<and>\n          (\\<forall>marka nexta levellist lla.\n              Levellist levellist nexta lla \\<and>\n              wf_levellist lt ll lla var \\<and> wf_marking lt mark marka m \\<and>\n              (\\<forall>p. p \\<notin> set_of lt \\<longrightarrow> next p = nexta p)\\<longrightarrow>\n              (high p \\<noteq> Null \\<longrightarrow> var (high p) < length levellist) \\<and>\n              ordered rt var \\<and>\n              (\\<exists>lla. Levellist levellist nexta lla \\<and>\n                     (\\<forall>n \\<in> set_of rt.\n                        if marka n = m\n                        then n \\<in> set (lla ! var n) \\<and>\n                             (\\<forall>nt p. Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n                                    marka p = m)\n                        else n \\<notin> set (concat lla)) \\<and>\n                     size (dag (high p) low high) < size (dag p low high) \\<and>\n                     (\\<forall>markb nextb levellist llb.\n                         Levellist levellist nextb llb \\<and>\n                         wf_levellist rt lla llb var \\<and>\n                         wf_marking rt marka markb m \\<and>\n                         (\\<forall>p. p \\<notin> set_of rt \\<longrightarrow> nexta p = nextb p) \\<longrightarrow>\n                         (\\<exists>ll'. Levellist (levellist[var p := p])\n                                 (nextb(p := levellist ! var p)) ll' \\<and>\n                                wf_levellist (Node lt p rt) ll ll' var \\<and>\n                                wf_marking (Node lt p rt) mark (markb(p := m)) m \\<and>\n                                (\\<forall>pa. pa \\<notin> set_of (Node lt p rt) \\<longrightarrow>\n                                      next pa =\n                                      (if pa = p then levellist ! var p\n                                       else nextb pa))))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (low p \\<noteq> Null \\<longrightarrow>\n     var (low p) < length levellist) \\<and>\n    ordered lt var \\<and>\n    (\\<forall>n\\<in>set_of lt.\n        if mark n = m\n        then n \\<in> set (ll ! var n) \\<and>\n             (\\<forall>nt p.\n                 Dag n low high nt \\<and>\n                 p \\<in> set_of nt \\<longrightarrow>\n                 mark p = m)\n        else n \\<notin> set (concat ll)) \\<and>\n    size (dag (low p) low high) < size (dag p low high) \\<and>\n    (\\<forall>marka nexta levellist lla.\n        Levellist levellist nexta lla \\<and>\n        wf_levellist lt ll lla var \\<and>\n        wf_marking lt mark marka m \\<and>\n        (\\<forall>p.\n            p \\<notin> set_of lt \\<longrightarrow>\n            next p = nexta p) \\<longrightarrow>\n        (high p \\<noteq> Null \\<longrightarrow>\n         var (high p) < length levellist) \\<and>\n        ordered rt var \\<and>\n        (\\<exists>lla.\n            Levellist levellist nexta lla \\<and>\n            (\\<forall>n\\<in>set_of rt.\n                if marka n = m\n                then n \\<in> set (lla ! var n) \\<and>\n                     (\\<forall>nt p.\n                         Dag n low high nt \\<and>\n                         p \\<in> set_of nt \\<longrightarrow>\n                         marka p = m)\n                else n \\<notin> set (concat lla)) \\<and>\n            size (dag (high p) low high) < size (dag p low high) \\<and>\n            (\\<forall>markb nextb levellist llb.\n                Levellist levellist nextb llb \\<and>\n                wf_levellist rt lla llb var \\<and>\n                wf_marking rt marka markb m \\<and>\n                (\\<forall>p.\n                    p \\<notin> set_of rt \\<longrightarrow>\n                    nexta p = nextb p) \\<longrightarrow>\n                (\\<exists>ll'.\n                    Levellist (levellist[var p := p])\n                     (nextb(p := levellist ! var p)) ll' \\<and>\n                    wf_levellist (Node lt p rt) ll ll' var \\<and>\n                    wf_marking (Node lt p rt) mark (markb(p := m)) m \\<and>\n                    (\\<forall>pa.\n                        pa \\<notin> set_of (Node lt p rt) \\<longrightarrow>\n                        next pa =\n                        (if pa = p then levellist ! var p\n                         else nextb pa))))))", "proof (cases \"lt\")"], ["proof (state)\ngoal (2 subgoals):\n 1. lt = Tip \\<Longrightarrow>\n    (low p \\<noteq> Null \\<longrightarrow>\n     var (low p) < length levellist) \\<and>\n    ordered lt var \\<and>\n    (\\<forall>n\\<in>set_of lt.\n        if mark n = m\n        then n \\<in> set (ll ! var n) \\<and>\n             (\\<forall>nt p.\n                 Dag n low high nt \\<and>\n                 p \\<in> set_of nt \\<longrightarrow>\n                 mark p = m)\n        else n \\<notin> set (concat ll)) \\<and>\n    size (dag (low p) low high) < size (dag p low high) \\<and>\n    (\\<forall>marka nexta levellist lla.\n        Levellist levellist nexta lla \\<and>\n        wf_levellist lt ll lla var \\<and>\n        wf_marking lt mark marka m \\<and>\n        (\\<forall>p.\n            p \\<notin> set_of lt \\<longrightarrow>\n            next p = nexta p) \\<longrightarrow>\n        (high p \\<noteq> Null \\<longrightarrow>\n         var (high p) < length levellist) \\<and>\n        ordered rt var \\<and>\n        (\\<exists>lla.\n            Levellist levellist nexta lla \\<and>\n            (\\<forall>n\\<in>set_of rt.\n                if marka n = m\n                then n \\<in> set (lla ! var n) \\<and>\n                     (\\<forall>nt p.\n                         Dag n low high nt \\<and>\n                         p \\<in> set_of nt \\<longrightarrow>\n                         marka p = m)\n                else n \\<notin> set (concat lla)) \\<and>\n            size (dag (high p) low high) < size (dag p low high) \\<and>\n            (\\<forall>markb nextb levellist llb.\n                Levellist levellist nextb llb \\<and>\n                wf_levellist rt lla llb var \\<and>\n                wf_marking rt marka markb m \\<and>\n                (\\<forall>p.\n                    p \\<notin> set_of rt \\<longrightarrow>\n                    nexta p = nextb p) \\<longrightarrow>\n                (\\<exists>ll'.\n                    Levellist (levellist[var p := p])\n                     (nextb(p := levellist ! var p)) ll' \\<and>\n                    wf_levellist (Node lt p rt) ll ll' var \\<and>\n                    wf_marking (Node lt p rt) mark (markb(p := m)) m \\<and>\n                    (\\<forall>pa.\n                        pa \\<notin> set_of (Node lt p rt) \\<longrightarrow>\n                        next pa =\n                        (if pa = p then levellist ! var p\n                         else nextb pa))))))\n 2. \\<And>x21 x22 x23.\n       lt = Node x21 x22 x23 \\<Longrightarrow>\n       (low p \\<noteq> Null \\<longrightarrow>\n        var (low p) < length levellist) \\<and>\n       ordered lt var \\<and>\n       (\\<forall>n\\<in>set_of lt.\n           if mark n = m\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt p.\n                    Dag n low high nt \\<and>\n                    p \\<in> set_of nt \\<longrightarrow>\n                    mark p = m)\n           else n \\<notin> set (concat ll)) \\<and>\n       size (dag (low p) low high) < size (dag p low high) \\<and>\n       (\\<forall>marka nexta levellist lla.\n           Levellist levellist nexta lla \\<and>\n           wf_levellist lt ll lla var \\<and>\n           wf_marking lt mark marka m \\<and>\n           (\\<forall>p.\n               p \\<notin> set_of lt \\<longrightarrow>\n               next p = nexta p) \\<longrightarrow>\n           (high p \\<noteq> Null \\<longrightarrow>\n            var (high p) < length levellist) \\<and>\n           ordered rt var \\<and>\n           (\\<exists>lla.\n               Levellist levellist nexta lla \\<and>\n               (\\<forall>n\\<in>set_of rt.\n                   if marka n = m\n                   then n \\<in> set (lla ! var n) \\<and>\n                        (\\<forall>nt p.\n                            Dag n low high nt \\<and>\n                            p \\<in> set_of nt \\<longrightarrow>\n                            marka p = m)\n                   else n \\<notin> set (concat lla)) \\<and>\n               size (dag (high p) low high) < size (dag p low high) \\<and>\n               (\\<forall>markb nextb levellist llb.\n                   Levellist levellist nextb llb \\<and>\n                   wf_levellist rt lla llb var \\<and>\n                   wf_marking rt marka markb m \\<and>\n                   (\\<forall>p.\n                       p \\<notin> set_of rt \\<longrightarrow>\n                       nexta p = nextb p) \\<longrightarrow>\n                   (\\<exists>ll'.\n                       Levellist (levellist[var p := p])\n                        (nextb(p := levellist ! var p)) ll' \\<and>\n                       wf_levellist (Node lt p rt) ll ll' var \\<and>\n                       wf_marking (Node lt p rt) mark (markb(p := m))\n                        m \\<and>\n                       (\\<forall>pa.\n                           pa \\<notin> set_of\n  (Node lt p rt) \\<longrightarrow>\n                           next pa =\n                           (if pa = p then levellist ! var p\n                            else nextb pa))))))", "case Tip"], ["proof (state)\nthis:\n  lt = Tip\n\ngoal (2 subgoals):\n 1. lt = Tip \\<Longrightarrow>\n    (low p \\<noteq> Null \\<longrightarrow>\n     var (low p) < length levellist) \\<and>\n    ordered lt var \\<and>\n    (\\<forall>n\\<in>set_of lt.\n        if mark n = m\n        then n \\<in> set (ll ! var n) \\<and>\n             (\\<forall>nt p.\n                 Dag n low high nt \\<and>\n                 p \\<in> set_of nt \\<longrightarrow>\n                 mark p = m)\n        else n \\<notin> set (concat ll)) \\<and>\n    size (dag (low p) low high) < size (dag p low high) \\<and>\n    (\\<forall>marka nexta levellist lla.\n        Levellist levellist nexta lla \\<and>\n        wf_levellist lt ll lla var \\<and>\n        wf_marking lt mark marka m \\<and>\n        (\\<forall>p.\n            p \\<notin> set_of lt \\<longrightarrow>\n            next p = nexta p) \\<longrightarrow>\n        (high p \\<noteq> Null \\<longrightarrow>\n         var (high p) < length levellist) \\<and>\n        ordered rt var \\<and>\n        (\\<exists>lla.\n            Levellist levellist nexta lla \\<and>\n            (\\<forall>n\\<in>set_of rt.\n                if marka n = m\n                then n \\<in> set (lla ! var n) \\<and>\n                     (\\<forall>nt p.\n                         Dag n low high nt \\<and>\n                         p \\<in> set_of nt \\<longrightarrow>\n                         marka p = m)\n                else n \\<notin> set (concat lla)) \\<and>\n            size (dag (high p) low high) < size (dag p low high) \\<and>\n            (\\<forall>markb nextb levellist llb.\n                Levellist levellist nextb llb \\<and>\n                wf_levellist rt lla llb var \\<and>\n                wf_marking rt marka markb m \\<and>\n                (\\<forall>p.\n                    p \\<notin> set_of rt \\<longrightarrow>\n                    nexta p = nextb p) \\<longrightarrow>\n                (\\<exists>ll'.\n                    Levellist (levellist[var p := p])\n                     (nextb(p := levellist ! var p)) ll' \\<and>\n                    wf_levellist (Node lt p rt) ll ll' var \\<and>\n                    wf_marking (Node lt p rt) mark (markb(p := m)) m \\<and>\n                    (\\<forall>pa.\n                        pa \\<notin> set_of (Node lt p rt) \\<longrightarrow>\n                        next pa =\n                        (if pa = p then levellist ! var p\n                         else nextb pa))))))\n 2. \\<And>x21 x22 x23.\n       lt = Node x21 x22 x23 \\<Longrightarrow>\n       (low p \\<noteq> Null \\<longrightarrow>\n        var (low p) < length levellist) \\<and>\n       ordered lt var \\<and>\n       (\\<forall>n\\<in>set_of lt.\n           if mark n = m\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt p.\n                    Dag n low high nt \\<and>\n                    p \\<in> set_of nt \\<longrightarrow>\n                    mark p = m)\n           else n \\<notin> set (concat ll)) \\<and>\n       size (dag (low p) low high) < size (dag p low high) \\<and>\n       (\\<forall>marka nexta levellist lla.\n           Levellist levellist nexta lla \\<and>\n           wf_levellist lt ll lla var \\<and>\n           wf_marking lt mark marka m \\<and>\n           (\\<forall>p.\n               p \\<notin> set_of lt \\<longrightarrow>\n               next p = nexta p) \\<longrightarrow>\n           (high p \\<noteq> Null \\<longrightarrow>\n            var (high p) < length levellist) \\<and>\n           ordered rt var \\<and>\n           (\\<exists>lla.\n               Levellist levellist nexta lla \\<and>\n               (\\<forall>n\\<in>set_of rt.\n                   if marka n = m\n                   then n \\<in> set (lla ! var n) \\<and>\n                        (\\<forall>nt p.\n                            Dag n low high nt \\<and>\n                            p \\<in> set_of nt \\<longrightarrow>\n                            marka p = m)\n                   else n \\<notin> set (concat lla)) \\<and>\n               size (dag (high p) low high) < size (dag p low high) \\<and>\n               (\\<forall>markb nextb levellist llb.\n                   Levellist levellist nextb llb \\<and>\n                   wf_levellist rt lla llb var \\<and>\n                   wf_marking rt marka markb m \\<and>\n                   (\\<forall>p.\n                       p \\<notin> set_of rt \\<longrightarrow>\n                       nexta p = nextb p) \\<longrightarrow>\n                   (\\<exists>ll'.\n                       Levellist (levellist[var p := p])\n                        (nextb(p := levellist ! var p)) ll' \\<and>\n                       wf_levellist (Node lt p rt) ll ll' var \\<and>\n                       wf_marking (Node lt p rt) mark (markb(p := m))\n                        m \\<and>\n                       (\\<forall>pa.\n                           pa \\<notin> set_of\n  (Node lt p rt) \\<longrightarrow>\n                           next pa =\n                           (if pa = p then levellist ! var p\n                            else nextb pa))))))", "note lt_Tip = this"], ["proof (state)\nthis:\n  lt = Tip\n\ngoal (2 subgoals):\n 1. lt = Tip \\<Longrightarrow>\n    (low p \\<noteq> Null \\<longrightarrow>\n     var (low p) < length levellist) \\<and>\n    ordered lt var \\<and>\n    (\\<forall>n\\<in>set_of lt.\n        if mark n = m\n        then n \\<in> set (ll ! var n) \\<and>\n             (\\<forall>nt p.\n                 Dag n low high nt \\<and>\n                 p \\<in> set_of nt \\<longrightarrow>\n                 mark p = m)\n        else n \\<notin> set (concat ll)) \\<and>\n    size (dag (low p) low high) < size (dag p low high) \\<and>\n    (\\<forall>marka nexta levellist lla.\n        Levellist levellist nexta lla \\<and>\n        wf_levellist lt ll lla var \\<and>\n        wf_marking lt mark marka m \\<and>\n        (\\<forall>p.\n            p \\<notin> set_of lt \\<longrightarrow>\n            next p = nexta p) \\<longrightarrow>\n        (high p \\<noteq> Null \\<longrightarrow>\n         var (high p) < length levellist) \\<and>\n        ordered rt var \\<and>\n        (\\<exists>lla.\n            Levellist levellist nexta lla \\<and>\n            (\\<forall>n\\<in>set_of rt.\n                if marka n = m\n                then n \\<in> set (lla ! var n) \\<and>\n                     (\\<forall>nt p.\n                         Dag n low high nt \\<and>\n                         p \\<in> set_of nt \\<longrightarrow>\n                         marka p = m)\n                else n \\<notin> set (concat lla)) \\<and>\n            size (dag (high p) low high) < size (dag p low high) \\<and>\n            (\\<forall>markb nextb levellist llb.\n                Levellist levellist nextb llb \\<and>\n                wf_levellist rt lla llb var \\<and>\n                wf_marking rt marka markb m \\<and>\n                (\\<forall>p.\n                    p \\<notin> set_of rt \\<longrightarrow>\n                    nexta p = nextb p) \\<longrightarrow>\n                (\\<exists>ll'.\n                    Levellist (levellist[var p := p])\n                     (nextb(p := levellist ! var p)) ll' \\<and>\n                    wf_levellist (Node lt p rt) ll ll' var \\<and>\n                    wf_marking (Node lt p rt) mark (markb(p := m)) m \\<and>\n                    (\\<forall>pa.\n                        pa \\<notin> set_of (Node lt p rt) \\<longrightarrow>\n                        next pa =\n                        (if pa = p then levellist ! var p\n                         else nextb pa))))))\n 2. \\<And>x21 x22 x23.\n       lt = Node x21 x22 x23 \\<Longrightarrow>\n       (low p \\<noteq> Null \\<longrightarrow>\n        var (low p) < length levellist) \\<and>\n       ordered lt var \\<and>\n       (\\<forall>n\\<in>set_of lt.\n           if mark n = m\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt p.\n                    Dag n low high nt \\<and>\n                    p \\<in> set_of nt \\<longrightarrow>\n                    mark p = m)\n           else n \\<notin> set (concat ll)) \\<and>\n       size (dag (low p) low high) < size (dag p low high) \\<and>\n       (\\<forall>marka nexta levellist lla.\n           Levellist levellist nexta lla \\<and>\n           wf_levellist lt ll lla var \\<and>\n           wf_marking lt mark marka m \\<and>\n           (\\<forall>p.\n               p \\<notin> set_of lt \\<longrightarrow>\n               next p = nexta p) \\<longrightarrow>\n           (high p \\<noteq> Null \\<longrightarrow>\n            var (high p) < length levellist) \\<and>\n           ordered rt var \\<and>\n           (\\<exists>lla.\n               Levellist levellist nexta lla \\<and>\n               (\\<forall>n\\<in>set_of rt.\n                   if marka n = m\n                   then n \\<in> set (lla ! var n) \\<and>\n                        (\\<forall>nt p.\n                            Dag n low high nt \\<and>\n                            p \\<in> set_of nt \\<longrightarrow>\n                            marka p = m)\n                   else n \\<notin> set (concat lla)) \\<and>\n               size (dag (high p) low high) < size (dag p low high) \\<and>\n               (\\<forall>markb nextb levellist llb.\n                   Levellist levellist nextb llb \\<and>\n                   wf_levellist rt lla llb var \\<and>\n                   wf_marking rt marka markb m \\<and>\n                   (\\<forall>p.\n                       p \\<notin> set_of rt \\<longrightarrow>\n                       nexta p = nextb p) \\<longrightarrow>\n                   (\\<exists>ll'.\n                       Levellist (levellist[var p := p])\n                        (nextb(p := levellist ! var p)) ll' \\<and>\n                       wf_levellist (Node lt p rt) ll ll' var \\<and>\n                       wf_marking (Node lt p rt) mark (markb(p := m))\n                        m \\<and>\n                       (\\<forall>pa.\n                           pa \\<notin> set_of\n  (Node lt p rt) \\<longrightarrow>\n                           next pa =\n                           (if pa = p then levellist ! var p\n                            else nextb pa))))))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (low p \\<noteq> Null \\<longrightarrow>\n     var (low p) < length levellist) \\<and>\n    ordered lt var \\<and>\n    (\\<forall>n\\<in>set_of lt.\n        if mark n = m\n        then n \\<in> set (ll ! var n) \\<and>\n             (\\<forall>nt p.\n                 Dag n low high nt \\<and>\n                 p \\<in> set_of nt \\<longrightarrow>\n                 mark p = m)\n        else n \\<notin> set (concat ll)) \\<and>\n    size (dag (low p) low high) < size (dag p low high) \\<and>\n    (\\<forall>marka nexta levellist lla.\n        Levellist levellist nexta lla \\<and>\n        wf_levellist lt ll lla var \\<and>\n        wf_marking lt mark marka m \\<and>\n        (\\<forall>p.\n            p \\<notin> set_of lt \\<longrightarrow>\n            next p = nexta p) \\<longrightarrow>\n        (high p \\<noteq> Null \\<longrightarrow>\n         var (high p) < length levellist) \\<and>\n        ordered rt var \\<and>\n        (\\<exists>lla.\n            Levellist levellist nexta lla \\<and>\n            (\\<forall>n\\<in>set_of rt.\n                if marka n = m\n                then n \\<in> set (lla ! var n) \\<and>\n                     (\\<forall>nt p.\n                         Dag n low high nt \\<and>\n                         p \\<in> set_of nt \\<longrightarrow>\n                         marka p = m)\n                else n \\<notin> set (concat lla)) \\<and>\n            size (dag (high p) low high) < size (dag p low high) \\<and>\n            (\\<forall>markb nextb levellist llb.\n                Levellist levellist nextb llb \\<and>\n                wf_levellist rt lla llb var \\<and>\n                wf_marking rt marka markb m \\<and>\n                (\\<forall>p.\n                    p \\<notin> set_of rt \\<longrightarrow>\n                    nexta p = nextb p) \\<longrightarrow>\n                (\\<exists>ll'.\n                    Levellist (levellist[var p := p])\n                     (nextb(p := levellist ! var p)) ll' \\<and>\n                    wf_levellist (Node lt p rt) ll ll' var \\<and>\n                    wf_marking (Node lt p rt) mark (markb(p := m)) m \\<and>\n                    (\\<forall>pa.\n                        pa \\<notin> set_of (Node lt p rt) \\<longrightarrow>\n                        next pa =\n                        (if pa = p then levellist ! var p\n                         else nextb pa))))))", "proof (cases \"rt\")"], ["proof (state)\ngoal (2 subgoals):\n 1. rt = Tip \\<Longrightarrow>\n    (low p \\<noteq> Null \\<longrightarrow>\n     var (low p) < length levellist) \\<and>\n    ordered lt var \\<and>\n    (\\<forall>n\\<in>set_of lt.\n        if mark n = m\n        then n \\<in> set (ll ! var n) \\<and>\n             (\\<forall>nt p.\n                 Dag n low high nt \\<and>\n                 p \\<in> set_of nt \\<longrightarrow>\n                 mark p = m)\n        else n \\<notin> set (concat ll)) \\<and>\n    size (dag (low p) low high) < size (dag p low high) \\<and>\n    (\\<forall>marka nexta levellist lla.\n        Levellist levellist nexta lla \\<and>\n        wf_levellist lt ll lla var \\<and>\n        wf_marking lt mark marka m \\<and>\n        (\\<forall>p.\n            p \\<notin> set_of lt \\<longrightarrow>\n            next p = nexta p) \\<longrightarrow>\n        (high p \\<noteq> Null \\<longrightarrow>\n         var (high p) < length levellist) \\<and>\n        ordered rt var \\<and>\n        (\\<exists>lla.\n            Levellist levellist nexta lla \\<and>\n            (\\<forall>n\\<in>set_of rt.\n                if marka n = m\n                then n \\<in> set (lla ! var n) \\<and>\n                     (\\<forall>nt p.\n                         Dag n low high nt \\<and>\n                         p \\<in> set_of nt \\<longrightarrow>\n                         marka p = m)\n                else n \\<notin> set (concat lla)) \\<and>\n            size (dag (high p) low high) < size (dag p low high) \\<and>\n            (\\<forall>markb nextb levellist llb.\n                Levellist levellist nextb llb \\<and>\n                wf_levellist rt lla llb var \\<and>\n                wf_marking rt marka markb m \\<and>\n                (\\<forall>p.\n                    p \\<notin> set_of rt \\<longrightarrow>\n                    nexta p = nextb p) \\<longrightarrow>\n                (\\<exists>ll'.\n                    Levellist (levellist[var p := p])\n                     (nextb(p := levellist ! var p)) ll' \\<and>\n                    wf_levellist (Node lt p rt) ll ll' var \\<and>\n                    wf_marking (Node lt p rt) mark (markb(p := m)) m \\<and>\n                    (\\<forall>pa.\n                        pa \\<notin> set_of (Node lt p rt) \\<longrightarrow>\n                        next pa =\n                        (if pa = p then levellist ! var p\n                         else nextb pa))))))\n 2. \\<And>x21 x22 x23.\n       rt = Node x21 x22 x23 \\<Longrightarrow>\n       (low p \\<noteq> Null \\<longrightarrow>\n        var (low p) < length levellist) \\<and>\n       ordered lt var \\<and>\n       (\\<forall>n\\<in>set_of lt.\n           if mark n = m\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt p.\n                    Dag n low high nt \\<and>\n                    p \\<in> set_of nt \\<longrightarrow>\n                    mark p = m)\n           else n \\<notin> set (concat ll)) \\<and>\n       size (dag (low p) low high) < size (dag p low high) \\<and>\n       (\\<forall>marka nexta levellist lla.\n           Levellist levellist nexta lla \\<and>\n           wf_levellist lt ll lla var \\<and>\n           wf_marking lt mark marka m \\<and>\n           (\\<forall>p.\n               p \\<notin> set_of lt \\<longrightarrow>\n               next p = nexta p) \\<longrightarrow>\n           (high p \\<noteq> Null \\<longrightarrow>\n            var (high p) < length levellist) \\<and>\n           ordered rt var \\<and>\n           (\\<exists>lla.\n               Levellist levellist nexta lla \\<and>\n               (\\<forall>n\\<in>set_of rt.\n                   if marka n = m\n                   then n \\<in> set (lla ! var n) \\<and>\n                        (\\<forall>nt p.\n                            Dag n low high nt \\<and>\n                            p \\<in> set_of nt \\<longrightarrow>\n                            marka p = m)\n                   else n \\<notin> set (concat lla)) \\<and>\n               size (dag (high p) low high) < size (dag p low high) \\<and>\n               (\\<forall>markb nextb levellist llb.\n                   Levellist levellist nextb llb \\<and>\n                   wf_levellist rt lla llb var \\<and>\n                   wf_marking rt marka markb m \\<and>\n                   (\\<forall>p.\n                       p \\<notin> set_of rt \\<longrightarrow>\n                       nexta p = nextb p) \\<longrightarrow>\n                   (\\<exists>ll'.\n                       Levellist (levellist[var p := p])\n                        (nextb(p := levellist ! var p)) ll' \\<and>\n                       wf_levellist (Node lt p rt) ll ll' var \\<and>\n                       wf_marking (Node lt p rt) mark (markb(p := m))\n                        m \\<and>\n                       (\\<forall>pa.\n                           pa \\<notin> set_of\n  (Node lt p rt) \\<longrightarrow>\n                           next pa =\n                           (if pa = p then levellist ! var p\n                            else nextb pa))))))", "case Tip"], ["proof (state)\nthis:\n  rt = Tip\n\ngoal (2 subgoals):\n 1. rt = Tip \\<Longrightarrow>\n    (low p \\<noteq> Null \\<longrightarrow>\n     var (low p) < length levellist) \\<and>\n    ordered lt var \\<and>\n    (\\<forall>n\\<in>set_of lt.\n        if mark n = m\n        then n \\<in> set (ll ! var n) \\<and>\n             (\\<forall>nt p.\n                 Dag n low high nt \\<and>\n                 p \\<in> set_of nt \\<longrightarrow>\n                 mark p = m)\n        else n \\<notin> set (concat ll)) \\<and>\n    size (dag (low p) low high) < size (dag p low high) \\<and>\n    (\\<forall>marka nexta levellist lla.\n        Levellist levellist nexta lla \\<and>\n        wf_levellist lt ll lla var \\<and>\n        wf_marking lt mark marka m \\<and>\n        (\\<forall>p.\n            p \\<notin> set_of lt \\<longrightarrow>\n            next p = nexta p) \\<longrightarrow>\n        (high p \\<noteq> Null \\<longrightarrow>\n         var (high p) < length levellist) \\<and>\n        ordered rt var \\<and>\n        (\\<exists>lla.\n            Levellist levellist nexta lla \\<and>\n            (\\<forall>n\\<in>set_of rt.\n                if marka n = m\n                then n \\<in> set (lla ! var n) \\<and>\n                     (\\<forall>nt p.\n                         Dag n low high nt \\<and>\n                         p \\<in> set_of nt \\<longrightarrow>\n                         marka p = m)\n                else n \\<notin> set (concat lla)) \\<and>\n            size (dag (high p) low high) < size (dag p low high) \\<and>\n            (\\<forall>markb nextb levellist llb.\n                Levellist levellist nextb llb \\<and>\n                wf_levellist rt lla llb var \\<and>\n                wf_marking rt marka markb m \\<and>\n                (\\<forall>p.\n                    p \\<notin> set_of rt \\<longrightarrow>\n                    nexta p = nextb p) \\<longrightarrow>\n                (\\<exists>ll'.\n                    Levellist (levellist[var p := p])\n                     (nextb(p := levellist ! var p)) ll' \\<and>\n                    wf_levellist (Node lt p rt) ll ll' var \\<and>\n                    wf_marking (Node lt p rt) mark (markb(p := m)) m \\<and>\n                    (\\<forall>pa.\n                        pa \\<notin> set_of (Node lt p rt) \\<longrightarrow>\n                        next pa =\n                        (if pa = p then levellist ! var p\n                         else nextb pa))))))\n 2. \\<And>x21 x22 x23.\n       rt = Node x21 x22 x23 \\<Longrightarrow>\n       (low p \\<noteq> Null \\<longrightarrow>\n        var (low p) < length levellist) \\<and>\n       ordered lt var \\<and>\n       (\\<forall>n\\<in>set_of lt.\n           if mark n = m\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt p.\n                    Dag n low high nt \\<and>\n                    p \\<in> set_of nt \\<longrightarrow>\n                    mark p = m)\n           else n \\<notin> set (concat ll)) \\<and>\n       size (dag (low p) low high) < size (dag p low high) \\<and>\n       (\\<forall>marka nexta levellist lla.\n           Levellist levellist nexta lla \\<and>\n           wf_levellist lt ll lla var \\<and>\n           wf_marking lt mark marka m \\<and>\n           (\\<forall>p.\n               p \\<notin> set_of lt \\<longrightarrow>\n               next p = nexta p) \\<longrightarrow>\n           (high p \\<noteq> Null \\<longrightarrow>\n            var (high p) < length levellist) \\<and>\n           ordered rt var \\<and>\n           (\\<exists>lla.\n               Levellist levellist nexta lla \\<and>\n               (\\<forall>n\\<in>set_of rt.\n                   if marka n = m\n                   then n \\<in> set (lla ! var n) \\<and>\n                        (\\<forall>nt p.\n                            Dag n low high nt \\<and>\n                            p \\<in> set_of nt \\<longrightarrow>\n                            marka p = m)\n                   else n \\<notin> set (concat lla)) \\<and>\n               size (dag (high p) low high) < size (dag p low high) \\<and>\n               (\\<forall>markb nextb levellist llb.\n                   Levellist levellist nextb llb \\<and>\n                   wf_levellist rt lla llb var \\<and>\n                   wf_marking rt marka markb m \\<and>\n                   (\\<forall>p.\n                       p \\<notin> set_of rt \\<longrightarrow>\n                       nexta p = nextb p) \\<longrightarrow>\n                   (\\<exists>ll'.\n                       Levellist (levellist[var p := p])\n                        (nextb(p := levellist ! var p)) ll' \\<and>\n                       wf_levellist (Node lt p rt) ll ll' var \\<and>\n                       wf_marking (Node lt p rt) mark (markb(p := m))\n                        m \\<and>\n                       (\\<forall>pa.\n                           pa \\<notin> set_of\n  (Node lt p rt) \\<longrightarrow>\n                           next pa =\n                           (if pa = p then levellist ! var p\n                            else nextb pa))))))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (low p \\<noteq> Null \\<longrightarrow>\n     var (low p) < length levellist) \\<and>\n    ordered lt var \\<and>\n    (\\<forall>n\\<in>set_of lt.\n        if mark n = m\n        then n \\<in> set (ll ! var n) \\<and>\n             (\\<forall>nt p.\n                 Dag n low high nt \\<and>\n                 p \\<in> set_of nt \\<longrightarrow>\n                 mark p = m)\n        else n \\<notin> set (concat ll)) \\<and>\n    size (dag (low p) low high) < size (dag p low high) \\<and>\n    (\\<forall>marka nexta levellist lla.\n        Levellist levellist nexta lla \\<and>\n        wf_levellist lt ll lla var \\<and>\n        wf_marking lt mark marka m \\<and>\n        (\\<forall>p.\n            p \\<notin> set_of lt \\<longrightarrow>\n            next p = nexta p) \\<longrightarrow>\n        (high p \\<noteq> Null \\<longrightarrow>\n         var (high p) < length levellist) \\<and>\n        ordered rt var \\<and>\n        (\\<exists>lla.\n            Levellist levellist nexta lla \\<and>\n            (\\<forall>n\\<in>set_of rt.\n                if marka n = m\n                then n \\<in> set (lla ! var n) \\<and>\n                     (\\<forall>nt p.\n                         Dag n low high nt \\<and>\n                         p \\<in> set_of nt \\<longrightarrow>\n                         marka p = m)\n                else n \\<notin> set (concat lla)) \\<and>\n            size (dag (high p) low high) < size (dag p low high) \\<and>\n            (\\<forall>markb nextb levellist llb.\n                Levellist levellist nextb llb \\<and>\n                wf_levellist rt lla llb var \\<and>\n                wf_marking rt marka markb m \\<and>\n                (\\<forall>p.\n                    p \\<notin> set_of rt \\<longrightarrow>\n                    nexta p = nextb p) \\<longrightarrow>\n                (\\<exists>ll'.\n                    Levellist (levellist[var p := p])\n                     (nextb(p := levellist ! var p)) ll' \\<and>\n                    wf_levellist (Node lt p rt) ll ll' var \\<and>\n                    wf_marking (Node lt p rt) mark (markb(p := m)) m \\<and>\n                    (\\<forall>pa.\n                        pa \\<notin> set_of (Node lt p rt) \\<longrightarrow>\n                        next pa =\n                        (if pa = p then levellist ! var p\n                         else nextb pa))))))", "using size_rt_dec Tip lt_Tip Tip lt rt"], ["proof (prove)\nusing this:\n  size (dag (high p) low high) < size (dag p low high)\n  rt = Tip\n  lt = Tip\n  rt = Tip\n  Dag (low p) low high lt\n  Dag (high p) low high rt\n\ngoal (1 subgoal):\n 1. (low p \\<noteq> Null \\<longrightarrow>\n     var (low p) < length levellist) \\<and>\n    ordered lt var \\<and>\n    (\\<forall>n\\<in>set_of lt.\n        if mark n = m\n        then n \\<in> set (ll ! var n) \\<and>\n             (\\<forall>nt p.\n                 Dag n low high nt \\<and>\n                 p \\<in> set_of nt \\<longrightarrow>\n                 mark p = m)\n        else n \\<notin> set (concat ll)) \\<and>\n    size (dag (low p) low high) < size (dag p low high) \\<and>\n    (\\<forall>marka nexta levellist lla.\n        Levellist levellist nexta lla \\<and>\n        wf_levellist lt ll lla var \\<and>\n        wf_marking lt mark marka m \\<and>\n        (\\<forall>p.\n            p \\<notin> set_of lt \\<longrightarrow>\n            next p = nexta p) \\<longrightarrow>\n        (high p \\<noteq> Null \\<longrightarrow>\n         var (high p) < length levellist) \\<and>\n        ordered rt var \\<and>\n        (\\<exists>lla.\n            Levellist levellist nexta lla \\<and>\n            (\\<forall>n\\<in>set_of rt.\n                if marka n = m\n                then n \\<in> set (lla ! var n) \\<and>\n                     (\\<forall>nt p.\n                         Dag n low high nt \\<and>\n                         p \\<in> set_of nt \\<longrightarrow>\n                         marka p = m)\n                else n \\<notin> set (concat lla)) \\<and>\n            size (dag (high p) low high) < size (dag p low high) \\<and>\n            (\\<forall>markb nextb levellist llb.\n                Levellist levellist nextb llb \\<and>\n                wf_levellist rt lla llb var \\<and>\n                wf_marking rt marka markb m \\<and>\n                (\\<forall>p.\n                    p \\<notin> set_of rt \\<longrightarrow>\n                    nexta p = nextb p) \\<longrightarrow>\n                (\\<exists>ll'.\n                    Levellist (levellist[var p := p])\n                     (nextb(p := levellist ! var p)) ll' \\<and>\n                    wf_levellist (Node lt p rt) ll ll' var \\<and>\n                    wf_marking (Node lt p rt) mark (markb(p := m)) m \\<and>\n                    (\\<forall>pa.\n                        pa \\<notin> set_of (Node lt p rt) \\<longrightarrow>\n                        next pa =\n                        (if pa = p then levellist ! var p\n                         else nextb pa))))))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>marka nexta levellist lla markb nextb levellista llb.\n       \\<lbrakk>0 < size (dag p low high); lt = Tip; rt = Tip; low p = Null;\n        high p = Null; Levellist levellist nexta lla;\n        wf_levellist Tip ll lla var; wf_marking Tip mark marka m;\n        \\<forall>p. next p = nextb p; Levellist levellista nextb llb;\n        wf_levellist Tip lla llb var; wf_marking Tip marka markb m;\n        \\<forall>p. nexta p = nextb p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ll'.\n                            Levellist (levellista[var p := p])\n                             (nextb(p := levellista ! var p)) ll' \\<and>\n                            wf_levellist (Node Tip p Tip) ll ll' var \\<and>\n                            wf_marking (Node Tip p Tip) mark (markb(p := m))\n                             m", "subgoal premises prems for marka nexta levellista lla markb nextb levellistb llb"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ll'.\n       Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n        ll' \\<and>\n       wf_levellist (Node Tip p Tip) ll ll' var \\<and>\n       wf_marking (Node Tip p Tip) mark (markb(p := m)) m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>ll'.\n       Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n        ll' \\<and>\n       wf_levellist (Node Tip p Tip) ll ll' var \\<and>\n       wf_marking (Node Tip p Tip) mark (markb(p := m)) m", "have lla: \"Levellist levellista nexta lla\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Levellist levellista nexta lla", "by fact"], ["proof (state)\nthis:\n  Levellist levellista nexta lla\n\ngoal (1 subgoal):\n 1. \\<exists>ll'.\n       Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n        ll' \\<and>\n       wf_levellist (Node Tip p Tip) ll ll' var \\<and>\n       wf_marking (Node Tip p Tip) mark (markb(p := m)) m", "have llb: \"Levellist levellistb nextb llb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Levellist levellistb nextb llb", "by fact"], ["proof (state)\nthis:\n  Levellist levellistb nextb llb\n\ngoal (1 subgoal):\n 1. \\<exists>ll'.\n       Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n        ll' \\<and>\n       wf_levellist (Node Tip p Tip) ll ll' var \\<and>\n       wf_marking (Node Tip p Tip) mark (markb(p := m)) m", "have wfll_lt: \"wf_levellist Tip ll lla var\"\n                        \"wf_marking Tip mark marka m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_levellist Tip ll lla var &&& wf_marking Tip mark marka m", "by fact+"], ["proof (state)\nthis:\n  wf_levellist Tip ll lla var\n  wf_marking Tip mark marka m\n\ngoal (1 subgoal):\n 1. \\<exists>ll'.\n       Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n        ll' \\<and>\n       wf_levellist (Node Tip p Tip) ll ll' var \\<and>\n       wf_marking (Node Tip p Tip) mark (markb(p := m)) m", "then"], ["proof (chain)\npicking this:\n  wf_levellist Tip ll lla var\n  wf_marking Tip mark marka m", "have ll_lla: \"ll = lla\""], ["proof (prove)\nusing this:\n  wf_levellist Tip ll lla var\n  wf_marking Tip mark marka m\n\ngoal (1 subgoal):\n 1. ll = lla", "by (simp add: wf_levellist_def)"], ["proof (state)\nthis:\n  ll = lla\n\ngoal (1 subgoal):\n 1. \\<exists>ll'.\n       Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n        ll' \\<and>\n       wf_levellist (Node Tip p Tip) ll ll' var \\<and>\n       wf_marking (Node Tip p Tip) mark (markb(p := m)) m", "moreover"], ["proof (state)\nthis:\n  ll = lla\n\ngoal (1 subgoal):\n 1. \\<exists>ll'.\n       Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n        ll' \\<and>\n       wf_levellist (Node Tip p Tip) ll ll' var \\<and>\n       wf_marking (Node Tip p Tip) mark (markb(p := m)) m", "with wfll_lt lt_Tip lt"], ["proof (chain)\npicking this:\n  wf_levellist Tip ll lla var\n  wf_marking Tip mark marka m\n  lt = Tip\n  Dag (low p) low high lt\n  ll = lla", "have \"marka = mark\""], ["proof (prove)\nusing this:\n  wf_levellist Tip ll lla var\n  wf_marking Tip mark marka m\n  lt = Tip\n  Dag (low p) low high lt\n  ll = lla\n\ngoal (1 subgoal):\n 1. marka = mark", "by (simp add: wf_marking_def)"], ["proof (state)\nthis:\n  marka = mark\n\ngoal (1 subgoal):\n 1. \\<exists>ll'.\n       Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n        ll' \\<and>\n       wf_levellist (Node Tip p Tip) ll ll' var \\<and>\n       wf_marking (Node Tip p Tip) mark (markb(p := m)) m", "moreover"], ["proof (state)\nthis:\n  marka = mark\n\ngoal (1 subgoal):\n 1. \\<exists>ll'.\n       Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n        ll' \\<and>\n       wf_levellist (Node Tip p Tip) ll ll' var \\<and>\n       wf_marking (Node Tip p Tip) mark (markb(p := m)) m", "have wfll_rt:\"wf_levellist Tip lla llb var\"\n                       \"wf_marking Tip marka markb m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_levellist Tip lla llb var &&& wf_marking Tip marka markb m", "by fact+"], ["proof (state)\nthis:\n  wf_levellist Tip lla llb var\n  wf_marking Tip marka markb m\n\ngoal (1 subgoal):\n 1. \\<exists>ll'.\n       Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n        ll' \\<and>\n       wf_levellist (Node Tip p Tip) ll ll' var \\<and>\n       wf_marking (Node Tip p Tip) mark (markb(p := m)) m", "then"], ["proof (chain)\npicking this:\n  wf_levellist Tip lla llb var\n  wf_marking Tip marka markb m", "have lla_llb: \"lla = llb\""], ["proof (prove)\nusing this:\n  wf_levellist Tip lla llb var\n  wf_marking Tip marka markb m\n\ngoal (1 subgoal):\n 1. lla = llb", "by (simp add: wf_levellist_def)"], ["proof (state)\nthis:\n  lla = llb\n\ngoal (1 subgoal):\n 1. \\<exists>ll'.\n       Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n        ll' \\<and>\n       wf_levellist (Node Tip p Tip) ll ll' var \\<and>\n       wf_marking (Node Tip p Tip) mark (markb(p := m)) m", "moreover"], ["proof (state)\nthis:\n  lla = llb\n\ngoal (1 subgoal):\n 1. \\<exists>ll'.\n       Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n        ll' \\<and>\n       wf_levellist (Node Tip p Tip) ll ll' var \\<and>\n       wf_marking (Node Tip p Tip) mark (markb(p := m)) m", "with wfll_rt Tip rt"], ["proof (chain)\npicking this:\n  wf_levellist Tip lla llb var\n  wf_marking Tip marka markb m\n  rt = Tip\n  Dag (high p) low high rt\n  lla = llb", "have \"markb = marka\""], ["proof (prove)\nusing this:\n  wf_levellist Tip lla llb var\n  wf_marking Tip marka markb m\n  rt = Tip\n  Dag (high p) low high rt\n  lla = llb\n\ngoal (1 subgoal):\n 1. markb = marka", "by (simp add: wf_marking_def)"], ["proof (state)\nthis:\n  markb = marka\n\ngoal (1 subgoal):\n 1. \\<exists>ll'.\n       Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n        ll' \\<and>\n       wf_levellist (Node Tip p Tip) ll ll' var \\<and>\n       wf_marking (Node Tip p Tip) mark (markb(p := m)) m", "moreover"], ["proof (state)\nthis:\n  markb = marka\n\ngoal (1 subgoal):\n 1. \\<exists>ll'.\n       Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n        ll' \\<and>\n       wf_levellist (Node Tip p Tip) ll ll' var \\<and>\n       wf_marking (Node Tip p Tip) mark (markb(p := m)) m", "from varsll llb ll_lla lla_llb"], ["proof (chain)\npicking this:\n  var p < length ll\n  Levellist levellistb nextb llb\n  ll = lla\n  lla = llb", "obtain \"var p < length levellistb\" \"var p < length llb\""], ["proof (prove)\nusing this:\n  var p < length ll\n  Levellist levellistb nextb llb\n  ll = lla\n  lla = llb\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>var p < length levellistb; var p < length llb\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp add: Levellist_length)"], ["proof (state)\nthis:\n  var p < length levellistb\n  var p < length llb\n\ngoal (1 subgoal):\n 1. \\<exists>ll'.\n       Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n        ll' \\<and>\n       wf_levellist (Node Tip p Tip) ll ll' var \\<and>\n       wf_marking (Node Tip p Tip) mark (markb(p := m)) m", "with llb pnN"], ["proof (chain)\npicking this:\n  Levellist levellistb nextb llb\n  p \\<noteq> Null\n  var p < length levellistb\n  var p < length llb", "have llc: \"Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n                      (llb[var p := p # llb ! var p])\""], ["proof (prove)\nusing this:\n  Levellist levellistb nextb llb\n  p \\<noteq> Null\n  var p < length levellistb\n  var p < length llb\n\ngoal (1 subgoal):\n 1. Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n     (llb[var p := p # llb ! var p])", "apply (clarsimp simp add: Levellist_def map_update)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>p \\<noteq> Null; var p < length llb;\n        \\<forall>i<length llb. List (first (llb ! i)) nextb (llb ! i);\n        levellistb = map first llb; i < length llb\\<rbrakk>\n       \\<Longrightarrow> List ((map first llb)[var p := p] ! i)\n                          (nextb(p := first (llb ! var p)))\n                          (llb[var p := p # llb ! var p] ! i)", "apply (erule_tac x=i in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>p \\<noteq> Null; var p < length llb;\n        levellistb = map first llb; i < length llb;\n        i < length llb \\<longrightarrow>\n        List (first (llb ! i)) nextb (llb ! i)\\<rbrakk>\n       \\<Longrightarrow> List ((map first llb)[var p := p] ! i)\n                          (nextb(p := first (llb ! var p)))\n                          (llb[var p := p # llb ! var p] ! i)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>p \\<noteq> Null; var p < length llb;\n        levellistb = map first llb; i < length llb;\n        List (first (llb ! i)) nextb (llb ! i)\\<rbrakk>\n       \\<Longrightarrow> List ((map first llb)[var p := p] ! i)\n                          (nextb(p := first (llb ! var p)))\n                          (llb[var p := p # llb ! var p] ! i)", "apply (subgoal_tac \"p \\<notin> set (llb ! i) \")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>p \\<noteq> Null; var p < length llb;\n        levellistb = map first llb; i < length llb;\n        List (first (llb ! i)) nextb (llb ! i);\n        p \\<notin> set (llb ! i)\\<rbrakk>\n       \\<Longrightarrow> List ((map first llb)[var p := p] ! i)\n                          (nextb(p := first (llb ! var p)))\n                          (llb[var p := p # llb ! var p] ! i)\n 2. \\<And>i.\n       \\<lbrakk>p \\<noteq> Null; var p < length llb;\n        levellistb = map first llb; i < length llb;\n        List (first (llb ! i)) nextb (llb ! i)\\<rbrakk>\n       \\<Longrightarrow> p \\<notin> set (llb ! i)", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>p \\<noteq> Null; var p < length llb;\n        levellistb = map first llb; i < length llb;\n        List (first (llb ! i)) nextb (llb ! i)\\<rbrakk>\n       \\<Longrightarrow> p \\<notin> set (llb ! i)\n 2. \\<And>i.\n       \\<lbrakk>p \\<noteq> Null; var p < length llb;\n        levellistb = map first llb; i < length llb;\n        List (first (llb ! i)) nextb (llb ! i);\n        p \\<notin> set (llb ! i)\\<rbrakk>\n       \\<Longrightarrow> List ((map first llb)[var p := p] ! i)\n                          (nextb(p := first (llb ! var p)))\n                          (llb[var p := p # llb ! var p] ! i)", "using  p_notin_ll ll_lla lla_llb"], ["proof (prove)\nusing this:\n  p \\<notin> set (concat ll)\n  ll = lla\n  lla = llb\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>p \\<noteq> Null; var p < length llb;\n        levellistb = map first llb; i < length llb;\n        List (first (llb ! i)) nextb (llb ! i)\\<rbrakk>\n       \\<Longrightarrow> p \\<notin> set (llb ! i)\n 2. \\<And>i.\n       \\<lbrakk>p \\<noteq> Null; var p < length llb;\n        levellistb = map first llb; i < length llb;\n        List (first (llb ! i)) nextb (llb ! i);\n        p \\<notin> set (llb ! i)\\<rbrakk>\n       \\<Longrightarrow> List ((map first llb)[var p := p] ! i)\n                          (nextb(p := first (llb ! var p)))\n                          (llb[var p := p # llb ! var p] ! i)", "apply  simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>p \\<noteq> Null; var p < length llb;\n        levellistb = map first llb; i < length llb;\n        List (first (llb ! i)) nextb (llb ! i);\n        p \\<notin> set (llb ! i)\\<rbrakk>\n       \\<Longrightarrow> List ((map first llb)[var p := p] ! i)\n                          (nextb(p := first (llb ! var p)))\n                          (llb[var p := p # llb ! var p] ! i)", "apply (case_tac \"i=var p\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>p \\<noteq> Null; var p < length llb;\n        levellistb = map first llb; i < length llb;\n        List (first (llb ! i)) nextb (llb ! i); p \\<notin> set (llb ! i);\n        i = var p\\<rbrakk>\n       \\<Longrightarrow> List ((map first llb)[var p := p] ! i)\n                          (nextb(p := first (llb ! var p)))\n                          (llb[var p := p # llb ! var p] ! i)\n 2. \\<And>i.\n       \\<lbrakk>p \\<noteq> Null; var p < length llb;\n        levellistb = map first llb; i < length llb;\n        List (first (llb ! i)) nextb (llb ! i); p \\<notin> set (llb ! i);\n        i \\<noteq> var p\\<rbrakk>\n       \\<Longrightarrow> List ((map first llb)[var p := p] ! i)\n                          (nextb(p := first (llb ! var p)))\n                          (llb[var p := p # llb ! var p] ! i)", "apply  simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>p \\<noteq> Null; var p < length llb;\n        levellistb = map first llb; i < length llb;\n        List (first (llb ! i)) nextb (llb ! i); p \\<notin> set (llb ! i);\n        i \\<noteq> var p\\<rbrakk>\n       \\<Longrightarrow> List ((map first llb)[var p := p] ! i)\n                          (nextb(p := first (llb ! var p)))\n                          (llb[var p := p # llb ! var p] ! i)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n   (llb[var p := p # llb ! var p])\n\ngoal (1 subgoal):\n 1. \\<exists>ll'.\n       Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n        ll' \\<and>\n       wf_levellist (Node Tip p Tip) ll ll' var \\<and>\n       wf_marking (Node Tip p Tip) mark (markb(p := m)) m", "ultimately"], ["proof (chain)\npicking this:\n  ll = lla\n  marka = mark\n  lla = llb\n  markb = marka\n  Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n   (llb[var p := p # llb ! var p])", "show ?thesis"], ["proof (prove)\nusing this:\n  ll = lla\n  marka = mark\n  lla = llb\n  markb = marka\n  Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n   (llb[var p := p # llb ! var p])\n\ngoal (1 subgoal):\n 1. \\<exists>ll'.\n       Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n        ll' \\<and>\n       wf_levellist (Node Tip p Tip) ll ll' var \\<and>\n       wf_marking (Node Tip p Tip) mark (markb(p := m)) m", "using lt_Tip Tip varsll"], ["proof (prove)\nusing this:\n  ll = lla\n  marka = mark\n  lla = llb\n  markb = marka\n  Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n   (llb[var p := p # llb ! var p])\n  lt = Tip\n  rt = Tip\n  var p < length ll\n\ngoal (1 subgoal):\n 1. \\<exists>ll'.\n       Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n        ll' \\<and>\n       wf_levellist (Node Tip p Tip) ll ll' var \\<and>\n       wf_marking (Node Tip p Tip) mark (markb(p := m)) m", "apply (clarsimp simp add: wf_levellist_def wf_marking_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>ll = llb; marka = mark; lla = llb; markb = mark;\n        Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n         (llb[var p := p # llb ! var p]);\n        lt = Tip; rt = Tip; var p < length llb; i \\<le> var p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>prx.\n                            llb[var p := p # llb ! var p] ! i =\n                            prx @ llb ! i \\<and>\n                            (\\<forall>pt\\<in>set prx.\n                                pt = p \\<and> var pt = i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>ll = llb; marka = mark; lla = llb; markb = mark;\n        Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n         (llb[var p := p # llb ! var p]);\n        lt = Tip; rt = Tip; var p < length llb; i \\<le> var p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>prx.\n                            llb[var p := p # llb ! var p] ! i =\n                            prx @ llb ! i \\<and>\n                            (\\<forall>pt\\<in>set prx.\n                                pt = p \\<and> var pt = i)", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>ll = llb; marka = mark; lla = llb; markb = mark;\n        Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n         (llb[var p := p # llb ! var p]);\n        lt = Tip; rt = Tip; var p < length llb; i \\<le> var p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>prx.\n                            llb[var p := p # llb ! var p] ! i =\n                            prx @ llb ! i \\<and>\n                            (\\<forall>pt\\<in>set prx.\n                                pt = p \\<and> var pt = i)", "assume varsllb: \"var p < length llb\""], ["proof (state)\nthis:\n  var p < length llb\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>ll = llb; marka = mark; lla = llb; markb = mark;\n        Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n         (llb[var p := p # llb ! var p]);\n        lt = Tip; rt = Tip; var p < length llb; i \\<le> var p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>prx.\n                            llb[var p := p # llb ! var p] ! i =\n                            prx @ llb ! i \\<and>\n                            (\\<forall>pt\\<in>set prx.\n                                pt = p \\<and> var pt = i)", "assume \"i \\<le> var p\""], ["proof (state)\nthis:\n  i \\<le> var p\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>ll = llb; marka = mark; lla = llb; markb = mark;\n        Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n         (llb[var p := p # llb ! var p]);\n        lt = Tip; rt = Tip; var p < length llb; i \\<le> var p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>prx.\n                            llb[var p := p # llb ! var p] ! i =\n                            prx @ llb ! i \\<and>\n                            (\\<forall>pt\\<in>set prx.\n                                pt = p \\<and> var pt = i)", "show \"\\<exists>prx. llb[var p := p#llb!var p]!i = prx @ llb!i \\<and>\n                      (\\<forall>pt\\<in>set prx. pt = p \\<and> var pt = i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>prx.\n       llb[var p := p # llb ! var p] ! i = prx @ llb ! i \\<and>\n       (\\<forall>pt\\<in>set prx. pt = p \\<and> var pt = i)", "proof (cases \"i = var p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = var p \\<Longrightarrow>\n    \\<exists>prx.\n       llb[var p := p # llb ! var p] ! i = prx @ llb ! i \\<and>\n       (\\<forall>pt\\<in>set prx. pt = p \\<and> var pt = i)\n 2. i \\<noteq> var p \\<Longrightarrow>\n    \\<exists>prx.\n       llb[var p := p # llb ! var p] ! i = prx @ llb ! i \\<and>\n       (\\<forall>pt\\<in>set prx. pt = p \\<and> var pt = i)", "case True"], ["proof (state)\nthis:\n  i = var p\n\ngoal (2 subgoals):\n 1. i = var p \\<Longrightarrow>\n    \\<exists>prx.\n       llb[var p := p # llb ! var p] ! i = prx @ llb ! i \\<and>\n       (\\<forall>pt\\<in>set prx. pt = p \\<and> var pt = i)\n 2. i \\<noteq> var p \\<Longrightarrow>\n    \\<exists>prx.\n       llb[var p := p # llb ! var p] ! i = prx @ llb ! i \\<and>\n       (\\<forall>pt\\<in>set prx. pt = p \\<and> var pt = i)", "with pnN lt rt varsllb lt_Tip Tip"], ["proof (chain)\npicking this:\n  p \\<noteq> Null\n  Dag (low p) low high lt\n  Dag (high p) low high rt\n  var p < length llb\n  lt = Tip\n  rt = Tip\n  i = var p", "show ?thesis"], ["proof (prove)\nusing this:\n  p \\<noteq> Null\n  Dag (low p) low high lt\n  Dag (high p) low high rt\n  var p < length llb\n  lt = Tip\n  rt = Tip\n  i = var p\n\ngoal (1 subgoal):\n 1. \\<exists>prx.\n       llb[var p := p # llb ! var p] ! i = prx @ llb ! i \\<and>\n       (\\<forall>pt\\<in>set prx. pt = p \\<and> var pt = i)", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> Null; Dag (low p) low high lt;\n     Dag (high p) low high rt; var p < length llb; lt = Tip; rt = Tip;\n     i = var p\\<rbrakk>\n    \\<Longrightarrow> \\<exists>prx.\n                         llb[var p := p # llb ! var p] ! i =\n                         prx @ llb ! i \\<and>\n                         (\\<forall>pt\\<in>set prx. pt = p \\<and> var pt = i)", "apply (rule_tac x=\"[p]\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> Null; Dag (low p) low high lt;\n     Dag (high p) low high rt; var p < length llb; lt = Tip; rt = Tip;\n     i = var p\\<rbrakk>\n    \\<Longrightarrow> llb[var p := p # llb ! var p] ! i =\n                      [p] @ llb ! i \\<and>\n                      (\\<forall>pt\\<in>set [p]. pt = p \\<and> var pt = i)", "apply (simp add: subdag_eq_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>prx.\n     llb[var p := p # llb ! var p] ! i = prx @ llb ! i \\<and>\n     (\\<forall>pt\\<in>set prx. pt = p \\<and> var pt = i)\n\ngoal (1 subgoal):\n 1. i \\<noteq> var p \\<Longrightarrow>\n    \\<exists>prx.\n       llb[var p := p # llb ! var p] ! i = prx @ llb ! i \\<and>\n       (\\<forall>pt\\<in>set prx. pt = p \\<and> var pt = i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> var p \\<Longrightarrow>\n    \\<exists>prx.\n       llb[var p := p # llb ! var p] ! i = prx @ llb ! i \\<and>\n       (\\<forall>pt\\<in>set prx. pt = p \\<and> var pt = i)", "assume \"i \\<noteq> var p\""], ["proof (state)\nthis:\n  i \\<noteq> var p\n\ngoal (1 subgoal):\n 1. i \\<noteq> var p \\<Longrightarrow>\n    \\<exists>prx.\n       llb[var p := p # llb ! var p] ! i = prx @ llb ! i \\<and>\n       (\\<forall>pt\\<in>set prx. pt = p \\<and> var pt = i)", "with varsllb"], ["proof (chain)\npicking this:\n  var p < length llb\n  i \\<noteq> var p", "show ?thesis"], ["proof (prove)\nusing this:\n  var p < length llb\n  i \\<noteq> var p\n\ngoal (1 subgoal):\n 1. \\<exists>prx.\n       llb[var p := p # llb ! var p] ! i = prx @ llb ! i \\<and>\n       (\\<forall>pt\\<in>set prx. pt = p \\<and> var pt = i)", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>var p < length llb; i \\<noteq> var p\\<rbrakk>\n    \\<Longrightarrow> \\<exists>prx.\n                         llb[var p := p # llb ! var p] ! i =\n                         prx @ llb ! i \\<and>\n                         (\\<forall>pt\\<in>set prx. pt = p \\<and> var pt = i)", "apply (rule_tac x=\"[]\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>var p < length llb; i \\<noteq> var p\\<rbrakk>\n    \\<Longrightarrow> llb[var p := p # llb ! var p] ! i =\n                      [] @ llb ! i \\<and>\n                      (\\<forall>pt\\<in>set []. pt = p \\<and> var pt = i)", "apply (simp add: subdag_eq_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>prx.\n     llb[var p := p # llb ! var p] ! i = prx @ llb ! i \\<and>\n     (\\<forall>pt\\<in>set prx. pt = p \\<and> var pt = i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>prx.\n     llb[var p := p # llb ! var p] ! i = prx @ llb ! i \\<and>\n     (\\<forall>pt\\<in>set prx. pt = p \\<and> var pt = i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ll'.\n     Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n      ll' \\<and>\n     wf_levellist (Node Tip p Tip) ll ll' var \\<and>\n     wf_marking (Node Tip p Tip) mark (markb(p := m)) m\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (low p \\<noteq> Null \\<longrightarrow>\n   var (low p) < length levellist) \\<and>\n  ordered lt var \\<and>\n  (\\<forall>n\\<in>set_of lt.\n      if mark n = m\n      then n \\<in> set (ll ! var n) \\<and>\n           (\\<forall>nt p.\n               Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n               mark p = m)\n      else n \\<notin> set (concat ll)) \\<and>\n  size (dag (low p) low high) < size (dag p low high) \\<and>\n  (\\<forall>marka nexta levellist lla.\n      Levellist levellist nexta lla \\<and>\n      wf_levellist lt ll lla var \\<and>\n      wf_marking lt mark marka m \\<and>\n      (\\<forall>p.\n          p \\<notin> set_of lt \\<longrightarrow>\n          next p = nexta p) \\<longrightarrow>\n      (high p \\<noteq> Null \\<longrightarrow>\n       var (high p) < length levellist) \\<and>\n      ordered rt var \\<and>\n      (\\<exists>lla.\n          Levellist levellist nexta lla \\<and>\n          (\\<forall>n\\<in>set_of rt.\n              if marka n = m\n              then n \\<in> set (lla ! var n) \\<and>\n                   (\\<forall>nt p.\n                       Dag n low high nt \\<and>\n                       p \\<in> set_of nt \\<longrightarrow>\n                       marka p = m)\n              else n \\<notin> set (concat lla)) \\<and>\n          size (dag (high p) low high) < size (dag p low high) \\<and>\n          (\\<forall>markb nextb levellist llb.\n              Levellist levellist nextb llb \\<and>\n              wf_levellist rt lla llb var \\<and>\n              wf_marking rt marka markb m \\<and>\n              (\\<forall>p.\n                  p \\<notin> set_of rt \\<longrightarrow>\n                  nexta p = nextb p) \\<longrightarrow>\n              (\\<exists>ll'.\n                  Levellist (levellist[var p := p])\n                   (nextb(p := levellist ! var p)) ll' \\<and>\n                  wf_levellist (Node lt p rt) ll ll' var \\<and>\n                  wf_marking (Node lt p rt) mark (markb(p := m)) m \\<and>\n                  (\\<forall>pa.\n                      pa \\<notin> set_of (Node lt p rt) \\<longrightarrow>\n                      next pa =\n                      (if pa = p then levellist ! var p else nextb pa))))))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       rt = Node x21 x22 x23 \\<Longrightarrow>\n       (low p \\<noteq> Null \\<longrightarrow>\n        var (low p) < length levellist) \\<and>\n       ordered lt var \\<and>\n       (\\<forall>n\\<in>set_of lt.\n           if mark n = m\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt p.\n                    Dag n low high nt \\<and>\n                    p \\<in> set_of nt \\<longrightarrow>\n                    mark p = m)\n           else n \\<notin> set (concat ll)) \\<and>\n       size (dag (low p) low high) < size (dag p low high) \\<and>\n       (\\<forall>marka nexta levellist lla.\n           Levellist levellist nexta lla \\<and>\n           wf_levellist lt ll lla var \\<and>\n           wf_marking lt mark marka m \\<and>\n           (\\<forall>p.\n               p \\<notin> set_of lt \\<longrightarrow>\n               next p = nexta p) \\<longrightarrow>\n           (high p \\<noteq> Null \\<longrightarrow>\n            var (high p) < length levellist) \\<and>\n           ordered rt var \\<and>\n           (\\<exists>lla.\n               Levellist levellist nexta lla \\<and>\n               (\\<forall>n\\<in>set_of rt.\n                   if marka n = m\n                   then n \\<in> set (lla ! var n) \\<and>\n                        (\\<forall>nt p.\n                            Dag n low high nt \\<and>\n                            p \\<in> set_of nt \\<longrightarrow>\n                            marka p = m)\n                   else n \\<notin> set (concat lla)) \\<and>\n               size (dag (high p) low high) < size (dag p low high) \\<and>\n               (\\<forall>markb nextb levellist llb.\n                   Levellist levellist nextb llb \\<and>\n                   wf_levellist rt lla llb var \\<and>\n                   wf_marking rt marka markb m \\<and>\n                   (\\<forall>p.\n                       p \\<notin> set_of rt \\<longrightarrow>\n                       nexta p = nextb p) \\<longrightarrow>\n                   (\\<exists>ll'.\n                       Levellist (levellist[var p := p])\n                        (nextb(p := levellist ! var p)) ll' \\<and>\n                       wf_levellist (Node lt p rt) ll ll' var \\<and>\n                       wf_marking (Node lt p rt) mark (markb(p := m))\n                        m \\<and>\n                       (\\<forall>pa.\n                           pa \\<notin> set_of\n  (Node lt p rt) \\<longrightarrow>\n                           next pa =\n                           (if pa = p then levellist ! var p\n                            else nextb pa))))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       rt = Node x21 x22 x23 \\<Longrightarrow>\n       (low p \\<noteq> Null \\<longrightarrow>\n        var (low p) < length levellist) \\<and>\n       ordered lt var \\<and>\n       (\\<forall>n\\<in>set_of lt.\n           if mark n = m\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt p.\n                    Dag n low high nt \\<and>\n                    p \\<in> set_of nt \\<longrightarrow>\n                    mark p = m)\n           else n \\<notin> set (concat ll)) \\<and>\n       size (dag (low p) low high) < size (dag p low high) \\<and>\n       (\\<forall>marka nexta levellist lla.\n           Levellist levellist nexta lla \\<and>\n           wf_levellist lt ll lla var \\<and>\n           wf_marking lt mark marka m \\<and>\n           (\\<forall>p.\n               p \\<notin> set_of lt \\<longrightarrow>\n               next p = nexta p) \\<longrightarrow>\n           (high p \\<noteq> Null \\<longrightarrow>\n            var (high p) < length levellist) \\<and>\n           ordered rt var \\<and>\n           (\\<exists>lla.\n               Levellist levellist nexta lla \\<and>\n               (\\<forall>n\\<in>set_of rt.\n                   if marka n = m\n                   then n \\<in> set (lla ! var n) \\<and>\n                        (\\<forall>nt p.\n                            Dag n low high nt \\<and>\n                            p \\<in> set_of nt \\<longrightarrow>\n                            marka p = m)\n                   else n \\<notin> set (concat lla)) \\<and>\n               size (dag (high p) low high) < size (dag p low high) \\<and>\n               (\\<forall>markb nextb levellist llb.\n                   Levellist levellist nextb llb \\<and>\n                   wf_levellist rt lla llb var \\<and>\n                   wf_marking rt marka markb m \\<and>\n                   (\\<forall>p.\n                       p \\<notin> set_of rt \\<longrightarrow>\n                       nexta p = nextb p) \\<longrightarrow>\n                   (\\<exists>ll'.\n                       Levellist (levellist[var p := p])\n                        (nextb(p := levellist ! var p)) ll' \\<and>\n                       wf_levellist (Node lt p rt) ll ll' var \\<and>\n                       wf_marking (Node lt p rt) mark (markb(p := m))\n                        m \\<and>\n                       (\\<forall>pa.\n                           pa \\<notin> set_of\n  (Node lt p rt) \\<longrightarrow>\n                           next pa =\n                           (if pa = p then levellist ! var p\n                            else nextb pa))))))", "case (Node dag1 a dag2)"], ["proof (state)\nthis:\n  rt = Node dag1 a dag2\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       rt = Node x21 x22 x23 \\<Longrightarrow>\n       (low p \\<noteq> Null \\<longrightarrow>\n        var (low p) < length levellist) \\<and>\n       ordered lt var \\<and>\n       (\\<forall>n\\<in>set_of lt.\n           if mark n = m\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt p.\n                    Dag n low high nt \\<and>\n                    p \\<in> set_of nt \\<longrightarrow>\n                    mark p = m)\n           else n \\<notin> set (concat ll)) \\<and>\n       size (dag (low p) low high) < size (dag p low high) \\<and>\n       (\\<forall>marka nexta levellist lla.\n           Levellist levellist nexta lla \\<and>\n           wf_levellist lt ll lla var \\<and>\n           wf_marking lt mark marka m \\<and>\n           (\\<forall>p.\n               p \\<notin> set_of lt \\<longrightarrow>\n               next p = nexta p) \\<longrightarrow>\n           (high p \\<noteq> Null \\<longrightarrow>\n            var (high p) < length levellist) \\<and>\n           ordered rt var \\<and>\n           (\\<exists>lla.\n               Levellist levellist nexta lla \\<and>\n               (\\<forall>n\\<in>set_of rt.\n                   if marka n = m\n                   then n \\<in> set (lla ! var n) \\<and>\n                        (\\<forall>nt p.\n                            Dag n low high nt \\<and>\n                            p \\<in> set_of nt \\<longrightarrow>\n                            marka p = m)\n                   else n \\<notin> set (concat lla)) \\<and>\n               size (dag (high p) low high) < size (dag p low high) \\<and>\n               (\\<forall>markb nextb levellist llb.\n                   Levellist levellist nextb llb \\<and>\n                   wf_levellist rt lla llb var \\<and>\n                   wf_marking rt marka markb m \\<and>\n                   (\\<forall>p.\n                       p \\<notin> set_of rt \\<longrightarrow>\n                       nexta p = nextb p) \\<longrightarrow>\n                   (\\<exists>ll'.\n                       Levellist (levellist[var p := p])\n                        (nextb(p := levellist ! var p)) ll' \\<and>\n                       wf_levellist (Node lt p rt) ll ll' var \\<and>\n                       wf_marking (Node lt p rt) mark (markb(p := m))\n                        m \\<and>\n                       (\\<forall>pa.\n                           pa \\<notin> set_of\n  (Node lt p rt) \\<longrightarrow>\n                           next pa =\n                           (if pa = p then levellist ! var p\n                            else nextb pa))))))", "have rt_node: \"rt = Node dag1 a dag2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rt = Node dag1 a dag2", "by fact"], ["proof (state)\nthis:\n  rt = Node dag1 a dag2\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       rt = Node x21 x22 x23 \\<Longrightarrow>\n       (low p \\<noteq> Null \\<longrightarrow>\n        var (low p) < length levellist) \\<and>\n       ordered lt var \\<and>\n       (\\<forall>n\\<in>set_of lt.\n           if mark n = m\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt p.\n                    Dag n low high nt \\<and>\n                    p \\<in> set_of nt \\<longrightarrow>\n                    mark p = m)\n           else n \\<notin> set (concat ll)) \\<and>\n       size (dag (low p) low high) < size (dag p low high) \\<and>\n       (\\<forall>marka nexta levellist lla.\n           Levellist levellist nexta lla \\<and>\n           wf_levellist lt ll lla var \\<and>\n           wf_marking lt mark marka m \\<and>\n           (\\<forall>p.\n               p \\<notin> set_of lt \\<longrightarrow>\n               next p = nexta p) \\<longrightarrow>\n           (high p \\<noteq> Null \\<longrightarrow>\n            var (high p) < length levellist) \\<and>\n           ordered rt var \\<and>\n           (\\<exists>lla.\n               Levellist levellist nexta lla \\<and>\n               (\\<forall>n\\<in>set_of rt.\n                   if marka n = m\n                   then n \\<in> set (lla ! var n) \\<and>\n                        (\\<forall>nt p.\n                            Dag n low high nt \\<and>\n                            p \\<in> set_of nt \\<longrightarrow>\n                            marka p = m)\n                   else n \\<notin> set (concat lla)) \\<and>\n               size (dag (high p) low high) < size (dag p low high) \\<and>\n               (\\<forall>markb nextb levellist llb.\n                   Levellist levellist nextb llb \\<and>\n                   wf_levellist rt lla llb var \\<and>\n                   wf_marking rt marka markb m \\<and>\n                   (\\<forall>p.\n                       p \\<notin> set_of rt \\<longrightarrow>\n                       nexta p = nextb p) \\<longrightarrow>\n                   (\\<exists>ll'.\n                       Levellist (levellist[var p := p])\n                        (nextb(p := levellist ! var p)) ll' \\<and>\n                       wf_levellist (Node lt p rt) ll ll' var \\<and>\n                       wf_marking (Node lt p rt) mark (markb(p := m))\n                        m \\<and>\n                       (\\<forall>pa.\n                           pa \\<notin> set_of\n  (Node lt p rt) \\<longrightarrow>\n                           next pa =\n                           (if pa = p then levellist ! var p\n                            else nextb pa))))))", "with rt"], ["proof (chain)\npicking this:\n  Dag (high p) low high rt\n  rt = Node dag1 a dag2", "have high_p: \"high p = a\""], ["proof (prove)\nusing this:\n  Dag (high p) low high rt\n  rt = Node dag1 a dag2\n\ngoal (1 subgoal):\n 1. high p = a", "by simp"], ["proof (state)\nthis:\n  high p = a\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       rt = Node x21 x22 x23 \\<Longrightarrow>\n       (low p \\<noteq> Null \\<longrightarrow>\n        var (low p) < length levellist) \\<and>\n       ordered lt var \\<and>\n       (\\<forall>n\\<in>set_of lt.\n           if mark n = m\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt p.\n                    Dag n low high nt \\<and>\n                    p \\<in> set_of nt \\<longrightarrow>\n                    mark p = m)\n           else n \\<notin> set (concat ll)) \\<and>\n       size (dag (low p) low high) < size (dag p low high) \\<and>\n       (\\<forall>marka nexta levellist lla.\n           Levellist levellist nexta lla \\<and>\n           wf_levellist lt ll lla var \\<and>\n           wf_marking lt mark marka m \\<and>\n           (\\<forall>p.\n               p \\<notin> set_of lt \\<longrightarrow>\n               next p = nexta p) \\<longrightarrow>\n           (high p \\<noteq> Null \\<longrightarrow>\n            var (high p) < length levellist) \\<and>\n           ordered rt var \\<and>\n           (\\<exists>lla.\n               Levellist levellist nexta lla \\<and>\n               (\\<forall>n\\<in>set_of rt.\n                   if marka n = m\n                   then n \\<in> set (lla ! var n) \\<and>\n                        (\\<forall>nt p.\n                            Dag n low high nt \\<and>\n                            p \\<in> set_of nt \\<longrightarrow>\n                            marka p = m)\n                   else n \\<notin> set (concat lla)) \\<and>\n               size (dag (high p) low high) < size (dag p low high) \\<and>\n               (\\<forall>markb nextb levellist llb.\n                   Levellist levellist nextb llb \\<and>\n                   wf_levellist rt lla llb var \\<and>\n                   wf_marking rt marka markb m \\<and>\n                   (\\<forall>p.\n                       p \\<notin> set_of rt \\<longrightarrow>\n                       nexta p = nextb p) \\<longrightarrow>\n                   (\\<exists>ll'.\n                       Levellist (levellist[var p := p])\n                        (nextb(p := levellist ! var p)) ll' \\<and>\n                       wf_levellist (Node lt p rt) ll ll' var \\<and>\n                       wf_marking (Node lt p rt) mark (markb(p := m))\n                        m \\<and>\n                       (\\<forall>pa.\n                           pa \\<notin> set_of\n  (Node lt p rt) \\<longrightarrow>\n                           next pa =\n                           (if pa = p then levellist ! var p\n                            else nextb pa))))))", "have s: \"\\<And>nexta. (\\<forall>p. next p = nexta p) = (next = nexta)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nexta. (\\<forall>p. next p = nexta p) = (next = nexta)", "by auto"], ["proof (state)\nthis:\n  (\\<forall>p. next p = ?nexta1 p) = (next = ?nexta1)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       rt = Node x21 x22 x23 \\<Longrightarrow>\n       (low p \\<noteq> Null \\<longrightarrow>\n        var (low p) < length levellist) \\<and>\n       ordered lt var \\<and>\n       (\\<forall>n\\<in>set_of lt.\n           if mark n = m\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt p.\n                    Dag n low high nt \\<and>\n                    p \\<in> set_of nt \\<longrightarrow>\n                    mark p = m)\n           else n \\<notin> set (concat ll)) \\<and>\n       size (dag (low p) low high) < size (dag p low high) \\<and>\n       (\\<forall>marka nexta levellist lla.\n           Levellist levellist nexta lla \\<and>\n           wf_levellist lt ll lla var \\<and>\n           wf_marking lt mark marka m \\<and>\n           (\\<forall>p.\n               p \\<notin> set_of lt \\<longrightarrow>\n               next p = nexta p) \\<longrightarrow>\n           (high p \\<noteq> Null \\<longrightarrow>\n            var (high p) < length levellist) \\<and>\n           ordered rt var \\<and>\n           (\\<exists>lla.\n               Levellist levellist nexta lla \\<and>\n               (\\<forall>n\\<in>set_of rt.\n                   if marka n = m\n                   then n \\<in> set (lla ! var n) \\<and>\n                        (\\<forall>nt p.\n                            Dag n low high nt \\<and>\n                            p \\<in> set_of nt \\<longrightarrow>\n                            marka p = m)\n                   else n \\<notin> set (concat lla)) \\<and>\n               size (dag (high p) low high) < size (dag p low high) \\<and>\n               (\\<forall>markb nextb levellist llb.\n                   Levellist levellist nextb llb \\<and>\n                   wf_levellist rt lla llb var \\<and>\n                   wf_marking rt marka markb m \\<and>\n                   (\\<forall>p.\n                       p \\<notin> set_of rt \\<longrightarrow>\n                       nexta p = nextb p) \\<longrightarrow>\n                   (\\<exists>ll'.\n                       Levellist (levellist[var p := p])\n                        (nextb(p := levellist ! var p)) ll' \\<and>\n                       wf_levellist (Node lt p rt) ll ll' var \\<and>\n                       wf_marking (Node lt p rt) mark (markb(p := m))\n                        m \\<and>\n                       (\\<forall>pa.\n                           pa \\<notin> set_of\n  (Node lt p rt) \\<longrightarrow>\n                           next pa =\n                           (if pa = p then levellist ! var p\n                            else nextb pa))))))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (low p \\<noteq> Null \\<longrightarrow>\n     var (low p) < length levellist) \\<and>\n    ordered lt var \\<and>\n    (\\<forall>n\\<in>set_of lt.\n        if mark n = m\n        then n \\<in> set (ll ! var n) \\<and>\n             (\\<forall>nt p.\n                 Dag n low high nt \\<and>\n                 p \\<in> set_of nt \\<longrightarrow>\n                 mark p = m)\n        else n \\<notin> set (concat ll)) \\<and>\n    size (dag (low p) low high) < size (dag p low high) \\<and>\n    (\\<forall>marka nexta levellist lla.\n        Levellist levellist nexta lla \\<and>\n        wf_levellist lt ll lla var \\<and>\n        wf_marking lt mark marka m \\<and>\n        (\\<forall>p.\n            p \\<notin> set_of lt \\<longrightarrow>\n            next p = nexta p) \\<longrightarrow>\n        (high p \\<noteq> Null \\<longrightarrow>\n         var (high p) < length levellist) \\<and>\n        ordered rt var \\<and>\n        (\\<exists>lla.\n            Levellist levellist nexta lla \\<and>\n            (\\<forall>n\\<in>set_of rt.\n                if marka n = m\n                then n \\<in> set (lla ! var n) \\<and>\n                     (\\<forall>nt p.\n                         Dag n low high nt \\<and>\n                         p \\<in> set_of nt \\<longrightarrow>\n                         marka p = m)\n                else n \\<notin> set (concat lla)) \\<and>\n            size (dag (high p) low high) < size (dag p low high) \\<and>\n            (\\<forall>markb nextb levellist llb.\n                Levellist levellist nextb llb \\<and>\n                wf_levellist rt lla llb var \\<and>\n                wf_marking rt marka markb m \\<and>\n                (\\<forall>p.\n                    p \\<notin> set_of rt \\<longrightarrow>\n                    nexta p = nextb p) \\<longrightarrow>\n                (\\<exists>ll'.\n                    Levellist (levellist[var p := p])\n                     (nextb(p := levellist ! var p)) ll' \\<and>\n                    wf_levellist (Node lt p rt) ll ll' var \\<and>\n                    wf_marking (Node lt p rt) mark (markb(p := m)) m \\<and>\n                    (\\<forall>pa.\n                        pa \\<notin> set_of (Node lt p rt) \\<longrightarrow>\n                        next pa =\n                        (if pa = p then levellist ! var p\n                         else nextb pa))))))", "using size_rt_dec size_lt_dec rt_node lt_Tip Tip lt rt"], ["proof (prove)\nusing this:\n  size (dag (high p) low high) < size (dag p low high)\n  size (dag (low p) low high) < size (dag p low high)\n  rt = Node dag1 a dag2\n  lt = Tip\n  lt = Tip\n  Dag (low p) low high lt\n  Dag (high p) low high rt\n\ngoal (1 subgoal):\n 1. (low p \\<noteq> Null \\<longrightarrow>\n     var (low p) < length levellist) \\<and>\n    ordered lt var \\<and>\n    (\\<forall>n\\<in>set_of lt.\n        if mark n = m\n        then n \\<in> set (ll ! var n) \\<and>\n             (\\<forall>nt p.\n                 Dag n low high nt \\<and>\n                 p \\<in> set_of nt \\<longrightarrow>\n                 mark p = m)\n        else n \\<notin> set (concat ll)) \\<and>\n    size (dag (low p) low high) < size (dag p low high) \\<and>\n    (\\<forall>marka nexta levellist lla.\n        Levellist levellist nexta lla \\<and>\n        wf_levellist lt ll lla var \\<and>\n        wf_marking lt mark marka m \\<and>\n        (\\<forall>p.\n            p \\<notin> set_of lt \\<longrightarrow>\n            next p = nexta p) \\<longrightarrow>\n        (high p \\<noteq> Null \\<longrightarrow>\n         var (high p) < length levellist) \\<and>\n        ordered rt var \\<and>\n        (\\<exists>lla.\n            Levellist levellist nexta lla \\<and>\n            (\\<forall>n\\<in>set_of rt.\n                if marka n = m\n                then n \\<in> set (lla ! var n) \\<and>\n                     (\\<forall>nt p.\n                         Dag n low high nt \\<and>\n                         p \\<in> set_of nt \\<longrightarrow>\n                         marka p = m)\n                else n \\<notin> set (concat lla)) \\<and>\n            size (dag (high p) low high) < size (dag p low high) \\<and>\n            (\\<forall>markb nextb levellist llb.\n                Levellist levellist nextb llb \\<and>\n                wf_levellist rt lla llb var \\<and>\n                wf_marking rt marka markb m \\<and>\n                (\\<forall>p.\n                    p \\<notin> set_of rt \\<longrightarrow>\n                    nexta p = nextb p) \\<longrightarrow>\n                (\\<exists>ll'.\n                    Levellist (levellist[var p := p])\n                     (nextb(p := levellist ! var p)) ll' \\<and>\n                    wf_levellist (Node lt p rt) ll ll' var \\<and>\n                    wf_marking (Node lt p rt) mark (markb(p := m)) m \\<and>\n                    (\\<forall>pa.\n                        pa \\<notin> set_of (Node lt p rt) \\<longrightarrow>\n                        next pa =\n                        (if pa = p then levellist ! var p\n                         else nextb pa))))))", "apply (clarsimp simp del: set_of_Node split del: if_split simp add: s)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>marka levellist lla.\n       \\<lbrakk>size (dag (high p) low high) < size (dag p low high);\n        rt = Node dag1 (high p) dag2; lt = Tip; low p = Null; a = high p;\n        high p \\<noteq> Null; Dag (low (high p)) low high dag1;\n        Dag (high (high p)) low high dag2; Levellist levellist next lla;\n        wf_levellist Tip ll lla var; wf_marking Tip mark marka m\\<rbrakk>\n       \\<Longrightarrow> var (high p) < length levellist \\<and>\n                         ordered (Node dag1 (high p) dag2) var \\<and>\n                         (\\<forall>n\\<in>set_of (Node dag1 (high p) dag2).\n                             if marka n = m\n                             then n \\<in> set (lla ! var n) \\<and>\n                                  (\\<forall>nt p.\nDag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow> marka p = m)\n                             else n \\<notin> set (concat lla)) \\<and>\n                         (\\<forall>markb nextb levellist.\n                             (\\<exists>llb.\n                                 Levellist levellist nextb llb \\<and>\n                                 wf_levellist (Node dag1 (high p) dag2) lla\n                                  llb var \\<and>\n                                 wf_marking (Node dag1 (high p) dag2) marka\n                                  markb m \\<and>\n                                 (\\<forall>pa.\n                                     pa \\<notin> set_of\n            (Node dag1 (high p) dag2) \\<longrightarrow>\n                                     next pa = nextb pa)) \\<longrightarrow>\n                             (\\<exists>ll'.\n                                 Levellist (levellist[var p := p])\n                                  (nextb(p := levellist ! var p)) ll' \\<and>\n                                 wf_levellist\n                                  (Node Tip p (Node dag1 (high p) dag2)) ll\n                                  ll' var \\<and>\n                                 wf_marking\n                                  (Node Tip p (Node dag1 (high p) dag2))\n                                  mark (markb(p := m)) m \\<and>\n                                 (\\<forall>pa.\n                                     pa \\<notin> set_of\n            (Node Tip p (Node dag1 (high p) dag2)) \\<longrightarrow>\n                                     next pa =\n                                     (if pa = p then levellist ! var p\nelse nextb pa))))", "subgoal premises prems for marka levellista lla"], ["proof (prove)\ngoal (1 subgoal):\n 1. var (high p) < length levellista \\<and>\n    ordered (Node dag1 (high p) dag2) var \\<and>\n    (\\<forall>n\\<in>set_of (Node dag1 (high p) dag2).\n        if marka n = m\n        then n \\<in> set (lla ! var n) \\<and>\n             (\\<forall>nt p.\n                 Dag n low high nt \\<and>\n                 p \\<in> set_of nt \\<longrightarrow>\n                 marka p = m)\n        else n \\<notin> set (concat lla)) \\<and>\n    (\\<forall>markb nextb levellist.\n        (\\<exists>llb.\n            Levellist levellist nextb llb \\<and>\n            wf_levellist (Node dag1 (high p) dag2) lla llb var \\<and>\n            wf_marking (Node dag1 (high p) dag2) marka markb m \\<and>\n            (\\<forall>pa.\n                pa \\<notin> set_of\n                             (Node dag1 (high p) dag2) \\<longrightarrow>\n                next pa = nextb pa)) \\<longrightarrow>\n        (\\<exists>ll'.\n            Levellist (levellist[var p := p])\n             (nextb(p := levellist ! var p)) ll' \\<and>\n            wf_levellist (Node Tip p (Node dag1 (high p) dag2)) ll ll'\n             var \\<and>\n            wf_marking (Node Tip p (Node dag1 (high p) dag2)) mark\n             (markb(p := m)) m \\<and>\n            (\\<forall>pa.\n                pa \\<notin> set_of\n                             (Node Tip p\n                               (Node dag1 (high p) dag2)) \\<longrightarrow>\n                next pa =\n                (if pa = p then levellist ! var p else nextb pa))))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. var (high p) < length levellista \\<and>\n    ordered (Node dag1 (high p) dag2) var \\<and>\n    (\\<forall>n\\<in>set_of (Node dag1 (high p) dag2).\n        if marka n = m\n        then n \\<in> set (lla ! var n) \\<and>\n             (\\<forall>nt p.\n                 Dag n low high nt \\<and>\n                 p \\<in> set_of nt \\<longrightarrow>\n                 marka p = m)\n        else n \\<notin> set (concat lla)) \\<and>\n    (\\<forall>markb nextb levellist.\n        (\\<exists>llb.\n            Levellist levellist nextb llb \\<and>\n            wf_levellist (Node dag1 (high p) dag2) lla llb var \\<and>\n            wf_marking (Node dag1 (high p) dag2) marka markb m \\<and>\n            (\\<forall>pa.\n                pa \\<notin> set_of\n                             (Node dag1 (high p) dag2) \\<longrightarrow>\n                next pa = nextb pa)) \\<longrightarrow>\n        (\\<exists>ll'.\n            Levellist (levellist[var p := p])\n             (nextb(p := levellist ! var p)) ll' \\<and>\n            wf_levellist (Node Tip p (Node dag1 (high p) dag2)) ll ll'\n             var \\<and>\n            wf_marking (Node Tip p (Node dag1 (high p) dag2)) mark\n             (markb(p := m)) m \\<and>\n            (\\<forall>pa.\n                pa \\<notin> set_of\n                             (Node Tip p\n                               (Node dag1 (high p) dag2)) \\<longrightarrow>\n                next pa =\n                (if pa = p then levellist ! var p else nextb pa))))", "have lla: \"Levellist levellista next lla\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Levellist levellista next lla", "by fact"], ["proof (state)\nthis:\n  Levellist levellista next lla\n\ngoal (1 subgoal):\n 1. var (high p) < length levellista \\<and>\n    ordered (Node dag1 (high p) dag2) var \\<and>\n    (\\<forall>n\\<in>set_of (Node dag1 (high p) dag2).\n        if marka n = m\n        then n \\<in> set (lla ! var n) \\<and>\n             (\\<forall>nt p.\n                 Dag n low high nt \\<and>\n                 p \\<in> set_of nt \\<longrightarrow>\n                 marka p = m)\n        else n \\<notin> set (concat lla)) \\<and>\n    (\\<forall>markb nextb levellist.\n        (\\<exists>llb.\n            Levellist levellist nextb llb \\<and>\n            wf_levellist (Node dag1 (high p) dag2) lla llb var \\<and>\n            wf_marking (Node dag1 (high p) dag2) marka markb m \\<and>\n            (\\<forall>pa.\n                pa \\<notin> set_of\n                             (Node dag1 (high p) dag2) \\<longrightarrow>\n                next pa = nextb pa)) \\<longrightarrow>\n        (\\<exists>ll'.\n            Levellist (levellist[var p := p])\n             (nextb(p := levellist ! var p)) ll' \\<and>\n            wf_levellist (Node Tip p (Node dag1 (high p) dag2)) ll ll'\n             var \\<and>\n            wf_marking (Node Tip p (Node dag1 (high p) dag2)) mark\n             (markb(p := m)) m \\<and>\n            (\\<forall>pa.\n                pa \\<notin> set_of\n                             (Node Tip p\n                               (Node dag1 (high p) dag2)) \\<longrightarrow>\n                next pa =\n                (if pa = p then levellist ! var p else nextb pa))))", "have wfll_lt:\"wf_levellist Tip ll lla var\"\n                       \"wf_marking Tip mark marka m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_levellist Tip ll lla var &&& wf_marking Tip mark marka m", "by fact+"], ["proof (state)\nthis:\n  wf_levellist Tip ll lla var\n  wf_marking Tip mark marka m\n\ngoal (1 subgoal):\n 1. var (high p) < length levellista \\<and>\n    ordered (Node dag1 (high p) dag2) var \\<and>\n    (\\<forall>n\\<in>set_of (Node dag1 (high p) dag2).\n        if marka n = m\n        then n \\<in> set (lla ! var n) \\<and>\n             (\\<forall>nt p.\n                 Dag n low high nt \\<and>\n                 p \\<in> set_of nt \\<longrightarrow>\n                 marka p = m)\n        else n \\<notin> set (concat lla)) \\<and>\n    (\\<forall>markb nextb levellist.\n        (\\<exists>llb.\n            Levellist levellist nextb llb \\<and>\n            wf_levellist (Node dag1 (high p) dag2) lla llb var \\<and>\n            wf_marking (Node dag1 (high p) dag2) marka markb m \\<and>\n            (\\<forall>pa.\n                pa \\<notin> set_of\n                             (Node dag1 (high p) dag2) \\<longrightarrow>\n                next pa = nextb pa)) \\<longrightarrow>\n        (\\<exists>ll'.\n            Levellist (levellist[var p := p])\n             (nextb(p := levellist ! var p)) ll' \\<and>\n            wf_levellist (Node Tip p (Node dag1 (high p) dag2)) ll ll'\n             var \\<and>\n            wf_marking (Node Tip p (Node dag1 (high p) dag2)) mark\n             (markb(p := m)) m \\<and>\n            (\\<forall>pa.\n                pa \\<notin> set_of\n                             (Node Tip p\n                               (Node dag1 (high p) dag2)) \\<longrightarrow>\n                next pa =\n                (if pa = p then levellist ! var p else nextb pa))))", "from this"], ["proof (chain)\npicking this:\n  wf_levellist Tip ll lla var\n  wf_marking Tip mark marka m", "have ll_lla: \"ll = lla\""], ["proof (prove)\nusing this:\n  wf_levellist Tip ll lla var\n  wf_marking Tip mark marka m\n\ngoal (1 subgoal):\n 1. ll = lla", "by (simp add: wf_levellist_def)"], ["proof (state)\nthis:\n  ll = lla\n\ngoal (1 subgoal):\n 1. var (high p) < length levellista \\<and>\n    ordered (Node dag1 (high p) dag2) var \\<and>\n    (\\<forall>n\\<in>set_of (Node dag1 (high p) dag2).\n        if marka n = m\n        then n \\<in> set (lla ! var n) \\<and>\n             (\\<forall>nt p.\n                 Dag n low high nt \\<and>\n                 p \\<in> set_of nt \\<longrightarrow>\n                 marka p = m)\n        else n \\<notin> set (concat lla)) \\<and>\n    (\\<forall>markb nextb levellist.\n        (\\<exists>llb.\n            Levellist levellist nextb llb \\<and>\n            wf_levellist (Node dag1 (high p) dag2) lla llb var \\<and>\n            wf_marking (Node dag1 (high p) dag2) marka markb m \\<and>\n            (\\<forall>pa.\n                pa \\<notin> set_of\n                             (Node dag1 (high p) dag2) \\<longrightarrow>\n                next pa = nextb pa)) \\<longrightarrow>\n        (\\<exists>ll'.\n            Levellist (levellist[var p := p])\n             (nextb(p := levellist ! var p)) ll' \\<and>\n            wf_levellist (Node Tip p (Node dag1 (high p) dag2)) ll ll'\n             var \\<and>\n            wf_marking (Node Tip p (Node dag1 (high p) dag2)) mark\n             (markb(p := m)) m \\<and>\n            (\\<forall>pa.\n                pa \\<notin> set_of\n                             (Node Tip p\n                               (Node dag1 (high p) dag2)) \\<longrightarrow>\n                next pa =\n                (if pa = p then levellist ! var p else nextb pa))))", "moreover"], ["proof (state)\nthis:\n  ll = lla\n\ngoal (1 subgoal):\n 1. var (high p) < length levellista \\<and>\n    ordered (Node dag1 (high p) dag2) var \\<and>\n    (\\<forall>n\\<in>set_of (Node dag1 (high p) dag2).\n        if marka n = m\n        then n \\<in> set (lla ! var n) \\<and>\n             (\\<forall>nt p.\n                 Dag n low high nt \\<and>\n                 p \\<in> set_of nt \\<longrightarrow>\n                 marka p = m)\n        else n \\<notin> set (concat lla)) \\<and>\n    (\\<forall>markb nextb levellist.\n        (\\<exists>llb.\n            Levellist levellist nextb llb \\<and>\n            wf_levellist (Node dag1 (high p) dag2) lla llb var \\<and>\n            wf_marking (Node dag1 (high p) dag2) marka markb m \\<and>\n            (\\<forall>pa.\n                pa \\<notin> set_of\n                             (Node dag1 (high p) dag2) \\<longrightarrow>\n                next pa = nextb pa)) \\<longrightarrow>\n        (\\<exists>ll'.\n            Levellist (levellist[var p := p])\n             (nextb(p := levellist ! var p)) ll' \\<and>\n            wf_levellist (Node Tip p (Node dag1 (high p) dag2)) ll ll'\n             var \\<and>\n            wf_marking (Node Tip p (Node dag1 (high p) dag2)) mark\n             (markb(p := m)) m \\<and>\n            (\\<forall>pa.\n                pa \\<notin> set_of\n                             (Node Tip p\n                               (Node dag1 (high p) dag2)) \\<longrightarrow>\n                next pa =\n                (if pa = p then levellist ! var p else nextb pa))))", "from wfll_lt lt_Tip lt"], ["proof (chain)\npicking this:\n  wf_levellist Tip ll lla var\n  wf_marking Tip mark marka m\n  lt = Tip\n  Dag (low p) low high lt", "have marklrec: \"marka = mark\""], ["proof (prove)\nusing this:\n  wf_levellist Tip ll lla var\n  wf_marking Tip mark marka m\n  lt = Tip\n  Dag (low p) low high lt\n\ngoal (1 subgoal):\n 1. marka = mark", "by (simp add: wf_marking_def)"], ["proof (state)\nthis:\n  marka = mark\n\ngoal (1 subgoal):\n 1. var (high p) < length levellista \\<and>\n    ordered (Node dag1 (high p) dag2) var \\<and>\n    (\\<forall>n\\<in>set_of (Node dag1 (high p) dag2).\n        if marka n = m\n        then n \\<in> set (lla ! var n) \\<and>\n             (\\<forall>nt p.\n                 Dag n low high nt \\<and>\n                 p \\<in> set_of nt \\<longrightarrow>\n                 marka p = m)\n        else n \\<notin> set (concat lla)) \\<and>\n    (\\<forall>markb nextb levellist.\n        (\\<exists>llb.\n            Levellist levellist nextb llb \\<and>\n            wf_levellist (Node dag1 (high p) dag2) lla llb var \\<and>\n            wf_marking (Node dag1 (high p) dag2) marka markb m \\<and>\n            (\\<forall>pa.\n                pa \\<notin> set_of\n                             (Node dag1 (high p) dag2) \\<longrightarrow>\n                next pa = nextb pa)) \\<longrightarrow>\n        (\\<exists>ll'.\n            Levellist (levellist[var p := p])\n             (nextb(p := levellist ! var p)) ll' \\<and>\n            wf_levellist (Node Tip p (Node dag1 (high p) dag2)) ll ll'\n             var \\<and>\n            wf_marking (Node Tip p (Node dag1 (high p) dag2)) mark\n             (markb(p := m)) m \\<and>\n            (\\<forall>pa.\n                pa \\<notin> set_of\n                             (Node Tip p\n                               (Node dag1 (high p) dag2)) \\<longrightarrow>\n                next pa =\n                (if pa = p then levellist ! var p else nextb pa))))", "from orderedt varsll lla ll_lla rt_node lt_Tip high_p"], ["proof (chain)\npicking this:\n  ordered (Node lt p rt) var\n  var p < length ll\n  Levellist levellista next lla\n  ll = lla\n  rt = Node dag1 a dag2\n  lt = Tip\n  high p = a", "have var_highp_bound: \"var (high p) < length levellista\""], ["proof (prove)\nusing this:\n  ordered (Node lt p rt) var\n  var p < length ll\n  Levellist levellista next lla\n  ll = lla\n  rt = Node dag1 a dag2\n  lt = Tip\n  high p = a\n\ngoal (1 subgoal):\n 1. var (high p) < length levellista", "by (auto simp add: Levellist_length)"], ["proof (state)\nthis:\n  var (high p) < length levellista\n\ngoal (1 subgoal):\n 1. var (high p) < length levellista \\<and>\n    ordered (Node dag1 (high p) dag2) var \\<and>\n    (\\<forall>n\\<in>set_of (Node dag1 (high p) dag2).\n        if marka n = m\n        then n \\<in> set (lla ! var n) \\<and>\n             (\\<forall>nt p.\n                 Dag n low high nt \\<and>\n                 p \\<in> set_of nt \\<longrightarrow>\n                 marka p = m)\n        else n \\<notin> set (concat lla)) \\<and>\n    (\\<forall>markb nextb levellist.\n        (\\<exists>llb.\n            Levellist levellist nextb llb \\<and>\n            wf_levellist (Node dag1 (high p) dag2) lla llb var \\<and>\n            wf_marking (Node dag1 (high p) dag2) marka markb m \\<and>\n            (\\<forall>pa.\n                pa \\<notin> set_of\n                             (Node dag1 (high p) dag2) \\<longrightarrow>\n                next pa = nextb pa)) \\<longrightarrow>\n        (\\<exists>ll'.\n            Levellist (levellist[var p := p])\n             (nextb(p := levellist ! var p)) ll' \\<and>\n            wf_levellist (Node Tip p (Node dag1 (high p) dag2)) ll ll'\n             var \\<and>\n            wf_marking (Node Tip p (Node dag1 (high p) dag2)) mark\n             (markb(p := m)) m \\<and>\n            (\\<forall>pa.\n                pa \\<notin> set_of\n                             (Node Tip p\n                               (Node dag1 (high p) dag2)) \\<longrightarrow>\n                next pa =\n                (if pa = p then levellist ! var p else nextb pa))))", "from orderedt high_p rt_node lt_Tip"], ["proof (chain)\npicking this:\n  ordered (Node lt p rt) var\n  high p = a\n  rt = Node dag1 a dag2\n  lt = Tip", "have ordered_rt: \"ordered (Node dag1 (high p) dag2) var\""], ["proof (prove)\nusing this:\n  ordered (Node lt p rt) var\n  high p = a\n  rt = Node dag1 a dag2\n  lt = Tip\n\ngoal (1 subgoal):\n 1. ordered (Node dag1 (high p) dag2) var", "by simp"], ["proof (state)\nthis:\n  ordered (Node dag1 (high p) dag2) var\n\ngoal (1 subgoal):\n 1. var (high p) < length levellista \\<and>\n    ordered (Node dag1 (high p) dag2) var \\<and>\n    (\\<forall>n\\<in>set_of (Node dag1 (high p) dag2).\n        if marka n = m\n        then n \\<in> set (lla ! var n) \\<and>\n             (\\<forall>nt p.\n                 Dag n low high nt \\<and>\n                 p \\<in> set_of nt \\<longrightarrow>\n                 marka p = m)\n        else n \\<notin> set (concat lla)) \\<and>\n    (\\<forall>markb nextb levellist.\n        (\\<exists>llb.\n            Levellist levellist nextb llb \\<and>\n            wf_levellist (Node dag1 (high p) dag2) lla llb var \\<and>\n            wf_marking (Node dag1 (high p) dag2) marka markb m \\<and>\n            (\\<forall>pa.\n                pa \\<notin> set_of\n                             (Node dag1 (high p) dag2) \\<longrightarrow>\n                next pa = nextb pa)) \\<longrightarrow>\n        (\\<exists>ll'.\n            Levellist (levellist[var p := p])\n             (nextb(p := levellist ! var p)) ll' \\<and>\n            wf_levellist (Node Tip p (Node dag1 (high p) dag2)) ll ll'\n             var \\<and>\n            wf_marking (Node Tip p (Node dag1 (high p) dag2)) mark\n             (markb(p := m)) m \\<and>\n            (\\<forall>pa.\n                pa \\<notin> set_of\n                             (Node Tip p\n                               (Node dag1 (high p) dag2)) \\<longrightarrow>\n                next pa =\n                (if pa = p then levellist ! var p else nextb pa))))", "from high_p marklrec marked_child_ll lt rt lt_Tip rt_node ll_lla"], ["proof (chain)\npicking this:\n  high p = a\n  marka = mark\n  \\<forall>n\\<in>set_of (Node lt p rt).\n     if mark n = m\n     then n \\<in> set (ll ! var n) \\<and>\n          (\\<forall>nt p.\n              Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n              mark p = m)\n     else n \\<notin> set (concat ll)\n  Dag (low p) low high lt\n  Dag (high p) low high rt\n  lt = Tip\n  rt = Node dag1 a dag2\n  ll = lla", "have mark_rt: \"(\\<forall>n\\<in>set_of (Node dag1 (high p) dag2).\n                if marka n = m\n                then n \\<in> set (lla ! var n) \\<and>\n                     (\\<forall>nt p. Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow> marka p = m)\n                else n \\<notin> set (concat lla))\""], ["proof (prove)\nusing this:\n  high p = a\n  marka = mark\n  \\<forall>n\\<in>set_of (Node lt p rt).\n     if mark n = m\n     then n \\<in> set (ll ! var n) \\<and>\n          (\\<forall>nt p.\n              Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n              mark p = m)\n     else n \\<notin> set (concat ll)\n  Dag (low p) low high lt\n  Dag (high p) low high rt\n  lt = Tip\n  rt = Node dag1 a dag2\n  ll = lla\n\ngoal (1 subgoal):\n 1. \\<forall>n\\<in>set_of (Node dag1 (high p) dag2).\n       if marka n = m\n       then n \\<in> set (lla ! var n) \\<and>\n            (\\<forall>nt p.\n                Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n                marka p = m)\n       else n \\<notin> set (concat lla)", "apply (simp only: BinDag.set_of.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>high p = a; marka = mark;\n     \\<forall>n\\<in>{p} \\<union> {} \\<union>\n                    ({a} \\<union> set_of dag1 \\<union> set_of dag2).\n        if mark n = m\n        then n \\<in> set (lla ! var n) \\<and>\n             (\\<forall>nt p.\n                 Dag n low high nt \\<and>\n                 p \\<in> set_of nt \\<longrightarrow>\n                 mark p = m)\n        else n \\<notin> set (concat lla);\n     Dag (low p) low high Tip; Dag a low high (Node dag1 a dag2); lt = Tip;\n     rt = Node dag1 a dag2; ll = lla\\<rbrakk>\n    \\<Longrightarrow> \\<forall>n\\<in>{a} \\<union> set_of dag1 \\<union>\n                                     set_of dag2.\n                         if mark n = m\n                         then n \\<in> set (lla ! var n) \\<and>\n                              (\\<forall>nt p.\n                                  Dag n low high nt \\<and>\n                                  p \\<in> set_of nt \\<longrightarrow>\n                                  mark p = m)\n                         else n \\<notin> set (concat lla)", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>marka = mark;\n        \\<forall>n\\<in>{p} \\<union> {} \\<union>\n                       ({high p} \\<union> set_of dag1 \\<union> set_of dag2).\n           if mark n = m\n           then n \\<in> set (lla ! var n) \\<and>\n                (\\<forall>nt p.\n                    Dag n low high nt \\<and>\n                    p \\<in> set_of nt \\<longrightarrow>\n                    mark p = m)\n           else n \\<notin> set (concat lla);\n        Dag (low p) low high Tip;\n        Dag (high p) low high (Node dag1 (high p) dag2); lt = Tip;\n        rt = Node dag1 (high p) dag2; ll = lla; a = high p;\n        n \\<in> {high p} \\<union> set_of dag1 \\<union> set_of dag2\\<rbrakk>\n       \\<Longrightarrow> if mark n = m\n                         then n \\<in> set (lla ! var n) \\<and>\n                              (\\<forall>nt p.\n                                  Dag n low high nt \\<and>\n                                  p \\<in> set_of nt \\<longrightarrow>\n                                  mark p = m)\n                         else n \\<notin> set (concat lla)", "apply (drule_tac x=n in bspec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>marka = mark; Dag (low p) low high Tip;\n        Dag (high p) low high (Node dag1 (high p) dag2); lt = Tip;\n        rt = Node dag1 (high p) dag2; ll = lla; a = high p;\n        n \\<in> {high p} \\<union> set_of dag1 \\<union> set_of dag2\\<rbrakk>\n       \\<Longrightarrow> n \\<in> {p} \\<union> {} \\<union>\n                                 ({high p} \\<union> set_of dag1 \\<union>\n                                  set_of dag2)\n 2. \\<And>n.\n       \\<lbrakk>marka = mark; Dag (low p) low high Tip;\n        Dag (high p) low high (Node dag1 (high p) dag2); lt = Tip;\n        rt = Node dag1 (high p) dag2; ll = lla; a = high p;\n        n \\<in> {high p} \\<union> set_of dag1 \\<union> set_of dag2;\n        if mark n = m\n        then n \\<in> set (lla ! var n) \\<and>\n             (\\<forall>nt p.\n                 Dag n low high nt \\<and>\n                 p \\<in> set_of nt \\<longrightarrow>\n                 mark p = m)\n        else n \\<notin> set (concat lla)\\<rbrakk>\n       \\<Longrightarrow> if mark n = m\n                         then n \\<in> set (lla ! var n) \\<and>\n                              (\\<forall>nt p.\n                                  Dag n low high nt \\<and>\n                                  p \\<in> set_of nt \\<longrightarrow>\n                                  mark p = m)\n                         else n \\<notin> set (concat lla)", "apply  blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>marka = mark; Dag (low p) low high Tip;\n        Dag (high p) low high (Node dag1 (high p) dag2); lt = Tip;\n        rt = Node dag1 (high p) dag2; ll = lla; a = high p;\n        n \\<in> {high p} \\<union> set_of dag1 \\<union> set_of dag2;\n        if mark n = m\n        then n \\<in> set (lla ! var n) \\<and>\n             (\\<forall>nt p.\n                 Dag n low high nt \\<and>\n                 p \\<in> set_of nt \\<longrightarrow>\n                 mark p = m)\n        else n \\<notin> set (concat lla)\\<rbrakk>\n       \\<Longrightarrow> if mark n = m\n                         then n \\<in> set (lla ! var n) \\<and>\n                              (\\<forall>nt p.\n                                  Dag n low high nt \\<and>\n                                  p \\<in> set_of nt \\<longrightarrow>\n                                  mark p = m)\n                         else n \\<notin> set (concat lla)", "apply assumption"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>n\\<in>set_of (Node dag1 (high p) dag2).\n     if marka n = m\n     then n \\<in> set (lla ! var n) \\<and>\n          (\\<forall>nt p.\n              Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n              marka p = m)\n     else n \\<notin> set (concat lla)\n\ngoal (1 subgoal):\n 1. var (high p) < length levellista \\<and>\n    ordered (Node dag1 (high p) dag2) var \\<and>\n    (\\<forall>n\\<in>set_of (Node dag1 (high p) dag2).\n        if marka n = m\n        then n \\<in> set (lla ! var n) \\<and>\n             (\\<forall>nt p.\n                 Dag n low high nt \\<and>\n                 p \\<in> set_of nt \\<longrightarrow>\n                 marka p = m)\n        else n \\<notin> set (concat lla)) \\<and>\n    (\\<forall>markb nextb levellist.\n        (\\<exists>llb.\n            Levellist levellist nextb llb \\<and>\n            wf_levellist (Node dag1 (high p) dag2) lla llb var \\<and>\n            wf_marking (Node dag1 (high p) dag2) marka markb m \\<and>\n            (\\<forall>pa.\n                pa \\<notin> set_of\n                             (Node dag1 (high p) dag2) \\<longrightarrow>\n                next pa = nextb pa)) \\<longrightarrow>\n        (\\<exists>ll'.\n            Levellist (levellist[var p := p])\n             (nextb(p := levellist ! var p)) ll' \\<and>\n            wf_levellist (Node Tip p (Node dag1 (high p) dag2)) ll ll'\n             var \\<and>\n            wf_marking (Node Tip p (Node dag1 (high p) dag2)) mark\n             (markb(p := m)) m \\<and>\n            (\\<forall>pa.\n                pa \\<notin> set_of\n                             (Node Tip p\n                               (Node dag1 (high p) dag2)) \\<longrightarrow>\n                next pa =\n                (if pa = p then levellist ! var p else nextb pa))))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. var (high p) < length levellista \\<and>\n    ordered (Node dag1 (high p) dag2) var \\<and>\n    (\\<forall>n\\<in>set_of (Node dag1 (high p) dag2).\n        if marka n = m\n        then n \\<in> set (lla ! var n) \\<and>\n             (\\<forall>nt p.\n                 Dag n low high nt \\<and>\n                 p \\<in> set_of nt \\<longrightarrow>\n                 marka p = m)\n        else n \\<notin> set (concat lla)) \\<and>\n    (\\<forall>markb nextb levellist.\n        (\\<exists>llb.\n            Levellist levellist nextb llb \\<and>\n            wf_levellist (Node dag1 (high p) dag2) lla llb var \\<and>\n            wf_marking (Node dag1 (high p) dag2) marka markb m \\<and>\n            (\\<forall>pa.\n                pa \\<notin> set_of\n                             (Node dag1 (high p) dag2) \\<longrightarrow>\n                next pa = nextb pa)) \\<longrightarrow>\n        (\\<exists>ll'.\n            Levellist (levellist[var p := p])\n             (nextb(p := levellist ! var p)) ll' \\<and>\n            wf_levellist (Node Tip p (Node dag1 (high p) dag2)) ll ll'\n             var \\<and>\n            wf_marking (Node Tip p (Node dag1 (high p) dag2)) mark\n             (markb(p := m)) m \\<and>\n            (\\<forall>pa.\n                pa \\<notin> set_of\n                             (Node Tip p\n                               (Node dag1 (high p) dag2)) \\<longrightarrow>\n                next pa =\n                (if pa = p then levellist ! var p else nextb pa))))", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. var (high p) < length levellista\n 2. ordered (Node dag1 (high p) dag2) var \\<and>\n    (\\<forall>n\\<in>set_of (Node dag1 (high p) dag2).\n        if marka n = m\n        then n \\<in> set (lla ! var n) \\<and>\n             (\\<forall>nt p.\n                 Dag n low high nt \\<and>\n                 p \\<in> set_of nt \\<longrightarrow>\n                 marka p = m)\n        else n \\<notin> set (concat lla)) \\<and>\n    (\\<forall>markb nextb levellist.\n        (\\<exists>llb.\n            Levellist levellist nextb llb \\<and>\n            wf_levellist (Node dag1 (high p) dag2) lla llb var \\<and>\n            wf_marking (Node dag1 (high p) dag2) marka markb m \\<and>\n            (\\<forall>pa.\n                pa \\<notin> set_of\n                             (Node dag1 (high p) dag2) \\<longrightarrow>\n                next pa = nextb pa)) \\<longrightarrow>\n        (\\<exists>ll'.\n            Levellist (levellist[var p := p])\n             (nextb(p := levellist ! var p)) ll' \\<and>\n            wf_levellist (Node Tip p (Node dag1 (high p) dag2)) ll ll'\n             var \\<and>\n            wf_marking (Node Tip p (Node dag1 (high p) dag2)) mark\n             (markb(p := m)) m \\<and>\n            (\\<forall>pa.\n                pa \\<notin> set_of\n                             (Node Tip p\n                               (Node dag1 (high p) dag2)) \\<longrightarrow>\n                next pa =\n                (if pa = p then levellist ! var p else nextb pa))))", "apply  (rule var_highp_bound)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ordered (Node dag1 (high p) dag2) var \\<and>\n    (\\<forall>n\\<in>set_of (Node dag1 (high p) dag2).\n        if marka n = m\n        then n \\<in> set (lla ! var n) \\<and>\n             (\\<forall>nt p.\n                 Dag n low high nt \\<and>\n                 p \\<in> set_of nt \\<longrightarrow>\n                 marka p = m)\n        else n \\<notin> set (concat lla)) \\<and>\n    (\\<forall>markb nextb levellist.\n        (\\<exists>llb.\n            Levellist levellist nextb llb \\<and>\n            wf_levellist (Node dag1 (high p) dag2) lla llb var \\<and>\n            wf_marking (Node dag1 (high p) dag2) marka markb m \\<and>\n            (\\<forall>pa.\n                pa \\<notin> set_of\n                             (Node dag1 (high p) dag2) \\<longrightarrow>\n                next pa = nextb pa)) \\<longrightarrow>\n        (\\<exists>ll'.\n            Levellist (levellist[var p := p])\n             (nextb(p := levellist ! var p)) ll' \\<and>\n            wf_levellist (Node Tip p (Node dag1 (high p) dag2)) ll ll'\n             var \\<and>\n            wf_marking (Node Tip p (Node dag1 (high p) dag2)) mark\n             (markb(p := m)) m \\<and>\n            (\\<forall>pa.\n                pa \\<notin> set_of\n                             (Node Tip p\n                               (Node dag1 (high p) dag2)) \\<longrightarrow>\n                next pa =\n                (if pa = p then levellist ! var p else nextb pa))))", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. ordered (Node dag1 (high p) dag2) var\n 2. (\\<forall>n\\<in>set_of (Node dag1 (high p) dag2).\n        if marka n = m\n        then n \\<in> set (lla ! var n) \\<and>\n             (\\<forall>nt p.\n                 Dag n low high nt \\<and>\n                 p \\<in> set_of nt \\<longrightarrow>\n                 marka p = m)\n        else n \\<notin> set (concat lla)) \\<and>\n    (\\<forall>markb nextb levellist.\n        (\\<exists>llb.\n            Levellist levellist nextb llb \\<and>\n            wf_levellist (Node dag1 (high p) dag2) lla llb var \\<and>\n            wf_marking (Node dag1 (high p) dag2) marka markb m \\<and>\n            (\\<forall>pa.\n                pa \\<notin> set_of\n                             (Node dag1 (high p) dag2) \\<longrightarrow>\n                next pa = nextb pa)) \\<longrightarrow>\n        (\\<exists>ll'.\n            Levellist (levellist[var p := p])\n             (nextb(p := levellist ! var p)) ll' \\<and>\n            wf_levellist (Node Tip p (Node dag1 (high p) dag2)) ll ll'\n             var \\<and>\n            wf_marking (Node Tip p (Node dag1 (high p) dag2)) mark\n             (markb(p := m)) m \\<and>\n            (\\<forall>pa.\n                pa \\<notin> set_of\n                             (Node Tip p\n                               (Node dag1 (high p) dag2)) \\<longrightarrow>\n                next pa =\n                (if pa = p then levellist ! var p else nextb pa))))", "apply  (rule ordered_rt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>n\\<in>set_of (Node dag1 (high p) dag2).\n        if marka n = m\n        then n \\<in> set (lla ! var n) \\<and>\n             (\\<forall>nt p.\n                 Dag n low high nt \\<and>\n                 p \\<in> set_of nt \\<longrightarrow>\n                 marka p = m)\n        else n \\<notin> set (concat lla)) \\<and>\n    (\\<forall>markb nextb levellist.\n        (\\<exists>llb.\n            Levellist levellist nextb llb \\<and>\n            wf_levellist (Node dag1 (high p) dag2) lla llb var \\<and>\n            wf_marking (Node dag1 (high p) dag2) marka markb m \\<and>\n            (\\<forall>pa.\n                pa \\<notin> set_of\n                             (Node dag1 (high p) dag2) \\<longrightarrow>\n                next pa = nextb pa)) \\<longrightarrow>\n        (\\<exists>ll'.\n            Levellist (levellist[var p := p])\n             (nextb(p := levellist ! var p)) ll' \\<and>\n            wf_levellist (Node Tip p (Node dag1 (high p) dag2)) ll ll'\n             var \\<and>\n            wf_marking (Node Tip p (Node dag1 (high p) dag2)) mark\n             (markb(p := m)) m \\<and>\n            (\\<forall>pa.\n                pa \\<notin> set_of\n                             (Node Tip p\n                               (Node dag1 (high p) dag2)) \\<longrightarrow>\n                next pa =\n                (if pa = p then levellist ! var p else nextb pa))))", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>n\\<in>set_of (Node dag1 (high p) dag2).\n       if marka n = m\n       then n \\<in> set (lla ! var n) \\<and>\n            (\\<forall>nt p.\n                Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n                marka p = m)\n       else n \\<notin> set (concat lla)\n 2. \\<forall>markb nextb levellist.\n       (\\<exists>llb.\n           Levellist levellist nextb llb \\<and>\n           wf_levellist (Node dag1 (high p) dag2) lla llb var \\<and>\n           wf_marking (Node dag1 (high p) dag2) marka markb m \\<and>\n           (\\<forall>pa.\n               pa \\<notin> set_of\n                            (Node dag1 (high p) dag2) \\<longrightarrow>\n               next pa = nextb pa)) \\<longrightarrow>\n       (\\<exists>ll'.\n           Levellist (levellist[var p := p]) (nextb(p := levellist ! var p))\n            ll' \\<and>\n           wf_levellist (Node Tip p (Node dag1 (high p) dag2)) ll ll'\n            var \\<and>\n           wf_marking (Node Tip p (Node dag1 (high p) dag2)) mark\n            (markb(p := m)) m \\<and>\n           (\\<forall>pa.\n               pa \\<notin> set_of\n                            (Node Tip p\n                              (Node dag1 (high p) dag2)) \\<longrightarrow>\n               next pa = (if pa = p then levellist ! var p else nextb pa)))", "apply  (rule mark_rt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>markb nextb levellist.\n       (\\<exists>llb.\n           Levellist levellist nextb llb \\<and>\n           wf_levellist (Node dag1 (high p) dag2) lla llb var \\<and>\n           wf_marking (Node dag1 (high p) dag2) marka markb m \\<and>\n           (\\<forall>pa.\n               pa \\<notin> set_of\n                            (Node dag1 (high p) dag2) \\<longrightarrow>\n               next pa = nextb pa)) \\<longrightarrow>\n       (\\<exists>ll'.\n           Levellist (levellist[var p := p]) (nextb(p := levellist ! var p))\n            ll' \\<and>\n           wf_levellist (Node Tip p (Node dag1 (high p) dag2)) ll ll'\n            var \\<and>\n           wf_marking (Node Tip p (Node dag1 (high p) dag2)) mark\n            (markb(p := m)) m \\<and>\n           (\\<forall>pa.\n               pa \\<notin> set_of\n                            (Node Tip p\n                              (Node dag1 (high p) dag2)) \\<longrightarrow>\n               next pa = (if pa = p then levellist ! var p else nextb pa)))", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>markb nextb levellist llb.\n       \\<lbrakk>Levellist levellist nextb llb;\n        wf_levellist (Node dag1 (high p) dag2) lla llb var;\n        wf_marking (Node dag1 (high p) dag2) marka markb m;\n        \\<forall>pa.\n           pa \\<notin> set_of (Node dag1 (high p) dag2) \\<longrightarrow>\n           next pa = nextb pa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ll'.\n                            Levellist (levellist[var p := p])\n                             (nextb(p := levellist ! var p)) ll' \\<and>\n                            wf_levellist\n                             (Node Tip p (Node dag1 (high p) dag2)) ll ll'\n                             var \\<and>\n                            wf_marking\n                             (Node Tip p (Node dag1 (high p) dag2)) mark\n                             (markb(p := m)) m \\<and>\n                            (\\<forall>pa.\n                                pa \\<notin> set_of\n       (Node Tip p (Node dag1 (high p) dag2)) \\<longrightarrow>\n                                next pa =\n                                (if pa = p then levellist ! var p\n                                 else nextb pa))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>markb nextb levellist llb.\n       \\<lbrakk>Levellist levellist nextb llb;\n        wf_levellist (Node dag1 (high p) dag2) lla llb var;\n        wf_marking (Node dag1 (high p) dag2) marka markb m;\n        \\<forall>pa.\n           pa \\<noteq> high p \\<and>\n           pa \\<notin> set_of dag1 \\<and>\n           pa \\<notin> set_of dag2 \\<longrightarrow>\n           next pa = nextb pa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ll'.\n                            Levellist (levellist[var p := p])\n                             (nextb(p := levellist ! var p)) ll' \\<and>\n                            wf_levellist\n                             (Node Tip p (Node dag1 (high p) dag2)) ll ll'\n                             var \\<and>\n                            wf_marking\n                             (Node Tip p (Node dag1 (high p) dag2)) mark\n                             (markb(p := m)) m", "subgoal premises prems for markb nextb levellistb llb"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ll'.\n       Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n        ll' \\<and>\n       wf_levellist (Node Tip p (Node dag1 (high p) dag2)) ll ll' var \\<and>\n       wf_marking (Node Tip p (Node dag1 (high p) dag2)) mark\n        (markb(p := m)) m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>ll'.\n       Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n        ll' \\<and>\n       wf_levellist (Node Tip p (Node dag1 (high p) dag2)) ll ll' var \\<and>\n       wf_marking (Node Tip p (Node dag1 (high p) dag2)) mark\n        (markb(p := m)) m", "have llb: \"Levellist levellistb nextb llb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Levellist levellistb nextb llb", "by fact"], ["proof (state)\nthis:\n  Levellist levellistb nextb llb\n\ngoal (1 subgoal):\n 1. \\<exists>ll'.\n       Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n        ll' \\<and>\n       wf_levellist (Node Tip p (Node dag1 (high p) dag2)) ll ll' var \\<and>\n       wf_marking (Node Tip p (Node dag1 (high p) dag2)) mark\n        (markb(p := m)) m", "have wfll_rt: \"wf_levellist (Node dag1 (high p) dag2) lla llb var\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_levellist (Node dag1 (high p) dag2) lla llb var", "by fact"], ["proof (state)\nthis:\n  wf_levellist (Node dag1 (high p) dag2) lla llb var\n\ngoal (1 subgoal):\n 1. \\<exists>ll'.\n       Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n        ll' \\<and>\n       wf_levellist (Node Tip p (Node dag1 (high p) dag2)) ll ll' var \\<and>\n       wf_marking (Node Tip p (Node dag1 (high p) dag2)) mark\n        (markb(p := m)) m", "have wfmarking_rt: \"wf_marking (Node dag1 (high p) dag2) marka markb m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_marking (Node dag1 (high p) dag2) marka markb m", "by fact"], ["proof (state)\nthis:\n  wf_marking (Node dag1 (high p) dag2) marka markb m\n\ngoal (1 subgoal):\n 1. \\<exists>ll'.\n       Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n        ll' \\<and>\n       wf_levellist (Node Tip p (Node dag1 (high p) dag2)) ll ll' var \\<and>\n       wf_marking (Node Tip p (Node dag1 (high p) dag2)) mark\n        (markb(p := m)) m", "from wfll_rt varsll llb ll_lla"], ["proof (chain)\npicking this:\n  wf_levellist (Node dag1 (high p) dag2) lla llb var\n  var p < length ll\n  Levellist levellistb nextb llb\n  ll = lla", "obtain var_p_bounds: \"var p < length levellistb\" \"var p < length llb\""], ["proof (prove)\nusing this:\n  wf_levellist (Node dag1 (high p) dag2) lla llb var\n  var p < length ll\n  Levellist levellistb nextb llb\n  ll = lla\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>var p < length levellistb; var p < length llb\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp add: Levellist_length wf_levellist_def)"], ["proof (state)\nthis:\n  var p < length levellistb\n  var p < length llb\n\ngoal (1 subgoal):\n 1. \\<exists>ll'.\n       Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n        ll' \\<and>\n       wf_levellist (Node Tip p (Node dag1 (high p) dag2)) ll ll' var \\<and>\n       wf_marking (Node Tip p (Node dag1 (high p) dag2)) mark\n        (markb(p := m)) m", "with p_notin_ll ll_lla wfll_rt"], ["proof (chain)\npicking this:\n  p \\<notin> set (concat ll)\n  ll = lla\n  wf_levellist (Node dag1 (high p) dag2) lla llb var\n  var p < length levellistb\n  var p < length llb", "have p_notin_llb: \"\\<forall>i < length llb. p \\<notin> set (llb ! i)\""], ["proof (prove)\nusing this:\n  p \\<notin> set (concat ll)\n  ll = lla\n  wf_levellist (Node dag1 (high p) dag2) lla llb var\n  var p < length levellistb\n  var p < length llb\n\ngoal (1 subgoal):\n 1. \\<forall>i<length llb. p \\<notin> set (llb ! i)", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<notin> set (concat ll); ll = lla;\n     wf_levellist (Node dag1 (high p) dag2) lla llb var;\n     var p < length levellistb; var p < length llb\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i<length llb. p \\<notin> set (llb ! i)", "apply (intro allI impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>p \\<notin> set (concat ll); ll = lla;\n        wf_levellist (Node dag1 (high p) dag2) lla llb var;\n        var p < length levellistb; var p < length llb;\n        i < length llb\\<rbrakk>\n       \\<Longrightarrow> p \\<notin> set (llb ! i)", "apply (clarsimp simp add: wf_levellist_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<forall>x\\<in>set lla. p \\<notin> set x; ll = lla;\n        var p < length levellistb; var p < length lla; i < length lla;\n        \\<forall>q.\n           (q = high p \\<longrightarrow>\n            high p \\<in> set (llb ! var (high p))) \\<and>\n           (q \\<in> set_of dag1 \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of dag2 \\<longrightarrow>\n            q \\<in> set (llb ! var q));\n        \\<forall>i\\<le>var (high p).\n           \\<exists>prx.\n              llb ! i = prx @ lla ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = high p \\<or>\n                   pt \\<in> set_of dag1 \\<or> pt \\<in> set_of dag2) \\<and>\n                  var pt = i);\n        \\<forall>i>var (high p). llb ! i = lla ! i; length llb = length lla;\n        p \\<in> set (llb ! i)\\<rbrakk>\n       \\<Longrightarrow> False", "apply (case_tac \"i \\<le> var (high p)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>\\<forall>x\\<in>set lla. p \\<notin> set x; ll = lla;\n        var p < length levellistb; var p < length lla; i < length lla;\n        \\<forall>q.\n           (q = high p \\<longrightarrow>\n            high p \\<in> set (llb ! var (high p))) \\<and>\n           (q \\<in> set_of dag1 \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of dag2 \\<longrightarrow>\n            q \\<in> set (llb ! var q));\n        \\<forall>i\\<le>var (high p).\n           \\<exists>prx.\n              llb ! i = prx @ lla ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = high p \\<or>\n                   pt \\<in> set_of dag1 \\<or> pt \\<in> set_of dag2) \\<and>\n                  var pt = i);\n        \\<forall>i>var (high p). llb ! i = lla ! i; length llb = length lla;\n        p \\<in> set (llb ! i); i \\<le> var (high p)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>i.\n       \\<lbrakk>\\<forall>x\\<in>set lla. p \\<notin> set x; ll = lla;\n        var p < length levellistb; var p < length lla; i < length lla;\n        \\<forall>q.\n           (q = high p \\<longrightarrow>\n            high p \\<in> set (llb ! var (high p))) \\<and>\n           (q \\<in> set_of dag1 \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of dag2 \\<longrightarrow>\n            q \\<in> set (llb ! var q));\n        \\<forall>i\\<le>var (high p).\n           \\<exists>prx.\n              llb ! i = prx @ lla ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = high p \\<or>\n                   pt \\<in> set_of dag1 \\<or> pt \\<in> set_of dag2) \\<and>\n                  var pt = i);\n        \\<forall>i>var (high p). llb ! i = lla ! i; length llb = length lla;\n        p \\<in> set (llb ! i); \\<not> i \\<le> var (high p)\\<rbrakk>\n       \\<Longrightarrow> False", "apply  (drule_tac x=i in spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>\\<forall>x\\<in>set lla. p \\<notin> set x; ll = lla;\n        var p < length levellistb; var p < length lla; i < length lla;\n        \\<forall>q.\n           (q = high p \\<longrightarrow>\n            high p \\<in> set (llb ! var (high p))) \\<and>\n           (q \\<in> set_of dag1 \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of dag2 \\<longrightarrow>\n            q \\<in> set (llb ! var q));\n        \\<forall>i>var (high p). llb ! i = lla ! i; length llb = length lla;\n        p \\<in> set (llb ! i); i \\<le> var (high p);\n        i \\<le> var (high p) \\<longrightarrow>\n        (\\<exists>prx.\n            llb ! i = prx @ lla ! i \\<and>\n            (\\<forall>pt\\<in>set prx.\n                (pt = high p \\<or>\n                 pt \\<in> set_of dag1 \\<or> pt \\<in> set_of dag2) \\<and>\n                var pt = i))\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>i.\n       \\<lbrakk>\\<forall>x\\<in>set lla. p \\<notin> set x; ll = lla;\n        var p < length levellistb; var p < length lla; i < length lla;\n        \\<forall>q.\n           (q = high p \\<longrightarrow>\n            high p \\<in> set (llb ! var (high p))) \\<and>\n           (q \\<in> set_of dag1 \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of dag2 \\<longrightarrow>\n            q \\<in> set (llb ! var q));\n        \\<forall>i\\<le>var (high p).\n           \\<exists>prx.\n              llb ! i = prx @ lla ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = high p \\<or>\n                   pt \\<in> set_of dag1 \\<or> pt \\<in> set_of dag2) \\<and>\n                  var pt = i);\n        \\<forall>i>var (high p). llb ! i = lla ! i; length llb = length lla;\n        p \\<in> set (llb ! i); \\<not> i \\<le> var (high p)\\<rbrakk>\n       \\<Longrightarrow> False", "using  orderedt rt_node lt_Tip high_p"], ["proof (prove)\nusing this:\n  ordered (Node lt p rt) var\n  rt = Node dag1 a dag2\n  lt = Tip\n  high p = a\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>\\<forall>x\\<in>set lla. p \\<notin> set x; ll = lla;\n        var p < length levellistb; var p < length lla; i < length lla;\n        \\<forall>q.\n           (q = high p \\<longrightarrow>\n            high p \\<in> set (llb ! var (high p))) \\<and>\n           (q \\<in> set_of dag1 \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of dag2 \\<longrightarrow>\n            q \\<in> set (llb ! var q));\n        \\<forall>i>var (high p). llb ! i = lla ! i; length llb = length lla;\n        p \\<in> set (llb ! i); i \\<le> var (high p);\n        i \\<le> var (high p) \\<longrightarrow>\n        (\\<exists>prx.\n            llb ! i = prx @ lla ! i \\<and>\n            (\\<forall>pt\\<in>set prx.\n                (pt = high p \\<or>\n                 pt \\<in> set_of dag1 \\<or> pt \\<in> set_of dag2) \\<and>\n                var pt = i))\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>i.\n       \\<lbrakk>\\<forall>x\\<in>set lla. p \\<notin> set x; ll = lla;\n        var p < length levellistb; var p < length lla; i < length lla;\n        \\<forall>q.\n           (q = high p \\<longrightarrow>\n            high p \\<in> set (llb ! var (high p))) \\<and>\n           (q \\<in> set_of dag1 \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of dag2 \\<longrightarrow>\n            q \\<in> set (llb ! var q));\n        \\<forall>i\\<le>var (high p).\n           \\<exists>prx.\n              llb ! i = prx @ lla ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = high p \\<or>\n                   pt \\<in> set_of dag1 \\<or> pt \\<in> set_of dag2) \\<and>\n                  var pt = i);\n        \\<forall>i>var (high p). llb ! i = lla ! i; length llb = length lla;\n        p \\<in> set (llb ! i); \\<not> i \\<le> var (high p)\\<rbrakk>\n       \\<Longrightarrow> False", "apply  clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<forall>x\\<in>set lla. p \\<notin> set x; ll = lla;\n        var p < length levellistb; var p < length lla; i < length lla;\n        \\<forall>q.\n           (q = high p \\<longrightarrow>\n            high p \\<in> set (llb ! var (high p))) \\<and>\n           (q \\<in> set_of dag1 \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of dag2 \\<longrightarrow>\n            q \\<in> set (llb ! var q));\n        \\<forall>i\\<le>var (high p).\n           \\<exists>prx.\n              llb ! i = prx @ lla ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = high p \\<or>\n                   pt \\<in> set_of dag1 \\<or> pt \\<in> set_of dag2) \\<and>\n                  var pt = i);\n        \\<forall>i>var (high p). llb ! i = lla ! i; length llb = length lla;\n        p \\<in> set (llb ! i); \\<not> i \\<le> var (high p)\\<rbrakk>\n       \\<Longrightarrow> False", "apply (drule_tac x=i in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<forall>x\\<in>set lla. p \\<notin> set x; ll = lla;\n        var p < length levellistb; var p < length lla; i < length lla;\n        \\<forall>q.\n           (q = high p \\<longrightarrow>\n            high p \\<in> set (llb ! var (high p))) \\<and>\n           (q \\<in> set_of dag1 \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of dag2 \\<longrightarrow>\n            q \\<in> set (llb ! var q));\n        \\<forall>i>var (high p). llb ! i = lla ! i; length llb = length lla;\n        p \\<in> set (llb ! i); \\<not> i \\<le> var (high p);\n        i \\<le> var (high p) \\<longrightarrow>\n        (\\<exists>prx.\n            llb ! i = prx @ lla ! i \\<and>\n            (\\<forall>pt\\<in>set prx.\n                (pt = high p \\<or>\n                 pt \\<in> set_of dag1 \\<or> pt \\<in> set_of dag2) \\<and>\n                var pt = i))\\<rbrakk>\n       \\<Longrightarrow> False", "apply (drule_tac x=i in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<forall>x\\<in>set lla. p \\<notin> set x; ll = lla;\n        var p < length levellistb; var p < length lla; i < length lla;\n        \\<forall>q.\n           (q = high p \\<longrightarrow>\n            high p \\<in> set (llb ! var (high p))) \\<and>\n           (q \\<in> set_of dag1 \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of dag2 \\<longrightarrow>\n            q \\<in> set (llb ! var q));\n        length llb = length lla; p \\<in> set (llb ! i);\n        \\<not> i \\<le> var (high p);\n        i \\<le> var (high p) \\<longrightarrow>\n        (\\<exists>prx.\n            llb ! i = prx @ lla ! i \\<and>\n            (\\<forall>pt\\<in>set prx.\n                (pt = high p \\<or>\n                 pt \\<in> set_of dag1 \\<or> pt \\<in> set_of dag2) \\<and>\n                var pt = i));\n        var (high p) < i \\<longrightarrow> llb ! i = lla ! i\\<rbrakk>\n       \\<Longrightarrow> False", "apply clarsimp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>i<length llb. p \\<notin> set (llb ! i)\n\ngoal (1 subgoal):\n 1. \\<exists>ll'.\n       Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n        ll' \\<and>\n       wf_levellist (Node Tip p (Node dag1 (high p) dag2)) ll ll' var \\<and>\n       wf_marking (Node Tip p (Node dag1 (high p) dag2)) mark\n        (markb(p := m)) m", "with llb pnN var_p_bounds"], ["proof (chain)\npicking this:\n  Levellist levellistb nextb llb\n  p \\<noteq> Null\n  var p < length levellistb\n  var p < length llb\n  \\<forall>i<length llb. p \\<notin> set (llb ! i)", "have llc: \"Levellist (levellistb[var p := p])\n                            (nextb(p := levellistb ! var p))\n                            (llb[var p := p # llb ! var p])\""], ["proof (prove)\nusing this:\n  Levellist levellistb nextb llb\n  p \\<noteq> Null\n  var p < length levellistb\n  var p < length llb\n  \\<forall>i<length llb. p \\<notin> set (llb ! i)\n\ngoal (1 subgoal):\n 1. Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n     (llb[var p := p # llb ! var p])", "apply (clarsimp simp add: Levellist_def map_update)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>p \\<noteq> Null; var p < length llb;\n        \\<forall>i<length llb. p \\<notin> set (llb ! i);\n        \\<forall>i<length llb. List (first (llb ! i)) nextb (llb ! i);\n        levellistb = map first llb; i < length llb\\<rbrakk>\n       \\<Longrightarrow> List ((map first llb)[var p := p] ! i)\n                          (nextb(p := first (llb ! var p)))\n                          (llb[var p := p # llb ! var p] ! i)", "apply (erule_tac x=i in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>p \\<noteq> Null; var p < length llb;\n        \\<forall>i<length llb. List (first (llb ! i)) nextb (llb ! i);\n        levellistb = map first llb; i < length llb;\n        i < length llb \\<longrightarrow> p \\<notin> set (llb ! i)\\<rbrakk>\n       \\<Longrightarrow> List ((map first llb)[var p := p] ! i)\n                          (nextb(p := first (llb ! var p)))\n                          (llb[var p := p # llb ! var p] ! i)", "apply (erule_tac x=i in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>p \\<noteq> Null; var p < length llb;\n        levellistb = map first llb; i < length llb;\n        i < length llb \\<longrightarrow> p \\<notin> set (llb ! i);\n        i < length llb \\<longrightarrow>\n        List (first (llb ! i)) nextb (llb ! i)\\<rbrakk>\n       \\<Longrightarrow> List ((map first llb)[var p := p] ! i)\n                          (nextb(p := first (llb ! var p)))\n                          (llb[var p := p # llb ! var p] ! i)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>p \\<noteq> Null; var p < length llb;\n        levellistb = map first llb; i < length llb;\n        p \\<notin> set (llb ! i);\n        List (first (llb ! i)) nextb (llb ! i)\\<rbrakk>\n       \\<Longrightarrow> List ((map first llb)[var p := p] ! i)\n                          (nextb(p := first (llb ! var p)))\n                          (llb[var p := p # llb ! var p] ! i)", "apply (case_tac \"i=var p\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>p \\<noteq> Null; var p < length llb;\n        levellistb = map first llb; i < length llb;\n        p \\<notin> set (llb ! i); List (first (llb ! i)) nextb (llb ! i);\n        i = var p\\<rbrakk>\n       \\<Longrightarrow> List ((map first llb)[var p := p] ! i)\n                          (nextb(p := first (llb ! var p)))\n                          (llb[var p := p # llb ! var p] ! i)\n 2. \\<And>i.\n       \\<lbrakk>p \\<noteq> Null; var p < length llb;\n        levellistb = map first llb; i < length llb;\n        p \\<notin> set (llb ! i); List (first (llb ! i)) nextb (llb ! i);\n        i \\<noteq> var p\\<rbrakk>\n       \\<Longrightarrow> List ((map first llb)[var p := p] ! i)\n                          (nextb(p := first (llb ! var p)))\n                          (llb[var p := p # llb ! var p] ! i)", "apply  simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>p \\<noteq> Null; var p < length llb;\n        levellistb = map first llb; i < length llb;\n        p \\<notin> set (llb ! i); List (first (llb ! i)) nextb (llb ! i);\n        i \\<noteq> var p\\<rbrakk>\n       \\<Longrightarrow> List ((map first llb)[var p := p] ! i)\n                          (nextb(p := first (llb ! var p)))\n                          (llb[var p := p # llb ! var p] ! i)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n   (llb[var p := p # llb ! var p])\n\ngoal (1 subgoal):\n 1. \\<exists>ll'.\n       Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n        ll' \\<and>\n       wf_levellist (Node Tip p (Node dag1 (high p) dag2)) ll ll' var \\<and>\n       wf_marking (Node Tip p (Node dag1 (high p) dag2)) mark\n        (markb(p := m)) m", "then"], ["proof (chain)\npicking this:\n  Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n   (llb[var p := p # llb ! var p])", "show ?thesis"], ["proof (prove)\nusing this:\n  Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n   (llb[var p := p # llb ! var p])\n\ngoal (1 subgoal):\n 1. \\<exists>ll'.\n       Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n        ll' \\<and>\n       wf_levellist (Node Tip p (Node dag1 (high p) dag2)) ll ll' var \\<and>\n       wf_marking (Node Tip p (Node dag1 (high p) dag2)) mark\n        (markb(p := m)) m", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n     (llb[var p := p # llb ! var p]) \\<Longrightarrow>\n    wf_levellist (Node Tip p (Node dag1 (high p) dag2)) ll\n     (llb[var p := p # llb ! var p]) var \\<and>\n    wf_marking (Node Tip p (Node dag1 (high p) dag2)) mark (markb(p := m)) m", "using wfll_rt wfmarking_rt\n                      lt_Tip rt_node varsll orderedt lt rt pnN ll_lla marklrec"], ["proof (prove)\nusing this:\n  wf_levellist (Node dag1 (high p) dag2) lla llb var\n  wf_marking (Node dag1 (high p) dag2) marka markb m\n  lt = Tip\n  rt = Node dag1 a dag2\n  var p < length ll\n  ordered (Node lt p rt) var\n  Dag (low p) low high lt\n  Dag (high p) low high rt\n  p \\<noteq> Null\n  ll = lla\n  marka = mark\n\ngoal (1 subgoal):\n 1. Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n     (llb[var p := p # llb ! var p]) \\<Longrightarrow>\n    wf_levellist (Node Tip p (Node dag1 (high p) dag2)) ll\n     (llb[var p := p # llb ! var p]) var \\<and>\n    wf_marking (Node Tip p (Node dag1 (high p) dag2)) mark (markb(p := m)) m", "apply (clarsimp simp add: wf_levellist_def wf_marking_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Levellist (levellistb[var p := p])\n              (nextb(p := levellistb ! var p))\n              (llb[var p := p # lla ! var p]);\n     lt = Tip; rt = Node dag1 (high p) dag2; var p < length lla;\n     low p = Null; p \\<noteq> Null; ll = lla; marka = mark;\n     \\<forall>q.\n        (q = high p \\<longrightarrow>\n         high p \\<in> set (llb ! var (high p))) \\<and>\n        (q \\<in> set_of dag1 \\<longrightarrow>\n         q \\<in> set (llb ! var q)) \\<and>\n        (q \\<in> set_of dag2 \\<longrightarrow> q \\<in> set (llb ! var q));\n     \\<forall>n.\n        n \\<noteq> high p \\<and>\n        n \\<notin> set_of dag1 \\<and>\n        n \\<notin> set_of dag2 \\<longrightarrow>\n        markb n = mark n;\n     \\<forall>n.\n        (n = high p \\<longrightarrow> markb (high p) = m) \\<and>\n        (n \\<in> set_of dag1 \\<longrightarrow> markb n = m) \\<and>\n        (n \\<in> set_of dag2 \\<longrightarrow> markb n = m);\n     var (high p) < var p; ordered (Node dag1 (high p) dag2) var;\n     a = high p;\n     \\<forall>i\\<le>var (high p).\n        \\<exists>prx.\n           llb ! i = prx @ lla ! i \\<and>\n           (\\<forall>pt\\<in>set prx.\n               (pt = high p \\<or>\n                pt \\<in> set_of dag1 \\<or> pt \\<in> set_of dag2) \\<and>\n               var pt = i);\n     high p \\<noteq> Null; \\<forall>i>var (high p). llb ! i = lla ! i;\n     length llb = length lla; Dag (low (high p)) low high dag1;\n     Dag (high (high p)) low high dag2\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>q.\n                          (q \\<in> set_of dag1 \\<longrightarrow>\n                           q \\<in> set (llb[var p := p # lla ! var p] !\n  var q)) \\<and>\n                          (q \\<in> set_of dag2 \\<longrightarrow>\n                           q \\<in> set (llb[var p := p # lla ! var p] !\n  var q))) \\<and>\n                      (\\<forall>i\\<le>var p.\n                          \\<exists>prx.\n                             llb[var p := p # lla ! var p] ! i =\n                             prx @ lla ! i \\<and>\n                             (\\<forall>pt\\<in>set prx.\n                                 (pt = high p \\<or>\n                                  pt = p \\<or>\n                                  pt \\<in> set_of dag1 \\<or>\n                                  pt \\<in> set_of dag2) \\<and>\n                                 var pt = i))", "apply (intro conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Levellist (levellistb[var p := p])\n              (nextb(p := levellistb ! var p))\n              (llb[var p := p # lla ! var p]);\n     lt = Tip; rt = Node dag1 (high p) dag2; var p < length lla;\n     low p = Null; p \\<noteq> Null; ll = lla; marka = mark;\n     \\<forall>q.\n        (q = high p \\<longrightarrow>\n         high p \\<in> set (llb ! var (high p))) \\<and>\n        (q \\<in> set_of dag1 \\<longrightarrow>\n         q \\<in> set (llb ! var q)) \\<and>\n        (q \\<in> set_of dag2 \\<longrightarrow> q \\<in> set (llb ! var q));\n     \\<forall>n.\n        n \\<noteq> high p \\<and>\n        n \\<notin> set_of dag1 \\<and>\n        n \\<notin> set_of dag2 \\<longrightarrow>\n        markb n = mark n;\n     \\<forall>n.\n        (n = high p \\<longrightarrow> markb (high p) = m) \\<and>\n        (n \\<in> set_of dag1 \\<longrightarrow> markb n = m) \\<and>\n        (n \\<in> set_of dag2 \\<longrightarrow> markb n = m);\n     var (high p) < var p; ordered (Node dag1 (high p) dag2) var;\n     a = high p;\n     \\<forall>i\\<le>var (high p).\n        \\<exists>prx.\n           llb ! i = prx @ lla ! i \\<and>\n           (\\<forall>pt\\<in>set prx.\n               (pt = high p \\<or>\n                pt \\<in> set_of dag1 \\<or> pt \\<in> set_of dag2) \\<and>\n               var pt = i);\n     high p \\<noteq> Null; \\<forall>i>var (high p). llb ! i = lla ! i;\n     length llb = length lla; Dag (low (high p)) low high dag1;\n     Dag (high (high p)) low high dag2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>q.\n                         (q \\<in> set_of dag1 \\<longrightarrow>\n                          q \\<in> set (llb[var p := p # lla ! var p] !\n var q)) \\<and>\n                         (q \\<in> set_of dag2 \\<longrightarrow>\n                          q \\<in> set (llb[var p := p # lla ! var p] !\n var q))\n 2. \\<lbrakk>Levellist (levellistb[var p := p])\n              (nextb(p := levellistb ! var p))\n              (llb[var p := p # lla ! var p]);\n     lt = Tip; rt = Node dag1 (high p) dag2; var p < length lla;\n     low p = Null; p \\<noteq> Null; ll = lla; marka = mark;\n     \\<forall>q.\n        (q = high p \\<longrightarrow>\n         high p \\<in> set (llb ! var (high p))) \\<and>\n        (q \\<in> set_of dag1 \\<longrightarrow>\n         q \\<in> set (llb ! var q)) \\<and>\n        (q \\<in> set_of dag2 \\<longrightarrow> q \\<in> set (llb ! var q));\n     \\<forall>n.\n        n \\<noteq> high p \\<and>\n        n \\<notin> set_of dag1 \\<and>\n        n \\<notin> set_of dag2 \\<longrightarrow>\n        markb n = mark n;\n     \\<forall>n.\n        (n = high p \\<longrightarrow> markb (high p) = m) \\<and>\n        (n \\<in> set_of dag1 \\<longrightarrow> markb n = m) \\<and>\n        (n \\<in> set_of dag2 \\<longrightarrow> markb n = m);\n     var (high p) < var p; ordered (Node dag1 (high p) dag2) var;\n     a = high p;\n     \\<forall>i\\<le>var (high p).\n        \\<exists>prx.\n           llb ! i = prx @ lla ! i \\<and>\n           (\\<forall>pt\\<in>set prx.\n               (pt = high p \\<or>\n                pt \\<in> set_of dag1 \\<or> pt \\<in> set_of dag2) \\<and>\n               var pt = i);\n     high p \\<noteq> Null; \\<forall>i>var (high p). llb ! i = lla ! i;\n     length llb = length lla; Dag (low (high p)) low high dag1;\n     Dag (high (high p)) low high dag2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i\\<le>var p.\n                         \\<exists>prx.\n                            llb[var p := p # lla ! var p] ! i =\n                            prx @ lla ! i \\<and>\n                            (\\<forall>pt\\<in>set prx.\n                                (pt = high p \\<or>\n                                 pt = p \\<or>\n                                 pt \\<in> set_of dag1 \\<or>\n                                 pt \\<in> set_of dag2) \\<and>\n                                var pt = i)", "apply  (rule allI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>Levellist (levellistb[var p := p])\n                 (nextb(p := levellistb ! var p))\n                 (llb[var p := p # lla ! var p]);\n        lt = Tip; rt = Node dag1 (high p) dag2; var p < length lla;\n        low p = Null; p \\<noteq> Null; ll = lla; marka = mark;\n        \\<forall>q.\n           (q = high p \\<longrightarrow>\n            high p \\<in> set (llb ! var (high p))) \\<and>\n           (q \\<in> set_of dag1 \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of dag2 \\<longrightarrow>\n            q \\<in> set (llb ! var q));\n        \\<forall>n.\n           n \\<noteq> high p \\<and>\n           n \\<notin> set_of dag1 \\<and>\n           n \\<notin> set_of dag2 \\<longrightarrow>\n           markb n = mark n;\n        \\<forall>n.\n           (n = high p \\<longrightarrow> markb (high p) = m) \\<and>\n           (n \\<in> set_of dag1 \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of dag2 \\<longrightarrow> markb n = m);\n        var (high p) < var p; ordered (Node dag1 (high p) dag2) var;\n        a = high p;\n        \\<forall>i\\<le>var (high p).\n           \\<exists>prx.\n              llb ! i = prx @ lla ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = high p \\<or>\n                   pt \\<in> set_of dag1 \\<or> pt \\<in> set_of dag2) \\<and>\n                  var pt = i);\n        high p \\<noteq> Null; \\<forall>i>var (high p). llb ! i = lla ! i;\n        length llb = length lla; Dag (low (high p)) low high dag1;\n        Dag (high (high p)) low high dag2\\<rbrakk>\n       \\<Longrightarrow> (q \\<in> set_of dag1 \\<longrightarrow>\n                          q \\<in> set (llb[var p := p # lla ! var p] !\n var q)) \\<and>\n                         (q \\<in> set_of dag2 \\<longrightarrow>\n                          q \\<in> set (llb[var p := p # lla ! var p] !\n var q))\n 2. \\<lbrakk>Levellist (levellistb[var p := p])\n              (nextb(p := levellistb ! var p))\n              (llb[var p := p # lla ! var p]);\n     lt = Tip; rt = Node dag1 (high p) dag2; var p < length lla;\n     low p = Null; p \\<noteq> Null; ll = lla; marka = mark;\n     \\<forall>q.\n        (q = high p \\<longrightarrow>\n         high p \\<in> set (llb ! var (high p))) \\<and>\n        (q \\<in> set_of dag1 \\<longrightarrow>\n         q \\<in> set (llb ! var q)) \\<and>\n        (q \\<in> set_of dag2 \\<longrightarrow> q \\<in> set (llb ! var q));\n     \\<forall>n.\n        n \\<noteq> high p \\<and>\n        n \\<notin> set_of dag1 \\<and>\n        n \\<notin> set_of dag2 \\<longrightarrow>\n        markb n = mark n;\n     \\<forall>n.\n        (n = high p \\<longrightarrow> markb (high p) = m) \\<and>\n        (n \\<in> set_of dag1 \\<longrightarrow> markb n = m) \\<and>\n        (n \\<in> set_of dag2 \\<longrightarrow> markb n = m);\n     var (high p) < var p; ordered (Node dag1 (high p) dag2) var;\n     a = high p;\n     \\<forall>i\\<le>var (high p).\n        \\<exists>prx.\n           llb ! i = prx @ lla ! i \\<and>\n           (\\<forall>pt\\<in>set prx.\n               (pt = high p \\<or>\n                pt \\<in> set_of dag1 \\<or> pt \\<in> set_of dag2) \\<and>\n               var pt = i);\n     high p \\<noteq> Null; \\<forall>i>var (high p). llb ! i = lla ! i;\n     length llb = length lla; Dag (low (high p)) low high dag1;\n     Dag (high (high p)) low high dag2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i\\<le>var p.\n                         \\<exists>prx.\n                            llb[var p := p # lla ! var p] ! i =\n                            prx @ lla ! i \\<and>\n                            (\\<forall>pt\\<in>set prx.\n                                (pt = high p \\<or>\n                                 pt = p \\<or>\n                                 pt \\<in> set_of dag1 \\<or>\n                                 pt \\<in> set_of dag2) \\<and>\n                                var pt = i)", "apply  (rule conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>Levellist (levellistb[var p := p])\n                 (nextb(p := levellistb ! var p))\n                 (llb[var p := p # lla ! var p]);\n        lt = Tip; rt = Node dag1 (high p) dag2; var p < length lla;\n        low p = Null; p \\<noteq> Null; ll = lla; marka = mark;\n        \\<forall>q.\n           (q = high p \\<longrightarrow>\n            high p \\<in> set (llb ! var (high p))) \\<and>\n           (q \\<in> set_of dag1 \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of dag2 \\<longrightarrow>\n            q \\<in> set (llb ! var q));\n        \\<forall>n.\n           n \\<noteq> high p \\<and>\n           n \\<notin> set_of dag1 \\<and>\n           n \\<notin> set_of dag2 \\<longrightarrow>\n           markb n = mark n;\n        \\<forall>n.\n           (n = high p \\<longrightarrow> markb (high p) = m) \\<and>\n           (n \\<in> set_of dag1 \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of dag2 \\<longrightarrow> markb n = m);\n        var (high p) < var p; ordered (Node dag1 (high p) dag2) var;\n        a = high p;\n        \\<forall>i\\<le>var (high p).\n           \\<exists>prx.\n              llb ! i = prx @ lla ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = high p \\<or>\n                   pt \\<in> set_of dag1 \\<or> pt \\<in> set_of dag2) \\<and>\n                  var pt = i);\n        high p \\<noteq> Null; \\<forall>i>var (high p). llb ! i = lla ! i;\n        length llb = length lla; Dag (low (high p)) low high dag1;\n        Dag (high (high p)) low high dag2\\<rbrakk>\n       \\<Longrightarrow> q \\<in> set_of dag1 \\<longrightarrow>\n                         q \\<in> set (llb[var p := p # lla ! var p] ! var q)\n 2. \\<And>q.\n       \\<lbrakk>Levellist (levellistb[var p := p])\n                 (nextb(p := levellistb ! var p))\n                 (llb[var p := p # lla ! var p]);\n        lt = Tip; rt = Node dag1 (high p) dag2; var p < length lla;\n        low p = Null; p \\<noteq> Null; ll = lla; marka = mark;\n        \\<forall>q.\n           (q = high p \\<longrightarrow>\n            high p \\<in> set (llb ! var (high p))) \\<and>\n           (q \\<in> set_of dag1 \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of dag2 \\<longrightarrow>\n            q \\<in> set (llb ! var q));\n        \\<forall>n.\n           n \\<noteq> high p \\<and>\n           n \\<notin> set_of dag1 \\<and>\n           n \\<notin> set_of dag2 \\<longrightarrow>\n           markb n = mark n;\n        \\<forall>n.\n           (n = high p \\<longrightarrow> markb (high p) = m) \\<and>\n           (n \\<in> set_of dag1 \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of dag2 \\<longrightarrow> markb n = m);\n        var (high p) < var p; ordered (Node dag1 (high p) dag2) var;\n        a = high p;\n        \\<forall>i\\<le>var (high p).\n           \\<exists>prx.\n              llb ! i = prx @ lla ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = high p \\<or>\n                   pt \\<in> set_of dag1 \\<or> pt \\<in> set_of dag2) \\<and>\n                  var pt = i);\n        high p \\<noteq> Null; \\<forall>i>var (high p). llb ! i = lla ! i;\n        length llb = length lla; Dag (low (high p)) low high dag1;\n        Dag (high (high p)) low high dag2\\<rbrakk>\n       \\<Longrightarrow> q \\<in> set_of dag2 \\<longrightarrow>\n                         q \\<in> set (llb[var p := p # lla ! var p] ! var q)\n 3. \\<lbrakk>Levellist (levellistb[var p := p])\n              (nextb(p := levellistb ! var p))\n              (llb[var p := p # lla ! var p]);\n     lt = Tip; rt = Node dag1 (high p) dag2; var p < length lla;\n     low p = Null; p \\<noteq> Null; ll = lla; marka = mark;\n     \\<forall>q.\n        (q = high p \\<longrightarrow>\n         high p \\<in> set (llb ! var (high p))) \\<and>\n        (q \\<in> set_of dag1 \\<longrightarrow>\n         q \\<in> set (llb ! var q)) \\<and>\n        (q \\<in> set_of dag2 \\<longrightarrow> q \\<in> set (llb ! var q));\n     \\<forall>n.\n        n \\<noteq> high p \\<and>\n        n \\<notin> set_of dag1 \\<and>\n        n \\<notin> set_of dag2 \\<longrightarrow>\n        markb n = mark n;\n     \\<forall>n.\n        (n = high p \\<longrightarrow> markb (high p) = m) \\<and>\n        (n \\<in> set_of dag1 \\<longrightarrow> markb n = m) \\<and>\n        (n \\<in> set_of dag2 \\<longrightarrow> markb n = m);\n     var (high p) < var p; ordered (Node dag1 (high p) dag2) var;\n     a = high p;\n     \\<forall>i\\<le>var (high p).\n        \\<exists>prx.\n           llb ! i = prx @ lla ! i \\<and>\n           (\\<forall>pt\\<in>set prx.\n               (pt = high p \\<or>\n                pt \\<in> set_of dag1 \\<or> pt \\<in> set_of dag2) \\<and>\n               var pt = i);\n     high p \\<noteq> Null; \\<forall>i>var (high p). llb ! i = lla ! i;\n     length llb = length lla; Dag (low (high p)) low high dag1;\n     Dag (high (high p)) low high dag2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i\\<le>var p.\n                         \\<exists>prx.\n                            llb[var p := p # lla ! var p] ! i =\n                            prx @ lla ! i \\<and>\n                            (\\<forall>pt\\<in>set prx.\n                                (pt = high p \\<or>\n                                 pt = p \\<or>\n                                 pt \\<in> set_of dag1 \\<or>\n                                 pt \\<in> set_of dag2) \\<and>\n                                var pt = i)", "apply   (erule_tac x=\"q\" in allE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>Levellist (levellistb[var p := p])\n                 (nextb(p := levellistb ! var p))\n                 (llb[var p := p # lla ! var p]);\n        lt = Tip; rt = Node dag1 (high p) dag2; var p < length lla;\n        low p = Null; p \\<noteq> Null; ll = lla; marka = mark;\n        \\<forall>n.\n           n \\<noteq> high p \\<and>\n           n \\<notin> set_of dag1 \\<and>\n           n \\<notin> set_of dag2 \\<longrightarrow>\n           markb n = mark n;\n        \\<forall>n.\n           (n = high p \\<longrightarrow> markb (high p) = m) \\<and>\n           (n \\<in> set_of dag1 \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of dag2 \\<longrightarrow> markb n = m);\n        var (high p) < var p; ordered (Node dag1 (high p) dag2) var;\n        a = high p;\n        \\<forall>i\\<le>var (high p).\n           \\<exists>prx.\n              llb ! i = prx @ lla ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = high p \\<or>\n                   pt \\<in> set_of dag1 \\<or> pt \\<in> set_of dag2) \\<and>\n                  var pt = i);\n        high p \\<noteq> Null; \\<forall>i>var (high p). llb ! i = lla ! i;\n        length llb = length lla; Dag (low (high p)) low high dag1;\n        Dag (high (high p)) low high dag2;\n        (q = high p \\<longrightarrow>\n         high p \\<in> set (llb ! var (high p))) \\<and>\n        (q \\<in> set_of dag1 \\<longrightarrow>\n         q \\<in> set (llb ! var q)) \\<and>\n        (q \\<in> set_of dag2 \\<longrightarrow>\n         q \\<in> set (llb ! var q))\\<rbrakk>\n       \\<Longrightarrow> q \\<in> set_of dag1 \\<longrightarrow>\n                         q \\<in> set (llb[var p := p # lla ! var p] ! var q)\n 2. \\<And>q.\n       \\<lbrakk>Levellist (levellistb[var p := p])\n                 (nextb(p := levellistb ! var p))\n                 (llb[var p := p # lla ! var p]);\n        lt = Tip; rt = Node dag1 (high p) dag2; var p < length lla;\n        low p = Null; p \\<noteq> Null; ll = lla; marka = mark;\n        \\<forall>q.\n           (q = high p \\<longrightarrow>\n            high p \\<in> set (llb ! var (high p))) \\<and>\n           (q \\<in> set_of dag1 \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of dag2 \\<longrightarrow>\n            q \\<in> set (llb ! var q));\n        \\<forall>n.\n           n \\<noteq> high p \\<and>\n           n \\<notin> set_of dag1 \\<and>\n           n \\<notin> set_of dag2 \\<longrightarrow>\n           markb n = mark n;\n        \\<forall>n.\n           (n = high p \\<longrightarrow> markb (high p) = m) \\<and>\n           (n \\<in> set_of dag1 \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of dag2 \\<longrightarrow> markb n = m);\n        var (high p) < var p; ordered (Node dag1 (high p) dag2) var;\n        a = high p;\n        \\<forall>i\\<le>var (high p).\n           \\<exists>prx.\n              llb ! i = prx @ lla ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = high p \\<or>\n                   pt \\<in> set_of dag1 \\<or> pt \\<in> set_of dag2) \\<and>\n                  var pt = i);\n        high p \\<noteq> Null; \\<forall>i>var (high p). llb ! i = lla ! i;\n        length llb = length lla; Dag (low (high p)) low high dag1;\n        Dag (high (high p)) low high dag2\\<rbrakk>\n       \\<Longrightarrow> q \\<in> set_of dag2 \\<longrightarrow>\n                         q \\<in> set (llb[var p := p # lla ! var p] ! var q)\n 3. \\<lbrakk>Levellist (levellistb[var p := p])\n              (nextb(p := levellistb ! var p))\n              (llb[var p := p # lla ! var p]);\n     lt = Tip; rt = Node dag1 (high p) dag2; var p < length lla;\n     low p = Null; p \\<noteq> Null; ll = lla; marka = mark;\n     \\<forall>q.\n        (q = high p \\<longrightarrow>\n         high p \\<in> set (llb ! var (high p))) \\<and>\n        (q \\<in> set_of dag1 \\<longrightarrow>\n         q \\<in> set (llb ! var q)) \\<and>\n        (q \\<in> set_of dag2 \\<longrightarrow> q \\<in> set (llb ! var q));\n     \\<forall>n.\n        n \\<noteq> high p \\<and>\n        n \\<notin> set_of dag1 \\<and>\n        n \\<notin> set_of dag2 \\<longrightarrow>\n        markb n = mark n;\n     \\<forall>n.\n        (n = high p \\<longrightarrow> markb (high p) = m) \\<and>\n        (n \\<in> set_of dag1 \\<longrightarrow> markb n = m) \\<and>\n        (n \\<in> set_of dag2 \\<longrightarrow> markb n = m);\n     var (high p) < var p; ordered (Node dag1 (high p) dag2) var;\n     a = high p;\n     \\<forall>i\\<le>var (high p).\n        \\<exists>prx.\n           llb ! i = prx @ lla ! i \\<and>\n           (\\<forall>pt\\<in>set prx.\n               (pt = high p \\<or>\n                pt \\<in> set_of dag1 \\<or> pt \\<in> set_of dag2) \\<and>\n               var pt = i);\n     high p \\<noteq> Null; \\<forall>i>var (high p). llb ! i = lla ! i;\n     length llb = length lla; Dag (low (high p)) low high dag1;\n     Dag (high (high p)) low high dag2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i\\<le>var p.\n                         \\<exists>prx.\n                            llb[var p := p # lla ! var p] ! i =\n                            prx @ lla ! i \\<and>\n                            (\\<forall>pt\\<in>set prx.\n                                (pt = high p \\<or>\n                                 pt = p \\<or>\n                                 pt \\<in> set_of dag1 \\<or>\n                                 pt \\<in> set_of dag2) \\<and>\n                                var pt = i)", "apply   (case_tac \"var p = var q\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>Levellist (levellistb[var p := p])\n                 (nextb(p := levellistb ! var p))\n                 (llb[var p := p # lla ! var p]);\n        lt = Tip; rt = Node dag1 (high p) dag2; var p < length lla;\n        low p = Null; p \\<noteq> Null; ll = lla; marka = mark;\n        \\<forall>n.\n           n \\<noteq> high p \\<and>\n           n \\<notin> set_of dag1 \\<and>\n           n \\<notin> set_of dag2 \\<longrightarrow>\n           markb n = mark n;\n        \\<forall>n.\n           (n = high p \\<longrightarrow> markb (high p) = m) \\<and>\n           (n \\<in> set_of dag1 \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of dag2 \\<longrightarrow> markb n = m);\n        var (high p) < var p; ordered (Node dag1 (high p) dag2) var;\n        a = high p;\n        \\<forall>i\\<le>var (high p).\n           \\<exists>prx.\n              llb ! i = prx @ lla ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = high p \\<or>\n                   pt \\<in> set_of dag1 \\<or> pt \\<in> set_of dag2) \\<and>\n                  var pt = i);\n        high p \\<noteq> Null; \\<forall>i>var (high p). llb ! i = lla ! i;\n        length llb = length lla; Dag (low (high p)) low high dag1;\n        Dag (high (high p)) low high dag2;\n        (q = high p \\<longrightarrow>\n         high p \\<in> set (llb ! var (high p))) \\<and>\n        (q \\<in> set_of dag1 \\<longrightarrow>\n         q \\<in> set (llb ! var q)) \\<and>\n        (q \\<in> set_of dag2 \\<longrightarrow> q \\<in> set (llb ! var q));\n        var p = var q\\<rbrakk>\n       \\<Longrightarrow> q \\<in> set_of dag1 \\<longrightarrow>\n                         q \\<in> set (llb[var p := p # lla ! var p] ! var q)\n 2. \\<And>q.\n       \\<lbrakk>Levellist (levellistb[var p := p])\n                 (nextb(p := levellistb ! var p))\n                 (llb[var p := p # lla ! var p]);\n        lt = Tip; rt = Node dag1 (high p) dag2; var p < length lla;\n        low p = Null; p \\<noteq> Null; ll = lla; marka = mark;\n        \\<forall>n.\n           n \\<noteq> high p \\<and>\n           n \\<notin> set_of dag1 \\<and>\n           n \\<notin> set_of dag2 \\<longrightarrow>\n           markb n = mark n;\n        \\<forall>n.\n           (n = high p \\<longrightarrow> markb (high p) = m) \\<and>\n           (n \\<in> set_of dag1 \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of dag2 \\<longrightarrow> markb n = m);\n        var (high p) < var p; ordered (Node dag1 (high p) dag2) var;\n        a = high p;\n        \\<forall>i\\<le>var (high p).\n           \\<exists>prx.\n              llb ! i = prx @ lla ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = high p \\<or>\n                   pt \\<in> set_of dag1 \\<or> pt \\<in> set_of dag2) \\<and>\n                  var pt = i);\n        high p \\<noteq> Null; \\<forall>i>var (high p). llb ! i = lla ! i;\n        length llb = length lla; Dag (low (high p)) low high dag1;\n        Dag (high (high p)) low high dag2;\n        (q = high p \\<longrightarrow>\n         high p \\<in> set (llb ! var (high p))) \\<and>\n        (q \\<in> set_of dag1 \\<longrightarrow>\n         q \\<in> set (llb ! var q)) \\<and>\n        (q \\<in> set_of dag2 \\<longrightarrow> q \\<in> set (llb ! var q));\n        var p \\<noteq> var q\\<rbrakk>\n       \\<Longrightarrow> q \\<in> set_of dag1 \\<longrightarrow>\n                         q \\<in> set (llb[var p := p # lla ! var p] ! var q)\n 3. \\<And>q.\n       \\<lbrakk>Levellist (levellistb[var p := p])\n                 (nextb(p := levellistb ! var p))\n                 (llb[var p := p # lla ! var p]);\n        lt = Tip; rt = Node dag1 (high p) dag2; var p < length lla;\n        low p = Null; p \\<noteq> Null; ll = lla; marka = mark;\n        \\<forall>q.\n           (q = high p \\<longrightarrow>\n            high p \\<in> set (llb ! var (high p))) \\<and>\n           (q \\<in> set_of dag1 \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of dag2 \\<longrightarrow>\n            q \\<in> set (llb ! var q));\n        \\<forall>n.\n           n \\<noteq> high p \\<and>\n           n \\<notin> set_of dag1 \\<and>\n           n \\<notin> set_of dag2 \\<longrightarrow>\n           markb n = mark n;\n        \\<forall>n.\n           (n = high p \\<longrightarrow> markb (high p) = m) \\<and>\n           (n \\<in> set_of dag1 \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of dag2 \\<longrightarrow> markb n = m);\n        var (high p) < var p; ordered (Node dag1 (high p) dag2) var;\n        a = high p;\n        \\<forall>i\\<le>var (high p).\n           \\<exists>prx.\n              llb ! i = prx @ lla ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = high p \\<or>\n                   pt \\<in> set_of dag1 \\<or> pt \\<in> set_of dag2) \\<and>\n                  var pt = i);\n        high p \\<noteq> Null; \\<forall>i>var (high p). llb ! i = lla ! i;\n        length llb = length lla; Dag (low (high p)) low high dag1;\n        Dag (high (high p)) low high dag2\\<rbrakk>\n       \\<Longrightarrow> q \\<in> set_of dag2 \\<longrightarrow>\n                         q \\<in> set (llb[var p := p # lla ! var p] ! var q)\n 4. \\<lbrakk>Levellist (levellistb[var p := p])\n              (nextb(p := levellistb ! var p))\n              (llb[var p := p # lla ! var p]);\n     lt = Tip; rt = Node dag1 (high p) dag2; var p < length lla;\n     low p = Null; p \\<noteq> Null; ll = lla; marka = mark;\n     \\<forall>q.\n        (q = high p \\<longrightarrow>\n         high p \\<in> set (llb ! var (high p))) \\<and>\n        (q \\<in> set_of dag1 \\<longrightarrow>\n         q \\<in> set (llb ! var q)) \\<and>\n        (q \\<in> set_of dag2 \\<longrightarrow> q \\<in> set (llb ! var q));\n     \\<forall>n.\n        n \\<noteq> high p \\<and>\n        n \\<notin> set_of dag1 \\<and>\n        n \\<notin> set_of dag2 \\<longrightarrow>\n        markb n = mark n;\n     \\<forall>n.\n        (n = high p \\<longrightarrow> markb (high p) = m) \\<and>\n        (n \\<in> set_of dag1 \\<longrightarrow> markb n = m) \\<and>\n        (n \\<in> set_of dag2 \\<longrightarrow> markb n = m);\n     var (high p) < var p; ordered (Node dag1 (high p) dag2) var;\n     a = high p;\n     \\<forall>i\\<le>var (high p).\n        \\<exists>prx.\n           llb ! i = prx @ lla ! i \\<and>\n           (\\<forall>pt\\<in>set prx.\n               (pt = high p \\<or>\n                pt \\<in> set_of dag1 \\<or> pt \\<in> set_of dag2) \\<and>\n               var pt = i);\n     high p \\<noteq> Null; \\<forall>i>var (high p). llb ! i = lla ! i;\n     length llb = length lla; Dag (low (high p)) low high dag1;\n     Dag (high (high p)) low high dag2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i\\<le>var p.\n                         \\<exists>prx.\n                            llb[var p := p # lla ! var p] ! i =\n                            prx @ lla ! i \\<and>\n                            (\\<forall>pt\\<in>set prx.\n                                (pt = high p \\<or>\n                                 pt = p \\<or>\n                                 pt \\<in> set_of dag1 \\<or>\n                                 pt \\<in> set_of dag2) \\<and>\n                                var pt = i)", "apply    fastforce"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>Levellist (levellistb[var p := p])\n                 (nextb(p := levellistb ! var p))\n                 (llb[var p := p # lla ! var p]);\n        lt = Tip; rt = Node dag1 (high p) dag2; var p < length lla;\n        low p = Null; p \\<noteq> Null; ll = lla; marka = mark;\n        \\<forall>n.\n           n \\<noteq> high p \\<and>\n           n \\<notin> set_of dag1 \\<and>\n           n \\<notin> set_of dag2 \\<longrightarrow>\n           markb n = mark n;\n        \\<forall>n.\n           (n = high p \\<longrightarrow> markb (high p) = m) \\<and>\n           (n \\<in> set_of dag1 \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of dag2 \\<longrightarrow> markb n = m);\n        var (high p) < var p; ordered (Node dag1 (high p) dag2) var;\n        a = high p;\n        \\<forall>i\\<le>var (high p).\n           \\<exists>prx.\n              llb ! i = prx @ lla ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = high p \\<or>\n                   pt \\<in> set_of dag1 \\<or> pt \\<in> set_of dag2) \\<and>\n                  var pt = i);\n        high p \\<noteq> Null; \\<forall>i>var (high p). llb ! i = lla ! i;\n        length llb = length lla; Dag (low (high p)) low high dag1;\n        Dag (high (high p)) low high dag2;\n        (q = high p \\<longrightarrow>\n         high p \\<in> set (llb ! var (high p))) \\<and>\n        (q \\<in> set_of dag1 \\<longrightarrow>\n         q \\<in> set (llb ! var q)) \\<and>\n        (q \\<in> set_of dag2 \\<longrightarrow> q \\<in> set (llb ! var q));\n        var p \\<noteq> var q\\<rbrakk>\n       \\<Longrightarrow> q \\<in> set_of dag1 \\<longrightarrow>\n                         q \\<in> set (llb[var p := p # lla ! var p] ! var q)\n 2. \\<And>q.\n       \\<lbrakk>Levellist (levellistb[var p := p])\n                 (nextb(p := levellistb ! var p))\n                 (llb[var p := p # lla ! var p]);\n        lt = Tip; rt = Node dag1 (high p) dag2; var p < length lla;\n        low p = Null; p \\<noteq> Null; ll = lla; marka = mark;\n        \\<forall>q.\n           (q = high p \\<longrightarrow>\n            high p \\<in> set (llb ! var (high p))) \\<and>\n           (q \\<in> set_of dag1 \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of dag2 \\<longrightarrow>\n            q \\<in> set (llb ! var q));\n        \\<forall>n.\n           n \\<noteq> high p \\<and>\n           n \\<notin> set_of dag1 \\<and>\n           n \\<notin> set_of dag2 \\<longrightarrow>\n           markb n = mark n;\n        \\<forall>n.\n           (n = high p \\<longrightarrow> markb (high p) = m) \\<and>\n           (n \\<in> set_of dag1 \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of dag2 \\<longrightarrow> markb n = m);\n        var (high p) < var p; ordered (Node dag1 (high p) dag2) var;\n        a = high p;\n        \\<forall>i\\<le>var (high p).\n           \\<exists>prx.\n              llb ! i = prx @ lla ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = high p \\<or>\n                   pt \\<in> set_of dag1 \\<or> pt \\<in> set_of dag2) \\<and>\n                  var pt = i);\n        high p \\<noteq> Null; \\<forall>i>var (high p). llb ! i = lla ! i;\n        length llb = length lla; Dag (low (high p)) low high dag1;\n        Dag (high (high p)) low high dag2\\<rbrakk>\n       \\<Longrightarrow> q \\<in> set_of dag2 \\<longrightarrow>\n                         q \\<in> set (llb[var p := p # lla ! var p] ! var q)\n 3. \\<lbrakk>Levellist (levellistb[var p := p])\n              (nextb(p := levellistb ! var p))\n              (llb[var p := p # lla ! var p]);\n     lt = Tip; rt = Node dag1 (high p) dag2; var p < length lla;\n     low p = Null; p \\<noteq> Null; ll = lla; marka = mark;\n     \\<forall>q.\n        (q = high p \\<longrightarrow>\n         high p \\<in> set (llb ! var (high p))) \\<and>\n        (q \\<in> set_of dag1 \\<longrightarrow>\n         q \\<in> set (llb ! var q)) \\<and>\n        (q \\<in> set_of dag2 \\<longrightarrow> q \\<in> set (llb ! var q));\n     \\<forall>n.\n        n \\<noteq> high p \\<and>\n        n \\<notin> set_of dag1 \\<and>\n        n \\<notin> set_of dag2 \\<longrightarrow>\n        markb n = mark n;\n     \\<forall>n.\n        (n = high p \\<longrightarrow> markb (high p) = m) \\<and>\n        (n \\<in> set_of dag1 \\<longrightarrow> markb n = m) \\<and>\n        (n \\<in> set_of dag2 \\<longrightarrow> markb n = m);\n     var (high p) < var p; ordered (Node dag1 (high p) dag2) var;\n     a = high p;\n     \\<forall>i\\<le>var (high p).\n        \\<exists>prx.\n           llb ! i = prx @ lla ! i \\<and>\n           (\\<forall>pt\\<in>set prx.\n               (pt = high p \\<or>\n                pt \\<in> set_of dag1 \\<or> pt \\<in> set_of dag2) \\<and>\n               var pt = i);\n     high p \\<noteq> Null; \\<forall>i>var (high p). llb ! i = lla ! i;\n     length llb = length lla; Dag (low (high p)) low high dag1;\n     Dag (high (high p)) low high dag2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i\\<le>var p.\n                         \\<exists>prx.\n                            llb[var p := p # lla ! var p] ! i =\n                            prx @ lla ! i \\<and>\n                            (\\<forall>pt\\<in>set prx.\n                                (pt = high p \\<or>\n                                 pt = p \\<or>\n                                 pt \\<in> set_of dag1 \\<or>\n                                 pt \\<in> set_of dag2) \\<and>\n                                var pt = i)", "apply   fastforce"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>Levellist (levellistb[var p := p])\n                 (nextb(p := levellistb ! var p))\n                 (llb[var p := p # lla ! var p]);\n        lt = Tip; rt = Node dag1 (high p) dag2; var p < length lla;\n        low p = Null; p \\<noteq> Null; ll = lla; marka = mark;\n        \\<forall>q.\n           (q = high p \\<longrightarrow>\n            high p \\<in> set (llb ! var (high p))) \\<and>\n           (q \\<in> set_of dag1 \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of dag2 \\<longrightarrow>\n            q \\<in> set (llb ! var q));\n        \\<forall>n.\n           n \\<noteq> high p \\<and>\n           n \\<notin> set_of dag1 \\<and>\n           n \\<notin> set_of dag2 \\<longrightarrow>\n           markb n = mark n;\n        \\<forall>n.\n           (n = high p \\<longrightarrow> markb (high p) = m) \\<and>\n           (n \\<in> set_of dag1 \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of dag2 \\<longrightarrow> markb n = m);\n        var (high p) < var p; ordered (Node dag1 (high p) dag2) var;\n        a = high p;\n        \\<forall>i\\<le>var (high p).\n           \\<exists>prx.\n              llb ! i = prx @ lla ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = high p \\<or>\n                   pt \\<in> set_of dag1 \\<or> pt \\<in> set_of dag2) \\<and>\n                  var pt = i);\n        high p \\<noteq> Null; \\<forall>i>var (high p). llb ! i = lla ! i;\n        length llb = length lla; Dag (low (high p)) low high dag1;\n        Dag (high (high p)) low high dag2\\<rbrakk>\n       \\<Longrightarrow> q \\<in> set_of dag2 \\<longrightarrow>\n                         q \\<in> set (llb[var p := p # lla ! var p] ! var q)\n 2. \\<lbrakk>Levellist (levellistb[var p := p])\n              (nextb(p := levellistb ! var p))\n              (llb[var p := p # lla ! var p]);\n     lt = Tip; rt = Node dag1 (high p) dag2; var p < length lla;\n     low p = Null; p \\<noteq> Null; ll = lla; marka = mark;\n     \\<forall>q.\n        (q = high p \\<longrightarrow>\n         high p \\<in> set (llb ! var (high p))) \\<and>\n        (q \\<in> set_of dag1 \\<longrightarrow>\n         q \\<in> set (llb ! var q)) \\<and>\n        (q \\<in> set_of dag2 \\<longrightarrow> q \\<in> set (llb ! var q));\n     \\<forall>n.\n        n \\<noteq> high p \\<and>\n        n \\<notin> set_of dag1 \\<and>\n        n \\<notin> set_of dag2 \\<longrightarrow>\n        markb n = mark n;\n     \\<forall>n.\n        (n = high p \\<longrightarrow> markb (high p) = m) \\<and>\n        (n \\<in> set_of dag1 \\<longrightarrow> markb n = m) \\<and>\n        (n \\<in> set_of dag2 \\<longrightarrow> markb n = m);\n     var (high p) < var p; ordered (Node dag1 (high p) dag2) var;\n     a = high p;\n     \\<forall>i\\<le>var (high p).\n        \\<exists>prx.\n           llb ! i = prx @ lla ! i \\<and>\n           (\\<forall>pt\\<in>set prx.\n               (pt = high p \\<or>\n                pt \\<in> set_of dag1 \\<or> pt \\<in> set_of dag2) \\<and>\n               var pt = i);\n     high p \\<noteq> Null; \\<forall>i>var (high p). llb ! i = lla ! i;\n     length llb = length lla; Dag (low (high p)) low high dag1;\n     Dag (high (high p)) low high dag2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i\\<le>var p.\n                         \\<exists>prx.\n                            llb[var p := p # lla ! var p] ! i =\n                            prx @ lla ! i \\<and>\n                            (\\<forall>pt\\<in>set prx.\n                                (pt = high p \\<or>\n                                 pt = p \\<or>\n                                 pt \\<in> set_of dag1 \\<or>\n                                 pt \\<in> set_of dag2) \\<and>\n                                var pt = i)", "apply  (case_tac \"var p = var q\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>Levellist (levellistb[var p := p])\n                 (nextb(p := levellistb ! var p))\n                 (llb[var p := p # lla ! var p]);\n        lt = Tip; rt = Node dag1 (high p) dag2; var p < length lla;\n        low p = Null; p \\<noteq> Null; ll = lla; marka = mark;\n        \\<forall>q.\n           (q = high p \\<longrightarrow>\n            high p \\<in> set (llb ! var (high p))) \\<and>\n           (q \\<in> set_of dag1 \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of dag2 \\<longrightarrow>\n            q \\<in> set (llb ! var q));\n        \\<forall>n.\n           n \\<noteq> high p \\<and>\n           n \\<notin> set_of dag1 \\<and>\n           n \\<notin> set_of dag2 \\<longrightarrow>\n           markb n = mark n;\n        \\<forall>n.\n           (n = high p \\<longrightarrow> markb (high p) = m) \\<and>\n           (n \\<in> set_of dag1 \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of dag2 \\<longrightarrow> markb n = m);\n        var (high p) < var p; ordered (Node dag1 (high p) dag2) var;\n        a = high p;\n        \\<forall>i\\<le>var (high p).\n           \\<exists>prx.\n              llb ! i = prx @ lla ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = high p \\<or>\n                   pt \\<in> set_of dag1 \\<or> pt \\<in> set_of dag2) \\<and>\n                  var pt = i);\n        high p \\<noteq> Null; \\<forall>i>var (high p). llb ! i = lla ! i;\n        length llb = length lla; Dag (low (high p)) low high dag1;\n        Dag (high (high p)) low high dag2; var p = var q\\<rbrakk>\n       \\<Longrightarrow> q \\<in> set_of dag2 \\<longrightarrow>\n                         q \\<in> set (llb[var p := p # lla ! var p] ! var q)\n 2. \\<And>q.\n       \\<lbrakk>Levellist (levellistb[var p := p])\n                 (nextb(p := levellistb ! var p))\n                 (llb[var p := p # lla ! var p]);\n        lt = Tip; rt = Node dag1 (high p) dag2; var p < length lla;\n        low p = Null; p \\<noteq> Null; ll = lla; marka = mark;\n        \\<forall>q.\n           (q = high p \\<longrightarrow>\n            high p \\<in> set (llb ! var (high p))) \\<and>\n           (q \\<in> set_of dag1 \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of dag2 \\<longrightarrow>\n            q \\<in> set (llb ! var q));\n        \\<forall>n.\n           n \\<noteq> high p \\<and>\n           n \\<notin> set_of dag1 \\<and>\n           n \\<notin> set_of dag2 \\<longrightarrow>\n           markb n = mark n;\n        \\<forall>n.\n           (n = high p \\<longrightarrow> markb (high p) = m) \\<and>\n           (n \\<in> set_of dag1 \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of dag2 \\<longrightarrow> markb n = m);\n        var (high p) < var p; ordered (Node dag1 (high p) dag2) var;\n        a = high p;\n        \\<forall>i\\<le>var (high p).\n           \\<exists>prx.\n              llb ! i = prx @ lla ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = high p \\<or>\n                   pt \\<in> set_of dag1 \\<or> pt \\<in> set_of dag2) \\<and>\n                  var pt = i);\n        high p \\<noteq> Null; \\<forall>i>var (high p). llb ! i = lla ! i;\n        length llb = length lla; Dag (low (high p)) low high dag1;\n        Dag (high (high p)) low high dag2; var p \\<noteq> var q\\<rbrakk>\n       \\<Longrightarrow> q \\<in> set_of dag2 \\<longrightarrow>\n                         q \\<in> set (llb[var p := p # lla ! var p] ! var q)\n 3. \\<lbrakk>Levellist (levellistb[var p := p])\n              (nextb(p := levellistb ! var p))\n              (llb[var p := p # lla ! var p]);\n     lt = Tip; rt = Node dag1 (high p) dag2; var p < length lla;\n     low p = Null; p \\<noteq> Null; ll = lla; marka = mark;\n     \\<forall>q.\n        (q = high p \\<longrightarrow>\n         high p \\<in> set (llb ! var (high p))) \\<and>\n        (q \\<in> set_of dag1 \\<longrightarrow>\n         q \\<in> set (llb ! var q)) \\<and>\n        (q \\<in> set_of dag2 \\<longrightarrow> q \\<in> set (llb ! var q));\n     \\<forall>n.\n        n \\<noteq> high p \\<and>\n        n \\<notin> set_of dag1 \\<and>\n        n \\<notin> set_of dag2 \\<longrightarrow>\n        markb n = mark n;\n     \\<forall>n.\n        (n = high p \\<longrightarrow> markb (high p) = m) \\<and>\n        (n \\<in> set_of dag1 \\<longrightarrow> markb n = m) \\<and>\n        (n \\<in> set_of dag2 \\<longrightarrow> markb n = m);\n     var (high p) < var p; ordered (Node dag1 (high p) dag2) var;\n     a = high p;\n     \\<forall>i\\<le>var (high p).\n        \\<exists>prx.\n           llb ! i = prx @ lla ! i \\<and>\n           (\\<forall>pt\\<in>set prx.\n               (pt = high p \\<or>\n                pt \\<in> set_of dag1 \\<or> pt \\<in> set_of dag2) \\<and>\n               var pt = i);\n     high p \\<noteq> Null; \\<forall>i>var (high p). llb ! i = lla ! i;\n     length llb = length lla; Dag (low (high p)) low high dag1;\n     Dag (high (high p)) low high dag2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i\\<le>var p.\n                         \\<exists>prx.\n                            llb[var p := p # lla ! var p] ! i =\n                            prx @ lla ! i \\<and>\n                            (\\<forall>pt\\<in>set prx.\n                                (pt = high p \\<or>\n                                 pt = p \\<or>\n                                 pt \\<in> set_of dag1 \\<or>\n                                 pt \\<in> set_of dag2) \\<and>\n                                var pt = i)", "apply   hypsubst_thin"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>Levellist (levellistb[var p := p])\n                 (nextb(p := levellistb ! var p))\n                 (llb[var p := p # lla ! var p]);\n        var p < length lla; low p = Null; p \\<noteq> Null;\n        \\<forall>q.\n           (q = high p \\<longrightarrow>\n            high p \\<in> set (llb ! var (high p))) \\<and>\n           (q \\<in> set_of dag1 \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of dag2 \\<longrightarrow>\n            q \\<in> set (llb ! var q));\n        \\<forall>n.\n           n \\<noteq> high p \\<and>\n           n \\<notin> set_of dag1 \\<and>\n           n \\<notin> set_of dag2 \\<longrightarrow>\n           markb n = mark n;\n        \\<forall>n.\n           (n = high p \\<longrightarrow> markb (high p) = m) \\<and>\n           (n \\<in> set_of dag1 \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of dag2 \\<longrightarrow> markb n = m);\n        var (high p) < var p; ordered (Node dag1 (high p) dag2) var;\n        \\<forall>i\\<le>var (high p).\n           \\<exists>prx.\n              llb ! i = prx @ lla ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = high p \\<or>\n                   pt \\<in> set_of dag1 \\<or> pt \\<in> set_of dag2) \\<and>\n                  var pt = i);\n        high p \\<noteq> Null; \\<forall>i>var (high p). llb ! i = lla ! i;\n        length llb = length lla; Dag (low (high p)) low high dag1;\n        Dag (high (high p)) low high dag2; var p = var q\\<rbrakk>\n       \\<Longrightarrow> q \\<in> set_of dag2 \\<longrightarrow>\n                         q \\<in> set (llb[var p := p # lla ! var p] ! var q)\n 2. \\<And>q.\n       \\<lbrakk>Levellist (levellistb[var p := p])\n                 (nextb(p := levellistb ! var p))\n                 (llb[var p := p # lla ! var p]);\n        lt = Tip; rt = Node dag1 (high p) dag2; var p < length lla;\n        low p = Null; p \\<noteq> Null; ll = lla; marka = mark;\n        \\<forall>q.\n           (q = high p \\<longrightarrow>\n            high p \\<in> set (llb ! var (high p))) \\<and>\n           (q \\<in> set_of dag1 \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of dag2 \\<longrightarrow>\n            q \\<in> set (llb ! var q));\n        \\<forall>n.\n           n \\<noteq> high p \\<and>\n           n \\<notin> set_of dag1 \\<and>\n           n \\<notin> set_of dag2 \\<longrightarrow>\n           markb n = mark n;\n        \\<forall>n.\n           (n = high p \\<longrightarrow> markb (high p) = m) \\<and>\n           (n \\<in> set_of dag1 \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of dag2 \\<longrightarrow> markb n = m);\n        var (high p) < var p; ordered (Node dag1 (high p) dag2) var;\n        a = high p;\n        \\<forall>i\\<le>var (high p).\n           \\<exists>prx.\n              llb ! i = prx @ lla ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = high p \\<or>\n                   pt \\<in> set_of dag1 \\<or> pt \\<in> set_of dag2) \\<and>\n                  var pt = i);\n        high p \\<noteq> Null; \\<forall>i>var (high p). llb ! i = lla ! i;\n        length llb = length lla; Dag (low (high p)) low high dag1;\n        Dag (high (high p)) low high dag2; var p \\<noteq> var q\\<rbrakk>\n       \\<Longrightarrow> q \\<in> set_of dag2 \\<longrightarrow>\n                         q \\<in> set (llb[var p := p # lla ! var p] ! var q)\n 3. \\<lbrakk>Levellist (levellistb[var p := p])\n              (nextb(p := levellistb ! var p))\n              (llb[var p := p # lla ! var p]);\n     lt = Tip; rt = Node dag1 (high p) dag2; var p < length lla;\n     low p = Null; p \\<noteq> Null; ll = lla; marka = mark;\n     \\<forall>q.\n        (q = high p \\<longrightarrow>\n         high p \\<in> set (llb ! var (high p))) \\<and>\n        (q \\<in> set_of dag1 \\<longrightarrow>\n         q \\<in> set (llb ! var q)) \\<and>\n        (q \\<in> set_of dag2 \\<longrightarrow> q \\<in> set (llb ! var q));\n     \\<forall>n.\n        n \\<noteq> high p \\<and>\n        n \\<notin> set_of dag1 \\<and>\n        n \\<notin> set_of dag2 \\<longrightarrow>\n        markb n = mark n;\n     \\<forall>n.\n        (n = high p \\<longrightarrow> markb (high p) = m) \\<and>\n        (n \\<in> set_of dag1 \\<longrightarrow> markb n = m) \\<and>\n        (n \\<in> set_of dag2 \\<longrightarrow> markb n = m);\n     var (high p) < var p; ordered (Node dag1 (high p) dag2) var;\n     a = high p;\n     \\<forall>i\\<le>var (high p).\n        \\<exists>prx.\n           llb ! i = prx @ lla ! i \\<and>\n           (\\<forall>pt\\<in>set prx.\n               (pt = high p \\<or>\n                pt \\<in> set_of dag1 \\<or> pt \\<in> set_of dag2) \\<and>\n               var pt = i);\n     high p \\<noteq> Null; \\<forall>i>var (high p). llb ! i = lla ! i;\n     length llb = length lla; Dag (low (high p)) low high dag1;\n     Dag (high (high p)) low high dag2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i\\<le>var p.\n                         \\<exists>prx.\n                            llb[var p := p # lla ! var p] ! i =\n                            prx @ lla ! i \\<and>\n                            (\\<forall>pt\\<in>set prx.\n                                (pt = high p \\<or>\n                                 pt = p \\<or>\n                                 pt \\<in> set_of dag1 \\<or>\n                                 pt \\<in> set_of dag2) \\<and>\n                                var pt = i)", "apply   fastforce"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>Levellist (levellistb[var p := p])\n                 (nextb(p := levellistb ! var p))\n                 (llb[var p := p # lla ! var p]);\n        lt = Tip; rt = Node dag1 (high p) dag2; var p < length lla;\n        low p = Null; p \\<noteq> Null; ll = lla; marka = mark;\n        \\<forall>q.\n           (q = high p \\<longrightarrow>\n            high p \\<in> set (llb ! var (high p))) \\<and>\n           (q \\<in> set_of dag1 \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of dag2 \\<longrightarrow>\n            q \\<in> set (llb ! var q));\n        \\<forall>n.\n           n \\<noteq> high p \\<and>\n           n \\<notin> set_of dag1 \\<and>\n           n \\<notin> set_of dag2 \\<longrightarrow>\n           markb n = mark n;\n        \\<forall>n.\n           (n = high p \\<longrightarrow> markb (high p) = m) \\<and>\n           (n \\<in> set_of dag1 \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of dag2 \\<longrightarrow> markb n = m);\n        var (high p) < var p; ordered (Node dag1 (high p) dag2) var;\n        a = high p;\n        \\<forall>i\\<le>var (high p).\n           \\<exists>prx.\n              llb ! i = prx @ lla ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = high p \\<or>\n                   pt \\<in> set_of dag1 \\<or> pt \\<in> set_of dag2) \\<and>\n                  var pt = i);\n        high p \\<noteq> Null; \\<forall>i>var (high p). llb ! i = lla ! i;\n        length llb = length lla; Dag (low (high p)) low high dag1;\n        Dag (high (high p)) low high dag2; var p \\<noteq> var q\\<rbrakk>\n       \\<Longrightarrow> q \\<in> set_of dag2 \\<longrightarrow>\n                         q \\<in> set (llb[var p := p # lla ! var p] ! var q)\n 2. \\<lbrakk>Levellist (levellistb[var p := p])\n              (nextb(p := levellistb ! var p))\n              (llb[var p := p # lla ! var p]);\n     lt = Tip; rt = Node dag1 (high p) dag2; var p < length lla;\n     low p = Null; p \\<noteq> Null; ll = lla; marka = mark;\n     \\<forall>q.\n        (q = high p \\<longrightarrow>\n         high p \\<in> set (llb ! var (high p))) \\<and>\n        (q \\<in> set_of dag1 \\<longrightarrow>\n         q \\<in> set (llb ! var q)) \\<and>\n        (q \\<in> set_of dag2 \\<longrightarrow> q \\<in> set (llb ! var q));\n     \\<forall>n.\n        n \\<noteq> high p \\<and>\n        n \\<notin> set_of dag1 \\<and>\n        n \\<notin> set_of dag2 \\<longrightarrow>\n        markb n = mark n;\n     \\<forall>n.\n        (n = high p \\<longrightarrow> markb (high p) = m) \\<and>\n        (n \\<in> set_of dag1 \\<longrightarrow> markb n = m) \\<and>\n        (n \\<in> set_of dag2 \\<longrightarrow> markb n = m);\n     var (high p) < var p; ordered (Node dag1 (high p) dag2) var;\n     a = high p;\n     \\<forall>i\\<le>var (high p).\n        \\<exists>prx.\n           llb ! i = prx @ lla ! i \\<and>\n           (\\<forall>pt\\<in>set prx.\n               (pt = high p \\<or>\n                pt \\<in> set_of dag1 \\<or> pt \\<in> set_of dag2) \\<and>\n               var pt = i);\n     high p \\<noteq> Null; \\<forall>i>var (high p). llb ! i = lla ! i;\n     length llb = length lla; Dag (low (high p)) low high dag1;\n     Dag (high (high p)) low high dag2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i\\<le>var p.\n                         \\<exists>prx.\n                            llb[var p := p # lla ! var p] ! i =\n                            prx @ lla ! i \\<and>\n                            (\\<forall>pt\\<in>set prx.\n                                (pt = high p \\<or>\n                                 pt = p \\<or>\n                                 pt \\<in> set_of dag1 \\<or>\n                                 pt \\<in> set_of dag2) \\<and>\n                                var pt = i)", "apply  fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Levellist (levellistb[var p := p])\n              (nextb(p := levellistb ! var p))\n              (llb[var p := p # lla ! var p]);\n     lt = Tip; rt = Node dag1 (high p) dag2; var p < length lla;\n     low p = Null; p \\<noteq> Null; ll = lla; marka = mark;\n     \\<forall>q.\n        (q = high p \\<longrightarrow>\n         high p \\<in> set (llb ! var (high p))) \\<and>\n        (q \\<in> set_of dag1 \\<longrightarrow>\n         q \\<in> set (llb ! var q)) \\<and>\n        (q \\<in> set_of dag2 \\<longrightarrow> q \\<in> set (llb ! var q));\n     \\<forall>n.\n        n \\<noteq> high p \\<and>\n        n \\<notin> set_of dag1 \\<and>\n        n \\<notin> set_of dag2 \\<longrightarrow>\n        markb n = mark n;\n     \\<forall>n.\n        (n = high p \\<longrightarrow> markb (high p) = m) \\<and>\n        (n \\<in> set_of dag1 \\<longrightarrow> markb n = m) \\<and>\n        (n \\<in> set_of dag2 \\<longrightarrow> markb n = m);\n     var (high p) < var p; ordered (Node dag1 (high p) dag2) var;\n     a = high p;\n     \\<forall>i\\<le>var (high p).\n        \\<exists>prx.\n           llb ! i = prx @ lla ! i \\<and>\n           (\\<forall>pt\\<in>set prx.\n               (pt = high p \\<or>\n                pt \\<in> set_of dag1 \\<or> pt \\<in> set_of dag2) \\<and>\n               var pt = i);\n     high p \\<noteq> Null; \\<forall>i>var (high p). llb ! i = lla ! i;\n     length llb = length lla; Dag (low (high p)) low high dag1;\n     Dag (high (high p)) low high dag2\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i\\<le>var p.\n                         \\<exists>prx.\n                            llb[var p := p # lla ! var p] ! i =\n                            prx @ lla ! i \\<and>\n                            (\\<forall>pt\\<in>set prx.\n                                (pt = high p \\<or>\n                                 pt = p \\<or>\n                                 pt \\<in> set_of dag1 \\<or>\n                                 pt \\<in> set_of dag2) \\<and>\n                                var pt = i)", "apply (rule allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>Levellist (levellistb[var p := p])\n                 (nextb(p := levellistb ! var p))\n                 (llb[var p := p # lla ! var p]);\n        lt = Tip; rt = Node dag1 (high p) dag2; var p < length lla;\n        low p = Null; p \\<noteq> Null; ll = lla; marka = mark;\n        \\<forall>q.\n           (q = high p \\<longrightarrow>\n            high p \\<in> set (llb ! var (high p))) \\<and>\n           (q \\<in> set_of dag1 \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of dag2 \\<longrightarrow>\n            q \\<in> set (llb ! var q));\n        \\<forall>n.\n           n \\<noteq> high p \\<and>\n           n \\<notin> set_of dag1 \\<and>\n           n \\<notin> set_of dag2 \\<longrightarrow>\n           markb n = mark n;\n        \\<forall>n.\n           (n = high p \\<longrightarrow> markb (high p) = m) \\<and>\n           (n \\<in> set_of dag1 \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of dag2 \\<longrightarrow> markb n = m);\n        var (high p) < var p; ordered (Node dag1 (high p) dag2) var;\n        a = high p;\n        \\<forall>i\\<le>var (high p).\n           \\<exists>prx.\n              llb ! i = prx @ lla ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = high p \\<or>\n                   pt \\<in> set_of dag1 \\<or> pt \\<in> set_of dag2) \\<and>\n                  var pt = i);\n        high p \\<noteq> Null; \\<forall>i>var (high p). llb ! i = lla ! i;\n        length llb = length lla; Dag (low (high p)) low high dag1;\n        Dag (high (high p)) low high dag2\\<rbrakk>\n       \\<Longrightarrow> i \\<le> var p \\<longrightarrow>\n                         (\\<exists>prx.\n                             llb[var p := p # lla ! var p] ! i =\n                             prx @ lla ! i \\<and>\n                             (\\<forall>pt\\<in>set prx.\n                                 (pt = high p \\<or>\n                                  pt = p \\<or>\n                                  pt \\<in> set_of dag1 \\<or>\n                                  pt \\<in> set_of dag2) \\<and>\n                                 var pt = i))", "apply (rotate_tac 4)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>low p = Null; p \\<noteq> Null; ll = lla; marka = mark;\n        \\<forall>q.\n           (q = high p \\<longrightarrow>\n            high p \\<in> set (llb ! var (high p))) \\<and>\n           (q \\<in> set_of dag1 \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of dag2 \\<longrightarrow>\n            q \\<in> set (llb ! var q));\n        \\<forall>n.\n           n \\<noteq> high p \\<and>\n           n \\<notin> set_of dag1 \\<and>\n           n \\<notin> set_of dag2 \\<longrightarrow>\n           markb n = mark n;\n        \\<forall>n.\n           (n = high p \\<longrightarrow> markb (high p) = m) \\<and>\n           (n \\<in> set_of dag1 \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of dag2 \\<longrightarrow> markb n = m);\n        var (high p) < var p; ordered (Node dag1 (high p) dag2) var;\n        a = high p;\n        \\<forall>i\\<le>var (high p).\n           \\<exists>prx.\n              llb ! i = prx @ lla ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = high p \\<or>\n                   pt \\<in> set_of dag1 \\<or> pt \\<in> set_of dag2) \\<and>\n                  var pt = i);\n        high p \\<noteq> Null; \\<forall>i>var (high p). llb ! i = lla ! i;\n        length llb = length lla; Dag (low (high p)) low high dag1;\n        Dag (high (high p)) low high dag2;\n        Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n         (llb[var p := p # lla ! var p]);\n        lt = Tip; rt = Node dag1 (high p) dag2; var p < length lla\\<rbrakk>\n       \\<Longrightarrow> i \\<le> var p \\<longrightarrow>\n                         (\\<exists>prx.\n                             llb[var p := p # lla ! var p] ! i =\n                             prx @ lla ! i \\<and>\n                             (\\<forall>pt\\<in>set prx.\n                                 (pt = high p \\<or>\n                                  pt = p \\<or>\n                                  pt \\<in> set_of dag1 \\<or>\n                                  pt \\<in> set_of dag2) \\<and>\n                                 var pt = i))", "apply (erule_tac x=\"i\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>low p = Null; p \\<noteq> Null; ll = lla; marka = mark;\n        \\<forall>q.\n           (q = high p \\<longrightarrow>\n            high p \\<in> set (llb ! var (high p))) \\<and>\n           (q \\<in> set_of dag1 \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of dag2 \\<longrightarrow>\n            q \\<in> set (llb ! var q));\n        \\<forall>n.\n           n \\<noteq> high p \\<and>\n           n \\<notin> set_of dag1 \\<and>\n           n \\<notin> set_of dag2 \\<longrightarrow>\n           markb n = mark n;\n        \\<forall>n.\n           (n = high p \\<longrightarrow> markb (high p) = m) \\<and>\n           (n \\<in> set_of dag1 \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of dag2 \\<longrightarrow> markb n = m);\n        var (high p) < var p; ordered (Node dag1 (high p) dag2) var;\n        a = high p; high p \\<noteq> Null;\n        \\<forall>i>var (high p). llb ! i = lla ! i; length llb = length lla;\n        Dag (low (high p)) low high dag1; Dag (high (high p)) low high dag2;\n        Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n         (llb[var p := p # lla ! var p]);\n        lt = Tip; rt = Node dag1 (high p) dag2; var p < length lla;\n        i \\<le> var (high p) \\<longrightarrow>\n        (\\<exists>prx.\n            llb ! i = prx @ lla ! i \\<and>\n            (\\<forall>pt\\<in>set prx.\n                (pt = high p \\<or>\n                 pt \\<in> set_of dag1 \\<or> pt \\<in> set_of dag2) \\<and>\n                var pt = i))\\<rbrakk>\n       \\<Longrightarrow> i \\<le> var p \\<longrightarrow>\n                         (\\<exists>prx.\n                             llb[var p := p # lla ! var p] ! i =\n                             prx @ lla ! i \\<and>\n                             (\\<forall>pt\\<in>set prx.\n                                 (pt = high p \\<or>\n                                  pt = p \\<or>\n                                  pt \\<in> set_of dag1 \\<or>\n                                  pt \\<in> set_of dag2) \\<and>\n                                 var pt = i))", "apply (case_tac \"i=var p\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>low p = Null; p \\<noteq> Null; ll = lla; marka = mark;\n        \\<forall>q.\n           (q = high p \\<longrightarrow>\n            high p \\<in> set (llb ! var (high p))) \\<and>\n           (q \\<in> set_of dag1 \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of dag2 \\<longrightarrow>\n            q \\<in> set (llb ! var q));\n        \\<forall>n.\n           n \\<noteq> high p \\<and>\n           n \\<notin> set_of dag1 \\<and>\n           n \\<notin> set_of dag2 \\<longrightarrow>\n           markb n = mark n;\n        \\<forall>n.\n           (n = high p \\<longrightarrow> markb (high p) = m) \\<and>\n           (n \\<in> set_of dag1 \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of dag2 \\<longrightarrow> markb n = m);\n        var (high p) < var p; ordered (Node dag1 (high p) dag2) var;\n        a = high p; high p \\<noteq> Null;\n        \\<forall>i>var (high p). llb ! i = lla ! i; length llb = length lla;\n        Dag (low (high p)) low high dag1; Dag (high (high p)) low high dag2;\n        Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n         (llb[var p := p # lla ! var p]);\n        lt = Tip; rt = Node dag1 (high p) dag2; var p < length lla;\n        i \\<le> var (high p) \\<longrightarrow>\n        (\\<exists>prx.\n            llb ! i = prx @ lla ! i \\<and>\n            (\\<forall>pt\\<in>set prx.\n                (pt = high p \\<or>\n                 pt \\<in> set_of dag1 \\<or> pt \\<in> set_of dag2) \\<and>\n                var pt = i));\n        i = var p\\<rbrakk>\n       \\<Longrightarrow> i \\<le> var p \\<longrightarrow>\n                         (\\<exists>prx.\n                             llb[var p := p # lla ! var p] ! i =\n                             prx @ lla ! i \\<and>\n                             (\\<forall>pt\\<in>set prx.\n                                 (pt = high p \\<or>\n                                  pt = p \\<or>\n                                  pt \\<in> set_of dag1 \\<or>\n                                  pt \\<in> set_of dag2) \\<and>\n                                 var pt = i))\n 2. \\<And>i.\n       \\<lbrakk>low p = Null; p \\<noteq> Null; ll = lla; marka = mark;\n        \\<forall>q.\n           (q = high p \\<longrightarrow>\n            high p \\<in> set (llb ! var (high p))) \\<and>\n           (q \\<in> set_of dag1 \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of dag2 \\<longrightarrow>\n            q \\<in> set (llb ! var q));\n        \\<forall>n.\n           n \\<noteq> high p \\<and>\n           n \\<notin> set_of dag1 \\<and>\n           n \\<notin> set_of dag2 \\<longrightarrow>\n           markb n = mark n;\n        \\<forall>n.\n           (n = high p \\<longrightarrow> markb (high p) = m) \\<and>\n           (n \\<in> set_of dag1 \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of dag2 \\<longrightarrow> markb n = m);\n        var (high p) < var p; ordered (Node dag1 (high p) dag2) var;\n        a = high p; high p \\<noteq> Null;\n        \\<forall>i>var (high p). llb ! i = lla ! i; length llb = length lla;\n        Dag (low (high p)) low high dag1; Dag (high (high p)) low high dag2;\n        Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n         (llb[var p := p # lla ! var p]);\n        lt = Tip; rt = Node dag1 (high p) dag2; var p < length lla;\n        i \\<le> var (high p) \\<longrightarrow>\n        (\\<exists>prx.\n            llb ! i = prx @ lla ! i \\<and>\n            (\\<forall>pt\\<in>set prx.\n                (pt = high p \\<or>\n                 pt \\<in> set_of dag1 \\<or> pt \\<in> set_of dag2) \\<and>\n                var pt = i));\n        i \\<noteq> var p\\<rbrakk>\n       \\<Longrightarrow> i \\<le> var p \\<longrightarrow>\n                         (\\<exists>prx.\n                             llb[var p := p # lla ! var p] ! i =\n                             prx @ lla ! i \\<and>\n                             (\\<forall>pt\\<in>set prx.\n                                 (pt = high p \\<or>\n                                  pt = p \\<or>\n                                  pt \\<in> set_of dag1 \\<or>\n                                  pt \\<in> set_of dag2) \\<and>\n                                 var pt = i))", "apply  simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>low p = Null; p \\<noteq> Null; ll = lla; marka = mark;\n        \\<forall>q.\n           (q = high p \\<longrightarrow>\n            high p \\<in> set (llb ! var (high p))) \\<and>\n           (q \\<in> set_of dag1 \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of dag2 \\<longrightarrow>\n            q \\<in> set (llb ! var q));\n        \\<forall>n.\n           n \\<noteq> high p \\<and>\n           n \\<notin> set_of dag1 \\<and>\n           n \\<notin> set_of dag2 \\<longrightarrow>\n           markb n = mark n;\n        \\<forall>n.\n           (n = high p \\<longrightarrow> markb (high p) = m) \\<and>\n           (n \\<in> set_of dag1 \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of dag2 \\<longrightarrow> markb n = m);\n        var (high p) < var p; ordered (Node dag1 (high p) dag2) var;\n        a = high p; high p \\<noteq> Null;\n        \\<forall>i>var (high p). llb ! i = lla ! i; length llb = length lla;\n        Dag (low (high p)) low high dag1; Dag (high (high p)) low high dag2;\n        Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n         (llb[var p := p # lla ! var p]);\n        lt = Tip; rt = Node dag1 (high p) dag2; var p < length lla;\n        i \\<le> var (high p) \\<longrightarrow>\n        (\\<exists>prx.\n            llb ! i = prx @ lla ! i \\<and>\n            (\\<forall>pt\\<in>set prx.\n                (pt = high p \\<or>\n                 pt \\<in> set_of dag1 \\<or> pt \\<in> set_of dag2) \\<and>\n                var pt = i));\n        i \\<noteq> var p\\<rbrakk>\n       \\<Longrightarrow> i \\<le> var p \\<longrightarrow>\n                         (\\<exists>prx.\n                             llb[var p := p # lla ! var p] ! i =\n                             prx @ lla ! i \\<and>\n                             (\\<forall>pt\\<in>set prx.\n                                 (pt = high p \\<or>\n                                  pt = p \\<or>\n                                  pt \\<in> set_of dag1 \\<or>\n                                  pt \\<in> set_of dag2) \\<and>\n                                 var pt = i))", "apply (case_tac \"var (high p) < i\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>low p = Null; p \\<noteq> Null; ll = lla; marka = mark;\n        \\<forall>q.\n           (q = high p \\<longrightarrow>\n            high p \\<in> set (llb ! var (high p))) \\<and>\n           (q \\<in> set_of dag1 \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of dag2 \\<longrightarrow>\n            q \\<in> set (llb ! var q));\n        \\<forall>n.\n           n \\<noteq> high p \\<and>\n           n \\<notin> set_of dag1 \\<and>\n           n \\<notin> set_of dag2 \\<longrightarrow>\n           markb n = mark n;\n        \\<forall>n.\n           (n = high p \\<longrightarrow> markb (high p) = m) \\<and>\n           (n \\<in> set_of dag1 \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of dag2 \\<longrightarrow> markb n = m);\n        var (high p) < var p; ordered (Node dag1 (high p) dag2) var;\n        a = high p; high p \\<noteq> Null;\n        \\<forall>i>var (high p). llb ! i = lla ! i; length llb = length lla;\n        Dag (low (high p)) low high dag1; Dag (high (high p)) low high dag2;\n        Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n         (llb[var p := p # lla ! var p]);\n        lt = Tip; rt = Node dag1 (high p) dag2; var p < length lla;\n        i \\<le> var (high p) \\<longrightarrow>\n        (\\<exists>prx.\n            llb ! i = prx @ lla ! i \\<and>\n            (\\<forall>pt\\<in>set prx.\n                (pt = high p \\<or>\n                 pt \\<in> set_of dag1 \\<or> pt \\<in> set_of dag2) \\<and>\n                var pt = i));\n        i \\<noteq> var p; var (high p) < i\\<rbrakk>\n       \\<Longrightarrow> i \\<le> var p \\<longrightarrow>\n                         (\\<exists>prx.\n                             llb[var p := p # lla ! var p] ! i =\n                             prx @ lla ! i \\<and>\n                             (\\<forall>pt\\<in>set prx.\n                                 (pt = high p \\<or>\n                                  pt = p \\<or>\n                                  pt \\<in> set_of dag1 \\<or>\n                                  pt \\<in> set_of dag2) \\<and>\n                                 var pt = i))\n 2. \\<And>i.\n       \\<lbrakk>low p = Null; p \\<noteq> Null; ll = lla; marka = mark;\n        \\<forall>q.\n           (q = high p \\<longrightarrow>\n            high p \\<in> set (llb ! var (high p))) \\<and>\n           (q \\<in> set_of dag1 \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of dag2 \\<longrightarrow>\n            q \\<in> set (llb ! var q));\n        \\<forall>n.\n           n \\<noteq> high p \\<and>\n           n \\<notin> set_of dag1 \\<and>\n           n \\<notin> set_of dag2 \\<longrightarrow>\n           markb n = mark n;\n        \\<forall>n.\n           (n = high p \\<longrightarrow> markb (high p) = m) \\<and>\n           (n \\<in> set_of dag1 \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of dag2 \\<longrightarrow> markb n = m);\n        var (high p) < var p; ordered (Node dag1 (high p) dag2) var;\n        a = high p; high p \\<noteq> Null;\n        \\<forall>i>var (high p). llb ! i = lla ! i; length llb = length lla;\n        Dag (low (high p)) low high dag1; Dag (high (high p)) low high dag2;\n        Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n         (llb[var p := p # lla ! var p]);\n        lt = Tip; rt = Node dag1 (high p) dag2; var p < length lla;\n        i \\<le> var (high p) \\<longrightarrow>\n        (\\<exists>prx.\n            llb ! i = prx @ lla ! i \\<and>\n            (\\<forall>pt\\<in>set prx.\n                (pt = high p \\<or>\n                 pt \\<in> set_of dag1 \\<or> pt \\<in> set_of dag2) \\<and>\n                var pt = i));\n        i \\<noteq> var p; \\<not> var (high p) < i\\<rbrakk>\n       \\<Longrightarrow> i \\<le> var p \\<longrightarrow>\n                         (\\<exists>prx.\n                             llb[var p := p # lla ! var p] ! i =\n                             prx @ lla ! i \\<and>\n                             (\\<forall>pt\\<in>set prx.\n                                 (pt = high p \\<or>\n                                  pt = p \\<or>\n                                  pt \\<in> set_of dag1 \\<or>\n                                  pt \\<in> set_of dag2) \\<and>\n                                 var pt = i))", "apply  simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>low p = Null; p \\<noteq> Null; ll = lla; marka = mark;\n        \\<forall>q.\n           (q = high p \\<longrightarrow>\n            high p \\<in> set (llb ! var (high p))) \\<and>\n           (q \\<in> set_of dag1 \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of dag2 \\<longrightarrow>\n            q \\<in> set (llb ! var q));\n        \\<forall>n.\n           n \\<noteq> high p \\<and>\n           n \\<notin> set_of dag1 \\<and>\n           n \\<notin> set_of dag2 \\<longrightarrow>\n           markb n = mark n;\n        \\<forall>n.\n           (n = high p \\<longrightarrow> markb (high p) = m) \\<and>\n           (n \\<in> set_of dag1 \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of dag2 \\<longrightarrow> markb n = m);\n        var (high p) < var p; ordered (Node dag1 (high p) dag2) var;\n        a = high p; high p \\<noteq> Null;\n        \\<forall>i>var (high p). llb ! i = lla ! i; length llb = length lla;\n        Dag (low (high p)) low high dag1; Dag (high (high p)) low high dag2;\n        Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n         (llb[var p := p # lla ! var p]);\n        lt = Tip; rt = Node dag1 (high p) dag2; var p < length lla;\n        i \\<le> var (high p) \\<longrightarrow>\n        (\\<exists>prx.\n            llb ! i = prx @ lla ! i \\<and>\n            (\\<forall>pt\\<in>set prx.\n                (pt = high p \\<or>\n                 pt \\<in> set_of dag1 \\<or> pt \\<in> set_of dag2) \\<and>\n                var pt = i));\n        i \\<noteq> var p; \\<not> var (high p) < i\\<rbrakk>\n       \\<Longrightarrow> i \\<le> var p \\<longrightarrow>\n                         (\\<exists>prx.\n                             llb[var p := p # lla ! var p] ! i =\n                             prx @ lla ! i \\<and>\n                             (\\<forall>pt\\<in>set prx.\n                                 (pt = high p \\<or>\n                                  pt = p \\<or>\n                                  pt \\<in> set_of dag1 \\<or>\n                                  pt \\<in> set_of dag2) \\<and>\n                                 var pt = i))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>low p = Null; p \\<noteq> Null; ll = lla; marka = mark;\n        \\<forall>q.\n           (q = high p \\<longrightarrow>\n            high p \\<in> set (llb ! var (high p))) \\<and>\n           (q \\<in> set_of dag1 \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of dag2 \\<longrightarrow>\n            q \\<in> set (llb ! var q));\n        \\<forall>n.\n           n \\<noteq> high p \\<and>\n           n \\<notin> set_of dag1 \\<and>\n           n \\<notin> set_of dag2 \\<longrightarrow>\n           markb n = mark n;\n        \\<forall>n.\n           (n = high p \\<longrightarrow> markb (high p) = m) \\<and>\n           (n \\<in> set_of dag1 \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of dag2 \\<longrightarrow> markb n = m);\n        var (high p) < var p; ordered (Node dag1 (high p) dag2) var;\n        a = high p; high p \\<noteq> Null;\n        \\<forall>i>var (high p). llb ! i = lla ! i; length llb = length lla;\n        Dag (low (high p)) low high dag1; Dag (high (high p)) low high dag2;\n        Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n         (llb[var p := p # lla ! var p]);\n        lt = Tip; rt = Node dag1 (high p) dag2; var p < length lla;\n        \\<exists>prx.\n           llb ! i = prx @ lla ! i \\<and>\n           (\\<forall>pt\\<in>set prx.\n               (pt = high p \\<or>\n                pt \\<in> set_of dag1 \\<or> pt \\<in> set_of dag2) \\<and>\n               var pt = i);\n        \\<not> var (high p) < i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>prx.\n                            llb ! i = prx @ lla ! i \\<and>\n                            (\\<forall>pt\\<in>set prx.\n                                (pt = high p \\<or>\n                                 pt = p \\<or>\n                                 pt \\<in> set_of dag1 \\<or>\n                                 pt \\<in> set_of dag2) \\<and>\n                                var pt = i)", "apply (erule exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i prx.\n       \\<lbrakk>low p = Null; p \\<noteq> Null; ll = lla; marka = mark;\n        \\<forall>q.\n           (q = high p \\<longrightarrow>\n            high p \\<in> set (llb ! var (high p))) \\<and>\n           (q \\<in> set_of dag1 \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of dag2 \\<longrightarrow>\n            q \\<in> set (llb ! var q));\n        \\<forall>n.\n           n \\<noteq> high p \\<and>\n           n \\<notin> set_of dag1 \\<and>\n           n \\<notin> set_of dag2 \\<longrightarrow>\n           markb n = mark n;\n        \\<forall>n.\n           (n = high p \\<longrightarrow> markb (high p) = m) \\<and>\n           (n \\<in> set_of dag1 \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of dag2 \\<longrightarrow> markb n = m);\n        var (high p) < var p; ordered (Node dag1 (high p) dag2) var;\n        a = high p; high p \\<noteq> Null;\n        \\<forall>i>var (high p). llb ! i = lla ! i; length llb = length lla;\n        Dag (low (high p)) low high dag1; Dag (high (high p)) low high dag2;\n        Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n         (llb[var p := p # lla ! var p]);\n        lt = Tip; rt = Node dag1 (high p) dag2; var p < length lla;\n        \\<not> var (high p) < i;\n        llb ! i = prx @ lla ! i \\<and>\n        (\\<forall>pt\\<in>set prx.\n            (pt = high p \\<or>\n             pt \\<in> set_of dag1 \\<or> pt \\<in> set_of dag2) \\<and>\n            var pt = i)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>prx.\n                            llb ! i = prx @ lla ! i \\<and>\n                            (\\<forall>pt\\<in>set prx.\n                                (pt = high p \\<or>\n                                 pt = p \\<or>\n                                 pt \\<in> set_of dag1 \\<or>\n                                 pt \\<in> set_of dag2) \\<and>\n                                var pt = i)", "apply (rule_tac x=\"prx\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i prx.\n       \\<lbrakk>low p = Null; p \\<noteq> Null; ll = lla; marka = mark;\n        \\<forall>q.\n           (q = high p \\<longrightarrow>\n            high p \\<in> set (llb ! var (high p))) \\<and>\n           (q \\<in> set_of dag1 \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of dag2 \\<longrightarrow>\n            q \\<in> set (llb ! var q));\n        \\<forall>n.\n           n \\<noteq> high p \\<and>\n           n \\<notin> set_of dag1 \\<and>\n           n \\<notin> set_of dag2 \\<longrightarrow>\n           markb n = mark n;\n        \\<forall>n.\n           (n = high p \\<longrightarrow> markb (high p) = m) \\<and>\n           (n \\<in> set_of dag1 \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of dag2 \\<longrightarrow> markb n = m);\n        var (high p) < var p; ordered (Node dag1 (high p) dag2) var;\n        a = high p; high p \\<noteq> Null;\n        \\<forall>i>var (high p). llb ! i = lla ! i; length llb = length lla;\n        Dag (low (high p)) low high dag1; Dag (high (high p)) low high dag2;\n        Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n         (llb[var p := p # lla ! var p]);\n        lt = Tip; rt = Node dag1 (high p) dag2; var p < length lla;\n        \\<not> var (high p) < i;\n        llb ! i = prx @ lla ! i \\<and>\n        (\\<forall>pt\\<in>set prx.\n            (pt = high p \\<or>\n             pt \\<in> set_of dag1 \\<or> pt \\<in> set_of dag2) \\<and>\n            var pt = i)\\<rbrakk>\n       \\<Longrightarrow> llb ! i = prx @ lla ! i \\<and>\n                         (\\<forall>pt\\<in>set prx.\n                             (pt = high p \\<or>\n                              pt = p \\<or>\n                              pt \\<in> set_of dag1 \\<or>\n                              pt \\<in> set_of dag2) \\<and>\n                             var pt = i)", "apply (intro conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i prx.\n       \\<lbrakk>low p = Null; p \\<noteq> Null; ll = lla; marka = mark;\n        \\<forall>q.\n           (q = high p \\<longrightarrow>\n            high p \\<in> set (llb ! var (high p))) \\<and>\n           (q \\<in> set_of dag1 \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of dag2 \\<longrightarrow>\n            q \\<in> set (llb ! var q));\n        \\<forall>n.\n           n \\<noteq> high p \\<and>\n           n \\<notin> set_of dag1 \\<and>\n           n \\<notin> set_of dag2 \\<longrightarrow>\n           markb n = mark n;\n        \\<forall>n.\n           (n = high p \\<longrightarrow> markb (high p) = m) \\<and>\n           (n \\<in> set_of dag1 \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of dag2 \\<longrightarrow> markb n = m);\n        var (high p) < var p; ordered (Node dag1 (high p) dag2) var;\n        a = high p; high p \\<noteq> Null;\n        \\<forall>i>var (high p). llb ! i = lla ! i; length llb = length lla;\n        Dag (low (high p)) low high dag1; Dag (high (high p)) low high dag2;\n        Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n         (llb[var p := p # lla ! var p]);\n        lt = Tip; rt = Node dag1 (high p) dag2; var p < length lla;\n        \\<not> var (high p) < i;\n        llb ! i = prx @ lla ! i \\<and>\n        (\\<forall>pt\\<in>set prx.\n            (pt = high p \\<or>\n             pt \\<in> set_of dag1 \\<or> pt \\<in> set_of dag2) \\<and>\n            var pt = i)\\<rbrakk>\n       \\<Longrightarrow> llb ! i = prx @ lla ! i\n 2. \\<And>i prx.\n       \\<lbrakk>low p = Null; p \\<noteq> Null; ll = lla; marka = mark;\n        \\<forall>q.\n           (q = high p \\<longrightarrow>\n            high p \\<in> set (llb ! var (high p))) \\<and>\n           (q \\<in> set_of dag1 \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of dag2 \\<longrightarrow>\n            q \\<in> set (llb ! var q));\n        \\<forall>n.\n           n \\<noteq> high p \\<and>\n           n \\<notin> set_of dag1 \\<and>\n           n \\<notin> set_of dag2 \\<longrightarrow>\n           markb n = mark n;\n        \\<forall>n.\n           (n = high p \\<longrightarrow> markb (high p) = m) \\<and>\n           (n \\<in> set_of dag1 \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of dag2 \\<longrightarrow> markb n = m);\n        var (high p) < var p; ordered (Node dag1 (high p) dag2) var;\n        a = high p; high p \\<noteq> Null;\n        \\<forall>i>var (high p). llb ! i = lla ! i; length llb = length lla;\n        Dag (low (high p)) low high dag1; Dag (high (high p)) low high dag2;\n        Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n         (llb[var p := p # lla ! var p]);\n        lt = Tip; rt = Node dag1 (high p) dag2; var p < length lla;\n        \\<not> var (high p) < i;\n        llb ! i = prx @ lla ! i \\<and>\n        (\\<forall>pt\\<in>set prx.\n            (pt = high p \\<or>\n             pt \\<in> set_of dag1 \\<or> pt \\<in> set_of dag2) \\<and>\n            var pt = i)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>pt\\<in>set prx.\n                            (pt = high p \\<or>\n                             pt = p \\<or>\n                             pt \\<in> set_of dag1 \\<or>\n                             pt \\<in> set_of dag2) \\<and>\n                            var pt = i", "apply  simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i prx.\n       \\<lbrakk>low p = Null; p \\<noteq> Null; ll = lla; marka = mark;\n        \\<forall>q.\n           (q = high p \\<longrightarrow>\n            high p \\<in> set (llb ! var (high p))) \\<and>\n           (q \\<in> set_of dag1 \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of dag2 \\<longrightarrow>\n            q \\<in> set (llb ! var q));\n        \\<forall>n.\n           n \\<noteq> high p \\<and>\n           n \\<notin> set_of dag1 \\<and>\n           n \\<notin> set_of dag2 \\<longrightarrow>\n           markb n = mark n;\n        \\<forall>n.\n           (n = high p \\<longrightarrow> markb (high p) = m) \\<and>\n           (n \\<in> set_of dag1 \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of dag2 \\<longrightarrow> markb n = m);\n        var (high p) < var p; ordered (Node dag1 (high p) dag2) var;\n        a = high p; high p \\<noteq> Null;\n        \\<forall>i>var (high p). llb ! i = lla ! i; length llb = length lla;\n        Dag (low (high p)) low high dag1; Dag (high (high p)) low high dag2;\n        Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n         (llb[var p := p # lla ! var p]);\n        lt = Tip; rt = Node dag1 (high p) dag2; var p < length lla;\n        \\<not> var (high p) < i;\n        llb ! i = prx @ lla ! i \\<and>\n        (\\<forall>pt\\<in>set prx.\n            (pt = high p \\<or>\n             pt \\<in> set_of dag1 \\<or> pt \\<in> set_of dag2) \\<and>\n            var pt = i)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>pt\\<in>set prx.\n                            (pt = high p \\<or>\n                             pt = p \\<or>\n                             pt \\<in> set_of dag1 \\<or>\n                             pt \\<in> set_of dag2) \\<and>\n                            var pt = i", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i prx pt.\n       \\<lbrakk>low p = Null; p \\<noteq> Null; ll = lla; marka = mark;\n        \\<forall>q.\n           (q = high p \\<longrightarrow>\n            high p \\<in> set (llb ! var (high p))) \\<and>\n           (q \\<in> set_of dag1 \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of dag2 \\<longrightarrow>\n            q \\<in> set (llb ! var q));\n        \\<forall>n.\n           n \\<noteq> high p \\<and>\n           n \\<notin> set_of dag1 \\<and>\n           n \\<notin> set_of dag2 \\<longrightarrow>\n           markb n = mark n;\n        \\<forall>n.\n           (n = high p \\<longrightarrow> markb (high p) = m) \\<and>\n           (n \\<in> set_of dag1 \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of dag2 \\<longrightarrow> markb n = m);\n        var (high p) < var p; ordered (Node dag1 (high p) dag2) var;\n        a = high p; high p \\<noteq> Null;\n        \\<forall>i>var (high p). llb ! i = lla ! i; length llb = length lla;\n        Dag (low (high p)) low high dag1; Dag (high (high p)) low high dag2;\n        Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n         (llb[var p := p # lla ! var p]);\n        lt = Tip; rt = Node dag1 (high p) dag2; var p < length lla;\n        \\<not> var (high p) < i; pt \\<in> set prx; llb ! i = prx @ lla ! i;\n        \\<forall>pt\\<in>set prx.\n           (pt = high p \\<or>\n            pt \\<in> set_of dag1 \\<or> pt \\<in> set_of dag2) \\<and>\n           var pt = i\\<rbrakk>\n       \\<Longrightarrow> (pt = high p \\<or>\n                          pt = p \\<or>\n                          pt \\<in> set_of dag1 \\<or>\n                          pt \\<in> set_of dag2) \\<and>\n                         var pt = i", "apply (rotate_tac 15)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i prx pt.\n       \\<lbrakk>Levellist (levellistb[var p := p])\n                 (nextb(p := levellistb ! var p))\n                 (llb[var p := p # lla ! var p]);\n        lt = Tip; rt = Node dag1 (high p) dag2; var p < length lla;\n        \\<not> var (high p) < i; pt \\<in> set prx; llb ! i = prx @ lla ! i;\n        \\<forall>pt\\<in>set prx.\n           (pt = high p \\<or>\n            pt \\<in> set_of dag1 \\<or> pt \\<in> set_of dag2) \\<and>\n           var pt = i;\n        low p = Null; p \\<noteq> Null; ll = lla; marka = mark;\n        \\<forall>q.\n           (q = high p \\<longrightarrow>\n            high p \\<in> set (llb ! var (high p))) \\<and>\n           (q \\<in> set_of dag1 \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of dag2 \\<longrightarrow>\n            q \\<in> set (llb ! var q));\n        \\<forall>n.\n           n \\<noteq> high p \\<and>\n           n \\<notin> set_of dag1 \\<and>\n           n \\<notin> set_of dag2 \\<longrightarrow>\n           markb n = mark n;\n        \\<forall>n.\n           (n = high p \\<longrightarrow> markb (high p) = m) \\<and>\n           (n \\<in> set_of dag1 \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of dag2 \\<longrightarrow> markb n = m);\n        var (high p) < var p; ordered (Node dag1 (high p) dag2) var;\n        a = high p; high p \\<noteq> Null;\n        \\<forall>i>var (high p). llb ! i = lla ! i; length llb = length lla;\n        Dag (low (high p)) low high dag1;\n        Dag (high (high p)) low high dag2\\<rbrakk>\n       \\<Longrightarrow> (pt = high p \\<or>\n                          pt = p \\<or>\n                          pt \\<in> set_of dag1 \\<or>\n                          pt \\<in> set_of dag2) \\<and>\n                         var pt = i", "apply (erule_tac x=\"pt\" in ballE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i prx pt.\n       \\<lbrakk>Levellist (levellistb[var p := p])\n                 (nextb(p := levellistb ! var p))\n                 (llb[var p := p # lla ! var p]);\n        lt = Tip; rt = Node dag1 (high p) dag2; var p < length lla;\n        \\<not> var (high p) < i; pt \\<in> set prx; llb ! i = prx @ lla ! i;\n        low p = Null; p \\<noteq> Null; ll = lla; marka = mark;\n        \\<forall>q.\n           (q = high p \\<longrightarrow>\n            high p \\<in> set (llb ! var (high p))) \\<and>\n           (q \\<in> set_of dag1 \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of dag2 \\<longrightarrow>\n            q \\<in> set (llb ! var q));\n        \\<forall>n.\n           n \\<noteq> high p \\<and>\n           n \\<notin> set_of dag1 \\<and>\n           n \\<notin> set_of dag2 \\<longrightarrow>\n           markb n = mark n;\n        \\<forall>n.\n           (n = high p \\<longrightarrow> markb (high p) = m) \\<and>\n           (n \\<in> set_of dag1 \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of dag2 \\<longrightarrow> markb n = m);\n        var (high p) < var p; ordered (Node dag1 (high p) dag2) var;\n        a = high p; high p \\<noteq> Null;\n        \\<forall>i>var (high p). llb ! i = lla ! i; length llb = length lla;\n        Dag (low (high p)) low high dag1; Dag (high (high p)) low high dag2;\n        (pt = high p \\<or>\n         pt \\<in> set_of dag1 \\<or> pt \\<in> set_of dag2) \\<and>\n        var pt = i\\<rbrakk>\n       \\<Longrightarrow> (pt = high p \\<or>\n                          pt = p \\<or>\n                          pt \\<in> set_of dag1 \\<or>\n                          pt \\<in> set_of dag2) \\<and>\n                         var pt = i\n 2. \\<And>i prx pt.\n       \\<lbrakk>Levellist (levellistb[var p := p])\n                 (nextb(p := levellistb ! var p))\n                 (llb[var p := p # lla ! var p]);\n        lt = Tip; rt = Node dag1 (high p) dag2; var p < length lla;\n        \\<not> var (high p) < i; pt \\<in> set prx; llb ! i = prx @ lla ! i;\n        low p = Null; p \\<noteq> Null; ll = lla; marka = mark;\n        \\<forall>q.\n           (q = high p \\<longrightarrow>\n            high p \\<in> set (llb ! var (high p))) \\<and>\n           (q \\<in> set_of dag1 \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of dag2 \\<longrightarrow>\n            q \\<in> set (llb ! var q));\n        \\<forall>n.\n           n \\<noteq> high p \\<and>\n           n \\<notin> set_of dag1 \\<and>\n           n \\<notin> set_of dag2 \\<longrightarrow>\n           markb n = mark n;\n        \\<forall>n.\n           (n = high p \\<longrightarrow> markb (high p) = m) \\<and>\n           (n \\<in> set_of dag1 \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of dag2 \\<longrightarrow> markb n = m);\n        var (high p) < var p; ordered (Node dag1 (high p) dag2) var;\n        a = high p; high p \\<noteq> Null;\n        \\<forall>i>var (high p). llb ! i = lla ! i; length llb = length lla;\n        Dag (low (high p)) low high dag1; Dag (high (high p)) low high dag2;\n        pt \\<notin> set prx\\<rbrakk>\n       \\<Longrightarrow> (pt = high p \\<or>\n                          pt = p \\<or>\n                          pt \\<in> set_of dag1 \\<or>\n                          pt \\<in> set_of dag2) \\<and>\n                         var pt = i", "apply  fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i prx pt.\n       \\<lbrakk>Levellist (levellistb[var p := p])\n                 (nextb(p := levellistb ! var p))\n                 (llb[var p := p # lla ! var p]);\n        lt = Tip; rt = Node dag1 (high p) dag2; var p < length lla;\n        \\<not> var (high p) < i; pt \\<in> set prx; llb ! i = prx @ lla ! i;\n        low p = Null; p \\<noteq> Null; ll = lla; marka = mark;\n        \\<forall>q.\n           (q = high p \\<longrightarrow>\n            high p \\<in> set (llb ! var (high p))) \\<and>\n           (q \\<in> set_of dag1 \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of dag2 \\<longrightarrow>\n            q \\<in> set (llb ! var q));\n        \\<forall>n.\n           n \\<noteq> high p \\<and>\n           n \\<notin> set_of dag1 \\<and>\n           n \\<notin> set_of dag2 \\<longrightarrow>\n           markb n = mark n;\n        \\<forall>n.\n           (n = high p \\<longrightarrow> markb (high p) = m) \\<and>\n           (n \\<in> set_of dag1 \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of dag2 \\<longrightarrow> markb n = m);\n        var (high p) < var p; ordered (Node dag1 (high p) dag2) var;\n        a = high p; high p \\<noteq> Null;\n        \\<forall>i>var (high p). llb ! i = lla ! i; length llb = length lla;\n        Dag (low (high p)) low high dag1; Dag (high (high p)) low high dag2;\n        pt \\<notin> set prx\\<rbrakk>\n       \\<Longrightarrow> (pt = high p \\<or>\n                          pt = p \\<or>\n                          pt \\<in> set_of dag1 \\<or>\n                          pt \\<in> set_of dag2) \\<and>\n                         var pt = i", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>ll'.\n     Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n      ll' \\<and>\n     wf_levellist (Node Tip p (Node dag1 (high p) dag2)) ll ll' var \\<and>\n     wf_marking (Node Tip p (Node dag1 (high p) dag2)) mark (markb(p := m))\n      m\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  var (high p) < length levellista \\<and>\n  ordered (Node dag1 (high p) dag2) var \\<and>\n  (\\<forall>n\\<in>set_of (Node dag1 (high p) dag2).\n      if marka n = m\n      then n \\<in> set (lla ! var n) \\<and>\n           (\\<forall>nt p.\n               Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n               marka p = m)\n      else n \\<notin> set (concat lla)) \\<and>\n  (\\<forall>markb nextb levellist.\n      (\\<exists>llb.\n          Levellist levellist nextb llb \\<and>\n          wf_levellist (Node dag1 (high p) dag2) lla llb var \\<and>\n          wf_marking (Node dag1 (high p) dag2) marka markb m \\<and>\n          (\\<forall>pa.\n              pa \\<notin> set_of (Node dag1 (high p) dag2) \\<longrightarrow>\n              next pa = nextb pa)) \\<longrightarrow>\n      (\\<exists>ll'.\n          Levellist (levellist[var p := p]) (nextb(p := levellist ! var p))\n           ll' \\<and>\n          wf_levellist (Node Tip p (Node dag1 (high p) dag2)) ll ll'\n           var \\<and>\n          wf_marking (Node Tip p (Node dag1 (high p) dag2)) mark\n           (markb(p := m)) m \\<and>\n          (\\<forall>pa.\n              pa \\<notin> set_of\n                           (Node Tip p\n                             (Node dag1 (high p) dag2)) \\<longrightarrow>\n              next pa = (if pa = p then levellist ! var p else nextb pa))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (low p \\<noteq> Null \\<longrightarrow>\n   var (low p) < length levellist) \\<and>\n  ordered lt var \\<and>\n  (\\<forall>n\\<in>set_of lt.\n      if mark n = m\n      then n \\<in> set (ll ! var n) \\<and>\n           (\\<forall>nt p.\n               Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n               mark p = m)\n      else n \\<notin> set (concat ll)) \\<and>\n  size (dag (low p) low high) < size (dag p low high) \\<and>\n  (\\<forall>marka nexta levellist lla.\n      Levellist levellist nexta lla \\<and>\n      wf_levellist lt ll lla var \\<and>\n      wf_marking lt mark marka m \\<and>\n      (\\<forall>p.\n          p \\<notin> set_of lt \\<longrightarrow>\n          next p = nexta p) \\<longrightarrow>\n      (high p \\<noteq> Null \\<longrightarrow>\n       var (high p) < length levellist) \\<and>\n      ordered rt var \\<and>\n      (\\<exists>lla.\n          Levellist levellist nexta lla \\<and>\n          (\\<forall>n\\<in>set_of rt.\n              if marka n = m\n              then n \\<in> set (lla ! var n) \\<and>\n                   (\\<forall>nt p.\n                       Dag n low high nt \\<and>\n                       p \\<in> set_of nt \\<longrightarrow>\n                       marka p = m)\n              else n \\<notin> set (concat lla)) \\<and>\n          size (dag (high p) low high) < size (dag p low high) \\<and>\n          (\\<forall>markb nextb levellist llb.\n              Levellist levellist nextb llb \\<and>\n              wf_levellist rt lla llb var \\<and>\n              wf_marking rt marka markb m \\<and>\n              (\\<forall>p.\n                  p \\<notin> set_of rt \\<longrightarrow>\n                  nexta p = nextb p) \\<longrightarrow>\n              (\\<exists>ll'.\n                  Levellist (levellist[var p := p])\n                   (nextb(p := levellist ! var p)) ll' \\<and>\n                  wf_levellist (Node lt p rt) ll ll' var \\<and>\n                  wf_marking (Node lt p rt) mark (markb(p := m)) m \\<and>\n                  (\\<forall>pa.\n                      pa \\<notin> set_of (Node lt p rt) \\<longrightarrow>\n                      next pa =\n                      (if pa = p then levellist ! var p else nextb pa))))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (low p \\<noteq> Null \\<longrightarrow>\n   var (low p) < length levellist) \\<and>\n  ordered lt var \\<and>\n  (\\<forall>n\\<in>set_of lt.\n      if mark n = m\n      then n \\<in> set (ll ! var n) \\<and>\n           (\\<forall>nt p.\n               Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n               mark p = m)\n      else n \\<notin> set (concat ll)) \\<and>\n  size (dag (low p) low high) < size (dag p low high) \\<and>\n  (\\<forall>marka nexta levellist lla.\n      Levellist levellist nexta lla \\<and>\n      wf_levellist lt ll lla var \\<and>\n      wf_marking lt mark marka m \\<and>\n      (\\<forall>p.\n          p \\<notin> set_of lt \\<longrightarrow>\n          next p = nexta p) \\<longrightarrow>\n      (high p \\<noteq> Null \\<longrightarrow>\n       var (high p) < length levellist) \\<and>\n      ordered rt var \\<and>\n      (\\<exists>lla.\n          Levellist levellist nexta lla \\<and>\n          (\\<forall>n\\<in>set_of rt.\n              if marka n = m\n              then n \\<in> set (lla ! var n) \\<and>\n                   (\\<forall>nt p.\n                       Dag n low high nt \\<and>\n                       p \\<in> set_of nt \\<longrightarrow>\n                       marka p = m)\n              else n \\<notin> set (concat lla)) \\<and>\n          size (dag (high p) low high) < size (dag p low high) \\<and>\n          (\\<forall>markb nextb levellist llb.\n              Levellist levellist nextb llb \\<and>\n              wf_levellist rt lla llb var \\<and>\n              wf_marking rt marka markb m \\<and>\n              (\\<forall>p.\n                  p \\<notin> set_of rt \\<longrightarrow>\n                  nexta p = nextb p) \\<longrightarrow>\n              (\\<exists>ll'.\n                  Levellist (levellist[var p := p])\n                   (nextb(p := levellist ! var p)) ll' \\<and>\n                  wf_levellist (Node lt p rt) ll ll' var \\<and>\n                  wf_marking (Node lt p rt) mark (markb(p := m)) m \\<and>\n                  (\\<forall>pa.\n                      pa \\<notin> set_of (Node lt p rt) \\<longrightarrow>\n                      next pa =\n                      (if pa = p then levellist ! var p else nextb pa))))))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       lt = Node x21 x22 x23 \\<Longrightarrow>\n       (low p \\<noteq> Null \\<longrightarrow>\n        var (low p) < length levellist) \\<and>\n       ordered lt var \\<and>\n       (\\<forall>n\\<in>set_of lt.\n           if mark n = m\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt p.\n                    Dag n low high nt \\<and>\n                    p \\<in> set_of nt \\<longrightarrow>\n                    mark p = m)\n           else n \\<notin> set (concat ll)) \\<and>\n       size (dag (low p) low high) < size (dag p low high) \\<and>\n       (\\<forall>marka nexta levellist lla.\n           Levellist levellist nexta lla \\<and>\n           wf_levellist lt ll lla var \\<and>\n           wf_marking lt mark marka m \\<and>\n           (\\<forall>p.\n               p \\<notin> set_of lt \\<longrightarrow>\n               next p = nexta p) \\<longrightarrow>\n           (high p \\<noteq> Null \\<longrightarrow>\n            var (high p) < length levellist) \\<and>\n           ordered rt var \\<and>\n           (\\<exists>lla.\n               Levellist levellist nexta lla \\<and>\n               (\\<forall>n\\<in>set_of rt.\n                   if marka n = m\n                   then n \\<in> set (lla ! var n) \\<and>\n                        (\\<forall>nt p.\n                            Dag n low high nt \\<and>\n                            p \\<in> set_of nt \\<longrightarrow>\n                            marka p = m)\n                   else n \\<notin> set (concat lla)) \\<and>\n               size (dag (high p) low high) < size (dag p low high) \\<and>\n               (\\<forall>markb nextb levellist llb.\n                   Levellist levellist nextb llb \\<and>\n                   wf_levellist rt lla llb var \\<and>\n                   wf_marking rt marka markb m \\<and>\n                   (\\<forall>p.\n                       p \\<notin> set_of rt \\<longrightarrow>\n                       nexta p = nextb p) \\<longrightarrow>\n                   (\\<exists>ll'.\n                       Levellist (levellist[var p := p])\n                        (nextb(p := levellist ! var p)) ll' \\<and>\n                       wf_levellist (Node lt p rt) ll ll' var \\<and>\n                       wf_marking (Node lt p rt) mark (markb(p := m))\n                        m \\<and>\n                       (\\<forall>pa.\n                           pa \\<notin> set_of\n  (Node lt p rt) \\<longrightarrow>\n                           next pa =\n                           (if pa = p then levellist ! var p\n                            else nextb pa))))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       lt = Node x21 x22 x23 \\<Longrightarrow>\n       (low p \\<noteq> Null \\<longrightarrow>\n        var (low p) < length levellist) \\<and>\n       ordered lt var \\<and>\n       (\\<forall>n\\<in>set_of lt.\n           if mark n = m\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt p.\n                    Dag n low high nt \\<and>\n                    p \\<in> set_of nt \\<longrightarrow>\n                    mark p = m)\n           else n \\<notin> set (concat ll)) \\<and>\n       size (dag (low p) low high) < size (dag p low high) \\<and>\n       (\\<forall>marka nexta levellist lla.\n           Levellist levellist nexta lla \\<and>\n           wf_levellist lt ll lla var \\<and>\n           wf_marking lt mark marka m \\<and>\n           (\\<forall>p.\n               p \\<notin> set_of lt \\<longrightarrow>\n               next p = nexta p) \\<longrightarrow>\n           (high p \\<noteq> Null \\<longrightarrow>\n            var (high p) < length levellist) \\<and>\n           ordered rt var \\<and>\n           (\\<exists>lla.\n               Levellist levellist nexta lla \\<and>\n               (\\<forall>n\\<in>set_of rt.\n                   if marka n = m\n                   then n \\<in> set (lla ! var n) \\<and>\n                        (\\<forall>nt p.\n                            Dag n low high nt \\<and>\n                            p \\<in> set_of nt \\<longrightarrow>\n                            marka p = m)\n                   else n \\<notin> set (concat lla)) \\<and>\n               size (dag (high p) low high) < size (dag p low high) \\<and>\n               (\\<forall>markb nextb levellist llb.\n                   Levellist levellist nextb llb \\<and>\n                   wf_levellist rt lla llb var \\<and>\n                   wf_marking rt marka markb m \\<and>\n                   (\\<forall>p.\n                       p \\<notin> set_of rt \\<longrightarrow>\n                       nexta p = nextb p) \\<longrightarrow>\n                   (\\<exists>ll'.\n                       Levellist (levellist[var p := p])\n                        (nextb(p := levellist ! var p)) ll' \\<and>\n                       wf_levellist (Node lt p rt) ll ll' var \\<and>\n                       wf_marking (Node lt p rt) mark (markb(p := m))\n                        m \\<and>\n                       (\\<forall>pa.\n                           pa \\<notin> set_of\n  (Node lt p rt) \\<longrightarrow>\n                           next pa =\n                           (if pa = p then levellist ! var p\n                            else nextb pa))))))", "case (Node llt l rlt)"], ["proof (state)\nthis:\n  lt = Node llt l rlt\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       lt = Node x21 x22 x23 \\<Longrightarrow>\n       (low p \\<noteq> Null \\<longrightarrow>\n        var (low p) < length levellist) \\<and>\n       ordered lt var \\<and>\n       (\\<forall>n\\<in>set_of lt.\n           if mark n = m\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt p.\n                    Dag n low high nt \\<and>\n                    p \\<in> set_of nt \\<longrightarrow>\n                    mark p = m)\n           else n \\<notin> set (concat ll)) \\<and>\n       size (dag (low p) low high) < size (dag p low high) \\<and>\n       (\\<forall>marka nexta levellist lla.\n           Levellist levellist nexta lla \\<and>\n           wf_levellist lt ll lla var \\<and>\n           wf_marking lt mark marka m \\<and>\n           (\\<forall>p.\n               p \\<notin> set_of lt \\<longrightarrow>\n               next p = nexta p) \\<longrightarrow>\n           (high p \\<noteq> Null \\<longrightarrow>\n            var (high p) < length levellist) \\<and>\n           ordered rt var \\<and>\n           (\\<exists>lla.\n               Levellist levellist nexta lla \\<and>\n               (\\<forall>n\\<in>set_of rt.\n                   if marka n = m\n                   then n \\<in> set (lla ! var n) \\<and>\n                        (\\<forall>nt p.\n                            Dag n low high nt \\<and>\n                            p \\<in> set_of nt \\<longrightarrow>\n                            marka p = m)\n                   else n \\<notin> set (concat lla)) \\<and>\n               size (dag (high p) low high) < size (dag p low high) \\<and>\n               (\\<forall>markb nextb levellist llb.\n                   Levellist levellist nextb llb \\<and>\n                   wf_levellist rt lla llb var \\<and>\n                   wf_marking rt marka markb m \\<and>\n                   (\\<forall>p.\n                       p \\<notin> set_of rt \\<longrightarrow>\n                       nexta p = nextb p) \\<longrightarrow>\n                   (\\<exists>ll'.\n                       Levellist (levellist[var p := p])\n                        (nextb(p := levellist ! var p)) ll' \\<and>\n                       wf_levellist (Node lt p rt) ll ll' var \\<and>\n                       wf_marking (Node lt p rt) mark (markb(p := m))\n                        m \\<and>\n                       (\\<forall>pa.\n                           pa \\<notin> set_of\n  (Node lt p rt) \\<longrightarrow>\n                           next pa =\n                           (if pa = p then levellist ! var p\n                            else nextb pa))))))", "have lt_Node: \"lt = Node llt l rlt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lt = Node llt l rlt", "by fact"], ["proof (state)\nthis:\n  lt = Node llt l rlt\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       lt = Node x21 x22 x23 \\<Longrightarrow>\n       (low p \\<noteq> Null \\<longrightarrow>\n        var (low p) < length levellist) \\<and>\n       ordered lt var \\<and>\n       (\\<forall>n\\<in>set_of lt.\n           if mark n = m\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt p.\n                    Dag n low high nt \\<and>\n                    p \\<in> set_of nt \\<longrightarrow>\n                    mark p = m)\n           else n \\<notin> set (concat ll)) \\<and>\n       size (dag (low p) low high) < size (dag p low high) \\<and>\n       (\\<forall>marka nexta levellist lla.\n           Levellist levellist nexta lla \\<and>\n           wf_levellist lt ll lla var \\<and>\n           wf_marking lt mark marka m \\<and>\n           (\\<forall>p.\n               p \\<notin> set_of lt \\<longrightarrow>\n               next p = nexta p) \\<longrightarrow>\n           (high p \\<noteq> Null \\<longrightarrow>\n            var (high p) < length levellist) \\<and>\n           ordered rt var \\<and>\n           (\\<exists>lla.\n               Levellist levellist nexta lla \\<and>\n               (\\<forall>n\\<in>set_of rt.\n                   if marka n = m\n                   then n \\<in> set (lla ! var n) \\<and>\n                        (\\<forall>nt p.\n                            Dag n low high nt \\<and>\n                            p \\<in> set_of nt \\<longrightarrow>\n                            marka p = m)\n                   else n \\<notin> set (concat lla)) \\<and>\n               size (dag (high p) low high) < size (dag p low high) \\<and>\n               (\\<forall>markb nextb levellist llb.\n                   Levellist levellist nextb llb \\<and>\n                   wf_levellist rt lla llb var \\<and>\n                   wf_marking rt marka markb m \\<and>\n                   (\\<forall>p.\n                       p \\<notin> set_of rt \\<longrightarrow>\n                       nexta p = nextb p) \\<longrightarrow>\n                   (\\<exists>ll'.\n                       Levellist (levellist[var p := p])\n                        (nextb(p := levellist ! var p)) ll' \\<and>\n                       wf_levellist (Node lt p rt) ll ll' var \\<and>\n                       wf_marking (Node lt p rt) mark (markb(p := m))\n                        m \\<and>\n                       (\\<forall>pa.\n                           pa \\<notin> set_of\n  (Node lt p rt) \\<longrightarrow>\n                           next pa =\n                           (if pa = p then levellist ! var p\n                            else nextb pa))))))", "from orderedt lt varsll' lt_Node"], ["proof (chain)\npicking this:\n  ordered (Node lt p rt) var\n  Dag (low p) low high lt\n  var p < length levellist\n  lt = Node llt l rlt", "obtain ordered_lt:\n      \"ordered lt var\" \"(low p \\<noteq> Null \\<longrightarrow> var (low p) < length levellist)\""], ["proof (prove)\nusing this:\n  ordered (Node lt p rt) var\n  Dag (low p) low high lt\n  var p < length levellist\n  lt = Node llt l rlt\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>ordered lt var;\n      low p \\<noteq> Null \\<longrightarrow>\n      var (low p) < length levellist\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases rt) auto"], ["proof (state)\nthis:\n  ordered lt var\n  low p \\<noteq> Null \\<longrightarrow> var (low p) < length levellist\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       lt = Node x21 x22 x23 \\<Longrightarrow>\n       (low p \\<noteq> Null \\<longrightarrow>\n        var (low p) < length levellist) \\<and>\n       ordered lt var \\<and>\n       (\\<forall>n\\<in>set_of lt.\n           if mark n = m\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt p.\n                    Dag n low high nt \\<and>\n                    p \\<in> set_of nt \\<longrightarrow>\n                    mark p = m)\n           else n \\<notin> set (concat ll)) \\<and>\n       size (dag (low p) low high) < size (dag p low high) \\<and>\n       (\\<forall>marka nexta levellist lla.\n           Levellist levellist nexta lla \\<and>\n           wf_levellist lt ll lla var \\<and>\n           wf_marking lt mark marka m \\<and>\n           (\\<forall>p.\n               p \\<notin> set_of lt \\<longrightarrow>\n               next p = nexta p) \\<longrightarrow>\n           (high p \\<noteq> Null \\<longrightarrow>\n            var (high p) < length levellist) \\<and>\n           ordered rt var \\<and>\n           (\\<exists>lla.\n               Levellist levellist nexta lla \\<and>\n               (\\<forall>n\\<in>set_of rt.\n                   if marka n = m\n                   then n \\<in> set (lla ! var n) \\<and>\n                        (\\<forall>nt p.\n                            Dag n low high nt \\<and>\n                            p \\<in> set_of nt \\<longrightarrow>\n                            marka p = m)\n                   else n \\<notin> set (concat lla)) \\<and>\n               size (dag (high p) low high) < size (dag p low high) \\<and>\n               (\\<forall>markb nextb levellist llb.\n                   Levellist levellist nextb llb \\<and>\n                   wf_levellist rt lla llb var \\<and>\n                   wf_marking rt marka markb m \\<and>\n                   (\\<forall>p.\n                       p \\<notin> set_of rt \\<longrightarrow>\n                       nexta p = nextb p) \\<longrightarrow>\n                   (\\<exists>ll'.\n                       Levellist (levellist[var p := p])\n                        (nextb(p := levellist ! var p)) ll' \\<and>\n                       wf_levellist (Node lt p rt) ll ll' var \\<and>\n                       wf_marking (Node lt p rt) mark (markb(p := m))\n                        m \\<and>\n                       (\\<forall>pa.\n                           pa \\<notin> set_of\n  (Node lt p rt) \\<longrightarrow>\n                           next pa =\n                           (if pa = p then levellist ! var p\n                            else nextb pa))))))", "from lt lt_Node marked_child_ll"], ["proof (chain)\npicking this:\n  Dag (low p) low high lt\n  lt = Node llt l rlt\n  \\<forall>n\\<in>set_of (Node lt p rt).\n     if mark n = m\n     then n \\<in> set (ll ! var n) \\<and>\n          (\\<forall>nt p.\n              Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n              mark p = m)\n     else n \\<notin> set (concat ll)", "have mark_lt: \"\\<forall>n\\<in>set_of lt.\n     if mark n = m\n     then n \\<in> set (ll ! var n) \\<and>\n          (\\<forall>nt p. Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow> mark p = m)\n     else n \\<notin> set (concat ll)\""], ["proof (prove)\nusing this:\n  Dag (low p) low high lt\n  lt = Node llt l rlt\n  \\<forall>n\\<in>set_of (Node lt p rt).\n     if mark n = m\n     then n \\<in> set (ll ! var n) \\<and>\n          (\\<forall>nt p.\n              Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n              mark p = m)\n     else n \\<notin> set (concat ll)\n\ngoal (1 subgoal):\n 1. \\<forall>n\\<in>set_of lt.\n       if mark n = m\n       then n \\<in> set (ll ! var n) \\<and>\n            (\\<forall>nt p.\n                Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n                mark p = m)\n       else n \\<notin> set (concat ll)", "apply (simp only: BinDag.set_of.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Dag (low p) low high (Node llt l rlt); lt = Node llt l rlt;\n     \\<forall>n\\<in>{p} \\<union>\n                    ({l} \\<union> set_of llt \\<union> set_of rlt) \\<union>\n                    set_of rt.\n        if mark n = m\n        then n \\<in> set (ll ! var n) \\<and>\n             (\\<forall>nt p.\n                 Dag n low high nt \\<and>\n                 p \\<in> set_of nt \\<longrightarrow>\n                 mark p = m)\n        else n \\<notin> set (concat ll)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>n\\<in>{l} \\<union> set_of llt \\<union>\n                                     set_of rlt.\n                         if mark n = m\n                         then n \\<in> set (ll ! var n) \\<and>\n                              (\\<forall>nt p.\n                                  Dag n low high nt \\<and>\n                                  p \\<in> set_of nt \\<longrightarrow>\n                                  mark p = m)\n                         else n \\<notin> set (concat ll)", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>Dag (low p) low high (Node llt l rlt); lt = Node llt l rlt;\n        \\<forall>n\\<in>{p} \\<union>\n                       ({l} \\<union> set_of llt \\<union>\n                        set_of rlt) \\<union>\n                       set_of rt.\n           if mark n = m\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt p.\n                    Dag n low high nt \\<and>\n                    p \\<in> set_of nt \\<longrightarrow>\n                    mark p = m)\n           else n \\<notin> set (concat ll);\n        n \\<in> {l} \\<union> set_of llt \\<union> set_of rlt\\<rbrakk>\n       \\<Longrightarrow> if mark n = m\n                         then n \\<in> set (ll ! var n) \\<and>\n                              (\\<forall>nt p.\n                                  Dag n low high nt \\<and>\n                                  p \\<in> set_of nt \\<longrightarrow>\n                                  mark p = m)\n                         else n \\<notin> set (concat ll)", "apply (drule_tac x=n in bspec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>Dag (low p) low high (Node llt l rlt); lt = Node llt l rlt;\n        n \\<in> {l} \\<union> set_of llt \\<union> set_of rlt\\<rbrakk>\n       \\<Longrightarrow> n \\<in> {p} \\<union>\n                                 ({l} \\<union> set_of llt \\<union>\n                                  set_of rlt) \\<union>\n                                 set_of rt\n 2. \\<And>n.\n       \\<lbrakk>Dag (low p) low high (Node llt l rlt); lt = Node llt l rlt;\n        n \\<in> {l} \\<union> set_of llt \\<union> set_of rlt;\n        if mark n = m\n        then n \\<in> set (ll ! var n) \\<and>\n             (\\<forall>nt p.\n                 Dag n low high nt \\<and>\n                 p \\<in> set_of nt \\<longrightarrow>\n                 mark p = m)\n        else n \\<notin> set (concat ll)\\<rbrakk>\n       \\<Longrightarrow> if mark n = m\n                         then n \\<in> set (ll ! var n) \\<and>\n                              (\\<forall>nt p.\n                                  Dag n low high nt \\<and>\n                                  p \\<in> set_of nt \\<longrightarrow>\n                                  mark p = m)\n                         else n \\<notin> set (concat ll)", "apply  blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>Dag (low p) low high (Node llt l rlt); lt = Node llt l rlt;\n        n \\<in> {l} \\<union> set_of llt \\<union> set_of rlt;\n        if mark n = m\n        then n \\<in> set (ll ! var n) \\<and>\n             (\\<forall>nt p.\n                 Dag n low high nt \\<and>\n                 p \\<in> set_of nt \\<longrightarrow>\n                 mark p = m)\n        else n \\<notin> set (concat ll)\\<rbrakk>\n       \\<Longrightarrow> if mark n = m\n                         then n \\<in> set (ll ! var n) \\<and>\n                              (\\<forall>nt p.\n                                  Dag n low high nt \\<and>\n                                  p \\<in> set_of nt \\<longrightarrow>\n                                  mark p = m)\n                         else n \\<notin> set (concat ll)", "apply assumption"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>n\\<in>set_of lt.\n     if mark n = m\n     then n \\<in> set (ll ! var n) \\<and>\n          (\\<forall>nt p.\n              Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n              mark p = m)\n     else n \\<notin> set (concat ll)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       lt = Node x21 x22 x23 \\<Longrightarrow>\n       (low p \\<noteq> Null \\<longrightarrow>\n        var (low p) < length levellist) \\<and>\n       ordered lt var \\<and>\n       (\\<forall>n\\<in>set_of lt.\n           if mark n = m\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt p.\n                    Dag n low high nt \\<and>\n                    p \\<in> set_of nt \\<longrightarrow>\n                    mark p = m)\n           else n \\<notin> set (concat ll)) \\<and>\n       size (dag (low p) low high) < size (dag p low high) \\<and>\n       (\\<forall>marka nexta levellist lla.\n           Levellist levellist nexta lla \\<and>\n           wf_levellist lt ll lla var \\<and>\n           wf_marking lt mark marka m \\<and>\n           (\\<forall>p.\n               p \\<notin> set_of lt \\<longrightarrow>\n               next p = nexta p) \\<longrightarrow>\n           (high p \\<noteq> Null \\<longrightarrow>\n            var (high p) < length levellist) \\<and>\n           ordered rt var \\<and>\n           (\\<exists>lla.\n               Levellist levellist nexta lla \\<and>\n               (\\<forall>n\\<in>set_of rt.\n                   if marka n = m\n                   then n \\<in> set (lla ! var n) \\<and>\n                        (\\<forall>nt p.\n                            Dag n low high nt \\<and>\n                            p \\<in> set_of nt \\<longrightarrow>\n                            marka p = m)\n                   else n \\<notin> set (concat lla)) \\<and>\n               size (dag (high p) low high) < size (dag p low high) \\<and>\n               (\\<forall>markb nextb levellist llb.\n                   Levellist levellist nextb llb \\<and>\n                   wf_levellist rt lla llb var \\<and>\n                   wf_marking rt marka markb m \\<and>\n                   (\\<forall>p.\n                       p \\<notin> set_of rt \\<longrightarrow>\n                       nexta p = nextb p) \\<longrightarrow>\n                   (\\<exists>ll'.\n                       Levellist (levellist[var p := p])\n                        (nextb(p := levellist ! var p)) ll' \\<and>\n                       wf_levellist (Node lt p rt) ll ll' var \\<and>\n                       wf_marking (Node lt p rt) mark (markb(p := m))\n                        m \\<and>\n                       (\\<forall>pa.\n                           pa \\<notin> set_of\n  (Node lt p rt) \\<longrightarrow>\n                           next pa =\n                           (if pa = p then levellist ! var p\n                            else nextb pa))))))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (low p \\<noteq> Null \\<longrightarrow>\n     var (low p) < length levellist) \\<and>\n    ordered lt var \\<and>\n    (\\<forall>n\\<in>set_of lt.\n        if mark n = m\n        then n \\<in> set (ll ! var n) \\<and>\n             (\\<forall>nt p.\n                 Dag n low high nt \\<and>\n                 p \\<in> set_of nt \\<longrightarrow>\n                 mark p = m)\n        else n \\<notin> set (concat ll)) \\<and>\n    size (dag (low p) low high) < size (dag p low high) \\<and>\n    (\\<forall>marka nexta levellist lla.\n        Levellist levellist nexta lla \\<and>\n        wf_levellist lt ll lla var \\<and>\n        wf_marking lt mark marka m \\<and>\n        (\\<forall>p.\n            p \\<notin> set_of lt \\<longrightarrow>\n            next p = nexta p) \\<longrightarrow>\n        (high p \\<noteq> Null \\<longrightarrow>\n         var (high p) < length levellist) \\<and>\n        ordered rt var \\<and>\n        (\\<exists>lla.\n            Levellist levellist nexta lla \\<and>\n            (\\<forall>n\\<in>set_of rt.\n                if marka n = m\n                then n \\<in> set (lla ! var n) \\<and>\n                     (\\<forall>nt p.\n                         Dag n low high nt \\<and>\n                         p \\<in> set_of nt \\<longrightarrow>\n                         marka p = m)\n                else n \\<notin> set (concat lla)) \\<and>\n            size (dag (high p) low high) < size (dag p low high) \\<and>\n            (\\<forall>markb nextb levellist llb.\n                Levellist levellist nextb llb \\<and>\n                wf_levellist rt lla llb var \\<and>\n                wf_marking rt marka markb m \\<and>\n                (\\<forall>p.\n                    p \\<notin> set_of rt \\<longrightarrow>\n                    nexta p = nextb p) \\<longrightarrow>\n                (\\<exists>ll'.\n                    Levellist (levellist[var p := p])\n                     (nextb(p := levellist ! var p)) ll' \\<and>\n                    wf_levellist (Node lt p rt) ll ll' var \\<and>\n                    wf_marking (Node lt p rt) mark (markb(p := m)) m \\<and>\n                    (\\<forall>pa.\n                        pa \\<notin> set_of (Node lt p rt) \\<longrightarrow>\n                        next pa =\n                        (if pa = p then levellist ! var p\n                         else nextb pa))))))", "apply (intro conjI ordered_lt mark_lt size_lt_dec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>marka nexta levellist lla.\n       Levellist levellist nexta lla \\<and>\n       wf_levellist lt ll lla var \\<and>\n       wf_marking lt mark marka m \\<and>\n       (\\<forall>p.\n           p \\<notin> set_of lt \\<longrightarrow>\n           next p = nexta p) \\<longrightarrow>\n       (high p \\<noteq> Null \\<longrightarrow>\n        var (high p) < length levellist) \\<and>\n       ordered rt var \\<and>\n       (\\<exists>lla.\n           Levellist levellist nexta lla \\<and>\n           (\\<forall>n\\<in>set_of rt.\n               if marka n = m\n               then n \\<in> set (lla ! var n) \\<and>\n                    (\\<forall>nt p.\n                        Dag n low high nt \\<and>\n                        p \\<in> set_of nt \\<longrightarrow>\n                        marka p = m)\n               else n \\<notin> set (concat lla)) \\<and>\n           size (dag (high p) low high) < size (dag p low high) \\<and>\n           (\\<forall>markb nextb levellist llb.\n               Levellist levellist nextb llb \\<and>\n               wf_levellist rt lla llb var \\<and>\n               wf_marking rt marka markb m \\<and>\n               (\\<forall>p.\n                   p \\<notin> set_of rt \\<longrightarrow>\n                   nexta p = nextb p) \\<longrightarrow>\n               (\\<exists>ll'.\n                   Levellist (levellist[var p := p])\n                    (nextb(p := levellist ! var p)) ll' \\<and>\n                   wf_levellist (Node lt p rt) ll ll' var \\<and>\n                   wf_marking (Node lt p rt) mark (markb(p := m)) m \\<and>\n                   (\\<forall>pa.\n                       pa \\<notin> set_of (Node lt p rt) \\<longrightarrow>\n                       next pa =\n                       (if pa = p then levellist ! var p else nextb pa)))))", "apply (clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>marka nexta levellist lla.\n       \\<lbrakk>Levellist levellist nexta lla; wf_levellist lt ll lla var;\n        wf_marking lt mark marka m;\n        \\<forall>p.\n           p \\<notin> set_of lt \\<longrightarrow> next p = nexta p\\<rbrakk>\n       \\<Longrightarrow> (high p \\<noteq> Null \\<longrightarrow>\n                          var (high p) < length levellist) \\<and>\n                         ordered rt var \\<and>\n                         (\\<exists>lla.\n                             Levellist levellist nexta lla \\<and>\n                             (\\<forall>n\\<in>set_of rt.\n                                 if marka n = m\n                                 then n \\<in> set (lla ! var n) \\<and>\n(\\<forall>nt p.\n    Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n    marka p = m)\n                                 else n \\<notin> set (concat lla)) \\<and>\n                             size (dag (high p) low high)\n                             < size (dag p low high) \\<and>\n                             (\\<forall>markb nextb levellist llb.\n                                 Levellist levellist nextb llb \\<and>\n                                 wf_levellist rt lla llb var \\<and>\n                                 wf_marking rt marka markb m \\<and>\n                                 (\\<forall>p.\n                                     p \\<notin> set_of rt \\<longrightarrow>\n                                     nexta p = nextb p) \\<longrightarrow>\n                                 (\\<exists>ll'.\n                                     Levellist (levellist[var p := p])\n(nextb(p := levellist ! var p)) ll' \\<and>\n                                     wf_levellist (Node lt p rt) ll ll'\nvar \\<and>\n                                     wf_marking (Node lt p rt) mark\n(markb(p := m)) m \\<and>\n                                     (\\<forall>pa.\n   pa \\<notin> set_of (Node lt p rt) \\<longrightarrow>\n   next pa = (if pa = p then levellist ! var p else nextb pa)))))", "apply (simp add: size_rt_dec split del: if_split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>marka nexta levellist lla.\n       \\<lbrakk>Levellist levellist nexta lla; wf_levellist lt ll lla var;\n        wf_marking lt mark marka m;\n        \\<forall>p.\n           p \\<notin> set_of lt \\<longrightarrow> next p = nexta p\\<rbrakk>\n       \\<Longrightarrow> (high p \\<noteq> Null \\<longrightarrow>\n                          var (high p) < length levellist) \\<and>\n                         ordered rt var \\<and>\n                         (\\<forall>n\\<in>set_of rt.\n                             if marka n = m\n                             then n \\<in> set (lla ! var n) \\<and>\n                                  (\\<forall>nt p.\nDag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow> marka p = m)\n                             else n \\<notin> set (concat lla)) \\<and>\n                         (\\<forall>markb nextb levellist.\n                             (\\<exists>llb.\n                                 Levellist levellist nextb llb \\<and>\n                                 wf_levellist rt lla llb var \\<and>\n                                 wf_marking rt marka markb m \\<and>\n                                 (\\<forall>p.\n                                     p \\<notin> set_of rt \\<longrightarrow>\n                                     nexta p = nextb p)) \\<longrightarrow>\n                             (\\<exists>ll'.\n                                 Levellist (levellist[var p := p])\n                                  (nextb(p := levellist ! var p)) ll' \\<and>\n                                 wf_levellist (Node lt p rt) ll ll'\n                                  var \\<and>\n                                 wf_marking (Node lt p rt) mark\n                                  (markb(p := m)) m))", "apply (simp only: Levellist_ext_to_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>marka nexta levellist lla.\n       \\<lbrakk>Levellist levellist nexta lla; wf_levellist lt ll lla var;\n        wf_marking lt mark marka m;\n        \\<forall>p.\n           p \\<notin> set_of lt \\<longrightarrow> next p = nexta p\\<rbrakk>\n       \\<Longrightarrow> (high p \\<noteq> Null \\<longrightarrow>\n                          var (high p) < length levellist) \\<and>\n                         ordered rt var \\<and>\n                         (\\<forall>n\\<in>set_of rt.\n                             if marka n = m\n                             then n \\<in> set (lla ! var n) \\<and>\n                                  (\\<forall>nt p.\nDag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow> marka p = m)\n                             else n \\<notin> set (concat lla)) \\<and>\n                         (\\<forall>markb nextb levellist llb.\n                             Levellist levellist nextb llb \\<and>\n                             wf_levellist rt lla llb var \\<and>\n                             wf_marking rt marka markb m \\<and>\n                             (\\<forall>p.\n                                 p \\<notin> set_of rt \\<longrightarrow>\n                                 nexta p = nextb p) \\<longrightarrow>\n                             (\\<exists>ll'.\n                                 Levellist (levellist[var p := p])\n                                  (nextb(p := levellist ! var p)) ll' \\<and>\n                                 wf_levellist (Node lt p rt) ll ll'\n                                  var \\<and>\n                                 wf_marking (Node lt p rt) mark\n                                  (markb(p := m)) m))", "subgoal premises prems for marka nexta levellista lla"], ["proof (prove)\ngoal (1 subgoal):\n 1. (high p \\<noteq> Null \\<longrightarrow>\n     var (high p) < length levellista) \\<and>\n    ordered rt var \\<and>\n    (\\<forall>n\\<in>set_of rt.\n        if marka n = m\n        then n \\<in> set (lla ! var n) \\<and>\n             (\\<forall>nt p.\n                 Dag n low high nt \\<and>\n                 p \\<in> set_of nt \\<longrightarrow>\n                 marka p = m)\n        else n \\<notin> set (concat lla)) \\<and>\n    (\\<forall>markb nextb levellist llb.\n        Levellist levellist nextb llb \\<and>\n        wf_levellist rt lla llb var \\<and>\n        wf_marking rt marka markb m \\<and>\n        (\\<forall>p.\n            p \\<notin> set_of rt \\<longrightarrow>\n            nexta p = nextb p) \\<longrightarrow>\n        (\\<exists>ll'.\n            Levellist (levellist[var p := p])\n             (nextb(p := levellist ! var p)) ll' \\<and>\n            wf_levellist (Node lt p rt) ll ll' var \\<and>\n            wf_marking (Node lt p rt) mark (markb(p := m)) m))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (high p \\<noteq> Null \\<longrightarrow>\n     var (high p) < length levellista) \\<and>\n    ordered rt var \\<and>\n    (\\<forall>n\\<in>set_of rt.\n        if marka n = m\n        then n \\<in> set (lla ! var n) \\<and>\n             (\\<forall>nt p.\n                 Dag n low high nt \\<and>\n                 p \\<in> set_of nt \\<longrightarrow>\n                 marka p = m)\n        else n \\<notin> set (concat lla)) \\<and>\n    (\\<forall>markb nextb levellist llb.\n        Levellist levellist nextb llb \\<and>\n        wf_levellist rt lla llb var \\<and>\n        wf_marking rt marka markb m \\<and>\n        (\\<forall>p.\n            p \\<notin> set_of rt \\<longrightarrow>\n            nexta p = nextb p) \\<longrightarrow>\n        (\\<exists>ll'.\n            Levellist (levellist[var p := p])\n             (nextb(p := levellist ! var p)) ll' \\<and>\n            wf_levellist (Node lt p rt) ll ll' var \\<and>\n            wf_marking (Node lt p rt) mark (markb(p := m)) m))", "have lla: \"Levellist levellista nexta lla\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Levellist levellista nexta lla", "by fact"], ["proof (state)\nthis:\n  Levellist levellista nexta lla\n\ngoal (1 subgoal):\n 1. (high p \\<noteq> Null \\<longrightarrow>\n     var (high p) < length levellista) \\<and>\n    ordered rt var \\<and>\n    (\\<forall>n\\<in>set_of rt.\n        if marka n = m\n        then n \\<in> set (lla ! var n) \\<and>\n             (\\<forall>nt p.\n                 Dag n low high nt \\<and>\n                 p \\<in> set_of nt \\<longrightarrow>\n                 marka p = m)\n        else n \\<notin> set (concat lla)) \\<and>\n    (\\<forall>markb nextb levellist llb.\n        Levellist levellist nextb llb \\<and>\n        wf_levellist rt lla llb var \\<and>\n        wf_marking rt marka markb m \\<and>\n        (\\<forall>p.\n            p \\<notin> set_of rt \\<longrightarrow>\n            nexta p = nextb p) \\<longrightarrow>\n        (\\<exists>ll'.\n            Levellist (levellist[var p := p])\n             (nextb(p := levellist ! var p)) ll' \\<and>\n            wf_levellist (Node lt p rt) ll ll' var \\<and>\n            wf_marking (Node lt p rt) mark (markb(p := m)) m))", "have wfll_lt: \"wf_levellist lt ll lla var\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_levellist lt ll lla var", "by fact"], ["proof (state)\nthis:\n  wf_levellist lt ll lla var\n\ngoal (1 subgoal):\n 1. (high p \\<noteq> Null \\<longrightarrow>\n     var (high p) < length levellista) \\<and>\n    ordered rt var \\<and>\n    (\\<forall>n\\<in>set_of rt.\n        if marka n = m\n        then n \\<in> set (lla ! var n) \\<and>\n             (\\<forall>nt p.\n                 Dag n low high nt \\<and>\n                 p \\<in> set_of nt \\<longrightarrow>\n                 marka p = m)\n        else n \\<notin> set (concat lla)) \\<and>\n    (\\<forall>markb nextb levellist llb.\n        Levellist levellist nextb llb \\<and>\n        wf_levellist rt lla llb var \\<and>\n        wf_marking rt marka markb m \\<and>\n        (\\<forall>p.\n            p \\<notin> set_of rt \\<longrightarrow>\n            nexta p = nextb p) \\<longrightarrow>\n        (\\<exists>ll'.\n            Levellist (levellist[var p := p])\n             (nextb(p := levellist ! var p)) ll' \\<and>\n            wf_levellist (Node lt p rt) ll ll' var \\<and>\n            wf_marking (Node lt p rt) mark (markb(p := m)) m))", "have wfmarking_lt:\"wf_marking lt mark marka m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_marking lt mark marka m", "by fact"], ["proof (state)\nthis:\n  wf_marking lt mark marka m\n\ngoal (1 subgoal):\n 1. (high p \\<noteq> Null \\<longrightarrow>\n     var (high p) < length levellista) \\<and>\n    ordered rt var \\<and>\n    (\\<forall>n\\<in>set_of rt.\n        if marka n = m\n        then n \\<in> set (lla ! var n) \\<and>\n             (\\<forall>nt p.\n                 Dag n low high nt \\<and>\n                 p \\<in> set_of nt \\<longrightarrow>\n                 marka p = m)\n        else n \\<notin> set (concat lla)) \\<and>\n    (\\<forall>markb nextb levellist llb.\n        Levellist levellist nextb llb \\<and>\n        wf_levellist rt lla llb var \\<and>\n        wf_marking rt marka markb m \\<and>\n        (\\<forall>p.\n            p \\<notin> set_of rt \\<longrightarrow>\n            nexta p = nextb p) \\<longrightarrow>\n        (\\<exists>ll'.\n            Levellist (levellist[var p := p])\n             (nextb(p := levellist ! var p)) ll' \\<and>\n            wf_levellist (Node lt p rt) ll ll' var \\<and>\n            wf_marking (Node lt p rt) mark (markb(p := m)) m))", "from wfll_lt lt_Node"], ["proof (chain)\npicking this:\n  wf_levellist lt ll lla var\n  lt = Node llt l rlt", "have lla_eq_ll: \"length lla = length ll\""], ["proof (prove)\nusing this:\n  wf_levellist lt ll lla var\n  lt = Node llt l rlt\n\ngoal (1 subgoal):\n 1. length lla = length ll", "by (simp add: wf_levellist_def)"], ["proof (state)\nthis:\n  length lla = length ll\n\ngoal (1 subgoal):\n 1. (high p \\<noteq> Null \\<longrightarrow>\n     var (high p) < length levellista) \\<and>\n    ordered rt var \\<and>\n    (\\<forall>n\\<in>set_of rt.\n        if marka n = m\n        then n \\<in> set (lla ! var n) \\<and>\n             (\\<forall>nt p.\n                 Dag n low high nt \\<and>\n                 p \\<in> set_of nt \\<longrightarrow>\n                 marka p = m)\n        else n \\<notin> set (concat lla)) \\<and>\n    (\\<forall>markb nextb levellist llb.\n        Levellist levellist nextb llb \\<and>\n        wf_levellist rt lla llb var \\<and>\n        wf_marking rt marka markb m \\<and>\n        (\\<forall>p.\n            p \\<notin> set_of rt \\<longrightarrow>\n            nexta p = nextb p) \\<longrightarrow>\n        (\\<exists>ll'.\n            Levellist (levellist[var p := p])\n             (nextb(p := levellist ! var p)) ll' \\<and>\n            wf_levellist (Node lt p rt) ll ll' var \\<and>\n            wf_marking (Node lt p rt) mark (markb(p := m)) m))", "with ll lla"], ["proof (chain)\npicking this:\n  Levellist levellist next ll\n  Levellist levellista nexta lla\n  length lla = length ll", "have lla_eq_ll': \"length levellista = length levellist\""], ["proof (prove)\nusing this:\n  Levellist levellist next ll\n  Levellist levellista nexta lla\n  length lla = length ll\n\ngoal (1 subgoal):\n 1. length levellista = length levellist", "by (simp add: Levellist_length)"], ["proof (state)\nthis:\n  length levellista = length levellist\n\ngoal (1 subgoal):\n 1. (high p \\<noteq> Null \\<longrightarrow>\n     var (high p) < length levellista) \\<and>\n    ordered rt var \\<and>\n    (\\<forall>n\\<in>set_of rt.\n        if marka n = m\n        then n \\<in> set (lla ! var n) \\<and>\n             (\\<forall>nt p.\n                 Dag n low high nt \\<and>\n                 p \\<in> set_of nt \\<longrightarrow>\n                 marka p = m)\n        else n \\<notin> set (concat lla)) \\<and>\n    (\\<forall>markb nextb levellist llb.\n        Levellist levellist nextb llb \\<and>\n        wf_levellist rt lla llb var \\<and>\n        wf_marking rt marka markb m \\<and>\n        (\\<forall>p.\n            p \\<notin> set_of rt \\<longrightarrow>\n            nexta p = nextb p) \\<longrightarrow>\n        (\\<exists>ll'.\n            Levellist (levellist[var p := p])\n             (nextb(p := levellist ! var p)) ll' \\<and>\n            wf_levellist (Node lt p rt) ll ll' var \\<and>\n            wf_marking (Node lt p rt) mark (markb(p := m)) m))", "with orderedt rt lt_Node lt varsll'"], ["proof (chain)\npicking this:\n  ordered (Node lt p rt) var\n  Dag (high p) low high rt\n  lt = Node llt l rlt\n  Dag (low p) low high lt\n  var p < length levellist\n  length levellista = length levellist", "obtain ordered_rt:\n          \"ordered rt var\" \"(high p \\<noteq> Null \\<longrightarrow> var (high p) < length levellista)\""], ["proof (prove)\nusing this:\n  ordered (Node lt p rt) var\n  Dag (high p) low high rt\n  lt = Node llt l rlt\n  Dag (low p) low high lt\n  var p < length levellist\n  length levellista = length levellist\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>ordered rt var;\n      high p \\<noteq> Null \\<longrightarrow>\n      var (high p) < length levellista\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases rt) auto"], ["proof (state)\nthis:\n  ordered rt var\n  high p \\<noteq> Null \\<longrightarrow> var (high p) < length levellista\n\ngoal (1 subgoal):\n 1. (high p \\<noteq> Null \\<longrightarrow>\n     var (high p) < length levellista) \\<and>\n    ordered rt var \\<and>\n    (\\<forall>n\\<in>set_of rt.\n        if marka n = m\n        then n \\<in> set (lla ! var n) \\<and>\n             (\\<forall>nt p.\n                 Dag n low high nt \\<and>\n                 p \\<in> set_of nt \\<longrightarrow>\n                 marka p = m)\n        else n \\<notin> set (concat lla)) \\<and>\n    (\\<forall>markb nextb levellist llb.\n        Levellist levellist nextb llb \\<and>\n        wf_levellist rt lla llb var \\<and>\n        wf_marking rt marka markb m \\<and>\n        (\\<forall>p.\n            p \\<notin> set_of rt \\<longrightarrow>\n            nexta p = nextb p) \\<longrightarrow>\n        (\\<exists>ll'.\n            Levellist (levellist[var p := p])\n             (nextb(p := levellist ! var p)) ll' \\<and>\n            wf_levellist (Node lt p rt) ll ll' var \\<and>\n            wf_marking (Node lt p rt) mark (markb(p := m)) m))", "from wfll_lt lt_Node"], ["proof (chain)\npicking this:\n  wf_levellist lt ll lla var\n  lt = Node llt l rlt", "have nodes_in_lla: \"\\<forall> q. q \\<in> set_of lt \\<longrightarrow> q \\<in> set (lla ! (q\\<rightarrow>var))\""], ["proof (prove)\nusing this:\n  wf_levellist lt ll lla var\n  lt = Node llt l rlt\n\ngoal (1 subgoal):\n 1. \\<forall>q.\n       q \\<in> set_of lt \\<longrightarrow> q \\<in> set (lla ! var q)", "by (simp add: wf_levellist_def)"], ["proof (state)\nthis:\n  \\<forall>q. q \\<in> set_of lt \\<longrightarrow> q \\<in> set (lla ! var q)\n\ngoal (1 subgoal):\n 1. (high p \\<noteq> Null \\<longrightarrow>\n     var (high p) < length levellista) \\<and>\n    ordered rt var \\<and>\n    (\\<forall>n\\<in>set_of rt.\n        if marka n = m\n        then n \\<in> set (lla ! var n) \\<and>\n             (\\<forall>nt p.\n                 Dag n low high nt \\<and>\n                 p \\<in> set_of nt \\<longrightarrow>\n                 marka p = m)\n        else n \\<notin> set (concat lla)) \\<and>\n    (\\<forall>markb nextb levellist llb.\n        Levellist levellist nextb llb \\<and>\n        wf_levellist rt lla llb var \\<and>\n        wf_marking rt marka markb m \\<and>\n        (\\<forall>p.\n            p \\<notin> set_of rt \\<longrightarrow>\n            nexta p = nextb p) \\<longrightarrow>\n        (\\<exists>ll'.\n            Levellist (levellist[var p := p])\n             (nextb(p := levellist ! var p)) ll' \\<and>\n            wf_levellist (Node lt p rt) ll ll' var \\<and>\n            wf_marking (Node lt p rt) mark (markb(p := m)) m))", "from wfll_lt lt_Node lt"], ["proof (chain)\npicking this:\n  wf_levellist lt ll lla var\n  lt = Node llt l rlt\n  Dag (low p) low high lt", "have lla_st: \"(\\<forall>i \\<le> (low p)\\<rightarrow>var.\n                        (\\<exists>prx. (lla ! i) = prx@(ll ! i) \\<and>\n                               (\\<forall>pt \\<in> set prx. pt \\<in> set_of lt \\<and> pt\\<rightarrow>var = i)))\""], ["proof (prove)\nusing this:\n  wf_levellist lt ll lla var\n  lt = Node llt l rlt\n  Dag (low p) low high lt\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<le>var (low p).\n       \\<exists>prx.\n          lla ! i = prx @ ll ! i \\<and>\n          (\\<forall>pt\\<in>set prx. pt \\<in> set_of lt \\<and> var pt = i)", "by (simp add: wf_levellist_def)"], ["proof (state)\nthis:\n  \\<forall>i\\<le>var (low p).\n     \\<exists>prx.\n        lla ! i = prx @ ll ! i \\<and>\n        (\\<forall>pt\\<in>set prx. pt \\<in> set_of lt \\<and> var pt = i)\n\ngoal (1 subgoal):\n 1. (high p \\<noteq> Null \\<longrightarrow>\n     var (high p) < length levellista) \\<and>\n    ordered rt var \\<and>\n    (\\<forall>n\\<in>set_of rt.\n        if marka n = m\n        then n \\<in> set (lla ! var n) \\<and>\n             (\\<forall>nt p.\n                 Dag n low high nt \\<and>\n                 p \\<in> set_of nt \\<longrightarrow>\n                 marka p = m)\n        else n \\<notin> set (concat lla)) \\<and>\n    (\\<forall>markb nextb levellist llb.\n        Levellist levellist nextb llb \\<and>\n        wf_levellist rt lla llb var \\<and>\n        wf_marking rt marka markb m \\<and>\n        (\\<forall>p.\n            p \\<notin> set_of rt \\<longrightarrow>\n            nexta p = nextb p) \\<longrightarrow>\n        (\\<exists>ll'.\n            Levellist (levellist[var p := p])\n             (nextb(p := levellist ! var p)) ll' \\<and>\n            wf_levellist (Node lt p rt) ll ll' var \\<and>\n            wf_marking (Node lt p rt) mark (markb(p := m)) m))", "from wfll_lt lt_Node lt"], ["proof (chain)\npicking this:\n  wf_levellist lt ll lla var\n  lt = Node llt l rlt\n  Dag (low p) low high lt", "have lla_nc: \"\\<forall>i. ((low p)\\<rightarrow>var) < i \\<longrightarrow> (lla ! i) = (ll ! i)\""], ["proof (prove)\nusing this:\n  wf_levellist lt ll lla var\n  lt = Node llt l rlt\n  Dag (low p) low high lt\n\ngoal (1 subgoal):\n 1. \\<forall>i>var (low p). lla ! i = ll ! i", "by (simp add: wf_levellist_def)"], ["proof (state)\nthis:\n  \\<forall>i>var (low p). lla ! i = ll ! i\n\ngoal (1 subgoal):\n 1. (high p \\<noteq> Null \\<longrightarrow>\n     var (high p) < length levellista) \\<and>\n    ordered rt var \\<and>\n    (\\<forall>n\\<in>set_of rt.\n        if marka n = m\n        then n \\<in> set (lla ! var n) \\<and>\n             (\\<forall>nt p.\n                 Dag n low high nt \\<and>\n                 p \\<in> set_of nt \\<longrightarrow>\n                 marka p = m)\n        else n \\<notin> set (concat lla)) \\<and>\n    (\\<forall>markb nextb levellist llb.\n        Levellist levellist nextb llb \\<and>\n        wf_levellist rt lla llb var \\<and>\n        wf_marking rt marka markb m \\<and>\n        (\\<forall>p.\n            p \\<notin> set_of rt \\<longrightarrow>\n            nexta p = nextb p) \\<longrightarrow>\n        (\\<exists>ll'.\n            Levellist (levellist[var p := p])\n             (nextb(p := levellist ! var p)) ll' \\<and>\n            wf_levellist (Node lt p rt) ll ll' var \\<and>\n            wf_marking (Node lt p rt) mark (markb(p := m)) m))", "from wfmarking_lt lt_Node lt"], ["proof (chain)\npicking this:\n  wf_marking lt mark marka m\n  lt = Node llt l rlt\n  Dag (low p) low high lt", "have mot_nc: \"\\<forall> n. n \\<notin> set_of lt \\<longrightarrow> mark n = marka n\""], ["proof (prove)\nusing this:\n  wf_marking lt mark marka m\n  lt = Node llt l rlt\n  Dag (low p) low high lt\n\ngoal (1 subgoal):\n 1. \\<forall>n. n \\<notin> set_of lt \\<longrightarrow> mark n = marka n", "by (simp add: wf_marking_def)"], ["proof (state)\nthis:\n  \\<forall>n. n \\<notin> set_of lt \\<longrightarrow> mark n = marka n\n\ngoal (1 subgoal):\n 1. (high p \\<noteq> Null \\<longrightarrow>\n     var (high p) < length levellista) \\<and>\n    ordered rt var \\<and>\n    (\\<forall>n\\<in>set_of rt.\n        if marka n = m\n        then n \\<in> set (lla ! var n) \\<and>\n             (\\<forall>nt p.\n                 Dag n low high nt \\<and>\n                 p \\<in> set_of nt \\<longrightarrow>\n                 marka p = m)\n        else n \\<notin> set (concat lla)) \\<and>\n    (\\<forall>markb nextb levellist llb.\n        Levellist levellist nextb llb \\<and>\n        wf_levellist rt lla llb var \\<and>\n        wf_marking rt marka markb m \\<and>\n        (\\<forall>p.\n            p \\<notin> set_of rt \\<longrightarrow>\n            nexta p = nextb p) \\<longrightarrow>\n        (\\<exists>ll'.\n            Levellist (levellist[var p := p])\n             (nextb(p := levellist ! var p)) ll' \\<and>\n            wf_levellist (Node lt p rt) ll ll' var \\<and>\n            wf_marking (Node lt p rt) mark (markb(p := m)) m))", "from wfmarking_lt lt_Node lt"], ["proof (chain)\npicking this:\n  wf_marking lt mark marka m\n  lt = Node llt l rlt\n  Dag (low p) low high lt", "have mit_marked: \"\\<forall>n. n \\<in> set_of lt \\<longrightarrow> marka n = m\""], ["proof (prove)\nusing this:\n  wf_marking lt mark marka m\n  lt = Node llt l rlt\n  Dag (low p) low high lt\n\ngoal (1 subgoal):\n 1. \\<forall>n. n \\<in> set_of lt \\<longrightarrow> marka n = m", "by (simp add: wf_marking_def)"], ["proof (state)\nthis:\n  \\<forall>n. n \\<in> set_of lt \\<longrightarrow> marka n = m\n\ngoal (1 subgoal):\n 1. (high p \\<noteq> Null \\<longrightarrow>\n     var (high p) < length levellista) \\<and>\n    ordered rt var \\<and>\n    (\\<forall>n\\<in>set_of rt.\n        if marka n = m\n        then n \\<in> set (lla ! var n) \\<and>\n             (\\<forall>nt p.\n                 Dag n low high nt \\<and>\n                 p \\<in> set_of nt \\<longrightarrow>\n                 marka p = m)\n        else n \\<notin> set (concat lla)) \\<and>\n    (\\<forall>markb nextb levellist llb.\n        Levellist levellist nextb llb \\<and>\n        wf_levellist rt lla llb var \\<and>\n        wf_marking rt marka markb m \\<and>\n        (\\<forall>p.\n            p \\<notin> set_of rt \\<longrightarrow>\n            nexta p = nextb p) \\<longrightarrow>\n        (\\<exists>ll'.\n            Levellist (levellist[var p := p])\n             (nextb(p := levellist ! var p)) ll' \\<and>\n            wf_levellist (Node lt p rt) ll ll' var \\<and>\n            wf_marking (Node lt p rt) mark (markb(p := m)) m))", "from marked_child_ll nodes_in_lla mot_nc mit_marked lla_st"], ["proof (chain)\npicking this:\n  \\<forall>n\\<in>set_of (Node lt p rt).\n     if mark n = m\n     then n \\<in> set (ll ! var n) \\<and>\n          (\\<forall>nt p.\n              Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n              mark p = m)\n     else n \\<notin> set (concat ll)\n  \\<forall>q. q \\<in> set_of lt \\<longrightarrow> q \\<in> set (lla ! var q)\n  \\<forall>n. n \\<notin> set_of lt \\<longrightarrow> mark n = marka n\n  \\<forall>n. n \\<in> set_of lt \\<longrightarrow> marka n = m\n  \\<forall>i\\<le>var (low p).\n     \\<exists>prx.\n        lla ! i = prx @ ll ! i \\<and>\n        (\\<forall>pt\\<in>set prx. pt \\<in> set_of lt \\<and> var pt = i)", "have mark_rt: \"\\<forall>n\\<in>set_of rt.\n               if marka n = m\n               then n \\<in> set (lla ! var n) \\<and>\n                   (\\<forall>nt p. Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow> marka p = m)\n               else n \\<notin> set (concat lla)\""], ["proof (prove)\nusing this:\n  \\<forall>n\\<in>set_of (Node lt p rt).\n     if mark n = m\n     then n \\<in> set (ll ! var n) \\<and>\n          (\\<forall>nt p.\n              Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n              mark p = m)\n     else n \\<notin> set (concat ll)\n  \\<forall>q. q \\<in> set_of lt \\<longrightarrow> q \\<in> set (lla ! var q)\n  \\<forall>n. n \\<notin> set_of lt \\<longrightarrow> mark n = marka n\n  \\<forall>n. n \\<in> set_of lt \\<longrightarrow> marka n = m\n  \\<forall>i\\<le>var (low p).\n     \\<exists>prx.\n        lla ! i = prx @ ll ! i \\<and>\n        (\\<forall>pt\\<in>set prx. pt \\<in> set_of lt \\<and> var pt = i)\n\ngoal (1 subgoal):\n 1. \\<forall>n\\<in>set_of rt.\n       if marka n = m\n       then n \\<in> set (lla ! var n) \\<and>\n            (\\<forall>nt p.\n                Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n                marka p = m)\n       else n \\<notin> set (concat lla)", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>n\\<in>set_of (Node lt p rt).\n                if mark n = m\n                then n \\<in> set (ll ! var n) \\<and>\n                     (\\<forall>nt p.\n                         Dag n low high nt \\<and>\n                         p \\<in> set_of nt \\<longrightarrow>\n                         mark p = m)\n                else n \\<notin> set (concat ll);\n     \\<forall>q.\n        q \\<in> set_of lt \\<longrightarrow> q \\<in> set (lla ! var q);\n     \\<forall>n. n \\<notin> set_of lt \\<longrightarrow> mark n = marka n;\n     \\<forall>n. n \\<in> set_of lt \\<longrightarrow> marka n = m;\n     \\<forall>i\\<le>var (low p).\n        \\<exists>prx.\n           lla ! i = prx @ ll ! i \\<and>\n           (\\<forall>pt\\<in>set prx.\n               pt \\<in> set_of lt \\<and> var pt = i)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>n\\<in>set_of rt.\n                         if marka n = m\n                         then n \\<in> set (lla ! var n) \\<and>\n                              (\\<forall>nt p.\n                                  Dag n low high nt \\<and>\n                                  p \\<in> set_of nt \\<longrightarrow>\n                                  marka p = m)\n                         else n \\<notin> set (concat lla)", "apply (rule ballI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>n\\<in>set_of (Node lt p rt).\n                   if mark n = m\n                   then n \\<in> set (ll ! var n) \\<and>\n                        (\\<forall>nt p.\n                            Dag n low high nt \\<and>\n                            p \\<in> set_of nt \\<longrightarrow>\n                            mark p = m)\n                   else n \\<notin> set (concat ll);\n        \\<forall>q.\n           q \\<in> set_of lt \\<longrightarrow> q \\<in> set (lla ! var q);\n        \\<forall>n. n \\<notin> set_of lt \\<longrightarrow> mark n = marka n;\n        \\<forall>n. n \\<in> set_of lt \\<longrightarrow> marka n = m;\n        \\<forall>i\\<le>var (low p).\n           \\<exists>prx.\n              lla ! i = prx @ ll ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  pt \\<in> set_of lt \\<and> var pt = i);\n        n \\<in> set_of rt\\<rbrakk>\n       \\<Longrightarrow> if marka n = m\n                         then n \\<in> set (lla ! var n) \\<and>\n                              (\\<forall>nt p.\n                                  Dag n low high nt \\<and>\n                                  p \\<in> set_of nt \\<longrightarrow>\n                                  marka p = m)\n                         else n \\<notin> set (concat lla)", "apply (drule_tac x=\"n\" in bspec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>q.\n                   q \\<in> set_of lt \\<longrightarrow>\n                   q \\<in> set (lla ! var q);\n        \\<forall>n. n \\<notin> set_of lt \\<longrightarrow> mark n = marka n;\n        \\<forall>n. n \\<in> set_of lt \\<longrightarrow> marka n = m;\n        \\<forall>i\\<le>var (low p).\n           \\<exists>prx.\n              lla ! i = prx @ ll ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  pt \\<in> set_of lt \\<and> var pt = i);\n        n \\<in> set_of rt\\<rbrakk>\n       \\<Longrightarrow> n \\<in> set_of (Node lt p rt)\n 2. \\<And>n.\n       \\<lbrakk>\\<forall>q.\n                   q \\<in> set_of lt \\<longrightarrow>\n                   q \\<in> set (lla ! var q);\n        \\<forall>n. n \\<notin> set_of lt \\<longrightarrow> mark n = marka n;\n        \\<forall>n. n \\<in> set_of lt \\<longrightarrow> marka n = m;\n        \\<forall>i\\<le>var (low p).\n           \\<exists>prx.\n              lla ! i = prx @ ll ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  pt \\<in> set_of lt \\<and> var pt = i);\n        n \\<in> set_of rt;\n        if mark n = m\n        then n \\<in> set (ll ! var n) \\<and>\n             (\\<forall>nt p.\n                 Dag n low high nt \\<and>\n                 p \\<in> set_of nt \\<longrightarrow>\n                 mark p = m)\n        else n \\<notin> set (concat ll)\\<rbrakk>\n       \\<Longrightarrow> if marka n = m\n                         then n \\<in> set (lla ! var n) \\<and>\n                              (\\<forall>nt p.\n                                  Dag n low high nt \\<and>\n                                  p \\<in> set_of nt \\<longrightarrow>\n                                  marka p = m)\n                         else n \\<notin> set (concat lla)", "apply (simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>q.\n                   q \\<in> set_of lt \\<longrightarrow>\n                   q \\<in> set (lla ! var q);\n        \\<forall>n. n \\<notin> set_of lt \\<longrightarrow> mark n = marka n;\n        \\<forall>n. n \\<in> set_of lt \\<longrightarrow> marka n = m;\n        \\<forall>i\\<le>var (low p).\n           \\<exists>prx.\n              lla ! i = prx @ ll ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  pt \\<in> set_of lt \\<and> var pt = i);\n        n \\<in> set_of rt;\n        if mark n = m\n        then n \\<in> set (ll ! var n) \\<and>\n             (\\<forall>nt p.\n                 Dag n low high nt \\<and>\n                 p \\<in> set_of nt \\<longrightarrow>\n                 mark p = m)\n        else n \\<notin> set (concat ll)\\<rbrakk>\n       \\<Longrightarrow> if marka n = m\n                         then n \\<in> set (lla ! var n) \\<and>\n                              (\\<forall>nt p.\n                                  Dag n low high nt \\<and>\n                                  p \\<in> set_of nt \\<longrightarrow>\n                                  marka p = m)\n                         else n \\<notin> set (concat lla)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>q.\n                   q \\<in> set_of lt \\<longrightarrow>\n                   q \\<in> set (lla ! var q);\n        \\<forall>n. n \\<notin> set_of lt \\<longrightarrow> mark n = marka n;\n        \\<forall>n. n \\<in> set_of lt \\<longrightarrow> marka n = m;\n        \\<forall>i\\<le>var (low p).\n           \\<exists>prx.\n              lla ! i = prx @ ll ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  pt \\<in> set_of lt \\<and> var pt = i);\n        n \\<in> set_of rt;\n        if mark n = m\n        then n \\<in> set (ll ! var n) \\<and>\n             (\\<forall>nt p.\n                 Dag n low high nt \\<and>\n                 p \\<in> set_of nt \\<longrightarrow>\n                 mark p = m)\n        else n \\<notin> set (concat ll)\\<rbrakk>\n       \\<Longrightarrow> if marka n = m\n                         then n \\<in> set (lla ! var n) \\<and>\n                              (\\<forall>nt p.\n                                  Dag n low high nt \\<and>\n                                  p \\<in> set_of nt \\<longrightarrow>\n                                  marka p = m)\n                         else n \\<notin> set (concat lla)", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>q.\n                   q \\<in> set_of lt \\<longrightarrow>\n                   q \\<in> set (lla ! var q);\n        \\<forall>n. n \\<notin> set_of lt \\<longrightarrow> mark n = marka n;\n        \\<forall>n. n \\<in> set_of lt \\<longrightarrow> marka n = m;\n        \\<forall>i\\<le>var (low p).\n           \\<exists>prx.\n              lla ! i = prx @ ll ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  pt \\<in> set_of lt \\<and> var pt = i);\n        n \\<in> set_of rt;\n        if mark n = m\n        then n \\<in> set (ll ! var n) \\<and>\n             (\\<forall>nt p.\n                 Dag n low high nt \\<and>\n                 p \\<in> set_of nt \\<longrightarrow>\n                 mark p = m)\n        else n \\<notin> set (concat ll)\\<rbrakk>\n       \\<Longrightarrow> if marka n = m\n                         then n \\<in> set (lla ! var n) \\<and>\n                              (\\<forall>nt p.\n                                  Dag n low high nt \\<and>\n                                  p \\<in> set_of nt \\<longrightarrow>\n                                  marka p = m)\n                         else n \\<notin> set (concat lla)", "assume nodes_in_lla: \"\\<forall>q. q \\<in> set_of lt \\<longrightarrow> q \\<in> set (lla ! var q)\""], ["proof (state)\nthis:\n  \\<forall>q. q \\<in> set_of lt \\<longrightarrow> q \\<in> set (lla ! var q)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>q.\n                   q \\<in> set_of lt \\<longrightarrow>\n                   q \\<in> set (lla ! var q);\n        \\<forall>n. n \\<notin> set_of lt \\<longrightarrow> mark n = marka n;\n        \\<forall>n. n \\<in> set_of lt \\<longrightarrow> marka n = m;\n        \\<forall>i\\<le>var (low p).\n           \\<exists>prx.\n              lla ! i = prx @ ll ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  pt \\<in> set_of lt \\<and> var pt = i);\n        n \\<in> set_of rt;\n        if mark n = m\n        then n \\<in> set (ll ! var n) \\<and>\n             (\\<forall>nt p.\n                 Dag n low high nt \\<and>\n                 p \\<in> set_of nt \\<longrightarrow>\n                 mark p = m)\n        else n \\<notin> set (concat ll)\\<rbrakk>\n       \\<Longrightarrow> if marka n = m\n                         then n \\<in> set (lla ! var n) \\<and>\n                              (\\<forall>nt p.\n                                  Dag n low high nt \\<and>\n                                  p \\<in> set_of nt \\<longrightarrow>\n                                  marka p = m)\n                         else n \\<notin> set (concat lla)", "assume mot_nc: \"\\<forall>n. n \\<notin> set_of lt \\<longrightarrow> mark n = marka n\""], ["proof (state)\nthis:\n  \\<forall>n. n \\<notin> set_of lt \\<longrightarrow> mark n = marka n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>q.\n                   q \\<in> set_of lt \\<longrightarrow>\n                   q \\<in> set (lla ! var q);\n        \\<forall>n. n \\<notin> set_of lt \\<longrightarrow> mark n = marka n;\n        \\<forall>n. n \\<in> set_of lt \\<longrightarrow> marka n = m;\n        \\<forall>i\\<le>var (low p).\n           \\<exists>prx.\n              lla ! i = prx @ ll ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  pt \\<in> set_of lt \\<and> var pt = i);\n        n \\<in> set_of rt;\n        if mark n = m\n        then n \\<in> set (ll ! var n) \\<and>\n             (\\<forall>nt p.\n                 Dag n low high nt \\<and>\n                 p \\<in> set_of nt \\<longrightarrow>\n                 mark p = m)\n        else n \\<notin> set (concat ll)\\<rbrakk>\n       \\<Longrightarrow> if marka n = m\n                         then n \\<in> set (lla ! var n) \\<and>\n                              (\\<forall>nt p.\n                                  Dag n low high nt \\<and>\n                                  p \\<in> set_of nt \\<longrightarrow>\n                                  marka p = m)\n                         else n \\<notin> set (concat lla)", "assume mit_marked: \"\\<forall>n. n \\<in> set_of lt \\<longrightarrow> marka n = m\""], ["proof (state)\nthis:\n  \\<forall>n. n \\<in> set_of lt \\<longrightarrow> marka n = m\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>q.\n                   q \\<in> set_of lt \\<longrightarrow>\n                   q \\<in> set (lla ! var q);\n        \\<forall>n. n \\<notin> set_of lt \\<longrightarrow> mark n = marka n;\n        \\<forall>n. n \\<in> set_of lt \\<longrightarrow> marka n = m;\n        \\<forall>i\\<le>var (low p).\n           \\<exists>prx.\n              lla ! i = prx @ ll ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  pt \\<in> set_of lt \\<and> var pt = i);\n        n \\<in> set_of rt;\n        if mark n = m\n        then n \\<in> set (ll ! var n) \\<and>\n             (\\<forall>nt p.\n                 Dag n low high nt \\<and>\n                 p \\<in> set_of nt \\<longrightarrow>\n                 mark p = m)\n        else n \\<notin> set (concat ll)\\<rbrakk>\n       \\<Longrightarrow> if marka n = m\n                         then n \\<in> set (lla ! var n) \\<and>\n                              (\\<forall>nt p.\n                                  Dag n low high nt \\<and>\n                                  p \\<in> set_of nt \\<longrightarrow>\n                                  marka p = m)\n                         else n \\<notin> set (concat lla)", "assume marked_child_ll: \"if mark n = m\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt p. Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow> mark p = m)\n           else n \\<notin> set (concat ll)\""], ["proof (state)\nthis:\n  if mark n = m\n  then n \\<in> set (ll ! var n) \\<and>\n       (\\<forall>nt p.\n           Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n           mark p = m)\n  else n \\<notin> set (concat ll)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>q.\n                   q \\<in> set_of lt \\<longrightarrow>\n                   q \\<in> set (lla ! var q);\n        \\<forall>n. n \\<notin> set_of lt \\<longrightarrow> mark n = marka n;\n        \\<forall>n. n \\<in> set_of lt \\<longrightarrow> marka n = m;\n        \\<forall>i\\<le>var (low p).\n           \\<exists>prx.\n              lla ! i = prx @ ll ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  pt \\<in> set_of lt \\<and> var pt = i);\n        n \\<in> set_of rt;\n        if mark n = m\n        then n \\<in> set (ll ! var n) \\<and>\n             (\\<forall>nt p.\n                 Dag n low high nt \\<and>\n                 p \\<in> set_of nt \\<longrightarrow>\n                 mark p = m)\n        else n \\<notin> set (concat ll)\\<rbrakk>\n       \\<Longrightarrow> if marka n = m\n                         then n \\<in> set (lla ! var n) \\<and>\n                              (\\<forall>nt p.\n                                  Dag n low high nt \\<and>\n                                  p \\<in> set_of nt \\<longrightarrow>\n                                  marka p = m)\n                         else n \\<notin> set (concat lla)", "assume lla_st: \"\\<forall>i\\<le>var (low p).\n                               \\<exists>prx. lla ! i = prx @ ll ! i \\<and>\n                               (\\<forall>pt\\<in>set prx. pt \\<in> set_of lt \\<and> var pt = i)\""], ["proof (state)\nthis:\n  \\<forall>i\\<le>var (low p).\n     \\<exists>prx.\n        lla ! i = prx @ ll ! i \\<and>\n        (\\<forall>pt\\<in>set prx. pt \\<in> set_of lt \\<and> var pt = i)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>q.\n                   q \\<in> set_of lt \\<longrightarrow>\n                   q \\<in> set (lla ! var q);\n        \\<forall>n. n \\<notin> set_of lt \\<longrightarrow> mark n = marka n;\n        \\<forall>n. n \\<in> set_of lt \\<longrightarrow> marka n = m;\n        \\<forall>i\\<le>var (low p).\n           \\<exists>prx.\n              lla ! i = prx @ ll ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  pt \\<in> set_of lt \\<and> var pt = i);\n        n \\<in> set_of rt;\n        if mark n = m\n        then n \\<in> set (ll ! var n) \\<and>\n             (\\<forall>nt p.\n                 Dag n low high nt \\<and>\n                 p \\<in> set_of nt \\<longrightarrow>\n                 mark p = m)\n        else n \\<notin> set (concat ll)\\<rbrakk>\n       \\<Longrightarrow> if marka n = m\n                         then n \\<in> set (lla ! var n) \\<and>\n                              (\\<forall>nt p.\n                                  Dag n low high nt \\<and>\n                                  p \\<in> set_of nt \\<longrightarrow>\n                                  marka p = m)\n                         else n \\<notin> set (concat lla)", "assume n_in_rt: \" n \\<in> set_of rt\""], ["proof (state)\nthis:\n  n \\<in> set_of rt\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>q.\n                   q \\<in> set_of lt \\<longrightarrow>\n                   q \\<in> set (lla ! var q);\n        \\<forall>n. n \\<notin> set_of lt \\<longrightarrow> mark n = marka n;\n        \\<forall>n. n \\<in> set_of lt \\<longrightarrow> marka n = m;\n        \\<forall>i\\<le>var (low p).\n           \\<exists>prx.\n              lla ! i = prx @ ll ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  pt \\<in> set_of lt \\<and> var pt = i);\n        n \\<in> set_of rt;\n        if mark n = m\n        then n \\<in> set (ll ! var n) \\<and>\n             (\\<forall>nt p.\n                 Dag n low high nt \\<and>\n                 p \\<in> set_of nt \\<longrightarrow>\n                 mark p = m)\n        else n \\<notin> set (concat ll)\\<rbrakk>\n       \\<Longrightarrow> if marka n = m\n                         then n \\<in> set (lla ! var n) \\<and>\n                              (\\<forall>nt p.\n                                  Dag n low high nt \\<and>\n                                  p \\<in> set_of nt \\<longrightarrow>\n                                  marka p = m)\n                         else n \\<notin> set (concat lla)", "show n_in_lla_marked: \"if marka n = m\n             then n \\<in> set (lla ! var n) \\<and>\n                  (\\<forall>nt p. Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow> marka p = m)\n             else n \\<notin> set (concat lla)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)", "proof (cases \"n \\<in> set_of lt\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n \\<in> set_of lt \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)\n 2. n \\<notin> set_of lt \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)", "case True"], ["proof (state)\nthis:\n  n \\<in> set_of lt\n\ngoal (2 subgoals):\n 1. n \\<in> set_of lt \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)\n 2. n \\<notin> set_of lt \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)", "from True nodes_in_lla"], ["proof (chain)\npicking this:\n  n \\<in> set_of lt\n  \\<forall>q. q \\<in> set_of lt \\<longrightarrow> q \\<in> set (lla ! var q)", "have n_in_ll: \"n \\<in> set (lla ! var n)\""], ["proof (prove)\nusing this:\n  n \\<in> set_of lt\n  \\<forall>q. q \\<in> set_of lt \\<longrightarrow> q \\<in> set (lla ! var q)\n\ngoal (1 subgoal):\n 1. n \\<in> set (lla ! var n)", "by simp"], ["proof (state)\nthis:\n  n \\<in> set (lla ! var n)\n\ngoal (2 subgoals):\n 1. n \\<in> set_of lt \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)\n 2. n \\<notin> set_of lt \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)", "moreover"], ["proof (state)\nthis:\n  n \\<in> set (lla ! var n)\n\ngoal (2 subgoals):\n 1. n \\<in> set_of lt \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)\n 2. n \\<notin> set_of lt \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)", "from True wfmarking_lt"], ["proof (chain)\npicking this:\n  n \\<in> set_of lt\n  wf_marking lt mark marka m", "have \"marka n = m\""], ["proof (prove)\nusing this:\n  n \\<in> set_of lt\n  wf_marking lt mark marka m\n\ngoal (1 subgoal):\n 1. marka n = m", "apply (cases lt)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>n \\<in> set_of lt; wf_marking lt mark marka m;\n     lt = Tip\\<rbrakk>\n    \\<Longrightarrow> marka n = m\n 2. \\<And>x21 x22 x23.\n       \\<lbrakk>n \\<in> set_of lt; wf_marking lt mark marka m;\n        lt = Node x21 x22 x23\\<rbrakk>\n       \\<Longrightarrow> marka n = m", "apply (auto simp add: wf_marking_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  marka n = m\n\ngoal (2 subgoals):\n 1. n \\<in> set_of lt \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)\n 2. n \\<notin> set_of lt \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)", "moreover"], ["proof (state)\nthis:\n  marka n = m\n\ngoal (2 subgoals):\n 1. n \\<in> set_of lt \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)\n 2. n \\<notin> set_of lt \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)", "{"], ["proof (state)\nthis:\n  marka n = m\n\ngoal (2 subgoals):\n 1. n \\<in> set_of lt \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)\n 2. n \\<notin> set_of lt \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)", "fix nt p"], ["proof (state)\ngoal (2 subgoals):\n 1. n \\<in> set_of lt \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)\n 2. n \\<notin> set_of lt \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)", "assume \"Dag n low high nt\""], ["proof (state)\nthis:\n  Dag n low high nt\n\ngoal (2 subgoals):\n 1. n \\<in> set_of lt \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)\n 2. n \\<notin> set_of lt \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)", "with lt True"], ["proof (chain)\npicking this:\n  Dag (low p__) low high lt\n  n \\<in> set_of lt\n  Dag n low high nt", "have subset_nt_lt: \"set_of nt \\<subseteq> set_of lt\""], ["proof (prove)\nusing this:\n  Dag (low p__) low high lt\n  n \\<in> set_of lt\n  Dag n low high nt\n\ngoal (1 subgoal):\n 1. set_of nt \\<subseteq> set_of lt", "by (rule dag_setof_subsetD)"], ["proof (state)\nthis:\n  set_of nt \\<subseteq> set_of lt\n\ngoal (2 subgoals):\n 1. n \\<in> set_of lt \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)\n 2. n \\<notin> set_of lt \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)", "moreover"], ["proof (state)\nthis:\n  set_of nt \\<subseteq> set_of lt\n\ngoal (2 subgoals):\n 1. n \\<in> set_of lt \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)\n 2. n \\<notin> set_of lt \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)", "assume \" p \\<in> set_of nt\""], ["proof (state)\nthis:\n  p \\<in> set_of nt\n\ngoal (2 subgoals):\n 1. n \\<in> set_of lt \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)\n 2. n \\<notin> set_of lt \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)", "ultimately"], ["proof (chain)\npicking this:\n  set_of nt \\<subseteq> set_of lt\n  p \\<in> set_of nt", "have \"p \\<in> set_of lt\""], ["proof (prove)\nusing this:\n  set_of nt \\<subseteq> set_of lt\n  p \\<in> set_of nt\n\ngoal (1 subgoal):\n 1. p \\<in> set_of lt", "by blast"], ["proof (state)\nthis:\n  p \\<in> set_of lt\n\ngoal (2 subgoals):\n 1. n \\<in> set_of lt \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)\n 2. n \\<notin> set_of lt \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)", "with mit_marked"], ["proof (chain)\npicking this:\n  \\<forall>n. n \\<in> set_of lt \\<longrightarrow> marka n = m\n  p \\<in> set_of lt", "have \" marka p = m\""], ["proof (prove)\nusing this:\n  \\<forall>n. n \\<in> set_of lt \\<longrightarrow> marka n = m\n  p \\<in> set_of lt\n\ngoal (1 subgoal):\n 1. marka p = m", "by simp"], ["proof (state)\nthis:\n  marka p = m\n\ngoal (2 subgoals):\n 1. n \\<in> set_of lt \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)\n 2. n \\<notin> set_of lt \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>Dag n low high ?nt3; ?pa3 \\<in> set_of ?nt3\\<rbrakk>\n  \\<Longrightarrow> marka ?pa3 = m\n\ngoal (2 subgoals):\n 1. n \\<in> set_of lt \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)\n 2. n \\<notin> set_of lt \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)", "ultimately"], ["proof (chain)\npicking this:\n  n \\<in> set (lla ! var n)\n  marka n = m\n  \\<lbrakk>Dag n low high ?nt3; ?pa3 \\<in> set_of ?nt3\\<rbrakk>\n  \\<Longrightarrow> marka ?pa3 = m", "show ?thesis"], ["proof (prove)\nusing this:\n  n \\<in> set (lla ! var n)\n  marka n = m\n  \\<lbrakk>Dag n low high ?nt3; ?pa3 \\<in> set_of ?nt3\\<rbrakk>\n  \\<Longrightarrow> marka ?pa3 = m\n\ngoal (1 subgoal):\n 1. if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)", "using n_in_rt"], ["proof (prove)\nusing this:\n  n \\<in> set (lla ! var n)\n  marka n = m\n  \\<lbrakk>Dag n low high ?nt3; ?pa3 \\<in> set_of ?nt3\\<rbrakk>\n  \\<Longrightarrow> marka ?pa3 = m\n  n \\<in> set_of rt\n\ngoal (1 subgoal):\n 1. if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)", "apply clarsimp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  if marka n = m\n  then n \\<in> set (lla ! var n) \\<and>\n       (\\<forall>nt p.\n           Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n           marka p = m)\n  else n \\<notin> set (concat lla)\n\ngoal (1 subgoal):\n 1. n \\<notin> set_of lt \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<notin> set_of lt \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)", "assume n_notin_lt: \"n \\<notin> set_of lt\""], ["proof (state)\nthis:\n  n \\<notin> set_of lt\n\ngoal (1 subgoal):\n 1. n \\<notin> set_of lt \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)", "proof (cases \"marka n = m\")"], ["proof (state)\ngoal (2 subgoals):\n 1. marka n = m \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)\n 2. marka n \\<noteq> m \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)", "case True"], ["proof (state)\nthis:\n  marka n = m\n\ngoal (2 subgoals):\n 1. marka n = m \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)\n 2. marka n \\<noteq> m \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)", "from n_notin_lt mot_nc"], ["proof (chain)\npicking this:\n  n \\<notin> set_of lt\n  \\<forall>n. n \\<notin> set_of lt \\<longrightarrow> mark n = marka n", "have marka_eq_mark: \"mark n = marka n\""], ["proof (prove)\nusing this:\n  n \\<notin> set_of lt\n  \\<forall>n. n \\<notin> set_of lt \\<longrightarrow> mark n = marka n\n\ngoal (1 subgoal):\n 1. mark n = marka n", "by simp"], ["proof (state)\nthis:\n  mark n = marka n\n\ngoal (2 subgoals):\n 1. marka n = m \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)\n 2. marka n \\<noteq> m \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)", "from marka_eq_mark True"], ["proof (chain)\npicking this:\n  mark n = marka n\n  marka n = m", "have n_marked: \"mark n = m\""], ["proof (prove)\nusing this:\n  mark n = marka n\n  marka n = m\n\ngoal (1 subgoal):\n 1. mark n = m", "by simp"], ["proof (state)\nthis:\n  mark n = m\n\ngoal (2 subgoals):\n 1. marka n = m \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)\n 2. marka n \\<noteq> m \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)", "from rt n_in_rt"], ["proof (chain)\npicking this:\n  Dag (high p) low high rt\n  n \\<in> set_of rt", "have nnN: \"n \\<noteq> Null\""], ["proof (prove)\nusing this:\n  Dag (high p) low high rt\n  n \\<in> set_of rt\n\ngoal (1 subgoal):\n 1. n \\<noteq> Null", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Dag (high p) low high rt; n \\<in> set_of rt\\<rbrakk>\n    \\<Longrightarrow> n \\<noteq> Null", "apply (rule set_of_nn [rule_format])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Dag (high p) low high rt; n \\<in> set_of rt\\<rbrakk>\n    \\<Longrightarrow> Dag ?p2 ?low2 ?high2 ?t2\n 2. \\<lbrakk>Dag (high p) low high rt; n \\<in> set_of rt\\<rbrakk>\n    \\<Longrightarrow> n \\<in> set_of ?t2", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Dag (high p) low high rt; n \\<in> set_of rt\\<rbrakk>\n    \\<Longrightarrow> n \\<in> set_of rt", "apply assumption"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  n \\<noteq> Null\n\ngoal (2 subgoals):\n 1. marka n = m \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)\n 2. marka n \\<noteq> m \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)", "from marked_child_ll n_in_rt marka_eq_mark nnN n_marked"], ["proof (chain)\npicking this:\n  if mark n = m\n  then n \\<in> set (ll ! var n) \\<and>\n       (\\<forall>nt p.\n           Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n           mark p = m)\n  else n \\<notin> set (concat ll)\n  n \\<in> set_of rt\n  mark n = marka n\n  n \\<noteq> Null\n  mark n = m", "have n_in_ll: \"n \\<in> set (ll ! var n)\""], ["proof (prove)\nusing this:\n  if mark n = m\n  then n \\<in> set (ll ! var n) \\<and>\n       (\\<forall>nt p.\n           Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n           mark p = m)\n  else n \\<notin> set (concat ll)\n  n \\<in> set_of rt\n  mark n = marka n\n  n \\<noteq> Null\n  mark n = m\n\ngoal (1 subgoal):\n 1. n \\<in> set (ll ! var n)", "by fastforce"], ["proof (state)\nthis:\n  n \\<in> set (ll ! var n)\n\ngoal (2 subgoals):\n 1. marka n = m \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)\n 2. marka n \\<noteq> m \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)", "from marked_child_ll n_in_rt marka_eq_mark nnN n_marked lt rt"], ["proof (chain)\npicking this:\n  if mark n = m\n  then n \\<in> set (ll ! var n) \\<and>\n       (\\<forall>nt p.\n           Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n           mark p = m)\n  else n \\<notin> set (concat ll)\n  n \\<in> set_of rt\n  mark n = marka n\n  n \\<noteq> Null\n  mark n = m\n  Dag (low p) low high lt\n  Dag (high p) low high rt", "have nt_mark: \"\\<forall>nt p. Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow> mark p = m\""], ["proof (prove)\nusing this:\n  if mark n = m\n  then n \\<in> set (ll ! var n) \\<and>\n       (\\<forall>nt p.\n           Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n           mark p = m)\n  else n \\<notin> set (concat ll)\n  n \\<in> set_of rt\n  mark n = marka n\n  n \\<noteq> Null\n  mark n = m\n  Dag (low p) low high lt\n  Dag (high p) low high rt\n\ngoal (1 subgoal):\n 1. \\<forall>nt p.\n       Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n       mark p = m", "by simp"], ["proof (state)\nthis:\n  \\<forall>nt p.\n     Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow> mark p = m\n\ngoal (2 subgoals):\n 1. marka n = m \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)\n 2. marka n \\<noteq> m \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)", "from nodes_in_lla n_in_ll lla_st"], ["proof (chain)\npicking this:\n  \\<forall>q. q \\<in> set_of lt \\<longrightarrow> q \\<in> set (lla ! var q)\n  n \\<in> set (ll ! var n)\n  \\<forall>i\\<le>var (low p).\n     \\<exists>prx.\n        lla ! i = prx @ ll ! i \\<and>\n        (\\<forall>pt\\<in>set prx. pt \\<in> set_of lt \\<and> var pt = i)", "have n_in_lla: \"n \\<in> set (lla ! var n)\""], ["proof (prove)\nusing this:\n  \\<forall>q. q \\<in> set_of lt \\<longrightarrow> q \\<in> set (lla ! var q)\n  n \\<in> set (ll ! var n)\n  \\<forall>i\\<le>var (low p).\n     \\<exists>prx.\n        lla ! i = prx @ ll ! i \\<and>\n        (\\<forall>pt\\<in>set prx. pt \\<in> set_of lt \\<and> var pt = i)\n\ngoal (1 subgoal):\n 1. n \\<in> set (lla ! var n)", "proof (cases \"var (low p) < (var n)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>q.\n                q \\<in> set_of lt \\<longrightarrow>\n                q \\<in> set (lla ! var q);\n     n \\<in> set (ll ! var n);\n     \\<forall>i\\<le>var (low p).\n        \\<exists>prx.\n           lla ! i = prx @ ll ! i \\<and>\n           (\\<forall>pt\\<in>set prx. pt \\<in> set_of lt \\<and> var pt = i);\n     var (low p) < var n\\<rbrakk>\n    \\<Longrightarrow> n \\<in> set (lla ! var n)\n 2. \\<lbrakk>\\<forall>q.\n                q \\<in> set_of lt \\<longrightarrow>\n                q \\<in> set (lla ! var q);\n     n \\<in> set (ll ! var n);\n     \\<forall>i\\<le>var (low p).\n        \\<exists>prx.\n           lla ! i = prx @ ll ! i \\<and>\n           (\\<forall>pt\\<in>set prx. pt \\<in> set_of lt \\<and> var pt = i);\n     \\<not> var (low p) < var n\\<rbrakk>\n    \\<Longrightarrow> n \\<in> set (lla ! var n)", "case True"], ["proof (state)\nthis:\n  var (low p) < var n\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>q.\n                q \\<in> set_of lt \\<longrightarrow>\n                q \\<in> set (lla ! var q);\n     n \\<in> set (ll ! var n);\n     \\<forall>i\\<le>var (low p).\n        \\<exists>prx.\n           lla ! i = prx @ ll ! i \\<and>\n           (\\<forall>pt\\<in>set prx. pt \\<in> set_of lt \\<and> var pt = i);\n     var (low p) < var n\\<rbrakk>\n    \\<Longrightarrow> n \\<in> set (lla ! var n)\n 2. \\<lbrakk>\\<forall>q.\n                q \\<in> set_of lt \\<longrightarrow>\n                q \\<in> set (lla ! var q);\n     n \\<in> set (ll ! var n);\n     \\<forall>i\\<le>var (low p).\n        \\<exists>prx.\n           lla ! i = prx @ ll ! i \\<and>\n           (\\<forall>pt\\<in>set prx. pt \\<in> set_of lt \\<and> var pt = i);\n     \\<not> var (low p) < var n\\<rbrakk>\n    \\<Longrightarrow> n \\<in> set (lla ! var n)", "with lla_nc"], ["proof (chain)\npicking this:\n  \\<forall>i>var (low p). lla ! i = ll ! i\n  var (low p) < var n", "have \"(lla ! var n) = (ll ! var n)\""], ["proof (prove)\nusing this:\n  \\<forall>i>var (low p). lla ! i = ll ! i\n  var (low p) < var n\n\ngoal (1 subgoal):\n 1. lla ! var n = ll ! var n", "by fastforce"], ["proof (state)\nthis:\n  lla ! var n = ll ! var n\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>q.\n                q \\<in> set_of lt \\<longrightarrow>\n                q \\<in> set (lla ! var q);\n     n \\<in> set (ll ! var n);\n     \\<forall>i\\<le>var (low p).\n        \\<exists>prx.\n           lla ! i = prx @ ll ! i \\<and>\n           (\\<forall>pt\\<in>set prx. pt \\<in> set_of lt \\<and> var pt = i);\n     var (low p) < var n\\<rbrakk>\n    \\<Longrightarrow> n \\<in> set (lla ! var n)\n 2. \\<lbrakk>\\<forall>q.\n                q \\<in> set_of lt \\<longrightarrow>\n                q \\<in> set (lla ! var q);\n     n \\<in> set (ll ! var n);\n     \\<forall>i\\<le>var (low p).\n        \\<exists>prx.\n           lla ! i = prx @ ll ! i \\<and>\n           (\\<forall>pt\\<in>set prx. pt \\<in> set_of lt \\<and> var pt = i);\n     \\<not> var (low p) < var n\\<rbrakk>\n    \\<Longrightarrow> n \\<in> set (lla ! var n)", "with n_in_ll"], ["proof (chain)\npicking this:\n  n \\<in> set (ll ! var n)\n  lla ! var n = ll ! var n", "show ?thesis"], ["proof (prove)\nusing this:\n  n \\<in> set (ll ! var n)\n  lla ! var n = ll ! var n\n\ngoal (1 subgoal):\n 1. n \\<in> set (lla ! var n)", "by fastforce"], ["proof (state)\nthis:\n  n \\<in> set (lla ! var n)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>q.\n                q \\<in> set_of lt \\<longrightarrow>\n                q \\<in> set (lla ! var q);\n     n \\<in> set (ll ! var n);\n     \\<forall>i\\<le>var (low p).\n        \\<exists>prx.\n           lla ! i = prx @ ll ! i \\<and>\n           (\\<forall>pt\\<in>set prx. pt \\<in> set_of lt \\<and> var pt = i);\n     \\<not> var (low p) < var n\\<rbrakk>\n    \\<Longrightarrow> n \\<in> set (lla ! var n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>q.\n                q \\<in> set_of lt \\<longrightarrow>\n                q \\<in> set (lla ! var q);\n     n \\<in> set (ll ! var n);\n     \\<forall>i\\<le>var (low p).\n        \\<exists>prx.\n           lla ! i = prx @ ll ! i \\<and>\n           (\\<forall>pt\\<in>set prx. pt \\<in> set_of lt \\<and> var pt = i);\n     \\<not> var (low p) < var n\\<rbrakk>\n    \\<Longrightarrow> n \\<in> set (lla ! var n)", "assume varnslp: \" \\<not> var (low p) < var n\""], ["proof (state)\nthis:\n  \\<not> var (low p) < var n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>q.\n                q \\<in> set_of lt \\<longrightarrow>\n                q \\<in> set (lla ! var q);\n     n \\<in> set (ll ! var n);\n     \\<forall>i\\<le>var (low p).\n        \\<exists>prx.\n           lla ! i = prx @ ll ! i \\<and>\n           (\\<forall>pt\\<in>set prx. pt \\<in> set_of lt \\<and> var pt = i);\n     \\<not> var (low p) < var n\\<rbrakk>\n    \\<Longrightarrow> n \\<in> set (lla ! var n)", "with lla_st"], ["proof (chain)\npicking this:\n  \\<forall>i\\<le>var (low p).\n     \\<exists>prx.\n        lla ! i = prx @ ll ! i \\<and>\n        (\\<forall>pt\\<in>set prx. pt \\<in> set_of lt \\<and> var pt = i)\n  \\<not> var (low p) < var n", "have ll_in_lla: \"\\<exists>prx. lla ! (var n) = prx @ ll ! (var n)\""], ["proof (prove)\nusing this:\n  \\<forall>i\\<le>var (low p).\n     \\<exists>prx.\n        lla ! i = prx @ ll ! i \\<and>\n        (\\<forall>pt\\<in>set prx. pt \\<in> set_of lt \\<and> var pt = i)\n  \\<not> var (low p) < var n\n\ngoal (1 subgoal):\n 1. \\<exists>prx. lla ! var n = prx @ ll ! var n", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i\\<le>var (low p).\n                \\<exists>prx.\n                   lla ! i = prx @ ll ! i \\<and>\n                   (\\<forall>pt\\<in>set prx.\n                       pt \\<in> set_of lt \\<and> var pt = i);\n     \\<not> var (low p) < var n\\<rbrakk>\n    \\<Longrightarrow> \\<exists>prx. lla ! var n = prx @ ll ! var n", "apply (erule_tac x=\"var n\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> var (low p) < var n;\n     var n \\<le> var (low p) \\<longrightarrow>\n     (\\<exists>prx.\n         lla ! var n = prx @ ll ! var n \\<and>\n         (\\<forall>pt\\<in>set prx.\n             pt \\<in> set_of lt \\<and> var pt = var n))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>prx. lla ! var n = prx @ ll ! var n", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>prx. lla ! var n = prx @ ll ! var n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>q.\n                q \\<in> set_of lt \\<longrightarrow>\n                q \\<in> set (lla ! var q);\n     n \\<in> set (ll ! var n);\n     \\<forall>i\\<le>var (low p).\n        \\<exists>prx.\n           lla ! i = prx @ ll ! i \\<and>\n           (\\<forall>pt\\<in>set prx. pt \\<in> set_of lt \\<and> var pt = i);\n     \\<not> var (low p) < var n\\<rbrakk>\n    \\<Longrightarrow> n \\<in> set (lla ! var n)", "with n_in_ll"], ["proof (chain)\npicking this:\n  n \\<in> set (ll ! var n)\n  \\<exists>prx. lla ! var n = prx @ ll ! var n", "show ?thesis"], ["proof (prove)\nusing this:\n  n \\<in> set (ll ! var n)\n  \\<exists>prx. lla ! var n = prx @ ll ! var n\n\ngoal (1 subgoal):\n 1. n \\<in> set (lla ! var n)", "by fastforce"], ["proof (state)\nthis:\n  n \\<in> set (lla ! var n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n \\<in> set (lla ! var n)\n\ngoal (2 subgoals):\n 1. marka n = m \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)\n 2. marka n \\<noteq> m \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)", "{"], ["proof (state)\nthis:\n  n \\<in> set (lla ! var n)\n\ngoal (2 subgoals):\n 1. marka n = m \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)\n 2. marka n \\<noteq> m \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)", "fix nt pt"], ["proof (state)\ngoal (2 subgoals):\n 1. marka n = m \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)\n 2. marka n \\<noteq> m \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)", "assume nt_Dag: \"Dag n low high nt\""], ["proof (state)\nthis:\n  Dag n low high nt\n\ngoal (2 subgoals):\n 1. marka n = m \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)\n 2. marka n \\<noteq> m \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)", "assume pt_in_nt: \"pt \\<in> set_of nt\""], ["proof (state)\nthis:\n  pt \\<in> set_of nt\n\ngoal (2 subgoals):\n 1. marka n = m \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)\n 2. marka n \\<noteq> m \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)", "have \" marka pt = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. marka pt = m", "proof (cases \"pt \\<in> set_of lt\")"], ["proof (state)\ngoal (2 subgoals):\n 1. pt \\<in> set_of lt \\<Longrightarrow> marka pt = m\n 2. pt \\<notin> set_of lt \\<Longrightarrow> marka pt = m", "case True"], ["proof (state)\nthis:\n  pt \\<in> set_of lt\n\ngoal (2 subgoals):\n 1. pt \\<in> set_of lt \\<Longrightarrow> marka pt = m\n 2. pt \\<notin> set_of lt \\<Longrightarrow> marka pt = m", "with mit_marked"], ["proof (chain)\npicking this:\n  \\<forall>n. n \\<in> set_of lt \\<longrightarrow> marka n = m\n  pt \\<in> set_of lt", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>n. n \\<in> set_of lt \\<longrightarrow> marka n = m\n  pt \\<in> set_of lt\n\ngoal (1 subgoal):\n 1. marka pt = m", "by fastforce"], ["proof (state)\nthis:\n  marka pt = m\n\ngoal (1 subgoal):\n 1. pt \\<notin> set_of lt \\<Longrightarrow> marka pt = m", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. pt \\<notin> set_of lt \\<Longrightarrow> marka pt = m", "assume pt_notin_lt: \" pt \\<notin> set_of lt\""], ["proof (state)\nthis:\n  pt \\<notin> set_of lt\n\ngoal (1 subgoal):\n 1. pt \\<notin> set_of lt \\<Longrightarrow> marka pt = m", "with mot_nc"], ["proof (chain)\npicking this:\n  \\<forall>n. n \\<notin> set_of lt \\<longrightarrow> mark n = marka n\n  pt \\<notin> set_of lt", "have \"mark pt = marka pt\""], ["proof (prove)\nusing this:\n  \\<forall>n. n \\<notin> set_of lt \\<longrightarrow> mark n = marka n\n  pt \\<notin> set_of lt\n\ngoal (1 subgoal):\n 1. mark pt = marka pt", "by fastforce"], ["proof (state)\nthis:\n  mark pt = marka pt\n\ngoal (1 subgoal):\n 1. pt \\<notin> set_of lt \\<Longrightarrow> marka pt = m", "with nt_mark nt_Dag pt_in_nt"], ["proof (chain)\npicking this:\n  \\<forall>nt p.\n     Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow> mark p = m\n  Dag n low high nt\n  pt \\<in> set_of nt\n  mark pt = marka pt", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>nt p.\n     Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow> mark p = m\n  Dag n low high nt\n  pt \\<in> set_of nt\n  mark pt = marka pt\n\ngoal (1 subgoal):\n 1. marka pt = m", "by fastforce"], ["proof (state)\nthis:\n  marka pt = m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  marka pt = m\n\ngoal (2 subgoals):\n 1. marka n = m \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)\n 2. marka n \\<noteq> m \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>Dag n low high ?nt3; ?pt3 \\<in> set_of ?nt3\\<rbrakk>\n  \\<Longrightarrow> marka ?pt3 = m\n\ngoal (2 subgoals):\n 1. marka n = m \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)\n 2. marka n \\<noteq> m \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>Dag n low high ?nt3; ?pt3 \\<in> set_of ?nt3\\<rbrakk>\n  \\<Longrightarrow> marka ?pt3 = m", "have nt_marka:\n                \"\\<forall>nt pt. Dag n low high nt \\<and> pt \\<in> set_of nt \\<longrightarrow> marka pt = m\""], ["proof (prove)\nusing this:\n  \\<lbrakk>Dag n low high ?nt3; ?pt3 \\<in> set_of ?nt3\\<rbrakk>\n  \\<Longrightarrow> marka ?pt3 = m\n\ngoal (1 subgoal):\n 1. \\<forall>nt pt.\n       Dag n low high nt \\<and> pt \\<in> set_of nt \\<longrightarrow>\n       marka pt = m", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>nt pt.\n     Dag n low high nt \\<and> pt \\<in> set_of nt \\<longrightarrow>\n     marka pt = m\n\ngoal (2 subgoals):\n 1. marka n = m \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)\n 2. marka n \\<noteq> m \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)", "with n_in_lla nt_marka True"], ["proof (chain)\npicking this:\n  n \\<in> set (lla ! var n)\n  \\<forall>nt pt.\n     Dag n low high nt \\<and> pt \\<in> set_of nt \\<longrightarrow>\n     marka pt = m\n  marka n = m\n  \\<forall>nt pt.\n     Dag n low high nt \\<and> pt \\<in> set_of nt \\<longrightarrow>\n     marka pt = m", "show ?thesis"], ["proof (prove)\nusing this:\n  n \\<in> set (lla ! var n)\n  \\<forall>nt pt.\n     Dag n low high nt \\<and> pt \\<in> set_of nt \\<longrightarrow>\n     marka pt = m\n  marka n = m\n  \\<forall>nt pt.\n     Dag n low high nt \\<and> pt \\<in> set_of nt \\<longrightarrow>\n     marka pt = m\n\ngoal (1 subgoal):\n 1. if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)", "by fastforce"], ["proof (state)\nthis:\n  if marka n = m\n  then n \\<in> set (lla ! var n) \\<and>\n       (\\<forall>nt p.\n           Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n           marka p = m)\n  else n \\<notin> set (concat lla)\n\ngoal (1 subgoal):\n 1. marka n \\<noteq> m \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. marka n \\<noteq> m \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)", "case False"], ["proof (state)\nthis:\n  marka n \\<noteq> m\n\ngoal (1 subgoal):\n 1. marka n \\<noteq> m \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)", "note n_not_marka = this"], ["proof (state)\nthis:\n  marka n \\<noteq> m\n\ngoal (1 subgoal):\n 1. marka n \\<noteq> m \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)", "with wfmarking_lt n_notin_lt"], ["proof (chain)\npicking this:\n  wf_marking lt mark marka m\n  n \\<notin> set_of lt\n  marka n \\<noteq> m", "have \"mark n \\<noteq> m\""], ["proof (prove)\nusing this:\n  wf_marking lt mark marka m\n  n \\<notin> set_of lt\n  marka n \\<noteq> m\n\ngoal (1 subgoal):\n 1. mark n \\<noteq> m", "by (simp add: wf_marking_def lt_Node)"], ["proof (state)\nthis:\n  mark n \\<noteq> m\n\ngoal (1 subgoal):\n 1. marka n \\<noteq> m \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)", "with marked_child_ll"], ["proof (chain)\npicking this:\n  if mark n = m\n  then n \\<in> set (ll ! var n) \\<and>\n       (\\<forall>nt p.\n           Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n           mark p = m)\n  else n \\<notin> set (concat ll)\n  mark n \\<noteq> m", "have n_notin_ll: \"n \\<notin> set (concat ll)\""], ["proof (prove)\nusing this:\n  if mark n = m\n  then n \\<in> set (ll ! var n) \\<and>\n       (\\<forall>nt p.\n           Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n           mark p = m)\n  else n \\<notin> set (concat ll)\n  mark n \\<noteq> m\n\ngoal (1 subgoal):\n 1. n \\<notin> set (concat ll)", "by simp"], ["proof (state)\nthis:\n  n \\<notin> set (concat ll)\n\ngoal (1 subgoal):\n 1. marka n \\<noteq> m \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)", "proof (cases \"n \\<in> set (concat lla)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n \\<in> set (concat lla) \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)\n 2. n \\<notin> set (concat lla) \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)", "case False"], ["proof (state)\nthis:\n  n \\<notin> set (concat lla)\n\ngoal (2 subgoals):\n 1. n \\<in> set (concat lla) \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)\n 2. n \\<notin> set (concat lla) \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)", "with n_not_marka"], ["proof (chain)\npicking this:\n  marka n \\<noteq> m\n  n \\<notin> set (concat lla)", "show ?thesis"], ["proof (prove)\nusing this:\n  marka n \\<noteq> m\n  n \\<notin> set (concat lla)\n\ngoal (1 subgoal):\n 1. if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)", "by simp"], ["proof (state)\nthis:\n  if marka n = m\n  then n \\<in> set (lla ! var n) \\<and>\n       (\\<forall>nt p.\n           Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n           marka p = m)\n  else n \\<notin> set (concat lla)\n\ngoal (1 subgoal):\n 1. n \\<in> set (concat lla) \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<in> set (concat lla) \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)", "case True"], ["proof (state)\nthis:\n  n \\<in> set (concat lla)\n\ngoal (1 subgoal):\n 1. n \\<in> set (concat lla) \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)", "with wf_levellist_subset [OF wfll_lt] n_notin_ll"], ["proof (chain)\npicking this:\n  set (concat lla) \\<subseteq> set (concat ll) \\<union> set_of lt\n  n \\<notin> set (concat ll)\n  n \\<in> set (concat lla)", "have \"n \\<in> set_of lt\""], ["proof (prove)\nusing this:\n  set (concat lla) \\<subseteq> set (concat ll) \\<union> set_of lt\n  n \\<notin> set (concat ll)\n  n \\<in> set (concat lla)\n\ngoal (1 subgoal):\n 1. n \\<in> set_of lt", "by blast"], ["proof (state)\nthis:\n  n \\<in> set_of lt\n\ngoal (1 subgoal):\n 1. n \\<in> set (concat lla) \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)", "with n_notin_lt"], ["proof (chain)\npicking this:\n  n \\<notin> set_of lt\n  n \\<in> set_of lt", "have False"], ["proof (prove)\nusing this:\n  n \\<notin> set_of lt\n  n \\<in> set_of lt\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. n \\<in> set (concat lla) \\<Longrightarrow>\n    if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. if marka n = m\n    then n \\<in> set (lla ! var n) \\<and>\n         (\\<forall>nt p.\n             Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n             marka p = m)\n    else n \\<notin> set (concat lla)", ".."], ["proof (state)\nthis:\n  if marka n = m\n  then n \\<in> set (lla ! var n) \\<and>\n       (\\<forall>nt p.\n           Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n           marka p = m)\n  else n \\<notin> set (concat lla)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  if marka n = m\n  then n \\<in> set (lla ! var n) \\<and>\n       (\\<forall>nt p.\n           Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n           marka p = m)\n  else n \\<notin> set (concat lla)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  if marka n = m\n  then n \\<in> set (lla ! var n) \\<and>\n       (\\<forall>nt p.\n           Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n           marka p = m)\n  else n \\<notin> set (concat lla)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  if marka n = m\n  then n \\<in> set (lla ! var n) \\<and>\n       (\\<forall>nt p.\n           Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n           marka p = m)\n  else n \\<notin> set (concat lla)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>n\\<in>set_of rt.\n     if marka n = m\n     then n \\<in> set (lla ! var n) \\<and>\n          (\\<forall>nt p.\n              Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n              marka p = m)\n     else n \\<notin> set (concat lla)\n\ngoal (1 subgoal):\n 1. (high p \\<noteq> Null \\<longrightarrow>\n     var (high p) < length levellista) \\<and>\n    ordered rt var \\<and>\n    (\\<forall>n\\<in>set_of rt.\n        if marka n = m\n        then n \\<in> set (lla ! var n) \\<and>\n             (\\<forall>nt p.\n                 Dag n low high nt \\<and>\n                 p \\<in> set_of nt \\<longrightarrow>\n                 marka p = m)\n        else n \\<notin> set (concat lla)) \\<and>\n    (\\<forall>markb nextb levellist llb.\n        Levellist levellist nextb llb \\<and>\n        wf_levellist rt lla llb var \\<and>\n        wf_marking rt marka markb m \\<and>\n        (\\<forall>p.\n            p \\<notin> set_of rt \\<longrightarrow>\n            nexta p = nextb p) \\<longrightarrow>\n        (\\<exists>ll'.\n            Levellist (levellist[var p := p])\n             (nextb(p := levellist ! var p)) ll' \\<and>\n            wf_levellist (Node lt p rt) ll ll' var \\<and>\n            wf_marking (Node lt p rt) mark (markb(p := m)) m))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (high p \\<noteq> Null \\<longrightarrow>\n     var (high p) < length levellista) \\<and>\n    ordered rt var \\<and>\n    (\\<forall>n\\<in>set_of rt.\n        if marka n = m\n        then n \\<in> set (lla ! var n) \\<and>\n             (\\<forall>nt p.\n                 Dag n low high nt \\<and>\n                 p \\<in> set_of nt \\<longrightarrow>\n                 marka p = m)\n        else n \\<notin> set (concat lla)) \\<and>\n    (\\<forall>markb nextb levellist llb.\n        Levellist levellist nextb llb \\<and>\n        wf_levellist rt lla llb var \\<and>\n        wf_marking rt marka markb m \\<and>\n        (\\<forall>p.\n            p \\<notin> set_of rt \\<longrightarrow>\n            nexta p = nextb p) \\<longrightarrow>\n        (\\<exists>ll'.\n            Levellist (levellist[var p := p])\n             (nextb(p := levellist ! var p)) ll' \\<and>\n            wf_levellist (Node lt p rt) ll ll' var \\<and>\n            wf_marking (Node lt p rt) mark (markb(p := m)) m))", "apply (intro conjI ordered_rt mark_rt)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>markb nextb levellist llb.\n       Levellist levellist nextb llb \\<and>\n       wf_levellist rt lla llb var \\<and>\n       wf_marking rt marka markb m \\<and>\n       (\\<forall>p.\n           p \\<notin> set_of rt \\<longrightarrow>\n           nexta p = nextb p) \\<longrightarrow>\n       (\\<exists>ll'.\n           Levellist (levellist[var p := p]) (nextb(p := levellist ! var p))\n            ll' \\<and>\n           wf_levellist (Node lt p rt) ll ll' var \\<and>\n           wf_marking (Node lt p rt) mark (markb(p := m)) m)", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>markb nextb levellist llb.\n       \\<lbrakk>Levellist levellist nextb llb; wf_levellist rt lla llb var;\n        wf_marking rt marka markb m;\n        \\<forall>p.\n           p \\<notin> set_of rt \\<longrightarrow> nexta p = nextb p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ll'.\n                            Levellist (levellist[var p := p])\n                             (nextb(p := levellist ! var p)) ll' \\<and>\n                            wf_levellist (Node lt p rt) ll ll' var \\<and>\n                            wf_marking (Node lt p rt) mark (markb(p := m)) m", "subgoal premises prems for markb nextb levellistb llb"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ll'.\n       Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n        ll' \\<and>\n       wf_levellist (Node lt p rt) ll ll' var \\<and>\n       wf_marking (Node lt p rt) mark (markb(p := m)) m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>ll'.\n       Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n        ll' \\<and>\n       wf_levellist (Node lt p rt) ll ll' var \\<and>\n       wf_marking (Node lt p rt) mark (markb(p := m)) m", "have llb: \"Levellist levellistb nextb llb\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Levellist levellistb nextb llb", "by fact"], ["proof (state)\nthis:\n  Levellist levellistb nextb llb\n\ngoal (1 subgoal):\n 1. \\<exists>ll'.\n       Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n        ll' \\<and>\n       wf_levellist (Node lt p rt) ll ll' var \\<and>\n       wf_marking (Node lt p rt) mark (markb(p := m)) m", "have wfll_rt: \"wf_levellist rt lla llb var\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_levellist rt lla llb var", "by fact"], ["proof (state)\nthis:\n  wf_levellist rt lla llb var\n\ngoal (1 subgoal):\n 1. \\<exists>ll'.\n       Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n        ll' \\<and>\n       wf_levellist (Node lt p rt) ll ll' var \\<and>\n       wf_marking (Node lt p rt) mark (markb(p := m)) m", "have wfmarking_rt: \"wf_marking rt marka markb m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_marking rt marka markb m", "by fact"], ["proof (state)\nthis:\n  wf_marking rt marka markb m\n\ngoal (1 subgoal):\n 1. \\<exists>ll'.\n       Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n        ll' \\<and>\n       wf_levellist (Node lt p rt) ll ll' var \\<and>\n       wf_marking (Node lt p rt) mark (markb(p := m)) m", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ll'.\n       Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n        ll' \\<and>\n       wf_levellist (Node lt p rt) ll ll' var \\<and>\n       wf_marking (Node lt p rt) mark (markb(p := m)) m", "proof (cases rt)"], ["proof (state)\ngoal (2 subgoals):\n 1. rt = Tip \\<Longrightarrow>\n    \\<exists>ll'.\n       Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n        ll' \\<and>\n       wf_levellist (Node lt p rt) ll ll' var \\<and>\n       wf_marking (Node lt p rt) mark (markb(p := m)) m\n 2. \\<And>x21 x22 x23.\n       rt = Node x21 x22 x23 \\<Longrightarrow>\n       \\<exists>ll'.\n          Levellist (levellistb[var p := p])\n           (nextb(p := levellistb ! var p)) ll' \\<and>\n          wf_levellist (Node lt p rt) ll ll' var \\<and>\n          wf_marking (Node lt p rt) mark (markb(p := m)) m", "case Tip"], ["proof (state)\nthis:\n  rt = Tip\n\ngoal (2 subgoals):\n 1. rt = Tip \\<Longrightarrow>\n    \\<exists>ll'.\n       Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n        ll' \\<and>\n       wf_levellist (Node lt p rt) ll ll' var \\<and>\n       wf_marking (Node lt p rt) mark (markb(p := m)) m\n 2. \\<And>x21 x22 x23.\n       rt = Node x21 x22 x23 \\<Longrightarrow>\n       \\<exists>ll'.\n          Levellist (levellistb[var p := p])\n           (nextb(p := levellistb ! var p)) ll' \\<and>\n          wf_levellist (Node lt p rt) ll ll' var \\<and>\n          wf_marking (Node lt p rt) mark (markb(p := m)) m", "from wfll_rt Tip"], ["proof (chain)\npicking this:\n  wf_levellist rt lla llb var\n  rt = Tip", "have lla_llb: \"lla = llb\""], ["proof (prove)\nusing this:\n  wf_levellist rt lla llb var\n  rt = Tip\n\ngoal (1 subgoal):\n 1. lla = llb", "by (simp add: wf_levellist_def)"], ["proof (state)\nthis:\n  lla = llb\n\ngoal (2 subgoals):\n 1. rt = Tip \\<Longrightarrow>\n    \\<exists>ll'.\n       Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n        ll' \\<and>\n       wf_levellist (Node lt p rt) ll ll' var \\<and>\n       wf_marking (Node lt p rt) mark (markb(p := m)) m\n 2. \\<And>x21 x22 x23.\n       rt = Node x21 x22 x23 \\<Longrightarrow>\n       \\<exists>ll'.\n          Levellist (levellistb[var p := p])\n           (nextb(p := levellistb ! var p)) ll' \\<and>\n          wf_levellist (Node lt p rt) ll ll' var \\<and>\n          wf_marking (Node lt p rt) mark (markb(p := m)) m", "moreover"], ["proof (state)\nthis:\n  lla = llb\n\ngoal (2 subgoals):\n 1. rt = Tip \\<Longrightarrow>\n    \\<exists>ll'.\n       Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n        ll' \\<and>\n       wf_levellist (Node lt p rt) ll ll' var \\<and>\n       wf_marking (Node lt p rt) mark (markb(p := m)) m\n 2. \\<And>x21 x22 x23.\n       rt = Node x21 x22 x23 \\<Longrightarrow>\n       \\<exists>ll'.\n          Levellist (levellistb[var p := p])\n           (nextb(p := levellistb ! var p)) ll' \\<and>\n          wf_levellist (Node lt p rt) ll ll' var \\<and>\n          wf_marking (Node lt p rt) mark (markb(p := m)) m", "from wfmarking_rt Tip rt"], ["proof (chain)\npicking this:\n  wf_marking rt marka markb m\n  rt = Tip\n  Dag (high p) low high rt", "have \"markb = marka\""], ["proof (prove)\nusing this:\n  wf_marking rt marka markb m\n  rt = Tip\n  Dag (high p) low high rt\n\ngoal (1 subgoal):\n 1. markb = marka", "by (simp add: wf_marking_def)"], ["proof (state)\nthis:\n  markb = marka\n\ngoal (2 subgoals):\n 1. rt = Tip \\<Longrightarrow>\n    \\<exists>ll'.\n       Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n        ll' \\<and>\n       wf_levellist (Node lt p rt) ll ll' var \\<and>\n       wf_marking (Node lt p rt) mark (markb(p := m)) m\n 2. \\<And>x21 x22 x23.\n       rt = Node x21 x22 x23 \\<Longrightarrow>\n       \\<exists>ll'.\n          Levellist (levellistb[var p := p])\n           (nextb(p := levellistb ! var p)) ll' \\<and>\n          wf_levellist (Node lt p rt) ll ll' var \\<and>\n          wf_marking (Node lt p rt) mark (markb(p := m)) m", "moreover"], ["proof (state)\nthis:\n  markb = marka\n\ngoal (2 subgoals):\n 1. rt = Tip \\<Longrightarrow>\n    \\<exists>ll'.\n       Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n        ll' \\<and>\n       wf_levellist (Node lt p rt) ll ll' var \\<and>\n       wf_marking (Node lt p rt) mark (markb(p := m)) m\n 2. \\<And>x21 x22 x23.\n       rt = Node x21 x22 x23 \\<Longrightarrow>\n       \\<exists>ll'.\n          Levellist (levellistb[var p := p])\n           (nextb(p := levellistb ! var p)) ll' \\<and>\n          wf_levellist (Node lt p rt) ll ll' var \\<and>\n          wf_marking (Node lt p rt) mark (markb(p := m)) m", "from wfll_lt varsll llb lla_llb"], ["proof (chain)\npicking this:\n  wf_levellist lt ll lla var\n  var p < length ll\n  Levellist levellistb nextb llb\n  lla = llb", "obtain var_p_bounds: \"var p < length levellistb\" \"var p < length llb\""], ["proof (prove)\nusing this:\n  wf_levellist lt ll lla var\n  var p < length ll\n  Levellist levellistb nextb llb\n  lla = llb\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>var p < length levellistb; var p < length llb\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp add: Levellist_length wf_levellist_def lt_Node Tip)"], ["proof (state)\nthis:\n  var p < length levellistb\n  var p < length llb\n\ngoal (2 subgoals):\n 1. rt = Tip \\<Longrightarrow>\n    \\<exists>ll'.\n       Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n        ll' \\<and>\n       wf_levellist (Node lt p rt) ll ll' var \\<and>\n       wf_marking (Node lt p rt) mark (markb(p := m)) m\n 2. \\<And>x21 x22 x23.\n       rt = Node x21 x22 x23 \\<Longrightarrow>\n       \\<exists>ll'.\n          Levellist (levellistb[var p := p])\n           (nextb(p := levellistb ! var p)) ll' \\<and>\n          wf_levellist (Node lt p rt) ll ll' var \\<and>\n          wf_marking (Node lt p rt) mark (markb(p := m)) m", "with p_notin_ll lla_llb wfll_lt"], ["proof (chain)\npicking this:\n  p \\<notin> set (concat ll)\n  lla = llb\n  wf_levellist lt ll lla var\n  var p < length levellistb\n  var p < length llb", "have p_notin_llb: \"\\<forall>i < length llb. p \\<notin> set (llb ! i)\""], ["proof (prove)\nusing this:\n  p \\<notin> set (concat ll)\n  lla = llb\n  wf_levellist lt ll lla var\n  var p < length levellistb\n  var p < length llb\n\ngoal (1 subgoal):\n 1. \\<forall>i<length llb. p \\<notin> set (llb ! i)", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<notin> set (concat ll); lla = llb;\n     wf_levellist lt ll lla var; var p < length levellistb;\n     var p < length llb\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i<length llb. p \\<notin> set (llb ! i)", "apply (intro allI impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>p \\<notin> set (concat ll); lla = llb;\n        wf_levellist lt ll lla var; var p < length levellistb;\n        var p < length llb; i < length llb\\<rbrakk>\n       \\<Longrightarrow> p \\<notin> set (llb ! i)", "apply (clarsimp simp add: wf_levellist_def lt_Node)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<forall>x\\<in>set ll. p \\<notin> set x; lla = llb;\n        var p < length levellistb; var p < length ll; i < length ll;\n        \\<forall>q.\n           (q = l \\<longrightarrow> l \\<in> set (llb ! var l)) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>i\\<le>var l.\n           \\<exists>prx.\n              llb ! i = prx @ ll ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = l \\<or>\n                   pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n                  var pt = i);\n        \\<forall>i>var l. llb ! i = ll ! i; length llb = length ll;\n        p \\<in> set (llb ! i)\\<rbrakk>\n       \\<Longrightarrow> False", "apply (case_tac \"i \\<le> var l\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>\\<forall>x\\<in>set ll. p \\<notin> set x; lla = llb;\n        var p < length levellistb; var p < length ll; i < length ll;\n        \\<forall>q.\n           (q = l \\<longrightarrow> l \\<in> set (llb ! var l)) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>i\\<le>var l.\n           \\<exists>prx.\n              llb ! i = prx @ ll ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = l \\<or>\n                   pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n                  var pt = i);\n        \\<forall>i>var l. llb ! i = ll ! i; length llb = length ll;\n        p \\<in> set (llb ! i); i \\<le> var l\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>i.\n       \\<lbrakk>\\<forall>x\\<in>set ll. p \\<notin> set x; lla = llb;\n        var p < length levellistb; var p < length ll; i < length ll;\n        \\<forall>q.\n           (q = l \\<longrightarrow> l \\<in> set (llb ! var l)) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>i\\<le>var l.\n           \\<exists>prx.\n              llb ! i = prx @ ll ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = l \\<or>\n                   pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n                  var pt = i);\n        \\<forall>i>var l. llb ! i = ll ! i; length llb = length ll;\n        p \\<in> set (llb ! i); \\<not> i \\<le> var l\\<rbrakk>\n       \\<Longrightarrow> False", "apply  (drule_tac x=i in spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>\\<forall>x\\<in>set ll. p \\<notin> set x; lla = llb;\n        var p < length levellistb; var p < length ll; i < length ll;\n        \\<forall>q.\n           (q = l \\<longrightarrow> l \\<in> set (llb ! var l)) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>i>var l. llb ! i = ll ! i; length llb = length ll;\n        p \\<in> set (llb ! i); i \\<le> var l;\n        i \\<le> var l \\<longrightarrow>\n        (\\<exists>prx.\n            llb ! i = prx @ ll ! i \\<and>\n            (\\<forall>pt\\<in>set prx.\n                (pt = l \\<or>\n                 pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n                var pt = i))\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>i.\n       \\<lbrakk>\\<forall>x\\<in>set ll. p \\<notin> set x; lla = llb;\n        var p < length levellistb; var p < length ll; i < length ll;\n        \\<forall>q.\n           (q = l \\<longrightarrow> l \\<in> set (llb ! var l)) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>i\\<le>var l.\n           \\<exists>prx.\n              llb ! i = prx @ ll ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = l \\<or>\n                   pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n                  var pt = i);\n        \\<forall>i>var l. llb ! i = ll ! i; length llb = length ll;\n        p \\<in> set (llb ! i); \\<not> i \\<le> var l\\<rbrakk>\n       \\<Longrightarrow> False", "using  orderedt Tip lt_Node"], ["proof (prove)\nusing this:\n  ordered (Node lt p rt) var\n  rt = Tip\n  lt = Node llt l rlt\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>\\<forall>x\\<in>set ll. p \\<notin> set x; lla = llb;\n        var p < length levellistb; var p < length ll; i < length ll;\n        \\<forall>q.\n           (q = l \\<longrightarrow> l \\<in> set (llb ! var l)) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>i>var l. llb ! i = ll ! i; length llb = length ll;\n        p \\<in> set (llb ! i); i \\<le> var l;\n        i \\<le> var l \\<longrightarrow>\n        (\\<exists>prx.\n            llb ! i = prx @ ll ! i \\<and>\n            (\\<forall>pt\\<in>set prx.\n                (pt = l \\<or>\n                 pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n                var pt = i))\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>i.\n       \\<lbrakk>\\<forall>x\\<in>set ll. p \\<notin> set x; lla = llb;\n        var p < length levellistb; var p < length ll; i < length ll;\n        \\<forall>q.\n           (q = l \\<longrightarrow> l \\<in> set (llb ! var l)) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>i\\<le>var l.\n           \\<exists>prx.\n              llb ! i = prx @ ll ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = l \\<or>\n                   pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n                  var pt = i);\n        \\<forall>i>var l. llb ! i = ll ! i; length llb = length ll;\n        p \\<in> set (llb ! i); \\<not> i \\<le> var l\\<rbrakk>\n       \\<Longrightarrow> False", "apply  clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<forall>x\\<in>set ll. p \\<notin> set x; lla = llb;\n        var p < length levellistb; var p < length ll; i < length ll;\n        \\<forall>q.\n           (q = l \\<longrightarrow> l \\<in> set (llb ! var l)) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>i\\<le>var l.\n           \\<exists>prx.\n              llb ! i = prx @ ll ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = l \\<or>\n                   pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n                  var pt = i);\n        \\<forall>i>var l. llb ! i = ll ! i; length llb = length ll;\n        p \\<in> set (llb ! i); \\<not> i \\<le> var l\\<rbrakk>\n       \\<Longrightarrow> False", "apply (drule_tac x=i in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<forall>x\\<in>set ll. p \\<notin> set x; lla = llb;\n        var p < length levellistb; var p < length ll; i < length ll;\n        \\<forall>q.\n           (q = l \\<longrightarrow> l \\<in> set (llb ! var l)) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>i>var l. llb ! i = ll ! i; length llb = length ll;\n        p \\<in> set (llb ! i); \\<not> i \\<le> var l;\n        i \\<le> var l \\<longrightarrow>\n        (\\<exists>prx.\n            llb ! i = prx @ ll ! i \\<and>\n            (\\<forall>pt\\<in>set prx.\n                (pt = l \\<or>\n                 pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n                var pt = i))\\<rbrakk>\n       \\<Longrightarrow> False", "apply (drule_tac x=i in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<forall>x\\<in>set ll. p \\<notin> set x; lla = llb;\n        var p < length levellistb; var p < length ll; i < length ll;\n        \\<forall>q.\n           (q = l \\<longrightarrow> l \\<in> set (llb ! var l)) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (llb ! var q));\n        length llb = length ll; p \\<in> set (llb ! i); \\<not> i \\<le> var l;\n        i \\<le> var l \\<longrightarrow>\n        (\\<exists>prx.\n            llb ! i = prx @ ll ! i \\<and>\n            (\\<forall>pt\\<in>set prx.\n                (pt = l \\<or>\n                 pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n                var pt = i));\n        var l < i \\<longrightarrow> llb ! i = ll ! i\\<rbrakk>\n       \\<Longrightarrow> False", "apply clarsimp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>i<length llb. p \\<notin> set (llb ! i)\n\ngoal (2 subgoals):\n 1. rt = Tip \\<Longrightarrow>\n    \\<exists>ll'.\n       Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n        ll' \\<and>\n       wf_levellist (Node lt p rt) ll ll' var \\<and>\n       wf_marking (Node lt p rt) mark (markb(p := m)) m\n 2. \\<And>x21 x22 x23.\n       rt = Node x21 x22 x23 \\<Longrightarrow>\n       \\<exists>ll'.\n          Levellist (levellistb[var p := p])\n           (nextb(p := levellistb ! var p)) ll' \\<and>\n          wf_levellist (Node lt p rt) ll ll' var \\<and>\n          wf_marking (Node lt p rt) mark (markb(p := m)) m", "with llb pnN var_p_bounds"], ["proof (chain)\npicking this:\n  Levellist levellistb nextb llb\n  p \\<noteq> Null\n  var p < length levellistb\n  var p < length llb\n  \\<forall>i<length llb. p \\<notin> set (llb ! i)", "have llc: \"Levellist (levellistb[var p := p])\n                            (nextb(p := levellistb ! var p))\n                            (llb[var p := p # llb ! var p])\""], ["proof (prove)\nusing this:\n  Levellist levellistb nextb llb\n  p \\<noteq> Null\n  var p < length levellistb\n  var p < length llb\n  \\<forall>i<length llb. p \\<notin> set (llb ! i)\n\ngoal (1 subgoal):\n 1. Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n     (llb[var p := p # llb ! var p])", "apply (clarsimp simp add: Levellist_def map_update)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>p \\<noteq> Null; var p < length llb;\n        \\<forall>i<length llb. p \\<notin> set (llb ! i);\n        \\<forall>i<length llb. List (first (llb ! i)) nextb (llb ! i);\n        levellistb = map first llb; i < length llb\\<rbrakk>\n       \\<Longrightarrow> List ((map first llb)[var p := p] ! i)\n                          (nextb(p := first (llb ! var p)))\n                          (llb[var p := p # llb ! var p] ! i)", "apply (erule_tac x=i in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>p \\<noteq> Null; var p < length llb;\n        \\<forall>i<length llb. List (first (llb ! i)) nextb (llb ! i);\n        levellistb = map first llb; i < length llb;\n        i < length llb \\<longrightarrow> p \\<notin> set (llb ! i)\\<rbrakk>\n       \\<Longrightarrow> List ((map first llb)[var p := p] ! i)\n                          (nextb(p := first (llb ! var p)))\n                          (llb[var p := p # llb ! var p] ! i)", "apply (erule_tac x=i in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>p \\<noteq> Null; var p < length llb;\n        levellistb = map first llb; i < length llb;\n        i < length llb \\<longrightarrow> p \\<notin> set (llb ! i);\n        i < length llb \\<longrightarrow>\n        List (first (llb ! i)) nextb (llb ! i)\\<rbrakk>\n       \\<Longrightarrow> List ((map first llb)[var p := p] ! i)\n                          (nextb(p := first (llb ! var p)))\n                          (llb[var p := p # llb ! var p] ! i)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>p \\<noteq> Null; var p < length llb;\n        levellistb = map first llb; i < length llb;\n        p \\<notin> set (llb ! i);\n        List (first (llb ! i)) nextb (llb ! i)\\<rbrakk>\n       \\<Longrightarrow> List ((map first llb)[var p := p] ! i)\n                          (nextb(p := first (llb ! var p)))\n                          (llb[var p := p # llb ! var p] ! i)", "apply (case_tac \"i=var p\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>p \\<noteq> Null; var p < length llb;\n        levellistb = map first llb; i < length llb;\n        p \\<notin> set (llb ! i); List (first (llb ! i)) nextb (llb ! i);\n        i = var p\\<rbrakk>\n       \\<Longrightarrow> List ((map first llb)[var p := p] ! i)\n                          (nextb(p := first (llb ! var p)))\n                          (llb[var p := p # llb ! var p] ! i)\n 2. \\<And>i.\n       \\<lbrakk>p \\<noteq> Null; var p < length llb;\n        levellistb = map first llb; i < length llb;\n        p \\<notin> set (llb ! i); List (first (llb ! i)) nextb (llb ! i);\n        i \\<noteq> var p\\<rbrakk>\n       \\<Longrightarrow> List ((map first llb)[var p := p] ! i)\n                          (nextb(p := first (llb ! var p)))\n                          (llb[var p := p # llb ! var p] ! i)", "apply  simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>p \\<noteq> Null; var p < length llb;\n        levellistb = map first llb; i < length llb;\n        p \\<notin> set (llb ! i); List (first (llb ! i)) nextb (llb ! i);\n        i \\<noteq> var p\\<rbrakk>\n       \\<Longrightarrow> List ((map first llb)[var p := p] ! i)\n                          (nextb(p := first (llb ! var p)))\n                          (llb[var p := p # llb ! var p] ! i)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n   (llb[var p := p # llb ! var p])\n\ngoal (2 subgoals):\n 1. rt = Tip \\<Longrightarrow>\n    \\<exists>ll'.\n       Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n        ll' \\<and>\n       wf_levellist (Node lt p rt) ll ll' var \\<and>\n       wf_marking (Node lt p rt) mark (markb(p := m)) m\n 2. \\<And>x21 x22 x23.\n       rt = Node x21 x22 x23 \\<Longrightarrow>\n       \\<exists>ll'.\n          Levellist (levellistb[var p := p])\n           (nextb(p := levellistb ! var p)) ll' \\<and>\n          wf_levellist (Node lt p rt) ll ll' var \\<and>\n          wf_marking (Node lt p rt) mark (markb(p := m)) m", "ultimately"], ["proof (chain)\npicking this:\n  lla = llb\n  markb = marka\n  Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n   (llb[var p := p # llb ! var p])", "show ?thesis"], ["proof (prove)\nusing this:\n  lla = llb\n  markb = marka\n  Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n   (llb[var p := p # llb ! var p])\n\ngoal (1 subgoal):\n 1. \\<exists>ll'.\n       Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n        ll' \\<and>\n       wf_levellist (Node lt p rt) ll ll' var \\<and>\n       wf_marking (Node lt p rt) mark (markb(p := m)) m", "using Tip lt_Node varsll orderedt lt rt pnN wfll_lt wfmarking_lt"], ["proof (prove)\nusing this:\n  lla = llb\n  markb = marka\n  Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n   (llb[var p := p # llb ! var p])\n  rt = Tip\n  lt = Node llt l rlt\n  var p < length ll\n  ordered (Node lt p rt) var\n  Dag (low p) low high lt\n  Dag (high p) low high rt\n  p \\<noteq> Null\n  wf_levellist lt ll lla var\n  wf_marking lt mark marka m\n\ngoal (1 subgoal):\n 1. \\<exists>ll'.\n       Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n        ll' \\<and>\n       wf_levellist (Node lt p rt) ll ll' var \\<and>\n       wf_marking (Node lt p rt) mark (markb(p := m)) m", "apply (clarsimp simp add: wf_levellist_def wf_marking_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lla = llb; markb = marka;\n     Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n      (llb[var p := p # ll ! var p]);\n     rt = Tip; lt = Node llt (low p) rlt; var p < length ll; high p = Null;\n     p \\<noteq> Null; var (low p) < var p;\n     ordered (Node llt (low p) rlt) var; l = low p;\n     \\<forall>q.\n        (q = low p \\<longrightarrow>\n         low p \\<in> set (llb ! var (low p))) \\<and>\n        (q \\<in> set_of llt \\<longrightarrow>\n         q \\<in> set (llb ! var q)) \\<and>\n        (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (llb ! var q));\n     \\<forall>n.\n        n \\<noteq> low p \\<and>\n        n \\<notin> set_of llt \\<and> n \\<notin> set_of rlt \\<longrightarrow>\n        marka n = mark n;\n     \\<forall>n.\n        (n = low p \\<longrightarrow> marka (low p) = m) \\<and>\n        (n \\<in> set_of llt \\<longrightarrow> marka n = m) \\<and>\n        (n \\<in> set_of rlt \\<longrightarrow> marka n = m);\n     low p \\<noteq> Null;\n     \\<forall>i\\<le>var (low p).\n        \\<exists>prx.\n           llb ! i = prx @ ll ! i \\<and>\n           (\\<forall>pt\\<in>set prx.\n               (pt = low p \\<or>\n                pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n               var pt = i);\n     Dag (low (low p)) low high llt; Dag (high (low p)) low high rlt;\n     \\<forall>i>var (low p). llb ! i = ll ! i;\n     length llb = length ll\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>q.\n                          (q \\<in> set_of llt \\<longrightarrow>\n                           q \\<in> set (llb[var p := p # ll ! var p] !\n  var q)) \\<and>\n                          (q \\<in> set_of rlt \\<longrightarrow>\n                           q \\<in> set (llb[var p := p # ll ! var p] !\n  var q))) \\<and>\n                      (\\<forall>i\\<le>var p.\n                          \\<exists>prx.\n                             llb[var p := p # ll ! var p] ! i =\n                             prx @ ll ! i \\<and>\n                             (\\<forall>pt\\<in>set prx.\n                                 (pt = low p \\<or>\n                                  pt = p \\<or>\n                                  pt \\<in> set_of llt \\<or>\n                                  pt \\<in> set_of rlt) \\<and>\n                                 var pt = i))", "apply (intro conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>lla = llb; markb = marka;\n     Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n      (llb[var p := p # ll ! var p]);\n     rt = Tip; lt = Node llt (low p) rlt; var p < length ll; high p = Null;\n     p \\<noteq> Null; var (low p) < var p;\n     ordered (Node llt (low p) rlt) var; l = low p;\n     \\<forall>q.\n        (q = low p \\<longrightarrow>\n         low p \\<in> set (llb ! var (low p))) \\<and>\n        (q \\<in> set_of llt \\<longrightarrow>\n         q \\<in> set (llb ! var q)) \\<and>\n        (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (llb ! var q));\n     \\<forall>n.\n        n \\<noteq> low p \\<and>\n        n \\<notin> set_of llt \\<and> n \\<notin> set_of rlt \\<longrightarrow>\n        marka n = mark n;\n     \\<forall>n.\n        (n = low p \\<longrightarrow> marka (low p) = m) \\<and>\n        (n \\<in> set_of llt \\<longrightarrow> marka n = m) \\<and>\n        (n \\<in> set_of rlt \\<longrightarrow> marka n = m);\n     low p \\<noteq> Null;\n     \\<forall>i\\<le>var (low p).\n        \\<exists>prx.\n           llb ! i = prx @ ll ! i \\<and>\n           (\\<forall>pt\\<in>set prx.\n               (pt = low p \\<or>\n                pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n               var pt = i);\n     Dag (low (low p)) low high llt; Dag (high (low p)) low high rlt;\n     \\<forall>i>var (low p). llb ! i = ll ! i;\n     length llb = length ll\\<rbrakk>\n    \\<Longrightarrow> \\<forall>q.\n                         (q \\<in> set_of llt \\<longrightarrow>\n                          q \\<in> set (llb[var p := p # ll ! var p] !\n var q)) \\<and>\n                         (q \\<in> set_of rlt \\<longrightarrow>\n                          q \\<in> set (llb[var p := p # ll ! var p] !\n var q))\n 2. \\<lbrakk>lla = llb; markb = marka;\n     Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n      (llb[var p := p # ll ! var p]);\n     rt = Tip; lt = Node llt (low p) rlt; var p < length ll; high p = Null;\n     p \\<noteq> Null; var (low p) < var p;\n     ordered (Node llt (low p) rlt) var; l = low p;\n     \\<forall>q.\n        (q = low p \\<longrightarrow>\n         low p \\<in> set (llb ! var (low p))) \\<and>\n        (q \\<in> set_of llt \\<longrightarrow>\n         q \\<in> set (llb ! var q)) \\<and>\n        (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (llb ! var q));\n     \\<forall>n.\n        n \\<noteq> low p \\<and>\n        n \\<notin> set_of llt \\<and> n \\<notin> set_of rlt \\<longrightarrow>\n        marka n = mark n;\n     \\<forall>n.\n        (n = low p \\<longrightarrow> marka (low p) = m) \\<and>\n        (n \\<in> set_of llt \\<longrightarrow> marka n = m) \\<and>\n        (n \\<in> set_of rlt \\<longrightarrow> marka n = m);\n     low p \\<noteq> Null;\n     \\<forall>i\\<le>var (low p).\n        \\<exists>prx.\n           llb ! i = prx @ ll ! i \\<and>\n           (\\<forall>pt\\<in>set prx.\n               (pt = low p \\<or>\n                pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n               var pt = i);\n     Dag (low (low p)) low high llt; Dag (high (low p)) low high rlt;\n     \\<forall>i>var (low p). llb ! i = ll ! i;\n     length llb = length ll\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i\\<le>var p.\n                         \\<exists>prx.\n                            llb[var p := p # ll ! var p] ! i =\n                            prx @ ll ! i \\<and>\n                            (\\<forall>pt\\<in>set prx.\n                                (pt = low p \\<or>\n                                 pt = p \\<or>\n                                 pt \\<in> set_of llt \\<or>\n                                 pt \\<in> set_of rlt) \\<and>\n                                var pt = i)", "apply  (rule allI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>lla = llb; markb = marka;\n        Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n         (llb[var p := p # ll ! var p]);\n        rt = Tip; lt = Node llt (low p) rlt; var p < length ll;\n        high p = Null; p \\<noteq> Null; var (low p) < var p;\n        ordered (Node llt (low p) rlt) var; l = low p;\n        \\<forall>q.\n           (q = low p \\<longrightarrow>\n            low p \\<in> set (llb ! var (low p))) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>n.\n           n \\<noteq> low p \\<and>\n           n \\<notin> set_of llt \\<and>\n           n \\<notin> set_of rlt \\<longrightarrow>\n           marka n = mark n;\n        \\<forall>n.\n           (n = low p \\<longrightarrow> marka (low p) = m) \\<and>\n           (n \\<in> set_of llt \\<longrightarrow> marka n = m) \\<and>\n           (n \\<in> set_of rlt \\<longrightarrow> marka n = m);\n        low p \\<noteq> Null;\n        \\<forall>i\\<le>var (low p).\n           \\<exists>prx.\n              llb ! i = prx @ ll ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = low p \\<or>\n                   pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n                  var pt = i);\n        Dag (low (low p)) low high llt; Dag (high (low p)) low high rlt;\n        \\<forall>i>var (low p). llb ! i = ll ! i;\n        length llb = length ll\\<rbrakk>\n       \\<Longrightarrow> (q \\<in> set_of llt \\<longrightarrow>\n                          q \\<in> set (llb[var p := p # ll ! var p] !\n var q)) \\<and>\n                         (q \\<in> set_of rlt \\<longrightarrow>\n                          q \\<in> set (llb[var p := p # ll ! var p] !\n var q))\n 2. \\<lbrakk>lla = llb; markb = marka;\n     Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n      (llb[var p := p # ll ! var p]);\n     rt = Tip; lt = Node llt (low p) rlt; var p < length ll; high p = Null;\n     p \\<noteq> Null; var (low p) < var p;\n     ordered (Node llt (low p) rlt) var; l = low p;\n     \\<forall>q.\n        (q = low p \\<longrightarrow>\n         low p \\<in> set (llb ! var (low p))) \\<and>\n        (q \\<in> set_of llt \\<longrightarrow>\n         q \\<in> set (llb ! var q)) \\<and>\n        (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (llb ! var q));\n     \\<forall>n.\n        n \\<noteq> low p \\<and>\n        n \\<notin> set_of llt \\<and> n \\<notin> set_of rlt \\<longrightarrow>\n        marka n = mark n;\n     \\<forall>n.\n        (n = low p \\<longrightarrow> marka (low p) = m) \\<and>\n        (n \\<in> set_of llt \\<longrightarrow> marka n = m) \\<and>\n        (n \\<in> set_of rlt \\<longrightarrow> marka n = m);\n     low p \\<noteq> Null;\n     \\<forall>i\\<le>var (low p).\n        \\<exists>prx.\n           llb ! i = prx @ ll ! i \\<and>\n           (\\<forall>pt\\<in>set prx.\n               (pt = low p \\<or>\n                pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n               var pt = i);\n     Dag (low (low p)) low high llt; Dag (high (low p)) low high rlt;\n     \\<forall>i>var (low p). llb ! i = ll ! i;\n     length llb = length ll\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i\\<le>var p.\n                         \\<exists>prx.\n                            llb[var p := p # ll ! var p] ! i =\n                            prx @ ll ! i \\<and>\n                            (\\<forall>pt\\<in>set prx.\n                                (pt = low p \\<or>\n                                 pt = p \\<or>\n                                 pt \\<in> set_of llt \\<or>\n                                 pt \\<in> set_of rlt) \\<and>\n                                var pt = i)", "apply  (rule conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>lla = llb; markb = marka;\n        Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n         (llb[var p := p # ll ! var p]);\n        rt = Tip; lt = Node llt (low p) rlt; var p < length ll;\n        high p = Null; p \\<noteq> Null; var (low p) < var p;\n        ordered (Node llt (low p) rlt) var; l = low p;\n        \\<forall>q.\n           (q = low p \\<longrightarrow>\n            low p \\<in> set (llb ! var (low p))) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>n.\n           n \\<noteq> low p \\<and>\n           n \\<notin> set_of llt \\<and>\n           n \\<notin> set_of rlt \\<longrightarrow>\n           marka n = mark n;\n        \\<forall>n.\n           (n = low p \\<longrightarrow> marka (low p) = m) \\<and>\n           (n \\<in> set_of llt \\<longrightarrow> marka n = m) \\<and>\n           (n \\<in> set_of rlt \\<longrightarrow> marka n = m);\n        low p \\<noteq> Null;\n        \\<forall>i\\<le>var (low p).\n           \\<exists>prx.\n              llb ! i = prx @ ll ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = low p \\<or>\n                   pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n                  var pt = i);\n        Dag (low (low p)) low high llt; Dag (high (low p)) low high rlt;\n        \\<forall>i>var (low p). llb ! i = ll ! i;\n        length llb = length ll\\<rbrakk>\n       \\<Longrightarrow> q \\<in> set_of llt \\<longrightarrow>\n                         q \\<in> set (llb[var p := p # ll ! var p] ! var q)\n 2. \\<And>q.\n       \\<lbrakk>lla = llb; markb = marka;\n        Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n         (llb[var p := p # ll ! var p]);\n        rt = Tip; lt = Node llt (low p) rlt; var p < length ll;\n        high p = Null; p \\<noteq> Null; var (low p) < var p;\n        ordered (Node llt (low p) rlt) var; l = low p;\n        \\<forall>q.\n           (q = low p \\<longrightarrow>\n            low p \\<in> set (llb ! var (low p))) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>n.\n           n \\<noteq> low p \\<and>\n           n \\<notin> set_of llt \\<and>\n           n \\<notin> set_of rlt \\<longrightarrow>\n           marka n = mark n;\n        \\<forall>n.\n           (n = low p \\<longrightarrow> marka (low p) = m) \\<and>\n           (n \\<in> set_of llt \\<longrightarrow> marka n = m) \\<and>\n           (n \\<in> set_of rlt \\<longrightarrow> marka n = m);\n        low p \\<noteq> Null;\n        \\<forall>i\\<le>var (low p).\n           \\<exists>prx.\n              llb ! i = prx @ ll ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = low p \\<or>\n                   pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n                  var pt = i);\n        Dag (low (low p)) low high llt; Dag (high (low p)) low high rlt;\n        \\<forall>i>var (low p). llb ! i = ll ! i;\n        length llb = length ll\\<rbrakk>\n       \\<Longrightarrow> q \\<in> set_of rlt \\<longrightarrow>\n                         q \\<in> set (llb[var p := p # ll ! var p] ! var q)\n 3. \\<lbrakk>lla = llb; markb = marka;\n     Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n      (llb[var p := p # ll ! var p]);\n     rt = Tip; lt = Node llt (low p) rlt; var p < length ll; high p = Null;\n     p \\<noteq> Null; var (low p) < var p;\n     ordered (Node llt (low p) rlt) var; l = low p;\n     \\<forall>q.\n        (q = low p \\<longrightarrow>\n         low p \\<in> set (llb ! var (low p))) \\<and>\n        (q \\<in> set_of llt \\<longrightarrow>\n         q \\<in> set (llb ! var q)) \\<and>\n        (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (llb ! var q));\n     \\<forall>n.\n        n \\<noteq> low p \\<and>\n        n \\<notin> set_of llt \\<and> n \\<notin> set_of rlt \\<longrightarrow>\n        marka n = mark n;\n     \\<forall>n.\n        (n = low p \\<longrightarrow> marka (low p) = m) \\<and>\n        (n \\<in> set_of llt \\<longrightarrow> marka n = m) \\<and>\n        (n \\<in> set_of rlt \\<longrightarrow> marka n = m);\n     low p \\<noteq> Null;\n     \\<forall>i\\<le>var (low p).\n        \\<exists>prx.\n           llb ! i = prx @ ll ! i \\<and>\n           (\\<forall>pt\\<in>set prx.\n               (pt = low p \\<or>\n                pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n               var pt = i);\n     Dag (low (low p)) low high llt; Dag (high (low p)) low high rlt;\n     \\<forall>i>var (low p). llb ! i = ll ! i;\n     length llb = length ll\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i\\<le>var p.\n                         \\<exists>prx.\n                            llb[var p := p # ll ! var p] ! i =\n                            prx @ ll ! i \\<and>\n                            (\\<forall>pt\\<in>set prx.\n                                (pt = low p \\<or>\n                                 pt = p \\<or>\n                                 pt \\<in> set_of llt \\<or>\n                                 pt \\<in> set_of rlt) \\<and>\n                                var pt = i)", "apply   (erule_tac x=\"q\" in allE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>lla = llb; markb = marka;\n        Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n         (llb[var p := p # ll ! var p]);\n        rt = Tip; lt = Node llt (low p) rlt; var p < length ll;\n        high p = Null; p \\<noteq> Null; var (low p) < var p;\n        ordered (Node llt (low p) rlt) var; l = low p;\n        \\<forall>n.\n           n \\<noteq> low p \\<and>\n           n \\<notin> set_of llt \\<and>\n           n \\<notin> set_of rlt \\<longrightarrow>\n           marka n = mark n;\n        \\<forall>n.\n           (n = low p \\<longrightarrow> marka (low p) = m) \\<and>\n           (n \\<in> set_of llt \\<longrightarrow> marka n = m) \\<and>\n           (n \\<in> set_of rlt \\<longrightarrow> marka n = m);\n        low p \\<noteq> Null;\n        \\<forall>i\\<le>var (low p).\n           \\<exists>prx.\n              llb ! i = prx @ ll ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = low p \\<or>\n                   pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n                  var pt = i);\n        Dag (low (low p)) low high llt; Dag (high (low p)) low high rlt;\n        \\<forall>i>var (low p). llb ! i = ll ! i; length llb = length ll;\n        (q = low p \\<longrightarrow>\n         low p \\<in> set (llb ! var (low p))) \\<and>\n        (q \\<in> set_of llt \\<longrightarrow>\n         q \\<in> set (llb ! var q)) \\<and>\n        (q \\<in> set_of rlt \\<longrightarrow>\n         q \\<in> set (llb ! var q))\\<rbrakk>\n       \\<Longrightarrow> q \\<in> set_of llt \\<longrightarrow>\n                         q \\<in> set (llb[var p := p # ll ! var p] ! var q)\n 2. \\<And>q.\n       \\<lbrakk>lla = llb; markb = marka;\n        Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n         (llb[var p := p # ll ! var p]);\n        rt = Tip; lt = Node llt (low p) rlt; var p < length ll;\n        high p = Null; p \\<noteq> Null; var (low p) < var p;\n        ordered (Node llt (low p) rlt) var; l = low p;\n        \\<forall>q.\n           (q = low p \\<longrightarrow>\n            low p \\<in> set (llb ! var (low p))) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>n.\n           n \\<noteq> low p \\<and>\n           n \\<notin> set_of llt \\<and>\n           n \\<notin> set_of rlt \\<longrightarrow>\n           marka n = mark n;\n        \\<forall>n.\n           (n = low p \\<longrightarrow> marka (low p) = m) \\<and>\n           (n \\<in> set_of llt \\<longrightarrow> marka n = m) \\<and>\n           (n \\<in> set_of rlt \\<longrightarrow> marka n = m);\n        low p \\<noteq> Null;\n        \\<forall>i\\<le>var (low p).\n           \\<exists>prx.\n              llb ! i = prx @ ll ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = low p \\<or>\n                   pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n                  var pt = i);\n        Dag (low (low p)) low high llt; Dag (high (low p)) low high rlt;\n        \\<forall>i>var (low p). llb ! i = ll ! i;\n        length llb = length ll\\<rbrakk>\n       \\<Longrightarrow> q \\<in> set_of rlt \\<longrightarrow>\n                         q \\<in> set (llb[var p := p # ll ! var p] ! var q)\n 3. \\<lbrakk>lla = llb; markb = marka;\n     Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n      (llb[var p := p # ll ! var p]);\n     rt = Tip; lt = Node llt (low p) rlt; var p < length ll; high p = Null;\n     p \\<noteq> Null; var (low p) < var p;\n     ordered (Node llt (low p) rlt) var; l = low p;\n     \\<forall>q.\n        (q = low p \\<longrightarrow>\n         low p \\<in> set (llb ! var (low p))) \\<and>\n        (q \\<in> set_of llt \\<longrightarrow>\n         q \\<in> set (llb ! var q)) \\<and>\n        (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (llb ! var q));\n     \\<forall>n.\n        n \\<noteq> low p \\<and>\n        n \\<notin> set_of llt \\<and> n \\<notin> set_of rlt \\<longrightarrow>\n        marka n = mark n;\n     \\<forall>n.\n        (n = low p \\<longrightarrow> marka (low p) = m) \\<and>\n        (n \\<in> set_of llt \\<longrightarrow> marka n = m) \\<and>\n        (n \\<in> set_of rlt \\<longrightarrow> marka n = m);\n     low p \\<noteq> Null;\n     \\<forall>i\\<le>var (low p).\n        \\<exists>prx.\n           llb ! i = prx @ ll ! i \\<and>\n           (\\<forall>pt\\<in>set prx.\n               (pt = low p \\<or>\n                pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n               var pt = i);\n     Dag (low (low p)) low high llt; Dag (high (low p)) low high rlt;\n     \\<forall>i>var (low p). llb ! i = ll ! i;\n     length llb = length ll\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i\\<le>var p.\n                         \\<exists>prx.\n                            llb[var p := p # ll ! var p] ! i =\n                            prx @ ll ! i \\<and>\n                            (\\<forall>pt\\<in>set prx.\n                                (pt = low p \\<or>\n                                 pt = p \\<or>\n                                 pt \\<in> set_of llt \\<or>\n                                 pt \\<in> set_of rlt) \\<and>\n                                var pt = i)", "apply   (case_tac \"var p = var q\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>lla = llb; markb = marka;\n        Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n         (llb[var p := p # ll ! var p]);\n        rt = Tip; lt = Node llt (low p) rlt; var p < length ll;\n        high p = Null; p \\<noteq> Null; var (low p) < var p;\n        ordered (Node llt (low p) rlt) var; l = low p;\n        \\<forall>n.\n           n \\<noteq> low p \\<and>\n           n \\<notin> set_of llt \\<and>\n           n \\<notin> set_of rlt \\<longrightarrow>\n           marka n = mark n;\n        \\<forall>n.\n           (n = low p \\<longrightarrow> marka (low p) = m) \\<and>\n           (n \\<in> set_of llt \\<longrightarrow> marka n = m) \\<and>\n           (n \\<in> set_of rlt \\<longrightarrow> marka n = m);\n        low p \\<noteq> Null;\n        \\<forall>i\\<le>var (low p).\n           \\<exists>prx.\n              llb ! i = prx @ ll ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = low p \\<or>\n                   pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n                  var pt = i);\n        Dag (low (low p)) low high llt; Dag (high (low p)) low high rlt;\n        \\<forall>i>var (low p). llb ! i = ll ! i; length llb = length ll;\n        (q = low p \\<longrightarrow>\n         low p \\<in> set (llb ! var (low p))) \\<and>\n        (q \\<in> set_of llt \\<longrightarrow>\n         q \\<in> set (llb ! var q)) \\<and>\n        (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (llb ! var q));\n        var p = var q\\<rbrakk>\n       \\<Longrightarrow> q \\<in> set_of llt \\<longrightarrow>\n                         q \\<in> set (llb[var p := p # ll ! var p] ! var q)\n 2. \\<And>q.\n       \\<lbrakk>lla = llb; markb = marka;\n        Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n         (llb[var p := p # ll ! var p]);\n        rt = Tip; lt = Node llt (low p) rlt; var p < length ll;\n        high p = Null; p \\<noteq> Null; var (low p) < var p;\n        ordered (Node llt (low p) rlt) var; l = low p;\n        \\<forall>n.\n           n \\<noteq> low p \\<and>\n           n \\<notin> set_of llt \\<and>\n           n \\<notin> set_of rlt \\<longrightarrow>\n           marka n = mark n;\n        \\<forall>n.\n           (n = low p \\<longrightarrow> marka (low p) = m) \\<and>\n           (n \\<in> set_of llt \\<longrightarrow> marka n = m) \\<and>\n           (n \\<in> set_of rlt \\<longrightarrow> marka n = m);\n        low p \\<noteq> Null;\n        \\<forall>i\\<le>var (low p).\n           \\<exists>prx.\n              llb ! i = prx @ ll ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = low p \\<or>\n                   pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n                  var pt = i);\n        Dag (low (low p)) low high llt; Dag (high (low p)) low high rlt;\n        \\<forall>i>var (low p). llb ! i = ll ! i; length llb = length ll;\n        (q = low p \\<longrightarrow>\n         low p \\<in> set (llb ! var (low p))) \\<and>\n        (q \\<in> set_of llt \\<longrightarrow>\n         q \\<in> set (llb ! var q)) \\<and>\n        (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (llb ! var q));\n        var p \\<noteq> var q\\<rbrakk>\n       \\<Longrightarrow> q \\<in> set_of llt \\<longrightarrow>\n                         q \\<in> set (llb[var p := p # ll ! var p] ! var q)\n 3. \\<And>q.\n       \\<lbrakk>lla = llb; markb = marka;\n        Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n         (llb[var p := p # ll ! var p]);\n        rt = Tip; lt = Node llt (low p) rlt; var p < length ll;\n        high p = Null; p \\<noteq> Null; var (low p) < var p;\n        ordered (Node llt (low p) rlt) var; l = low p;\n        \\<forall>q.\n           (q = low p \\<longrightarrow>\n            low p \\<in> set (llb ! var (low p))) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>n.\n           n \\<noteq> low p \\<and>\n           n \\<notin> set_of llt \\<and>\n           n \\<notin> set_of rlt \\<longrightarrow>\n           marka n = mark n;\n        \\<forall>n.\n           (n = low p \\<longrightarrow> marka (low p) = m) \\<and>\n           (n \\<in> set_of llt \\<longrightarrow> marka n = m) \\<and>\n           (n \\<in> set_of rlt \\<longrightarrow> marka n = m);\n        low p \\<noteq> Null;\n        \\<forall>i\\<le>var (low p).\n           \\<exists>prx.\n              llb ! i = prx @ ll ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = low p \\<or>\n                   pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n                  var pt = i);\n        Dag (low (low p)) low high llt; Dag (high (low p)) low high rlt;\n        \\<forall>i>var (low p). llb ! i = ll ! i;\n        length llb = length ll\\<rbrakk>\n       \\<Longrightarrow> q \\<in> set_of rlt \\<longrightarrow>\n                         q \\<in> set (llb[var p := p # ll ! var p] ! var q)\n 4. \\<lbrakk>lla = llb; markb = marka;\n     Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n      (llb[var p := p # ll ! var p]);\n     rt = Tip; lt = Node llt (low p) rlt; var p < length ll; high p = Null;\n     p \\<noteq> Null; var (low p) < var p;\n     ordered (Node llt (low p) rlt) var; l = low p;\n     \\<forall>q.\n        (q = low p \\<longrightarrow>\n         low p \\<in> set (llb ! var (low p))) \\<and>\n        (q \\<in> set_of llt \\<longrightarrow>\n         q \\<in> set (llb ! var q)) \\<and>\n        (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (llb ! var q));\n     \\<forall>n.\n        n \\<noteq> low p \\<and>\n        n \\<notin> set_of llt \\<and> n \\<notin> set_of rlt \\<longrightarrow>\n        marka n = mark n;\n     \\<forall>n.\n        (n = low p \\<longrightarrow> marka (low p) = m) \\<and>\n        (n \\<in> set_of llt \\<longrightarrow> marka n = m) \\<and>\n        (n \\<in> set_of rlt \\<longrightarrow> marka n = m);\n     low p \\<noteq> Null;\n     \\<forall>i\\<le>var (low p).\n        \\<exists>prx.\n           llb ! i = prx @ ll ! i \\<and>\n           (\\<forall>pt\\<in>set prx.\n               (pt = low p \\<or>\n                pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n               var pt = i);\n     Dag (low (low p)) low high llt; Dag (high (low p)) low high rlt;\n     \\<forall>i>var (low p). llb ! i = ll ! i;\n     length llb = length ll\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i\\<le>var p.\n                         \\<exists>prx.\n                            llb[var p := p # ll ! var p] ! i =\n                            prx @ ll ! i \\<and>\n                            (\\<forall>pt\\<in>set prx.\n                                (pt = low p \\<or>\n                                 pt = p \\<or>\n                                 pt \\<in> set_of llt \\<or>\n                                 pt \\<in> set_of rlt) \\<and>\n                                var pt = i)", "apply    fastforce"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>lla = llb; markb = marka;\n        Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n         (llb[var p := p # ll ! var p]);\n        rt = Tip; lt = Node llt (low p) rlt; var p < length ll;\n        high p = Null; p \\<noteq> Null; var (low p) < var p;\n        ordered (Node llt (low p) rlt) var; l = low p;\n        \\<forall>n.\n           n \\<noteq> low p \\<and>\n           n \\<notin> set_of llt \\<and>\n           n \\<notin> set_of rlt \\<longrightarrow>\n           marka n = mark n;\n        \\<forall>n.\n           (n = low p \\<longrightarrow> marka (low p) = m) \\<and>\n           (n \\<in> set_of llt \\<longrightarrow> marka n = m) \\<and>\n           (n \\<in> set_of rlt \\<longrightarrow> marka n = m);\n        low p \\<noteq> Null;\n        \\<forall>i\\<le>var (low p).\n           \\<exists>prx.\n              llb ! i = prx @ ll ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = low p \\<or>\n                   pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n                  var pt = i);\n        Dag (low (low p)) low high llt; Dag (high (low p)) low high rlt;\n        \\<forall>i>var (low p). llb ! i = ll ! i; length llb = length ll;\n        (q = low p \\<longrightarrow>\n         low p \\<in> set (llb ! var (low p))) \\<and>\n        (q \\<in> set_of llt \\<longrightarrow>\n         q \\<in> set (llb ! var q)) \\<and>\n        (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (llb ! var q));\n        var p \\<noteq> var q\\<rbrakk>\n       \\<Longrightarrow> q \\<in> set_of llt \\<longrightarrow>\n                         q \\<in> set (llb[var p := p # ll ! var p] ! var q)\n 2. \\<And>q.\n       \\<lbrakk>lla = llb; markb = marka;\n        Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n         (llb[var p := p # ll ! var p]);\n        rt = Tip; lt = Node llt (low p) rlt; var p < length ll;\n        high p = Null; p \\<noteq> Null; var (low p) < var p;\n        ordered (Node llt (low p) rlt) var; l = low p;\n        \\<forall>q.\n           (q = low p \\<longrightarrow>\n            low p \\<in> set (llb ! var (low p))) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>n.\n           n \\<noteq> low p \\<and>\n           n \\<notin> set_of llt \\<and>\n           n \\<notin> set_of rlt \\<longrightarrow>\n           marka n = mark n;\n        \\<forall>n.\n           (n = low p \\<longrightarrow> marka (low p) = m) \\<and>\n           (n \\<in> set_of llt \\<longrightarrow> marka n = m) \\<and>\n           (n \\<in> set_of rlt \\<longrightarrow> marka n = m);\n        low p \\<noteq> Null;\n        \\<forall>i\\<le>var (low p).\n           \\<exists>prx.\n              llb ! i = prx @ ll ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = low p \\<or>\n                   pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n                  var pt = i);\n        Dag (low (low p)) low high llt; Dag (high (low p)) low high rlt;\n        \\<forall>i>var (low p). llb ! i = ll ! i;\n        length llb = length ll\\<rbrakk>\n       \\<Longrightarrow> q \\<in> set_of rlt \\<longrightarrow>\n                         q \\<in> set (llb[var p := p # ll ! var p] ! var q)\n 3. \\<lbrakk>lla = llb; markb = marka;\n     Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n      (llb[var p := p # ll ! var p]);\n     rt = Tip; lt = Node llt (low p) rlt; var p < length ll; high p = Null;\n     p \\<noteq> Null; var (low p) < var p;\n     ordered (Node llt (low p) rlt) var; l = low p;\n     \\<forall>q.\n        (q = low p \\<longrightarrow>\n         low p \\<in> set (llb ! var (low p))) \\<and>\n        (q \\<in> set_of llt \\<longrightarrow>\n         q \\<in> set (llb ! var q)) \\<and>\n        (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (llb ! var q));\n     \\<forall>n.\n        n \\<noteq> low p \\<and>\n        n \\<notin> set_of llt \\<and> n \\<notin> set_of rlt \\<longrightarrow>\n        marka n = mark n;\n     \\<forall>n.\n        (n = low p \\<longrightarrow> marka (low p) = m) \\<and>\n        (n \\<in> set_of llt \\<longrightarrow> marka n = m) \\<and>\n        (n \\<in> set_of rlt \\<longrightarrow> marka n = m);\n     low p \\<noteq> Null;\n     \\<forall>i\\<le>var (low p).\n        \\<exists>prx.\n           llb ! i = prx @ ll ! i \\<and>\n           (\\<forall>pt\\<in>set prx.\n               (pt = low p \\<or>\n                pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n               var pt = i);\n     Dag (low (low p)) low high llt; Dag (high (low p)) low high rlt;\n     \\<forall>i>var (low p). llb ! i = ll ! i;\n     length llb = length ll\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i\\<le>var p.\n                         \\<exists>prx.\n                            llb[var p := p # ll ! var p] ! i =\n                            prx @ ll ! i \\<and>\n                            (\\<forall>pt\\<in>set prx.\n                                (pt = low p \\<or>\n                                 pt = p \\<or>\n                                 pt \\<in> set_of llt \\<or>\n                                 pt \\<in> set_of rlt) \\<and>\n                                var pt = i)", "apply   fastforce"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>lla = llb; markb = marka;\n        Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n         (llb[var p := p # ll ! var p]);\n        rt = Tip; lt = Node llt (low p) rlt; var p < length ll;\n        high p = Null; p \\<noteq> Null; var (low p) < var p;\n        ordered (Node llt (low p) rlt) var; l = low p;\n        \\<forall>q.\n           (q = low p \\<longrightarrow>\n            low p \\<in> set (llb ! var (low p))) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>n.\n           n \\<noteq> low p \\<and>\n           n \\<notin> set_of llt \\<and>\n           n \\<notin> set_of rlt \\<longrightarrow>\n           marka n = mark n;\n        \\<forall>n.\n           (n = low p \\<longrightarrow> marka (low p) = m) \\<and>\n           (n \\<in> set_of llt \\<longrightarrow> marka n = m) \\<and>\n           (n \\<in> set_of rlt \\<longrightarrow> marka n = m);\n        low p \\<noteq> Null;\n        \\<forall>i\\<le>var (low p).\n           \\<exists>prx.\n              llb ! i = prx @ ll ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = low p \\<or>\n                   pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n                  var pt = i);\n        Dag (low (low p)) low high llt; Dag (high (low p)) low high rlt;\n        \\<forall>i>var (low p). llb ! i = ll ! i;\n        length llb = length ll\\<rbrakk>\n       \\<Longrightarrow> q \\<in> set_of rlt \\<longrightarrow>\n                         q \\<in> set (llb[var p := p # ll ! var p] ! var q)\n 2. \\<lbrakk>lla = llb; markb = marka;\n     Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n      (llb[var p := p # ll ! var p]);\n     rt = Tip; lt = Node llt (low p) rlt; var p < length ll; high p = Null;\n     p \\<noteq> Null; var (low p) < var p;\n     ordered (Node llt (low p) rlt) var; l = low p;\n     \\<forall>q.\n        (q = low p \\<longrightarrow>\n         low p \\<in> set (llb ! var (low p))) \\<and>\n        (q \\<in> set_of llt \\<longrightarrow>\n         q \\<in> set (llb ! var q)) \\<and>\n        (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (llb ! var q));\n     \\<forall>n.\n        n \\<noteq> low p \\<and>\n        n \\<notin> set_of llt \\<and> n \\<notin> set_of rlt \\<longrightarrow>\n        marka n = mark n;\n     \\<forall>n.\n        (n = low p \\<longrightarrow> marka (low p) = m) \\<and>\n        (n \\<in> set_of llt \\<longrightarrow> marka n = m) \\<and>\n        (n \\<in> set_of rlt \\<longrightarrow> marka n = m);\n     low p \\<noteq> Null;\n     \\<forall>i\\<le>var (low p).\n        \\<exists>prx.\n           llb ! i = prx @ ll ! i \\<and>\n           (\\<forall>pt\\<in>set prx.\n               (pt = low p \\<or>\n                pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n               var pt = i);\n     Dag (low (low p)) low high llt; Dag (high (low p)) low high rlt;\n     \\<forall>i>var (low p). llb ! i = ll ! i;\n     length llb = length ll\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i\\<le>var p.\n                         \\<exists>prx.\n                            llb[var p := p # ll ! var p] ! i =\n                            prx @ ll ! i \\<and>\n                            (\\<forall>pt\\<in>set prx.\n                                (pt = low p \\<or>\n                                 pt = p \\<or>\n                                 pt \\<in> set_of llt \\<or>\n                                 pt \\<in> set_of rlt) \\<and>\n                                var pt = i)", "apply  (case_tac \"var p = var q\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>lla = llb; markb = marka;\n        Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n         (llb[var p := p # ll ! var p]);\n        rt = Tip; lt = Node llt (low p) rlt; var p < length ll;\n        high p = Null; p \\<noteq> Null; var (low p) < var p;\n        ordered (Node llt (low p) rlt) var; l = low p;\n        \\<forall>q.\n           (q = low p \\<longrightarrow>\n            low p \\<in> set (llb ! var (low p))) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>n.\n           n \\<noteq> low p \\<and>\n           n \\<notin> set_of llt \\<and>\n           n \\<notin> set_of rlt \\<longrightarrow>\n           marka n = mark n;\n        \\<forall>n.\n           (n = low p \\<longrightarrow> marka (low p) = m) \\<and>\n           (n \\<in> set_of llt \\<longrightarrow> marka n = m) \\<and>\n           (n \\<in> set_of rlt \\<longrightarrow> marka n = m);\n        low p \\<noteq> Null;\n        \\<forall>i\\<le>var (low p).\n           \\<exists>prx.\n              llb ! i = prx @ ll ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = low p \\<or>\n                   pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n                  var pt = i);\n        Dag (low (low p)) low high llt; Dag (high (low p)) low high rlt;\n        \\<forall>i>var (low p). llb ! i = ll ! i; length llb = length ll;\n        var p = var q\\<rbrakk>\n       \\<Longrightarrow> q \\<in> set_of rlt \\<longrightarrow>\n                         q \\<in> set (llb[var p := p # ll ! var p] ! var q)\n 2. \\<And>q.\n       \\<lbrakk>lla = llb; markb = marka;\n        Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n         (llb[var p := p # ll ! var p]);\n        rt = Tip; lt = Node llt (low p) rlt; var p < length ll;\n        high p = Null; p \\<noteq> Null; var (low p) < var p;\n        ordered (Node llt (low p) rlt) var; l = low p;\n        \\<forall>q.\n           (q = low p \\<longrightarrow>\n            low p \\<in> set (llb ! var (low p))) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>n.\n           n \\<noteq> low p \\<and>\n           n \\<notin> set_of llt \\<and>\n           n \\<notin> set_of rlt \\<longrightarrow>\n           marka n = mark n;\n        \\<forall>n.\n           (n = low p \\<longrightarrow> marka (low p) = m) \\<and>\n           (n \\<in> set_of llt \\<longrightarrow> marka n = m) \\<and>\n           (n \\<in> set_of rlt \\<longrightarrow> marka n = m);\n        low p \\<noteq> Null;\n        \\<forall>i\\<le>var (low p).\n           \\<exists>prx.\n              llb ! i = prx @ ll ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = low p \\<or>\n                   pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n                  var pt = i);\n        Dag (low (low p)) low high llt; Dag (high (low p)) low high rlt;\n        \\<forall>i>var (low p). llb ! i = ll ! i; length llb = length ll;\n        var p \\<noteq> var q\\<rbrakk>\n       \\<Longrightarrow> q \\<in> set_of rlt \\<longrightarrow>\n                         q \\<in> set (llb[var p := p # ll ! var p] ! var q)\n 3. \\<lbrakk>lla = llb; markb = marka;\n     Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n      (llb[var p := p # ll ! var p]);\n     rt = Tip; lt = Node llt (low p) rlt; var p < length ll; high p = Null;\n     p \\<noteq> Null; var (low p) < var p;\n     ordered (Node llt (low p) rlt) var; l = low p;\n     \\<forall>q.\n        (q = low p \\<longrightarrow>\n         low p \\<in> set (llb ! var (low p))) \\<and>\n        (q \\<in> set_of llt \\<longrightarrow>\n         q \\<in> set (llb ! var q)) \\<and>\n        (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (llb ! var q));\n     \\<forall>n.\n        n \\<noteq> low p \\<and>\n        n \\<notin> set_of llt \\<and> n \\<notin> set_of rlt \\<longrightarrow>\n        marka n = mark n;\n     \\<forall>n.\n        (n = low p \\<longrightarrow> marka (low p) = m) \\<and>\n        (n \\<in> set_of llt \\<longrightarrow> marka n = m) \\<and>\n        (n \\<in> set_of rlt \\<longrightarrow> marka n = m);\n     low p \\<noteq> Null;\n     \\<forall>i\\<le>var (low p).\n        \\<exists>prx.\n           llb ! i = prx @ ll ! i \\<and>\n           (\\<forall>pt\\<in>set prx.\n               (pt = low p \\<or>\n                pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n               var pt = i);\n     Dag (low (low p)) low high llt; Dag (high (low p)) low high rlt;\n     \\<forall>i>var (low p). llb ! i = ll ! i;\n     length llb = length ll\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i\\<le>var p.\n                         \\<exists>prx.\n                            llb[var p := p # ll ! var p] ! i =\n                            prx @ ll ! i \\<and>\n                            (\\<forall>pt\\<in>set prx.\n                                (pt = low p \\<or>\n                                 pt = p \\<or>\n                                 pt \\<in> set_of llt \\<or>\n                                 pt \\<in> set_of rlt) \\<and>\n                                var pt = i)", "apply   hypsubst_thin"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>Levellist (levellistb[var p := p])\n                 (nextb(p := levellistb ! var p))\n                 (llb[var p := p # ll ! var p]);\n        var p < length ll; high p = Null; p \\<noteq> Null;\n        var (low p) < var p; ordered (Node llt (low p) rlt) var;\n        \\<forall>q.\n           (q = low p \\<longrightarrow>\n            low p \\<in> set (llb ! var (low p))) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>n.\n           n \\<noteq> low p \\<and>\n           n \\<notin> set_of llt \\<and>\n           n \\<notin> set_of rlt \\<longrightarrow>\n           marka n = mark n;\n        \\<forall>n.\n           (n = low p \\<longrightarrow> marka (low p) = m) \\<and>\n           (n \\<in> set_of llt \\<longrightarrow> marka n = m) \\<and>\n           (n \\<in> set_of rlt \\<longrightarrow> marka n = m);\n        low p \\<noteq> Null;\n        \\<forall>i\\<le>var (low p).\n           \\<exists>prx.\n              llb ! i = prx @ ll ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = low p \\<or>\n                   pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n                  var pt = i);\n        Dag (low (low p)) low high llt; Dag (high (low p)) low high rlt;\n        \\<forall>i>var (low p). llb ! i = ll ! i; length llb = length ll;\n        var p = var q\\<rbrakk>\n       \\<Longrightarrow> q \\<in> set_of rlt \\<longrightarrow>\n                         q \\<in> set (llb[var p := p # ll ! var p] ! var q)\n 2. \\<And>q.\n       \\<lbrakk>lla = llb; markb = marka;\n        Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n         (llb[var p := p # ll ! var p]);\n        rt = Tip; lt = Node llt (low p) rlt; var p < length ll;\n        high p = Null; p \\<noteq> Null; var (low p) < var p;\n        ordered (Node llt (low p) rlt) var; l = low p;\n        \\<forall>q.\n           (q = low p \\<longrightarrow>\n            low p \\<in> set (llb ! var (low p))) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>n.\n           n \\<noteq> low p \\<and>\n           n \\<notin> set_of llt \\<and>\n           n \\<notin> set_of rlt \\<longrightarrow>\n           marka n = mark n;\n        \\<forall>n.\n           (n = low p \\<longrightarrow> marka (low p) = m) \\<and>\n           (n \\<in> set_of llt \\<longrightarrow> marka n = m) \\<and>\n           (n \\<in> set_of rlt \\<longrightarrow> marka n = m);\n        low p \\<noteq> Null;\n        \\<forall>i\\<le>var (low p).\n           \\<exists>prx.\n              llb ! i = prx @ ll ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = low p \\<or>\n                   pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n                  var pt = i);\n        Dag (low (low p)) low high llt; Dag (high (low p)) low high rlt;\n        \\<forall>i>var (low p). llb ! i = ll ! i; length llb = length ll;\n        var p \\<noteq> var q\\<rbrakk>\n       \\<Longrightarrow> q \\<in> set_of rlt \\<longrightarrow>\n                         q \\<in> set (llb[var p := p # ll ! var p] ! var q)\n 3. \\<lbrakk>lla = llb; markb = marka;\n     Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n      (llb[var p := p # ll ! var p]);\n     rt = Tip; lt = Node llt (low p) rlt; var p < length ll; high p = Null;\n     p \\<noteq> Null; var (low p) < var p;\n     ordered (Node llt (low p) rlt) var; l = low p;\n     \\<forall>q.\n        (q = low p \\<longrightarrow>\n         low p \\<in> set (llb ! var (low p))) \\<and>\n        (q \\<in> set_of llt \\<longrightarrow>\n         q \\<in> set (llb ! var q)) \\<and>\n        (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (llb ! var q));\n     \\<forall>n.\n        n \\<noteq> low p \\<and>\n        n \\<notin> set_of llt \\<and> n \\<notin> set_of rlt \\<longrightarrow>\n        marka n = mark n;\n     \\<forall>n.\n        (n = low p \\<longrightarrow> marka (low p) = m) \\<and>\n        (n \\<in> set_of llt \\<longrightarrow> marka n = m) \\<and>\n        (n \\<in> set_of rlt \\<longrightarrow> marka n = m);\n     low p \\<noteq> Null;\n     \\<forall>i\\<le>var (low p).\n        \\<exists>prx.\n           llb ! i = prx @ ll ! i \\<and>\n           (\\<forall>pt\\<in>set prx.\n               (pt = low p \\<or>\n                pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n               var pt = i);\n     Dag (low (low p)) low high llt; Dag (high (low p)) low high rlt;\n     \\<forall>i>var (low p). llb ! i = ll ! i;\n     length llb = length ll\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i\\<le>var p.\n                         \\<exists>prx.\n                            llb[var p := p # ll ! var p] ! i =\n                            prx @ ll ! i \\<and>\n                            (\\<forall>pt\\<in>set prx.\n                                (pt = low p \\<or>\n                                 pt = p \\<or>\n                                 pt \\<in> set_of llt \\<or>\n                                 pt \\<in> set_of rlt) \\<and>\n                                var pt = i)", "apply   fastforce"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>lla = llb; markb = marka;\n        Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n         (llb[var p := p # ll ! var p]);\n        rt = Tip; lt = Node llt (low p) rlt; var p < length ll;\n        high p = Null; p \\<noteq> Null; var (low p) < var p;\n        ordered (Node llt (low p) rlt) var; l = low p;\n        \\<forall>q.\n           (q = low p \\<longrightarrow>\n            low p \\<in> set (llb ! var (low p))) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>n.\n           n \\<noteq> low p \\<and>\n           n \\<notin> set_of llt \\<and>\n           n \\<notin> set_of rlt \\<longrightarrow>\n           marka n = mark n;\n        \\<forall>n.\n           (n = low p \\<longrightarrow> marka (low p) = m) \\<and>\n           (n \\<in> set_of llt \\<longrightarrow> marka n = m) \\<and>\n           (n \\<in> set_of rlt \\<longrightarrow> marka n = m);\n        low p \\<noteq> Null;\n        \\<forall>i\\<le>var (low p).\n           \\<exists>prx.\n              llb ! i = prx @ ll ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = low p \\<or>\n                   pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n                  var pt = i);\n        Dag (low (low p)) low high llt; Dag (high (low p)) low high rlt;\n        \\<forall>i>var (low p). llb ! i = ll ! i; length llb = length ll;\n        var p \\<noteq> var q\\<rbrakk>\n       \\<Longrightarrow> q \\<in> set_of rlt \\<longrightarrow>\n                         q \\<in> set (llb[var p := p # ll ! var p] ! var q)\n 2. \\<lbrakk>lla = llb; markb = marka;\n     Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n      (llb[var p := p # ll ! var p]);\n     rt = Tip; lt = Node llt (low p) rlt; var p < length ll; high p = Null;\n     p \\<noteq> Null; var (low p) < var p;\n     ordered (Node llt (low p) rlt) var; l = low p;\n     \\<forall>q.\n        (q = low p \\<longrightarrow>\n         low p \\<in> set (llb ! var (low p))) \\<and>\n        (q \\<in> set_of llt \\<longrightarrow>\n         q \\<in> set (llb ! var q)) \\<and>\n        (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (llb ! var q));\n     \\<forall>n.\n        n \\<noteq> low p \\<and>\n        n \\<notin> set_of llt \\<and> n \\<notin> set_of rlt \\<longrightarrow>\n        marka n = mark n;\n     \\<forall>n.\n        (n = low p \\<longrightarrow> marka (low p) = m) \\<and>\n        (n \\<in> set_of llt \\<longrightarrow> marka n = m) \\<and>\n        (n \\<in> set_of rlt \\<longrightarrow> marka n = m);\n     low p \\<noteq> Null;\n     \\<forall>i\\<le>var (low p).\n        \\<exists>prx.\n           llb ! i = prx @ ll ! i \\<and>\n           (\\<forall>pt\\<in>set prx.\n               (pt = low p \\<or>\n                pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n               var pt = i);\n     Dag (low (low p)) low high llt; Dag (high (low p)) low high rlt;\n     \\<forall>i>var (low p). llb ! i = ll ! i;\n     length llb = length ll\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i\\<le>var p.\n                         \\<exists>prx.\n                            llb[var p := p # ll ! var p] ! i =\n                            prx @ ll ! i \\<and>\n                            (\\<forall>pt\\<in>set prx.\n                                (pt = low p \\<or>\n                                 pt = p \\<or>\n                                 pt \\<in> set_of llt \\<or>\n                                 pt \\<in> set_of rlt) \\<and>\n                                var pt = i)", "apply  fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lla = llb; markb = marka;\n     Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n      (llb[var p := p # ll ! var p]);\n     rt = Tip; lt = Node llt (low p) rlt; var p < length ll; high p = Null;\n     p \\<noteq> Null; var (low p) < var p;\n     ordered (Node llt (low p) rlt) var; l = low p;\n     \\<forall>q.\n        (q = low p \\<longrightarrow>\n         low p \\<in> set (llb ! var (low p))) \\<and>\n        (q \\<in> set_of llt \\<longrightarrow>\n         q \\<in> set (llb ! var q)) \\<and>\n        (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (llb ! var q));\n     \\<forall>n.\n        n \\<noteq> low p \\<and>\n        n \\<notin> set_of llt \\<and> n \\<notin> set_of rlt \\<longrightarrow>\n        marka n = mark n;\n     \\<forall>n.\n        (n = low p \\<longrightarrow> marka (low p) = m) \\<and>\n        (n \\<in> set_of llt \\<longrightarrow> marka n = m) \\<and>\n        (n \\<in> set_of rlt \\<longrightarrow> marka n = m);\n     low p \\<noteq> Null;\n     \\<forall>i\\<le>var (low p).\n        \\<exists>prx.\n           llb ! i = prx @ ll ! i \\<and>\n           (\\<forall>pt\\<in>set prx.\n               (pt = low p \\<or>\n                pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n               var pt = i);\n     Dag (low (low p)) low high llt; Dag (high (low p)) low high rlt;\n     \\<forall>i>var (low p). llb ! i = ll ! i;\n     length llb = length ll\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i\\<le>var p.\n                         \\<exists>prx.\n                            llb[var p := p # ll ! var p] ! i =\n                            prx @ ll ! i \\<and>\n                            (\\<forall>pt\\<in>set prx.\n                                (pt = low p \\<or>\n                                 pt = p \\<or>\n                                 pt \\<in> set_of llt \\<or>\n                                 pt \\<in> set_of rlt) \\<and>\n                                var pt = i)", "apply (rule allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>lla = llb; markb = marka;\n        Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n         (llb[var p := p # ll ! var p]);\n        rt = Tip; lt = Node llt (low p) rlt; var p < length ll;\n        high p = Null; p \\<noteq> Null; var (low p) < var p;\n        ordered (Node llt (low p) rlt) var; l = low p;\n        \\<forall>q.\n           (q = low p \\<longrightarrow>\n            low p \\<in> set (llb ! var (low p))) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>n.\n           n \\<noteq> low p \\<and>\n           n \\<notin> set_of llt \\<and>\n           n \\<notin> set_of rlt \\<longrightarrow>\n           marka n = mark n;\n        \\<forall>n.\n           (n = low p \\<longrightarrow> marka (low p) = m) \\<and>\n           (n \\<in> set_of llt \\<longrightarrow> marka n = m) \\<and>\n           (n \\<in> set_of rlt \\<longrightarrow> marka n = m);\n        low p \\<noteq> Null;\n        \\<forall>i\\<le>var (low p).\n           \\<exists>prx.\n              llb ! i = prx @ ll ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = low p \\<or>\n                   pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n                  var pt = i);\n        Dag (low (low p)) low high llt; Dag (high (low p)) low high rlt;\n        \\<forall>i>var (low p). llb ! i = ll ! i;\n        length llb = length ll\\<rbrakk>\n       \\<Longrightarrow> i \\<le> var p \\<longrightarrow>\n                         (\\<exists>prx.\n                             llb[var p := p # ll ! var p] ! i =\n                             prx @ ll ! i \\<and>\n                             (\\<forall>pt\\<in>set prx.\n                                 (pt = low p \\<or>\n                                  pt = p \\<or>\n                                  pt \\<in> set_of llt \\<or>\n                                  pt \\<in> set_of rlt) \\<and>\n                                 var pt = i))", "apply (rotate_tac 4)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>lt = Node llt (low p) rlt; var p < length ll; high p = Null;\n        p \\<noteq> Null; var (low p) < var p;\n        ordered (Node llt (low p) rlt) var; l = low p;\n        \\<forall>q.\n           (q = low p \\<longrightarrow>\n            low p \\<in> set (llb ! var (low p))) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>n.\n           n \\<noteq> low p \\<and>\n           n \\<notin> set_of llt \\<and>\n           n \\<notin> set_of rlt \\<longrightarrow>\n           marka n = mark n;\n        \\<forall>n.\n           (n = low p \\<longrightarrow> marka (low p) = m) \\<and>\n           (n \\<in> set_of llt \\<longrightarrow> marka n = m) \\<and>\n           (n \\<in> set_of rlt \\<longrightarrow> marka n = m);\n        low p \\<noteq> Null;\n        \\<forall>i\\<le>var (low p).\n           \\<exists>prx.\n              llb ! i = prx @ ll ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = low p \\<or>\n                   pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n                  var pt = i);\n        Dag (low (low p)) low high llt; Dag (high (low p)) low high rlt;\n        \\<forall>i>var (low p). llb ! i = ll ! i; length llb = length ll;\n        lla = llb; markb = marka;\n        Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n         (llb[var p := p # ll ! var p]);\n        rt = Tip\\<rbrakk>\n       \\<Longrightarrow> i \\<le> var p \\<longrightarrow>\n                         (\\<exists>prx.\n                             llb[var p := p # ll ! var p] ! i =\n                             prx @ ll ! i \\<and>\n                             (\\<forall>pt\\<in>set prx.\n                                 (pt = low p \\<or>\n                                  pt = p \\<or>\n                                  pt \\<in> set_of llt \\<or>\n                                  pt \\<in> set_of rlt) \\<and>\n                                 var pt = i))", "apply (erule_tac x=\"i\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>lt = Node llt (low p) rlt; var p < length ll; high p = Null;\n        p \\<noteq> Null; var (low p) < var p;\n        ordered (Node llt (low p) rlt) var; l = low p;\n        \\<forall>q.\n           (q = low p \\<longrightarrow>\n            low p \\<in> set (llb ! var (low p))) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>n.\n           n \\<noteq> low p \\<and>\n           n \\<notin> set_of llt \\<and>\n           n \\<notin> set_of rlt \\<longrightarrow>\n           marka n = mark n;\n        \\<forall>n.\n           (n = low p \\<longrightarrow> marka (low p) = m) \\<and>\n           (n \\<in> set_of llt \\<longrightarrow> marka n = m) \\<and>\n           (n \\<in> set_of rlt \\<longrightarrow> marka n = m);\n        low p \\<noteq> Null; Dag (low (low p)) low high llt;\n        Dag (high (low p)) low high rlt;\n        \\<forall>i>var (low p). llb ! i = ll ! i; length llb = length ll;\n        lla = llb; markb = marka;\n        Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n         (llb[var p := p # ll ! var p]);\n        rt = Tip;\n        i \\<le> var (low p) \\<longrightarrow>\n        (\\<exists>prx.\n            llb ! i = prx @ ll ! i \\<and>\n            (\\<forall>pt\\<in>set prx.\n                (pt = low p \\<or>\n                 pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n                var pt = i))\\<rbrakk>\n       \\<Longrightarrow> i \\<le> var p \\<longrightarrow>\n                         (\\<exists>prx.\n                             llb[var p := p # ll ! var p] ! i =\n                             prx @ ll ! i \\<and>\n                             (\\<forall>pt\\<in>set prx.\n                                 (pt = low p \\<or>\n                                  pt = p \\<or>\n                                  pt \\<in> set_of llt \\<or>\n                                  pt \\<in> set_of rlt) \\<and>\n                                 var pt = i))", "apply (case_tac \"i=var p\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>lt = Node llt (low p) rlt; var p < length ll; high p = Null;\n        p \\<noteq> Null; var (low p) < var p;\n        ordered (Node llt (low p) rlt) var; l = low p;\n        \\<forall>q.\n           (q = low p \\<longrightarrow>\n            low p \\<in> set (llb ! var (low p))) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>n.\n           n \\<noteq> low p \\<and>\n           n \\<notin> set_of llt \\<and>\n           n \\<notin> set_of rlt \\<longrightarrow>\n           marka n = mark n;\n        \\<forall>n.\n           (n = low p \\<longrightarrow> marka (low p) = m) \\<and>\n           (n \\<in> set_of llt \\<longrightarrow> marka n = m) \\<and>\n           (n \\<in> set_of rlt \\<longrightarrow> marka n = m);\n        low p \\<noteq> Null; Dag (low (low p)) low high llt;\n        Dag (high (low p)) low high rlt;\n        \\<forall>i>var (low p). llb ! i = ll ! i; length llb = length ll;\n        lla = llb; markb = marka;\n        Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n         (llb[var p := p # ll ! var p]);\n        rt = Tip;\n        i \\<le> var (low p) \\<longrightarrow>\n        (\\<exists>prx.\n            llb ! i = prx @ ll ! i \\<and>\n            (\\<forall>pt\\<in>set prx.\n                (pt = low p \\<or>\n                 pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n                var pt = i));\n        i = var p\\<rbrakk>\n       \\<Longrightarrow> i \\<le> var p \\<longrightarrow>\n                         (\\<exists>prx.\n                             llb[var p := p # ll ! var p] ! i =\n                             prx @ ll ! i \\<and>\n                             (\\<forall>pt\\<in>set prx.\n                                 (pt = low p \\<or>\n                                  pt = p \\<or>\n                                  pt \\<in> set_of llt \\<or>\n                                  pt \\<in> set_of rlt) \\<and>\n                                 var pt = i))\n 2. \\<And>i.\n       \\<lbrakk>lt = Node llt (low p) rlt; var p < length ll; high p = Null;\n        p \\<noteq> Null; var (low p) < var p;\n        ordered (Node llt (low p) rlt) var; l = low p;\n        \\<forall>q.\n           (q = low p \\<longrightarrow>\n            low p \\<in> set (llb ! var (low p))) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>n.\n           n \\<noteq> low p \\<and>\n           n \\<notin> set_of llt \\<and>\n           n \\<notin> set_of rlt \\<longrightarrow>\n           marka n = mark n;\n        \\<forall>n.\n           (n = low p \\<longrightarrow> marka (low p) = m) \\<and>\n           (n \\<in> set_of llt \\<longrightarrow> marka n = m) \\<and>\n           (n \\<in> set_of rlt \\<longrightarrow> marka n = m);\n        low p \\<noteq> Null; Dag (low (low p)) low high llt;\n        Dag (high (low p)) low high rlt;\n        \\<forall>i>var (low p). llb ! i = ll ! i; length llb = length ll;\n        lla = llb; markb = marka;\n        Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n         (llb[var p := p # ll ! var p]);\n        rt = Tip;\n        i \\<le> var (low p) \\<longrightarrow>\n        (\\<exists>prx.\n            llb ! i = prx @ ll ! i \\<and>\n            (\\<forall>pt\\<in>set prx.\n                (pt = low p \\<or>\n                 pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n                var pt = i));\n        i \\<noteq> var p\\<rbrakk>\n       \\<Longrightarrow> i \\<le> var p \\<longrightarrow>\n                         (\\<exists>prx.\n                             llb[var p := p # ll ! var p] ! i =\n                             prx @ ll ! i \\<and>\n                             (\\<forall>pt\\<in>set prx.\n                                 (pt = low p \\<or>\n                                  pt = p \\<or>\n                                  pt \\<in> set_of llt \\<or>\n                                  pt \\<in> set_of rlt) \\<and>\n                                 var pt = i))", "apply  simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>lt = Node llt (low p) rlt; var p < length ll; high p = Null;\n        p \\<noteq> Null; var (low p) < var p;\n        ordered (Node llt (low p) rlt) var; l = low p;\n        \\<forall>q.\n           (q = low p \\<longrightarrow>\n            low p \\<in> set (llb ! var (low p))) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>n.\n           n \\<noteq> low p \\<and>\n           n \\<notin> set_of llt \\<and>\n           n \\<notin> set_of rlt \\<longrightarrow>\n           marka n = mark n;\n        \\<forall>n.\n           (n = low p \\<longrightarrow> marka (low p) = m) \\<and>\n           (n \\<in> set_of llt \\<longrightarrow> marka n = m) \\<and>\n           (n \\<in> set_of rlt \\<longrightarrow> marka n = m);\n        low p \\<noteq> Null; Dag (low (low p)) low high llt;\n        Dag (high (low p)) low high rlt;\n        \\<forall>i>var (low p). llb ! i = ll ! i; length llb = length ll;\n        lla = llb; markb = marka;\n        Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n         (llb[var p := p # ll ! var p]);\n        rt = Tip;\n        i \\<le> var (low p) \\<longrightarrow>\n        (\\<exists>prx.\n            llb ! i = prx @ ll ! i \\<and>\n            (\\<forall>pt\\<in>set prx.\n                (pt = low p \\<or>\n                 pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n                var pt = i));\n        i \\<noteq> var p\\<rbrakk>\n       \\<Longrightarrow> i \\<le> var p \\<longrightarrow>\n                         (\\<exists>prx.\n                             llb[var p := p # ll ! var p] ! i =\n                             prx @ ll ! i \\<and>\n                             (\\<forall>pt\\<in>set prx.\n                                 (pt = low p \\<or>\n                                  pt = p \\<or>\n                                  pt \\<in> set_of llt \\<or>\n                                  pt \\<in> set_of rlt) \\<and>\n                                 var pt = i))", "apply (case_tac \"var (low p) < i\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>lt = Node llt (low p) rlt; var p < length ll; high p = Null;\n        p \\<noteq> Null; var (low p) < var p;\n        ordered (Node llt (low p) rlt) var; l = low p;\n        \\<forall>q.\n           (q = low p \\<longrightarrow>\n            low p \\<in> set (llb ! var (low p))) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>n.\n           n \\<noteq> low p \\<and>\n           n \\<notin> set_of llt \\<and>\n           n \\<notin> set_of rlt \\<longrightarrow>\n           marka n = mark n;\n        \\<forall>n.\n           (n = low p \\<longrightarrow> marka (low p) = m) \\<and>\n           (n \\<in> set_of llt \\<longrightarrow> marka n = m) \\<and>\n           (n \\<in> set_of rlt \\<longrightarrow> marka n = m);\n        low p \\<noteq> Null; Dag (low (low p)) low high llt;\n        Dag (high (low p)) low high rlt;\n        \\<forall>i>var (low p). llb ! i = ll ! i; length llb = length ll;\n        lla = llb; markb = marka;\n        Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n         (llb[var p := p # ll ! var p]);\n        rt = Tip;\n        i \\<le> var (low p) \\<longrightarrow>\n        (\\<exists>prx.\n            llb ! i = prx @ ll ! i \\<and>\n            (\\<forall>pt\\<in>set prx.\n                (pt = low p \\<or>\n                 pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n                var pt = i));\n        i \\<noteq> var p; var (low p) < i\\<rbrakk>\n       \\<Longrightarrow> i \\<le> var p \\<longrightarrow>\n                         (\\<exists>prx.\n                             llb[var p := p # ll ! var p] ! i =\n                             prx @ ll ! i \\<and>\n                             (\\<forall>pt\\<in>set prx.\n                                 (pt = low p \\<or>\n                                  pt = p \\<or>\n                                  pt \\<in> set_of llt \\<or>\n                                  pt \\<in> set_of rlt) \\<and>\n                                 var pt = i))\n 2. \\<And>i.\n       \\<lbrakk>lt = Node llt (low p) rlt; var p < length ll; high p = Null;\n        p \\<noteq> Null; var (low p) < var p;\n        ordered (Node llt (low p) rlt) var; l = low p;\n        \\<forall>q.\n           (q = low p \\<longrightarrow>\n            low p \\<in> set (llb ! var (low p))) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>n.\n           n \\<noteq> low p \\<and>\n           n \\<notin> set_of llt \\<and>\n           n \\<notin> set_of rlt \\<longrightarrow>\n           marka n = mark n;\n        \\<forall>n.\n           (n = low p \\<longrightarrow> marka (low p) = m) \\<and>\n           (n \\<in> set_of llt \\<longrightarrow> marka n = m) \\<and>\n           (n \\<in> set_of rlt \\<longrightarrow> marka n = m);\n        low p \\<noteq> Null; Dag (low (low p)) low high llt;\n        Dag (high (low p)) low high rlt;\n        \\<forall>i>var (low p). llb ! i = ll ! i; length llb = length ll;\n        lla = llb; markb = marka;\n        Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n         (llb[var p := p # ll ! var p]);\n        rt = Tip;\n        i \\<le> var (low p) \\<longrightarrow>\n        (\\<exists>prx.\n            llb ! i = prx @ ll ! i \\<and>\n            (\\<forall>pt\\<in>set prx.\n                (pt = low p \\<or>\n                 pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n                var pt = i));\n        i \\<noteq> var p; \\<not> var (low p) < i\\<rbrakk>\n       \\<Longrightarrow> i \\<le> var p \\<longrightarrow>\n                         (\\<exists>prx.\n                             llb[var p := p # ll ! var p] ! i =\n                             prx @ ll ! i \\<and>\n                             (\\<forall>pt\\<in>set prx.\n                                 (pt = low p \\<or>\n                                  pt = p \\<or>\n                                  pt \\<in> set_of llt \\<or>\n                                  pt \\<in> set_of rlt) \\<and>\n                                 var pt = i))", "apply  simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>lt = Node llt (low p) rlt; var p < length ll; high p = Null;\n        p \\<noteq> Null; var (low p) < var p;\n        ordered (Node llt (low p) rlt) var; l = low p;\n        \\<forall>q.\n           (q = low p \\<longrightarrow>\n            low p \\<in> set (llb ! var (low p))) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>n.\n           n \\<noteq> low p \\<and>\n           n \\<notin> set_of llt \\<and>\n           n \\<notin> set_of rlt \\<longrightarrow>\n           marka n = mark n;\n        \\<forall>n.\n           (n = low p \\<longrightarrow> marka (low p) = m) \\<and>\n           (n \\<in> set_of llt \\<longrightarrow> marka n = m) \\<and>\n           (n \\<in> set_of rlt \\<longrightarrow> marka n = m);\n        low p \\<noteq> Null; Dag (low (low p)) low high llt;\n        Dag (high (low p)) low high rlt;\n        \\<forall>i>var (low p). llb ! i = ll ! i; length llb = length ll;\n        lla = llb; markb = marka;\n        Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n         (llb[var p := p # ll ! var p]);\n        rt = Tip;\n        i \\<le> var (low p) \\<longrightarrow>\n        (\\<exists>prx.\n            llb ! i = prx @ ll ! i \\<and>\n            (\\<forall>pt\\<in>set prx.\n                (pt = low p \\<or>\n                 pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n                var pt = i));\n        i \\<noteq> var p; \\<not> var (low p) < i\\<rbrakk>\n       \\<Longrightarrow> i \\<le> var p \\<longrightarrow>\n                         (\\<exists>prx.\n                             llb[var p := p # ll ! var p] ! i =\n                             prx @ ll ! i \\<and>\n                             (\\<forall>pt\\<in>set prx.\n                                 (pt = low p \\<or>\n                                  pt = p \\<or>\n                                  pt \\<in> set_of llt \\<or>\n                                  pt \\<in> set_of rlt) \\<and>\n                                 var pt = i))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>lt = Node llt (low p) rlt; var p < length ll; high p = Null;\n        p \\<noteq> Null; var (low p) < var p;\n        ordered (Node llt (low p) rlt) var; l = low p;\n        \\<forall>q.\n           (q = low p \\<longrightarrow>\n            low p \\<in> set (llb ! var (low p))) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>n.\n           n \\<noteq> low p \\<and>\n           n \\<notin> set_of llt \\<and>\n           n \\<notin> set_of rlt \\<longrightarrow>\n           marka n = mark n;\n        \\<forall>n.\n           (n = low p \\<longrightarrow> marka (low p) = m) \\<and>\n           (n \\<in> set_of llt \\<longrightarrow> marka n = m) \\<and>\n           (n \\<in> set_of rlt \\<longrightarrow> marka n = m);\n        low p \\<noteq> Null; Dag (low (low p)) low high llt;\n        Dag (high (low p)) low high rlt;\n        \\<forall>i>var (low p). llb ! i = ll ! i; length llb = length ll;\n        lla = llb; markb = marka;\n        Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n         (llb[var p := p # ll ! var p]);\n        rt = Tip;\n        \\<exists>prx.\n           llb ! i = prx @ ll ! i \\<and>\n           (\\<forall>pt\\<in>set prx.\n               (pt = low p \\<or>\n                pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n               var pt = i);\n        \\<not> var (low p) < i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>prx.\n                            llb ! i = prx @ ll ! i \\<and>\n                            (\\<forall>pt\\<in>set prx.\n                                (pt = low p \\<or>\n                                 pt = p \\<or>\n                                 pt \\<in> set_of llt \\<or>\n                                 pt \\<in> set_of rlt) \\<and>\n                                var pt = i)", "apply (erule exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i prx.\n       \\<lbrakk>lt = Node llt (low p) rlt; var p < length ll; high p = Null;\n        p \\<noteq> Null; var (low p) < var p;\n        ordered (Node llt (low p) rlt) var; l = low p;\n        \\<forall>q.\n           (q = low p \\<longrightarrow>\n            low p \\<in> set (llb ! var (low p))) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>n.\n           n \\<noteq> low p \\<and>\n           n \\<notin> set_of llt \\<and>\n           n \\<notin> set_of rlt \\<longrightarrow>\n           marka n = mark n;\n        \\<forall>n.\n           (n = low p \\<longrightarrow> marka (low p) = m) \\<and>\n           (n \\<in> set_of llt \\<longrightarrow> marka n = m) \\<and>\n           (n \\<in> set_of rlt \\<longrightarrow> marka n = m);\n        low p \\<noteq> Null; Dag (low (low p)) low high llt;\n        Dag (high (low p)) low high rlt;\n        \\<forall>i>var (low p). llb ! i = ll ! i; length llb = length ll;\n        lla = llb; markb = marka;\n        Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n         (llb[var p := p # ll ! var p]);\n        rt = Tip; \\<not> var (low p) < i;\n        llb ! i = prx @ ll ! i \\<and>\n        (\\<forall>pt\\<in>set prx.\n            (pt = low p \\<or>\n             pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n            var pt = i)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>prx.\n                            llb ! i = prx @ ll ! i \\<and>\n                            (\\<forall>pt\\<in>set prx.\n                                (pt = low p \\<or>\n                                 pt = p \\<or>\n                                 pt \\<in> set_of llt \\<or>\n                                 pt \\<in> set_of rlt) \\<and>\n                                var pt = i)", "apply (rule_tac x=\"prx\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i prx.\n       \\<lbrakk>lt = Node llt (low p) rlt; var p < length ll; high p = Null;\n        p \\<noteq> Null; var (low p) < var p;\n        ordered (Node llt (low p) rlt) var; l = low p;\n        \\<forall>q.\n           (q = low p \\<longrightarrow>\n            low p \\<in> set (llb ! var (low p))) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>n.\n           n \\<noteq> low p \\<and>\n           n \\<notin> set_of llt \\<and>\n           n \\<notin> set_of rlt \\<longrightarrow>\n           marka n = mark n;\n        \\<forall>n.\n           (n = low p \\<longrightarrow> marka (low p) = m) \\<and>\n           (n \\<in> set_of llt \\<longrightarrow> marka n = m) \\<and>\n           (n \\<in> set_of rlt \\<longrightarrow> marka n = m);\n        low p \\<noteq> Null; Dag (low (low p)) low high llt;\n        Dag (high (low p)) low high rlt;\n        \\<forall>i>var (low p). llb ! i = ll ! i; length llb = length ll;\n        lla = llb; markb = marka;\n        Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n         (llb[var p := p # ll ! var p]);\n        rt = Tip; \\<not> var (low p) < i;\n        llb ! i = prx @ ll ! i \\<and>\n        (\\<forall>pt\\<in>set prx.\n            (pt = low p \\<or>\n             pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n            var pt = i)\\<rbrakk>\n       \\<Longrightarrow> llb ! i = prx @ ll ! i \\<and>\n                         (\\<forall>pt\\<in>set prx.\n                             (pt = low p \\<or>\n                              pt = p \\<or>\n                              pt \\<in> set_of llt \\<or>\n                              pt \\<in> set_of rlt) \\<and>\n                             var pt = i)", "apply (intro conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i prx.\n       \\<lbrakk>lt = Node llt (low p) rlt; var p < length ll; high p = Null;\n        p \\<noteq> Null; var (low p) < var p;\n        ordered (Node llt (low p) rlt) var; l = low p;\n        \\<forall>q.\n           (q = low p \\<longrightarrow>\n            low p \\<in> set (llb ! var (low p))) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>n.\n           n \\<noteq> low p \\<and>\n           n \\<notin> set_of llt \\<and>\n           n \\<notin> set_of rlt \\<longrightarrow>\n           marka n = mark n;\n        \\<forall>n.\n           (n = low p \\<longrightarrow> marka (low p) = m) \\<and>\n           (n \\<in> set_of llt \\<longrightarrow> marka n = m) \\<and>\n           (n \\<in> set_of rlt \\<longrightarrow> marka n = m);\n        low p \\<noteq> Null; Dag (low (low p)) low high llt;\n        Dag (high (low p)) low high rlt;\n        \\<forall>i>var (low p). llb ! i = ll ! i; length llb = length ll;\n        lla = llb; markb = marka;\n        Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n         (llb[var p := p # ll ! var p]);\n        rt = Tip; \\<not> var (low p) < i;\n        llb ! i = prx @ ll ! i \\<and>\n        (\\<forall>pt\\<in>set prx.\n            (pt = low p \\<or>\n             pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n            var pt = i)\\<rbrakk>\n       \\<Longrightarrow> llb ! i = prx @ ll ! i\n 2. \\<And>i prx.\n       \\<lbrakk>lt = Node llt (low p) rlt; var p < length ll; high p = Null;\n        p \\<noteq> Null; var (low p) < var p;\n        ordered (Node llt (low p) rlt) var; l = low p;\n        \\<forall>q.\n           (q = low p \\<longrightarrow>\n            low p \\<in> set (llb ! var (low p))) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>n.\n           n \\<noteq> low p \\<and>\n           n \\<notin> set_of llt \\<and>\n           n \\<notin> set_of rlt \\<longrightarrow>\n           marka n = mark n;\n        \\<forall>n.\n           (n = low p \\<longrightarrow> marka (low p) = m) \\<and>\n           (n \\<in> set_of llt \\<longrightarrow> marka n = m) \\<and>\n           (n \\<in> set_of rlt \\<longrightarrow> marka n = m);\n        low p \\<noteq> Null; Dag (low (low p)) low high llt;\n        Dag (high (low p)) low high rlt;\n        \\<forall>i>var (low p). llb ! i = ll ! i; length llb = length ll;\n        lla = llb; markb = marka;\n        Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n         (llb[var p := p # ll ! var p]);\n        rt = Tip; \\<not> var (low p) < i;\n        llb ! i = prx @ ll ! i \\<and>\n        (\\<forall>pt\\<in>set prx.\n            (pt = low p \\<or>\n             pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n            var pt = i)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>pt\\<in>set prx.\n                            (pt = low p \\<or>\n                             pt = p \\<or>\n                             pt \\<in> set_of llt \\<or>\n                             pt \\<in> set_of rlt) \\<and>\n                            var pt = i", "apply  simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i prx.\n       \\<lbrakk>lt = Node llt (low p) rlt; var p < length ll; high p = Null;\n        p \\<noteq> Null; var (low p) < var p;\n        ordered (Node llt (low p) rlt) var; l = low p;\n        \\<forall>q.\n           (q = low p \\<longrightarrow>\n            low p \\<in> set (llb ! var (low p))) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>n.\n           n \\<noteq> low p \\<and>\n           n \\<notin> set_of llt \\<and>\n           n \\<notin> set_of rlt \\<longrightarrow>\n           marka n = mark n;\n        \\<forall>n.\n           (n = low p \\<longrightarrow> marka (low p) = m) \\<and>\n           (n \\<in> set_of llt \\<longrightarrow> marka n = m) \\<and>\n           (n \\<in> set_of rlt \\<longrightarrow> marka n = m);\n        low p \\<noteq> Null; Dag (low (low p)) low high llt;\n        Dag (high (low p)) low high rlt;\n        \\<forall>i>var (low p). llb ! i = ll ! i; length llb = length ll;\n        lla = llb; markb = marka;\n        Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n         (llb[var p := p # ll ! var p]);\n        rt = Tip; \\<not> var (low p) < i;\n        llb ! i = prx @ ll ! i \\<and>\n        (\\<forall>pt\\<in>set prx.\n            (pt = low p \\<or>\n             pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n            var pt = i)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>pt\\<in>set prx.\n                            (pt = low p \\<or>\n                             pt = p \\<or>\n                             pt \\<in> set_of llt \\<or>\n                             pt \\<in> set_of rlt) \\<and>\n                            var pt = i", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i prx pt.\n       \\<lbrakk>lt = Node llt (low p) rlt; var p < length ll; high p = Null;\n        p \\<noteq> Null; var (low p) < var p;\n        ordered (Node llt (low p) rlt) var; l = low p;\n        \\<forall>q.\n           (q = low p \\<longrightarrow>\n            low p \\<in> set (llb ! var (low p))) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>n.\n           n \\<noteq> low p \\<and>\n           n \\<notin> set_of llt \\<and>\n           n \\<notin> set_of rlt \\<longrightarrow>\n           marka n = mark n;\n        \\<forall>n.\n           (n = low p \\<longrightarrow> marka (low p) = m) \\<and>\n           (n \\<in> set_of llt \\<longrightarrow> marka n = m) \\<and>\n           (n \\<in> set_of rlt \\<longrightarrow> marka n = m);\n        low p \\<noteq> Null; Dag (low (low p)) low high llt;\n        Dag (high (low p)) low high rlt;\n        \\<forall>i>var (low p). llb ! i = ll ! i; length llb = length ll;\n        lla = llb; markb = marka;\n        Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n         (llb[var p := p # ll ! var p]);\n        rt = Tip; \\<not> var (low p) < i; pt \\<in> set prx;\n        llb ! i = prx @ ll ! i;\n        \\<forall>pt\\<in>set prx.\n           (pt = low p \\<or>\n            pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n           var pt = i\\<rbrakk>\n       \\<Longrightarrow> (pt = low p \\<or>\n                          pt = p \\<or>\n                          pt \\<in> set_of llt \\<or>\n                          pt \\<in> set_of rlt) \\<and>\n                         var pt = i", "apply (rotate_tac 15)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i prx pt.\n       \\<lbrakk>lla = llb; markb = marka;\n        Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n         (llb[var p := p # ll ! var p]);\n        rt = Tip; \\<not> var (low p) < i; pt \\<in> set prx;\n        llb ! i = prx @ ll ! i;\n        \\<forall>pt\\<in>set prx.\n           (pt = low p \\<or>\n            pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n           var pt = i;\n        lt = Node llt (low p) rlt; var p < length ll; high p = Null;\n        p \\<noteq> Null; var (low p) < var p;\n        ordered (Node llt (low p) rlt) var; l = low p;\n        \\<forall>q.\n           (q = low p \\<longrightarrow>\n            low p \\<in> set (llb ! var (low p))) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>n.\n           n \\<noteq> low p \\<and>\n           n \\<notin> set_of llt \\<and>\n           n \\<notin> set_of rlt \\<longrightarrow>\n           marka n = mark n;\n        \\<forall>n.\n           (n = low p \\<longrightarrow> marka (low p) = m) \\<and>\n           (n \\<in> set_of llt \\<longrightarrow> marka n = m) \\<and>\n           (n \\<in> set_of rlt \\<longrightarrow> marka n = m);\n        low p \\<noteq> Null; Dag (low (low p)) low high llt;\n        Dag (high (low p)) low high rlt;\n        \\<forall>i>var (low p). llb ! i = ll ! i;\n        length llb = length ll\\<rbrakk>\n       \\<Longrightarrow> (pt = low p \\<or>\n                          pt = p \\<or>\n                          pt \\<in> set_of llt \\<or>\n                          pt \\<in> set_of rlt) \\<and>\n                         var pt = i", "apply (erule_tac x=\"pt\" in ballE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i prx pt.\n       \\<lbrakk>lla = llb; markb = marka;\n        Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n         (llb[var p := p # ll ! var p]);\n        rt = Tip; \\<not> var (low p) < i; pt \\<in> set prx;\n        llb ! i = prx @ ll ! i; lt = Node llt (low p) rlt;\n        var p < length ll; high p = Null; p \\<noteq> Null;\n        var (low p) < var p; ordered (Node llt (low p) rlt) var; l = low p;\n        \\<forall>q.\n           (q = low p \\<longrightarrow>\n            low p \\<in> set (llb ! var (low p))) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>n.\n           n \\<noteq> low p \\<and>\n           n \\<notin> set_of llt \\<and>\n           n \\<notin> set_of rlt \\<longrightarrow>\n           marka n = mark n;\n        \\<forall>n.\n           (n = low p \\<longrightarrow> marka (low p) = m) \\<and>\n           (n \\<in> set_of llt \\<longrightarrow> marka n = m) \\<and>\n           (n \\<in> set_of rlt \\<longrightarrow> marka n = m);\n        low p \\<noteq> Null; Dag (low (low p)) low high llt;\n        Dag (high (low p)) low high rlt;\n        \\<forall>i>var (low p). llb ! i = ll ! i; length llb = length ll;\n        (pt = low p \\<or>\n         pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n        var pt = i\\<rbrakk>\n       \\<Longrightarrow> (pt = low p \\<or>\n                          pt = p \\<or>\n                          pt \\<in> set_of llt \\<or>\n                          pt \\<in> set_of rlt) \\<and>\n                         var pt = i\n 2. \\<And>i prx pt.\n       \\<lbrakk>lla = llb; markb = marka;\n        Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n         (llb[var p := p # ll ! var p]);\n        rt = Tip; \\<not> var (low p) < i; pt \\<in> set prx;\n        llb ! i = prx @ ll ! i; lt = Node llt (low p) rlt;\n        var p < length ll; high p = Null; p \\<noteq> Null;\n        var (low p) < var p; ordered (Node llt (low p) rlt) var; l = low p;\n        \\<forall>q.\n           (q = low p \\<longrightarrow>\n            low p \\<in> set (llb ! var (low p))) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>n.\n           n \\<noteq> low p \\<and>\n           n \\<notin> set_of llt \\<and>\n           n \\<notin> set_of rlt \\<longrightarrow>\n           marka n = mark n;\n        \\<forall>n.\n           (n = low p \\<longrightarrow> marka (low p) = m) \\<and>\n           (n \\<in> set_of llt \\<longrightarrow> marka n = m) \\<and>\n           (n \\<in> set_of rlt \\<longrightarrow> marka n = m);\n        low p \\<noteq> Null; Dag (low (low p)) low high llt;\n        Dag (high (low p)) low high rlt;\n        \\<forall>i>var (low p). llb ! i = ll ! i; length llb = length ll;\n        pt \\<notin> set prx\\<rbrakk>\n       \\<Longrightarrow> (pt = low p \\<or>\n                          pt = p \\<or>\n                          pt \\<in> set_of llt \\<or>\n                          pt \\<in> set_of rlt) \\<and>\n                         var pt = i", "apply  fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i prx pt.\n       \\<lbrakk>lla = llb; markb = marka;\n        Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n         (llb[var p := p # ll ! var p]);\n        rt = Tip; \\<not> var (low p) < i; pt \\<in> set prx;\n        llb ! i = prx @ ll ! i; lt = Node llt (low p) rlt;\n        var p < length ll; high p = Null; p \\<noteq> Null;\n        var (low p) < var p; ordered (Node llt (low p) rlt) var; l = low p;\n        \\<forall>q.\n           (q = low p \\<longrightarrow>\n            low p \\<in> set (llb ! var (low p))) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>n.\n           n \\<noteq> low p \\<and>\n           n \\<notin> set_of llt \\<and>\n           n \\<notin> set_of rlt \\<longrightarrow>\n           marka n = mark n;\n        \\<forall>n.\n           (n = low p \\<longrightarrow> marka (low p) = m) \\<and>\n           (n \\<in> set_of llt \\<longrightarrow> marka n = m) \\<and>\n           (n \\<in> set_of rlt \\<longrightarrow> marka n = m);\n        low p \\<noteq> Null; Dag (low (low p)) low high llt;\n        Dag (high (low p)) low high rlt;\n        \\<forall>i>var (low p). llb ! i = ll ! i; length llb = length ll;\n        pt \\<notin> set prx\\<rbrakk>\n       \\<Longrightarrow> (pt = low p \\<or>\n                          pt = p \\<or>\n                          pt \\<in> set_of llt \\<or>\n                          pt \\<in> set_of rlt) \\<and>\n                         var pt = i", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>ll'.\n     Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n      ll' \\<and>\n     wf_levellist (Node lt p rt) ll ll' var \\<and>\n     wf_marking (Node lt p rt) mark (markb(p := m)) m\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       rt = Node x21 x22 x23 \\<Longrightarrow>\n       \\<exists>ll'.\n          Levellist (levellistb[var p := p])\n           (nextb(p := levellistb ! var p)) ll' \\<and>\n          wf_levellist (Node lt p rt) ll ll' var \\<and>\n          wf_marking (Node lt p rt) mark (markb(p := m)) m", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       rt = Node x21 x22 x23 \\<Longrightarrow>\n       \\<exists>ll'.\n          Levellist (levellistb[var p := p])\n           (nextb(p := levellistb ! var p)) ll' \\<and>\n          wf_levellist (Node lt p rt) ll ll' var \\<and>\n          wf_marking (Node lt p rt) mark (markb(p := m)) m", "case (Node lrt r rrt)"], ["proof (state)\nthis:\n  rt = Node lrt r rrt\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       rt = Node x21 x22 x23 \\<Longrightarrow>\n       \\<exists>ll'.\n          Levellist (levellistb[var p := p])\n           (nextb(p := levellistb ! var p)) ll' \\<and>\n          wf_levellist (Node lt p rt) ll ll' var \\<and>\n          wf_marking (Node lt p rt) mark (markb(p := m)) m", "have rt_Node: \"rt = Node lrt r rrt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rt = Node lrt r rrt", "by fact"], ["proof (state)\nthis:\n  rt = Node lrt r rrt\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       rt = Node x21 x22 x23 \\<Longrightarrow>\n       \\<exists>ll'.\n          Levellist (levellistb[var p := p])\n           (nextb(p := levellistb ! var p)) ll' \\<and>\n          wf_levellist (Node lt p rt) ll ll' var \\<and>\n          wf_marking (Node lt p rt) mark (markb(p := m)) m", "from wfll_rt rt_Node"], ["proof (chain)\npicking this:\n  wf_levellist rt lla llb var\n  rt = Node lrt r rrt", "have llb_eq_lla: \"length llb = length lla\""], ["proof (prove)\nusing this:\n  wf_levellist rt lla llb var\n  rt = Node lrt r rrt\n\ngoal (1 subgoal):\n 1. length llb = length lla", "by (simp add: wf_levellist_def)"], ["proof (state)\nthis:\n  length llb = length lla\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       rt = Node x21 x22 x23 \\<Longrightarrow>\n       \\<exists>ll'.\n          Levellist (levellistb[var p := p])\n           (nextb(p := levellistb ! var p)) ll' \\<and>\n          wf_levellist (Node lt p rt) ll ll' var \\<and>\n          wf_marking (Node lt p rt) mark (markb(p := m)) m", "with llb lla"], ["proof (chain)\npicking this:\n  Levellist levellistb nextb llb\n  Levellist levellista nexta lla\n  length llb = length lla", "have llb_eq_lla': \"length levellistb = length levellista\""], ["proof (prove)\nusing this:\n  Levellist levellistb nextb llb\n  Levellist levellista nexta lla\n  length llb = length lla\n\ngoal (1 subgoal):\n 1. length levellistb = length levellista", "by (simp add: Levellist_length)"], ["proof (state)\nthis:\n  length levellistb = length levellista\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       rt = Node x21 x22 x23 \\<Longrightarrow>\n       \\<exists>ll'.\n          Levellist (levellistb[var p := p])\n           (nextb(p := levellistb ! var p)) ll' \\<and>\n          wf_levellist (Node lt p rt) ll ll' var \\<and>\n          wf_marking (Node lt p rt) mark (markb(p := m)) m", "from wfll_rt rt_Node"], ["proof (chain)\npicking this:\n  wf_levellist rt lla llb var\n  rt = Node lrt r rrt", "have nodes_in_llb: \"\\<forall>q. q \\<in> set_of rt \\<longrightarrow> q \\<in> set (llb ! (q\\<rightarrow>var))\""], ["proof (prove)\nusing this:\n  wf_levellist rt lla llb var\n  rt = Node lrt r rrt\n\ngoal (1 subgoal):\n 1. \\<forall>q.\n       q \\<in> set_of rt \\<longrightarrow> q \\<in> set (llb ! var q)", "by (simp add: wf_levellist_def)"], ["proof (state)\nthis:\n  \\<forall>q. q \\<in> set_of rt \\<longrightarrow> q \\<in> set (llb ! var q)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       rt = Node x21 x22 x23 \\<Longrightarrow>\n       \\<exists>ll'.\n          Levellist (levellistb[var p := p])\n           (nextb(p := levellistb ! var p)) ll' \\<and>\n          wf_levellist (Node lt p rt) ll ll' var \\<and>\n          wf_marking (Node lt p rt) mark (markb(p := m)) m", "from wfll_rt rt_Node rt"], ["proof (chain)\npicking this:\n  wf_levellist rt lla llb var\n  rt = Node lrt r rrt\n  Dag (high p) low high rt", "have llb_st: \"(\\<forall> i \\<le> (high p)\\<rightarrow>var.\n                             (\\<exists> prx. (llb ! i) = prx@(lla ! i) \\<and>\n                             (\\<forall>pt \\<in> set prx. pt \\<in> set_of rt \\<and> pt\\<rightarrow>var = i)))\""], ["proof (prove)\nusing this:\n  wf_levellist rt lla llb var\n  rt = Node lrt r rrt\n  Dag (high p) low high rt\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<le>var (high p).\n       \\<exists>prx.\n          llb ! i = prx @ lla ! i \\<and>\n          (\\<forall>pt\\<in>set prx. pt \\<in> set_of rt \\<and> var pt = i)", "by (simp add: wf_levellist_def)"], ["proof (state)\nthis:\n  \\<forall>i\\<le>var (high p).\n     \\<exists>prx.\n        llb ! i = prx @ lla ! i \\<and>\n        (\\<forall>pt\\<in>set prx. pt \\<in> set_of rt \\<and> var pt = i)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       rt = Node x21 x22 x23 \\<Longrightarrow>\n       \\<exists>ll'.\n          Levellist (levellistb[var p := p])\n           (nextb(p := levellistb ! var p)) ll' \\<and>\n          wf_levellist (Node lt p rt) ll ll' var \\<and>\n          wf_marking (Node lt p rt) mark (markb(p := m)) m", "from wfll_rt rt_Node rt"], ["proof (chain)\npicking this:\n  wf_levellist rt lla llb var\n  rt = Node lrt r rrt\n  Dag (high p) low high rt", "have llb_nc:\n                \"\\<forall>i. ((high p)\\<rightarrow>var) < i \\<longrightarrow> (llb ! i) = (lla ! i)\""], ["proof (prove)\nusing this:\n  wf_levellist rt lla llb var\n  rt = Node lrt r rrt\n  Dag (high p) low high rt\n\ngoal (1 subgoal):\n 1. \\<forall>i>var (high p). llb ! i = lla ! i", "by (simp add: wf_levellist_def)"], ["proof (state)\nthis:\n  \\<forall>i>var (high p). llb ! i = lla ! i\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       rt = Node x21 x22 x23 \\<Longrightarrow>\n       \\<exists>ll'.\n          Levellist (levellistb[var p := p])\n           (nextb(p := levellistb ! var p)) ll' \\<and>\n          wf_levellist (Node lt p rt) ll ll' var \\<and>\n          wf_marking (Node lt p rt) mark (markb(p := m)) m", "from wfmarking_rt rt_Node rt"], ["proof (chain)\npicking this:\n  wf_marking rt marka markb m\n  rt = Node lrt r rrt\n  Dag (high p) low high rt", "have mort_nc: \"\\<forall>n. n \\<notin> set_of rt \\<longrightarrow> marka n = markb n\""], ["proof (prove)\nusing this:\n  wf_marking rt marka markb m\n  rt = Node lrt r rrt\n  Dag (high p) low high rt\n\ngoal (1 subgoal):\n 1. \\<forall>n. n \\<notin> set_of rt \\<longrightarrow> marka n = markb n", "by (simp add: wf_marking_def)"], ["proof (state)\nthis:\n  \\<forall>n. n \\<notin> set_of rt \\<longrightarrow> marka n = markb n\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       rt = Node x21 x22 x23 \\<Longrightarrow>\n       \\<exists>ll'.\n          Levellist (levellistb[var p := p])\n           (nextb(p := levellistb ! var p)) ll' \\<and>\n          wf_levellist (Node lt p rt) ll ll' var \\<and>\n          wf_marking (Node lt p rt) mark (markb(p := m)) m", "from wfmarking_rt rt_Node rt"], ["proof (chain)\npicking this:\n  wf_marking rt marka markb m\n  rt = Node lrt r rrt\n  Dag (high p) low high rt", "have mirt_marked: \"\\<forall>n. n \\<in> set_of rt \\<longrightarrow> markb n = m\""], ["proof (prove)\nusing this:\n  wf_marking rt marka markb m\n  rt = Node lrt r rrt\n  Dag (high p) low high rt\n\ngoal (1 subgoal):\n 1. \\<forall>n. n \\<in> set_of rt \\<longrightarrow> markb n = m", "by (simp add: wf_marking_def)"], ["proof (state)\nthis:\n  \\<forall>n. n \\<in> set_of rt \\<longrightarrow> markb n = m\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       rt = Node x21 x22 x23 \\<Longrightarrow>\n       \\<exists>ll'.\n          Levellist (levellistb[var p := p])\n           (nextb(p := levellistb ! var p)) ll' \\<and>\n          wf_levellist (Node lt p rt) ll ll' var \\<and>\n          wf_marking (Node lt p rt) mark (markb(p := m)) m", "with p_notin_ll wfll_rt wfll_lt"], ["proof (chain)\npicking this:\n  p \\<notin> set (concat ll)\n  wf_levellist rt lla llb var\n  wf_levellist lt ll lla var\n  \\<forall>n. n \\<in> set_of rt \\<longrightarrow> markb n = m", "have p_notin_llb: \"\\<forall>i < length llb. p \\<notin> set (llb ! i)\""], ["proof (prove)\nusing this:\n  p \\<notin> set (concat ll)\n  wf_levellist rt lla llb var\n  wf_levellist lt ll lla var\n  \\<forall>n. n \\<in> set_of rt \\<longrightarrow> markb n = m\n\ngoal (1 subgoal):\n 1. \\<forall>i<length llb. p \\<notin> set (llb ! i)", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<notin> set (concat ll); wf_levellist rt lla llb var;\n     wf_levellist lt ll lla var;\n     \\<forall>n. n \\<in> set_of rt \\<longrightarrow> markb n = m\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i<length llb. p \\<notin> set (llb ! i)", "apply (intro allI impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>p \\<notin> set (concat ll); wf_levellist rt lla llb var;\n        wf_levellist lt ll lla var;\n        \\<forall>n. n \\<in> set_of rt \\<longrightarrow> markb n = m;\n        i < length llb\\<rbrakk>\n       \\<Longrightarrow> p \\<notin> set (llb ! i)", "apply (clarsimp simp add: wf_levellist_def lt_Node rt_Node)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<forall>x\\<in>set ll. p \\<notin> set x;\n        \\<forall>n.\n           (n = r \\<longrightarrow> markb r = m) \\<and>\n           (n \\<in> set_of lrt \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of rrt \\<longrightarrow> markb n = m);\n        i < length ll;\n        \\<forall>q.\n           (q = r \\<longrightarrow> r \\<in> set (llb ! var r)) \\<and>\n           (q \\<in> set_of lrt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rrt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>q.\n           (q = l \\<longrightarrow> l \\<in> set (lla ! var l)) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (lla ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (lla ! var q));\n        \\<forall>i\\<le>var r.\n           \\<exists>prx.\n              llb ! i = prx @ lla ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = r \\<or>\n                   pt \\<in> set_of lrt \\<or> pt \\<in> set_of rrt) \\<and>\n                  var pt = i);\n        \\<forall>i\\<le>var l.\n           \\<exists>prx.\n              lla ! i = prx @ ll ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = l \\<or>\n                   pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n                  var pt = i);\n        \\<forall>i>var r. llb ! i = lla ! i; length llb = length ll;\n        \\<forall>i>var l. lla ! i = ll ! i; length lla = length ll;\n        p \\<in> set (llb ! i)\\<rbrakk>\n       \\<Longrightarrow> False", "apply (case_tac \"i \\<le> var r\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>\\<forall>x\\<in>set ll. p \\<notin> set x;\n        \\<forall>n.\n           (n = r \\<longrightarrow> markb r = m) \\<and>\n           (n \\<in> set_of lrt \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of rrt \\<longrightarrow> markb n = m);\n        i < length ll;\n        \\<forall>q.\n           (q = r \\<longrightarrow> r \\<in> set (llb ! var r)) \\<and>\n           (q \\<in> set_of lrt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rrt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>q.\n           (q = l \\<longrightarrow> l \\<in> set (lla ! var l)) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (lla ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (lla ! var q));\n        \\<forall>i\\<le>var r.\n           \\<exists>prx.\n              llb ! i = prx @ lla ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = r \\<or>\n                   pt \\<in> set_of lrt \\<or> pt \\<in> set_of rrt) \\<and>\n                  var pt = i);\n        \\<forall>i\\<le>var l.\n           \\<exists>prx.\n              lla ! i = prx @ ll ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = l \\<or>\n                   pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n                  var pt = i);\n        \\<forall>i>var r. llb ! i = lla ! i; length llb = length ll;\n        \\<forall>i>var l. lla ! i = ll ! i; length lla = length ll;\n        p \\<in> set (llb ! i); i \\<le> var r\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>i.\n       \\<lbrakk>\\<forall>x\\<in>set ll. p \\<notin> set x;\n        \\<forall>n.\n           (n = r \\<longrightarrow> markb r = m) \\<and>\n           (n \\<in> set_of lrt \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of rrt \\<longrightarrow> markb n = m);\n        i < length ll;\n        \\<forall>q.\n           (q = r \\<longrightarrow> r \\<in> set (llb ! var r)) \\<and>\n           (q \\<in> set_of lrt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rrt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>q.\n           (q = l \\<longrightarrow> l \\<in> set (lla ! var l)) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (lla ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (lla ! var q));\n        \\<forall>i\\<le>var r.\n           \\<exists>prx.\n              llb ! i = prx @ lla ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = r \\<or>\n                   pt \\<in> set_of lrt \\<or> pt \\<in> set_of rrt) \\<and>\n                  var pt = i);\n        \\<forall>i\\<le>var l.\n           \\<exists>prx.\n              lla ! i = prx @ ll ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = l \\<or>\n                   pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n                  var pt = i);\n        \\<forall>i>var r. llb ! i = lla ! i; length llb = length ll;\n        \\<forall>i>var l. lla ! i = ll ! i; length lla = length ll;\n        p \\<in> set (llb ! i); \\<not> i \\<le> var r\\<rbrakk>\n       \\<Longrightarrow> False", "apply  (drule_tac x=i in spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>\\<forall>x\\<in>set ll. p \\<notin> set x;\n        \\<forall>n.\n           (n = r \\<longrightarrow> markb r = m) \\<and>\n           (n \\<in> set_of lrt \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of rrt \\<longrightarrow> markb n = m);\n        i < length ll;\n        \\<forall>q.\n           (q = r \\<longrightarrow> r \\<in> set (llb ! var r)) \\<and>\n           (q \\<in> set_of lrt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rrt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>q.\n           (q = l \\<longrightarrow> l \\<in> set (lla ! var l)) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (lla ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (lla ! var q));\n        \\<forall>i\\<le>var l.\n           \\<exists>prx.\n              lla ! i = prx @ ll ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = l \\<or>\n                   pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n                  var pt = i);\n        \\<forall>i>var r. llb ! i = lla ! i; length llb = length ll;\n        \\<forall>i>var l. lla ! i = ll ! i; length lla = length ll;\n        p \\<in> set (llb ! i); i \\<le> var r;\n        i \\<le> var r \\<longrightarrow>\n        (\\<exists>prx.\n            llb ! i = prx @ lla ! i \\<and>\n            (\\<forall>pt\\<in>set prx.\n                (pt = r \\<or>\n                 pt \\<in> set_of lrt \\<or> pt \\<in> set_of rrt) \\<and>\n                var pt = i))\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>i.\n       \\<lbrakk>\\<forall>x\\<in>set ll. p \\<notin> set x;\n        \\<forall>n.\n           (n = r \\<longrightarrow> markb r = m) \\<and>\n           (n \\<in> set_of lrt \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of rrt \\<longrightarrow> markb n = m);\n        i < length ll;\n        \\<forall>q.\n           (q = r \\<longrightarrow> r \\<in> set (llb ! var r)) \\<and>\n           (q \\<in> set_of lrt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rrt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>q.\n           (q = l \\<longrightarrow> l \\<in> set (lla ! var l)) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (lla ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (lla ! var q));\n        \\<forall>i\\<le>var r.\n           \\<exists>prx.\n              llb ! i = prx @ lla ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = r \\<or>\n                   pt \\<in> set_of lrt \\<or> pt \\<in> set_of rrt) \\<and>\n                  var pt = i);\n        \\<forall>i\\<le>var l.\n           \\<exists>prx.\n              lla ! i = prx @ ll ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = l \\<or>\n                   pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n                  var pt = i);\n        \\<forall>i>var r. llb ! i = lla ! i; length llb = length ll;\n        \\<forall>i>var l. lla ! i = ll ! i; length lla = length ll;\n        p \\<in> set (llb ! i); \\<not> i \\<le> var r\\<rbrakk>\n       \\<Longrightarrow> False", "using  orderedt rt_Node lt_Node"], ["proof (prove)\nusing this:\n  ordered (Node lt p rt) var\n  rt = Node lrt r rrt\n  lt = Node llt l rlt\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>\\<forall>x\\<in>set ll. p \\<notin> set x;\n        \\<forall>n.\n           (n = r \\<longrightarrow> markb r = m) \\<and>\n           (n \\<in> set_of lrt \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of rrt \\<longrightarrow> markb n = m);\n        i < length ll;\n        \\<forall>q.\n           (q = r \\<longrightarrow> r \\<in> set (llb ! var r)) \\<and>\n           (q \\<in> set_of lrt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rrt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>q.\n           (q = l \\<longrightarrow> l \\<in> set (lla ! var l)) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (lla ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (lla ! var q));\n        \\<forall>i\\<le>var l.\n           \\<exists>prx.\n              lla ! i = prx @ ll ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = l \\<or>\n                   pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n                  var pt = i);\n        \\<forall>i>var r. llb ! i = lla ! i; length llb = length ll;\n        \\<forall>i>var l. lla ! i = ll ! i; length lla = length ll;\n        p \\<in> set (llb ! i); i \\<le> var r;\n        i \\<le> var r \\<longrightarrow>\n        (\\<exists>prx.\n            llb ! i = prx @ lla ! i \\<and>\n            (\\<forall>pt\\<in>set prx.\n                (pt = r \\<or>\n                 pt \\<in> set_of lrt \\<or> pt \\<in> set_of rrt) \\<and>\n                var pt = i))\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>i.\n       \\<lbrakk>\\<forall>x\\<in>set ll. p \\<notin> set x;\n        \\<forall>n.\n           (n = r \\<longrightarrow> markb r = m) \\<and>\n           (n \\<in> set_of lrt \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of rrt \\<longrightarrow> markb n = m);\n        i < length ll;\n        \\<forall>q.\n           (q = r \\<longrightarrow> r \\<in> set (llb ! var r)) \\<and>\n           (q \\<in> set_of lrt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rrt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>q.\n           (q = l \\<longrightarrow> l \\<in> set (lla ! var l)) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (lla ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (lla ! var q));\n        \\<forall>i\\<le>var r.\n           \\<exists>prx.\n              llb ! i = prx @ lla ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = r \\<or>\n                   pt \\<in> set_of lrt \\<or> pt \\<in> set_of rrt) \\<and>\n                  var pt = i);\n        \\<forall>i\\<le>var l.\n           \\<exists>prx.\n              lla ! i = prx @ ll ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = l \\<or>\n                   pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n                  var pt = i);\n        \\<forall>i>var r. llb ! i = lla ! i; length llb = length ll;\n        \\<forall>i>var l. lla ! i = ll ! i; length lla = length ll;\n        p \\<in> set (llb ! i); \\<not> i \\<le> var r\\<rbrakk>\n       \\<Longrightarrow> False", "apply  clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i prx.\n       \\<lbrakk>\\<forall>x\\<in>set ll. p \\<notin> set x;\n        \\<forall>n.\n           (n = r \\<longrightarrow> markb r = m) \\<and>\n           (n \\<in> set_of lrt \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of rrt \\<longrightarrow> markb n = m);\n        i < length ll;\n        \\<forall>q.\n           (q = r \\<longrightarrow> r \\<in> set (llb ! var r)) \\<and>\n           (q \\<in> set_of lrt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rrt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>q.\n           (q = l \\<longrightarrow> l \\<in> set (lla ! var l)) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (lla ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (lla ! var q));\n        \\<forall>i\\<le>var l.\n           \\<exists>prx.\n              lla ! i = prx @ ll ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = l \\<or>\n                   pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n                  var pt = i);\n        \\<forall>i>var r. llb ! i = lla ! i; length llb = length ll;\n        \\<forall>i>var l. lla ! i = ll ! i; length lla = length ll;\n        p \\<in> set prx \\<or> p \\<in> set (lla ! i); i \\<le> var r;\n        rt = Node lrt r rrt; lt = Node llt l rlt; var l < var p;\n        llb ! i = prx @ lla ! i;\n        \\<forall>pt\\<in>set prx.\n           (pt = r \\<or>\n            pt \\<in> set_of lrt \\<or> pt \\<in> set_of rrt) \\<and>\n           var pt = i;\n        var r < var p; ordered (Node llt l rlt) var;\n        ordered (Node lrt r rrt) var\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>i.\n       \\<lbrakk>\\<forall>x\\<in>set ll. p \\<notin> set x;\n        \\<forall>n.\n           (n = r \\<longrightarrow> markb r = m) \\<and>\n           (n \\<in> set_of lrt \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of rrt \\<longrightarrow> markb n = m);\n        i < length ll;\n        \\<forall>q.\n           (q = r \\<longrightarrow> r \\<in> set (llb ! var r)) \\<and>\n           (q \\<in> set_of lrt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rrt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>q.\n           (q = l \\<longrightarrow> l \\<in> set (lla ! var l)) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (lla ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (lla ! var q));\n        \\<forall>i\\<le>var r.\n           \\<exists>prx.\n              llb ! i = prx @ lla ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = r \\<or>\n                   pt \\<in> set_of lrt \\<or> pt \\<in> set_of rrt) \\<and>\n                  var pt = i);\n        \\<forall>i\\<le>var l.\n           \\<exists>prx.\n              lla ! i = prx @ ll ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = l \\<or>\n                   pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n                  var pt = i);\n        \\<forall>i>var r. llb ! i = lla ! i; length llb = length ll;\n        \\<forall>i>var l. lla ! i = ll ! i; length lla = length ll;\n        p \\<in> set (llb ! i); \\<not> i \\<le> var r\\<rbrakk>\n       \\<Longrightarrow> False", "apply  (erule disjE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i prx.\n       \\<lbrakk>\\<forall>x\\<in>set ll. p \\<notin> set x;\n        \\<forall>n.\n           (n = r \\<longrightarrow> markb r = m) \\<and>\n           (n \\<in> set_of lrt \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of rrt \\<longrightarrow> markb n = m);\n        i < length ll;\n        \\<forall>q.\n           (q = r \\<longrightarrow> r \\<in> set (llb ! var r)) \\<and>\n           (q \\<in> set_of lrt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rrt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>q.\n           (q = l \\<longrightarrow> l \\<in> set (lla ! var l)) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (lla ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (lla ! var q));\n        \\<forall>i\\<le>var l.\n           \\<exists>prx.\n              lla ! i = prx @ ll ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = l \\<or>\n                   pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n                  var pt = i);\n        \\<forall>i>var r. llb ! i = lla ! i; length llb = length ll;\n        \\<forall>i>var l. lla ! i = ll ! i; length lla = length ll;\n        i \\<le> var r; rt = Node lrt r rrt; lt = Node llt l rlt;\n        var l < var p; llb ! i = prx @ lla ! i;\n        \\<forall>pt\\<in>set prx.\n           (pt = r \\<or>\n            pt \\<in> set_of lrt \\<or> pt \\<in> set_of rrt) \\<and>\n           var pt = i;\n        var r < var p; ordered (Node llt l rlt) var;\n        ordered (Node lrt r rrt) var; p \\<in> set prx\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>i prx.\n       \\<lbrakk>\\<forall>x\\<in>set ll. p \\<notin> set x;\n        \\<forall>n.\n           (n = r \\<longrightarrow> markb r = m) \\<and>\n           (n \\<in> set_of lrt \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of rrt \\<longrightarrow> markb n = m);\n        i < length ll;\n        \\<forall>q.\n           (q = r \\<longrightarrow> r \\<in> set (llb ! var r)) \\<and>\n           (q \\<in> set_of lrt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rrt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>q.\n           (q = l \\<longrightarrow> l \\<in> set (lla ! var l)) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (lla ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (lla ! var q));\n        \\<forall>i\\<le>var l.\n           \\<exists>prx.\n              lla ! i = prx @ ll ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = l \\<or>\n                   pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n                  var pt = i);\n        \\<forall>i>var r. llb ! i = lla ! i; length llb = length ll;\n        \\<forall>i>var l. lla ! i = ll ! i; length lla = length ll;\n        i \\<le> var r; rt = Node lrt r rrt; lt = Node llt l rlt;\n        var l < var p; llb ! i = prx @ lla ! i;\n        \\<forall>pt\\<in>set prx.\n           (pt = r \\<or>\n            pt \\<in> set_of lrt \\<or> pt \\<in> set_of rrt) \\<and>\n           var pt = i;\n        var r < var p; ordered (Node llt l rlt) var;\n        ordered (Node lrt r rrt) var; p \\<in> set (lla ! i)\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>i.\n       \\<lbrakk>\\<forall>x\\<in>set ll. p \\<notin> set x;\n        \\<forall>n.\n           (n = r \\<longrightarrow> markb r = m) \\<and>\n           (n \\<in> set_of lrt \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of rrt \\<longrightarrow> markb n = m);\n        i < length ll;\n        \\<forall>q.\n           (q = r \\<longrightarrow> r \\<in> set (llb ! var r)) \\<and>\n           (q \\<in> set_of lrt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rrt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>q.\n           (q = l \\<longrightarrow> l \\<in> set (lla ! var l)) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (lla ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (lla ! var q));\n        \\<forall>i\\<le>var r.\n           \\<exists>prx.\n              llb ! i = prx @ lla ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = r \\<or>\n                   pt \\<in> set_of lrt \\<or> pt \\<in> set_of rrt) \\<and>\n                  var pt = i);\n        \\<forall>i\\<le>var l.\n           \\<exists>prx.\n              lla ! i = prx @ ll ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = l \\<or>\n                   pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n                  var pt = i);\n        \\<forall>i>var r. llb ! i = lla ! i; length llb = length ll;\n        \\<forall>i>var l. lla ! i = ll ! i; length lla = length ll;\n        p \\<in> set (llb ! i); \\<not> i \\<le> var r\\<rbrakk>\n       \\<Longrightarrow> False", "apply   clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i prx.\n       \\<lbrakk>\\<forall>x\\<in>set ll. p \\<notin> set x;\n        \\<forall>n.\n           (n = r \\<longrightarrow> markb r = m) \\<and>\n           (n \\<in> set_of lrt \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of rrt \\<longrightarrow> markb n = m);\n        i < length ll;\n        \\<forall>q.\n           (q = r \\<longrightarrow> r \\<in> set (llb ! var r)) \\<and>\n           (q \\<in> set_of lrt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rrt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>q.\n           (q = l \\<longrightarrow> l \\<in> set (lla ! var l)) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (lla ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (lla ! var q));\n        \\<forall>i\\<le>var l.\n           \\<exists>prx.\n              lla ! i = prx @ ll ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = l \\<or>\n                   pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n                  var pt = i);\n        \\<forall>i>var r. llb ! i = lla ! i; length llb = length ll;\n        \\<forall>i>var l. lla ! i = ll ! i; length lla = length ll;\n        i \\<le> var r; rt = Node lrt r rrt; lt = Node llt l rlt;\n        var l < var p; llb ! i = prx @ lla ! i;\n        \\<forall>pt\\<in>set prx.\n           (pt = r \\<or>\n            pt \\<in> set_of lrt \\<or> pt \\<in> set_of rrt) \\<and>\n           var pt = i;\n        var r < var p; ordered (Node llt l rlt) var;\n        ordered (Node lrt r rrt) var; p \\<in> set (lla ! i)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>i.\n       \\<lbrakk>\\<forall>x\\<in>set ll. p \\<notin> set x;\n        \\<forall>n.\n           (n = r \\<longrightarrow> markb r = m) \\<and>\n           (n \\<in> set_of lrt \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of rrt \\<longrightarrow> markb n = m);\n        i < length ll;\n        \\<forall>q.\n           (q = r \\<longrightarrow> r \\<in> set (llb ! var r)) \\<and>\n           (q \\<in> set_of lrt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rrt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>q.\n           (q = l \\<longrightarrow> l \\<in> set (lla ! var l)) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (lla ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (lla ! var q));\n        \\<forall>i\\<le>var r.\n           \\<exists>prx.\n              llb ! i = prx @ lla ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = r \\<or>\n                   pt \\<in> set_of lrt \\<or> pt \\<in> set_of rrt) \\<and>\n                  var pt = i);\n        \\<forall>i\\<le>var l.\n           \\<exists>prx.\n              lla ! i = prx @ ll ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = l \\<or>\n                   pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n                  var pt = i);\n        \\<forall>i>var r. llb ! i = lla ! i; length llb = length ll;\n        \\<forall>i>var l. lla ! i = ll ! i; length lla = length ll;\n        p \\<in> set (llb ! i); \\<not> i \\<le> var r\\<rbrakk>\n       \\<Longrightarrow> False", "apply  (case_tac \"i \\<le> var l\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i prx.\n       \\<lbrakk>\\<forall>x\\<in>set ll. p \\<notin> set x;\n        \\<forall>n.\n           (n = r \\<longrightarrow> markb r = m) \\<and>\n           (n \\<in> set_of lrt \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of rrt \\<longrightarrow> markb n = m);\n        i < length ll;\n        \\<forall>q.\n           (q = r \\<longrightarrow> r \\<in> set (llb ! var r)) \\<and>\n           (q \\<in> set_of lrt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rrt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>q.\n           (q = l \\<longrightarrow> l \\<in> set (lla ! var l)) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (lla ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (lla ! var q));\n        \\<forall>i\\<le>var l.\n           \\<exists>prx.\n              lla ! i = prx @ ll ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = l \\<or>\n                   pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n                  var pt = i);\n        \\<forall>i>var r. llb ! i = lla ! i; length llb = length ll;\n        \\<forall>i>var l. lla ! i = ll ! i; length lla = length ll;\n        i \\<le> var r; rt = Node lrt r rrt; lt = Node llt l rlt;\n        var l < var p; llb ! i = prx @ lla ! i;\n        \\<forall>pt\\<in>set prx.\n           (pt = r \\<or>\n            pt \\<in> set_of lrt \\<or> pt \\<in> set_of rrt) \\<and>\n           var pt = i;\n        var r < var p; ordered (Node llt l rlt) var;\n        ordered (Node lrt r rrt) var; p \\<in> set (lla ! i);\n        i \\<le> var l\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>i prx.\n       \\<lbrakk>\\<forall>x\\<in>set ll. p \\<notin> set x;\n        \\<forall>n.\n           (n = r \\<longrightarrow> markb r = m) \\<and>\n           (n \\<in> set_of lrt \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of rrt \\<longrightarrow> markb n = m);\n        i < length ll;\n        \\<forall>q.\n           (q = r \\<longrightarrow> r \\<in> set (llb ! var r)) \\<and>\n           (q \\<in> set_of lrt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rrt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>q.\n           (q = l \\<longrightarrow> l \\<in> set (lla ! var l)) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (lla ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (lla ! var q));\n        \\<forall>i\\<le>var l.\n           \\<exists>prx.\n              lla ! i = prx @ ll ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = l \\<or>\n                   pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n                  var pt = i);\n        \\<forall>i>var r. llb ! i = lla ! i; length llb = length ll;\n        \\<forall>i>var l. lla ! i = ll ! i; length lla = length ll;\n        i \\<le> var r; rt = Node lrt r rrt; lt = Node llt l rlt;\n        var l < var p; llb ! i = prx @ lla ! i;\n        \\<forall>pt\\<in>set prx.\n           (pt = r \\<or>\n            pt \\<in> set_of lrt \\<or> pt \\<in> set_of rrt) \\<and>\n           var pt = i;\n        var r < var p; ordered (Node llt l rlt) var;\n        ordered (Node lrt r rrt) var; p \\<in> set (lla ! i);\n        \\<not> i \\<le> var l\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>i.\n       \\<lbrakk>\\<forall>x\\<in>set ll. p \\<notin> set x;\n        \\<forall>n.\n           (n = r \\<longrightarrow> markb r = m) \\<and>\n           (n \\<in> set_of lrt \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of rrt \\<longrightarrow> markb n = m);\n        i < length ll;\n        \\<forall>q.\n           (q = r \\<longrightarrow> r \\<in> set (llb ! var r)) \\<and>\n           (q \\<in> set_of lrt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rrt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>q.\n           (q = l \\<longrightarrow> l \\<in> set (lla ! var l)) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (lla ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (lla ! var q));\n        \\<forall>i\\<le>var r.\n           \\<exists>prx.\n              llb ! i = prx @ lla ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = r \\<or>\n                   pt \\<in> set_of lrt \\<or> pt \\<in> set_of rrt) \\<and>\n                  var pt = i);\n        \\<forall>i\\<le>var l.\n           \\<exists>prx.\n              lla ! i = prx @ ll ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = l \\<or>\n                   pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n                  var pt = i);\n        \\<forall>i>var r. llb ! i = lla ! i; length llb = length ll;\n        \\<forall>i>var l. lla ! i = ll ! i; length lla = length ll;\n        p \\<in> set (llb ! i); \\<not> i \\<le> var r\\<rbrakk>\n       \\<Longrightarrow> False", "apply   (drule_tac x=i in spec)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>i prx.\n       \\<lbrakk>\\<forall>x\\<in>set ll. p \\<notin> set x;\n        \\<forall>n.\n           (n = r \\<longrightarrow> markb r = m) \\<and>\n           (n \\<in> set_of lrt \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of rrt \\<longrightarrow> markb n = m);\n        i < length ll;\n        \\<forall>q.\n           (q = r \\<longrightarrow> r \\<in> set (llb ! var r)) \\<and>\n           (q \\<in> set_of lrt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rrt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>q.\n           (q = l \\<longrightarrow> l \\<in> set (lla ! var l)) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (lla ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (lla ! var q));\n        \\<forall>i>var r. llb ! i = lla ! i; length llb = length ll;\n        \\<forall>i>var l. lla ! i = ll ! i; length lla = length ll;\n        i \\<le> var r; rt = Node lrt r rrt; lt = Node llt l rlt;\n        var l < var p; llb ! i = prx @ lla ! i;\n        \\<forall>pt\\<in>set prx.\n           (pt = r \\<or>\n            pt \\<in> set_of lrt \\<or> pt \\<in> set_of rrt) \\<and>\n           var pt = i;\n        var r < var p; ordered (Node llt l rlt) var;\n        ordered (Node lrt r rrt) var; p \\<in> set (lla ! i); i \\<le> var l;\n        i \\<le> var l \\<longrightarrow>\n        (\\<exists>prx.\n            lla ! i = prx @ ll ! i \\<and>\n            (\\<forall>pt\\<in>set prx.\n                (pt = l \\<or>\n                 pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n                var pt = i))\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>i prx.\n       \\<lbrakk>\\<forall>x\\<in>set ll. p \\<notin> set x;\n        \\<forall>n.\n           (n = r \\<longrightarrow> markb r = m) \\<and>\n           (n \\<in> set_of lrt \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of rrt \\<longrightarrow> markb n = m);\n        i < length ll;\n        \\<forall>q.\n           (q = r \\<longrightarrow> r \\<in> set (llb ! var r)) \\<and>\n           (q \\<in> set_of lrt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rrt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>q.\n           (q = l \\<longrightarrow> l \\<in> set (lla ! var l)) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (lla ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (lla ! var q));\n        \\<forall>i\\<le>var l.\n           \\<exists>prx.\n              lla ! i = prx @ ll ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = l \\<or>\n                   pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n                  var pt = i);\n        \\<forall>i>var r. llb ! i = lla ! i; length llb = length ll;\n        \\<forall>i>var l. lla ! i = ll ! i; length lla = length ll;\n        i \\<le> var r; rt = Node lrt r rrt; lt = Node llt l rlt;\n        var l < var p; llb ! i = prx @ lla ! i;\n        \\<forall>pt\\<in>set prx.\n           (pt = r \\<or>\n            pt \\<in> set_of lrt \\<or> pt \\<in> set_of rrt) \\<and>\n           var pt = i;\n        var r < var p; ordered (Node llt l rlt) var;\n        ordered (Node lrt r rrt) var; p \\<in> set (lla ! i);\n        \\<not> i \\<le> var l\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>i.\n       \\<lbrakk>\\<forall>x\\<in>set ll. p \\<notin> set x;\n        \\<forall>n.\n           (n = r \\<longrightarrow> markb r = m) \\<and>\n           (n \\<in> set_of lrt \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of rrt \\<longrightarrow> markb n = m);\n        i < length ll;\n        \\<forall>q.\n           (q = r \\<longrightarrow> r \\<in> set (llb ! var r)) \\<and>\n           (q \\<in> set_of lrt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rrt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>q.\n           (q = l \\<longrightarrow> l \\<in> set (lla ! var l)) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (lla ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (lla ! var q));\n        \\<forall>i\\<le>var r.\n           \\<exists>prx.\n              llb ! i = prx @ lla ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = r \\<or>\n                   pt \\<in> set_of lrt \\<or> pt \\<in> set_of rrt) \\<and>\n                  var pt = i);\n        \\<forall>i\\<le>var l.\n           \\<exists>prx.\n              lla ! i = prx @ ll ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = l \\<or>\n                   pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n                  var pt = i);\n        \\<forall>i>var r. llb ! i = lla ! i; length llb = length ll;\n        \\<forall>i>var l. lla ! i = ll ! i; length lla = length ll;\n        p \\<in> set (llb ! i); \\<not> i \\<le> var r\\<rbrakk>\n       \\<Longrightarrow> False", "apply   clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i prx.\n       \\<lbrakk>\\<forall>x\\<in>set ll. p \\<notin> set x;\n        \\<forall>n.\n           (n = r \\<longrightarrow> markb r = m) \\<and>\n           (n \\<in> set_of lrt \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of rrt \\<longrightarrow> markb n = m);\n        i < length ll;\n        \\<forall>q.\n           (q = r \\<longrightarrow> r \\<in> set (llb ! var r)) \\<and>\n           (q \\<in> set_of lrt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rrt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>q.\n           (q = l \\<longrightarrow> l \\<in> set (lla ! var l)) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (lla ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (lla ! var q));\n        \\<forall>i\\<le>var l.\n           \\<exists>prx.\n              lla ! i = prx @ ll ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = l \\<or>\n                   pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n                  var pt = i);\n        \\<forall>i>var r. llb ! i = lla ! i; length llb = length ll;\n        \\<forall>i>var l. lla ! i = ll ! i; length lla = length ll;\n        i \\<le> var r; rt = Node lrt r rrt; lt = Node llt l rlt;\n        var l < var p; llb ! i = prx @ lla ! i;\n        \\<forall>pt\\<in>set prx.\n           (pt = r \\<or>\n            pt \\<in> set_of lrt \\<or> pt \\<in> set_of rrt) \\<and>\n           var pt = i;\n        var r < var p; ordered (Node llt l rlt) var;\n        ordered (Node lrt r rrt) var; p \\<in> set (lla ! i);\n        \\<not> i \\<le> var l\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>i.\n       \\<lbrakk>\\<forall>x\\<in>set ll. p \\<notin> set x;\n        \\<forall>n.\n           (n = r \\<longrightarrow> markb r = m) \\<and>\n           (n \\<in> set_of lrt \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of rrt \\<longrightarrow> markb n = m);\n        i < length ll;\n        \\<forall>q.\n           (q = r \\<longrightarrow> r \\<in> set (llb ! var r)) \\<and>\n           (q \\<in> set_of lrt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rrt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>q.\n           (q = l \\<longrightarrow> l \\<in> set (lla ! var l)) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (lla ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (lla ! var q));\n        \\<forall>i\\<le>var r.\n           \\<exists>prx.\n              llb ! i = prx @ lla ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = r \\<or>\n                   pt \\<in> set_of lrt \\<or> pt \\<in> set_of rrt) \\<and>\n                  var pt = i);\n        \\<forall>i\\<le>var l.\n           \\<exists>prx.\n              lla ! i = prx @ ll ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = l \\<or>\n                   pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n                  var pt = i);\n        \\<forall>i>var r. llb ! i = lla ! i; length llb = length ll;\n        \\<forall>i>var l. lla ! i = ll ! i; length lla = length ll;\n        p \\<in> set (llb ! i); \\<not> i \\<le> var r\\<rbrakk>\n       \\<Longrightarrow> False", "apply  clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<forall>x\\<in>set ll. p \\<notin> set x;\n        \\<forall>n.\n           (n = r \\<longrightarrow> markb r = m) \\<and>\n           (n \\<in> set_of lrt \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of rrt \\<longrightarrow> markb n = m);\n        i < length ll;\n        \\<forall>q.\n           (q = r \\<longrightarrow> r \\<in> set (llb ! var r)) \\<and>\n           (q \\<in> set_of lrt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rrt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>q.\n           (q = l \\<longrightarrow> l \\<in> set (lla ! var l)) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (lla ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (lla ! var q));\n        \\<forall>i\\<le>var r.\n           \\<exists>prx.\n              llb ! i = prx @ lla ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = r \\<or>\n                   pt \\<in> set_of lrt \\<or> pt \\<in> set_of rrt) \\<and>\n                  var pt = i);\n        \\<forall>i\\<le>var l.\n           \\<exists>prx.\n              lla ! i = prx @ ll ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = l \\<or>\n                   pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n                  var pt = i);\n        \\<forall>i>var r. llb ! i = lla ! i; length llb = length ll;\n        \\<forall>i>var l. lla ! i = ll ! i; length lla = length ll;\n        p \\<in> set (llb ! i); \\<not> i \\<le> var r\\<rbrakk>\n       \\<Longrightarrow> False", "apply (subgoal_tac \"llb ! i = lla ! i\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>\\<forall>x\\<in>set ll. p \\<notin> set x;\n        \\<forall>n.\n           (n = r \\<longrightarrow> markb r = m) \\<and>\n           (n \\<in> set_of lrt \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of rrt \\<longrightarrow> markb n = m);\n        i < length ll;\n        \\<forall>q.\n           (q = r \\<longrightarrow> r \\<in> set (llb ! var r)) \\<and>\n           (q \\<in> set_of lrt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rrt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>q.\n           (q = l \\<longrightarrow> l \\<in> set (lla ! var l)) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (lla ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (lla ! var q));\n        \\<forall>i\\<le>var r.\n           \\<exists>prx.\n              llb ! i = prx @ lla ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = r \\<or>\n                   pt \\<in> set_of lrt \\<or> pt \\<in> set_of rrt) \\<and>\n                  var pt = i);\n        \\<forall>i\\<le>var l.\n           \\<exists>prx.\n              lla ! i = prx @ ll ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = l \\<or>\n                   pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n                  var pt = i);\n        \\<forall>i>var r. llb ! i = lla ! i; length llb = length ll;\n        \\<forall>i>var l. lla ! i = ll ! i; length lla = length ll;\n        p \\<in> set (llb ! i); \\<not> i \\<le> var r;\n        llb ! i = lla ! i\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>i.\n       \\<lbrakk>\\<forall>x\\<in>set ll. p \\<notin> set x;\n        \\<forall>n.\n           (n = r \\<longrightarrow> markb r = m) \\<and>\n           (n \\<in> set_of lrt \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of rrt \\<longrightarrow> markb n = m);\n        i < length ll;\n        \\<forall>q.\n           (q = r \\<longrightarrow> r \\<in> set (llb ! var r)) \\<and>\n           (q \\<in> set_of lrt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rrt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>q.\n           (q = l \\<longrightarrow> l \\<in> set (lla ! var l)) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (lla ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (lla ! var q));\n        \\<forall>i\\<le>var r.\n           \\<exists>prx.\n              llb ! i = prx @ lla ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = r \\<or>\n                   pt \\<in> set_of lrt \\<or> pt \\<in> set_of rrt) \\<and>\n                  var pt = i);\n        \\<forall>i\\<le>var l.\n           \\<exists>prx.\n              lla ! i = prx @ ll ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = l \\<or>\n                   pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n                  var pt = i);\n        \\<forall>i>var r. llb ! i = lla ! i; length llb = length ll;\n        \\<forall>i>var l. lla ! i = ll ! i; length lla = length ll;\n        p \\<in> set (llb ! i); \\<not> i \\<le> var r\\<rbrakk>\n       \\<Longrightarrow> llb ! i = lla ! i", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>\\<forall>x\\<in>set ll. p \\<notin> set x;\n        \\<forall>n.\n           (n = r \\<longrightarrow> markb r = m) \\<and>\n           (n \\<in> set_of lrt \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of rrt \\<longrightarrow> markb n = m);\n        i < length ll;\n        \\<forall>q.\n           (q = r \\<longrightarrow> r \\<in> set (llb ! var r)) \\<and>\n           (q \\<in> set_of lrt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rrt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>q.\n           (q = l \\<longrightarrow> l \\<in> set (lla ! var l)) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (lla ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (lla ! var q));\n        \\<forall>i\\<le>var r.\n           \\<exists>prx.\n              llb ! i = prx @ lla ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = r \\<or>\n                   pt \\<in> set_of lrt \\<or> pt \\<in> set_of rrt) \\<and>\n                  var pt = i);\n        \\<forall>i\\<le>var l.\n           \\<exists>prx.\n              lla ! i = prx @ ll ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = l \\<or>\n                   pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n                  var pt = i);\n        \\<forall>i>var r. llb ! i = lla ! i; length llb = length ll;\n        \\<forall>i>var l. lla ! i = ll ! i; length lla = length ll;\n        p \\<in> set (llb ! i); \\<not> i \\<le> var r\\<rbrakk>\n       \\<Longrightarrow> llb ! i = lla ! i\n 2. \\<And>i.\n       \\<lbrakk>\\<forall>x\\<in>set ll. p \\<notin> set x;\n        \\<forall>n.\n           (n = r \\<longrightarrow> markb r = m) \\<and>\n           (n \\<in> set_of lrt \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of rrt \\<longrightarrow> markb n = m);\n        i < length ll;\n        \\<forall>q.\n           (q = r \\<longrightarrow> r \\<in> set (llb ! var r)) \\<and>\n           (q \\<in> set_of lrt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rrt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>q.\n           (q = l \\<longrightarrow> l \\<in> set (lla ! var l)) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (lla ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (lla ! var q));\n        \\<forall>i\\<le>var r.\n           \\<exists>prx.\n              llb ! i = prx @ lla ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = r \\<or>\n                   pt \\<in> set_of lrt \\<or> pt \\<in> set_of rrt) \\<and>\n                  var pt = i);\n        \\<forall>i\\<le>var l.\n           \\<exists>prx.\n              lla ! i = prx @ ll ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = l \\<or>\n                   pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n                  var pt = i);\n        \\<forall>i>var r. llb ! i = lla ! i; length llb = length ll;\n        \\<forall>i>var l. lla ! i = ll ! i; length lla = length ll;\n        p \\<in> set (llb ! i); \\<not> i \\<le> var r;\n        llb ! i = lla ! i\\<rbrakk>\n       \\<Longrightarrow> False", "apply  clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<forall>x\\<in>set ll. p \\<notin> set x;\n        \\<forall>n.\n           (n = r \\<longrightarrow> markb r = m) \\<and>\n           (n \\<in> set_of lrt \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of rrt \\<longrightarrow> markb n = m);\n        i < length ll;\n        \\<forall>q.\n           (q = r \\<longrightarrow> r \\<in> set (llb ! var r)) \\<and>\n           (q \\<in> set_of lrt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rrt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>q.\n           (q = l \\<longrightarrow> l \\<in> set (lla ! var l)) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (lla ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (lla ! var q));\n        \\<forall>i\\<le>var r.\n           \\<exists>prx.\n              llb ! i = prx @ lla ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = r \\<or>\n                   pt \\<in> set_of lrt \\<or> pt \\<in> set_of rrt) \\<and>\n                  var pt = i);\n        \\<forall>i\\<le>var l.\n           \\<exists>prx.\n              lla ! i = prx @ ll ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = l \\<or>\n                   pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n                  var pt = i);\n        \\<forall>i>var r. llb ! i = lla ! i; length llb = length ll;\n        \\<forall>i>var l. lla ! i = ll ! i; length lla = length ll;\n        p \\<in> set (llb ! i); \\<not> i \\<le> var r;\n        llb ! i = lla ! i\\<rbrakk>\n       \\<Longrightarrow> False", "apply (case_tac \"i \\<le> var l\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>\\<forall>x\\<in>set ll. p \\<notin> set x;\n        \\<forall>n.\n           (n = r \\<longrightarrow> markb r = m) \\<and>\n           (n \\<in> set_of lrt \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of rrt \\<longrightarrow> markb n = m);\n        i < length ll;\n        \\<forall>q.\n           (q = r \\<longrightarrow> r \\<in> set (llb ! var r)) \\<and>\n           (q \\<in> set_of lrt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rrt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>q.\n           (q = l \\<longrightarrow> l \\<in> set (lla ! var l)) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (lla ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (lla ! var q));\n        \\<forall>i\\<le>var r.\n           \\<exists>prx.\n              llb ! i = prx @ lla ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = r \\<or>\n                   pt \\<in> set_of lrt \\<or> pt \\<in> set_of rrt) \\<and>\n                  var pt = i);\n        \\<forall>i\\<le>var l.\n           \\<exists>prx.\n              lla ! i = prx @ ll ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = l \\<or>\n                   pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n                  var pt = i);\n        \\<forall>i>var r. llb ! i = lla ! i; length llb = length ll;\n        \\<forall>i>var l. lla ! i = ll ! i; length lla = length ll;\n        p \\<in> set (llb ! i); \\<not> i \\<le> var r; llb ! i = lla ! i;\n        i \\<le> var l\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>i.\n       \\<lbrakk>\\<forall>x\\<in>set ll. p \\<notin> set x;\n        \\<forall>n.\n           (n = r \\<longrightarrow> markb r = m) \\<and>\n           (n \\<in> set_of lrt \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of rrt \\<longrightarrow> markb n = m);\n        i < length ll;\n        \\<forall>q.\n           (q = r \\<longrightarrow> r \\<in> set (llb ! var r)) \\<and>\n           (q \\<in> set_of lrt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rrt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>q.\n           (q = l \\<longrightarrow> l \\<in> set (lla ! var l)) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (lla ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (lla ! var q));\n        \\<forall>i\\<le>var r.\n           \\<exists>prx.\n              llb ! i = prx @ lla ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = r \\<or>\n                   pt \\<in> set_of lrt \\<or> pt \\<in> set_of rrt) \\<and>\n                  var pt = i);\n        \\<forall>i\\<le>var l.\n           \\<exists>prx.\n              lla ! i = prx @ ll ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = l \\<or>\n                   pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n                  var pt = i);\n        \\<forall>i>var r. llb ! i = lla ! i; length llb = length ll;\n        \\<forall>i>var l. lla ! i = ll ! i; length lla = length ll;\n        p \\<in> set (llb ! i); \\<not> i \\<le> var r; llb ! i = lla ! i;\n        \\<not> i \\<le> var l\\<rbrakk>\n       \\<Longrightarrow> False", "apply  (drule_tac x=i in spec, erule impE, assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>\\<forall>x\\<in>set ll. p \\<notin> set x;\n        \\<forall>n.\n           (n = r \\<longrightarrow> markb r = m) \\<and>\n           (n \\<in> set_of lrt \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of rrt \\<longrightarrow> markb n = m);\n        i < length ll;\n        \\<forall>q.\n           (q = r \\<longrightarrow> r \\<in> set (llb ! var r)) \\<and>\n           (q \\<in> set_of lrt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rrt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>q.\n           (q = l \\<longrightarrow> l \\<in> set (lla ! var l)) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (lla ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (lla ! var q));\n        \\<forall>i\\<le>var r.\n           \\<exists>prx.\n              llb ! i = prx @ lla ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = r \\<or>\n                   pt \\<in> set_of lrt \\<or> pt \\<in> set_of rrt) \\<and>\n                  var pt = i);\n        \\<forall>i>var r. llb ! i = lla ! i; length llb = length ll;\n        \\<forall>i>var l. lla ! i = ll ! i; length lla = length ll;\n        p \\<in> set (llb ! i); \\<not> i \\<le> var r; llb ! i = lla ! i;\n        i \\<le> var l;\n        \\<exists>prx.\n           lla ! i = prx @ ll ! i \\<and>\n           (\\<forall>pt\\<in>set prx.\n               (pt = l \\<or>\n                pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n               var pt = i)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>i.\n       \\<lbrakk>\\<forall>x\\<in>set ll. p \\<notin> set x;\n        \\<forall>n.\n           (n = r \\<longrightarrow> markb r = m) \\<and>\n           (n \\<in> set_of lrt \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of rrt \\<longrightarrow> markb n = m);\n        i < length ll;\n        \\<forall>q.\n           (q = r \\<longrightarrow> r \\<in> set (llb ! var r)) \\<and>\n           (q \\<in> set_of lrt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rrt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>q.\n           (q = l \\<longrightarrow> l \\<in> set (lla ! var l)) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (lla ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (lla ! var q));\n        \\<forall>i\\<le>var r.\n           \\<exists>prx.\n              llb ! i = prx @ lla ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = r \\<or>\n                   pt \\<in> set_of lrt \\<or> pt \\<in> set_of rrt) \\<and>\n                  var pt = i);\n        \\<forall>i\\<le>var l.\n           \\<exists>prx.\n              lla ! i = prx @ ll ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = l \\<or>\n                   pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n                  var pt = i);\n        \\<forall>i>var r. llb ! i = lla ! i; length llb = length ll;\n        \\<forall>i>var l. lla ! i = ll ! i; length lla = length ll;\n        p \\<in> set (llb ! i); \\<not> i \\<le> var r; llb ! i = lla ! i;\n        \\<not> i \\<le> var l\\<rbrakk>\n       \\<Longrightarrow> False", "apply  clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i prx.\n       \\<lbrakk>\\<forall>x\\<in>set ll. p \\<notin> set x;\n        \\<forall>n.\n           (n = r \\<longrightarrow> markb r = m) \\<and>\n           (n \\<in> set_of lrt \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of rrt \\<longrightarrow> markb n = m);\n        i < length ll;\n        \\<forall>q.\n           (q = r \\<longrightarrow> r \\<in> set (llb ! var r)) \\<and>\n           (q \\<in> set_of lrt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rrt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>q.\n           (q = l \\<longrightarrow> l \\<in> set (lla ! var l)) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (lla ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (lla ! var q));\n        \\<forall>i\\<le>var r.\n           \\<exists>prx.\n              llb ! i = prx @ lla ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = r \\<or>\n                   pt \\<in> set_of lrt \\<or> pt \\<in> set_of rrt) \\<and>\n                  var pt = i);\n        \\<forall>i>var r. llb ! i = lla ! i; length llb = length ll;\n        \\<forall>i>var l. lla ! i = ll ! i; length lla = length ll;\n        p \\<in> set prx; \\<not> i \\<le> var r; i \\<le> var l;\n        lla ! i = prx @ ll ! i;\n        \\<forall>pt\\<in>set prx.\n           (pt = l \\<or>\n            pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n           var pt = i\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>i.\n       \\<lbrakk>\\<forall>x\\<in>set ll. p \\<notin> set x;\n        \\<forall>n.\n           (n = r \\<longrightarrow> markb r = m) \\<and>\n           (n \\<in> set_of lrt \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of rrt \\<longrightarrow> markb n = m);\n        i < length ll;\n        \\<forall>q.\n           (q = r \\<longrightarrow> r \\<in> set (llb ! var r)) \\<and>\n           (q \\<in> set_of lrt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rrt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>q.\n           (q = l \\<longrightarrow> l \\<in> set (lla ! var l)) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (lla ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (lla ! var q));\n        \\<forall>i\\<le>var r.\n           \\<exists>prx.\n              llb ! i = prx @ lla ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = r \\<or>\n                   pt \\<in> set_of lrt \\<or> pt \\<in> set_of rrt) \\<and>\n                  var pt = i);\n        \\<forall>i\\<le>var l.\n           \\<exists>prx.\n              lla ! i = prx @ ll ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = l \\<or>\n                   pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n                  var pt = i);\n        \\<forall>i>var r. llb ! i = lla ! i; length llb = length ll;\n        \\<forall>i>var l. lla ! i = ll ! i; length lla = length ll;\n        p \\<in> set (llb ! i); \\<not> i \\<le> var r; llb ! i = lla ! i;\n        \\<not> i \\<le> var l\\<rbrakk>\n       \\<Longrightarrow> False", "using  orderedt rt_Node lt_Node"], ["proof (prove)\nusing this:\n  ordered (Node lt p rt) var\n  rt = Node lrt r rrt\n  lt = Node llt l rlt\n\ngoal (2 subgoals):\n 1. \\<And>i prx.\n       \\<lbrakk>\\<forall>x\\<in>set ll. p \\<notin> set x;\n        \\<forall>n.\n           (n = r \\<longrightarrow> markb r = m) \\<and>\n           (n \\<in> set_of lrt \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of rrt \\<longrightarrow> markb n = m);\n        i < length ll;\n        \\<forall>q.\n           (q = r \\<longrightarrow> r \\<in> set (llb ! var r)) \\<and>\n           (q \\<in> set_of lrt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rrt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>q.\n           (q = l \\<longrightarrow> l \\<in> set (lla ! var l)) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (lla ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (lla ! var q));\n        \\<forall>i\\<le>var r.\n           \\<exists>prx.\n              llb ! i = prx @ lla ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = r \\<or>\n                   pt \\<in> set_of lrt \\<or> pt \\<in> set_of rrt) \\<and>\n                  var pt = i);\n        \\<forall>i>var r. llb ! i = lla ! i; length llb = length ll;\n        \\<forall>i>var l. lla ! i = ll ! i; length lla = length ll;\n        p \\<in> set prx; \\<not> i \\<le> var r; i \\<le> var l;\n        lla ! i = prx @ ll ! i;\n        \\<forall>pt\\<in>set prx.\n           (pt = l \\<or>\n            pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n           var pt = i\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>i.\n       \\<lbrakk>\\<forall>x\\<in>set ll. p \\<notin> set x;\n        \\<forall>n.\n           (n = r \\<longrightarrow> markb r = m) \\<and>\n           (n \\<in> set_of lrt \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of rrt \\<longrightarrow> markb n = m);\n        i < length ll;\n        \\<forall>q.\n           (q = r \\<longrightarrow> r \\<in> set (llb ! var r)) \\<and>\n           (q \\<in> set_of lrt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rrt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>q.\n           (q = l \\<longrightarrow> l \\<in> set (lla ! var l)) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (lla ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (lla ! var q));\n        \\<forall>i\\<le>var r.\n           \\<exists>prx.\n              llb ! i = prx @ lla ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = r \\<or>\n                   pt \\<in> set_of lrt \\<or> pt \\<in> set_of rrt) \\<and>\n                  var pt = i);\n        \\<forall>i\\<le>var l.\n           \\<exists>prx.\n              lla ! i = prx @ ll ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = l \\<or>\n                   pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n                  var pt = i);\n        \\<forall>i>var r. llb ! i = lla ! i; length llb = length ll;\n        \\<forall>i>var l. lla ! i = ll ! i; length lla = length ll;\n        p \\<in> set (llb ! i); \\<not> i \\<le> var r; llb ! i = lla ! i;\n        \\<not> i \\<le> var l\\<rbrakk>\n       \\<Longrightarrow> False", "apply  clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<forall>x\\<in>set ll. p \\<notin> set x;\n        \\<forall>n.\n           (n = r \\<longrightarrow> markb r = m) \\<and>\n           (n \\<in> set_of lrt \\<longrightarrow> markb n = m) \\<and>\n           (n \\<in> set_of rrt \\<longrightarrow> markb n = m);\n        i < length ll;\n        \\<forall>q.\n           (q = r \\<longrightarrow> r \\<in> set (llb ! var r)) \\<and>\n           (q \\<in> set_of lrt \\<longrightarrow>\n            q \\<in> set (llb ! var q)) \\<and>\n           (q \\<in> set_of rrt \\<longrightarrow> q \\<in> set (llb ! var q));\n        \\<forall>q.\n           (q = l \\<longrightarrow> l \\<in> set (lla ! var l)) \\<and>\n           (q \\<in> set_of llt \\<longrightarrow>\n            q \\<in> set (lla ! var q)) \\<and>\n           (q \\<in> set_of rlt \\<longrightarrow> q \\<in> set (lla ! var q));\n        \\<forall>i\\<le>var r.\n           \\<exists>prx.\n              llb ! i = prx @ lla ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = r \\<or>\n                   pt \\<in> set_of lrt \\<or> pt \\<in> set_of rrt) \\<and>\n                  var pt = i);\n        \\<forall>i\\<le>var l.\n           \\<exists>prx.\n              lla ! i = prx @ ll ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  (pt = l \\<or>\n                   pt \\<in> set_of llt \\<or> pt \\<in> set_of rlt) \\<and>\n                  var pt = i);\n        \\<forall>i>var r. llb ! i = lla ! i; length llb = length ll;\n        \\<forall>i>var l. lla ! i = ll ! i; length lla = length ll;\n        p \\<in> set (llb ! i); \\<not> i \\<le> var r; llb ! i = lla ! i;\n        \\<not> i \\<le> var l\\<rbrakk>\n       \\<Longrightarrow> False", "apply clarsimp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>i<length llb. p \\<notin> set (llb ! i)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       rt = Node x21 x22 x23 \\<Longrightarrow>\n       \\<exists>ll'.\n          Levellist (levellistb[var p := p])\n           (nextb(p := levellistb ! var p)) ll' \\<and>\n          wf_levellist (Node lt p rt) ll ll' var \\<and>\n          wf_marking (Node lt p rt) mark (markb(p := m)) m", "from wfll_lt wfll_rt varsll lla llb"], ["proof (chain)\npicking this:\n  wf_levellist lt ll lla var\n  wf_levellist rt lla llb var\n  var p < length ll\n  Levellist levellista nexta lla\n  Levellist levellistb nextb llb", "obtain var_p_bounds: \"var p < length levellistb\" \"var p < length llb\""], ["proof (prove)\nusing this:\n  wf_levellist lt ll lla var\n  wf_levellist rt lla llb var\n  var p < length ll\n  Levellist levellista nexta lla\n  Levellist levellistb nextb llb\n\ngoal (1 subgoal):\n 1. (\\<lbrakk>var p < length levellistb; var p < length llb\\<rbrakk>\n     \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (simp add: Levellist_length wf_levellist_def lt_Node rt_Node)"], ["proof (state)\nthis:\n  var p < length levellistb\n  var p < length llb\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       rt = Node x21 x22 x23 \\<Longrightarrow>\n       \\<exists>ll'.\n          Levellist (levellistb[var p := p])\n           (nextb(p := levellistb ! var p)) ll' \\<and>\n          wf_levellist (Node lt p rt) ll ll' var \\<and>\n          wf_marking (Node lt p rt) mark (markb(p := m)) m", "with p_notin_llb llb pnN var_p_bounds"], ["proof (chain)\npicking this:\n  \\<forall>i<length llb. p \\<notin> set (llb ! i)\n  Levellist levellistb nextb llb\n  p \\<noteq> Null\n  var p < length levellistb\n  var p < length llb\n  var p < length levellistb\n  var p < length llb", "have llc: \"Levellist (levellistb[var p := p])\n                            (nextb(p := levellistb ! var p))\n                            (llb[var p := p # llb ! var p])\""], ["proof (prove)\nusing this:\n  \\<forall>i<length llb. p \\<notin> set (llb ! i)\n  Levellist levellistb nextb llb\n  p \\<noteq> Null\n  var p < length levellistb\n  var p < length llb\n  var p < length levellistb\n  var p < length llb\n\ngoal (1 subgoal):\n 1. Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n     (llb[var p := p # llb ! var p])", "apply (clarsimp simp add: Levellist_def map_update)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>\\<forall>i<length llb. p \\<notin> set (llb ! i);\n        p \\<noteq> Null; var p < length llb;\n        \\<forall>i<length llb. List (first (llb ! i)) nextb (llb ! i);\n        levellistb = map first llb; i < length llb\\<rbrakk>\n       \\<Longrightarrow> List ((map first llb)[var p := p] ! i)\n                          (nextb(p := first (llb ! var p)))\n                          (llb[var p := p # llb ! var p] ! i)", "apply (erule_tac x=i in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>p \\<noteq> Null; var p < length llb;\n        \\<forall>i<length llb. List (first (llb ! i)) nextb (llb ! i);\n        levellistb = map first llb; i < length llb;\n        i < length llb \\<longrightarrow> p \\<notin> set (llb ! i)\\<rbrakk>\n       \\<Longrightarrow> List ((map first llb)[var p := p] ! i)\n                          (nextb(p := first (llb ! var p)))\n                          (llb[var p := p # llb ! var p] ! i)", "apply (erule_tac x=i in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>p \\<noteq> Null; var p < length llb;\n        levellistb = map first llb; i < length llb;\n        i < length llb \\<longrightarrow> p \\<notin> set (llb ! i);\n        i < length llb \\<longrightarrow>\n        List (first (llb ! i)) nextb (llb ! i)\\<rbrakk>\n       \\<Longrightarrow> List ((map first llb)[var p := p] ! i)\n                          (nextb(p := first (llb ! var p)))\n                          (llb[var p := p # llb ! var p] ! i)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>p \\<noteq> Null; var p < length llb;\n        levellistb = map first llb; i < length llb;\n        p \\<notin> set (llb ! i);\n        List (first (llb ! i)) nextb (llb ! i)\\<rbrakk>\n       \\<Longrightarrow> List ((map first llb)[var p := p] ! i)\n                          (nextb(p := first (llb ! var p)))\n                          (llb[var p := p # llb ! var p] ! i)", "apply (case_tac \"i=var p\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>p \\<noteq> Null; var p < length llb;\n        levellistb = map first llb; i < length llb;\n        p \\<notin> set (llb ! i); List (first (llb ! i)) nextb (llb ! i);\n        i = var p\\<rbrakk>\n       \\<Longrightarrow> List ((map first llb)[var p := p] ! i)\n                          (nextb(p := first (llb ! var p)))\n                          (llb[var p := p # llb ! var p] ! i)\n 2. \\<And>i.\n       \\<lbrakk>p \\<noteq> Null; var p < length llb;\n        levellistb = map first llb; i < length llb;\n        p \\<notin> set (llb ! i); List (first (llb ! i)) nextb (llb ! i);\n        i \\<noteq> var p\\<rbrakk>\n       \\<Longrightarrow> List ((map first llb)[var p := p] ! i)\n                          (nextb(p := first (llb ! var p)))\n                          (llb[var p := p # llb ! var p] ! i)", "apply  simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>p \\<noteq> Null; var p < length llb;\n        levellistb = map first llb; i < length llb;\n        p \\<notin> set (llb ! i); List (first (llb ! i)) nextb (llb ! i);\n        i \\<noteq> var p\\<rbrakk>\n       \\<Longrightarrow> List ((map first llb)[var p := p] ! i)\n                          (nextb(p := first (llb ! var p)))\n                          (llb[var p := p # llb ! var p] ! i)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n   (llb[var p := p # llb ! var p])\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       rt = Node x21 x22 x23 \\<Longrightarrow>\n       \\<exists>ll'.\n          Levellist (levellistb[var p := p])\n           (nextb(p := levellistb ! var p)) ll' \\<and>\n          wf_levellist (Node lt p rt) ll ll' var \\<and>\n          wf_marking (Node lt p rt) mark (markb(p := m)) m", "then"], ["proof (chain)\npicking this:\n  Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n   (llb[var p := p # llb ! var p])", "show ?thesis"], ["proof (prove)\nusing this:\n  Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n   (llb[var p := p # llb ! var p])\n\ngoal (1 subgoal):\n 1. \\<exists>ll'.\n       Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n        ll' \\<and>\n       wf_levellist (Node lt p rt) ll ll' var \\<and>\n       wf_marking (Node lt p rt) mark (markb(p := m)) m", "proof (clarsimp)"], ["proof (state)\ngoal (1 subgoal):\n 1. Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n     (llb[var p := p # llb ! var p]) \\<Longrightarrow>\n    wf_levellist (Node lt p rt) ll (llb[var p := p # llb ! var p])\n     var \\<and>\n    wf_marking (Node lt p rt) mark (markb(p := m)) m", "show \"wf_levellist (Node lt p rt) ll (llb[var p := p#llb ! var p]) var \\<and>\n                      wf_marking (Node lt p rt) mark (markb(p := m)) m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_levellist (Node lt p rt) ll (llb[var p := p # llb ! var p])\n     var \\<and>\n    wf_marking (Node lt p rt) mark (markb(p := m)) m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wf_levellist (Node lt p rt) ll (llb[var p := p # llb ! var p])\n     var \\<and>\n    wf_marking (Node lt p rt) mark (markb(p := m)) m", "have nodes_in_upllb: \"\\<forall> q. q \\<in> set_of (Node lt p rt)\n                    \\<longrightarrow> q \\<in> set (llb[var p :=p # llb ! var p] ! (var q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>q.\n       q \\<in> set_of (Node lt p rt) \\<longrightarrow>\n       q \\<in> set (llb[var p := p # llb ! var p] ! var q)", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>q.\n       q \\<in> set_of (Node lt p rt) \\<longrightarrow>\n       q \\<in> set (llb[var p := p # llb ! var p] ! var q)", "apply (rule allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q.\n       q \\<in> set_of (Node lt p rt) \\<longrightarrow>\n       q \\<in> set (llb[var p := p # llb ! var p] ! var q)", "apply (rule impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q.\n       q \\<in> set_of (Node lt p rt) \\<Longrightarrow>\n       q \\<in> set (llb[var p := p # llb ! var p] ! var q)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q.\n       q \\<in> set_of (Node lt p rt) \\<Longrightarrow>\n       q \\<in> set (llb[var p := p # llb ! var p] ! var q)", "fix q"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q.\n       q \\<in> set_of (Node lt p rt) \\<Longrightarrow>\n       q \\<in> set (llb[var p := p # llb ! var p] ! var q)", "assume q_in_t: \"q \\<in> set_of (Node lt p rt)\""], ["proof (state)\nthis:\n  q \\<in> set_of (Node lt p rt)\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       q \\<in> set_of (Node lt p rt) \\<Longrightarrow>\n       q \\<in> set (llb[var p := p # llb ! var p] ! var q)", "show q_in_upllb:\n                      \"q \\<in> set (llb[var p :=p # llb ! var p] ! (var q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> set (llb[var p := p # llb ! var p] ! var q)", "proof (cases \"q \\<in> set_of rt\")"], ["proof (state)\ngoal (2 subgoals):\n 1. q \\<in> set_of rt \\<Longrightarrow>\n    q \\<in> set (llb[var p := p # llb ! var p] ! var q)\n 2. q \\<notin> set_of rt \\<Longrightarrow>\n    q \\<in> set (llb[var p := p # llb ! var p] ! var q)", "case True"], ["proof (state)\nthis:\n  q \\<in> set_of rt\n\ngoal (2 subgoals):\n 1. q \\<in> set_of rt \\<Longrightarrow>\n    q \\<in> set (llb[var p := p # llb ! var p] ! var q)\n 2. q \\<notin> set_of rt \\<Longrightarrow>\n    q \\<in> set (llb[var p := p # llb ! var p] ! var q)", "with nodes_in_llb"], ["proof (chain)\npicking this:\n  \\<forall>q. q \\<in> set_of rt \\<longrightarrow> q \\<in> set (llb ! var q)\n  q \\<in> set_of rt", "have q_in_llb: \"q \\<in> set (llb ! (var q))\""], ["proof (prove)\nusing this:\n  \\<forall>q. q \\<in> set_of rt \\<longrightarrow> q \\<in> set (llb ! var q)\n  q \\<in> set_of rt\n\ngoal (1 subgoal):\n 1. q \\<in> set (llb ! var q)", "by fastforce"], ["proof (state)\nthis:\n  q \\<in> set (llb ! var q)\n\ngoal (2 subgoals):\n 1. q \\<in> set_of rt \\<Longrightarrow>\n    q \\<in> set (llb[var p := p # llb ! var p] ! var q)\n 2. q \\<notin> set_of rt \\<Longrightarrow>\n    q \\<in> set (llb[var p := p # llb ! var p] ! var q)", "from orderedt rt_Node lt_Node lt rt"], ["proof (chain)\npicking this:\n  ordered (Node lt p rt) var\n  rt = Node lrt r rrt\n  lt = Node llt l rlt\n  Dag (low p) low high lt\n  Dag (high p) low high rt", "have ordered_rt: \"ordered rt var\""], ["proof (prove)\nusing this:\n  ordered (Node lt p rt) var\n  rt = Node lrt r rrt\n  lt = Node llt l rlt\n  Dag (low p) low high lt\n  Dag (high p) low high rt\n\ngoal (1 subgoal):\n 1. ordered rt var", "by fastforce"], ["proof (state)\nthis:\n  ordered rt var\n\ngoal (2 subgoals):\n 1. q \\<in> set_of rt \\<Longrightarrow>\n    q \\<in> set (llb[var p := p # llb ! var p] ! var q)\n 2. q \\<notin> set_of rt \\<Longrightarrow>\n    q \\<in> set (llb[var p := p # llb ! var p] ! var q)", "from True rt ordered_rt rt_Node lt lt_Node"], ["proof (chain)\npicking this:\n  q \\<in> set_of rt\n  Dag (high p) low high rt\n  ordered rt var\n  rt = Node lrt r rrt\n  Dag (low p) low high lt\n  lt = Node llt l rlt", "have \"var q \\<le> var r\""], ["proof (prove)\nusing this:\n  q \\<in> set_of rt\n  Dag (high p) low high rt\n  ordered rt var\n  rt = Node lrt r rrt\n  Dag (low p) low high lt\n  lt = Node llt l rlt\n\ngoal (1 subgoal):\n 1. var q \\<le> var r", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>q \\<in> set_of rt; Dag (high p) low high rt; ordered rt var;\n     rt = Node lrt r rrt; Dag (low p) low high lt;\n     lt = Node llt l rlt\\<rbrakk>\n    \\<Longrightarrow> var q \\<le> var r", "apply (drule subnodes_ordered)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>Dag (high p) low high rt; ordered rt var; rt = Node lrt r rrt;\n     Dag (low p) low high lt; lt = Node llt l rlt\\<rbrakk>\n    \\<Longrightarrow> Dag ?p6 ?low6 ?high6 rt\n 2. \\<lbrakk>Dag (high p) low high rt; ordered rt var; rt = Node lrt r rrt;\n     Dag (low p) low high lt; lt = Node llt l rlt\\<rbrakk>\n    \\<Longrightarrow> ordered rt ?var6\n 3. \\<lbrakk>Dag (high p) low high rt; ordered rt var; rt = Node lrt r rrt;\n     Dag (low p) low high lt; lt = Node llt l rlt;\n     ?var6 q \\<le> ?var6 ?p6\\<rbrakk>\n    \\<Longrightarrow> var q \\<le> var r", "apply fastforce"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Dag (high p) low high rt; ordered rt var; rt = Node lrt r rrt;\n     Dag (low p) low high lt; lt = Node llt l rlt\\<rbrakk>\n    \\<Longrightarrow> ordered rt ?var6\n 2. \\<lbrakk>Dag (high p) low high rt; ordered rt var; rt = Node lrt r rrt;\n     Dag (low p) low high lt; lt = Node llt l rlt;\n     ?var6 q \\<le> ?var6 (high p)\\<rbrakk>\n    \\<Longrightarrow> var q \\<le> var r", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Dag (high p) low high rt; ordered rt var; rt = Node lrt r rrt;\n     Dag (low p) low high lt; lt = Node llt l rlt;\n     var q \\<le> var (high p)\\<rbrakk>\n    \\<Longrightarrow> var q \\<le> var r", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  var q \\<le> var r\n\ngoal (2 subgoals):\n 1. q \\<in> set_of rt \\<Longrightarrow>\n    q \\<in> set (llb[var p := p # llb ! var p] ! var q)\n 2. q \\<notin> set_of rt \\<Longrightarrow>\n    q \\<in> set (llb[var p := p # llb ! var p] ! var q)", "with orderedt rt lt rt_Node lt_Node"], ["proof (chain)\npicking this:\n  ordered (Node lt p rt) var\n  Dag (high p) low high rt\n  Dag (low p) low high lt\n  rt = Node lrt r rrt\n  lt = Node llt l rlt\n  var q \\<le> var r", "have \"var q < var p\""], ["proof (prove)\nusing this:\n  ordered (Node lt p rt) var\n  Dag (high p) low high rt\n  Dag (low p) low high lt\n  rt = Node lrt r rrt\n  lt = Node llt l rlt\n  var q \\<le> var r\n\ngoal (1 subgoal):\n 1. var q < var p", "by fastforce"], ["proof (state)\nthis:\n  var q < var p\n\ngoal (2 subgoals):\n 1. q \\<in> set_of rt \\<Longrightarrow>\n    q \\<in> set (llb[var p := p # llb ! var p] ! var q)\n 2. q \\<notin> set_of rt \\<Longrightarrow>\n    q \\<in> set (llb[var p := p # llb ! var p] ! var q)", "then"], ["proof (chain)\npicking this:\n  var q < var p", "have\n                        \"llb[var p :=p#llb ! var p] ! var q =\n                         llb ! var q\""], ["proof (prove)\nusing this:\n  var q < var p\n\ngoal (1 subgoal):\n 1. llb[var p := p # llb ! var p] ! var q = llb ! var q", "by fastforce"], ["proof (state)\nthis:\n  llb[var p := p # llb ! var p] ! var q = llb ! var q\n\ngoal (2 subgoals):\n 1. q \\<in> set_of rt \\<Longrightarrow>\n    q \\<in> set (llb[var p := p # llb ! var p] ! var q)\n 2. q \\<notin> set_of rt \\<Longrightarrow>\n    q \\<in> set (llb[var p := p # llb ! var p] ! var q)", "with q_in_llb"], ["proof (chain)\npicking this:\n  q \\<in> set (llb ! var q)\n  llb[var p := p # llb ! var p] ! var q = llb ! var q", "show ?thesis"], ["proof (prove)\nusing this:\n  q \\<in> set (llb ! var q)\n  llb[var p := p # llb ! var p] ! var q = llb ! var q\n\ngoal (1 subgoal):\n 1. q \\<in> set (llb[var p := p # llb ! var p] ! var q)", "by fastforce"], ["proof (state)\nthis:\n  q \\<in> set (llb[var p := p # llb ! var p] ! var q)\n\ngoal (1 subgoal):\n 1. q \\<notin> set_of rt \\<Longrightarrow>\n    q \\<in> set (llb[var p := p # llb ! var p] ! var q)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. q \\<notin> set_of rt \\<Longrightarrow>\n    q \\<in> set (llb[var p := p # llb ! var p] ! var q)", "assume q_notin_rt: \"q \\<notin> set_of rt\""], ["proof (state)\nthis:\n  q \\<notin> set_of rt\n\ngoal (1 subgoal):\n 1. q \\<notin> set_of rt \\<Longrightarrow>\n    q \\<in> set (llb[var p := p # llb ! var p] ! var q)", "show \"q \\<in> set (llb[var p :=p # llb ! var p] ! var q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<in> set (llb[var p := p # llb ! var p] ! var q)", "proof (cases \"q \\<in> set_of lt\")"], ["proof (state)\ngoal (2 subgoals):\n 1. q \\<in> set_of lt \\<Longrightarrow>\n    q \\<in> set (llb[var p := p # llb ! var p] ! var q)\n 2. q \\<notin> set_of lt \\<Longrightarrow>\n    q \\<in> set (llb[var p := p # llb ! var p] ! var q)", "case True"], ["proof (state)\nthis:\n  q \\<in> set_of lt\n\ngoal (2 subgoals):\n 1. q \\<in> set_of lt \\<Longrightarrow>\n    q \\<in> set (llb[var p := p # llb ! var p] ! var q)\n 2. q \\<notin> set_of lt \\<Longrightarrow>\n    q \\<in> set (llb[var p := p # llb ! var p] ! var q)", "assume q_in_lt: \"q \\<in> set_of lt\""], ["proof (state)\nthis:\n  q \\<in> set_of lt\n\ngoal (2 subgoals):\n 1. q \\<in> set_of lt \\<Longrightarrow>\n    q \\<in> set (llb[var p := p # llb ! var p] ! var q)\n 2. q \\<notin> set_of lt \\<Longrightarrow>\n    q \\<in> set (llb[var p := p # llb ! var p] ! var q)", "with nodes_in_lla"], ["proof (chain)\npicking this:\n  \\<forall>q. q \\<in> set_of lt \\<longrightarrow> q \\<in> set (lla ! var q)\n  q \\<in> set_of lt", "have q_in_lla: \"q \\<in> set (lla ! (var q))\""], ["proof (prove)\nusing this:\n  \\<forall>q. q \\<in> set_of lt \\<longrightarrow> q \\<in> set (lla ! var q)\n  q \\<in> set_of lt\n\ngoal (1 subgoal):\n 1. q \\<in> set (lla ! var q)", "by fastforce"], ["proof (state)\nthis:\n  q \\<in> set (lla ! var q)\n\ngoal (2 subgoals):\n 1. q \\<in> set_of lt \\<Longrightarrow>\n    q \\<in> set (llb[var p := p # llb ! var p] ! var q)\n 2. q \\<notin> set_of lt \\<Longrightarrow>\n    q \\<in> set (llb[var p := p # llb ! var p] ! var q)", "from orderedt rt_Node lt_Node lt rt"], ["proof (chain)\npicking this:\n  ordered (Node lt p rt) var\n  rt = Node lrt r rrt\n  lt = Node llt l rlt\n  Dag (low p) low high lt\n  Dag (high p) low high rt", "have ordered_lt: \"ordered lt var\""], ["proof (prove)\nusing this:\n  ordered (Node lt p rt) var\n  rt = Node lrt r rrt\n  lt = Node llt l rlt\n  Dag (low p) low high lt\n  Dag (high p) low high rt\n\ngoal (1 subgoal):\n 1. ordered lt var", "by fastforce"], ["proof (state)\nthis:\n  ordered lt var\n\ngoal (2 subgoals):\n 1. q \\<in> set_of lt \\<Longrightarrow>\n    q \\<in> set (llb[var p := p # llb ! var p] ! var q)\n 2. q \\<notin> set_of lt \\<Longrightarrow>\n    q \\<in> set (llb[var p := p # llb ! var p] ! var q)", "from q_in_lt lt ordered_lt rt_Node rt lt_Node"], ["proof (chain)\npicking this:\n  q \\<in> set_of lt\n  Dag (low p) low high lt\n  ordered lt var\n  rt = Node lrt r rrt\n  Dag (high p) low high rt\n  lt = Node llt l rlt", "have \"var q \\<le> var l\""], ["proof (prove)\nusing this:\n  q \\<in> set_of lt\n  Dag (low p) low high lt\n  ordered lt var\n  rt = Node lrt r rrt\n  Dag (high p) low high rt\n  lt = Node llt l rlt\n\ngoal (1 subgoal):\n 1. var q \\<le> var l", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>q \\<in> set_of lt; Dag (low p) low high lt; ordered lt var;\n     rt = Node lrt r rrt; Dag (high p) low high rt;\n     lt = Node llt l rlt\\<rbrakk>\n    \\<Longrightarrow> var q \\<le> var l", "apply (drule subnodes_ordered)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>Dag (low p) low high lt; ordered lt var; rt = Node lrt r rrt;\n     Dag (high p) low high rt; lt = Node llt l rlt\\<rbrakk>\n    \\<Longrightarrow> Dag ?p6 ?low6 ?high6 lt\n 2. \\<lbrakk>Dag (low p) low high lt; ordered lt var; rt = Node lrt r rrt;\n     Dag (high p) low high rt; lt = Node llt l rlt\\<rbrakk>\n    \\<Longrightarrow> ordered lt ?var6\n 3. \\<lbrakk>Dag (low p) low high lt; ordered lt var; rt = Node lrt r rrt;\n     Dag (high p) low high rt; lt = Node llt l rlt;\n     ?var6 q \\<le> ?var6 ?p6\\<rbrakk>\n    \\<Longrightarrow> var q \\<le> var l", "apply fastforce"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Dag (low p) low high lt; ordered lt var; rt = Node lrt r rrt;\n     Dag (high p) low high rt; lt = Node llt l rlt\\<rbrakk>\n    \\<Longrightarrow> ordered lt ?var6\n 2. \\<lbrakk>Dag (low p) low high lt; ordered lt var; rt = Node lrt r rrt;\n     Dag (high p) low high rt; lt = Node llt l rlt;\n     ?var6 q \\<le> ?var6 (low p)\\<rbrakk>\n    \\<Longrightarrow> var q \\<le> var l", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Dag (low p) low high lt; ordered lt var; rt = Node lrt r rrt;\n     Dag (high p) low high rt; lt = Node llt l rlt;\n     var q \\<le> var (low p)\\<rbrakk>\n    \\<Longrightarrow> var q \\<le> var l", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  var q \\<le> var l\n\ngoal (2 subgoals):\n 1. q \\<in> set_of lt \\<Longrightarrow>\n    q \\<in> set (llb[var p := p # llb ! var p] ! var q)\n 2. q \\<notin> set_of lt \\<Longrightarrow>\n    q \\<in> set (llb[var p := p # llb ! var p] ! var q)", "with orderedt rt lt rt_Node lt_Node"], ["proof (chain)\npicking this:\n  ordered (Node lt p rt) var\n  Dag (high p) low high rt\n  Dag (low p) low high lt\n  rt = Node lrt r rrt\n  lt = Node llt l rlt\n  var q \\<le> var l", "have qsp: \"var q < var p\""], ["proof (prove)\nusing this:\n  ordered (Node lt p rt) var\n  Dag (high p) low high rt\n  Dag (low p) low high lt\n  rt = Node lrt r rrt\n  lt = Node llt l rlt\n  var q \\<le> var l\n\ngoal (1 subgoal):\n 1. var q < var p", "by fastforce"], ["proof (state)\nthis:\n  var q < var p\n\ngoal (2 subgoals):\n 1. q \\<in> set_of lt \\<Longrightarrow>\n    q \\<in> set (llb[var p := p # llb ! var p] ! var q)\n 2. q \\<notin> set_of lt \\<Longrightarrow>\n    q \\<in> set (llb[var p := p # llb ! var p] ! var q)", "then"], ["proof (chain)\npicking this:\n  var q < var p", "show ?thesis"], ["proof (prove)\nusing this:\n  var q < var p\n\ngoal (1 subgoal):\n 1. q \\<in> set (llb[var p := p # llb ! var p] ! var q)", "proof (cases \"var q \\<le> var (high p)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>var q < var p; var q \\<le> var (high p)\\<rbrakk>\n    \\<Longrightarrow> q \\<in> set (llb[var p := p # llb ! var p] ! var q)\n 2. \\<lbrakk>var q < var p; \\<not> var q \\<le> var (high p)\\<rbrakk>\n    \\<Longrightarrow> q \\<in> set (llb[var p := p # llb ! var p] ! var q)", "case True"], ["proof (state)\nthis:\n  var q \\<le> var (high p)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>var q < var p; var q \\<le> var (high p)\\<rbrakk>\n    \\<Longrightarrow> q \\<in> set (llb[var p := p # llb ! var p] ! var q)\n 2. \\<lbrakk>var q < var p; \\<not> var q \\<le> var (high p)\\<rbrakk>\n    \\<Longrightarrow> q \\<in> set (llb[var p := p # llb ! var p] ! var q)", "with llb_st"], ["proof (chain)\npicking this:\n  \\<forall>i\\<le>var (high p).\n     \\<exists>prx.\n        llb ! i = prx @ lla ! i \\<and>\n        (\\<forall>pt\\<in>set prx. pt \\<in> set_of rt \\<and> var pt = i)\n  var q \\<le> var (high p)", "have \"\\<exists>prx. (llb ! (var q)) = prx@(lla ! (var q))\""], ["proof (prove)\nusing this:\n  \\<forall>i\\<le>var (high p).\n     \\<exists>prx.\n        llb ! i = prx @ lla ! i \\<and>\n        (\\<forall>pt\\<in>set prx. pt \\<in> set_of rt \\<and> var pt = i)\n  var q \\<le> var (high p)\n\ngoal (1 subgoal):\n 1. \\<exists>prx. llb ! var q = prx @ lla ! var q", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>prx. llb ! var q = prx @ lla ! var q\n\ngoal (2 subgoals):\n 1. \\<lbrakk>var q < var p; var q \\<le> var (high p)\\<rbrakk>\n    \\<Longrightarrow> q \\<in> set (llb[var p := p # llb ! var p] ! var q)\n 2. \\<lbrakk>var q < var p; \\<not> var q \\<le> var (high p)\\<rbrakk>\n    \\<Longrightarrow> q \\<in> set (llb[var p := p # llb ! var p] ! var q)", "with nodes_in_lla q_in_lla"], ["proof (chain)\npicking this:\n  \\<forall>q. q \\<in> set_of lt \\<longrightarrow> q \\<in> set (lla ! var q)\n  q \\<in> set (lla ! var q)\n  \\<exists>prx. llb ! var q = prx @ lla ! var q", "have q_in_llb: \"q \\<in> set (llb ! (var q))\""], ["proof (prove)\nusing this:\n  \\<forall>q. q \\<in> set_of lt \\<longrightarrow> q \\<in> set (lla ! var q)\n  q \\<in> set (lla ! var q)\n  \\<exists>prx. llb ! var q = prx @ lla ! var q\n\ngoal (1 subgoal):\n 1. q \\<in> set (llb ! var q)", "by fastforce"], ["proof (state)\nthis:\n  q \\<in> set (llb ! var q)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>var q < var p; var q \\<le> var (high p)\\<rbrakk>\n    \\<Longrightarrow> q \\<in> set (llb[var p := p # llb ! var p] ! var q)\n 2. \\<lbrakk>var q < var p; \\<not> var q \\<le> var (high p)\\<rbrakk>\n    \\<Longrightarrow> q \\<in> set (llb[var p := p # llb ! var p] ! var q)", "from qsp"], ["proof (chain)\npicking this:\n  var q < var p", "have \"llb[var p :=p#llb ! var p]!var q =\n                                   llb ! (var q)\""], ["proof (prove)\nusing this:\n  var q < var p\n\ngoal (1 subgoal):\n 1. llb[var p := p # llb ! var p] ! var q = llb ! var q", "by fastforce"], ["proof (state)\nthis:\n  llb[var p := p # llb ! var p] ! var q = llb ! var q\n\ngoal (2 subgoals):\n 1. \\<lbrakk>var q < var p; var q \\<le> var (high p)\\<rbrakk>\n    \\<Longrightarrow> q \\<in> set (llb[var p := p # llb ! var p] ! var q)\n 2. \\<lbrakk>var q < var p; \\<not> var q \\<le> var (high p)\\<rbrakk>\n    \\<Longrightarrow> q \\<in> set (llb[var p := p # llb ! var p] ! var q)", "with q_in_llb"], ["proof (chain)\npicking this:\n  q \\<in> set (llb ! var q)\n  llb[var p := p # llb ! var p] ! var q = llb ! var q", "show ?thesis"], ["proof (prove)\nusing this:\n  q \\<in> set (llb ! var q)\n  llb[var p := p # llb ! var p] ! var q = llb ! var q\n\ngoal (1 subgoal):\n 1. q \\<in> set (llb[var p := p # llb ! var p] ! var q)", "by fastforce"], ["proof (state)\nthis:\n  q \\<in> set (llb[var p := p # llb ! var p] ! var q)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>var q < var p; \\<not> var q \\<le> var (high p)\\<rbrakk>\n    \\<Longrightarrow> q \\<in> set (llb[var p := p # llb ! var p] ! var q)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>var q < var p; \\<not> var q \\<le> var (high p)\\<rbrakk>\n    \\<Longrightarrow> q \\<in> set (llb[var p := p # llb ! var p] ! var q)", "assume \"\\<not> var q \\<le> var (high p)\""], ["proof (state)\nthis:\n  \\<not> var q \\<le> var (high p)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>var q < var p; \\<not> var q \\<le> var (high p)\\<rbrakk>\n    \\<Longrightarrow> q \\<in> set (llb[var p := p # llb ! var p] ! var q)", "with llb_nc"], ["proof (chain)\npicking this:\n  \\<forall>i>var (high p). llb ! i = lla ! i\n  \\<not> var q \\<le> var (high p)", "have \"llb ! (var q) = lla ! (var q)\""], ["proof (prove)\nusing this:\n  \\<forall>i>var (high p). llb ! i = lla ! i\n  \\<not> var q \\<le> var (high p)\n\ngoal (1 subgoal):\n 1. llb ! var q = lla ! var q", "by fastforce"], ["proof (state)\nthis:\n  llb ! var q = lla ! var q\n\ngoal (1 subgoal):\n 1. \\<lbrakk>var q < var p; \\<not> var q \\<le> var (high p)\\<rbrakk>\n    \\<Longrightarrow> q \\<in> set (llb[var p := p # llb ! var p] ! var q)", "with q_in_lla"], ["proof (chain)\npicking this:\n  q \\<in> set (lla ! var q)\n  llb ! var q = lla ! var q", "have q_in_llb: \"q \\<in> set (llb ! (var q))\""], ["proof (prove)\nusing this:\n  q \\<in> set (lla ! var q)\n  llb ! var q = lla ! var q\n\ngoal (1 subgoal):\n 1. q \\<in> set (llb ! var q)", "by fastforce"], ["proof (state)\nthis:\n  q \\<in> set (llb ! var q)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>var q < var p; \\<not> var q \\<le> var (high p)\\<rbrakk>\n    \\<Longrightarrow> q \\<in> set (llb[var p := p # llb ! var p] ! var q)", "from qsp"], ["proof (chain)\npicking this:\n  var q < var p", "have\n                            \"llb[var p :=p # llb ! var p] ! var q = llb ! (var q)\""], ["proof (prove)\nusing this:\n  var q < var p\n\ngoal (1 subgoal):\n 1. llb[var p := p # llb ! var p] ! var q = llb ! var q", "by fastforce"], ["proof (state)\nthis:\n  llb[var p := p # llb ! var p] ! var q = llb ! var q\n\ngoal (1 subgoal):\n 1. \\<lbrakk>var q < var p; \\<not> var q \\<le> var (high p)\\<rbrakk>\n    \\<Longrightarrow> q \\<in> set (llb[var p := p # llb ! var p] ! var q)", "with q_in_llb"], ["proof (chain)\npicking this:\n  q \\<in> set (llb ! var q)\n  llb[var p := p # llb ! var p] ! var q = llb ! var q", "show ?thesis"], ["proof (prove)\nusing this:\n  q \\<in> set (llb ! var q)\n  llb[var p := p # llb ! var p] ! var q = llb ! var q\n\ngoal (1 subgoal):\n 1. q \\<in> set (llb[var p := p # llb ! var p] ! var q)", "by fastforce"], ["proof (state)\nthis:\n  q \\<in> set (llb[var p := p # llb ! var p] ! var q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  q \\<in> set (llb[var p := p # llb ! var p] ! var q)\n\ngoal (1 subgoal):\n 1. q \\<notin> set_of lt \\<Longrightarrow>\n    q \\<in> set (llb[var p := p # llb ! var p] ! var q)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. q \\<notin> set_of lt \\<Longrightarrow>\n    q \\<in> set (llb[var p := p # llb ! var p] ! var q)", "assume q_notin_lt: \"q \\<notin> set_of lt\""], ["proof (state)\nthis:\n  q \\<notin> set_of lt\n\ngoal (1 subgoal):\n 1. q \\<notin> set_of lt \\<Longrightarrow>\n    q \\<in> set (llb[var p := p # llb ! var p] ! var q)", "with q_notin_rt rt lt rt_Node lt_Node q_in_t"], ["proof (chain)\npicking this:\n  q \\<notin> set_of rt\n  Dag (high p) low high rt\n  Dag (low p) low high lt\n  rt = Node lrt r rrt\n  lt = Node llt l rlt\n  q \\<in> set_of (Node lt p rt)\n  q \\<notin> set_of lt", "have qp: \"q = p\""], ["proof (prove)\nusing this:\n  q \\<notin> set_of rt\n  Dag (high p) low high rt\n  Dag (low p) low high lt\n  rt = Node lrt r rrt\n  lt = Node llt l rlt\n  q \\<in> set_of (Node lt p rt)\n  q \\<notin> set_of lt\n\ngoal (1 subgoal):\n 1. q = p", "by fastforce"], ["proof (state)\nthis:\n  q = p\n\ngoal (1 subgoal):\n 1. q \\<notin> set_of lt \\<Longrightarrow>\n    q \\<in> set (llb[var p := p # llb ! var p] ! var q)", "with varsll lla_eq_ll llb_eq_lla"], ["proof (chain)\npicking this:\n  var p < length ll\n  length lla = length ll\n  length llb = length lla\n  q = p", "have \"var p < length llb\""], ["proof (prove)\nusing this:\n  var p < length ll\n  length lla = length ll\n  length llb = length lla\n  q = p\n\ngoal (1 subgoal):\n 1. var p < length llb", "by fastforce"], ["proof (state)\nthis:\n  var p < length llb\n\ngoal (1 subgoal):\n 1. q \\<notin> set_of lt \\<Longrightarrow>\n    q \\<in> set (llb[var p := p # llb ! var p] ! var q)", "with qp"], ["proof (chain)\npicking this:\n  q = p\n  var p < length llb", "show ?thesis"], ["proof (prove)\nusing this:\n  q = p\n  var p < length llb\n\ngoal (1 subgoal):\n 1. q \\<in> set (llb[var p := p # llb ! var p] ! var q)", "by simp"], ["proof (state)\nthis:\n  q \\<in> set (llb[var p := p # llb ! var p] ! var q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  q \\<in> set (llb[var p := p # llb ! var p] ! var q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  q \\<in> set (llb[var p := p # llb ! var p] ! var q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>q.\n     q \\<in> set_of (Node lt p rt) \\<longrightarrow>\n     q \\<in> set (llb[var p := p # llb ! var p] ! var q)\n\ngoal (1 subgoal):\n 1. wf_levellist (Node lt p rt) ll (llb[var p := p # llb ! var p])\n     var \\<and>\n    wf_marking (Node lt p rt) mark (markb(p := m)) m", "have prx_ll_st: \"\\<forall>i \\<le> var p.\n                   (\\<exists>prx. llb[var p :=p#llb!var p]!i = prx@(ll!i) \\<and>\n                         (\\<forall>pt \\<in> set prx. pt \\<in> set_of (Node lt p rt) \\<and> var pt = i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<le>var p.\n       \\<exists>prx.\n          llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n          (\\<forall>pt\\<in>set prx.\n              pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<le>var p.\n       \\<exists>prx.\n          llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n          (\\<forall>pt\\<in>set prx.\n              pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)", "apply (rule allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<le> var p \\<longrightarrow>\n       (\\<exists>prx.\n           llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n           (\\<forall>pt\\<in>set prx.\n               pt \\<in> set_of (Node lt p rt) \\<and> var pt = i))", "apply (rule impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<le> var p \\<Longrightarrow>\n       \\<exists>prx.\n          llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n          (\\<forall>pt\\<in>set prx.\n              pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<le> var p \\<Longrightarrow>\n       \\<exists>prx.\n          llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n          (\\<forall>pt\\<in>set prx.\n              pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<le> var p \\<Longrightarrow>\n       \\<exists>prx.\n          llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n          (\\<forall>pt\\<in>set prx.\n              pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)", "assume isep: \"i \\<le> var p\""], ["proof (state)\nthis:\n  i \\<le> var p\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<le> var p \\<Longrightarrow>\n       \\<exists>prx.\n          llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n          (\\<forall>pt\\<in>set prx.\n              pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)", "show \"\\<exists>prx. llb[var p :=p#llb!var p]!i = prx@ll!i \\<and>\n                      (\\<forall>pt\\<in>set prx. pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>prx.\n       llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n       (\\<forall>pt\\<in>set prx.\n           pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)", "proof (cases \"i = var p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = var p \\<Longrightarrow>\n    \\<exists>prx.\n       llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n       (\\<forall>pt\\<in>set prx.\n           pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)\n 2. i \\<noteq> var p \\<Longrightarrow>\n    \\<exists>prx.\n       llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n       (\\<forall>pt\\<in>set prx.\n           pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)", "case True"], ["proof (state)\nthis:\n  i = var p\n\ngoal (2 subgoals):\n 1. i = var p \\<Longrightarrow>\n    \\<exists>prx.\n       llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n       (\\<forall>pt\\<in>set prx.\n           pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)\n 2. i \\<noteq> var p \\<Longrightarrow>\n    \\<exists>prx.\n       llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n       (\\<forall>pt\\<in>set prx.\n           pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)", "with orderedt lt lt_Node rt rt_Node"], ["proof (chain)\npicking this:\n  ordered (Node lt p rt) var\n  Dag (low p) low high lt\n  lt = Node llt l rlt\n  Dag (high p) low high rt\n  rt = Node lrt r rrt\n  i = var p", "have lpsp: \"var (low p) < var p\""], ["proof (prove)\nusing this:\n  ordered (Node lt p rt) var\n  Dag (low p) low high lt\n  lt = Node llt l rlt\n  Dag (high p) low high rt\n  rt = Node lrt r rrt\n  i = var p\n\ngoal (1 subgoal):\n 1. var (low p) < var p", "by fastforce"], ["proof (state)\nthis:\n  var (low p) < var p\n\ngoal (2 subgoals):\n 1. i = var p \\<Longrightarrow>\n    \\<exists>prx.\n       llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n       (\\<forall>pt\\<in>set prx.\n           pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)\n 2. i \\<noteq> var p \\<Longrightarrow>\n    \\<exists>prx.\n       llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n       (\\<forall>pt\\<in>set prx.\n           pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)", "with orderedt lt lt_Node rt rt_Node"], ["proof (chain)\npicking this:\n  ordered (Node lt p rt) var\n  Dag (low p) low high lt\n  lt = Node llt l rlt\n  Dag (high p) low high rt\n  rt = Node lrt r rrt\n  var (low p) < var p", "have hpsp: \"var (high p) < var p\""], ["proof (prove)\nusing this:\n  ordered (Node lt p rt) var\n  Dag (low p) low high lt\n  lt = Node llt l rlt\n  Dag (high p) low high rt\n  rt = Node lrt r rrt\n  var (low p) < var p\n\ngoal (1 subgoal):\n 1. var (high p) < var p", "by fastforce"], ["proof (state)\nthis:\n  var (high p) < var p\n\ngoal (2 subgoals):\n 1. i = var p \\<Longrightarrow>\n    \\<exists>prx.\n       llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n       (\\<forall>pt\\<in>set prx.\n           pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)\n 2. i \\<noteq> var p \\<Longrightarrow>\n    \\<exists>prx.\n       llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n       (\\<forall>pt\\<in>set prx.\n           pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)", "with lpsp lla_nc"], ["proof (chain)\npicking this:\n  var (low p) < var p\n  \\<forall>i>var (low p). lla ! i = ll ! i\n  var (high p) < var p", "have llall: \"lla ! var p = ll ! var p\""], ["proof (prove)\nusing this:\n  var (low p) < var p\n  \\<forall>i>var (low p). lla ! i = ll ! i\n  var (high p) < var p\n\ngoal (1 subgoal):\n 1. lla ! var p = ll ! var p", "by fastforce"], ["proof (state)\nthis:\n  lla ! var p = ll ! var p\n\ngoal (2 subgoals):\n 1. i = var p \\<Longrightarrow>\n    \\<exists>prx.\n       llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n       (\\<forall>pt\\<in>set prx.\n           pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)\n 2. i \\<noteq> var p \\<Longrightarrow>\n    \\<exists>prx.\n       llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n       (\\<forall>pt\\<in>set prx.\n           pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)", "with hpsp llb_nc"], ["proof (chain)\npicking this:\n  var (high p) < var p\n  \\<forall>i>var (high p). llb ! i = lla ! i\n  lla ! var p = ll ! var p", "have \"llb ! var p = ll ! var p\""], ["proof (prove)\nusing this:\n  var (high p) < var p\n  \\<forall>i>var (high p). llb ! i = lla ! i\n  lla ! var p = ll ! var p\n\ngoal (1 subgoal):\n 1. llb ! var p = ll ! var p", "by fastforce"], ["proof (state)\nthis:\n  llb ! var p = ll ! var p\n\ngoal (2 subgoals):\n 1. i = var p \\<Longrightarrow>\n    \\<exists>prx.\n       llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n       (\\<forall>pt\\<in>set prx.\n           pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)\n 2. i \\<noteq> var p \\<Longrightarrow>\n    \\<exists>prx.\n       llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n       (\\<forall>pt\\<in>set prx.\n           pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)", "with llb_eq_lla lla_eq_ll isep True varsll lt rt"], ["proof (chain)\npicking this:\n  length llb = length lla\n  length lla = length ll\n  i \\<le> var p\n  i = var p\n  var p < length ll\n  Dag (low p) low high lt\n  Dag (high p) low high rt\n  llb ! var p = ll ! var p", "show ?thesis"], ["proof (prove)\nusing this:\n  length llb = length lla\n  length lla = length ll\n  i \\<le> var p\n  i = var p\n  var p < length ll\n  Dag (low p) low high lt\n  Dag (high p) low high rt\n  llb ! var p = ll ! var p\n\ngoal (1 subgoal):\n 1. \\<exists>prx.\n       llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n       (\\<forall>pt\\<in>set prx.\n           pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length llb = length lla; length lla = length ll; i \\<le> var p;\n     i = var p; var p < length ll; Dag (low p) low high lt;\n     Dag (high p) low high rt; llb ! var p = ll ! var p\\<rbrakk>\n    \\<Longrightarrow> \\<exists>prx.\n                         llb[var p := p # llb ! var p] ! i =\n                         prx @ ll ! i \\<and>\n                         (\\<forall>pt\\<in>set prx.\n                             pt \\<in> set_of (Node lt p rt) \\<and>\n                             var pt = i)", "apply (rule_tac x=\"[p]\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length llb = length lla; length lla = length ll; i \\<le> var p;\n     i = var p; var p < length ll; Dag (low p) low high lt;\n     Dag (high p) low high rt; llb ! var p = ll ! var p\\<rbrakk>\n    \\<Longrightarrow> llb[var p := p # llb ! var p] ! i =\n                      [p] @ ll ! i \\<and>\n                      (\\<forall>pt\\<in>set [p].\n                          pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>length llb = length lla; length lla = length ll; i \\<le> var p;\n     i = var p; var p < length ll; Dag (low p) low high lt;\n     Dag (high p) low high rt; llb ! var p = ll ! var p\\<rbrakk>\n    \\<Longrightarrow> llb[var p := p # llb ! var p] ! i = [p] @ ll ! i\n 2. \\<lbrakk>length llb = length lla; length lla = length ll; i \\<le> var p;\n     i = var p; var p < length ll; Dag (low p) low high lt;\n     Dag (high p) low high rt; llb ! var p = ll ! var p\\<rbrakk>\n    \\<Longrightarrow> \\<forall>pt\\<in>set [p].\n                         pt \\<in> set_of (Node lt p rt) \\<and> var pt = i", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length llb = length lla; length lla = length ll; i \\<le> var p;\n     i = var p; var p < length ll; Dag (low p) low high lt;\n     Dag (high p) low high rt; llb ! var p = ll ! var p\\<rbrakk>\n    \\<Longrightarrow> \\<forall>pt\\<in>set [p].\n                         pt \\<in> set_of (Node lt p rt) \\<and> var pt = i", "apply (rule ballI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>pt.\n       \\<lbrakk>length llb = length lla; length lla = length ll;\n        i \\<le> var p; i = var p; var p < length ll;\n        Dag (low p) low high lt; Dag (high p) low high rt;\n        llb ! var p = ll ! var p; pt \\<in> set [p]\\<rbrakk>\n       \\<Longrightarrow> pt \\<in> set_of (Node lt p rt) \\<and> var pt = i", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>prx.\n     llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n     (\\<forall>pt\\<in>set prx.\n         pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)\n\ngoal (1 subgoal):\n 1. i \\<noteq> var p \\<Longrightarrow>\n    \\<exists>prx.\n       llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n       (\\<forall>pt\\<in>set prx.\n           pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> var p \\<Longrightarrow>\n    \\<exists>prx.\n       llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n       (\\<forall>pt\\<in>set prx.\n           pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)", "assume inp: \" i \\<noteq> var p\""], ["proof (state)\nthis:\n  i \\<noteq> var p\n\ngoal (1 subgoal):\n 1. i \\<noteq> var p \\<Longrightarrow>\n    \\<exists>prx.\n       llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n       (\\<forall>pt\\<in>set prx.\n           pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>prx.\n       llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n       (\\<forall>pt\\<in>set prx.\n           pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)", "proof (cases \"var (low p) < i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. var (low p) < i \\<Longrightarrow>\n    \\<exists>prx.\n       llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n       (\\<forall>pt\\<in>set prx.\n           pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)\n 2. \\<not> var (low p) < i \\<Longrightarrow>\n    \\<exists>prx.\n       llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n       (\\<forall>pt\\<in>set prx.\n           pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)", "case True"], ["proof (state)\nthis:\n  var (low p) < i\n\ngoal (2 subgoals):\n 1. var (low p) < i \\<Longrightarrow>\n    \\<exists>prx.\n       llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n       (\\<forall>pt\\<in>set prx.\n           pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)\n 2. \\<not> var (low p) < i \\<Longrightarrow>\n    \\<exists>prx.\n       llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n       (\\<forall>pt\\<in>set prx.\n           pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)", "with lla_nc"], ["proof (chain)\npicking this:\n  \\<forall>i>var (low p). lla ! i = ll ! i\n  var (low p) < i", "have llall: \"lla ! i = ll ! i\""], ["proof (prove)\nusing this:\n  \\<forall>i>var (low p). lla ! i = ll ! i\n  var (low p) < i\n\ngoal (1 subgoal):\n 1. lla ! i = ll ! i", "by fastforce"], ["proof (state)\nthis:\n  lla ! i = ll ! i\n\ngoal (2 subgoals):\n 1. var (low p) < i \\<Longrightarrow>\n    \\<exists>prx.\n       llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n       (\\<forall>pt\\<in>set prx.\n           pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)\n 2. \\<not> var (low p) < i \\<Longrightarrow>\n    \\<exists>prx.\n       llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n       (\\<forall>pt\\<in>set prx.\n           pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)", "assume vpsi: \"var (low p) < i\""], ["proof (state)\nthis:\n  var (low p) < i\n\ngoal (2 subgoals):\n 1. var (low p) < i \\<Longrightarrow>\n    \\<exists>prx.\n       llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n       (\\<forall>pt\\<in>set prx.\n           pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)\n 2. \\<not> var (low p) < i \\<Longrightarrow>\n    \\<exists>prx.\n       llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n       (\\<forall>pt\\<in>set prx.\n           pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>prx.\n       llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n       (\\<forall>pt\\<in>set prx.\n           pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)", "proof (cases \"var (high p) < i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. var (high p) < i \\<Longrightarrow>\n    \\<exists>prx.\n       llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n       (\\<forall>pt\\<in>set prx.\n           pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)\n 2. \\<not> var (high p) < i \\<Longrightarrow>\n    \\<exists>prx.\n       llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n       (\\<forall>pt\\<in>set prx.\n           pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)", "case True"], ["proof (state)\nthis:\n  var (high p) < i\n\ngoal (2 subgoals):\n 1. var (high p) < i \\<Longrightarrow>\n    \\<exists>prx.\n       llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n       (\\<forall>pt\\<in>set prx.\n           pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)\n 2. \\<not> var (high p) < i \\<Longrightarrow>\n    \\<exists>prx.\n       llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n       (\\<forall>pt\\<in>set prx.\n           pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)", "with llall llb_nc"], ["proof (chain)\npicking this:\n  lla ! i = ll ! i\n  \\<forall>i>var (high p). llb ! i = lla ! i\n  var (high p) < i", "have \"llb ! i = ll ! i\""], ["proof (prove)\nusing this:\n  lla ! i = ll ! i\n  \\<forall>i>var (high p). llb ! i = lla ! i\n  var (high p) < i\n\ngoal (1 subgoal):\n 1. llb ! i = ll ! i", "by fastforce"], ["proof (state)\nthis:\n  llb ! i = ll ! i\n\ngoal (2 subgoals):\n 1. var (high p) < i \\<Longrightarrow>\n    \\<exists>prx.\n       llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n       (\\<forall>pt\\<in>set prx.\n           pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)\n 2. \\<not> var (high p) < i \\<Longrightarrow>\n    \\<exists>prx.\n       llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n       (\\<forall>pt\\<in>set prx.\n           pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)", "with inp True vpsi varsll lt rt"], ["proof (chain)\npicking this:\n  i \\<noteq> var p\n  var (high p) < i\n  var (low p) < i\n  var p < length ll\n  Dag (low p) low high lt\n  Dag (high p) low high rt\n  llb ! i = ll ! i", "show ?thesis"], ["proof (prove)\nusing this:\n  i \\<noteq> var p\n  var (high p) < i\n  var (low p) < i\n  var p < length ll\n  Dag (low p) low high lt\n  Dag (high p) low high rt\n  llb ! i = ll ! i\n\ngoal (1 subgoal):\n 1. \\<exists>prx.\n       llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n       (\\<forall>pt\\<in>set prx.\n           pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<noteq> var p; var (high p) < i; var (low p) < i;\n     var p < length ll; Dag (low p) low high lt; Dag (high p) low high rt;\n     llb ! i = ll ! i\\<rbrakk>\n    \\<Longrightarrow> \\<exists>prx.\n                         llb[var p := p # llb ! var p] ! i =\n                         prx @ ll ! i \\<and>\n                         (\\<forall>pt\\<in>set prx.\n                             pt \\<in> set_of (Node lt p rt) \\<and>\n                             var pt = i)", "apply (rule_tac x=\"[]\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<noteq> var p; var (high p) < i; var (low p) < i;\n     var p < length ll; Dag (low p) low high lt; Dag (high p) low high rt;\n     llb ! i = ll ! i\\<rbrakk>\n    \\<Longrightarrow> llb[var p := p # llb ! var p] ! i = [] @ ll ! i \\<and>\n                      (\\<forall>pt\\<in>set [].\n                          pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>i \\<noteq> var p; var (high p) < i; var (low p) < i;\n     var p < length ll; Dag (low p) low high lt; Dag (high p) low high rt;\n     llb ! i = ll ! i\\<rbrakk>\n    \\<Longrightarrow> llb[var p := p # llb ! var p] ! i = [] @ ll ! i\n 2. \\<lbrakk>i \\<noteq> var p; var (high p) < i; var (low p) < i;\n     var p < length ll; Dag (low p) low high lt; Dag (high p) low high rt;\n     llb ! i = ll ! i\\<rbrakk>\n    \\<Longrightarrow> \\<forall>pt\\<in>set [].\n                         pt \\<in> set_of (Node lt p rt) \\<and> var pt = i", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<noteq> var p; var (high p) < i; var (low p) < i;\n     var p < length ll; Dag (low p) low high lt; Dag (high p) low high rt;\n     llb ! i = ll ! i\\<rbrakk>\n    \\<Longrightarrow> \\<forall>pt\\<in>set [].\n                         pt \\<in> set_of (Node lt p rt) \\<and> var pt = i", "apply (rule ballI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>pt.\n       \\<lbrakk>i \\<noteq> var p; var (high p) < i; var (low p) < i;\n        var p < length ll; Dag (low p) low high lt;\n        Dag (high p) low high rt; llb ! i = ll ! i; pt \\<in> set []\\<rbrakk>\n       \\<Longrightarrow> pt \\<in> set_of (Node lt p rt) \\<and> var pt = i", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>prx.\n     llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n     (\\<forall>pt\\<in>set prx.\n         pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)\n\ngoal (1 subgoal):\n 1. \\<not> var (high p) < i \\<Longrightarrow>\n    \\<exists>prx.\n       llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n       (\\<forall>pt\\<in>set prx.\n           pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> var (high p) < i \\<Longrightarrow>\n    \\<exists>prx.\n       llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n       (\\<forall>pt\\<in>set prx.\n           pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)", "assume isehp: \" \\<not> var (high p) < i\""], ["proof (state)\nthis:\n  \\<not> var (high p) < i\n\ngoal (1 subgoal):\n 1. \\<not> var (high p) < i \\<Longrightarrow>\n    \\<exists>prx.\n       llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n       (\\<forall>pt\\<in>set prx.\n           pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)", "with vpsi lla_nc"], ["proof (chain)\npicking this:\n  var (low p) < i\n  \\<forall>i>var (low p). lla ! i = ll ! i\n  \\<not> var (high p) < i", "have lla_ll: \"lla ! i = ll ! i\""], ["proof (prove)\nusing this:\n  var (low p) < i\n  \\<forall>i>var (low p). lla ! i = ll ! i\n  \\<not> var (high p) < i\n\ngoal (1 subgoal):\n 1. lla ! i = ll ! i", "by fastforce"], ["proof (state)\nthis:\n  lla ! i = ll ! i\n\ngoal (1 subgoal):\n 1. \\<not> var (high p) < i \\<Longrightarrow>\n    \\<exists>prx.\n       llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n       (\\<forall>pt\\<in>set prx.\n           pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)", "with isehp llb_st"], ["proof (chain)\npicking this:\n  \\<not> var (high p) < i\n  \\<forall>i\\<le>var (high p).\n     \\<exists>prx.\n        llb ! i = prx @ lla ! i \\<and>\n        (\\<forall>pt\\<in>set prx. pt \\<in> set_of rt \\<and> var pt = i)\n  lla ! i = ll ! i", "have prx_lla: \"\\<exists>prx. llb ! i = prx @ lla ! i \\<and>\n                            (\\<forall>pt\\<in>set prx. pt \\<in> set_of rt \\<and> var pt = i)\""], ["proof (prove)\nusing this:\n  \\<not> var (high p) < i\n  \\<forall>i\\<le>var (high p).\n     \\<exists>prx.\n        llb ! i = prx @ lla ! i \\<and>\n        (\\<forall>pt\\<in>set prx. pt \\<in> set_of rt \\<and> var pt = i)\n  lla ! i = ll ! i\n\ngoal (1 subgoal):\n 1. \\<exists>prx.\n       llb ! i = prx @ lla ! i \\<and>\n       (\\<forall>pt\\<in>set prx. pt \\<in> set_of rt \\<and> var pt = i)", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> var (high p) < i;\n     \\<forall>i\\<le>var (high p).\n        \\<exists>prx.\n           llb ! i = prx @ lla ! i \\<and>\n           (\\<forall>pt\\<in>set prx. pt \\<in> set_of rt \\<and> var pt = i);\n     lla ! i = ll ! i\\<rbrakk>\n    \\<Longrightarrow> \\<exists>prx.\n                         llb ! i = prx @ lla ! i \\<and>\n                         (\\<forall>pt\\<in>set prx.\n                             pt \\<in> set_of rt \\<and> var pt = i)", "apply (erule_tac x=\"i\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> var (high p) < i; lla ! i = ll ! i;\n     i \\<le> var (high p) \\<longrightarrow>\n     (\\<exists>prx.\n         llb ! i = prx @ lla ! i \\<and>\n         (\\<forall>pt\\<in>set prx.\n             pt \\<in> set_of rt \\<and> var pt = i))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>prx.\n                         llb ! i = prx @ lla ! i \\<and>\n                         (\\<forall>pt\\<in>set prx.\n                             pt \\<in> set_of rt \\<and> var pt = i)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>prx.\n     llb ! i = prx @ lla ! i \\<and>\n     (\\<forall>pt\\<in>set prx. pt \\<in> set_of rt \\<and> var pt = i)\n\ngoal (1 subgoal):\n 1. \\<not> var (high p) < i \\<Longrightarrow>\n    \\<exists>prx.\n       llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n       (\\<forall>pt\\<in>set prx.\n           pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)", "with lla_ll inp rt"], ["proof (chain)\npicking this:\n  lla ! i = ll ! i\n  i \\<noteq> var p\n  Dag (high p) low high rt\n  \\<exists>prx.\n     llb ! i = prx @ lla ! i \\<and>\n     (\\<forall>pt\\<in>set prx. pt \\<in> set_of rt \\<and> var pt = i)", "show ?thesis"], ["proof (prove)\nusing this:\n  lla ! i = ll ! i\n  i \\<noteq> var p\n  Dag (high p) low high rt\n  \\<exists>prx.\n     llb ! i = prx @ lla ! i \\<and>\n     (\\<forall>pt\\<in>set prx. pt \\<in> set_of rt \\<and> var pt = i)\n\ngoal (1 subgoal):\n 1. \\<exists>prx.\n       llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n       (\\<forall>pt\\<in>set prx.\n           pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lla ! i = ll ! i; i \\<noteq> var p; Dag (high p) low high rt;\n     \\<exists>prx.\n        llb ! i = prx @ lla ! i \\<and>\n        (\\<forall>pt\\<in>set prx.\n            pt \\<in> set_of rt \\<and> var pt = i)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>prx.\n                         llb[var p := p # llb ! var p] ! i =\n                         prx @ ll ! i \\<and>\n                         (\\<forall>pt\\<in>set prx.\n                             pt \\<in> set_of (Node lt p rt) \\<and>\n                             var pt = i)", "apply (erule exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>prx.\n       \\<lbrakk>lla ! i = ll ! i; i \\<noteq> var p;\n        Dag (high p) low high rt;\n        llb ! i = prx @ lla ! i \\<and>\n        (\\<forall>pt\\<in>set prx.\n            pt \\<in> set_of rt \\<and> var pt = i)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>prx.\n                            llb[var p := p # llb ! var p] ! i =\n                            prx @ ll ! i \\<and>\n                            (\\<forall>pt\\<in>set prx.\n                                pt \\<in> set_of (Node lt p rt) \\<and>\n                                var pt = i)", "apply (rule_tac x=\"prx\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>prx.\n       \\<lbrakk>lla ! i = ll ! i; i \\<noteq> var p;\n        Dag (high p) low high rt;\n        llb ! i = prx @ lla ! i \\<and>\n        (\\<forall>pt\\<in>set prx.\n            pt \\<in> set_of rt \\<and> var pt = i)\\<rbrakk>\n       \\<Longrightarrow> llb[var p := p # llb ! var p] ! i =\n                         prx @ ll ! i \\<and>\n                         (\\<forall>pt\\<in>set prx.\n                             pt \\<in> set_of (Node lt p rt) \\<and>\n                             var pt = i)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>prx.\n     llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n     (\\<forall>pt\\<in>set prx.\n         pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>prx.\n     llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n     (\\<forall>pt\\<in>set prx.\n         pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)\n\ngoal (1 subgoal):\n 1. \\<not> var (low p) < i \\<Longrightarrow>\n    \\<exists>prx.\n       llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n       (\\<forall>pt\\<in>set prx.\n           pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> var (low p) < i \\<Longrightarrow>\n    \\<exists>prx.\n       llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n       (\\<forall>pt\\<in>set prx.\n           pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)", "assume iselp: \"\\<not> var (low p) < i\""], ["proof (state)\nthis:\n  \\<not> var (low p) < i\n\ngoal (1 subgoal):\n 1. \\<not> var (low p) < i \\<Longrightarrow>\n    \\<exists>prx.\n       llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n       (\\<forall>pt\\<in>set prx.\n           pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>prx.\n       llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n       (\\<forall>pt\\<in>set prx.\n           pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)", "proof (cases \"var (high p) < i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. var (high p) < i \\<Longrightarrow>\n    \\<exists>prx.\n       llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n       (\\<forall>pt\\<in>set prx.\n           pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)\n 2. \\<not> var (high p) < i \\<Longrightarrow>\n    \\<exists>prx.\n       llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n       (\\<forall>pt\\<in>set prx.\n           pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)", "case True"], ["proof (state)\nthis:\n  var (high p) < i\n\ngoal (2 subgoals):\n 1. var (high p) < i \\<Longrightarrow>\n    \\<exists>prx.\n       llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n       (\\<forall>pt\\<in>set prx.\n           pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)\n 2. \\<not> var (high p) < i \\<Longrightarrow>\n    \\<exists>prx.\n       llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n       (\\<forall>pt\\<in>set prx.\n           pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)", "with llb_nc"], ["proof (chain)\npicking this:\n  \\<forall>i>var (high p). llb ! i = lla ! i\n  var (high p) < i", "have llb_ll: \"llb ! i = lla ! i\""], ["proof (prove)\nusing this:\n  \\<forall>i>var (high p). llb ! i = lla ! i\n  var (high p) < i\n\ngoal (1 subgoal):\n 1. llb ! i = lla ! i", "by fastforce"], ["proof (state)\nthis:\n  llb ! i = lla ! i\n\ngoal (2 subgoals):\n 1. var (high p) < i \\<Longrightarrow>\n    \\<exists>prx.\n       llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n       (\\<forall>pt\\<in>set prx.\n           pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)\n 2. \\<not> var (high p) < i \\<Longrightarrow>\n    \\<exists>prx.\n       llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n       (\\<forall>pt\\<in>set prx.\n           pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)", "with iselp lla_st"], ["proof (chain)\npicking this:\n  \\<not> var (low p) < i\n  \\<forall>i\\<le>var (low p).\n     \\<exists>prx.\n        lla ! i = prx @ ll ! i \\<and>\n        (\\<forall>pt\\<in>set prx. pt \\<in> set_of lt \\<and> var pt = i)\n  llb ! i = lla ! i", "have prx_ll: \"\\<exists>prx. lla ! i = prx @ ll ! i \\<and>\n                            (\\<forall>pt\\<in>set prx. pt \\<in> set_of lt \\<and> var pt = i)\""], ["proof (prove)\nusing this:\n  \\<not> var (low p) < i\n  \\<forall>i\\<le>var (low p).\n     \\<exists>prx.\n        lla ! i = prx @ ll ! i \\<and>\n        (\\<forall>pt\\<in>set prx. pt \\<in> set_of lt \\<and> var pt = i)\n  llb ! i = lla ! i\n\ngoal (1 subgoal):\n 1. \\<exists>prx.\n       lla ! i = prx @ ll ! i \\<and>\n       (\\<forall>pt\\<in>set prx. pt \\<in> set_of lt \\<and> var pt = i)", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> var (low p) < i;\n     \\<forall>i\\<le>var (low p).\n        \\<exists>prx.\n           lla ! i = prx @ ll ! i \\<and>\n           (\\<forall>pt\\<in>set prx. pt \\<in> set_of lt \\<and> var pt = i);\n     llb ! i = lla ! i\\<rbrakk>\n    \\<Longrightarrow> \\<exists>prx.\n                         lla ! i = prx @ ll ! i \\<and>\n                         (\\<forall>pt\\<in>set prx.\n                             pt \\<in> set_of lt \\<and> var pt = i)", "apply (erule_tac x=\"i\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> var (low p) < i; llb ! i = lla ! i;\n     i \\<le> var (low p) \\<longrightarrow>\n     (\\<exists>prx.\n         lla ! i = prx @ ll ! i \\<and>\n         (\\<forall>pt\\<in>set prx.\n             pt \\<in> set_of lt \\<and> var pt = i))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>prx.\n                         lla ! i = prx @ ll ! i \\<and>\n                         (\\<forall>pt\\<in>set prx.\n                             pt \\<in> set_of lt \\<and> var pt = i)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>prx.\n     lla ! i = prx @ ll ! i \\<and>\n     (\\<forall>pt\\<in>set prx. pt \\<in> set_of lt \\<and> var pt = i)\n\ngoal (2 subgoals):\n 1. var (high p) < i \\<Longrightarrow>\n    \\<exists>prx.\n       llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n       (\\<forall>pt\\<in>set prx.\n           pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)\n 2. \\<not> var (high p) < i \\<Longrightarrow>\n    \\<exists>prx.\n       llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n       (\\<forall>pt\\<in>set prx.\n           pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)", "with llb_ll inp lt"], ["proof (chain)\npicking this:\n  llb ! i = lla ! i\n  i \\<noteq> var p\n  Dag (low p) low high lt\n  \\<exists>prx.\n     lla ! i = prx @ ll ! i \\<and>\n     (\\<forall>pt\\<in>set prx. pt \\<in> set_of lt \\<and> var pt = i)", "show ?thesis"], ["proof (prove)\nusing this:\n  llb ! i = lla ! i\n  i \\<noteq> var p\n  Dag (low p) low high lt\n  \\<exists>prx.\n     lla ! i = prx @ ll ! i \\<and>\n     (\\<forall>pt\\<in>set prx. pt \\<in> set_of lt \\<and> var pt = i)\n\ngoal (1 subgoal):\n 1. \\<exists>prx.\n       llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n       (\\<forall>pt\\<in>set prx.\n           pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>llb ! i = lla ! i; i \\<noteq> var p; Dag (low p) low high lt;\n     \\<exists>prx.\n        lla ! i = prx @ ll ! i \\<and>\n        (\\<forall>pt\\<in>set prx.\n            pt \\<in> set_of lt \\<and> var pt = i)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>prx.\n                         llb[var p := p # llb ! var p] ! i =\n                         prx @ ll ! i \\<and>\n                         (\\<forall>pt\\<in>set prx.\n                             pt \\<in> set_of (Node lt p rt) \\<and>\n                             var pt = i)", "apply (erule exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>prx.\n       \\<lbrakk>llb ! i = lla ! i; i \\<noteq> var p;\n        Dag (low p) low high lt;\n        lla ! i = prx @ ll ! i \\<and>\n        (\\<forall>pt\\<in>set prx.\n            pt \\<in> set_of lt \\<and> var pt = i)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>prx.\n                            llb[var p := p # llb ! var p] ! i =\n                            prx @ ll ! i \\<and>\n                            (\\<forall>pt\\<in>set prx.\n                                pt \\<in> set_of (Node lt p rt) \\<and>\n                                var pt = i)", "apply (rule_tac x=\"prx\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>prx.\n       \\<lbrakk>llb ! i = lla ! i; i \\<noteq> var p;\n        Dag (low p) low high lt;\n        lla ! i = prx @ ll ! i \\<and>\n        (\\<forall>pt\\<in>set prx.\n            pt \\<in> set_of lt \\<and> var pt = i)\\<rbrakk>\n       \\<Longrightarrow> llb[var p := p # llb ! var p] ! i =\n                         prx @ ll ! i \\<and>\n                         (\\<forall>pt\\<in>set prx.\n                             pt \\<in> set_of (Node lt p rt) \\<and>\n                             var pt = i)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>prx.\n     llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n     (\\<forall>pt\\<in>set prx.\n         pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)\n\ngoal (1 subgoal):\n 1. \\<not> var (high p) < i \\<Longrightarrow>\n    \\<exists>prx.\n       llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n       (\\<forall>pt\\<in>set prx.\n           pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> var (high p) < i \\<Longrightarrow>\n    \\<exists>prx.\n       llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n       (\\<forall>pt\\<in>set prx.\n           pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)", "assume isehp: \" \\<not> var (high p) < i\""], ["proof (state)\nthis:\n  \\<not> var (high p) < i\n\ngoal (1 subgoal):\n 1. \\<not> var (high p) < i \\<Longrightarrow>\n    \\<exists>prx.\n       llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n       (\\<forall>pt\\<in>set prx.\n           pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)", "from iselp lla_st"], ["proof (chain)\npicking this:\n  \\<not> var (low p) < i\n  \\<forall>i\\<le>var (low p).\n     \\<exists>prx.\n        lla ! i = prx @ ll ! i \\<and>\n        (\\<forall>pt\\<in>set prx. pt \\<in> set_of lt \\<and> var pt = i)", "have prxl: \"\\<exists>prx. lla ! i = prx @ ll ! i \\<and>\n                            (\\<forall>pt\\<in>set prx. pt \\<in> set_of lt \\<and> var pt = i)\""], ["proof (prove)\nusing this:\n  \\<not> var (low p) < i\n  \\<forall>i\\<le>var (low p).\n     \\<exists>prx.\n        lla ! i = prx @ ll ! i \\<and>\n        (\\<forall>pt\\<in>set prx. pt \\<in> set_of lt \\<and> var pt = i)\n\ngoal (1 subgoal):\n 1. \\<exists>prx.\n       lla ! i = prx @ ll ! i \\<and>\n       (\\<forall>pt\\<in>set prx. pt \\<in> set_of lt \\<and> var pt = i)", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>prx.\n     lla ! i = prx @ ll ! i \\<and>\n     (\\<forall>pt\\<in>set prx. pt \\<in> set_of lt \\<and> var pt = i)\n\ngoal (1 subgoal):\n 1. \\<not> var (high p) < i \\<Longrightarrow>\n    \\<exists>prx.\n       llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n       (\\<forall>pt\\<in>set prx.\n           pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)", "from isehp llb_st"], ["proof (chain)\npicking this:\n  \\<not> var (high p) < i\n  \\<forall>i\\<le>var (high p).\n     \\<exists>prx.\n        llb ! i = prx @ lla ! i \\<and>\n        (\\<forall>pt\\<in>set prx. pt \\<in> set_of rt \\<and> var pt = i)", "have prxh: \"\\<exists>prx. llb ! i = prx @ lla ! i \\<and>\n                            (\\<forall>pt\\<in>set prx. pt \\<in> set_of rt \\<and> var pt = i)\""], ["proof (prove)\nusing this:\n  \\<not> var (high p) < i\n  \\<forall>i\\<le>var (high p).\n     \\<exists>prx.\n        llb ! i = prx @ lla ! i \\<and>\n        (\\<forall>pt\\<in>set prx. pt \\<in> set_of rt \\<and> var pt = i)\n\ngoal (1 subgoal):\n 1. \\<exists>prx.\n       llb ! i = prx @ lla ! i \\<and>\n       (\\<forall>pt\\<in>set prx. pt \\<in> set_of rt \\<and> var pt = i)", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>prx.\n     llb ! i = prx @ lla ! i \\<and>\n     (\\<forall>pt\\<in>set prx. pt \\<in> set_of rt \\<and> var pt = i)\n\ngoal (1 subgoal):\n 1. \\<not> var (high p) < i \\<Longrightarrow>\n    \\<exists>prx.\n       llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n       (\\<forall>pt\\<in>set prx.\n           pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)", "with prxl inp lt pnN rt"], ["proof (chain)\npicking this:\n  \\<exists>prx.\n     lla ! i = prx @ ll ! i \\<and>\n     (\\<forall>pt\\<in>set prx. pt \\<in> set_of lt \\<and> var pt = i)\n  i \\<noteq> var p\n  Dag (low p) low high lt\n  p \\<noteq> Null\n  Dag (high p) low high rt\n  \\<exists>prx.\n     llb ! i = prx @ lla ! i \\<and>\n     (\\<forall>pt\\<in>set prx. pt \\<in> set_of rt \\<and> var pt = i)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>prx.\n     lla ! i = prx @ ll ! i \\<and>\n     (\\<forall>pt\\<in>set prx. pt \\<in> set_of lt \\<and> var pt = i)\n  i \\<noteq> var p\n  Dag (low p) low high lt\n  p \\<noteq> Null\n  Dag (high p) low high rt\n  \\<exists>prx.\n     llb ! i = prx @ lla ! i \\<and>\n     (\\<forall>pt\\<in>set prx. pt \\<in> set_of rt \\<and> var pt = i)\n\ngoal (1 subgoal):\n 1. \\<exists>prx.\n       llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n       (\\<forall>pt\\<in>set prx.\n           pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>prx.\n                lla ! i = prx @ ll ! i \\<and>\n                (\\<forall>pt\\<in>set prx.\n                    pt \\<in> set_of lt \\<and> var pt = i);\n     i \\<noteq> var p; Dag (low p) low high lt; p \\<noteq> Null;\n     Dag (high p) low high rt;\n     \\<exists>prx.\n        llb ! i = prx @ lla ! i \\<and>\n        (\\<forall>pt\\<in>set prx.\n            pt \\<in> set_of rt \\<and> var pt = i)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>prx.\n                         llb[var p := p # llb ! var p] ! i =\n                         prx @ ll ! i \\<and>\n                         (\\<forall>pt\\<in>set prx.\n                             pt \\<in> set_of (Node lt p rt) \\<and>\n                             var pt = i)", "apply (elim exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>prx prxa.\n       \\<lbrakk>i \\<noteq> var p; Dag (low p) low high lt; p \\<noteq> Null;\n        Dag (high p) low high rt;\n        lla ! i = prx @ ll ! i \\<and>\n        (\\<forall>pt\\<in>set prx. pt \\<in> set_of lt \\<and> var pt = i);\n        llb ! i = prxa @ lla ! i \\<and>\n        (\\<forall>pt\\<in>set prxa.\n            pt \\<in> set_of rt \\<and> var pt = i)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>prx.\n                            llb[var p := p # llb ! var p] ! i =\n                            prx @ ll ! i \\<and>\n                            (\\<forall>pt\\<in>set prx.\n                                pt \\<in> set_of (Node lt p rt) \\<and>\n                                var pt = i)", "apply (rule_tac x=\"prxa @ prx\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>prx prxa.\n       \\<lbrakk>i \\<noteq> var p; Dag (low p) low high lt; p \\<noteq> Null;\n        Dag (high p) low high rt;\n        lla ! i = prx @ ll ! i \\<and>\n        (\\<forall>pt\\<in>set prx. pt \\<in> set_of lt \\<and> var pt = i);\n        llb ! i = prxa @ lla ! i \\<and>\n        (\\<forall>pt\\<in>set prxa.\n            pt \\<in> set_of rt \\<and> var pt = i)\\<rbrakk>\n       \\<Longrightarrow> llb[var p := p # llb ! var p] ! i =\n                         (prxa @ prx) @ ll ! i \\<and>\n                         (\\<forall>pt\\<in>set (prxa @ prx).\n                             pt \\<in> set_of (Node lt p rt) \\<and>\n                             var pt = i)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>prx prxa.\n       \\<lbrakk>i \\<noteq> var p; Dag (low p) low high lt; p \\<noteq> Null;\n        Dag (high p) low high rt;\n        lla ! i = prx @ ll ! i \\<and>\n        (\\<forall>pt\\<in>set prx. pt \\<in> set_of lt \\<and> var pt = i);\n        llb ! i = prxa @ prx @ ll ! i \\<and>\n        (\\<forall>pt\\<in>set prxa.\n            pt \\<in> set_of rt \\<and> var pt = i)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>pt\\<in>set prxa \\<union> set prx.\n                            (pt = p \\<or>\n                             pt \\<in> set_of lt \\<or>\n                             pt \\<in> set_of rt) \\<and>\n                            var pt = i", "apply (elim conjE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>prx prxa.\n       \\<lbrakk>i \\<noteq> var p; Dag (low p) low high lt; p \\<noteq> Null;\n        Dag (high p) low high rt; lla ! i = prx @ ll ! i;\n        \\<forall>pt\\<in>set prx. pt \\<in> set_of lt \\<and> var pt = i;\n        llb ! i = prxa @ prx @ ll ! i;\n        \\<forall>pt\\<in>set prxa.\n           pt \\<in> set_of rt \\<and> var pt = i\\<rbrakk>\n       \\<Longrightarrow> \\<forall>pt\\<in>set prxa \\<union> set prx.\n                            (pt = p \\<or>\n                             pt \\<in> set_of lt \\<or>\n                             pt \\<in> set_of rt) \\<and>\n                            var pt = i", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>prx.\n     llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n     (\\<forall>pt\\<in>set prx.\n         pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>prx.\n     llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n     (\\<forall>pt\\<in>set prx.\n         pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>prx.\n     llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n     (\\<forall>pt\\<in>set prx.\n         pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>prx.\n     llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n     (\\<forall>pt\\<in>set prx.\n         pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i\\<le>var p.\n     \\<exists>prx.\n        llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n        (\\<forall>pt\\<in>set prx.\n            pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)\n\ngoal (1 subgoal):\n 1. wf_levellist (Node lt p rt) ll (llb[var p := p # llb ! var p])\n     var \\<and>\n    wf_marking (Node lt p rt) mark (markb(p := m)) m", "have big_Nodes_nc: \"\\<forall>i. (p->var) < i\n                    \\<longrightarrow> (llb[var p :=p # llb ! var p]) ! i = ll ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i>var p. llb[var p := p # llb ! var p] ! i = ll ! i", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i>var p. llb[var p := p # llb ! var p] ! i = ll ! i", "apply (rule allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       var p < i \\<longrightarrow>\n       llb[var p := p # llb ! var p] ! i = ll ! i", "apply (rule impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       var p < i \\<Longrightarrow>\n       llb[var p := p # llb ! var p] ! i = ll ! i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       var p < i \\<Longrightarrow>\n       llb[var p := p # llb ! var p] ! i = ll ! i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       var p < i \\<Longrightarrow>\n       llb[var p := p # llb ! var p] ! i = ll ! i", "assume psi: \"var p < i\""], ["proof (state)\nthis:\n  var p < i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       var p < i \\<Longrightarrow>\n       llb[var p := p # llb ! var p] ! i = ll ! i", "with orderedt lt rt lt_Node rt_Node"], ["proof (chain)\npicking this:\n  ordered (Node lt p rt) var\n  Dag (low p) low high lt\n  Dag (high p) low high rt\n  lt = Node llt l rlt\n  rt = Node lrt r rrt\n  var p < i", "have lpsi: \"var (low p) < i\""], ["proof (prove)\nusing this:\n  ordered (Node lt p rt) var\n  Dag (low p) low high lt\n  Dag (high p) low high rt\n  lt = Node llt l rlt\n  rt = Node lrt r rrt\n  var p < i\n\ngoal (1 subgoal):\n 1. var (low p) < i", "by fastforce"], ["proof (state)\nthis:\n  var (low p) < i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       var p < i \\<Longrightarrow>\n       llb[var p := p # llb ! var p] ! i = ll ! i", "with lla_nc"], ["proof (chain)\npicking this:\n  \\<forall>i>var (low p). lla ! i = ll ! i\n  var (low p) < i", "have lla_ll: \"lla ! i = ll ! i\""], ["proof (prove)\nusing this:\n  \\<forall>i>var (low p). lla ! i = ll ! i\n  var (low p) < i\n\ngoal (1 subgoal):\n 1. lla ! i = ll ! i", "by fastforce"], ["proof (state)\nthis:\n  lla ! i = ll ! i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       var p < i \\<Longrightarrow>\n       llb[var p := p # llb ! var p] ! i = ll ! i", "from psi orderedt lt rt lt_Node rt_Node"], ["proof (chain)\npicking this:\n  var p < i\n  ordered (Node lt p rt) var\n  Dag (low p) low high lt\n  Dag (high p) low high rt\n  lt = Node llt l rlt\n  rt = Node lrt r rrt", "have hpsi: \"var (high p) < i\""], ["proof (prove)\nusing this:\n  var p < i\n  ordered (Node lt p rt) var\n  Dag (low p) low high lt\n  Dag (high p) low high rt\n  lt = Node llt l rlt\n  rt = Node lrt r rrt\n\ngoal (1 subgoal):\n 1. var (high p) < i", "by fastforce"], ["proof (state)\nthis:\n  var (high p) < i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       var p < i \\<Longrightarrow>\n       llb[var p := p # llb ! var p] ! i = ll ! i", "with llb_nc"], ["proof (chain)\npicking this:\n  \\<forall>i>var (high p). llb ! i = lla ! i\n  var (high p) < i", "have llb_lla: \"llb ! i = lla ! i\""], ["proof (prove)\nusing this:\n  \\<forall>i>var (high p). llb ! i = lla ! i\n  var (high p) < i\n\ngoal (1 subgoal):\n 1. llb ! i = lla ! i", "by fastforce"], ["proof (state)\nthis:\n  llb ! i = lla ! i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       var p < i \\<Longrightarrow>\n       llb[var p := p # llb ! var p] ! i = ll ! i", "from psi"], ["proof (chain)\npicking this:\n  var p < i", "have upllb_llb: \"llb[var p :=p#llb!var p]!i = llb!i\""], ["proof (prove)\nusing this:\n  var p < i\n\ngoal (1 subgoal):\n 1. llb[var p := p # llb ! var p] ! i = llb ! i", "by fastforce"], ["proof (state)\nthis:\n  llb[var p := p # llb ! var p] ! i = llb ! i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       var p < i \\<Longrightarrow>\n       llb[var p := p # llb ! var p] ! i = ll ! i", "from upllb_llb llb_lla lla_ll"], ["proof (chain)\npicking this:\n  llb[var p := p # llb ! var p] ! i = llb ! i\n  llb ! i = lla ! i\n  lla ! i = ll ! i", "show \"llb[var p :=p # llb ! var p] ! i = ll ! i\""], ["proof (prove)\nusing this:\n  llb[var p := p # llb ! var p] ! i = llb ! i\n  llb ! i = lla ! i\n  lla ! i = ll ! i\n\ngoal (1 subgoal):\n 1. llb[var p := p # llb ! var p] ! i = ll ! i", "by fastforce"], ["proof (state)\nthis:\n  llb[var p := p # llb ! var p] ! i = ll ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i>var p. llb[var p := p # llb ! var p] ! i = ll ! i\n\ngoal (1 subgoal):\n 1. wf_levellist (Node lt p rt) ll (llb[var p := p # llb ! var p])\n     var \\<and>\n    wf_marking (Node lt p rt) mark (markb(p := m)) m", "from lla_eq_ll llb_eq_lla"], ["proof (chain)\npicking this:\n  length lla = length ll\n  length llb = length lla", "have length_eq: \"length (llb[var p :=p # llb ! var p]) = length ll\""], ["proof (prove)\nusing this:\n  length lla = length ll\n  length llb = length lla\n\ngoal (1 subgoal):\n 1. length (llb[var p := p # llb ! var p]) = length ll", "by fastforce"], ["proof (state)\nthis:\n  length (llb[var p := p # llb ! var p]) = length ll\n\ngoal (1 subgoal):\n 1. wf_levellist (Node lt p rt) ll (llb[var p := p # llb ! var p])\n     var \\<and>\n    wf_marking (Node lt p rt) mark (markb(p := m)) m", "from length_eq big_Nodes_nc prx_ll_st nodes_in_upllb"], ["proof (chain)\npicking this:\n  length (llb[var p := p # llb ! var p]) = length ll\n  \\<forall>i>var p. llb[var p := p # llb ! var p] ! i = ll ! i\n  \\<forall>i\\<le>var p.\n     \\<exists>prx.\n        llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n        (\\<forall>pt\\<in>set prx.\n            pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)\n  \\<forall>q.\n     q \\<in> set_of (Node lt p rt) \\<longrightarrow>\n     q \\<in> set (llb[var p := p # llb ! var p] ! var q)", "have wf_ll_upllb:\n                    \"wf_levellist (Node lt p rt) ll (llb[var p :=p # llb ! var p]) var\""], ["proof (prove)\nusing this:\n  length (llb[var p := p # llb ! var p]) = length ll\n  \\<forall>i>var p. llb[var p := p # llb ! var p] ! i = ll ! i\n  \\<forall>i\\<le>var p.\n     \\<exists>prx.\n        llb[var p := p # llb ! var p] ! i = prx @ ll ! i \\<and>\n        (\\<forall>pt\\<in>set prx.\n            pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)\n  \\<forall>q.\n     q \\<in> set_of (Node lt p rt) \\<longrightarrow>\n     q \\<in> set (llb[var p := p # llb ! var p] ! var q)\n\ngoal (1 subgoal):\n 1. wf_levellist (Node lt p rt) ll (llb[var p := p # llb ! var p]) var", "by (simp add: wf_levellist_def)"], ["proof (state)\nthis:\n  wf_levellist (Node lt p rt) ll (llb[var p := p # llb ! var p]) var\n\ngoal (1 subgoal):\n 1. wf_levellist (Node lt p rt) ll (llb[var p := p # llb ! var p])\n     var \\<and>\n    wf_marking (Node lt p rt) mark (markb(p := m)) m", "have mark_nc:\n                    \"\\<forall> n. n \\<notin> set_of (Node lt p rt) \\<longrightarrow> (markb(p:=m)) n = mark n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n.\n       n \\<notin> set_of (Node lt p rt) \\<longrightarrow>\n       (markb(p := m)) n = mark n", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n.\n       n \\<notin> set_of (Node lt p rt) \\<longrightarrow>\n       (markb(p := m)) n = mark n", "apply (rule allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<notin> set_of (Node lt p rt) \\<longrightarrow>\n       (markb(p := m)) n = mark n", "apply (rule impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<notin> set_of (Node lt p rt) \\<Longrightarrow>\n       (markb(p := m)) n = mark n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<notin> set_of (Node lt p rt) \\<Longrightarrow>\n       (markb(p := m)) n = mark n", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<notin> set_of (Node lt p rt) \\<Longrightarrow>\n       (markb(p := m)) n = mark n", "assume nnit: \"n \\<notin> set_of (Node lt p rt)\""], ["proof (state)\nthis:\n  n \\<notin> set_of (Node lt p rt)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<notin> set_of (Node lt p rt) \\<Longrightarrow>\n       (markb(p := m)) n = mark n", "with lt rt"], ["proof (chain)\npicking this:\n  Dag (low p) low high lt\n  Dag (high p) low high rt\n  n \\<notin> set_of (Node lt p rt)", "have nnilt: \" n \\<notin> set_of lt\""], ["proof (prove)\nusing this:\n  Dag (low p) low high lt\n  Dag (high p) low high rt\n  n \\<notin> set_of (Node lt p rt)\n\ngoal (1 subgoal):\n 1. n \\<notin> set_of lt", "by fastforce"], ["proof (state)\nthis:\n  n \\<notin> set_of lt\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<notin> set_of (Node lt p rt) \\<Longrightarrow>\n       (markb(p := m)) n = mark n", "from nnit lt rt"], ["proof (chain)\npicking this:\n  n \\<notin> set_of (Node lt p rt)\n  Dag (low p) low high lt\n  Dag (high p) low high rt", "have nnirt: \" n \\<notin> set_of rt\""], ["proof (prove)\nusing this:\n  n \\<notin> set_of (Node lt p rt)\n  Dag (low p) low high lt\n  Dag (high p) low high rt\n\ngoal (1 subgoal):\n 1. n \\<notin> set_of rt", "by fastforce"], ["proof (state)\nthis:\n  n \\<notin> set_of rt\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<notin> set_of (Node lt p rt) \\<Longrightarrow>\n       (markb(p := m)) n = mark n", "with nnilt mot_nc mort_nc"], ["proof (chain)\npicking this:\n  n \\<notin> set_of lt\n  \\<forall>n. n \\<notin> set_of lt \\<longrightarrow> mark n = marka n\n  \\<forall>n. n \\<notin> set_of rt \\<longrightarrow> marka n = markb n\n  n \\<notin> set_of rt", "have mb_eq_m: \"markb n = mark n\""], ["proof (prove)\nusing this:\n  n \\<notin> set_of lt\n  \\<forall>n. n \\<notin> set_of lt \\<longrightarrow> mark n = marka n\n  \\<forall>n. n \\<notin> set_of rt \\<longrightarrow> marka n = markb n\n  n \\<notin> set_of rt\n\ngoal (1 subgoal):\n 1. markb n = mark n", "by fastforce"], ["proof (state)\nthis:\n  markb n = mark n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<notin> set_of (Node lt p rt) \\<Longrightarrow>\n       (markb(p := m)) n = mark n", "from nnit"], ["proof (chain)\npicking this:\n  n \\<notin> set_of (Node lt p rt)", "have \"n\\<noteq>p\""], ["proof (prove)\nusing this:\n  n \\<notin> set_of (Node lt p rt)\n\ngoal (1 subgoal):\n 1. n \\<noteq> p", "by fastforce"], ["proof (state)\nthis:\n  n \\<noteq> p\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<notin> set_of (Node lt p rt) \\<Longrightarrow>\n       (markb(p := m)) n = mark n", "then"], ["proof (chain)\npicking this:\n  n \\<noteq> p", "have upmarkb_markb: \"(markb(p :=m)) n = markb n\""], ["proof (prove)\nusing this:\n  n \\<noteq> p\n\ngoal (1 subgoal):\n 1. (markb(p := m)) n = markb n", "by fastforce"], ["proof (state)\nthis:\n  (markb(p := m)) n = markb n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<notin> set_of (Node lt p rt) \\<Longrightarrow>\n       (markb(p := m)) n = mark n", "with mb_eq_m"], ["proof (chain)\npicking this:\n  markb n = mark n\n  (markb(p := m)) n = markb n", "show \"(markb(p :=m)) n = mark n\""], ["proof (prove)\nusing this:\n  markb n = mark n\n  (markb(p := m)) n = markb n\n\ngoal (1 subgoal):\n 1. (markb(p := m)) n = mark n", "by fastforce"], ["proof (state)\nthis:\n  (markb(p := m)) n = mark n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>n.\n     n \\<notin> set_of (Node lt p rt) \\<longrightarrow>\n     (markb(p := m)) n = mark n\n\ngoal (1 subgoal):\n 1. wf_levellist (Node lt p rt) ll (llb[var p := p # llb ! var p])\n     var \\<and>\n    wf_marking (Node lt p rt) mark (markb(p := m)) m", "have mark_c: \"\\<forall> n. n \\<in> set_of (Node lt p rt) \\<longrightarrow> (markb(p :=m)) n = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n.\n       n \\<in> set_of (Node lt p rt) \\<longrightarrow> (markb(p := m)) n = m", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n.\n       n \\<in> set_of (Node lt p rt) \\<longrightarrow> (markb(p := m)) n = m", "apply (intro allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<in> set_of (Node lt p rt) \\<longrightarrow> (markb(p := m)) n = m", "apply (rule impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<in> set_of (Node lt p rt) \\<Longrightarrow> (markb(p := m)) n = m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<in> set_of (Node lt p rt) \\<Longrightarrow> (markb(p := m)) n = m", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<in> set_of (Node lt p rt) \\<Longrightarrow> (markb(p := m)) n = m", "assume nint: \" n \\<in> set_of (Node lt p rt)\""], ["proof (state)\nthis:\n  n \\<in> set_of (Node lt p rt)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       n \\<in> set_of (Node lt p rt) \\<Longrightarrow> (markb(p := m)) n = m", "show \"(markb(p :=m)) n = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (markb(p := m)) n = m", "proof (cases \"n=p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n = p \\<Longrightarrow> (markb(p := m)) n = m\n 2. n \\<noteq> p \\<Longrightarrow> (markb(p := m)) n = m", "case True"], ["proof (state)\nthis:\n  n = p\n\ngoal (2 subgoals):\n 1. n = p \\<Longrightarrow> (markb(p := m)) n = m\n 2. n \\<noteq> p \\<Longrightarrow> (markb(p := m)) n = m", "then"], ["proof (chain)\npicking this:\n  n = p", "show ?thesis"], ["proof (prove)\nusing this:\n  n = p\n\ngoal (1 subgoal):\n 1. (markb(p := m)) n = m", "by fastforce"], ["proof (state)\nthis:\n  (markb(p := m)) n = m\n\ngoal (1 subgoal):\n 1. n \\<noteq> p \\<Longrightarrow> (markb(p := m)) n = m", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> p \\<Longrightarrow> (markb(p := m)) n = m", "assume nnp: \" n \\<noteq> p\""], ["proof (state)\nthis:\n  n \\<noteq> p\n\ngoal (1 subgoal):\n 1. n \\<noteq> p \\<Longrightarrow> (markb(p := m)) n = m", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (markb(p := m)) n = m", "proof (cases \"n \\<in> set_of rt\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n \\<in> set_of rt \\<Longrightarrow> (markb(p := m)) n = m\n 2. n \\<notin> set_of rt \\<Longrightarrow> (markb(p := m)) n = m", "case True"], ["proof (state)\nthis:\n  n \\<in> set_of rt\n\ngoal (2 subgoals):\n 1. n \\<in> set_of rt \\<Longrightarrow> (markb(p := m)) n = m\n 2. n \\<notin> set_of rt \\<Longrightarrow> (markb(p := m)) n = m", "with mirt_marked"], ["proof (chain)\npicking this:\n  \\<forall>n. n \\<in> set_of rt \\<longrightarrow> markb n = m\n  n \\<in> set_of rt", "have \"markb n = m\""], ["proof (prove)\nusing this:\n  \\<forall>n. n \\<in> set_of rt \\<longrightarrow> markb n = m\n  n \\<in> set_of rt\n\ngoal (1 subgoal):\n 1. markb n = m", "by fastforce"], ["proof (state)\nthis:\n  markb n = m\n\ngoal (2 subgoals):\n 1. n \\<in> set_of rt \\<Longrightarrow> (markb(p := m)) n = m\n 2. n \\<notin> set_of rt \\<Longrightarrow> (markb(p := m)) n = m", "with nnp"], ["proof (chain)\npicking this:\n  n \\<noteq> p\n  markb n = m", "show ?thesis"], ["proof (prove)\nusing this:\n  n \\<noteq> p\n  markb n = m\n\ngoal (1 subgoal):\n 1. (markb(p := m)) n = m", "by fastforce"], ["proof (state)\nthis:\n  (markb(p := m)) n = m\n\ngoal (1 subgoal):\n 1. n \\<notin> set_of rt \\<Longrightarrow> (markb(p := m)) n = m", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<notin> set_of rt \\<Longrightarrow> (markb(p := m)) n = m", "assume nninrt: \" n \\<notin> set_of rt\""], ["proof (state)\nthis:\n  n \\<notin> set_of rt\n\ngoal (1 subgoal):\n 1. n \\<notin> set_of rt \\<Longrightarrow> (markb(p := m)) n = m", "with nint nnp"], ["proof (chain)\npicking this:\n  n \\<in> set_of (Node lt p rt)\n  n \\<noteq> p\n  n \\<notin> set_of rt", "have ninlt: \"n \\<in> set_of lt\""], ["proof (prove)\nusing this:\n  n \\<in> set_of (Node lt p rt)\n  n \\<noteq> p\n  n \\<notin> set_of rt\n\ngoal (1 subgoal):\n 1. n \\<in> set_of lt", "by fastforce"], ["proof (state)\nthis:\n  n \\<in> set_of lt\n\ngoal (1 subgoal):\n 1. n \\<notin> set_of rt \\<Longrightarrow> (markb(p := m)) n = m", "with mit_marked"], ["proof (chain)\npicking this:\n  \\<forall>n. n \\<in> set_of lt \\<longrightarrow> marka n = m\n  n \\<in> set_of lt", "have marka_m: \"marka n = m\""], ["proof (prove)\nusing this:\n  \\<forall>n. n \\<in> set_of lt \\<longrightarrow> marka n = m\n  n \\<in> set_of lt\n\ngoal (1 subgoal):\n 1. marka n = m", "by fastforce"], ["proof (state)\nthis:\n  marka n = m\n\ngoal (1 subgoal):\n 1. n \\<notin> set_of rt \\<Longrightarrow> (markb(p := m)) n = m", "from mort_nc nninrt"], ["proof (chain)\npicking this:\n  \\<forall>n. n \\<notin> set_of rt \\<longrightarrow> marka n = markb n\n  n \\<notin> set_of rt", "have \"marka n = markb n\""], ["proof (prove)\nusing this:\n  \\<forall>n. n \\<notin> set_of rt \\<longrightarrow> marka n = markb n\n  n \\<notin> set_of rt\n\ngoal (1 subgoal):\n 1. marka n = markb n", "by fastforce"], ["proof (state)\nthis:\n  marka n = markb n\n\ngoal (1 subgoal):\n 1. n \\<notin> set_of rt \\<Longrightarrow> (markb(p := m)) n = m", "with marka_m"], ["proof (chain)\npicking this:\n  marka n = m\n  marka n = markb n", "have \"markb n = m\""], ["proof (prove)\nusing this:\n  marka n = m\n  marka n = markb n\n\ngoal (1 subgoal):\n 1. markb n = m", "by fastforce"], ["proof (state)\nthis:\n  markb n = m\n\ngoal (1 subgoal):\n 1. n \\<notin> set_of rt \\<Longrightarrow> (markb(p := m)) n = m", "with nnp"], ["proof (chain)\npicking this:\n  n \\<noteq> p\n  markb n = m", "show ?thesis"], ["proof (prove)\nusing this:\n  n \\<noteq> p\n  markb n = m\n\ngoal (1 subgoal):\n 1. (markb(p := m)) n = m", "by fastforce"], ["proof (state)\nthis:\n  (markb(p := m)) n = m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (markb(p := m)) n = m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (markb(p := m)) n = m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>n.\n     n \\<in> set_of (Node lt p rt) \\<longrightarrow> (markb(p := m)) n = m\n\ngoal (1 subgoal):\n 1. wf_levellist (Node lt p rt) ll (llb[var p := p # llb ! var p])\n     var \\<and>\n    wf_marking (Node lt p rt) mark (markb(p := m)) m", "from mark_c mark_nc"], ["proof (chain)\npicking this:\n  \\<forall>n.\n     n \\<in> set_of (Node lt p rt) \\<longrightarrow> (markb(p := m)) n = m\n  \\<forall>n.\n     n \\<notin> set_of (Node lt p rt) \\<longrightarrow>\n     (markb(p := m)) n = mark n", "have wf_mark: \"wf_marking (Node lt p rt) mark (markb(p :=m)) m\""], ["proof (prove)\nusing this:\n  \\<forall>n.\n     n \\<in> set_of (Node lt p rt) \\<longrightarrow> (markb(p := m)) n = m\n  \\<forall>n.\n     n \\<notin> set_of (Node lt p rt) \\<longrightarrow>\n     (markb(p := m)) n = mark n\n\ngoal (1 subgoal):\n 1. wf_marking (Node lt p rt) mark (markb(p := m)) m", "by (simp add: wf_marking_def)"], ["proof (state)\nthis:\n  wf_marking (Node lt p rt) mark (markb(p := m)) m\n\ngoal (1 subgoal):\n 1. wf_levellist (Node lt p rt) ll (llb[var p := p # llb ! var p])\n     var \\<and>\n    wf_marking (Node lt p rt) mark (markb(p := m)) m", "with wf_ll_upllb"], ["proof (chain)\npicking this:\n  wf_levellist (Node lt p rt) ll (llb[var p := p # llb ! var p]) var\n  wf_marking (Node lt p rt) mark (markb(p := m)) m", "show ?thesis"], ["proof (prove)\nusing this:\n  wf_levellist (Node lt p rt) ll (llb[var p := p # llb ! var p]) var\n  wf_marking (Node lt p rt) mark (markb(p := m)) m\n\ngoal (1 subgoal):\n 1. wf_levellist (Node lt p rt) ll (llb[var p := p # llb ! var p])\n     var \\<and>\n    wf_marking (Node lt p rt) mark (markb(p := m)) m", "by fastforce"], ["proof (state)\nthis:\n  wf_levellist (Node lt p rt) ll (llb[var p := p # llb ! var p]) var \\<and>\n  wf_marking (Node lt p rt) mark (markb(p := m)) m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wf_levellist (Node lt p rt) ll (llb[var p := p # llb ! var p]) var \\<and>\n  wf_marking (Node lt p rt) mark (markb(p := m)) m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ll'.\n     Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n      ll' \\<and>\n     wf_levellist (Node lt p rt) ll ll' var \\<and>\n     wf_marking (Node lt p rt) mark (markb(p := m)) m\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ll'.\n     Levellist (levellistb[var p := p]) (nextb(p := levellistb ! var p))\n      ll' \\<and>\n     wf_levellist (Node lt p rt) ll ll' var \\<and>\n     wf_marking (Node lt p rt) mark (markb(p := m)) m\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (high p \\<noteq> Null \\<longrightarrow>\n   var (high p) < length levellista) \\<and>\n  ordered rt var \\<and>\n  (\\<forall>n\\<in>set_of rt.\n      if marka n = m\n      then n \\<in> set (lla ! var n) \\<and>\n           (\\<forall>nt p.\n               Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n               marka p = m)\n      else n \\<notin> set (concat lla)) \\<and>\n  (\\<forall>markb nextb levellist llb.\n      Levellist levellist nextb llb \\<and>\n      wf_levellist rt lla llb var \\<and>\n      wf_marking rt marka markb m \\<and>\n      (\\<forall>p.\n          p \\<notin> set_of rt \\<longrightarrow>\n          nexta p = nextb p) \\<longrightarrow>\n      (\\<exists>ll'.\n          Levellist (levellist[var p := p]) (nextb(p := levellist ! var p))\n           ll' \\<and>\n          wf_levellist (Node lt p rt) ll ll' var \\<and>\n          wf_marking (Node lt p rt) mark (markb(p := m)) m))\n\ngoal:\nNo subgoals!", "qed"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (low p \\<noteq> Null \\<longrightarrow>\n   var (low p) < length levellist) \\<and>\n  ordered lt var \\<and>\n  (\\<forall>n\\<in>set_of lt.\n      if mark n = m\n      then n \\<in> set (ll ! var n) \\<and>\n           (\\<forall>nt p.\n               Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n               mark p = m)\n      else n \\<notin> set (concat ll)) \\<and>\n  size (dag (low p) low high) < size (dag p low high) \\<and>\n  (\\<forall>marka nexta levellist lla.\n      Levellist levellist nexta lla \\<and>\n      wf_levellist lt ll lla var \\<and>\n      wf_marking lt mark marka m \\<and>\n      (\\<forall>p.\n          p \\<notin> set_of lt \\<longrightarrow>\n          next p = nexta p) \\<longrightarrow>\n      (high p \\<noteq> Null \\<longrightarrow>\n       var (high p) < length levellist) \\<and>\n      ordered rt var \\<and>\n      (\\<exists>lla.\n          Levellist levellist nexta lla \\<and>\n          (\\<forall>n\\<in>set_of rt.\n              if marka n = m\n              then n \\<in> set (lla ! var n) \\<and>\n                   (\\<forall>nt p.\n                       Dag n low high nt \\<and>\n                       p \\<in> set_of nt \\<longrightarrow>\n                       marka p = m)\n              else n \\<notin> set (concat lla)) \\<and>\n          size (dag (high p) low high) < size (dag p low high) \\<and>\n          (\\<forall>markb nextb levellist llb.\n              Levellist levellist nextb llb \\<and>\n              wf_levellist rt lla llb var \\<and>\n              wf_marking rt marka markb m \\<and>\n              (\\<forall>p.\n                  p \\<notin> set_of rt \\<longrightarrow>\n                  nexta p = nextb p) \\<longrightarrow>\n              (\\<exists>ll'.\n                  Levellist (levellist[var p := p])\n                   (nextb(p := levellist ! var p)) ll' \\<and>\n                  wf_levellist (Node lt p rt) ll ll' var \\<and>\n                  wf_marking (Node lt p rt) mark (markb(p := m)) m \\<and>\n                  (\\<forall>pa.\n                      pa \\<notin> set_of (Node lt p rt) \\<longrightarrow>\n                      next pa =\n                      (if pa = p then levellist ! var p else nextb pa))))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (low p \\<noteq> Null \\<longrightarrow>\n   var (low p) < length levellist) \\<and>\n  ordered lt var \\<and>\n  (\\<forall>n\\<in>set_of lt.\n      if mark n = m\n      then n \\<in> set (ll ! var n) \\<and>\n           (\\<forall>nt p.\n               Dag n low high nt \\<and> p \\<in> set_of nt \\<longrightarrow>\n               mark p = m)\n      else n \\<notin> set (concat ll)) \\<and>\n  size (dag (low p) low high) < size (dag p low high) \\<and>\n  (\\<forall>marka nexta levellist lla.\n      Levellist levellist nexta lla \\<and>\n      wf_levellist lt ll lla var \\<and>\n      wf_marking lt mark marka m \\<and>\n      (\\<forall>p.\n          p \\<notin> set_of lt \\<longrightarrow>\n          next p = nexta p) \\<longrightarrow>\n      (high p \\<noteq> Null \\<longrightarrow>\n       var (high p) < length levellist) \\<and>\n      ordered rt var \\<and>\n      (\\<exists>lla.\n          Levellist levellist nexta lla \\<and>\n          (\\<forall>n\\<in>set_of rt.\n              if marka n = m\n              then n \\<in> set (lla ! var n) \\<and>\n                   (\\<forall>nt p.\n                       Dag n low high nt \\<and>\n                       p \\<in> set_of nt \\<longrightarrow>\n                       marka p = m)\n              else n \\<notin> set (concat lla)) \\<and>\n          size (dag (high p) low high) < size (dag p low high) \\<and>\n          (\\<forall>markb nextb levellist llb.\n              Levellist levellist nextb llb \\<and>\n              wf_levellist rt lla llb var \\<and>\n              wf_marking rt marka markb m \\<and>\n              (\\<forall>p.\n                  p \\<notin> set_of rt \\<longrightarrow>\n                  nexta p = nextb p) \\<longrightarrow>\n              (\\<exists>ll'.\n                  Levellist (levellist[var p := p])\n                   (nextb(p := levellist ! var p)) ll' \\<and>\n                  wf_levellist (Node lt p rt) ll ll' var \\<and>\n                  wf_marking (Node lt p rt) mark (markb(p := m)) m \\<and>\n                  (\\<forall>pa.\n                      pa \\<notin> set_of (Node lt p rt) \\<longrightarrow>\n                      next pa =\n                      (if pa = p then levellist ! var p else nextb pa))))))\n\ngoal (1 subgoal):\n 1. \\<And>ll var low high mark next p levellist lt rt.\n       \\<lbrakk>ordered (Node lt p rt) var; Levellist levellist next ll;\n        \\<forall>n\\<in>set_of (Node lt p rt).\n           if mark n = mark p\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt pa.\n                    Dag n low high nt \\<and>\n                    pa \\<in> set_of nt \\<longrightarrow>\n                    mark pa = mark p)\n           else n \\<notin> set (concat ll);\n        p \\<noteq> Null; var p < length levellist; Dag (low p) low high lt;\n        Dag (high p) low high rt\\<rbrakk>\n       \\<Longrightarrow> wf_levellist (Node lt p rt) ll ll var \\<and>\n                         wf_marking (Node lt p rt) mark mark (mark p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ll var low high mark next p levellist lt rt.\n       \\<lbrakk>ordered (Node lt p rt) var; Levellist levellist next ll;\n        \\<forall>n\\<in>set_of (Node lt p rt).\n           if mark n = mark p\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt pa.\n                    Dag n low high nt \\<and>\n                    pa \\<in> set_of nt \\<longrightarrow>\n                    mark pa = mark p)\n           else n \\<notin> set (concat ll);\n        p \\<noteq> Null; var p < length levellist; Dag (low p) low high lt;\n        Dag (high p) low high rt\\<rbrakk>\n       \\<Longrightarrow> wf_levellist (Node lt p rt) ll ll var \\<and>\n                         wf_marking (Node lt p rt) mark mark (mark p)", "fix var low high p lt rt and levellist and\n    ll::\"ref list list\" and mark::\"ref \\<Rightarrow> bool\" and \"next\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ll var low high mark next p levellist lt rt.\n       \\<lbrakk>ordered (Node lt p rt) var; Levellist levellist next ll;\n        \\<forall>n\\<in>set_of (Node lt p rt).\n           if mark n = mark p\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt pa.\n                    Dag n low high nt \\<and>\n                    pa \\<in> set_of nt \\<longrightarrow>\n                    mark pa = mark p)\n           else n \\<notin> set (concat ll);\n        p \\<noteq> Null; var p < length levellist; Dag (low p) low high lt;\n        Dag (high p) low high rt\\<rbrakk>\n       \\<Longrightarrow> wf_levellist (Node lt p rt) ll ll var \\<and>\n                         wf_marking (Node lt p rt) mark mark (mark p)", "assume pnN: \"p \\<noteq> Null\""], ["proof (state)\nthis:\n  p \\<noteq> Null\n\ngoal (1 subgoal):\n 1. \\<And>ll var low high mark next p levellist lt rt.\n       \\<lbrakk>ordered (Node lt p rt) var; Levellist levellist next ll;\n        \\<forall>n\\<in>set_of (Node lt p rt).\n           if mark n = mark p\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt pa.\n                    Dag n low high nt \\<and>\n                    pa \\<in> set_of nt \\<longrightarrow>\n                    mark pa = mark p)\n           else n \\<notin> set (concat ll);\n        p \\<noteq> Null; var p < length levellist; Dag (low p) low high lt;\n        Dag (high p) low high rt\\<rbrakk>\n       \\<Longrightarrow> wf_levellist (Node lt p rt) ll ll var \\<and>\n                         wf_marking (Node lt p rt) mark mark (mark p)", "assume ll: \"Levellist levellist next ll\""], ["proof (state)\nthis:\n  Levellist levellist next ll\n\ngoal (1 subgoal):\n 1. \\<And>ll var low high mark next p levellist lt rt.\n       \\<lbrakk>ordered (Node lt p rt) var; Levellist levellist next ll;\n        \\<forall>n\\<in>set_of (Node lt p rt).\n           if mark n = mark p\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt pa.\n                    Dag n low high nt \\<and>\n                    pa \\<in> set_of nt \\<longrightarrow>\n                    mark pa = mark p)\n           else n \\<notin> set (concat ll);\n        p \\<noteq> Null; var p < length levellist; Dag (low p) low high lt;\n        Dag (high p) low high rt\\<rbrakk>\n       \\<Longrightarrow> wf_levellist (Node lt p rt) ll ll var \\<and>\n                         wf_marking (Node lt p rt) mark mark (mark p)", "assume vpsll: \"var p < length levellist\""], ["proof (state)\nthis:\n  var p < length levellist\n\ngoal (1 subgoal):\n 1. \\<And>ll var low high mark next p levellist lt rt.\n       \\<lbrakk>ordered (Node lt p rt) var; Levellist levellist next ll;\n        \\<forall>n\\<in>set_of (Node lt p rt).\n           if mark n = mark p\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt pa.\n                    Dag n low high nt \\<and>\n                    pa \\<in> set_of nt \\<longrightarrow>\n                    mark pa = mark p)\n           else n \\<notin> set (concat ll);\n        p \\<noteq> Null; var p < length levellist; Dag (low p) low high lt;\n        Dag (high p) low high rt\\<rbrakk>\n       \\<Longrightarrow> wf_levellist (Node lt p rt) ll ll var \\<and>\n                         wf_marking (Node lt p rt) mark mark (mark p)", "assume orderedt: \"ordered (Node lt p rt) var\""], ["proof (state)\nthis:\n  ordered (Node lt p rt) var\n\ngoal (1 subgoal):\n 1. \\<And>ll var low high mark next p levellist lt rt.\n       \\<lbrakk>ordered (Node lt p rt) var; Levellist levellist next ll;\n        \\<forall>n\\<in>set_of (Node lt p rt).\n           if mark n = mark p\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt pa.\n                    Dag n low high nt \\<and>\n                    pa \\<in> set_of nt \\<longrightarrow>\n                    mark pa = mark p)\n           else n \\<notin> set (concat ll);\n        p \\<noteq> Null; var p < length levellist; Dag (low p) low high lt;\n        Dag (high p) low high rt\\<rbrakk>\n       \\<Longrightarrow> wf_levellist (Node lt p rt) ll ll var \\<and>\n                         wf_marking (Node lt p rt) mark mark (mark p)", "assume marked_child_ll: \"\\<forall>n\\<in>set_of (Node lt p rt).\n           if mark n = mark p\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt pa. Dag n low high nt \\<and> pa \\<in> set_of nt \\<longrightarrow> mark pa = mark p)\n           else n \\<notin> set (concat ll)\""], ["proof (state)\nthis:\n  \\<forall>n\\<in>set_of (Node lt p rt).\n     if mark n = mark p\n     then n \\<in> set (ll ! var n) \\<and>\n          (\\<forall>nt pa.\n              Dag n low high nt \\<and> pa \\<in> set_of nt \\<longrightarrow>\n              mark pa = mark p)\n     else n \\<notin> set (concat ll)\n\ngoal (1 subgoal):\n 1. \\<And>ll var low high mark next p levellist lt rt.\n       \\<lbrakk>ordered (Node lt p rt) var; Levellist levellist next ll;\n        \\<forall>n\\<in>set_of (Node lt p rt).\n           if mark n = mark p\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt pa.\n                    Dag n low high nt \\<and>\n                    pa \\<in> set_of nt \\<longrightarrow>\n                    mark pa = mark p)\n           else n \\<notin> set (concat ll);\n        p \\<noteq> Null; var p < length levellist; Dag (low p) low high lt;\n        Dag (high p) low high rt\\<rbrakk>\n       \\<Longrightarrow> wf_levellist (Node lt p rt) ll ll var \\<and>\n                         wf_marking (Node lt p rt) mark mark (mark p)", "assume lt: \"Dag (low p) low high lt\""], ["proof (state)\nthis:\n  Dag (low p) low high lt\n\ngoal (1 subgoal):\n 1. \\<And>ll var low high mark next p levellist lt rt.\n       \\<lbrakk>ordered (Node lt p rt) var; Levellist levellist next ll;\n        \\<forall>n\\<in>set_of (Node lt p rt).\n           if mark n = mark p\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt pa.\n                    Dag n low high nt \\<and>\n                    pa \\<in> set_of nt \\<longrightarrow>\n                    mark pa = mark p)\n           else n \\<notin> set (concat ll);\n        p \\<noteq> Null; var p < length levellist; Dag (low p) low high lt;\n        Dag (high p) low high rt\\<rbrakk>\n       \\<Longrightarrow> wf_levellist (Node lt p rt) ll ll var \\<and>\n                         wf_marking (Node lt p rt) mark mark (mark p)", "assume rt: \"Dag (high p) low high rt\""], ["proof (state)\nthis:\n  Dag (high p) low high rt\n\ngoal (1 subgoal):\n 1. \\<And>ll var low high mark next p levellist lt rt.\n       \\<lbrakk>ordered (Node lt p rt) var; Levellist levellist next ll;\n        \\<forall>n\\<in>set_of (Node lt p rt).\n           if mark n = mark p\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt pa.\n                    Dag n low high nt \\<and>\n                    pa \\<in> set_of nt \\<longrightarrow>\n                    mark pa = mark p)\n           else n \\<notin> set (concat ll);\n        p \\<noteq> Null; var p < length levellist; Dag (low p) low high lt;\n        Dag (high p) low high rt\\<rbrakk>\n       \\<Longrightarrow> wf_levellist (Node lt p rt) ll ll var \\<and>\n                         wf_marking (Node lt p rt) mark mark (mark p)", "show \"wf_levellist (Node lt p rt) ll ll var \\<and>\n        wf_marking (Node lt p rt) mark mark (mark p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_levellist (Node lt p rt) ll ll var \\<and>\n    wf_marking (Node lt p rt) mark mark (mark p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wf_levellist (Node lt p rt) ll ll var \\<and>\n    wf_marking (Node lt p rt) mark mark (mark p)", "from marked_child_ll pnN lt rt"], ["proof (chain)\npicking this:\n  \\<forall>n\\<in>set_of (Node lt p rt).\n     if mark n = mark p\n     then n \\<in> set (ll ! var n) \\<and>\n          (\\<forall>nt pa.\n              Dag n low high nt \\<and> pa \\<in> set_of nt \\<longrightarrow>\n              mark pa = mark p)\n     else n \\<notin> set (concat ll)\n  p \\<noteq> Null\n  Dag (low p) low high lt\n  Dag (high p) low high rt", "have marked_st:\n      \"(\\<forall>pa. pa \\<in> set_of (Node lt p rt) \\<longrightarrow> mark pa = mark p)\""], ["proof (prove)\nusing this:\n  \\<forall>n\\<in>set_of (Node lt p rt).\n     if mark n = mark p\n     then n \\<in> set (ll ! var n) \\<and>\n          (\\<forall>nt pa.\n              Dag n low high nt \\<and> pa \\<in> set_of nt \\<longrightarrow>\n              mark pa = mark p)\n     else n \\<notin> set (concat ll)\n  p \\<noteq> Null\n  Dag (low p) low high lt\n  Dag (high p) low high rt\n\ngoal (1 subgoal):\n 1. \\<forall>pa.\n       pa \\<in> set_of (Node lt p rt) \\<longrightarrow> mark pa = mark p", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>n\\<in>set_of (Node lt p rt).\n                if mark n = mark p\n                then n \\<in> set (ll ! var n) \\<and>\n                     (\\<forall>nt pa.\n                         Dag n low high nt \\<and>\n                         pa \\<in> set_of nt \\<longrightarrow>\n                         mark pa = mark p)\n                else n \\<notin> set (concat ll);\n     p \\<noteq> Null; Dag (low p) low high lt;\n     Dag (high p) low high rt\\<rbrakk>\n    \\<Longrightarrow> \\<forall>pa.\n                         pa \\<in> set_of (Node lt p rt) \\<longrightarrow>\n                         mark pa = mark p", "apply (drule_tac x=\"p\" in bspec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>p \\<noteq> Null; Dag (low p) low high lt;\n     Dag (high p) low high rt\\<rbrakk>\n    \\<Longrightarrow> p \\<in> set_of (Node lt p rt)\n 2. \\<lbrakk>p \\<noteq> Null; Dag (low p) low high lt;\n     Dag (high p) low high rt;\n     if mark p = mark p\n     then p \\<in> set (ll ! var p) \\<and>\n          (\\<forall>nt pa.\n              Dag p low high nt \\<and> pa \\<in> set_of nt \\<longrightarrow>\n              mark pa = mark p)\n     else p \\<notin> set (concat ll)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>pa.\n                         pa \\<in> set_of (Node lt p rt) \\<longrightarrow>\n                         mark pa = mark p", "apply  simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> Null; Dag (low p) low high lt;\n     Dag (high p) low high rt;\n     if mark p = mark p\n     then p \\<in> set (ll ! var p) \\<and>\n          (\\<forall>nt pa.\n              Dag p low high nt \\<and> pa \\<in> set_of nt \\<longrightarrow>\n              mark pa = mark p)\n     else p \\<notin> set (concat ll)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>pa.\n                         pa \\<in> set_of (Node lt p rt) \\<longrightarrow>\n                         mark pa = mark p", "apply (clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>pa.\n       \\<lbrakk>p \\<noteq> Null; Dag (low p) low high lt;\n        Dag (high p) low high rt; p \\<in> set (ll ! var p);\n        \\<forall>nt pa.\n           (\\<exists>lt rt.\n               nt = Node lt p rt \\<and>\n               Dag (low p) low high lt \\<and>\n               Dag (high p) low high rt) \\<and>\n           pa \\<in> set_of nt \\<longrightarrow>\n           mark pa = mark p\\<rbrakk>\n       \\<Longrightarrow> (pa \\<in> set_of lt \\<longrightarrow>\n                          mark pa = mark p) \\<and>\n                         (pa \\<in> set_of rt \\<longrightarrow>\n                          mark pa = mark p)", "apply (erule_tac x=\"(Node lt p rt)\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>pa.\n       \\<lbrakk>p \\<noteq> Null; Dag (low p) low high lt;\n        Dag (high p) low high rt; p \\<in> set (ll ! var p);\n        \\<forall>pa.\n           (\\<exists>lta rta.\n               Node lt p rt = Node lta p rta \\<and>\n               Dag (low p) low high lta \\<and>\n               Dag (high p) low high rta) \\<and>\n           pa \\<in> set_of (Node lt p rt) \\<longrightarrow>\n           mark pa = mark p\\<rbrakk>\n       \\<Longrightarrow> (pa \\<in> set_of lt \\<longrightarrow>\n                          mark pa = mark p) \\<and>\n                         (pa \\<in> set_of rt \\<longrightarrow>\n                          mark pa = mark p)", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>pa.\n     pa \\<in> set_of (Node lt p rt) \\<longrightarrow> mark pa = mark p\n\ngoal (1 subgoal):\n 1. wf_levellist (Node lt p rt) ll ll var \\<and>\n    wf_marking (Node lt p rt) mark mark (mark p)", "have nodest_in_ll:\n      \"\\<forall>q. q \\<in> set_of (Node lt p rt) \\<longrightarrow> q \\<in> set (ll ! var q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>q.\n       q \\<in> set_of (Node lt p rt) \\<longrightarrow>\n       q \\<in> set (ll ! var q)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>q.\n       q \\<in> set_of (Node lt p rt) \\<longrightarrow>\n       q \\<in> set (ll ! var q)", "from marked_child_ll pnN"], ["proof (chain)\npicking this:\n  \\<forall>n\\<in>set_of (Node lt p rt).\n     if mark n = mark p\n     then n \\<in> set (ll ! var n) \\<and>\n          (\\<forall>nt pa.\n              Dag n low high nt \\<and> pa \\<in> set_of nt \\<longrightarrow>\n              mark pa = mark p)\n     else n \\<notin> set (concat ll)\n  p \\<noteq> Null", "have pinll: \"p \\<in> set (ll ! var p)\""], ["proof (prove)\nusing this:\n  \\<forall>n\\<in>set_of (Node lt p rt).\n     if mark n = mark p\n     then n \\<in> set (ll ! var n) \\<and>\n          (\\<forall>nt pa.\n              Dag n low high nt \\<and> pa \\<in> set_of nt \\<longrightarrow>\n              mark pa = mark p)\n     else n \\<notin> set (concat ll)\n  p \\<noteq> Null\n\ngoal (1 subgoal):\n 1. p \\<in> set (ll ! var p)", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>n\\<in>set_of (Node lt p rt).\n                if mark n = mark p\n                then n \\<in> set (ll ! var n) \\<and>\n                     (\\<forall>nt pa.\n                         Dag n low high nt \\<and>\n                         pa \\<in> set_of nt \\<longrightarrow>\n                         mark pa = mark p)\n                else n \\<notin> set (concat ll);\n     p \\<noteq> Null\\<rbrakk>\n    \\<Longrightarrow> p \\<in> set (ll ! var p)", "apply (drule_tac x=\"p\" in bspec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. p \\<noteq> Null \\<Longrightarrow> p \\<in> set_of (Node lt p rt)\n 2. \\<lbrakk>p \\<noteq> Null;\n     if mark p = mark p\n     then p \\<in> set (ll ! var p) \\<and>\n          (\\<forall>nt pa.\n              Dag p low high nt \\<and> pa \\<in> set_of nt \\<longrightarrow>\n              mark pa = mark p)\n     else p \\<notin> set (concat ll)\\<rbrakk>\n    \\<Longrightarrow> p \\<in> set (ll ! var p)", "apply  simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p \\<noteq> Null;\n     if mark p = mark p\n     then p \\<in> set (ll ! var p) \\<and>\n          (\\<forall>nt pa.\n              Dag p low high nt \\<and> pa \\<in> set_of nt \\<longrightarrow>\n              mark pa = mark p)\n     else p \\<notin> set (concat ll)\\<rbrakk>\n    \\<Longrightarrow> p \\<in> set (ll ! var p)", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  p \\<in> set (ll ! var p)\n\ngoal (1 subgoal):\n 1. \\<forall>q.\n       q \\<in> set_of (Node lt p rt) \\<longrightarrow>\n       q \\<in> set (ll ! var q)", "from marked_st marked_child_ll lt rt"], ["proof (chain)\npicking this:\n  \\<forall>pa.\n     pa \\<in> set_of (Node lt p rt) \\<longrightarrow> mark pa = mark p\n  \\<forall>n\\<in>set_of (Node lt p rt).\n     if mark n = mark p\n     then n \\<in> set (ll ! var n) \\<and>\n          (\\<forall>nt pa.\n              Dag n low high nt \\<and> pa \\<in> set_of nt \\<longrightarrow>\n              mark pa = mark p)\n     else n \\<notin> set (concat ll)\n  Dag (low p) low high lt\n  Dag (high p) low high rt", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>pa.\n     pa \\<in> set_of (Node lt p rt) \\<longrightarrow> mark pa = mark p\n  \\<forall>n\\<in>set_of (Node lt p rt).\n     if mark n = mark p\n     then n \\<in> set (ll ! var n) \\<and>\n          (\\<forall>nt pa.\n              Dag n low high nt \\<and> pa \\<in> set_of nt \\<longrightarrow>\n              mark pa = mark p)\n     else n \\<notin> set (concat ll)\n  Dag (low p) low high lt\n  Dag (high p) low high rt\n\ngoal (1 subgoal):\n 1. \\<forall>q.\n       q \\<in> set_of (Node lt p rt) \\<longrightarrow>\n       q \\<in> set (ll ! var q)", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>pa.\n                pa \\<in> set_of (Node lt p rt) \\<longrightarrow>\n                mark pa = mark p;\n     \\<forall>n\\<in>set_of (Node lt p rt).\n        if mark n = mark p\n        then n \\<in> set (ll ! var n) \\<and>\n             (\\<forall>nt pa.\n                 Dag n low high nt \\<and>\n                 pa \\<in> set_of nt \\<longrightarrow>\n                 mark pa = mark p)\n        else n \\<notin> set (concat ll);\n     Dag (low p) low high lt; Dag (high p) low high rt\\<rbrakk>\n    \\<Longrightarrow> \\<forall>q.\n                         q \\<in> set_of (Node lt p rt) \\<longrightarrow>\n                         q \\<in> set (ll ! var q)", "apply (rule allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>\\<forall>pa.\n                   pa \\<in> set_of (Node lt p rt) \\<longrightarrow>\n                   mark pa = mark p;\n        \\<forall>n\\<in>set_of (Node lt p rt).\n           if mark n = mark p\n           then n \\<in> set (ll ! var n) \\<and>\n                (\\<forall>nt pa.\n                    Dag n low high nt \\<and>\n                    pa \\<in> set_of nt \\<longrightarrow>\n                    mark pa = mark p)\n           else n \\<notin> set (concat ll);\n        Dag (low p) low high lt; Dag (high p) low high rt\\<rbrakk>\n       \\<Longrightarrow> q \\<in> set_of (Node lt p rt) \\<longrightarrow>\n                         q \\<in> set (ll ! var q)", "apply (erule_tac x=\"q\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>\\<forall>n\\<in>set_of (Node lt p rt).\n                   if mark n = mark p\n                   then n \\<in> set (ll ! var n) \\<and>\n                        (\\<forall>nt pa.\n                            Dag n low high nt \\<and>\n                            pa \\<in> set_of nt \\<longrightarrow>\n                            mark pa = mark p)\n                   else n \\<notin> set (concat ll);\n        Dag (low p) low high lt; Dag (high p) low high rt;\n        q \\<in> set_of (Node lt p rt) \\<longrightarrow>\n        mark q = mark p\\<rbrakk>\n       \\<Longrightarrow> q \\<in> set_of (Node lt p rt) \\<longrightarrow>\n                         q \\<in> set (ll ! var q)", "apply (rule impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>\\<forall>n\\<in>set_of (Node lt p rt).\n                   if mark n = mark p\n                   then n \\<in> set (ll ! var n) \\<and>\n                        (\\<forall>nt pa.\n                            Dag n low high nt \\<and>\n                            pa \\<in> set_of nt \\<longrightarrow>\n                            mark pa = mark p)\n                   else n \\<notin> set (concat ll);\n        Dag (low p) low high lt; Dag (high p) low high rt;\n        q \\<in> set_of (Node lt p rt) \\<longrightarrow> mark q = mark p;\n        q \\<in> set_of (Node lt p rt)\\<rbrakk>\n       \\<Longrightarrow> q \\<in> set (ll ! var q)", "apply (erule impE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>\\<forall>n\\<in>set_of (Node lt p rt).\n                   if mark n = mark p\n                   then n \\<in> set (ll ! var n) \\<and>\n                        (\\<forall>nt pa.\n                            Dag n low high nt \\<and>\n                            pa \\<in> set_of nt \\<longrightarrow>\n                            mark pa = mark p)\n                   else n \\<notin> set (concat ll);\n        Dag (low p) low high lt; Dag (high p) low high rt;\n        q \\<in> set_of (Node lt p rt)\\<rbrakk>\n       \\<Longrightarrow> q \\<in> set_of (Node lt p rt)\n 2. \\<And>q.\n       \\<lbrakk>\\<forall>n\\<in>set_of (Node lt p rt).\n                   if mark n = mark p\n                   then n \\<in> set (ll ! var n) \\<and>\n                        (\\<forall>nt pa.\n                            Dag n low high nt \\<and>\n                            pa \\<in> set_of nt \\<longrightarrow>\n                            mark pa = mark p)\n                   else n \\<notin> set (concat ll);\n        Dag (low p) low high lt; Dag (high p) low high rt;\n        q \\<in> set_of (Node lt p rt); mark q = mark p\\<rbrakk>\n       \\<Longrightarrow> q \\<in> set (ll ! var q)", "apply  assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>\\<forall>n\\<in>set_of (Node lt p rt).\n                   if mark n = mark p\n                   then n \\<in> set (ll ! var n) \\<and>\n                        (\\<forall>nt pa.\n                            Dag n low high nt \\<and>\n                            pa \\<in> set_of nt \\<longrightarrow>\n                            mark pa = mark p)\n                   else n \\<notin> set (concat ll);\n        Dag (low p) low high lt; Dag (high p) low high rt;\n        q \\<in> set_of (Node lt p rt); mark q = mark p\\<rbrakk>\n       \\<Longrightarrow> q \\<in> set (ll ! var q)", "apply (drule_tac x=\"q\" in bspec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>q.\n       \\<lbrakk>Dag (low p) low high lt; Dag (high p) low high rt;\n        q \\<in> set_of (Node lt p rt); mark q = mark p\\<rbrakk>\n       \\<Longrightarrow> q \\<in> set_of (Node lt p rt)\n 2. \\<And>q.\n       \\<lbrakk>Dag (low p) low high lt; Dag (high p) low high rt;\n        q \\<in> set_of (Node lt p rt); mark q = mark p;\n        if mark q = mark p\n        then q \\<in> set (ll ! var q) \\<and>\n             (\\<forall>nt pa.\n                 Dag q low high nt \\<and>\n                 pa \\<in> set_of nt \\<longrightarrow>\n                 mark pa = mark p)\n        else q \\<notin> set (concat ll)\\<rbrakk>\n       \\<Longrightarrow> q \\<in> set (ll ! var q)", "apply  simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q.\n       \\<lbrakk>Dag (low p) low high lt; Dag (high p) low high rt;\n        q \\<in> set_of (Node lt p rt); mark q = mark p;\n        if mark q = mark p\n        then q \\<in> set (ll ! var q) \\<and>\n             (\\<forall>nt pa.\n                 Dag q low high nt \\<and>\n                 pa \\<in> set_of nt \\<longrightarrow>\n                 mark pa = mark p)\n        else q \\<notin> set (concat ll)\\<rbrakk>\n       \\<Longrightarrow> q \\<in> set (ll ! var q)", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>q.\n     q \\<in> set_of (Node lt p rt) \\<longrightarrow>\n     q \\<in> set (ll ! var q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>q.\n     q \\<in> set_of (Node lt p rt) \\<longrightarrow>\n     q \\<in> set (ll ! var q)\n\ngoal (1 subgoal):\n 1. wf_levellist (Node lt p rt) ll ll var \\<and>\n    wf_marking (Node lt p rt) mark mark (mark p)", "have levellist_nc: \"\\<forall> i \\<le> var p. (\\<exists> prx. ll ! i = prx@(ll ! i) \\<and>\n      (\\<forall> pt \\<in> set prx. pt \\<in> set_of (Node lt p rt) \\<and> var pt = i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<le>var p.\n       \\<exists>prx.\n          ll ! i = prx @ ll ! i \\<and>\n          (\\<forall>pt\\<in>set prx.\n              pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<le>var p.\n       \\<exists>prx.\n          ll ! i = prx @ ll ! i \\<and>\n          (\\<forall>pt\\<in>set prx.\n              pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)", "apply (rule allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<le> var p \\<longrightarrow>\n       (\\<exists>prx.\n           ll ! i = prx @ ll ! i \\<and>\n           (\\<forall>pt\\<in>set prx.\n               pt \\<in> set_of (Node lt p rt) \\<and> var pt = i))", "apply (rule impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<le> var p \\<Longrightarrow>\n       \\<exists>prx.\n          ll ! i = prx @ ll ! i \\<and>\n          (\\<forall>pt\\<in>set prx.\n              pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)", "apply (rule_tac x=\"[]\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<le> var p \\<Longrightarrow>\n       ll ! i = [] @ ll ! i \\<and>\n       (\\<forall>pt\\<in>set [].\n           pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>i\\<le>var p.\n     \\<exists>prx.\n        ll ! i = prx @ ll ! i \\<and>\n        (\\<forall>pt\\<in>set prx.\n            pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)\n\ngoal (1 subgoal):\n 1. wf_levellist (Node lt p rt) ll ll var \\<and>\n    wf_marking (Node lt p rt) mark mark (mark p)", "have ll_nc: \"\\<forall> i. (var p) < i \\<longrightarrow> ll ! i = ll ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i>var p. ll ! i = ll ! i", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>i>var p. ll ! i = ll ! i\n\ngoal (1 subgoal):\n 1. wf_levellist (Node lt p rt) ll ll var \\<and>\n    wf_marking (Node lt p rt) mark mark (mark p)", "have length_ll: \"length ll = length ll\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length ll = length ll", "by fastforce"], ["proof (state)\nthis:\n  length ll = length ll\n\ngoal (1 subgoal):\n 1. wf_levellist (Node lt p rt) ll ll var \\<and>\n    wf_marking (Node lt p rt) mark mark (mark p)", "with ll_nc levellist_nc nodest_in_ll"], ["proof (chain)\npicking this:\n  \\<forall>i>var p. ll ! i = ll ! i\n  \\<forall>i\\<le>var p.\n     \\<exists>prx.\n        ll ! i = prx @ ll ! i \\<and>\n        (\\<forall>pt\\<in>set prx.\n            pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)\n  \\<forall>q.\n     q \\<in> set_of (Node lt p rt) \\<longrightarrow>\n     q \\<in> set (ll ! var q)\n  length ll = length ll", "have wf: \"wf_levellist (Node lt p rt) ll ll var\""], ["proof (prove)\nusing this:\n  \\<forall>i>var p. ll ! i = ll ! i\n  \\<forall>i\\<le>var p.\n     \\<exists>prx.\n        ll ! i = prx @ ll ! i \\<and>\n        (\\<forall>pt\\<in>set prx.\n            pt \\<in> set_of (Node lt p rt) \\<and> var pt = i)\n  \\<forall>q.\n     q \\<in> set_of (Node lt p rt) \\<longrightarrow>\n     q \\<in> set (ll ! var q)\n  length ll = length ll\n\ngoal (1 subgoal):\n 1. wf_levellist (Node lt p rt) ll ll var", "by (simp add: wf_levellist_def)"], ["proof (state)\nthis:\n  wf_levellist (Node lt p rt) ll ll var\n\ngoal (1 subgoal):\n 1. wf_levellist (Node lt p rt) ll ll var \\<and>\n    wf_marking (Node lt p rt) mark mark (mark p)", "have m_nc: \"\\<forall> n. n \\<notin> set_of (Node lt p rt) \\<longrightarrow> mark n = mark n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n.\n       n \\<notin> set_of (Node lt p rt) \\<longrightarrow> mark n = mark n", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>n.\n     n \\<notin> set_of (Node lt p rt) \\<longrightarrow> mark n = mark n\n\ngoal (1 subgoal):\n 1. wf_levellist (Node lt p rt) ll ll var \\<and>\n    wf_marking (Node lt p rt) mark mark (mark p)", "from marked_st"], ["proof (chain)\npicking this:\n  \\<forall>pa.\n     pa \\<in> set_of (Node lt p rt) \\<longrightarrow> mark pa = mark p", "have \"\\<forall> n. n \\<in> set_of (Node lt p rt) \\<longrightarrow> mark n = mark p\""], ["proof (prove)\nusing this:\n  \\<forall>pa.\n     pa \\<in> set_of (Node lt p rt) \\<longrightarrow> mark pa = mark p\n\ngoal (1 subgoal):\n 1. \\<forall>n.\n       n \\<in> set_of (Node lt p rt) \\<longrightarrow> mark n = mark p", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>n.\n     n \\<in> set_of (Node lt p rt) \\<longrightarrow> mark n = mark p\n\ngoal (1 subgoal):\n 1. wf_levellist (Node lt p rt) ll ll var \\<and>\n    wf_marking (Node lt p rt) mark mark (mark p)", "with m_nc"], ["proof (chain)\npicking this:\n  \\<forall>n.\n     n \\<notin> set_of (Node lt p rt) \\<longrightarrow> mark n = mark n\n  \\<forall>n.\n     n \\<in> set_of (Node lt p rt) \\<longrightarrow> mark n = mark p", "have \" wf_marking (Node lt p rt) mark mark (mark p)\""], ["proof (prove)\nusing this:\n  \\<forall>n.\n     n \\<notin> set_of (Node lt p rt) \\<longrightarrow> mark n = mark n\n  \\<forall>n.\n     n \\<in> set_of (Node lt p rt) \\<longrightarrow> mark n = mark p\n\ngoal (1 subgoal):\n 1. wf_marking (Node lt p rt) mark mark (mark p)", "by (simp add: wf_marking_def)"], ["proof (state)\nthis:\n  wf_marking (Node lt p rt) mark mark (mark p)\n\ngoal (1 subgoal):\n 1. wf_levellist (Node lt p rt) ll ll var \\<and>\n    wf_marking (Node lt p rt) mark mark (mark p)", "with wf"], ["proof (chain)\npicking this:\n  wf_levellist (Node lt p rt) ll ll var\n  wf_marking (Node lt p rt) mark mark (mark p)", "show ?thesis"], ["proof (prove)\nusing this:\n  wf_levellist (Node lt p rt) ll ll var\n  wf_marking (Node lt p rt) mark mark (mark p)\n\ngoal (1 subgoal):\n 1. wf_levellist (Node lt p rt) ll ll var \\<and>\n    wf_marking (Node lt p rt) mark mark (mark p)", "by fastforce"], ["proof (state)\nthis:\n  wf_levellist (Node lt p rt) ll ll var \\<and>\n  wf_marking (Node lt p rt) mark mark (mark p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wf_levellist (Node lt p rt) ll ll var \\<and>\n  wf_marking (Node lt p rt) mark mark (mark p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma allD: \"\\<forall>ll. P ll \\<Longrightarrow> P ll\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ll. P ll \\<Longrightarrow> P ll", "by blast"], ["", "lemma replicate_spec: \"\\<lbrakk>\\<forall>i < n. xs ! i = x; n=length xs\\<rbrakk>\n  \\<Longrightarrow> replicate (length xs) x = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i<n. xs ! i = x; n = length xs\\<rbrakk>\n    \\<Longrightarrow> replicate (length xs) x = xs", "apply hypsubst_thin"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length xs. xs ! i = x \\<Longrightarrow>\n    replicate (length xs) x = xs", "apply (induct xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>i<length []. [] ! i = x \\<Longrightarrow>\n    replicate (length []) x = []\n 2. \\<And>a xs.\n       \\<lbrakk>\\<forall>i<length xs. xs ! i = x \\<Longrightarrow>\n                replicate (length xs) x = xs;\n        \\<forall>i<length (a # xs). (a # xs) ! i = x\\<rbrakk>\n       \\<Longrightarrow> replicate (length (a # xs)) x = a # xs", "apply  simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<forall>i<length xs. xs ! i = x \\<Longrightarrow>\n                replicate (length xs) x = xs;\n        \\<forall>i<length (a # xs). (a # xs) ! i = x\\<rbrakk>\n       \\<Longrightarrow> replicate (length (a # xs)) x = a # xs", "apply force"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma (in Levellist_impl) Levellist_spec_total:\nshows \"\\<forall>\\<sigma> t. \\<Gamma>,\\<Theta>\\<turnstile>\\<^sub>t\n        \\<lbrace>\\<sigma>. Dag \\<acute>p \\<acute>low \\<acute>high t \\<and> (\\<forall>i < length \\<acute>levellist. \\<acute>levellist ! i = Null) \\<and>\n             length \\<acute>levellist  = \\<acute>p \\<rightarrow> \\<acute>var + 1 \\<and>\n             ordered t \\<acute>var \\<and> (\\<forall>n \\<in> set_of t. \\<acute>mark n = (\\<not> \\<acute>m) )\\<rbrace>\n          \\<acute>levellist :== PROC Levellist (\\<acute>p, \\<acute>m, \\<acute>levellist)\n       \\<lbrace>\\<exists>ll. Levellist \\<acute>levellist \\<acute>next ll \\<and> wf_ll t ll \\<^bsup>\\<sigma>\\<^esup>var  \\<and>\n         length \\<acute>levellist = \\<^bsup>\\<sigma>\\<^esup>p \\<rightarrow> \\<^bsup>\\<sigma>\\<^esup>var + 1 \\<and>\n         wf_marking t \\<^bsup>\\<sigma>\\<^esup>mark \\<acute>mark \\<^bsup>\\<sigma>\\<^esup>m \\<and>\n         (\\<forall>p. p \\<notin> set_of t \\<longrightarrow> \\<^bsup>\\<sigma>\\<^esup>next p = \\<acute>next p)\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma> t.\n       \\<Gamma>,\\<Theta>\n          \\<turnstile>\\<^sub>t \\<lbrace>\\<sigma>. Dag \\<acute>p \\<acute>low\n             \\<acute>high t \\<and>\n            (\\<forall>i<length \\<acute>levellist.\n                \\<acute>levellist ! i = Null) \\<and>\n            length \\<acute>levellist =\n            \\<acute>p\\<rightarrow>\\<acute>var + 1 \\<and>\n            ordered t \\<acute>var \\<and>\n            (\\<forall>n\\<in>set_of t.\n                n\\<rightarrow>\\<acute>mark = (\\<not> \\<acute>m))\\<rbrace>\n                               \\<acute>levellist :== PROC Levellist(\\<acute>p,\n                               \\<acute>m,\\<acute>levellist)\n                               \\<lbrace>\\<exists>ll.\n     Levellist \\<acute>levellist \\<acute>next ll \\<and>\n     wf_ll t ll \\<^bsup>\\<sigma>\\<^esup>var \\<and>\n     length \\<acute>levellist =\n     \\<^bsup>\\<sigma>\\<^esup>var \\<^bsup>\\<sigma>\\<^esup>p + 1 \\<and>\n     wf_marking t \\<^bsup>\\<sigma>\\<^esup>mark \\<acute>mark\n      \\<^bsup>\\<sigma>\\<^esup>m \\<and>\n     (\\<forall>p.\n         p \\<notin> set_of t \\<longrightarrow>\n         \\<^bsup>\\<sigma>\\<^esup>next p =\n         p\\<rightarrow>\\<acute>next)\\<rbrace>", "apply (hoare_rule HoareTotal.conseq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma> t.\n       \\<forall>\\<sigma>' ta.\n          \\<Gamma>,\\<Theta>\n             \\<turnstile>\\<^sub>t (?P'2 \\<sigma> t \\<sigma>' ta)\n                                  \\<acute>levellist :== PROC Levellist(\\<acute>p,\n                                  \\<acute>m,\\<acute>levellist)\n                                  (?Q'2 \\<sigma> t \\<sigma>' ta),\n                                  (?A'2 \\<sigma> t \\<sigma>' ta)\n 2. \\<And>\\<sigma> t.\n       \\<forall>s.\n          s \\<in> \\<lbrace>\\<sigma>. Dag \\<acute>p \\<acute>low \\<acute>high\nt \\<and>\n                                     (\\<forall>i<length \\<acute>levellist.\n   \\<acute>levellist ! i = Null) \\<and>\n                                     length \\<acute>levellist =\n                                     \\<acute>p\\<rightarrow>\\<acute>var +\n                                     1 \\<and>\n                                     ordered t \\<acute>var \\<and>\n                                     (\\<forall>n\\<in>set_of t.\n   n\\<rightarrow>\\<acute>mark =\n   (\\<not> \\<acute>m))\\<rbrace> \\<longrightarrow>\n          (\\<exists>\\<sigma>' ta.\n              s \\<in> ?P'2 \\<sigma> t \\<sigma>' ta \\<and>\n              ?Q'2 \\<sigma> t \\<sigma>' ta\n              \\<subseteq> \\<lbrace>\\<exists>ll.\nLevellist \\<acute>levellist \\<acute>next ll \\<and>\nwf_ll t ll \\<^bsup>\\<sigma>\\<^esup>var \\<and>\nlength \\<acute>levellist =\n\\<^bsup>\\<sigma>\\<^esup>var \\<^bsup>\\<sigma>\\<^esup>p + 1 \\<and>\nwf_marking t \\<^bsup>\\<sigma>\\<^esup>mark \\<acute>mark\n \\<^bsup>\\<sigma>\\<^esup>m \\<and>\n(\\<forall>p.\n    p \\<notin> set_of t \\<longrightarrow>\n    \\<^bsup>\\<sigma>\\<^esup>next p =\n    p\\<rightarrow>\\<acute>next)\\<rbrace> \\<and>\n              ?A'2 \\<sigma> t \\<sigma>' ta \\<subseteq> {})", "apply  (rule_tac ll=\"replicate (\\<^bsup>\\<sigma>\\<^esup>p\\<rightarrow>\\<^bsup>\\<sigma>\\<^esup>var + 1) []\" in allD [OF Levellist_spec_total'])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> t.\n       \\<forall>s.\n          s \\<in> \\<lbrace>\\<sigma>. Dag \\<acute>p \\<acute>low \\<acute>high\nt \\<and>\n                                     (\\<forall>i<length \\<acute>levellist.\n   \\<acute>levellist ! i = Null) \\<and>\n                                     length \\<acute>levellist =\n                                     \\<acute>p\\<rightarrow>\\<acute>var +\n                                     1 \\<and>\n                                     ordered t \\<acute>var \\<and>\n                                     (\\<forall>n\\<in>set_of t.\n   n\\<rightarrow>\\<acute>mark =\n   (\\<not> \\<acute>m))\\<rbrace> \\<longrightarrow>\n          (\\<exists>\\<sigma>' ta.\n              s \\<in> \\<lbrace>\\<sigma>'. Dag \\<acute>p \\<acute>low\n     \\<acute>high ta \\<and>\n    (\\<acute>p \\<noteq> Null \\<longrightarrow>\n     \\<acute>p\\<rightarrow>\\<acute>var < length \\<acute>levellist) \\<and>\n    ordered ta \\<acute>var \\<and>\n    Levellist \\<acute>levellist \\<acute>next\n     (replicate (\\<^bsup>\\<sigma>\\<^esup>var \\<^bsup>\\<sigma>\\<^esup>p + 1)\n       []) \\<and>\n    (\\<forall>n\\<in>set_of ta.\n        if n\\<rightarrow>\\<acute>mark = \\<acute>m\n        then n \\<in> set (replicate\n                           (\\<^bsup>\\<sigma>\\<^esup>var\n                             \\<^bsup>\\<sigma>\\<^esup>p +\n                            1)\n                           [] !\n                          (n\\<rightarrow>\\<acute>var)) \\<and>\n             (\\<forall>nt p.\n                 Dag n \\<acute>low \\<acute>high nt \\<and>\n                 p \\<in> set_of nt \\<longrightarrow>\n                 p\\<rightarrow>\\<acute>mark = \\<acute>m)\n        else n \\<notin> set (concat\n                              (replicate\n                                (\\<^bsup>\\<sigma>\\<^esup>var\n                                  \\<^bsup>\\<sigma>\\<^esup>p +\n                                 1)\n                                [])))\\<rbrace> \\<and>\n              \\<lbrace>\\<exists>ll'.\n                          Levellist \\<acute>levellist \\<acute>next\n                           ll' \\<and>\n                          wf_levellist ta\n                           (replicate\n                             (\\<^bsup>\\<sigma>\\<^esup>var\n                               \\<^bsup>\\<sigma>\\<^esup>p +\n                              1)\n                             [])\n                           ll' \\<^bsup>\\<sigma>'\\<^esup>var \\<and>\n                          wf_marking ta \\<^bsup>\\<sigma>'\\<^esup>mark\n                           \\<acute>mark \\<^bsup>\\<sigma>'\\<^esup>m \\<and>\n                          (\\<forall>p.\n                              p \\<notin> set_of ta \\<longrightarrow>\n                              \\<^bsup>\\<sigma>'\\<^esup>next p =\n                              p\\<rightarrow>\\<acute>next)\\<rbrace>\n              \\<subseteq> \\<lbrace>\\<exists>ll.\nLevellist \\<acute>levellist \\<acute>next ll \\<and>\nwf_ll t ll \\<^bsup>\\<sigma>\\<^esup>var \\<and>\nlength \\<acute>levellist =\n\\<^bsup>\\<sigma>\\<^esup>var \\<^bsup>\\<sigma>\\<^esup>p + 1 \\<and>\nwf_marking t \\<^bsup>\\<sigma>\\<^esup>mark \\<acute>mark\n \\<^bsup>\\<sigma>\\<^esup>m \\<and>\n(\\<forall>p.\n    p \\<notin> set_of t \\<longrightarrow>\n    \\<^bsup>\\<sigma>\\<^esup>next p =\n    p\\<rightarrow>\\<acute>next)\\<rbrace> \\<and>\n              {} \\<subseteq> {})", "apply (intro allI impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> t s.\n       s \\<in> \\<lbrace>\\<sigma>. Dag \\<acute>p \\<acute>low \\<acute>high\n                                   t \\<and>\n                                  (\\<forall>i<length \\<acute>levellist.\n\\<acute>levellist ! i = Null) \\<and>\n                                  length \\<acute>levellist =\n                                  \\<acute>p\\<rightarrow>\\<acute>var +\n                                  1 \\<and>\n                                  ordered t \\<acute>var \\<and>\n                                  (\\<forall>n\\<in>set_of t.\nn\\<rightarrow>\\<acute>mark = (\\<not> \\<acute>m))\\<rbrace> \\<Longrightarrow>\n       \\<exists>\\<sigma>' ta.\n          s \\<in> \\<lbrace>\\<sigma>'. Dag \\<acute>p \\<acute>low \\<acute>high\n ta \\<and>\n(\\<acute>p \\<noteq> Null \\<longrightarrow>\n \\<acute>p\\<rightarrow>\\<acute>var < length \\<acute>levellist) \\<and>\nordered ta \\<acute>var \\<and>\nLevellist \\<acute>levellist \\<acute>next\n (replicate (\\<^bsup>\\<sigma>\\<^esup>var \\<^bsup>\\<sigma>\\<^esup>p + 1)\n   []) \\<and>\n(\\<forall>n\\<in>set_of ta.\n    if n\\<rightarrow>\\<acute>mark = \\<acute>m\n    then n \\<in> set (replicate\n                       (\\<^bsup>\\<sigma>\\<^esup>var\n                         \\<^bsup>\\<sigma>\\<^esup>p +\n                        1)\n                       [] !\n                      (n\\<rightarrow>\\<acute>var)) \\<and>\n         (\\<forall>nt p.\n             Dag n \\<acute>low \\<acute>high nt \\<and>\n             p \\<in> set_of nt \\<longrightarrow>\n             p\\<rightarrow>\\<acute>mark = \\<acute>m)\n    else n \\<notin> set (concat\n                          (replicate\n                            (\\<^bsup>\\<sigma>\\<^esup>var\n                              \\<^bsup>\\<sigma>\\<^esup>p +\n                             1)\n                            [])))\\<rbrace> \\<and>\n          \\<lbrace>\\<exists>ll'.\n                      Levellist \\<acute>levellist \\<acute>next ll' \\<and>\n                      wf_levellist ta\n                       (replicate\n                         (\\<^bsup>\\<sigma>\\<^esup>var\n                           \\<^bsup>\\<sigma>\\<^esup>p +\n                          1)\n                         [])\n                       ll' \\<^bsup>\\<sigma>'\\<^esup>var \\<and>\n                      wf_marking ta \\<^bsup>\\<sigma>'\\<^esup>mark\n                       \\<acute>mark \\<^bsup>\\<sigma>'\\<^esup>m \\<and>\n                      (\\<forall>p.\n                          p \\<notin> set_of ta \\<longrightarrow>\n                          \\<^bsup>\\<sigma>'\\<^esup>next p =\n                          p\\<rightarrow>\\<acute>next)\\<rbrace>\n          \\<subseteq> \\<lbrace>\\<exists>ll.\n                                  Levellist \\<acute>levellist \\<acute>next\n                                   ll \\<and>\n                                  wf_ll t ll\n                                   \\<^bsup>\\<sigma>\\<^esup>var \\<and>\n                                  length \\<acute>levellist =\n                                  \\<^bsup>\\<sigma>\\<^esup>var\n                                   \\<^bsup>\\<sigma>\\<^esup>p +\n                                  1 \\<and>\n                                  wf_marking t \\<^bsup>\\<sigma>\\<^esup>mark\n                                   \\<acute>mark\n                                   \\<^bsup>\\<sigma>\\<^esup>m \\<and>\n                                  (\\<forall>p.\np \\<notin> set_of t \\<longrightarrow>\n\\<^bsup>\\<sigma>\\<^esup>next p = p\\<rightarrow>\\<acute>next)\\<rbrace> \\<and>\n          {} \\<subseteq> {}", "apply (rule_tac x=\\<sigma> in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> t s.\n       s \\<in> \\<lbrace>\\<sigma>. Dag \\<acute>p \\<acute>low \\<acute>high\n                                   t \\<and>\n                                  (\\<forall>i<length \\<acute>levellist.\n\\<acute>levellist ! i = Null) \\<and>\n                                  length \\<acute>levellist =\n                                  \\<acute>p\\<rightarrow>\\<acute>var +\n                                  1 \\<and>\n                                  ordered t \\<acute>var \\<and>\n                                  (\\<forall>n\\<in>set_of t.\nn\\<rightarrow>\\<acute>mark = (\\<not> \\<acute>m))\\<rbrace> \\<Longrightarrow>\n       \\<exists>ta.\n          s \\<in> \\<lbrace>\\<sigma>. Dag \\<acute>p \\<acute>low \\<acute>high\nta \\<and>\n                                     (\\<acute>p \\<noteq>\nNull \\<longrightarrow>\n\\<acute>p\\<rightarrow>\\<acute>var < length \\<acute>levellist) \\<and>\n                                     ordered ta \\<acute>var \\<and>\n                                     Levellist \\<acute>levellist\n\\<acute>next\n(replicate (\\<^bsup>\\<sigma>\\<^esup>var \\<^bsup>\\<sigma>\\<^esup>p + 1)\n  []) \\<and>\n                                     (\\<forall>n\\<in>set_of ta.\n   if n\\<rightarrow>\\<acute>mark = \\<acute>m\n   then n \\<in> set (replicate\n                      (\\<^bsup>\\<sigma>\\<^esup>var\n                        \\<^bsup>\\<sigma>\\<^esup>p +\n                       1)\n                      [] !\n                     (n\\<rightarrow>\\<acute>var)) \\<and>\n        (\\<forall>nt p.\n            Dag n \\<acute>low \\<acute>high nt \\<and>\n            p \\<in> set_of nt \\<longrightarrow>\n            p\\<rightarrow>\\<acute>mark = \\<acute>m)\n   else n \\<notin> set (concat\n                         (replicate\n                           (\\<^bsup>\\<sigma>\\<^esup>var\n                             \\<^bsup>\\<sigma>\\<^esup>p +\n                            1)\n                           [])))\\<rbrace> \\<and>\n          \\<lbrace>\\<exists>ll'.\n                      Levellist \\<acute>levellist \\<acute>next ll' \\<and>\n                      wf_levellist ta\n                       (replicate\n                         (\\<^bsup>\\<sigma>\\<^esup>var\n                           \\<^bsup>\\<sigma>\\<^esup>p +\n                          1)\n                         [])\n                       ll' \\<^bsup>\\<sigma>\\<^esup>var \\<and>\n                      wf_marking ta \\<^bsup>\\<sigma>\\<^esup>mark\n                       \\<acute>mark \\<^bsup>\\<sigma>\\<^esup>m \\<and>\n                      (\\<forall>p.\n                          p \\<notin> set_of ta \\<longrightarrow>\n                          \\<^bsup>\\<sigma>\\<^esup>next p =\n                          p\\<rightarrow>\\<acute>next)\\<rbrace>\n          \\<subseteq> \\<lbrace>\\<exists>ll.\n                                  Levellist \\<acute>levellist \\<acute>next\n                                   ll \\<and>\n                                  wf_ll t ll\n                                   \\<^bsup>\\<sigma>\\<^esup>var \\<and>\n                                  length \\<acute>levellist =\n                                  \\<^bsup>\\<sigma>\\<^esup>var\n                                   \\<^bsup>\\<sigma>\\<^esup>p +\n                                  1 \\<and>\n                                  wf_marking t \\<^bsup>\\<sigma>\\<^esup>mark\n                                   \\<acute>mark\n                                   \\<^bsup>\\<sigma>\\<^esup>m \\<and>\n                                  (\\<forall>p.\np \\<notin> set_of t \\<longrightarrow>\n\\<^bsup>\\<sigma>\\<^esup>next p = p\\<rightarrow>\\<acute>next)\\<rbrace> \\<and>\n          {} \\<subseteq> {}", "apply (rule_tac x=t in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> t s.\n       s \\<in> \\<lbrace>\\<sigma>. Dag \\<acute>p \\<acute>low \\<acute>high\n                                   t \\<and>\n                                  (\\<forall>i<length \\<acute>levellist.\n\\<acute>levellist ! i = Null) \\<and>\n                                  length \\<acute>levellist =\n                                  \\<acute>p\\<rightarrow>\\<acute>var +\n                                  1 \\<and>\n                                  ordered t \\<acute>var \\<and>\n                                  (\\<forall>n\\<in>set_of t.\nn\\<rightarrow>\\<acute>mark = (\\<not> \\<acute>m))\\<rbrace> \\<Longrightarrow>\n       s \\<in> \\<lbrace>\\<sigma>. Dag \\<acute>p \\<acute>low \\<acute>high\n                                   t \\<and>\n                                  (\\<acute>p \\<noteq> Null \\<longrightarrow>\n                                   \\<acute>p\\<rightarrow>\\<acute>var\n                                   < length \\<acute>levellist) \\<and>\n                                  ordered t \\<acute>var \\<and>\n                                  Levellist \\<acute>levellist \\<acute>next\n                                   (replicate\n                                     (\\<^bsup>\\<sigma>\\<^esup>var\n \\<^bsup>\\<sigma>\\<^esup>p +\n1)\n                                     []) \\<and>\n                                  (\\<forall>n\\<in>set_of t.\nif n\\<rightarrow>\\<acute>mark = \\<acute>m\nthen n \\<in> set (replicate\n                   (\\<^bsup>\\<sigma>\\<^esup>var \\<^bsup>\\<sigma>\\<^esup>p +\n                    1)\n                   [] !\n                  (n\\<rightarrow>\\<acute>var)) \\<and>\n     (\\<forall>nt p.\n         Dag n \\<acute>low \\<acute>high nt \\<and>\n         p \\<in> set_of nt \\<longrightarrow>\n         p\\<rightarrow>\\<acute>mark = \\<acute>m)\nelse n \\<notin> set (concat\n                      (replicate\n                        (\\<^bsup>\\<sigma>\\<^esup>var\n                          \\<^bsup>\\<sigma>\\<^esup>p +\n                         1)\n                        [])))\\<rbrace> \\<and>\n       \\<lbrace>\\<exists>ll'.\n                   Levellist \\<acute>levellist \\<acute>next ll' \\<and>\n                   wf_levellist t\n                    (replicate\n                      (\\<^bsup>\\<sigma>\\<^esup>var\n                        \\<^bsup>\\<sigma>\\<^esup>p +\n                       1)\n                      [])\n                    ll' \\<^bsup>\\<sigma>\\<^esup>var \\<and>\n                   wf_marking t \\<^bsup>\\<sigma>\\<^esup>mark \\<acute>mark\n                    \\<^bsup>\\<sigma>\\<^esup>m \\<and>\n                   (\\<forall>p.\n                       p \\<notin> set_of t \\<longrightarrow>\n                       \\<^bsup>\\<sigma>\\<^esup>next p =\n                       p\\<rightarrow>\\<acute>next)\\<rbrace>\n       \\<subseteq> \\<lbrace>\\<exists>ll.\n                               Levellist \\<acute>levellist \\<acute>next\n                                ll \\<and>\n                               wf_ll t ll \\<^bsup>\\<sigma>\\<^esup>var \\<and>\n                               length \\<acute>levellist =\n                               \\<^bsup>\\<sigma>\\<^esup>var\n                                \\<^bsup>\\<sigma>\\<^esup>p +\n                               1 \\<and>\n                               wf_marking t \\<^bsup>\\<sigma>\\<^esup>mark\n                                \\<acute>mark\n                                \\<^bsup>\\<sigma>\\<^esup>m \\<and>\n                               (\\<forall>p.\n                                   p \\<notin> set_of t \\<longrightarrow>\n                                   \\<^bsup>\\<sigma>\\<^esup>next p =\n                                   p\\<rightarrow>\\<acute>next)\\<rbrace> \\<and>\n       {} \\<subseteq> {}", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma> t s.\n       s \\<in> \\<lbrace>\\<sigma>. Dag \\<acute>p \\<acute>low \\<acute>high\n                                   t \\<and>\n                                  (\\<forall>i<length \\<acute>levellist.\n\\<acute>levellist ! i = Null) \\<and>\n                                  length \\<acute>levellist =\n                                  \\<acute>p\\<rightarrow>\\<acute>var +\n                                  1 \\<and>\n                                  ordered t \\<acute>var \\<and>\n                                  (\\<forall>n\\<in>set_of t.\nn\\<rightarrow>\\<acute>mark = (\\<not> \\<acute>m))\\<rbrace> \\<Longrightarrow>\n       s \\<in> \\<lbrace>\\<sigma>. Dag \\<acute>p \\<acute>low \\<acute>high\n                                   t \\<and>\n                                  (\\<acute>p \\<noteq> Null \\<longrightarrow>\n                                   \\<acute>p\\<rightarrow>\\<acute>var\n                                   < length \\<acute>levellist) \\<and>\n                                  ordered t \\<acute>var \\<and>\n                                  Levellist \\<acute>levellist \\<acute>next\n                                   (replicate\n                                     (\\<^bsup>\\<sigma>\\<^esup>var\n \\<^bsup>\\<sigma>\\<^esup>p +\n1)\n                                     []) \\<and>\n                                  (\\<forall>n\\<in>set_of t.\nif n\\<rightarrow>\\<acute>mark = \\<acute>m\nthen n \\<in> set (replicate\n                   (\\<^bsup>\\<sigma>\\<^esup>var \\<^bsup>\\<sigma>\\<^esup>p +\n                    1)\n                   [] !\n                  (n\\<rightarrow>\\<acute>var)) \\<and>\n     (\\<forall>nt p.\n         Dag n \\<acute>low \\<acute>high nt \\<and>\n         p \\<in> set_of nt \\<longrightarrow>\n         p\\<rightarrow>\\<acute>mark = \\<acute>m)\nelse n \\<notin> set (concat\n                      (replicate\n                        (\\<^bsup>\\<sigma>\\<^esup>var\n                          \\<^bsup>\\<sigma>\\<^esup>p +\n                         1)\n                        [])))\\<rbrace>\n 2. \\<And>\\<sigma> t s.\n       s \\<in> \\<lbrace>\\<sigma>. Dag \\<acute>p \\<acute>low \\<acute>high\n                                   t \\<and>\n                                  (\\<forall>i<length \\<acute>levellist.\n\\<acute>levellist ! i = Null) \\<and>\n                                  length \\<acute>levellist =\n                                  \\<acute>p\\<rightarrow>\\<acute>var +\n                                  1 \\<and>\n                                  ordered t \\<acute>var \\<and>\n                                  (\\<forall>n\\<in>set_of t.\nn\\<rightarrow>\\<acute>mark = (\\<not> \\<acute>m))\\<rbrace> \\<Longrightarrow>\n       \\<lbrace>\\<exists>ll'.\n                   Levellist \\<acute>levellist \\<acute>next ll' \\<and>\n                   wf_levellist t\n                    (replicate\n                      (\\<^bsup>\\<sigma>\\<^esup>var\n                        \\<^bsup>\\<sigma>\\<^esup>p +\n                       1)\n                      [])\n                    ll' \\<^bsup>\\<sigma>\\<^esup>var \\<and>\n                   wf_marking t \\<^bsup>\\<sigma>\\<^esup>mark \\<acute>mark\n                    \\<^bsup>\\<sigma>\\<^esup>m \\<and>\n                   (\\<forall>p.\n                       p \\<notin> set_of t \\<longrightarrow>\n                       \\<^bsup>\\<sigma>\\<^esup>next p =\n                       p\\<rightarrow>\\<acute>next)\\<rbrace>\n       \\<subseteq> \\<lbrace>\\<exists>ll.\n                               Levellist \\<acute>levellist \\<acute>next\n                                ll \\<and>\n                               wf_ll t ll \\<^bsup>\\<sigma>\\<^esup>var \\<and>\n                               length \\<acute>levellist =\n                               \\<^bsup>\\<sigma>\\<^esup>var\n                                \\<^bsup>\\<sigma>\\<^esup>p +\n                               1 \\<and>\n                               wf_marking t \\<^bsup>\\<sigma>\\<^esup>mark\n                                \\<acute>mark\n                                \\<^bsup>\\<sigma>\\<^esup>m \\<and>\n                               (\\<forall>p.\n                                   p \\<notin> set_of t \\<longrightarrow>\n                                   \\<^bsup>\\<sigma>\\<^esup>next p =\n                                   p\\<rightarrow>\\<acute>next)\\<rbrace> \\<and>\n       {} \\<subseteq> {}", "apply  (clarsimp split:if_split_asm simp del: concat_replicate_trivial)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma> t.\n       \\<lbrakk>Dag (p_' \\<sigma>) (low_' (globals \\<sigma>))\n                 (high_' (globals \\<sigma>)) t;\n        \\<forall>i<Suc (var_' (globals \\<sigma>) (p_' \\<sigma>)).\n           levellist_' \\<sigma> ! i = Null;\n        length (levellist_' \\<sigma>) =\n        Suc (var_' (globals \\<sigma>) (p_' \\<sigma>));\n        ordered t (var_' (globals \\<sigma>));\n        \\<forall>n\\<in>set_of t.\n           mark_' (globals \\<sigma>) n = (\\<not> m_' \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> Levellist (levellist_' \\<sigma>)\n                          (next_' (globals \\<sigma>))\n                          ([] #\n                           replicate\n                            (var_' (globals \\<sigma>) (p_' \\<sigma>)) [])\n 2. \\<And>\\<sigma> t s.\n       s \\<in> \\<lbrace>\\<sigma>. Dag \\<acute>p \\<acute>low \\<acute>high\n                                   t \\<and>\n                                  (\\<forall>i<length \\<acute>levellist.\n\\<acute>levellist ! i = Null) \\<and>\n                                  length \\<acute>levellist =\n                                  \\<acute>p\\<rightarrow>\\<acute>var +\n                                  1 \\<and>\n                                  ordered t \\<acute>var \\<and>\n                                  (\\<forall>n\\<in>set_of t.\nn\\<rightarrow>\\<acute>mark = (\\<not> \\<acute>m))\\<rbrace> \\<Longrightarrow>\n       \\<lbrace>\\<exists>ll'.\n                   Levellist \\<acute>levellist \\<acute>next ll' \\<and>\n                   wf_levellist t\n                    (replicate\n                      (\\<^bsup>\\<sigma>\\<^esup>var\n                        \\<^bsup>\\<sigma>\\<^esup>p +\n                       1)\n                      [])\n                    ll' \\<^bsup>\\<sigma>\\<^esup>var \\<and>\n                   wf_marking t \\<^bsup>\\<sigma>\\<^esup>mark \\<acute>mark\n                    \\<^bsup>\\<sigma>\\<^esup>m \\<and>\n                   (\\<forall>p.\n                       p \\<notin> set_of t \\<longrightarrow>\n                       \\<^bsup>\\<sigma>\\<^esup>next p =\n                       p\\<rightarrow>\\<acute>next)\\<rbrace>\n       \\<subseteq> \\<lbrace>\\<exists>ll.\n                               Levellist \\<acute>levellist \\<acute>next\n                                ll \\<and>\n                               wf_ll t ll \\<^bsup>\\<sigma>\\<^esup>var \\<and>\n                               length \\<acute>levellist =\n                               \\<^bsup>\\<sigma>\\<^esup>var\n                                \\<^bsup>\\<sigma>\\<^esup>p +\n                               1 \\<and>\n                               wf_marking t \\<^bsup>\\<sigma>\\<^esup>mark\n                                \\<acute>mark\n                                \\<^bsup>\\<sigma>\\<^esup>m \\<and>\n                               (\\<forall>p.\n                                   p \\<notin> set_of t \\<longrightarrow>\n                                   \\<^bsup>\\<sigma>\\<^esup>next p =\n                                   p\\<rightarrow>\\<acute>next)\\<rbrace> \\<and>\n       {} \\<subseteq> {}", "apply  (frule replicate_spec [symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>\\<sigma> t.\n       \\<lbrakk>Dag (p_' \\<sigma>) (low_' (globals \\<sigma>))\n                 (high_' (globals \\<sigma>)) t;\n        \\<forall>i<Suc (var_' (globals \\<sigma>) (p_' \\<sigma>)).\n           levellist_' \\<sigma> ! i = Null;\n        length (levellist_' \\<sigma>) =\n        Suc (var_' (globals \\<sigma>) (p_' \\<sigma>));\n        ordered t (var_' (globals \\<sigma>));\n        \\<forall>n\\<in>set_of t.\n           mark_' (globals \\<sigma>) n = (\\<not> m_' \\<sigma>)\\<rbrakk>\n       \\<Longrightarrow> Suc (var_' (globals \\<sigma>) (p_' \\<sigma>)) =\n                         length (levellist_' \\<sigma>)\n 2. \\<And>\\<sigma> t.\n       \\<lbrakk>Dag (p_' \\<sigma>) (low_' (globals \\<sigma>))\n                 (high_' (globals \\<sigma>)) t;\n        \\<forall>i<Suc (var_' (globals \\<sigma>) (p_' \\<sigma>)).\n           levellist_' \\<sigma> ! i = Null;\n        length (levellist_' \\<sigma>) =\n        Suc (var_' (globals \\<sigma>) (p_' \\<sigma>));\n        ordered t (var_' (globals \\<sigma>));\n        \\<forall>n\\<in>set_of t.\n           mark_' (globals \\<sigma>) n = (\\<not> m_' \\<sigma>);\n        levellist_' \\<sigma> =\n        replicate (length (levellist_' \\<sigma>)) Null\\<rbrakk>\n       \\<Longrightarrow> Levellist (levellist_' \\<sigma>)\n                          (next_' (globals \\<sigma>))\n                          ([] #\n                           replicate\n                            (var_' (globals \\<sigma>) (p_' \\<sigma>)) [])\n 3. \\<And>\\<sigma> t s.\n       s \\<in> \\<lbrace>\\<sigma>. Dag \\<acute>p \\<acute>low \\<acute>high\n                                   t \\<and>\n                                  (\\<forall>i<length \\<acute>levellist.\n\\<acute>levellist ! i = Null) \\<and>\n                                  length \\<acute>levellist =\n                                  \\<acute>p\\<rightarrow>\\<acute>var +\n                                  1 \\<and>\n                                  ordered t \\<acute>var \\<and>\n                                  (\\<forall>n\\<in>set_of t.\nn\\<rightarrow>\\<acute>mark = (\\<not> \\<acute>m))\\<rbrace> \\<Longrightarrow>\n       \\<lbrace>\\<exists>ll'.\n                   Levellist \\<acute>levellist \\<acute>next ll' \\<and>\n                   wf_levellist t\n                    (replicate\n                      (\\<^bsup>\\<sigma>\\<^esup>var\n                        \\<^bsup>\\<sigma>\\<^esup>p +\n                       1)\n                      [])\n                    ll' \\<^bsup>\\<sigma>\\<^esup>var \\<and>\n                   wf_marking t \\<^bsup>\\<sigma>\\<^esup>mark \\<acute>mark\n                    \\<^bsup>\\<sigma>\\<^esup>m \\<and>\n                   (\\<forall>p.\n                       p \\<notin> set_of t \\<longrightarrow>\n                       \\<^bsup>\\<sigma>\\<^esup>next p =\n                       p\\<rightarrow>\\<acute>next)\\<rbrace>\n       \\<subseteq> \\<lbrace>\\<exists>ll.\n                               Levellist \\<acute>levellist \\<acute>next\n                                ll \\<and>\n                               wf_ll t ll \\<^bsup>\\<sigma>\\<^esup>var \\<and>\n                               length \\<acute>levellist =\n                               \\<^bsup>\\<sigma>\\<^esup>var\n                                \\<^bsup>\\<sigma>\\<^esup>p +\n                               1 \\<and>\n                               wf_marking t \\<^bsup>\\<sigma>\\<^esup>mark\n                                \\<acute>mark\n                                \\<^bsup>\\<sigma>\\<^esup>m \\<and>\n                               (\\<forall>p.\n                                   p \\<notin> set_of t \\<longrightarrow>\n                                   \\<^bsup>\\<sigma>\\<^esup>next p =\n                                   p\\<rightarrow>\\<acute>next)\\<rbrace> \\<and>\n       {} \\<subseteq> {}", "apply   (simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma> t.\n       \\<lbrakk>Dag (p_' \\<sigma>) (low_' (globals \\<sigma>))\n                 (high_' (globals \\<sigma>)) t;\n        \\<forall>i<Suc (var_' (globals \\<sigma>) (p_' \\<sigma>)).\n           levellist_' \\<sigma> ! i = Null;\n        length (levellist_' \\<sigma>) =\n        Suc (var_' (globals \\<sigma>) (p_' \\<sigma>));\n        ordered t (var_' (globals \\<sigma>));\n        \\<forall>n\\<in>set_of t.\n           mark_' (globals \\<sigma>) n = (\\<not> m_' \\<sigma>);\n        levellist_' \\<sigma> =\n        replicate (length (levellist_' \\<sigma>)) Null\\<rbrakk>\n       \\<Longrightarrow> Levellist (levellist_' \\<sigma>)\n                          (next_' (globals \\<sigma>))\n                          ([] #\n                           replicate\n                            (var_' (globals \\<sigma>) (p_' \\<sigma>)) [])\n 2. \\<And>\\<sigma> t s.\n       s \\<in> \\<lbrace>\\<sigma>. Dag \\<acute>p \\<acute>low \\<acute>high\n                                   t \\<and>\n                                  (\\<forall>i<length \\<acute>levellist.\n\\<acute>levellist ! i = Null) \\<and>\n                                  length \\<acute>levellist =\n                                  \\<acute>p\\<rightarrow>\\<acute>var +\n                                  1 \\<and>\n                                  ordered t \\<acute>var \\<and>\n                                  (\\<forall>n\\<in>set_of t.\nn\\<rightarrow>\\<acute>mark = (\\<not> \\<acute>m))\\<rbrace> \\<Longrightarrow>\n       \\<lbrace>\\<exists>ll'.\n                   Levellist \\<acute>levellist \\<acute>next ll' \\<and>\n                   wf_levellist t\n                    (replicate\n                      (\\<^bsup>\\<sigma>\\<^esup>var\n                        \\<^bsup>\\<sigma>\\<^esup>p +\n                       1)\n                      [])\n                    ll' \\<^bsup>\\<sigma>\\<^esup>var \\<and>\n                   wf_marking t \\<^bsup>\\<sigma>\\<^esup>mark \\<acute>mark\n                    \\<^bsup>\\<sigma>\\<^esup>m \\<and>\n                   (\\<forall>p.\n                       p \\<notin> set_of t \\<longrightarrow>\n                       \\<^bsup>\\<sigma>\\<^esup>next p =\n                       p\\<rightarrow>\\<acute>next)\\<rbrace>\n       \\<subseteq> \\<lbrace>\\<exists>ll.\n                               Levellist \\<acute>levellist \\<acute>next\n                                ll \\<and>\n                               wf_ll t ll \\<^bsup>\\<sigma>\\<^esup>var \\<and>\n                               length \\<acute>levellist =\n                               \\<^bsup>\\<sigma>\\<^esup>var\n                                \\<^bsup>\\<sigma>\\<^esup>p +\n                               1 \\<and>\n                               wf_marking t \\<^bsup>\\<sigma>\\<^esup>mark\n                                \\<acute>mark\n                                \\<^bsup>\\<sigma>\\<^esup>m \\<and>\n                               (\\<forall>p.\n                                   p \\<notin> set_of t \\<longrightarrow>\n                                   \\<^bsup>\\<sigma>\\<^esup>next p =\n                                   p\\<rightarrow>\\<acute>next)\\<rbrace> \\<and>\n       {} \\<subseteq> {}", "apply  (clarsimp simp add: Levellist_def )"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma> t i.\n       \\<lbrakk>Dag (p_' \\<sigma>) (low_' (globals \\<sigma>))\n                 (high_' (globals \\<sigma>)) t;\n        \\<forall>i<Suc (var_' (globals \\<sigma>) (p_' \\<sigma>)).\n           (Null #\n            replicate (var_' (globals \\<sigma>) (p_' \\<sigma>)) Null) !\n           i =\n           Null;\n        ordered t (var_' (globals \\<sigma>));\n        \\<forall>n\\<in>set_of t.\n           mark_' (globals \\<sigma>) n = (\\<not> m_' \\<sigma>);\n        levellist_' \\<sigma> =\n        Null # replicate (var_' (globals \\<sigma>) (p_' \\<sigma>)) Null;\n        i < Suc (var_' (globals \\<sigma>) (p_' \\<sigma>))\\<rbrakk>\n       \\<Longrightarrow> ([] #\n                          replicate\n                           (var_' (globals \\<sigma>) (p_' \\<sigma>)) []) !\n                         i =\n                         []\n 2. \\<And>\\<sigma> t s.\n       s \\<in> \\<lbrace>\\<sigma>. Dag \\<acute>p \\<acute>low \\<acute>high\n                                   t \\<and>\n                                  (\\<forall>i<length \\<acute>levellist.\n\\<acute>levellist ! i = Null) \\<and>\n                                  length \\<acute>levellist =\n                                  \\<acute>p\\<rightarrow>\\<acute>var +\n                                  1 \\<and>\n                                  ordered t \\<acute>var \\<and>\n                                  (\\<forall>n\\<in>set_of t.\nn\\<rightarrow>\\<acute>mark = (\\<not> \\<acute>m))\\<rbrace> \\<Longrightarrow>\n       \\<lbrace>\\<exists>ll'.\n                   Levellist \\<acute>levellist \\<acute>next ll' \\<and>\n                   wf_levellist t\n                    (replicate\n                      (\\<^bsup>\\<sigma>\\<^esup>var\n                        \\<^bsup>\\<sigma>\\<^esup>p +\n                       1)\n                      [])\n                    ll' \\<^bsup>\\<sigma>\\<^esup>var \\<and>\n                   wf_marking t \\<^bsup>\\<sigma>\\<^esup>mark \\<acute>mark\n                    \\<^bsup>\\<sigma>\\<^esup>m \\<and>\n                   (\\<forall>p.\n                       p \\<notin> set_of t \\<longrightarrow>\n                       \\<^bsup>\\<sigma>\\<^esup>next p =\n                       p\\<rightarrow>\\<acute>next)\\<rbrace>\n       \\<subseteq> \\<lbrace>\\<exists>ll.\n                               Levellist \\<acute>levellist \\<acute>next\n                                ll \\<and>\n                               wf_ll t ll \\<^bsup>\\<sigma>\\<^esup>var \\<and>\n                               length \\<acute>levellist =\n                               \\<^bsup>\\<sigma>\\<^esup>var\n                                \\<^bsup>\\<sigma>\\<^esup>p +\n                               1 \\<and>\n                               wf_marking t \\<^bsup>\\<sigma>\\<^esup>mark\n                                \\<acute>mark\n                                \\<^bsup>\\<sigma>\\<^esup>m \\<and>\n                               (\\<forall>p.\n                                   p \\<notin> set_of t \\<longrightarrow>\n                                   \\<^bsup>\\<sigma>\\<^esup>next p =\n                                   p\\<rightarrow>\\<acute>next)\\<rbrace> \\<and>\n       {} \\<subseteq> {}", "apply  (case_tac i)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>\\<sigma> t i.\n       \\<lbrakk>Dag (p_' \\<sigma>) (low_' (globals \\<sigma>))\n                 (high_' (globals \\<sigma>)) t;\n        \\<forall>i<Suc (var_' (globals \\<sigma>) (p_' \\<sigma>)).\n           (Null #\n            replicate (var_' (globals \\<sigma>) (p_' \\<sigma>)) Null) !\n           i =\n           Null;\n        ordered t (var_' (globals \\<sigma>));\n        \\<forall>n\\<in>set_of t.\n           mark_' (globals \\<sigma>) n = (\\<not> m_' \\<sigma>);\n        levellist_' \\<sigma> =\n        Null # replicate (var_' (globals \\<sigma>) (p_' \\<sigma>)) Null;\n        i < Suc (var_' (globals \\<sigma>) (p_' \\<sigma>)); i = 0\\<rbrakk>\n       \\<Longrightarrow> ([] #\n                          replicate\n                           (var_' (globals \\<sigma>) (p_' \\<sigma>)) []) !\n                         i =\n                         []\n 2. \\<And>\\<sigma> t i nat.\n       \\<lbrakk>Dag (p_' \\<sigma>) (low_' (globals \\<sigma>))\n                 (high_' (globals \\<sigma>)) t;\n        \\<forall>i<Suc (var_' (globals \\<sigma>) (p_' \\<sigma>)).\n           (Null #\n            replicate (var_' (globals \\<sigma>) (p_' \\<sigma>)) Null) !\n           i =\n           Null;\n        ordered t (var_' (globals \\<sigma>));\n        \\<forall>n\\<in>set_of t.\n           mark_' (globals \\<sigma>) n = (\\<not> m_' \\<sigma>);\n        levellist_' \\<sigma> =\n        Null # replicate (var_' (globals \\<sigma>) (p_' \\<sigma>)) Null;\n        i < Suc (var_' (globals \\<sigma>) (p_' \\<sigma>));\n        i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> ([] #\n                          replicate\n                           (var_' (globals \\<sigma>) (p_' \\<sigma>)) []) !\n                         i =\n                         []\n 3. \\<And>\\<sigma> t s.\n       s \\<in> \\<lbrace>\\<sigma>. Dag \\<acute>p \\<acute>low \\<acute>high\n                                   t \\<and>\n                                  (\\<forall>i<length \\<acute>levellist.\n\\<acute>levellist ! i = Null) \\<and>\n                                  length \\<acute>levellist =\n                                  \\<acute>p\\<rightarrow>\\<acute>var +\n                                  1 \\<and>\n                                  ordered t \\<acute>var \\<and>\n                                  (\\<forall>n\\<in>set_of t.\nn\\<rightarrow>\\<acute>mark = (\\<not> \\<acute>m))\\<rbrace> \\<Longrightarrow>\n       \\<lbrace>\\<exists>ll'.\n                   Levellist \\<acute>levellist \\<acute>next ll' \\<and>\n                   wf_levellist t\n                    (replicate\n                      (\\<^bsup>\\<sigma>\\<^esup>var\n                        \\<^bsup>\\<sigma>\\<^esup>p +\n                       1)\n                      [])\n                    ll' \\<^bsup>\\<sigma>\\<^esup>var \\<and>\n                   wf_marking t \\<^bsup>\\<sigma>\\<^esup>mark \\<acute>mark\n                    \\<^bsup>\\<sigma>\\<^esup>m \\<and>\n                   (\\<forall>p.\n                       p \\<notin> set_of t \\<longrightarrow>\n                       \\<^bsup>\\<sigma>\\<^esup>next p =\n                       p\\<rightarrow>\\<acute>next)\\<rbrace>\n       \\<subseteq> \\<lbrace>\\<exists>ll.\n                               Levellist \\<acute>levellist \\<acute>next\n                                ll \\<and>\n                               wf_ll t ll \\<^bsup>\\<sigma>\\<^esup>var \\<and>\n                               length \\<acute>levellist =\n                               \\<^bsup>\\<sigma>\\<^esup>var\n                                \\<^bsup>\\<sigma>\\<^esup>p +\n                               1 \\<and>\n                               wf_marking t \\<^bsup>\\<sigma>\\<^esup>mark\n                                \\<acute>mark\n                                \\<^bsup>\\<sigma>\\<^esup>m \\<and>\n                               (\\<forall>p.\n                                   p \\<notin> set_of t \\<longrightarrow>\n                                   \\<^bsup>\\<sigma>\\<^esup>next p =\n                                   p\\<rightarrow>\\<acute>next)\\<rbrace> \\<and>\n       {} \\<subseteq> {}", "apply   simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma> t i nat.\n       \\<lbrakk>Dag (p_' \\<sigma>) (low_' (globals \\<sigma>))\n                 (high_' (globals \\<sigma>)) t;\n        \\<forall>i<Suc (var_' (globals \\<sigma>) (p_' \\<sigma>)).\n           (Null #\n            replicate (var_' (globals \\<sigma>) (p_' \\<sigma>)) Null) !\n           i =\n           Null;\n        ordered t (var_' (globals \\<sigma>));\n        \\<forall>n\\<in>set_of t.\n           mark_' (globals \\<sigma>) n = (\\<not> m_' \\<sigma>);\n        levellist_' \\<sigma> =\n        Null # replicate (var_' (globals \\<sigma>) (p_' \\<sigma>)) Null;\n        i < Suc (var_' (globals \\<sigma>) (p_' \\<sigma>));\n        i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> ([] #\n                          replicate\n                           (var_' (globals \\<sigma>) (p_' \\<sigma>)) []) !\n                         i =\n                         []\n 2. \\<And>\\<sigma> t s.\n       s \\<in> \\<lbrace>\\<sigma>. Dag \\<acute>p \\<acute>low \\<acute>high\n                                   t \\<and>\n                                  (\\<forall>i<length \\<acute>levellist.\n\\<acute>levellist ! i = Null) \\<and>\n                                  length \\<acute>levellist =\n                                  \\<acute>p\\<rightarrow>\\<acute>var +\n                                  1 \\<and>\n                                  ordered t \\<acute>var \\<and>\n                                  (\\<forall>n\\<in>set_of t.\nn\\<rightarrow>\\<acute>mark = (\\<not> \\<acute>m))\\<rbrace> \\<Longrightarrow>\n       \\<lbrace>\\<exists>ll'.\n                   Levellist \\<acute>levellist \\<acute>next ll' \\<and>\n                   wf_levellist t\n                    (replicate\n                      (\\<^bsup>\\<sigma>\\<^esup>var\n                        \\<^bsup>\\<sigma>\\<^esup>p +\n                       1)\n                      [])\n                    ll' \\<^bsup>\\<sigma>\\<^esup>var \\<and>\n                   wf_marking t \\<^bsup>\\<sigma>\\<^esup>mark \\<acute>mark\n                    \\<^bsup>\\<sigma>\\<^esup>m \\<and>\n                   (\\<forall>p.\n                       p \\<notin> set_of t \\<longrightarrow>\n                       \\<^bsup>\\<sigma>\\<^esup>next p =\n                       p\\<rightarrow>\\<acute>next)\\<rbrace>\n       \\<subseteq> \\<lbrace>\\<exists>ll.\n                               Levellist \\<acute>levellist \\<acute>next\n                                ll \\<and>\n                               wf_ll t ll \\<^bsup>\\<sigma>\\<^esup>var \\<and>\n                               length \\<acute>levellist =\n                               \\<^bsup>\\<sigma>\\<^esup>var\n                                \\<^bsup>\\<sigma>\\<^esup>p +\n                               1 \\<and>\n                               wf_marking t \\<^bsup>\\<sigma>\\<^esup>mark\n                                \\<acute>mark\n                                \\<^bsup>\\<sigma>\\<^esup>m \\<and>\n                               (\\<forall>p.\n                                   p \\<notin> set_of t \\<longrightarrow>\n                                   \\<^bsup>\\<sigma>\\<^esup>next p =\n                                   p\\<rightarrow>\\<acute>next)\\<rbrace> \\<and>\n       {} \\<subseteq> {}", "apply  simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> t s.\n       s \\<in> \\<lbrace>\\<sigma>. Dag \\<acute>p \\<acute>low \\<acute>high\n                                   t \\<and>\n                                  (\\<forall>i<length \\<acute>levellist.\n\\<acute>levellist ! i = Null) \\<and>\n                                  length \\<acute>levellist =\n                                  \\<acute>p\\<rightarrow>\\<acute>var +\n                                  1 \\<and>\n                                  ordered t \\<acute>var \\<and>\n                                  (\\<forall>n\\<in>set_of t.\nn\\<rightarrow>\\<acute>mark = (\\<not> \\<acute>m))\\<rbrace> \\<Longrightarrow>\n       \\<lbrace>\\<exists>ll'.\n                   Levellist \\<acute>levellist \\<acute>next ll' \\<and>\n                   wf_levellist t\n                    (replicate\n                      (\\<^bsup>\\<sigma>\\<^esup>var\n                        \\<^bsup>\\<sigma>\\<^esup>p +\n                       1)\n                      [])\n                    ll' \\<^bsup>\\<sigma>\\<^esup>var \\<and>\n                   wf_marking t \\<^bsup>\\<sigma>\\<^esup>mark \\<acute>mark\n                    \\<^bsup>\\<sigma>\\<^esup>m \\<and>\n                   (\\<forall>p.\n                       p \\<notin> set_of t \\<longrightarrow>\n                       \\<^bsup>\\<sigma>\\<^esup>next p =\n                       p\\<rightarrow>\\<acute>next)\\<rbrace>\n       \\<subseteq> \\<lbrace>\\<exists>ll.\n                               Levellist \\<acute>levellist \\<acute>next\n                                ll \\<and>\n                               wf_ll t ll \\<^bsup>\\<sigma>\\<^esup>var \\<and>\n                               length \\<acute>levellist =\n                               \\<^bsup>\\<sigma>\\<^esup>var\n                                \\<^bsup>\\<sigma>\\<^esup>p +\n                               1 \\<and>\n                               wf_marking t \\<^bsup>\\<sigma>\\<^esup>mark\n                                \\<acute>mark\n                                \\<^bsup>\\<sigma>\\<^esup>m \\<and>\n                               (\\<forall>p.\n                                   p \\<notin> set_of t \\<longrightarrow>\n                                   \\<^bsup>\\<sigma>\\<^esup>next p =\n                                   p\\<rightarrow>\\<acute>next)\\<rbrace> \\<and>\n       {} \\<subseteq> {}", "apply (simp add: Collect_conv_if split:if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> t.\n       Dag (p_' \\<sigma>) (low_' (globals \\<sigma>))\n        (high_' (globals \\<sigma>)) t \\<and>\n       (\\<forall>i<length (levellist_' \\<sigma>).\n           levellist_' \\<sigma> ! i = Null) \\<and>\n       length (levellist_' \\<sigma>) =\n       Suc (var_' (globals \\<sigma>) (p_' \\<sigma>)) \\<and>\n       ordered t (var_' (globals \\<sigma>)) \\<and>\n       (\\<forall>n\\<in>set_of t.\n           mark_' (globals \\<sigma>) n =\n           (\\<not> m_' \\<sigma>)) \\<Longrightarrow>\n       \\<lbrace>\\<exists>ll'.\n                   Levellist \\<acute>levellist \\<acute>next ll' \\<and>\n                   wf_levellist t\n                    ([] #\n                     replicate\n                      (\\<^bsup>\\<sigma>\\<^esup>var\n                        \\<^bsup>\\<sigma>\\<^esup>p)\n                      [])\n                    ll' \\<^bsup>\\<sigma>\\<^esup>var \\<and>\n                   wf_marking t \\<^bsup>\\<sigma>\\<^esup>mark \\<acute>mark\n                    \\<^bsup>\\<sigma>\\<^esup>m \\<and>\n                   (\\<forall>p.\n                       p \\<notin> set_of t \\<longrightarrow>\n                       \\<^bsup>\\<sigma>\\<^esup>next p =\n                       p\\<rightarrow>\\<acute>next)\\<rbrace>\n       \\<subseteq> \\<lbrace>\\<exists>ll.\n                               Levellist \\<acute>levellist \\<acute>next\n                                ll \\<and>\n                               wf_ll t ll \\<^bsup>\\<sigma>\\<^esup>var \\<and>\n                               length \\<acute>levellist =\n                               Suc (\\<^bsup>\\<sigma>\\<^esup>var\n                                     \\<^bsup>\\<sigma>\\<^esup>p) \\<and>\n                               wf_marking t \\<^bsup>\\<sigma>\\<^esup>mark\n                                \\<acute>mark\n                                \\<^bsup>\\<sigma>\\<^esup>m \\<and>\n                               (\\<forall>p.\n                                   p \\<notin> set_of t \\<longrightarrow>\n                                   \\<^bsup>\\<sigma>\\<^esup>next p =\n                                   p\\<rightarrow>\\<acute>next)\\<rbrace>", "apply vcg_step"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>var low high mark next p levellist m t marka nexta levellista.\n       \\<lbrakk>Dag p low high t;\n        \\<forall>i<length levellist. levellist ! i = Null;\n        length levellist = Suc (var p); ordered t var;\n        \\<forall>n\\<in>set_of t. mark n = (\\<not> m);\n        \\<exists>ll'.\n           Levellist levellista nexta ll' \\<and>\n           wf_levellist t ([] # replicate (var p) []) ll' var \\<and>\n           wf_marking t mark marka m \\<and>\n           (\\<forall>p.\n               p \\<notin> set_of t \\<longrightarrow>\n               next p = nexta p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ll.\n                            Levellist levellista nexta ll \\<and>\n                            wf_ll t ll var \\<and>\n                            length levellista = Suc (var p) \\<and>\n                            wf_marking t mark marka m \\<and>\n                            (\\<forall>p.\n                                p \\<notin> set_of t \\<longrightarrow>\n                                next p = nexta p)", "apply (elim exE conjE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>var low high mark next p levellist m t marka nexta levellista ll'.\n       \\<lbrakk>Dag p low high t;\n        \\<forall>i<length levellist. levellist ! i = Null;\n        length levellist = Suc (var p); ordered t var;\n        \\<forall>n\\<in>set_of t. mark n = (\\<not> m);\n        Levellist levellista nexta ll';\n        wf_levellist t ([] # replicate (var p) []) ll' var;\n        wf_marking t mark marka m;\n        \\<forall>p.\n           p \\<notin> set_of t \\<longrightarrow> next p = nexta p\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ll.\n                            Levellist levellista nexta ll \\<and>\n                            wf_ll t ll var \\<and>\n                            length levellista = Suc (var p) \\<and>\n                            wf_marking t mark marka m \\<and>\n                            (\\<forall>p.\n                                p \\<notin> set_of t \\<longrightarrow>\n                                next p = nexta p)", "apply (rule_tac x=ll' in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>var low high mark next p levellist m t marka nexta levellista ll'.\n       \\<lbrakk>Dag p low high t;\n        \\<forall>i<length levellist. levellist ! i = Null;\n        length levellist = Suc (var p); ordered t var;\n        \\<forall>n\\<in>set_of t. mark n = (\\<not> m);\n        Levellist levellista nexta ll';\n        wf_levellist t ([] # replicate (var p) []) ll' var;\n        wf_marking t mark marka m;\n        \\<forall>p.\n           p \\<notin> set_of t \\<longrightarrow> next p = nexta p\\<rbrakk>\n       \\<Longrightarrow> Levellist levellista nexta ll' \\<and>\n                         wf_ll t ll' var \\<and>\n                         length levellista = Suc (var p) \\<and>\n                         wf_marking t mark marka m \\<and>\n                         (\\<forall>p.\n                             p \\<notin> set_of t \\<longrightarrow>\n                             next p = nexta p)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>var low high mark next p levellist m t marka nexta levellista ll'.\n       \\<lbrakk>Dag p low high t;\n        \\<forall>i<Suc (var p). levellist ! i = Null;\n        length levellist = Suc (var p); ordered t var;\n        \\<forall>n\\<in>set_of t. mark n = (\\<not> m);\n        Levellist levellista nexta ll';\n        wf_levellist t ([] # replicate (var p) []) ll' var;\n        wf_marking t mark marka m;\n        \\<forall>p.\n           p \\<notin> set_of t \\<longrightarrow> next p = nexta p\\<rbrakk>\n       \\<Longrightarrow> wf_ll t ll' var \\<and>\n                         length levellista = Suc (var p)", "apply (thin_tac \"\\<forall>p. p \\<notin> set_of t \\<longrightarrow> next p = nexta p\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>var low high mark next p levellist m t marka nexta levellista ll'.\n       \\<lbrakk>Dag p low high t;\n        \\<forall>i<Suc (var p). levellist ! i = Null;\n        length levellist = Suc (var p); ordered t var;\n        \\<forall>n\\<in>set_of t. mark n = (\\<not> m);\n        Levellist levellista nexta ll';\n        wf_levellist t ([] # replicate (var p) []) ll' var;\n        wf_marking t mark marka m\\<rbrakk>\n       \\<Longrightarrow> wf_ll t ll' var \\<and>\n                         length levellista = Suc (var p)", "apply (simp add: wf_levellist_def wf_ll_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>var low high mark p levellist m t marka nexta levellista ll'.\n       \\<lbrakk>Dag p low high t;\n        \\<forall>i<Suc (var p). levellist ! i = Null;\n        length levellist = Suc (var p); ordered t var;\n        \\<forall>n\\<in>set_of t. mark n = (\\<not> m);\n        Levellist levellista nexta ll';\n        case t of Tip \\<Rightarrow> [] # replicate (var p) [] = ll'\n        | Node lt pa rt \\<Rightarrow>\n            (\\<forall>q.\n                q \\<in> set_of t \\<longrightarrow>\n                q \\<in> set (ll' ! var q)) \\<and>\n            (\\<forall>i\\<le>var pa.\n                \\<exists>prx.\n                   ll' ! i = prx @ ([] # replicate (var p) []) ! i \\<and>\n                   (\\<forall>pt\\<in>set prx.\n                       pt \\<in> set_of t \\<and> var pt = i)) \\<and>\n            (\\<forall>i>var pa.\n                ll' ! i = ([] # replicate (var p) []) ! i) \\<and>\n            length ll' = length ([] # replicate (var p) []);\n        wf_marking t mark marka m\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>p.\n                             p \\<in> set_of t \\<longrightarrow>\n                             p \\<in> set (ll' ! var p)) \\<and>\n                         (\\<forall>k<length ll'.\n                             \\<forall>p\\<in>set (ll' ! k).\n                                p \\<in> set_of t \\<and> var p = k) \\<and>\n                         length levellista = Suc (var p)", "apply (case_tac \"t = Tip\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>var low high mark p levellist m t marka nexta levellista ll'.\n       \\<lbrakk>Dag p low high t;\n        \\<forall>i<Suc (var p). levellist ! i = Null;\n        length levellist = Suc (var p); ordered t var;\n        \\<forall>n\\<in>set_of t. mark n = (\\<not> m);\n        Levellist levellista nexta ll';\n        case t of Tip \\<Rightarrow> [] # replicate (var p) [] = ll'\n        | Node lt pa rt \\<Rightarrow>\n            (\\<forall>q.\n                q \\<in> set_of t \\<longrightarrow>\n                q \\<in> set (ll' ! var q)) \\<and>\n            (\\<forall>i\\<le>var pa.\n                \\<exists>prx.\n                   ll' ! i = prx @ ([] # replicate (var p) []) ! i \\<and>\n                   (\\<forall>pt\\<in>set prx.\n                       pt \\<in> set_of t \\<and> var pt = i)) \\<and>\n            (\\<forall>i>var pa.\n                ll' ! i = ([] # replicate (var p) []) ! i) \\<and>\n            length ll' = length ([] # replicate (var p) []);\n        wf_marking t mark marka m; t = Tip\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>p.\n                             p \\<in> set_of t \\<longrightarrow>\n                             p \\<in> set (ll' ! var p)) \\<and>\n                         (\\<forall>k<length ll'.\n                             \\<forall>p\\<in>set (ll' ! k).\n                                p \\<in> set_of t \\<and> var p = k) \\<and>\n                         length levellista = Suc (var p)\n 2. \\<And>var low high mark p levellist m t marka nexta levellista ll'.\n       \\<lbrakk>Dag p low high t;\n        \\<forall>i<Suc (var p). levellist ! i = Null;\n        length levellist = Suc (var p); ordered t var;\n        \\<forall>n\\<in>set_of t. mark n = (\\<not> m);\n        Levellist levellista nexta ll';\n        case t of Tip \\<Rightarrow> [] # replicate (var p) [] = ll'\n        | Node lt pa rt \\<Rightarrow>\n            (\\<forall>q.\n                q \\<in> set_of t \\<longrightarrow>\n                q \\<in> set (ll' ! var q)) \\<and>\n            (\\<forall>i\\<le>var pa.\n                \\<exists>prx.\n                   ll' ! i = prx @ ([] # replicate (var p) []) ! i \\<and>\n                   (\\<forall>pt\\<in>set prx.\n                       pt \\<in> set_of t \\<and> var pt = i)) \\<and>\n            (\\<forall>i>var pa.\n                ll' ! i = ([] # replicate (var p) []) ! i) \\<and>\n            length ll' = length ([] # replicate (var p) []);\n        wf_marking t mark marka m; t \\<noteq> Tip\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>p.\n                             p \\<in> set_of t \\<longrightarrow>\n                             p \\<in> set (ll' ! var p)) \\<and>\n                         (\\<forall>k<length ll'.\n                             \\<forall>p\\<in>set (ll' ! k).\n                                p \\<in> set_of t \\<and> var p = k) \\<and>\n                         length levellista = Suc (var p)", "apply  simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>var mark p levellist m t marka nexta levellista ll'.\n       \\<lbrakk>p = Null; \\<forall>i<Suc (var Null). levellist ! i = Null;\n        length levellist = Suc (var Null); Levellist levellista nexta ll';\n        [] # replicate (var Null) [] = ll'; wf_marking Tip mark marka m;\n        t = Tip\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>k<length ll'. ll' ! k = []) \\<and>\n                         length levellista = Suc (var Null)\n 2. \\<And>var low high mark p levellist m t marka nexta levellista ll'.\n       \\<lbrakk>Dag p low high t;\n        \\<forall>i<Suc (var p). levellist ! i = Null;\n        length levellist = Suc (var p); ordered t var;\n        \\<forall>n\\<in>set_of t. mark n = (\\<not> m);\n        Levellist levellista nexta ll';\n        case t of Tip \\<Rightarrow> [] # replicate (var p) [] = ll'\n        | Node lt pa rt \\<Rightarrow>\n            (\\<forall>q.\n                q \\<in> set_of t \\<longrightarrow>\n                q \\<in> set (ll' ! var q)) \\<and>\n            (\\<forall>i\\<le>var pa.\n                \\<exists>prx.\n                   ll' ! i = prx @ ([] # replicate (var p) []) ! i \\<and>\n                   (\\<forall>pt\\<in>set prx.\n                       pt \\<in> set_of t \\<and> var pt = i)) \\<and>\n            (\\<forall>i>var pa.\n                ll' ! i = ([] # replicate (var p) []) ! i) \\<and>\n            length ll' = length ([] # replicate (var p) []);\n        wf_marking t mark marka m; t \\<noteq> Tip\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>p.\n                             p \\<in> set_of t \\<longrightarrow>\n                             p \\<in> set (ll' ! var p)) \\<and>\n                         (\\<forall>k<length ll'.\n                             \\<forall>p\\<in>set (ll' ! k).\n                                p \\<in> set_of t \\<and> var p = k) \\<and>\n                         length levellista = Suc (var p)", "apply  (rule conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>var mark p levellist m t marka nexta levellista ll'.\n       \\<lbrakk>p = Null; \\<forall>i<Suc (var Null). levellist ! i = Null;\n        length levellist = Suc (var Null); Levellist levellista nexta ll';\n        [] # replicate (var Null) [] = ll'; wf_marking Tip mark marka m;\n        t = Tip\\<rbrakk>\n       \\<Longrightarrow> \\<forall>k<length ll'. ll' ! k = []\n 2. \\<And>var mark p levellist m t marka nexta levellista ll'.\n       \\<lbrakk>p = Null; \\<forall>i<Suc (var Null). levellist ! i = Null;\n        length levellist = Suc (var Null); Levellist levellista nexta ll';\n        [] # replicate (var Null) [] = ll'; wf_marking Tip mark marka m;\n        t = Tip\\<rbrakk>\n       \\<Longrightarrow> length levellista = Suc (var Null)\n 3. \\<And>var low high mark p levellist m t marka nexta levellista ll'.\n       \\<lbrakk>Dag p low high t;\n        \\<forall>i<Suc (var p). levellist ! i = Null;\n        length levellist = Suc (var p); ordered t var;\n        \\<forall>n\\<in>set_of t. mark n = (\\<not> m);\n        Levellist levellista nexta ll';\n        case t of Tip \\<Rightarrow> [] # replicate (var p) [] = ll'\n        | Node lt pa rt \\<Rightarrow>\n            (\\<forall>q.\n                q \\<in> set_of t \\<longrightarrow>\n                q \\<in> set (ll' ! var q)) \\<and>\n            (\\<forall>i\\<le>var pa.\n                \\<exists>prx.\n                   ll' ! i = prx @ ([] # replicate (var p) []) ! i \\<and>\n                   (\\<forall>pt\\<in>set prx.\n                       pt \\<in> set_of t \\<and> var pt = i)) \\<and>\n            (\\<forall>i>var pa.\n                ll' ! i = ([] # replicate (var p) []) ! i) \\<and>\n            length ll' = length ([] # replicate (var p) []);\n        wf_marking t mark marka m; t \\<noteq> Tip\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>p.\n                             p \\<in> set_of t \\<longrightarrow>\n                             p \\<in> set (ll' ! var p)) \\<and>\n                         (\\<forall>k<length ll'.\n                             \\<forall>p\\<in>set (ll' ! k).\n                                p \\<in> set_of t \\<and> var p = k) \\<and>\n                         length levellista = Suc (var p)", "apply   clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>var mark levellist m marka nexta levellista k.\n       \\<lbrakk>\\<forall>i<Suc (var Null). levellist ! i = Null;\n        length levellist = Suc (var Null);\n        Levellist levellista nexta ([] # replicate (var Null) []);\n        wf_marking Tip mark marka m; k < Suc (var Null)\\<rbrakk>\n       \\<Longrightarrow> ([] # replicate (var Null) []) ! k = []\n 2. \\<And>var mark p levellist m t marka nexta levellista ll'.\n       \\<lbrakk>p = Null; \\<forall>i<Suc (var Null). levellist ! i = Null;\n        length levellist = Suc (var Null); Levellist levellista nexta ll';\n        [] # replicate (var Null) [] = ll'; wf_marking Tip mark marka m;\n        t = Tip\\<rbrakk>\n       \\<Longrightarrow> length levellista = Suc (var Null)\n 3. \\<And>var low high mark p levellist m t marka nexta levellista ll'.\n       \\<lbrakk>Dag p low high t;\n        \\<forall>i<Suc (var p). levellist ! i = Null;\n        length levellist = Suc (var p); ordered t var;\n        \\<forall>n\\<in>set_of t. mark n = (\\<not> m);\n        Levellist levellista nexta ll';\n        case t of Tip \\<Rightarrow> [] # replicate (var p) [] = ll'\n        | Node lt pa rt \\<Rightarrow>\n            (\\<forall>q.\n                q \\<in> set_of t \\<longrightarrow>\n                q \\<in> set (ll' ! var q)) \\<and>\n            (\\<forall>i\\<le>var pa.\n                \\<exists>prx.\n                   ll' ! i = prx @ ([] # replicate (var p) []) ! i \\<and>\n                   (\\<forall>pt\\<in>set prx.\n                       pt \\<in> set_of t \\<and> var pt = i)) \\<and>\n            (\\<forall>i>var pa.\n                ll' ! i = ([] # replicate (var p) []) ! i) \\<and>\n            length ll' = length ([] # replicate (var p) []);\n        wf_marking t mark marka m; t \\<noteq> Tip\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>p.\n                             p \\<in> set_of t \\<longrightarrow>\n                             p \\<in> set (ll' ! var p)) \\<and>\n                         (\\<forall>k<length ll'.\n                             \\<forall>p\\<in>set (ll' ! k).\n                                p \\<in> set_of t \\<and> var p = k) \\<and>\n                         length levellista = Suc (var p)", "apply   (case_tac k)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>var mark levellist m marka nexta levellista k.\n       \\<lbrakk>\\<forall>i<Suc (var Null). levellist ! i = Null;\n        length levellist = Suc (var Null);\n        Levellist levellista nexta ([] # replicate (var Null) []);\n        wf_marking Tip mark marka m; k < Suc (var Null); k = 0\\<rbrakk>\n       \\<Longrightarrow> ([] # replicate (var Null) []) ! k = []\n 2. \\<And>var mark levellist m marka nexta levellista k nat.\n       \\<lbrakk>\\<forall>i<Suc (var Null). levellist ! i = Null;\n        length levellist = Suc (var Null);\n        Levellist levellista nexta ([] # replicate (var Null) []);\n        wf_marking Tip mark marka m; k < Suc (var Null);\n        k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> ([] # replicate (var Null) []) ! k = []\n 3. \\<And>var mark p levellist m t marka nexta levellista ll'.\n       \\<lbrakk>p = Null; \\<forall>i<Suc (var Null). levellist ! i = Null;\n        length levellist = Suc (var Null); Levellist levellista nexta ll';\n        [] # replicate (var Null) [] = ll'; wf_marking Tip mark marka m;\n        t = Tip\\<rbrakk>\n       \\<Longrightarrow> length levellista = Suc (var Null)\n 4. \\<And>var low high mark p levellist m t marka nexta levellista ll'.\n       \\<lbrakk>Dag p low high t;\n        \\<forall>i<Suc (var p). levellist ! i = Null;\n        length levellist = Suc (var p); ordered t var;\n        \\<forall>n\\<in>set_of t. mark n = (\\<not> m);\n        Levellist levellista nexta ll';\n        case t of Tip \\<Rightarrow> [] # replicate (var p) [] = ll'\n        | Node lt pa rt \\<Rightarrow>\n            (\\<forall>q.\n                q \\<in> set_of t \\<longrightarrow>\n                q \\<in> set (ll' ! var q)) \\<and>\n            (\\<forall>i\\<le>var pa.\n                \\<exists>prx.\n                   ll' ! i = prx @ ([] # replicate (var p) []) ! i \\<and>\n                   (\\<forall>pt\\<in>set prx.\n                       pt \\<in> set_of t \\<and> var pt = i)) \\<and>\n            (\\<forall>i>var pa.\n                ll' ! i = ([] # replicate (var p) []) ! i) \\<and>\n            length ll' = length ([] # replicate (var p) []);\n        wf_marking t mark marka m; t \\<noteq> Tip\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>p.\n                             p \\<in> set_of t \\<longrightarrow>\n                             p \\<in> set (ll' ! var p)) \\<and>\n                         (\\<forall>k<length ll'.\n                             \\<forall>p\\<in>set (ll' ! k).\n                                p \\<in> set_of t \\<and> var p = k) \\<and>\n                         length levellista = Suc (var p)", "apply    simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>var mark levellist m marka nexta levellista k nat.\n       \\<lbrakk>\\<forall>i<Suc (var Null). levellist ! i = Null;\n        length levellist = Suc (var Null);\n        Levellist levellista nexta ([] # replicate (var Null) []);\n        wf_marking Tip mark marka m; k < Suc (var Null);\n        k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> ([] # replicate (var Null) []) ! k = []\n 2. \\<And>var mark p levellist m t marka nexta levellista ll'.\n       \\<lbrakk>p = Null; \\<forall>i<Suc (var Null). levellist ! i = Null;\n        length levellist = Suc (var Null); Levellist levellista nexta ll';\n        [] # replicate (var Null) [] = ll'; wf_marking Tip mark marka m;\n        t = Tip\\<rbrakk>\n       \\<Longrightarrow> length levellista = Suc (var Null)\n 3. \\<And>var low high mark p levellist m t marka nexta levellista ll'.\n       \\<lbrakk>Dag p low high t;\n        \\<forall>i<Suc (var p). levellist ! i = Null;\n        length levellist = Suc (var p); ordered t var;\n        \\<forall>n\\<in>set_of t. mark n = (\\<not> m);\n        Levellist levellista nexta ll';\n        case t of Tip \\<Rightarrow> [] # replicate (var p) [] = ll'\n        | Node lt pa rt \\<Rightarrow>\n            (\\<forall>q.\n                q \\<in> set_of t \\<longrightarrow>\n                q \\<in> set (ll' ! var q)) \\<and>\n            (\\<forall>i\\<le>var pa.\n                \\<exists>prx.\n                   ll' ! i = prx @ ([] # replicate (var p) []) ! i \\<and>\n                   (\\<forall>pt\\<in>set prx.\n                       pt \\<in> set_of t \\<and> var pt = i)) \\<and>\n            (\\<forall>i>var pa.\n                ll' ! i = ([] # replicate (var p) []) ! i) \\<and>\n            length ll' = length ([] # replicate (var p) []);\n        wf_marking t mark marka m; t \\<noteq> Tip\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>p.\n                             p \\<in> set_of t \\<longrightarrow>\n                             p \\<in> set (ll' ! var p)) \\<and>\n                         (\\<forall>k<length ll'.\n                             \\<forall>p\\<in>set (ll' ! k).\n                                p \\<in> set_of t \\<and> var p = k) \\<and>\n                         length levellista = Suc (var p)", "apply   simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>var mark p levellist m t marka nexta levellista ll'.\n       \\<lbrakk>p = Null; \\<forall>i<Suc (var Null). levellist ! i = Null;\n        length levellist = Suc (var Null); Levellist levellista nexta ll';\n        [] # replicate (var Null) [] = ll'; wf_marking Tip mark marka m;\n        t = Tip\\<rbrakk>\n       \\<Longrightarrow> length levellista = Suc (var Null)\n 2. \\<And>var low high mark p levellist m t marka nexta levellista ll'.\n       \\<lbrakk>Dag p low high t;\n        \\<forall>i<Suc (var p). levellist ! i = Null;\n        length levellist = Suc (var p); ordered t var;\n        \\<forall>n\\<in>set_of t. mark n = (\\<not> m);\n        Levellist levellista nexta ll';\n        case t of Tip \\<Rightarrow> [] # replicate (var p) [] = ll'\n        | Node lt pa rt \\<Rightarrow>\n            (\\<forall>q.\n                q \\<in> set_of t \\<longrightarrow>\n                q \\<in> set (ll' ! var q)) \\<and>\n            (\\<forall>i\\<le>var pa.\n                \\<exists>prx.\n                   ll' ! i = prx @ ([] # replicate (var p) []) ! i \\<and>\n                   (\\<forall>pt\\<in>set prx.\n                       pt \\<in> set_of t \\<and> var pt = i)) \\<and>\n            (\\<forall>i>var pa.\n                ll' ! i = ([] # replicate (var p) []) ! i) \\<and>\n            length ll' = length ([] # replicate (var p) []);\n        wf_marking t mark marka m; t \\<noteq> Tip\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>p.\n                             p \\<in> set_of t \\<longrightarrow>\n                             p \\<in> set (ll' ! var p)) \\<and>\n                         (\\<forall>k<length ll'.\n                             \\<forall>p\\<in>set (ll' ! k).\n                                p \\<in> set_of t \\<and> var p = k) \\<and>\n                         length levellista = Suc (var p)", "apply  (subgoal_tac \"length ll'=Suc (var Null)\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>var mark p levellist m t marka nexta levellista ll'.\n       \\<lbrakk>p = Null; \\<forall>i<Suc (var Null). levellist ! i = Null;\n        length levellist = Suc (var Null); Levellist levellista nexta ll';\n        [] # replicate (var Null) [] = ll'; wf_marking Tip mark marka m;\n        t = Tip; length ll' = Suc (var Null)\\<rbrakk>\n       \\<Longrightarrow> length levellista = Suc (var Null)\n 2. \\<And>var mark p levellist m t marka nexta levellista ll'.\n       \\<lbrakk>p = Null; \\<forall>i<Suc (var Null). levellist ! i = Null;\n        length levellist = Suc (var Null); Levellist levellista nexta ll';\n        [] # replicate (var Null) [] = ll'; wf_marking Tip mark marka m;\n        t = Tip\\<rbrakk>\n       \\<Longrightarrow> length ll' = Suc (var Null)\n 3. \\<And>var low high mark p levellist m t marka nexta levellista ll'.\n       \\<lbrakk>Dag p low high t;\n        \\<forall>i<Suc (var p). levellist ! i = Null;\n        length levellist = Suc (var p); ordered t var;\n        \\<forall>n\\<in>set_of t. mark n = (\\<not> m);\n        Levellist levellista nexta ll';\n        case t of Tip \\<Rightarrow> [] # replicate (var p) [] = ll'\n        | Node lt pa rt \\<Rightarrow>\n            (\\<forall>q.\n                q \\<in> set_of t \\<longrightarrow>\n                q \\<in> set (ll' ! var q)) \\<and>\n            (\\<forall>i\\<le>var pa.\n                \\<exists>prx.\n                   ll' ! i = prx @ ([] # replicate (var p) []) ! i \\<and>\n                   (\\<forall>pt\\<in>set prx.\n                       pt \\<in> set_of t \\<and> var pt = i)) \\<and>\n            (\\<forall>i>var pa.\n                ll' ! i = ([] # replicate (var p) []) ! i) \\<and>\n            length ll' = length ([] # replicate (var p) []);\n        wf_marking t mark marka m; t \\<noteq> Tip\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>p.\n                             p \\<in> set_of t \\<longrightarrow>\n                             p \\<in> set (ll' ! var p)) \\<and>\n                         (\\<forall>k<length ll'.\n                             \\<forall>p\\<in>set (ll' ! k).\n                                p \\<in> set_of t \\<and> var p = k) \\<and>\n                         length levellista = Suc (var p)", "apply   (simp add: Levellist_length)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>var mark p levellist m t marka nexta levellista ll'.\n       \\<lbrakk>p = Null; \\<forall>i<Suc (var Null). levellist ! i = Null;\n        length levellist = Suc (var Null); Levellist levellista nexta ll';\n        [] # replicate (var Null) [] = ll'; wf_marking Tip mark marka m;\n        t = Tip\\<rbrakk>\n       \\<Longrightarrow> length ll' = Suc (var Null)\n 2. \\<And>var low high mark p levellist m t marka nexta levellista ll'.\n       \\<lbrakk>Dag p low high t;\n        \\<forall>i<Suc (var p). levellist ! i = Null;\n        length levellist = Suc (var p); ordered t var;\n        \\<forall>n\\<in>set_of t. mark n = (\\<not> m);\n        Levellist levellista nexta ll';\n        case t of Tip \\<Rightarrow> [] # replicate (var p) [] = ll'\n        | Node lt pa rt \\<Rightarrow>\n            (\\<forall>q.\n                q \\<in> set_of t \\<longrightarrow>\n                q \\<in> set (ll' ! var q)) \\<and>\n            (\\<forall>i\\<le>var pa.\n                \\<exists>prx.\n                   ll' ! i = prx @ ([] # replicate (var p) []) ! i \\<and>\n                   (\\<forall>pt\\<in>set prx.\n                       pt \\<in> set_of t \\<and> var pt = i)) \\<and>\n            (\\<forall>i>var pa.\n                ll' ! i = ([] # replicate (var p) []) ! i) \\<and>\n            length ll' = length ([] # replicate (var p) []);\n        wf_marking t mark marka m; t \\<noteq> Tip\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>p.\n                             p \\<in> set_of t \\<longrightarrow>\n                             p \\<in> set (ll' ! var p)) \\<and>\n                         (\\<forall>k<length ll'.\n                             \\<forall>p\\<in>set (ll' ! k).\n                                p \\<in> set_of t \\<and> var p = k) \\<and>\n                         length levellista = Suc (var p)", "apply  fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>var low high mark p levellist m t marka nexta levellista ll'.\n       \\<lbrakk>Dag p low high t;\n        \\<forall>i<Suc (var p). levellist ! i = Null;\n        length levellist = Suc (var p); ordered t var;\n        \\<forall>n\\<in>set_of t. mark n = (\\<not> m);\n        Levellist levellista nexta ll';\n        case t of Tip \\<Rightarrow> [] # replicate (var p) [] = ll'\n        | Node lt pa rt \\<Rightarrow>\n            (\\<forall>q.\n                q \\<in> set_of t \\<longrightarrow>\n                q \\<in> set (ll' ! var q)) \\<and>\n            (\\<forall>i\\<le>var pa.\n                \\<exists>prx.\n                   ll' ! i = prx @ ([] # replicate (var p) []) ! i \\<and>\n                   (\\<forall>pt\\<in>set prx.\n                       pt \\<in> set_of t \\<and> var pt = i)) \\<and>\n            (\\<forall>i>var pa.\n                ll' ! i = ([] # replicate (var p) []) ! i) \\<and>\n            length ll' = length ([] # replicate (var p) []);\n        wf_marking t mark marka m; t \\<noteq> Tip\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>p.\n                             p \\<in> set_of t \\<longrightarrow>\n                             p \\<in> set (ll' ! var p)) \\<and>\n                         (\\<forall>k<length ll'.\n                             \\<forall>p\\<in>set (ll' ! k).\n                                p \\<in> set_of t \\<and> var p = k) \\<and>\n                         length levellista = Suc (var p)", "apply (split dag.splits)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>var low high mark p levellist m t marka nexta levellista ll'.\n       \\<lbrakk>wf_marking t mark marka m; t \\<noteq> Tip; Dag p low high t;\n        \\<forall>i<Suc (var p). levellist ! i = Null;\n        length levellist = Suc (var p); ordered t var;\n        \\<forall>n\\<in>set_of t. mark n = (\\<not> m);\n        Levellist levellista nexta ll'; t = Tip;\n        [] # replicate (var p) [] = ll'\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>p.\n                             p \\<in> set_of t \\<longrightarrow>\n                             p \\<in> set (ll' ! var p)) \\<and>\n                         (\\<forall>k<length ll'.\n                             \\<forall>p\\<in>set (ll' ! k).\n                                p \\<in> set_of t \\<and> var p = k) \\<and>\n                         length levellista = Suc (var p)\n 2. \\<And>var low high mark p levellist m t marka nexta levellista ll' x21\n       x22 x23.\n       \\<lbrakk>wf_marking t mark marka m; t \\<noteq> Tip; Dag p low high t;\n        \\<forall>i<Suc (var p). levellist ! i = Null;\n        length levellist = Suc (var p); ordered t var;\n        \\<forall>n\\<in>set_of t. mark n = (\\<not> m);\n        Levellist levellista nexta ll'; t = Node x21 x22 x23;\n        (\\<forall>q.\n            q \\<in> set_of t \\<longrightarrow>\n            q \\<in> set (ll' ! var q)) \\<and>\n        (\\<forall>i\\<le>var x22.\n            \\<exists>prx.\n               ll' ! i = prx @ ([] # replicate (var p) []) ! i \\<and>\n               (\\<forall>pt\\<in>set prx.\n                   pt \\<in> set_of t \\<and> var pt = i)) \\<and>\n        (\\<forall>i>var x22.\n            ll' ! i = ([] # replicate (var p) []) ! i) \\<and>\n        length ll' = length ([] # replicate (var p) [])\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>p.\n                             p \\<in> set_of t \\<longrightarrow>\n                             p \\<in> set (ll' ! var p)) \\<and>\n                         (\\<forall>k<length ll'.\n                             \\<forall>p\\<in>set (ll' ! k).\n                                p \\<in> set_of t \\<and> var p = k) \\<and>\n                         length levellista = Suc (var p)", "apply  simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>var low high mark p levellist m t marka nexta levellista ll' x21\n       x22 x23.\n       \\<lbrakk>wf_marking t mark marka m; t \\<noteq> Tip; Dag p low high t;\n        \\<forall>i<Suc (var p). levellist ! i = Null;\n        length levellist = Suc (var p); ordered t var;\n        \\<forall>n\\<in>set_of t. mark n = (\\<not> m);\n        Levellist levellista nexta ll'; t = Node x21 x22 x23;\n        (\\<forall>q.\n            q \\<in> set_of t \\<longrightarrow>\n            q \\<in> set (ll' ! var q)) \\<and>\n        (\\<forall>i\\<le>var x22.\n            \\<exists>prx.\n               ll' ! i = prx @ ([] # replicate (var p) []) ! i \\<and>\n               (\\<forall>pt\\<in>set prx.\n                   pt \\<in> set_of t \\<and> var pt = i)) \\<and>\n        (\\<forall>i>var x22.\n            ll' ! i = ([] # replicate (var p) []) ! i) \\<and>\n        length ll' = length ([] # replicate (var p) [])\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>p.\n                             p \\<in> set_of t \\<longrightarrow>\n                             p \\<in> set (ll' ! var p)) \\<and>\n                         (\\<forall>k<length ll'.\n                             \\<forall>p\\<in>set (ll' ! k).\n                                p \\<in> set_of t \\<and> var p = k) \\<and>\n                         length levellista = Suc (var p)", "apply (elim conjE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>var low high mark p levellist m t marka nexta levellista ll' x21\n       x22 x23.\n       \\<lbrakk>wf_marking t mark marka m; t \\<noteq> Tip; Dag p low high t;\n        \\<forall>i<Suc (var p). levellist ! i = Null;\n        length levellist = Suc (var p); ordered t var;\n        \\<forall>n\\<in>set_of t. mark n = (\\<not> m);\n        Levellist levellista nexta ll'; t = Node x21 x22 x23;\n        \\<forall>q.\n           q \\<in> set_of t \\<longrightarrow> q \\<in> set (ll' ! var q);\n        \\<forall>i\\<le>var x22.\n           \\<exists>prx.\n              ll' ! i = prx @ ([] # replicate (var p) []) ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  pt \\<in> set_of t \\<and> var pt = i);\n        \\<forall>i>var x22. ll' ! i = ([] # replicate (var p) []) ! i;\n        length ll' = length ([] # replicate (var p) [])\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>p.\n                             p \\<in> set_of t \\<longrightarrow>\n                             p \\<in> set (ll' ! var p)) \\<and>\n                         (\\<forall>k<length ll'.\n                             \\<forall>p\\<in>set (ll' ! k).\n                                p \\<in> set_of t \\<and> var p = k) \\<and>\n                         length levellista = Suc (var p)", "apply (intro conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>var low high mark p levellist m t marka nexta levellista ll' x21\n       x22 x23.\n       \\<lbrakk>wf_marking t mark marka m; t \\<noteq> Tip; Dag p low high t;\n        \\<forall>i<Suc (var p). levellist ! i = Null;\n        length levellist = Suc (var p); ordered t var;\n        \\<forall>n\\<in>set_of t. mark n = (\\<not> m);\n        Levellist levellista nexta ll'; t = Node x21 x22 x23;\n        \\<forall>q.\n           q \\<in> set_of t \\<longrightarrow> q \\<in> set (ll' ! var q);\n        \\<forall>i\\<le>var x22.\n           \\<exists>prx.\n              ll' ! i = prx @ ([] # replicate (var p) []) ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  pt \\<in> set_of t \\<and> var pt = i);\n        \\<forall>i>var x22. ll' ! i = ([] # replicate (var p) []) ! i;\n        length ll' = length ([] # replicate (var p) [])\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p.\n                            p \\<in> set_of t \\<longrightarrow>\n                            p \\<in> set (ll' ! var p)\n 2. \\<And>var low high mark p levellist m t marka nexta levellista ll' x21\n       x22 x23.\n       \\<lbrakk>wf_marking t mark marka m; t \\<noteq> Tip; Dag p low high t;\n        \\<forall>i<Suc (var p). levellist ! i = Null;\n        length levellist = Suc (var p); ordered t var;\n        \\<forall>n\\<in>set_of t. mark n = (\\<not> m);\n        Levellist levellista nexta ll'; t = Node x21 x22 x23;\n        \\<forall>q.\n           q \\<in> set_of t \\<longrightarrow> q \\<in> set (ll' ! var q);\n        \\<forall>i\\<le>var x22.\n           \\<exists>prx.\n              ll' ! i = prx @ ([] # replicate (var p) []) ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  pt \\<in> set_of t \\<and> var pt = i);\n        \\<forall>i>var x22. ll' ! i = ([] # replicate (var p) []) ! i;\n        length ll' = length ([] # replicate (var p) [])\\<rbrakk>\n       \\<Longrightarrow> \\<forall>k<length ll'.\n                            \\<forall>p\\<in>set (ll' ! k).\n                               p \\<in> set_of t \\<and> var p = k\n 3. \\<And>var low high mark p levellist m t marka nexta levellista ll' x21\n       x22 x23.\n       \\<lbrakk>wf_marking t mark marka m; t \\<noteq> Tip; Dag p low high t;\n        \\<forall>i<Suc (var p). levellist ! i = Null;\n        length levellist = Suc (var p); ordered t var;\n        \\<forall>n\\<in>set_of t. mark n = (\\<not> m);\n        Levellist levellista nexta ll'; t = Node x21 x22 x23;\n        \\<forall>q.\n           q \\<in> set_of t \\<longrightarrow> q \\<in> set (ll' ! var q);\n        \\<forall>i\\<le>var x22.\n           \\<exists>prx.\n              ll' ! i = prx @ ([] # replicate (var p) []) ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  pt \\<in> set_of t \\<and> var pt = i);\n        \\<forall>i>var x22. ll' ! i = ([] # replicate (var p) []) ! i;\n        length ll' = length ([] # replicate (var p) [])\\<rbrakk>\n       \\<Longrightarrow> length levellista = Suc (var p)", "apply   (rule allI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>var low high mark p levellist m t marka nexta levellista ll' x21\n       x22 x23 pa.\n       \\<lbrakk>wf_marking t mark marka m; t \\<noteq> Tip; Dag p low high t;\n        \\<forall>i<Suc (var p). levellist ! i = Null;\n        length levellist = Suc (var p); ordered t var;\n        \\<forall>n\\<in>set_of t. mark n = (\\<not> m);\n        Levellist levellista nexta ll'; t = Node x21 x22 x23;\n        \\<forall>q.\n           q \\<in> set_of t \\<longrightarrow> q \\<in> set (ll' ! var q);\n        \\<forall>i\\<le>var x22.\n           \\<exists>prx.\n              ll' ! i = prx @ ([] # replicate (var p) []) ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  pt \\<in> set_of t \\<and> var pt = i);\n        \\<forall>i>var x22. ll' ! i = ([] # replicate (var p) []) ! i;\n        length ll' = length ([] # replicate (var p) [])\\<rbrakk>\n       \\<Longrightarrow> pa \\<in> set_of t \\<longrightarrow>\n                         pa \\<in> set (ll' ! var pa)\n 2. \\<And>var low high mark p levellist m t marka nexta levellista ll' x21\n       x22 x23.\n       \\<lbrakk>wf_marking t mark marka m; t \\<noteq> Tip; Dag p low high t;\n        \\<forall>i<Suc (var p). levellist ! i = Null;\n        length levellist = Suc (var p); ordered t var;\n        \\<forall>n\\<in>set_of t. mark n = (\\<not> m);\n        Levellist levellista nexta ll'; t = Node x21 x22 x23;\n        \\<forall>q.\n           q \\<in> set_of t \\<longrightarrow> q \\<in> set (ll' ! var q);\n        \\<forall>i\\<le>var x22.\n           \\<exists>prx.\n              ll' ! i = prx @ ([] # replicate (var p) []) ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  pt \\<in> set_of t \\<and> var pt = i);\n        \\<forall>i>var x22. ll' ! i = ([] # replicate (var p) []) ! i;\n        length ll' = length ([] # replicate (var p) [])\\<rbrakk>\n       \\<Longrightarrow> \\<forall>k<length ll'.\n                            \\<forall>p\\<in>set (ll' ! k).\n                               p \\<in> set_of t \\<and> var p = k\n 3. \\<And>var low high mark p levellist m t marka nexta levellista ll' x21\n       x22 x23.\n       \\<lbrakk>wf_marking t mark marka m; t \\<noteq> Tip; Dag p low high t;\n        \\<forall>i<Suc (var p). levellist ! i = Null;\n        length levellist = Suc (var p); ordered t var;\n        \\<forall>n\\<in>set_of t. mark n = (\\<not> m);\n        Levellist levellista nexta ll'; t = Node x21 x22 x23;\n        \\<forall>q.\n           q \\<in> set_of t \\<longrightarrow> q \\<in> set (ll' ! var q);\n        \\<forall>i\\<le>var x22.\n           \\<exists>prx.\n              ll' ! i = prx @ ([] # replicate (var p) []) ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  pt \\<in> set_of t \\<and> var pt = i);\n        \\<forall>i>var x22. ll' ! i = ([] # replicate (var p) []) ! i;\n        length ll' = length ([] # replicate (var p) [])\\<rbrakk>\n       \\<Longrightarrow> length levellista = Suc (var p)", "apply   (erule_tac x=\"pa\" in allE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>var low high mark p levellist m t marka nexta levellista ll' x21\n       x22 x23 pa.\n       \\<lbrakk>wf_marking t mark marka m; t \\<noteq> Tip; Dag p low high t;\n        \\<forall>i<Suc (var p). levellist ! i = Null;\n        length levellist = Suc (var p); ordered t var;\n        \\<forall>n\\<in>set_of t. mark n = (\\<not> m);\n        Levellist levellista nexta ll'; t = Node x21 x22 x23;\n        \\<forall>i\\<le>var x22.\n           \\<exists>prx.\n              ll' ! i = prx @ ([] # replicate (var p) []) ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  pt \\<in> set_of t \\<and> var pt = i);\n        \\<forall>i>var x22. ll' ! i = ([] # replicate (var p) []) ! i;\n        length ll' = length ([] # replicate (var p) []);\n        pa \\<in> set_of t \\<longrightarrow>\n        pa \\<in> set (ll' ! var pa)\\<rbrakk>\n       \\<Longrightarrow> pa \\<in> set_of t \\<longrightarrow>\n                         pa \\<in> set (ll' ! var pa)\n 2. \\<And>var low high mark p levellist m t marka nexta levellista ll' x21\n       x22 x23.\n       \\<lbrakk>wf_marking t mark marka m; t \\<noteq> Tip; Dag p low high t;\n        \\<forall>i<Suc (var p). levellist ! i = Null;\n        length levellist = Suc (var p); ordered t var;\n        \\<forall>n\\<in>set_of t. mark n = (\\<not> m);\n        Levellist levellista nexta ll'; t = Node x21 x22 x23;\n        \\<forall>q.\n           q \\<in> set_of t \\<longrightarrow> q \\<in> set (ll' ! var q);\n        \\<forall>i\\<le>var x22.\n           \\<exists>prx.\n              ll' ! i = prx @ ([] # replicate (var p) []) ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  pt \\<in> set_of t \\<and> var pt = i);\n        \\<forall>i>var x22. ll' ! i = ([] # replicate (var p) []) ! i;\n        length ll' = length ([] # replicate (var p) [])\\<rbrakk>\n       \\<Longrightarrow> \\<forall>k<length ll'.\n                            \\<forall>p\\<in>set (ll' ! k).\n                               p \\<in> set_of t \\<and> var p = k\n 3. \\<And>var low high mark p levellist m t marka nexta levellista ll' x21\n       x22 x23.\n       \\<lbrakk>wf_marking t mark marka m; t \\<noteq> Tip; Dag p low high t;\n        \\<forall>i<Suc (var p). levellist ! i = Null;\n        length levellist = Suc (var p); ordered t var;\n        \\<forall>n\\<in>set_of t. mark n = (\\<not> m);\n        Levellist levellista nexta ll'; t = Node x21 x22 x23;\n        \\<forall>q.\n           q \\<in> set_of t \\<longrightarrow> q \\<in> set (ll' ! var q);\n        \\<forall>i\\<le>var x22.\n           \\<exists>prx.\n              ll' ! i = prx @ ([] # replicate (var p) []) ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  pt \\<in> set_of t \\<and> var pt = i);\n        \\<forall>i>var x22. ll' ! i = ([] # replicate (var p) []) ! i;\n        length ll' = length ([] # replicate (var p) [])\\<rbrakk>\n       \\<Longrightarrow> length levellista = Suc (var p)", "apply   clarify"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>var low high mark p levellist m t marka nexta levellista ll' x21\n       x22 x23.\n       \\<lbrakk>wf_marking t mark marka m; t \\<noteq> Tip; Dag p low high t;\n        \\<forall>i<Suc (var p). levellist ! i = Null;\n        length levellist = Suc (var p); ordered t var;\n        \\<forall>n\\<in>set_of t. mark n = (\\<not> m);\n        Levellist levellista nexta ll'; t = Node x21 x22 x23;\n        \\<forall>q.\n           q \\<in> set_of t \\<longrightarrow> q \\<in> set (ll' ! var q);\n        \\<forall>i\\<le>var x22.\n           \\<exists>prx.\n              ll' ! i = prx @ ([] # replicate (var p) []) ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  pt \\<in> set_of t \\<and> var pt = i);\n        \\<forall>i>var x22. ll' ! i = ([] # replicate (var p) []) ! i;\n        length ll' = length ([] # replicate (var p) [])\\<rbrakk>\n       \\<Longrightarrow> \\<forall>k<length ll'.\n                            \\<forall>p\\<in>set (ll' ! k).\n                               p \\<in> set_of t \\<and> var p = k\n 2. \\<And>var low high mark p levellist m t marka nexta levellista ll' x21\n       x22 x23.\n       \\<lbrakk>wf_marking t mark marka m; t \\<noteq> Tip; Dag p low high t;\n        \\<forall>i<Suc (var p). levellist ! i = Null;\n        length levellist = Suc (var p); ordered t var;\n        \\<forall>n\\<in>set_of t. mark n = (\\<not> m);\n        Levellist levellista nexta ll'; t = Node x21 x22 x23;\n        \\<forall>q.\n           q \\<in> set_of t \\<longrightarrow> q \\<in> set (ll' ! var q);\n        \\<forall>i\\<le>var x22.\n           \\<exists>prx.\n              ll' ! i = prx @ ([] # replicate (var p) []) ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  pt \\<in> set_of t \\<and> var pt = i);\n        \\<forall>i>var x22. ll' ! i = ([] # replicate (var p) []) ! i;\n        length ll' = length ([] # replicate (var p) [])\\<rbrakk>\n       \\<Longrightarrow> length levellista = Suc (var p)", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>var low high mark p levellist m t marka nexta levellista ll' x21\n       x22 x23.\n       \\<lbrakk>wf_marking t mark marka m; t \\<noteq> Tip; Dag p low high t;\n        \\<forall>i<Suc (var p). levellist ! i = Null;\n        length levellist = Suc (var p); ordered t var;\n        \\<forall>n\\<in>set_of t. mark n = (\\<not> m);\n        Levellist levellista nexta ll'; t = Node x21 x22 x23;\n        \\<forall>q.\n           q \\<in> set_of t \\<longrightarrow> q \\<in> set (ll' ! var q);\n        \\<forall>i\\<le>var x22.\n           \\<exists>prx.\n              ll' ! i = prx @ ([] # replicate (var p) []) ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  pt \\<in> set_of t \\<and> var pt = i);\n        \\<forall>i>var x22. ll' ! i = ([] # replicate (var p) []) ! i;\n        length ll' = length ([] # replicate (var p) [])\\<rbrakk>\n       \\<Longrightarrow> length levellista = Suc (var p)\n 2. \\<And>var low high mark p levellist m t marka nexta levellista ll' x21\n       x22 x23.\n       \\<lbrakk>wf_marking t mark marka m; t \\<noteq> Tip; Dag p low high t;\n        \\<forall>i<Suc (var p). levellist ! i = Null;\n        length levellist = Suc (var p); ordered t var;\n        \\<forall>n\\<in>set_of t. mark n = (\\<not> m);\n        Levellist levellista nexta ll'; t = Node x21 x22 x23;\n        \\<forall>q.\n           q \\<in> set_of t \\<longrightarrow> q \\<in> set (ll' ! var q);\n        \\<forall>i\\<le>var x22.\n           \\<exists>prx.\n              ll' ! i = prx @ ([] # replicate (var p) []) ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  pt \\<in> set_of t \\<and> var pt = i);\n        \\<forall>i>var x22. ll' ! i = ([] # replicate (var p) []) ! i;\n        length ll' = length ([] # replicate (var p) [])\\<rbrakk>\n       \\<Longrightarrow> \\<forall>k<length ll'.\n                            \\<forall>p\\<in>set (ll' ! k).\n                               p \\<in> set_of t \\<and> var p = k", "apply  (simp add: Levellist_length)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>var low high mark p levellist m t marka nexta levellista ll' x21\n       x22 x23.\n       \\<lbrakk>wf_marking t mark marka m; t \\<noteq> Tip; Dag p low high t;\n        \\<forall>i<Suc (var p). levellist ! i = Null;\n        length levellist = Suc (var p); ordered t var;\n        \\<forall>n\\<in>set_of t. mark n = (\\<not> m);\n        Levellist levellista nexta ll'; t = Node x21 x22 x23;\n        \\<forall>q.\n           q \\<in> set_of t \\<longrightarrow> q \\<in> set (ll' ! var q);\n        \\<forall>i\\<le>var x22.\n           \\<exists>prx.\n              ll' ! i = prx @ ([] # replicate (var p) []) ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  pt \\<in> set_of t \\<and> var pt = i);\n        \\<forall>i>var x22. ll' ! i = ([] # replicate (var p) []) ! i;\n        length ll' = length ([] # replicate (var p) [])\\<rbrakk>\n       \\<Longrightarrow> \\<forall>k<length ll'.\n                            \\<forall>p\\<in>set (ll' ! k).\n                               p \\<in> set_of t \\<and> var p = k", "apply (rule allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>var low high mark p levellist m t marka nexta levellista ll' x21\n       x22 x23 k.\n       \\<lbrakk>wf_marking t mark marka m; t \\<noteq> Tip; Dag p low high t;\n        \\<forall>i<Suc (var p). levellist ! i = Null;\n        length levellist = Suc (var p); ordered t var;\n        \\<forall>n\\<in>set_of t. mark n = (\\<not> m);\n        Levellist levellista nexta ll'; t = Node x21 x22 x23;\n        \\<forall>q.\n           q \\<in> set_of t \\<longrightarrow> q \\<in> set (ll' ! var q);\n        \\<forall>i\\<le>var x22.\n           \\<exists>prx.\n              ll' ! i = prx @ ([] # replicate (var p) []) ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  pt \\<in> set_of t \\<and> var pt = i);\n        \\<forall>i>var x22. ll' ! i = ([] # replicate (var p) []) ! i;\n        length ll' = length ([] # replicate (var p) [])\\<rbrakk>\n       \\<Longrightarrow> k < length ll' \\<longrightarrow>\n                         (\\<forall>p\\<in>set (ll' ! k).\n                             p \\<in> set_of t \\<and> var p = k)", "apply (rule impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>var low high mark p levellist m t marka nexta levellista ll' x21\n       x22 x23 k.\n       \\<lbrakk>wf_marking t mark marka m; t \\<noteq> Tip; Dag p low high t;\n        \\<forall>i<Suc (var p). levellist ! i = Null;\n        length levellist = Suc (var p); ordered t var;\n        \\<forall>n\\<in>set_of t. mark n = (\\<not> m);\n        Levellist levellista nexta ll'; t = Node x21 x22 x23;\n        \\<forall>q.\n           q \\<in> set_of t \\<longrightarrow> q \\<in> set (ll' ! var q);\n        \\<forall>i\\<le>var x22.\n           \\<exists>prx.\n              ll' ! i = prx @ ([] # replicate (var p) []) ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  pt \\<in> set_of t \\<and> var pt = i);\n        \\<forall>i>var x22. ll' ! i = ([] # replicate (var p) []) ! i;\n        length ll' = length ([] # replicate (var p) []);\n        k < length ll'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>p\\<in>set (ll' ! k).\n                            p \\<in> set_of t \\<and> var p = k", "apply (rule ballI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>var low high mark p levellist m t marka nexta levellista ll' x21\n       x22 x23 k pa.\n       \\<lbrakk>wf_marking t mark marka m; t \\<noteq> Tip; Dag p low high t;\n        \\<forall>i<Suc (var p). levellist ! i = Null;\n        length levellist = Suc (var p); ordered t var;\n        \\<forall>n\\<in>set_of t. mark n = (\\<not> m);\n        Levellist levellista nexta ll'; t = Node x21 x22 x23;\n        \\<forall>q.\n           q \\<in> set_of t \\<longrightarrow> q \\<in> set (ll' ! var q);\n        \\<forall>i\\<le>var x22.\n           \\<exists>prx.\n              ll' ! i = prx @ ([] # replicate (var p) []) ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  pt \\<in> set_of t \\<and> var pt = i);\n        \\<forall>i>var x22. ll' ! i = ([] # replicate (var p) []) ! i;\n        length ll' = length ([] # replicate (var p) []); k < length ll';\n        pa \\<in> set (ll' ! k)\\<rbrakk>\n       \\<Longrightarrow> pa \\<in> set_of t \\<and> var pa = k", "apply (rotate_tac 11)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>var low high mark p levellist m t marka nexta levellista ll' x21\n       x22 x23 k pa.\n       \\<lbrakk>\\<forall>i>var x22.\n                   ll' ! i = ([] # replicate (var p) []) ! i;\n        length ll' = length ([] # replicate (var p) []); k < length ll';\n        pa \\<in> set (ll' ! k); wf_marking t mark marka m; t \\<noteq> Tip;\n        Dag p low high t; \\<forall>i<Suc (var p). levellist ! i = Null;\n        length levellist = Suc (var p); ordered t var;\n        \\<forall>n\\<in>set_of t. mark n = (\\<not> m);\n        Levellist levellista nexta ll'; t = Node x21 x22 x23;\n        \\<forall>q.\n           q \\<in> set_of t \\<longrightarrow> q \\<in> set (ll' ! var q);\n        \\<forall>i\\<le>var x22.\n           \\<exists>prx.\n              ll' ! i = prx @ ([] # replicate (var p) []) ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  pt \\<in> set_of t \\<and> var pt = i)\\<rbrakk>\n       \\<Longrightarrow> pa \\<in> set_of t \\<and> var pa = k", "apply (erule_tac x=\"k\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>var low high mark p levellist m t marka nexta levellista ll' x21\n       x22 x23 k pa.\n       \\<lbrakk>length ll' = length ([] # replicate (var p) []);\n        k < length ll'; pa \\<in> set (ll' ! k); wf_marking t mark marka m;\n        t \\<noteq> Tip; Dag p low high t;\n        \\<forall>i<Suc (var p). levellist ! i = Null;\n        length levellist = Suc (var p); ordered t var;\n        \\<forall>n\\<in>set_of t. mark n = (\\<not> m);\n        Levellist levellista nexta ll'; t = Node x21 x22 x23;\n        \\<forall>q.\n           q \\<in> set_of t \\<longrightarrow> q \\<in> set (ll' ! var q);\n        \\<forall>i\\<le>var x22.\n           \\<exists>prx.\n              ll' ! i = prx @ ([] # replicate (var p) []) ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  pt \\<in> set_of t \\<and> var pt = i);\n        var x22 < k \\<longrightarrow>\n        ll' ! k = ([] # replicate (var p) []) ! k\\<rbrakk>\n       \\<Longrightarrow> pa \\<in> set_of t \\<and> var pa = k", "apply (rename_tac dag1 ref dag2 k pa)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>var low high mark p levellist m t marka nexta levellista ll' dag1\n       ref dag2 k pa.\n       \\<lbrakk>length ll' = length ([] # replicate (var p) []);\n        k < length ll'; pa \\<in> set (ll' ! k); wf_marking t mark marka m;\n        t \\<noteq> Tip; Dag p low high t;\n        \\<forall>i<Suc (var p). levellist ! i = Null;\n        length levellist = Suc (var p); ordered t var;\n        \\<forall>n\\<in>set_of t. mark n = (\\<not> m);\n        Levellist levellista nexta ll'; t = Node dag1 ref dag2;\n        \\<forall>q.\n           q \\<in> set_of t \\<longrightarrow> q \\<in> set (ll' ! var q);\n        \\<forall>i\\<le>var ref.\n           \\<exists>prx.\n              ll' ! i = prx @ ([] # replicate (var p) []) ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  pt \\<in> set_of t \\<and> var pt = i);\n        var ref < k \\<longrightarrow>\n        ll' ! k = ([] # replicate (var p) []) ! k\\<rbrakk>\n       \\<Longrightarrow> pa \\<in> set_of t \\<and> var pa = k", "apply (subgoal_tac \"k <= var ref\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>var low high mark p levellist m t marka nexta levellista ll' dag1\n       ref dag2 k pa.\n       \\<lbrakk>length ll' = length ([] # replicate (var p) []);\n        k < length ll'; pa \\<in> set (ll' ! k); wf_marking t mark marka m;\n        t \\<noteq> Tip; Dag p low high t;\n        \\<forall>i<Suc (var p). levellist ! i = Null;\n        length levellist = Suc (var p); ordered t var;\n        \\<forall>n\\<in>set_of t. mark n = (\\<not> m);\n        Levellist levellista nexta ll'; t = Node dag1 ref dag2;\n        \\<forall>q.\n           q \\<in> set_of t \\<longrightarrow> q \\<in> set (ll' ! var q);\n        \\<forall>i\\<le>var ref.\n           \\<exists>prx.\n              ll' ! i = prx @ ([] # replicate (var p) []) ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  pt \\<in> set_of t \\<and> var pt = i);\n        var ref < k \\<longrightarrow>\n        ll' ! k = ([] # replicate (var p) []) ! k;\n        k \\<le> var ref\\<rbrakk>\n       \\<Longrightarrow> pa \\<in> set_of t \\<and> var pa = k\n 2. \\<And>var low high mark p levellist m t marka nexta levellista ll' dag1\n       ref dag2 k pa.\n       \\<lbrakk>length ll' = length ([] # replicate (var p) []);\n        k < length ll'; pa \\<in> set (ll' ! k); wf_marking t mark marka m;\n        t \\<noteq> Tip; Dag p low high t;\n        \\<forall>i<Suc (var p). levellist ! i = Null;\n        length levellist = Suc (var p); ordered t var;\n        \\<forall>n\\<in>set_of t. mark n = (\\<not> m);\n        Levellist levellista nexta ll'; t = Node dag1 ref dag2;\n        \\<forall>q.\n           q \\<in> set_of t \\<longrightarrow> q \\<in> set (ll' ! var q);\n        \\<forall>i\\<le>var ref.\n           \\<exists>prx.\n              ll' ! i = prx @ ([] # replicate (var p) []) ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  pt \\<in> set_of t \\<and> var pt = i);\n        var ref < k \\<longrightarrow>\n        ll' ! k = ([] # replicate (var p) []) ! k\\<rbrakk>\n       \\<Longrightarrow> k \\<le> var ref", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>var low high mark p levellist m t marka nexta levellista ll' dag1\n       ref dag2 k pa.\n       \\<lbrakk>length ll' = length ([] # replicate (var p) []);\n        k < length ll'; pa \\<in> set (ll' ! k); wf_marking t mark marka m;\n        t \\<noteq> Tip; Dag p low high t;\n        \\<forall>i<Suc (var p). levellist ! i = Null;\n        length levellist = Suc (var p); ordered t var;\n        \\<forall>n\\<in>set_of t. mark n = (\\<not> m);\n        Levellist levellista nexta ll'; t = Node dag1 ref dag2;\n        \\<forall>q.\n           q \\<in> set_of t \\<longrightarrow> q \\<in> set (ll' ! var q);\n        \\<forall>i\\<le>var ref.\n           \\<exists>prx.\n              ll' ! i = prx @ ([] # replicate (var p) []) ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  pt \\<in> set_of t \\<and> var pt = i);\n        var ref < k \\<longrightarrow>\n        ll' ! k = ([] # replicate (var p) []) ! k\\<rbrakk>\n       \\<Longrightarrow> k \\<le> var ref\n 2. \\<And>var low high mark p levellist m t marka nexta levellista ll' dag1\n       ref dag2 k pa.\n       \\<lbrakk>length ll' = length ([] # replicate (var p) []);\n        k < length ll'; pa \\<in> set (ll' ! k); wf_marking t mark marka m;\n        t \\<noteq> Tip; Dag p low high t;\n        \\<forall>i<Suc (var p). levellist ! i = Null;\n        length levellist = Suc (var p); ordered t var;\n        \\<forall>n\\<in>set_of t. mark n = (\\<not> m);\n        Levellist levellista nexta ll'; t = Node dag1 ref dag2;\n        \\<forall>q.\n           q \\<in> set_of t \\<longrightarrow> q \\<in> set (ll' ! var q);\n        \\<forall>i\\<le>var ref.\n           \\<exists>prx.\n              ll' ! i = prx @ ([] # replicate (var p) []) ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  pt \\<in> set_of t \\<and> var pt = i);\n        var ref < k \\<longrightarrow>\n        ll' ! k = ([] # replicate (var p) []) ! k;\n        k \\<le> var ref\\<rbrakk>\n       \\<Longrightarrow> pa \\<in> set_of t \\<and> var pa = k", "apply  (subgoal_tac \"ref = p\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>var low high mark p levellist m t marka nexta levellista ll' dag1\n       ref dag2 k pa.\n       \\<lbrakk>length ll' = length ([] # replicate (var p) []);\n        k < length ll'; pa \\<in> set (ll' ! k); wf_marking t mark marka m;\n        t \\<noteq> Tip; Dag p low high t;\n        \\<forall>i<Suc (var p). levellist ! i = Null;\n        length levellist = Suc (var p); ordered t var;\n        \\<forall>n\\<in>set_of t. mark n = (\\<not> m);\n        Levellist levellista nexta ll'; t = Node dag1 ref dag2;\n        \\<forall>q.\n           q \\<in> set_of t \\<longrightarrow> q \\<in> set (ll' ! var q);\n        \\<forall>i\\<le>var ref.\n           \\<exists>prx.\n              ll' ! i = prx @ ([] # replicate (var p) []) ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  pt \\<in> set_of t \\<and> var pt = i);\n        var ref < k \\<longrightarrow>\n        ll' ! k = ([] # replicate (var p) []) ! k;\n        ref = p\\<rbrakk>\n       \\<Longrightarrow> k \\<le> var ref\n 2. \\<And>var low high mark p levellist m t marka nexta levellista ll' dag1\n       ref dag2 k pa.\n       \\<lbrakk>length ll' = length ([] # replicate (var p) []);\n        k < length ll'; pa \\<in> set (ll' ! k); wf_marking t mark marka m;\n        t \\<noteq> Tip; Dag p low high t;\n        \\<forall>i<Suc (var p). levellist ! i = Null;\n        length levellist = Suc (var p); ordered t var;\n        \\<forall>n\\<in>set_of t. mark n = (\\<not> m);\n        Levellist levellista nexta ll'; t = Node dag1 ref dag2;\n        \\<forall>q.\n           q \\<in> set_of t \\<longrightarrow> q \\<in> set (ll' ! var q);\n        \\<forall>i\\<le>var ref.\n           \\<exists>prx.\n              ll' ! i = prx @ ([] # replicate (var p) []) ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  pt \\<in> set_of t \\<and> var pt = i);\n        var ref < k \\<longrightarrow>\n        ll' ! k = ([] # replicate (var p) []) ! k\\<rbrakk>\n       \\<Longrightarrow> ref = p\n 3. \\<And>var low high mark p levellist m t marka nexta levellista ll' dag1\n       ref dag2 k pa.\n       \\<lbrakk>length ll' = length ([] # replicate (var p) []);\n        k < length ll'; pa \\<in> set (ll' ! k); wf_marking t mark marka m;\n        t \\<noteq> Tip; Dag p low high t;\n        \\<forall>i<Suc (var p). levellist ! i = Null;\n        length levellist = Suc (var p); ordered t var;\n        \\<forall>n\\<in>set_of t. mark n = (\\<not> m);\n        Levellist levellista nexta ll'; t = Node dag1 ref dag2;\n        \\<forall>q.\n           q \\<in> set_of t \\<longrightarrow> q \\<in> set (ll' ! var q);\n        \\<forall>i\\<le>var ref.\n           \\<exists>prx.\n              ll' ! i = prx @ ([] # replicate (var p) []) ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  pt \\<in> set_of t \\<and> var pt = i);\n        var ref < k \\<longrightarrow>\n        ll' ! k = ([] # replicate (var p) []) ! k;\n        k \\<le> var ref\\<rbrakk>\n       \\<Longrightarrow> pa \\<in> set_of t \\<and> var pa = k", "apply   simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>var low high mark p levellist m t marka nexta levellista ll' dag1\n       ref dag2 k pa.\n       \\<lbrakk>length ll' = length ([] # replicate (var p) []);\n        k < length ll'; pa \\<in> set (ll' ! k); wf_marking t mark marka m;\n        t \\<noteq> Tip; Dag p low high t;\n        \\<forall>i<Suc (var p). levellist ! i = Null;\n        length levellist = Suc (var p); ordered t var;\n        \\<forall>n\\<in>set_of t. mark n = (\\<not> m);\n        Levellist levellista nexta ll'; t = Node dag1 ref dag2;\n        \\<forall>q.\n           q \\<in> set_of t \\<longrightarrow> q \\<in> set (ll' ! var q);\n        \\<forall>i\\<le>var ref.\n           \\<exists>prx.\n              ll' ! i = prx @ ([] # replicate (var p) []) ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  pt \\<in> set_of t \\<and> var pt = i);\n        var ref < k \\<longrightarrow>\n        ll' ! k = ([] # replicate (var p) []) ! k\\<rbrakk>\n       \\<Longrightarrow> ref = p\n 2. \\<And>var low high mark p levellist m t marka nexta levellista ll' dag1\n       ref dag2 k pa.\n       \\<lbrakk>length ll' = length ([] # replicate (var p) []);\n        k < length ll'; pa \\<in> set (ll' ! k); wf_marking t mark marka m;\n        t \\<noteq> Tip; Dag p low high t;\n        \\<forall>i<Suc (var p). levellist ! i = Null;\n        length levellist = Suc (var p); ordered t var;\n        \\<forall>n\\<in>set_of t. mark n = (\\<not> m);\n        Levellist levellista nexta ll'; t = Node dag1 ref dag2;\n        \\<forall>q.\n           q \\<in> set_of t \\<longrightarrow> q \\<in> set (ll' ! var q);\n        \\<forall>i\\<le>var ref.\n           \\<exists>prx.\n              ll' ! i = prx @ ([] # replicate (var p) []) ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  pt \\<in> set_of t \\<and> var pt = i);\n        var ref < k \\<longrightarrow>\n        ll' ! k = ([] # replicate (var p) []) ! k;\n        k \\<le> var ref\\<rbrakk>\n       \\<Longrightarrow> pa \\<in> set_of t \\<and> var pa = k", "apply  clarify"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>var low high mark p levellist m t marka nexta levellista ll' dag1\n       ref dag2 k pa.\n       \\<lbrakk>length ll' = length ([] # replicate (var p) []);\n        k < length ll'; pa \\<in> set (ll' ! k);\n        wf_marking (Node dag1 ref dag2) mark marka m;\n        Node dag1 ref dag2 \\<noteq> Tip;\n        Dag p low high (Node dag1 ref dag2);\n        \\<forall>i<Suc (var p). levellist ! i = Null;\n        length levellist = Suc (var p); ordered (Node dag1 ref dag2) var;\n        \\<forall>n\\<in>set_of (Node dag1 ref dag2). mark n = (\\<not> m);\n        Levellist levellista nexta ll';\n        \\<forall>q.\n           q \\<in> set_of (Node dag1 ref dag2) \\<longrightarrow>\n           q \\<in> set (ll' ! var q);\n        \\<forall>i\\<le>var ref.\n           \\<exists>prx.\n              ll' ! i = prx @ ([] # replicate (var p) []) ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  pt \\<in> set_of (Node dag1 ref dag2) \\<and> var pt = i);\n        var ref < k \\<longrightarrow>\n        ll' ! k = ([] # replicate (var p) []) ! k\\<rbrakk>\n       \\<Longrightarrow> ref = p\n 2. \\<And>var low high mark p levellist m t marka nexta levellista ll' dag1\n       ref dag2 k pa.\n       \\<lbrakk>length ll' = length ([] # replicate (var p) []);\n        k < length ll'; pa \\<in> set (ll' ! k); wf_marking t mark marka m;\n        t \\<noteq> Tip; Dag p low high t;\n        \\<forall>i<Suc (var p). levellist ! i = Null;\n        length levellist = Suc (var p); ordered t var;\n        \\<forall>n\\<in>set_of t. mark n = (\\<not> m);\n        Levellist levellista nexta ll'; t = Node dag1 ref dag2;\n        \\<forall>q.\n           q \\<in> set_of t \\<longrightarrow> q \\<in> set (ll' ! var q);\n        \\<forall>i\\<le>var ref.\n           \\<exists>prx.\n              ll' ! i = prx @ ([] # replicate (var p) []) ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  pt \\<in> set_of t \\<and> var pt = i);\n        var ref < k \\<longrightarrow>\n        ll' ! k = ([] # replicate (var p) []) ! k;\n        k \\<le> var ref\\<rbrakk>\n       \\<Longrightarrow> pa \\<in> set_of t \\<and> var pa = k", "apply  (erule_tac ?P = \"Dag p low high (Node dag1 ref dag2)\" in rev_mp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>var low high mark p levellist m t marka nexta levellista ll' dag1\n       ref dag2 k pa.\n       \\<lbrakk>length ll' = length ([] # replicate (var p) []);\n        k < length ll'; pa \\<in> set (ll' ! k);\n        wf_marking (Node dag1 ref dag2) mark marka m;\n        Node dag1 ref dag2 \\<noteq> Tip;\n        \\<forall>i<Suc (var p). levellist ! i = Null;\n        length levellist = Suc (var p); ordered (Node dag1 ref dag2) var;\n        \\<forall>n\\<in>set_of (Node dag1 ref dag2). mark n = (\\<not> m);\n        Levellist levellista nexta ll';\n        \\<forall>q.\n           q \\<in> set_of (Node dag1 ref dag2) \\<longrightarrow>\n           q \\<in> set (ll' ! var q);\n        \\<forall>i\\<le>var ref.\n           \\<exists>prx.\n              ll' ! i = prx @ ([] # replicate (var p) []) ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  pt \\<in> set_of (Node dag1 ref dag2) \\<and> var pt = i);\n        var ref < k \\<longrightarrow>\n        ll' ! k = ([] # replicate (var p) []) ! k\\<rbrakk>\n       \\<Longrightarrow> Dag p low high\n                          (Node dag1 ref dag2) \\<longrightarrow>\n                         ref = p\n 2. \\<And>var low high mark p levellist m t marka nexta levellista ll' dag1\n       ref dag2 k pa.\n       \\<lbrakk>length ll' = length ([] # replicate (var p) []);\n        k < length ll'; pa \\<in> set (ll' ! k); wf_marking t mark marka m;\n        t \\<noteq> Tip; Dag p low high t;\n        \\<forall>i<Suc (var p). levellist ! i = Null;\n        length levellist = Suc (var p); ordered t var;\n        \\<forall>n\\<in>set_of t. mark n = (\\<not> m);\n        Levellist levellista nexta ll'; t = Node dag1 ref dag2;\n        \\<forall>q.\n           q \\<in> set_of t \\<longrightarrow> q \\<in> set (ll' ! var q);\n        \\<forall>i\\<le>var ref.\n           \\<exists>prx.\n              ll' ! i = prx @ ([] # replicate (var p) []) ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  pt \\<in> set_of t \\<and> var pt = i);\n        var ref < k \\<longrightarrow>\n        ll' ! k = ([] # replicate (var p) []) ! k;\n        k \\<le> var ref\\<rbrakk>\n       \\<Longrightarrow> pa \\<in> set_of t \\<and> var pa = k", "apply  (simp (no_asm))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>var low high mark p levellist m t marka nexta levellista ll' dag1\n       ref dag2 k pa.\n       \\<lbrakk>length ll' = length ([] # replicate (var p) []);\n        k < length ll'; pa \\<in> set (ll' ! k); wf_marking t mark marka m;\n        t \\<noteq> Tip; Dag p low high t;\n        \\<forall>i<Suc (var p). levellist ! i = Null;\n        length levellist = Suc (var p); ordered t var;\n        \\<forall>n\\<in>set_of t. mark n = (\\<not> m);\n        Levellist levellista nexta ll'; t = Node dag1 ref dag2;\n        \\<forall>q.\n           q \\<in> set_of t \\<longrightarrow> q \\<in> set (ll' ! var q);\n        \\<forall>i\\<le>var ref.\n           \\<exists>prx.\n              ll' ! i = prx @ ([] # replicate (var p) []) ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  pt \\<in> set_of t \\<and> var pt = i);\n        var ref < k \\<longrightarrow>\n        ll' ! k = ([] # replicate (var p) []) ! k;\n        k \\<le> var ref\\<rbrakk>\n       \\<Longrightarrow> pa \\<in> set_of t \\<and> var pa = k", "apply (rotate_tac 14)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>var low high mark p levellist m t marka nexta levellista ll' dag1\n       ref dag2 k pa.\n       \\<lbrakk>var ref < k \\<longrightarrow>\n                ll' ! k = ([] # replicate (var p) []) ! k;\n        k \\<le> var ref; length ll' = length ([] # replicate (var p) []);\n        k < length ll'; pa \\<in> set (ll' ! k); wf_marking t mark marka m;\n        t \\<noteq> Tip; Dag p low high t;\n        \\<forall>i<Suc (var p). levellist ! i = Null;\n        length levellist = Suc (var p); ordered t var;\n        \\<forall>n\\<in>set_of t. mark n = (\\<not> m);\n        Levellist levellista nexta ll'; t = Node dag1 ref dag2;\n        \\<forall>q.\n           q \\<in> set_of t \\<longrightarrow> q \\<in> set (ll' ! var q);\n        \\<forall>i\\<le>var ref.\n           \\<exists>prx.\n              ll' ! i = prx @ ([] # replicate (var p) []) ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  pt \\<in> set_of t \\<and> var pt = i)\\<rbrakk>\n       \\<Longrightarrow> pa \\<in> set_of t \\<and> var pa = k", "apply (erule_tac x=k in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>var low high mark p levellist m t marka nexta levellista ll' dag1\n       ref dag2 k pa.\n       \\<lbrakk>var ref < k \\<longrightarrow>\n                ll' ! k = ([] # replicate (var p) []) ! k;\n        k \\<le> var ref; length ll' = length ([] # replicate (var p) []);\n        k < length ll'; pa \\<in> set (ll' ! k); wf_marking t mark marka m;\n        t \\<noteq> Tip; Dag p low high t; length levellist = Suc (var p);\n        ordered t var; \\<forall>n\\<in>set_of t. mark n = (\\<not> m);\n        Levellist levellista nexta ll'; t = Node dag1 ref dag2;\n        \\<forall>q.\n           q \\<in> set_of t \\<longrightarrow> q \\<in> set (ll' ! var q);\n        \\<forall>i\\<le>var ref.\n           \\<exists>prx.\n              ll' ! i = prx @ ([] # replicate (var p) []) ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  pt \\<in> set_of t \\<and> var pt = i);\n        k < Suc (var p) \\<longrightarrow> levellist ! k = Null\\<rbrakk>\n       \\<Longrightarrow> pa \\<in> set_of t \\<and> var pa = k", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>var low high mark p levellist m t marka nexta levellista ll' dag1\n       ref dag2 k pa.\n       \\<lbrakk>var ref < k \\<longrightarrow>\n                ll' ! k = ([] # replicate (var p) []) ! k;\n        k \\<le> var ref; length ll' = length ([] # replicate (var p) []);\n        k < length ll'; pa \\<in> set (ll' ! k);\n        wf_marking (Node dag1 ref dag2) mark marka m;\n        Node dag1 ref dag2 \\<noteq> Tip;\n        Dag p low high (Node dag1 ref dag2); length levellist = Suc (var p);\n        ordered (Node dag1 ref dag2) var;\n        \\<forall>n\\<in>set_of (Node dag1 ref dag2). mark n = (\\<not> m);\n        Levellist levellista nexta ll';\n        \\<forall>q.\n           q \\<in> set_of (Node dag1 ref dag2) \\<longrightarrow>\n           q \\<in> set (ll' ! var q);\n        \\<forall>i\\<le>var ref.\n           \\<exists>prx.\n              ll' ! i = prx @ ([] # replicate (var p) []) ! i \\<and>\n              (\\<forall>pt\\<in>set prx.\n                  pt \\<in> set_of (Node dag1 ref dag2) \\<and> var pt = i);\n        k < Suc (var p) \\<longrightarrow> levellist ! k = Null\\<rbrakk>\n       \\<Longrightarrow> pa \\<in> set_of (Node dag1 ref dag2) \\<and>\n                         var pa = k", "apply (erule_tac x=k in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>var low high mark p levellist m t marka nexta levellista ll' dag1\n       ref dag2 k pa.\n       \\<lbrakk>var ref < k \\<longrightarrow>\n                ll' ! k = ([] # replicate (var p) []) ! k;\n        k \\<le> var ref; length ll' = length ([] # replicate (var p) []);\n        k < length ll'; pa \\<in> set (ll' ! k);\n        wf_marking (Node dag1 ref dag2) mark marka m;\n        Node dag1 ref dag2 \\<noteq> Tip;\n        Dag p low high (Node dag1 ref dag2); length levellist = Suc (var p);\n        ordered (Node dag1 ref dag2) var;\n        \\<forall>n\\<in>set_of (Node dag1 ref dag2). mark n = (\\<not> m);\n        Levellist levellista nexta ll';\n        \\<forall>q.\n           q \\<in> set_of (Node dag1 ref dag2) \\<longrightarrow>\n           q \\<in> set (ll' ! var q);\n        k < Suc (var p) \\<longrightarrow> levellist ! k = Null;\n        k \\<le> var ref \\<longrightarrow>\n        (\\<exists>prx.\n            ll' ! k = prx @ ([] # replicate (var p) []) ! k \\<and>\n            (\\<forall>pt\\<in>set prx.\n                pt \\<in> set_of (Node dag1 ref dag2) \\<and>\n                var pt = k))\\<rbrakk>\n       \\<Longrightarrow> pa \\<in> set_of (Node dag1 ref dag2) \\<and>\n                         var pa = k", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>var low high mark p levellist m t marka nexta levellista ll' dag1\n       ref dag2 k pa prx.\n       \\<lbrakk>var ref < k \\<longrightarrow>\n                ll' ! k = ([] # replicate (var p) []) ! k;\n        k \\<le> var ref; length ll' = length ([] # replicate (var p) []);\n        k < length ll'; pa \\<in> set (ll' ! k);\n        wf_marking (Node dag1 ref dag2) mark marka m;\n        Node dag1 ref dag2 \\<noteq> Tip;\n        Dag p low high (Node dag1 ref dag2); length levellist = Suc (var p);\n        ordered (Node dag1 ref dag2) var;\n        \\<forall>n\\<in>set_of (Node dag1 ref dag2). mark n = (\\<not> m);\n        Levellist levellista nexta ll';\n        \\<forall>q.\n           q \\<in> set_of (Node dag1 ref dag2) \\<longrightarrow>\n           q \\<in> set (ll' ! var q);\n        k < Suc (var p) \\<longrightarrow> levellist ! k = Null;\n        ll' ! k = prx @ ([] # replicate (var p) []) ! k;\n        \\<forall>pt\\<in>set prx.\n           pt \\<in> set_of (Node dag1 ref dag2) \\<and> var pt = k\\<rbrakk>\n       \\<Longrightarrow> pa \\<in> set_of (Node dag1 ref dag2) \\<and>\n                         var pa = k", "apply (case_tac k)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>var low high mark p levellist m t marka nexta levellista ll' dag1\n       ref dag2 k pa prx.\n       \\<lbrakk>var ref < k \\<longrightarrow>\n                ll' ! k = ([] # replicate (var p) []) ! k;\n        k \\<le> var ref; length ll' = length ([] # replicate (var p) []);\n        k < length ll'; pa \\<in> set (ll' ! k);\n        wf_marking (Node dag1 ref dag2) mark marka m;\n        Node dag1 ref dag2 \\<noteq> Tip;\n        Dag p low high (Node dag1 ref dag2); length levellist = Suc (var p);\n        ordered (Node dag1 ref dag2) var;\n        \\<forall>n\\<in>set_of (Node dag1 ref dag2). mark n = (\\<not> m);\n        Levellist levellista nexta ll';\n        \\<forall>q.\n           q \\<in> set_of (Node dag1 ref dag2) \\<longrightarrow>\n           q \\<in> set (ll' ! var q);\n        k < Suc (var p) \\<longrightarrow> levellist ! k = Null;\n        ll' ! k = prx @ ([] # replicate (var p) []) ! k;\n        \\<forall>pt\\<in>set prx.\n           pt \\<in> set_of (Node dag1 ref dag2) \\<and> var pt = k;\n        k = 0\\<rbrakk>\n       \\<Longrightarrow> pa \\<in> set_of (Node dag1 ref dag2) \\<and>\n                         var pa = k\n 2. \\<And>var low high mark p levellist m t marka nexta levellista ll' dag1\n       ref dag2 k pa prx nat.\n       \\<lbrakk>var ref < k \\<longrightarrow>\n                ll' ! k = ([] # replicate (var p) []) ! k;\n        k \\<le> var ref; length ll' = length ([] # replicate (var p) []);\n        k < length ll'; pa \\<in> set (ll' ! k);\n        wf_marking (Node dag1 ref dag2) mark marka m;\n        Node dag1 ref dag2 \\<noteq> Tip;\n        Dag p low high (Node dag1 ref dag2); length levellist = Suc (var p);\n        ordered (Node dag1 ref dag2) var;\n        \\<forall>n\\<in>set_of (Node dag1 ref dag2). mark n = (\\<not> m);\n        Levellist levellista nexta ll';\n        \\<forall>q.\n           q \\<in> set_of (Node dag1 ref dag2) \\<longrightarrow>\n           q \\<in> set (ll' ! var q);\n        k < Suc (var p) \\<longrightarrow> levellist ! k = Null;\n        ll' ! k = prx @ ([] # replicate (var p) []) ! k;\n        \\<forall>pt\\<in>set prx.\n           pt \\<in> set_of (Node dag1 ref dag2) \\<and> var pt = k;\n        k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> pa \\<in> set_of (Node dag1 ref dag2) \\<and>\n                         var pa = k", "apply  simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>var low high mark p levellist m t marka nexta levellista ll' dag1\n       ref dag2 k pa prx nat.\n       \\<lbrakk>var ref < k \\<longrightarrow>\n                ll' ! k = ([] # replicate (var p) []) ! k;\n        k \\<le> var ref; length ll' = length ([] # replicate (var p) []);\n        k < length ll'; pa \\<in> set (ll' ! k);\n        wf_marking (Node dag1 ref dag2) mark marka m;\n        Node dag1 ref dag2 \\<noteq> Tip;\n        Dag p low high (Node dag1 ref dag2); length levellist = Suc (var p);\n        ordered (Node dag1 ref dag2) var;\n        \\<forall>n\\<in>set_of (Node dag1 ref dag2). mark n = (\\<not> m);\n        Levellist levellista nexta ll';\n        \\<forall>q.\n           q \\<in> set_of (Node dag1 ref dag2) \\<longrightarrow>\n           q \\<in> set (ll' ! var q);\n        k < Suc (var p) \\<longrightarrow> levellist ! k = Null;\n        ll' ! k = prx @ ([] # replicate (var p) []) ! k;\n        \\<forall>pt\\<in>set prx.\n           pt \\<in> set_of (Node dag1 ref dag2) \\<and> var pt = k;\n        k = Suc nat\\<rbrakk>\n       \\<Longrightarrow> pa \\<in> set_of (Node dag1 ref dag2) \\<and>\n                         var pa = k", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}